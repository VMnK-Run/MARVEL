{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n", "idx": 24100, "substitutes": {"state": ["command", "request", "that", "estate", "store", "lock", "instance", "status", "style", "role", "value", "now", "type", "form", "i", "stat", "runner", "offset", "next", "history", "monitor", "policy", "states", "process", "State", "version", "call", "check", "task", "st", "progress", "stats", "start", "init", "data", "power", "local", "print", "parent", "initial", "shape", "tag", "event", "see", "r", "spec", "art", "comment", "component", "port", "space", "operator", "out", "view", "error", "row", "index", "test", "root", "cache", "post", "config", "job", "info", "setup", "area", "t", "update", "STATE", "org", "list", "up", "trace", "rule", "size", "scope", "resource", "it", "self"], "io": ["ir", "ex", "oop", "conn", "co", "util", "mode", "rit", "rio", "net", "it", "timeout", "ai", "ami", "info", "ilo", "ror", "ico", "ip", "image", "area", "ri", "o", "connection", "out", "org", "os", "ro", "storage", "lo", "ior", "row", "IO", "ia", "i", "icon", "ie"], "fw_cfg": ["fw_virt", "wiredbcfg", "wiredbvirt", "fw_log", "wire_cfg", "fwdbconfig", "hw_fg", "fwJfg", "fw_config", "wire_config", "fwJconf", "fwdbvirt", "fw_conf", "fw_fg", "wiredburg", "hw_log", "wiredbconfig", "fwdburg", "fwJcfg", "fwJlog", "hw_conf", "hw_cfg", "wire_virt", "fwdbcfg", "fw_urg", "wire_urg"], "owner": ["er", "office", "holder", " owners", " owns", "user", "owners", "server", "loader", "self", "member", "OWN", "Owner", "link", "parent", " Owner", "instance", "reader", "manager", "older", "writer", "handler", "origin", "component", "framework", "org", "shared", "own", " ownership", "owned", "object", "scope", "inner", "root", "ctx"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 24103, "substitutes": {"bs": ["BS", "aus", "bits", "bas", "iss", "bis", "js", "gs", "bp", "ses", "ubis", "obs", "fs", "blog", "ns", "ubs", "ss", "b", "ts", "oss", "bos", "bytes", "bc", "cs", "bl", "blocks", "bes", "sb", "bps", "ims", "bh", "boxes", "fps", "banks", "ds", "outs", "bles", "ls", "jac", "os", "locks", "cks", "hz", "rs", "irms", "bm", "vs", "aos", "lbs", "sts", "its", "flows", "pb", "ps"], "res": ["rev", "ren", "vals", "rem", "rez", "rec", "result", "js", "ms", "ers", "red", "cons", "gr", " Res", "aux", "rr", "rt", "details", "Res", "resolution", "r", "reg", "reset", "report", "pers", "vec", "vers", "sol", "usr", "resh", "pres", "cond", "pas", "der", "ref", "req", "expr", "ress", "rel", "wcs", "mr", "os", "fresh", "response", "rs", "RES", "def", "rc", "resp", "stats", "ber", "re", "pr", "resource", "inv", "rest", "ro", "results", "ps", "rss", "css", "rect"], "fix": [" conflict", "cmp", " impl", " err", "CHECK", "bf", " def", " prefix", " only", " conf", " ops", " ptr", " dirty", " diff", " clear", " mask", "Fix", " wait", " quiet", " fuse", "check", " msg", " enforce", " pack", " orig", " validate", " report"], "rebuild": ["reBuild", "resuild", "ReBuild", "resbuild", " rebuilt", "Rebuild", "Reuild", "resBuild", "reuild", " reuild", "resbuilt", "rebuilt", " reBuild", "Rebuilt"], "refcount_table": ["refmatch_Table", "refcount32table", "refcountingtable", "reflist2total", "refCount_cache", "refcountsbatch", "refcountingTable", "refcount2error", "refcountptoption", "refcount_total", "refcountmtstorage", "refcountptterm", "refref_tab", "refclaim_tab", "refcount_storage", "refclaim32global", "refcount_function", "refcount_TABLE", "refcount2table", "refmatchixbatch", "refmatchixtable", "refref_tree", "refcount_tree", "refclaim_table", "refcountingtree", "refCount_table", "refcountpledata", "refrefPtask", "refclaim32table", "refclaim_global", "refcountPtab", "refcountmttab", "refcount32global", "reflist_table", "reflist_total", "refmatchixtask", "refcountingerror", "refref_task", "refcountingfunction", "refref_data", "refcountPtable", "refcount32entity", "refcount_error", "refcountstable", "refcount_global", "refcountsTable", "refcount_option", "refcountPtree", "refcountmttotal", "refmatch_table", "refcountPtrace", "refcount1trace", "refcount1table", "refmatch_task", "refcountmttable", "refcountmtterm", "refrefPtrace", "refrefPtab", "refcountPdata", "refcount1task", "refcount_entity", "refcount_term", "refcountingtab", "refref_trace", "refrefPtable", "refcountpleTable", "refcountingtotal", "refclaim32entity", "refmatch_batch", "refcount_batch", "refcount_data", "refcount_task", "refwrite_term", "refcountingtask", "refcountplebatch", "refwrite_storage", "refclaim32tab", "refcountpttable", "refcountmtoption", "refcount32tab", "refmatchixTable", "refcount_trace", "refcountingdata", "refcountingcache", "refcountpletable", "refrefpletask", "refref_table", "refcount_cache", "refcountmtentity", "reflist2error", "refrefpledata", "refclaim_entity", "refcountixbatch", "refcountpletask", "refcountmtglobal", "reflist_error", "refcount_Table", "refcountpletree", "refwrite_option", "refcountPtask", "refCount_Table", "refcount_list", "refcountixtask", "refcountstask", "refcount_tab", "refcount1tab", "refrefpletable", "refcountixTable", "refcountixtable", "refwrite_table", "reflist2table", "refcountptstorage", "refcountmterror", "refrefpletree", "refcount2total"], "nb_clusters": ["nb_clubes", "nbLEclusters", "nb_Clodes", "nb_collannels", "nb_collumers", "nb_critockets", "nb_lust", "nb_collopes", "nbolyclonents", "nb_clust", "nbolyfilayers", "nb_plients", "nb_CLusters", "nbolychainsores", "nb_caots", "nb_declumers", "nb_clores", "nb_clograms", "nb_histopes", "nb_chonents", "nb_contusters", "nb_shockets", "nb_archograms", "nb_splurs", "nb_plaves", "nb_chainsubes", "nb_gluster", "nb_configusters", "nb_lusters", "nb_Cliders", "nb_Clusters", "nbLEclaves", "nb_clannels", "nb_shust", "nb_histusters", "nb_plroups", "nb_histumers", "nb_caograms", "nb_Clients", "nb_flusters", "nb_declannels", "nb_curonents", "nb_CLiders", "nb_filonents", "nbolyclurs", "nb_flaves", "nbosecollannels", "nbolyfilonents", "nbolychainsusters", "nbolyfilusters", "nb_critids", "nb_collayers", "nbolychainsubes", "nb_filicans", "nboseclumers", "nbLEclroups", "nbosecollopes", "nb_bliders", "nb_critust", "nb_archonents", "nb_clayers", "nb_clonents", "nb_critusters", "nb_shusters", "nb_contust", "nb_caonents", "nbolyclores", "nb_clicans", "nb_flroups", "nb_glusters", "nb_clockets", "nb_blodes", "nb_chainsores", "nbolyfilicans", "nb_splubes", "nb_histannels", "nb_contids", "nb_clroups", "nbolychainsurs", "nb_curograms", "nb_filayers", "nb_splusters", "nb_curots", "nb_claves", "nb_causters", "nb_configients", "nbosecollusters", "nbLEconfigaves", "nb_clurs", "nb_flients", "nbolyclayers", "nb_curusters", "nb_declusters", "nb_clots", "nb_glust", "nb_clodes", "nboseclopes", "nb_cliders", "nb_chicans", "nb_clids", "nb_archusters", "nb_criturs", "nb_chainsusters", "nb_cluster", "nb_shids", "nb_collicans", "nbLEclients", "nb_Clust", "nbolyclusters", "nb_collusters", "nb_critubes", "nb_blusters", "nbolyclicans", "nb_collonents", "nb_lients", "nb_CLuster", "nb_clumers", "nb_contockets", "nboseclannels", "nbosecollumers", "nb_configroups", "nb_plusters", "nb_critores", "nb_chainsurs", "nbLEconfigroups", "nbLEconfigients", "nb_Cluster", "nb_glients", "nb_declopes", "nboseclusters", "nb_filusters", "nb_luster", "nb_clopes", "nb_clients", "nb_configaves", "nb_CLodes", "nbolyclubes", "nb_chayers", "nb_splores", "nbLEconfigusters", "nb_archots", "nb_chusters", "nb_bluster"], "s": ["sv", "v", "bits", "args", "hs", "is", "settings", "gs", "js", "ms", "ses", "changes", "bis", "eps", "S", "sp", "fs", "sam", "ns", "details", "ss", "b", "states", "ts", "qs", "parts", "ops", "spec", "cs", "ssl", "less", "ats", "sb", "ins", "ims", "p", "comm", "m", "times", "e", "aws", "sl", "ds", "sym", "ls", "g", "os", "es", "scl", "a", "rs", "h", "vs", "l", "as", "sys", "conf", "stats", "sts", "als", "its", "xs", "y", "stat", "sq", "ps", "w"], "i": ["qi", "init", "gu", " j", "is", "n", " I", "me", "iter", "ind", "li", "ij", "ix", "it", "xi", "ai", "ini", "ji", "gi", "ci", "ki", "di", "hi", "ii", "oi", "t", "mi", "ip", " bi", "ei", "cli", "ri", "sim", "m", "p", "multi", "ic", "e", "ui", "inter", " ii", "u", "pi", " di", "im", "iu", "l", "us", " ti", "ti", "zi", "j", "ia", "index", "phi", "x", "y", "ie", "si", "bi", " si", "I"], "sn": ["sv", "nr", "n", "nl", "sr", "sa", "dn", "txt", "sp", "sam", "sf", "ns", "ne", "tn", "sbm", "ss", "mn", "pn", "ts", "fn", "sol", "cs", "ssl", "sh", "SN", "sb", "cn", "sd", "wn", "sl", "ds", "sw", "ny", "news", "os", "rn", "bn", "syn", "snap", "gn", "ln", "nn", "sys", "ski", "span", "Sn", "sq", "si", "sm"], "ret": ["obj", "txt", "val", "net", "after", "reset", "report", "elt", "cmd", "dt", "len", "ref", "deg", "compl", "expr", "arg", "value", "att", "def", "nil", " RET", "alt", "term", "nt", "rem", "result", "grain", "over", "det", " Ret", "usr", "web", "der", "fun", "cat", "ft", "Ret", "rep", "pret", "virt", "last", "RET", "back", "re", "et", "prop", "lit", "rev", "vals", "sr", "final", "del", "git", "get", "print", "ll", "rt", "rets", "reply", "tr", "r", "cert", "ry", "out", "vet", "mt", "flag", "try", "resp", "cont", "eval", "plain", "test", "url", "ter", "red", "ext", "reg", "detail", "Return", "gt", "format", "rm", "mat", "it", "err", "rect"], "check_errors": ["check_err", "callCounterr", "checkCounterror", "checkCounterr", "callCounterror", "check_error", "checkCounterrors", "call_errors", "checkCountrors", "callCounterrors", "call_rors", "call_err", "callCountrors", "call_error", "check_rors"]}}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n", "idx": 24123, "substitutes": {"q": ["qi", "v", "k", "iq", "eq", "qu", "query", "r", "b", "dq", "qs", "t", "quit", "p", "e", "g", "queue", "d", "u", "requ", "qt", "h", "pe", "qq", "ue", "Q", "c", "sq", "que", "ch", "w"], "addr": ["Address", "obj", "to", "work", "adr", "host", "arp", "rt", "ar", "tx", "tr", "ace", "ack", "r", "kt", "gate", "address", "ag", "at", "act", "t", "aro", "pat", "ref", "add", "hash", "pad", "dh", "inter", "aser", " address", "mt", "ad", "rs", "eth", "dr", "x", "ptr", "ctx"], "qtd": ["wtd", "thinkdet", "thinktar", "qdem", "thinksd", "eqtd", "qdt", "querysd", "Qxd", "thinkdash", "qdat", " qrd", "sqdt", "qdash", "wTD", "qcd", "thinkfd", "iqdet", "Qmont", "qqbd", "Qdp", "sqds", "qsd", "qpb", "Qmd", "quds", "querytd", " qmd", "qqdem", "tdt", "qqdp", " qdash", "qudn", "dqxd", "qupb", "qdm", "qTD", "Qdl", "eqpb", "qmd", "eqdet", "qfd", "eqmont", "qubd", "dqbd", "qqmont", "qqdm", "qudm", "querydp", "eqdat", "sqmont", "querydet", "sqpb", " qtw", "Qrd", "qudem", "qqfd", "qdp", "querydm", "qdn", "sqsd", "Qtar", "Qtd", "Qfd", "wdl", "quTD", "qutd", "qtw", "qxd", "Qbd", "qds", "qdet", "querydash", "qbd", "qqtd", "qudp", "sqdn", "qqmd", " qdp", "thinkmont", "sqcd", "tsd", "qumont", "sqdp", "qurd", " qdet", "Qdem", "iqdat", "queryfd", "Qsd", "qqtw", " qdt", "qutar", "eqds", "iqsd", "qmont", "Qdn", "thinktd", "dqsd", "tcd", "sqbd", "iqtd", "Qdat", "sqxd", "qdl", "qqdat", "qrd", " qdat", " qcd", "wbd", " qdn", "qudl", "qufd", "Qtw", "sqtd", "eqsd", "QTD", "dqtd", "qtar", " qsd", "ttd"]}}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n", "idx": 24141, "substitutes": {"d": ["data", "dm", "did", "n", "dn", "dp", "dd", "db", "dos", "f", "r", "dq", "di", "dt", "e", "dx", "dc", "du", "send", "o", "D", "m", "fd", "p", "dat", "sd", "ds", "da", "dh", "pd", "debug", "out", "bd", "g", "ed", "ad", "dr", "des", "l", "de", "ld", "done", "i", "c", "dis", "dl", "w"], "s": ["sv", "data", "v", "hs", "is", "n", "gs", "js", "sa", "ses", "fs", "S", "sp", "sam", "ns", "f", "ss", "b", "r", "set", "ts", "state", "se", "t", "cs", "south", "sb", "sing", "m", "p", "sd", "e", "aws", "sl", "ds", "g", "ls", "sw", "os", "a", "rs", "su", "h", "st", "l", "sys", "conf", "stats", "sts", "y", "i", "sports", "c", "stat", "sq", "ps", "self", "sm", "w"]}}
{"project": "FFmpeg", "commit_id": "70f9661542a581dfe93b636b1c55b5558e4a4e3c", "target": 0, "func": "static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame, AVPacket *avpkt)\n\n{\n\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n\n    ThreadFrame frame = { .f = data };\n\n    AVFrame *picture = data;\n\n    int tileno, ret;\n\n\n\n    s->avctx     = avctx;\n\n    s->buf       = s->buf_start = avpkt->data;\n\n    s->buf_end   = s->buf_start + avpkt->size;\n\n    s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles\n\n\n\n    // reduction factor, i.e number of resolution levels to skip\n\n    s->reduction_factor = s->lowres;\n\n\n\n    ff_jpeg2000_init_tier1_luts();\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    // check if the image is in jp2 format\n\n    if ((AV_RB32(s->buf) == 12) &&\n\n        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&\n\n        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {\n\n        if (!jp2_find_codestream(s)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't find jpeg2k codestream atom\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {\n\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n\n        return -1;\n\n    }\n\n    if (ret = jpeg2000_read_main_headers(s))\n\n        goto end;\n\n\n\n    /* get picture buffer */\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"ff_thread_get_buffer() failed.\\n\");\n\n        goto end;\n\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n\n    picture->key_frame = 1;\n\n\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n\n            goto end;\n\n\n\n    *got_frame = 1;\n\n\n\nend:\n\n    jpeg2000_dec_cleanup(s);\n\n    return ret ? ret : s->buf - s->buf_start;\n\n}\n", "idx": 24148, "substitutes": {"avctx": ["avejac", "wavconn", "cvctx", "aukl", "averjac", "aveobj", "afcmp", " avcm", "verobj", "avecontext", "avconf", "avercp", "avecb", "wavcmd", " avctl", " avcf", "cvcm", "averkl", "apcontext", "vercmd", "avkl", " avtx", "ajcfg", "avetx", "avreq", "ajcb", "ajcontext", "abcontext", "abcmp", " avcontext", "avtx", "avctl", "avekl", "abctx", "wavctx", "avecf", "apconn", "avercontext", "vctl", "avcontext", "verctx", "ajreq", "afctx", "ajcp", "avcmd", "auctx", "avcb", "avecmd", "aveconf", "cvtx", "avobj", "verconn", " avjac", "avconn", "wavobj", "cvcontext", "avcp", "avcmp", "aveconn", "afcontext", "averconf", "avcm", "avercfg", "avcf", "vctx", "averctx", " avcfg", "avereq", "averreq", "avercb", "auconf", "vcontext", "avcfg", "avectl", "apcmp", "abconn", "avercf", "avjac", "vtx", "afconn", "ajctx", " avcp", "avecm", "apctx", "avectx"], "data": ["init", "DATA", "to", "first", "video", "res", "text", "rew", "offset", "next", "frame", "Data", "json", "file", "content", "f", "initial", "join", "intel", "message", "r", "info", "block", "bytes", "image", "t", "this", "new", "len", "padding", "bin", "ref", "align", "p", "dat", "buffer", "feed", "format", "name", "d", "a", "table", "window", "id", "size", "value", "def", "done", "start", "i", "buf", "extra", "empty", "ata", "length", "raw"], "got_frame": ["fetched_frames", "went____frame", "fetched___frames", "gotMemfram", "got42frame", "fetched_frame", "got_fram", "got_next", "got____next", "gotMemframes", "fetched___fram", "went____next", "got____space", "got_space", "got___frames", "got42next", "went_frame", "went_space", "got____frame", "got42space", "fetched___frame", "went____space", "gotMemframe", "fetched_fram", "got___frame", "went_next", "got___fram", "got_frames"], "avpkt": ["avpcdu", "aveppct", "svpkt", "avepacket", "avoppt", "svpck", "avopck", "avcct", "avPvt", "avopacket", "avspacket", "avckt", "avppkt", "avPdu", "avspct", "avpck", "avpadkt", "avpct", "avepvt", "aveppdu", "avpdu", "avspvt", "avepppt", "avpacket", "avespvt", "avppdu", "avopkt", "avcpt", "svpacket", "avcck", "avpadck", "avpppt", "aveppkt", "avspkt", "avepct", "avpvt", "avcvt", "avppt", "svcacket", "avPacket", "avespacket", "svppt", "avPpt", "aveppt", "avepkt", "avppct", "svcck", "avpadpt", "avespct", "avpcpt", "avcacket", "avPct", "avPkt", "avpcct", "avpckt", "avepdu", "svckt", "avespkt", "avpadacket", "svcpt"], "s": ["sv", "gs", "ses", "changes", "services", "scripts", "details", "b", "parts", "https", "styles", "p", "e", "aws", "ls", "so", "rs", "sc", "as", "conf", "webkit", "als", "session", "i", "sports", "c", "y", "ps", "set", "w", "n", "sa", "bis", "fs", "params", "ns", "ts", "se", "ssl", "less", "sb", "ins", "d", "os", "es", "a", "ies", "events", "vs", "stats", "sts", "ctx", "ports", "settings", "args", "hs", "is", "f", "ss", "r", "spec", "this", "cs", "ats", "space", "m", "comm", "simple", "ds", "ids", "l", "sys", "j", "sq", "v", "js", "eps", "S", "sp", "qs", "t", "ims", "g", "sl", "sw", "views", "ess", "h", "bs", "its", "xs", "aunts", "utils", "self"], "picture": ["gif", "video", "obj", "vp", "camera", "profile", "ive", "sharp", "peg", "frame", "feature", "file", "print", "details", "query", "policy", "Picture", "png", "performance", "photo", "bite", "info", "feat", "support", " Picture", "image", "man", "pict", "statement", "pty", "p", "friendly", "format", "pic", "figure", "iture", "style", "pause", "share", "pdf", "fp", "summary", "img", "point", "fi", "piece", "document", "pen", "j", "media", "ctx"], "tileno": ["bilen", "tileny", "tinento", " tilestyle", "hunigo", "utilno", "ilogo", "ilestyle", "filno", "yllen", "tilerno", "sitno", "siteno", "bileno", "huneny", "tinenum", "bilnette", "tiligo", "utileno", " tilenum", "utileny", "tilnette", "ilerno", "ileno", "ilno", "iligo", " tilento", "bilento", "ileny", "tilestyle", "bilerno", "tineno", "huneno", "yllento", "tinerno", "sitogo", "siterno", "bilenum", "filogo", "utiligo", " tilerno", "tilogo", "tilen", "tilenum", "hunno", "fileno", "hunen", "hunnette", "bilno", "bilogo", " tilno", "hunento", " tilogo", "ylleno", "tilno", "yllnette", "filestyle", "tilento"], "ret": ["rev", "nt", "rem", "il", "tif", "res", "nl", "result", "fin", "ter", "get", "jp", "val", "print", "ll", "rt", "net", "rets", "after", "mem", "tr", "det", "reset", "elt", " Ret", "true", "len", "fun", "ref", "deg", "ft", "gt", "status", "Ret", "format", "rel", "not", "mt", "RET", "flag", "att", "def", "dr", "try", "cont", "resp", "progress", "mat", "ber", "re", "alt", "success", "it", "elf"]}}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162, "substitutes": {"vbasedev": ["vbediv", "vbidel", "vbidem", "vbedel", " vndep", "vbaseddev", " vbackedev", "vbidiv", "vvardef", "hbasedev", "vbaseef", "hbasedel", "vbasedep", "vfacedev", "vbedef", " vbasedep", "vbasedem", " vbackeddev", "vbackedriver", "vbaseep", "vfacedel", "hbaseef", "vfacedef", "vfireddev", " vbasedel", " vfacedev", " vbasedele", "vndem", " vfacedele", "vbasedel", " vfacedel", " vndef", "vbaseem", "vbasedele", "vbaseriver", " vbasedef", "vbaseel", "vbaseiv", "vbaseele", "vfiredev", "vbackeddev", "vfiredriver", "hbasedef", "vndev", "vfacedele", " vbasedriver", "vbackedev", "vndep", " vndem", "vbasedef", "vbedev", "vbidef", "hbasediv", " vndev", " vfacedef", "vvardev", "vbasediv", "hbaseev", "vndef", " vbaseddev", "vbaseev", "hbaseiv", "vvardele", "vbidep", " vbasedem", "vvardel", "hbaseel", " vbackedriver", "vbidev", "vbasedriver"], "intp": ["uintpc", "intpid", "antpress", "interps", "instP", "interpc", "uintping", "intpc", " intf", "pretp", "intpp", "entps", "backpa", "printn", "interping", "antpp", "restpc", " intn", "latp", "icpp", "restp", "interp", "strpatch", "incpkg", "interpa", "antp", "gtpa", "instp", "printP", "intpt", "interfaceping", "intf", "latpt", "uintpt", " intping", " intv", "gtping", "intv", "intP", "printpa", "indpc", "instps", "incpid", "pretpatch", "alp", "interfacepkg", "intsp", "icpa", "gtP", "uintcp", "backf", "incsp", "latsp", "uintp", "latpa", "indping", "latpatch", " intpa", "instpa", "gtp", "antpa", "incphp", "intern", "alpp", "uintpa", "inping", "incping", "indp", "pretpc", "icpress", "pretpa", "inpid", "antphp", "uintpatch", "indpt", "interfacep", "resth", "backping", "incpa", "antv", "alpa", " intsp", "entP", "intpress", " intphp", "latpc", "printp", "entp", " intP", "instf", "intpatch", "intping", "alpress", "uinth", "intps", "icp", "intcp", "interP", "inth", "incpatch", "intpa", "entpa", "inpkg", "restcp", "interfacepid", "backp", "latping", "intercp", "instping", "intn", "interh", "intphp", "strp", "inp", " intpatch", "incv", "strpc", "incp", "intpkg", "strpa"], "vdev": ["cvdb", "avserial", "voltbuild", " vdevice", "voltdiv", "gstable", "virtualdevelop", "verpay", "wireserial", " vstable", "vDEV", "hdevice", " venv", "VDEV", "verdevices", "henv", "gdevice", "verdev", "voltDEV", "wdevice", "vpay", "avbuild", "wirepay", "vcdevice", "wdb", "vdiv", "voltw", "venv", "Vstable", "avstable", "avdev", "Vdev", "hdev", "vconn", "tvdev", " vdevelop", "avDEV", "gdev", "wiredev", "vw", "vdb", "voltstable", "tvconn", "virtualdevice", "mcam", "vdevice", "voltdevice", "verconn", " vdiv", "mw", "vcw", "vdevices", "vserial", " vconn", "wiredevices", "mdev", "vcam", "voltdev", "vcdev", "cvdevice", "vccam", "voltcam", "verserial", "cvdiv", "gdevelop", "tvdevelop", " vdb", "vstable", "wdev", "avdevices", "voltenv", "virtualstable", "vbuild", "mdevice", "wdiv", "vdevelop", "virtualdev", "verdevelop", "cvdev", "Vbuild", "hdiv", "avpay"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164, "substitutes": {"s": ["v", "n", "is", "hs", "gs", "js", "sa", "ses", "ctx", "S", "fs", "sp", "ns", "ss", "r", "b", "ts", "sm", "t", "cs", "space", "sb", "p", "e", "g", "ds", "q", "os", "a", "sg", "rs", "sc", "h", "st", "as", "sys", "stats", "sts", "bs", "c", "y", "self", "set", "w"], "rlow": ["rtlocal", "ormin", "rmin", "rlocal", "vbegin", "rlower", "rloc", "vlow", "orlower", "orbegin", "rdmin", "pmin", "rtloc", "plow", "rdlocal", "vlower", "mrloc", "pbegin", "orlow", "mrlow", "plower", "vmin", "mrmin", "rdlow", "rdloc", "rtlow", "mrlocal", "rbegin", "rtmin"], "rhigh": ["vmax", "RHigh", " rHigh", "bhighest", "vhigh", " rright", " rmax", "Rright", "rmax", " rhighest", "rright", "Rhigh", "bhigh", "bright", "bHigh", "vhighest", "vHigh", "Rhighest", "rhighest", "rHigh", "Rmax"], "val": ["data", "vals", "v", "pol", "serv", "valid", "ret", "mem", "tx", "loc", "var", "VAL", "vec", "reg", "Val", "func", "ival", "grad", "t", "alpha", "al", "vt", "key", "bin", "ref", "p", "sel", "expr", "pt", "out", " v", "cal", "vol", "value", "def", "xy", "num", "alt", "buf", "index", "x", "pr", "eval", "temp", "it", "test", "err", "bal", "ctx"], "tmp": ["nt", "v", "obj", "cv", "cmp", "util", "emp", "txt", "sp", "uv", "tt", "sam", "rt", "mint", "jp", "ret", "timeout", "tn", "td", "buff", "tg", "b", "mk", "mb", "cb", "var", "cmd", "attr", "pkg", "tv", "gb", "new", "gm", "t", "vt", "mp", "uf", "lib", "tm", "m", "p", "gt", "pt", "tab", "tz", "pot", "py", "cp", "split", "bo", "part", "snap", "perm", "img", "grow", "etc", "resp", "np", "xy", "tar", "buf", "j", "proc", "ptr", "msg", "orig", "temp", "ctx"]}}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179, "substitutes": {"obj": ["obs", "txt", "typ", "src", "aux", "buff", "cb", "elt", "oss", "cmd", "pkg", "iv", "ref", "expr", "off", "here", "Obj", "yt", "vol", "att", "def", "np", "obo", "oj", "tk", "alt", "inv", "y", "ind", " Obj", "nt", "db", "ist", "inst", "ob", "op", "rb", "act", "arr", "oid", "str", "ct", "os", "bj", "addr", "object", "onet", "po", "wo", "gr", "ot", "ij", "opt", "ent", "rt", "attr", "adj", "art", "rel", "ck", "con", "img", "cur", "resp", "cont", "xy", "tmp", "j", "msg", "ie", "js", "co", "ext", "stick", "kl", "aq", "og", "go", "utt", "t", "req", "o", "bh", "pt", "sw", "org", "rm", "bo", "br", "eff", "ht", "it", "self", "rect"], "qint": ["qind", "iqind", "questionint", "requinit", "qpoint", " qnet", "qindex", "eqind", "qinit", "eqint", "sqint", "dqind", "qclient", "qtind", "qqpoint", "quind", "dqpt", "qualconst", "dqvert", "qinteger", "questionINT", "iqinit", "qualind", "eqnet", "questinteger", "qqint", "qqnet", "qqconst", "qrec", "qualrec", "qINT", "questind", " qclient", "iqrec", "eqpt", "iqint", "eqindex", "eqinit", "questin", "qualint", "eqvert", "requpt", "sqinit", "quinteger", "qqind", "qconst", "dqINT", "qin", "qualpoint", "questioninit", "qualinteger", "questint", "iqent", "iqnet", "qtconst", "qualINT", "questionent", "quin", "iqINT", "sqINT", "iqindex", "dqint", " qindex", "qtint", "requint", "eqclient", "dqrec", "requnet", "qent", "qqpt", "iqclient", "qualvert", "quint", "qvert", "qualpt", "qpt", "sqent", "qqinit", "qtpoint", "qnet", "qualin"], "qfloat": ["iqflo", "aqflat", "qvar", "iqfloat", "aqint", "dqFloat", "qport", " qfat", "sqvar", "queryfloat", "queryfat", "sqfloat", "qFloat", " qprint", "gvar", "qflo", "iqbool", "gport", "qfat", "aqFloat", " qvert", "queryint", "gflat", "quickflo", "sqport", "iqprint", "qprint", " qport", "dqfloat", "aqdouble", "queryflat", "qvert", "quickbool", "gFloat", "sqvert", " qflat", "qflat", "quickfloat", "quickprint", "dqflat", "aqfloat", "qbool", "gdouble", "gfloat", " qbool", "qdouble", " qvar", " qflo", "gvert", "dqdouble", "aqfat"]}}
{"project": "qemu", "commit_id": "95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb", "target": 0, "func": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n", "idx": 24200, "substitutes": {"ohci": ["hci", " ohCI", "hcci", "ihpi", "ehdi", "ahco", "Ohcont", "ohdi", "Ohcci", " ohcu", "ehci", "ihci", "ihc", " ohcci", "hdi", "ahci", "ahdi", "Ohdi", "ihdi", "ihca", "ohc", "Ohcu", "ahcci", "Ohpi", "hCI", "ohca", "ohcu", "ohcci", " ohpi", "ihcci", "ahcont", "ohCI", "Ohci", "ehc", "ohpi", "ahcu", "Ohco", "ehpi", " ohca", "hpi", "OhCI", " ohdi", "ohcont", " ohcont", "ahc", "ahpi", "ehcci", "ahca", "ohco", " ohco"], "head": ["tail", "max", "weight", "th", "link", "wind", "lock", "bit", "run", "hold", "origin", "len", "hash", "header", "off", "HEAD", "depth", "window", "id", "position", "capacity", "map", "form", "n", "foot", "ahead", "iter", "offset", "next", "host", "load", "body", "before", "pad", "device", "mean", "Head", "cycle", "cap", "back", "start", "ptr", "length", "limit", "top", "count", "parent", "shape", "tag", "query", "heading", "gate", "sum", "ock", "ck", "front", "flag", "row", "flags", "pos", "index", "md", "post", "loop", "frame", "mask", "end", "headed", "then", "headers", "block", "shift", "min", "heads", "size", "h", "point", "port"], "completion": ["completed", "omplete", "Completing", "ompleted", "Completed", "completing", " Completed", "complete", "Completion", " Complete", " Completing", "ompletion", "Complete", "ompleting", " Completion"], "ed": ["arted", "ex", " d", " es", "ented", " added", "or", "used", "ED", "ored", "sed", "ized", "osed", "el", "p", "e", " got", " found", "ied", " ev", "owed", "ated", "ted", "er", "ped", "acked", "db", "ined", "embed", "ar", " sent", "ued", "se", " od", "sent", "eded", "sh", "reed", "eed", "d", "es", "ned", "hed", " e", "et", "ered", "and", "bed", " parsed", "ged", "ended", "Ed", "aled", "ent", "edited", "z", "med", "ded", "em", "oned", "started", "elected", "ared", "led", "ached", "ad", "edd", "ld", "l", "added", " ke", "created", "eds", "red", " stored", "loaded", "eb", "ired", "en", "ev", "fed", "h", "ved", "de", "done", "aed", "ez", "oted", "ing", "est"], "next_ed": ["nextOffe", "nextOffed", " next_eb", "nextTheer", "nextOffeds", "Next_ted", "Next_ed", "nextSeted", "nextSeed", "nextOffred", "next_eb", " next_red", "next_e", "Next_er", "next_ED", " next_eds", "nextTheed", "next_eds", "nextSeED", "nextTheeds", " next_e", "next_er", "nextTheeb", " next_er", "nextSeer", "Next_ED", "next_ted", "next_red"], "cur": ["track", "ur", "conn", "or", "cb", "loc", "ce", " car", "cmd", "pg", "occ", "off", "sur", "sc", "now", "c", "nc", "adr", "gc", "iter", "oc", "next", "cor", "dc", "Cur", "cat", " now", " cursor", "ct", "cp", "currently", "close", "open", "cycle", "start", "col", "buf", "desc", "handle", "ptr", "ctrl", "ver", "ctx", "rev", "pri", "ph", "cv", "count", "ser", " Cur", "tr", "current", "ry", "bur", "ach", "con", "rc", "try", "dr", "ctr", "cont", "sys", "row", "tmp", "unc", "nr", "cmp", " curs", "seq", "cr", "bc", "car", "ok", "q", "tc", "err", "ch"], "active": ["rev", "_", "enabled", "pc", "track", "count", "exec", "loop", "ended", "mode", "selected", "action", "seq", "activate", "connected", "current", "func", "act", "alert", "sequence", "total", "ac", "status", "name", "g", "iguous", " inactive", "running", "def", "ctr", "progress", "stable", "activity", "cycle", "confirmed", "Active", "cap", "charged", "activated", "index", "c", "le", "ptr", "cont", "all"], "addr": ["Address", "rev", "url", "to", "obj", "cmp", "res", "adr", "offset", "host", "ether", "src", "arp", "rt", "ret", "ar", "tag", "tr", "hl", "ack", "ace", "trans", "r", "loc", "elt", "cmd", "attr", "address", "ag", "at", "t", "ip", "coord", "arr", "ref", "add", "str", "dev", "name", "tz", "ress", "inter", "rel", "from", "id", "mt", "ad", "eth", "att", "dr", "rc", "ord", "alt", "ptr", "sta", "et", "err"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201, "substitutes": {"pbdev": ["typver", "pbdef", "typgu", "fbdevice", "cbdiv", "pkgdef", "fbdet", "cbdevice", "pbdet", "pkgDev", "pkgdevice", "bufdevice", "pyDEV", "pbDev", "PBver", "pkgve", "cbdet", "typdevice", "pserv", "pbdebug", "cbserv", "bufdebug", "PBdef", "PBDEV", "PBgu", "pydev", "bufserv", "bbgu", "pbver", "pbdiv", "fbdiv", "pkgDEV", "bufdev", "pdev", "pbserv", "pkgver", "fbdev", "phydiv", "pbDEV", "ebdev", "pbve", "PBve", "PBdev", "pdebug", "pkgdev", "cbdebug", "bbdevice", "ebver", "ebdevice", "pyve", "phydevice", "cbdev", "bbver", "pbdevice", "pdevice", "phydev", "PBDev", "typdev", "ebDev", "pydef", "PBdevice", "phydet", "pbgu", "bbdev"]}}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_connect(URLContext *uc, AVDictionary **options)\n\n{\n\n    int err =\n\n        uc->prot->url_open2 ? uc->prot->url_open2(uc,\n\n                                                  uc->filename,\n\n                                                  uc->flags,\n\n                                                  options) :\n\n        uc->prot->url_open(uc, uc->filename, uc->flags);\n\n    if (err)\n\n        return err;\n\n    uc->is_connected = 1;\n\n    /* We must be careful here as ffurl_seek() could be slow,\n\n     * for example for http */\n\n    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, \"file\"))\n\n        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)\n\n            uc->is_streamed = 1;\n\n    return 0;\n\n}\n", "idx": 24205, "substitutes": {"uc": ["aus", "urn", "pc", "ucc", "ur", "usb", "uk", "gc", "util", "exec", "oc", "upt", "wp", "ub", "cam", "anc", "ow", "umi", "emp", "uv", "ut", " unc", "ocr", "ou", "lc", "mc", "ux", "fc", "ud", "kt", "um", "eu", "bc", "utf", "cu", "ctl", "auc", "uf", "cus", "uh", "ec", "aut", "lam", "ac", "clus", "hw", "tm", "cc", "sup", "u", "ck", "lu", "ul", "orc", "up", "pac", "uch", "uph", "sc", "cur", "soc", "etc", "uu", "uci", "userc", "tc", "eg", "usc", "roc", "proc", "unc", "kw", "nc", "ui", "UC"], "options": ["tags", "data", "args", "settings", "currency", "members", "json", "opt", "fs", "params", "details", "ptions", "context", "config", "ption", "policy", "ts", "parts", "ops", "headers", "styles", "metadata", "Options", "other", "times", "ims", "features", "properties", "values", "es", "option", "pdf", "stats", "flags", "foreign", "atts", "words", "types", "its", "uploads", "ps", "results"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206, "substitutes": {"sd": ["sv", "dm", "dd", "sam", "details", "dt", "add", "bd", "nd", "sea", "sc", "series", "def", "s", " cd", "sand", "form", "disc", "sy", "SD", "ind", "sa", "db", "dk", "gd", "wd", "td", "vd", "di", "se", "std", "ssl", "south", "cod", "sh", "send", "lib", "sb", "dev", "pd", "eas", "d", "sch", "desc", "ell", "dis", "df", "and", "ss", "mod", "reci", "sim", "fd", "ds", "ad", "good", "score", "ld", "sys", "sql", "pm", "ord", "sta", "amd", "si", "ma", "md", "cd", "ay", "ud", "cell", "sec", "draw", "sl", "dist", "sw", "sg", "od", "hd", "storage", "ard", "dl", "sky"], "ret": ["rev", "nt", "rem", "url", "il", "res", "result", "ert", "nz", "ter", "fin", "get", "jp", "aux", "print", "ll", "rt", "tf", "rets", "tr", "det", "reset", "elt", " Ret", "t", "arr", "uf", "ft", "gt", "format", "Ret", "out", "rel", "rep", "rm", "pret", "arg", "mt", "fit", "RET", "lt", "att", "def", "des", "try", "resp", "back", "alt", "re", "rest", "utils", "prop", "lit"], "io_len": ["io_dir", "io33gen", " io_body", "io2len", " ioxlan", " io2lif", "io__lif", " io2l", "ioxlen", " io_els", "io67elt", "io33len", "io2data", "ci_len", "io_label", " ioxlen", " io_gen", "io67lan", " ioxfin", "io_cap", "ci68Len", " io2len", "io_l", "io67lit", "io8cap", "io2lif", " io7els", " io_data", "io55ln", "iolenseq", " io2lan", "ao_lan", "ao_cap", " io_den", "ao_loc", "io_seq", "ci_lit", "io_vol", "ci68len", "io_loc", "io67len", "ao_dir", "io_lit", " io7ln", "io67body", "io__lan", "io_fin", "ao_len", "io_data", " io_ln", "io8den", " io_Len", "io7gen", " io_lit", " io2seq", "io_den", "io_elt", " io_l", "io_lan", "io68Len", "io_Len", " io_lan", "io33els", " io_elt", "io__len", "io_ln", "io2seq", "iolenlen", "io_lif", "iolenl", "io2l", " ioxbody", " io_lif", "io67fin", "io2ln", " io2ln", "io68lit", " io7len", "io_lim", "iolendata", "ci68lit", "ioxlan", "ci_Len", "ao_ln", "io8lan", "io55len", "io__ln", " io_seq", " io2data", "io8Len", "io_body", "ci68vol", "io8len", "io8loc", "io68len", " io7gen", "io33ln", "io_els", " io_lim", "ioxbody", "io7len", "io2lan", "ioxfin", "io68vol", "io55lif", "io_gen", "io55lan", "io7els", "ao_label", "io7ln", " io_fin", "io67lim", "ci_vol"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212, "substitutes": {"data": ["DATA", "output", "v", "to", "zero", "rew", "Data", "dal", "aw", "json", "mode", "mem", "context", "mu", "reader", "step", "reg", "dump", "info", "di", "missing", "spec", "t", "this", "o", "dat", "dev", "out", "da", "device", "debug", "d", "ds", "a", "table", "window", "id", "bus", "ad", "value", "att", "def", "map", "session", "desc", "batch", "ata", "test", "ctx"], "unused": ["nonUse", " unuse", " unUse", "nonexpected", "unUse", "unexpected", "sunused", "unuse", " unexpected", "sunuse", "nonuse", "nonused", "sunUse", "sunexpected"], "obj": ["nt", "v", "ex", "n", "res", "bis", "js", "oc", "obs", "ot", "opt", "ij", "val", "txt", "ent", "stick", "inst", "ob", "og", "op", "instance", "buff", "elt", "attr", "vo", "adj", "iv", "act", "t", "arr", "cod", "ref", "o", "pt", "out", "org", "bo", "bj", "Obj", "cur", "con", "resp", "cont", "np", "tmp", "obo", "oj", "tk", "eff", "oa", "object", "j", "pr", "x", "ht", "it", "ind", "po", "ctx"]}}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213, "substitutes": {"mon": ["ann", "dm", "ston", "hog", "mons", "vis", " mu", "chron", "conn", "on", "util", "master", "Mon", "MON", "monitor", "mint", "mer", "mu", "mn", "den", " mem", "chan", "fn", "mx", "mi", "coord", "man", "mit", "cat", "mm", "m", "wat", "mut", "mate", "min", "san", "mt", "mun", "mont", "con", "rup", "num", "mat", " monitor", "monkey", "met", "onet"], "src_str": ["src64buf", "src2Str", " src_Str", "src___str", "src_buf", "rc_int", "src_src", "tmp_str", "tmp_string", "src_int", "tmp___list", "tmp_buf", "src___buf", "rc_str", "src64string", "src_list", " src_txt", "tmp___string", "tmp___str", "src_Str", "src2str", "src2buf", "rc_trans", "src64list", " src_string", "src_string", " src_br", "src_br", "src2br", "src___string", "tmp___buf", "src64str", "src_txt", "src_trans", "src___list", "rc_string", " src_buf", "tmp_list", " src_src"], "host_port": [" hostzports", " host_Port", "host_host", "host2ort", "host_offset", "host_ort", "host_Port", "host2Port", "host_ports", "host2port", " host_offset", " hostzoffset", "host_PORT", " host_PORT", "host2PORT", "hostzport", " hostzport", " host_ort", " hostzPORT", "hostzoffset", "hostzports", " host_host", " host_ports", "hostzPORT"], "buf": ["vp", "txt", "tx", "buff", "cb", "b", "cmd", "pkg", "pg", "off", "queue", "rw", "window", "Buffer", "Buff", "np", "pb", "ff", "ann", "cast", "iter", "db", " buffer", "rb", "bytes", "cat", "doc", "str", "pad", "ah", "cp", "pack", "array", "nm", "cap", "desc", "font", "prop", "kw", "ctx", "raw", "data", "cv", "count", "cam", "mu", "vec", "pool", "uf", "conv", "fd", "dat", "buffer", "cur", "img", "tmp", "words", "pos", "proc", "orig", "msg", "temp", "bag", "cache", "text", "page", "bar", "mem", "seq", "block", "req", "aka", "q", "list", "paste", "br", "batch", "bt", "que", "port"], "p": ["v", "pard", "pc", "k", "pre", "tp", "vp", "bp", "pa", "post", "lp", "jp", "sp", "f", "r", "b", "pid", "pp", "pool", "pkg", "at", "t", "pat", "m", "par", "ping", "pad", "pt", "g", "P", "per", "d", "cp", "u", "q", "pi", "a", "part", "fp", "h", "pe", "l", "np", "progress", "i", "c", "pb", "j", "pos", "ps", "port"], "n": ["nt", " i", "v", "nr", "k", " ni", "na", "nu", "ns", "ne", "b", "r", "z", "an", "nan", "t", "cn", "o", "m", "ni", "g", "en", "d", "N", "u", "number", " fn", "nb", " l", "no", "ln", "gn", " len", "l", "nn", "nm", "num", "np", "i", "j", "c", "x", "sn", "y", "nc", "port"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222, "substitutes": {"bs": ["BS", "aus", "bits", "bas", "hs", "iss", "bis", "js", "gs", "ses", "ubis", "bp", "ms", "obs", "bf", "fs", "blog", "lb", "ns", "ubs", "ss", "b", "ts", "bos", "bc", "cs", "bl", "bes", "sb", "bps", "bh", "boxes", "fps", "aws", "ds", "outs", "bb", "ls", "os", "locks", "hz", "rs", "bm", "vs", "sys", "aos", "lbs", "als", "sts", "its", "pb", "bt"], "sector_num": ["section_Num", "section_norm", "sectorNamenumber", "sector_NUM", "sector_number", "sector1norm", "sector1number", "sector2num", "sectorNamenum", "sector2NUM", "sector1num", " sector_NUM", "section_nom", "sector2Num", "sector1Num", "sector_nom", "sector_mon", "section_number", "sector_norm", "sectorNamenorm", "section_mon", "sector_um", "sectorNameNum", "section_um", "sector2number", " sector_Num", " sector_number", "sector2mon", "section_NUM", "section_num", "sector_Num"], "remaining_sectors": ["remaining_seapters", "remaining_vectors", "remaining_severs", "remaining_peors", "remaining_seivers", "remaining_sesections", "remainingitysvctors", "remainingitysectors", "remainingitysvcs", "remainingityseors", "remaining_veapters", "remaining_svctors", "remainingitysecs", "remaining_spectors", "remaining_tectors", "remainingitysvors", "remaining_speapters", "remaining_specs", "remaining_svcs", "remaining_soors", "remaining_secs", "remainingityseapters", "remaining_sosections", "remaining_pecs", "remaining_teivers", "remaining_speors", "remaining_veors", "remaining_vesections", "remaining_seors", "remaining_spevers", "remaining_tesections", "remaining_veivers", "remaining_teors", "remaining_svapters", "remaining_pectors", "remaining_pevers", "remainingitysvapters", "remaining_soivers", "remaining_soctors", "remaining_vevers", "remaining_vecs", "remaining_svors"], "qiov": ["eqiev", "sqiop", "quovi", "ckovi", "iqiv", "qovi", "quconv", "qudyl", "qurolet", "sqiev", "qiop", "quiop", "eqiv", "eqdyl", "qconv", "iqiov", "quiour", "ckconv", " qiop", "quiv", "sqrolet", "qiv", "qiev", "quiev", "qiour", " qconv", "qdyl", "quiov", " qovi", " qrolet", "iqiev", "ckiov", "ckiour", "qrolet", " qiour", "iqdyl", " qiev", "eqiov", "sqiov"], "s": ["abilities", "sv", "args", "settings", "hs", "is", "gs", "js", "ms", "ses", "bis", "changes", "sp", "S", "serv", "sam", "fs", "ns", "details", "actions", "ss", "b", "states", "ts", "qs", "spec", "t", "cs", "ssl", "less", "ats", "bes", "sb", "ins", "ims", "p", "comm", "aws", "ds", "ls", "sw", "es", "os", "rs", "series", "h", "vs", "as", "sys", "conf", "stats", "sts", "als", "its", "i", "j", "socket", "stat", "sq", "ps", "self", "set", "w"], "index_in_cluster": ["index_in_clusters", "index_in_Cluster", "index_in_Clust", "index_in_Closer", "index_in_ploser", "index_in_plusters", "index_in_scoser", "index_in_choser", "index_in_clust", "index_in_pluster", "index_in_scusters", "index_in_plust", "index_in_scust", "index_in_chusters", "index_in_Clusters", "index_in_closer", "index_in_scuster", "index_in_chust", "index_in_chuster"], "n1": [" NOne", "cn1", "r1", "fnOne", "rn001", "nOne", "cnOnce", "nones", "r81", " N2", "fn1", "rnuber", "nuber", "sn1", "n001", " Nones", "r0", " nOne", " n2", "anuber", "n0", "snOne", "nOnce", "sn0", " N1", "rn1", "an001", " n001", " nOnce", "dn2", "fnones", "an1", "cn2", "sn81", " nones", "n2", "cn81", "n81", " nuber", " n81", " n0", "dn81", "rOne", "fn2", "dn1", "dnOnce"], "ret": ["far", "rev", "nt", "il", "res", "virtual", "result", "ter", "net", "red", "final", "get", "val", "ll", "print", "rt", "tf", "f", "rets", "mem", "tr", "leg", "job", "rect", "after", "r", "elt", "cert", "reset", " Ret", "cmd", "t", "len", "fun", "ref", "details", "deg", "ft", "gt", "Ret", "out", "sub", "rm", "arg", "mt", "locked", "RET", "lt", "att", "def", "cont", "fi", " RET", "back", "re", "alt", "et", "prot", "lit"], "cur_nr_sectors": ["cur_nr_spegments", "cur_nr_spellers", "cur_nr_spevers", "cur_nr_severs", "cur_nr_pectors", "cur_nr_bectors", "cur_nr_vevers", "cur_nr_meors", "cur_nr_bellers", "cur_nr_beivers", "cur_nr_bevers", "cur_nr_begments", "cur_nr_peors", "cur_nr_spectors", "cur_nr_speors", "cur_nr_veors", "cur_nr_seivers", "cur_nr_speivers", "cur_nr_mectors", "cur_nr_meivers", "cur_nr_mevers", "cur_nr_veivers", "cur_nr_segments", "cur_nr_pellers", "cur_nr_vegments", "cur_nr_vectors", "cur_nr_beors", "cur_nr_sellers", "cur_nr_pevers", "cur_nr_pegments", "cur_nr_vellers", "cur_nr_seors"], "hd_qiov": ["hd_acqukov", "hd_quiev", "hdmyqkov", "hd_dqiour", "hd_acquiev", "hd_ueiol", "hdmyacqudyl", "hd_ekovi", "hd_qrolet", "hd_dqiao", "hd_acquopted", "hd_chnox", "hdmyacquiov", "hdmyqdyl", "hd_iqiov", "hd_myiour", "hd_myiev", "hd_qovi", "hd_chopted", "hd_myiov", "hd_quyon", "hd_ueiev", "hd_ueiov", "hd_dqiever", "hd_dqkov", "hd_quiol", "hd_qiever", "hd_quiov", "hd_iqrolet", "hd_iqiour", "hd_qiol", "hd_quopted", "hd_qiv", "hdmyacquiao", "hd_zyon", "hd_dqiv", "hdmyqiao", "hd_iqiv", "hd_qyon", "hd_dqiev", "hd_eqiov", "hd_acqudyl", "hd_eriov", "hd_qkov", "hd_chiev", "hd_qunox", "hd_qnox", "hd_eqdyl", "hd_qiour", "hd_ekyon", "hd_qopted", "hd_giour", "hd_dqrolet", "hd_giov", "hd_qdyl", "hd_iqiev", "hd_chiov", "hd_iqiever", "hd_eqkov", "hd_acqunox", "hd_qiev", "hd_ekiov", "hd_zovi", "hd_giv", "hd_quovi", "hd_ekiev", "hd_acquiao", "hd_acquiov", "hd_grolet", "hd_myiever", "hd_qiao", "hd_eriev", "hd_ziov", "hd_dqdyl", "hd_eqiao", "hd_ueiour", "hd_eriour", "hdmyacqukov", "hd_dqiov", "hd_ziev", "hd_eriol", "hd_quiour", "hdmyqiov"], "cluster_data": ["clusteritydata", "cluster_offset", "cluster2info", "clusters_error", "cluster2error", "clusterityerror", "clusterityinfo", "cluster2offset", "clusterityoffset", "clusters_data", "cluster_info", "cluster_error", "clusters_offset", "cluster2data", "clusters_info"]}}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230, "substitutes": {"s": ["sv", "v", "ans", "n", "hs", "is", "gs", "js", "ses", "fs", "S", "sp", "ns", "ar", "ss", "b", "r", "ts", "qs", "se", "ops", "t", "cs", "ssl", "south", "ats", "conv", "space", "sb", "ins", "p", "aws", "ds", "g", "ls", "sw", "os", "a", "scl", "sg", "es", "rs", "h", "as", "sys", "l", "stats", "sts", "bs", "its", "xs", "c", "j", "sq", "ps", "sm", "ctx"], "size": ["data", "too", "to", "n", "false", "max", "count", "zero", "offset", "scroll", "small", "notice", "scale", "sp", "amount", "shape", "after", "ize", "message", "ce", "body", "z", "address", "sum", "bytes", "t", "len", "south", "padding", "sh", "shift", "send", "space", "total", "time", "password", "e", "buffer", "format", "g", "name", "sw", "fee", "number", "news", "ze", "no", "error", "SIZE", "storage", "capacity", "height", "num", "now", "large", "gz", "c", "x", "empty", "sn", "Size", "network", "length"], "pb": ["cv", "pc", "vp", "tp", "dp", "bp", "pa", "db", "wp", "ub", "lp", "sp", "typ", "jp", "lb", "phys", "pl", "pro", "ob", "tx", "td", "stab", "cb", "vm", "b", "rb", "ts", "pp", "pool", "pg", "pkg", "gp", "func", "um", "gb", "mp", "uf", "sb", "tm", "p", "bh", "pt", "tab", "bb", "cp", "px", "nb", "fb", "snap", "ib", "fp", "sys", "np", "span", "pm", "tc", "bs", "tk", "wb", "amp", "BP", "pr", "buf", "cm", "proc", "PB", "emb", "ctx"], "st": ["nt", "sv", "cl", "ust", "stop", "ST", "th", "ist", "St", "ast", "sp", "typ", "tt", "ut", "rt", "inst", "td", "ss", "step", "set", "stan", "ts", "se", "std", "sty", "t", "art", "sh", "sb", "ft", "str", "pt", "sl", "irst", "ct", "sw", "stage", "must", "nd", "mt", "sc", "stable", "sts", "ost", "start", "stat", "sta", "sn", "est", "rest", "ind", "ste", "sm"], "strt": ["sprte", " strp", "iterdt", " strte", "stringt", "Strpt", " strct", "chart", "strv", "itert", " strdt", "strpt", " strg", "strdt", "Strdt", "stringp", "sprt", "sprv", "charv", "strg", "stringct", "sprl", "strte", "charl", "Strt", "stringtt", "strl", " strtt", "chartt", "strtt", "Strg", "charct", "charp", "strp", "iterpt", " strpt", "charte", "strct", "iterg", " strl", " strv"], "skip": ["limit", "zero", "count", "iter", "offset", "scroll", "loop", "sp", "link", "Skip", "slot", "after", "then", "delay", "step", "trans", "run", "missing", "find", "pass", "ip", "sk", "send", "add", "scan", "seek", "copy", "sleep", "jump", "ipp", "check", "syn", "sync", "trace", "snap", "miss", "no", "share", "num", "row", "need", "strip", "wait", "include", "pos", "move"], "atom": ["xml", "aton", " atomic", " oxygen", " prop", " bom", "typ", "node", "fam", " electron", " matrix", "om", "item", "op", "or", " strat", "ym", " mate", "cmd", " bond", "attr", "mol", "at", " emit", " om", "orb", "m", " symb", " moment", "tab", "com", "format", "from", "mate", "part", "element", " contam", "orm", "nm", "xy", "mat", "tar", "asm", "pair", "msg", "sym", "prop", "term", " partner", " plat"], "preamble": ["promble", "preamBLE", "Pamlist", "ppreamBLE", "pparmBLE", "pamlist", "pamBLE", "prambled", "pamle", "Preamble", "parmble", "pparmlet", "Preamle", "ppreamble", "Preamler", "parmlet", "preamler", "Pamler", "Pambles", "Pamble", "parmbles", "prewble", "pressole", "prambles", "pramler", "pambles", "Pamle", "pamler", "prombled", "prewBLE", "pamlet", "prewlet", "Preambled", "pparmbles", "Preambles", "promlist", "pressoler", "pramle", "pambled", "pparmble", "preamle", "preamlist", "pressoble", "Pambled", "prewbles", "pramble", "pressobles", "parmBLE", "Preamlist", "ppreambles", "preamlet", "preambled", "prombles", "ppreamlet", "pamble", "pramlist", "preambles"]}}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231, "substitutes": {"rdma": ["rmo", "rma", "rustlia", "rman", "drmu", "rnmma", "rdna", "drma", "erdmo", "rdmic", "rnma", "udma", "ldna", "ldma", "udmma", "rustsm", "erdman", "drsm", "rdlia", "ldsm", "rdsta", "ridmma", "rnmic", "drmo", "erdmu", "rdmo", "ridmic", "rdmu", "drman", "udsta", "rmu", "udmic", "rdsm", "rustma", "erdma", "drlia", "ridma", "ldlia", "ridsta", "rustna", "rdmma", "drna", "rdman", "rnsta"], "mode": ["command", "md", "zero", "dd", "me", "range", "none", "only", "power", "mask", "scale", "stroke", "MODE", "mod", "ward", "ase", "raid", "cmd", "area", "mac", "mit", "ode", "mm", "m", "time", "code", "format", "device", "pose", "Mode", "mate", "mop", "te", "prefix", "phrase", "mt", "role", "option", "perm", "position", "pe", "de", "use", "force", "direction", "module", "when", "test", "move"], "r": ["ren", "er", "hr", "nr", "res", "rec", "result", "sr", "k", "fr", "gr", "R", "rr", "rt", "f", "it", "ar", "rl", "ret", "or", "reader", "rb", "b", "cr", "rd", "rate", "new", "rg", "ref", "req", "m", "p", "g", "d", "rel", "rar", "mr", "q", "rm", "response", "rh", "rs", "lr", "h", "rc", "dr", "br", "rer", "re", "j", "pr", "y", "ro", "rn", "vr", "err", "root", "rect"]}}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int decode_codestream(J2kDecoderContext *s)\n\n{\n\n    J2kCodingStyle *codsty = s->codsty;\n\n    J2kQuantStyle  *qntsty = s->qntsty;\n\n    uint8_t *properties = s->properties;\n\n\n\n    for (;;){\n\n        int marker, len, ret = 0;\n\n        const uint8_t *oldbuf;\n\n        if (s->buf_end - s->buf < 2){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n\n            break;\n\n        }\n\n\n\n        marker = bytestream_get_be16(&s->buf);\n\n        if(s->avctx->debug & FF_DEBUG_STARTCODE)\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n        oldbuf = s->buf;\n\n\n\n        if (marker == J2K_SOD){\n\n            J2kTile *tile = s->tile + s->curtileno;\n\n            if (ret = init_tile(s, s->curtileno))\n\n                return ret;\n\n            if (ret = decode_packets(s, tile))\n\n                return ret;\n\n            continue;\n\n        }\n\n        if (marker == J2K_EOC)\n\n            break;\n\n\n\n        if (s->buf_end - s->buf < 2)\n\n            return AVERROR(EINVAL);\n\n        len = bytestream_get_be16(&s->buf);\n\n        switch(marker){\n\n            case J2K_SIZ:\n\n                ret = get_siz(s); break;\n\n            case J2K_COC:\n\n                ret = get_coc(s, codsty, properties); break;\n\n            case J2K_COD:\n\n                ret = get_cod(s, codsty, properties); break;\n\n            case J2K_QCC:\n\n                ret = get_qcc(s, len, qntsty, properties); break;\n\n            case J2K_QCD:\n\n                ret = get_qcd(s, len, qntsty, properties); break;\n\n            case J2K_SOT:\n\n                if (!(ret = get_sot(s))){\n\n                    codsty = s->tile[s->curtileno].codsty;\n\n                    qntsty = s->tile[s->curtileno].qntsty;\n\n                    properties = s->tile[s->curtileno].properties;\n\n                }\n\n                break;\n\n            case J2K_COM:\n\n                // the comment is ignored\n\n                s->buf += len - 2; break;\n\n            default:\n\n                av_log(s->avctx, AV_LOG_ERROR, \"unsupported marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n                s->buf += len - 2; break;\n\n        }\n\n        if (s->buf - oldbuf != len || ret){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"error during processing marker segment %.4x\\n\", marker);\n\n            return ret ? ret : -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 24244, "substitutes": {"s": ["sv", "ex", "bits", "gs", "ms", "ses", "changes", "sam", "details", "b", "parts", "orders", "comments", "styles", "p", "e", "aws", "ls", "dates", "rs", "app", "as", "als", "i", "sports", "c", "y", "ags", "ps", "set", "w", "er", "n", "bis", "ers", "fs", "ties", "ns", "ants", "ts", "south", "less", "sb", "ins", "d", "es", "os", "a", "ies", "events", "vs", "stats", "sts", "args", "settings", "ports", "hs", "is", "ss", "r", "spec", "cs", "ats", "times", "http", "comm", "simple", "ds", "ids", "summary", "sys", "j", "sq", "v", "js", "eps", "S", "source", "qs", "t", "gets", "ims", "g", "tests", "sw", "h", "bs", "xs", "its", "x", "self"], "codsty": ["lexsty", "lexstyle", "cmdsty", "odestyle", " codsy", "codsy", " codestyle", "codety", "codesy", "odsy", "oxstyle", "cmdestyles", "lexstro", " codstyle", " codty", "codestyle", "oxestyle", "odstro", "codesty", "codstro", " codstra", "cmdstra", "oxsty", "odstyle", "oxestyles", "codst", "codty", "cdsty", " codety", "codstra", "pedstyle", " codstro", "cdety", "cmdstyle", "codstyle", "pedsty", " codst", "cmdsy", " codestyles", "cpstra", "odty", "cmdst", "odestyles", "cdsy", "oxstro", "cpsty", "pedty", "codeestyles", "codestyles", "cpestyles", "cdestyle", "oxety", "cpst", "odety", "pedstro", "lexestyle", "odsty"], "qntsty": ["qrtstyles", "qentso", "qndstyle", "qrtfo", "qrtstyle", "qndsym", "qctsty", "Qntsym", " qntSty", " qrtsty", "qncstyle", "qnotstyles", "qncst", "qntstyles", "Qntstyle", "qndso", "qrtsym", "qnotsty", "qntsy", "qncsta", "qndsty", "qntst", " qndso", " qntsta", "qnsty", " qntstyles", " qntso", "qncsty", "Qntfo", " qndstyle", "qdefsty", "Qntsty", "Qndsty", "qrentsym", "qrtsy", " qntst", "qndsta", "qntsym", "qndSty", "qctsy", "qrentsty", "Qndstyle", "qnotstyle", "qctstyles", "qnfo", "qnnsta", "qdefstyle", "qnsym", " qntsy", "qntsta", " qndSty", "qntso", " qndst", "qdefso", "Qndfo", " qrtstyles", "qmtsty", "qmtstyle", "qrtsty", "qnnst", "qntSty", " qndsym", " qrtstyle", "qmtSty", "qndfo", " qntstyle", " qndsta", " qrtsy", "qntfo", " qndsty", "qnstyle", "qndst", "qentsty", "qnnstyle", "qntstyle", "qnnsty", "qrentstyle", "qentstyle", "qrentSty", "Qndsym", " qntsym", "qnotsy", "qctstyle", "qmtsym"], "properties": ["abilities", "tags", "vals", "settings", "bits", "units", "errors", "fields", "powers", "members", "services", "ties", "params", "dos", "details", "frames", "pro", "pointers", "artifacts", "images", "states", "phy", "products", "parts", "headers", "objects", "orders", "notes", "options", "comments", "styles", "metadata", "times", "bugs", "pps", "features", "values", "terms", "beans", "workers", "reports", "stories", "dates", "links", "packages", "perties", "resources", "poses", "items", "types", "flags", "effects", "phones", "progress", "property", "classes", "strings", "fixes", "prints", "prop", "ps", "tis"], "marker": [" markarer", "merarer", " Markiter", "markER", "packER", " MarkER", "markarer", "markiter", "arkker", "markediner", "Markera", "markter", "Markner", " markter", "markiner", "masker", "markedera", "misser", "missiner", "packner", "markedter", "merer", "Markiter", "markedER", "presentker", "merER", " markner", "maskER", "Markener", "arker", "MarkER", "Marker", "Markarer", "Marketer", "markener", "Markker", "marketer", "packter", " Marker", " markER", "markera", "presenter", "presentener", "packer", "Markter", "presentER", "markeder", "arkener", "maskner", "markner", " marketer", "mereter", "arkera", "misster", "maskiter", " Markner", "arkter", "missER", "arkER", "Markiner", "markker"], "len": ["limit", "nt", "il", "n", "nl", "fin", "mid", "iter", "offset", "del", "els", "lp", "sp", "val", "fil", "ll", "kl", "mem", "lim", "lis", "ret", "seq", "loc", "elt", "vec", "z", "fn", "lan", "fun", "lib", "el", "lon", "en", "Len", "ls", "syn", "size", "ln", "vol", "joined", "wid", "l", "resp", "num", "pos", "lvl", "ptr", "inv", "un", "length"], "oldbuf": ["newcb", " oldbuffer", "oldbuff", "Oldbytes", "oldbytes", " oldbuff", "OLDcb", "oldercb", "lowbuf", "lowbuffer", "olderbuff", "Oldbuf", "olderbuf", "newbuf", "oldbuffer", "Oldbuffer", "OLDbuff", "lowbuff", "newbuff", "newbuffer", " oldbytes", "OLDbuf", "olderbuffer", "oldcb", "lowbytes", "Oldbuff", "OLDbuffer"], "tile": ["vp", "tif", "tip", "ten", "ile", "ele", " Tile", "slice", "offset", "theme", "member", "scale", "node", "details", "tle", "tag", "store", "layer", "rect", "toggle", "sheet", "kt", "detail", "ts", "tree", "cell", "image", "t", "coord", "vt", "key", "stone", "port", "sel", "buffer", "tab", "device", "pose", "mate", "phone", "table", "window", "te", "title", "depth", "site", "pixel", "shot", "unit", "sector", "league", "property", "mat", "target", "ti", "entity", "mobile", "texture", "ptr", "tie", "Tile", "grid", "tier", "player", "test", "sett"]}}
{"project": "FFmpeg", "commit_id": "9745f19ffc9031ce480e43d7cf1053b58100d70f", "target": 0, "func": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n\n    avctx->subtitle_header_size = avctx->extradata_size;\n\n    return 0;\n\n}\n", "idx": 24269, "substitutes": {"avctx": ["navgc", "navcmp", "avepkg", " avcmd", "averkt", " avcrit", "wavpkg", " avpkg", "devcontext", "avecontext", "actkt", "wavctl", " avpid", "wavcmd", "avertx", " avctl", "wavcrit", "actcmd", "avgc", "averpkg", " avtx", "avetx", "autctl", "navctx", " avtxt", "avtxt", "avpool", "devtx", "actpool", "acttx", "avegc", "wavtx", " avcontext", "actgc", "avertxt", "avtx", "afctl", "avctl", "wavctx", "actcmp", "actctx", "avercontext", " avkt", "devctx", "avcontext", "afctx", "wavtxt", "avcmd", "avercrit", "wavcb", "avercmd", "avcb", "afpkg", "avpkg", "averctl", "autctx", "devpool", " avpool", "avcmp", "autcontext", "afcontext", "averctx", "avecmp", "afcb", "avercb", "avectl", "actcontext", "wavcontext", "autpid", "avcrit", "avpid", "afpid", "navcontext", "actpkg", "avectx", "avkt"]}}
{"project": "qemu", "commit_id": "f2b58c43758efc61e2a49b899f5e58848489d0dc", "target": 1, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n\n{\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n    int rc = 1;\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n        s->pdus[i].s = s;\n\n        s->pdus[i].idx = i;\n\n    }\n\n\n\n    v9fs_path_init(&path);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n\n                   \"id = %s\",\n\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n\n                   s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n", "idx": 24280, "substitutes": {"s": ["sv", "obj", "gs", "ms", "ses", "changes", "services", "sam", "details", "store", "b", "state", "parts", "bes", "p", "e", "aws", "ls", "so", "rs", "des", "as", "conf", "als", "session", "these", "c", "y", "ps", "set", "results", "w", "n", "fs", "params", "ns", "states", "ts", "has", "save", "ssl", "south", "less", "sb", "ins", "d", "u", "es", "os", "a", "ies", "vs", "ys", "stats", "sts", "re", "ports", "settings", "args", "hs", "is", "errors", "f", "ss", "r", "spec", "this", "cs", "ats", "space", "m", "comm", "ds", "sync", "l", "sys", "j", "sq", "v", "js", "eps", "S", "source", "serv", "reads", "go", "qs", "t", "gets", "ims", "o", "g", "sl", "sw", "h", "service", "bs", "its", "utils", "self"], "errp": ["errpb", " errpy", "nerP", "errap", "errorpad", "errpe", " erp", "acerpress", "rerpre", "errpolicy", "rerP", "nerpy", "errpad", "ermpolicy", "errpoint", "errorpe", "corp", "ererpoint", " errpb", "errorP", " errP", "ererpe", "lrpress", "rerpa", "errorback", "errorpart", "acerpart", "lrp", "lrpolicy", "ermpad", "rerp", "errorpoint", "errorpa", "ermback", "errorpy", "erp", "errback", "nerpb", " erback", "corap", "ermpart", "errorp", "erP", "acerpolicy", "errpre", " erpad", "errP", "errorap", " erpart", "ermpress", "erpre", "errpa", "ermp", "errorpre", "acerp", "errpress", "lrpart", "errorpb", "corpe", "erpa", "corpoint", "nerp", "ererp", "errpy", "errpart", "ererap"], "i": ["qi", " I", "ix", "xi", "ami", "used", "ii", "ip", "ei", "p", "e", "id", "io", "zi", "c", "y", "bi", "ind", "I", "n", "k", "iter", "next", "client", "ci", "di", "u", "pi", " mi", "iu", " ti", "phi", "is", "me", "ij", "f", "ini", "r", "gi", "hi", " bi", "cli", "sim", "ri", "m", "multi", "MI", " ii", "im", "try", "l", "ski", "j", "index", "si", "iri", "v", "in", "li", "ai", "ji", "mi", "key", "ims", "uri", "ti", "batch", "x", "it", "ui"], "len": ["nt", "gen", "il", "n", "cmp", "nl", "count", "fin", "li", "lp", "L", "val", "ll", "kl", "pl", "mem", "lim", "seq", "loc", "elt", "vec", "fn", "lf", "lan", "mult", "fun", "cod", "conv", "el", "lon", "coll", "compl", "fl", "en", "Len", "ls", "Length", "ul", "size", "ln", "enc", "von", "ld", "wid", "l", "num", "gz", "pos", "err", "dl", "length"], "stat": ["cache", "kan", "fin", "gc", "conn", "util", "db", "Stat", "get", "disk", "file", "node", "print", " Stat", "load", "fat", "STAT", "info", "attr", "fn", "fw", "ctl", "dir", "Stats", "scan", "fd", "p", "str", "status", " stats", " STAT", "check", "sync", "h", "def", "l", "num", "stats", "pr", "et", "it", " fi", "un", "set"], "fse": ["fSE", "bfese", " fese", "firese", "cfse", "bsle", "bpe", "Fse", "jsle", "vpse", "fspe", "vse", "vpe", "jte", "bfpe", "fwsche", "fsese", "cfpe", "Fsem", "flowse", "fwse", "fsene", "flowpe", "jse", "Fsle", "bse", "vSE", "firesche", "cfSE", "fsle", "Fpe", "fpse", "pte", " fpse", "fwese", "jve", "bve", "vte", " fsche", "fese", "fireese", "flowte", "fsse", "cfese", "cfpse", "bSE", "cfene", "fwpe", "ppe", "fwSE", "psem", "bfse", "bte", "fsche", "fwte", "flowsem", "fpe", "pse", " fSE", "fte", "bfene", "Fte", "Fve", "fene", "fsem", "fve"], "path": ["dest", "ex", "output", "ring", "wp", "th", "host", "txt", "sp", "file", "ext", "ATH", "f", "context", "__", "tag", "policy", "full", "Path", "r", "core", "cmd", "pkg", "patch", "t", "key", "dir", "ref", "template", "pod", "doc", "p", "m", "pt", "name", "dev", "P", "root", "d", "out", "cp", "route", "id", "prefix", "h", "point", "np", "pattern", "target", "PATH", "ep", "c", "transform", "ath", "temp", "self", "w"]}}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int wsd_read_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    int version;\n\n    uint32_t text_offset, data_offset, channel_assign;\n\n    char playback_time[AV_TIMECODE_STR_SIZE];\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avio_skip(pb, 8);\n\n    version = avio_r8(pb);\n\n    av_log(s, AV_LOG_DEBUG, \"version: %i.%i\\n\", version >> 4, version & 0xF);\n\n    avio_skip(pb, 11);\n\n\n\n    if (version < 0x10) {\n\n        text_offset = 0x80;\n\n        data_offset = 0x800;\n\n        avio_skip(pb, 8);\n\n    } else {\n\n        text_offset = avio_rb32(pb);\n\n        data_offset = avio_rb32(pb);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);\n\n    av_dict_set(&s->metadata, \"playback_time\", playback_time, 0);\n\n\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->codec_id    = s->iformat->raw_codec_id;\n\n    st->codecpar->sample_rate = avio_rb32(pb) / 8;\n\n    avio_skip(pb, 4);\n\n    st->codecpar->channels    = avio_r8(pb) & 0xF;\n\n    st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;\n\n    if (!st->codecpar->channels)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avio_skip(pb, 3);\n\n    channel_assign         = avio_rb32(pb);\n\n    if (!(channel_assign & 1)) {\n\n        int i;\n\n        for (i = 1; i < 32; i++)\n\n            if (channel_assign & (1 << i))\n\n                st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);\n\n    }\n\n\n\n    avio_skip(pb, 16);\n\n    if (avio_rb32(pb))\n\n       avpriv_request_sample(s, \"emphasis\");\n\n\n\n    if (avio_seek(pb, text_offset, SEEK_SET) >= 0) {\n\n        get_metadata(s, \"title\",       128);\n\n        get_metadata(s, \"composer\",    128);\n\n        get_metadata(s, \"song_writer\", 128);\n\n        get_metadata(s, \"artist\",      128);\n\n        get_metadata(s, \"album\",       128);\n\n        get_metadata(s, \"genre\",        32);\n\n        get_metadata(s, \"date\",         32);\n\n        get_metadata(s, \"location\",     32);\n\n        get_metadata(s, \"comment\",     512);\n\n        get_metadata(s, \"user\",        512);\n\n    }\n\n\n\n    return avio_seek(pb, data_offset, SEEK_SET);\n\n}\n", "idx": 24283, "substitutes": {"s": ["sv", "v", "n", "hs", "gs", "js", "ses", "services", "fs", "S", "src", "sp", "ns", "f", "ss", "b", "ts", "qs", "pkg", "t", "cs", "ats", "sb", "ins", "p", "m", "aws", "ds", "g", "ls", "os", "a", "es", "sg", "scl", "rs", "sc", "h", "sys", "stats", "sts", "bs", "its", "c", "stat", "sn", "sq", "ps"], "pb": ["prototype", "cv", "pc", "vp", "tp", "dp", "atum", "bp", "pa", "wp", "gc", "lp", "txt", "sp", "typ", "uv", "jp", "pl", "peer", "pro", "stab", "td", "vm", "cb", "cpp", "b", "rb", "tg", "ts", "pp", "pool", "pg", "pkg", "gp", "um", "erb", "mp", "uf", "conv", "sb", "p", "bh", "pt", "tab", "bb", "bot", "cp", "py", "bank", "nb", "px", "fb", "bj", "snap", "ib", "fp", "resp", "np", "span", "pm", "tc", "amp", "tk", "wb", "jpg", "BP", "buf", "cm", "proc", "PB", "emb", "ctx"], "st": ["sv", "nt", "n", "stop", "ST", "sat", "th", "ist", "St", "ast", "sp", "ut", "tt", "inst", "stab", "td", "store", "ss", "step", "set", "stan", "ts", "se", "usr", "std", "sm", "put", "sty", "t", "art", "interface", "sh", "stand", "sb", "p", "ft", "str", "pt", "sth", "sl", "irst", "d", "ct", "sw", "stage", "must", "mt", "nd", "sc", "h", "cont", "stable", "tmp", "sts", "ost", "start", "stat", "sta", "est", "sn", "rest", "et", "bt", "ste", "ust"], "version": ["versions", "command", "v", "result", "Version", "server", "final", "usage", "json", "fish", "feature", "channel", "mode", "scale", "power", "f", "vision", "volume", "go", "tag", "about", "product", "message", "major", "step", "ersion", "vers", "class", "spec", "current", "VER", "serial", "python", "sequence", "release", "conv", "match", "component", "flash", "time", "hash", "status", "format", "currently", "number", "depth", "package", "size", "section", "value", "ception", "latest", "position", "chip", "type", "VERSION", "index", "ver", "length", "binding"], "text_offset": ["text_tile", "textiptile", "text_prefix", "textipoffset", "text___index", " text_size", " text_index", "textptoffset", "textipOffset", "textipindex", "text___offset", "textPskip", "textptprefix", " text_Offset", "text_skip", " text_tile", "textpttile", "textPsize", " text_skip", "text_Offset", "text___Offset", " text_prefix", "text___tile", "textPtile", "textPoffset", "text___skip", "text_index", "textptOffset", "text_size", "text___size"], "data_offset": ["video___Offset", "data___address", " data_shift", "data__offset", "data_shift", "data___offset", "data_Offset", "data_address", "data___size", "data___position", " data_seek", "video_off", " data_position", "data___Offset", " data_size", "data___off", "data__Offset", "video___address", "video___off", "video_address", "data_size", "data_seek", "data__off", "data__address", "video___offset", "data_off", "data_position", " data_Offset", "video_offset", "video_Offset"], "channel_assign": ["channel_passay", "channel_ordign", "channel_assignment", "channel_seigned", "channel_attign", "channel_ordition", "channel___assign", "channel_ignignment", "channel___balign", "channel___balition", "channel_seignment", "channel_attoc", "channel_assigned", "channel_affect", "channel_assIGN", "channel_seign", "channel_ordect", "channel_balition", "channel_attignment", "channel_attIGN", "channel_Assignment", "channel_ordigned", "channel_aligned", "channel_assition", "channel_attigned", "channel_attay", "channel_passoc", "channel___assigned", "channel_ignign", "channel_assect", "channel_balect", "channel_passignment", "channel_assoc", "channel_affign", "channel_assay", "channel_alignment", "channel___balect", "channel_Assigned", "channel_baligned", "channel_Assign", "channel_passign", "channel_affigned", "channel___baligned", "channel___assition", "channel_ignay", "channel_affition", "channel_seIGN", "channel___assect", "channel_align", "channel_balign", "channel_ignoc", "channel_alIGN"], "playback_time": ["playbo_time", "playbo_string", "playBack_time", "playback_Time", "playback_times", "playback_info", "playbacks_Time", "playback_string", "playbacks_time", "playBack_times", "playBack_Time", "playbo_times", "playbacks_info"], "i": ["qi", "init", "v", "ex", "gu", " j", "is", "n", "k", " I", "me", "iter", "in", "ind", "li", "ix", "xi", "ai", "gi", "ci", "di", "hi", "ii", "t", "mi", "ip", "cli", "ic", "sim", "m", "multi", "p", "ims", "PI", " ii", "u", "q", "pi", "\u0438", "iu", "l", "ti", "zi", "j", "c", "x", "phi", "index", "y", "it", "si", "bi", "ui", "length", "I"]}}
{"project": "FFmpeg", "commit_id": "16c6795465fd7663792fe535256c760560714863", "target": 0, "func": "x11grab_read_header(AVFormatContext *s1)\n\n{\n\n    struct x11grab *x11grab = s1->priv_data;\n\n    Display *dpy;\n\n    AVStream *st = NULL;\n\n    enum AVPixelFormat input_pixfmt;\n\n    XImage *image;\n\n    int x_off = 0;\n\n    int y_off = 0;\n\n    int screen;\n\n    int use_shm;\n\n    char *dpyname, *offset;\n\n    int ret = 0;\n\n    Colormap color_map;\n\n    XColor color[256];\n\n    int i;\n\n\n\n    dpyname = av_strdup(s1->filename);\n\n    if (!dpyname)\n\n        goto out;\n\n\n\n    offset = strchr(dpyname, '+');\n\n    if (offset) {\n\n        sscanf(offset, \"%d,%d\", &x_off, &y_off);\n\n        if (strstr(offset, \"nomouse\")) {\n\n            av_log(s1, AV_LOG_WARNING,\n\n                   \"'nomouse' specification in argument is deprecated: \"\n\n                   \"use 'draw_mouse' option with value 0 instead\\n\");\n\n            x11grab->draw_mouse = 0;\n\n        }\n\n        *offset= 0;\n\n    }\n\n\n\n    av_log(s1, AV_LOG_INFO, \"device: %s -> display: %s x: %d y: %d width: %d height: %d\\n\",\n\n           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);\n\n\n\n    dpy = XOpenDisplay(dpyname);\n\n    av_freep(&dpyname);\n\n    if(!dpy) {\n\n        av_log(s1, AV_LOG_ERROR, \"Could not open X display.\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto out;\n\n    }\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto out;\n\n    }\n\n    avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */\n\n\n\n    screen = DefaultScreen(dpy);\n\n\n\n    if (x11grab->follow_mouse) {\n\n        int screen_w, screen_h;\n\n        Window w;\n\n\n\n        screen_w = DisplayWidth(dpy, screen);\n\n        screen_h = DisplayHeight(dpy, screen);\n\n        XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);\n\n        x_off -= x11grab->width / 2;\n\n        y_off -= x11grab->height / 2;\n\n        x_off = FFMIN(FFMAX(x_off, 0), screen_w - x11grab->width);\n\n        y_off = FFMIN(FFMAX(y_off, 0), screen_h - x11grab->height);\n\n        av_log(s1, AV_LOG_INFO, \"followmouse is enabled, resetting grabbing region to x: %d y: %d\\n\", x_off, y_off);\n\n    }\n\n\n\n    use_shm = XShmQueryExtension(dpy);\n\n    av_log(s1, AV_LOG_INFO, \"shared memory extension%s found\\n\", use_shm ? \"\" : \" not\");\n\n\n\n    if(use_shm) {\n\n        int scr = XDefaultScreen(dpy);\n\n        image = XShmCreateImage(dpy,\n\n                                DefaultVisual(dpy, scr),\n\n                                DefaultDepth(dpy, scr),\n\n                                ZPixmap,\n\n                                NULL,\n\n                                &x11grab->shminfo,\n\n                                x11grab->width, x11grab->height);\n\n        x11grab->shminfo.shmid = shmget(IPC_PRIVATE,\n\n                                        image->bytes_per_line * image->height,\n\n                                        IPC_CREAT|0777);\n\n        if (x11grab->shminfo.shmid == -1) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Can't get shared memory!\\n\");\n\n            ret = AVERROR(ENOMEM);\n\n            goto out;\n\n        }\n\n        x11grab->shminfo.shmaddr = image->data = shmat(x11grab->shminfo.shmid, 0, 0);\n\n        x11grab->shminfo.readOnly = False;\n\n\n\n        if (!XShmAttach(dpy, &x11grab->shminfo)) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Failed to attach shared memory!\\n\");\n\n            /* needs some better error subroutine :) */\n\n            ret = AVERROR(EIO);\n\n            goto out;\n\n        }\n\n    } else {\n\n        image = XGetImage(dpy, RootWindow(dpy, screen),\n\n                          x_off,y_off,\n\n                          x11grab->width, x11grab->height,\n\n                          AllPlanes, ZPixmap);\n\n    }\n\n\n\n    switch (image->bits_per_pixel) {\n\n    case 8:\n\n        av_log (s1, AV_LOG_DEBUG, \"8 bit palette\\n\");\n\n        input_pixfmt = AV_PIX_FMT_PAL8;\n\n        color_map = DefaultColormap(dpy, screen);\n\n        for (i = 0; i < 256; ++i)\n\n            color[i].pixel = i;\n\n        XQueryColors(dpy, color_map, color, 256);\n\n        for (i = 0; i < 256; ++i)\n\n            x11grab->palette[i] = (color[i].red   & 0xFF00) << 8 |\n\n                                  (color[i].green & 0xFF00)      |\n\n                                  (color[i].blue  & 0xFF00) >> 8;\n\n        x11grab->palette_changed = 1;\n\n        break;\n\n    case 16:\n\n        if (       image->red_mask   == 0xf800 &&\n\n                   image->green_mask == 0x07e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log (s1, AV_LOG_DEBUG, \"16 bit RGB565\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB565;\n\n        } else if (image->red_mask   == 0x7c00 &&\n\n                   image->green_mask == 0x03e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log(s1, AV_LOG_DEBUG, \"16 bit RGB555\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB555;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR, \"RGB ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 24:\n\n        if (        image->red_mask   == 0xff0000 &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0x0000ff ) {\n\n            input_pixfmt = AV_PIX_FMT_BGR24;\n\n        } else if ( image->red_mask   == 0x0000ff &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0xff0000 ) {\n\n            input_pixfmt = AV_PIX_FMT_RGB24;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR,\"rgb ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 32:\n\n        input_pixfmt = AV_PIX_FMT_0RGB32;\n\n        break;\n\n    default:\n\n        av_log(s1, AV_LOG_ERROR, \"image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n        ret = AVERROR_PATCHWELCOME;\n\n        goto out;\n\n    }\n\n\n\n    x11grab->frame_size = x11grab->width * x11grab->height * image->bits_per_pixel/8;\n\n    x11grab->dpy = dpy;\n\n    x11grab->time_base  = av_inv_q(x11grab->framerate);\n\n    x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);\n\n    x11grab->x_off = x_off;\n\n    x11grab->y_off = y_off;\n\n    x11grab->image = image;\n\n    x11grab->use_shm = use_shm;\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width  = x11grab->width;\n\n    st->codec->height = x11grab->height;\n\n    st->codec->pix_fmt = input_pixfmt;\n\n    st->codec->time_base = x11grab->time_base;\n\n    st->codec->bit_rate = x11grab->frame_size * 1/av_q2d(x11grab->time_base) * 8;\n\n\n\nout:\n\n    av_free(dpyname);\n\n    return ret;\n\n}\n", "idx": 24289, "substitutes": {"x11grab": ["ax11rab", "x_grab", "xonedGrab", "x11progress", "x11ab", " x3port", "ax11grab", " x11client", "x14crop", "x3rab", "x51grab", "x112progress", "x18rab", "x6progress", "x1080stat", "x11config", "x118grab", "ey11cap", "X11progress", "x1080port", "ey11call", "x211pop", "x112crop", "x18cache", " x3grab", "axonedGrab", "x1ab", "ox11grab", "ox18job", "x11gc", "x1111gc", "x86stat", "ax11Grab", "x51cache", "x11call", "X11gc", "xx14cap", "x3Grab", "xx14grab", "axonedgrab", "xonyab", " x3client", "x11stat", "ax18grab", "ox11job", "xx14crop", "xx11crop", "ey11grab", "ox18rab", "x_rab", "x3config", "x511crop", "x18gc", "x86grab", "xonedconfig", "ey511call", "X11grab", "x211grab", "ax18cache", " x3stat", "xonygrab", "x86client", "x51pop", "x86port", "x1080grab", "x18grab", "xx11cap", "x18job", "x14progress", "x1job", "xx14progress", "xonyrab", "x11rab", "ox18grab", "ey511cap", "x11port", "x_Grab", "x11crop", "x18pop", "x11cache", "ey511crop", "x118crop", "axonedconfig", "xx11grab", "x6grab", "ey11crop", "x211cache", "ey511grab", "x118cap", "x1111grab", "x51gc", "x11client", "x3grab", "x1rab", "x112grab", "xonyjob", "x1111progress", "ax11pop", "x14cap", "x18ab", "x3client", "x3stat", "xx11progress", "x11Grab", "x112cap", "axonedrab", "x1grab", "x511grab", "ax11cache", "x211gc", "X11call", "x14grab", "x11pop", " x11port", "xonedrab", "ax18pop", "x511cap", "x511call", "ax11config", "xonedgrab", "x_config", "ax18gc", "ox11rab", " x11stat", "ox18ab", "x118call", "x6call", "x1111call", "ox11ab", "ax11gc", "x1080client", "x11cap", "x11job", "x3port", "x6gc"], "dpy": [" dmy", "adpy", "gtry", "dotry", "sdpty", "dspm", "dnpc", " dbase", " dpm", "tdPy", "dmit", "sdPy", "dnxy", "npy", "mainpy", "dPy", "edpo", "tdpty", "dlpy", "dply", "dopy", "diply", "domit", "dlpu", "domtry", " dpo", "tdpy", "adumpy", "dommy", " dpc", "dmy", "dsply", " dphy", "dxpc", "dxxy", "edply", "dpu", " dpu", "sdpm", "ntry", " dxy", "sdpe", "dpe", "dipy", "adphy", "dnpm", "ypy", " dply", " dtry", "gphy", "dnpy", "dphy", " dmit", "tdpe", "sdtry", "dlbase", "dsxy", "mainpu", "maintry", "dipm", "dspy", "edtry", "dopm", "ypm", " dumpy", "ymit", "nply", "npo", " dpty", "dompm", " dpe", "adtry", "dbase", "dpty", "dpm", " dPy", "dxpy", "dxpm", "dtry", "ytry", "dpo", "gumpy", "dpc", "dumpy", "gpy", "sdmy", "dixy", "dltry", "dxy", "dompy", "mainbase", "sdpy", "edpy"], "st": ["nt", "sv", "ust", "stop", "fr", "ST", " ST", "ist", "St", "ast", "sp", "tt", "ut", "end", "rt", "inst", "store", "r", "set", "se", "std", "sty", "t", "art", "sh", "stack", "str", "pt", "sl", "irst", "dist", "d", "sw", "ct", "stage", "so", "nd", "sc", "dr", "cont", "tmp", "stable", "sts", "ost", "start", "stat", "sn", "rest", "it", "ste", "est"], "input_pixfmt": ["input_pixelsfMT", "input_pixfbgt", "input_pixfcMT", "input_pixfbsm", "input_pixfcgt", "input_pixfbMT", "input_pixelsfgt", "input_pixfcsm", "input_pixfsm", "input_pixelsfsm", "input_pixfMT", "input_pixfcmt", "input_pixelsfmt", "input_pixfbmt", "input_pixfgt"], "image": ["gif", "xml", "video", "frame", "file", "source", "crop", "f", "mage", "Image", "png", "ime", "photo", "sample", "o", "m", "picture", "figure", "view", "im", "io", "img", "input", "map", "document", "icon", "media"], "screen": ["creen", "scene", "script", "isc", "gc", "page", "scroll", "server", "host", "scale", "sp", "crop", "ram", "white", "go", "query", "store", "connect", "process", "tree", "path", "sec", "win", "sh", "SC", "space", "draw", "display", "scan", "seek", "secure", "password", "chain", "buffer", "remote", "hw", "focus", "view", "stage", "window", "clear", "snap", "size", "sc", "score", "sys", "console", "desktop", "Screen", "pen", "scope", "disc", "proc", "widget", "grid", "network", "root", "set"], "use_shm": ["use_khmt", "use_thm", "usexShm", "usexShM", "usexshc", "use_khm", "use_thM", "use_shc", "usexshmt", "use_Shc", "use_khM", "usexshM", "use_khc", "use_Shmt", "use_shM", "use_Shm", "usexShc", "use_shmt", "use_thc", "use_ShM", "usexshm", "use_thmt", "usexShmt"], "dpyname": ["dpyome", "dpynaming", "dpyoaming", "DPgnaming", "dpylonome", "tpwnAME", "ddynAME", "dpagnamer", "dpwname", "pdnamer", "dpyoamy", "DPynname", "dpwnAME", "pdynename", "dpagname", "ddynename", "dpnename", "dpgnAME", "dpydAME", "cpyname", "dpyomial", "tpynamed", "dpynAME", "cpYNamer", "dpagnaming", "dpYName", "dprename", "pdyename", "dpnamy", "dpgnname", "dpynam", "tpynename", "ddname", "dprenami", "dpylamer", "DPynamed", "dpyename", "dpyrname", "pdyomial", "dpylonename", "vpylamer", "vpylename", "vpynename", "dpname", "dpyrAME", "dpgnaming", "dpwnamed", "DPgname", "dpyoame", "dpgnamer", "pdnaming", "dpyanname", "dpymam", "DPynaming", "dpagnamy", "dpgnamed", "dpwnename", "tpyname", "dpydamer", "tpynAME", "dpynomial", "dprenam", "dpynamed", "DPyname", "dpyoamer", "pdyame", "dpylename", "dpylonam", "dpyloname", "dpYNamer", "cpynami", "dprenamer", "dpnAME", "vpylam", "dpynome", "pdyname", "cpynam", "ddyname", "DPgnname", "dpynami", "pdynaming", "dprenename", "dpydename", "dpylam", "tpwnename", "ddnAME", "dpymamer", "pdnamy", "dpydame", "dpyramed", "dpylonamer", "dpyanaming", "dpgnename", "cpYName", "dpYNam", "dpYNami", "cpynamer", "pdyome", "pdynamy", "pdynomial", "dpnaming", "dpyraming", "dpnomial", "dpymame", "dpyrename", "cpYNam", "dpynname", "pdynome", "vpynam", "vpynamer", "tpwnamed", "pdynamer", "dpyame", "pdname", "tpwname", "cpYNami", "dpnamer", "ddnamer", "dpynamer", "dpnome", "dpyaname", "dpylame", "dpyrame", "dpylonomial", "vpylame", "dpyanamed", "DPgnamed", "dpymami", "ddnename", "dpynename", "dpynamy", "dpgname", "vpyname", "ddynamer"], "offset": ["data", "command", "url", "output", "zero", "scroll", "range", "frame", "sp", "source", "crop", "slot", "timeout", "initial", "ret", "optional", "reset", "iso", "info", "address", "origin", "padding", "shift", "meta", "key", "associated", "rot", "ref", "o", "seek", "buffer", "name", "off", "line", "style", "Offset", "prefix", "tile", "error", "size", "reference", "location", "position", "point", "pointer", "row", "map", "addr", "type", "alt", "layout", "alias", "index", "pos", "start", "order", "onet", "attribute", "et", "encrypted", "ptr", "set"], "color_map": [" color_maps", "color2map", " color2maps", " color2set", "color2maps", " color_set", " color2map", "color2set", "color_maps", "color_set"], "color": ["filter", "mask", "gray", "context", "white", "stroke", "store", "state", "match", "COLOR", "blue", "buffer", "number", "table", "array", "value", "pixel", "background", "colour", "map", "type", "field", "col"], "i": ["v", "n", "print", "f", "b", "r", "z", "info", "di", "ii", "t", "o", "m", "p", "e", "out", "id", "io", "h", "l", "j", "c", "et", "it", "si", "set", "I"], "screen_w": ["cover_wh", "cover_r", "screen_r", "screen_wh", "screenmingw", "screen_x", "screenmingn", "covermingw", "screen_W", "screen2n", "covermingn", "screen2r", "covermingr", "covermingwh", "screen2wh", "cover_n", "screen_n", "screen2w", "screen_width", "screenmingr", " screen_W", "cover_w", " screen_width", " screen_x", "screenmingwh"], "screen_h": [" screen_c", "screen2h", "screen__height", " screen_height", "screen_ch", " screen_ch", "screen2w", "screen__w", "screen__i", "screen_i", "screen_height", "screen_c", " screen_i", "screen__h", "screen2ch", "screen2c"], "w": ["v", "n", "W", "wp", "f", "wx", "wa", "wd", "r", "z", "b", "path", "t", "win", "o", "p", "e", "m", "hw", "g", "d", "nw", "sw", "q", "a", "rw", "window", " W", "h", "s", "wt", "l", "iw", "wb", "c", "x", "y", "widget", "kw"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++)\n\n        if (simple_limit(dst+i*stride, 1, flim))\n\n            filter_common(dst+i*stride, 1, 1);\n\n}\n", "idx": 24291, "substitutes": {"dst": ["dest", "Due", "due", "datnd", "trc", "dend", " dend", "tst", "dost", "Drc", " dsrc", "ddue", "datend", "tost", "ddsrc", "drc", " due", "mst", " dnd", " dest", "datst", "ddest", "Dsrc", "dnd", "Dest", "ddst", "Dost", "mend", "datest", " drc", "Dst", "mnd", " dost", "dsrc", "mest", "test"], "stride": [" strick", "strance", "strride", " strance", "strime", "stringuse", "strope", "stringick", "STRope", "stringride", "strick", "constider", "struse", "intride", "intuse", "constride", "STRime", " strider", "slide", "STRide", "constide", " strope", "slride", "intide", "STRider", "constance", " strride", "strider", "slope", "STRance", "slime", " strime", " struse", "intick", "STRride", "stringide"], "flim": [" Fdep", " fclip", "fclip", "fclim", "tlimit", "fclimit", "sflam", "fcclip", " flimit", " Flimit", "sflim", "fcdep", "flam", "sfmin", " fdep", " Flim", "tlam", "fmin", "sflimit", " fmin", " flam", "fdep", "flimit", " Fclip", "tmin", "tlim"], "i": ["init", "qi", "v", "ex", "gu", "is", "iq", "bi", " I", " err", "me", "in", "yi", "li", " ni", "ij", "ix", "xi", "ai", "go", "ini", "ji", "gi", "ci", "z", "ki", " multi", "di", "info", "hi", "ii", "t", "oi", "mi", "ip", "ei", " m", "ic", "sim", "m", "e", "multi", "ims", "chain", "g", "ui", " ii", "pi", "id", "cli", " mi", "im", "iu", "iy", "span", " pi", " ti", "ti", "zi", "j", "batch", "x", "index", "phi", "it", "si", "asi", "ind", "I"]}}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292, "substitutes": {"bs": ["BS", "aus", "bits", "bas", "iss", "ks", "gs", "js", "bis", "ses", "ms", "obs", "fs", "ns", "ubs", "ss", "ts", "qs", "uts", "bos", "bc", "cs", "blocks", "bes", "ats", "uses", "sb", "bps", "ims", "bh", "ds", "bles", "outs", "ls", "es", "cks", "hz", "rs", "acs", "vs", "sys", "aos", "lbs", "sts", "its", "ps"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n", "idx": 24294, "substitutes": {"nonblocking": ["Nonblocking", " nonocking", "noneloading", "nolocking", "noneblocking", "nonblock", "notocking", "southblocking", "notblocks", "nonlocking", "Nonloading", "noblocks", "Nonocking", "southblock", "notblocking", "noblocking", "noneblock", "nonelocking", "nonloading", "southlocking", " nonblock", " nonlocking", "noocking", "Nonlocking", "notlocking", "nonblocks", "notblock", "Nonblock", "noblock", "nonocking", "notloading", "southblocks"], "last_io": [" last_connection", "last_ios", "last___ios", "last___connection", "last___io", " last_iol", " last_boot", "lasttimeno", "last_i", "lasttimeio", " last_no", "lasttimei", " last_ios", "last_connection", "last_iol", "lasttimeios", "last_boot", " last_i", "last___iol", "last_no"], "ti": ["tw", "ita", "tp", "yi", "tu", "ta", "li", "txt", "iat", "ai", "Ti", "gi", "ci", "di", "hi", "tv", "TI", "ii", "ati", "mi", "t", "iti", "isi", "ri", "tm", "ni", "aki", "pi", "te", "lt", "io", "fi", "iw", "uci", "tk", "zi", "i", "phi", "tim", "tie", "vi", "si", "bi", "ui"], "r": ["er", "v", "nr", "hr", "n", "res", "sr", " err", "result", "R", "rr", "rt", "ar", "ru", "or", "cr", "rb", "run", "rin", " intr", "b", "rd", "ry", "t", "rg", "p", "e", "m", "out", "g", "d", "q", "mr", "rw", "rm", " R", "rs", "up", "lr", "h", "ra", "rc", "dr", "l", "br", "re", "i", "c", "ptr", "it", "err", "w"]}}
{"project": "qemu", "commit_id": "0928a95ffe91862938cee997c9e30602fa7884ab", "target": 0, "func": "static void bootp_reply(const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    const struct in_addr *preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr)\n\n        dprintf(\" req_addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n    else\n\n        dprintf(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr) {\n\n            bc = request_addr(preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = *preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(&daddr.sin_addr);\n\n            if (!bc) {\n\n                dprintf(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else if (preq_addr) {\n\n        bc = request_addr(preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = *preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, 6);\n\n        } else {\n\n            daddr.sin_addr.s_addr = 0;\n\n        }\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        dprintf(\"%s addr=%08x\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24311, "substitutes": {"bp": ["pc", "vp", "tp", "bi", "wp", "lp", "bf", "jp", "lb", "sp", "bg", "cb", "b", "rb", "phy", "pp", "gp", "sb", "bps", "p", "bh", "pd", "bb", "cp", "nb", "bj", "bm", "hp", "fp", "kb", "bsp", "np", "br", "bs", "BP", "pb", "batch", "bt", "ps", "ctx"], "bc": ["broad", "bridge", "ca", "pc", "bitcoin", "abl", "ba", "gc", "db", "exec", "loop", "bf", "anc", "ll", "bg", "mu", "cb", "lc", "b", "mc", "nc", "fc", "circ", "xc", "eb", "scribed", "func", "dc", "bl", "arb", "sec", "uc", "butt", "abc", "ic", "ec", "clus", "comm", "cc", "bb", "cf", "ml", "BC", "bd", "bec", "ck", "bo", "sync", "gov", "bm", "sc", "arc", "soc", "rc", "console", "tc", "bs", "vc", "pb", "c", "cm", "proc", "unc", "bt", "bi"], "m": ["ma", "dm", "v", "md", "ms", "me", "hm", "f", "am", "mem", "mu", "vm", "managed", "mod", "mn", "b", "r", "mc", "em", "gm", "M", "t", "mi", "mp", "mail", "tm", "mm", "p", "o", "g", "d", "mr", "rm", "mt", "bm", "perm", "h", "pm", "mat", "mo", "module", "i", "j", "c", "cm", "msg", "sm", "mb"], "rbp": ["umbP", "umbp", " RBp", "obbv", "rwP", "robpa", " RBpm", " RBv", "rbpm", "rbpre", "robps", "erbps", "umbd", "erbpc", "rbpc", "vrv", "robpc", "rwpc", "erbp", "rwps", "rwp", "rbpa", "rbP", "umbpa", "robp", "erbd", "vrpm", " RBpre", "vrp", "rbv", "vrpre", "rbd", "robd", "erbpa", "erbP", "obbpm", "rbps", "obbp", "robP", "obbpre"], "saddr": ["sysadd", "sysha", "saddress", " saddress", "sha", " sha", " sadd", "nsaddress", "sysaddress", "nsadd", "nsaddr", "nsha", "sadd", "sysaddr"], "daddr": ["maddr", "ddaddr", "dnaddr", "ddist", "daddress", "ddurl", "ddaddress", "dcaddr", "Ddist", "dnadd", "Durl", " dptr", " durl", "sdaddr", "sdurl", " ddist", "Dptr", "mattr", "dptr", "dadd", "dcptr", "durl", "dnptr", "ddadd", "Daddr", " dattr", "Daddress", "sdaddress", "madd", "dcdist", "Dadd", " dadd", "dattr", "dnattr", "mptr", "dcadd", " daddress", "sdadd"], "dns_addr": ["dnsgurl", "dnsgname", "dnsqname", "dnsqurl", "dNS_addr", "dNS_address", "dNS_name", "dnsgaddress", "dns_name", "dns_url", "dns_address", "dNS_url", "dnsqaddress", "dnsgaddr", "dnsqaddr"], "preq_addr": ["preq_ptr", "prequest_data", "prek_conn", "preqxloc", "preq_loc", "preq___cmd", "preq__msg", "preq___conn", "prequest_url", "preq___addr", "preqipaddress", "prek_ref", "preq__data", "prek___conn", "preqt__attr", "preq___ref", "preq___ord", "preqipdata", "prech__addr", "preq_ord", "preq___ad", "prek_addr", "prech_address", "preqxmsg", "prequ_address", "prek___addr", "preq__attr", "prequest_addr", "prequest_attr", "preq_attr", "prequ_order", "prev_msg", "prequ_host", "prequest_msg", "preqt__ord", "prekg_ord", "prev_addr", "preqipaddr", "preq_data", "preqt_addr", "preq__ad", "preq_ref", "preq_ad", "preq_conn", "prev_loc", "prek___cmd", "preq_host", "prek___ref", "preq_url", "preqt_ad", "preq_address", "preq__loc", "preq__address", "preqt_attr", "prech__ref", "prech_addr", "prech_ref", "preqt__addr", "preqt_ord", "prekg_addr", "prequ_addr", "prequest_address", "preq_msg", "prequ_req", "preq_cmd", "preq__ref", "preq_order", "preq_adr", "preq_add", "prekg_ptr", "prech__address", "preq__addr", "preqxaddr", "preq__ord", "prek_cmd", "preq___attr", "preq_req", "prekg_adr", "prequ_add", "preqt__ad"], "dhcp_msg_type": ["dhcp_message_name", "dhcp_message_types", "dhcp_msg_info", "dhcp_msg_name", "dhcp_message_status", "dhcp_message_TYPE", "dhcp_msg_status", "dhcp_msg_id", "dhcp_req_no", "dhcp_cmd_t", "dhcp_message_Type", "dhcp_req_name", "dhcp_cmd_Type", "dhcp_msg_TYPE", "dhcp_message_type", "dhcp_message_num", "dhcp_req_t", "dhcp_msg_types", "dhcp_message_time", "dhcp_msg_Type", "dhcp_req_type", "dhcp_msg_no", "dhcp_cmd_id", "dhcp_msg_num", "dhcp_msg_style", "dhcp_msg_size", "dhcp_cmd_type", "dhcp_req_style", "dhcp_message_info", "dhcp_cmd_name", "dhcp_message_id", "dhcp_msg_t", "dhcp_msg_time", "dhcp_message_size"], "val": ["vals", "v", "res", "pol", "typ", "local", "valid", "mem", "ret", "tx", "seq", "VAL", "Val", "len", "al", "key", "rel", "cal", "base", "value", "addr", "vc", "pos", "eval", "msg", "test", "bal", "ctx"], "q": ["qi", "v", "k", "iq", "eq", "f", "qu", "query", "dq", "qs", "t", "o", "p", "e", "qa", "g", "d", "u", "h", "ql", "qq", "ue", "Q", "j", "c", "sq", "ch", "w"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n", "idx": 24312, "substitutes": {"f": ["v", "n", "fr", "bf", "fa", "fs", "file", "tf", "full", "b", "r", "F", "fc", "fn", "xf", "fw", "lf", "t", "fac", "uf", "rf", "fm", "o", "fd", "p", "e", "m", "fl", "g", "fx", "cf", "out", "d", "fast", "q", "fb", "fp", "h", "s", "l", "fi", "form", "j", "c", "x", "ff", "w"], "cpu_fprintf": ["cpu_vformat", "cpu_cmt", "cpu_hmt", "cpu_vprint", "cpu_rprint", "cpu_fprint", "cpu_hprint", "cpu_hformat", "cpu_dmt", "cpu_vprintf", "cpu_rmt", "cpu_vprintln", "cpu_fformat", "cpu_rformat", "cpu_cformat", "cpu_vmt", "cpu_fmt", "cpu_rprintln", "cpu_rprintf", "cpu_cprintf", "cpu_dprint", "cpu_fprintln", "cpu_dprintln", "cpu_dprintf", "cpu_cprint", "cpu_hprintf", "cpu_dformat"], "features": ["versions", "bits", "acts", "fields", "feature", "faces", "rows", "details", "frames", "images", " matches", "weights", "parts", "feat", "names", "blocks", "pins", "sections", "forms", "ATURES", "eatures", "ances", "properties", "tests", "terms", "reports", "events", " rows", "Features", " Features", "ints", "items", "types", "flags", "words", "xs", "classes", "fixes", "fts", " feats", "prints"], "prefix": ["cache", "priority", "pre", "offset", "master", "fix", "txt", "sp", "print", "ix", "tag", "tx", "border", "append", "null", "pkg", "wrapper", "pres", "alpha", "key", "padding", "p", "chain", "pad", "format", "fx", "name", "buffer", "quote", "base", "foo", "yes", "phrase", "fp", "help", "restricted", "just", "pattern", "pretty", "progress", "label", "confirmed", "FIX", "fixes", "x", "password"], "i": ["init", "qi", "v", "ex", "gu", "n", "is", "iq", " I", "me", "ms", "yi", "ind", "in", "li", " ni", "json", "ij", "o", "ix", "xi", "ai", "mu", "ini", "gi", "ci", "z", "ki", " multi", "di", "ii", "mi", "ip", "key", "cli", "ic", "ims", "m", "multi", "p", "e", "sim", "g", "chain", "ri", "ni", " ii", "u", "pi", "id", " mi", "im", "io", "iu", "l", "num", " ti", "ti", "zi", "j", "phi", "x", "index", "y", "it", "si", "bi", "ui", "I"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315, "substitutes": {"gen_code_buf": ["gen_co_buffer", "gen_co_buf", "gen_co_begin", "gen_code_bin", "gen_call_buffer", "gen_call_buff", "gen_call_size", "gen_code_iter", "gen_code_begin", "gen_co_size", "gen_call_buf", "gen_code_buffer", "gen_call_iter", "gen_code_buff", "gen_Code_buf", "gen_Code_buffer", "gen_call_bin", "gen_code_size", "gen_Code_iter", "gen_Code_size"], "max_code_size": ["max_code_len", "max_data_len", "max_data_name", "max_code2size", "max_code2len", "max_code2name", "max_code_name", "max_data_length", "max_code_Size", "max_data_Size", "max_data_size", "max_code_length"], "gen_code_size_ptr": ["gen_code_size_loc", "gen_code_Size_Ptr", "gen_code_size_addr", "gen_code_Size_ptr", "gen_code_size_tr", "gen_code_Size_addr", "gen_code_Size_tr", "gen_code_size_Ptr"], "pc_start": ["fc_begin", "fc_end", "pc_end", "pc2end", "PC_start", "PC_ptr", "pc2ptr", "fc_start", "pc2begin", "fc_ptr", "PC_end", "PC_begin", "pc_begin", "pc2start"], "flags": ["tags", "args", "bits", "ports", "fields", "ms", "fs", "mask", "faces", "details", "kind", "actions", "weights", "pages", "amps", "ts", "cmd", "products", "ops", "xf", "FLAG", "doms", "cs", "pins", "comments", "options", " Flags", "limits", "bugs", "fps", "status", "features", "ds", "posts", "properties", "stores", "heads", "locks", "reports", "flag", "Flags", "utils", "words", "levels", "planes", "lag", "files", "ags"], "dc1": ["c2", "c8", "DC6", "DC0", "c1", "dc8", " dc8", "dc2", "c0", "disc2", " dc2", "cca6", "disc8", "disc3", "cca2", "dc0", "DC1", "cca0", "dc3", "disc1", "cca1", "c6", "dc6", "c3", " dc3", "DC2"], "dc": ["df", "dm", "ca", "iac", "create", "central", "rec", "adr", "dp", "dd", "gc", "die", "currency", "wp", "cam", "driver", "disk", "cd", "cca", "city", "td", "ce", "cr", "lc", "mk", "mc", "fc", "di", "dt", "bc", "center", "ctl", "DC", "cat", "mac", "ac", "dir", "ec", "draw", "doc", "mm", "dat", "cc", "da", "dh", "d", "controller", "ct", "cp", "bd", "design", "rc", "ga", "dr", "tc", "document", "drm", "desc", "c", "disc", "cm", "dra", "dim", "kw", "nc", "ctx"], "gen_code_end": ["gen_code_len", "gen_code_offset", "gen_code_END", "gen_codes_end", "gen_pre_END", "gen_code_start", "gen_data_end", "gen_codes_offset", "gen_code__end", "gen_data_buf", "gen_codes_len", "gen_pre_end", "gen_data_start", "gen_code_ptr", "gen_code__offset", "gen_data_ptr", "gen_codes_start", "gen_pre_start", "gen_code__start", "gen_code__len"], "pc_ptr": ["pcPptr", "pc_pointer", " pc_sp", "pc__pointer", "pcPrect", "gc_ctr", "pc_sp", "pcPpointers", "pc_end", "podPpointers", "pcPlr", "pcPaddr", "asc_lr", "fc_Ptr", " pc_iter", "gc_ptr", "pod_pointers", "asc_rect", "pod_ptr", "asc_rel", "asc_ptr", "pc__ptr", " pc_addr", "podPptr", "gc_pointer", "pc_rep", "pc_iter", "gc__tr", "proc_start", "pc_Ptr", "pc_addr", "podPaddr", "pc_rect", "ascPptr", "pc0buf", "pod_addr", "pc0start", "proc_pointer", "podPend", "ascPlr", "proc_ptr", "pc_rel", "pc0Ptr", "pcPend", "ascPrel", "pc_lr", "fc_start", "fc_ptr", "fc_buf", "ascPrect", "pcPrel", "pc_ctr", "pcPrep", "pc0ptr", "pc__tr", "pc_tr", "asc_rep", "gc__ptr", "pod_end", "ascPrep", "pc__ctr", "pc_pointers", "proc_addr", "gc_tr", "pc_buf", "gc__ctr", "gc__pointer"], "ret": ["rev", "nt", "rem", "res", "result", "nz", "gc", "ter", "iter", "red", " alt", "ext", "txt", "val", "ll", "print", "rt", "valid", "tf", "rets", "reply", "det", "tr", "mem", "r", "elt", "reset", " Ret", "ts", "cmd", "null", "t", "len", "vt", "fun", "ref", "deg", "ft", "gt", "status", "Ret", "out", "inter", "rm", "arg", "mt", "RET", "gov", "value", "def", "try", "resp", "cont", "tmp", "num", " RET", "addr", "back", "alt", "re", "desc", "j", "success", "err"], "disasm_info": ["disassembly_info", "dislamm_Info", "disarm_info", "disassembly_state", "disassembly_fo", "disarm_inf", "disasm_status", "disasm_id", "disasm__INFO", "disarm_Info", "disassembly_Info", "disasm__inf", "disasm__Info", "disassembly_inf", "disasm_state", "dislamm_id", "disasm_Info", "disasm_fo", "disasm__state", "disasm_inf", "disasm__info", "dislamm_info", "disassembly_INFO", "disasm_INFO", "disassembly_status", "disasm__status"], "pc": ["tp", "isc", "gc", "oc", "PC", "lp", "asc", "mc", "fc", "psc", "bc", "cs", "ac", "ec", "pt", "pic", "cc", "cp", "sc", "arc", "rc", "tc", "pb", "c", "proc", "nc", "enc", "ctx"], "count": [" call", "cmp", "result", "z", "process", "func", "current", "Count", "total", "draw", "code", "name", "ount", "ct", "call", "id", "flag", "counter", "ctr", "resp", "num", "type", "skip", "c", "nc", "err", "length", "ctx"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328, "substitutes": {"qiv": ["qIV", "sqivo", "acquiver", "sqtv", "sqiver", "acquiv", "qivo", "qIv", " qiver", "acquIV", "quIv", "queryivo", "quivo", "dqiv", "sqiv", "quiv", " qIV", "dqivo", "queryiver", "queryiv", " qIv", "qutv", "quiver", "acquIv", "qiver", "dqtv", "dqiver", "querytv", "quIV", "qtv"], "name": ["ma", "data", "init", "n", "in", "named", "ext", "na", "local", "common", "NAME", "item", "var", "missing", "spec", "names", "path", "nan", "new", "key", "p", "str", "format", "title", "prefix", "id", "part", "no", "san", "base", "value", "error", "size", "search", "def", "lat", "nm", "label", "nam", "word", "type", "ame", "normal", "resource", "Name", "w"], "errp": ["errorpr", "errpat", " errper", " erp", "errpe", " errr", "krpa", "riskpat", "arrper", " erpat", "scorepe", "errorpe", "errorP", " errP", "errpid", "arrm", "arrr", " errpe", "krpat", "riskpa", "rrr", "scoreP", "errm", "rrm", "errorp", " errm", "scorep", "arrp", "errP", "errr", "rrper", " errpr", "krpid", " erpid", "rrp", "errpa", "krp", "riskp", "errpr", "errper", "riskpid", "scorepr", " erpa"], "qobj": ["sqobj", "qqobject", "qqjs", "dqObj", "qrect", " qobject", "qujs", "dqobj", "qubo", " qjs", "eqobject", "dqobject", "qbo", " qObj", "eqstr", "eqobj", "quobj", "queryrect", "qqobj", "sqObj", "qobject", "quopt", "sqjs", " qrect", "dqopt", " qtxt", "qqtxt", "qjs", "queryobj", "eqrect", "qtxt", "qObj", "dqbo", "quObj", "dqjs", "qutxt", "sqopt", "queryobject", "qqbo", "qqObj", "querystr", " qbo", "qopt"], "qstr": ["qufr", "querybr", "qubr", "sqobj", "qustable", "querySTR", "dqfr", "dqSTR", "dqobj", " qfr", "qustring", " qbr", "qqst", "qqstring", "quarr", "qst", "quobj", "sqsp", "qarr", " qst", "dqstr", "qusp", "dqarr", "qustr", " qstring", "sqstring", "qust", "qstable", " qstable", "dqbr", "dqsp", "queryobj", "qsp", "sqstr", "qqstable", "qfr", "qbr", "querystr", " qarr", "qSTR", "qstring", "qqstr", " qSTR", "dqstring"]}}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331, "substitutes": {"obj": ["nt", "ex", "cmp", "js", "conn", "obs", "txt", "any", "ob", "cmd", "attr", "pkg", "objects", "act", "t", "ock", "ref", "other", "o", "bh", "Object", "org", "os", "bo", "bj", "Obj", "resp", "cont", "xy", "tmp", "piece", "obo", "oj", "tk", "object", "j", "onet", "oco"], "ioc": ["iroc", " ioco", "ziocated", "iiocy", "iiroc", "zioc", "bioci", "piog", "giocy", "iocy", "dioc", " iocy", " ioci", "dioco", "ioco", "iog", "pioc", "biroc", "giroc", "diroc", "gioco", " iroc", "pioco", "ioci", "lioc", "zioco", " iog", "diOC", "iioco", "bioc", "piroc", "dioci", "liocated", "iocated", "lioco", "iOC", "giog", "diocy", "gioc", "biOC", "iioc", " iocated", "liroc", "ziroc", " iOC"]}}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351, "substitutes": {"mount_point": ["mount_base", "mount_points", "mount_area", "mount_Point", "mount2point", "mount_prefix", "mount2points", "mounturepattern", " mount_pattern", "mountityarea", "mount_pattern", "mounturepoint", "mounturearea", " mount_prefix", "mounted_Point", "mountitypoint", " mount_area", " mount_Point", "mountitypattern", "mount2base", " mount_points", "mountitypoints", "mounted_point", "mounturepoints", " mount_base"], "path": ["dest", "data", "url", "to", "text", "th", "history", "walk", "file", "local", "link", "config", "kind", "context", "parent", "directory", "message", "Path", "full", "core", "cmd", "spec", "pkg", "patch", "key", "dir", "where", "mount", "port", "pod", "template", "time", "p", "chain", "doc", "pt", "name", "format", "root", "call", "route", "test", "pi", "id", "package", "here", "prefix", "part", "progress", "pattern", "PATH", "type", "form", "module", "index", "transform", "empty", "ath", "temp", "prop", "order", "self", "length", "binding"], "debugfs_found": ["debugfs_finder", "debugFS_Found", "debugfs2Found", "debugfs2find", "debugf_found", "debugf_Found", "debugFS_found", "debugbs_finder", "debugbs_Found", "debugf_find", "debugf2Found", "debugfs2found", "debugbs_found", "debugfs_loaded", "debugFS_loaded", "debugfs_Found", "debugf2find", "debugf2found", "debugfs_find"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A1 = 0xffff<<14, A2= 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A1 = 0xffff<<14, A2 = 0xffff<<14;\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24356, "substitutes": {"ubuf0": ["abbuf8", "ubbuff8", "ubimg1", "abbuf3", "ubuffer2", "ubbufSpec", "ubbuf3", "ubufferSpec", "ubbuf2", "ubbuf1", "abufSpec", "ubbuf8", "ubuffer0", "abbuf1", "ubimg0", "abbuf0", "ubuff3", "ubuff8", "ubimg2", "abuf1", "ubbuff3", "ubbuff0", "ubbuff1", "ubimgSpec", "abuf3", "abuf2", "ubuff0", "ubufSpec", "ubuf2", "ubuffer1", "abbuf2", "ubuf8", "abuf8", "ubbuf0", "ubuf3", "abbufSpec", "abuf0", "ubuff1"], "vbuf0": ["vuf1", "bbuf0", "vfont1", "buf0", "vbur0", "vbuff0", "guf047", "vuf3", "vfont6", "vuffer1", "bbuf3", "vbuf6", "vuf0", "vuffer6", "gbuf1", "gbuf0", "vbur1", "vuf6", "vfont047", "buf1", "vbuff1", "vbuff3", "vuffer047", "guf0", "vbur3", "vuffer0", "guf1", "gbuf047", "bbuf1", "vfont0", "vbuf3", "guf6", "buf3", "vuf047", "vbuf047", "gbuf6"], "i": ["qi", "v", "n", "is", "k", "me", "li", "ij", "f", "ix", "xi", "ai", "go", "ini", "ji", "ami", "gi", "ci", "z", "ki", "info", "di", "ii", "t", "this", "mi", "ip", "oi", "ei", "cli", "sim", "ic", "m", "p", "multi", "status", "o", "chain", "ui", "ri", "name", "pi", "a", "id", "\u0438", "im", "uri", "h", "io", "iu", "l", "ish", "point", "ski", "span", "ti", "phi", "j", "index", "x", "c", "zi", "batch", "y", "it", "si", "bi", "ind", "I"], "R": ["SR", "Y", "W", "RR", "E", "L", "RF", "ER", "H", "r", "X", "U", "RM", "BR", "RC", "M", "RB", "TR", "D", "RT", "P", "N", "T", "NR", "RG", "RE", "A", "C", "V", "GR", "RGB", "HR", "DR", "Q", "RA", "RO", "I"], "G": ["Y", "W", "BG", "GD", "GP", "GI", "L", "Group", "GG", "GU", "H", "U", "PG", "GV", "M", "Graphics", "GC", "D", "Ge", "g", "VG", "GT", "RG", "Car", "GM", "C", "V", "GR", "Q", "GB", "LG", "GS", "Gu", "GA", "Gs"], "B": ["Bus", "Y", "W", "BL", "SB", "BG", "J", "S", "AB", "Bi", "L", "DB", "U", "BR", "VB", "M", "BU", "Bar", "BA", "D", "BB", "Bs", "P", "T", "BM", "N", "BC", "NB", "C", "V", "A", "GB", "LB", "BO", "BW", "BT"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364, "substitutes": {"v": ["sv", "cv", "vp", "n", "vis", "uv", "mint", "f", "it", "vm", "r", "b", "vr", "tv", "vv", "lv", "t", "vt", "conv", "o", "p", "m", "e", "g", "d", "view", "q", "ev", "V", "h", "s", "vs", "l", "av", "vc", "i", "j", "c", "x", "inv", "pr", "y", "vi", "ver", "w"], "obj": ["nt", "js", "ist", "obs", "ot", "inst", "ob", "og", "rb", "elt", "cmd", "info", "attr", "pkg", "objects", "act", "lib", "ref", "oid", "o", "off", "Object", "org", "nb", "px", "so", "bj", "Obj", " ob", "np", "tmp", "addr", "tk", "oj", "object", "inv", " Obj", "self", "ctx"], "name": ["ma", "data", "ann", "init", "n", "text", "named", " prefix", "na", "ext", "local", "ne", "NAME", "var", "ident", "an", "missing", "spec", "names", "path", "t", "comment", "key", "p", "str", "par", "id", "part", "prefix", "no", "error", "def", "s", " names", "nm", "word", "type", "ame", "alias", "normal", "Name", " Name", "w"], "errp": [" errps", "errpe", "errd", "errorpe", "errorP", " errP", "errorm", " errpe", "errps", "rrpa", "rrpe", "cerd", "cerp", "errm", " errpa", "rrps", "errorp", " errm", "errP", "rrp", "cerpa", "errpa", "rrd", " errd", "rrP", "errorps", "rrm"]}}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_mid_8w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3;\n\n    v16u8 out0, out1;\n\n\n\n    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    hz_out0 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n    hz_out1 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n    hz_out3 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n\n\n        hz_out5 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n        hz_out6 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n        hz_out7 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n        hz_out8 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst1 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst3 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n        out0 = PCKEV_XORI128_UB(dst0, dst1);\n\n        out1 = PCKEV_XORI128_UB(dst2, dst3);\n\n        ST8x4_UB(out0, out1, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out3 = hz_out7;\n\n        hz_out1 = hz_out5;\n\n        hz_out5 = hz_out4;\n\n        hz_out4 = hz_out8;\n\n        hz_out2 = hz_out6;\n\n        hz_out0 = hz_out5;\n\n    }\n\n}\n", "idx": 24368, "substitutes": {"src": ["dest", "pri", "url", "ipl", "tp", "sr", "in", "ser", "th", "host", "txt", "source", "rt", "ix", "inst", "rl", "lat", "tr", "hl", "loc", "supp", "fc", "usr", "std", "iv", "sec", "stack", "sb", "ins", "scan", "rx", "seek", "sub", "sl", "dist", "stream", "syn", "sync", "rs", "sc", "cur", "img", "rc", "st", "s", "ctr", "cont", "input", "tmp", "sys", "addr", "ptr", "sn", "raw"], "src_stride": ["src_decides", "src_strim", "src_STRite", "src_strine", "src_strate", "src_glide", "src_STRice", "src_grides", "src_strides", "src_slide", "src_Strate", "src_STRim", "src_decride", "src_STRade", "src_brride", "src_stade", "src_constide", "src_grine", "src_Strim", "src_gline", "src_strite", "src_Stride", "src_STRide", "src_glice", "src_constides", "src_brides", "src_STRride", "src_stides", "src_grade", "src_stide", "src_gride", "src_STRine", "src_bride", "src_slate", "src_STRides", "src_grride", "src_strice", "src_decide", "src_Strride", "src_STRate", "src_strride", "src_slride", "src_grice", "src_decite", "src_constride", "src_strade", "src_glade", "src_brade", "src_slim", "src_constite"], "dst": ["dnd", "dest", "Dest", "tnd", "Dnd", " ddest", "Dst", "Ddest", "tdest", " dnd", " dest", "tst", "test", "ddest"], "dst_stride": ["dst_glade", "dst_brade", "dst_decade", "dst_strade", "dst_decide", "dst_brride", "dst_brate", "dst_glide", "dst_strride", "dst_strate", "dst_glride", "dst_glate", "dst_bride", "dst_decride", "dst_decate"], "height": ["flow", "Height", "command", "frequency", "count", "scroll", "th", "ty", "history", "zh", "bottom", "show", "resolution", "tx", "read", "push", "padding", "draw", "hash", "chain", "buffer", "import", "rank", "check", "window", "loss", "depth", "here", "density", "size", "h", "grow", "capacity", "radius", "gravity", "ht", "scope", "y", "kw", "length", "ctx"], "loop_cnt": ["loop_cust", "loop2Cust", "loop_ccount", "loop2Ccount", "loop2cpt", "loop_acst", "loop_acount", "loop_cpt", "loop_Cst", "loop_Ccount", "loop_tount", "loop_Count", "loop_uncctr", "loop2Count", "loop_fcpt", "loop_tcount", "loop_acnt", "loop_Cnt", "loop_cctr", "loop_uncNT", "loop_Cust", "loop_account", "loop_cNT", "loop_Cpt", "loop_acpt", "loop_CNT", "loop2Cnt", "loop2ccount", "loop2count", "loop_fccount", "loop_fcnt", "loop2cst", "loop2cnt", "loop_fcst", "loop_uncpt", "loop_cst", "loop_count", "loop2cust", "loop_uncnt", "loop2Cst", "loop2Cpt", "loop_tust", "loop_Cctr", "loop_tnt", "loop_acust"], "src0": ["ser00", "source0", "ser1", "source1", "st0", "source00", "rc0", "inst0", "source3", " src5", " src02", "inst02", "src5", "src02", "ser2", "rc02", "source4", " src00", "src00", "st00", "source2", "st1", "rc00", "inst5", "rc4", "inst1", "rc3", "rc5", "ser0", "rc1", "rc2", "st2"], "src1": ["sys3", "source0", "ser1", "source1", "srcOne", "source11", "ser3", "rc0", "source3", "ser4", " src11", "sys4", "sys1", "sr0", "rc11", "sr1", "rcOne", "source01", "sys0", "dest3", "ser2", "source4", "dest0", "src01", "dest1", "src11", " src01", "source2", "sys2", "rc4", "sr4", "sr3", "sourceOne", "rc3", "ser0", "rc1", "rc2", "rc01", "dest2", " srcOne"], "src2": ["sys3", "source0", "ser1", "source1", "proc2", "rc0", "source3", "src6", "ser4", "proc6", " src02", "sys1", "proc3", "ser02", "source02", "src02", "sys0", "dest3", "rc02", "ser2", "source4", "sys6", "dest0", "proc1", "rc6", "dest1", "source2", "sys2", "rc4", "rc3", "rc1", "rc2", "dest2"], "src3": ["sys3", "source0", "source1", "sr003", "sourceant", "source03", "rc0", "source3", " src5", "sys1", " src03", "srcd", "rcant", " src003", "src5", "sr1", "srant", "source4", "source5", "source2", "sr03", "sys2", "sys03", "src03", "rc4", "sr4", "sr3", "src003", "rc3", "sourced", "rc5", "rc2", "rc1", "rcd", "rc03", "sr2", "srcant", "rc003", "srd"], "src4": ["source0", "source44", "source1", "rc44", "rc0", "source3", " src5", "src5", "dest3", "src44", "source4", "source5", "dest1", "source2", " src44", "dest4", "rc4", "rc3", "rc5", "rc1", "rc2", "dest2"], "mask0": ["shape8", " maskator", "mark0", "mask3", "flag1", "ask1", " mask50", "miss0", "weight3", "ask3", "flag2", "facING", "maskING", "shape1", "weight1", "miss3", " mask6", "Mask1", "fac0", "mask8", "Mask50", "flag0", "fac2", "cmd0", "miss2", "markator", "weight0", "ask6", "askator", "mark3", "mask50", "Mask8", "mask6", "cmdator", "shape50", " mask3", "mark2", "fac1", "Mask0", "shape0", "ask2", "miss1", "markING", "flag6", " mask8", "maskator", "askING", "ask0", "mark1", "weight2", "cmd1", "cmd2"], "mask1": ["mark1", "mask4", "map0", "mask3", "mark0", "missONE", "ask1", "map4", "miss0", "map6", "filter2", "ask3", "markONE", "broad1", "miss3", "filter0", "lock0", "miss2", "lock1", "lock6", "ask6", "mark3", "broad3", "mask6", "map1", " mask3", "maskONE", "mark2", "filter3", "ask4", "broadONE", "lock4", "ask2", "miss1", "broad2", "ask0", "filter1"], "mask2": ["mask4", "mask3", "mark0", "check1", "ask1", "ask05", "filter1", "miss0", "ask3", "mark6", "filter2", "broad1", "miss3", " mask6", "mark4", "mask05", "broad4", "miss2", "check2", "miss05", "ask6", "check3", "mark3", "broad05", "miss4", "mask6", " mask3", "filter4", "mark2", "filter3", "ask4", "ask2", "miss1", "check4", "broad2", "ask0", "mark1", " mask4"], "hz_out0": ["hz_int4", "hz_val1", "hz_no1", "hz_no4", "hz_val0", "hz_in6", "hz_no2", "hz_in1", "hz_in0", "hz_in4", "hz_in2", "hz_int0", "hz_int1", "hz_err6", "hz_val6", "hz_val2", "hz_int2", "hz_no0", "hz_err2", "hz_err0", "hz_err1"], "hz_out1": ["hz_objB", "hz_no3", "hz_outB", "hz_Out3", "hz_outOne", "hz_OutOne", "hz_no2", "hz_in1", "hz_obj2", "hz_obj3", "hz_in2", "hz_in3", "hz_obj1", "hz_inB", "hz_noB", "hz_Out1", "hz_inOne", "hz_no1"], "hz_out2": ["hz_result0", "hz_inner2", "hz_int5", "hz_OUT0", "hz_out02", "hz_OUT8", "hz_OUT5", "hz_off2", "hz_off02", "hz_inner4", "hz_inner3", "hz_int2", "hz_off4", "hz_off3", "hz_int8", "hz_result5", "hz_OUT2", "hz_result8", "hz_result2", "hz_int0", "hz_inner02"], "hz_out3": ["hz_key8", "hz_key7", "hz_key3", "hz_key6", "hz_OUT8", "hz_OUT5", "hz_result3", "hz_output7", "hz_output3", "hz_OUT7", "hz_result6", "hz_output4", "hz_OUT6", "hz_off7", "hz_OUT3", "hz_off4", "hz_off3", "hz_result8", "hz_result7", "hz_output5", "hz_OUT4", "hz_off5"], "hz_out4": ["hz_offFourth", "hz_off2", "hz_post4", "hz_post2", "hz_err4", "hz_in1", "hz_in4", "hz_in2", "hz_err3", "hz_post1", "hz_postFourth", "hz_off3", "hz_off4", "hz_outFourth", "hz_err2", "hz_inFourth", "hz_off1"], "hz_out5": ["hz_output0", "hz_option7", "hz_option5", "hz_off0", "hz_output7", "hz_option0", "hz_output1", "hz_off7", "hz_option1", "hz_output5", "hz_off5", "hz_off1"], "hz_out6": ["hz_output6", "hz_off2", "hz_result6", "hz_output4", "hz_result4", "hz_off6", "hz_output2", "hz_off4", "hz_result5", "hz_result2", "hz_output5", "hz_off5"], "hz_out7": ["hz_option7", "hz_output7", "hz_output1", "hz_off7", "hz_off3", "hz_option1", "hz_option3", "hz_output3", "hz_off1"], "hz_out8": ["hz_off8", "hz_OUT8", "hz_off11", "hz_OUT7", "hz_OUT6", "hz_out11", "hz_off7", "hz_off6", "hz_OUT11"], "dst0": ["dost4", "lest0", "dst5", "ddest1", "ddest4", "lest1", "dost1", "lst1", "lst5", "lest5", "dest0", "lest4", "dest1", "dost5", "lst0", "dest4", "dost0", "lst4", "ddest0", "dest5", "dst4", "ddest5"], "dst1": ["dstr4", "dist0", "dist1", " dst4", "dstr0", " dstr4", " dstr0", "dest0", "dest1", "dist4", "dstr2", "dstr1", "dest4", " dstr2", "dist2", " dstr1", "dest2", "dst4"], "dst2": ["idistTwo", "dst256", "idst256", "idist2", "idist256", "dstTwo", "idstTwo", "drestTwo", "dist256", "idst2", "dest256", "dist2", "drest256", "destTwo", "distTwo", "dest2", "drest2"], "dst3": [" dst6", "dest7", " dst7", "dest3", " dint7", "dnd7", "dnd6", "dnd2", "dint7", "dint6", "dst7", "dst6", "dint3", " dint6", "dnd3", " dint2", " dint3", "dest2", "dint2", "dest6"], "out0": [" outk", "ink", "in0", "in2", "result0", " out2", "out2", "in1", "outk", "resultk", "result1", "result2"], "out1": ["Out1", "out4", "out3", " out4", "output4", " out2", "out2", "Out4", " out3", "Out2", "output2", "output1", "Out3", "output3"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pam_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 24371, "substitutes": {"avctx": ["aftx", "avcontext", " avcmd", "aircmd", "airctx", " avtx", "afctx", "aircontext", "Avcmd", "wavtxt", "avcmd", " avtxt", "avtxt", "Avctx", "Avsys", "wavcontext", " avsys", "avsys", "wavtx", " avcontext", "Avcontext", "avtx", "airsys", "afcontext", "aftxt", "wavctx"]}}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)\n\n{\n\n    OggVorbisContext *context = avccontext->priv_data;\n\n    double cfreq;\n\n\n\n    if (avccontext->flags & CODEC_FLAG_QSCALE) {\n\n        /* variable bitrate */\n\n        if (vorbis_encode_setup_vbr(vi, avccontext->channels,\n\n                                    avccontext->sample_rate,\n\n                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))\n\n            return -1;\n\n    } else {\n\n        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;\n\n        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;\n\n\n\n        /* constant bitrate */\n\n        if (vorbis_encode_setup_managed(vi, avccontext->channels,\n\n                                        avccontext->sample_rate, minrate,\n\n                                        avccontext->bit_rate, maxrate))\n\n            return -1;\n\n\n\n        /* variable bitrate by estimate, disable slow rate management */\n\n        if (minrate == -1 && maxrate == -1)\n\n            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))\n\n                return -1;\n\n    }\n\n\n\n    /* cutoff frequency */\n\n    if (avccontext->cutoff > 0) {\n\n        cfreq = avccontext->cutoff / 1000.0;\n\n        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))\n\n            return -1;\n\n    }\n\n\n\n    if (context->iblock) {\n\n        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);\n\n    }\n\n\n\n    return vorbis_encode_setup_init(vi);\n\n}\n", "idx": 24375, "substitutes": {"vi": ["via", "v", "iri", "vp", "vis", "ve", "umi", "ive", "edi", "eni", "qv", "uv", "vision", "xi", "ai", "ami", "vin", "see", "activate", "ci", "Vi", "ku", "ki", "pin", "vre", "di", "can", "vo", "wiki", "verse", "voice", "iv", "vr", "ii", "mi", "vt", "oci", "mit", "cli", "ri", "avi", "jac", "voc", "vid", "pi", "vim", "VI", "vert", "vich", "av", "ti", "vc", "vy", "i", "wire", "bi", "ui"], "avccontext": ["avccanfig", "avcconttex", "avcelloncontext", "avctaytext", "avcusocontext", "avccantonstruct", "avckorestant", "avccroncurrent", "avctaycontext", "avccaontex", "avcconsnect", "avccoconect", "avccyntext", "avccocontex", "avcusonconnection", "avccontfig", "avcconcert", "avccondtext", "avccalassnect", "avccanstant", "avcconstem", "avCConfig", "avcconasole", "avccxonect", "avckonstant", "avccynsole", "avcconsject", "avccanoncontext", "avcconstruct", "avcconth", "avccynject", "avccocontext", "avccante", "avccoconconnection", "avncyntxt", "avccronth", "avcconject", "avcfonect", "avccaonnect", "avcconkey", "avccoconject", "avceonytext", "avcconstext", "avcellonfig", "avccrontxt", "avccrontex", "avccantontext", "avccxonfigure", "avceonect", "avCContcontext", "avcellanontext", "avclonstruct", "avclonclient", "avccronte", "avcellanonsole", "avccontkey", "avccontclient", "avccoontext", "avccoconsole", "avcconte", "avceontext", "avccynstant", "avccustomect", "avccntext", "avccencontext", "avcclasste", "avccontxt", "avccoconcert", "avccontcontext", "avccorestant", "avccoonclient", "avCConnect", "avcusocontex", "avccncontext", "avccatstem", "avcfoconcert", "avctonstant", "avcconttxt", "avncyntext", "avccalasstext", "avckoncontext", "avccanonect", "avccoconfig", "avcconsole", "avccancert", "avccantonclient", "avctronfig", "avcfonject", "avccaonte", "avaccondstant", "avaccontext", "avcconstant", "avctonect", "avCConcontext", "avccyntex", "avcfoconject", "avcconystem", "avccannect", "avceonyect", "avcconect", "avccoretex", "avcconconnection", "avcconakey", "avccondsole", "avcconystant", "avckoretext", "avcelloconsole", "avclonsole", "avccaconth", "avcloonclient", "avccanoncurrent", "avncyntex", "avcconnect", "avccaycontext", "avncontxt", "avctayect", "avccattext", "avcellanontxt", "avccronect", "avcconsect", "avccronstant", "avcloontext", "avceonstem", "avccynload", "avckoretex", "avccaconload", "avccondstant", "avccontsole", "avccatect", "avccorecontext", "avccontnect", "avcconfig", "avccxonstem", "avccronject", "avccustomcert", "avccoconcontext", "avcconytex", "avccantext", "avcellanonth", "avcusoconconnection", "avccontstant", "avctonfig", "avcusoconcontext", "avceonyfigure", "avcconload", "avccnnect", "avcclasstex", "avckonect", "avcellonth", "avccondct", "avccaystant", "avckoconect", "avcellanonstant", "avcellonsole", "avcconct", "avccenconnection", "avccoonstruct", "avcconcontext", "avcellanoncontext", "avcusontext", "avcellonject", "avncontex", "avcellontext", "avccnfig", "avccanonkey", "avccantonsole", "avccontload", "avclontext", "avccaconstant", "avckocontext", "avccayect", "avaccondsole", "avccynfig", "avcconfigure", "avacconct", "avccoconcurrent", "avacconstant", "avccronfig", "avccalasste", "avcfontext", "avcconclient", "avccoonsole", "avccynct", "avcellonkey", "avcfoconect", "avctoncontext", "avccacontext", "avccalasstex", "avckoncurrent", "avaccondct", "avcconscontext", "avckoconcurrent", "avccaontext", "avccontconnection", "avcconsstant", "avcellocontext", "avcusoncontext", "avcconsfig", "avccanonject", "avckontex", "avCContext", "avctronstant", "avccanonstant", "avccoretext", "avcclassnect", "avccronct", "avccustomject", "avccanect", "avcloonstruct", "avctaystant", "avcconatext", "avcconyfigure", "avcellonstant", "avccustomtext", "avcconycontext", "avccacontxt", "avccronnect", "avccacontex", "avccentext", "avctronect", "avCContfig", "avccatfigure", "avcclasstext", "avcellontxt", "avcconttext", "avncontext", "avckoconject", "avcconytext", "avccxontext", "avcconyect", "avccentex", "avCContnect", "avcconcurrent", "avccrontext", "avcellanonkey", "avcelloconfig", "avcconssole", "avccantex", "avccaytext", "avckontext", "avctrontext", "avccontex", "avceonystem", "avccyntxt", "avacconsole", "avaccondtext", "avccanject", "avctontext", "avccanontxt", "avckorecontext", "avckonject", "avccontstruct", "avcconacontext", "avcfocontext", "avncynload", "avcloonsole", "avceonfigure", "avcfoncert", "avccontect", "avCConttext", "avnconload", "avccanonsole", "avcusontex", "avcelloconject", "avccronsole", "avccanonth", "avccanontext"], "context": ["command", "data", "text", "profile", "history", "host", "local", "content", "config", "parent", "tx", "event", "instance", "mc", "info", "address", "information", "options", "metadata", "component", "man", "contact", "translation", "chain", "function", "connection", "buffer", "cc", "cf", "environment", "kernel", "check", "package", "engine", "reference", "window", "location", "capacity", "Context", "condition", "language", "document", "module", "index", "c", "support", "network", "interface", "ctx"], "cfreq": ["cfqq", " cfrequ", "lfq", " cfqq", "czrequ", "czrr", "cfq", "czq", " cfrr", " cfrequest", "cfrequire", "czqq", "fcrequ", "czrequire", "cfrequ", "cloudrequ", "fcreq", "lfrequ", "fcrr", "fwq", "cfrr", "fwreq", "cloudrequire", "cfrequest", "cloudqq", " cfrequire", "lfrequest", "czrequest", "fwrequ", "cloudreq", "fwrequest", "fcrequest", "lfreq", "czreq"]}}
{"project": "FFmpeg", "commit_id": "439c3d5bcc4a4560eaf5fd43c6e156e3d9bc42f2", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                        const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    NellyMoserEncodeContext *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n\n\n    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));\n\n    if (frame) {\n\n        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],\n\n               frame->nb_samples * sizeof(*s->buf));\n\n        if (frame->nb_samples < NELLY_SAMPLES) {\n\n            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,\n\n                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));\n\n            if (frame->nb_samples >= NELLY_BUF_LEN)\n\n                s->last_frame = 1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))\n\n            return ret;\n\n    } else {\n\n        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));\n\n        s->last_frame = 1;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n    encode_block(s, avpkt->data, avpkt->size);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 24400, "substitutes": {"avctx": ["avejac", "apconn", "wavconn", "avercontext", "abtx", "aftx", "averctx", " avctrl", "avcontext", "vrcontext", "vrctx", "wavcu", "apcontext", " avtx", " avconn", "iverctx", "afctx", "aucontext", "auconn", "avercu", "ivercontext", " avpkg", "auctx", "avctrl", "iverconn", "iverctrl", " avcu", "abpkg", "wavctx", "avjac", "apctrl", "aucu", "ajjac", "avecontext", "afpkg", " avjac", "vrcu", "ajcu", "avpkg", "avconn", "ajcontext", "wavcontext", "avecu", "abcontext", "ajctx", "averconn", " avcontext", "vrconn", "avtx", "afcontext", "apctx", "avectx", "abctx", "avcu"], "avpkt": ["avvkg", "avhet", "avckt", "avphpwk", "averpingett", "avpaoint", "avtpet", "avpadkt", "campackett", "avpakt", "ahpwk", "avwpft", "averpqt", "avpodacket", "avcet", "avepft", "avcpkat", "avtpkat", "ahpkt", "campackacket", "averpingcht", "afckt", "ahphpwk", " avpett", "avpett", "campacket", "avhkt", "avoptxt", "avpwk", "avpet", "aveopacket", "avpackkt", "avmett", "afcelt", "aveopkt", "campkg", "avvett", "avpadqt", "avphpkat", "campackkg", "avpackett", "avpacket", "avcpet", " avpgt", "avwptxt", "avmkt", "afpelt", "avcompoint", "afcet", "campett", "avwpkt", "avpingkt", "avcpkt", "avckg", "avjkt", "avcompgt", "avpft", "avpackkg", "avpgt", "avpagt", "avpkat", "avcett", "avpingcht", " avPkt", "avepacket", "avopacket", "ahphpkt", "campackkt", "campkt", "avpingett", "avpadett", "avjft", "avvacket", "avopkt", "ahphpet", "avpodft", "ahpkat", "avpackacket", "avwpacket", "avpkg", "avcompett", "avopft", "avtpwk", "averpingkt", "avjet", "avphpet", "avpelt", "avpcht", "avcompkt", "avpadcht", "avcft", "afpet", "avpqt", "avpodkt", "avtpkt", "afcft", "avpaett", "avptxt", "avhelt", "avjelt", " avPoint", "avcelt", "avphpkt", "avmqt", "avcpwk", "aveoptxt", " avpoint", "averpkt", "ahphpkat", " avPgt", "ahpet", "averpett", "avpoint", "avmcht", "avvkt", "avPgt", "avPett", "averpingqt", " avPett", "avPoint", "avpodtxt", "avepkt", "avhft", "avpingqt", "afpkt", "aveptxt", "avcacket", "avPkt", "averpcht", "aveopft", "afpft"], "frame": ["flow", "data", "iframe", "video", "request", "command", "scene", "face", "profile", "me", "fr", "range", "rame", "next", "channel", "file", "feature", "show", " Frame", "f", "frames", "context", "event", "ce", "message", "r", "ime", "process", "state", "info", "block", "xf", "feat", "fw", "fram", "image", "sequence", "sample", "new", "component", "zone", "movie", "version", "draw", "time", "e", "header", "function", "chain", "cf", "style", "framework", "from", "call", "response", "window", "fb", "trace", "error", "ence", "close", "force", "point", "fe", "row", "word", "one", "field", "object", "normal", "Frame"], "got_packet_ptr": ["got_packkt_ptr", "got_packacket2pointer", "got_packacket_pointer", "got_packet_pointer", "got_packkt_pointer", "got_packacket2ptr", "got_packacket2obj", "got_packacket_obj", "got_packet2obj", "got_packet_addr", "got_packet2ptr", "got_packkt_addr", "got_packacket2addr", "got_packacket_ptr", "got_packacket_addr", "got_packet2Ptr", "got_packet_obj", "got_packet2addr", "got_packet2pointer", "got_packkt_Ptr", "got_packet_Ptr"], "s": ["sv", "ex", "bits", "gs", "ms", "changes", "services", "b", "parts", "aws", "ls", "ains", "scl", "ges", "rs", "sc", "as", "conf", "us", "als", "i", "c", "y", "ps", "results", "set", "n", "bis", "ers", "fs", "ns", "ts", "has", "se", "ssl", "less", "sb", "ins", "os", "es", "ies", "vs", "stats", "sts", "hs", "is", "ss", "spec", "cs", "ats", "m", "comm", "simple", "ds", "ares", "tes", "l", "sys", "alls", "sq", "iss", "js", "S", "qs", "gets", "ims", "lines", "g", "sl", "ows", "sw", "ess", "acs", "h", "bs", "its", "xs", "uns", "utils", "self"], "ret": ["nt", "rem", "res", "virtual", "result", "red", "final", "del", "ext", "txt", "val", "print", "ll", "rt", "f", "rets", "mel", "det", "tr", "reset", "elt", "cert", "reg", " Ret", "pas", "ry", "new", "t", "len", "fun", "ref", "deg", "ft", "compl", "str", "gt", "status", "Ret", "out", "rm", "pret", "fit", "mt", "RET", "flag", "value", "att", "def", "try", "resp", "cont", "back", "alt", "re", "it", "err", "lit"]}}
{"project": "FFmpeg", "commit_id": "7167bc94cb695a3027aea6aac34a1b040848c7dc", "target": 1, "func": "static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n\n{\n\n    IndividualChannelStream *ics = &sce->ics;\n\n    float *in    = sce->coeffs;\n\n    float *out   = sce->ret;\n\n    float *saved = sce->saved;\n\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    float *buf  = ac->buf_mdct;\n\n    float *temp = ac->temp;\n\n    int i;\n\n\n\n    // imdct\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)\n\n            av_log(ac->avctx, AV_LOG_WARNING,\n\n                   \"Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. \"\n\n                   \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\");\n\n        for (i = 0; i < 1024; i += 128)\n\n            ff_imdct_half(&ac->mdct_small, buf + i, in + i);\n\n    } else\n\n        ff_imdct_half(&ac->mdct, buf, in);\n\n\n\n    /* window overlapping\n\n     * NOTE: To simplify the overlapping code, all 'meaningless' short to long\n\n     * and long to short transitions are considered to be short to short\n\n     * transitions. This leaves just two cases (long to long and short to short)\n\n     * with a little special sauce for EIGHT_SHORT_SEQUENCE.\n\n     */\n\n    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&\n\n            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {\n\n        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n\n    } else {\n\n        for (i = 0; i < 448; i++)\n\n            out[i] = saved[i] + bias;\n\n\n\n        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n\n        } else {\n\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n\n            for (i = 576; i < 1024; i++)\n\n                out[i] = buf[i-512] + bias;\n\n        }\n\n    }\n\n\n\n    // buffer update\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        for (i = 0; i < 64; i++)\n\n            saved[i] = temp[64 + i] - bias;\n\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else { // LONG_STOP or ONLY_LONG\n\n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n\n    }\n\n}\n", "idx": 24424, "substitutes": {"ac": ["acl", "ap", "iac", "pc", "acc", "cache", "cam", "gc", "oc", "cas", "AC", "ctx", "anc", "aci", "aq", "am", "sac", "ack", "ace", "mc", "fc", "bc", "ica", "act", "dc", "cs", "cu", "fac", "mac", "rac", "auc", "ec", "ic", "comm", "aco", "cc", "jac", "ach", "ak", "ct", "ab", "ad", "pac", "acer", "acs", "aic", "tc", "c", "unc", "abc", "Ac"], "sce": ["msse", "mske", "ssce", "jske", "sscle", "jscle", "osce", "sCE", "nce", " ske", " sse", "jsCE", "desCE", "desce", " sces", "nscle", "Sces", " spe", "sced", "ssced", "descle", "npe", "desces", "ncle", "Scle", "sces", "msce", " scle", "nse", "nsse", "osces", "deske", "nspe", "Sse", "oscle", "Sce", "desse", "nsce", "ske", "spe", "ssces", "jsce", "sse", "msced", " sced", "scle", "osced"], "bias": ["sbases", "Bii", "lase", "rbade", " baid", " bac", "bases", "lases", "rbac", "ambias", "maos", "ambii", "sbias", " bade", "bade", "rbaid", "ambaos", "blias", "mias", "blaid", "baid", "bii", "mase", "Base", "Baos", "bac", "dias", "dases", "blac", "base", "dau", "lias", "ambase", "dase", "sbau", "baos", "blade", "sbase", "Bias", "bau", "lau", "rbias", "mii"], "ics": ["ips", "xes", "ands", "is", "ars", "ms", "icks", "cons", "fs", "ICS", "onics", "mic", "ns", "ix", "iques", "icing", "ives", "actions", "icons", "mc", "iris", "amps", "ts", " ic", "qs", "checks", "ick", "his", "cs", "ires", "oms", "ats", "cus", "uses", "rics", "ic", "ins", "irs", "ims", "inks", "fps", "atics", "irc", "icc", "terms", "nic", "ents", "nuts", "eric", "ices", "acs", "icates", "IC", "aic", "aps", "sys", "ints", "ris", "stats", "bs", "ads", "atts", "its", "xs", "ians", "ists", "phones", "icals", "caps", "ik", "iers", "css", "tis"], "in": ["qi", "init", "ex", "nin", "iter", "In", "val", "into", "mem", "din", "gin", "isin", "ini", "vin", "rin", "pin", "info", "len", "mi", "bin", "inf", "ref", "add", "ins", "mm", "m", "en", "oin", "min", "id", "inn", "input", "inc", "it", "inner", "IN", "ind", "raw"], "out": ["nt", "data", "v", "to", "output", "n", "res", "ex", "result", "cache", "final", "ot", "end", "f", "ret", "mem", "ou", "b", "r", "OUT", "at", "new", "t", "ref", "o", "p", "all", "buffer", "off", "outs", "Out", "list", "up", "io", "tmp", "batch", "pos", "it", "ch", "set", "w"], "saved": ["Saved", "Save", "morted", "unsaves", "unsaved", "daves", "assaled", "jsaving", "jsave", "Saves", "daved", "assave", "sorted", " save", "dave", "save", "assaved", "unsave", "unsaving", "jsaves", "mave", "Sorted", " saled", " saving", "maves", "maved", "saves", " saves", " sorted", "saving", "assaving", "daving", "jsaved", "Saving", "unsaled", "saled"], "swindow": ["swandowe", "swinkowe", "swandow", "swidthowe", "swidthow", "swinkew", "twandowe", "twandew", "swandew", "twindow", "swidthew", "swindew", "swindox", "swidthox", "swinkox", "twandow", "twindox", "twandox", "swinkow", "twindew", "swandox", "swindowe", "twindowe"], "lwindow_prev": ["lwindow_next", "lwindow_orig", "lwindow2last", "lwindow_last", "lwindow2next", "lwindow_pre", "lwindow2pre", "lwindow2prev"], "swindow_prev": ["swindow_tmp", "swindew_tmp", "swindew_prev", "swindow_orig", "swindow_pre", "swindew_pre", "swindew_orig"], "buf": ["limit", "init", "cache", "cv", "cam", "iter", "txt", " vec", "mem", "lim", "seq", "buff", "cb", "var", "vec", "rb", "box", "cmd", "pool", "block", "pkg", "bc", "len", "BU", "uf", "bin", "conv", "uc", "buffer", "off", "queue", "rw", "window", "memory", "Buffer", "img", "Buff", "tmp", "cap", "wb", "ff", "batch", "proc", "msg", "alloc", "xff", "raw"], "temp": ["dest", "cache", "v", "rem", "acc", "emp", "hum", "mint", "mem", "strength", "em", "current", "water", "tem", "t", "Temp", "fac", "tm", "mm", "m", "deg", "buffer", "pt", "dev", "pi", "unit", "height", "num", "tmp", "tc", "cap", "tim", "pos", "dim", "kw", "test", "w"], "i": ["qi", "ix", "xi", "ami", "ii", "ip", "ei", "p", "e", "spin", " v", "id", "io", "s", "us", "zi", "y", "ind", "I", " ki", "iter", "ci", "di", " x", "u", "pi", "iu", " ti", " e", "phi", "init", " j", "is", "iq", "me", "ij", "f", "ini", "gi", "cli", "ic", "sim", "m", "multi", "ri", "remote", " ii", " l", "\u0438", "im", " pi", "j", "index", "si", "Xi", "li", " ni", "ai", "ji", "ki", "info", "t", "mi", " m", "ims", "o", "g", "q", "uri", "point", "ti", "x", "it", "ui"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->avg_pixels_tab[0][0] = avg_pixels16_axp;\n\n    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;\n\n    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;\n\n    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;\n\n    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->put_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_pixels_tab[1][1] = put_pixels_x2_axp;\n\n    c->put_pixels_tab[1][2] = put_pixels_y2_axp;\n\n    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;\n\n\n\n    c->avg_pixels_tab[1][0] = avg_pixels_axp;\n\n    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;\n\n    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;\n\n    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;\n\n    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;\n\n\n\n    c->clear_blocks = clear_blocks_axp;\n\n    }\n\n\n\n    /* amask clears all bits that correspond to present features.  */\n\n    if (amask(AMASK_MVI) == 0) {\n\n        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;\n\n        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;\n\n\n\n        if (!high_bit_depth)\n\n            c->get_pixels   = get_pixels_mvi;\n\n        c->diff_pixels      = diff_pixels_mvi;\n\n        c->sad[0]           = pix_abs16x16_mvi_asm;\n\n        c->sad[1]           = pix_abs8x8_mvi;\n\n        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;\n\n        c->pix_abs[1][0]    = pix_abs8x8_mvi;\n\n        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;\n\n        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;\n\n        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;\n\n    }\n\n\n\n    put_pixels_clamped_axp_p = c->put_pixels_clamped;\n\n    add_pixels_clamped_axp_p = c->add_pixels_clamped;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {\n\n        c->idct_put = ff_simple_idct_put_axp;\n\n        c->idct_add = ff_simple_idct_add_axp;\n\n        c->idct =     ff_simple_idct_axp;\n\n    }\n\n}\n", "idx": 24426, "substitutes": {"c": ["ca", "v", "pc", "cl", "cache", "cam", "co", "gc", "anc", "f", "comp", "config", "cb", "cr", "b", "lc", "ci", "mc", "fc", "ce", "nc", "can", "xc", "bc", "dc", "cs", "t", "cu", "ac", "w", "uc", "ec", "ic", "unc", "p", "e", "m", "chain", "g", "cc", "com", "d", "ct", "cp", "call", "pi", "check", "enc", "sc", "C", "con", "rc", "st", "l", "cont", "conf", "tc", "vc", "cm", "etc", "abc", "ch", "ctx"], "avctx": ["AVco", "vctx", "averctx", "avercontext", "avcontext", " avconn", "AVconn", "AVctx", "AVcontext", "vcontext", "avtc", "avco", " avtc", "avertc", "averco", "vtc", "avconn", " avco", "vconn", "averconn", " avcontext"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "static char *check_nan_suffix(char *s)\n\n{\n\n    char *start = s;\n\n\n\n    if (*s++ != '(')\n\n        return start;\n\n\n\n    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\n           (*s >= '0' && *s <= '9') ||  *s == '_')\n\n        s++;\n\n\n\n    return *s == ')' ? s + 1 : start;\n\n}\n", "idx": 24433, "substitutes": {"s": ["sv", "gs", "ms", "ix", "b", "pers", "p", "status", "ls", "rs", "sets", "as", "i", "c", "sym", "y", "ps", "w", "n", "ars", "fs", "ns", "ar", "ts", "has", "south", "less", "sb", "ins", "d", "os", "es", "a", "stats", "sts", "ports", "args", "hs", "is", "f", "ss", "r", "z", "an", "cs", "ats", "times", "m", "comm", "ds", "ares", "tes", "search", "l", "sys", "sq", "si", "v", "res", "js", "S", "sp", "gins", "qs", "sol", "t", "single", "gets", "ims", "g", "sl", "ess", "h", "span", "its", "xs", "uns"], "start": ["init", "first", "v", "stop", "star", "offset", "next", "sp", "end", "join", "Start", "step", "trans", "starting", "state", "new", "art", "started", "key", "before", "p", "str", "name", "g", "d", "arts", "q", "list", "id", "part", "base", "error", "value", "st", "tmp", "span", "i", "j", "index", "rest", "it", "begin", "length"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\n\n    long i;\n\n#if !HAVE_FAST_UNALIGNED\n\n    if((long)src2 & (sizeof(long)-1)){\n\n        for(i=0; i+7<w; i+=8){\n\n            dst[i+0] = src1[i+0]-src2[i+0];\n\n            dst[i+1] = src1[i+1]-src2[i+1];\n\n            dst[i+2] = src1[i+2]-src2[i+2];\n\n            dst[i+3] = src1[i+3]-src2[i+3];\n\n            dst[i+4] = src1[i+4]-src2[i+4];\n\n            dst[i+5] = src1[i+5]-src2[i+5];\n\n            dst[i+6] = src1[i+6]-src2[i+6];\n\n            dst[i+7] = src1[i+7]-src2[i+7];\n\n        }\n\n    }else\n\n#endif\n\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n\n        long a = *(long*)(src1+i);\n\n        long b = *(long*)(src2+i);\n\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n\n    }\n\n    for(; i<w; i++)\n\n        dst[i+0] = src1[i+0]-src2[i+0];\n\n}\n", "idx": 24472, "substitutes": {"dst": ["Dpt", "redct", "dsl", "dlst", "dlsl", "dpt", "drald", "dsst", "disdest", "bdbsp", " dest", "redst", "Dbl", "tddest", "DST", "tdst", " ddest", " dct", " dstart", " dist", "dset", " dput", "dest", "drastop", "dsbl", "dlld", "dentry", " dsee", "sdbl", "dhport", "dbl", "Dv", " dcr", "dstart", "donedest", "drabsp", "tdpt", "disbsp", "dhdest", "dastart", "daist", "bdport", "dST", "redist", "donestop", "dacr", "dcr", "dld", "donesl", "dsee", "dhst", "dbsp", "drabl", "sdst", "dput", "dv", "Dist", "dradest", "disport", "dsput", "donesee", "dsST", "Dct", "delcr", "draport", "dport", "dsv", "drasl", "deldest", "tdest", "disst", "dabsp", "redbsp", "dsct", "doneld", "dsset", "Dput", "drast", "dact", " dbl", "Dst", "delstart", "dasee", "bdbl", "dast", " dpt", "sdST", "donebsp", "sdset", "delst", "Dset", "bdst", "dct", " dbsp", " dport", "draentry", "ddest", "dhentry", "Dest", "dist", "dadest", " dentry", "donest", "dlstop", "dstop", "dsest", " dv", "Ddest", "dsist"], "src1": ["source0", "usr1", "source1", " src0", "srcOne", " src001", "attr1", "attr2", " src3", "attrOne", "proc2", "rc0", "inst0", "usrOne", "usc2", "uscOne", "rcone", "rc001", "proc3", "inst2", "sourceone", "rcOne", "src0", "proc1", "srcone", "instOne", "src001", "src01", "usc1", " srcone", " src01", "source2", "usr001", "instone", "inst1", "sourceOne", "usr2", "src3", "rc3", "rc1", "rc2", "rc01", "proc01", " srcOne", "source01"], "src2": ["rcserver", "secure02", " src3", "srcTwo", "usc2", "ripp1", "rcb", "srcserver", "sur1", "src9", "ser2", "rc02", "ripp9", "srclib", "sourceb", "proc1", "iv6", "sur02", "secure6", "stock22", "src3", "rcTwo", "stock2", "cur4", "cmd2", "procb", "source1", " src0", "func4", "rc0", "rc14", "priv1", "secure1", " src4", "rclib", "src0", "iv2", "stocklib", "source6", "srcb", "cur2", "rc3", "usclib", "sync2", "iv1", "source0", "ripp2", "priv14", "src22", "secure2", "sur2", "ser3", "sync1", " src02", "surserver", "cur1", "func2", "src14", "usc22", " srcserver", " src9", "stock1", " srcTwo", "sync42", "rc22", "proc0", "secure4", "src4", "priv2", "ser1", "cmd14", "proc2", "source3", "iv42", "ripp02", "src6", "src02", "source4", "rc6", "usc1", "sync6", "source2", "rc42", "rc4", "src42", "rc9", "func1", "rc1", "rc2", "serTwo", "cmd1"], "w": ["v", "we", "n", "W", "wr", "wp", "week", "wa", "wx", "f", "wl", "r", "z", "len", "win", "m", "hw", "p", "wal", "wh", "wi", "d", "nw", "sw", "rw", "ew", "window", " W", "h", "wt", "l", "iw", "word", "wb", "wait", "c", "x", "y", "kw"], "i": ["qi", " I", "yi", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "p", "e", "status", "id", "io", "zi", "y", "bi", "ind", "I", "er", "n", "k", "iter", "json", "ci", "di", "um", "iii", "u", "pi", "os", "iu", "iy", "fi", " ti", "phi", "init", "ir", " j", "is", "me", "ij", "f", "ini", "gi", "hi", "this", " bi", "cli", "ic", "sim", "m", "multi", "ri", "chain", " ii", "\u0438", "im", "try", "l", "ia", "j", "index", "si", "ma", "iri", "v", "gu", " err", "in", "li", " ni", "source", "ai", "go", "ji", "ki", "info", "at", "mi", "key", "ims", "o", "ni", "g", "name", "q", "list", "uri", "h", "err", "ti", "batch", "x", "it", "asi", "ui"]}}
{"project": "FFmpeg", "commit_id": "cb85779d459c6486acbbf060b3f169779424583e", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    DPXContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr[AV_NUM_DATA_POINTERS];\n\n\n\n    unsigned int offset;\n\n    int magic_num, endian;\n\n    int x, y, i, ret;\n\n    int w, h, bits_per_color, descriptor, elements, packing, total_size;\n\n\n\n    unsigned int rgbBuffer = 0;\n\n    int n_datum = 0;\n\n\n\n    if (avpkt->size <= 1634) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small for DPX header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_num = AV_RB32(buf);\n\n    buf += 4;\n\n\n\n    /* Check if the files \"magic number\" is \"SDPX\" which means it uses\n\n     * big-endian or XPDS which is for little-endian files */\n\n    if (magic_num == AV_RL32(\"SDPX\")) {\n\n        endian = 0;\n\n    } else if (magic_num == AV_RB32(\"SDPX\")) {\n\n        endian = 1;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"DPX marker not found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    offset = read32(&buf, endian);\n\n    if (avpkt->size <= offset) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid data start offset\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    // Need to end in 0x304 offset from start of file\n\n    buf = avpkt->data + 0x304;\n\n    w = read32(&buf, endian);\n\n    h = read32(&buf, endian);\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    // Need to end in 0x320 to read the descriptor\n\n    buf += 20;\n\n    descriptor = buf[0];\n\n\n\n    // Need to end in 0x323 to read the bits per color\n\n    buf += 3;\n\n    avctx->bits_per_raw_sample =\n\n    bits_per_color = buf[0];\n\n    buf++;\n\n    packing = *((uint16_t*)buf);\n\n\n\n    buf += 824;\n\n    avctx->sample_aspect_ratio.num = read32(&buf, endian);\n\n    avctx->sample_aspect_ratio.den = read32(&buf, endian);\n\n    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)\n\n        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,\n\n                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,\n\n                  0x10000);\n\n    else\n\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n\n\n    switch (descriptor) {\n\n        case 51: // RGBA\n\n            elements = 4;\n\n            break;\n\n        case 50: // RGB\n\n            elements = 3;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported descriptor %d\\n\", descriptor);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (bits_per_color) {\n\n        case 8:\n\n            if (elements == 4) {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            }\n\n            total_size = avctx->width * avctx->height * elements;\n\n            break;\n\n        case 10:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 32bit required\\n\");\n\n                return -1;\n\n            }\n\n            avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n\n            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;\n\n            break;\n\n        case 12:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 16bit required\\n\");\n\n                return -1;\n\n            }\n\n            if (endian) {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        case 16:\n\n            if (endian) {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;\n\n            } else {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported color depth : %d\\n\", bits_per_color);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n    if ((ret = ff_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    // Move pointer to offset from start of file\n\n    buf =  avpkt->data + offset;\n\n\n\n    for (i=0; i<AV_NUM_DATA_POINTERS; i++)\n\n        ptr[i] = p->data[i];\n\n\n\n    if (total_size > avpkt->size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Overread buffer. Invalid header?\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (bits_per_color) {\n\n    case 10:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[0]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[1]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                // For 10 bit, ignore alpha\n\n                if (elements == 4)\n\n                    read10in32(&buf, &rgbBuffer,\n\n                               &n_datum, endian);\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 12:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2] = *((uint16_t*)buf);\n\n                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);\n\n                dst[2]++;\n\n                buf += 2;\n\n                *dst[0] = *((uint16_t*)buf);\n\n                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);\n\n                dst[0]++;\n\n                buf += 2;\n\n                *dst[1] = *((uint16_t*)buf);\n\n                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);\n\n                dst[1]++;\n\n                buf += 2;\n\n                // For 12 bit, ignore alpha\n\n                if (elements == 4)\n\n                    buf += 2;\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 16:\n\n        elements *= 2;\n\n    case 8:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            memcpy(ptr[0], buf, elements*avctx->width);\n\n            ptr[0] += p->linesize[0];\n\n            buf += elements*avctx->width;\n\n        }\n\n        break;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 24478, "substitutes": {"avctx": ["avertmp", "cvctx", "wavpkg", "avecp", "awpkg", "aveobj", "afcmp", "averobj", "abcp", "vrtc", "wavcmp", "avecontext", "avercp", "ajpkg", "navcp", "avertx", "averpkg", "vrcontext", " avtx", " avconn", "ajsys", "avetx", "navctx", "avercmp", "avtxt", "avetxt", "vrtx", "wavjac", "avsys", "abcontext", "abcmp", "wavsys", "avtmp", "cvconn", " avcontext", "avetc", "vrconn", "avertxt", "avtx", "awconn", " avcmp", "afctl", "avctl", "wavcp", "afcp", "abctx", "wavctx", "abtx", "aftx", "avcontext", "verctx", "vrctx", "afctx", "abtmp", "avcmd", "vrcmp", "avecmd", "awcmd", "cvtx", "avobj", "verconn", "ajjac", "afpkg", "avpkg", "avconn", "averctl", "cvcontext", "vercontext", "vertx", "abcmd", "avcp", "avcmp", "aveconn", "awjac", "averctx", "awsys", "avecmp", "avtc", "avectl", "aftmp", " avtc", "abconn", "abpkg", "avjac", "awctx", "navtxt", "navobj", "ajctx", "awcp", "avectx"], "data": ["DATA", "video", "bits", "to", "cache", "text", "page", "next", "frame", "Data", "raw", "file", "family", "images", "action", "query", "policy", "message", "reader", "read", "info", "bytes", "current", "image", "area", "t", "sample", "padding", "bin", "o", "m", "buffer", "dat", "name", "device", "format", "pic", "d", "rel", "pad", "a", "response", "window", "package", "table", "id", "error", "size", "value", "share", "pointer", "input", "record", "type", "start", "original", "batch", "empty", "media", "ata", "root", "length"], "got_frame": ["got2frame", "got2state", "received_state", "got2time", "got2frames", "got___time", "got_state", "got___frames", "got___state", "received_frames", "received_time", "got___frame", "got_time", "got_frames", "received_frame"], "avpkt": ["avpatacket", "avcpdr", "avckt", "avepkg", "avedpt", "avpck", "avecct", "avpakt", "iverpatkin", " avppt", "avmck", "avPdr", "iverpkt", "avedkg", "avcpkat", "iverpatacket", "avepct", "avdct", "avcpct", "avndr", "avPet", "avepett", "avPkin", "aveppt", "avpatkt", "avPct", "avpett", "iverpatck", "avpet", "avwpds", " avpet", "iverpacket", "iverpck", "avpatck", "avmkin", "aveckt", "avpct", "avpacket", "iverpkin", "avcpet", "avdkg", "avmkt", "avbpacket", "avdkt", "avpakat", "avecett", "avwpkt", "avcpkt", "avecpck", " avcpacket", "avwpct", "avwpck", "avbpkt", "avpkat", "avcppt", "avcett", "avepacket", "avcct", "avbppt", " avpdr", "avdpt", "avpdr", " avcpkt", "avepkat", " avpds", "avnet", "avPck", "avcpds", "avckat", "avcpacket", "avwpacket", "avpkg", "avecpacket", "avepck", "avpatkin", " avpacket", "avbpds", "avedct", "avwppt", "iverpatkt", "avcpett", "aveckat", " avcpds", "avpaett", "avnacket", "avnkt", "avpact", " avcpdr", "avcpkg", "avedkt", "avcpck", "avppt", "avPacket", "avwpkg", "avepkt", "avpkin", "avecpkt", "avPkt", " avcppt", "avecpct", "avmacket", " avcpet", "avpds"], "buf": ["far", "obj", "zero", "txt", "aux", "after", "buff", "cb", "b", "read", "box", "cmd", "pkg", "pg", "func", "len", "ref", "off", "important", "queue", "window", "Buffer", "def", "np", "packed", "pb", "ff", "begin", "emb", "result", "db", "next", "aw", "pend", "rb", "var", "usr", "bytes", "doc", "pad", "cp", "pack", "late", "nb", "fp", "nm", "cap", "wb", "desc", "prop", "length", "ctx", "limit", "raw", "_", "args", "cv", "bed", "bp", "bf", "bg", "tr", "vec", "new", "bl", "coord", "uf", "conv", "port", "buffer", "bur", "foo", "cur", "img", "rc", "dr", "ctr", "cont", "tmp", "orig", "proc", "msg", "temp", "alloc", "bag", "v", "text", "bar", "keep", "mem", "env", "block", "eb", "bc", "shift", "bin", "padding", "paste", "br", "bs", "done", "batch", "err", "xff"], "s": ["sv", "v", "gs", "js", "ms", "S", "fs", "ns", "ss", "b", "ts", "qs", "t", "cs", "ats", "space", "sb", "e", "g", "ds", "ls", "os", "es", "a", "rs", "acs", "sys", "stats", "sts", "c", "sq", "ps", "csv"], "picture": ["command", "video", "settings", "camera", "profile", "pa", "frame", "feature", "family", "images", "context", "query", "policy", "Picture", "png", "conference", "photo", "info", "pkg", "support", "path", "image", "information", "pict", "audio", "status", "format", "pic", "style", "table", "share", "summary", "img", "piece", "document", "pen", "media"], "p": ["ap", "pc", "n", "pa", "jp", "sp", "f", "b", "r", "pp", "pkg", "t", "o", "m", "par", "pic", "P", "cp", "u", "a", "fp", "np", "pb", "c", "j", "ps"], "ptr": ["rev", "ext", "src", "pointers", "tr", "vec", "push", "attr", "address", "arr", "ref", "str", "pad", "buffer", "pt", "rel", "dr", "ctr", "pointer", "br", "Ptr", "addr", "desc", "pr", "pos", "alloc", "err"], "AV_NUM_DATA_POINTERS": ["AV_NUM_DATA_POINTINGS", "AV_NUM_DATA_POINTERERS", "AV_NUM_DATA_POINER", "AV_NUM_DATA_POADERS", "AV_NUM_DATA_PAINers", "AV_NUM_DATA_PAINTers", "AV_NUM_DATA_POADER", "AV_NUM_DATA_PAINERS", "AV_NUM_DATA_POINers", "AV_NUM_DATA_POADINGS", "AV_NUM_DATA_PAINTERS", "AV_NUM_DATA_POINTER", "AV_NUM_DATA_PAININGS", "AV_NUM_DATA_POINTERINGS", "AV_NUM_DATA_PAINTER", "AV_NUM_DATA_POINTers", "AV_NUM_DATA_POINTERER", "AV_NUM_DATA_PAINTINGS", "AV_NUM_DATA_POADers", "AV_NUM_DATA_POINERS", "AV_NUM_DATA_POINTERers", "AV_NUM_DATA_POININGS", "AV_NUM_DATA_PAINER"], "offset": ["page", "sp", "end", "f", "slot", "timeout", "loc", "offs", "address", "image", "origin", "len", "area", "t", "shift", "rot", "padding", "ref", "o", "seek", "header", "pad", "buffer", "out", "off", "expected", "Offset", "window", "package", "error", "size", "location", "position", "point", "pointer", "row", "addr", "type", "start", "pos", "index", "extra", "et", "order", "ff", "length"], "magic_num": [" magic_no", "magic10ord", " magic_unit", "magicityNUM", "magic_no", "magicitynum", " magic_major", " magic_ord", "magic00no", "magic_mod", "magic10number", "magic_number", "magic00unit", " magic_name", "magic_ord", "magicitynumber", "magic00num", " magic_mult", " magic_number", "magic_name", "magic_NUM", "magic00mod", "magic_unit", " magic_NUM", "magic_major", "magic10mult", "magicityname", "magic00major", "magic_mult", "magic00number", "magic10num", " magic_mod"], "endian": ["eastieval", "EndIAN", "windrian", " endalian", " endort", "eastalian", "endinger", "endIAN", "endorable", "endrian", "endingrian", "Endior", "endieval", "endedieval", " endorable", "endingieval", " endrian", " endians", "endingian", "endedIAN", "endingians", "ENDians", "indrian", "indorable", "endedian", "endort", " endIAN", "endingalian", "endalian", "ENDian", "endedians", "Endians", "ENDrian", "Enden", "ENDen", "endedior", "eastians", "eastary", "endingicator", "endicator", "enden", "ENDer", "windort", " enden", " endary", "endior", "ender", "endedicator", "endians", "ENDIAN", " ender", "windorable", "endingIAN", "Endian", " endior", "endingary", "indian", "eastian", "windian", "easticator", "endary", "indort"], "x": ["ax", "v", "ex", "n", "ix", "wx", "tx", "r", "X", "xc", "dx", "ox", "o", "rx", "m", "a", "px", "l", "xy", "xs", "c", "index"], "y": ["Y", "ty", "b", "ym", "ey", "gy", "yy", "o", "m", "my", "hy", "dy", "yl", "ny", "py", "yt", "iy", "xy", "axy", "ys", "yn", "j", "c", "sy", "ch"], "i": ["ir", "in", "ij", "f", "ix", "b", "info", "di", "ii", "ip", "mi", "m", "g", "pi", "id", "ib", "im", "iu", "l", "j", "index", "c", "it", "si", "ind", "I"], "ret": ["magic", "nt", "rem", "res", "result", "found", "native", "txt", "val", "print", "rt", "tf", "f", "rets", "mem", "tr", "reset", "elt", " Ret", "new", "vector", "arr", "total", "ref", "ft", "status", "format", "Ret", "out", "gt", "not", "RET", "flag", "value", "def", "dr", "try", "resp", "back", "packed", "alt", "re", "callback", "j", "got", "success", "it", "err"], "w": ["whe", "ex", "we", "wig", "n", "wr", "W", "work", "wp", "aw", "wa", "wx", "wd", "weights", "r", "z", "fw", "win", "m", "hw", "wal", "wh", "wn", "wi", "g", "nw", "d", "sw", "ew", "rw", "window", "wt", "wid", "l", "ww", "iw", "wb", "widget", "kw"], "h": ["hr", "ih", "v", "ph", "n", "k", "hs", "host", "hl", "H", "b", "ha", "z", "he", "mk", "hi", "hei", "hh", "html", "oh", "sh", "kh", "uh", "o", "m", "bh", "hw", "hash", "wh", "ah", "d", "q", "hang", "high", "hz", "hal", "size", "hd", "height", "l", "ho", "ht", "it", "ch", "length"], "bits_per_color": ["bits_per_pixel", "bits_PER_component", "bits_per_image", "bits_per_channel", "bits_PER_channel", "bits_PER_pixel", "bits_PER_image", "bits_per_component", "bits_PER_color"], "descriptor": ["Description", "decriptractor", "descructor", "descructractor", "descryptor", "deccriptor", "descriptors", "Desccriptator", "descryptors", "Desccription", "Descriptator", "description", "desccription", "descriptator", "descryption", "descructors", "decription", "descripors", "descripractor", "desccriptator", "Descriptors", "decriptors", "decriptor", "descripor", "descryptator", "descructator", "Desccriptor", "descruction", "desccriptors", "deccriptors", "descripion", "deccription", "deccriptractor", "Desccriptors", "Descriptor", "descriptractor", "desccriptor", "desccriptractor"], "elements": ["melement", "Elements", "eelements", "melem", "elem", "Elem", "eelem", "mesections", "eelement", "melements", "esections", "Esections", "element", "eesections", "Element"], "packing": ["using", "packs", "tracking", "boxing", "sharing", "aging", "length", "working", "power", "scoring", "picking", "testing", "heading", "processing", "checking", "protection", "pkg", "sequence", "padding", "shift", "rating", "ordering", "ping", "pack", "package", "reading", "fp", "loading", "locking", "fitting", "packed", "saving", "extra", "forcing", "adding"], "total_size": [" total_space", "total_SIZE", " total_count", "total_count", "total_space", " total_SIZE"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n\n{\n\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n\n    int rs = mmreg(ctx->opcode & 0x7);\n\n    int opc;\n\n\n\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n\n    case NOT16 + 0:\n\n    case NOT16 + 1:\n\n    case NOT16 + 2:\n\n    case NOT16 + 3:\n\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n\n        break;\n\n    case XOR16 + 0:\n\n    case XOR16 + 1:\n\n    case XOR16 + 2:\n\n    case XOR16 + 3:\n\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n\n        break;\n\n    case AND16 + 0:\n\n    case AND16 + 1:\n\n    case AND16 + 2:\n\n    case AND16 + 3:\n\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n\n        break;\n\n    case OR16 + 0:\n\n    case OR16 + 1:\n\n    case OR16 + 2:\n\n    case OR16 + 3:\n\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n\n        break;\n\n    case LWM16 + 0:\n\n    case LWM16 + 1:\n\n    case LWM16 + 2:\n\n    case LWM16 + 3:\n\n        {\n\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case SWM16 + 0:\n\n    case SWM16 + 1:\n\n    case SWM16 + 2:\n\n    case SWM16 + 3:\n\n        {\n\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case JR16 + 0:\n\n    case JR16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case JRC16 + 0:\n\n    case JRC16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    case JALR16 + 0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 24483, "substitutes": {"ctx": ["conn", "ksh", "anc", "txt", "jp", "typ", "aux", "tx", "mc", "kt", "cmd", "pkg", "xc", "pg", "func", "ctl", "ork", "hw", "tz", "scl", "sc", "lex", "conf", "np", "gz", "nc", " cx", "nt", "work", "gc", "history", "iat", "std", "grad", "handler", "act", "dc", "cu", "jj", "ct", "cp", "prefix", "cm", "kw", "cfg", "init", "cv", "wp", "xp", "rt", "wx", "context", "timeout", "kk", "fw", "nw", "ck", "kb", "resp", "sys", "ctr", "xy", "proc", "msg", "etc", "cmp", "js", "unk", "kl", "bc", "setup", "req", "mom", "bh", "cc", "jac", "pause", "ka", "tc", "xs", "batch", "x"], "is_branch": ["is_relranch", "is_relanch", "is_blanch", "is_blag", "is_BRranch", "is_relag", "is_BRag", "is_blranch", "is_brranch", "is_BRanch", "is_brag"], "opc": [" opcs", "opcs", "pc", " opci", "OPc", "opci", " opC", "pci", "OPci", "opC", "pcs", "OPC", "pC", "OPcs"], "lwm_convert": ["lwm_transv", "lwm_unver", "lwm_changevert", "lwm_changeversion", "lwm_conv", "lwm_calvert", "lwm_calver", "lwm_transverts", "lwm_unvert", "lwm_transver", "lwm_changev", "lwm_unverts", "lwm_conversion", "lwm_transvert", "lwm_transversion", "lwm_convv", "lwm_convversion", "lwm_calverts", "lwm_conver", "lwm_converts", "lwm_convvert"], "swm_convert": ["swm_changevert", "swm_createconv", "swm_interchange", "swm_intervert", "swm_interconv", "swm_conconv", "swm_uncode", "swm_transcode", "swm_unver", "swm_createver", "swm_unvert", "swm_conchange", "swm_interver", "swm_createvert", "swm_mapvert", "swm_createchange", "swm_conver", "swm_transvert", "swm_transver", "swm_mapver", "swm_mapconv", "swm_changecode", "swm_changever", "swm_concode", "swm_mapchange"]}}
{"project": "FFmpeg", "commit_id": "abb5e37f64c48bba8bd0fde2bada0f7544defa24", "target": 1, "func": "int ff_filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFrame *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFrame *out;\n\n\n\n    FF_DPRINTF_START(NULL, filter_frame);\n\n    ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    /* copy the frame if needed */\n\n    if (dst->needs_writable && !av_frame_is_writable(frame)) {\n\n        av_log(link->dst, AV_LOG_DEBUG, \"Copying data in avfilter.\\n\");\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, frame->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        av_frame_copy_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->width, frame->height);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        av_frame_free(&frame);\n\n    } else\n\n        out = frame;\n\n\n\n    return filter_frame(link, out);\n\n}\n", "idx": 24484, "substitutes": {"link": ["range", "low", "join", "store", "lock", "loc", "path", "image", "ref", "Link", "connection", "line", "style", "id", "links", "ln", "def", "thread", "map", "type", "le", "ind", "set", "drive", "owner", "db", "tool", "filter", "load", "connect", "lib", "match", "device", "ml", "cp", "call", "linked", "check", "base", "like", "open", "field", "handle", "library", "ink", "lay", "local", "kind", "parent", "tag", "query", "z", "this", "relation", "chain", "rel", "mt", "share", "ld", "l", "target", "head", "msg", "ie", "network", "slave", "flow", "url", "user", "in", "slice", "loop", "li", "way", "sp", "source", "node", "pl", "info", "key", "light", "name", "stream", "list", "label", "self"], "frame": ["request", "profile", "range", "file", "ce", "instance", "message", "state", "image", "ref", "time", "function", "header", "line", "style", "window", "force", "pointer", "normal", "term", "ind", "to", "cast", "next", "filter", " Frame", "process", "feat", "movie", "version", "doc", "framework", "call", "from", "response", "base", "part", "cycle", "module", "one", "start", "field", "length", "data", "iframe", "scene", "me", "rame", "channel", "local", "f", "frames", "event", "step", "new", "sequence", "sample", "zone", "component", "remote", "chain", "buffer", "cf", "error", "ence", "shot", "head", "Frame", "flow", "video", "face", "user", "fr", "in", "page", "feature", "source", "show", "info", "block", "fram", "t", "draw", "code", "trace", "up", "rule", "point", "word"], "filter_frame": ["filter_image", " filter_link", "filter2filter", "filter___channel", "filtermytype", "save_channel", "filter___window", "filter_link", "filtermyframes", "filter4frame", "filter___format", "filter4image", "filterphpchannel", "transform___format", " filter_state", " filter_type", "filter___frame", "filter___frames", "filter_state", " filter_filter", "filterphpframe", "filter2frame", "filteriptype", "transform___frame", "filteripframe", "filter4filter", "transform_format", "save_line", "filter_filter", "filter_channel", "transform___frames", "filter_window", "filter2image", "filter_line", " filter_window", "filtermychannel", " filter_frames", "transform_frames", "filter___line", "filter_format", "filter_position", "filter_type", "filter4link", "transform_window", " filter_channel", "filter___state", "filtermyframe", "filter_frames", "filterphpline", "filter_fram", "filterphpposition", "transform___window", " filter_image", "filter2link", "filteripchannel", "filter___position", "transform_frame", "save_position", "save_frame", " filter_fram", "filteripframes", "filter___link"], "dst": ["dest", " dust", "daust", "sost", "bddest", "dsp", "dast", "dost", " dset", "bdost", "sbr", " dbr", "sdST", "sddest", "sdset", "daST", " dsp", "fost", "bdst", " dest", "Dsp", "ddest", "dST", "fst", "Dest", " dST", "sdost", "fdest", "dadest", "bdset", "dust", "fest", "Dost", "sdst", "Dbr", " ddest", "Dst", "Ddest", "ssp", " dost", "dbr", "sst", "dset", "sdust"], "out": ["gen", "ex", "obj", "zero", "val", "aux", "outer", "net", "ou", "or", "b", "bit", "box", "image", "ref", "p", "status", "off", "line", "Out", "old", "io", "aos", "vert", "external", "inv", "set", "w", "to", "output", "n", "false", "cast", "result", "client", "op", "full", "var", "ch", "allowed", "os", "check", "base", "one", "order", "inner", "all", "raw", "init", "data", "ot", "f", "group", "null", "pool", "new", "comment", "conv", "buffer", "outs", "table", "error", "tmp", "extra", "empty", "msg", "v", "cache", "res", "user", "co", "in", "ext", "end", "mem", "can", "bool", "OUT", "at", "t", "boot", "update", "o", "gt", "name", "list", "up", "no", "point", "batch", "it", "err", "port"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24485, "substitutes": {"transport": ["Transform", "transaction", "teleports", "teleport", "exaction", "teleaction", "exporter", "ransform", "Transports", "Transaction", "teleporter", " transform", "transmit", "transports", "Transporter", " transporter", "export", "transporter", "ransport", "Transport", "ransporter", " transmit", "transform", "exports", "ransmit", "Transmit"], "data": ["DATA", "text", "rec", "rew", "raw", "Data", "f", "action", "load", "message", "block", "bytes", "bin", " DATA", "p", "dat", "buffer", "pad", "str", "d", "rel", "table", "a", "window", "def", "pointer", "buf", "batch", "empty", "msg", "ata", "partial"], "len": ["nt", " bl", "n", "cmp", "nl", "fin", "mid", "lp", "fil", "val", "end", "ll", "mem", "elt", "vec", "bytes", "lf", "lan", "t", "lib", "lic", "el", " length", "str", "en", "Len", " l", "size", "ln", "ld", "wid", "l", "resp", "pos", "elta", "enc", "length"], "vs": ["sv", "vals", "v", "ks", "gs", "js", "ms", "obs", "fs", "ils", "ns", "VS", "vl", "var", "ps", "ts", "qs", "vers", "cs", "vt", "ats", "ins", "ds", "ls", "values", "otes", "px", "rs", "stats", "sts", "bs", "als", "Vs", "vc", "inv", "caps", "vr"], "ret": ["rev", "nt", "rem", "res", "fin", "gc", "ter", "iter", "db", " alt", "ext", "jp", "val", "ll", "rt", "rets", "tr", "det", "reset", "elt", " Ret", "ere", "usr", "t", "xt", "fun", "arr", "pat", "deg", "ft", "pub", "code", "gt", "status", "Ret", "out", "en", "off", "inter", "vet", "arg", "mt", "lt", "RET", "flag", "att", "def", "ld", "dr", "cont", "num", " RET", "back", "alt", "re", "j", "desc", "x", "err"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486, "substitutes": {"obj": ["nt", "js", "obs", "ot", "txt", "ob", "op", "og", "b", "elt", "info", "attr", "pkg", "iv", "objects", "act", "t", "ref", "oid", "o", "hw", "bh", "pt", "Object", "org", "os", "bo", "gov", "Obj", "vs", "np", "xy", "tmp", "object", "pr", "onet", "vr", "self", "rect", "ctx"], "v": ["sv", "cv", "vp", "vis", "k", "uv", "f", "vm", "b", "r", "tv", "iv", "vt", "conv", "o", "p", "m", "g", "view", "nv", "q", "ev", "vu", "vim", "V", "h", "vs", "l", "av", "vc", "vy", "j", "c", "vi", "vr", "w"], "opaque": ["oposter", "oplois", "opsiera", "ioposter", "iopque", "popaque", "OPacity", "ipois", "iopaque", "popque", "opacity", "OPque", "oplaque", "OPiera", "opois", "opsacity", "oplque", "opiera", "iposter", "popiera", "iopois", "opsaque", "popacity", "ipaque", "oploster", "opque", "ipque", "OPaque", "opsque"], "name": [" key", "n", "text", "named", " prefix", "term", " NAME", "NAME", " path", "missing", "attr", "names", "path", "t", "comment", "key", "add", "str", "ni", "prefix", "san", "part", "no", "error", "search", "def", " names", "nm", "label", "nam", "word", "type", "ame", "cap", "alias", "Name", " Name", "w"], "errp": [" errpre", " errr", "errorr", "ferpr", "arrpre", "errorpc", "yrr", "rrpc", "errpid", "yrpr", "errpc", "yrp", "arrr", "rrpa", "rrr", "yrpid", " errpa", "errorp", " errpc", "arrp", "ferr", "errpre", "ferpid", "errr", " errpr", "arrpc", "rrp", "errpr", "errpa", "ferp", "errorpre", "arrpa", " errpid"], "prop": ["Pro", "acc", " props", "pa", " pos", " def", "jp", "val", "opt", "pro", "pl", "priv", "op", "tag", "item", " pro", "cmd", "attr", "pp", "pkg", " val", "Prop", "fac", "key", "mp", "ref", "lit", "p", "pt", " p", "cp", "rep", "decl", "pred", " ref", "def", " proc", "property", "prof", " tmp", "col", "pr", "pb", "desc", " prob", "ptr", "proc", "ps", "prot", " Prop"], "value": ["data", "VALUE", "text", "max", "count", "result", "length", "val", "valid", "message", "instance", "description", "state", "address", "current", "iv", "new", "inner", "key", "total", " Value", "code", "status", "values", "number", "no", "size", "V", "unit", "des", "Value", "num", "property", "now", "ue", "type", "field", "index", "attribute", "widget", "test", "entry", "port", "set"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,\n\n                            int mb_x, int mb_y, uint8_t *img_y,\n\n                            uint8_t *img_cb, uint8_t *img_cr,\n\n                            unsigned int linesize, unsigned int uvlinesize)\n\n{\n\n    assert(!FRAME_MBAFF(h));\n\n    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {\n\n        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n\n        return;\n\n    }\n\n\n\n#if CONFIG_SMALL\n\n    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);\n\n#else\n\n    if(h->pixel_shift){\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);\n\n    }else{\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);\n\n    }\n\n#endif\n\n}\n", "idx": 24488, "substitutes": {"h": ["hr", "v", "ih", "cache", "hs", "ph", "zh", "host", "history", "each", "hm", "f", "context", "hl", "H", "he", "hi", "hh", "t", "html", "oh", "sh", "kh", "hash", "p", "bh", "m", "hw", "http", "g", "ah", "dh", "comm", "rh", "hz", "ssh", "hal", "hp", "hd", "s", "l", "handle", "j", "ht", "c", "x", "it", "hum", "ch", "w"], "sl": ["sal", "sv", "la", "ph", "il", "hs", "nl", "sa", "spot", "slice", "zh", "sp", "jl", "serv", "sche", "kl", "pl", "rl", "isl", "sil", "hl", "sol", "se", "sid", "kel", "ssl", "sh", "lib", "shell", "sb", "coll", "sel", "bh", "fl", "ml", "dh", "ls", "scl", "syn", "ssh", "sole", "ln", "SL", "spl", "s", "ld", "l", "sql", "sch", "ht", "ell", "sn", "Sl", "tl", "dl", "sm", "lit"], "mb_x": ["mb____wx", "mb_xy", "mb_lex", "MB_ex", "mb_ax", "MB_xp", "img_x", "mb_xt", "mb_xs", "img_wx", "mb64ax", "MB_x", "mg_xs", "mg_x", "mb64x", "mg_ix", "mb__xp", "mb64X", "mb__x", "mb_xp", "mb_ex", "img_X", "mb__ex", "mb_axis", "img_lex", "mb_wx", "mb__axis", "mb_X", "img_ax", "mb5ip", "MB_y", "mb__y", "mb64xy", "mb__xs", "mb5xs", "mb5x", "mb5ix", "mb_ix", "mb_ip", "img_xt", "mb____lex", "mb____x", "MB_xs", "mb____xt", "img_xy", "mg_ip", "MB_axis"], "mb_y": ["mb67ay", "mb67ys", "mb5cy", "rav_cy", "mb_sy", "mb_ys", "mb5out", "rav_y", "rav___hot", "nom_y", "MB_x", "umb_cy", "nom_ly", "rav___out", "mbXx", "mb_asy", "mb_ym", "img_asy", "mbXym", "mb67y", "rav_out", "MB_ym", "mb___y", "mb_id", "mb___cy", "mb_ay", "nom_sy", "mb___hot", "umb_y", "umb_hot", "mb_ly", "rav_hot", "mb5yy", "mbXy", "mb_out", "mb5hot", "nom_id", "mb___out", "rav___cy", "MB_y", "mbXcy", "mb67asy", "img_ys", "MB_cy", "mb_hot", "umb_yy", "img_ay", "rav___y", "mb_cy", "mb_yy", "mb5y"], "img_y": ["aug___ya", "img___yy", "img_yy", "emb___my", "emb_my", "img_Y", "aug___asy", "good___yy", "img______oy", "emb___y", "emb_xy", "aug___oy", "anim_uy", "orig_ey", "img_oy", "img_ny", "good_oy", "good_y", "anim_y", "aug_oy", "img___ya", "img_cy", "img_ya", "img_asy", "img_uy", "img___y", "aug___y", "aug_y", "emb___xy", "good___Y", "good___oy", "aug_ya", "img_my", "img___xy", "anim_asy", "good_yy", "img______y", "emb_ya", "img______yy", "img_ey", "img___my", "img___Y", "good_Y", "emb___ya", "img___oy", "img___asy", "orig_uy", "img______Y", "anim_cy", "orig_ny", "emb_y", "orig_y", "aug_asy", "good___y", "img_xy"], "img_cb": [" img_cf", "imgCcb", "imgCzb", " img_cp", "imgLctrl", " img_kw", "img_nw", "pkg_ctrl", "pkg_vc", "img_bb", "img___cr", "img_zb", "img___cb", "img_ctrl", "img___bb", " img_nw", " img_cc", "imag_ctrl", "img_kw", "imag_cb", "img_erb", "pkg_zb", "img_cp", "img_bg", "img___cf", "imgLdb", " img_rb", "imag_db", " img_bb", "pkg_cb", " img_erb", "img___kw", "img_db", "imgCvc", "imgCctrl", "img_rb", "imgLbg", "img_cc", "img_vc", "imag_bg", "imgLcb", "img___rb", "img_cf", "img___cc"], "img_cr": ["img___br", "img___err", "img_ctr", " img_cp", " img_tc", " img_fr", " img_br", " img_err", "img___tc", "img_cy", "img___cr", "img___cb", " img_cc", " img_try", "img___fr", "img___cp", "img_crit", "img_cp", "img_try", "img_br", "img_err", "img_fr", " img_cy", "img_tc", "img___cy", "img___ctr", "img_cc", " img_crit", " img_ctr", "img___cc"], "linesize": ["linesization", "workseline", " linesze", " linesization", "lineshare", "linesforge", "inesize", "linksize", "linsize", "linesze", "locksize", "lineszie", "pinsization", "linsIZE", "lockseline", "worksiz", "linszie", "stepseline", "linesIZE", "pinsforge", "insIZE", "linsiz", "stepsization", "inessize", "linessize", "linsization", "stepsize", " lineszie", "stepsforge", "stepszie", "linksze", "worksIZE", "linssize", "lockshare", "pinsize", "insization", "inesze", "insize", "linksization", "inssize", "linksIZE", "workshare", "stepshare", "inesIZE", " linesiz", "lineseline", " linesIZE", "inesization", "endsization", "workszie", "pinszie", "endsize", "endsforge", "worksize", "endszie", "linesiz"], "uvlinesize": ["uvringsizer", "uvlinesIZE", "vvlinesetime", "nvlevelsizing", "uvvalsizer", "uupointsize", "uvlevelsizing", "vvlinsizer", "uvlinesizing", "vvlinsetime", "uvlevelsocate", "ujlinesocate", "uvframesetime", "uvlinesz", "uvlinsicate", "uvstylesource", "vvlinesect", "ujlinesizer", "vvlinesIZE", "vvlinesizer", "uvmarksz", "uvlinesource", "uvpointsect", "uvlinsect", "uvvalsIZE", "uvlinksizer", "ujlevelsizer", "ujlinesize", "uvmarksize", "uvcodesizer", "ujlevelsocate", "uvlinsetime", "uvlineszie", "uupointsicate", "vvlineszie", "uvframesize", "uvinesIZE", "uvcodesocate", "uvlinesify", "uvvalsize", "uvstyleszie", "nvlinesize", "uvlinksify", "vvlinsize", "vvlinzie", "uvlinesetime", "uvcodesify", "uvlevelsify", "uvpointsicate", "nvlinesizer", "uvpointsize", "uvframesizer", "uvinesize", "uvlinksocate", "ujlinesify", "uvvalsizing", "uvlinsz", "vvlinesource", "nvlevelsize", "uupointsz", "vvlinize", "uulinesizer", "nvlevelsIZE", "uvringsizing", "uvpointsetime", "uvframesect", "uvlinesocate", "nvlinesizing", "uvlinize", "uvlinksize", "uvlinource", "uvlinesicate", "vvlinsect", "uvpointsz", "uvmarksicate", "vvlinesize", "uvpointsizer", "uvineszie", "vvlinIZE", "uvstylesIZE", "uvringsIZE", "uvlinesect", "nvlevelsizer", "ujlevelsize", "uvlevelsizer", "uvlinsizer", "uvlevelsIZE", "uvstylesize", "ujlevelsify", "uvlevelsize", "uulinesize", "uvmarksizer", "uulinesz", "uvcodesize", "uvlinzie", "nvlinesIZE", "uvlinIZE", "uvinesource", "uvlinsize", "uulinesicate", "vvlinource", "uvlinesizer", "uupointsizer", "uvringsize"]}}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n", "idx": 24501, "substitutes": {"device": ["Device", "drive", "command", "server", "driver", "DEV", "disk", "devices", "link", "end", "any", "mode", "hid", "directory", "android", "context", "query", "product", "reader", "pipe", "di", "address", "spec", "path", "serial", "DE", "pod", "remote", "pad", "dev", "connection", "buffer", "name", "controller", "project", "window", "engine", "error", "location", "de", "target", "module", "edge", "handle", " Device", "index", "resource", "scope", "network", "port", "interface", "slave"], "has_force": ["has_forced", "has___forcing", "yes___force", "yes___Force", "has___force", "yes_forcing", "has___forced", " has_forced", "has_forcing", "yes_Force", "yes_forced", "has_Force", "has___Force", "yes___forcing", "yes___forced", "yes_force", " has_Force"], "force": ["flow", "safe", "command", "enable", "Force", "util", "forced", "ly", " Force", "required", "file", "ise", "f", "ignore", "store", "policy", "ce", "forcer", "ync", "cmd", "find", "dirty", "forward", "act", "allow", " confirm", "orce", "remote", "secure", "forge", "late", "needed", "check", "write", "sync", "always", " enforce", "rule", "flag", "yes", " forced", "spread", "close", "use", "console", "service", "fine", "cycle", "confirmed", "edge", "require", "form", "handle", "forcing", "core"], "errp": [" errps", " errper", "iterpa", "bufps", "rrcp", "erm", "bufp", "errorP", " errP", "errorcp", " errcp", "errorm", "errpm", "errcp", "errps", "rrpa", "bufpm", "bufP", "erp", "errm", " errpa", "rrps", "errorp", "erP", " errm", "iterps", "errP", "errorpm", "rrper", "iterper", "rrp", "errpa", " errpm", "errper", "rrP", "iterp", "errorps"], "local_err": ["global_r", "local____error", "local____err", "local_error", "local_r", " local_error", "global_err", "local_rr", "local_kr", " local_rr", "local___error", "global_error", "local____eas", "local____er", "local_er", " local_er", "global_kr", "local___kr", "global_er", "local_eas", "local___r", " local_eas", "local___err"], "rc": ["nt", "pc", "cmp", "res", "rec", "erc", "isc", "gc", "co", "oc", " RC", "rt", " cc", " src", "cr", "ack", "lc", "cor", "fc", "cb", "cmd", "ry", "bc", "RC", "dc", "cs", "sec", " ac", "auc", "ok", "ac", "uc", "ec", "coll", "code", "cc", "ck", " ec", "rs", "sc", "arc", "cur", "con", "ctr", "inc", "userc", "err", "tc", "roc", "c", " cr", "nc", " exc", "ch", " proc"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508, "substitutes": {"prot": ["top", "prototype", "chron", "Prot", "tp", "virtual", "tif", "ort", "typ", "jp", "sche", "phys", "net", "tf", "pro", "protected", "tr", "rect", "phy", "gate", "pkg", "gp", "alg", "ocol", "ssl", "inet", "vt", "rot", "nav", "pat", "fl", "vet", "org", "pred", "gov", "eth", "att", "protect", "def", "np", "pb", "ht", "ptr", "et", "onet", "php", "prop", "iot", "port"], "rw": ["tw", "we", "vp", "wr", "rew", "wp", "aw", "writ", "rt", "wx", "wa", "wl", "rl", "wd", "ru", "RW", "rb", "web", "writer", "rd", "fw", "hw", "wn", "nw", "sw", "route", "rh", "nb", "write", "rob", "iw", "wb", "nor", "ro", "vr", "w"], "access_type": ["Access_flag", "access_kind", "access2kind", " access_Type", "access_Type", "access_flag", " access_info", "Access_Type", "access___kind", "access_info", "access2Type", " access_kind", "access___info", "access_TYPE", "Access_TYPE", "access___type", "access2type", "access___Type", "Access_type", "access2info"], "ret": [" fut", "rev", "nt", "rem", "res", "ert", "nz", "ter", "del", "ext", "txt", "val", "jp", "print", "ll", "rt", "net", "f", "rets", "mem", "tr", "det", "reply", "quad", "reset", "elt", "cert", "reg", "cmd", "bill", "pas", "dt", "Return", "t", "fun", "req", "ref", "lit", "pub", "ft", "compl", "gt", "Ret", "out", "off", "rel", "inter", "rm", "pret", "mt", "RET", "flag", "eth", "att", "def", "dr", "ld", "resp", "cont", "sys", "back", "alt", "re", "desc", "rest", "mb"]}}
{"project": "qemu", "commit_id": "4545d4f4af8b29ba3b38dfb74d6f45342e15a62d", "target": 1, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24540, "substitutes": {"extent": ["extant", "contant", "extension", "expend", "indment", "geent", "expension", "geension", "content", "extect", "extents", "contENT", "xtENT", "extment", "indents", "extENT", "intect", "indent", "indend", "contension", "indant", "contents", "xtents", "ordent", "gement", "contend", "intent", "indension", "Extect", "intension", "xtension", "ordENT", "geents", "intents", "expant", "Extension", "Extant", "xtment", "extend", "expent", "ordant", "ordension", "Extent", "xtant", "xtent", "Extents", "xtect"], "cluster_offset": ["cluster_align", "cluster_position", "clusterxOffset", "clusterxposition", "cluster_Offset", "clusteripalign", "clusters_position", "cluster_owner", "cluster_info", "clusteripposition", "clusters_Offset", "clusterxowner", "clusters_owner", "clusters_offset", "clusteripoffset", "clusterxoffset", "clusters_info", "clusters_align", "clusteripinfo"], "offset_in_cluster": ["offset_in_Cluster", "offset_in_glust", "offset_in_pluster", "offset_in_clusters", "offset_in_plure", "offset_in_clust", "offset_in_gluster", "offset_in_clure", "offset_in_Clust", "offset_in_glusters", "offset_in_Clusters", "offset_in_colusters", "offset_in_colust", "offset_in_plusters", "offset_in_coluster", "offset_in_plust", "offset_in_gloser", "offset_in_ploser", "offset_in_Closer", "offset_in_glure", "offset_in_colure", "offset_in_closer"], "qiov": ["qqovi", "queryibr", "iqiour", "qualiov", " qriver", "questiev", "eqriver", "eqvoice", "qovi", "quibr", "qibr", "quconv", "qiop", "questiour", "qconv", "queryiour", "eqiov", "iqvoice", "iqiov", "questibr", "eqiop", "qqiov", "qqiour", "questiov", " qiop", "qualiour", "iqriver", "qriver", "qvoice", " qibr", "queryiev", "qiev", "qualconv", "qualovi", "quiev", "qiour", "iqibr", " qconv", "quiov", " qovi", " qvoice", "iqiev", "qqiev", "qualibr", "queryiov", " qiour", " qiev", "iqiop", "qualiev"], "qiov_offset": ["qoulder_origin", "qiol_offset", "qiol_off", "qiov_off", "qiop_error", "qiov_Offset", "qiov2Offset", "qiov_reset", "qiov__off", "qoulder_error", "qiop_offset", "qiov2reset", "qiol_addr", "qiov_len", "qiop_Offset", "qiol_error", "qiov_addr", "qiov_error", "qiov__addr", "qiov__offset", "qiop_reset", "qoulder_len", "qoulder_offset", "qiov2offset", "qiov__error", "qiov2error", "qiov_origin"], "n_bytes": ["nbytesbytes", "n_bits", " n_frames", "n_byte", "an_bytes", "nbytesections", "cmd", "nowbytes", "an42windows", "n__bytes", "noxwindows", "n_blocks", "nbytebytes", "n_seconds", "an_windows", "nowdetails", " n_sections", "gc", "into", "n__bits", "n_Bytes", "n_changes", "an42bytes", "an_changes", "n_parts", " n_seconds", "n_tes", "nbytebyte", "_", "an42seconds", "n_sections", "N_Bytes", "N_tes", "N_bytes", "an_seconds", " n_tes", "N_blocks", "vec", "n_frames", "noxseconds", "n_rows", "n__Bytes", "n_errors", "flag", "nbytesbyte", "n__tes", "cont", "n_details", "nowseconds", "n42bytes", "an42changes", "nbytessections", "n42windows", "noxchanges", "nowtes", " n_byte", "n42changes", "N_parts", " n_details", "block", "n42seconds", "n_windows", "N_seconds", " n_rows", "N_errors", "noxbytes", "N_bits"], "offset": ["top", "eta", "ta", "scroll", "length", "end", "amount", "f", "op", "info", "address", "image", "origin", "shift", "rot", "padding", "ref", "oid", "o", "seek", "buffer", "off", "Offset", "base", "prefix", "id", "mt", "error", "size", "location", "position", "pointer", "addr", "start", "alt", "buf", "pos", "index", "ptr", "attribute", "set"], "ret": ["rev", "nt", "rem", "url", "res", "result", "ter", "final", "over", "opt", "val", "print", "ll", "rt", "valid", "net", "rets", "mel", "after", "det", "tr", "mem", "reset", "elt", " Ret", "dt", "Return", "t", "len", "fun", "ref", "deg", "ft", "status", "gt", "Ret", "out", "rm", "not", "arg", "mt", "RET", "flag", "att", "def", "utils", "try", "resp", " RET", "back", "re", "alt", "j", "success", "err", "prot", "lit"], "data": ["obj", "message", "reset", "read", "missing", "writer", "image", "len", "ref", "add", "hash", "p", "off", "window", "value", "def", "map", "c", "normal", "to", "output", "result", "next", "Data", "address", "bytes", " DATA", "str", "pad", "d", "base", "module", "buf", "length", "partial", "init", "initial", "group", "this", "dat", "buffer", "rel", "table", "error", "memory", "ATA", "extra", "empty", "ata", "DATA", "cache", "text", "only", "mem", "reader", "info", "block", "t", "padding", "bin", "format", "name", "number", "no", "size", "h", "tar", "done", "batch", "self"], "buf_len": ["uf_length", "buf0length", "uf_lib", "uf_ln", "buf2length", "queue_ls", "buf_lib", "buff_lon", "buf2len", "buff_ls", "buf_Len", "buf__length", "uf_size", "buf2ls", "buf_ls", "uf_len", "buf_length", "buf0len", "buf0ls", "buf_min", "queue_lim", "buf0size", "buf67length", " buf_length", "buf_size", "uf_min", "uf_el", "buf__el", "buf_lon", "queue_len", " buf_lit", "buf_ln", "queue_lib", " buftlen", "buftlength", " buftlength", "buf_lit", "buf__ls", "buf_el", "buf67len", " buf_ln", "buftln", "buf67ln", " buftln", "buftlen", " buftlit", "queue_length", "buf__lon", "buff_len", "buf2size", "buf__len", "queue_Len", "buf_lim", "buf__lib", "uf_ls", "buff_length", "buftlit", "buf67min"], "local_qiov": ["local_ueminecraft", "local_sqvoice", "local_qualibi", "local_iqibi", "local_qualoji", "local_sqiour", "local___qvoice", "local_qiological", "local_qibr", "local_qqiov", "local_iqvoice", "local_ueiev", "local_quiov", "local_qiour", "local_qtovi", "local_qminecraft", "local_clientiov", "local___qibr", "local_qtiov", "local_iqiour", "local_qualibr", "local_sqiov", "local_checkoji", "local_quiev", "local_qtoyer", "local_sqibr", "local_qqiev", "local_sqibi", "local_qovi", "local_qiev", "local_ueivic", "local___iqibr", "local_qibi", "local_iqibr", "local_iqiological", "local_quiour", "local_qqminecraft", "local_ueiov", "local___iqvoice", "local_checkoyer", "local_qtoji", "local_checkovi", "local_sqiological", "local___iqiov", "local_qoyer", "local_qivic", "local_qualiov", "local_qualoyer", "local___iqibi", "local_quiological", "local_checkiov", "local_iqiev", "local___qiov", "local_qualvoice", "local_qoji", "local_qqivic", "local_iqiov", "local_qualovi", "local_clientivic", "local_clientiev", "local_clientminecraft", "local___qibi", "local_sqiev", "local_qvoice"], "iov": [" mob", "ir", "vp", "tif", " mus", "iq", " neigh", " coh", " mor", " resp", " unim", " multimedia", " misc", " tv", "ivic", "isco", " calib", " civ", "ij", "communication", "riot", "iat", " vib", " cohort", "serv", "nir", "uart", "veh", "iva", "nov", "ux", "voice", " residual", " fav", "vo", "tv", "iv", "minecraft", "vector", " vital", " imp", " commun", "conv", " bio", " mech", " enorm", "org", " serv", "imp", "liv", "iol", " vers", "uj", " impulse", "gov", "rov", "iop", "von", " pir", "iological", " rav", " codec", "river", " vocal", "ech", "icon", "eur", "iour", "vr", "kov"], "write_offset": ["seek_offset", "seek___offset", "write67floor", "writeableoff", "writeableoffset", "write_mask", "writeingmask", "write67padding", "writeingseek", "writeableposition", "seek_off", " write_floor", "seek___off", "seek_position", "seek___position", "write___offset", "writeingoffset", "writeablestart", "write_position", "write___start", "write67position", " write_mask", " write_seek", "writeingposition", "write___off", "write___position", "write67offset", "write_start", "seek___start", " write_position", "write_seek", "write_floor", " write_padding", "write_off", "write_padding", "seek_start"], "write_end_sector": ["write_start_sector", "write_end2sec", "write_end_offset", "write_endzsel", "write_end2sel", "write_start_offset", "write_endzsec", "write_end_sel", "write_end_sec", "write_endzsector", "write_end2sector", "write_start_sel", "write_start_sec", "write_endzoffset", "write_end2offset"], "compressed_data": ["compressed67data", "compressed1dat", "composed_table", "compressed_key", "computed67key", "compressedingData", "compressed1buffer", "compressed2data", "compressed_ata", "compressed2DATA", "composed2data", "compressedingmemory", "compressedingdata", "computed_data", "composed2table", "computed67data", "compressed_memory", "compressed67key", "composed_DATA", "computed_hash", "compressed_dat", "compress_memory", "compressed2table", "compress_Data", "compressed67bytes", "compressed_DATA", "compressed_bytes", "compress_str", "compacted_ata", "compress_data", "compacted_data", "compacted_dat", "computed67hash", "composed2DATA", "compacted_buffer", "computed_key", "compressed1Data", "compressed1data", "compressed_hash", "compressed_str", "computed67bytes", "compressed1ata", "compressed_table", "compressed1str", "computed_bytes", "compressed67hash", "composed_data", "compressed_buffer", "compressed_Data"]}}
{"project": "FFmpeg", "commit_id": "8bc80f8b24cb6f03ad209ce546ae594904c8b353", "target": 1, "func": "static int http_server(void)\n\n{\n\n    int server_fd, ret, rtsp_server_fd, delay, delay1;\n\n    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 2], *poll_entry;\n\n    HTTPContext *c, *c_next;\n\n\n\n    server_fd = socket_open_listen(&my_http_addr);\n\n    if (server_fd < 0)\n\n        return -1;\n\n\n\n    rtsp_server_fd = socket_open_listen(&my_rtsp_addr);\n\n    if (rtsp_server_fd < 0)\n\n        return -1;\n\n    \n\n    http_log(\"ffserver started.\\n\");\n\n\n\n    start_children(first_feed);\n\n\n\n    first_http_ctx = NULL;\n\n    nb_connections = 0;\n\n    first_http_ctx = NULL;\n\n\n\n    start_multicast();\n\n\n\n    for(;;) {\n\n        poll_entry = poll_table;\n\n        poll_entry->fd = server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        poll_entry->fd = rtsp_server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        /* wait for events on each HTTP handle */\n\n        c = first_http_ctx;\n\n        delay = 1000;\n\n        while (c != NULL) {\n\n            int fd;\n\n            fd = c->fd;\n\n            switch(c->state) {\n\n            case HTTPSTATE_SEND_HEADER:\n\n            case RTSPSTATE_SEND_REPLY:\n\n            case RTSPSTATE_SEND_PACKET:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLOUT;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_SEND_DATA_HEADER:\n\n            case HTTPSTATE_SEND_DATA:\n\n            case HTTPSTATE_SEND_DATA_TRAILER:\n\n                if (!c->is_packetized) {\n\n                    /* for TCP, we output as much as we can (may need to put a limit) */\n\n                    c->poll_entry = poll_entry;\n\n                    poll_entry->fd = fd;\n\n                    poll_entry->events = POLLOUT;\n\n                    poll_entry++;\n\n                } else {\n\n                    /* not strictly correct, but currently cannot add\n\n                       more than one fd in poll entry */\n\n                    delay = 0;\n\n                }\n\n                break;\n\n            case HTTPSTATE_WAIT_REQUEST:\n\n            case HTTPSTATE_RECEIVE_DATA:\n\n            case HTTPSTATE_WAIT_FEED:\n\n            case RTSPSTATE_WAIT_REQUEST:\n\n                /* need to catch errors */\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;/* Maybe this will work */\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_WAIT:\n\n                c->poll_entry = NULL;\n\n                delay1 = compute_send_delay(c);\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            case HTTPSTATE_WAIT_SHORT:\n\n                c->poll_entry = NULL;\n\n                delay1 = 10; /* one tick wait XXX: 10 ms assumed */\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            default:\n\n                c->poll_entry = NULL;\n\n                break;\n\n            }\n\n            c = c->next;\n\n        }\n\n\n\n        /* wait for an event on one connection. We poll at least every\n\n           second to handle timeouts */\n\n        do {\n\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n\n        } while (ret == -1);\n\n        \n\n        cur_time = gettime_ms();\n\n\n\n        if (need_to_start_children) {\n\n            need_to_start_children = 0;\n\n            start_children(first_feed);\n\n        }\n\n\n\n        /* now handle the events */\n\n        for(c = first_http_ctx; c != NULL; c = c_next) {\n\n            c_next = c->next;\n\n            if (handle_connection(c) < 0) {\n\n                /* close and free the connection */\n\n                log_connection(c);\n\n                close_connection(c);\n\n            }\n\n        }\n\n\n\n        poll_entry = poll_table;\n\n        /* new HTTP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(server_fd, 0);\n\n        }\n\n        poll_entry++;\n\n        /* new RTSP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(rtsp_server_fd, 1);\n\n        }\n\n    }\n\n}\n", "idx": 24542, "substitutes": {"server_fd": ["erver_fd", "server2fp", " server_fed", "server__f", "serverEfd", "serverTimeFD", "server_fn", "server2fn", "server__fd", " server2dir", "serverEfed", "ser_fd", "ser_FD", "server2fd", "server2f", " server2fd", "server_f", "server_fl", "erver_fee", "serverTimefd", " server_dir", " server2fl", "server2fl", "server__fi", "server__dir", "server__fp", "serverEfn", "ser_fp", "serverEfl", "server2dir", " server2fp", " server_fn", " server2fn", "server_fee", "serverTimefp", "server_fp", "server_fi", "server_dir", "server2fed", " server_fl", " server_f", "server_fed", "erver_fi", "server64fee", "server__fee", "server64fd", "serverTimefl", " server2fed", "ser_fl", " server2f", "server_FD", "server64fi", "server64fp", "erver_fp", " server_fp"], "ret": ["res", "result", "poll", "iter", "rt", "rets", "elt", "xff", "dt", "fun", "rx", "status", "Ret", "dy", "rel", "received", "RET", "flag", "dr", "resp", "fe", "done", "re", "alt", "ff", "err", "dl"], "rtsp_server_fd": ["rtsp_host_dl", "rtsp_client_fc", "rtsp_client_fee", "rtsp_host_fee", "rtsp_client2dl", "rtsp_server_fee", "rtsp_server___dl", "rtsp_client_fp", "rtsp_server2dl", "rtsp_client_dl", "rtsp_server___d", "rtsp_server_dl", "rtsp_client_dir", "rtsp_server_dir", "rtsp_server_fc", "rtsp_server2fp", "rtsp_client2fd", "rtsp_server___fd", "rtsp_server2fd", "rtsp_client2fp", "rtsp_client_fd", "rtsp_client2d", "rtsp_host_fd", "rtsp_server_d", "rtsp_client_d", "rtsp_server2d", "rtsp_client_pid", "rtsp_server___fp", "rtsp_server_addr", "rtsp_server_pid", "rtsp_server_fp", "rtsp_client_addr", "rtsp_host_pid"], "delay": ["command", "priority", "ait", "stop", "dp", "offset", "loop", "del", "driver", "distance", "timeout", "ay", "step", "lambda", "hold", "dq", "dt", "rate", "sequence", "duration", "shift", "send", "time", "buffer", "sleep", "da", "dy", "d", "dist", "rel", "depth", "pause", "seed", "sync", "size", "def", "dr", "label", "disable", "skip", "layout", "wait", "dl", "batch", "slow", "poll"], "delay1": ["sleep1", "loop2", "sleepone", "sleep2", "timeout1", "timeoutone", "delay2", "delayone", "timeout2", "loop1", "loopone"], "poll_table": ["poll_list", " poll_TABLE", "pollationtable", "pollationentry", "pollationinitial", "pull_entry", "poll2buffer", "poll2entry", "poll_initial", " poll_buffer", "pull_list", "poll_TABLE", "poll2table", "pull_initial", "poll2TABLE", "pollationlist", "poll_buffer", "pull_table"], "poll_entry": ["pool_entry", "poll_search", "voteptexit", "polllyleft", "question_match", "polllchild", "poll_item", "pollptowner", "pollvattribute", "polledwriter", "town_entry", "poll32entry", "pollacdef", "wait_handler", "polledgroup", "roll_row", "polllyowner", "download_entry", "pollDentry", "polloptable", "scrolloptable", "poll_exit", "pollFsystem", "scroll_input", "pollDsection", "download_queue", "poll_left", "poll_instance", "wait_entry", "poll_enter", "wait_owner", "pollFfunction", "cache_ry", "poll64Entry", "pool___ent", "pollgsearch", "poll32object", " poll_item", "pollableinter", "poll1entry", "polledkeeper", "pollptexit", "roll_entry", "pull_row", "roll_inter", "pollEsetting", "pool___system", "pollgargument", "pollerentry", "vote_def", "poll_argument", "polljentry", "pollopresult", "oll_entry", "polledtable", "poll_writer", "question_entry", "ollFfunction", "poll_function", "poll_element", "downloaderresource", "ollFentry", "oll_system", "scroll_table", "pollLentry", "pollopentry", "voteptry", "polledattribute", "poll_match", "poll64ry", "patch_option", "pollopinstance", "downloadptowner", "questiongattribute", "downloaderentry", "pollableentry", " poll_interface", " poll_member", "cache_Entry", "poll_ent", " poll_ent", "oll_attribute", "ollFsystem", "pollerry", "ollgdef", "poll32input", "pollLsystem", "cacheeriterator", "pollgdef", "pollgobject", " poll_row", "polllentry", " poll_array", "poll_member", "pollammuentry", "poll_attribute", "pollableenter", "pollerresource", "poll_Entry", "poll64exit", "poll1interface", "oll_def", "poll_setting", "pollDsetting", "polllyentry", "roll32enter", "download_resource", "polldair", "poll_group", "pollacexit", "poll_interface", "ollgentry", "downloaderqueue", " poll_internal", "cacheerEntry", "pollventry", "download_child", "pollophandler", "questiongmatch", "poll_air", "polleddef", "pollammugroup", "pollingent", "waitopinstance", "waitopair", "pool_ent", "pollingrow", "voteptentry", "polljneeded", "wait_result", "vote_ry", "pollfentry", "poll_resource", "vote_group", "pollginput", "poll_keeper", " poll_element", "polleriterator", "patch64Entry", "polledentry", "poll_cell", "pollgentry", "poll_child", "pollopair", "poll_input", "downloaderneeded", "pollfelement", " poll_left", "cacheerentry", "pollgattribute", "cache_iterator", "pollptchild", "pull_cell", "Poll_option", "poll___ent", "patch_Entry", "poll_inter", "pollerEntry", "pollfinternal", "poll64option", "polldinstance", "cache_entry", "pollerneeded", "question_attribute", "pollerqueue", "roll32row", "poll___entry", "pollvargument", "scroll_entry", "pool_system", "questiongentry", "roll_enter", "pollptdef", "polldowner", "download_needed", "pollLfunction", "polledinterface", "ollgwriter", "poll32enter", "townEsetting", "pollgwriter", "patch64option", "scroll_object", "poll64def", "poll_result", "downloadptchild", "scrollopentry", "pollgmatch", "voteptdef", "wait_air", "poll_internal", "pollacry", "pollEsection", "poll_system", "vote_exit", "poll___system", "vote_keeper", "waitopowner", "poll_array", "poll1table", "downloadptentry", "polllowner", "patch_entry", "pollopowner", "oll_function", "Poll_entry", "pollingarray", "polljresource", "poll32inter", "roll32entry", "scrollopobject", "pull_entry", "wait_instance", "pollEentry", "polldentry", "pollopobject", "cacheerry", " poll_search", "pollgtable", "ollgattribute", "pollptry", "pollammukeeper", "Poll_element", "pollacentry", "poll_ry", "townEsection", "polllymember", "polllyair", "pollingentry", "roll32inter", "scrollopinput", "town_setting", "town_section", "poll_iterator", "poll_option", "poll_row", "poll_def", "pool___entry", "question_argument", "pollgitem", "polljqueue", "poll64entry", "polllyinstance", "pollablerow", "pollvmatch", "poll32table", "patch64entry", "pollopinput", "poll_needed", "poll_handler", "poll32row", "questiongargument", "poll_object", "waitophandler", "pollptentry", "voteedgroup", "download_owner", "vote_entry", "townEentry", "waitopentry", "oll_writer", "voteedentry", "poll_queue", "voteedkeeper", "waitopresult", "poll_owner", "pollFentry", "poll_section"], "c": ["v", "cache", "pc", "n", "cmp", "cl", "cv", "gc", "co", "anc", "cd", "f", "ce", "cb", "lc", "cr", "ci", "mc", "fc", "toc", "b", "xc", "bc", "dc", "cs", "t", "cu", "ca", "lib", "ac", "ec", "p", "e", "m", "comm", "com", "cc", "cf", "ct", "cp", "call", "enc", "C", "h", "con", "rc", "cur", "cont", "conf", "tc", "vc", "cm", "ctrl", "abc", "ch", "ctx"], "c_next": ["cjcurrent", "h_next", "c_prev", "h_response", "c_current", "h_prev", "cjprev", "h_current", "cjresponse", "cjnext", "c_response"], "fd": ["df", "dll", "dn", "fin", "dd", "db", "fr", "bf", "fa", "fs", "cd", "f", "gd", "wd", "td", "cb", "FD", "elt", "fc", "pid", "fn", "ffff", "rd", "dt", "func", "handler", "lf", "dc", "du", "dir", "uf", "fm", "port", "dat", "draw", "sd", "fps", "fl", "buffer", "fx", "ds", "dig", "dist", "d", "dy", "pd", "da", "fee", "stream", "fb", "nd", "fed", "fp", "ld", "dr", "fi", "fe", "addr", "handle", "wait", "ff", "dial", "dra", "ptr", "buf", "socket", "desc", "ind", "dl"]}}
{"project": "FFmpeg", "commit_id": "f3c0e0bf6f53df0977f3878d4f5cec99dff8de9e", "target": 0, "func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n\n                               const uint8_t *buf, int buf_size,\n\n                               int first_field)\n\n{\n\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n\n    int i, cid, ret;\n\n\n\n    if (buf_size < 0x280)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5)) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"error in header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf[5] & 2) { /* interlaced */\n\n        ctx->cur_field = buf[5] & 1;\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n\n    }\n\n\n\n    ctx->height = AV_RB16(buf + 0x18);\n\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n\n\n    av_dlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height);\n\n\n\n    ctx->is_444 = 0;\n\n    if (buf[0x4] == 0x2) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n\n        }\n\n        ctx->is_444 = 1;\n\n    } else if (buf[0x21] & 0x40) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n\n        }\n\n    } else {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n\n        ctx->avctx->bits_per_raw_sample = 8;\n\n        if (ctx->bit_depth != 8) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 8;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n\n        }\n\n    }\n\n\n\n    cid = AV_RB32(buf + 0x28);\n\n    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n\n        return ret;\n\n\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ctx->mb_width  = ctx->width >> 4;\n\n    ctx->mb_height = buf[0x16d];\n\n\n\n    av_dlog(ctx->avctx,\n\n            \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);\n\n\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n\n        ctx->height <<= 1;\n\n\n\n    if (ctx->mb_height > 68 ||\n\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR,\n\n               \"mb height too big: %d\\n\", ctx->mb_height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (i = 0; i < ctx->mb_height; i++) {\n\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n\n        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24555, "substitutes": {"ctx": ["acl", "command", "cookie", "obj", "conn", "util", "exec", "anc", "lp", "jp", "aux", "that", "tx", "cb", "loc", "mc", "kt", "cmd", "pkg", "xc", "func", "ctl", "tm", "hw", "expr", "tz", "wcs", "px", "def", "conf", "np", "qq", "tk", "c", "nc", " cx", "nt", "gc", "history", "iat", "ns", "inst", "lc", "std", "act", "kick", "ct", "cp", "crit", "check", "addr", "module", "handle", "cm", "ctrl", "kw", "cfg", "raw", "and", "ca", "cv", "iac", "cam", "ij", "xp", "wx", "context", "timeout", "mk", "pool", "kk", "fw", "new", "conv", "cn", "cf", "ck", "resp", "Context", "sys", "tmp", "proc", "etc", "alloc", "abc", "cmp", "co", "cas", "kl", "setup", "req", "mom", "cc", "jac", "pause", "ka", "tc", "jpg", "scope", "x", "utils"], "frame": ["init", "data", "iframe", "command", "scene", "face", "fr", "rame", "next", "feature", "file", "sp", "f", "config", "context", "tx", "event", "seq", "ce", "ace", "lock", "process", "state", "cmd", "block", "se", "feat", "info", "fw", "fram", "sequence", "image", "component", "zone", "version", "chain", "code", "function", "buffer", "format", "cf", "line", "list", "window", "base", "cpu", "position", "point", "row", "module", "x", "Frame", "set"], "buf": ["data", "v", "cv", "cache", "cmp", "result", "cam", "bp", "db", "length", "bar", "bf", "history", "bg", "mem", "tx", "seq", "buff", "cb", "b", "rb", "vec", "box", "cmd", "pkg", "bytes", "func", "grad", "len", "bl", "uf", "conv", "ref", "deg", "doc", "bh", "buffer", "aka", "pad", "queue", "pack", "bn", "window", "fb", "foo", "burst", "Buffer", "img", "Buff", "nm", "np", "br", "mat", "bs", "ctr", "cap", "tmp", "desc", "pb", "batch", "proc", "msg", "orig", "bu", "emb"], "buf_size": ["buf_offset", "buf2size", "buf_loc", "buf2offset", "buf_ize", " buf2Size", "buffer_ize", "buf2Size", " buf2size", " buf2offset", " buf_Size", " buf_offset", "buffer_Size", "buffer_loc", "buffer_size", "buf_Size"], "first_field": ["first___field", " first_key", " first___Field", "first__field", "first_Field", "initial_fix", "first_len", "initial_field", " first___len", "first_key", "first___Field", "first_byte", "firstFieldField", " first_Field", "first___len", "initial_key", "firstFieldfield", "firstFieldkey", "first__len", "first___key", " first___key", "first__Field", "initial_byte", " first_len", "first_fix", "firstFieldlen", "first__key", " first___field"], "header_prefix": ["frame_prefix", "frame67field", "header_field", "header67origin", "frame_field", "frame67origin", "frame_base", "header___prefix", " header_master", "header_base", "frame_origin", "header_origin", "frame67base", "header__prefix", "header67base", "header__origin", "header__base", "header_pkg", "header67field", " header_pkg", "header__field", "header___pkg", "frame67prefix", "header_master", "header67prefix", "header___master"], "header_prefix444": ["header_fix444", "header_ring444", "header_format483", "header_ring411", "header_prefix483", "header_buffer444", "header_prefix420", "header___type444", "header_buffer345", "header_type411", "header_type420", "header_ring420", "header_format345", "header_format444", "header_prefix345", "header_format450", "header_prefix450", "header___type420", "header___prefix420", "header_prefix411", "header_buffer450", "header___prefix411", "header___prefix444", "header_fix450", "header_buffer483", "header_type444", "header_fix345", "header___type411", "header_fix483"], "i": ["v", " j", "li", "ij", "ix", "ai", "ci", "ki", "di", "ii", "mi", "ip", " bi", "m", " ii", "pi", " mi", "l", "fi", "iy", " ti", "ti", "j", "y", "it", "si", "bi", "I"], "cid": ["recvid", "chanID", "cfID", "cfId", "cfvid", "chanId", "cvid", "recid", "recID", "cID", "recId", "cId", "cfid", "chanvid", "chanid"], "ret": ["url", "tif", "res", "result", "txt", "val", "aux", "rt", "mem", "reset", "new", "len", "fun", "ref", "out", "Ret", "rel", "mt", "RET", "flag", "rc", "resp", "alt", "desc"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559, "substitutes": {"pval": ["pingval", "pVAL", "pdata", "phpVal", "pvals", "mVal", "Preg", " preg", "phpdata", " pVAL", "tVal", " pcal", "Ppol", "phpreg", "paval", "Pvalue", "mVAL", "phpval", "preg", " ppol", " paval", "prel", "tvalue", "pingdata", "pvalue", "pingcal", "tval", "PVal", "ppol", "phpvals", " pvals", "phppol", "pVal", " pdata", "Pval", "Pvals", " prel", "pcal", "mvalue", "phpaval", "Prel", "PVAL", "phpcal", " pvalue", "mval", "phprel", "pingaval", " pVal"], "name": ["ma", "data", "command", "n", "text", "on", "in", "none", "named", "mask", "family", "local", "file", "kind", "mem", "group", "parent", "NAME", "tag", "action", "description", "state", "cmd", "class", "info", "names", "path", "t", "comment", "key", "ref", "version", "unknown", "m", "p", "str", "status", "code", "call", "title", "id", "prefix", "base", "no", "old", "value", "def", "nm", "nam", "word", "type", "ame", "alias", "c", "normal", "Name", "term", "w"], "md": ["dm", "obj", "dd", "ms", "sam", "managed", "mc", "cmd", "mx", "add", "tm", "mm", "sd", "bd", "nd", "att", "def", "MD", "dj", "ind", "ann", "nt", "det", "td", "wd", "mn", "di", "cond", "grad", "dem", "der", "doc", "bind", "pd", " cmd", "d", "ct", "ng", "df", " dd", "mid", "del", "bf", "mod", "mk", "ded", "esm", "m", "multi", "dat", "ds", "mt", "ad", " Md", "dr", "ld", "mand", "ord", "msg", "amd", "sm", "mb", "ma", "dn", "cd", "mem", "og", "ud", "mi", "man", "metadata", "mp", "pt", "mind", "od", "hd", "de", "met", "dl"], "ptr": ["prototype", "pc", "tp", "adr", "dep", "ped", "iter", "offset", "txt", "prime", "jp", "sp", "pl", "inst", "pointers", "then", "tr", "td", "buff", "loc", "ts", "attr", "address", "t", "arr", "ref", "req", "butt", "p", "str", "pad", "pt", "dev", "buffer", "dh", "rel", "inter", "pack", "rob", "eth", "cur", "dr", "ctr", "pointer", "np", "row", "map", "addr", "Ptr", "handle", "pr", "index", "pos", "proc", "alloc", "ps", "ind", "rect", "ctx"], "env": ["init", "er", "ve", "v", "cv", "obj", "ped", "dep", "conn", "db", "ext", "txt", "sp", "uv", "bean", "priv", "context", "cb", "loc", "var", "cmd", "attr", "pkg", "eu", "pres", "vt", "shell", "e", "eng", "en", "dev", "environment", "org", "nv", "ew", "ef", "window", "ev", "rc", "vs", "conf", "np", "now", "open", "tmp", "cap", "tk", "pen", "pb", "buf", "proc", "qt", "exc", "po", "ctx"]}}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578, "substitutes": {"env": ["eco", "v", "cv", "obj", "enter", "conn", "server", "uv", "viron", "net", "config", "context", "mem", "vm", "cb", "kw", "act", "ec", "erd", "tm", "e", "code", "hw", "eng", "en", "environment", "dev", "ah", "org", "te", "esc", "window", "ev", "ef", "here", "gov", "sc", "con", "cur", "vs", "conf", "home", "desc", "proc", "ptr", "et", "exc", "nc", "enc", "ctx"], "frame_addr": ["frame_address", "trace_ref", "frame_prefix", "trace_address", "frame_ptr", "frame___prefix", "frame2ptr", " frame_address", "frame__address", "trace_addr", "frame2addr", "frame2address", "frame__ptr", "frame___ref", "trace_prefix", "frame_ref", " frame_ptr", "frame__addr", "frame___addr", "frame___address"], "uc": ["urn", "ucc", "uk", "oc", "upt", "ub", "anc", "uv", "ut", "ocr", "ou", "mc", "ux", "fc", "ud", "um", "uca", "bc", "uma", "cu", "du", "auc", "uf", "uh", "ec", "u", "nic", "ul", "orc", "uph", "uch", "sc", "rc", "uu", "uci", "userc", "tc", "usc", "unc", "alloc", "clus", "ui", "UC"], "host_set": ["h_map", "h_Set", "host_list", "addr_set", "hostnameset", "hostmodSet", "target_value", "hostnamesc", "h_set", "hostnameSet", "host___mask", "host_value", "host___list", "addr_sets", "host_map", "hmodmap", "host_mask", "target_list", "hostmodsc", "h_sc", "hostnamemap", "hostmodset", "target_mask", "hostmodmap", "addr_map", "hmodsc", "target_set", "host_Set", "host_sets", "addr_mask", "host_sc", "hmodset", "host___value", "hmodSet", "host___set"], "regspace": ["funcsid", "funcSpace", "regSpace", "functab", "pgsid", "memtab", "pgspace", "pgtab", "funcspace", "regsid", "regtab", "memsid", "memSpace", "pgSpace", "memspace"]}}
{"project": "qemu", "commit_id": "619d11e4631000f20318dec90b87f314272bfa4a", "target": 0, "func": "FWCfgState *pc_memory_init(MemoryRegion *system_memory,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           ram_addr_t below_4g_mem_size,\n\n                           ram_addr_t above_4g_mem_size,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"pc.ram\",\n\n                           below_4g_mem_size + above_4g_mem_size);\n\n    vmstate_register_ram_global(ram);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 24588, "substitutes": {"system_memory": ["system_cache", "systemitymedia", "sys_cache", "system_mem", "system_media", "systemitydatabase", "systemalstorage", "sys_activity", "systemitymemory", "systemalactivity", "sys_maximum", "sys_storage", " system_mem", "systemitymem", "sys_memory", "systemalmemory", "systemalmaximum", " system_media", "system_database", "system_activity", "system_maximum", " system_database", "system_energy", "system_storage", "sys_energy"], "kernel_filename": ["kernel2file", "kerneloxfilename", "kernel_header", "kernel2Filename", "kerneloxFilename", "kerneloxheader", "system_Filename", "kernel2filename", "disk_filename", "system_header", "disk_directory", "disk_file", "kernel_file", "kerneloxfile", "kernel_Filename", "kernel2directory", "disk_Filename", "system_file", "kernel_directory", "system_filename"], "kernel_cmdline": ["kernel_commandlist", "kernel_programlist", "kernel_commandl", "kernel_programl", "kernel_cpline", "kernel_cmdl", "kernel_commandline", "kernel_cplist", "kernel_cmdlist", "kernel_cpl", "kernel_programline"], "initrd_filename": ["initringuartfolder", "initringuartflags", "initrdfileflags", "initrd_location", "initrdfilefolder", "initrd_flags", "initrd_folder", "initrdfilelocation", "initring_filename", "initrduartfolder", "initrduartlocation", "initringuartfilename", "initring_flags", "initrduartfilename", "initring_location", "initrdfilefilename", "initrduartflags", "initring_folder", "initringuartlocation"], "below_4g_mem_size": ["below_4g_memory_to", "below_4g_mem2SIZE", "below_4g_mem2size", "below_4g_mem_Size", "below_4g_memory_Size", "below_4g_memssize", "below_4g_mem_sum", "below_4g_mem2name", "below_4g_memsSize", "below_4g_memory_size", "below_4g_mem_name", "below_4g_memsto", "below_4g_Mem_SIZE", "below_4g_mem_to", "below_4g_Mem_sum", "below_4g_mem_member", "below_4g_Mem_size", "below_4g_mem_SIZE"], "above_4g_mem_size": ["above_4g_Mem_Size", "above_4g_memLsize", "above_4g_mem_SIZE", "above_4g_mem2name", "above_4g_mem2SIZE", "above_4g_mem_Size", "above_4g_mem_power", "above_4g_Mem_sum", "above_4g_memLSIZE", "above_4g_Mem_size", "above_4g_memLpower", "above_4g_mem_sum", "above_4g_Mem_name", "above_4g_Mem_power", "above_4g_Mem_SIZE", "above_4g_mem2size", "above_4g_mem_name"], "rom_memory": ["system_queue", "romplememory", "system_session", "rom_mem", "rom_queue", "romplesession", "rom___storage", "rom___memory", "rom___queue", "romplestorage", "rom___session", "rom_session", "rom_library", "system_storage", "rom_storage", "romplequeue", "ram_mem", "ram_library", "ram_storage"], "ram_memory": ["rom_address", "ram_media", "ram2memory", "ram__media", "system_address", "system_media", "ram___address", "ram___storage", "ram_address", "ram___media", "ram2address", "rom_media", "ram__address", "ram___memory", "ram__reference", "ram2media", "ram_reference", "ram__memory", "system_storage", "rom_reference", "ram2storage", "ram_storage"], "guest_info": ["guer_information", "guess_id", "guer_info", "guess_settings", "guest_Info", "guest_information", "guess_info", "guest_id", "guest_settings", "guess_Info", "guer_Info"], "linux_boot": ["Linux_linux", "Linux_boot", "linux8boot", "linux8linux", "Linux_Boot", "linux_Boot", "linux8Boot", "Linux_oot", "linux_oot", "linux_linux", "Linux_start", "linux_start", "linux8start"], "i": ["ir", "n", "k", "li", "f", "b", "r", "ci", "di", "ii", "t", "mi", "m", "p", "g", "pi", "ib", "l", "fi", "ti", "phi", "j", "c", "y", "it", "si", "bi", "I"], "ram": ["ma", "rem", "gram", "res", "RAM", "storm", "cam", "ray", "range", "raw", "usage", "rom", "sam", "serv", "gray", "am", "mem", "amd", "go", "tx", "ru", "vm", "mb", "rum", "reg", "mc", "core", "alloc", "program", "Ram", "mix", "um", "sum", "ry", "tem", "area", "dem", "ank", "win", "lib", "mac", "lam", "sim", "mm", "my", "sd", "scan", "hw", "dev", "rank", "rm", "region", "im", "memory", "cpu", "ra", "rain", "row", "gem", "ream", "tar", "ame", "gra", "dim", "ro", "ance", "iam", "AM", "sky"], "option_rom_mr": ["optionalsromexec", "option_mem_rs", "option_mem_kr", "option_rom__rs", "option_chrom_vr", "option_rom_rm", "optionalsraexec", "option_rom2rm", "option_rom_vr", "option_romexec", "option_mem_hr", "option_rom2vr", "option_rom__hr", "option_chrom_hr", "option_rom__kr", "option_chrom_mr", "option_rom2hr", "option_rom_rs", "option_raexec", "option_rom2mr", "option_mem_mr", "option_rom_hr", "option_rom__mr", "option_memexec", "option_chrom_rm", "option_cmexec", "option_rom_kr"], "ram_below_4g": ["ram_below_04gu", "ram_below_04d", "ram_below_2g", "ram_below_4l", "ram_below_2p", "ram_below_2v", "ram_below_fourG", "ram_below_5g", "ram_below_04v", "ram_below_4j", "ram_below_5l", "ram_below_04g", "ram_below_8g", "ram_below_5d", "ram_below_8j", "ram_below_fourg", "ram_below_2l", "ram_below_4d", "ram_below_4gu", "ram_below_2j", "ram_below_44g", "ram_below_2gu", "ram_below_fourv", "ram_below_8l", "ram_below_2G", "ram_below_fourj", "ram_below_04j", "ram_below_4v", "ram_below_4G", "ram_below_04G", "ram_below_44l", "ram_below_2d", "ram_below_8p", "ram_below_44G", "ram_below_5j", "ram_below_4p", "ram_below_44j"], "ram_above_4g": ["ram_above_04j", "ram_above_fourm", "ram_above_4l", "ram_above_fourl", "ram_above_2j", "ram_above_4G", "ram_above_4f", "ram_above_04l", "ram_above_5l", "ram_above_44g", "ram_above_fourgi", "ram_above_5v", "ram_above_2m", "ram_above_44l", "ram_above_4v", "ram_above_5gi", "ram_above_5j", "ram_above_2f", "ram_above_49g", "ram_above_5m", "ram_above_2g", "ram_above_49og", "ram_above_14v", "ram_above_fourg", "ram_above_44j", "ram_above_14g", "ram_above_5og", "ram_above_2gi", "ram_above_44G", "ram_above_fourj", "ram_above_4j", "ram_above_04G", "ram_above_44f", "ram_above_49l", "ram_above_2l", "ram_above_4m", "ram_above_04g", "ram_above_5g", "ram_above_14l", "ram_above_4og", "ram_above_14og", "ram_above_4gi", "ram_above_49v"], "fw_cfg": ["hw_fg", "fw_config", "fw__config", "fw_conf", "fw_fg", "hw_config", "fw__cfg", "hw_conf", "hw_cfg", "fw__fg", "fw__conf"]}}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603, "substitutes": {"vs": ["sv", "vals", "v", "ails", "vp", "hs", "ues", "ks", "js", "ms", "ses", "changes", "obs", "fs", "ils", "blogs", "ns", "VS", "vm", "ss", "pages", "vd", "ps", "plays", "ts", "ops", "cs", "pins", "vt", "sb", "ins", "fps", "lines", "ds", "ls", "values", "views", "wcs", "heads", "rs", "lists", "helps", "s", "ques", "lbs", "stats", "sts", "bs", "atts", "its", "Vs", "vc", "xs", "vr"], "keysym": ["codesys", "codesy", "codesym", "namesemb", " keysy", " keysemb", "namesym", "ksemb", " keyssym", "ksym", "keyssym", "keysymm", "ksy", "ksymm", "ksys", "keysys", " keysymm", "namesy", "namesymm", "keysy", " keysys", "codessym", "keysemb", "kssym"]}}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static void s390_virtio_device_sync(VirtIOS390Device *dev)\n\n{\n\n    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    ram_addr_t cur_offs;\n\n    uint8_t num_vq;\n\n    int i;\n\n\n\n    virtio_reset(dev->vdev);\n\n\n\n    /* Sync dev space */\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n", "idx": 24606, "substitutes": {"dev": ["obj", "dd", "util", "conn", "die", "range", "th", "build", "driver", "val", "cmd", "pkg", "patch", "add", "scan", "watch", "hw", "app", "develop", "vol", "def", "des", "home", "form", "normal", "disc", "w", "nt", "pay", "cast", "db", "DEV", "det", "var", "grad", "dem", "der", "doc", "pad", "device", "debug", "Dev", "d", "pack", "desc", "dis", "prop", "ver", "raw", "data", "cam", "ow", "priv", "mod", "spec", "oy", "comment", "ad", "prom", "test", "v", "ve", "gu", "md", "server", "stick", "serv", "end", "pro", "mem", "ay", "go", "block", "req", "draw", "ev", "roy", "od", "game", "de", "av", "err", "sky"], "bus": ["nt", "Bus", "bridge", "gen", "is", "usb", "util", "db", "loop", "bar", "way", "driver", "host", "disk", "self", "serv", "local", "link", "config", "lock", "b", "box", "hub", "block", "hand", "board", "bc", "proxy", "boot", "lib", "ac", "mount", "chain", "out", "device", "os", "bank", "base", "vol", "con", "us", " BUS", "bs", "type", "handle", "vc", "buf", "c", "BUS", "bolt", "port"], "cur_offs": ["cur_pos", "cur_posts", " cur_ups", "cur_outs", "cur_ops", " cur_ops", " cur_outs", "cur___outs", "cur___phones", "cat_offs", "cur___offs", "cat_opens", " cur_posts", " cur_pos", "cat_off", "cur___off", "cur_phones", "cat_phones", "cur_off", "cur_opens", " cur_off", "cur_ups", "cur___ups", "cur___opens"], "num_vq": ["num_svq", "num_veQ", "num_vsQ", "num_vsple", "num___vsig", "numoothvq", "num_vinck", "num_veq", "num_svQ", "num_vsq", "num_vmig", "num_vmQ", "num_svqu", "num___vQ", "num_vmq", "num_vue", "numoothvqs", "num_qucu", "numoothquq", "num___vsQ", "num_uQ", "num___vsq", "num_fq", "num_fqs", "num_veue", "num_svqi", "num_vqu", "num_veck", "numoothvQ", "num_visqi", "num_vinqi", "num_vqs", "num_vinq", "num_vsig", "num_vick", "num_vique", "num_fQ", "numoothquqs", "num_visq", "num_vck", "num_svqs", "num_veqs", "num_vinQ", "num___vig", "num_vple", "num_vqi", "num___vple", "num_visQ", "num_vinf", "num_avqs", "num_vf", "num_quqs", "num_vque", "num_svf", "num_vmple", "num_uq", "num_avq", "num___vq", "num_veque", "num_quQ", "num_vinque", "num_viue", "num_uqu", "num_fple", "num_avQ", "num_fig", "num_vig", "num_vQ", "num_uqs", "numoothqucu", "num_vequ", "num_visf", "numoothquQ", "num_fcu", "num_viq", "num_quq", "numoothvcu", "num_vinue", "num_vcu", "num___vsple", "num_avcu"], "i": ["qi", "v", "asi", "is", "iq", "n", " I", "me", "in", "ind", "li", " ni", "ij", "o", "ix", "xi", "ai", "ami", "ini", "gi", "ci", "ki", " multi", "di", "hi", "ii", "t", "mi", "ip", " bi", "ei", " m", "ims", "sim", "m", "multi", "cli", "ic", "my", "name", "ui", "ri", "e", "p", " ii", "u", "pi", " v", "id", " mi", "\u0438", "im", "h", "iu", "s", " pi", " ti", " index", "ti", "zi", "j", "batch", "x", "phi", "index", "y", "it", "si", "bi", " si", "I"], "vring": ["svri", "vlic", "wling", "wjing", "ivri", "ivling", "vmng", "wring", "svring", "svg", " vlic", "qvstring", " vrings", "ivring", "vbinding", "svbinding", " vg", "frings", "vmlic", "svng", "flic", "fng", "wstring", "fring", "vmring", "svling", "mbinding", "vri", "vrings", "vjing", "qvjing", "qvring", " vng", " vri", "mng", "mling", " vjing", "vstring", "ivg", "qvling", "vling", "vg", " vbinding", "vmrings", " vling", " vstring", "mring", "vng"]}}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n", "idx": 24621, "substitutes": {"_src": ["_sys", "_rc", "___ser", " _ser", "_ser", " _sys", "___rc", " _source", "___source", "_source", " _rc", "___src"], "stride": ["STRuse", "volide", "stringider", "volice", "slice", "STRimate", "strride", "strice", "scheider", "voline", "stringride", "Strate", "STRode", "strimate", "stringide", "strope", "Strride", "STRine", "trice", "Strine", "brride", "striine", "Strimate", "stringision", " strine", "slision", "brate", "scheine", "stine", "slider", "stringine", "tride", " strate", "striride", "Strice", "stide", "struse", "Strider", "strate", "trider", "slide", " strider", "strision", "STRide", "arrice", "strode", "arrine", "Strope", " strimate", "Stride", "stuse", "brope", "scheride", " strope", "trision", "volride", "arrride", "sline", "STRider", " strride", "strider", "scheide", "slode", "STRice", "arride", "strine", "stringice", "bride", "striide", "STRride", " strode", "striuse"], "i": ["qi", "ex", "ix", "xi", "ami", "mc", "ii", "oi", "ip", "ei", "PI", "p", "e", "my", "id", "io", "s", "zi", "y", "php", "bi", "ind", "I", "er", "to", "n", "iter", "ci", "di", "iii", "pi", "iu", " ti", "phi", "ik", "init", "is", "iq", "me", "ij", "print", "f", "ini", "r", "gi", "hi", "this", " bi", "cli", "sim", "ri", "m", "multi", "ic", "MI", " ii", "\u0438", "im", "dr", "l", "j", "index", "ie", "si", "in", "li", "ai", "go", "ji", "ki", "info", "at", "mi", "key", "ims", "o", "g", "name", "q", "uri", "point", "err", "ti", "batch", "x", "it", "ui", "port"], "dc0": ["dc50", "DC0", "ccazero", "dc1", "dc00", "rc0", "rcZero", "ccaator", "dcZero", "dczero", "bc9", "dcator", " dc1", "fc0", " dcZero", "bc50", " dc7", " dc9", " dc6", "disc2", "disc7", "bc0", "DC7", " dczero", "dc9", "cca6", "disc0", "bc6", " dcator", "bc2", " dc50", " dc00", "DC1", "rc00", "disc50", "cca0", "bcator", "disc9", "dc7", "disc1", "dc6", "fc00", "fcZero", "bczero"], "dc2": ["cd02", "cd5", " dc02", "fc3", "cd3", "di2", "lc2", "dc02", "dc4", "dcTwo", "fc02", "fc0", "fc_", "discTwo", " dc_", "disc5", "diTwo", "di02", "cd2", "disc2", "di3", "bc0", "lc4", "dc5", "lcTwo", "disc0", "disc3", "bc2", " dc4", "dc_", " dcTwo", "fc5", "cd0", "di4", "bc3", "fc2", "dc3", "cdTwo", "bcTwo", "di_", " dc3", "disc02"], "dc0splat": ["dc0splatted", "dc5splatted", "dc5splat", "dc0bspatch", "dc5splats", "dc0explats", "dc0splAT", "dc0scatch", "dc0splats", "dc2split", "dc0polAT", "dc0polat", "dc0plit", "dc0split", "dc0splitats", "dc0separitter", "dc5splitat", "dc0plant", "dc2Splant", "dc0Splant", "dc0splititter", "dc0Split", "dc0scit", "dc1plat", "dc0separat", "dc0separatted", "dc0separats", "dc0bspit", "dc2SplAT", "dc0polit", "dc0bspicit", "dc0splitatted", "dc0splitat", "dc2Splat", "dc0Splat", "dc1splat", "dc2splant", "dc0scat", "dc0splicit", "dc1plit", "dc1splatch", "dc0plat", "dc0platch", "dc0bspat", "dc0explat", "dc5splititter", "dc0plAT", "dc2splAT", "dc0scicit", "dc5splitter", "dc0SplAT", "dc0explitter", "dc1plicit", "dc0explatted", "dc0splant", "dc1splicit", "dc5splitats", "dc0splitter", "dc2Split", "dc0splatch", "dc1platch", "dc5splitatted", "dc0polant", "dc0plicit", "dc1split"], "dc2splat": ["dc2spat", "dc2splitat", "dc1SplAT", "dc2plat", "dc2platio", "dc2Splate", "dc7splitate", "dc1Splot", "dc7splatio", "dc2plit", "dc2split", "dc7splate", "dc3splAT", "dc2plate", "dc2Splatio", "dc2spate", "dc3SplAT", "dc2splitit", "dc2SplAT", "dc2spot", "dc2splatio", "dc2Splat", "dc7splitatio", "dc1splat", "dc7split", "dc2splot", "dc7splat", "dc2splate", "dc2splitatio", "dc3splat", "dc3splate", "dc2splitate", "dc2splAT", "dc2Splot", "dc1Split", "dc1splAT", "dc7splitit", "dc2plot", "dc7splitat", "dc3Splat", "dc1splot", "dc3split", "dc2Split", "dc2spit", "dc2plAT", "dc2spAT", "dc3Splate", "dc3Split", "dc1Splat", "dc1split"], "src": ["via", "dest", "url", "obj", "tp", "ur", "sr", "iter", "ser", "slice", "txt", "source", "rt", "config", "inst", "rl", "hl", "seq", "loc", "supp", "r", "fc", "usr", "attr", "pkg", "spec", "iv", "bc", "RC", "filename", "req", "sb", "ins", "scan", "cli", "str", "sl", "dist", "sw", "sup", "sur", "syn", "sync", "rs", "sc", "cur", "img", "rc", "st", "ctr", "sys", "input", "tmp", "cont", "bs", "addr", "usc", "proc", "ptr", "sn", "inner", "vr", "root", "rect"]}}
{"project": "FFmpeg", "commit_id": "48aecf5a7dd8e914d44cb4210a09172dbd8d5d86", "target": 1, "func": "static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n", "idx": 24625, "substitutes": {"poutbuf": ["poldcb", "poutbound", "psongbatch", "tinbuffer", "poutbatch", "paoutfac", "psoutvec", "pOutbuf", "panotbin", "pinnerproc", "panotbuf", "poubuffer", "paoubuf", "Poutbuffer", "poutscat", "pioutrc", "panotfac", "poutscache", "poubuf", "paouterport", "toutbuf", "poutsbin", "pouterbuf", "poutvec", "poutbuff", "poutfunc", "pourbox", "paoutpkg", "pnotbin", "pouterbag", "poutcat", "paoutbc", "poutbox", "poutsbuf", "poutsfac", "poutqueue", "pentbuf", "pwbuff", "pOutqueue", "pOutbuffer", "paoutcache", "pdobuf", "poutsbound", "pexiter", "pioutcb", " poutbuffer", "pinnerbuf", "pwbuf", "paoufunc", "poutiter", "pinbin", "pincv", "pongbatch", "poldbuf", "pOutbuff", "Pinbuf", "pexbox", " pexbound", "pinnerbuffer", "pinnervec", "poutpkg", "pexbuf", "poldbag", "pentstream", "pOutproc", "panotcache", "pinbuf", "panditer", "poutsbc", "poutcb", "pourbound", "poutcache", "pourbuffer", "psoutbatch", "pnotbuf", "pongbuf", "paoubuffer", "pioutbuf", "poufunc", "psoutbuf", "paontcat", "ponfac", "pandpkg", " pexbuffer", "paouterpkg", "poutrc", "pontbound", "paoubin", "paoutbin", "pontbc", "paouteriter", "pouterpkg", "piongrc", "tincv", "pinnerbatch", "toutcv", "pinnerbin", "poutbin", " pexbox", "pinnerstream", "toutbuff", "toutbuffer", "pinbound", "pouteriter", "pontbuf", "Poutproc", "Poutqueue", "piongbag", "pinnerfunc", "pnotcache", " poutbound", "pinproc", "paouterbuf", "pwbuffer", "paontbound", "paontbuf", "poutbc", "pnotfac", "pouterrc", "pexport", "paoutfunc", "poutfac", "pdocat", "pinbox", "psoutstream", "pongbag", "pinbuffer", "pexbuffer", "poutcv", "pdobc", "pOutcv", "poutport", "ponbuf", "pontcat", "pandport", "Pinqueue", "pentbatch", "piongbuf", "poutbag", "paontbc", "pentvec", "pexbound", "poubin", " poutbox", "tinbuf", "Pinbuffer", "poutbuffer", "paoutport", "pioutbag", "poutercb", "piongcb", "psongbuf", "ponbin", "poutstream", "psongstream", "pdobound", "tinbuff", "pourbuf", "pinqueue", "pongrc", "paoutbuffer", "psongvec", "pwcv", "pongcb", "pexpkg", "pinnerqueue", "poncache", "Pinproc", "paoutcat", "pinbuff", "poldrc", "paoutbuf", "paoutiter", "pandbuf", " pexbuf", "pouterport", "paoutbound", "pinfunc", "poutproc", "Poutbuf", "pongvec", "pongstream"], "poutbuf_size": ["poutbuffer_space", "poutbuf_length", "poutbuf_sy", "poutqueue_SIZE", "poutqueue_size", "poutbuffer_len", "poutbuffer_name", "poutbuffer_length", "poutbuffer_ize", "poutqueue_sy", "poutbuf_Size", "poutqueue_Size", "poutbuf_SIZE", "poutbuf_ize", "poutbuffer_Size", "poutbuf_space", "poutbuffer_size", "poutbuf_name", "poutbuf_len"], "sps_pps": ["sPS_pps", "sps2bps", "sps_pp", "sps2pp", "sapes_ps", "sps__pp", "sps__ppers", "sps2ps", "speityps", "sapes_pp", "sapes_pps", "speitypp", "sps___pp", "spsitypp", "spe_ps", "sps___ps", "sps__pps", "sPS_ps", "speityppers", "sPS_bps", "spsitypps", "sPS_pp", "sps2pps", "sps___pps", "sapes_ppy", "spsityps", "sps___bps", "speitypps", "spe_ppers", "spe_pps", "sps_ppy", "spe_pp", "spsityppers", "sps_ps", "sps_ppers", "sps__ps", "sps_bps"], "sps_pps_size": ["sps_pps_Size", "sps_pps_space", "sps_ppa_size", "sps_pp_Size", "sps_pp_length", "sps_ppa_SIZE", "sps_pp_size", "sps_pps_length", "sps_ps_size", "sps_pps_scope", "sps_pps_sum", "sps_ps_sum", "sps_ps_Size", "sps_pps_SIZE", "sps_ppa_length", "sps_ps_SIZE", "sps_ps_space", "sps_ps_scope"], "in": ["data", "nin", "is", "In", "din", "gin", "isin", "vin", "rin", "t", "mi", "bin", "inf", "ac", "ins", "doc", "m", "p", "ic", "str", "out", "id", "inn", "h", "con", "s", "st", "input", "inc", "i", "c", "inv", "it", "inner", "IN", "ind", "all", "raw"], "in_size": ["out_shape", "ini67SIZE", "in67size", "ini_SIZE", "in_Size", "in67speed", "ini_size", "in_len", "in_length", "out_Size", "in_shape", "ini_speed", "out_size", "ini67size", "in_SIZE", "in67SIZE", "ini67speed", "in67length", " in_name", " in_len", "in_speed", "in_name", "ini_length", "out_count", "in_count", "ini67length", " in_Size"]}}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 24626, "substitutes": {"ctx": ["nt", "ca", "cv", "obj", "cmp", "cl", "pc", "conn", "co", "anc", "jp", "params", "aux", "xp", "comp", "config", "wx", "context", "kl", "tx", "cb", "loc", "kt", "fc", "cmd", "pkg", "xc", "func", "bc", "act", "t", "ctl", "stack", "conv", "req", "p", "hw", "expr", "fx", "cc", "cf", "tz", "jac", "ct", "cp", "crit", "org", "course", "wcs", "px", "window", "ck", "sc", "height", "resp", "conf", "xy", "sys", "Context", "tc", "addr", "desc", "c", "cm", "x", "etc", "ctrl", "kw", "nc", "cfg"], "e": ["er", "v", "obj", "ex", "n", "ele", "eps", "E", "ee", "ea", "eeee", "ent", "end", "f", "it", "ne", "event", "ce", "r", "b", "se", "xe", "eu", "eb", "t", "ei", "ge", "el", "ec", "o", "p", "m", "en", "ae", "g", "d", "u", "q", "ed", "es", "te", "a", "ev", "element", "ef", "enc", "h", "s", "pe", "de", "l", "entity", "re", "eg", "i", "c", "x", "ep", "et", "le", "y", "ie", "ing"], "io_notify": ["io_notification", "io_nist", "io_notize", "io_annifier", "io_notist", "io_prine", "io_notise", "io_signify", "io_notif", "io_noifier", "io_prifier", "io_listig", "io__notification", "io_listize", "io_Notist", "io_notsync", "io_signification", "io_Notize", "io_annification", "io_notig", "io__notify", "io_prify", "io_Notify", "io_nif", "io_disise", "io__notsync", "io_Notig", "io_notifier", "io_annif", "io_annify", "io_Notification", "io_nify", "io_listification", "io_noify", "io_prise", "io_noise", "io_nification", "io_disify", "io__notifier", "io_annsync", "io_disine", "io_annist", "io_disifier", "io_noine", "io_signig", "io_listify", "io_Notif", "io_notine", "io_signize"], "io_flush": ["iopresave", "io_save", "i_save", "io_flat", "i_open", "i_sync", "io___write", "io_write", "io_sync", "iojbuild", "io_open", "io2send", "iopreflush", "io___build", "ilo_flush", "iozflush", "iopredestroy", "ilocbuild", "i_send", "ilo_write", "io2open", "io_ush", "io_send", "iocflush", "io___flush", "iocflat", "ioacflush", "iojflush", "iozopen", "ilocwrite", "iozush", "iocwrite", "ilocflat", "iojflat", "ioacsave", "i_destroy", "iopresync", "ioacdestroy", "io___flat", "ilo_flat", "i_flush", "ioacsync", "io_build", "ilocflush", "iozsend", "iocbuild", "io2flush", "i_ush", "io_destroy", "iojwrite", "ilo_build", "io2ush"], "node": ["our", "obj", "max", "ready", "link", "nu", "store", "or", "instance", "message", "box", "cmd", "missing", "tree", "ref", "add", "note", "p", "function", "window", "id", "nd", "leaf", "np", "now", "c", "normal", "y", "entry", "nt", "nut", "n", "k", "holder", "false", "tip", "gc", "db", "host", "peer", "ne", "load", "manager", "process", "se", "wrapper", "station", "handler", "save", "total", "ode", "pad", "device", "call", "linked", "check", "array", "nn", "num", "addr", "thus", "module", "field", "edge", "desc", "object", "ptr", "inner", "data", "create", "master", "none", "local", "parent", "event", "see", "step", "connected", "null", "fn", "ye", "adj", "sum", "new", "component", "remote", "m", "copy", "nw", "table", "stage", "worker", "good", "row", "tmp", "document", "callback", "index", "empty", "msg", "eval", "root", "slave", "cache", "parse", "page", "post", "server", "source", "primary", "valid", "mem", "item", "info", "t", "key", "g", "Node", "name", "list", "bo", "seed", "no", "od", "child", "hd", "stable", "self"]}}
{"project": "FFmpeg", "commit_id": "40ad05bab206c932a32171d45581080c914b06ec", "target": 0, "func": "int float_near_ulp(float a, float b, unsigned max_ulp)\n\n{\n\n    union av_intfloat32 x, y;\n\n\n\n    x.f = a;\n\n    y.f = b;\n\n\n\n    if (is_negative(x) != is_negative(y)) {\n\n        // handle -0.0 == +0.0\n\n        return a == b;\n\n    }\n\n\n\n    if (abs(x.i - y.i) <= max_ulp)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n", "idx": 24629, "substitutes": {"a": ["ma", "ax", "ca", "la", "ba", "sa", "ta", "va", "ea", "f", "am", "ar", "aaa", "an", "xa", "at", "t", "alpha", "al", "\u00e1", "ac", "o", "p", "ae", "da", "eas", "ach", "d", "aa", "apa", "ab", "af", "A", "ra", "au", "as", "l", "oa", "ao", "ia", "i", "c", "sta", "w"], "b": ["B", "v", "n", "ba", "bis", "db", "bp", "bf", "f", "ob", "cb", "beta", "rb", "z", "eb", "bc", "t", "sb", "by", "m", "e", "g", "bb", "be", "u", "nb", "fb", "ab", "ib", "l", "br", "bs", "i", "c", "j", "bi", "mb"], "max_ulp": ["max_imp", "max_fp", " max_pdf", "max_raf", " max_imp", " max_raf", " max_fp", "max_pdf"], "x": [" cx", "ax", "xml", "ex", "v", "xx", "xp", "f", "wx", "ix", "xi", "tx", "X", "ux", "z", "xa", "xf", "xc", " X", "mx", "at", "ox", "dx", "xt", "yx", "rx", "p", "zx", "fx", "u", "px", "xd", " ax", "lat", "lex", "l", "xy", "xs", "one", "i", " xx", "w"], "y": ["v", "iny", "Y", "yi", "ty", "ly", "ot", "yr", "ay", "ym", "z", "ey", "ye", "gy", "ry", "uy", "oy", "ady", "yy", "ya", "my", "fy", "hy", "yl", "ny", "py", "yt", "ies", "yo", "sys", "iy", "xy", "ys", "axy", "yd", "vy", "i", "cy", "sy", "yer"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}", "idx": 24631, "substitutes": {"avctx": ["avkw", "wavtc", "avertmp", "avaddr", "tenresp", " avca", "averkt", "ajtx", "ajobj", "wavpkg", "avhandle", "avresp", " avpkg", "afresp", "afcmp", "averobj", "averaddr", "Avctx", "avecontext", "wavctl", "wavcmd", "avertx", "wavgc", "averheight", "afthis", "avthis", "avgc", "averpkg", "averpy", " avtx", "avca", "aversys", "avetx", "tencontext", "avercmp", "afheight", "tenkw", "vansys", "avsys", "avegc", "vanctx", "wavtmp", "wavtx", "avtmp", "avpy", "afkw", "averthis", " avcontext", "avtx", "wavkt", " avcmp", "afctl", "avctl", "wavctx", "aveca", " avgc", "avercontext", "avehandle", "aftx", "avcontext", "averkw", "afctx", "Avtx", "afobj", "avesys", "avcmd", "afpy", "avercmd", "avobj", "afpkg", "avpkg", "vanaddr", "averctl", "averhandle", "avcmp", "afcontext", "aveaddr", "vanhandle", "averctx", " avtmp", "ajpy", "tenctx", "avtc", "Avca", "aftmp", " avtc", "averresp", "avertc", "wavcontext", "ajheight", "ajctx", "ajcmd", "avheight", "Avcontext", "wavthis", "avectx", "ajkt", "avkt"], "context": ["data", "command", "cache", "settings", "reason", "text", "result", "count", "profile", "subject", "history", "json", "filter", "client", "distance", "local", "content", "config", "that", "tx", "policy", "message", "info", "public", "address", "path", "information", "sequence", "collection", "metadata", "component", "where", "version", "translation", "chain", "buffer", "connection", "status", "environment", "operator", "iterator", "package", "section", "close", "position", "capacity", "Context", "map", "condition", "document", "module", "c", "index", "resource", "scope", "support", "ctx"]}}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648, "substitutes": {"cs": ["pc", "ces", "hs", "ks", "cms", "js", "gc", "cas", "ctx", "fs", "ns", "ix", "ts", "cu", "CS", "cus", "ec", "cc", "ds", "ls", "wcs", "cp", "ck", "cks", "rs", "sc", "acs", "s", "vs", "rc", "sys", "bs", "sts", "c", "proc", "ps", "css", "core"], "fdt": ["fdp", "fdm", "ffn", "ffw", "FDw", "dll", "dlt", "dlwt", "ddm", "FDn", "dlp", "fdn", "dfm", "ffwt", "dfl", "fft", "dln", "dlw", "fdl", "dfp", "FDwt", "dft", "ddl", "fdw", "fdwt", "ddp", "dlm", "FDt", "ddt"], "offset": ["to", "count", "zero", "length", "slice", "end", "f", "slot", "lock", "address", "len", "interface", "shift", "padding", "oid", "o", "seek", "buffer", "pad", "off", " offsets", "Offset", "id", "seed", "error", "size", "fp", "location", "position", "point", "pointer", " index", "start", "index", "pos", "ptr", "set"], "spapr": ["spavrs", " spaprs", " spipr", " spipR", "spippr", "spcapr", "swapsr", "spavR", "spaprs", "spavro", "spipro", "spipr", "swaprs", "spapsR", "swapsp", "spaper", " spipro", " spiprs", "swapp", "spapro", " spapro", "spapsr", "swapsrs", "spapeR", "spippR", "spcapR", " spapR", "spapp", "swapr", "spapers", "spapsrs", "spcaprs", "spapR", "spippro", "spipR", "spavr", "spipprs", "swapR", "spapsp", "spiprs", "spapep", "swapsR", "spcapp"], "cpu": ["cache", "cv", "pc", "linux", "tp", "conn", "gc", "util", "frame", "nu", "node", "phys", "mem", "vm", "core", "process", "cmd", "pool", "processor", "mx", "pu", "cu", "boot", "mac", "clock", "cn", "gpu", "hw", "aco", "cc", "cp", "ck", "nic", "px", "ka", "density", "sc", "sys", "chip", "us", "cum", "c", "proc", "CPU", "stat", "nc", "prof", "ctx"], "env": ["er", "v", "cv", "obj", "conn", "ext", "node", "end", "viron", "priv", "context", "estate", "cb", "attr", "pres", "win", "ei", "ec", "e", "eng", "en", "environment", "dev", "equ", "ef", "ev", "window", "pillar", "ework", "vs", "pe", "conf", "map", "cap", "buf", "scope", "proc", "cfg", "ctx"], "pcc": ["jpcc", "jpcs", " pCC", "PCC", " pcs", "pck", "Pcs", "Pck", "jpCC", "Pcc", "jpck", "pcs", "pCC", " pck"], "segs": ["segments", " seg", " segments", "begments", "beg", "vegments", "beges", "seges", "vegs", " seges", "seg", "veg", "begs", "veges"], "page_sizes_prop": ["page_sizers_property", "page_sizes_property", "page_sizes_attr", "page_sizes_ps", "page_sizers_prop", "page_sizers_ps", "page_sizers_attr"], "page_sizes_prop_size": ["page_sizes_property_type", "page_sizes_property_len", "page_sizes_property_size", "page_sizes_property_value", "page_sizes_prop_value", "page_sizes_prop_len", "page_sizes_prop_type"], "pft_size_prop": ["pft_name2tmp", "pft_size_tmp", "pft_name_properties", "pft_size_buf", "pft_name_prop", "pft_size2tmp", "pft_size2buf", "pft_name2buf", "pft_name2properties", "pft_name_buf", "pft_size2prop", "pft_name_tmp", "pft_size_properties", "pft_size2properties", "pft_name2prop"], "drc": ["bdRC", "madrr", " dcur", "ddrc", " drl", "Drr", "madRC", "pdrr", "rdRC", "ddry", "nrc", "nrl", "bdror", "Dclus", "Drc", "dcur", "nRC", "Dpc", "Drs", "Dry", " dpc", "drl", "rdrc", "pdRC", "bdcur", "rdrs", "Drl", "Dsrc", "DRC", " dry", " dror", " drs", " dclus", "bdrc", "dry", "nrs", "dpc", "ddRC", "pdsrc", "madsrc", "dror", "drr", "pdrc", "dclus", "ddclus", " dRC", "dRC", "madrc", "rdpc", "dsrc", "drs"], "drck": ["drmack", "drkk", "drk", "drmkick", "delcks", "delck", "vrack", "drmkk", " drkick", "derkk", "vrck", " drcker", "vrcheck", "drmcker", "delack", " drack", " drcks", "drmcheck", "drmcks", " drcheck", " drk", "drcheck", "derkick", "drcks", " drkk", "drcker", "derck", "drkick", "drack", "drmk", "delkk", "vrcker", "drmck", "derk"], "drc_index": ["drec__Index", "drc_id", "drec__find", "dRC_id", "drc_find", "drc__ind", "drc_Index", "drc__id", "drec_Index", "dRC_number", "drc__index", "drec_id", "drc__number", "drc__Index", "drec__index", "dRC_index", "drec_index", "drc_number", "dRC_Index", "drc_ind", "drec__id", "drec_find", "drc__find", "dRC_ind"], "radix_AP_encodings": ["radix_prop_ENCoders", "radix_prop_encODers", "radix_prop_encoders", "radix_prop_encodesING", "radix_prop_encodesings", "radix_prop_ENCODings", "radix_prop_encodedING", "radix_prop_encODINGS", "radix_prop_encodesers", "radix_prop_encodedINGS", "radix_prop_ENCodING", "radix_prop_encodings", "radix_prop_encodeders", "radix_prop_ENCodings", "radix_prop_encodesINGS", "radix_prop_ENCodINGS", "radix_prop_encodING", "radix_prop_ENCODING", "radix_prop_encODings", "radix_prop_encodedings", "radix_prop_ENCODers", "radix_prop_ENCODINGS", "radix_prop_encODING", "radix_prop_encodINGS"], "i": [" j", "n", "f", "info", "ii", "t", "ip", "key", "o", "m", "p", "e", " ii", "list", "a", "id", "io", "l", "point", " index", "j", "c", "x", "y", "it", "si", "set", "I"]}}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void test_function(const TestStruct test_sample)\n\n{\n\n    int ret, i;\n\n    void **output_data  = NULL;\n\n    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,\n\n                                            test_sample.nb_samples_pch);\n\n    if (!afifo) {\n\n        ERROR(\"ERROR: av_audio_fifo_alloc returned NULL!\");\n\n    }\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n\n    }\n\n    printf(\"read: %d\\n\", ret);\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    /* test av_audio_fifo_peek */\n\n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n\n    }\n\n    printf(\"peek:\\n\");\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_peek_at */\n\n    printf(\"peek_at:\\n\");\n\n    for (i = 0; i < afifo->nb_samples; ++i){\n\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n\n        if (ret < 0){\n\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n\n        }\n\n        printf(\"%d:\\n\", i);\n\n        print_audio_bytes(&test_sample, output_data, ret);\n\n    }\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_drain */\n\n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n\n    }\n\n    if (afifo->nb_samples){\n\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n\n    }\n\n\n\n    /* deallocate */\n\n    for (i = 0; i < afifo->nb_buffers; ++i){\n\n        av_freep(&output_data[i]);\n\n    }\n\n    av_freep(&output_data);\n\n    av_audio_fifo_free(afifo);\n\n}\n", "idx": 24655, "substitutes": {"test_sample": ["fake_component", "testing_sample", "testing_sam", "est2error", "testablespace", "test_sim", "testablesample", "test_sequence", "test___Sample", "testing_Sample", "test2error", " test_sam", "test_example", "testobjspace", "test2space", "test2profile", "testobjsample", " test_Sample", "test___sample", " test_example", " test_model", "fake_sim", "testing_example", "test_site", " test_stream", "est2sample", "est_error", "est_sample", "test_component", "testtprofile", "est2profile", "fake_profile", "testing_step", " test_sim", "testobjprofile", "test2sample", "test_model", "test_step", "test_stream", "test_data", "fake_sample", "testobjsave", " test_save", "testtcomponent", "test_save", "test___package", "test_space", "test_system", "testobjerror", "testing_space", "testing_data", "testablesave", " test_site", "test_Sample", "test_error", "test_package", "test_sam", "est2space", " test_sequence", "est_profile", "est_space", "testobjexample", " test_system", "testtsample", " test_package", "test_profile", " test_space", "test___sim", "testableexample", "testtsim"], "ret": ["backed", "rier", "obj", "ert", "txt", "jp", "val", "aux", "net", "details", "after", "mel", "reset", "elt", "report", "cmd", "dt", "len", "ref", "add", "deg", "expr", "status", "RT", "arg", "rs", "att", "def", " RET", "alt", "nt", "rem", "result", "gc", "iter", "ben", "repl", "det", "full", "arm", " Ret", "complete", "usr", "arr", "fun", "total", "ft", "str", "Ret", "inter", "RET", "addr", "back", "re", "desc", "et", "rest", "rev", "sr", "final", "del", "get", "print", "ll", "rt", "rets", "reply", "tr", "r", "cert", "ry", "art", "out", "vet", "mt", "dr", "try", "resp", "cont", "sys", "j", "res", "ter", "red", "ext", "t", "Return", "gt", "rm", "br", "it", "err", "rect"], "i": ["qi", "v", "ex", "n", "me", "iter", "in", "li", "print", "f", "ix", "xi", "ai", "ami", "ini", "r", "gi", "ci", "mc", "b", "info", "di", "ie", "ii", "t", "mi", "ip", "ic", "o", "m", "p", "multi", "chain", "e", "ri", "ui", "inter", "u", "q", "pi", "id", "\u0438", "im", "io", "dr", "iu", "l", "us", "err", "ti", "phi", "j", "index", "x", "batch", "c", "y", "it", "si", "bi", "ind", "I"], "output_data": ["output_size", "outputingbuffer", "output_next", "Output_bus", "output2list", "outputingnext", "outputlistbody", "write_buffer", "outputmmno", " output_bytes", "output2values", "outputmmlog", " output_DATA", "output_value", "write_data", "output_bytes", "Output_batch", "output_body", " output_next", "output3batch", "outputlistdata", "outputingdata", "write_values", "outputingvalue", "output_buffer", "output_mu", "outputinglog", "outputingbus", "outputlistnext", "output2data", " output_value", "output_bus", "Output_body", "output_no", "write_list", "output_log", "output2buffer", "output_batch", "outputmmbus", "output_DATA", " output_buffer", "outputmmbatch", "output3no", "outputmmdata", "outputingbody", "Output_log", "Output_data", " output_mu", "Output_next", "outputingDATA", "Output_no", "output3data", "output_values", "output_list", " output_size"], "afifo": ["affifbo", "afiffno", "afifton", "affiffi", "afiovonet", "afiovolic", "auxtifo", "afimano", "afffifo", "afichoi", "afichoo", " afihi", "afifto", "affiffo", " affunc", "afihi", "affiffoin", "afIfoo", "afifoi", "afiftoo", "afihoin", "afIfo", "afIfos", "aftifoin", "afiffi", "affimos", "affunc", " afifoo", "auxifos", "aftifno", "aficho", "affiffio", "afiffoo", "afiffon", " afifi", "afifoid", "afffifoi", "affimbo", "alffunc", "afiteroo", "auxifno", "afiftos", "affifoi", "afifonet", "afimbo", "afitero", "ancifoin", "afiano", "auxifo", "afiterpo", "affiffoo", "alf_", "afiftbo", " afihole", "afiho", "aftifo", "afico", "afiffo", "afihos", "afiftoin", "afichio", "aftiano", "aff_", "afiftoid", "afifano", "affifoid", "afifoo", " afifole", "anciftoin", "afipno", "afffifoid", "afior", " afihonet", "afifon", "anciftoo", "afIfno", "aftifor", " afiho", "afichos", "aftifoo", "afiloo", "afiffos", " afifonet", "affifno", "affiffos", "afichon", "auxtifno", "afihno", "afiftole", "afihole", "afifi", "ancifon", "afifio", "afifor", "affifos", "afici", "afiwoo", "affifio", "affifpo", "afifole", "afifbo", "afimos", "ancifoo", "afimoin", "ancifton", " afihoo", " afifolic", "afimor", "afimo", "affifi", "afifno", " afiholic", "afiwole", "afihano", "afiwo", " afihano", "affimo", "ancifo", "afihoo", "afipos", "aftifos", "affimoin", "afIfoin", " af_", "auxtifos", "affifoin", "afiteroid", "afiftano", "afiffoin", " afifano", "afIfbo", "afiholic", "afiwano", "afilo", "afiftpo", "aficolic", "aftio", "afiovi", "afffunc", "afiwor", "afifoin", "afffifon", "afipo", "afio", "afiloi", "afiovo", "afipoin", "affifoo", "affifon", "auxifoin", "afiffio", "afifpo", "ancifto", "auxtifoin", "aftior", "af_", "aftifano", "afffifpo", "aficonet", "afifolic", "afifos", "afihonet", "afffifoo", "affifo", "affiffno", "afilon"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n", "idx": 24668, "substitutes": {"dest": ["result", "stop", "comb", "iter", "master", "self", "way", "source", "src", "end", "tr", "loc", "trans", "ident", "spec", "dc", "origin", "Dest", "dev", "dist", "d", "decl", "table", "st", "target", "desc", "orig", "transform", "rest", "temp", "port", "results", "slave"], "line_size": ["block_size", "lineingstorage", "linelystorage", " line_height", "lineingheight", "block_Size", " line_storage", "linelysize", "line_height", "line_space", "lineingsize", "block_space", "line_Size", "line_storage", "linelyheight"], "block": ["cl", "BL", "frame", "link", "source", "group", "load", "lock", "b", "trans", "r", "bc", "image", "blocks", "bl", "ip", "bin", "ref", "hash", "p", "chain", "scan", "buffer", "copy", "out", "line", "pack", "list", "part", "sync", "snap", "Block", "pixel", "def", "point", "row", "map", "record", "word", "type", "field", "object", "batch", "buf", "c", "set", "raw"]}}
{"project": "FFmpeg", "commit_id": "5a08ba5381cf8d46034440163e71cd95748beceb", "target": 0, "func": "static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)\n\n{\n\n    Hnm4VideoContext *hnm = avctx->priv_data;\n\n    GetByteContext gb;\n\n    uint32_t writeoffset = 0, count, left, offset;\n\n    uint8_t tag, previous, backline, backward, swap;\n\n\n\n    bytestream2_init(&gb, src, size);\n\n\n\n    while (bytestream2_tell(&gb) < size) {\n\n        count = bytestream2_peek_byte(&gb) & 0x1F;\n\n        if (count == 0) {\n\n            tag = bytestream2_get_byte(&gb) & 0xE0;\n\n            tag = tag >> 5;\n\n            if (tag == 0) {\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n            } else if (tag == 1) {\n\n                writeoffset += bytestream2_get_byte(&gb) * 2;\n\n            } else if (tag == 2) {\n\n                count = bytestream2_get_le16(&gb);\n\n                count *= 2;\n\n                writeoffset += count;\n\n            } else if (tag == 3) {\n\n                count = bytestream2_get_byte(&gb) * 2;\n\n                while (count > 0) {\n\n                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);\n\n                    count--;\n\n                }\n\n                bytestream2_skip(&gb, 1);\n\n            } else {\n\n                break;\n\n            }\n\n        } else {\n\n            previous = bytestream2_peek_byte(&gb) & 0x20;\n\n            backline = bytestream2_peek_byte(&gb) & 0x40;\n\n            backward = bytestream2_peek_byte(&gb) & 0x80;\n\n            bytestream2_skip(&gb, 1);\n\n            swap   = bytestream2_peek_byte(&gb) & 0x01;\n\n            offset = bytestream2_get_le16(&gb);\n\n            offset = (offset >> 1) & 0x7FFF;\n\n            offset = writeoffset + (offset * 2) - 0x8000;\n\n\n\n            left = count;\n\n\n\n            if (!backward && offset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (backward && offset >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (writeoffset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"Attempting to write out of bounds\");\n\n                break;\n\n            }\n\n\n\n            if (previous) {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            } else {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            }\n\n\n\n            if (swap) {\n\n                left         = count;\n\n                writeoffset -= count * 2;\n\n                while (left > 0) {\n\n                    swap = hnm->current[writeoffset];\n\n                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];\n\n                    hnm->current[writeoffset + 1] = swap;\n\n                    left--;\n\n                    writeoffset += 2;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24677, "substitutes": {"avctx": ["awctl", "AVtx", "avcontext", "AVcmp", "avecmp", " avtx", "AVctx", "AVcontext", "avectl", "awctx", "avecontext", "awtx", "avectx", "awcontext", " avcontext", "avcmp", " avctl", "avtx", " avcmp", "avctl", "AVctl"], "src": ["dest", "sr", "in", "ser", "raw", "source", "bg", "inst", "gin", "cb", "loc", "usr", "iv", "origin", "sh", "bin", "filename", "sb", "sel", "seek", "copy", "bb", "impl", "stream", "seed", "rs", "sc", "cur", "img", "rc", "sys", "input", "tmp", "ptr", "sn", "sq", "ctx"], "size": ["data", "n", "max", "small", "scale", "shape", "ize", "message", "body", "set", "z", "sum", "bytes", "year", "len", "total", "send", "buffer", "name", "fee", "number", "SIZE", "height", "storage", "capacity", "type", "start", "empty", "sn", "Size", "length"], "hnm": ["dnmc", "dnM", "uhmi", "hranpm", "hnmc", "hnmm", "hnam", "hdm", "atzm", "uhm", "hdmm", "wnmc", "atzam", "hnd", "havenmi", "pnmi", "havenm", "hodm", "dnmm", "bnmi", "mnM", "atzmi", "hnM", "dnm", "wnm", "bnd", "hdpm", "pnd", "mnmc", "dnman", "pnm", "hodam", "havenum", "hranM", "uhum", "hdM", "hnum", "bnm", "hnpm", "pnam", "atzd", "hodmi", "hranm", "hodum", "mnman", "hnman", "havenam", "bnam", "dnpm", "mnm", "hranmm", "uham", "hnmi", "wnM", "wnman"], "gb": ["gif", " rgb", "bridge", "gu", "gs", "gc", "BG", "Gb", "db", "git", "bf", "ctx", "bg", " eg", "gd", "vm", "gin", "gom", "cb", "tg", " rc", "rb", "buff", "b", "hub", "attr", "pg", "gp", "bytes", "eb", "gm", "rg", "lib", "sb", "deg", " GB", "gt", "BB", "g", "cfg", "bb", " pg", "nb", " img", "gov", "ib", "orm", "kb", "storage", "img", "ga", " g", "large", "jpg", "vg", "gg", "GB", "eg", "gz", "buf", "pb", "entity", "BT", " rg", " db", "yg", "mb"], "count": ["max", "found", "val", "read", "cmd", "len", "add", "hash", "contact", "carry", "force", "conf", "type", "c", "ind", "nt", "first", "n", "cast", "result", "next", "amount", "level", "complete", "cond", "act", "total", "match", "debug", "ct", "call", "check", "part", "num", "cycle", "start", "col", "length", "all", "limit", "init", "current", "sum", "Count", "comment", "component", "chain", "ount", "error", "flag", "search", "try", "card", "cont", "ctr", "cart", "index", "cache", "scroll", "loop", "only", "common", "more", "info", "find", "cell", "code", "name", "cc", "number", "counter", "child", "skip", "core"], "offset": ["tail", "init", "data", "limit", "half", "sort", "length", "scroll", "range", "unk", "next", "source", "end", "mask", "amount", "slot", "initial", "timeout", "item", "after", "lock", "attr", "address", "article", "origin", "shift", "padding", "time", "seek", "translation", "code", "pad", "off", "tz", "iterator", "Offset", "base", "part", "prefix", "atomic", "error", "option", "flag", "byte", "location", "position", "point", "pointer", "type", "skip", "start", "alt", "index", "pos", "extra", "angle", "lag", "attribute", "term", "port", "set"], "tag": ["tail", "tags", "bit", "state", "hash", "time", "status", "lead", "style", "id", "role", "color", "type", "stat", "attribute", "term", "bug", "next", "TAG", "ag", "match", "meta", "cat", "version", "debug", "prefix", "part", "back", "field", "start", "pair", "length", "parent", "event", "step", "Tag", "attr", "token", "category", "comment", "option", "error", "flag", "card", "tmp", "head", "pos", "index", "date", "test", "magic", "user", "feature", "slot", "product", "class", "at", "t", "key", "code", "format", "name", "month", "phrase", "element", "use", "word", "port"], "previous": [" precient", "prevvious", "Preward", " preward", "Precedes", "pervious", "pinvious", "perviously", "prevcient", " preprev", "pincedes", "pinviously", "previously", "Previously", "preprev", "Previous", "prevprev", "pinflower", "Precient", "Preflower", "perflower", "preward", "Preprev", "percedes", "preflower", "prevward", "precedes", "precient"], "backline": ["sideboard", "backboard", "blacklay", "Backlines", "blackboard", "foreboard", "Backline", "blackline", "blacklink", " backboard", " backlay", "backlink", "Backboard", "Backlink", " backlink", "sidelink", "sideline", "sidelay", "forelink", "forelines", "backlay", " backlines", "backlines", "foreline"], "backward": ["backforward", "preverse", " backverse", " backwards", " backway", " backvious", "prebone", "preforward", "gateward", "backvious", "backwards", "backbone", "backway", "backedvious", "backverse", "preward", "backedward", "backedwards", "backedbone", "prewards", "gateforward", "preway", "gateverse", " backbone", "gateway", " backforward"], "swap": ["Swarp", "swag", "slap", "slop", "wap", "wrap", "slip", "Swrap", "wip", "snip", "warp", " swip", "swrap", "snrap", " swop", "slag", "snag", "swarp", "swip", "snop", "snap", "Swip", "Swap", " swag", "snarp", "swop"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720, "substitutes": {"sig": ["Sigen", "rsign", "nsigma", "dsigma", "psigs", "digs", " sigma", "xsig", "ssigen", "xsigs", "sigen", "rsigs", " sigen", "ssIG", "ssigs", "sign", "nsigs", "digma", "dsig", "dig", "sigs", "SIG", "xsign", "ssig", "sIG", "nsIG", "Sigma", "Sig", "sigma", "rsIG", "xsIG", "dsigen", "psig", "psIG", "dIG", "rsig", "ssigma", "Sigs", "dsigs", " sigs", "nsig", "psigma"], "ka": ["ja", "ma", "arma", "ker", "kan", "eta", "k", "ks", "ama", "sa", "ta", "pa", "va", "kl", "km", "kat", "gha", "ha", "ku", "kt", "ki", "ema", "iak", "ik", "ana", "ken", "ena", "ica", "ko", "sk", "KA", "java", "aka", "ak", "ket", "ke", "ck", "cki", "sc", "kas", "ski", "tk", "Ka", "kw", "kr", "ctx"], "set": ["init", "parse", "settings", "pre", "SET", "util", "range", "offset", "get", "sp", "sche", "end", "net", "config", "Set", "setting", "join", "store", "see", "dict", "reset", "step", "push", "se", "spec", "setup", "new", "t", "sh", "add", "format", "sub", "pack", "check", "base", "clear", "mark", "site", "size", "section", "sc", "def", "st", "sets", "use", "map", "tk", "target", "start", "pair", "et", "test", "ver", "ch"], "env": ["obj", "vp", "ten", "conn", "uv", "outer", "net", "cb", "pkg", "dt", "origin", "vt", "ei", "ec", "erd", "hw", "e", "environment", "nv", "window", "here", "sc", "np", "entry", "er", "next", "Environment", "der", "dev", "eng", "ah", "vs", "screen", "open", "addr", "ov", "desc", "buf", "ptr", "et", "ctx", "init", "cv", "priv", "context", "query", "menu", "attr", "eu", "esm", "worker", "proc", "enc", "v", "ve", "enter", "server", "eq", "end", "viron", "mem", "gear", "den", "info", "setup", "stack", "code", "en", "dh", "sw", "org", "ew", "esc", "ef", "ev", "engine", "up", "deck", "err", "self"], "frame": ["request", "zero", "profile", "range", "file", "lock", "ce", "message", "reset", "state", "fake", "image", "ref", "function", "header", "connection", "environment", "line", "style", "queue", "window", "fb", "role", "value", "def", "force", "session", "type", "offset", "next", "tick", "policy", "process", "feat", "movie", "send", "version", "doc", "call", "response", "base", "close", "fi", "module", "object", "ptr", "ctx", "init", "data", "iframe", "scene", "me", "rame", "none", "channel", "sche", "f", "frames", "context", "event", "step", "new", "ine", "sequence", "zone", "component", "buffer", "cf", "error", "ence", "shot", "row", "ie", "Frame", "flow", "ma", "face", "fr", "page", "feature", "ace", "block", "fram", "draw", "code", "ze", "trace", "rule", "size", "point", "word", "scope", "err"]}}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730, "substitutes": {"bs": ["BS", "vals", "bits", "bas", "hs", "iss", "bis", "gs", "js", "ses", "bp", "ms", "obs", "fs", "ns", "ubs", "ss", "b", "ts", "bos", "bc", "blocks", "bes", "ats", "sb", "bps", "ds", "bb", "outs", "bec", "cks", "acs", "vs", "lbs", "aos", "bing", "its"], "s": ["sv", "n", "hs", "iss", "gs", "js", "sa", "ses", "S", "fs", "ns", "ss", "b", "ts", "qs", "sol", "se", "spec", "cs", "less", "ats", "sb", "ins", "p", "comm", "aws", "ds", "ls", "ares", "es", "q", "a", "os", "rs", "ies", " ss", "sys", "stats", "sts", "als", "its", "i", "j", "c", "sq", "ps"]}}
{"project": "FFmpeg", "commit_id": "93c39db5f1544d1220488cfeb93bfe812a52f374", "target": 1, "func": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;", "idx": 24732, "substitutes": {"s": ["sv", "v", "n", "hs", "is", "gs", "js", "ms", "ses", "bis", "fs", "S", "sp", "ns", "ss", "b", "ts", "qs", "ops", "t", "cs", "ats", "ins", "http", "p", "comm", "aws", "ds", "g", "ls", "os", "a", "es", "rs", "events", "h", "vs", "sys", "as", "conf", "stats", "sts", "bs", "its", "xs", "c", "sq", "ps", "set"], "pkt": ["pcqt", "pnt", "pdu", "pront", " pdu", "pcacket", "tkt", "pqt", "proacket", "tacket", " pqt", "pvc", "paynt", "tnt", " pgt", "paracket", "Pwk", " pwk", "wpvc", "ppkt", "tdu", "paydu", "Pkt", "pckt", "pkg", " pkg", "pct", "pargt", " pnt", "Pnt", "ppacket", "wpkt", "produ", " pvc", "wpacket", "Pct", "payacket", "pgt", "pwk", "Pvc", "wpgt", "ppqt", "ppnt", " packet", "prokt", "pcnt", "wpct", "wpkg", "parkt", "packet", "paykt", "wpwk", "parkg", " pct", "Pdu", "Packet"], "st": ["sv", "obj", "ust", "sa", "stop", "ST", "th", "ist", "St", "ast", "sp", "tt", "ut", "inst", "td", "ss", "step", "set", "z", "ts", "se", "usr", "std", "t", "sh", "stack", "sb", "ft", "str", "pt", "sl", "irst", "ct", "sw", "be", "stage", "must", "mt", "rs", "nd", "sc", "storage", "etc", "cont", "stable", "sts", "ost", "start", "desc", "stat", "sta", "sn", "rest", "est", "et", "ste", "sm"], "aiff": ["vaif", " aich", "awif", "yaolf", "maIFF", " aif", "aolf", "yaif", "awiper", "awesh", "yaich", "caial", " aial", "eaesh", "maial", "aich", "vaolf", " aesh", "awiff", "aiper", "aIFF", " aiper", "caif", "vaiff", "eaiper", "vaich", "aesh", " aolf", "eaiff", "maif", "aial", "caIFF", "eaif", "yaiff", "maiff", "aif", " aIFF", "caiff"], "max_size": ["max_data", "max_value", " max_align", "top_length", "max67length", " max_value", "MAX_data", " max_SIZE", "top_Size", "max67diff", "max67SIZE", "maxlenlen", " max_Size", "max_diff", " max_len", "max_Size", "top67diff", "maxmaxalign", "top67Size", "top_diff", "MAX_Size", "max_results", "maxmaxsize", "MAX_size", "max67Size", "max_align", " max_results", "max67results", "maxmaxSize", "top_size", "maxlenalign", "top67size", "max_len", "max67size", "maxlensize", "max_length", "top67length", "maxlenSize", "MAX_SIZE", "max67value", "max_SIZE", "maxmaxlen"], "res": ["rev", " rs", "vals", "rem", "ex", "rez", " resolved", "bits", "result", "max", " resp", "ms", "js", "zero", "count", "cons", "none", " Res", "val", "rows", "success", "ret", "Res", "ne", "resolution", "reset", "pers", " RES", "ts", "resh", "pres", "cond", "act", "bytes", "cs", "sum", "req", "expr", "out", "ress", "rel", "rep", "os", "yes", "rs", "RES", "con", "rc", "des", " ret", "resp", "resources", "bs", "err", "re", "i", "j", "pos", "resource", "rest", "empty", "x", "ps", "rss", "results"], "size": ["data", "ose", "args", "too", "max", "count", "zero", "ms", "result", "range", "weight", "small", "notice", "scale", "sp", "power", "mem", "timeout", "shape", "resolution", "ize", "message", "full", "set", "body", "z", "bytes", "sum", "area", "cs", "len", "south", "shift", "zone", "send", "space", "time", "password", "name", "fee", "min", "number", "news", "loss", "window", "equal", "SIZE", "grow", "storage", "height", "capacity", "score", "num", "type", "scope", "dim", "sn", "empty", "Size", "x", "length", "speed"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 24742, "substitutes": {"arg1": [" arg01", "prop01", "args01", "args2", "param1", "Arged", "argsed", " arged", "param3", "Arg01", "param0", "arg0", "param01", "Arg1", "arg01", "prop0", "args1", "prop1", "arged", "Arg2", " arg0", "prop3"], "arg2": ["ig02", "arg5", "ig2", "arg02", "agg1", " arg02", "param3", "param2", "agg02", "arg0", " arg5", "ig0", "agg0", "ig1", "argument2", " arg0", "argument5", "argument3", "param5", "agg2"], "arg3": ["Arg5", "arg5", "doc23", "targetthree", " argthree", "target3", "doc3", "target2", "Arg7", "param3", "param2", " arg7", "arg23", "arg7", " arg5", "Arg3", "doc2", " arg23", "target23", "Arg2", "param5", "argthree", "docthree", "param7"], "farg1": ["farg50", "fflag001", "farg5", "farg001", "fdocn", "fargumentn", "formarm8", "fig1", "farm12", "fblockone", "fprocess1", "farpn", "fargumentone", " fagg1", "formblock1", "farm1", " fagg001", "fargument37", "fargument1", "fig001", "farge61", " farg5", " fparamn", "fdoc1", "formargone", "ftcall1", "farp0", "fargument9", "fprocessone", "fagg1", "fagg3", "fprocess37", "formarg12", "ftarg8", "fcall001", "ftag1", "fagg9", "fblock71", "ftag71", "farp3", "fflag8", "fflag1", "fmargn", "fmarg71", "ftagn", "fparamn", "fargs0", "fargument01", " fargOne", "fdoc61", " fcallone", "farp1", "fument001", "fargs1", "fargone", "farg0", " fcall1", "fmtag71", "formblock71", "farm3", "fparam5", " fparam5", " fargs1", "fagg12", "fcallone", "farpOne", "farge1", " fagg9", "farge001", "fmarg1", "fagg01", "fargs2", "formarm1", "formarg8", "fcall3", "fvar1", "ftcall8", "fvar001", "fargs41", "fargumentOne", " fargone", "figone", "farp41", "fument50", "fagg001", "formblock37", "ftag61", "formarm12", "fument61", "fargument001", " fparamOne", "fblock1", "fparam1", "fargument61", "formarg37", "fprocess71", "farg61", " fparam1", "fArgone", "fvar50", " farg0", " fcall3", "fdoc71", "fArg001", "fparamOne", "farg41", "fcall8", "fmarg61", "farg12", "fArg1", "fargn", "fvar01", " farg9", "formarg1", "farg37", "farg71", "fargument71", "farp5", "farp8", "fblock37", " fcall001", "fmtagn", " fagg01", "ftcall001", " fargs41", "farg01", "ftarg001", "farm8", "farp2", "farg8", "ftarg1", "formarg71", "formarm3", "fvar61", "fvar8", "fagg8", "fargOne", "formblockone", " farg41", "farge50", "fArg3", " fargs0", " fargn", " farg01", "farg9", "fmtag61", "farp12", " farg001", "fvar9", "fargument5", "formarg3", " fargs2", "fmtag1", "fument1", "fig3", "fcall1"], "farg2": ["fpack5", "farg5", "fdev8", "foarg15", "cfarg2", "cfarg3", "cfarg14", "alfarg2", "farg4", "fvalid3", "cfig2", "fargtwo", "alfarg21", "foangtwo", "fparamtwo", "fagg3", "cfparamed", "cfarged", "farg14", "fvalid21", "cfig14", "fok4", "fig2", "foang15", "cfarg5", "fapptwo", "alfargless", "fflagtwo", "fagg42", "fang15", "fparam2", "fdev3", "floatarg3", "alftag3", "farg15", "floatdev3", "fang5", "fparam5", "ftag3", "floatarg42", "floatarg8", "fagg2", "alftag21", "floatdev42", "alftag2", "fok21", "alftagless", "fapp14", "fark2", "cfagg5", "fark3", "fagg5", "fig14", "fdev2", "fargless", "fangtwo", "fArg2", "fargument4", "fok3", "floatdev2", "foktwo", "ftag21", "fpack2", "foarg2", "floatdev8", "fparam15", "fargumented", "cfparamtwo", "foarg5", "foang2", "fok2", "fang2", "fdev42", "fparam4", "fparamed", "fvalid2", "cfagg4", "fflag14", "cfigtwo", "fark5", "farg42", "fpacktwo", "cfparam2", "fvalidless", "foked", "farged", "fagg4", "farg8", "foang5", "cfagg3", "farg21", "cfargtwo", "ftagless", "fagg8", "fapped", "fark4", "fflaged", "fokless", "fArg8", "fapp2", "alfarg3", "fargument2", "cfagg2", "fArg3", "ftag2", "cfarg4", "fflag2", "fArg42", "fargumenttwo", "fpack15", "floatarg2", "foargtwo", "figtwo", "cfparam4", "figed", "cfiged"], "farg3": ["fcargck", "fdim83", "ftarget11", "fagg03", "fargthree", "cfarg3", "wtarget03", "facaj8", "facarg3", "farg11", "ftag11", " fok21", "flag3", "fargs3", "farg4", "warg11", "fargck", "targs2", "fument3", "figThree", "fdim3", "fagg3", "farg43", "floc83", "fargument3", "fArgThree", "warg512", "fig3", "fok4", "cfarg03", "fagg53", "fcargumentthree", "fumentck", "farc53", "facaj3", "farcThree", "ftag512", "targsThree", "fargsThree", "facaj43", "targThree", "flag512", "fok83", "faj8", "farc3", "fcargumentck", "fdim21", " fok4", "faggThree", "flag03", "fcargthree", "fcarg3", "ftag3", "farc03", "fig03", " fok3", "fmem3", "facarg43", "fcall43", "fargThree", "fcargument3", "cfagg03", "fargs2", "fok21", "fcall3", "facajthree", "fArg2", "cfargThree", "targ3", "fok3", "flag11", "cfagg53", "fdoc2", "wtarget512", "fargumentthree", "ftarget03", "fcall8", "targ2", "facargthree", "floc3", " fok83", "warg3", "fargument8", "cfarg53", "fig53", "wtarget11", "farg83", "farg53", "farg8", "fargumentck", "fdocThree", "fdim4", "cfagg3", "fmemck", "farg21", " farg83", "fdoc3", "ftarget3", "fajthree", "farg03", "fmemthree", "floc4", " farg4", "targs3", "floc21", "faj3", "cfaggThree", "fArg3", "fcallthree", "fargument43", "ftarget512", "faj43", "farg512", "warg03", "ftag03", "fumentthree", " farg21", "wtarget3", "facarg8"], "ft0_128": ["ft0_512", "ft50_20", "exec", "ft2_256", "ft50pt256", "ft2_65", "func", "ft067208", "ft50pt128", "def", "ft067256", "ft0pt20", "ft0__132", "ft1_256", "FL", "ft0__128", "ft00_48", "ft0_3", "ft067188", "ft50_128", "ft00_132", "ft2_32", "ft0pt256", "ft0pt48", "_", "ft00_128", "ft0_256", "ft1_512", "ft2_128", "ft50_256", "ft0pt188", "ft0_65", "ft0pt128", "ft0_756", "ft0_32", "ft60_756", "ft50pt48", "ft0_48", "ft0_132", "ft0_20", "ft0_188", "ft0__48", "ft1_208", "ft50_48", "ft00_3", "ft50pt20", "ft60_128", "NUM", "ft067128", "ft0__3", "ft0pt208", "ft1_188", "ft0_30", "ft60_30", "ft0_208"], "ft1_128": ["ft167128", "ft1_192", "ftOne_63", "ftONE_hex", "ft1678", "ft0_16", "ft1_256", "ft167hex", "ft11256", "ftOne_138", "ftOne_192", "ftOne_128", "ft1_hex", "ft11128", "ft0_0", "ft0_1024", "ft1_8", "ft1_32", "ft0_256", "ft1_63", "ft1_1024", "ft167height", "ftONE_height", "ft0_32", "ft1_16", "ftONE_128", "ftONE_8", "ft1_height", "ft110", "ft1_138", "ft1_0", "ft1116"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 24744, "substitutes": {"dc": ["df", "dm", "ca", "iac", "pc", "central", "rec", "dp", "dd", "db", "oc", "exec", "gc", "wp", "conn", "driver", "currency", "disk", "cd", "cca", "td", "cr", "lc", "mc", "ci", "fc", "cmd", "di", "spec", "dt", "bc", "cs", "ctl", "du", "DC", "ac", "mac", "cat", "coord", "draw", "ic", "doc", "ec", "tm", "dat", "dir", "cc", "da", "ds", "d", "cf", "wcs", "fee", "design", "sc", "arc", "def", "dr", "rc", "de", "tc", "vc", "desc", "c", "disc", "cm", "dim", "kw", "nc", "dl"], "l1": [" lax", "l0", "mOne", " L0", "lp8", "L3", " lOne", "lp1", "lc2", "lp01", "lOne", " l0", " l3", " ln", " LOne", "leveln", "lpOne", "L1", "m2", "lax", "lc1", " L1", " l01", "l3", "m1", "lc3", "lcax", "lp2", "l01", "m0", "level1", "l8", "ln", " l2", "l2", " l8", "lc8", "level2", "levelOne", " L2", "lc01", "lpn", "L2", "Lax"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n", "idx": 24748, "substitutes": {"opaque": ["OPque", " opatile", "opatile", "opface", "Opatile", "OPatile", " opface", "OPface", " opque", "Opque", "opque", "OPaque", "Opface", "Opaque"], "addr": ["Address", "obj", "work", "res", "adr", "offset", "src", "mem", "ay", "tx", "store", "ack", "loc", "r", "cmd", "gate", "block", "address", "attr", "at", "act", "t", "ip", "coord", "align", "add", "hash", "bind", "hw", "pad", "name", "off", "dh", "a", " address", "id", "prefix", "mt", "ad", "rs", "eth", "dr", "now", "map", "oad", "target", "ord", "i", "handle", "pos", "index", "ptr", "alias", "msg", "alloc", "err"], "value": ["data", "VALUE", "v", "vp", "weight", "val", "message", "state", "address", "tree", "current", " val", "serial", "sequence", "vector", " weight", "padding", "total", "comment", " Value", "key", "time", "code", "buffer", "function", "values", "fee", "number", "byte", "memory", "unit", "Value", "property", "ue", "type", "field", "test", "term"]}}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n\n{\n\n\n\n    if (err == 0 || errno != ENOENT) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    if (vs->perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_do_mkdir(s, vs);\n\n        v9fs_create_post_mkdir(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_do_symlink(s, vs);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_LINK) {\n\n        int32_t nfid = atoi(vs->extension.data);\n\n        V9fsFidState *nfidp = lookup_fid(s, nfid);\n\n        if (nfidp == NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 24754, "substitutes": {"s": ["sv", "v", "hs", "is", "gs", "js", "ms", "ses", "bis", "fs", "S", "ties", "ns", "ss", "r", "z", "ts", "qs", "cs", "ssl", "ats", "bes", "sb", "ins", "ims", "p", "irs", "aws", "ds", "sl", "g", "ls", "ains", "ashes", "sw", "os", "es", "ges", "rs", "ies", "h", "as", "sys", "ys", "us", "als", "sts", "bs", "stats", "its", "xs", "uns", "sn", "sq", "ps"], "vs": ["versions", "sv", "bits", "vp", "vis", "gs", "ms", "changes", "obs", "blogs", "rys", "ops", "func", "vv", "ics", "vt", "ls", "wcs", "values", "rs", "def", "vy", "inv", "ps", "w", "nt", "ks", "fs", "ils", "ns", "VS", "ts", "ins", "posts", "call", "terms", "es", "otes", "lists", "ies", "ys", "stats", "sts", "Vs", "vr", "_", "vals", "ports", "hs", "docs", "ss", "iffs", "lv", "cs", "ds", "fits", "irms", "ices", "V", "vc", "v", "js", "ves", "uds", "vers", "qs", "gets", "ims", "ows", "views", "heads", "bs", "its", "xs", "caps", "of"], "err": ["obj", "erm", "conn", "die", "txt", "or", "cb", "elt", "ner", "dt", "e", "here", "rs", "conf", "eg", "gz", "pr", "Error", "c", "inv", "y", "er", "result", "iter", "aaa", "ier", "warn", "norm", "rb", "usr", "der", "arr", "str", "eas", "Er", "fee", "rank", "hz", "progress", "buf", "order", "ell", "ptr", "ver", "cfg", "raw", "rez", "gr", "notice", "aer", "ll", "r", "attr", "coord", "out", "lr", "error", "good", "rc", "dr", "try", "resp", "sys", "msg", "test", "erer", "nr", "cmp", "res", "fr", "rr", "orum", "cr", "req", "code", "g", "rar", "mr", "rm", "trace", "later", "h", "br", "asm", "exc", "kr", "eor", "ch"], "nfidp": ["nfridp", "nfxoidP", "nfdidper", "nfitper", "nfIdphp", "nfridwp", "nfridP", "nfIdps", "nfoidwp", "nfidpa", "nfitp", "nfsidP", "nfsIdpb", "nfdIdps", "nfIdP", "nfiqpb", "nfsIdp", "nfdIdpa", "nfitpa", "nfaidpb", "nfIdp", "nfoidP", "nfdidp", "nfaidper", "nfdIdp", "nfaidp", "nfxidP", "nfitps", "nfxoidwp", "nfIdpb", "nfidps", "nfdidps", "nfiqphp", "nfidP", "nfIdwp", "nfidper", "nfaidpa", "nfidpb", "nfsidphp", "nfidphp", "nfaidphp", "nfIdv", "nfaidps", "nfiqP", "nfidv", "nfsIdP", "nfIdper", "nfxoidv", "nfridv", "nfxidv", "nfsidp", "nfidwp", "nfsidpb", "nfxidwp", "nfiqp", "nfxoidp", "nfdIdper", "nfdidpa", "nfoidp", "nfIdpa", "nfsIdphp", "nfoidv", "nfaidP", "nfxidp"], "ctype": ["ccyp", "CTyp", "cartype", "ccypes", "CTypes", "ctyp", "contype", "ccype", "cctype", "contyp", "codyp", "ctypes", "codotype", "nttype", "cttype", "contypes", "ctType", "contotype", "ntype", "cartyp", "CTtype", "codtype", "ntotype", "ntyp", "contType", "codype", "CType", "ccType", "cartType", "conttype", "ctotype", "carttype"], "major": ["ax", "priority", "ora", "max", "mid", "male", "sharp", "basic", "ser", "master", "none", "next", "native", "mot", "gr", "oral", "Major", "feature", "primary", "valid", "mint", "nir", "or", " maj", "ajor", "older", "feat", "patch", " Major", "serial", "dx", "total", "rod", " majors", "significant", "arser", "present", "good", "ctr", "ior", "normal", "ptr", "recent", "ver"], "minor": ["MINOR", "minOR", " minorable", "demorable", "ignOR", "donory", "monory", "minory", "donion", "manimal", "ignor", "monor", "minimal", "minorable", "demor", "MINory", "Minor", "manorable", "manor", "Minore", "Minory", "minion", "ignion", "demori", "monored", "minored", " minori", "MINor", "MINore", "ignory", "MINion", "donOR", "demimal", "monore", "MINored", "manori", " minimal", "Minored", "minore", "minori", "donor"]}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init (CPUState *env)\n\n{\n\n}\n", "idx": 24756, "substitutes": {"env": ["v", "cv", "obj", "me", "db", "end", "EN", "viron", "context", "cb", "ec", "e", "code", "dev", "en", "environment", "ef", "ev", "screen", "vs", "pe", "conf", "tmp", "map", "buf", "proc", "test", "ctx"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759, "substitutes": {"spapr": [" spipR", " spaprs", " spipr", "spappr", " spandr", "spaptrs", "spaprs", "spapslr", "spipr", "spapior", "spepR", "spaptior", "sparpr", "spapser", "ispaper", "spandlr", "ispapser", "speper", "spapprar", "sparprs", "spapper", "ispapsr", "sparprar", "ispapr", "spaper", "spiper", "spepr", "ispaprar", "spaplr", "spaptlr", " spapior", "spaptr", "spapsr", "ispaprs", "ispapsrs", "sparper", " spandlr", "spappR", " spapR", " spaplr", " spandrs", "spandr", "spaptrar", " spiprar", " spaprar", "spapsrs", "spandrs", "spapR", "speprar", " spandior", "spipR", "spapter", "spaprar", " spiper", "spiprar", "spandior", "spapsior", "spapsrar", "ispapsrar", " spaper"], "token": ["prototype", "typ", "atom", "message", "ask", "reset", "kt", "tree", "len", "note", "time", "function", "header", "kn", "ln", "value", "position", "input", "now", "tk", "type", "normal", "attribute", "TO", "Token", "offset", "tick", "TN", "WT", "complete", "before", "wt", "field", "all", "topic", "KEN", "none", "final", "notice", "channel", "local", "tn", "event", "tag", "serial", "year", "termin", "buffer", "table", "error", "trigger", "index", "date", "frame", "node", "oken", "block", "forward", "t", "key", "padding", "ok", "template", "number", "seed", "no", "rule", "era", "word", "password"], "nargs": ["nabis", " narg", "Ngs", "cnabis", "numgs", "Narg", "numargs", "ngs", "narg", "numarg", " nparams", "cnargs", "numparams", "nrows", "targ", "targs", "nparams", " ngs", "cnparams", "normparams", "normargs", "normabis", " nrows", "cnarg", "cnrows", "trows", "normarg", "Nparams", "cngs", "Nargs", "tgs", " nabis"], "args": ["vals", "ans", "ands", "ars", "acts", "ras", "gs", "js", "issues", "eps", "arms", "ens", "fs", "params", "aux", "ns", "frames", "actions", "ants", "ems", "amps", "ts", "qs", "parts", "ps", "orders", "gets", "arr", "win", "ins", "doc", "ims", "aws", "ds", "posts", "ams", "values", "assets", "terms", "arg", "keys", "uments", "sys", "stats", "Args", "atts", "xs", "ais", "files", "ags"], "nret": ["tnrets", "nrt", "nalt", "Nrepl", "NRet", "tnRet", "Nret", "Nrets", "tret", " nrepl", " nRet", "nrepl", "nRet", "tnret", " nreturn", " nrt", " nrets", "trt", "tRet", "Nrt", "Nreturn", "Nalt", "nrets", " nalt", "nreturn", "trets", "tnrepl", "talt", "treturn"], "rets": ["nt", "vals", "errors", "res", "ras", "gs", "cas", "ens", "fs", "rows", "uds", " secrets", "aux", "ns", "details", "rt", "ret", "ties", "protected", "ants", "states", "ts", "qs", "runs", "uts", "vt", "ins", "gt", "fits", "outs", "ls", "tests", "values", "pillar", "secret", "ents", "tracks", "rs", "RET", "lists", "events", "keys", "def", "uments", "des", "ints", "als", "sts", "its", "results"], "call": ["make", "create", "n", "rec", "pre", "util", "co", "exec", "build", "node", "ll", "local", "f", "load", "execute", "run", "set", "block", "find", "circ", "cell", "t", "cod", "ac", "send", "ref", "draw", "add", "function", "roll", "Call", "fail", "cal", "check", "list", "con", "def", "close", "l", "use", "row", "label", "back", "dial", "c", "ell", "eval", "play", "all"]}}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n", "idx": 24761, "substitutes": {"out": ["nt", "v", "obj", "output", "n", "to", "cache", "result", "ex", "cast", "co", "ot", "opt", "client", "print", "f", "net", "ret", "ou", "store", "full", "b", "dot", "null", "cmd", "pool", "sum", "OUT", "at", "new", "t", "update", "other", "conv", "cn", "o", "p", "copy", "outs", "Out", "clean", "list", "check", "table", "sync", "up", "att", "global", "map", "one", "batch", "c", "all"], "in": ["init", "data", "v", "n", "is", "rec", "nin", "pre", "iter", "In", "file", "serv", "thin", "val", "f", "din", "gin", "vin", "ini", "isin", "b", "rin", "sum", "image", "t", "inf", "ac", "bin", "add", "ins", "ic", "p", "m", "o", "doc", "mm", "inn", "con", "s", "l", "input", "form", "c", "it", "inner", "IN", "ind", "raw"], "order": ["er", "v", "priority", "n", "sort", "max", "count", "ordered", "iter", "offset", "page", "ind", "frame", "weight", "mode", "scale", "end", "level", "store", "or", "den", "asc", "r", "ase", "block", "address", "orders", "sequence", "shift", "dir", "m", "chain", "en", "rar", "rank", "q", "depth", "base", "seed", "error", "size", "inn", "unit", "position", "num", "row", "record", "err", "condition", "orient", "ord", "start", "field", "index", "pos", "angle", "Order", "dim", "incre", "ice", "length"], "direction": ["flow", "command", "irection", "weight", "range", "filter", "driver", "mode", "distance", "kind", "directory", "wind", "trans", "positive", "di", "sign", "forward", "vector", "duration", "dir", "relation", "version", "d", "direct", "DIR", "number", "reverse", "directed", "language", "orient", "type", "degree", "normal", "transform", "angle", "negative", "length", "speed"], "tns_coefs": ["tns_coEFFerences", "tns_coefps", "tns_coffS", "tns_coeffs", "tns_coffrs", "tns_coefficientsps", "tns_coefficientss", "tns_coffls", "tns_coeffls", "tns_coEFFS", "tns_coefrs", "tns_coeffS", "tns_coEFFs", "tns_coeffps", "tns_coffs", "tns_coeffrs", "tns_coefficientsrs", "tns_coefls", "tns_cofferences", "tns_coefS", "tns_coefferences", "tns_coffps", "tns_coEFFls", "tns_coefficientsS", "tns_coefficientsls", "tns_coeferences", "tns_coefficientserences"], "ltp_used": ["ltP_Used", "ltp2used", "ltpnotused", "ltpnotuse", "ltpnotavailable", "ltpnotusing", "ltp_Used", "ltp2use", "ltP_using", "ltp2Used", "ltp_using", "ltP_available", "ltP_used", "ltp_use", "ltp_available", "ltP_use"], "w": ["gen", "v", "W", "weight", "aw", "ow", "wa", "wl", "wd", "weights", "wind", "r", "fw", "t", "worth", "draw", "deg", "e", "wh", "nw", "d", "sw", "ew", "window", "wt", "kw"], "filt": ["ffisher", "frend", "afrend", "ffilt", "ffiltration", "ffrend", "filtration", "afisher", "afilt", "tfilt", "tfiltration", "fisher", "tfrend", "tfisher", "afiltration"], "start_i": ["indexptj", "startptl", " start_in", "indexptl", "start_l", "index_j", "start_is", "startptj", "startptis", "start_j", "start_p", "indexpti", " start_p", "startpti", "index_l", "indexptis", "start_in", "index_i", "index_is"], "len": ["limit", "nt", "il", "n", "cmp", "nl", "count", "fin", "iter", "ind", "del", "els", "lp", "val", "end", "ll", "mem", "lim", "wl", "seq", "ail", "den", "elt", "loc", "fn", "vel", "lf", "lan", "win", "lib", "el", "lon", "align", "m", "fl", "en", "sl", "Len", "ls", "q", "list", "size", "ln", "vol", "latest", "h", "l", "num", "pos", "dim", "ell", "un", "length"], "i": ["qi", "init", "v", "ir", "n", "is", "bi", "me", "iter", "li", "ij", "iat", "ix", "xi", "ai", "item", "ini", "ji", "gi", "ci", "ki", "info", "di", "ik", "um", "at", "ie", "ii", "t", "oi", "mi", "ip", "this", "ei", "sim", "ims", "p", "m", "multi", "ic", "ri", "ui", "g", "iii", "status", "u", "pi", "list", "ori", "id", "\u0438", "im", "io", "iu", "l", "ti", "start", "index", "x", "ia", "phi", "c", "y", "it", "si", "zi", "ind", "I"], "j": ["obj", "jp", "jl", "ix", "kj", "b", "dt", "jack", "ii", "ge", "el", "note", "p", "e", "jump", "jc", "nd", "io", "att", "s", "oj", "pr", "c", "dj", "y", "ind", "er", "aj", "n", "k", "jo", "json", "mn", "di", "je", "by", "str", "jj", "bj", "ju", "ng", "ja", "ver", "J", "ij", "f", "tr", "r", "z", "adj", "m", "dr", "try", "l", "xy", "msg", "v", "js", "fr", "li", "job", "ji", "jas", "t", "key", "ijk", "other", "o", "pt", "g", "jac", "q", "ev", "uj", "bo", "br", "bs", "it", "jit", "err"], "inc": ["init", "acc", "ipl", "rec", "iter", "alph", "ext", "amin", "INC", "lin", "isin", "asc", "step", "fc", "margin", "diff", "pp", "circ", "adj", "sum", "cond", "sign", "inner", "alpha", "fac", "inf", "occ", "gain", "align", "add", "ins", "frac", "cc", "inter", "imp", "decl", "prefix", "up", "vol", "inn", "ln", "con", "grow", "amp", "err", "Inc", "asm", "start", "incre", "inv", "include", "c", "index", "exc", "ind", "enc"], "tmp": [" np", "nt", " rgb", "obj", "cache", "cmp", "tp", " mp", "result", "pre", "MP", "emp", "ctx", "txt", "sp", "params", "prime", "comp", "tf", "mint", "td", "buff", "cb", "mk", "cmd", "pp", "attr", "pkg", "gb", "new", "t", "mp", "uf", "zip", "mm", "frac", "copy", "tab", "jj", "cp", "list", "nb", " img", "table", "up", "perm", "cur", "img", "etc", " ret", "resp", "np", " amp", "qq", "xy", "tk", "xs", "buf", "sq", "msg", "temp", " dst", "test", "ind", "mb"]}}
{"project": "FFmpeg", "commit_id": "69c1fe7c9c9bc85eebfc02c6a19caf7e88cd74ff", "target": 0, "func": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n\n                                AVPacket *pkt)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n\n    uint8_t *start, *end, *data = pkt->data;\n\n    ebml_master blockgroup;\n\n    char buffer[2048];\n\n\n\n    while (data_size) {\n\n        int duration = ass_get_duration(data);\n\n        max_duration = FFMAX(duration, max_duration);\n\n        end          = memchr(data, '\\n', data_size);\n\n        size         = line_size = end ? end - data + 1 : data_size;\n\n        size        -= end ? (end[-1] == '\\r') + 1 : 0;\n\n        start        = data;\n\n        for (i = 0; i < 3; i++, start++)\n\n            if (!(start = memchr(start, ',', size - (start - data))))\n\n                return max_duration;\n\n        size -= start - data;\n\n        sscanf(data, \"Dialogue: %d,\", &layer);\n\n        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",\n\n                     s->streams[pkt->stream_index]->nb_frames, layer);\n\n        size = FFMIN(i + size, sizeof(buffer));\n\n        memcpy(buffer + i, start, size - i);\n\n\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"Writing block at offset %\" PRIu64 \", size %d, \"\n\n               \"pts %\" PRId64 \", duration %d\\n\",\n\n               avio_tell(pb), size, pkt->pts, duration);\n\n        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n\n                                       mkv_blockgroup_size(size));\n\n        put_ebml_id(pb, MATROSKA_ID_BLOCK);\n\n        put_ebml_num(pb, size + 4, 0);\n\n        // this assumes stream_index is less than 126\n\n        avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n\n        avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n\n        avio_w8(pb, 0);\n\n        avio_write(pb, buffer, size);\n\n        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n\n        end_ebml_master(pb, blockgroup);\n\n\n\n        data      += line_size;\n\n        data_size -= line_size;\n\n    }\n\n\n\n    return max_duration;\n\n}\n", "idx": 24768, "substitutes": {"s": ["sv", "v", "n", "hs", "gs", "js", "ms", "ses", "S", "fs", "sp", "client", "ns", "ss", "b", "ts", "spec", "t", "cs", "ssl", "ats", "p", "m", "aws", "ds", "ls", "os", "a", "es", "sg", "rs", "sc", "h", "sys", "conf", "stats", "sts", "c", "sq", "ps", "self", "ctx"], "pb": ["obj", "vp", "lp", "jp", "typ", "apy", "stab", "cb", "buff", "b", "cmd", "pkg", "pg", "patch", "p", "px", "sc", "np", "tk", "ps", "emb", "pc", "n", "pa", "into", "phys", "td", "rb", "pp", "sb", "bb", "bot", "cp", "ab", "fp", "wb", "buf", "ctx", "_", "tp", "bp", "wp", "lb", "uf", "mt", "resp", "sys", "tmp", "proc", "PB", "v", "dp", "sp", "pl", "tg", "eb", "mp", "pub", "pt", "snap", "tc", "bs", "amp"], "pkt": ["cpdu", "pnt", " pdu", "pdu", "cpkt", "pvt", "Ptx", "prowk", "proacket", "pk", "pcacket", "tpk", "mnt", "prkt", "Pwk", "mtx", " pwk", " pvt", "ppkt", "prdu", "ppct", "ptx", "tpwk", "Pkt", "pckt", "tpacket", "pct", "cpct", " pnt", "Pnt", "pracket", "Pq", "macket", "Pct", " ptx", "ppvt", " pq", "prok", "cpacket", "pwk", "proct", "mdu", "Pk", "ppnt", " packet", "prokt", "pctx", "pcnt", "tpkt", "mkt", "packet", "pq", " pct", "Pdu", "Pvt", "prq", "Packet"], "mkv": ["tkv", "tkV", "mkc", " mkc", "kv", "mutv", "mkV", "mkvr", " mkvp", "mtv", "mkvc", "mtc", "kvp", "mutvr", " mkvs", "mkvs", "kV", "mutc", "mutvs", "mkvp", "tkvc", "mtvs", "mtvr", "tkvp", " mkvc", " mkvr", "kvc", " mkV"], "i": ["init", "qi", "v", "n", "is", "iter", "in", "li", "ij", "f", "ix", "xi", "ri", "ai", "ic", "ini", "b", "gi", "ci", "info", "di", "hi", "ii", "t", "mi", "ip", "cli", "sim", "ims", "m", "p", "multi", "e", "ni", "g", "ui", "d", "u", "pi", "a", "id", "io", "im", "uri", "memory", "iu", "position", "l", "height", "h", "ti", "j", "zi", "x", "phi", "index", "c", "y", "it", "si", "bi", "ind", "all", "I"], "size": ["max", "message", "read", "len", "general", "align", " Size", "time", "function", "status", "window", "id", "position", "capacity", "large", "type", "set", "speed", "ose", "offset", "small", "resolution", "body", "address", "bytes", "duration", "south", "total", "send", "sized", "dimension", "fee", "loss", "grow", "num", "length", "too", "count", "notice", "scale", "power", "timeout", "shape", "sum", "zone", "space", "unit", "l", "index", "empty", "sn", "si", "network", "scroll", "ize", "area", "padding", "shift", "name", "number", "stream", "write", "SIZE", "storage", "height", "span", "dim", "Size", "ui"], "line_size": ["Line_width", "Line_length", "line2length", "line2SIZE", "line_width", " line_SIZE", "line_space", " line_space", "line2size", " line_length", "line2space", "line_SIZE", "line_length", "Line_size"], "start": ["max", "stop", "range", "wind", "reset", "state", "origin", "len", "add", "time", "p", "e", "id", "window", "position", "type", "entry", "begin", "set", "middle", "first", "to", "offset", "next", "Start", "trans", "starting", "address", "before", "seek", "pad", "from", "a", "base", "part", "st", "length", "init", "top", "mid", "get", "delay", "r", "step", "new", "art", "started", "space", "try", "l", "tmp", "head", "index", "pos", "root", "v", "in", "sp", "source", "t", "alpha", "key", "shift", "name", "g", "point", "span", "it"], "end": ["url", "obj", "max", "stop", "mid", "offset", "range", "ended", "final", "rend", "ent", "pend", "wind", "event", "full", "END", "set", " End", "append", "complete", "east", "until", "len", "entry", "endif", "send", "add", "p", "e", "ment", "eng", "en", "out", "line", "all", "dev", "escape", "End", "ending", "last", "id", "nd", "ad", "old", "h", "close", "st", "open", "except", "hend", "done", "ue", "ord", "edge", "buf", "alt", "ff", "closed", "est", "entity", "begin", "port", "length", "w"], "data": ["message", "reset", "read", "allow", "image", "len", "align", "time", "p", "e", "feed", "id", "window", "value", "def", "input", "record", "map", "type", "aud", "first", "to", "n", "result", "offset", "iter", "next", "Data", "load", "trans", "body", "di", "bytes", "win", "str", "pad", "dev", "device", "d", "a", "base", "last", "multiple", "one", "buf", "all", "raw", "length", "partial", "f", "parent", "group", "shape", "step", "r", "dat", "ed", "table", "burst", "error", "row", "pos", "empty", "date", "ata", "DATA", "video", "cache", "text", "source", "block", "area", "t", "padding", "bin", "shift", "name", "stream", "no", "done", "batch"], "blockgroup": ["blockmap", " blocknumber", "bookgroups", "groupvolume", "blocknumber", "blockgroups", "bookvolume", "Blockgroup", "groupnumber", "blockGroup", "groupmap", "blockname", " blockGroup", "bookgroup", "groupGroup", "Blocknumber", "bookmap", "Blockname", " blockname", " blockgroups", "groupgroups", " blockmap", "blockvolume", "groupname", "groupgroup", " blockvolume", "BlockGroup"], "buffer": ["command", "cache", "bridge", "v", "text", "result", "count", "length", "iter", "server", "frame", "only", "integer", "binary", "source", "buff", "message", "b", "read", "block", "address", "sequence", "interface", "comment", "uf", "stack", "send", "header", "pad", "out", "device", "line", "queue", "stream", "table", "base", "window", "array", "byte", "Buffer", "memory", "position", "pointer", "row", "word", "document", "buf", "batch", "pair", "ptr", "variable"]}}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "substitutes": {"block_name": ["lock_path", "blocknamenames", "block_names", "block_path", "blocknametype", "lock_type", "blocknamename", "lock_name", "lock_names", "blocknamepath", "block_type"], "host_addr": ["host_address", " host_ref", "Host_ptr", "Host_ref", "host_ptr", "Host_addr", "host_ref", " host_address"], "offset": ["count", "op", "loc", "set", "address", "origin", "coord", "shift", "before", "ref", "off", "style", "bound", "os", "prefix", "base", "error", "size", "addr", "type", "start", "head", "pos", "index", "order", "alloc", "port"], "length": ["limit", "data", "count", "range", "loop", "family", "end", "amount", "shape", "load", "message", "enth", "address", "block", "sequence", "len", "duration", "padding", "total", "buffer", "pad", "idth", "ENGTH", "number", "Length", "depth", "last", "size", "value", "SIZE", "location", "position", "capacity", "height", "type", "ength", "phi", " lengths"], "opaque": ["ropaques", "oplois", "opiphany", "OPiphany", "roposit", " Opiphany", "OPaques", "oposit", " Opque", "opaques", "OPque", "OPasus", "oplasus", "oplaque", "ropaque", "OPois", "opliphany", "opois", "oplaques", "ropois", "oplque", " Opasus", "opasus", "opque", "OPosit", " Opaque", "OPaque", "oplosit"], "mis": ["ma", "sis", " us", "is", "iss", "ms", "emis", "fs", "jp", "asis", "mn", "MS", " mes", "bos", "mx", "mi", "mit", "ims", "m", "mm", "ias", "wi", "wcs", "mr", "mt", "miss", "bm", "mes", "sic", "mits", "aos", "mos", " sus", "us", "asm", "Mis", "cm", "oses", "mas", "tis"], "reg_struct": ["register_destruct", " reg_obj", "reg_desc", " reg_fun", "regetydestruct", "Reg__struct", " reg2struct", "reg__STRUCT", "reg__desc", " reg_str", "reg2str", "reg_destruct", "register_struct", "reg_obj", "Reg__desc", "regetydetails", " reg_ptr", "Reg_STRUCT", "cell_struct", "regetystr", "regetymethod", "cell_method", "reg_ptr", "reg__struct", "reg_details", "Reg__STRUCT", "reg_fun", "reg_data", " reg2obj", "regetydata", "reg2struct", "regetystruct", "reg_STRUCT", "register_data", " reg2str", " reg2fun", "Reg_desc", "reg_str", "reg_method", "reg2fun", "cell_data", "reg2obj", "Reg_struct", "cell_details", "register_str", " reg_desc"]}}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void draw_bar_yuv(AVFrame *out, const float *h, const float *rcp_h,\n\n                         const ColorFloat *c, int bar_h)\n\n{\n\n    int x, y, yh, w = out->width;\n\n    float mul, ht, rcp_bar_h = 1.0f / bar_h;\n\n    uint8_t *vy = out->data[0], *vu = out->data[1], *vv = out->data[2];\n\n    uint8_t *lpy, *lpu, *lpv;\n\n    int lsy = out->linesize[0], lsu = out->linesize[1], lsv = out->linesize[2];\n\n    int fmt = out->format;\n\n\n\n    for (y = 0; y < bar_h; y += 2) {\n\n        yh = (fmt == AV_PIX_FMT_YUV420P) ? y / 2 : y;\n\n        ht = (bar_h - y) * rcp_bar_h;\n\n        lpy = vy + y * lsy;\n\n        lpu = vu + yh * lsu;\n\n        lpv = vv + yh * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            if (h[x] <= ht) {\n\n                *lpy++ = 16;\n\n                *lpu++ = 128;\n\n                *lpv++ = 128;\n\n            } else {\n\n                mul = (h[x] - ht) * rcp_h[x];\n\n                *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (fmt == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n\n\n        ht = (bar_h - (y+1)) * rcp_bar_h;\n\n        lpy = vy + (y+1) * lsy;\n\n        lpu = vu + (y+1) * lsu;\n\n        lpv = vv + (y+1) * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            /* u and v are skipped on yuv420p */\n\n            if (fmt != AV_PIX_FMT_YUV420P) {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (out->format == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24787, "substitutes": {"out": ["data", "ex", "v", "output", "n", "obj", "to", "result", "res", "conn", "in", "raw", "frame", "over", "client", "file", "aux", "end", "f", "net", "full", "report", "b", "dot", "set", "reset", "null", "cmd", "info", "sum", "OUT", "at", "new", "t", "conv", "version", "o", "p", "scan", "g", "outs", "Out", "call", "list", "check", "base", "up", "error", "no", "io", "con", "screen", "point", "conf", "one", "batch", "normal", "success", "inv", "it", "err", "ch", "all", "w"], "h": ["hr", "ih", "v", "ph", "hs", "th", "history", "host", "hm", "f", "hl", "H", "b", "ha", "r", "he", "pp", "hi", "hh", "html", "t", "oh", "sh", "kh", "hash", "p", "m", "hw", "bh", "http", "ah", "dh", "q", "hz", "hp", "hd", "ch", "w"], "rcp_h": ["rcp__h", "rcP_f", "rcpPp", "rcp__ho", "rcpPk", "rcP_H", "rcp__f", "rcp_k", "rcp_ho", "rcp__H", "rccp_p", "rcpPhm", "rccp_hm", "rccp_k", "rcp_f", "rcp_H", "rcpPh", "rcp_p", "rcP_h", "rccp_h", "rcp_hm", "rcP_ho"], "c": ["v", "cv", "cache", "n", "pc", "ca", "cam", "co", "f", "cb", "ce", "b", "lc", "mc", "fc", "xc", "bc", "t", "cs", "dc", "cu", "lib", "ac", "conv", "ec", "cn", "p", "m", "e", "chain", "g", "cc", "cf", "ct", "cp", "u", "wcs", "cal", "sc", "C", "con", "conf", "tc", "vc", "col", "cm", "etc", "nc", "ch", "ctx"], "bar_h": ["barNamey", "bar_hi", "row_hs", "scale_v", "barprebh", "bar_height", "bar2height", "barLengthhs", "bar_hs", "comb_ih", "barpreh", "barNameh", "scale_h", "barLengthh", "bar_bh", "ca_f", "comb___th", "bar_th", "scale_height", "bar2v", "comb___bh", "bar_y", "comb_h", "bar___ih", "bar___h", "row_y", "comb_th", "barpreih", "row_ph", "barLengthy", "bar_p", "comb___ih", "comb_bh", "comb___h", "bar___th", "barLengthph", "ca_p", "barNameph", "barpreth", "row_h", "bar_ih", "barNamehs", "ca_h", "bar2h", "bar_ph", "bar___bh", "bar_f", "ca_hi", "bar_v"], "x": ["ex", "ix", "xi", "tx", "ux", "xf", "xc", "mx", "el", "add", "p", "e", "status", "te", "px", "id", "window", "att", "lex", "i", "w", " cx", "ax", "xes", "n", "k", "full", "major", "X", "yx", "by", "check", "xxxx", " xx", "ctx", "on", "inx", "xp", "wx", "step", "r", "z", "xxx", "ey", "ry", "ox", "m", "fx", "tex", "column", "search", "l", "xy", "row", "j", "index", " i", "xx", "scroll", "post", "ext", "xa", "at", "dx", "xt", "key", "o", "rx", "name", "sw", "q", "exclusive", "lat", "plus", "batch"], "y": ["ley", "v", "Y", "yi", "ty", "ly", "ot", "aily", "yr", "yu", "ay", "b", "ym", "z", "ey", "wy", "ye", "gy", "ry", "hot", "uy", "oy", "t", "ky", "ady", "yy", "ya", "yx", "m", "my", "fy", "hy", "dy", "yl", "asy", "ny", "py", "kit", "yt", "ies", "yo", "height", "try", "iy", "xy", "axy", "ys", "hey", "yn", "i", "cy", "j", "sy", "yd", "yer", "ch", "yp", "sky"], "yh": ["Yh", "uysh", "yht", "nyH", "yz", "yoh", "vyhash", "yehe", "iesh", "eyhd", "yyht", "Yhi", "yhi", "YH", "vyhi", "eyoh", "yyh", "yeh", "yyth", " yht", "nyh", "yyH", "yth", "vyh", "nyhi", " yoh", "iesht", " yhd", "iesH", "yhe", "cyth", "uyz", "vyH", "ysh", "yhd", "Yhash", "yehd", "uyh", "yeoh", "yysh", "nyhash", "cyz", " yH", "ieshe", "yyhe", "eyh", "yH", "cyh", " yhe", "cysh", "uyth", "yhash", "yyz", "eyhe"], "mul": ["Muf", "ful", "lul", "fil", " mull", "muf", "Muli", "remular", "fuf", "rult", " maj", " mmuli", "mol", "paramesh", "manull", "dol", "fUL", "mull", " mUL", "remol", "mutul", "muli", "pmular", "maj", "mutult", " moul", " mular", "fcul", "gmular", "Mult", " mula", "mult", "Mul", "mula", "Mull", "remuler", " muli", "rul", "loul", "pmil", "dular", "pmult", "Mula", "Mil", "rcul", "cmull", "mular", "remul", "cmuli", "dul", "gmuf", "lula", " mol", " mmUL", "manaj", "muler", "paramula", "mUL", "cmUL", "Mcul", " mcul", " muler", "lull", "manuf", "fular", "cmul", "moul", "rUL", "manular", "manoul", "manul", "gmul", "manula", "mil", "manesh", " mil", "mcul", "paramaj", "MUL", "gmcul", "paramul", "duler", " mmul", "mutil", " muf", "mancul", " mmula", "mutular", "pmul", " mult", "mesh", " mesh"], "ht": ["hr", "ih", "tif", "tp", "hs", "th", "zh", "txt", "tt", "hm", "rt", "hn", "HT", "hl", "wd", "phy", "ha", "he", "wy", "dq", "uly", "gy", "dt", "hop", "hei", "hh", "html", "him", "vt", "yy", "uh", "tm", "bh", "hw", "gt", "htm", "pt", "dh", "rh", "hz", "hua", "mt", "yt", "att", "hd", "lat", "height", "wt", "iw", "xy", "phi", "tml", "qt", "bt", "ch"], "vy": ["ley", "sv", "v", "vp", "yi", "ly", "qv", "yu", "vm", "ou", "vin", "wy", "ey", "uy", "oy", "ky", "vt", "yy", "fy", "hy", "vet", "ny", "py", "ishy", "zu", "yt", "ju", "yll", "von", "yo", "zy", "iy", "axy", "isy", "vc", "cy", "vi", "vr"], "vu": ["vp", "uo", "wu", "tu", "qv", "uv", "nu", "yu", "ru", "vin", "ku", "ux", "vo", "uy", "pu", "cu", "du", "asu", "zu", "u", "lu", "uj", "fu", "ju", "su", "von", "iu", "uu", "us", "vi", "ue", "vc", "bu", "ui"], "vv": ["sv", "v", "cv", "vp", "uum", "qv", "va", "uv", "yu", "vm", "var", "nov", "vd", "ku", "lv", "tv", "iv", "cu", "ctl", "vt", "asu", "avi", "nv", "ul", "ev", "uj", "ju", "von", "vs", "uu", "av", "vg", "ov", "vc", "buf", "vi", "vr"], "lpy": ["llpo", "lpte", "lbpo", " lpo", "lpo", "llpy", "dlpx", "laxy", "lepy", "lepu", "lepx", "dlpsy", "llpa", "llaxy", "lpxy", "lppy", "lbpa", "lepsy", "dlpi", "lpsy", "dlphp", "lipy", "lpse", "lipsy", "llxy", "llpx", " lpse", " lpa", "lpi", "llpsy", "lphp", "lite", "lipse", "lpa", "dlpse", "lipi", "llphp", "lxy", "lipo", "lpx", "lbpy", "lbpx", "dlpo", "lpaxy", "dlpy", " lpi", "liaxy", " lpsy", "liphp", "llte", "dlpu", "lte", " lpx", "lixy"], "lpu": ["lsu", "mlpy", "llpo", "lpie", "mpu", "linu", "nsu", " lpo", "npie", "lity", "lpo", "lpid", "nlsu", "licpu", "Lty", "llpu", "mmp", "lipie", "mlpo", "Lpo", "nlpu", "Lpy", "lipy", "lipu", "ppu", "Lsu", "elnu", "mlpu", "elpu", "elpid", "llpid", "npu", "lsnu", "pty", "pcpu", "llcpu", "llmp", "elcpu", "nlpie", "lcpu", "mlsu", "llnu", "Lcpu", "lipo", "ppy", "lmp", "lty", "mnu", "lnu", "lscpu", "lspu", "lisu", " lsu", "limp", "mpo", "lspid", "Lpu"], "lpv": ["lsu", "ppV", "bpv", "lpvr", "lpr", "gpvin", "lpve", "ctlvr", "bpz", "lpva", "lbf", "mlv", "bpf", "ppv", "lsv", "lpvin", "LPv", "lbvi", "lbr", "lipvi", "ppu", "lipr", "lv", "linva", "lf", "mlve", "lsve", "lbz", "LPve", "lbvt", "gpu", "ppvin", "mlf", "lsvt", "lbv", "bpve", "ctlve", "lbvr", "LPf", "linf", "lpz", "ctlv", "ctlvi", "mlva", "lbve", "lipv", "lve", "lipve", "lipvr", "lpvi", "LPz", "lsvin", "lpf", "lpvt", "gpv", "gpV", "lsr", "linve", "lpV", "lsV", "lipvt", "linv", "lva"]}}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n", "idx": 24794, "substitutes": {"opts": ["opgs", "coptx", "optpt", "ioptx", "iopths", "ioprs", "oprs", "ops", "coprs", "uppt", "OPs", "upgs", "optts", "OPgs", "opttx", "iopts", "oppt", "ups", "optx", "optrs", "copts", "optgs", "OPpt", "copths", "opths", "OPts", "optths", "upts"], "_chr": [" _Chlr", " _cht", "_otp", " _chlr", "_Char", " _Chl", " _chl", "_Chp", " _chrs", "_CHr", "_echl", "_CHp", "_otar", " _Chp", " _Char", "_Chlr", " _char", " _Cht", "_echt", "_CHlr", "_cht", "_chp", "_otr", "_chrs", "_char", " _Chrs", " _Chr", "_CHar", "_chlr", "_Chr", "_chl", "_Chrs", "_echr", "_Cht", " _chp", "_Chl", "_otlr", "_echrs"], "file_out": ["File_out", "File_in", "File_name", "file__output", "file_Out", " file_in", "file_output", "file_handle", "file_in", " file_output", "file__out", " file_Out", "File_handle", "file__in", "file_name", "file__Out"], "fd_out": ["FD_new", "fd___out", "fd___in", "fd2con", "fd___OUT", "file_in", "fd_group", "fd_key", "file_OUT", "fd_in", "file_con", "fd_new", "fd_Out", "fd_OUT", "file_Out", "FD_check", "fd_check", "file2key", "fd2out", "fd2Out", "file2con", "fd_list", "fd2key", "FD_list", "file_group", "FD_out", "file2out", "file_key", "fd___group", "file2Out", "FD_in", "fd_con"]}}
{"project": "FFmpeg", "commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "target": 1, "func": "int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int i, len;\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        H264Picture *sorted[32];\n\n        int cur_poc, list;\n\n        int lens[2];\n\n\n\n        if (FIELD_PICTURE(h))\n\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n\n        else\n\n            cur_poc = h->cur_pic_ptr->poc;\n\n\n\n        for (list = 0; list < 2; list++) {\n\n            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);\n\n            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);\n\n            av_assert0(len <= 32);\n\n\n\n            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                                  sorted, len, 0, h->picture_structure);\n\n            len += build_def_list(h->default_ref_list[list] + len,\n\n                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                                  h->long_ref, 16, 1, h->picture_structure);\n\n            av_assert0(len <= 32);\n\n\n\n            if (len < sl->ref_count[list])\n\n                memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n\n            lens[list] = len;\n\n        }\n\n\n\n        if (lens[0] == lens[1] && lens[1] > 1) {\n\n            for (i = 0; i < lens[0] &&\n\n                        h->default_ref_list[0][i].parent->f.buf[0]->buffer ==\n\n                        h->default_ref_list[1][i].parent->f.buf[0]->buffer; i++);\n\n            if (i == lens[0]) {\n\n                FFSWAP(H264Ref, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n            }\n\n        }\n\n    } else {\n\n        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                              h->short_ref, h->short_ref_count, 0, h->picture_structure);\n\n        len += build_def_list(h->default_ref_list[0] + len,\n\n                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                              h-> long_ref, 16, 1, h->picture_structure);\n\n        av_assert0(len <= 32);\n\n\n\n        if (len < sl->ref_count[0])\n\n            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n\n    }\n\n#ifdef TRACE\n\n    for (i = 0; i < sl->ref_count[0]; i++) {\n\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n\n                (h->default_ref_list[0][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                h->default_ref_list[0][i].pic_id,\n\n                h->default_ref_list[0][i].parent->f.data[0]);\n\n    }\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        for (i = 0; i < sl->ref_count[1]; i++) {\n\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n\n                    (h->default_ref_list[1][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                    h->default_ref_list[1][i].pic_id,\n\n                    h->default_ref_list[1][i].parent->f.data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24818, "substitutes": {"h": ["v", "ih", "ph", "hs", "cache", "th", "history", "host", "zh", "hm", "f", "hl", "http", "H", "r", "ha", "z", "he", "pp", "hi", "hh", "html", "HH", "oh", "sh", "eh", "kh", "w", "uh", "el", "hash", "p", "bh", "hw", "m", "header", "g", "ah", "dh", "comm", "dev", "sw", "rh", "window", "hz", "here", "hal", "hp", "hd", "s", "cur", "l", "ho", "gh", "handle", "ht", "c", "y", "ch", "ctx"], "sl": ["sv", "cl", "nl", "spot", "slice", "zh", "sp", "jl", "serv", "sf", "kl", "pl", "rl", "isl", "shr", "hl", "se", "bl", "ssl", "sh", "sb", "sel", "bh", "fl", "gro", "ml", "ls", "sw", "scl", "so", "syn", "ssh", "ln", "sc", "spl", "SL", "s", "l", "bs", "pse", "c", "ht", "sn", "Sl", "tl", "dl"], "i": ["qi", "init", "v", "is", "in", "iter", "li", "client", "f", "ix", "xi", "ai", "ini", "r", "gi", "ci", "ki", "info", "di", "hi", "at", "ii", "oi", "this", "mi", "ip", "ei", "sim", "ic", "p", "multi", "status", "ui", " ii", "q", "pi", "id", "im", "iu", "try", "l", "us", "ti", "phi", "j", "index", "x", "c", "batch", "zi", "y", "it", "si", "bi", "ind", "I"], "len": ["gen", "fin", "lp", "val", "low", "comp", "loc", "elt", "pres", "lf", "lan", "el", "ref", "coll", "compl", "Len", "ls", "ln", "vol", "def", "alt", "gz", "il", "n", "iter", "L", "gl", "lis", "norm", "full", "lc", "lig", "lang", "html", "fun", "lib", "lon", "str", "ml", "ul", "wid", "ell", "length", "lit", "limit", "rev", "count", "ll", "lim", "hl", "vec", "spec", "bl", "rot", "relation", "rel", "syn", "lt", "ler", "ld", "l", "pos", "msg", "cmp", "cl", "li", "sp", "kl", "pl", "mem", "seq", "den", "fl", "en", "size", "von", "label", "lvl", "err", "dl"], "sorted": ["isorting", "Saved", "sort", "Sorting", "isordered", " sorting", "Sort", "insort", "sorter", "rsorter", "Sorter", "insorting", " sordered", "insorted", "insaved", "saved", "isaved", "isort", "Sorted", "sordered", "isorted", "rsorted", "insorter", "rsort", "sorting", "Sordered", " sorter", " sort", "isorter", "rsorting"], "cur_poc": ["cur_prOC", "cur_vivot", "cur_pocation", "cur_perocation", "cur_prix", "cur_losc", "cur_phpOC", "cur_piivot", "cur_perOC", "cur_picoc", "cur_permoca", "cur_plivot", "cur_plocol", "cur_permOC", "cur_ploc", "cur_opoca", "cur_Pop", "cur_pivot", "cur_vop", "cur_loca", "cur_permop", "cur_phpvoc", "cur_POC", "cur_vOC", "cur_pervoc", "cur_opOC", "cur_piop", "cur_ploco", "cur_Poc", "cur_opop", "cur_voca", "cur_piix", "cur_voc", "cur_piocol", "cur_poca", "cur_loc", "cur_piOC", "cur_peroc", "cur_picoco", "cur_vosc", "cur_pvoc", "cur_permoc", "cur_pOC", "cur_pix", "cur_phpoc", "cur_voco", "cur_pioc", "cur_Poca", "cur_poco", "cur_vix", "cur_vocol", "cur_picoca", "cur_picosc", "cur_vvoc", "cur_posc", "cur_vocation", "cur_pop", "cur_pioco", "cur_loco", "cur_pocol", "cur_prop", "cur_proc", "cur_opoc", "cur_phpocation"], "list": ["range", "file", "link", "any", "tree", "plot", "add", "note", "status", "ls", "id", "old", "List", "listed", "record", "type", "alt", "form", "ind", "set", "ist", "L", "level", "lc", "feat", "act", "total", "LI", "alist", "from", "ul", "part", "lists", "high", "st", "num", "order", "all", "length", "and", "top", "count", "local", "parent", "tag", "layer", "null", "spec", "token", "sequence", "art", "collection", "chain", "out", "table", "lt", "l", "card", "row", "LIST", "index", "msg", "test", "user", "loop", "li", "member", "show", "item", "block", "single", "code", "name", "number", "no", "size", "lat", "label", "batch", "lvl", "dl"], "lens": ["olents", "llens", "llanguages", " laps", " lems", "ilaps", "Laps", "llents", "leen", " lizes", "olears", " lows", "plen", "glems", "plens", "flents", "ylens", "ylents", "lems", "flens", "Lenses", " lenses", "Lensions", "Lizes", "languages", "llaps", "Lears", "lears", "olens", "lensions", "leows", "glens", "glenses", "leens", "olensions", "lenses", "lows", "laps", "ylears", "glents", "Len", "lents", "Lows", "ilenses", "ilens", "flenses", " languages", "plizes", "ilents", "lizes", "Languages", "ylensions", "plents", "leents", "Lens", "Lents", " lents", "flems"]}}
{"project": "qemu", "commit_id": "a3f409cb4a35d9aa6a4d24a7a1e05423e189cb7a", "target": 1, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->iommu_ops.notify_started = vtd_iommu_notify_started;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    if (x86_iommu->intr_supported) {\n\n        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;\n\n    }\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n", "idx": 24824, "substitutes": {"s": ["sv", "tags", "bits", "gs", "ms", "ses", "changes", "services", "sam", "details", "actions", "pers", "parts", "comments", "styles", "sd", "p", "e", "aws", "ls", "rs", "sets", "as", "us", "als", "i", "sports", "c", "y", "ps", "results", "set", "n", "bis", "ers", "fs", "ties", "ns", "states", "ts", "se", "south", "less", "sb", "ins", "terms", "os", "es", "locks", "ies", "vs", "stats", "sts", "ports", "settings", "args", "hs", "is", "ss", "r", "an", "spec", "cs", "ats", "space", "comm", "simple", "ds", "sync", "ids", "l", "sys", "sql", "ads", "sq", "v", "js", "eps", "S", "reads", "qs", "t", "mods", "gets", "ims", "sl", "tests", "sw", "h", "bs", "its", "utils", "self"], "x86_iommu": ["x86_iomingu", "x86_iommun", "x86_iummcu", "x86_gomun", "x86_iomue", "x86_iomun", "x86_iommcu", "x86_iomingun", "x86_iomcu", "x86_iopheru", "x86_Iommue", "x86_Iommcu", "x86_iummtu", "x86_iopherun", "x86_Iommu", "x86_gommcu", "x86_Iomu", "x86_Iomtu", "x86_Iomcu", "x86_gommu", "x86_iormue", "x86_iommue", "x86_iormcu", "x86_iomu", "x86_gomu", "x86_iomtu", "x86_iommtu", "x86_Iomue", "x86_iummu", "x86_gomcu", "x86_Iommtu", "x86_iummue", "x86_iophercu", "x86_iomingcu", "x86_iormu", "x86_gommun", "x86_iormtu"]}}
{"project": "FFmpeg", "commit_id": "ce19aec15b4291dc48e791d89a1f940babc22cdc", "target": 0, "func": "const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)\n\n{\n\n    av_assert2(p < end);\n\n\n\n    end-=2;\n\n    p++;\n\n    for(;p<end; p+=2){\n\n        if(!*p){\n\n            if     (!p[-1] && p[1]) return p - 1;\n\n            else if(!p[ 1] && p[2]) return p;\n\n        }\n\n    }\n\n    return end+2;\n\n}\n", "idx": 24829, "substitutes": {"av_restrict": ["av_destricted", "av_district", "av_Restrict", "av_destrict", "av_stateind", "av_statericted", "av_restriction", "av_Restricted", "av_distind", "av_restind", "av_Restriction", "av_destind", "av_stateriction", "av_staterict", "av_restricted", "av_distriction", "av_destriction", "av_districted"], "p": ["ap", "vp", "lp", "jp", "after", "b", "pers", "pkg", "pg", "ip", "e", "ping", "app", "perm", "np", "i", "pb", "c", "pr", "php", "y", "ps", "pc", "n", "pa", "op", "pn", "pp", "pat", "pad", "P", "d", "cp", "u", "rep", "pi", "part", "fp", "pe", "progress", "pair", "ptr", "tp", "pre", "bp", "wp", "power", "f", "r", "z", "pid", "m", "out", "l", "pm", "j", "pos", "empty", "v", "parse", "dp", "page", "post", "sp", "end", "pl", "pro", "info", "at", "t", "par", "pt", "g", "q", "up", "h", "point", "span", "err", "port"]}}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n", "idx": 24847, "substitutes": {"env": ["obj", "vp", "conn", "txt", "uv", "net", "estate", "vm", "cb", "ner", "cmd", "pg", "vv", "vt", "ei", "ec", "erd", "forge", "e", "hw", "environment", "nv", "te", "window", "here", "app", "tk", "eg", "inv", "entry", "er", "runner", "db", "client", "Environment", "manager", "timer", "eh", "shell", "doc", "eng", "dev", "ah", "cp", "equ", "vs", "addr", " environment", "ov", "desc", "buf", "et", "order", "ctx", "init", "cv", "context", "query", "hl", "gate", "em", "door", "operator", "stage", "worker", "global", "extra", "msg", "test", "network", "v", "enter", "oe", "server", "loader", "ext", "disk", "ee", "end", "viron", "config", "mem", "gear", "den", "stack", "req", "en", "sw", "org", "ew", "esc", "engine", "ev", "ef", "h", "era"], "arg1": ["sum1", "addr001", "eventone", "app01", "arg2", "argument01", "block1", "alt0", " argument1", "att1", "alt001", "loc1", "Arg1", "arg3", "block001", "argone", "event001", "prop1", "Arg2", "attized", "prop3", "app51", "arg001", "argumentized", "app512", " argument2", "arg11", "matchone", "args3", "match1", "argument0", "argument001", "arr1", "attOne", "argument8", "alt512", "val8", "msg1", "arg101", "app1", " arg3", "loced", "alt11", "Arg11", "args0", "link001", "agg2", " arg0", "att2", "app0", " arg01", "argumentOne", "argument512", "alt1", "val1", "link01", "argized", " argument0", "match001", "addr0", "loc001", " arg11", "addr1", "Arg0", "arr191", "msgized", "argOne", "arrized", "argument2", "arg01", "arr101", "msg191", " arg8", "argument3", "arged", "prop2", "link1", "argument11", "app2", "prop01", "arg512", "args2", " argument11", "locone", "val3", "sum191", "arg51", "argument51", "testized", "agg1", "event1", "testOne", "arg8", "agg01", "block2", "matched", "arg0", "val2", " arg2", "test2", "evented", "sum101", "addr512", "arg191", "args1", "link2", "sumized", "test1", "app11", "block01", "argument1", "msg101", "agg51"], "reg": ["rem", "res", "rec", "script", "isc", "gc", "red", "typ", "ret", "leg", "tag", "registered", "or", "r", "round", "cmd", "sec", "key", "match", "ref", "Reg", "eng", "g", "rm", "arg", "region", "REG", "rc", "pattern", "br", "row", "addr", "re", "eg", "ia", "index", "asm", "lag", "abc"]}}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853, "substitutes": {"opaque": ["Opaques", "oplane", " opca", "iopue", "Opient", " opaques", "OPca", "opca", " opient", " opane", "opient", "oplca", "iopaque", "opane", "opaques", "OPane", "iopient", "oplaque", "iopaques", "Opue", " opue", "opue", "OPaque", "Opaque"], "irq": ["iraware", "irtqi", "renqq", "rirquest", "renq", "reng", "irgate", "irp", " irquest", "iriqu", "irique", " virqi", "irque", "ireql", "pirquer", "irconf", "interquer", "irquer", "rirware", "pirqu", "pirquest", "iriq", "irware", "irfy", "pirq", "rirqq", "irquest", "irqq", "irqu", "irql", "irqa", " virqa", "ireq", "rengate", "rirq", " irg", "iraque", " irquer", "iriware", " virql", "irtq", "rirqu", "rirconf", " irgate", "irtql", "iriquest", " virq", "rirfy", " irp", "iriconf", "iraq", "irtqa", "pirp", "rirque", "pirfy", "ireqa", " irqq", "irify", "interp", "interquest", "rirg", "interq", "iraconf", "irg", "irqi", "rirgate", "ireqi"], "level": ["limit", "priority", "VEL", "count", "loop", "member", "mode", "scale", "local", "show", "low", "print", "required", "quiet", "group", "legal", "layer", "bit", "vel", "where", "goal", "code", "status", "allowed", "style", "visible", "impact", "depth", "high", "role", "flag", "Level", "levels", "condition", "type", "lvl", "scope", "index", "le"], "env": ["obj", "conn", "die", "uv", "outer", "estate", "vm", "cmd", " context", "vt", "ec", "erd", "e", "environment", " horizon", "window", " ne", "console", "entry", " ent", "er", " vex", "db", " buffer", "Environment", "policy", "manager", "der", " te", "eh", "shell", "doc", "dev", " envelope", "ah", "vs", "screen", " environment", "ov", "desc", " dh", "context", "menu", "door", "goal", " envoy", "ds", "worker", "global", "v", "ve", "enter", "oe", "server", "actor", "bar", "ext", "ee", "disk", "end", "viron", "config", "gear", "den", " ov", "code", "en", "dh", "esc", "engine", "ev", "ef", " en", "scope"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n", "idx": 24855, "substitutes": {"bdrv": ["vsrf", "vdrv", " bldvr", "bsrf", "bvrv", "vsrv", " bdrvc", "bvrf", "bldver", "bserver", "bsrvc", "bservr", "bsrv", "vdrvr", "bldv", "bdrf", " bldf", " bdrf", " bldv", "bsrvr", "bserf", " bldvc", "vdrver", "bldvr", "bvrvr", "bvrvc", "bldf", "vdrf", "bldvc", "bsrver", "bserv", "bdrvc", "bdrver", "bdrvr", "vsrver", "vsrvr", " bdrvr"], "cmd": ["command", "nt", "gen", "obj", "pay", "cmp", "md", "cl", "control", "conn", "exec", "raw", "Cmd", "ext", "txt", "mode", "cd", "opt", "content", "comp", "config", "job", "mem", "tx", "seq", "det", "cb", "buff", "mk", "phy", "dq", "pkg", "cond", "path", "fun", "cod", "uf", "req", "quit", "cli", "comm", "code", "pt", "off", "crypt", "ct", "cp", "call", "window", "cur", "def", "img", "force", "help", "ctr", "cont", "map", "addr", "handle", "desc", "batch", "msg", "ind", "cfg", "ctx"], "buf": ["data", "nt", "v", "cv", "vp", "cache", "obj", "ba", "db", "txt", "bg", "mem", "context", "seq", "tx", "buff", "cb", "rb", "vec", "pipe", "dq", "block", "pool", "pkg", "bytes", "path", "arr", "uf", "bin", "ref", "doc", "p", "buffer", "eng", "pt", "queue", "cp", "q", "nb", "window", "Buffer", "cur", "img", "def", "Buff", "nm", "np", "br", "map", "tmp", "resp", "cap", "wb", "wait", "batch", "desc", "ff", "msg", "proc", "orig", "pos", "bag", "pb", "err", "ctx"], "sensebuf": ["iebuffer", "ensebuffer", "tiebuffer", " sensedata", " sensebuff", "rangebuff", "ensebuff", " sensewindow", "sensebuffer", "iebuf", "tiewindow", "rangecb", "ensecb", "rangefb", "tiebuf", "sensedata", "sensecb", "senseblock", " sensebuffer", " senseblock", "ensefb", "iedata", "sexbuffer", "ieblock", "tiebuff", "sensefb", "sexfb", "sexbuff", "sexcb", "sexbuf", "sensebuff", "enseblock", "rangebuf", "ensebuf", "sensewindow", "sexwindow", "ensedata"], "io_header": [" io_state", "ioacholder", "autoermaster", " io_body", " io_drm", " io_writer", "io_flag", "cli_header", "io_detail", "io2drm", "ioptsource", "io__writer", " io_headers", "erroracplayer", "ao_handler", "ao_detail", "erroracheader", "io2holder", "io__headers", "ao\u05bcdetail", "io_holder", "iojbody", "io_drm", "ioOheaders", "autoermodel", "io_Header", "ioacterm", "io_writer", "ioptdrm", " io_layer", "ao\u05bcheader", "io_head", "ioacheader", "io___detail", " io2dr", "ioerhead", "io___header", "lo_headers", "ao\u05bcdata", " io_flag", "ioOheader", " io2info", "io_device", "io_layer", "error_state", "io_info", "iopthead", "lo_layer", "clioheader", " io2drm", "ioptheader", "io___list", " io2Header", " io2header", "error_header", "io_master", "ioodetail", " io_tree", " io2wrapper", "ao_header", "io_data", "io_state", "autoerloader", "io2dr", "io__tree", "io2info", " io2holder", "ioptmaster", "ioptplayer", "error_head", "errorachead", "io_model", "auto_master", "ioermetadata", "ioptmetadata", "io\u05bcdata", "io_term", "io\u05bchandler", "io___tree", "io_headers", "iojheader", "ioachead", "iooinfo", "io_tree", " io_Header", "io_player", " io_head", "ioerloader", " io_term", "io_loader", "io2wrapper", "autoerheader", " io_info", "ioermodel", "ioacplayer", "io__header", "io_handler", "ioOdevice", "ioaclayer", "io__flag", "clioholder", "ao_data", "io_list", "cli_detail", "ioOlayer", "io2Header", " io_player", "auto_loader", " io_source", "ioptinfo", "io___data", "io2header", " io_list", " io_master", "io___handler", " io_dr", "cliodetail", " io_holder", "ioptdetail", "io_source", "ioptwrapper", " io_model", "auto_model", " io_wrapper", "auto_header", "ao\u05bchandler", "io_metadata", "io_body", "lo_header", "io_status", " io_status", "ioptHeader", "ioptholder", "io\u05bcheader", "cli_info", "io__list", "cli_holder", "io_dr", "io_wrapper", "erroracstate", "lo_device", "ioermaster", " io_metadata", "io___state", "iooheader", "ioacstate", "clioinfo", "error_player", "ioerheader", "io__state", "iooholder", "io\u05bcdetail"], "ret": [" fut", "nt", "rem", "res", "result", "gc", "ter", " alt", "ext", "val", "aux", "ll", "rt", "rets", "ne", "reply", "tr", "det", "reset", "elt", " Ret", "usr", "Return", "len", "t", "xt", "arr", "deg", "ft", "gt", "Ret", "out", "inter", "ount", "mt", "RET", "lt", "flag", "cont", "resp", " RET", "back", "re", "alt", "desc", "err", "rect", "lit"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24880, "substitutes": {"bs": ["BS", "bits", "bas", "hs", "iss", "ba", "bis", "js", "ks", "bp", "gs", "ms", "ses", "ubis", "bf", "obs", "fs", "ubs", "ss", "b", "ts", "qs", "bos", "bc", "cs", "bl", "bes", "sb", "bps", "bh", "ds", "bles", "bb", "ls", "bd", "cks", "bm", "vs", "lbs", "sts", "its", "bt", "bi"], "ign": ["iban", "urn", "aj", "IGN", "anc", "sam", "ignore", "mem", " assign", "lock", "ize", "loc", "reg", "box", "cmd", "cond", "sign", "act", "coord", "auth", "align", "add", "abc", "bind", "ont", "bag", "check", "bn", "gn", "aff", "ignment", "cont", "col", "anch", "igned", "rn", "iam", "ind", "set"], "offset": ["owner", "util", "ocation", "file", "crop", "amount", "op", "loc", "upload", "block", "address", "offs", "area", "origin", "metadata", "offer", "align", "ref", "o", "seek", "out", "off", " offsets", "absolute", "Offset", "prefix", "tile", "base", "trace", "error", "mt", "part", "location", "position", "point", "pointer", "addr", "type", "start", "alias", "index", "pos", "et", "order", "attribute", "root", "set"], "size": ["count", "small", "scale", "mode", "amount", "mem", "shape", "ize", "message", "description", "body", "spec", "address", "bytes", "sum", "year", "len", "sec", "total", "space", "time", "sha", "name", "sym", "since", "fee", "news", "SIZE", "storage", "unit", "height", "capacity", "iz", "s", "large", "type", "gz", "empty", "dim", "sn", "sq", "Size", "term", "length"]}}
{"project": "FFmpeg", "commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "target": 0, "func": "int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    Picture *pic;\n\n    s->mb_skipped = 0;\n\n\n\n    if (!ff_thread_can_start_frame(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* mark & release old frames */\n\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n\n        s->last_picture_ptr != s->next_picture_ptr &&\n\n        s->last_picture_ptr->f.buf[0]) {\n\n        ff_mpeg_unref_picture(s, s->last_picture_ptr);\n\n    }\n\n\n\n    /* release forgotten pictures */\n\n    /* if (mpeg124/h263) */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (&s->picture[i] != s->last_picture_ptr &&\n\n            &s->picture[i] != s->next_picture_ptr &&\n\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n\n            if (!(avctx->active_thread_type & FF_THREAD_FRAME))\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"releasing zombie picture\\n\");\n\n            ff_mpeg_unref_picture(s, &s->picture[i]);\n\n        }\n\n    }\n\n\n\n    ff_mpeg_unref_picture(s, &s->current_picture);\n\n\n\n    release_unused_pictures(s);\n\n\n\n    if (s->current_picture_ptr &&\n\n        s->current_picture_ptr->f.buf[0] == NULL) {\n\n        // we already have a unused image\n\n        // (maybe it was set before reading the header)\n\n        pic = s->current_picture_ptr;\n\n    } else {\n\n        i   = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        pic = &s->picture[i];\n\n    }\n\n\n\n    pic->reference = 0;\n\n    if (!s->droppable) {\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            pic->reference = 3;\n\n    }\n\n\n\n    pic->f.coded_picture_number = s->coded_picture_number++;\n\n\n\n    if (ff_alloc_picture(s, pic, 0) < 0)\n\n        return -1;\n\n\n\n    s->current_picture_ptr = pic;\n\n    // FIXME use only the vars from current_pic\n\n    s->current_picture_ptr->f.top_field_first = s->top_field_first;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (s->picture_structure != PICT_FRAME)\n\n            s->current_picture_ptr->f.top_field_first =\n\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n\n    }\n\n    s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&\n\n                                                 !s->progressive_sequence;\n\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n\n\n    s->current_picture_ptr->f.pict_type = s->pict_type;\n\n    // if (s->flags && CODEC_FLAG_QSCALE)\n\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n\n    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n\n                                   s->current_picture_ptr)) < 0)\n\n        return ret;\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n\n        s->last_picture_ptr = s->next_picture_ptr;\n\n        if (!s->droppable)\n\n            s->next_picture_ptr = s->current_picture_ptr;\n\n    }\n\n    av_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n\n            s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,\n\n            s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,\n\n            s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,\n\n            s->pict_type, s->droppable);\n\n\n\n    if ((s->last_picture_ptr == NULL ||\n\n         s->last_picture_ptr->f.buf[0] == NULL) &&\n\n        (s->pict_type != AV_PICTURE_TYPE_I ||\n\n         s->picture_structure != PICT_FRAME)) {\n\n        int h_chroma_shift, v_chroma_shift;\n\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n\n                                         &h_chroma_shift, &v_chroma_shift);\n\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocating dummy last picture for B frame\\n\");\n\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"warning: first frame is no keyframe\\n\");\n\n        else if (s->picture_structure != PICT_FRAME)\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocate dummy last picture for field based first keyframe\\n\");\n\n\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->last_picture_ptr = &s->picture[i];\n\n\n\n        s->last_picture_ptr->reference   = 3;\n\n        s->last_picture_ptr->f.key_frame = 0;\n\n        s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n\n            s->last_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n\n\n        memset(s->last_picture_ptr->f.data[0], 0x80,\n\n               avctx->height * s->last_picture_ptr->f.linesize[0]);\n\n        memset(s->last_picture_ptr->f.data[1], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[1]);\n\n        memset(s->last_picture_ptr->f.data[2], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[2]);\n\n\n\n        if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n\n            for(i=0; i<avctx->height; i++)\n\n            memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);\n\n        }\n\n\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n    if ((s->next_picture_ptr == NULL ||\n\n         s->next_picture_ptr->f.buf[0] == NULL) &&\n\n        s->pict_type == AV_PICTURE_TYPE_B) {\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->next_picture_ptr = &s->picture[i];\n\n\n\n        s->next_picture_ptr->reference   = 3;\n\n        s->next_picture_ptr->f.key_frame = 0;\n\n        s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n\n            s->next_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n\n\n#if 0 // BUFREF-FIXME\n\n    memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));\n\n    memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));\n\n#endif\n\n    if (s->last_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->last_picture);\n\n        if (s->last_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->last_picture,\n\n                                       s->last_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n    if (s->next_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->next_picture);\n\n        if (s->next_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->next_picture,\n\n                                       s->next_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n\n                                                 s->last_picture_ptr->f.buf[0]));\n\n\n\n    if (s->picture_structure!= PICT_FRAME) {\n\n        int i;\n\n        for (i = 0; i < 4; i++) {\n\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n\n                s->current_picture.f.data[i] +=\n\n                    s->current_picture.f.linesize[i];\n\n            }\n\n            s->current_picture.f.linesize[i] *= 2;\n\n            s->last_picture.f.linesize[i]    *= 2;\n\n            s->next_picture.f.linesize[i]    *= 2;\n\n        }\n\n    }\n\n\n\n    s->err_recognition = avctx->err_recognition;\n\n\n\n    /* set dequantizer, we can't do it during init as\n\n     * it might change for mpeg4 and we can't do it in the header\n\n     * decode as init is not called for mpeg4 there yet */\n\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n\n    } else {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24881, "substitutes": {"s": ["sv", "bits", "gs", "ms", "ses", "changes", "sam", "scripts", "details", "b", "state", "parts", "https", "comments", "bes", "styles", "p", "aws", "ls", "news", "scl", "rs", "series", "as", "us", "als", "sports", "c", "y", "ags", "ps", "set", "w", "n", "bis", "fs", "ns", "states", "ts", "has", "se", "less", "sb", "ins", "os", "es", "a", "ies", "events", "vs", "stats", "sts", "ports", "settings", "args", "hs", "is", "f", "asts", "ss", "z", "an", "spec", "cs", "ats", "times", "m", "comm", "ds", "sys", "j", "sq", "v", "js", "eps", "S", "sp", "qs", "t", "ims", "g", "tests", "sw", "views", "q", "sg", "h", "bs", "its", "aunts", "self"], "avctx": ["avejac", "aveco", "avercontext", "averctx", "avctl", "averwcs", "avcontext", "devctx", "ovobj", "avwcs", " avconn", "ovcss", " avtx", "avcaps", "ovctx", "ajtx", "avercb", "wavpkg", "avco", "ajwcs", " avpkg", "avectl", "averjac", "avcb", "aveobj", "averobj", "devcaps", "wavcaps", "avobj", "devjac", "ajcb", "avjac", "devcontext", "averco", "avecontext", " avjac", "wavcontext", "avpkg", "wavjac", "avconn", "avewcs", " avco", "avecb", "ajco", "averctl", "ajcontext", "avercaps", "ajctx", "ajpkg", "averconn", "avercss", "wavtx", " avcontext", " avwcs", "avcss", "avtx", "aveconn", "avecss", "avectx", "ovctl", "wavctx"], "i": ["qi", "ex", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "p", "e", "ori", "id", "io", "zi", "c", "y", "ish", "bi", "ind", "I", "to", "n", "k", "json", "ci", "di", "by", "jj", "d", "u", "pi", "a", "iu", "fi", "phi", "init", " j", "is", "me", "ij", "f", "ini", "r", "gi", " bi", "cli", "ri", "ic", "m", "multi", "sim", "chain", "cgi", " ii", "\u0438", "im", "l", "j", "index", "si", "v", "in", "li", " ni", "ai", "go", "ji", "ki", "info", "mi", "o", "g", "list", "uri", "point", "span", "err", "ti", "batch", "x", "it", "ui"], "ret": ["nt", "rem", "il", "res", "result", "txt", "jp", "val", "ll", "print", "rt", "reply", "r", "bool", "ri", "gt", "status", "Ret", "out", "rel", "mt", "RET", "re", "alt", "et", "set"], "pic": ["magic", "ig", "iac", "pc", "pick", "camera", " Pic", "script", "cam", "gc", "pa", "peg", "lp", "sp", "jp", "feature", "phys", "f", "pl", "policy", "Pict", "Picture", "png", "capt", "photo", "pin", "pp", "spec", "spr", "feat", "pres", "image", "ics", "mp", "ac", "pict", "phot", "ic", "doc", "p", "picture", "ping", "g", "py", "pi", "kit", "fp", "sc", "img", "piece", "jpg", "pen", "pr", "Pic", "pb", "proc", "ptr", "ps", " picture"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895, "substitutes": {"opaque": ["popaques", "ogque", "oplute", "ogaque", "paques", "popaque", "OPaques", "oposit", "pulus", "OPulus", "ogaques", "opaques", "popque", "oplulus", "ogosit", "opulus", "oplaque", "oplaques", "pute", "oplque", "OPute", "opque", "poposit", "OPaque", "opute", "oplosit", "paque"], "s": ["sv", "sis", "n", "is", "hs", "gs", "S", "fs", "ns", "Ws", "ss", "r", "b", "z", "ts", "state", "se", "t", "less", "ats", "o", "p", "e", "m", "ds", "ls", "q", "os", "a", "es", "rs", "ess", "acs", "sts", "bs", "c", "sq", "ps", "set"]}}
{"project": "FFmpeg", "commit_id": "41abc9da50ba7a7b68bbbf6622475ce7a3c72e3f", "target": 1, "func": "static int decode_frame_ilbm(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for (plane = 0; plane < s->bpp; plane++) {\n\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for(y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n\n                    if (start >= buf_end)\n\n                        break;\n\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n\n        int x;\n\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n\n            buf += raw_width;\n\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n\n                for(x = 0; x < avctx->width; x++)\n\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { // PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 24896, "substitutes": {"avctx": ["avejac", "AVkt", "avertmp", "avepkg", " avcmd", "AVcontext", "ajtx", "wavpkg", "avhandle", " avpkg", "averjac", "wavhandle", "svctx", "avecontext", "wavcf", "wavctl", "ajpkg", "avertx", " avctl", " avhandle", "avgc", "svtx", "averpkg", "svcontext", "averkl", "avkl", " avtx", " avconn", "ajcfg", "ajctl", "avetx", "avercmp", "wavjac", "ajcontext", "abcontext", "avegc", "wavtmp", "avtmp", "wavtx", "averconn", " avcontext", "avtx", " avcmp", "averwindow", "afctl", "avctl", "svcmd", "abctx", "wavctx", "avehandle", "abtx", " avkt", "avercontext", "aftx", " avgc", "avcontext", "verctx", "abkt", "abhandle", "ajkl", "afctx", "avcmd", "avwindow", "avecmd", "verctl", "ajjac", "afpkg", "wavcm", " avjac", "avpkg", "ajcf", "avconn", "averctl", "ajgc", "abcmd", "vertx", "ajcm", "avcmp", "aveconn", "AVctl", "avcm", "avercfg", "avcf", "vergc", "AVtx", "averctx", " avcfg", "svwindow", "avecmp", "AVctx", "afkl", "avcfg", "avectl", "aftmp", "avekt", "avergc", "afgc", "abpkg", "avercf", "avjac", "avecfg", "wavcontext", "ajctx", " avwindow", "avecm", "avectx", "ajkt", "avkt"], "data": ["bits", "zero", "rew", "message", "read", "len", "options", "p", "header", "da", "window", "id", "value", "def", "map", "offset", "next", "Data", "history", "action", "body", "bytes", "version", "pad", "debug", "device", "d", "base", "part", "length", "raw", "mode", "f", "group", "mu", "query", "r", "sequence", "m", "chain", "dat", "buffer", "rel", "table", "ad", "error", "dr", "flags", "head", "extra", "empty", "ata", "DATA", "cache", "text", "frame", "end", "content", "block", "area", "t", "padding", "bin", "code", "name", "stream", "list", "no", "size", "done", "batch"], "data_size": [" data_Size", "data_mode", "data_length", " data_mode", " data_length", "data_Size"], "avpkt": ["averpidct", "avcwd", "avckt", "avpidacket", "avepkg", "iverpkgwd", "aveopdt", "avpadkt", "avpodkat", "avpakt", "avpkgkt", "avpcacket", "iverpkt", "iverpwd", "avpodacket", "avepdt", "averpgt", "avcet", "avcpkat", "avcpct", "avpaacket", " avpct", "avpkget", "awwpwk", "averpwt", "avPct", "avopct", "avtpct", "avpkgct", "iverpkgkt", "avpwk", "avpet", "iverpacket", "awcpacket", "aveopacket", "avpartkg", "avcpht", "avpkgacket", "awpht", "averpkg", "avopkat", "avwpwt", "aveopkt", "averpartacket", "averppt", "avpct", "avpdu", "wavopct", "averpartgt", "avpacket", "avwpwk", "avopdu", "wavpdu", "avpcet", "iverpkget", "avpaddt", "awpct", "iverpet", " avpkat", "avpkght", "awcpct", "avwpkt", "avpartkt", "avwpgt", "avcpkt", " avcpacket", "avpidpt", "averpidkt", "avwpct", "avpht", "avpartgt", "avtpacket", "avpgt", "avpagt", "avpadacket", "avpkat", "wavpct", "avepacket", "averpct", "avopacket", "wavopdu", "wavopacket", "averpidwt", "averpartkt", "avPwt", "avpawk", "averpacket", "avpwd", " avcpkt", "avPht", "avtpdu", "averpartkg", "avopkt", "avpartacket", "avcpacket", "avwpacket", "avpkg", "avpidwt", "awpwk", "awcpht", "avpwt", "awcpkt", "avpakg", " avpacket", "aveopkg", "avpadkg", "avwppt", "avpckt", "avpodct", "avcpdu", "avpcwd", "avpkgwd", "awpacket", "awwpacket", "averpidpt", "avopkg", "avpodkt", "avtpkt", "avpdt", "awwpkt", "avpidwk", " avcpkat", "avopdt", "iverpkgacket", " avcpct", "averpkt", "avpadt", "wavopkt", "awpkt", "wavpkt", "avpidct", "wavpacket", "avppt", "avPacket", "avPpt", "avwpkg", "avepkt", "avcacket", "avPkt", "avpidkt"], "s": ["sv", "v", "args", "settings", "hs", "is", "ports", "gs", "js", "ms", "ses", "changes", "obj", "bis", "S", "fs", "sam", "ns", "details", "ss", "ants", "b", "ts", "qs", "parts", "ops", "t", "cs", "less", "ats", "gets", "comments", "sb", "ims", "ins", "p", "comm", "m", "times", "aws", "sl", "ds", "g", "ls", "sw", "ares", "os", "a", "es", "tes", "rs", "ess", "events", "h", "vs", "sys", "conf", "stats", "sts", "bs", "als", "its", "i", "sports", "c", "sq", "results", "ps", "sm"], "buf": ["limit", "cv", "bed", "max", "cam", "offset", "bar", "bf", "txt", "mem", "lim", "tr", "seq", "buff", "cb", "b", "vec", "rb", "loc", "box", "cmd", "pool", "block", "bytes", "true", "len", "bl", "uf", "ref", "buffer", "queue", "window", "Buffer", "h", "img", "xy", "br", "map", "tmp", "addr", "cap", "batch", "pos", "ptr", "msg", "planes", "alloc", "xff", "length", "mb"], "buf_end": ["buff_len", "bin_last", "buf_ended", "buff_size", "bin_ended", "buf_size", "buf_start", "buff_end", "buff_start", "buf_last", "bin_end", "buf_len"], "y": ["tiny", "Y", "n", "yi", "sat", "ty", "ot", "icy", "yr", "ery", "ay", "b", "ym", "z", "ey", "ye", "gy", "hot", "uy", "oy", "t", "ip", "ady", "yy", "ya", "m", "my", "p", "e", "fy", "dy", "bot", "yl", "asy", "ny", "py", "h", "height", "l", "iy", "xy", "axy", "ys", "hey", "i", "j", "col", "cy", "vy", "sy", "yer", "ind", "ch", "sky"], "plane": ["flow", "ve", "ker", "wise", "priority", "half", "face", "pei", "profile", "ane", "pa", "slice", "loop", "way", "cone", "frame", "plan", "mode", "mask", "flat", "place", "clip", "pan", "stroke", "heading", "pipe", "gate", "lane", "board", "plot", "zone", "component", "cube", "fl", " planes", "line", "obe", "pose", "mate", "late", "depth", "animate", "flag", "panel", "pe", "axis", "bird", "straight", "plate", "pen", "layout", "planes", "normal", "cut", "dim", "que", "port"], "res": ["init", "rev", "vals", "rem", "rez", "ras", "result", "js", "ms", "fr", "red", "gr", "fs", "val", " Res", "rss", "details", "mem", "Res", "ret", "resolution", "reset", "r", "reg", "sol", "resh", "pres", "pas", "der", "req", "ref", "rek", "hash", "expr", "status", "out", "ress", "rel", "rep", "rs", "RES", "def", "dr", "des", "resp", "progress", "ber", "re", "pr", "proc", "msg", "success", "rest", "alloc", "ps", "err", "results", "raw"], "row": ["ow", "rows", "node", "val", "tr", "block", "ry", "cell", "entry", "key", "du", "sel", "roll", "line", "px", "rc", "num", "record", "field", "edge", "col", "pos", "ro", "ver", "port", "rect", "raw"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n", "idx": 24897, "substitutes": {"addr": ["Address", "nl", "sort", "nz", "dd", "arp", "ix", "tx", "loc", "elt", "cmd", "pkg", "ip", " ip", "ac", "ref", "align", "add", "hash", "expr", "news", " address", "id", "arg", "rs", "att", "np", " amp", " conn", "map", "oa", "alt", "inv", "er", "adr", "offset", " url", "host", " sa", " sr", "ar", " ptr", "var", "ha", "usr", "address", "ag", "act", "arr", "a", " wr", "adv", "ptr", " addresses", "et", "order", " dh", " ha", "data", "args", " req", "rt", "tag", "r", "attr", "art", "coord", "ash", "mt", "ad", "aff", "dr", "tmp", "ord", "pos", "msg", "url", "md", " r", " err", " kb", "sp", "rr", "mem", "ace", "ack", "at", "gt", "name", "ress", "dh", "br", " a", "oad", " add", "err"], "so": ["obj", "dll", "th", "sam", "dylib", "SO", "store", "or", "osp", "box", "sty", " So", "ico", "esh", "te", "oso", "sc", "s", "ao", " soc", "sy", "set", "sa", "isco", " sa", "ne", "iso", "se", "ssl", "oh", "sh", "sing", "osi", "sel", "stro", "rh", "os", "yes", "problem", "su", "lo", "st", " o", "po", "sie", "ow", "opt", "inho", "fo", "sf", " s", "ss", "sum", " su", "ry", "proxy", "ko", "cs", "sim", "So", "py", "syn", "must", "sync", "ho", "ski", "sn", "si", "sm", "js", "co", "sp", "pro", "go", "info", "mi", "stone", "o", "cho", "sl", "since", "sw", "ism", "bo", "no", "size", "soc", "bs", "mo", "resource", "ro", "sky"]}}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899, "substitutes": {"opaque": ["pque", " opque", "palloc", "paco", " opaques", "pacity", "paques", "operacity", "iopque", "operaque", " opaco", "operane", "iopaque", "opane", "opaques", "opacity", "operalloc", "iopane", "iopaco", "opalloc", "iopaques", "iopalloc", "opaco", "iopacity", "pane", "opque", "paque"], "addr": ["Address", "obj", "conn", "src", "any", "arp", "aux", "ix", "tx", "cb", "loc", "elt", "kt", "cmd", "pkg", "ip", "align", "ref", "add", "hash", "deg", "expr", "hw", "off", " address", "id", "att", "now", "map", "oa", "alt", "gz", "inv", "set", "adr", "iter", "offset", "db", "host", "phys", "ar", "ha", "usr", "address", "ag", "grad", "act", "arr", "pad", "handle", "ptr", "order", "data", "ser", "rt", "tag", "hl", "gate", "attr", "adj", "hop", "art", "coord", "aro", "sha", "ash", "mt", "ad", "aff", "dr", "sys", "ord", "pos", "index", "msg", "alloc", "url", "cmp", "md", "rr", "mem", "ace", "ack", "at", "t", "shift", "mac", "code", "gt", "name", "dh", "eth", "hd", "au", "amp", "oad", "alias", "err", "port"], "irqmp": ["irqumy", "ierqlmy", "ierqlmp", "ireqtmp", "irqlmy", "irqtms", "irsqms", "irdqmp", "ireqMP", "ireqqMP", "ireqqtmp", "irqqcmp", "ierqcmp", "mirqtms", "irdqtmp", "irquMP", "irqqms", "irqlcmp", "ierqmy", "mirqtmt", "ierqlmt", "irqlmt", "mirqtmp", "irqqmp", "ierqlcmp", "irsqmp", "irqtmp", "irqumt", "irqqmy", "irqucmp", "irqqtmp", "ierqmp", "irqutmp", "mirqmp", "ireqqmp", "irqmy", "ierqmt", "mirqmt", "irqMP", "irqmt", "irsqmt", "irqms", "mirqms", "irdqMP", "irqqMP", "irqtmt", "irqcmp", "irqqmt", "irqlmp", "ireqmp", "irqump"], "state": ["conn", "store", "dict", "message", "instance", "image", "al", "hash", "status", "style", "oo", "value", "map", "type", "stat", "runner", "output", "n", "next", "client", "params", "monitor", "ne", "action", "states", "manager", "State", "base", "close", "progress", "stats", "start", "handle", "order", "all", "length", "init", "data", "is", "count", "agent", "local", "print", "parent", "tag", "event", "see", "null", "spec", "new", "comment", "zone", "component", "space", "buffer", "out", "error", "memory", "unit", "l", "row", "test", "cache", "text", "oe", "post", "self", "config", "job", "mem", "item", "info", "public", "block", "area", "t", "cell", "draw", "STATE", "code", "name", "list", "trust", "no", "rule", "size", "point", "scope", "resource", "it", "port"]}}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}", "idx": 24902, "substitutes": {"qsg": ["qgs", " qgs", "qusb", "zsg", "querg", "zerg", "qusg", " qerg", "qsb", "zsb", " qg", "Qsb", "Qsg", " qsb", "qug", "qerg", "qugs", "Qgs", "Qg", "zgs", "qg"]}}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921, "substitutes": {"vdev": ["gev", "wdevice", "Vgo", " vgo", "ghost", "Vdevice", " vserv", " vdevice", "vmserv", "vmdev", "vhost", "wdev", "tdev", " vhost", " vev", "vdevice", " vserver", "tserver", "Vconn", "hdevice", "wconn", "Vdev", "hdev", "vgo", "vconn", "vserv", "hev", " vconn", "hhost", "tserv", "vserver", "vev", "vmdevice", "tdevice", "wgo", "vmserver", "gdevice", "gdev"], "s": ["sv", "sis", "obj", "gs", "ms", "ses", "changes", "services", "sam", "details", "store", "b", "pers", "p", "my", "aws", "ls", "so", "rs", "des", "as", "conf", "als", "these", "c", "y", "ps", "set", "w", "results", "n", "bis", "fs", "params", "ns", "states", "ts", "south", "less", "sb", "ins", "es", "os", "locks", "ies", "vs", "stats", "sts", "ports", "args", "settings", "hs", "is", "ss", "spec", "cs", "ats", "space", "m", "comm", "simple", "ds", "sync", "search", "j", "sq", "v", "js", "S", "source", "serv", "qs", "sol", "t", "gets", "mods", "ims", "sl", "tests", "sw", "h", "bs", "its", "self"], "i": ["qi", "gu", "n", " j", "bi", " I", "me", "in", "ind", "li", " ni", " li", "ix", "xi", "ai", "ami", "ini", "ji", "gi", "ci", " multi", "di", "hi", "ii", "mi", "ip", " bi", " m", "sim", "cli", "m", "multi", "p", "ri", "ui", "MI", "cgi", " ii", "q", "pi", " v", " mi", " di", "im", " pi", " ti", " e", "ti", "phi", "j", "zi", "x", "index", "batch", "y", "it", "si", " wi", " si", "I"], "len": ["ren", "nt", "gen", "data", "init", "il", "n", "cmp", "nl", "fin", "offset", "li", "lp", "fil", "L", " Len", "ll", "val", "kl", "end", "pl", "mem", "lim", "seq", "mn", "loc", "elt", "vec", "lc", "fn", " le", "bytes", "lf", "lan", "t", "fun", "conv", "el", "lon", " length", "coll", "LI", "compl", "all", "str", "fl", "ni", "en", "format", "Len", "ls", "min", "lt", "size", "ln", "enc", "von", "ld", "l", "nn", "addr", "gz", "pos", "err", "dl", "length"], "stat": ["init", "cache", "fin", "gc", "conn", "util", "Stat", "get", "disk", "file", "net", "config", " Stat", "fat", "r", "STAT", "info", "attr", "find", "std", "state", "fw", "ctl", "dir", "Stats", "scan", "fd", "p", "status", "name", "d", "sync", "h", "l", "sys", "num", "stats", "desc", "it", "rss"], "fse": ["fSE", "rSE", "wSE", "ffpe", "Fene", "gpe", "npse", "fpse", "nse", "ftse", "dse", "bfsche", " fbe", "rse", "bfse", " fce", "rfsche", "mpse", " fpe", "fsex", "gSE", "Fse", "ffse", "hSE", "fbe", "gse", "mpe", "bfpe", "afpe", "npe", "rfpse", "cfSE", "dpse", "rfpe", "ffsche", "dpe", "fpe", " fSE", "ffpse", "bfpse", "mse", "hte", "ftSE", "cfse", "hse", "vse", "rfse", "fcSE", "vene", "nte", "Fbe", "wse", "afse", "fcpe", "vbe", "fcse", "fene", "rsex", "fcte", "afSE", "dte", "rpse", "ftsex", " fene", "fce", "gte", "mte", "vce", "ftpse", "cfpse", "Fce", "fsche", "wpe", "cfsex", "fte", "hpe"], "path": ["dest", "next", "history", "host", "ext", "file", "config", "parent", "context", "full", "Path", "loc", "pid", "cmd", "pkg", "key", "dir", "mount", "ref", "template", "doc", "p", "m", "o", "pt", "name", "root", "from", "route", "os", "stream", "depth", "id", "prefix", "pattern", "tmp", "home", "target", "PATH", "handle", "proc", "ath", "prop", "po", "w"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_request(V9fsProxy *proxy, int type,\n\n                        void *response, const char *fmt, ...)\n\n{\n\n    dev_t rdev;\n\n    va_list ap;\n\n    int size = 0;\n\n    int retval = 0;\n\n    uint64_t offset;\n\n    ProxyHeader header = { 0, 0};\n\n    struct timespec spec[2];\n\n    int flags, mode, uid, gid;\n\n    V9fsString *name, *value;\n\n    V9fsString *path, *oldpath;\n\n    struct iovec *iovec = NULL, *reply = NULL;\n\n\n\n    qemu_mutex_lock(&proxy->mutex);\n\n\n\n    if (proxy->sockfd == -1) {\n\n        retval = -EIO;\n\n        goto err_out;\n\n    }\n\n    iovec = &proxy->out_iovec;\n\n    reply = &proxy->in_iovec;\n\n    va_start(ap, fmt);\n\n    switch (type) {\n\n    case T_OPEN:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_OPEN;\n\n        }\n\n        break;\n\n    case T_CREATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n\n                                    flags, mode, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CREATE;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        rdev = va_arg(ap, long int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n\n                                    uid, gid, path, mode, rdev);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKNOD;\n\n        }\n\n        break;\n\n    case T_MKDIR:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n\n                                    uid, gid, path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKDIR;\n\n        }\n\n        break;\n\n    case T_SYMLINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n\n                                    uid, gid, oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_SYMLINK;\n\n        }\n\n        break;\n\n    case T_LINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n\n                                    oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LINK;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSTAT;\n\n        }\n\n        break;\n\n    case T_READLINK:\n\n        path = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_READLINK;\n\n        }\n\n        break;\n\n    case T_STATFS:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_STATFS;\n\n        }\n\n        break;\n\n    case T_CHMOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHMOD;\n\n        }\n\n        break;\n\n    case T_CHOWN:\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHOWN;\n\n        }\n\n        break;\n\n    case T_TRUNCATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        offset = va_arg(ap, uint64_t);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_TRUNCATE;\n\n        }\n\n        break;\n\n    case T_UTIME:\n\n        path = va_arg(ap, V9fsString *);\n\n        spec[0].tv_sec = va_arg(ap, long);\n\n        spec[0].tv_nsec = va_arg(ap, long);\n\n        spec[1].tv_sec = va_arg(ap, long);\n\n        spec[1].tv_nsec = va_arg(ap, long);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_UTIME;\n\n        }\n\n        break;\n\n    case T_RENAME:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_RENAME;\n\n        }\n\n        break;\n\n    case T_REMOVE:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_REMOVE;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n\n                                    \"dss\", size, path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LGETXATTR;\n\n        }\n\n        break;\n\n    case T_LLISTXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LLISTXATTR;\n\n        }\n\n        break;\n\n    case T_LSETXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        value = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n\n                                    path, name, value, size, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSETXATTR;\n\n        }\n\n        break;\n\n    case T_LREMOVEXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LREMOVEXATTR;\n\n        }\n\n        break;\n\n    case T_GETVERSION:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_GETVERSION;\n\n        }\n\n        break;\n\n    default:\n\n        error_report(\"Invalid type %d\", type);\n\n        retval = -EINVAL;\n\n        break;\n\n    }\n\n    va_end(ap);\n\n\n\n    if (retval < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* marshal the header details */\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n", "idx": 24933, "substitutes": {"proxy": ["roxy", "cache", "pc", "linux", "profile", "master", "server", "native", "client", "link", "apache", "source", "node", "prime", "show", "timeout", "manager", "phy", "core", "address", "gp", "handler", "po", "mi", "ock", "version", "remote", "http", "super", "slave", "p", "ping", "device", "controller", "view", "project", "engine", "reference", "sync", "echo", "force", "pe", "reverse", "xy", "service", "shadow", "Proxy", "target", "module", "pse", "handle", "alias", "index", "ion", "x", "socket", "friend", "port"], "type": [" Type", "tp", "pre", "count", "length", "range", "ty", "Type", "typ", "family", "link", "kind", "action", "ype", "op", "event", "change", "lock", "message", "policy", "state", "class", "issue", "ity", "t", "what", "al", "relation", "time", "code", "ping", "format", "status", "function", "style", "rel", "call", "title", "id", "like", "role", "error", "size", "trace", "TYPE", "pe", "color", "types", "start", "index", "scope", " typ", "test", "set"], "response": ["data", "v", "output", "res", "result", "page", "next", "json", "answer", "action", "timeout", "message", "block", "image", "ref", "version", "o", "header", "buffer", "status", "resp", "Response", "x", "success", "ata"], "fmt": [" fms", "tfmt", " fMT", "frMT", "fms", "ifmt", "tfformat", "frmt", "ffMT", "ffformat", "ifformat", "iffm", "frfm", "ffms", "ffmt", "tfMT", "fMT", " fformat", "ifMT", "ffm", " ffm", "frformat", "fformat", "tfms"], "rdev": ["indef", "redov", "lddev", "ldef", "rdov", "redef", "rddev", "rdiv", "xdiv", "xdef", "ldep", "redev", "rwep", "rdef", "xdev", "ldev", "redep", "rwef", "rwdev", "indiv", "indev", "rediv", "reddev", "rwev", "indov", "rdep", "xdov"], "ap": ["acl", "vp", " mp", "sam", "arp", "apper", "ip", " ip", "al", " soap", "ac", "el", " heap", "p", " rep", " address", "app", "att", "as", " sap", "np", "map", "ax", "aj", "pa", "aph", "ast", " sa", "ar", "op", " ptr", " sp", "asc", "pp", "ag", "um", "html", "act", "api", "apa", "a", "ipp", "array", "ab", "cap", "ep", " cap", " cp", "ait", "pre", "bp", "wp", "apt", "apache", "gap", " map", " AP", " ac", "ic", "ash", " p", "ach", "ed", "af", "im", " api", "ape", "aps", "AP", "ma", "cache", "tap", "fa", "ext", "sp", " tap", " op", "hap", "at", "mp", "snap", "au", " app", "av", "amp"], "offset": ["data", "count", "length", "load", "op", "info", "attr", "address", "origin", "len", "shift", "rot", "ref", "seek", "off", "oot", "fee", "Offset", "base", "error", "flag", "addr", "start", "pos", "extra", "alloc", "ata", "set"], "spec": ["Spec", "f", "ification", "info", "ica", "cs", "ip", "entry", "len", "match", "space", "str", "pack", "list", "ice", "def", "spe", "row", "map", "cap", "form", "desc", "ptr", "ie", " specification", "ify"], "flags": ["acl", "tags", "vals", "args", "bits", "alf", "settings", "acts", "ports", "fields", "weight", "points", "members", "mask", "params", "faces", "ns", "details", "kind", "actions", "weights", "policy", "ants", "mates", "amps", "ts", "cmd", "ops", "FLAG", "names", "doms", "grades", "options", "comments", "times", "ims", "bugs", "fd", "friendly", "status", "lines", "features", "posts", "properties", "heads", "locks", "id", "links", "orts", "flag", "keys", "packages", "Flags", "s", "def", "ints", "types", "stats", "levels", "atts", "missions", "files", "ags"], "mode": ["owner", "command", "settings", "cmp", "md", "mid", "ms", "me", "driver", "member", "mask", "source", "room", "kind", "mem", "pro", "MODE", "lock", "mod", "mk", "ase", "cmd", "nom", "mac", "mit", "metadata", "dir", "version", "tm", "mm", "m", "time", "code", "status", "format", "dev", "device", "Mode", "id", "mt", "role", "size", "flag", "perm", "pe", "direction", "language", "module", "normal"], "uid": [" UID", "owner", "fork", "ua", "user", "mid", "util", "aid", "mask", "uv", "nu", "mu", "rid", "mn", "mk", "pid", "ud", "usr", "sid", "username", "um", "eu", "pu", "cu", "unique", "lan", "du", "uc", "oid", "mail", "fd", "upid", "u", "vid", "id", "cpu", "su", "uu", "us", "stud", "UID", "mo", "ug", "ui"], "gid": ["gids", " gip", "gend", "ggoid", "pgID", " gId", "guid", "geids", "sgip", "pgid", "groupid", "gcpid", "vgId", "gId", "ggid", "pgno", "vgip", " gz", "sgid", "gcID", "geid", "guID", "gcid", "sgId", "groupno", "ggids", "gno", "gcno", " gpid", "gID", "gez", "ggz", " gids", " gmid", " goid", "pgpid", " gno", " gID", " gend", "guend", "groupID", "vgid", "gpid", "groupend", "sgmid", "gip", "gmid", "guno", "gz", "geoid", "goid", "vgmid"], "name": ["data", "member", "val", "action", "NAME", "mod", "names", "comment", "key", "metadata", "meta", "version", "time", "format", "id", "size", "label", "ame", "field", "alias", "normal", "order", "Name"], "value": ["data", "VALUE", "v", "output", "text", "weight", "binary", "val", "content", "action", "context", "message", "description", "address", "comment", "key", "version", "status", "format", "values", "prefix", "unit", "Value", "property", "field", "attribute", "password"], "path": ["reason", "url", "method", "text", "physical", "filter", "host", "txt", "raw", "source", "file", "parent", "action", "mem", "join", "partial", "policy", "full", "Path", "pid", "cmd", "tree", "address", "pkg", "key", "dir", "filename", "pat", "ref", "template", "p", "chain", "format", "out", "near", "pt", "route", "prefix", "package", "id", "trace", "location", "point", "pointer", "pattern", "map", "target", "PATH", "form", "alias", "transform", "stat", "ath", "prop", "inner", "entry", "root", "binding"], "oldpath": ["fullpath", "fullpattern", "oldpattern", "fullvalue", "rawvalue", "newPath", "rawpattern", "oldvalue", "rawpath", "rawPath", "newpath", "oldPath", "fullPath", "newvalue", "newpattern"], "iovec": ["ilovec", "ioecr", "iovecam", "ilovecs", " ionsefc", "iorepc", "iokeec", "iovecor", "ioverecs", " iovecam", "ioveec", " iovcam", "iovecin", "iokecs", "iovecr", "istrucs", "iovecs", "ilovecor", "iuefc", " iovecon", "iorecin", "iimec", " iorec", "iuecon", " iovecs", "iodec", "liucec", "iimecam", "iorecs", " iovecp", " iorecos", " iorecs", " iovefc", "iovecon", "ioec", "iovcam", "Iovecs", "iodepc", "liucecin", " iovecan", "iuec", " ionsec", "iorect", "liovec", "liucecr", "iovect", "iodecs", "Iovec", "iancecam", "iovecan", "liovecin", "iocyc", "istrucp", "iovc", "iuecin", " iovepc", "iancecon", "istruc", " iovecin", "ionsec", "Iokec", "Ioveec", "iucecin", "liovecs", "iovefc", " iovecos", "iokec", "ioecin", " iovc", "iovepc", " iovecor", "ionsecin", "Iokeec", "iucecr", " iorecor", "iucec", "iimecon", "iovecos", "iovecp", "ioreec", "iucecs", "ioverec", "iokect", "Iovect", "liucecs", "iorec", "iovcan", " iovcon", "iovcs", "ioverecos", "liovecr", "Iokecs", "iorecp", "iocycin", "ilovecos", "iocycon", "iorecos", " iovcan", "istrupc", " ionsecin", "ionsefc", "Iokect", "ioverecor", "ionsecon", " ionsecon", "iodecp", "iancec", " iorecp", " iorepc", "iorecor", "ioecs", "iimecan", "iorecr", "iocyfc", "iovct", "iovcon", "iancecan"], "reply": ["request", "result", "frame", "repl", "answer", "rr", "ret", "ply", "message", "report", "body", "state", "pin", "info", "address", "ror", "mi", "metadata", "match", "relation", "buffer", "status", "out", "fire", "queue", "route", "rm", "sync", "error", "rob", "echo", "Reply", "force", "resp", "callback", "ptr", "ro", "err"]}}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n", "idx": 24968, "substitutes": {"r": ["er", "v", "res", "rec", "sr", "ur", "gr", "R", "repl", "rr", "rt", "ar", "or", "cr", "rb", "rd", "rg", "req", "o", "p", "e", "rx", "m", "g", "d", "rar", "mr", "q", "rw", "rh", "rs", "ra", "rc", "dr", "br", "re", "i", "x", "it", "rn", "vr", "w"], "status": ["result", "notice", "mode", "power", "source", "content", "valid", "kind", "policy", "strength", "description", "Status", "iso", "state", "diff", "info", "sol", "spec", "current", "sequence", "uses", "health", "version", "note", "compl", "atus", "code", "dev", "name", "active", "str", "check", "error", "size", "summary", "good", "search", "close", "score", "progress", "stats", "confirmed", "type", "index", "stat", "sense", "msg", "success", "si", "set", "speed"], "sense_code": ["sense__cod", "senseablecodes", "sense_Code", "Sense_Code", "Sense_code", "sense_codes", " sense_cod", "senseablecode", "senseablemessage", " sense_codes", " sense_message", "senseableCode", "Sense_codes", "sense__codes", "sense__message", "sense__code", "Sense_message", "sense_message", "sense_cod"], "s": ["sv", "v", "n", "is", "iss", "gs", "js", "fs", "S", "sam", "sp", "ns", "ss", "b", "z", "ts", "sol", "se", "t", "south", "sb", "p", "e", "str", "m", "sl", "ds", "ls", "es", "sg", "rs", "l", "sys", "sts", "c", "sq", "ps", "self", "set"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n", "idx": 25005, "substitutes": {"s": ["ches", "sv", "ex", "bits", "ears", "gs", "ries", "ms", "ses", "changes", "services", "details", "actions", "checks", "parts", "ops", "orders", "comments", "bes", "p", "aws", "ls", "ains", "rs", "as", "conf", "us", "als", "sports", "ps", "set", "w", "n", "bis", "fs", "ties", "ns", "ants", "ts", "ssl", "less", "sb", "ins", "d", "terms", "es", "os", "locks", "ies", "events", "st", "vs", "stats", "sts", "ports", "hs", "is", "f", "ss", "z", "an", "cs", "ats", "m", "comm", "ds", "ares", "sync", "sys", "sq", "js", "eps", "S", "reads", "qs", "t", "gets", "mods", "ims", "sl", "tests", "sw", "h", "acs", "bs", "its", "xs", "uns"], "value": ["data", "VALUE", "v", "request", "we", "length", "get", "json", "val", "valid", "see", "message", "example", "description", "VAL", "process", "block", "current", "python", "sequence", "image", "key", "total", "update", "version", "hash", "code", "buffer", "format", "values", "currently", "number", "option", "rule", "byte", "unit", "position", "Value", "input", "property", "now", "ue", "type", "field", "expression", "word", "document", "index", "hello", "attribute", "widget", "variable"]}}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n", "idx": 25024, "substitutes": {"opts": [" coptions", "prote", "opsTS", "OPTS", " opfs", "optTs", " opargs", " ops", " opcs", "procs", "opters", "operts", "ops", "opfs", "optrets", "oports", "opTs", "OPs", "payrets", " opTs", "opscs", "options", "optts", "payts", " copts", "opercs", "opcs", " opte", "oprets", "operorts", "optorts", "opsters", " oprets", " copte", "opte", "opargs", "optargs", "operters", "prots", "optcs", " options", "opsts", "opsargs", "optTS", "OPargs", "opss", "payfs", " copcs", "payTs", "protions", "opsorts", "optters", "opTS", "optfs", "OPts"], "backend": [" backender", "Backload", "BACKbegin", " backende", "BACKad", "booktenance", "backpad", "frontpad", "Backface", "Backended", "bookbegin", "BACKload", "retender", "Backende", "backface", "BACKrend", "bootende", "backenter", "Backender", "backender", "BACKenter", "frontin", "retended", "frontenter", "BACKface", "blackended", "frontended", "bootad", " backended", "Backend", " backface", "retend", "backrend", "backbegin", "frontrend", "backtenance", "blacktenance", "backload", "bookender", "bootend", " backpad", " backad", "blackender", " backload", "bootender", "Backbegin", "frontender", "BACKener", "backad", "BACKend", "blackend", "backended", "backin", "frontener", "bookend", " backener", "fronttenance", "frontend", "bookrend", " backbegin", "backener", "retin", "bookenter", "backende", " backenter", "BACKended", "BACKender", "Backad", "bookended", " backin", "BACKpad"], "errp": ["erp", "rrp", "rrpp", " errpp", " errr", "errr", "errpp", "erpp", "err", "rrr"], "val": ["obj", "lev", "util", "txt", "ret", "tx", "VAL", " inval", "elt", "func", "gb", "len", "al", "vt", "el", "ref", "compl", "fail", " v", "value", "vol", "def", "lex", " aval", "conf", "als", "alt", "pr", "stat", " eval", " value", "il", "grain", "repl", "var", "Val", "grad", " interval", "arr", "lib", "sel", "dev", "AL", "crit", "pret", "prop", "ver", "lit", "ctx", "vals", "pol", " valid", "mod", "vec", "cert", "let", "vet", "cal", "V", "unit", "resp", "pal", "proc", "eval", "msg", "test", "v", "gold", "li", "serv", "valid", " var", "pl", "slot", "mem", "aval", "bool", " el", "ival", "update", "req", "pt", "cho", "sl", "bo", "fol", "x", "it", "tl"]}}
{"project": "FFmpeg", "commit_id": "39e0accb7a934bfe3d42324b016dd8790790746d", "target": 1, "func": "static unsigned int find_best(struct vf_instance *vf){\n\n  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);\n\n  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))\n\n    return IMGFMT_YV12;\n\n  else\n\n    return 0;\n\n}\n", "idx": 25066, "substitutes": {"vf": [" vfc", "vfc", "evcf", "vrf", "fcf", "Vcf", " vbf", " vcf", " vrf", "avrf", "evfi", "wf", "evxf", "vF", "VF", "evf", "vxf", "Vrf", "avbf", "wbf", "wfc", "avfc", " vxf", "avcf", "vcf", "avf", " vfi", "Vf", "ffi", "vbf", "wcf", "ff", "avF", "vfi", " vF", "fxf"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075, "substitutes": {"den": ["DEN", "gen", "n", "dn", "ten", "co", "han", "range", "ind", "none", "ven", "na", "don", "nu", "zen", "dan", "ran", "ne", " Den", "norm", "mn", "nov", "z", "ki", "di", "bill", "dt", "sum", "nom", "t", "len", "der", "dem", "du", "bin", "deg", " DEN", "dat", "en", "dev", "da", "d", "number", "window", "size", "perm", "un", "con", "def", "des", "ho", "nn", "non", "mat", "vert", "mon", "ov", "ord", "pen", "fen", "pos", "normal", "dim", "nor", "Den"], "q": ["qi", "question", "v", "n", "k", "iq", "eq", "f", "aq", "qu", "query", "b", "z", "dq", "qs", "t", "req", "quit", "qual", "p", "m", "qa", "g", "u", "requ", "h", "l", "ql", "qq", "y", "ue", "Q", "i", "j", "quant", "sq", "x", "c", " Q", "qt", "ch", "w"], "r": ["er", "v", "nr", "n", "ur", "sr", "R", "rr", "rt", "f", "ar", "rl", "or", "cr", "rb", "b", "rd", "rate", "t", "rg", "rf", "rx", "e", "p", "m", "g", "d", "rar", "u", "mr", "rm", "rat", "rs", "h", "rc", "dr", "l", "re", "i", "c", "ro", "rn", "vr"], "num": [" np", "data", "nt", "rem", "n", " numer", "ta", "final", "na", "typ", "nu", "net", "valid", "tr", "mn", "uni", " nu", "block", "um", "sum", "mult", "new", "nom", "t", "coord", "total", "m", "NUM", "name", "en", "g", "out", "number", "cal", "bn", "id", "no", " msg", "con", "nm", "np", "cum", "nam", "mon", "ver", "quant", "index", "dim", "msg", " tid", "un", "Num"]}}
{"project": "FFmpeg", "commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "target": 1, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n\n{\n\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n\n    int t10, t11, t12, t13;\n\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n", "idx": 25081, "substitutes": {"blk": ["bellkid", " blork", " blkb", "bleork", "stk", "abelork", "Blck", "blekar", "bsk", " blks", "BLk", "bellkk", "lbkid", "abelsk", "bellk", " blkw", "berk", "milkt", "bldk", " blkt", "abelck", "blekt", " blsk", "lbdk", "bellkar", "blork", "blkar", "bk", "Blk", "bledk", "abelker", "stkw", "belldk", " blkan", "Blks", " blikk", " blkk", "berkb", "bellikk", "blkt", "bellck", "lbck", "lbork", " blkar", "BLck", "blker", "blkk", "lbk", "blkw", "blkid", "lbkk", "BLq", "BLks", "bellkan", "bleck", " blker", "lbker", "blq", "blks", "blsk", "bellkt", "berkw", "blkb", "blekk", "abeldk", "milork", "abelkan", "berck", "blekid", "abelk", "blek", "milk", "Blq", " bldk", "blikk", "abelikk", "stck", "blck", "stkb", "milck", "bdk", "bck", "blkan", " blq", " blck"], "quant": [" quantity", "cmp", "rec", "util", "forced", "tick", "mot", "gr", "integer", "client", "valid", "config", "stock", "Quant", "qu", "quad", "nice", "quick", " pint", " qu", "pkg", "patch", "available", " q", "mult", "serial", " quot", "private", "req", "draw", "qual", "percent", "frac", "par", "fx", "quart", "quote", "liquid", "q", "requ", "imp", "check", "complex", "atomic", "mill", "vol", " Quant", "cur", "good", "specific", "sys", "qq", "pal", "qt", "ch", "raw"], "t0": ["T3", "p1", " t00", "T0", "ot06", "ot00", "T2", "v0", "ts6", "T5", "p0", "ot0", "ts1", "let06", "T1", "let00", "ts0", "let0", "v2", "v5", " t06", "tc6", "p3", "v1", "t00", "tc1", "tc2", "tc0", "p2", "ts2", "t06"], "t1": ["at6", "ot6", "tone", "T3", "ta3", "tt1", "T6", "ot4", "tt2", " tone", "at1", "TA", "T2", "at4", "eltA", "ot2", "ta1", "elt6", "ta2", "elt1", "ot1", "ttA", "T1", "ot3", "elt2", "Tone", "at2", "taone", "tt6"], "t2": ["l0", "T3", "tt1", "T6", "v4", "p1", "e4", "tt2", "l6", "ttwo", "T2", "v0", "p0", "T02", "e6", "ts4", "tstwo", "T4", "e2", "ts3", "e0", "T1", "v2", "l4", "int4", "Ttwo", "inttwo", "int3", "v1", "p4", "l2", "tt02", "tt6", "p2", "ts2", "int2", "t02", " t02"], "t3": ["tthree", "T3", "T6", "ot8", "pt6", "tThree", "T0", "tt03", "T03", "tethree", "T2", "T8", "T5", "ot2", "tt3", "pt3", "ts1", "ts3", "t03", "ot1", "T1", "ttThree", "ts5", "ts0", "Tthree", "te3", "ot3", "te03", "pt2", "ttthree", "pt1", "ts2", "teThree", "TThree"], "t4": ["tuFour", "int428", "ot4", "intFour", "tu428", "atFour", " tFour", "at4", "ot2", " t04", "int4", "ot04", "at04", "tFour", "at2", "tu4", "otFour", "t04", " t428", "t428"], "t5": ["tree1", "at6", "tt1", "t05", "tree15", "at12", "tree4", "tt5", "at05", "tree12", "tt12", "tree5", "tt15", "te4", "tree6", "tree05", "te1", "tt4", "te5", "tt05", "te15", "t15", "at5", "tt6"], "t6": ["t60", "ot6", "T3", "p12", "ot4", "tSc", "p6", "T6", "ts8", "ot7", "ot9", "ta7", "T8", "let6", "ta9", "ts6", "ot2", "let60", "ta2", "ot12", "T7", "ts3", " tSc", "s8", "t76", "let76", "ot3", "tt60", "letSc", "p3", "tt76", "p4", " t76", "ts7", " t60", "ttSc", "ta6", "tt6"], "t7": ["tseven", "int79", "r6", "ot6", "te77", "r1", "taseven", " tseven", "unt705", "teseven", "int17", "unt79", "tt7", "t79", "ot7", "tt625", "ta7", "t625", "tt17", "int705", "unt17", "unt7", "int7", "rseven", "te7", "ta625", "r7", "ot1", "tt77", "ta77", "t705", "t17", "t77", "otseven", "ttseven", "te625", "tt79", "tt705"], "t8": ["at6", "atE", "T6", "ot8", "at8", "unt11", "ot7", "T8", "T08", "type08", "unt7", "ot11", "unt8", "type8", "t08", "ot08", "typeE", "te08", "te8", "at08", "TE", "unt08", "te11", "type6", "te7"], "t9": [" tNine", "let15", "dt8", "dtN", "TN", "T8", "ttNine", "tN", "tNine", "tt8", "dt9", "T15", "TNine", "tt15", "T9", "let9", "t15", "tt9", "let8", "dtNine", "letNine", " tN"], "tA": ["wtAn", " tG", "tempA", "temp8", "otA", "tempB", " tAn", "otC", "tG", "teA", "tempS", " tS", "teB", "wtA", "otAn", "wtG", "otG", "tAn", "wtC", "teS", "te8", "tS"], "tB": ["treeBB", " tG", "treeB", "treeBR", "otIB", "otBB", "treeG", " t42", "tBB", "ttBar", "tBar", "tG", " tIB", " tBar", "otBar", "ttB", "otBR", "t42", "tIB", "ot42", "tBR", "otG", "ttIB", "otB", " tBB", "tt42", " tBR"], "tC": ["taG", " tG", "tsD", "ot4", "otA", "TC", "cA", "tDC", "ta4", " tDC", "tG", "otC", " tR", "testDC", "testD", "trCA", " tCA", "testC", "TR", "tsC", "cC", "tr3", "trD", "tsDC", "cE", "trC", "otG", "tCA", "taC", "testR", "TD", "trA", "trE", "TCA", "trR", "taA", "tR", "c3", "tsR"], "tD": ["treeI", "wtD", "tDD", "tmD", "tDB", "treeD", "tmR", " tDD", "tt21", " tDB", " tR", "wtF", "ttDD", " tI", "wtDB", "tI", "ttI", "tmF", "ttD", "wtR", "tmDB", "t21", "tree21", "treeDD", "tR", " t21"], "tE": [" tG", "tO", "treeG", "tG", "teO", "treeE", "teA", "wtO", " tO", "wtA", "te6", "wtE", "wt8", "tree6", "teE", "teF", "treeF", "te8", "teG"], "tF": ["teF", "ptZ", "itJ", "tZ", "ptG", "tG", "teZ", "tJ", "itF", "ptJ", "teG", "ptF", "itZ", "teJ", "itG"], "t10": ["i09", "t60", "t09", "i60", "let09", "i10", "i8", "let10", "let60", " t60", "let8", " t09"], "t11": ["ts21", "ts16", "t16", "t21", "t31", "ts31", "tt31", " t31", "tt11", "tt21", " t21", " t16", "ts11", "tt16"], "t12": ["tt14", "tc11", "tc16", "t16", "tt12", "tt11", " t14", "t14", " t16", "tc14", "tc12", "tt16"], "t13": ["t17", "ot17", "tu13", "ot13", "t57", "at13", "t16", "tu16", "ot57", "tu57", "at57", "tu17", "ot16", "at17", "at16"], "s0": ["i5", "S0", "g0", "i2", "sl0", "i4", "S2", "g00", "sl3", "ts4", "S4", "ts3", "ts0", "ts5", "sl5", " s00", "sl00", "s00", "g5", "i0", "ts2", "g3", "S3"], "s1": ["v3", "sp3", "jsB", "v9", "specB", " s9", "set1", "sp9", "sp5", "sp1", "set4", "ts6", "js4", "s81", "ts1", "s9", "set6", "js81", " s81", "ts4", "ts3", "sp6", "v5", "sp4", " sB", "js1", "sB", "spec1", "v1", "set3", "spec81", "spec4"], "s2": ["us1", "h6", "h2", "v4", "S1", "h5", "b3", "us6", "set4", "us5", "set5", "v6", "b2", "S2", "S4", "h1", "v2", "S5", "v5", "set2", "S6", "v1", "set3", "b5", "b4", "us2"], "s3": ["v3", "SThree", "sv3", "js3", " sThree", " s03", "v4", "S1", "js5", "set4", "siii", "S03", "set5", "v6", "sThree", "svThree", "set6", "S4", "jsiii", "Siii", "v2", "S5", "v5", "tiii", "js1", "S6", "sv03", "v1", "set3", "S3", "sv4", "s03"], "s4": ["sv9", "space8", "space04", "is8", "v4", "is12", "space12", " s9", "S1", " sFour", "s04", "serv6", " s04", "is4", "ts6", "s9", "ts1", "v6", "S2", "ts4", "space4", "sFour", "S4", "s8", "serv8", "v2", "is6", "space6", "S6", "s12", "spaceFour", "v1", "space9", "serv4", "ts2", "serv12", "svFour", "sv4", "sv04"], "s5": ["is5", "S7", "sp3", "is8", "p6", " s9", "is9", "sp5", "S1", "sp1", "set4", "is4", "m7", "set5", "s9", "sp7", "set6", " s8", "spec6", "sp6", "s8", "S5", "sp4", "set9", "spec9", "spec5", "m4", "p5", "m6", "m5", "p4", "spec8", "p7", "S3", "spec4"], "s6": ["sE", "sv9", "S7", "solE", "p1", "p6", "g6", " s9", "S8", "s9", "set6", " s8", "sol6", "s8", "sol8", "sv7", "setE", "set9", "sv6", "set8", "sv8", "S6", "g2", "g5", "p4", "sol9", "p2", "S9", "g8"], "s7": ["sv9", "h6", "S7", "sseven", "sv13", "jsseven", " s9", "js7", "h5", " sseven", "S13", "m7", "s9", "js8", " s13", "h7", " s8", "m3", "h1", "s13", "m1", "sv7", "s8", "sv6", "sv8", "S6", "js13", "m6", "m5", "svseven", "S9"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 25091, "substitutes": {"p": ["v", "ap", "pc", "n", "tp", "pre", "bp", "pa", "post", "wp", "ctx", "jp", "sp", "f", "pro", "op", "r", "b", "z", "pp", "pkg", "t", "art", "mp", "pat", "pod", "o", "m", "par", "pt", "P", "d", "cp", "q", "rep", "a", "part", "ad", "up", "app", "fp", "att", "h", "progress", "np", "pm", "pb", "c", "j", "proc", "ps", "self", "w"]}}
{"project": "FFmpeg", "commit_id": "2c9be3882a03823413945bd9e2d9af33e6e322d5", "target": 0, "func": "static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,\n\n                              ScanTable *intra_scantable,\n\n                              uint16_t luma_intra_matrix[64],\n\n                              uint16_t chroma_intra_matrix[64],\n\n                              int hsample[3])\n\n{\n\n    int i, j, size;\n\n    uint8_t *ptr;\n\n    MpegEncContext *s = avctx->priv_data;\n\n\n\n    if (avctx->codec_id != AV_CODEC_ID_LJPEG) {\n\n        int matrix_count = 1 + !!memcmp(luma_intra_matrix,\n\n                                        chroma_intra_matrix,\n\n                                        sizeof(luma_intra_matrix[0]) * 64);\n\n    if (s->force_duplicated_matrix)\n\n        matrix_count = 2;\n\n    /* quant matrixes */\n\n    put_marker(p, DQT);\n\n    put_bits(p, 16, 2 + matrix_count * (1 + 64));\n\n    put_bits(p, 4, 0); /* 8 bit precision */\n\n    put_bits(p, 4, 0); /* table 0 */\n\n    for(i=0;i<64;i++) {\n\n        j = intra_scantable->permutated[i];\n\n        put_bits(p, 8, luma_intra_matrix[j]);\n\n    }\n\n\n\n        if (matrix_count > 1) {\n\n            put_bits(p, 4, 0); /* 8 bit precision */\n\n            put_bits(p, 4, 1); /* table 1 */\n\n            for(i=0;i<64;i++) {\n\n                j = intra_scantable->permutated[i];\n\n                put_bits(p, 8, chroma_intra_matrix[j]);\n\n            }\n\n        }\n\n    }\n\n\n\n    if(avctx->active_thread_type & FF_THREAD_SLICE){\n\n        put_marker(p, DRI);\n\n        put_bits(p, 16, 4);\n\n        put_bits(p, 16, (avctx->width-1)/(8*hsample[0]) + 1);\n\n    }\n\n\n\n    /* huffman table */\n\n    put_marker(p, DHT);\n\n    flush_put_bits(p);\n\n    ptr = put_bits_ptr(p);\n\n    put_bits(p, 16, 0); /* patched later */\n\n    size = 2;\n\n\n\n    // Only MJPEG can have a variable Huffman variable. All other\n\n    // formats use the default Huffman table.\n\n    if (s->out_format == FMT_MJPEG && s->huffman == HUFFMAN_TABLE_OPTIMAL) {\n\n        size += put_huffman_table(p, 0, 0, s->mjpeg_ctx->bits_dc_luminance,\n\n                                  s->mjpeg_ctx->val_dc_luminance);\n\n        size += put_huffman_table(p, 0, 1, s->mjpeg_ctx->bits_dc_chrominance,\n\n                                  s->mjpeg_ctx->val_dc_chrominance);\n\n\n\n        size += put_huffman_table(p, 1, 0, s->mjpeg_ctx->bits_ac_luminance,\n\n                                  s->mjpeg_ctx->val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, s->mjpeg_ctx->bits_ac_chrominance,\n\n                                  s->mjpeg_ctx->val_ac_chrominance);\n\n    } else {\n\n        size += put_huffman_table(p, 0, 0, avpriv_mjpeg_bits_dc_luminance,\n\n                                  avpriv_mjpeg_val_dc);\n\n        size += put_huffman_table(p, 0, 1, avpriv_mjpeg_bits_dc_chrominance,\n\n                                  avpriv_mjpeg_val_dc);\n\n\n\n        size += put_huffman_table(p, 1, 0, avpriv_mjpeg_bits_ac_luminance,\n\n                                  avpriv_mjpeg_val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, avpriv_mjpeg_bits_ac_chrominance,\n\n                                  avpriv_mjpeg_val_ac_chrominance);\n\n    }\n\n    AV_WB16(ptr, size);\n\n}\n", "idx": 25095, "substitutes": {"avctx": [" avconf", "AVcp", "iamcontext", "iamctx", "Avpkg", "averconst", "avercontext", "abtx", "awctl", "averctx", " avconst", "AVtx", "avcontext", " avcam", "avecam", "navcam", "iamctl", " avtx", " avconn", "AVconn", "AVctx", "AVcontext", " avpkg", "navctx", "aveconf", "abctl", "Avctx", "awctx", "avconst", "avconf", "avecontext", "avpkg", "avercp", "avconn", "averctl", "awtx", "abcontext", "avectx", "iamconst", "awcontext", " avcp", "avcp", " avcontext", "avertx", "navcontext", "Avcontext", " avctl", "navconf", "avtx", "AVpkg", "avcam", "avctl", "Avconn", "abctx"], "p": ["er", "v", "ap", "pc", "vp", "tp", "pre", "n", "cache", "dp", "bp", "pa", "wp", "post", "lp", "jp", "sp", "f", "op", "b", "r", "pid", "pp", "pkg", "pg", "patch", "at", "new", "t", "ip", "w", "o", "m", "ping", "pt", "g", "pad", "P", "per", "d", "cp", "q", "pi", "part", "up", "app", "fp", "h", "point", "np", "br", "y", "pb", "c", "php", "ps", "port", "ctx"], "intra_scantable": ["intra_Scanttable", "intra_scannator", "intra_spectantable", "intra_escantable", "intra_scentator", "intra_scentated", "intra_Scentated", "intra_scantabe", "intra_Scantated", "intra_scandable", "intra_escantabe", "intra_scancable", "intra_escenttable", "intra_scantstable", "intra_scantated", "intra_Scantator", "intra_scatchtable", "intra_scantsabe", "intra_scatchables", "intra_escentable", "intra_Scentator", "intra_spectatchable", "intra_scancated", "intra_scantant", "intra_spectatchables", "intra_scentables", "intra_scenttable", "intra_scantsable", "intra_spectantant", "intra_Scantable", "intra_scandtable", "intra_scanntable", "intra_scannant", "intra_scanttable", "intra_escantator", "intra_scancator", "intra_scandator", "intra_escentabe", "intra_Scenttable", "intra_scatchant", "intra_escentator", "intra_scanctable", "intra_scannables", "intra_scentable", "intra_scatchable", "intra_scantables", "intra_scentant", "intra_scandated", "intra_scantator", "intra_scannabe", "intra_spectatchtable", "intra_scentabe", "intra_escanttable", "intra_spectantables", "intra_spectatchant", "intra_scantsator", "intra_spectanttable", "intra_scannable", "intra_Scentable"], "luma_intra_matrix": ["luma_intra_contrie", "luma_intra_contrix", "luma_intra_matx", "luma_intra_matchric", "luma_intra_matric", "luma_intra_catrices", "luma_intra_patrix", "luma_intra_matchtx", "luma_intra_patrics", "luma_intra_patrie", "luma_intra_atrie", "luma_intra_mattx", "luma_intra_manric", "luma_intra_catx", "luma_intra_manrix", "luma_intra_contrics", "luma_intra_matchrix", "luma_intra_catrix", "luma_intra_scheric", "luma_intra_cattx", "luma_intra_atrices", "luma_intra_patric", "luma_intra_matrics", "luma_intra_atrix", "luma_intra_schex", "luma_intra_attx", "luma_intra_patrices", "luma_intra_atrics", "luma_intra_matchrices", "luma_intra_matrie", "luma_intra_manrices", "luma_intra_atric", "luma_intra_catric", "luma_intra_scherices", "luma_intra_matrices", "luma_intra_patx", "luma_intra_contrices", "luma_intra_scherix"], "chroma_intra_matrix": ["chroma_intra5matice", "chroma_intra_attice", "chroma_intra_catrices", "chroma_intra5methodice", "chroma_intra_matice", "chroma_intra_tagrie", "chroma_intra_mitrix", "chroma_intra_manvec", "chroma_intra_matvec", "chroma_intra5methodhod", "chroma_intra_tagrix", "chroma_intra5methodrix", "chroma_intra_tagrices", "chroma_intra_catrix", "chroma_intra_manrix", "chroma_intra_attrix", "chroma_intra_methodrix", "chroma_intra_manric", "chroma_intra_mitrices", "chroma_intra_atthod", "chroma_intra_tric", "chroma_intra_mitrie", "chroma_intra_catrie", "chroma_intra_methodice", "chroma_intra_catvec", "chroma_intra_methodhod", "chroma_intra_trices", "chroma_intra_manrices", "chroma_intra_matrices", "chroma_intra5mathod", "chroma_intra_mitice", "chroma_intra_catric", "chroma_intra_mithod", "chroma_intra5matrix", "chroma_intra_tvec", "chroma_intra_trix", "chroma_intra_matrie", "chroma_intra_mathod", "chroma_intra_matric"], "hsample": ["psamples", "hessamples", "psample", "hzamples", "xsample", "pspeed", "hhamples", "hesssample", "hssample", "xssample", "pssample", "xsamples", "hesspeed", "hzammy", "hhsample", "hsamples", "xspeed", "hhammy", "hessample", "hhample", "hzample", "hspeed", "hsammy", "hzsample", "xsammy"], "i": ["qi", "ex", "ix", "xi", "ami", "ii", "ip", "ei", "my", "e", "id", "io", "series", "us", "zi", "c", "y", "bi", "ind", "I", "er", "n", "ci", "di", "pi", "iu", "iy", "phi", "init", "is", "me", "ij", "print", "parent", "ini", "r", "gi", "hi", "this", "cli", "ic", "ri", "m", "multi", "remote", " ii", "\u0438", "dr", "try", "l", " index", "index", "ie", "si", "v", "in", "li", "ai", "ji", "ki", "info", "ity", "mi", "mac", "g", "uri", "point", "ti", "x", "it", "ui"], "j": ["er", "v", "aj", "obj", "k", "kid", "js", "fr", "J", "li", "json", "ij", "jp", "jl", "nu", "job", "kj", "ji", "b", "r", "z", "gi", "block", "di", "je", "ijk", "note", "str", "ni", "jj", "g", "jac", "jump", "q", "jc", "uj", "bo", "try", "l", "br", "y", "oj", "err", "pos", "dj", "index", "ia", "ja", "it", "jit", "bi", "ind"], "size": ["v", "args", "n", "max", "count", "offset", "small", "li", "notice", "sp", "scale", "shape", "ize", "ci", "set", "z", "sum", "len", "mi", "shift", "sh", "send", "m", "g", "pi", "SIZE", "height", "l", "c", "pos", "sn", "dim", "Size", "si", "length", "w"], "ptr": ["pc", "tp", "iter", "offset", "sp", "prime", "pointers", "tr", "loc", "push", "ts", "address", "ref", "pad", "pt", "rel", "rep", "pi", "eth", "fp", "dr", "ctr", "pointer", "np", "br", "row", "addr", "Ptr", "err", "pr", "pos", "index", "alloc", "ps", "ind", "ctx"], "s": ["sv", "_", "v", "n", "hs", "is", "gs", "js", "ses", "S", "fs", "sp", "ns", "ss", "ts", "spec", "t", "cs", "ssl", "ats", "sb", "ds", "sw", "os", "scl", "es", "sg", "a", "rs", "sets", "sys", "cont", "stats", "sts", "c", "sn", "ps", "set", "w"]}}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103, "substitutes": {"machine": ["magic", "dm", "linux", "virtual", "domain", "Machine", "server", "host", "mode", "power", "node", "monitor", "link", "local", "common", "vm", "managed", "achine", "instance", "manager", "smart", "mc", "program", "iso", "state", "message", "money", "process", "computer", "handler", "cell", "zone", "shell", "template", "hard", "sim", "unknown", "m", "connection", "device", "check", "engine", "series", "model", "direction", "module", "object", "alias", "normal", "hello", "sm"], "spapr": ["speaptler", "ppamprar", "snapadr", "slapr", "sparpR", "spraprer", "spapprs", "spapsrel", "spaprs", "repaptrar", "repaprb", "spipprar", "repapred", "spamprer", "slaptrer", "snaptadr", "respapr", "spmapro", "repaprt", "skaptrt", "spaspred", "skaprt", "repapprb", "spamprar", "repaprar", "spmapR", "spaphr", "spaptR", "speapler", "spaperar", "spampr", "ppampR", "speaptres", "spapadr", "speaprr", "spiprar", "spippred", "sprapred", "spraperr", "respaprar", "papsdr", "snaptr", "spappr", "spapserr", "spaspler", "snaptlr", "spaptred", "spraprt", "spasprar", "spapperrr", "spapnr", "sphapr", "spaphrr", "spapler", "snapred", "spapperred", "snapr", "sparpr", "spiprer", "slaptr", "spapsR", "spaphrar", "repapprs", "spaptrel", "spaptr", "spapperstr", "speaptstr", "spaptrer", "spaptrr", "spapsr", "spmaprb", "spapeR", "spmapr", "papsro", "skaperr", "spaprel", "spaprer", "repapr", "spaptrar", "resparpr", "spapyro", "sparprt", "spanddr", "slaptrel", "spapperlr", "spaptnr", "spaprt", "speaptro", "slapnr", "spipR", "papr", "repaperr", "ppamprer", "skapr", "spampR", "spapsrer", "spaptrt", "spcapro", "resparprar", "speaprar", "spapsnr", "spcapr", "spaphstr", "spapyler", "repapterr", "spapperrar", "papsr", "resparpR", "ppampr", "repaptred", "snaplr", "spaspro", "respapR", "spraplr", "spmaprt", "spaptlr", "snaptred", "skaptr", "spipperr", "spapsro", "spapyres", "spapperr", "resparpro", "repappr", "speapres", "papR", "slaprel", "spandR", "skapterr", "spaprb", "spaprr", "spapsrt", "spapres", "spapR", "sphapnr", "speaptr", "spasperr", "ppapr", "spapred", "spaprar", "spapperadr", "speapr", "skaptrer", "spaptstr", "spmapdr", "speapstr", "spippr", "speaptrar", "skaprer", "spapstr", "spaspr", "spapprb", "spcaprar", "repaprs", "sparprb", "slaprer", "spaspres", "repaptr", "spipr", "spaptro", "sprapadr", "spaperr", "sparprar", "sparprs", "respapro", "spaptler", "spaper", "spaplr", "sphaprer", "spapro", "spapyr", "sprapr", "spaperer", "papro", "spaptres", "spcapR", "spandr", "spmaprs", "repapprt", "spapterr", "spapprt", "speaptrr", "papsR", "speapro", "slaptnr", "sparpro", "ppaprar", "papdr", "sphaprel", "ppapR", "spapdr", "spandro", "ppaprer", "spaptadr", "spapsdr"], "smc": ["symf", "symu", "symt", " smt", "smu", " smu", "smf", "smt", "simf", "simt", "simc", "simu", " smf", "symc"], "kernel_filename": ["kernelpyexe", "kernelpywriting", "kernelphpusername", "proc_filename", "kernelphpexe", "kernel_exe", "module_writing", "kernelpyfilename", "kernel_username", "kernel_location", "kernelphpfilename", "module_filename", "proc_username", "kernelpyusername", "module_exe", "kernel_writing", "proc_directory", "module_username", "kernelphpwriting", "kernel_directory", "proc_location"], "kernel_cmdline": ["kernel_cplines", "kernel_programlines", "kernel_cmdLine", "kernel_mdLine", "kernel_extline", "kernel_extlines", "kernel_cpline", "kernel_mdlines", "kernel_commandLine", "kernel_commandline", "kernel_extLine", "kernel_cpLine", "kernel_commandlines", "kernel_mdline", "kernel_cmdlines", "kernel_programLine", "kernel_programline"], "initrd_filename": ["initrd_Filename", "initrd__file", "initrd_file", "initrs_Filename", "initrb_txt", "initrb_Filename", "initrs_filename", "initrd_txt", "initrs_file", "initrs_directory", "initrd__Filename", "initrd_directory", "initrd__filename", "initrb_file", "initrd__txt", "initrb_filename"], "cpu": ["cache", "linux", "pc", "gc", "util", "ctx", "phys", "mem", "vm", "process", "pool", "processor", "computer", "pu", "cu", "clock", "gpu", "java", "kernel", "cp", "memory", "pixel", "chip", "CPU", "proc", "socket", "network", "core"], "phb": ["phs", "Phbs", "Phs", "sha", "shs", " phbs", "Pha", " pha", "Phb", "pha", "shbs", "shb", "phbs", " phs"], "i": ["v", " j", " I", "li", "ci", "ki", "di", "ii", "t", "ip", " bi", "m", "p", " ii", "pi", " v", " l", "io", "l", "fi", "j", "ia", "x", " init", "y", "it", "si", "I"], "sysmem": [" sysmc", "ysmemory", "ysmc", "sysmemory", "ysmem", "systemmc", "systemmem", "systemmemory", "sysram", "sysmc", " sysram", " sysmemory", "ysram", "systemram"], "ram": ["ma", "rem", "gram", "res", "RAM", "cam", "range", "red", "sam", "rom", "mode", "am", "mem", "vm", "ru", "rum", "tem", "mm", "rad", "dev", "region", "memory", "ra", "row", "gra", "ro", "AM", "mb"], "rma_region": ["rna_reg", "rma2reg", "rma2range", "rma_range", "rna_region", "rma_reg", "rma2region", "rna_range"], "rma": ["rva", "msa", "rhea", "rtva", "rtota", "mna", " rsa", "Rna", "rota", "Rma", "rrva", " rva", "rrma", " rna", "rrpa", "Rhea", "Rsa", "mma", "mhea", " rhea", "rrota", "rsa", "rpa", "rtma", " rota", "rna", " rpa", "rtpa"], "rma_alloc_size": ["rma_alloc2len", "rma_all_scale", "rma_memxlen", "rma_all_size", "rma_all_SIZE", "rma_alloc_len", "rma_mem_space", "rma_all_mode", "rma_alloctsize", "rma_oc_space", "rma_alloc_loc", "rma_allocxloc", "rma_memxspace", "rma_alloc_name", "rma_alloctspace", "rma_oc_sum", "rma_alloc_mode", "rma_oc_size", "rma_alloc2Size", "rma_alloc_scale", "rma_buf_member", "rma_memxsize", "rma_allocxSIZE", "rma_mem_size", "rma_alloc2space", "rma_mem_len", "rma_all_loc", "rma_alloc2mode", "rma_mem_name", "rma_buf_size", "rma_all_Size", "rma_alloc_space", "rma_alloc2name", "rma_alloc_Size", "rma_buf_len", "rma_allocxname", "rma_alloc2sum", "rma_allocxlen", "rma_alloc_member", "rma_allocxspace", "rma_alloc2size", "rma_alloc_sum", "rma_memxname", "rma_alloctloc", "rma_all_space", "rma_alloctSIZE", "rma_allocxsize", "rma_alloc_SIZE"], "load_limit": ["loader_length", "loader_limits", "load_lim", "loader_policy", "load_policy", "load_limits", "loader_delay", "load_length", "load_delay", "loader_limit", "loader_lim"], "fw_size": ["fw_len", "hw_len", "hw_SIZE", "hw_size", "hw_name", "fw_name", "fw_SIZE"], "filename": ["Filename", "ename", "json", "fs", "params", "family", "directory", "message", "description", "fn", "writer", "username", "processor", "metadata", "seek", "buffer", "connection", "prefix", "write", "fp", "uri", "location", "module", "wire", "socket", "files", "length"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n", "idx": 25113, "substitutes": {"s": ["sv", "ports", "args", "n", "is", "hs", "gs", "js", "sa", "ses", "ms", "changes", "services", "fs", "S", "params", "ties", "ns", "details", "store", "ss", "ants", "states", "set", "ts", "qs", "parts", "se", "spec", "cs", "south", "ats", "esm", "sb", "ims", "ins", "p", "comm", "aws", "ds", "sl", "ls", "tests", "q", "os", "es", "sync", "rs", "ies", "h", "vs", "as", "l", "sql", "conf", "stats", "sts", "als", "its", "asm", "i", "sports", "c", "sq", "y", "ps", "sm", "w"], "otp_region": ["otpa__region", "ottp_storage", "otp_global", "otpacheregion", "otbp_rect", "otbp_region", "otp___union", "otp___origin", "otp_field", "otp__reg", "otp___region", "otp_union", "otbp_reg", "otpa_origin", "ottp_field", "otP_region", "otpa_union", "otpacheorigin", "otP_global", "otpachearea", "otp__union", "ottp_region", "otpacheunion", "otp_REG", "otp__region", "otpa__union", "otp__Region", "otp_area", "otpachestorage", "ottp_area", "otp__origin", "otP_reg", "otp_Region", "otp_rect", "otpa_region", "otp_storage", "otp_reg", "otbp_REG", "otpa__origin", "otpachefield", "otP_Region", "otp_origin", "otp__global"], "dinfo": [" dno", "Dinfo", "Dfo", "dsinfo", "Dube", " dInfo", "dfo", "Dno", "DInfo", " dinf", "ddInfo", "ddube", "lddetails", "dsInfo", "dno", "ddinfo", "ddfo", "dinf", "dsfo", "ldinfo", "mdno", "mdinfo", " ddetails", "Dinf", "dube", "mdinf", " dube", "mdfo", "Ddetails", "dInfo", " dfo", "ddetails", "ldinf", "dsinf"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 25119, "substitutes": {"env": ["obj", "vp", "ten", "txt", "outer", "store", "ce", "ner", "cmd", "vt", "ei", "ec", "erd", "forge", "e", "environment", "nv", "te", "window", "def", "conf", "inv", "entry", "set", "w", "er", "ped", "result", "db", "next", "manager", "rb", "pp", "eh", "shell", "doc", "eng", "dev", "ah", "project", "site", "vs", " environment", "desc", "buf", "et", "ctx", "cv", "context", "event", "hl", "erb", "cf", "worker", "cur", "rc", "extra", "msg", "ie", "enc", "v", "ve", "enter", "ter", "server", "ext", "ee", "end", "config", "gear", "den", "info", "quer", "req", "en", "org", "ew", "esc", "ef", "ev", "engine", "era", "err"], "f": ["alf", "v", "fr", "fa", "bf", "fs", "file", "fo", "sf", "tf", "full", "b", "r", "F", "fc", "fn", "xf", "func", "fw", "lf", "t", "fac", "uf", "rf", "fm", "o", "fd", "e", "p", "m", "fl", "fx", "g", "cf", "ft", "d", "out", "ef", "fb", "fg", "fp", "h", "l", "fi", "fe", "form", "ff", "c", "x", "it", "w"], "cpu_fprintf": ["cpu_cmt", "cpu_vprint", "cpu_fprint", "cpu_fflush", "cpu_frprint", "cpu_mformat", "cpu_rmt", "cpu_cformat", "cpu_pprintf", "cpu_rprintf", "cpu_pprintln", "cpu_frprintln", "cpu_dprint", "cpu_rflush", "cpu_dflush", "cpu_tprintf", "cpu_prep", "cpu_dformat", "cpu_tprint", "cpu_fsprintf", "cpu_lmt", "cpu_fwrite", "cpu_cprintln", "cpu_dmt", "cpu_frep", "cpu_vprintf", "cpu_rformat", "cpu_fmt", "cpu_tmt", "cpu_fsprintln", "cpu_lprintf", "cpu_fprintln", "cpu_rrep", "cpu_rprint", "cpu_lprintln", "cpu_mprintln", "cpu_vwrite", "cpu_vprintln", "cpu_rwrite", "cpu_pprint", "cpu_drep", "cpu_frprintf", "cpu_dwrite", "cpu_mmt", "cpu_vformat", "cpu_fsprint", "cpu_fspr", "cpu_tformat", "cpu_fpr", "cpu_fformat", "cpu_mprintf", "cpu_vmt", "cpu_rprintln", "cpu_lprint", "cpu_cprintf", "cpu_dpr", "cpu_dprintln", "cpu_cpr", "cpu_frflush", "cpu_dprintf", "cpu_cprint"], "flags": ["alf", " args", "tags", "args", "bits", "vals", "gs", "fields", "ms", "members", "fs", "faces", "weights", "pages", " fields", "ts", "cmd", "cond", "func", "pins", "options", " Flags", "comments", "fd", "fps", "ds", "cf", "features", "posts", "fee", "heads", "locks", "ents", "ensions", "ags", "rs", " options", "flag", "fp", "gnu", "Flags", "s", "atts", "ff", "ptr", " fmt", "lag", "files", "ps", " fs"], "c0_status": ["c0__flag", "c0__name", "c2_stat", "c1_sync", "c0__status", "c2__status", "c2__stat", "c1_flag", "c1_Status", "c1__status", "c0_flag", "c1_stat", "c1_status", "c0_stat", "c0_Status", "c0_sync", "c1__flag", "c0_active", "c1_active", "c1_name", "c0__sync", "c0_name", "c2__Status", "c0__active", "c1__Status", "c2_Status", "c0__stat", "c1__sync", "c0__Status", "c2_status"], "i": ["qi", "v", "ex", "n", "is", "iq", "me", "in", "abi", "li", "ij", "ix", "xi", "ri", "ai", "ami", "ini", "ji", "gi", "ci", "z", "info", "di", "ii", "oi", "t", "ip", "mi", "key", "mac", "ei", "cli", "ic", "sim", "p", "multi", "m", "by", "my", "status", "ui", "o", "chain", "pi", "id", "\u0438", "size", "im", "iu", "l", "point", "fi", "us", "ti", "phi", "j", "c", "x", "zi", "batch", "index", "y", "it", "si", "bi", "ind", "I"]}}
{"project": "FFmpeg", "commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "target": 1, "func": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n", "idx": 25130, "substitutes": {"state": ["init", "data", "cache", "output", "count", "next", "config", "mem", "store", "lock", "states", "reg", "info", "block", "sample", "State", "STATE", "hash", "code", "buffer", "out", "base", "seed", "value", "memory", "st", "conf", "input", "map", "pointer", "start", "buf", "resource", "msg", "test", "length"], "hdr_info": ["hdr__conf", "hdr_fo", "hvr_info", "hdr_inf", "hvr_Info", "her_help", "hdrletinformation", "hdr__inf", "hvr_information", "hdr_help", "hdr_INFO", "hdrlethelp", "hdr__fo", "hdr2information", "hvr_fo", "holder_info", "holder_fo", "hheader_Info", "hheader_information", "hheader_info", "hheader_inf", "hdr2fo", "holder_conf", "hdr2info", "hheader_INFO", "her_information", "holder_inf", "hdr__info", "hdr_Info", "hdr_conf", "hdr2Info", "hdr_information", "hdrletinfo", "her_info"], "need_next_header": ["need_nextalindex", "need_nextmlindex", "need_nextalheader", "need_nextfulheaders", "need_first_headers", "need_nextfuldrop", "need_nextalheaders", "need_next_layer", "need_next_index", "need_next_headers", "need_next_drop", "need_first_header", "need_nextmlvolume", "need_nextfulheader", "need_nextmlheaders", "need_nextalvolume", "need_first_drop", "need_next_volume", "need_first_layer", "need_nextmlheader", "need_nextfullayer"], "new_frame_start": ["new_window_start", "new_frames_from", "new_frames_offset", "new_frame_from", "new_window_end", "new_frame_offset", "new_window_size", "new_frame_end", "new_window_offset", "new_frame_size", "new_frames_end", "new_frames_start"], "bits": ["vals", "gs", " bases", "bis", "js", "issues", " buffers", "ms", "cats", "bf", "maps", "fs", "ns", "b", "bit", "checks", "ts", "parts", "ops", "codes", "uts", "bytes", "gb", "cs", "pins", "boot", "bps", "bugs", "nets", "bh", "outs", "tops", "locks", "base", "orts", "keys", "vs", "ints", "stats", "bs", "flags", "als", "its", "xs", "rots", "buf", "qt", "bt", "ps", "ctx"], "hdr": ["hbr", "hpr", "hild", "hiDR", "Hder", "ohdr", "ohmt", "chpr", " phdr", "chbr", "Hbr", "hivr", " phDR", "hDR", " hDR", " phder", " hpr", " phDr", "hDr", " hmt", "chdr", "histr", "herdr", "ohint", "Hint", "hls", "chder", "rhDR", " hder", " hld", " hvr", "Hld", "ohDR", "Hstr", "hils", " hls", "rhbr", " hDr", " hbr", "hder", "herbr", "Hls", "hld", " hint", "hidr", "ohld", "hmt", "herpr", "hvr", "rhdr", "himt", "HDR", "rhder", "hstr", "hint", "Hdr", "HDr", "ohvr", " hstr", "herder"], "size": ["v", "to", "n", "max", "count", "zero", "length", "offset", "final", "small", "notice", "scale", "sp", "shape", "ize", "message", "body", "z", "spec", "sum", "sent", "new", "len", "shift", "send", "space", "code", "name", "g", "fee", "ze", "from", "loss", "up", "SIZE", "s", "now", "type", "start", "c", "index", "empty", "sn", "msg", "Size", "set"], "u8": ["u32", "i16", "i32", "iu8", "ui64", "uni16", "u48", "i64", "iu15", "U32", "ui8", "uni8", "i15", "i9", "i8", "uni9", "u64", "U8", "u16", "U48", "uni15", "ui48", "iu9", "iu16", "u15", "i48", "u9", "ui32", "U64"], "tmp": ["nt", "v", "cv", "obj", "cmp", "cache", "gs", "txt", "sp", "params", "uv", "src", "aux", "mint", "tf", "appy", "buff", "cb", "mk", "pkg", "bytes", "new", "t", "vt", "mp", "uf", "zip", "m", "buffer", "out", "nb", "up", "perm", "img", "etc", "resp", "np", "xy", "buf", "pos", "proc", "empty", "msg", "temp", "bt", "test", "ctx"]}}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,\n\n                       int sign)\n\n{\n\n    uint64_t ret = 0;\n\n#if defined(DEBUG_ASI)\n\n    target_ulong last_addr = addr;\n\n#endif\n\n\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    switch (asi) {\n\n    case 0x82: /* Primary no-fault */\n\n    case 0x8a: /* Primary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 25134, "substitutes": {"env": ["init", "sv", "er", "v", "cv", "vp", "enter", "obj", "conn", "server", "sp", "end", "viron", "context", "store", "cb", "attr", "pg", "vv", "setup", "vt", "sb", "erd", "doc", "forge", "hw", "e", "buffer", "eng", "en", "environment", "dev", "sw", "org", "nv", "project", "esc", "te", "window", "ev", "ew", "gov", "sc", "cur", "h", "vs", "conf", "inv", "ptr", "entry", "err", "cfg", "set", "ctx"], "addr": ["obj", "nl", "max", "link", "src", "arp", "ix", "ret", "tx", "store", "cb", "loc", "elt", "state", "cmd", "pkg", "len", "ip", "ref", "align", "add", "hash", "p", "deg", "hw", "off", " address", "id", "rs", "np", "now", "map", "oa", "alt", "to", "adr", "iter", "offset", "oc", "iat", "ar", "wd", "var", "arm", "usr", "address", "ag", "act", "arr", "str", "pad", "site", "handle", "start", "ptr", "et", "order", "ctx", "init", "rev", "ait", "rt", "r", "gate", "attr", "art", "coord", "mt", "ad", "rc", "dr", "ord", "pos", "index", "alloc", "url", "res", "mask", "end", "mem", "ack", "ace", "reg", "at", "mac", "gt", "name", "lat", "asm", "alias", "x", "err"], "asi": ["anti", "arma", "isa", "is", "adr", "sa", "bi", "ta", "eni", "aci", "notice", "iat", "asis", "xi", "arity", "ai", "ami", "ini", "asia", "ani", "ku", "pai", "esi", "AI", "di", "obi", "ati", "ity", "mi", "oat", "aii", "osi", "agi", "afi", "aka", "ni", "pi", "ori", "au", "as", "axis", "ski", "ois", "adi", "ti", "assi", "zi", "i", "asm", "sta", "opa", "ais", "qt", "aki", "si", "ui", "asa"], "size": ["max", "weight", "state", "len", "time", "function", "style", "news", "s", "type", "sym", "set", "ose", "n", "izes", "offset", "small", "ci", "se", "address", "sh", "send", "fee", "yes", "num", "length", "count", "notice", "scale", "mode", "shape", "city", "see", "z", "spec", "sum", "zone", "space", "sha", "unit", "extra", "pos", "empty", "sn", "test", "si", "magic", "member", "sp", "ize", "shift", "code", "format", "en", "name", "g", "since", "sw", "number", "gn", "SIZE", "iz", "scope", "dim", "Size"], "sign": ["ig", "trade", "sa", "small", "get", "scale", "sp", "prime", "wrap", "shape", "lock", "ize", "mod", "reg", "round", "big", "se", "sum", "pres", "act", "sh", "align", "secure", "code", "name", "style", "pack", "trust", "value", "sc", "close", " sig", "ign", "type", "re", "rest", "Sign", "ify", "set"]}}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift, ret;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance < FF_COMPLIANCE_STRICT) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Format does not strictly comply with VC2 specs\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, decrease strictness to use it.\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    ret = av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n    if (ret)\n\n        return ret;\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 25135, "substitutes": {"avctx": ["avejac", "wavconn", "avertmp", "cvctx", "avepkg", "avedef", "wavpkg", "averdef", "averjac", "avecc", "Avctx", "avecontext", "avconf", "ajtmp", "avecu", "varconf", "Avnp", "varconn", "wavcmd", "avertx", "evcontext", "afconf", "vrcontext", "ajdef", " avtx", " avconn", "avercu", "aversys", "afcfg", "avetx", "avreq", "vrtx", "evsettings", "wavjac", "ajcontext", "avsys", "wavtmp", "varsys", "wavtx", "avtmp", "cvconn", "averconn", "avpy", " avcontext", "vrconn", "avtx", "wavreq", "varcmd", "averconfig", "wavctx", "evctx", "avconfig", "avercontext", "vrpkg", "aftx", "avcontext", "vrctx", "ajreq", "avdef", "afctx", "Avtx", "avesys", "avermk", "avcmd", "afpy", "avercmd", "avecmd", "aveconf", " avsettings", "cvtx", "ajjac", " avjac", "avpkg", "avconn", "ajsettings", "cvcontext", "varmk", "avmk", "aveconn", "afcontext", "varctx", "avernp", "afconfig", "avnp", " avnp", "averctx", " avcfg", "avereq", "afcc", "avetmp", "aveconfig", "avcfg", "ajconn", "avemk", "avercc", "avcc", "avjac", "avecfg", "wavcontext", "avsettings", "ajcu", "avepy", "afconn", "ajctx", "varpy", "vrcmd", "Avcontext", "avectx", "evconn", "avcu"], "p": ["v", "ap", "pc", "ph", "n", "pa", "sp", "jp", "pl", "pn", "pp", "t", "ip", "m", "pt", "P", "cp", "pi", "a", "l", "pe", "pr", "c"], "b": ["B", "v", "n", "bp", "f", "r", "z", "bc", "t", "sb", "m", "e", "g", "sub", "d", "a", "base", "bm", "l", "bs", "c", "y", "bi"], "i": ["qi", "init", "v", "gu", "is", "asi", "n", "me", "in", "li", "ij", "f", "ix", "xi", "ai", "go", "ini", "ji", "ami", "instance", "r", "gi", "ci", "ki", "info", "di", "hi", "ii", "t", "oi", "mi", "ip", "key", "remote", " bi", "ei", "cli", "ic", "m", "multi", "ims", "ri", "g", "ui", "cgi", " ii", "u", "pi", "a", "id", "\u0438", "im", "uri", "iu", "ish", "ti", "zi", "index", "x", "c", "batch", "y", "it", "si", "bi", "ind", "I"], "j": ["v", "aj", "k", "n", "js", "J", "ij", "jp", "kj", "ji", "z", "m", "jj", "g", "jump", "q", "uj", "jc", "bj", "l", "oj", "pos", "dj", "ja", "ind"], "level": ["limit", "pri", "priority", "half", "count", "profile", "offset", "weight", "loop", "member", "scale", "val", "mode", "family", "low", "local", "group", "tag", "community", "loc", "lc", "report", "quality", "strength", "state", "detail", "vel", "len", "key", "where", "version", "display", "time", "coll", "goal", "note", "fl", "status", "debug", "rel", "depth", "stage", "title", "high", "trace", "size", "summary", "score", "l", "pe", "color", "num", "stable", "prof", "levels", "Level", "type", "lvl", "index", "pos", "le", "dim", "scope", "ind", "length"], "o": ["n", "ta", "offset", "ot", "mode", "fo", "f", "om", "ob", "op", "ou", "go", "iso", "ok", "m", "e", "out", "off", "u", "os", "oo", "O", "bo", "lo", "l", "oa", "ao"], "shift": ["offset", "aw", "scale", "src", "ix", "shape", "shr", "push", "dq", "pkg", "sh", "conv", "align", "Shift", "seek", "sup", "depth", "seed", "share", "sc", "rc", "sch", "start", "hift", "pos", "dim", "sq", "set"], "ret": ["res", "result", "na", "val", "gl", "ll", "jp", "mem", "reset", "bit", "quality", "new", "ii", "mi", "mac", "conv", "deg", "status", "Ret", "out", "rel", "reflect", "rc", "dr", "fi", "alt", "dim", "set"], "fmt": ["fullirm", "Fmt", "pmt", "vformat", "vmm", " flux", "fingformat", "vtm", " fMT", "ftm", "afffeat", "fmm", "virm", "hmm", "ptm", "hirm", "vatt", "finglux", "Flt", "Flux", " facet", "vMT", " fmat", "forformat", " ftm", "firm", "affts", "pts", "ffeat", "vmt", "vmat", "afftm", "vtx", "floatformat", "htm", " fformat", "fMT", "flux", "fullformat", "floattm", "foratt", "floatmt", "fullmt", " fmm", "formt", "Fmm", "facet", "pfeat", "vlt", " fatt", "vacet", " ffeat", "hmt", "hMT", "fmat", "Fformat", "htx", "affmt", "fformat", "flt", "ftx", "fatt", " ftx", "fingtm", "fts", "fingmt", " flt", " firm", "Ftm", "formm", "floatacet", "fullmat", " fts"], "s": ["sv", "obj", "bits", "gs", "ms", "ses", "changes", "services", "details", "actions", "pers", "parts", "ops", "comments", "styles", "e", "status", "aws", "ls", "rs", "sets", "als", "sports", "c", "uploads", "ps", "set", "er", "n", "bis", "ers", "fs", "ns", "ants", "ts", "less", "ins", "d", "terms", "os", "a", "es", "locks", "ies", "vs", "stats", "sts", "ports", "settings", "args", "hs", "is", "ss", "r", "spec", "cs", "ats", "m", "comm", "ds", "sys", "sq", "v", "res", "js", "eps", "S", "qs", "t", "mods", "ims", "g", "tests", "bs", "its"]}}
{"project": "FFmpeg", "commit_id": "b86651a208ee67666a7305b002bc9f14b21dae7f", "target": 1, "func": "static av_cold int rv40_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n\n\n    r->rv30 = 0;\n\n    ff_rv34_decode_init(avctx);\n\n    if(!aic_top_vlc.bits)\n\n        rv40_init_tables();\n\n    r->parse_slice_header = rv40_parse_slice_header;\n\n    r->decode_intra_types = rv40_decode_intra_types;\n\n    r->decode_mb_info     = rv40_decode_mb_info;\n\n    r->loop_filter        = rv40_loop_filter;\n\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n\n    return 0;\n\n}\n", "idx": 25149, "substitutes": {"avctx": [" avconf", " avcc", "vctx", "vcmp", "vpkg", "afconf", "avcontext", "awcmp", "afcc", " avtx", " avconn", "afctx", "Avtx", "vcontext", " avpkg", "avetx", "awpkg", "aveconf", "avecc", "avcc", "Avctx", "awctx", "avecontext", "avconf", "avpkg", "avconn", "awcontext", " avcontext", "Avcontext", "avcmp", "avtx", " avcmp", "aveconn", "afcontext", "avectx", "Avconn"], "r": ["ren", "er", "v", "obj", "nr", "ir", "res", "rec", "ur", "result", "fr", "gr", "R", "rr", "rt", "it", "ar", "tr", "or", "cr", "rb", "attr", "rd", "rate", "ref", "p", "m", "d", "rel", "rar", "mr", "q", "rw", "rs", "lr", "h", "rc", "dr", "br", "rer", "re", "pr", "j", "kr", "ro", "vr", "err", "rect"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25163, "substitutes": {"opaque": ["pque", "Opaques", "appque", " opque", "appac", "appaque", "ipac", " opaques", "paques", "ipacity", "popaque", "popac", " opane", "opane", "opaques", "Opane", "opacity", "popque", "appacity", "Opque", "ipaque", "popacity", "pane", "opque", "ipque", "opac", "paque", "Opaque"], "sprn": ["SprN", "prN", "srnn", "solnn", "sprnn", "Sprnr", "sprN", "solnw", " sprnw", "srnt", "sprnr", "Sprn", "soln", "prnn", "sprnw", "Sprnn", "Sprnw", "sprnt", "solnr", "prn", " sprnn", "Sprnt", "srn", " sprnr", "prnt", "srN"], "ctx": [" cx", "ca", "cv", " temporarily", "obj", "urg", "conn", "gc", "co", "pa", "anc", "ij", "iat", "jp", "context", "tx", "cb", "alloc", "mc", "pkg", "xc", "bc", " gorilla", " context", "ac", "qa", "fx", "cc", "jac", "cf", "gas", "voc", "ct", "cp", "sc", "cur", "ctr", "tmp", "tk", "batch", "c", "proc", "ptr", "scope", "unc", "ctrl", "nc", "ind"]}}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167, "substitutes": {"format": ["limit", "command", "args", "v", "text", "filter", "Format", "file", "flat", "print", "f", "details", "it", "tag", "join", "fn", "spec", "at", "len", "ats", "cat", "template", "version", "edit", "str", "function", "style", "atter", "list", "prefix", "arg", "mt", "value", "att", "unit", "force", "color", "pattern", "mat", "type", "module", "form", "transform", " fmt", "term"]}}
{"project": "FFmpeg", "commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "target": 1, "func": "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n\n                                   uint8_t **data, int *size)\n\n{\n\n    static const int extradata_nal_types_hevc[] = {\n\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n\n    };\n\n    static const int extradata_nal_types_h264[] = {\n\n        H264_NAL_SPS, H264_NAL_PPS,\n\n    };\n\n\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n\n\n    H2645Packet h2645_pkt = { 0 };\n\n    int extradata_size = 0;\n\n    const int *extradata_nal_types;\n\n    int nb_extradata_nal_types;\n\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n        extradata_nal_types    = extradata_nal_types_hevc;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n\n    } else {\n\n        extradata_nal_types    = extradata_nal_types_h264;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n\n    }\n\n\n\n    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,\n\n                                ctx, 0, 0, ctx->par_in->codec_id, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &h2645_pkt.nals[i];\n\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n\n            extradata_size += nal->raw_size + 3;\n\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n\n            } else {\n\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (extradata_size &&\n\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n", "idx": 25179, "substitutes": {"ctx": ["obj", "conn", "anc", "txt", "jp", "that", "tx", "cb", "mc", "kt", "cmd", "pkg", "xc", "func", "ac", "p", "hw", "scl", "sc", "conf", "np", "gz", "c", "nc", " cx", "work", "k", "gc", "history", "iat", "lc", "fc", "act", "ct", "cp", "a", "addr", "handle", "buf", "cm", "kw", "cfg", "ca", "cv", "ij", "xp", "wx", "kind", "context", "null", "pool", "this", "conv", "cn", "cf", "ck", "Context", "tmp", "unc", "abc", "cmp", "co", "cas", "config", "mem", "at", "bc", "setup", "t", "req", "g", "cc", "jac", "tc", "x", "self"], "pkt": ["apct", "dkt", " pkg", "Ptx", "cpkt", "Pwk", " pwk", "det", "ppkg", "ppkt", "ptx", "Pkt", "pkg", "pct", "ppacket", "Pct", " ptx", "cptx", "cpet", "apkt", "cpacket", "pwk", "dacket", "Pet", " packet", " pet", "packet", "ppet", "apacket", " pct", "apwk", "pet", "Packet", "dkg"], "data": ["DATA", "cache", "n", "text", "next", "raw", "Data", "file", "content", "mu", "body", "read", "box", "bytes", "image", "t", "bin", "p", "dat", "buffer", "format", "out", "da", "name", "d", "a", "window", "id", "value", "def", "input", "addr", "type", "buf", "batch", "ata", "length", "w"], "size": ["magic", "n", "max", "count", "length", "offset", "scale", "sp", "end", "mode", "mem", "shape", "ize", "z", "read", "address", "sum", "sent", "bytes", "area", "len", "total", "send", "space", "time", "code", "name", "g", "fee", "id", "SIZE", "use", "num", "type", "start", "c", "pos", "empty", "sn", "Size", "set"], "extradata_nal_types_hevc": ["extradata_nal_types_hvc", "extradata_nal_types_hvin", "extradata_nal_types_hervin", "extradata_nal_types_herck", "extradata_nal_types_heVC", "extradata_nal_types_wevp", "extradata_nal_types_hdVC", "extradata_nal_types_hevin", "extradata_nal_types_hxc", "extradata_nal_types_hdvin", "extradata_nal_types_hevp", "extradata_nal_types_hdvc", "extradata_nal_types_chevc", "extradata_nal_types_hdck", "extradata_nal_types_chec", "extradata_nal_types_chevp", "extradata_nal_types_chexc", "extradata_nal_types_hexc", "extradata_nal_types_wec", "extradata_nal_types_hyux", "extradata_nal_types_hc", "extradata_nal_types_weVC", "extradata_nal_types_cheVC", "extradata_nal_types_wevc", "extradata_nal_types_hyvc", "extradata_nal_types_herVC", "extradata_nal_types_hyvp", "extradata_nal_types_heck", "extradata_nal_types_hervc", "extradata_nal_types_heux", "extradata_nal_types_hVC", "extradata_nal_types_hec", "extradata_nal_types_cheux", "extradata_nal_types_hyxc", "extradata_nal_types_hux", "extradata_nal_types_hck", "extradata_nal_types_hvp"], "extradata_nal_types_h264": ["extradata_nal_types_w323", "extradata_nal_types_phtml", "extradata_nal_types_w264", "extradata_nal_types_h265", "extradata_nal_types_w265", "extradata_nal_types_oh264", "extradata_nal_types_ehvp", "extradata_nal_types_ohtml", "extradata_nal_types_w263", "extradata_nal_types_h64", "extradata_nal_types_ph264", "extradata_nal_types_html", "extradata_nal_types_vvm", "extradata_nal_types_phvm", "extradata_nal_types_ph64", "extradata_nal_types_w64", "extradata_nal_types_H264", "extradata_nal_types_wvp", "extradata_nal_types_ohvm", "extradata_nal_types_oh64", "extradata_nal_types_h323", "extradata_nal_types_H64", "extradata_nal_types_eh264", "extradata_nal_types_h263", "extradata_nal_types_vtml", "extradata_nal_types_eh263", "extradata_nal_types_v264", "extradata_nal_types_eh323", "extradata_nal_types_H265", "extradata_nal_types_v64", "extradata_nal_types_hvm", "extradata_nal_types_H323", "extradata_nal_types_hvp"], "s": ["sv", "v", "n", "sa", "gs", "sp", "S", "ns", "ss", "z", "t", "sb", "p", "e", "g", "ds", "d", "sw", "a", "sg", "sc", "sys", "c", "x", "sn", "sq", "ps", "w"], "extradata_nal_types": ["extradata_nal_packages", "extradata_nalitypackages", "extradata_nals_keys", "extradata_nal_names", "extradata_nals_names", "extradata_nals_type", "extradata_nal_type", "extradata_nal_modules", "extradata_nalid_types", "extradata_nalitymodules", "extradata_nal_Types", "extradata_nalid_type", "extradata_nalitytypes", "extradata_nal_keys", "extradata_nalitynames", "extradata_nals_packages", "extradata_nals_types", "extradata_nals_Types", "extradata_nalid_names", "extradata_nals_modules"], "nb_extradata_nal_types": ["nb_extradata_nal_type", "nb_extradata_nal_names", "nb_extradata_nal2types", "nb_extradata_nal2type", "nb_extradata_nal_Types", "nb_extradata_nalxtype", "nb_extradata_nalximages", "nb_extradata_nals_type", "nb_extradata_nals_ypes", "nb_extradata_nal_ypes", "nb_extradata_nals_types", "nb_extradata_nal_pes", "nb_extradata_nal_images", "nb_extradata_nals_pes", "nb_extradata_nals_Types", "nb_extradata_nals_images", "nb_extradata_nals_names", "nb_extradata_nalxtypes", "nb_extradata_nal2Types", "nb_extradata_nal2pes"], "i": ["qi", "gu", " j", "asi", "me", "in", "ind", "li", " ni", "ij", "ix", "xi", "ai", "ami", "ini", "ji", "gi", "ci", "info", "di", "hi", "ii", "mi", "ip", " bi", "ei", "cli", "sim", "ic", "m", "p", "e", "multi", "ims", "g", "o", "ri", " ii", "pi", " mi", " di", "\u0438", "im", "iu", "fi", "us", " ti", " index", "ti", "zi", "j", "c", "x", "index", "batch", "y", "it", "si", "bi", "ui", "I"], "nal": ["nalog", "neal", "anals", "snalog", "snal", "nals", "anal", " nial", "snald", "annale", "annAL", " nale", "nnAL", "nnial", " hasnals", "annal", "nAL", "nnale", " neal", "nnal", "snals", "aneal", "annial", " hasnalog", "Neal", "nial", "NAL", "Nal", " hasnald", " hasnal", "Nals", " nAL", " nalog", "anAL", " nals", " nald", "nale", "nald"]}}
{"project": "FFmpeg", "commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "target": 1, "func": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,\n\n                                       int16_t *src2,\n\n                                       int height, int denom, int wx0, int wx1,\n\n                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)\n\n{\n\n    int x, y;\n\n    pixel *src = (pixel *)_src;\n\n    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);\n\n    pixel *dst          = (pixel *)_dst;\n\n    ptrdiff_t dststride = _dststride / sizeof(pixel);\n\n    const int8_t *filter = ff_hevc_epel_filters[mx - 1];\n\n    int shift = 14 + 1 - BIT_DEPTH;\n\n    int log2Wd = denom + shift - 1;\n\n\n\n    ox0     = ox0 * (1 << (BIT_DEPTH - 8));\n\n    ox1     = ox1 * (1 << (BIT_DEPTH - 8));\n\n    for (y = 0; y < height; y++) {\n\n        for (x = 0; x < width; x++)\n\n            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +\n\n                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));\n\n        src  += srcstride;\n\n        dst  += dststride;\n\n        src2 += MAX_PB_SIZE;\n\n    }\n\n}\n", "idx": 25181, "substitutes": {"_dst": ["_ststs", " _sst", "_dapt", "_ddest", "_dlrd", "_dlst", "_srd", " _dapt", "_sst", "_dsrc", " _dast", "_dsts", "_dssrc", "_ssrc", "_stdest", " _srd", "_dlsrc", "_drd", "_dsdest", "_dpt", "_sdest", " _dsts", "_dast", " _dasts", "_dadest", " _ssrc", " _drd", " _dadest", "_dldest", " _sdest", "_dsrd", "_dsst", "_stpt", "_dasts", " _dpt", " _dsrc", "_stst", " _ddest"], "_dststride": ["_dstSTRide", "_ddstrage", "_dthstrend", "_dthstringride", "_dststringider", "_dthstride", "_dthstringend", "_ddstrride", "_dststringage", "_dstrider", "_dthstringope", "_dstSTRride", "_dstside", "_dstzride", "_dstride", "_dstsider", "_ddstringride", "_dstrage", "_dststrider", "_dstSTRend", "_dststringope", "_dthstringide", "_dststrend", "_ddstride", "_dstSTRope", "_ddstringage", "_dststrage", "_ddstringide", "_dthstrope", "_dthstrride", "_dstzope", "_dstrride", "_dststrride", "_dststringride", "_dstzend", "_dstsride", "_dstzide", "_dststringend", "_ddstringider", "_dstsage", "_dststringide", "_dststrope", "_ddstrider"], "_src": [" _sn", "_inst", "tinst", "trc", "_rc", "devsn", "tsource", "devrc", "devsource", " _inst", "tsrc", "devsrc", " _source", "_source", "_sn", " _rc", "tsn"], "_srcstride": ["_statstrension", "_srcconstride", "_srcstide", "_stattrider", "_srcconstension", "_stattrension", "_srcSTRride", "_srcstrice", "_srcctrice", "_statstride", "_srcdrend", "_statstrider", "_stattrride", "_srcctrride", "_srcctride", "_statstrride", "_srctrride", "_srcstend", "_srcstrider", "_srcconstide", "_rcstide", "_srcSTRension", "_rcstrice", "_srcdrride", "_srctride", "_srcstrend", "_srctrension", "_stattride", "_srcdride", "_rcstend", "_rcstrride", "_srcconstider", "_rcstrend", "_srcSTRide", "_rcstride", "_srcstrride", "_srcctrend", "_srcSTRider", "_srcstice", "_srctrider", "_srcstrension", "_srcdrice", "_rcstice"], "src2": ["source0", "ser1", "source1", " src0", " src3", "rc0", "source3", "src1", "ser4", " src4", "sr1", "src0", "ser2", "source4", "sr2", " src1", "source2", "rc4", "sr4", "rc3", "rc1", "rc2", "src3", "src4"], "height": ["Height", "top", "ih", "hs", "max", "count", " Height", "ty", "th", "oom", "history", "ow", "scale", "rows", "power", "bottom", "volume", "resolution", "H", "hei", "html", "padding", "inches", "wh", "rank", "hang", "depth", "window", "high", "hz", "density", "size", "h", "capacity", "num", "row", "radius", "ht", "ish", "length", "w"], "denom": ["sunometry", "Denorm", "dnoms", "Denom", " denoms", " denomin", "dnomin", "sunom", "enom", "dnom", "sunorm", "denoms", "denum", "denometry", "enoms", "denomin", "denorm", "enorm", "Denum", "Denomin", "enometry", "sunoms", "Denoms", "dnum", "Denometry", " denum"], "wx0": ["wx00", "wx2", "fx1", "rx0", "rx1", "rxeros", "wy0", "wx3", "tx00", "fx00", "rx3", "tx1", "wy3", "rx2", "fxeros", "fx0", "wy1", "txeros", "wxeros", "fx2", "rx00", "fx3", "wy2", "tx0"], "wx1": ["wx2", "fx1", "rx0", "dx0", "rx1", "x7", "wx01", "dx1", "dx2", "x1", "wx7", "xp7", "exp9", "rx01", "xp0", "fx01", "x0", "exp0", "xp9", "dx01", "wx9", "rx2", "fx0", "xp1", "exp7", "x9", "fx2", "exp1"], "ox0": ["roxzero", "xon0", "ix0", "xon00", "axZero", " oxZero", "ollzero", "hopZero", "rox1", "owzero", "ow0", "ixZero", "oxzero", "ollx", "hop1", "hop0", "hop00", "ax00", "ix1", "ux00", "oxx", "oll1", "ux0", "roxx", "ow1", "owx", "ax0", "rox0", "ox00", "oll0", "ax1", "xonZero", "ix00", "oxZero", "xon1", " ox00"], "ox1": ["Ox1", "oxy1", "box01", "box3", "owOne", "box0", " oxOne", " ox01", "ax01", "OX1", "ock1", "ock4", "oxy0", "ow3", "ox2", "ox01", "ow0", "ox3", "oxyOne", "Ox0", "ow4", "ock0", "OX0", "ow1", "OX4", "oxOne", "ax0", "OxOne", " ox3", "OX2", "ow2", "ock2", "Ox3", "ax1", "boxOne", "box1", "ox4", "oxy3", "axOne"], "mx": ["ax", "ex", "xx", "tp", "wm", "nz", "ms", "xp", "wx", "tf", "xi", "ix", "vm", "tx", "mn", "ux", "ey", "xe", "xc", "dx", "ox", "mi", "ip", "yx", "tm", "mm", "rx", "zx", "m", "fx", "ml", "cp", "mr", "px", "hz", "bm", "MX", "sys", "xy", "pm", "xs", "ti", "cm"], "my": ["ma", "ms", "ty", "MY", "ery", "ym", "mk", "wy", "oy", "mi", "ky", "yy", "mm", "wi", "ny", "py", "mt", "bm", "yo", "xy", "ys", "pm", "axy", "mon", "vy", "mys", "cy", "sym", "mb"], "x": ["ax", "_", " i", "ex", "v", "ph", "n", "xx", "k", "ect", "on", "ty", "cross", "inx", "xp", "ix", "xi", "tx", "ace", "r", " w", "X", "ux", "z", "ey", "xxx", "ick", "php", "xf", "xa", "xc", "at", "ry", "path", "dx", "ox", "xt", "act", "key", "image", "el", "yx", "by", "o", "rx", "p", "m", "time", "e", "g", "fx", "ct", "q", "px", "im", "att", "h", "column", "lat", "l", "xy", "row", "i", "j", "index", "col", "ch", "w"], "y": ["v", "Y", "sky", "ty", "ot", "any", "yr", "ay", "b", "ym", "z", "ey", "wy", "ye", "gy", "ry", "at", "uy", "t", "key", "ady", "yy", "ya", "by", "o", "m", "p", "dy", "py", "ny", "yt", "ies", "h", "lat", "l", "sys", "iy", "xy", "axy", "i", "j", "c", "cy", "index", "sy", "vy", "col", "ht", "ch", "w"], "src": ["dest", "sort", "sr", "in", "ser", "obs", "txt", "source", "inst", "rl", "tr", "loc", "r", "supp", "fc", "fn", "spec", "bin", "filename", "sb", "ins", "scan", "sel", "sing", "sub", "sl", "out", "sup", "stream", "syn", "ul", "sync", "rs", "sc", "pixel", "img", "rc", "st", "s", "sys", "ctr", "input", "tmp", "screen", "usc", "desc", "proc", "resource", "sn", "sq"], "dst": [" dput", "dest", "dsbl", "dsput", "dlst", "lsp", "dlport", "dbl", "dsp", "sdsc", "lst", "dlsp", "dport", " dset", "dsst", " dsp", "Dset", "adst", " dist", " dest", "Dsp", "dsc", "lsc", "Dest", "Dbl", "adsp", "dist", "sdsp", "adest", "dlsc", "Dput", "sdst", "dput", " dbl", "lport", "Dst", "sdport", "Dist", "adset", "dsist", "dset"], "filter": ["feature", "channel", "source", "fil", "scale", "config", "Filter", "block", "image", "alpha", "bin", "conv", "match", "fl", "format", "pack", "stream", "pixel", "map", "word", "field", "form", "ff", "transform", "proc", "batch", "attribute", "term"]}}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182, "substitutes": {"dcl": ["edlc", " dpl", "dsl", "sdcl", "edcl", "cdlc", " dcr", "dscl", "sdpl", " dCl", "dspl", "dCL", "dfl", "sdcr", "sdCL", "dnpl", "dsCL", "sdsl", "dnsl", "dCl", "cdfl", "edfl", "cdcl", "dnCL", "edCl", "dcr", " dfl", "dlc", "dpl", "cdCl", "dscr", " dsl", " dCL", " dlc", "dncl"], "backing_id": ["backding_id", "backing_name", "backing_pid", "backing_Id", "backowing_Id", "backding_key", "backing___on", "backing__key", "backowing_id", "backowing_pid", "backing__name", "backingOid", "backing_on", "backing__id", "backingOpid", "backing___name", "backing___id", "backding_name", "backing__on", "backing___Id", "backing___pid", "backding_on", "backingOId", "backing___key", "backing_key"], "backing_y_0_top": ["backing_y_no_top", "backing_y_zero_bottom", "backing_y_0_part", "backing_y_zeroxorigin", "backing_y_0__top", "backing_y_0_bottom", "backing_y_0_origin", "backing_y_0__bottom", "backing_y_0xtop", "backing_y_0__part", "backing_y_0_to", "backing_y_no_bottom", "backing_y_no_part", "backing_y_zero_pos", "backing_y_0_pos", "backing_y_0__to", "backing_y_no_to", "backing_y_zeroxbottom", "backing_y_zeroxpos", "backing_y_0sbottom", "backing_y_zeroxtop", "backing_y_zero_origin", "backing_y_0xpos", "backing_y_0spos", "backing_y_0stop", "backing_y_zero_top", "backing_y_0xbottom", "backing_y_0sorigin", "backing_y_0xorigin"], "x": ["xml", "ex", "v", "n", "xx", "wx", "ix", "xi", "f", "tx", "r", "X", "z", "ux", "current", "ox", "dx", "t", "yx", "rx", "p", "m", "e", "fx", "g", "a", "px", "id", "window", " dx", "s", "l", "xy", "ross", "west", "i", "c", "index"], "y": ["top", "v", "iny", "Y", "sky", "ly", "icy", "very", "ery", "ay", "ym", "b", "z", "wy", "ey", "ye", "gy", "ry", "hot", "oy", "t", "yy", "ya", "my", "p", "hy", "dy", "ny", "py", "yt", "s", "height", "l", "iy", "xy", "axy", "isy", "vy", "i", "cy", "sy", "yer"], "w": ["v", "we", "n", "W", "wr", "wm", "weight", "wp", "wa", "wx", "f", "wl", "wd", "wind", "b", "z", "fw", "t", "what", "win", "m", "p", "wal", "wn", "wh", "g", "nw", "d", "sw", "q", "rw", "ew", "window", "ww", "wid", "l", "wt", "words", "wb", "c", "kw"], "h": ["hr", "top", "v", "ih", "ph", "k", "th", "history", "host", "hm", "f", "hl", "H", "b", "ha", "z", "he", "pp", "hi", "hh", "t", "hhh", "oh", "sh", "ac", "kh", "uh", "hash", "m", "p", "bh", "wh", "ah", "d", "u", "rh", "q", "hang", "a", "window", "hz", "hal", "hd", "s", "height", "l", "ho", "i", "uth", "ht", "c", "it", "ch"], "scon": ["lessconf", "gscon", "Sconf", "ascon", "hsconn", "excon", " sCon", "wscons", "simplecons", "oscon", "jsco", " sconv", "nsCon", "esoon", "scons", " sconn", "psconst", "Scons", "rsconv", "smon", "rsconn", "hsconv", "statsconf", "atscon", "jsconv", "nscn", "atsoon", "rscon", "jsconn", "gsconst", "Sco", "stsmon", "svCon", "stsconv", "gsCon", "sdon", "nsconv", " sconst", "stscon", "psdon", "lessconn", "svco", "tsconv", "nsconn", "atsconn", "atsconst", "psconv", "dscons", "sconf", "osconst", "nsconst", "excons", "sCon", "sconn", "lesscn", "nscons", "scn", "rscons", "rsconf", "dsdon", "dsconv", "asconn", "gscons", "statsconst", "atsconv", "svcon", "jscon", " sconf", "exconv", "hscon", "pscons", "sconv", "tsconst", "SCon", "sconst", "nsmon", "lessco", "adsco", "tscon", "lessconnect", "gsmon", "asconv", "Scon", "adscon", "tsconn", "pscon", "lessconst", "exdon", "dscon", "esconn", "statsconn", "sco", "stsCon", "tsCon", "rsconst", "sconnect", "nscon", "lesscon", "adsconf", "wsconn", "soon", " scn", "oscn", "Sconst", "simpleconst", "wsconv", "atsconnect", "jsconf", "Scn", "adsconn", "esconst", "stsconst", "escon", "dsconst", "Sconn", "jsconst", "svcons", "hscons", "gsconv", "simpleconv", "dsconn", "statscon", "wscon", "ascn", "nsdon", "asconst", " sco", "simplecon", " scons", "lessoon", "osconv", "atsco", "nsconf"]}}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185, "substitutes": {"t": ["v", "tap", "n", "tp", " T", "tt", "f", "tn", "tr", "r", "ts", "dt", "vt", "tm", "p", "m", "e", "g", "tz", "T", "a", "tty", "tmp", "tc", "tim", "c", "bt", "w"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 25189, "substitutes": {"s": ["sv", "n", "is", "hs", "gs", "js", "ms", "ses", "bis", "S", "source", "ties", "fs", "ns", "ss", "r", "b", "z", "ts", "an", "qs", "spec", "sm", "t", "cs", "this", "less", "w", "sb", "ims", "o", "p", "e", "m", "comm", "g", "ds", "out", "ls", "sw", "q", "os", "a", "es", "sg", "rs", "series", "h", "as", "sys", "us", "stats", "sts", "its", "i", "j", "c", "x", "socket", "y", "ps", "self", "set", "ctx"], "data": ["DATA", "obj", "cache", "res", "rec", "Data", "val", "src", "ns", "mem", "mu", "r", "reg", " mem", "fn", "info", "di", "address", "attr", "t", "bin", "o", "m", "p", "dat", "str", "buffer", "name", "da", "d", "rel", "id", "ad", "no", "size", "dr", "rc", "np", "map", "re", "extra", "ptr", "msg", "ata", "ctx"], "addr": ["url", "obj", "v", "adr", "nl", "offset", "link", "src", "rr", "mem", "tx", "loc", "r", "var", " mem", "cmd", "usr", "address", "ag", "attr", "pkg", "t", "ip", " ip", "coord", "ref", "add", "m", "hw", "str", "pad", "name", "a", " address", "id", "arg", "mt", "ad", "rs", "dr", "rc", "np", "map", "oa", "target", "ord", "gz", "alias", "pos", "x", "ptr", "msg", "index", "ata", "ctx"], "oi": ["iri", " ki", "obj", "asi", "eta", "bis", "bi", "ta", "igi", "offset", " tv", "eni", "link", "rio", "xi", "ami", "ini", "udi", "iso", "attr", "obi", "mx", " iso", "ilo", "ati", "ico", "mi", "ip", "ei", " bi", "oid", "osi", " vi", "o", " mic", "avi", "off", "oin", "pi", "ori", " mi", " di", "odi", "uti", "eric", "fp", "cpu", "pointer", "uci", "xy", "ois", " pi", "oa", " ti", "ti", "obo", " nic", "i", "ano", "ovi", "tmp", "si", " tid", "ui", "coe", "ctx"], "addrz": ["areaj", "addru", "adru", " addrld", "areaz", "addressz", "addrzone", "offsetu", "addrzo", "offsetj", "ptrld", "ptrZ", "ptrzone", "areald", "adrj", "offsetz", "addrZ", "adrz", " addrzone", "ptrz", "ptrzo", "addresszone", "areazo", " addrj", " addrZ", " addru", "ptrj", " addrzo", "addrld", "addressZ", "addrj"], "param": ["command", "pri", "dm", "method", "count", "offset", "weight", "meter", "member", "params", "config", "mem", "tag", "vm", "mod", "var", "imm", "info", "attr", "address", "sum", "fac", "padding", "comment", "coord", "req", "ref", "mm", "m", "p", "par", "admin", "call", "aram", "rank", "min", "cal", "prefix", "arg", "part", "mark", "error", "flag", "perm", "cpu", "value", "position", "resp", "pointer", "num", "tmp", "row", "label", "nam", "prom", "field", "col", "alias", "index", "Param", "pos", "dim", "sym", "prop", "ctx"], "func": ["args", "obj", "cast", "result", "util", "exec", "aux", "comp", "f", "amd", "cb", "var", "lambda", "lc", "fc", "cmd", "fn", "attr", "fw", "cond", "act", "fac", "fun", "conv", "ac", "doc", "expr", "function", "str", "cc", "cf", "call", "must", "con", "sys", "callback", "proc", "unc", "kw", "nc", "ctx"], "label_ptr": ["label__ptr", " label_pos", "label_ctr", "abel_addr", "label__offset", "abel_Ptr", "label_addr", "label__pointer", "label_offset", "labelmyaddr", "labelmyset", "Label_ptr", "labelmyptr", "Label_pointer", " label_addr", "labelmypos", " label_ctr", "label_Ptr", "abel_pointer", "label__addr", "label_set", "Label_addr", " label_set", "abel_ptr", "label_pointer", "label_pos", "Label_offset"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n", "idx": 25223, "substitutes": {"fd": ["df", " d", " f", "fin", "dd", "db", "ind", "bf", " fin", "fs", "cd", " fid", "f", " df", "wind", " ff", "td", "FD", "fc", "ud", "pid", " filed", "dc", "dir", "sd", "dat", "fl", " sd", "ds", "pd", "d", " td", "bd", "fee", "ed", "id", " dur", "fb", "fed", "nd", "size", "fp", "od", "hd", "ld", "fi", " ed", "ord", "handle", "dl", "ff", "buf", "ptr", " db", " fs", "ctx"], "s": ["sv", "gs", "services", "sam", "details", "b", "parts", "sd", "p", "e", "ls", "rs", "sc", "as", "als", "c", "y", "ps", "set", "w", "n", "sa", "fs", "params", "ns", "states", "ts", "se", "save", "less", "sh", "sb", "ins", "es", "a", "ies", "su", "stats", "sts", "start", "ports", "hs", "is", "sf", "f", "ss", "r", "spec", "cs", "ats", "m", "comm", "ds", "outs", "l", "sys", "sq", "sm", "v", "eds", "js", "S", "source", "qs", "sol", "t", "gets", "g", "sl", "h", "bs", "its", "self"]}}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->sei.unregistered.x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->sei.unregistered.x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 25245, "substitutes": {"h": ["v", "her", "ih", "hs", "util", "ctx", "history", "host", "zh", "hm", "context", "hl", "H", "ha", "he", "hi", "hh", "t", "oh", "sh", "kh", "hash", "p", "hw", "bh", "http", "ah", "dh", "rh", "hp", "s", "help", "l", "phi", "handle", "ht", "c", "ch", "w"], "sl": ["sv", "la", "il", "cl", "nl", "slice", "zh", "sp", "jl", "serv", "ll", "gl", "kl", "sche", "pl", "rl", "isl", "sil", "hl", "vl", "sol", "pkg", "owl", "bl", "ssl", "sh", "sb", "coll", "sel", "bh", "str", "fl", "ml", "ls", "sw", "scl", "syn", "ln", "sc", "spl", "SL", "l", "sql", "console", "service", "phi", "asm", "sn", "eval", "Sl", "tl", "dl", "sm", "lit"], "mb_type": ["mm_TYPE", "mb_name", "mb_Type", "mb7Type", "mb7ype", "MB_TYPE", "mblyTYPE", "mm_name", "mb_class", "MB_Type", "mm_class", "mb_no", "mb_number", "mb_ype", "mb7type", "mblynumber", "MB_ype", "mm_type", "mblytype", "MB_no", "mb7name", "MB_type", "MB_name", "MB_number", "mblyclass", "mblyno", "mb_TYPE", "mblyname"], "mb_type_col": ["mb_types_row", "mb_type_row", "mb_type2row", "mb_type2col", "mb_type_Col", "mb_type_column", "mb_types_col", "mb_types_Col", "mb_type2Col", "mb_types_column", "mb_type2column"], "l1mv0": ["l1imvc4", "l1mv4", "l1imvc0", "l1mvc4", "l1mav4", "l1mav0", "l1mvc8", "l1mav8", "l1mvc0", "l1mva4", "l1mv8", "l1mva0", "l1imv0", "l1mav1", "l1imv8", "l1mva8", "l1imvc8", "l1imvc1", "l1mvc1", "l1imv4", "l1imv1", "l1mva1"], "l1mv1": ["l1mV0", "l1imvc0", "l1mav0", "l1imv2", "l1mV1", "l1mvc0", "l1imv0", "l1mav1", "l1mvc2", "l1mV2", "l1mav2", "l1imvc1", "l1imvc2", "l1mv2", "l1mvc1", "l1imv1"], "l1ref0": ["l1rel2", "l1re0", "l2ref2", "l1re1", "l2rel2", "l1re2", "l2ref0", "l1ref2", "l1reference2", "l1reference0", "l1reference1", "l2rel0", "l1rel1", "l1rel0", "l2ref1", "l2rel1"], "l1ref1": ["l1rel2", "l0rely", "l0rel1", "l0ref1", "l1remy", "l1refy", "l0rel2", "l1ref2", "l0refy", "l1reference2", "l0rel0", "l1reference0", "l1reference1", "l1rel1", "l1referencey", "l1rel0", "l0ref2", "l0ref0", "l1rem1", "l1rem0", "l1rem2", "l1rely"], "i8": ["b08", "b8", "pi6", "i6", "pi4", "pi08", "i08", " i6", "b6", "b4", "pi8", " i08"], "i4": ["int24", "ip44", "int44", "ip4", " i24", "i44", " i44", "i24", "int4", "ip24"], "ref": ["ap", "obj", "result", "range", "val", "Ref", "f", "ret", "mem", "ob", "loc", "null", "REF", "req", "p", "buffer", "tab", "out", "rel", "rep", "table", "ef", "arg", "id", "reference", "def", "point", "pointer", "resp", "row", "map", "br", "conf", "type", "col", "pos", "index", "ro", "all", "mb"], "mv": [" mV", "rmv", "Mv", "rmvc", "mV", "rmV", " mav", "rmav", "mav", "MV", "Mav", "mvc", " mvc", "Mvc"], "list": ["range", "low", "net", "dict", "add", "e", "header", "status", "line", "queue", "id", "old", "List", "def", "listed", "record", "map", "type", "alt", "i", "stat", "entry", "ind", "set", "result", "ist", "L", "level", "feat", "alist", "call", "base", "ul", "array", "lists", "st", "back", "commit", "all", "reason", "count", "flat", "local", "print", "parent", "null", "spec", "comment", "chain", "out", "table", "lt", "error", "try", "l", "cont", "card", "row", "LIST", "index", "msg", "test", "page", "loop", "li", "pl", "item", "can", "detail", "info", "block", "stack", "code", "name", "number", "no", "batch", "lvl", "err", "dl"], "C": ["W", "E", "R", "S", "L", "H", "F", "CCC", "Chain", "CA", "M", "CV", "Cache", "DC", "G", "LC", "D", "CL", "P", "CG", "T", "JC", "N", "CU", "O", "V", "CC", "K", "Q", "CP", "c", "Counter", "CR", "CT", "CS", "I"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n", "idx": 25247, "substitutes": {"opaque": ["Opaques", "Oply", "oply", " opacity", "obaque", " opaques", "oplause", " oply", " opaco", " oparam", "opaques", "obaco", "opacity", "Opaco", "oplaque", "oplacity", "oparam", "opause", "obaques", " opause", "opsacity", "oplaram", "obly", "opaco", "opsaque", "opsause", "opsaram", "Opaque"], "event": ["command", "request", "text", "zero", "topic", " EVENT", "feature", "ent", "level", "change", "tag", "policy", "message", "Event", "state", "vent", "address", "image", "t", "what", "comment", "when", "release", "version", "time", "e", "code", "function", "style", "thing", " Event", "ENT", "option", "error", "size", "events", "age", "task", "future", "type", "entity", "ion", "operation", "attribute", "date", "commit"], "s": ["sv", "sis", "hs", "is", "gs", "S", "fs", "source", "serv", "sp", "ns", "sac", "ss", "store", "r", "states", "ts", "qs", "se", "ssl", "ats", "sb", "p", "ds", "sl", "ls", "sw", "q", "es", "so", "rs", "ess", "st", "sys", "als", "sts", "bs", "y", "stats", "service", "j", "sports", "c", "sq", "ps", "sm"]}}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252, "substitutes": {"ci": ["qi", "co", "li", "ai", "ini", "ce", "ani", "gi", "ki", "di", "ati", "ii", "cu", "ico", "mi", "oci", "dc", "ei", "cci", "cli", "ic", "CI", "ni", "cc", "cgi", "cit", "pi", "fi", "uci", "ti", "i", "c", "cm", "sci", "si", "bi", "ice"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq(OpenPICState *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25260, "substitutes": {"opp": ["prep", "sie", "isu", "obj", "vp", "cmp", "ripp", "tip", "dep", "ipl", "oop", "emp", "oc", "ow", "ij", "jp", "typ", "comp", "it", "omp", "pro", "pl", "op", "ack", "supp", "upp", "buff", "pp", "ik", "attr", "pkg", "iv", "setup", "oit", "ip", "ko", "cod", "ok", "obb", "req", "och", "odd", "sim", "pps", "Opp", "off", "kick", "jump", "sup", "impl", "oper", "ipp", "imp", "front", "app", "up", "perm", "along", "hack", "img", "piece", "ost", "eff", "ff", "onet", "udi", "ppo", "prop", "jit"], "n_IRQ": ["n__IRU", "n_IRMQ", "n_IORQ", "n_IrQ", "n_IMQUEST", "n_WRIQ", "n_INTERQueue", "n_MRQue", "n__VRU", "n_RCW", "n_IORJ", "n_IRCJ", "n__IRQueue", "n_EARQueue", "n_INTERQ", "n_HRQB", "n_IVQ", "n_IRQB", "n_IORHT", "n_MIQuery", "n_ERW", "n_IMIQ", "n_RCq", "n_VRHT", "n_AIRQ", "n_VRQUEST", "n_IRQL", "n_IRQu", "n_IRW", "n__IRMQ", "n_ARIQ", "n_IRq", "n_VRJ", "n_IRIQ", "n_RELJ", "n_EARZ", "n_irQL", "n_MIQ", "n_IRQue", "n_IRJ", "n__ARQue", "n_ARQUIRE", "n_IVJ", "n_VRQ", "n_IrQuery", "n_IREQ", "n__ARQueue", "n_VRG", "n_MRQU", "nAMIREQ", "n_VRQu", "n_AIRQU", "n_IRQUEST", "n_IRG", "n_IRCQ", "n_MRq", "n_IRHT", "n_IMQueue", "nAMIREQUEST", "n_WRHT", "nAMIRG", "n_HRQ", "n_ARZ", "nAMIRQL", "n_ARQUEST", "n__IRJ", "n_RCQ", "n_irQ", "n_IMQ", "n_IRQUIRE", "n_VRU", "n_IRCZ", "n_ERq", "n_IRQueue", "n_ARQ", "n_RELQ", "n_IREJ", "n_INTERQUEST", "n_ERC", "n_IRQU", "n_ARQue", "n_EARQue", "n__IRQue", "n_MIQB", "n__VRMQ", "n_irQUEST", "n_IREQUEST", "n_IREQue", "n_HRW", "n_IREq", "n_IRCQue", "n_RELQu", "n_MRQUIRE", "n_EARQ", "n_VRIQ", "n_IRZ", "n_HRQuery", "n_VRMQ", "n_MIW", "n_ERQ", "n_IRQuery", "n_IrW", "n_IREQL", "n_IVQu", "n_IRU", "n_IREU", "n_IRCMQ", "nAMIRQ", "n__IRQ", "n__VRJ", "n_VRQL", "n_RCC", "n_IVHT", "n_IRC", "nAMIRQUEST", "n_IrC", "n_WRJ", "n_RELHT", "nAMIREQL", "n_AIRQUIRE", "n_ARQU", "n_MRQ", "n_Irq", "n__ARQ", "n_IRCU", "n_IREMQ", "n_IRCQueue", "n_INTERIQ", "n_IREG", "n_irG", "nAMIREG", "n_ARQueue", "n__VRQ", "n__ARZ", "n_DIRQue", "n_IrQB", "n_DIRQ", "n_DIRq", "n_IORIQ", "n_WRQ", "n__IRZ"], "src": ["uint", "obj", "txt", "typ", "comp", "store", "supp", "loc", "instance", "cmd", "pkg", "iv", "https", "unknown", "scan", "sup", "sur", "rs", "sc", "nil", "input", "np", "stud", "ost", "usc", "rol", "stat", "ind", "dest", "btn", "iov", "inst", "warn", "rb", "usr", "std", "ssl", "sh", "lib", "send", "sb", "sing", "ins", "sel", "str", "scenes", "sub", "bb", "ipp", "bj", "st", "nn", "stats", "addr", "desc", "buf", "vr", "ctx", "pri", "tp", "sr", "ser", "rt", "stock", "tn", "hl", "attr", "spec", "this", "conv", "http", "syn", "sync", "rob", "cur", "rc", "sys", "ctr", "tmp", "sit", "proc", "sn", "sq", "via", "ripp", "stick", "source", "serv", "config", "rl", "ack", "setup", "sec", "boot", "req", "bh", "sl", "dist", "sw", "stream", "snap", "soc", "bs"], "i": ["qi", " I", " iter", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "status", " v", "id", "zi", "php", "y", "bi", "ind", "I", "n", "iter", "ci", "di", " x", "u", "pi", " k", "iu", "fi", "docker", " ti", " e", "phi", "limit", "init", " j", "is", "me", "ij", "print", "f", "mu", "ini", "gi", "hi", " bi", "cli", "ic", "ri", "m", "multi", "wi", " ii", " n", "\u0438", " si", "im", "l", "ski", " pi", " index", "j", "index", "si", "iri", "gu", "in", "li", " ni", "go", "ai", "ki", "mi", "key", "shift", " m", "ims", "q", "list", "uri", "h", "span", "ti", "batch", "x", "it", "ui"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n", "idx": 25263, "substitutes": {"s": ["sv", "v", "n", "is", "usb", "gs", "js", "ses", "S", "fs", "ns", "ss", "b", "r", "ts", "qs", "t", "cs", "ssl", "less", "ats", "sb", "p", "e", "comm", "aws", "ds", "sl", "ls", "os", "es", "sync", "rs", "h", "st", "vs", "sys", "conf", "as", "stats", "bs", "sts", "i", "c", "ps"], "fifo": [" fifaco", "lifodo", " fifO", "lifo", "fifpo", "fati", "liginator", " fifota", "histano", " fifi", "Fifpo", "fatolo", "lifpo", "fifan", "helio", "fetinator", " fifinator", "lipi", "fifado", " fifodo", "fourado", "flexodo", "fetpo", "helpo", "Fifan", "Fifoo", "fifi", "fourota", "wifeO", "ligo", "feto", " femo", " fifano", "rito", "pedpo", "fetator", "fifoice", "pedoc", "Fifoe", "fifoe", "fifodo", " femolo", "fifolo", "Fifado", "fouro", "helo", "fenoker", "fifO", "fifator", "fifoker", "fifio", "ligi", "Fifaco", "fetodo", " fifoo", "fifano", "fetoe", "ritoice", "fatpo", "histo", "histO", "flexpo", "fedO", "fetio", "rumpo", "FifO", "fato", "wifeaco", "lifoe", "Fifator", "fouroc", "fenoo", "fetaco", "lifinator", "fifoc", "fifinator", " fifoker", " fifoice", "fetoo", "pedota", "fedaco", "ruman", "Fifolo", "fedo", " fifpo", "ritO", "rumado", "lippo", "fouran", "tippo", "fedpo", "fetoker", "fifaco", "fetO", "Fifio", "flexinator", "lipolo", "pedo", " femO", " femano", "histolo", "tipo", "Fifi", "flexo", "tipaco", " fifolo", "wifeo", "feno", "wifeoice", "fifoo", "lipo", "fenO", "Fifo", "lifi", "heloo", "fifota", "lifoo", "fourpo", "rumo", "ritaco", "ligodo", "tipator", " fifoc"], "send": ["init", "command", "parse", "respond", "create", "sort", "fin", "exec", "ceive", "post", "sp", "link", "end", "show", "pend", "connect", "message", "reset", "set", "push", "info", "se", "find", "sent", "ense", "save", "shift", "sh", "update", "component", "add", "remote", "bind", "status", "Send", "fire", "kick", "call", "pack", "write", "nd", "size", "spread", "use", "kill", "transfer", " transmit", "start", "stat", "handle", "msg", "ind", "self", "execute", "export"], "complete": ["parse", "COMPLE", "create", "tif", "pletion", "plete", "result", "final", "only", "required", "scale", "correct", "load", "tle", "closure", "see", "ce", "execute", "process", "Complete", "replace", "when", "component", "match", "update", "total", "secure", "status", "buffer", "com", "fail", "repeat", "te", "check", " completing", "error", "completely", "close", "progress", "confirmed", "done", "require", "transfer", "le", "success", "empty", "test", "commit", "length", "partial"], "data": ["max", "val", "file", "ret", "tx", "message", "read", "image", "ip", "al", "p", "id", "window", "value", "def", "map", "results", "n", "result", "next", "Data", "load", "full", "body", "bytes", "str", "d", "cap", "buf", "inner", "all", "length", "raw", "reason", "mid", "none", "ll", "mu", "r", "attr", "new", "dat", "buffer", "out", "rel", "error", "dr", "ord", "empty", "msg", "ata", "DATA", "cache", "url", "res", "text", "only", "content", "valid", "mem", "block", "area", "key", "bin", "format", "name", "list", "no", "snap", "size", "done", "batch"], "len": ["tail", "gen", "nl", "fin", "lp", "fil", "val", "low", "ret", "loc", "elt", "lf", "lan", "el", "coll", "compl", "line", "ls", "Len", "depth", "ln", "vol", "alt", "gz", "le", "ind", "nt", "n", "iter", "offset", "ly", "L", "gl", "level", "lis", "full", "lang", "bytes", "lib", "lon", "str", "lu", "wid", "num", "cap", "buf", "all", "length", "limit", "lit", "rev", "on", "del", "ll", "lim", "hl", "z", "fac", " l", "lt", "ld", "l", "pos", "empty", "msg", "la", "cmp", "li", "sp", "kl", "valid", "pl", "mem", "seq", "den", "ity", "t", " length", "fl", "en", "name", "list", "size", "label", "lvl", "tl", "err"]}}
{"project": "FFmpeg", "commit_id": "c2c1726847fe3a043762062db40774bf0cc434c3", "target": 0, "func": "static void compute_status(HTTPContext *c)\n\n{\n\n    HTTPContext *c1;\n\n    FFStream *stream;\n\n    char *p;\n\n    time_t ti;\n\n    int i, len;\n\n    AVIOContext *pb;\n\n\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n\n        /* XXX: return an error ? */\n\n        c->buffer_ptr = c->buffer;\n\n        c->buffer_end = c->buffer;\n\n        return;\n\n    }\n\n\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n\n    avio_printf(pb, \"Content-type: %s\\r\\n\", \"text/html\");\n\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n\n    avio_printf(pb, \"\\r\\n\");\n\n\n\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n\n    if (c->stream->feed_filename[0])\n\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feed_filename);\n\n    avio_printf(pb, \"</head>\\n<body>\");\n\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n\n    /* format status */\n\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n\n    avio_printf(pb, \"<table cellspacing=0 cellpadding=4>\\n\");\n\n    avio_printf(pb, \"<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\\n\");\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        char sfilename[1024];\n\n        char *eosf;\n\n\n\n        if (stream->feed != stream) {\n\n            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n\n            eosf = sfilename + strlen(sfilename);\n\n            if (eosf - sfilename >= 4) {\n\n                if (strcmp(eosf - 4, \".asf\") == 0)\n\n                    strcpy(eosf - 4, \".asx\");\n\n                else if (strcmp(eosf - 3, \".rm\") == 0)\n\n                    strcpy(eosf - 3, \".ram\");\n\n                else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n\n                    /* generate a sample RTSP director if\n\n                       unicast. Generate an SDP redirector if\n\n                       multicast */\n\n                    eosf = strrchr(sfilename, '.');\n\n                    if (!eosf)\n\n                        eosf = sfilename + strlen(sfilename);\n\n                    if (stream->is_multicast)\n\n                        strcpy(eosf, \".sdp\");\n\n                    else\n\n                        strcpy(eosf, \".rtsp\");\n\n                }\n\n            }\n\n\n\n            avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n\n                         sfilename, stream->filename);\n\n            avio_printf(pb, \"<td align=right> %d <td align=right> \",\n\n                        stream->conns_served);\n\n            fmt_bytecount(pb, stream->bytes_served);\n\n            switch(stream->stream_type) {\n\n            case STREAM_TYPE_LIVE: {\n\n                    int audio_bit_rate = 0;\n\n                    int video_bit_rate = 0;\n\n                    const char *audio_codec_name = \"\";\n\n                    const char *video_codec_name = \"\";\n\n                    const char *audio_codec_name_extra = \"\";\n\n                    const char *video_codec_name_extra = \"\";\n\n\n\n                    for(i=0;i<stream->nb_streams;i++) {\n\n                        AVStream *st = stream->streams[i];\n\n                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                        switch(st->codec->codec_type) {\n\n                        case AVMEDIA_TYPE_AUDIO:\n\n                            audio_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*audio_codec_name)\n\n                                    audio_codec_name_extra = \"...\";\n\n                                audio_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_VIDEO:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*video_codec_name)\n\n                                    video_codec_name_extra = \"...\";\n\n                                video_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_DATA:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                    }\n\n                    avio_printf(pb, \"<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s\",\n\n                                 stream->fmt->name,\n\n                                 stream->bandwidth,\n\n                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,\n\n                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);\n\n                    if (stream->feed)\n\n                        avio_printf(pb, \"<td>%s\", stream->feed->filename);\n\n                    else\n\n                        avio_printf(pb, \"<td>%s\", stream->feed_filename);\n\n                    avio_printf(pb, \"\\n\");\n\n                }\n\n                break;\n\n            default:\n\n                avio_printf(pb, \"<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\\n\");\n\n                break;\n\n            }\n\n        }\n\n        stream = stream->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        if (stream->feed == stream) {\n\n            avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n\n            if (stream->pid) {\n\n                avio_printf(pb, \"Running as pid %d.\\n\", stream->pid);\n\n\n\n#if defined(linux) && !defined(CONFIG_NOCUTILS)\n\n                {\n\n                    FILE *pid_stat;\n\n                    char ps_cmd[64];\n\n\n\n                    /* This is somewhat linux specific I guess */\n\n                    snprintf(ps_cmd, sizeof(ps_cmd),\n\n                             \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\",\n\n                             stream->pid);\n\n\n\n                    pid_stat = popen(ps_cmd, \"r\");\n\n                    if (pid_stat) {\n\n                        char cpuperc[10];\n\n                        char cpuused[64];\n\n\n\n                        if (fscanf(pid_stat, \"%9s %63s\", cpuperc,\n\n                                   cpuused) == 2) {\n\n                            avio_printf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\",\n\n                                         cpuperc, cpuused);\n\n                        }\n\n                        fclose(pid_stat);\n\n                    }\n\n                }\n\n#endif\n\n\n\n                avio_printf(pb, \"<p>\");\n\n            }\n\n            avio_printf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\");\n\n\n\n            for (i = 0; i < stream->nb_streams; i++) {\n\n                AVStream *st = stream->streams[i];\n\n                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                const char *type = \"unknown\";\n\n                char parameters[64];\n\n\n\n                parameters[0] = 0;\n\n\n\n                switch(st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_AUDIO:\n\n                    type = \"audio\";\n\n                    snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->sample_rate);\n\n                    break;\n\n                case AVMEDIA_TYPE_VIDEO:\n\n                    type = \"video\";\n\n                    snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height,\n\n                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                avio_printf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\",\n\n                        i, type, st->codec->bit_rate/1000, codec ? codec->name : \"\", parameters);\n\n            }\n\n            avio_printf(pb, \"</table>\\n\");\n\n\n\n        }\n\n        stream = stream->next;\n\n    }\n\n\n\n    /* connection status */\n\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n\n                 nb_connections, nb_max_connections);\n\n\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n\n                 current_bandwidth, max_bandwidth);\n\n\n\n    avio_printf(pb, \"<table>\\n\");\n\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\");\n\n    c1 = first_http_ctx;\n\n    i = 0;\n\n    while (c1 != NULL) {\n\n        int bitrate;\n\n        int j;\n\n\n\n        bitrate = 0;\n\n        if (c1->stream) {\n\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n\n                if (!c1->stream->feed)\n\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n\n                else if (c1->feed_streams[j] >= 0)\n\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n\n            }\n\n        }\n\n\n\n        i++;\n\n        p = inet_ntoa(c1->from_addr.sin_addr);\n\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\",\n\n                    i,\n\n                    c1->stream ? c1->stream->filename : \"\",\n\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n\n                    p,\n\n                    c1->protocol,\n\n                    http_state[c1->state]);\n\n        fmt_bytecount(pb, bitrate);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, c1->data_count);\n\n        avio_printf(pb, \"\\n\");\n\n        c1 = c1->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    /* date */\n\n    ti = time(NULL);\n\n    p = ctime(&ti);\n\n    avio_printf(pb, \"<hr size=1 noshade>Generated at %s\", p);\n\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n\n    c->buffer_ptr = c->pb_buffer;\n\n    c->buffer_end = c->pb_buffer + len;\n\n}\n", "idx": 25265, "substitutes": {"c": ["v", "cache", "pc", "n", "cv", "ca", "cl", "gc", "co", "cam", "oc", "anc", "f", "cb", "ce", "b", "lc", "ci", "mc", "fc", "can", "xc", "bc", "dc", "t", "cs", "this", "ac", "conv", "abc", "coll", "ec", "m", "e", "chain", "g", "cc", "com", "cf", "ct", "cp", "call", "C", "con", "cur", "rc", "cont", "conf", "tc", "cm", "etc", "nc", "enc", "ctx"], "c1": ["c2", " c0", "cc1", "c0", "ctx", "C0", " c2", "cc0", "C1", "Ctx", "cctx", "cc2", " ctx", "C2"], "stream": ["ready", "driver", "store", "or", "message", "read", "hold", "flash", "time", "status", "feed", "HEAD", "iterator", "clean", "window", "io", "sc", "s", "console", "session", "runtime", "form", "speed", "STDOUT", "filter", "host", "history", "client", "peer", "oooo", "wrapper", "handler", "ssl", "REAM", "version", "check", "close", "progress", "ream", "transform", "length", "accept", "data", "standard", "ST", "channel", "local", "f", "parent", "context", "tr", "event", "upload", "pool", "new", "sample", "follow", "zip", "http", "chain", "remote", "buffer", "cf", " upstream", "table", "stage", "tty", "sync", "READ", "error", "cont", "row", "Streamer", "download", "empty", "test", "poll", "v", "video", "RAW", "Stream", "loop", "server", "self", "source", "valid", "reader", "pipe", "stack", "pod", "draw", "secure", "sl", "sw", "engine", "present", "socket", "port"], "p": ["v", "pc", "n", "tp", "bp", "pa", "lp", "jp", "sp", "b", "pn", "r", "pp", "t", "o", "m", "e", "P", "cp", "q", "pi", "fp", "h", "np"], "ti": [" ki", " ot", "tu", "ta", " tv", "tt", " li", "ai", "ci", "ii", "t", " te", " bi", "tm", "ri", " vi", "te", " mi", " di", " tid", " tu", "fi", " tf", " ta", "si", "bi", " si"], "i": ["li", " ni", " li", "f", "ai", "r", "ci", " multi", "ii", "ati", " bi", " vi", "e", " ii", "pi", " v", "io", "l", " index", "x", "it", "si", " si", "I"], "len": ["il", "n", "nl", "fin", "li", "lp", "ll", "mem", "lim", "lc", "fn", "lf", "lan", "lib", "el", "lon", "en", "ml", "Len", "ls", "size", "ln", "l", "nm", "pos", "le", "length"], "pb": ["cv", "pc", "vp", "tp", "tap", "dp", "gc", "bp", "wp", "PC", "lp", "jp", "typ", "lb", "repl", "pl", "pan", "pel", "ob", "tx", "stab", "td", "cb", "tg", "b", "pn", "mb", "rb", "pid", "pp", "pool", "pkg", "pg", "patch", "bc", "erb", "vt", "uf", "mp", "xb", "sb", "bps", "pty", "tm", "buffer", "tab", "pt", "cc", "pd", "bb", "cp", "py", "px", "nb", "fb", "bj", "fp", "kb", "rpm", "vm", "np", "pm", "tc", "bs", "tk", "wb", "amp", "buf", "proc", "ps", "PB", "emb", "ctx"], "sfilename": ["sysFilename", " sfile", " sdirectory", "ssfile", " sames", "sysfilename", "osames", "osfilename", "jsfilename", " susername", "jsFilename", "esdirectory", "jsfn", "ssusername", "esfilename", "sysfn", "sjournal", "Sfilename", " sfn", "lsjournal", "lsdirectory", "susername", "svfilename", "Slength", "sfp", "svFilename", "esFilename", "sfn", "sames", " sFilename", "Sjournal", " sfp", "jsusername", "Susername", " slength", "lsfilename", "osFilename", "sysjournal", "svjournal", "lsfile", "ssFilename", "Sfp", "svfn", "sdirectory", "svusername", "svfile", "ssfn", "sysusername", "ssfilename", "svdirectory", "sfile", "slength", "SFilename", "esfile", "sFilename"], "eosf": ["Eoesl", "eoidfx", "peossb", "eotfo", "Eosp", "Eoesp", "eOSl", " eossfs", "peotfl", "eozfl", "eopensp", "eomfy", "eossf", "Eosf", "eosesfl", "nosn", "eoesfs", "eoosfs", "peosp", "eoSl", "eosp", "xosf", "eosl", "peosfs", "Eoosf", "Eoesfs", "eoSp", "erosl", " eosfx", "eoesfo", "eossfx", "eoSf", "eOSf", "eopensfo", "Eosfs", "eoSfs", "eomf", "eosesl", "eoosf", "eosesfs", "eopensf", "eoesfx", "nossn", "nosv", "eoesfe", "nossp", "eosfe", "peosrf", "peosfl", "eoesp", "eoosp", "eosfo", "peossfe", "nossf", "peossp", "eostv", " eosfs", "xosfg", "eopensfl", " eosfe", "eosfl", "eoesfg", "eozfo", "peosf", "eoidfy", "eosb", "eoesf", "eOSfac", "xoesfx", "peotrf", "peossl", " eossfx", "nossv", "eosv", "eosesp", "eaosfl", "eoosl", "eosesfe", " eosc", " eossc", " eossf", "peossfo", "eomfx", "peosfo", "peotfo", "eoidf", "erosf", "xoesfy", "eoidfg", "eozrf", "eossfo", "eossfe", "Eoosl", "eosesc", "eoosfac", " eosfl", "eossl", "eossb", "eosfs", "eOSp", " eossl", "eoosb", " eossp", "eotn", "Eosl", "Eosfac", "eozf", "Eosfo", "Eoosfac", " eossfo", "xosfx", "eotf", "eotfl", "eomfg", "eoosc", "eotv", "eostp", "eoesfy", "eoosfo", "eosesf", "eaosfo", "eostn", "eosc", "eoesc", " eossfe", "eosn", "nosf", "xosfy", "peosb", "xoesfg", "eossv", "eaosrf", "eossc", "eostf", "eossn", " eossfl", "eosesfo", "eosrf", "eossfl", "eosfac", "peosfe", "nosp", "eoesl", "erosfs", "erosfo", "eossp", "eosesfac", "eosfg", "eoosfx", "eossfs", "peotf", "eaosf", "Eoesf", "eosfx", " eosfo", "eOSfs", "peosl", "peossfs", "eosfy", "eOSfo", "eoesb", "peossf", "xoesf", "eotp", "eotrf", " eosl", "Eoosfo", " eosp"]}}
{"project": "qemu", "commit_id": "b3be28969b797b27d7f7f806827e9898e4ee08f0", "target": 0, "func": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,\n\n                                    bool last_stage,\n\n                                    uint64_t *bytes_transferred)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit;\n\n    uint8_t *p;\n\n    int ret;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->offset;\n\n\n\n    p = block->host + offset;\n\n\n\n    bytes_xmit = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 25284, "substitutes": {"f": ["v", "util", "fr", "exec", "bf", "fs", "file", "fo", "sf", "tf", "lock", "b", "r", "z", "F", "fc", "fw", "lf", "t", "fac", "uf", "rf", "fm", "ref", "o", "fd", "e", "m", "buffer", "g", "cf", "d", "framework", "q", "ef", "fb", "window", "fp", "h", "def", "s", "l", "conf", "fi", "i", "ff", "c", "x", "y", "w"], "pss": ["cSS", " pSS", "cpcss", "cse", "Pcss", "ppsi", "psp", "PSS", "apsi", "pcss", " pcss", "psi", "cpSS", "cess", "apSS", " psi", "ppSS", "Pss", "apss", "cpss", "cpess", "Pess", "ppsp", "pess", "Pse", " psp", " pse", "pse", "apsp", " pess", "ppss", "css", "pSS"], "last_stage": [" last2sent", " last2stage", "last1sent", "last_sent", "last1stage", " last_sent", "last_send", " last2active", " last2send", " last_active", "last2sent", "last_active", " last_send", "last2stage", "last1send", "last1active", "last2active", "last2send"], "bytes_transferred": ["bytes_transreported", "bytes_translationinitialized", "bytes5payferred", "bytes5transreported", "bytes_sentpleted", "bytes64transuted", "bytes_Transpleted", "bytes5transitted", "bytes2transfer", "bytes_compmitted", "bytes_exferred", "bytes64redfixed", "bytes_configuted", "bytes_payoved", "bytes_expleted", "bytes_ranitted", "bytes2transmitted", "bytes_translationferred", "bytes5transferred", "bytes_translationformed", "bytes64reduted", "bytes2Transmitted", "bytes_compferred", "bytes_permitted", "bytes5paypleted", "bytes64transfixed", "bytes_sentreported", "bytes_transfixed", "bytes_transpleted", "bytes_configmitted", "bytes_configfixed", "bytes_foundinitialized", "bytes_transitted", "bytes_sentferred", "bytes_transpired", "bytes_costmitted", "bytes2Transfer", "bytes64transferred", "bytes_transfer", "bytes_sentoved", "bytes_transuted", "bytes2transferred", "bytes5transpleted", "bytes_createdlated", "bytes_ranpleted", "bytes5transmitted", "bytes_createdinitialized", "bytes_redmitted", "bytes5transoved", "bytes2transpleted", "bytes_costfer", "bytes_ranpired", "bytes_Transmitted", "bytes_ranspleted", "bytes_ranmitted", "bytes_transinitialized", "bytes_redferred", "bytes64redmitted", "bytes_ransmitted", "bytes_costpleted", "bytes_extmitted", "bytes_redfixed", "bytes_costferred", "bytes_payferred", "bytes_transcluded", "bytes_createdferred", "bytes_exmitted", "bytes_extferred", "bytes_perferred", "bytes5extpired", "bytes_payreported", "bytes64transmitted", "bytes_reduted", "bytes_transformed", "bytes_ranreported", "bytes_translationlated", "bytes_foundformed", "bytes_computed", "bytes_createdformed", "bytes_extitted", "bytes_ranscluded", "bytes_foundferred", "bytes_Transfer", "bytes5payreported", "bytes_ranoved", "bytes5payoved", "bytes_compfixed", "bytes_excluded", "bytes5extitted", "bytes_Transitted", "bytes2Transpleted", "bytes_perfer", "bytes_ransferred", "bytes_Transferred", "bytes5extferred", "bytes_translated", "bytes_ranferred", "bytes_extpired", "bytes5extmitted", "bytes_Transpired", "bytes_transoved", "bytes_perpleted", "bytes_paypleted", "bytes_configferred", "bytes64redferred", "bytes_transmitted", "bytes_Transcluded", "bytes_foundlated", "bytes5transpired", "bytes2Transferred"], "bytes_xmit": ["bytes_intermitt", "bytes_exlate", "bytes64xot", "bytes_Xmitt", "bytes_xMIT", "bytes_xxmit", "bytes_rxmit", "bytes64uxmat", "bytes_axmit", "bytes_axsend", "bytes_axmitter", "bytes_uxmit", "bytes_xphibit", "bytes_mxmitted", "bytes_xpmitter", "bytes_txferred", "bytes_remit", "bytes_Xmitted", "bytes_ixmit", "bytes_xxmitt", "bytes_rxMIT", "bytes_consvent", "bytes_Xmit", "bytes_axmid", "bytes_xpmit", "bytes_xsmits", "bytes_intermission", "bytes_uxmits", "bytes_transmitt", "bytes_ixmite", "bytes_xsmit", "bytes_wxot", "bytes_txmission", "bytes_reot", "bytes_relate", "bytes_wxmit", "bytes_xpceive", "bytes_uxmid", "bytes_consmit", "bytes_xpsend", "bytes_Xvert", "bytes64uxmit", "bytes_xmitt", "bytes_xslate", "bytes_txmit", "bytes_intermit", "bytes_remits", "bytes_wxmat", "bytes_rxwait", "bytes_xvent", "bytes64xmit", "bytes_xwait", "bytes_xmat", "bytes_uxot", "bytes_Xmite", "bytes_xot", "bytes_mxmission", "bytes_xlate", "bytes64xmits", "bytes_xferred", "bytes_axvent", "bytes_xpmid", "bytes_wxmits", "bytes_axceive", "bytes_remat", "bytes_xhibit", "bytes_txmitted", "bytes_exmitted", "bytes_xvert", "bytes64uxmits", "bytes_exmitt", "bytes_ixmitted", "bytes_remitted", "bytes_intermits", "bytes_XMIT", "bytes_uxmat", "bytes_xxMIT", "bytes_axhibit", "bytes_rxmitted", "bytes_exmission", "bytes_txMIT", "bytes_conshibit", "bytes_ixvert", "bytes_xswait", "bytes_mxferred", "bytes_xsMIT", "bytes64xmat", "bytes_xpvent", "bytes_mxmit", "bytes_xsmitt", "bytes_xmission", "bytes_exmits", "bytes_uxceive", "bytes_xceive", "bytes_xsmitted", "bytes_transmits", "bytes_xmite", "bytes_exmit", "bytes_txwait", "bytes64uxot", "bytes_xmitter", "bytes_uxsend", "bytes_xxmitted", "bytes_xsend", "bytes_consmitter", "bytes_xmits", "bytes_transmitted", "bytes_xmitted", "bytes_transmit", "bytes_transmission", "bytes_xmid"], "p": ["ap", "pc", "n", "k", "tp", "vp", "pre", "page", "pa", "wp", "offset", "bp", "lp", "jp", "sp", "op", "b", "r", "pid", "pp", "address", "pkg", "t", "ip", "pod", "o", "m", "ping", "pt", "g", "P", "cp", "u", "q", "part", "up", "fp", "h", "point", "np", "i", "pb", "c", "pos", "it", "ps", "port"], "ret": ["rev", "nt", "rem", "url", "res", "result", "page", "offset", "jp", "val", "rows", "sp", "rt", "tf", "mem", "rets", "tr", "pages", "reply", "reset", "elt", "r", "ts", "pas", "t", "len", "ref", "hash", "Ret", "out", "off", "mt", "RET", "flag", "att", "def", "resp", "flags", "re", "alt", "j", "it", "prot"], "block": ["BL", "range", "link", "file", "lock", "b", "bit", "box", "image", "ip", "ref", "hash", "header", "line", "window", "byte", "def", "record", "map", "session", "type", "pb", "inv", "un", "work", "k", "offset", "host", "load", "blocking", "address", "pack", "bus", "base", "part", "prefix", "fp", "model", "field", "object", "data", "wall", "volume", "group", "tag", "pool", "bl", "chain", "buffer", "out", "table", "container", "Block", "row", "index", "proc", "mb", "cache", "v", "page", "frame", "disk", "sp", "config", "job", "mem", "info", "blocks", "man", "bin", "key", "name", "list", "bo", "snap", "point", "label", "word"], "acct_info": ["acnc_info", "acct_Info", "acct__current", "acct__info", "acct_current", "acct_data", "acnt_INFO", "acncpostatus", "acnc_inf", "acnc_Info", "acnt_state", "acctpostatus", "acctpoinf", "acctpoInfo", "acnt_info", "acct_status", "acct__list", "acncpoInfo", "acncpoinf", "acnt_list", "acnt_current", "acncpoinfo", "acct_state", "acctdbcurrent", "acct_INFO", "acct_list", "acctdbinfo", "acnt_data", "acctpoinfo", "acct_inf", "acnc_status", "acctdblist"], "norm_pages": ["normMBpointers", "norm_blocks", "norm_pointers", "normMBblocks", "norm_files", "normal_pages", "norm_plugins", "normal_blocks", "normal_plugins", "normMBfiles", "normal_files", "norm_posts", "normal_posts", "normMBpages", "normal_pointers"], "dup_pages": ["dup_files", "dued_fields", "dupExposts", "dued_files", "dupExfiles", "dupExpages", "dup_fields", "dupExfields", "dued_pages", "dued_posts", "dup_posts"]}}
{"project": "qemu", "commit_id": "554b614765090f47d97a20ca6981e17e96515ec1", "target": 0, "func": "void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_error, BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25310, "substitutes": {"has_job_id": ["has_jobityid", "has_job__id", "has_job__ids", "has_job__info", "has_jobityname", "has_job_name", "has_jobityinfo", "has_jobs_id", "has_jobs_info", "has_jobitynumber", "has_job_type", "has_job_info", "has_job_ids", "has_jobs_ids", "has_job__type", "has_jobs_type", "has_job_number"], "job_id": ["jobiddetails", "job_type", "job_ids", " job_details", "jobidinfo", " job_event", "jobidid", "job_ident", " job_info", "job_details", " job_ids", "job_info", " job_type", "job_event", "jobidident", " job_ident"], "device": ["Device", "drive", "command", "driver", "devices", "disk", "mode", "feature", "family", "volume", "directory", "database", "block", "address", "serial", "image", "pod", "version", "remote", "template", "chain", "buffer", "dev", "status", "connection", "name", "controller", "number", "project", "bank", "depth", "engine", "id", "location", "module", "type", "handle", "resource", "network", "password"], "has_base": ["Has_base", "acts_child", "Has_Base", "has__background", "acts_buffer", "Has_bas", "has__base", "Has_buffer", "acts_background", "has_Base", "has_child", "has_background", "has__buffer", "has_buffer", "has__child", "has_bas", "acts_base"], "base": ["bas", "create", "profile", "basic", "db", "pa", "bare", "file", "family", "source", "local", "common", "parent", "based", "b", "bid", "ase", "se", "address", "path", "sample", "padding", "bin", "key", "relative", "ASE", "template", "version", "p", "chain", "status", "buffer", "name", "pad", "Base", "bound", "id", "prefix", "part", "stable", "balance", "back", "type", "handle", "alias", "batch", "normal", "resource", "root", "binding"], "has_backing_file": ["has_backging_file", "has_backingfulurl", "has_backingfulfiles", "has_backging_url", "has_backbing_image", "has_backingletfiles", "has_backingableimage", "has_backing_url", "has_backingfulfile", "has_backingablefiles", "has_backging_number", "has_backingablelink", "has_backing_link", "has_backbing_files", "has_backingfullink", "has_backging_link", "has_backingletfile", "has_backing_files", "has_backging_files", "has_backing_number", "has_backingletnumber", "has_backbing_file", "has_backingablefile", "has_backing_image", "has_backbing_link"], "backing_file": ["backing_files", "backingFilefiles", "backing___files", "backding_only", "backing_table", "backingFileimage", "backing___image", "backing_image", "backding_file", "backing_only", "backing___only", "backding_table", "backingFilefile", "backding_files", "backingFiletable", "backing___file", "backding_image"], "has_speed": ["has___size", " has__size", " has_size", " has_duration", " has__duration", "has_command", "has_size", " has_weight", "has_duration", " has__weight", "has_weight", "has__size", "has___duration", "has__weight", " has__speed", "has_system", "has___speed", "has__speed", " has_system", "has___weight", " has_command", "has__duration"], "speed": ["command", "data", "priority", "frequency", "count", "weight", "reshold", "ower", "driver", "scale", "power", "distance", "shape", "timeout", "delay", "sex", "read", "state", "performance", "rate", "interface", "gain", "secure", "seek", "status", "efficiency", "sw", "stream", "engine", "sync", "attery", "size", "density", "capacity", "peed", "type", "start", "index", "Speed", "port", "length"], "has_on_error": ["has_on_change", "has_on_command", "has_oningdefault", "has_on_default", "has_oningerrors", "has_oningsuccess", "has_oningerror", "has_on__success", "has_on_errors", "has_on__change", "has_onableerror", "has_on_success", "has_on__error", "has_on__command", "has_onablechange", "has_onablesuccess", "has_onablecommand"], "on_error": ["on67info", " on_info", " on_query", "on__error", "onmlerror", " on_ror", "on__ror", "on__debug", "on67success", " on_success", "on_debug", "on___error", "onewerror", "on_query", "on_ror", "on67query", " on_change", "on___change", "onmldebug", "on___ror", "on67error", "onewquery", "on_success", "onewsuccess", "onewinfo", " on_debug", "on_change", "on_info", "onmlror"], "errp": ["errorpr", "errpb", " errpy", "nerP", " errping", "lrP", "errpe", "derpb", " errr", "dieP", "dercp", "errpy", "arrP", "errorr", "eorpa", "rrping", "arrper", "sprping", "arrping", "nerpa", " errP", "errorP", "arrpy", "errping", " errcp", "lrp", "lrpy", "sprpr", "derpa", " errpe", "errcp", "derP", "errorpa", "eorcp", "derping", "diepe", "nerr", "erp", "derp", "rrpb", "lrpa", " errpa", "erP", "errorp", "sprp", "eorp", "eorP", "arrp", "erpe", "errP", "errr", "rrper", " errpr", "rrp", "errpa", "errorping", "errpr", "arrpb", "errper", "arrpa", "diep", "nerp", "derper", "sprP"], "bs": ["BS", "bits", "bas", "obj", "bed", "gs", "js", "bis", "ses", "bi", "ubis", "bp", "obs", "fs", "ns", "ubs", "ss", "b", "cb", "ts", "bos", "eb", "bytes", "bc", "cs", "bl", "blocks", "bes", "sb", "bps", "bh", "boxes", "ds", "bles", "bb", "ls", "outs", "locks", "cks", "hz", "rs", "s", "vs", "lbs", "aos", "stats", "its", "pb", "socket", "ps"], "base_bs": ["base_blog", "basePbs", "base___boxes", "basePblog", "baseablets", "domainPbs", "base_bu", "base_ls", "domainPbu", "base67bs", "baseablebb", "bas_bb", "domainPbh", "base_ts", "base___sb", "baseablebs", "domain_blog", "domain_bh", "bas_ts", "b_base", "base_bps", "base_boxes", "domainPblog", "base_ubis", "base_bis", "back_ubis", "base67bh", "base8base", "bas_bis", "b_bs", "base8vs", " base_vs", "back_bps", "base_obs", "base_bb", "base___bs", "base_sb", "base8ls", "b_bits", "base_base", "base___base", "base_vs", "domain_bu", "bas_bs", "baseablebis", " base_ls", "base_bits", "base67blog", " base_base", "back_bs", "b_obs", "domain_bs", "base8bs", " base_boxes", "base67bu", "base8bu", " base_sb", "basePbu", "basePbh", "base8blog", "back_bis", "base_bh", "base8bh"], "aio_context": ["aoy_information", "aao_ctx", "aio_translation", "aio_manager", "aoy_resource", "aio_environment", "aio___ctx", "aio7resource", "aao_translation", "aIO_context", "aio_resource", "aio7environment", "aio___Context", "aao___context", "aao_Context", "aao___ctx", "ai_Context", "aio_record", "aio_choice", "aIO_choice", "aio7context", "aoy_environment", "aio7information", "aao___Context", "ai_context", "aao___translation", "aoy_context", "aio___context", "aIO_Context", "aio___translation", "aio_information", "aao_context", "ai_ctx", "aIO_record", "aio_Context", "aio_ctx", "aIO_manager", "ai_config", "aio_config", "aIO_ctx"], "local_err": ["localitymsg", "local_log", "local__log", "local____rr", " local_log", "local___rr", "local____error", "local____err", "local_error", "local____attr", "local_attr", "local____log", "local_exc", " local_error", "local_obj", "global_err", "localityer", "local__err", " local_result", "local_rr", "localityobj", "local_msg", "local_result", " local_rr", " local_exc", "local__error", "local___error", "local___attr", "local__exc", "global_msg", "local____exc", " local_attr", "global_obj", "local_er", " local_msg", "global_er", "localityerr", "local___err"], "base_name": ["buffer_name", "base12Name", "base_id", "Base_name", "Base_id", "base_code", "base_Name", "base___code", "baseNamename", "base12name", "base___Name", " base_file", "base12file", " base_named", "base_image", "Base_file", "baseJnamed", "base2no", "baseNameimage", "Base_image", " base_Name", "buffer_Name", "base2Name", "Base_Name", "baseNameName", "base_file", "buffer_no", "base_no", " base_code", "base___name", "baseJName", "baseJname", "base_named", "baseJfile", "base12image", "base2name", "baseNamefile", "base___file"]}}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n\n                           AVDXVAContext *ctx,\n\n                           DECODER_BUFFER_DESC *dsc,\n\n                           unsigned type, const void *data, unsigned size,\n\n                           unsigned mb_count)\n\n{\n\n    void     *dxva_data;\n\n    unsigned dxva_size;\n\n    int      result;\n\n    HRESULT hr;\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,\n\n                                                 D3D11VA_CONTEXT(ctx)->decoder,\n\n                                                 type,\n\n                                                 &dxva_size, &dxva_data);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,\n\n                                            &dxva_data, &dxva_size);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",\n\n               type, hr);\n\n        return -1;\n\n    }\n\n    if (size <= dxva_size) {\n\n        memcpy(dxva_data, data, size);\n\n\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n\n            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n\n            memset(dsc11, 0, sizeof(*dsc11));\n\n            dsc11->BufferType           = type;\n\n            dsc11->DataSize             = size;\n\n            dsc11->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n\n            DXVA2_DecodeBufferDesc *dsc2 = dsc;\n\n            memset(dsc2, 0, sizeof(*dsc2));\n\n            dsc2->CompressedBufferType = type;\n\n            dsc2->DataSize             = size;\n\n            dsc2->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n\n\n        result = 0;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);\n\n        result = -1;\n\n    }\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to release buffer type %u: 0x%x\\n\",\n\n               type, hr);\n\n        result = -1;\n\n    }\n\n    return result;\n\n}\n", "idx": 25344, "substitutes": {"avctx": ["evctx", "avkw", "avewp", "savkw", "evcontext", "avercontext", " avcfg", "averctx", "cvctx", "avcontext", "evtx", "vrcontext", "evcfg", "vrctx", "averkw", "AVwp", " avtx", "aveinit", "afctx", " avconn", "AVinit", "AVctx", "AVcontext", "Avtx", "AVconn", "avjp", "afcfg", " avpkg", "avcfg", "vrcmp", "afcmp", "avercmp", "avekw", "savctx", "Avctx", "vrtx", "avecontext", "evcp", "avpkg", "avercp", "avconn", "avejp", "Avcmp", "averjp", "vrcfg", "evcmp", "cvcontext", "avwp", "averconn", "cvconn", "avinit", " avcontext", "avcp", "avcmp", "Avcontext", "avtx", "averwp", "avercfg", " avcmp", "averinit", "AVpkg", "aveconn", "avectx", "savjp", "savconn", "cvpkg", "afcp"], "ctx": ["init", "nt", "cv", "obj", "cmp", "conn", "history", "txt", "jp", "rt", "config", "context", "tx", "cb", "loc", "lc", "cpp", "kt", "cmd", "pkg", "xc", "bc", "setup", "act", "dc", "ctl", "tm", "rx", "hw", "cc", "jac", "tz", "ct", "cp", "voc", "crit", "ck", "wcs", "sc", "rc", "sys", "tmp", "tc", "gz", "c", "cm", "today", "alloc", "kw", "nc", "cfg"], "dsc": ["csc", "dnSC", "mbc", "sdsc", " dSC", "dntc", "indbc", "rca", "sdca", " dcs", "rbc", "rcs", "cesc", "indpc", "sdcs", "dbc", " dbc", " dtc", "dca", "ddsc", "cbc", "rsc", "sdbc", "dpc", "ddtc", "indsc", " dca", "dcs", "mpc", "indesc", "msc", "cpc", "dnsc", "dtc", "mesc", "desc", "ddSC", "dSC"], "type": ["reason", " Type", "to", "method", "count", "in", "weight", "ty", "Type", "typ", "family", "file", "kind", "ype", "tag", "description", "info", "address", "spec", "handler", "t", "what", "version", "time", "p", "code", "buffer", "format", "name", "ping", "function", "style", "id", " ty", "role", "error", "value", "TYPE", "unit", "pe", " TYPE", "color", "types", "desc", "ptr", " typ", "test", "ver", "length"], "data": ["DATA", "cache", "zero", "iter", "Data", "mode", "message", "block", "bytes", "image", "area", "bin", "w", "ref", "p", "all", "str", "buffer", "format", "name", "out", "a", "window", "id", "error", "value", "map", "done", "batch", "buf", "empty", "ata", "length", "raw"], "size": ["to", "settings", "max", "count", "offset", "small", "scale", "sp", "file", "shape", "ize", "see", "message", "full", " sizes", "set", "info", "spec", "sum", "bytes", "area", "len", "sh", "send", "space", "time", "sha", "code", "buffer", "format", "g", "name", "style", "sw", "fee", "number", "id", "SIZE", "storage", "height", "s", "capacity", "start", "scope", "empty", "sn", "dim", "Size", "length"], "mb_count": ["MB_container", "mblount", "MB_count", "mb_ctr", "MB_ctr", "MB_ount", "mbetyctr", "mbetycontainer", "mbptctr", "mb_len", "mblcount", "MB_len", "mbllen", "mb_ount", "mbetycount", "mb9count", "mbptcontainer", "mb9len", "mb_container", "mb9ount", "mbptcount"], "dxva_data": ["dxva_cache", "dxva___mu", "dxba_mu", "dxha_cache", "dxha_data", "dxva___size", "dxba_name", "dxva___data", "dxba_path", "dxva2bytes", "dxvaistmu", "dxvaistmem", "dxva2name", "dxvaistdata", "dxva64data", "dxva64path", "dxba_cache", "dxba_size", "dxva_path", "dxva_bytes", "dxba_bytes", "dxva_mu", "dxvaistsize", "dxva___mem", "dxba_data", "dxva_name", "dxva_mode", "dxba_mode", "dxha_bytes", "dxva64mode", "dxva2data", "dxba_mem", "dxva2cache", "dxva64size", "dxva_mem"], "dxva_size": ["dxva____height", "dxva_Size", "dxVA_len", "dxova_message", "dxova_scale", "dxVA_count", "dxvo_height", "dxvo_size", "dxVA_SIZE", "dxva_count", "dxva____data", "dxvo_data", "dxva_height", "dxva_scale", "dxVA_size", "dxova_size", "dxva____size", "dxva_SIZE", "dxova_Size", "dxva_len", "dxvo_SIZE", "dxva_message", "dxva____SIZE"], "result": ["nr", "obj", "res", "count", "r", "attr", " res", "duration", "match", "p", "Result", "code", "status", "number", "mark", "error", "rc", "num", "br", "success", "date", "ver", "err", "results"], "hr": [" yr", "er", "her", "nr", "ih", "HER", "hs", " err", "fr", " HDR", "rr", "hm", "yr", "ocr", "shr", "then", "hl", "tr", "H", "or", "r", "ha", "enth", "usr", " dr", "rd", "resh", "timer", "hh", "Mr", "oh", "eor", " h", "eh", "kh", "uh", "mr", "rh", "hz", "rs", "hour", "here", "HK", " HR", "lr", "h", "hd", "dr", "HR", "rer", " pr", "br", " er", "DR", "drm", "pr", " cr", "kr", "vr", "err"], "dsc11": ["dsc20", "dsync1", " dbc001", " dsc18", "desc1", "dsc10", "dsc1", "dbc31", " dbc112", "dss11", "dSC11", " dsc112", "dSC20", "dsync11", "dsc31", " dbc20", "nesc12", "dusc11", "dusc18", "dsc112", " dsc001", "ddc1", "dsec10", "dusc1", "drc31", "nsc11", "dbc11", "dbc18", " dbc1", "dirc11", " dsc31", "dirc1", "dSC18", "desc11", " dsc10", "dbc12", "dpc10", " dbc18", "desc31", "dbc001", "dbc91", "dbc1", " dbc31", "dbc10", " dsc301", " dbc10", "dss12", "dsec11", " dbc12", "desc12", "dsync112", "dsec1", "dsc001", "dpc11", "dsc18", "ddc11", " dsc20", "dpc001", "dss91", "ddc301", "dsync301", " dsc12", "dsc12", "dSC1", "nsc91", "dpc1", "drc12", "nesc91", "dsc301", "dbc301", " dbc11", "dirc20", "nesc11", "dsc91", " dsc1", "dsec001", "drc11", " dbc301", "drc1", "dbc112", "nsc12", "dbc20", "ddc112", "desc91"], "dsc2": ["sdsp3", "dsync1", "dsp02", "dbc3", "desc1", "desc2", "desc22", "dsc1", "dsync2", " dbc22", "dsync6", "sdsc5", "dsync16", "dpc16", "dsc5", "desc02", "dpc6", " dSC1", "sdsc02", "dsc16", "dSC3", "sdsp02", " dsc16", " dbc2", " dbc1", "dpc2", "sdsc3", " dsc6", "dSC16", "dsp5", "src2", "dSC6", " dsc3", " dsc22", "sdsc2", "dbc1", "dsp3", "dSC02", "dsc6", "desc5", "dbc02", "dbc2", "ssc1", "dsc22", "dsec3", "dSC1", "dsec02", "sdsp5", "dpc1", "dsc02", " dSC6", "dsp2", " dbc3", "dSC22", "desc3", "dsec2", "src1", "ssc2", "drc02", "ssc02", "src02", "dsc3", " dsc1", "dbc22", " dSC16", "sdsp2", "drc2", " dSC2", "drc1", "dsec5", "dSC2"]}}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353, "substitutes": {"saddr": ["wadd", "wadr", "shost", "Salign", " sadd", "ssaddress", "itsmod", "esarp", "sinalign", " sconn", "tsaddr", "Saddr", "rsconn", "ssadr", " saddress", "ssmod", "ssconn", "sinaddress", "jsadd", "itsaddr", "wsvr", "esadd", " snode", "salign", "esvr", "svr", "jshost", "jsaddr", "sinaddr", "rsaddress", "Saddress", "esadr", "haddr", "dsaddr", "sconn", "sctx", "osadd", "sarp", "dsadd", " sctx", "esaddress", "hconn", "sadder", "rsaddr", "jsadr", " sadr", "haddress", "itsadr", "jsctx", "wsaddr", "osaddr", "itsadder", "jsarp", "smod", "saddress", "hadd", "sadr", " shost", " sarp", "dsaddress", "rsadr", "ssadd", "waddr", "hadr", "jsaddress", "osnode", "snode", "wsadd", "sadd", "Sadd", "esctx", "osaddress", "dsadr", "wsadr", "esaddr", "tsadd", " salign", "eshost", "ssadder", "ssnode", "wvr", "Sadr", "ssaddr", "tsadr", "sinadd"], "port_offset": ["port_shift", " port_error", "port_Offset", "port__error", "sort_offset", "Port_length", "port2style", "port__Offset", "Port_Offset", "port_style", " port_Offset", "port__off", "port_off", " port_off", "Port_shift", "port2offset", "port_padding", "port__offset", "port2off", "Port_offset", "sort_shift", "sort_style", "port2shift", "port_length", "port_error", "sort_off", " port_padding"], "update_addr": [" update_cache", " update2map", "updatepubaddr", " update_address", "update2addr", " update2address", "updateipmap", "updatepubaddress", " update2addr", "update2address", "update2cache", " update_map", "updateipaddr", "update_cache", "updatepubcache", "updatepubmap", "update_map", " update2cache", "update2map", "updateipcache", "updateipaddress", "update_address"], "errp": ["errorpad", "derpoint", "erm", "errpad", "errpoint", "errorphp", " errP", "errpc", "errorm", "errps", "ezpa", "derp", "erd", "erpre", "derd", "dercache", "ezps", " errpress", "derps", "errord", "orderP", "dangercache", "eorpad", "ererper", " errpa", "wrp", "eorpoint", "erP", "eorp", "testps", "rrpre", "errpress", "rrP", "ererp", "dangerpad", " errpre", "orderd", "derpad", "errd", "ererd", "testp", "errorP", "ererphp", "orderp", "derpa", "erp", "errm", "errorp", "orderpad", "derpc", "errpre", "orderphp", "errP", "errper", "ezp", "derper", "testpc", " errpad", "dangerp", "dangerpoint", "wrpa", "orderper", " errphp", "testpa", "derphp", "derm", "errphp", "strp", "errcache", "eorcache", "wrpress", "rrp", "errpa", "ezpc", "erpad", "strpa", "strpress"], "ai": [" au", "arp", "ami", "auth", "ac", "ei", "hai", "ro", "aos", " av", "oa", "ao", "i", "aud", "AE", "bi", "aj", "sa", "pa", "aci", " sa", " ba", "am", "ar", "aaa", "ha", "ci", "cu", " na", "api", "aa", "a", " mi", " ad", "addr", "ali", " ha", " am", "pri", "ca", "ait", "iq", "ras", "pai", "an", "AI", "attr", "hi", " ac", " bi", "cgi", "ia", " pa", " ta", "ais", "iam", "aus", " da", "aq", "mem", "ay", "ki", "info", " ap", "mi", "air", "aim", "ni", "ae", "ak", "ka", "acs", "au", " a", "ti", "asm", "alias", "aki", "asi", "ui"], "res": ["rev", "er", "rem", "ex", "ir", "rec", "result", "pre", "conn", "fr", "ser", "gr", "val", "pro", "ret", "Res", "mem", "ack", "r", "reg", "pas", "ref", "req", "ri", "ress", "rel", "os", "rs", "RES", "dr", "des", "resp", "sys", "progress", "addr", "ber", "re", "ro", "results"], "e": ["er", "oe", "ele", "me", "E", "ee", "ce", "r", "eu", "em", "t", "ge", "ei", "ec", "o", "ae", "en", "es", "ed", "te", "ef", "ev", "pe", "ue", "eg", "ep", "re", "c", "et"], "port": ["priority", "file", "message", "eport", "path", "ip", "note", "display", "header", "ping", "connection", "line", "queue", "ORT", "window", "id", "value", "position", "pointer", "map", "type", "player", "pr", "interface", "cast", " Port", "host", "client", "pp", "address", "version", "bind", "pad", "device", "P", "cp", "project", "direction", "handle", "buf", "pair", "ptr", "et", "prop", "length", "export", "limit", "data", "ports", "tp", "none", " sport", "ort", "channel", "tr", "pid", "PORT", "null", "pool", "proxy", "comment", "component", "remote", "localhost", "buffer", "be", "table", "error", "row", "target", "mobile", "index", "test", "Port", "bridge", "ve", "pport", "text", "dp", "page", "server", "family", "pro", "ace", "database", "key", "padding", "mit", "pod", "secure", "code", "pt", "name", "number", "stream", "phrase", "trace", "point", "socket", "ice", "password"], "uaddr": [" uAddress", "uiaddress", "uires", " ures", " uaddress", "ulAddress", "ulres", "uladdr", "uaddress", "uAddress", "ures", "uiAddress", "uiaddr", "uladdress"], "uport": ["unionport", "paddress", "Uaddr", "paddr", "pport", "unionaddress", "Uaddress", "unionaddr", "Uport", "uaddress"], "slisten": ["slister", " sopen", "sfiler", "stopern", "sfilern", "stopen", "slistener", "sopen", "slistern", " slistener", "sopern", "sopener", " sopern", "stoper", " slistern", "soper", "sfilener", "sfilen", "stopener", " slister", " sopener", " soper"], "rc": ["isc", "exec", "anc", "src", "cb", "func", "ge", "uc", "ec", "irc", "rs", "sc", "def", "c", "rn", "nc", "pc", "result", "cor", "fc", "usr", "call", "addr", "success", "_", "rt", "r", "ry", "new", "cs", "ck", "sync", "arc", "cur", "con", "ctr", "nr", "cmp", "rec", "co", "cas", "end", "rr", "rl", "ack", "info", "rd", "bc", "ror", "RC", "ok", "rx", "cc", "ro", "xff"], "port_min": ["port_mod", "port_MIN", " port_mod", " port_MIN"], "port_max": ["port_mod", "port2max", "port2range", "port2min", " port_mod", "port_range", " port_range", "port2mod"], "p": ["pc", "n", "tp", "pa", "jp", "f", "r", "pn", "b", "pp", "pkg", "t", "pat", "m", "pt", "P", "cp", "q", "pi", "rep", "fp", "pe", "np", "i", "pr", "c", "ps"], "err": ["init", "er", "ex", "obj", "errors", "ait", "result", "conn", "iter", "die", "fr", "notice", "txt", "rr", "esp", "aaa", "or", "cb", "cr", "r", "ere", "attr", "usr", "timer", "der", "eor", "arr", "ei", "req", "str", "cfg", "ah", "eas", "Er", "fee", "mr", "rn", "ev", "rs", "error", "lr", "later", "cer", "dr", "try", "resp", "sys", "conf", "addr", "gz", "re", "buf", "Error", "msg", "exc", "kr", "ch"], "baseport": ["Baseline", "balename", "baseity", "Basename", " basestamp", "baseeline", " basewater", "baseeport", "baename", "baseestamp", "baseewater", "Basewater", "Basestamp", "batabel", "Basity", "basename", "basaxy", "baseename", "basity", " basename", " basport", " baseline", "baseelist", "batelist", "beneport", " basency", "batename", "basestamp", "baleport", "baseline", "Baseport", "benename", "baseency", "baaxy", "baeport", "Baselist", "balency", " basaxy", "benabel", "bateport", "basabel", "baselist", "basport", "baeline", " baselist", " basity", "benelist", "Basaxy", "basewater", "baseabel", "basency", "Basport", "baleline"]}}
{"project": "FFmpeg", "commit_id": "a7f27453f64d9020b92b01687baeb5909c6cdad0", "target": 0, "func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;\n\n    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n\n        codec->codec_id == AV_CODEC_ID_H264 &&\n\n        atom.size > 11) {\n\n        avio_skip(pb, 10);\n\n        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n\n        if (avio_rb16(pb) == 0xd4d)\n\n            codec->width = 1440;\n\n        return 0;\n\n    }\n\n\n\n    return mov_read_avid(c, pb, atom);\n\n}\n", "idx": 25357, "substitutes": {"c": ["v", "cv", "pc", "ca", "cmp", "gc", "co", "anc", "cd", "f", "ce", "cb", "lc", "ci", "nc", "fc", "xc", "bc", "dc", "cs", "t", "cu", "ac", "ec", "coll", "cn", "p", "chain", "e", "unc", "com", "cc", "cf", "ct", "cp", "call", "C", "con", "cur", "rc", "l", "cont", "conf", "tc", "vc", "cm", "etc", "kw", "abc", "enc", "ctx"], "pb": ["ap", "pc", "vp", "tp", "tap", "dp", "bp", "pa", "wp", "ub", "ctx", "lp", "bf", "jp", "lb", "sp", "pan", "apy", "ob", "td", "cb", "b", "rb", "pp", "pkg", "orp", "pg", "eb", "gb", "mp", "uf", "sb", "pub", "p", "tab", "bb", "cp", "nb", "fb", "ib", "fp", "np", "amp", "bs", "tk", "wb", "BP", "zb", "PB", "emb", "mb"], "atom": ["data", "xml", "ap", "obj", "md", "text", "ext", "typ", "node", "term", "om", "am", "kat", "item", "op", "ob", "b", "cmd", "attr", "um", "at", "tem", "key", "abc", "orb", "p", "m", "buffer", "tab", "out", "name", "com", "part", "atomic", "app", "band", "byte", "orm", "unit", "num", "tmp", "mat", "map", "amp", "word", "addr", "buf", "x", "msg", "prop", "ata", "entry"], "codec": [" coddec", "condec", "condect", "Coderer", " codoc", "cenc", "coderer", "codrc", "coder", "Codisc", "coderc", " codek", " metrc", "codoc", "odect", "cec", "condEC", "cododer", "codEC", "cEC", "codeoder", "codeec", " codenc", " metoc", "Codenc", " cododer", "odoc", "Codrc", "odec", "codect", " metek", "Codoc", "codeEC", "codek", "codeerer", "codisc", " metec", "CodEC", " codEC", "codeenc", "conddec", " codrc", "odEC", "codeoc", "odrc", "odisc", " codect", "Codec", "oddec", "codenc", "odek", "codeisc", "coddec", " coderer"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370, "substitutes": {"vmsd": ["ventsd", " vmesds", "vssd", "mmesdc", " vmsdn", "vmessd", "vnsdc", "mmsl", "ventsdn", "vjsr", "vtsd", " vmesisd", "vnsd", "vmsl", "mmesr", "vssds", "vtsl", "mmessd", "vtsisd", "mmesds", "vmsdc", "vmesds", "ventsds", "vmesisd", "mmsds", "vmesr", "vmesl", "mmsd", "ventsisd", "vjsl", "vtsds", " vmsisd", "mmesd", "vmsr", " vmsds", "vmesd", "vnssd", "mmesl", "mmsdc", "vsssd", "vmsdn", "vnsds", "vmesdn", " vmesdn", "vssdc", "vtsdn", "vmesdc", "vmsisd", "vmsds", "vtsr", "vjsds", "mmsr", "vjsd", "mmssd", "vmssd", " vmesd"], "opaque": ["ompatile", "opparency", "operacity", "ipacity", "ompacity", "operaque", "opus", "oacity", "hopque", "opacity", "Opacity", "Opus", "hopparency", "hopacity", "opsatile", "ous", "opois", "oque", "ipus", "opsois", "Opque", "opsacity", "opatile", "opsaque", "ipaque", "ompois", "oaque", "operois", "oparency", "ipparency", "hopaque", "opque", "ipque", "ompaque", "operatile", "Opaque"], "se": ["sv", "ve", "parse", "sa", "ele", "ses", "ser", "me", "ene", "ree", "ide", "sche", "cle", "ent", "she", "ne", "see", "ce", "ace", "ase", "ense", "ry", "Se", "sed", "ine", "sem", "sec", "ge", "e", "ae", "ze", "sle", "es", "te", "so", "SE", "ke", "sea", "ese", "spe", "s", "pe", "de", "ade", "pse", "le", "ie", "entry", "ste", "est"], "new_se": ["new_me", "new___ce", "new__se", "old___me", "old_see", "new___se", "new__ge", "new__me", "old_se", "old___ce", "new___ge", " new_ge", "old___see", "new_ge", "new__ce", " new_ce", "old_me", "old_ce", "old___se", "new___me", "new__see", "new_ce", "new___see", "new_see"]}}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382, "substitutes": {"n": ["ren", "nt", "nl", "dn", "conn", "on", "na", "nu", "node", "ns", "net", "config", "ne", "tn", "norm", "mn", "an", "fn", "names", "t", "cn", "note", "o", "p", "m", "wn", "en", "name", "N", "nw", "nv", "a", "nb", "nd", "gn", "ln", "nex", "l", "nn", "nm", "np", "num", "ng", "j", "c", "sn", "nor", "rn", "network", "w"], "cmd": ["command", "nt", "cmp", "md", " command", "CT", "conn", "Cmd", "mode", "cd", "job", "kind", "cb", "mk", "kt", "dq", "pkg", "act", "ctl", "fun", "req", "cli", "comm", "code", "cfg", "cc", "cf", "ct", "cp", " chip", " msg", "def", "ctr", "cont", "tk", "type", "batch", " typ", "msg", "qt", "ctrl", "tl", "ind", " cc", "ctx"], "iov": ["v", "ir", "vp", "iq", "usb", "isco", "nox", "ij", "uv", "serv", "xp", "src", "mu", "mpeg", "uart", "iva", "nov", "vec", "iris", "ux", "voice", "vo", "pkg", "IV", "ilo", "iv", "tv", "minecraft", "vector", "conv", "fax", "comm", "verbs", "meyer", "irc", "browser", "ivo", "voc", "news", "org", "liv", "imp", "iol", "uj", "gov", "rov", "iop", "io", "rolet", "iu", "soc", "dyl", "river", "iw", "yon", "vg", "av", "drm", "mus", "icon", "ech", "ever", "aunts", "when", "rn", "vr"], "iov_cnt": ["iov_uncnt", "iov_Cst", "iov_eant", "iovolycunt", "iov_rtry", "iov_cacheres", "iov_Cry", "iov0ctnd", "iov_CNT", "iov0ctrowd", "iov0cgt", "iov_cst", "iov_eounter", "iov_cacheounter", "iov0cnd", "iov_scnd", "iov_cuoud", "iov_ctgt", "iov_secres", "iov_uncrand", "iov_acnt", "iov0crowd", "iov2curres", "iov_scrowd", "iov2cst", "iovolycnt", "iov_ctnt", "iov_curnt", "iov2acst", "iov_est", "iovolycuript", "iov_kount", "iov_Count", "iov2curnt", "iov2cry", "iov_arcnd", "iov_cres", "iov_curgt", "iov_gcant", "iov_scrt", "iov_cacheNT", "iov_arcst", "iov2count", "iov_acry", "iov0ctnt", "iov_arctry", "iov_scnt", "iovolycuoud", "iov_ctry", "iovolycrand", "iov_discnt", "iov_crand", "iovolycurand", "iov_Cant", "iov2acount", "iov2cnt", "iov_discoud", "iov_gcrt", "iov_knt", "iov_secnt", "iov_currt", "iov_cachent", "iov_acst", "iov_coud", "iov_ctrowd", "iov_scres", "iov2cant", "iov_discript", "iov0cnt", "iovolycoud", "iov_rst", "iov_curres", "iov_currowd", "iov_cunt", "iov_gcres", "iov_Counter", "iov_scant", "iov_secNT", "iov_cgt", "iov_gcnt", "iov0ctgt", "iov_arcnt", "iov_cript", "iov_uncoud", "iov2acry", "iov2crt", "iov_secounter", "iov_rnd", "iovolycript", "iov_curnd", "iov_acount", "iov_scgt", "iov_curand", "iov_curant", "iov_cuript", "iov2currt", "iov_ctnd", "iov_rnt", "iov_cNT", "iov_Cnt", "iov_uncript", "iov_cry", "iov2curant", "iov_count", "iov_discrand", "iov_crowd", "iov2cres", "iov_crt", "iov_cnd", "iov_ent", "iov_kst", "iov_Cres", "iov2acnt", "iov_cant", "iov_kry", "iov_counter"], "mac_data": ["ac_ata", "ac_def", "phrase_data", "mac2info", "micctl", "mac2entry", "phrase_dat", "mac_DATA", " macnew", "phrasePtable", "Mac_info", "macPdetails", " mac_ata", "ac_data", "mac67data", "mac7def", " mac_good", "mac8def", " mac_group", "Mac_def", "macctl", "mac8info", "mat_", " mac_DATA", "matnew", "mac_table", " mac_", "mac_dat", "mac_ata", " mac_res", "mic_", "mac_details", "mac_group", "mac8entry", "mac_info", "Mac_entry", "phrasePdat", "mac_entry", "mac_", "micnew", " mac_def", "mac_no", "mac2data", "Mac_data", "mac8data", "mac67table", "phrase_table", "phrasePdata", "macPtable", "mac2def", "mac7ata", "ac_no", "macPdat", " mac_list", "macnew", "mac2list", "mac_list", "mac_good", "mac_def", "macPdata", "mac_res", "matctl", " macctl", "phrasePdetails", "phrase_details", "mac2DATA", "mac67res", " mac_table", "mac7data"], "s": ["sv", "v", "is", "hs", "gs", "js", "ms", "changes", "rates", "S", "fs", "sp", "ns", "f", "ss", "r", "b", "z", "ts", "qs", "spec", "bytes", "t", "cs", "https", "south", "less", "ats", "gets", "conv", "space", "sb", "m", "p", "e", "g", "sl", "ds", "sym", "d", "ls", "sw", "es", "a", "os", "tes", "rs", "ies", "su", "h", "l", "as", "stats", "bs", "sts", "its", "xs", "i", "j", "c", "sq", "y", "ps", "w"], "nc": ["nt", "nr", "cv", "pc", "NC", "nl", "nz", "conn", "gc", "anc", "ns", "ne", "tn", "mn", "lc", "mc", "fn", "xc", "bc", "dc", "cs", "cn", "cc", "nec", "nw", "ct", "nv", "nb", "nic", "nd", "nn", "np", "tc", "yn", "c", "sn", "rn", "ctx"], "macs": ["tmacs", "maps", "smats", "macts", "smamps", "gmacs", "smacts", "mamps", "mats", "smaps", "tmamps", " mats", "gmats", "smacs", " mamps", "gmaps", "gmacts", "tmats", " macts", " maps", "tmaps"]}}
{"project": "FFmpeg", "commit_id": "14a90c9ef09a4b046500dceab5ca1875e330a376", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401, "substitutes": {"avctx": ["avval", "avedesc", "cvctx", "aveval", "wavval", "avepkg", " avcmd", "averloc", "wavcu", "avwcs", "afreq", "AVcontext", "averdl", " avpkg", "auwcs", "afcmp", "avedl", "wavcmp", "avdl", "avconf", "vrdesc", "avmsg", "awtx", "varconf", "wavctl", "vawcs", "wavcmd", "averdj", "avertx", "cvdesc", "avermsg", "vasys", "averpkg", "averwcs", " avdj", "awcmp", "averpy", " avtx", "auxcu", "aversys", "aveloc", "avetx", " avcu", " avtxt", "avtxt", "avreq", "avetxt", "devtx", "vrtx", "auxcp", "avdj", "averdesc", "avsys", "abcontext", "awcontext", "wavtx", "avpy", " avcontext", " avobj", "avertxt", "avtx", " avcmp", "avctl", "abreq", "wavcp", "abctx", "wavctx", " avconf", "avercontext", "abtx", "aftx", "devctx", "avcontext", "vrctx", "avcu", "afctx", "avcmd", "auctx", "vrcmp", "avercmd", "avecmd", "aveconf", "vamsg", "cvtx", "avobj", "avpkg", "AVdj", "wavobj", "avcp", "avcmp", "afcontext", "varctx", "averconf", " avreq", "devval", "aumsg", "AVtx", "averctx", "AVcmp", "avecmp", "avdesc", "AVctx", "avectl", "vardl", "devctl", " avdesc", "awctx", "avloc", "auxctx", "avepy", "afcmd", "vactx", "varpy", " avcp", "ausys", "avectx", "cvcmp", "auxobj", " avloc"], "ctx": ["nt", "ca", "cv", "obj", "cmp", "conn", "gc", "cas", "history", "txt", "jp", "val", "context", "timeout", "tx", "cb", "kt", "cmd", "pool", "pkg", "xc", "mx", "setup", "act", "dc", "ctl", "conv", "req", "hw", "cc", "cf", "jac", "ct", "cp", "wcs", "ck", "px", "prefix", "window", "etc", "resp", "conf", "np", "Context", "tc", "handle", "index", "cm", "qt", "ctrl", "kw", "cfg", "set"], "status": ["data", "res", "result", "gc", "sp", "f", "ret", "event", "Status", "state", "info", "this", "uses", "code", "str", "name", "out", "active", "sw", "id", "base", "prefix", "error", "flag", "summary", "s", "st", " ret", "sys", "progress", "service", "type", "wait", "index", "stat", "msg", "success", "access", "set"], "format_in": [" format_add", "pattern_gin", "filter_ins", "formatptinf", "format101out", "formatpyin", "formatptin", "formatixinn", "formatptold", "flatTYto", "format_", "pattern_in", "format__to", "format_din", " format_rin", "format101In", "pattern_din", "formatixin", "format_inf", "flat_ini", "format00nin", "format__ini", "filter_inner", " format_out", "format_out", "version_In", "transformptin", "version_rin", "formatpyrin", "filter_In", "formatobjnin", "flatTYin", " format_IN", "filter_", "format101init", "flat_in", "format_vin", "filter_init", "format_to", "transform_nin", "format___IN", "format00in", "formatableinn", "formatptnin", "format_ins", "format00inner", "formatpynin", "version_nin", "format23to", "transformptIn", "format_IN", "format23gin", "flat_to", "format_ini", "version_in", "format__gin", "format23ini", "transform_In", "format_gin", "formatMixin", "formatpyIn", "format_init", " format_", "formatptgin", "format_i", "format_rin", "format_inner", "format00IN", "format_add", "filter_in", "formatTYto", "formatMixadd", "format__in", "transformptold", "transformptnin", " format_In", "formatablein", "formatablevin", "format___inn", "formatobji", "format101in", "formatobjin", "transform_in", "flatTYini", "transform_old", "formatobjdin", "filter_nin", "flat_gin", "formatixvin", "filter_IN", "format00old", "formatixIN", "formatptIn", "format00ins", "formatTYini", "formatptdin", "format_In", "format00In", " format_inn", "transform_", "filter_out", "format23in", "formatMixIN", "format___in", "filter_din", " format_vin", "flatTYgin", "formatTYin", "format_inn", "format_nin", "pattern_inf", "formatTYgin", "formatableIN", "filter_i", "format_old"], "decoder": ["recressor", "ecoder", "unicode", "recor", "deener", "ecoding", "recoded", " decode", "recoding", "Decode", "encoded", "ecoded", "eccer", "ecode", " decor", "deccer", "decoded", "decressor", "decener", "unicener", "recoser", "decor", "Decoder", "ecressor", "ecor", "Decoser", "decode", "deode", " decoded", "encressor", "recoder", "recode", "deoser", "Decener", "reccer", "deoded", " deccer", "decoser", "ecoser", "unicoser", "encoder", "deoder", "unicoder", "decer", " decoding", "decoding", "encoser", "encode"], "tmp": [" rgb", "obj", "cache", "cmp", "v", "result", "mask", "uv", "params", "cb", "buff", " buff", "lib", "pad", "name", "base", " msg", " ref", "perm", "img", " junk", " pts", "proc", "etc", "test", " img", " params", " proc"]}}
{"project": "FFmpeg", "commit_id": "9e1c55cfdec1e1e46fa39b92ea5c425ba9499c68", "target": 1, "func": "static int ogg_get_length(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int i;\n\n    int64_t size, end;\n\n    int streams_left=0;\n\n\n\n    if(!s->pb->seekable)\n\n        return 0;\n\n\n\n// already set\n\n    if (s->duration != AV_NOPTS_VALUE)\n\n        return 0;\n\n\n\n    size = avio_size(s->pb);\n\n    if(size < 0)\n\n        return 0;\n\n    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, end, SEEK_SET);\n\n\n\n    while (!ogg_read_page (s, &i)){\n\n        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&\n\n            ogg->streams[i].codec) {\n\n            s->streams[i]->duration =\n\n                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);\n\n            if (s->streams[i]->start_time != AV_NOPTS_VALUE){\n\n                s->streams[i]->duration -= s->streams[i]->start_time;\n\n                streams_left-= (ogg->streams[i].got_start==-1);\n\n                ogg->streams[i].got_start= 1;\n\n            }else if(!ogg->streams[i].got_start){\n\n                ogg->streams[i].got_start= -1;\n\n                streams_left++;\n\n            }\n\n        }\n\n    }\n\n\n\n    ogg_restore (s, 0);\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, s->data_offset, SEEK_SET);\n\n    ogg_reset(s);\n\n\n    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {\n\n\n        int64_t pts = ogg_calc_pts(s, i, NULL);\n\n        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            s->streams[i]->duration -= pts;\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }\n\n        }\n\n            if(streams_left<=0)\n\n                break;\n\n    }\n\n    ogg_restore (s, 0);\n\n\n\n    return 0;\n\n}", "idx": 25404, "substitutes": {"s": ["ches", "sv", "ears", "gs", "ms", "ses", "changes", "scripts", "b", "parts", "ops", "https", "bes", "p", "aws", "ls", "news", "rs", "sc", "as", "webkit", "sports", "c", "ps", "ags", "results", "w", "er", "n", "bis", "erences", "fs", "ns", "ts", "ssl", "less", "sb", "ins", "d", "terms", "os", "a", "es", "ies", "vs", "ys", "stats", "sts", "ports", "hs", "is", "ss", "r", "z", "an", "cs", "ats", "times", "m", "comm", "irs", "ds", "aps", "sys", "ads", "v", "eds", "js", "S", "qs", "t", "gets", "ims", "o", "g", "sw", "h", "bs", "its"], "ogg": ["ears", "gs", "obs", "uv", "or", "mpeg", "ables", "oss", "pg", "important", "news", "craft", "ogl", "map", "gg", "eg", "pb", "aud", "oc", "ogle", "ast", "embed", "GG", "ob", "ott", "pp", "ssl", "oci", "orb", "OG", "ang", "bb", "ble", "ga", "ys", "umble", "ream", "atts", "ik", "igm", "raw", "ink", "errors", "oga", "ow", "tt", "amps", "gp", "owl", "arb", "obb", "annot", "audio", "able", "http", "iop", "ib", "orm", "good", "ebin", "sys", "ogs", "ais", "gif", "youtube", "Stream", "eps", "peg", "config", "og", "ace", "tg", "voice", "eb", "article", "agg", "mp", "ok", "ible", "BB", "oggle", "ows", "stream", "pdf", "podcast", "av", "rss"], "i": ["qi", "any", "ix", "xi", "ami", "b", "used", "ii", "oi", "ip", "ei", "p", "e", "status", "ori", "id", "io", "c", "y", "bi", "ind", "I", "n", "history", "ci", "di", "u", "pi", "iu", "fi", "start", "phi", "rest", "ik", "inner", "init", "ir", "is", "ij", "mu", "ini", "gi", "hi", "associated", "cli", "ic", "ri", "m", "multi", "remote", "wi", "rel", " ii", "ed", "\u0438", "im", "try", "l", "j", "index", "si", "v", "iri", "li", "ai", "ji", "info", "t", "mi", "o", "g", "q", "list", "uri", "h", "err", "ti", "batch", "x", "it", "ui"], "size": ["limit", "data", "too", "settings", "n", "izes", "max", "count", "ms", "offset", "scroll", "small", "scale", "sp", "any", "amount", "huge", "mem", "shape", "resolution", "ize", "message", "see", "body", "set", "parts", "address", "bytes", "sum", "sent", "area", "len", "south", "padding", "total", "speed", "send", "space", "time", "all", "eng", "name", "g", "news", "number", "loss", "inos", "SIZE", "st", "height", "capacity", "storage", "large", "largest", "start", "c", "x", "empty", "sn", "Size", "length", "export"], "end": ["limit", "dest", "max", "stop", "fin", "offset", "ended", "next", "final", "ent", "after", "pend", "wind", "END", "set", "len", "send", "add", "seek", "e", "en", "off", "bound", "End", "ending", "id", "last", "nd", "h", "st", "ue", "start", "ff", "pos", "est", "rest", "it", "begin", "length", "export"], "streams_left": ["streamers_low", "streams_all", "streamgs_right", "streams_bottom", "streams_low", "streams1Left", "streamgs_left", "streamids_expected", "streams_expected", "streamgs_Left", "streamids_all", "streams1left", "streams1bottom", "streams_old", "streams1low", "streamers_bottom", "streamids_old", "streams_Left", "streamers_left", "streamers_Left", "streamids_left", "streams_right"]}}
{"project": "FFmpeg", "commit_id": "80387f0e2568746dce4a68e2217297029a053dae", "target": 1, "func": "static int mimic_decode_frame(AVCodecContext *avctx, void *data,\n\n                              int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MimicContext *ctx = avctx->priv_data;\n\n    GetByteContext gb;\n\n    int is_pframe;\n\n    int width, height;\n\n    int quality, num_coeffs;\n\n    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;\n\n\n\n    if (buf_size <= MIMIC_HEADER_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"insufficient data\\n\");\n\n        return -1;\n\n    }\n\n\n\n    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);\n\n    bytestream2_skip(&gb, 2); /* some constant (always 256) */\n\n    quality    = bytestream2_get_le16u(&gb);\n\n    width      = bytestream2_get_le16u(&gb);\n\n    height     = bytestream2_get_le16u(&gb);\n\n    bytestream2_skip(&gb, 4); /* some constant */\n\n    is_pframe  = bytestream2_get_le32u(&gb);\n\n    num_coeffs = bytestream2_get_byteu(&gb);\n\n    bytestream2_skip(&gb, 3); /* some constant */\n\n\n\n    if(!ctx->avctx) {\n\n        int i;\n\n\n\n        if(!(width == 160 && height == 120) &&\n\n           !(width == 320 && height == 240)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid width/height!\\n\");\n\n            return -1;\n\n        }\n\n\n\n        ctx->avctx     = avctx;\n\n        avctx->width   = width;\n\n        avctx->height  = height;\n\n        avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        for(i = 0; i < 3; i++) {\n\n            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));\n\n            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;\n\n        }\n\n    } else if(width != ctx->avctx->width || height != ctx->avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"resolution changing is not supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decoding must start with keyframe\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->buf_ptrs[ctx->cur_index].reference = 1;\n\n    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;\n\n    if(ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->next_prev_index = ctx->cur_index;\n\n    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;\n\n\n\n    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],\n\n                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    ff_thread_finish_setup(avctx);\n\n\n\n    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,\n\n                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if(!ctx->swap_buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ctx->dsp.bswap_buf(ctx->swap_buf,\n\n                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),\n\n                        swap_buf_size>>2);\n\n    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);\n\n\n\n    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {\n\n        if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);\n\n        else {\n\n            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ctx->prev_index = ctx->next_prev_index;\n\n    ctx->cur_index  = ctx->next_cur_index;\n\n\n\n    /* Only release frames that aren't used for backreferences anymore */\n\n    if(ctx->buf_ptrs[ctx->cur_index].data[0])\n\n        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    return buf_size;\n\n}\n", "idx": 25413, "substitutes": {"avctx": ["cvctx", "avepkg", "avercookie", "awcu", "AVcontext", "ajtx", "wavpkg", "avhandle", " avpkg", "afsys", "avecp", "averjac", "svctx", "savctx", "avecontext", "avercp", "vcfg", "avmsg", "awtx", "avertx", "vkt", "afthis", "avthis", " avhandle", "avgc", "svtx", "AVcv", "avecv", "svcontext", "vrcontext", "apcontext", "averstate", " avtx", "ajsys", "avcv", "avercu", "aversys", "svsys", "avetx", " avcu", "avemsg", "vrtx", " avsys", "ajcontext", "avsys", "abcontext", "abcu", "ajthis", "savcookie", "ajhandle", "awcontext", "wavtx", "ajgp", "averthis", " avcontext", "wavmsg", "avecookie", "savcontext", "avtx", " avcmp", "AVpkg", "savstate", "afcp", "wavctx", "apcp", "abctx", "avercontext", "abtx", "aftx", " avkt", "avcontext", "avergp", "vrctx", "afctx", " avcv", "vrcmp", "cvtx", "aptx", "ajjac", " avjac", "avpkg", "apkt", "ajgc", "cvcontext", "averhandle", "avcp", "avstate", "avcmp", "afcontext", "vctx", "AVtx", "averctx", " avcfg", "AVcmp", "avecmp", "AVctx", "vcontext", "avcfg", "avergc", "afgc", "avjac", "awctx", "avcookie", " avmsg", "ajcu", " avgp", "apcfg", "avgp", "ajctx", "avestate", " avcp", "svcp", "apctx", "avectx", "cvcmp", "avkt", "avcu"], "data": ["DATA", "bits", "text", "frame", "Data", "raw", "content", "f", "mu", "query", "message", "body", "read", "block", "bytes", "area", "t", "image", "padding", "bin", "p", "m", "dat", "buffer", "feed", "pad", "name", "d", "stream", "a", "window", "size", "value", "def", "input", "batch", "ata", "length", "w"], "data_size": [" data_SIZE", "data_length", "data_SIZE", "data_count", " data_count", " data_length"], "avpkt": ["wavpct", "wavwpet", "AVpacket", "avwpet", "avpatacket", "AVcpacket", "avpodkt", "avcpst", "avpst", "avcpdr", "avdpacket", "avcpq", "avpoddr", "avpq", "avdacket", "afpacket", "wavwpst", "avpodfx", "avpct", "avpdr", "avdptt", "afcpdr", "avpacket", "avcpet", "afcpkt", "AVpq", "avcpfx", "avdfx", "avptt", "avpodacket", "avdkt", "wavpkt", "wavpet", "avpatq", "avpfx", "wavwpct", "avdpkt", "afpdr", "wavwpkt", "avcpacket", "avcpct", "wavpst", "avcptt", "afcpacket", "avPet", "avwpkt", "afcpfx", "AVpkt", "avdpq", "avwpst", "avcpkt", "AVcptt", "AVptt", "avPst", "avddr", "avwpct", "afpkt", "avpattt", "avpatkt", "avPct", "avPkt", "AVcpq", "afpfx", "avpet", "AVcpkt"], "buf": ["init", "v", "cv", "text", "db", "txt", "mem", "buff", "cb", "b", "vec", "rb", "read", "box", "cmd", "pkg", "bytes", "t", "bl", "uf", "p", "dat", "buffer", "queue", "window", "Buffer", "h", "img", "rc", "br", "map", "tmp", "cap", "wb", "pb", "ptr", "msg", "raw"], "ctx": ["acl", "nt", "cv", "obj", "cmp", "iac", "conn", "gc", "exec", "unk", "history", "txt", "jp", "iat", "local", "xp", "kl", "wx", "rt", "context", "mem", "timeout", "tx", "cb", "ack", "lc", "loc", "kt", "cmd", "pool", "pkg", "xc", "func", "bc", "act", "cu", "ctl", "ac", "req", "hw", "expr", "comm", "cc", "jac", "cf", "ct", "cp", "crit", "ck", "prefix", "sc", "etc", "sys", "resp", "np", "tmp", "tc", "addr", "tk", "gz", "desc", "utils", "unc", "ctrl", "kw", "abc", "cfg"], "gb": ["gif", " rgb", "cv", " gcc", "gu", "bridge", "args", " gu", "gc", "gs", "Gb", "db", "git", "bf", "sam", "bg", "gd", "gin", "gom", "cb", "tg", "rb", "mb", "hub", "attr", "gio", "pg", "gp", "eb", "bc", "gm", "rg", "uf", "ge", "lib", "yg", "sb", "gow", " GB", "gt", "g", "bb", " gui", "py", "bd", "nb", "sg", "gov", "kb", "storage", "ga", " bu", "global", "tc", "gg", "wb", "GB", "eg", "pb", " rg", " db", "cfg"], "is_pframe": ["is_paFrame", "is_hfram", "is_preframe", "is_pchannel", "is_prefram", "is_cFrame", "is_pfram", "is_hframe", "is_pFrame", "is_paframe", "is_preFrame", "is_prechannel", "is_hFrame", "is_pafram", "is_cframe", "is_hchannel", "is_cchannel"], "height": ["Height", "range", "stroke", "hash", "style", "depth", "window", "id", "capacity", "input", " heights", "y", "w", "history", "host", "level", "resolution", "html", "total", "version", "dimension", "rank", "pi", "hang", "base", "high", "grow", "gh", "docker", "layout", "length", "top", "count", "rows", "bottom", "power", "volume", "shape", "huge", "images", "hi", "http", "buffer", "inches", "visible", "resy", "title", "error", "memory", "radius", "scroll", "ty", "family", "strength", "alpha", "padding", "holes", "ows", "density", "size", "above", "h", "SIZE", "era", "gravity", "angle", "dim", "tight", "port"], "quality": ["command", "priority", "frequency", "Quality", "weight", "confidence", "fficiency", "mode", "channel", "family", "gallery", "quiet", "context", "description", "area", "sequence", "comment", "comments", "metadata", "version", "secure", "qual", "code", "status", "format", "name", "equality", "important", "q", "title", "depth", "equal", "lace", "flags", "type", "xff", "length"], "num_coeffs": ["num_coefos", "num_coffS", "num_coEFFls", "num_coefS", "num_coefficS", "num_coefls", "num_coeffS", "num_coffs", "num_coefs", "num_coefes", "num_coEFFes", "num_coffos", "num_coEFFs", "num_coeffos", "num_coffls", "num_coeffics", "num_coeffes", "num_coeffls", "num_coeffices", "num_coEFFS", "num_coffes", "num_coefficos"], "i": ["qi", "ex", "yi", "ix", "xi", "ami", "b", "ii", "ico", "ip", "ei", "p", "status", "id", "io", "s", "us", "zi", "c", "y", "ind", "set", "I", "n", "json", "ci", "di", "pi", "iu", "fi", "phi", "init", "is", "count", "me", "none", "ij", "print", "f", "ini", "gi", "em", "cli", "sim", "ic", "m", "multi", "chain", " ii", "\u0438", "im", "l", "ia", "j", "index", "si", "v", "in", "li", "ai", "ki", "info", "t", "mi", "o", "g", "ice", "h", "span", "ti", "batch", "x", "it", "ui"]}}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x8(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[2];\n\n    unsigned int flags = 0;\n\n\n\n    /* 2-color encoding for each 4x4 quadrant, or 2-color encoding on\n\n     * either top and bottom or left and right halves */\n\n    CHECK_STREAM_PTR(2);\n\n\n\n    P[0] = *s->stream_ptr++;\n\n    P[1] = *s->stream_ptr++;\n\n\n\n    if (P[0] <= P[1]) {\n\n\n\n        CHECK_STREAM_PTR(14);\n\n        s->stream_ptr -= 2;\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // new values for each 4x4 block\n\n            if (!(y & 3)) {\n\n                P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                flags = bytestream_get_le16(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 1)\n\n                *s->pixel_ptr++ = P[flags & 1];\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n\n\n        /* need 10 more bytes */\n\n        CHECK_STREAM_PTR(10);\n\n\n\n        if (s->stream_ptr[4] <= s->stream_ptr[5]) {\n\n\n\n            flags = bytestream_get_le32(&s->stream_ptr);\n\n\n\n            /* vertical split; left & right halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 16; y++) {\n\n                for (x = 0; x < 4; x++, flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) {\n\n                    s->pixel_ptr -= 8 * s->stride - 4;\n\n                    P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                    flags = bytestream_get_le32(&s->stream_ptr);\n\n                }\n\n            }\n\n\n\n        } else {\n\n\n\n            /* horizontal split; top & bottom halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 8; y++) {\n\n                if (y == 4) {\n\n                    P[0] = *s->stream_ptr++;\n\n                    P[1] = *s->stream_ptr++;\n\n                }\n\n                flags = *s->stream_ptr++ | 0x100;\n\n\n\n                for (; flags != 1; flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->line_inc;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 25448, "substitutes": {"s": ["sv", "ans", "gs", "ms", "changes", "services", "details", "b", "parts", "https", "comments", "p", "e", "aws", "ls", "rs", "as", "conf", "webkit", "us", "als", "i", "sports", "c", "ps", "results", "w", "n", "bis", "ast", "fs", "ns", "ar", "ants", "states", "ts", "se", "ssl", "less", "sb", "ins", "os", "es", "a", "vs", "stats", "sts", "ports", "hs", "is", "f", "ss", "r", "an", "this", "cs", "ats", "http", "m", "comm", "ds", "ares", "tes", "ids", "l", "sys", "sq", "v", "js", "S", "gins", "qs", "t", "ims", "g", "sg", "ess", "h", "acs", "service", "bs", "its"], "x": ["ax", "xes", "xml", "ex", "n", "xx", "on", "crop", "xp", "f", "ix", "wx", "xi", "tx", "step", "X", "z", "ux", "php", "xa", "xxx", "ick", "xf", "xc", "mx", "at", "path", "dx", "ox", "act", "ip", "key", "xt", "el", "lon", "add", "o", "p", "m", "rx", "e", "fx", "g", "ml", "ct", "u", "q", "px", "xd", "att", "h", "lat", "dr", "l", "xy", "mat", "xs", "ord", "i", "j", "index", "w"], "y": ["Y", "yi", "any", "yr", "or", "b", "yy", "my", "e", "p", "iley", "kit", "yt", "axy", "hey", "yet", "vy", "i", "c", "sy", "er", "n", "ly", "wy", "yout", "gy", "html", "lon", "yx", "by", "yes", "ies", "iy", "ys", "cy", "yer", "on", "ot", "z", "xxx", "ey", "ye", "ry", "uy", "year", "oy", "m", "out", "ny", "py", "try", "sys", "xy", "yn", "j", "v", "xx", "scroll", "ty", "ay", "ym", "hot", "t", "key", "ya", "o", "pt", "yl", "no", "h", "yo", "height", "lat", "it", "ch", "sky"], "P": ["AFP", "Y", "GP", "Pay", "SCP", "H", "Query", "PS", "PI", "p", "D", "Other", "N", "O", "List", "LP", "NP", "I", "Part", "R", "L", "Array", "X", "F", "Cache", "Command", "State", "HP", "G", "PD", "PT", "vP", "Pro", "B", "PR", "JP", "Map", "Copy", "J", "PC", "Format", "TP", "Progress", "If", "M", "PE", "SP", "DP", "Ps", "AMP", "Request", "PIN", "C", "V", "A", "Policy", "Q", "BP", "AP", "Message", "PB", "IP", "Port", "MP", "CB", "PK", "All", "S", "Path", "YP", "PP", "PO", "PUT", "T", "PA", "New", "K", "CP", "FP"]}}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "substitutes": {"env": ["sv", "ten", "conn", "estate", "message", "ner", "ec", "erd", "e", "expr", "environment", "kernel", "style", "queue", "te", "window", "here", "console", "En", "entry", "w", "er", "runner", "next", "EN", "Environment", "policy", "var", "manager", "shell", "eng", "dev", "ah", "equ", "vs", "ov", " environment", "start", "buf", "desc", "ptr", "et", "ctx", "context", "event", "query", "see", "hl", "spec", "tern", "buffer", "operator", "worker", "global", "extra", "empty", " Environment", "network", "enc", "v", "enter", "server", "ext", "ee", "disk", "end", "viron", "info", "stack", "code", "en", "esc", "ew", "engine", "ev", "ef", "h", "era", "exc", "err"], "mem_buf": ["mem2buf", "mem_cache", "mem_block", " mem_queue", " mem_uf", "mem_cat", " mem_orig", "mem_orig", "memdbuf", " mem_cat", "memablequeue", " mem_mu", "mem2orig", "mem2bin", " mem_bag", "mem2buffer", "memdcache", "mem_uf", " mem_buffer", "mem__buf", "mem__cur", "mem_buffer", "memablebuf", "memablecomb", " mem_block", "mem64buf", "mem_bin", " mem_comb", "mem64buffer", "memoccur", "mem_queue", "mem_mu", "mem_buff", " mem_cur", "mem__bag", "memocbuf", "mem2buff", "mem64buff", "mem64orig", "mem_bag", " mem_cache", "mem_cur", " mem_bin", "memdcat", "mem2uf", "memocmu", " mem_buff", "mem_comb", "mem__buffer"], "n": ["ren", "nt", "nr", "v", "dn", "count", "conn", " ng", "none", " ni", "na", "nu", "any", "ns", "ne", "tn", "norm", "z", "an", "fn", "names", "nan", "new", " num", "len", "el", "cn", "o", "m", "p", "en", "g", "name", "N", "d", "nw", "ny", "number", "sw", "nb", " fn", "no", " nm", "size", "gn", "ln", "nil", "l", "nn", "nm", "num", "np", "ng", "i", "j", "c", " ns", "sn", "nor", "y", "nc", "un", "all"]}}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 25472, "substitutes": {"s": ["sv", "sis", "gs", "ses", "changes", "services", "sam", "details", "state", "styles", "comments", "p", "status", "ls", "rs", "as", "conf", "als", "sports", "c", "ps", "set", "results", "w", "n", "fs", "ns", "ar", "states", "ts", "se", "less", "sb", "ins", "os", "es", "vs", "stats", "sts", "ports", "settings", "hs", "is", "ss", "r", "spec", "this", "cs", "ats", "space", "m", "ds", "sync", "sys", "sq", "js", "S", "source", "qs", "t", "ims", "g", "sl", "sw", "views", "q", "acs", "bs", "its", "resource", "self"], "full_update": ["full___change", "full_up", "complete_check", "fulllogupdate", "full_buffer", "full__check", "full2update", "fulllogflush", "fulllogbuffer", "full__Update", "fulllogcheck", "fulllyup", "fulllyfail", "full__up", "full_change", "fulllyupdate", "full__fail", "full_edit", "fullvalup", "full__updated", "fulllycheck", "complete_edit", " full__check", "fullvaledit", "fullvalupdate", "complete_flush", "full___check", "complete_up", " full__update", " full_fail", "full_flush", "complete_buffer", "complete_updated", "full_check", "complete_update", " full__up", "full_updated", "complete_Update", "full_Update", "full2up", "full2Update", " full_up", "full___update", "full2updated", "fullvalflush", "full_fail", "full__update", "complete_change", " full_check", " full__fail"], "surface": ["plane", "face", "profile", "client", "source", "f", "manager", "sheet", "cell", "image", "fac", "uf", "display", "buffer", "view", "table", "sur", "window", "tile", "con", "screen", "console", "document", "layout", "ui", "port", "sm"], "cx": ["cpx", "cwd", "pcwd", "tcwd", "pcx", "Cw", "tcx", "Cx", "tcw", "Cpx", "tcpx", "Cwd", "pcw", "pcpx"], "cy": ["scroll", "currency", "ty", "cd", "cb", "cr", "ce", "cor", "wy", "ry", "sty", "cell", "dc", "ico", "center", "my", "cow", "ct", "xy", "cycle", "col", "ht", "cm", "c", "sy", "y", "sky"], "cheight": ["chyight", "schearge", "cheigh", "cearge", "cleck", "chigh", "ricealth", "chealth", "riceck", "chyarge", "chck", "ceights", "ceuth", "cheights", "scheight", "chearge", "chight", "scheights", "chyights", "scheuth", "ceight", "check", "chyuth", "cleight", "clealth", "cleigh", "riceigh", "chalth", "cheuth", "riceight"], "cw": [" cwd", "xx", "cox", "ccwd", "ctwd", "xw", "ccx", "cwp", "cwd", "ccwp", "xow", "cowp", " cwp", "ccw", "cow", "xwd", "cowd", "ccow", "ctw", "ctow", "ctx"], "ch": ["count", "th", "zh", "tch", "channel", "cd", "cb", "chan", "attr", "cs", "ich", "wh", "ach", "ct", "cp", "high", "chip", "cht", "CH", "ech", "col", "ht", "c", "cm", "y"], "cattr": ["lcattr", "Cattr", "Cattribute", "Catt", "lcattribute", "qatt", "lcdata", "cattribute", "lcatt", "qdata", "catt", "qattr", "Cdata", "cdata", "qattribute"], "height": ["Height", "max", "sky", "th", "ty", "history", "zh", "scale", "rows", "bottom", "power", "volume", "stroke", "shape", "huge", "resolution", "hi", "hei", "html", "padding", "sh", "kh", "hash", "wh", "style", "hang", "depth", "window", "high", "size", "density", "capacity", "radius", "row", "gh", "ht", "angle", "dim", "x", "y", "length", "w"], "ch_attr": ["th_att", "ch__attribute", "ch__att", "ch_att", "th_attribute", "ch__attr", "ch__err", "ch_attribute", "th_attr", "ch_err", "th_err"], "cx_min": ["cx_start", "cw_min", "cw_start", "cw_mins", "cw_max", "cx_mins"], "cx_max": ["cx_scale", "cw_total", "cw_ax", "cx_total", "cw_max", "cw_scale", "cx_ax"], "linesize": [" linesiz", "inesizer", "linesizer", " linesized", "linsized", "inesized", "inesiz", "inesize", "linesized", "linsize", "linsizer", " linesizer", "linsiz", "linesiz"], "x_incr": ["x_accrs", "x_acar", "x_acrs", "x_accer", "x_incrs", "x_acer", "x_incar", "x_incer", "x_scrs", "x_scar", "x_acr", "x_accar", "x_scr", "x_scer", "x_accr"], "line": ["limit", "text", "page", "link", "stroke", "lin", "eline", "pipe", "block", "path", "cell", "ine", "draw", "lines", "ln", "column", "position", "l", "color", "row", "edge", "col", "index", "le", "Line"], "line1": ["Line1", "l0", "l2", "link2", "l1", "link0", "Line2", "line2", "line0", "Line0", "link1"], "offset": ["command", "zero", "reset", "append", "origin", "ref", "time", "translation", "e", "off", "style", "tile", "location", "position", "pointer", "encrypted", "attribute", "entry", "adjusted", "set", "output", "tif", "iter", "peer", "op", "iso", "address", "vector", "version", "seek", "pad", "prefix", "field", "start", "layout", "transform", "et", "length", "limit", "usage", "f", "timeout", "event", "OFF", "sample", "coord", "associated", "buffer", "out", "table", "Offset", "option", "error", "flag", "index", "pos", "frequency", "scroll", "frame", "sp", "slot", "item", "info", "shift", "padding", "key", "update", "o", "format", "seed", "trace", "no", "size", "point", "skip"], "fgcol": ["bgCol", "fxcolor", "rgcol", "bgrc", "fxrc", "fgCol", "fxcol", "rgcolor", "rgrc", "rgCol", "fgcolor", "fgrc", "fxCol", "bgcolor"], "bgcol": ["rgcycle", "BGcycle", "BGcol", "rgcol", "bbcol", "BGcolor", "BGchar", "bgcycle", "bgchar", "rgcolor", "bbcolor", "rgchar", "bbcycle", "bbchar", "bgcolor"], "v": ["sv", "data", "cv", "vp", "n", "ve", "video", "qv", "get", "va", "uv", "f", "vm", "r", "b", "vo", "tv", "lv", "iv", "vv", "t", "vector", "vt", "conv", "version", "m", "p", "buffer", "dev", "g", "u", "q", "view", "ev", "size", "value", "vol", "V", "l", "color", "av", "ver", "vc", "i", "j", "c", "inv", "NV", "y", "vi", "vr", "w"], "cursor_offset": ["cursor__ptr", "crow_offset", "cursor__off", "crow_off", "cursor__address", "crow_ptr", "crow_address", "cursor_address", "cursor_off", "cursor__offset"], "d1": ["ds1", "D2", "d0", "D3", "dim3", "dim2", "ds3", "d3", "dim0", "dim1", "D1", "D0", "d2", "ds0", "ds2"], "d": ["n", "dep", "f", "r", "di", "dt", "dc", "t", "du", "dir", "draw", "D", "m", "p", "e", "dimension", "g", "ds", "dist", "depth", "l", "direction", "done", "desc", "c", "dim", "ind"], "src": ["sr", "ser", "scale", "source", "bg", "rt", "inst", "rl", "loc", "trans", "r", "dir", "ins", "sub", "sl", "rs", "sc", "cur", "img", "rc", "st", "sys", "input", "addr", "start", "ptr", "sn", "ind"], "dest": ["iter", "del", "way", "mode", "source", "loc", "pipe", "usr", "origin", "coord", "comment", "dir", "cat", "Dest", "name", "table", "id", "cur", "img", "num", "target", "wb", "desc", "buf", "orig", "prop", "err", "port"], "cursor_ptr": ["cram_ptr", "cram_offset", "cram_pointer", "cursor_addr", "cram_addr", "cursor_pointer"], "font_ptr": ["text_tile", "text_ptr", "fontitypointer", "fontitytile", "text_offset", "fontityoffset", "text_pointer", "font_offset", "font_pointer", "font_tile", "fontityptr"], "font_base": ["fontalspace", "font4base", "font4list", "font___space", " font_list", "font___base", " font_space", "fontalmask", " font_mask", "font2buffer", " font_prefix", "font_bas", "font4bas", "tab_Base", " font_bas", "font___mask", "font2bas", "font2base", "font_Base", "tab_base", "fontalbase", "font_mask", "tab_buffer", "font4prefix", "tab_bas", "font_space", "font_buffer", "font_prefix", "font2Base", "font_list"], "dup9": [" derpwin", " dernp3", "dupp3", " dernp9", " derp7", " dernp7", "duv3", " dernpwin", "dunp9", "duv7", "dunp3", "duppwin", "dunpwin", "dunp7", "dup7", "duv9", "dupp7", "duvwin", "dupp9", " derp3", "dup3", "dupwin", " derp9"], "line_offset": ["line___offset", "line__index", "line_position", "line_set", "line__no", "line__pos", " line_position", "line_no", "line__Offset", "Line_set", "line__offset", "line_pos", "line_Offset", "line_index", " line_no", "Line_pos", "line___index", "Line_position", "Line_index", "Line_offset", "line__position", " line_Offset", "line___position", "line___pos"], "palette": ["plcolor", "polbo", "polette", "plbo", "Palettes", "Palbo", "palcolor", "polettes", "palbo", "polcolor", "plettes", "palettes", "plette", "Palcolor", "Palette"], "ch_attr_ptr": ["ch_attr_pointer", "ch_att_offset", "ch_attr__ptr", "ch_att_ptr", "ch_attr__offset", "ch_att_pointer", "ch_attr__pointer", "ch_attr_offset", "ch_att_addr", "ch_attr_addr", "ch_attr__addr"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492, "substitutes": {"f": ["alf", "df", "v", "fr", "fa", "fs", "file", "fo", "sf", "tf", "r", "b", "F", "fc", "fn", "fw", "lf", "t", "fac", "uf", "rf", "ref", "fm", "fd", "p", "e", "g", "cf", "d", "q", "a", "fb", "af", "fp", "h", "l", "fi", "fe", "fab", "i", "ff", "c", "w"]}}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    return av_read_frame(qc->fmtctx, pkt);\n\n}\n", "idx": 25501, "substitutes": {"s": ["n", "gs", "js", "sa", "ses", "S", "ns", "ss", "b", "z", "ts", "spec", "t", "cs", "ats", "sb", "ins", "p", "comm", "m", "aws", "ds", "q", "os", "a", "sg", "rs", "acs", "h", "as", "sys", "stats", "sts", "i", "c", "sq", "ps", "set"], "pkt": ["packnt", "pnt", "pqt", " pqt", "fct", "facket", "fkt", "ppkt", "Pkt", "pct", " pnt", "ppacket", "packqt", "Pct", "packkt", "Pet", "ppqt", "ppnt", " packet", " pet", "fet", "packet", " pct", "pet", "Packet", "packacket"], "qc": [" qdc", "qdc", "quc", "sqpc", " mypc", "ckpc", " mydc", " myc", "sqsc", "querysc", "ckc", " qcor", "sqci", " mycor", "queryci", "sqc", "querypc", "qusc", " qpc", "ckcor", "qupc", "qcor", "qsc", "quci", "qci", "queryc", "qpc", "ckdc"]}}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n\n                                           const char *devaddr,\n\n                                           const char *opts)\n\n{\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    int type = -1;\n\n    char buf[128];\n\n    PCIBus *bus;\n\n    int devfn;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", opts)) {\n\n        if (!strcmp(buf, \"scsi\"))\n\n            type = IF_SCSI;\n\n        else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 25505, "substitutes": {"mon": ["ann", "dm", "ston", "hog", "mons", "vis", "chron", "conn", "Mon", "gun", "mot", "MON", "sam", "monitor", "net", "mer", "mu", "det", "dom", "mn", "demon", "med", "an", "mx", "tem", "mi", "man", "cat", "annot", "mm", "dat", "wat", "en", "admin", "mut", "san", "mt", "mun", "tom", "von", "mont", "rain", "num", "mat", "monkey", "met", "onet", "msg"], "devaddr": ["evaddr", "deviceaddr", "devAddress", "evid", "deviceid", "devptr", "devaddress", "evname", "developaddress", " devptr", " devadd", "evsrc", "deviceadr", " devid", "privadr", "dessrc", "devname", "developAddress", "evAddress", "privaddress", " devadr", "privaddr", "desname", "evaddress", "devsrc", "evptr", "deviceAddress", "deviceadd", "desptr", "devadr", "devid", " devaddress", "desaddr", "devadd", " devname", "deviceaddress", "privadd", "developaddr", " devsrc"], "opts": ["optals", "OPtr", " opkt", " opsp", "optkt", "opps", " opfs", "opsp", "OPps", "optionsfs", "optps", "OPsp", "opkt", " ops", " optr", "optr", "opters", "ops", "props", "opfs", "OPters", "OPals", " opps", "OPs", "optts", "optionsts", " opters", "optfs", "optionsps", "prots", "prokt", "opttr", "opals", "optsp", "optters", "OPfs", "optionsals", "OPts"], "dev": ["obj", "dd", "conn", " devs", "die", "driver", "any", "tech", "cmd", "iv", "watch", "hw", "sd", "off", "jump", "window", "develop", "att", "def", "des", "conf", "home", "normal", "w", "nt", "er", "db", "DEV", "wd", "var", "di", "dem", "der", "fun", "doc", "pad", "device", "debug", "Dev", "d", "adv", "dis", "ver", "raw", "data", "cam", "del", "ow", "fo", "local", "priv", "tr", "event", "serial", "comment", "out", "ad", "ve", "v", "gu", "dep", "stick", "serv", "valid", "pro", "mem", "go", "den", "info", "env", "vo", "block", "boot", "rent", "ev", "de", " device", "stable", "err"], "dinfo": ["dsinfo", "dresult", "dfo", "diinfo", "sdfo", "linformation", "linfo", "dderror", "difo", "dxti", "binf", "pfo", "dsfo", "vdInfo", "lfo", "pti", "didinfo", "dxinf", " dinformation", "dstate", "pinfo", "derror", "ddinformation", "didresult", "xInfo", " dtype", "djinf", "sdinf", " dno", "fdInfo", "djerror", "dxinfo", "dino", "diter", "pinformation", "ddstate", "xfo", "dti", "deinformation", "fdinfo", "ltype", "Dinformation", "Dinf", "vdresult", "linf", "deinf", "didinformation", "dInfo", "xinf", "xinfo", "lno", "Dfo", "binformation", "dsINFO", "djinfo", "vdinformation", "indti", "ditype", "dtype", "dINFO", "vdinfo", "Dresult", " dINFO", "dditer", "indinf", "indinit", "lInfo", " dfo", "bInfo", " dstate", "Dinfo", "dinformation", "fdinf", " dInfo", "sdinit", "DInfo", " dinf", "dinit", "binfo", "dxfo", "dno", "deinfo", "ddinfo", "piter", "pINFO", "djiter", "dinf", "destate", "pinf", " dinit", "pInfo", "sdinfo", "didInfo", "ddinf", "fdinformation", "indinfo", "indfo"], "buf": [" buffers", "txt", "tx", "buff", "cb", "b", "phy", "box", "cmd", "pg", "pkg", "path", "ref", "off", "queue", "rw", "window", "Buffer", "Buff", "map", "pb", " buffer", "rb", "bytes", "doc", "str", "pad", "eng", " cmd", "cp", "pack", "nm", "addr", "cap", "cfg", "ctx", "raw", "data", "cv", "tr", "pool", "uf", "conv", "comm", "buffer", "cf", "mt", "good", "img", "rc", "tmp", "orig", "proc", "msg", "alloc", "bag", "v", "cache", "mem", "seq", "block", "bc", " buff", "bin", "req", "bh", "aka", "br", "mat", "bs", " b", "batch", "bt", "err"], "bus": ["nt", "Bus", "bridge", "gen", "book", "bug", "machine", "holder", "usb", "util", "db", "loop", "bal", "way", "host", "stick", "disk", "phys", "net", "lock", "buff", "loc", "b", "bid", "box", "hub", "block", "hand", "board", "bill", "bc", "proxy", "boot", "lib", "cus", "mount", "cat", "dir", "chain", "bur", "os", "kit", "bo", "vol", "soc", "sys", "us", " BUS", "bs", "home", "vc", "handle", " buses", "bu", "BUS", "bolt", "root"], "devfn": ["DEVfun", " devFN", "evaddr", " Devfn", "testFN", "testfn", "padln", "linkfn", "linkln", "devnm", "DEVln", "DEVfn", "evFN", "linknn", "evname", "devFN", "deffn", " DevFN", "devname", " Devln", "devsyn", "padfn", "evnm", "devfun", "defaddr", "defnm", " devln", " devfun", "testaddr", "defname", " Devsyn", "devln", " devnn", "DEVnn", "padsyn", "evfn", "evln", "padFN", "devnn", " devname", " devnm", "linkfun", "evsyn"], "scsibus": ["scsisi", " scsic", "scsisu", " scssis", "scsinis", " scssisu", " scssicol", "scssic", " scsicol", "scssisu", " scssic", "scisibus", "scsgisu", "scisis", " scssibus", "scsicol", "sccsisu", " scsis", "scsinicol", " scssisi", "scsinibus", " scsisu", "scssisi", "scssis", "sccsisi", "scisic", "scssicol", "scsic", "scisicol", "scsgibus", "scsgis", "sccsis", "scsgisi", " scsisi", "scsis", "scsinic", "scssibus", "sccsibus"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510, "substitutes": {"eeprom": ["eebrom", "eebprom", "eebram", "eepram", "ceepchrom", "eecdem", "eepdem", "eepom", "eepschrom", "eyprom", "eEPchrom", "meepom", "ceepdem", "eepsom", "eebom", "eEPprom", "ceepprom", "eEPom", "eepprom", "eypdem", "eecrom", "ceEPprom", "meecprom", "peepdem", "eEProm", "ceeprom", "peepsrom", "ceEPdem", "peeprom", "peepsdem", "meepchrom", "eebdem", "meecom", "eEPdem", "eypom", "eebchrom", "ceEProm", "eepsdem", "peepram", "eepsprom", "peepsram", "ceEPchrom", "eEPram", "eepchrom", "eecchrom", "eepsram", "peepsom", "peepom", "eecom", "meeprom", "peepprom", "meepprom", "peepsprom", "eypram", "meecrom", "meecchrom", "eepsrom", "eecprom"]}}
{"project": "qemu", "commit_id": "f3172a0e2e7bd983cada19f11d9bb59400e0dd3d", "target": 0, "func": "static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 25515, "substitutes": {"opaque": ["OPac", "opsi", "ipac", "iopsi", "compque", " opaques", "iopque", "OPaques", "compsi", "compaque", "iplay", "compacity", "iopaque", "opaques", "Opacity", "opacity", " oplay", "Opque", "oplay", "iopacity", "ipaque", "Opsi", " opac", "ipaques", "OPlay", "opque", "OPaque", "opac", "Opaque"], "addr": ["Address", "obj", "src", "arp", "ix", "ret", "tx", "elt", "state", "cmd", "pkg", "ref", "align", "add", "hash", "hw", "expr", "id", "arg", "rs", "np", "map", "type", "alt", "gz", "set", "adr", "db", "offset", "host", "phys", "wd", "var", "arm", "usr", "address", "grad", "act", "arr", "seek", "pad", "inter", "prefix", "nm", "handle", "start", "ptr", "ctx", "data", "args", "rt", "tag", "gate", "attr", "adj", "coord", "ady", "mt", "ad", "dr", "ctr", "ord", "index", "pos", "msg", "lag", "alloc", "v", "res", "urg", "md", "mask", "mem", "ack", "ace", "shift", "req", "dh", "eth", "x", "err"], "value": ["command", "sv", "vp", "max", "weight", "range", "val", "message", "instance", "state", "where", "unknown", "hash", "time", "function", "status", "values", "byte", "position", "now", "type", "attribute", "entry", "set", "w", "result", "json", "peer", "level", "example", "diff", "address", "python", "vector", "save", "total", "version", "fee", "package", "ue", "field", "pair", "length", "raw", "all", "limit", "data", "we", "create", "get", "scale", "power", "distance", "parent", "initial", "see", "description", "null", "current", "sum", "new", "sequence", "sample", "comment", "buffer", "operator", "always", "memory", "unit", "condition", "expression", "index", "widget", "test", "root", "VALUE", "v", "variable", "page", "node", "content", "database", "tv", "key", "bin", "update", "code", "format", "name", "number", "list", "no", "size", "maximum", "height", "Value", "property", "label", "done", "resource", "hello", "port", "password"], "s": ["sv", "sis", "bits", "gs", "ms", "ses", "changes", "services", "sam", "details", "b", "state", "parts", "ops", "comments", "bes", "p", "aws", "ls", "rs", "series", "as", "conf", "als", "i", "ps", "n", "bis", "erences", "fs", "ties", "ns", "states", "ts", "se", "ssl", "less", "sb", "ins", "os", "es", "ies", "vs", "stats", "sts", "hs", "is", "ss", "r", "z", "spec", "cs", "ats", "space", "http", "m", "comm", "ds", "sys", "sn", "sq", "sm", "js", "sp", "S", "qs", "t", "gets", "ims", "sl", "sw", "h", "service", "bs", "its"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_mallocz(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avcodec_get_frame_defaults(frame);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    return frame;\n\n}\n", "idx": 25526, "substitutes": {"frame": ["flow", "data", "request", "we", "cast", "scene", "face", "result", "profile", "me", "fr", "none", "next", "feature", "file", "f", "valid", "frames", "join", "event", "ce", "message", "ace", "instance", "process", "state", "info", "block", "null", "feat", "image", "sequence", "new", "sample", "zone", "component", "draw", "version", "chain", "figure", "line", "cf", "queue", "window", "base", "trace", "role", "error", "ence", "shot", "close", "point", "row", "word", "object", "empty", "entry", "Frame", "all"]}}
{"project": "FFmpeg", "commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "target": 1, "func": "static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n", "idx": 25530, "substitutes": {"dst": [" dput", "dest", "dsbl", "pdsts", "idest", "bdbl", "dbl", "bdsts", "delput", "dspr", "dsts", "pdpr", "delST", "dsst", "pdest", "delst", "bdpr", "bdst", "dpr", " dist", " dest", "delsts", "dsc", "ddest", " dsts", "dST", "Dest", " dST", "pdst", "ddsc", "dist", "ddst", "Dsc", "Dsts", "ddpr", "bdput", "idpr", "bdist", "dput", " dbl", "bdST", "Dst", "idst", "dsist", "idsc", " dpr", "Dpr"], "src": ["via", "dest", "ur", "sr", "in", "ser", "th", "txt", "source", "comp", "inst", "rl", "seq", "hl", "loc", "supp", "fc", "attr", "iv", "bc", "sec", "sh", "conv", "sb", "ins", "str", "sub", "sl", "cc", "syn", "rs", "sc", "cur", "img", "rc", "st", "s", "sys", "ctr", "input", "tmp", "inc", "bs", "usc", "ptr", "sn", "sq", "ind", "raw"], "mask": ["ma", "magic", "cache", "cmp", "result", " flag", "weight", "filter", "lay", "scale", "fix", "level", "Mask", "tag", "black", "lock", "mod", "delay", "ask", "bit", "margin", "hold", "sum", "sign", "fac", "key", "shift", "comment", "match", "gain", "arr", "mac", "sk", "m", "pack", "window", "clear", "miss", "flag", "sc", "perm", "conf", "map", "flags", "label", "type", " masked", "batch", "c", "cm", "set"], "w": ["v", "we", "n", "W", "wr", "max", "wm", "wp", "weight", "aw", "end", "wa", "wx", "wl", "weights", "fw", "win", "m", "wal", "wh", "wi", "nw", "d", "sw", "wcs", "ew", "rw", "window", "wt", "h", "iw", "wk", "wb", "start", "wait", "batch", "x", "y", "kw", "wo"], "acc": ["acl", "rev", "cache", "ca", "cmp", "Acc", "result", "rec", "gc", "conn", "cas", " ACC", "AC", " tc", "ent", "f", "aq", "aaa", "score", "tr", " cc", " accuracy", "attr", "ag", " gain", " nu", "sum", "adj", "func", "bc", "fac", "arr", "comment", "ac", "sc", "gain", "auc", " ac", " accum", "dev", "out", "cc", "fee", "u", "ACC", "enc", "account", "aff", "att", "good", "gam", "rc", "perm", "gn", "CC", "cont", "conf", "uu", "con", "cum", "tc", "inc", "ga", "eff", "alias", "batch", "c", "unc", "err", "xff", " carry"], "i": ["qi", " I", "ms", "ix", "xi", "ii", "oi", "ip", "ei", "p", "status", "id", "io", "record", "zi", "y", "bi", "ind", "I", "ci", "di", "iii", "pi", "iu", "iy", " ti", "phi", "ik", "init", " j", "is", "me", "ij", "print", "ini", "gi", "hi", "em", " bi", "cli", "sim", "ic", "m", "multi", "ri", "chain", " ii", "\u0438", "im", "j", "index", "si", "v", "slice", "li", "ai", "ji", "ki", "info", "mi", " m", "ims", "o", "uli", "list", "uri", "point", "ti", "batch", "x", "it", "asi", "ui"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549, "substitutes": {"base": ["data", "ex", "v", "bas", "eta", "create", "ba", " bases", "bp", "db", "server", "bar", " Base", "bf", "na", "file", "end", "based", "b", "ase", "null", "address", "origin", "ip", "ASE", "bind", "buffer", "name", "Base", "bound", "kit", "id", "site", "cpu", "kb", "use", "sys", "bs", " b", "extra", " BASE", "c", "bu", "network", "bal", "set", "binding"], "env": ["er", "v", "cv", "vp", "obj", "conn", "server", "txt", "jp", "EN", "end", "viron", "net", "context", "eu", "act", "vt", "kh", "ec", "sb", "e", "hw", "code", "dev", "en", "environment", "ah", "org", "nv", "ew", "window", "ev", "gov", "sc", "h", "vs", "pe", "conf", "np", "home", "scope", "ptr", "et", "qt", "vr", "network", "enc", "set", "ctx"], "s": ["sv", "er", "v", "settings", "args", "ex", "is", "hs", "gs", "js", "sa", "ses", "sp", "fs", "S", "sam", "ns", "f", "details", "store", "ss", "b", "r", "ts", "qs", "se", "spec", "ops", "cs", "less", "sh", "ats", "space", "sb", "ins", "o", "p", "comm", "m", "ims", "aws", "sl", "ds", "g", "ls", "properties", "q", "es", "os", "a", "rs", "storage", "h", "vs", "l", "conf", "stats", "sts", "bs", "y", "i", "c", "socket", "sq", "ps", "set"], "iomemtype": ["iomimerpe", "iomemt", "xiemType", "iomemet", "omanomype", "iomhimType", "iomimpe", "iomimerType", "iomimvalue", "iomimertype", "iememType", "iometyty", "iomemetype", "iemempe", "iemimpe", "omanemType", "xiemtype", "iomemvalue", "iomemeType", "omanemtype", "iomympe", "xiimvalue", "iememtypes", "iomymType", "iomimtypes", "omanemype", "iomymtype", "xiemty", "iometyvalue", "iomhimty", "iomomtype", "iomempe", "omanomtype", "iomemeype", "iomomType", "iomEMype", "omanomType", "xiimtype", "iemimtype", "iememtype", "iomomype", "omanomt", "iometyType", "iomimty", "iometytype", "iomimType", "iemimtypes", "omanemt", "iomemty", "iomhimvalue", "iomimertypes", "xiimType", "iomomt", "iomymtypes", "iomemype", "iomemType", "iomEMType", "iomimtype", "iomhimtype", "iemimType", "xiimty", "iomemtypes", "iomEMt", "xiemvalue", "iomEMtype"], "qi": ["gui", "ike", " ki", "oka", " i", "iq", "li", " Ni", "qv", " ni", "eni", "aq", "Si", "qu", "query", "ique", "ku", "squ", "ki", "qs", "dq", " sq", " q", "ii", "cu", "ei", "quer", "ifa", "\u043e", "qa", "afi", "ni", "eas", "cgi", "q", "iza", "IQ", " mi", " si", " MI", "esque", " IQ", "fi", "qq", " pi", " ti", " cu", "i", "ia", "Ni", "sq", " cis", "qt", "si", " fi", "ui"]}}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25550, "substitutes": {"opts": ["opgs", "optgs", "popts", " opt", "opps", "prows", " opttions", "opt", " optds", " optjs", " optrs", "optte", "opstions", "oprs", "synns", " oputs", "optuts", "opttions", "popte", " opjs", "opws", "optns", " opds", "props", "iopws", "syntx", " opter", " opps", " opTS", " opns", "opter", "optts", " opats", "optjs", "popTS", "options", " opws", " opte", "iopts", "opjs", " optter", "opte", "optx", "opsrs", "optrs", "prots", "iopps", "iopt", "opns", "optds", "optter", "opsgs", " optts", "opsts", "optTS", "synuts", " optgs", "popats", "oputs", " optx", "synts", "opats", "opds", "opTS", "optats", "prot", "opttx"], "new_opts": ["newccopTS", "new_synTS", "new_OPs", "newccsynTS", "newccsynts", "newccsyns", "new_proTS", "new_synts", "newccops", "new_OPts", "new_prots", "new_ops", "new_syns", "new_oprs", "newccopts", "newccoprs", "new_OPTS", "new_pros", "new_synrs", "new_OPrs", "new_prors", "new_opTS", "newccsynrs"], "name": ["data", "v", "n", "named", "file", "local", "family", "ns", "net", "common", "parent", "NAME", "ident", "names", "path", "new", "key", "other", "code", "format", "ni", "title", "prefix", "part", "id", "base", "package", "nam", "word", "type", "ame", "alias", "normal", "order", "Name", " Name", "root", "raw"], "vlan": ["svlan", "Vni", "vrLAN", "Vlan", "wireale", " vLAN", "svnet", "plad", " vlad", "vni", "plan", "vlad", " vnet", "vrni", "wireni", "pLAN", "pnet", "vrale", "svLAN", "Vale", "vale", "wirelan", "vnet", "vLAN", "wireLAN", "VLAN", "svlad", "vrlan"], "sock": [" sip", "tip", "vock", "vockets", "voot", "trc", "wsrc", "soot", "src", " soot", "tocks", "slip", "wsocks", " socket", " src", "wsock", "scp", "sncp", "sockets", "vcp", "wsocket", "slocks", "tock", "snoot", "sip", " socks", "socks", " sck", "snock", "slock", " sockets", "sck", " scp", "tck", "socket", "snockets", "slck", "tocket"], "group": ["owner", "v", "user", "way", "groups", "gr", "host", "mask", "file", "driver", "Group", "member", "parent", "tag", "mod", "manager", "folder", "block", "pool", "pg", "pkg", "key", "dir", "coll", "by", "p", "chain", "g", "org", "q", "GROUP", "id", "part", "roup", "size", "band", "global", "back", "module", "field", "handle", "scope", "order"], "port": ["limit", "Port", "ports", "pc", "priority", "pport", "n", "page", " sport", "ort", "file", "print", "room", "pro", "eport", "PORT", "pid", "public", "path", "len", "component", "version", "m", "p", "pt", "line", "queue", "pose", "ORT", "import", "number", "project", "phone", "trace", "size", "position", "pe", "point", "mobile", "pr", "index", "pos", "it", "iot", "length", "export"], "mode": ["command", "md", "oe", "me", "range", "mask", "power", "scale", "pro", "mem", "level", "tag", "MODE", "kind", "mod", "state", "menu", "rate", "where", "version", "ode", "mm", "m", "time", "code", "status", "operator", "pose", "Mode", "mate", "id", "option", "role", "mt", "size", "perm", "model", "direction", "module", "type", "rol", "order", "length"]}}
{"project": "FFmpeg", "commit_id": "f57b00e89749b559da7cd99a4b630c90617e17d4", "target": 1, "func": "static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n\n{\n\n    int i = 0;\n\n    while (ff_id3v2_extra_meta_funcs[i].tag3) {\n\n        if (!memcmp(tag,\n\n                    (isv34 ?\n\n                        ff_id3v2_extra_meta_funcs[i].tag4 :\n\n                        ff_id3v2_extra_meta_funcs[i].tag3),\n\n                    (isv34 ? 4 : 3)))\n\n            return &ff_id3v2_extra_meta_funcs[i];\n\n        i++;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25557, "substitutes": {"tag": ["tags", "data", "bug", "text", "local", "TAG", "product", "var", "reg", "Tag", "bit", "trans", "bad", "attr", "ag", "feat", "t", "key", "cat", "ref", "str", "code", "name", "attribute", "pack", "prefix", "arg", "old", "byte", "mat", "map", "word", "type", "field", "buf", "pet", "term"], "isv34": ["isconv39", "IsV37", "isvol27", "isqv37", "isvol37", "isrev349", "Isv27", "ish349", " isv39", "isv357", "isqv346", "isalv349", "isv349", "isV27", " isv35", "isv35", " isv37", "isrev37", "isV346", "IsV346", "isV39", "isV37", "ish357", "isv39", "isvt39", "isqv34", "isvt35", " isV37", "isrev357", "isV34", "isalrev37", "Isv37", "ish34", "isv346", "isV35", "isconv35", "isV357", "isvt34", "isvol34", "isV349", " isV39", "Isv34", "isv37", "isrev34", "isalrev34", "isconv37", "isalrev357", "isqv27", "isconv34", "isv27", "IsV27", "isalv357", "isalv37", "isvt37", "ish37", "IsV34", "isalv34", " isV34", "isvol346", "isalrev349", " isV35", "Isv346"], "i": ["init", "qi", "v", "to", " j", " iii", "iq", "li", " ni", "ij", "iat", "client", "ix", "xi", "ai", "ini", "gi", "ci", "z", "info", "di", "hi", "at", "ii", "oi", "ip", "mi", " bi", "ei", "conv", "cli", "ic", "sim", "multi", "status", "ui", " ii", "pi", "list", "ori", "id", "\u0438", "im", "uri", "iu", "try", "ish", "iy", "fi", " ti", "err", "ti", "phi", "j", "index", "x", "batch", "stat", "y", "it", "si", "bi", "ind", "I"]}}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}", "idx": 25566, "substitutes": {"buffer_filter": ["buffertprofile", " buffer1cache", "buffertfilter", "buffermatprofile", " buffer_control", "callback_profile", "buffer1context", "buffermatmaster", "bufferthandler", "buffererfilter", " buffer1context", "Buffer_stream", "callback_filter", "buffer_spec", "buffer_ref", "buffermatfilter", " buffer1filter", "buffer_source", "Buffer_filter", "buffer_control", "filter_profile", "bufferwcontext", "bufferwfilter", "filter_filter", "bufferwcache", "buffer_context", "buffermatservice", "bufferermaster", "buffertref", "buffer1filter", " buffer_context", "buffer_stream", "buffererprofile", "callbackmatfilter", "buffer1cache", "Buffer_source", "callbackmatmaster", "buffer_profile", " buffer_cache", "buffer_master", "callback_service", "callbackmatprofile", "bufferwcontrol", " buffer1control", "buffer_service", "callbackmatservice", "buffer_handler", "buffererservice", "callback_master", "filter_handler", "buffer1control", "buffer_cache", "filter_ref", "Buffer_spec"], "picref": ["picadd", " picREF", " picRef", "pictRef", "pictureadd", "picbr", "icreq", "pcRef", "icdef", "picmb", "nicarg", "nicreq", "ericdef", "nicRef", "pictmb", "pinreq", "picreq", "picturereference", "pictureRef", "picreference", "ericmb", "pcreference", "pinRef", "pcbr", " picbr", "nicadd", " picdef", "nicdef", "ericarg", "nicref", "picRef", "picdef", "pinbr", "pictarg", "pictureref", "pcref", "pindef", "pinarg", "ericref", "nicbr", " picadd", "pictref", "picarg", "nicmb", " picreference", "pictREF", "icbr", " picarg", "picREF", "pinREF", "icref", "pinref", "pinreference", "pictdef", "nicreference"], "flags": ["facts", "tags", "args", "settings", "bits", "ports", "acts", "gs", "fields", "ms", "members", "mask", "faces", "details", "kind", "actions", "weights", "ants", "xxx", "ps", "amps", "ts", "parts", "FLAG", "cond", "names", "options", " Flags", "comments", "limits", "uses", "bugs", "features", "posts", "properties", "terms", "locks", "ents", "ensions", "links", "flag", "events", "Flags", "types", "words", "atts", "caps", "lag", "ags"], "c": ["v", "cv", "cache", "cmp", "cl", "ca", "pc", "conn", "co", "gc", "cam", "cd", "f", "config", "comp", "ce", "cb", "lc", "b", "ci", "mc", "fc", "can", "ch", "xc", "bc", "t", "cs", "cu", "dc", "ac", "ec", "ic", "coll", "p", "comm", "m", "g", "cc", "cf", "com", "ct", "cp", "u", "a", "C", "con", "cur", "rc", "l", "cont", "conf", "tc", "col", "cm", "etc", "ctrl", "nc", "enc", "ctx"], "buf": ["data", "v", "cv", "obj", "result", "cam", "iter", "bp", "bar", "next", "txt", "uv", "mem", "nah", "seq", "tx", "tr", "buff", "cb", "rb", "vec", "b", "kw", "alloc", "box", "cmd", "block", "pool", "pkg", "bytes", "bc", "len", "bl", "arr", "uf", "bin", "conv", "ref", "doc", "str", "buffer", "off", "queue", "rw", "bn", "window", "fb", "foo", "Buffer", "img", "Buff", "nm", "np", "br", "tmp", "ctr", "cap", "wb", "batch", "pb", "ptr", "msg", "orig", "prop", "bt", "err", "raw"], "ret": ["txt", "val", "net", "after", "reset", "elt", "state", "cmd", "pas", "len", "deg", "hash", "status", "arg", "value", "att", "def", " RET", "ber", "alt", "nt", "rem", "result", "iter", "det", " Ret", "usr", "fun", "arr", "ft", "str", "Ret", "pret", "RET", "back", "re", "desc", "lit", "rev", "final", "del", "print", "ll", "rt", "rets", "tr", "cert", "ry", "out", "vet", "mt", "flag", "dr", "try", "resp", "cont", "sys", "j", "res", "ter", "ext", "pro", "reg", "at", "t", "gt", "rm", "br", "it", "err"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n", "idx": 25571, "substitutes": {"obj": ["nt", "js", "none", "obs", "ot", "opt", "any", "inst", "ob", "og", "go", "opp", "iso", "oss", "cmd", "utt", "pkg", "act", "oy", "ok", "obb", "o", "bh", "hw", "aco", "pt", "Object", "org", "os", "ck", "imp", "bo", "bj", "Obj", "od", "resp", "xy", "now", "tmp", "bs", "obo", "oj", "mo", "addr", "piece", "object", "onet", "et", "err", "po", "rect", "ctx"], "qs": ["ips", "aus", "vals", "hs", "ues", "ks", "gs", "js", "ms", "eps", "icks", "obs", "fs", "uds", "ns", "qu", "rets", "ems", "ts", "dq", "ics", "cs", "gets", "ats", "ims", "ins", "irs", "qa", "igs", "aws", "ours", "fits", "outs", "ls", "ds", "q", "cks", "acs", "s", "eks", "ques", "ys", "qq", "sts", "bs", "als", "xs", "ads", "GS", "its", "fts", "sq", "csv"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n", "idx": 25574, "substitutes": {"ctx": ["nt", "cv", "cmp", "cl", "conn", "cam", "anc", "ctrl", "txt", "jp", "wx", "context", "timeout", "tx", "cb", "loc", "mk", "kt", "cmd", "pkg", "xc", "func", "bc", "setup", "parents", "ctl", "req", "hw", "cc", "jac", "cf", "ct", "cp", "crit", "ck", "window", "mt", "resp", "conf", "sys", "tmp", "Context", "tc", "xs", "c", "cm", "scope", "etc", "alloc", "kw", "cfg"], "node": ["obj", "max", "link", "or", "instance", "cmd", "tree", "func", "image", "ref", "note", "p", "e", "function", "window", "np", "type", "c", "normal", "nt", "n", "k", "holder", "db", "host", "peer", "se", "pp", "station", "handler", "device", "check", "nn", "num", "addr", "module", "field", "edge", "desc", "data", "master", "local", "f", "parent", "context", "event", "fn", "adj", "hop", "new", "this", "component", "remote", "m", "nw", "view", "worker", "good", "row", "tmp", "index", "proc", "msg", "root", "slave", "via", "cache", "parse", "post", "server", "cd", "info", "cell", "t", "key", "name", "Node", "list", "resource"]}}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578, "substitutes": {"vq": ["svqq", "vqq", "verqq", "fqueue", "vqs", "svqs", "vquant", "svdq", "svg", " vg", "fqs", "svq", "fq", "verquant", "svquant", " vqs", "fg", "svqueue", " vquant", "vg", " vdq", "vqueue", "verdq", " vqq", "vdq", "verq", " vqueue"], "in": [" i", "v", "ex", "pc", "n", "k", " din", "In", " IN", "din", "gin", "isin", "r", "bit", "rin", "sum", "t", "len", "mi", " input", "inf", "req", "ins", "doc", "m", "p", "en", "g", "d", "from", "min", "q", "id", "window", "size", "inn", "h", "s", "l", "input", "i", "c", "x", "inner", "IN", "ind", " inf"], "out": ["nt", "gen", "v", "output", "n", "result", "co", "client", "val", "print", "ent", "net", "ne", "ou", "b", "bit", "bytes", "OUT", "t", "ins", "o", "m", "by", "g", "outs", "Out", "list", "window", "size", "io", "s", "l", "inc", "i", "j", "c", "x", "ch", "set", "w"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "substitutes": {"argc": ["argscs", "Argc", "argsc", "ArgC", "Argcs", "argsC", "argcs", " argcs", "argC", " argC"], "argv": ["argsvs", "argvs", "argsc", "Argc", "argsv", " argm", "Argvs", "Argm", "argm", "Argv", "argsm", " argvs"]}}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583, "substitutes": {"ram_size": [" ram_name", "ram2size", "ram_Size", "ram_addr", "rametmode", "RAM2size", "ram_name", "RAM2SIZE", "RAM_Size", " ram_SIZE", " ram_addr", " ram_mode", "rametSIZE", "ram_mode", "RAM_SIZE", "ram2SIZE", "ram2Size", "ram2name", "RAM2Size", "ram_space", "rametsize", "rametaddr", "RAM_size", " ram_space", "ram2space", "ram_SIZE", "RAM2name", "RAM_name"], "boot_device": ["boot_buffer", "bootlybuffer", "cpu_device", "cpu_node", "cpu_buffer", "cpu_dev", "boot_node", "bootlydevice", "bootlydev", "bootlynode", "boot_dev"], "kernel_filename": ["kernelletfilename", "kernel___filename", "kernel___binary", "kernel_path", "kernel_module", "kernel_binary", " kernel_file", " kernel_path", " kernelablemodule", "kernelablefilename", " kernelablefile", "kernelablemodule", " kernelablefilename", "kernel_network", "kernelletpath", " kernel_network", "kernelletfile", " kernel_binary", "kernel___module", " kernel_module", "kernelletnetwork", "kernel___file", "kernel_file", "kernelablefile", "kernelablebinary", " kernelablebinary"], "kernel_cmdline": ["kernel_calllines", "kernel_cryptcode", "kernel_callLine", "kernel_cmdcall", "kernel_callline", "kernel_cmdLine", "kernel_commandcode", "kernel_mdLine", "kernel_mdlines", "kernel_commandLine", "kernel_advline", "kernel_commandline", "kernel_cryptcall", "kernel_commandcall", "kernel_advcode", "kernel_commandlines", "kernel_cmdcode", "kernel_mdline", "kernel_cmdlines", "kernel_cryptline", "kernel_advcall"], "initrd_filename": ["initrd_Filename", "initrd_file", "initrb_Filename", "initdr_file", "initdretyfilename", "initrd_location", "initrdetyfilename", "initdr_filename", "initrdetydll", "initdretydll", "initrd_fn", "initdretylocation", "initdr_location", "initrdetylocation", "initrb_fn", "initrdetyfile", "initdretyfile", "initrd_dll", "initrb_file", "initdr_dll", "initrb_filename"], "cpu_model": ["clock_controller", "cpuponetwork", "cpu_models", "cpupomodel", "clock_models", "cpu1controller", "cp_model", "cp_link", "cpu1model", "cpu_device", "cp_device", "cpupocontroller", "cpu2device", "clock_model", "cpu_link", "cpu_controller", "cpu_network", "cpu2link", "cpu2model", "cpupomodels", "cpu1models", "cpu1network", "clock_network", "cpu2models", "cp_models"], "pci_enabled": ["pico_Enabled", "pci2enabled", "pci2enable", "pcgi_enable", "pico_enabled", "pcci_Enabled", "pcgi_enabled", "pci_status", "pci_checked", "pci_Enabled", "pico_enable", "pci_enable", "pico_activated", "pcgi_checked", "pcci_enable", "pcgi_status", "pci2Enabled", "pci_activated", "pcci_enabled"], "kvmclock_enabled": ["kvmsync_enable", "kvmclock_required", "kvmsync_Enabled", "kvmclock2enabled", "kvmlock_required", "kvmclock2enable", "kvmclock_enable", "kvmclock2Enabled", "kvmlock_enabled", "kvmsync_enabled", "kvmclock2created", "kvmsync_created", "kvmclock_Enabled", "kvmlock_Enabled", "kvmclock_created", "kvmlock_created"], "i": ["v", " j", " I", "f", "ci", "di", "ii", "t", "ip", " bi", "o", "m", "p", "e", " ii", "pi", " v", "a", "l", "fi", " pi", "phi", "j", "c", "ia", "si", "bi", "I"], "below_4g_mem_size": ["below_4g_mem2size", "below_4g_mem_Size", "below_4g_Mem_Size", "below_4g_mem2name", "below_4g_mem_name", "below_4g_Mem_name", "below_4g_mem2Size", "below_4g_Mem_size", "below_4g_mem_SIZE"], "above_4g_mem_size": ["above_4g_mem_Size", "above_4g_mem2Size", "above_4g_mem_sum", "above_4g_mem2sum", "above_4g_mem2size"], "pci_bus": ["pci__board", "pki__home", "pki_state", "pci__BUS", "pki_BUS", "pki_box", "pki__BUS", "pci_box", "pci___home", "pci___board", "pki__bus", "pci__bus", "pci__home", "pki__boot", "pki_bus", "pki_boot", "pci__boot", "pki_board", "pci_home", "pki__board", "pci_BUS", "pki_home", "pci___box", "pci_boot", "pci__state", "pci__box", "pci_state", "pki__box", "pci___bus", "pci_board"], "i440fx_state": ["i440fx2store", "i440fx_status", "i440fx2cache", "i440px_cache", "i440ty_store", "i440fx_new", "i440fx___store", "i440fx___state", "i440fx___new", "i440fx___status", "i440fx_store", "i440fx2state", "i440px_state", "i440px_store", "i440ty_new", "i440fx_cache", "i440fx2status", "i440ty_state", "i440ty_status", "i440px_status"], "cpu_irq": ["cpu_erql", "cpu_virqs", "cpu_rinql", "cpu_mirql", "cpu_pirqs", "cpu_pirity", "cpu_mirity", "cpu_rinq", "cpu_irp", "cpu_pirp", "cpu_irQ", "cpu__pirQ", "cpu__irq", "cpu_rinqq", "cpu_virq", "cpu__irp", "cpu_irtq", "cpu__pirp", "cpu_irtity", "cpu_mirqs", "cpu_erqq", "cpu__irqs", "cpu_irql", "cpu_erqs", "cpu_irity", "cpu_erq", "cpu_pirq", "cpu_irqs", "cpu_pirQ", "cpu_ireQ", "cpu_irqq", "cpu_ireq", "cpu_irep", "cpu__irQ", "cpu_irtqs", "cpu_virp", "cpu_rinqs", "cpu_mirqq", "cpu__pirq", "cpu_mirq", "cpu_virQ", "cpu__pirqs", "cpu_ireqs"], "isa_irq": ["isa_mirque", "isa_pirch", "isa_ique", "isa_pirq", "isa_irch", "isa_iq", "isa_irmQ", "isa_iterque", "isa_iterqq", "isa_irQ", "isa_mirch", "isa_pirque", "isa_ird", "isa_drq", "isa_mirqq", "isa_irqq", "isa_mirqs", "isa_drqs", "isa_irque", "isa_pirqs", "isa_virQ", "isa_irmqs", "isa_pird", "isa_irmd", "isa_irqs", "isa_ich", "isa_vird", "isa_iqs", "isa_iterqs", "isa_iterq", "isa_drqq", "isa_virqs", "isa_mirq", "isa_irmq", "isa_virq", "isa_drque", "isa_pirQ"], "i8259": [" i8265", " i4259", " i4260", "i805254", "pi8258", "mi8259", "i810259", "i4258", "i4249", " i8285", "mi8249", "i810260", "mi8260", "i8269", "i9249", "i810258", "mi83249", "i81024", "i8151024", "i8260", "i810249", "i805249", "i8249", " i4265", "i9259", "i4265", "i8285", "i8101024", "i805259", "i83249", "i815258", "pi4249", "i83269", "pi4258", "i815259", "mi8269", "i4259", "i83259", "i12260", "i9254", "pi8254", " i8260", "i8254", "i815249", "pi8259", "i810285", "i12259", "pi81024", "pi4259", "i4269", "pi8249", "mi83269", "pi4254", "i12265", "i4254", "i83260", " i4285", "i810265", "i9269", "i9258", "i12285", "i4260", "mi83259", "mi83260", "i8265", "i4285", "i805258", "i8258", "i9260"], "cmos_s3": ["cmos_snd", "cmos_sin3", "cmos_r3", "cmos_sin2", "cmos2sinnd", "cmos2snd", "cmos_tip", "cmos_sinnd", "cmos_t3", "cmos2sin2", "cmos_sinip", "cmos_s2", "cmos2sinip", "cmos_t2", "cmos_rnd", "cmos2sin3", "cmos_tnd", "cmos_r2", "cmos2s2", "cmos_rip", "cmos_sip", "cmos2sip", "cmos2s3"], "smi_irq": ["smi_mirq", "smi__mirq", "smi_irQ", "smi_mirqs", "smi__irQ", "smi_arq", "smi__irqs", "smi__mirqs", "smi_mirch", "smi_pirqs", "smi__irq", "smi_mirQ", "smi_irch", "smi_irqs", "smi_arqs", "smi_arQ", "smi__mirch", "smi_arch", "smi__mirQ", "smi_pirQ", "smi_pirq", "smi__irch", "smi_pirch"], "isa_irq_state": ["isa_irq2handle", "isa_irq____new", "isa_irz_new", "isa_iru_out", "isa_irq_State", "isa_irr2stat", "isa_irqq_start", "isa_irq____state", "isa_iru_state", "isa_irq2start", "isa_irq_stat", "isa_irr_stat", "isa_irz_info", "isa_irq___start", "isa_irq2stat", "isa_irz_stat", "isa_irq_area", "isa_irq_new", "isa_irq_cache", "isa_irq_handler", "isa_irr2state", "isa_irqq_state", "isa_irq___handle", "isa_irqq_stat", "isa_irq_init", "isa_irq_start", "isa_iru_info", "isa_irqq_handler", "isa_irq_info", "isa_irr_state", "isa_irr_handle", "isa_irz_cache", "isa_irq_out", "isa_irq___state", "isa_iru_init", "isa_irr_start", "isa_irq___stat", "isa_irr2handle", "isa_irqq_info", "isa_irq____cache", "isa_irqq_area", "isa_irr2start", "isa_irq2state", "isa_irq_handle", "isa_irz_State", "isa_irz_state"], "hd": ["dm", "hs", "dn", "dd", "cd", "hid", "dylib", "uda", "dri", "ha", "vd", "ded", "izon", "him", "du", "hard", "hw", "ds", "ah", "dh", "bd", "rh", "hz", "hp", "h", "ld", "dr", "ht", "HD"], "MAX_IDE_BUS": ["MAX_IDELEBUS", "MAX_IDE_USB", "MAX_IDE_BS", "MAX_IDES_OUT", "MAX_IDEONUSB", "MAX_IDES_USB", "MAX_IDELEOUT", "MAX_IDES_PATH", "MAX_IDE_US", "MAX_IDE_OUT", "MAX_IDES_US", "MAX_IDEONBUS", "MAX_IDEONUS", "MAX_IDELEPATH", "MAX_IDELEBS", "MAX_IDES_BS", "MAX_IDE_PATH", "MAX_IDES_BUS"], "MAX_IDE_DEVS": ["MAX_IDE_PDKS", "MAX_IDE_DRPS", "MAX_IDE_DISPS", "MAX_IDE_DISKS", "MAX_IDE_DEKS", "MAX_IDE_PDVICE", "MAX_IDE_DISVS", "MAX_IDE_DISVICE", "MAX_IDE_DRVS", "MAX_IDE_DEPS", "MAX_IDE_DRVICE", "MAX_IDE_DEVICE", "MAX_IDE_PDPS", "MAX_IDE_PDVS", "MAX_IDE_DRKS"], "floppy_controller": ["flppy_ctrl", "floppy_model", "flppy_model", "floppyitymodel", "flppy_controller", "floppy_ctrl", "floppy_driver", "floppyityctrl", "flppy_driver", "floppyitycontroller", "floppyitydriver"], "idebus": ["IDEBUS", "corebus", "idestate", "ridestate", "rideBUS", "coreBus", "coreBUS", "ideBus", "IDEBus", "IDEstate", "corestate", "rideBus", "ridebus", "IDEbus", "ideBUS"], "rtc_state": ["rtf_data", "rtc_port", "rtc_data", "rtc_info", "rtf_info", "rtc__data", "rtf_state", "rtc__port", "rtc__state", "rtc__info", "rtf_port"]}}
{"project": "FFmpeg", "commit_id": "8be23d424feea50d4ee892cdbdd6abd9a807709f", "target": 0, "func": "static av_cold int roq_decode_init(AVCodecContext *avctx)\n\n{\n\n    RoqContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n\n\n    if (avctx->width % 16 || avctx->height % 16) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Dimensions must be a multiple of 16\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    s->last_frame    = av_frame_alloc();\n\n    s->current_frame = av_frame_alloc();\n\n    if (!s->current_frame || !s->last_frame) {\n\n        av_frame_free(&s->current_frame);\n\n        av_frame_free(&s->last_frame);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n\n\n\n    return 0;\n\n}\n", "idx": 25593, "substitutes": {"avctx": ["avejac", " avcc", "cvctx", "avaddr", "vartimeout", "avwcs", "ajtx", "avhandle", "devaddr", "aveclient", "averaddr", "Avctx", "avecontext", "devtimeout", "apttimeout", "ajcam", "avertx", "avcam", "apttx", "aptaddr", "avgc", "varhandle", "averwcs", "apcontext", " avtx", "iverctx", "apclient", "afcfg", "ajctl", "avetx", "avcpu", "devtx", "cvtmp", "avct", "avetimeout", "avtimeout", "abcontext", "avegc", "wavcfg", "wavtx", "avtmp", " avcontext", "avtx", "avctl", "Avconfig", "abctx", "wavctx", "avecf", "avconfig", "avect", "avecpu", "abtx", "aftx", "avehandle", "devctx", "avcontext", "afclient", "wavcc", "afctx", "Avtx", "ajwcs", " avct", "cvtx", " avconfig", "aptx", " avjac", "ajcf", "averctl", "ajgc", "abjac", "avercam", "wavconfig", "cvcontext", "avercpu", "varcpu", "averhandle", "afcontext", "varctx", "avcf", "averctx", " avcfg", " avtmp", " avcam", "avertimeout", "afcc", "avetmp", "aveconfig", "aptctx", "ivercontext", "avcfg", "avectl", "iverct", "iverconfig", "avcc", "avergc", "avercf", "avjac", "wavcontext", "avclient", "ajctx", " avwcs", "Avcontext", "apctx", "avectx"], "s": ["sv", "v", "ports", "hs", "is", "gs", "js", "ms", "ses", "ers", "changes", "eps", "services", "S", "fs", "ns", "details", "sac", "ss", "states", "z", "pers", "ts", "qs", "has", "parts", "spec", "ops", "cs", "less", "ats", "gets", "sb", "ins", "ims", "p", "comm", "aws", "ds", "g", "ls", "tests", "sw", "os", "scl", "es", "rs", "ags", "acs", "vs", "as", "l", "als", "bs", "sts", "stats", "its", "ass", "c", "sports", "aunts", "sq", "ps", "set"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602, "substitutes": {"dev": ["Device", "nt", "v", "usb", "conn", "cam", "raw", "DEV", "devices", "hid", "priv", "mem", "pro", "phy", "an", "cmd", "t", "ac", "scan", "hw", "pad", "device", "ds", "Dev", "ach", "os", "ev", "ad", "app", "att", "h", "def", "des", " device", "home", "av", "buf", "proc", "test", "ver", "w"], "p": ["data", "command", "v", "ap", "pc", "vp", "tp", "pre", "dp", "bp", "pa", "wp", "post", "lp", "jp", "sp", "power", "xp", "f", "op", "b", "phy", "pp", "pkg", "at", "t", "ip", "pat", "press", "o", "m", "e", "ping", "pt", "g", "pad", "P", "d", "cp", "q", "rep", "part", "up", "app", "fp", "att", "prev", "pe", "resp", "l", "np", "br", "i", "pb", "c", "j", "y", "ps", "port", "w"], "s": ["sv", "tags", "sis", "ans", "gs", "ms", "ses", "changes", "sam", "b", "state", "bes", "aws", "ls", "rs", "app", "des", "as", "conf", "session", "i", "c", "y", "ps", "set", "w", "n", "fs", "params", "ns", "states", "ts", "has", "ssl", "less", "sb", "ins", "os", "es", "vs", "num", "stats", "sts", "args", "hs", "is", "ss", "r", "an", "cs", "ats", "space", "m", "comm", "ds", "l", "sys", "j", "sq", "v", "res", "js", "sp", "S", "serv", "go", "t", "ims", "g", "sl", "sw", "ess", "h", "bs", "its", "self"]}}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 25619, "substitutes": {"cpu": ["linux", "pc", "conn", "gc", "ctx", "jp", "nu", "phys", "mem", "xi", "pid", "process", "processor", "gp", "pu", "cu", "boot", "cli", "gpu", "hw", "cp", "sys", "chip", "np", "CPU", "proc", "prof", "core"], "spapr": [" spipR", " spaprs", " spipr", "spippr", "spopr", " spopro", "spaprs", "spaprc", "spipr", "spipprar", "spopir", " spapir", "spapsir", "spaptrc", "spaptr", "spoprs", "spapro", "sprapr", " spapro", "spapsr", "sprapir", "spapsro", "spippR", "spaptR", " spaprc", " spiprc", " spapR", "spapir", "spaptrar", " spiprar", "spipprc", " spaprar", "spapsrs", "spapR", "spiprc", "sprapro", "spipR", "spaprar", " spopir", "spiprar", "spopro", " spoprs", "spraprs", " spopr"], "token": ["init", "Token", "next", "json", "ens", "rt", "ns", "tn", "reset", "ets", "kt", "ts", "fn", "info", "oken", "tree", "vt", "ok", " tokens", "rf", "hat", "os", "secret", "mt", "wt", "target", "ti"], "nargs": [" narg", "pargs", "Narg", "pparams", "narg", "prets", " nparams", "Nret", "Nrets", "tret", "nparams", "targ", "targs", " nrets", "parg", "Nparams", "Nargs", "nrets", "trets"], "args": ["vals", "bits", "settings", "ras", "ars", "res", "gs", "js", "fields", "issues", "arms", "ots", "params", "rows", "ns", "states", "ts", "parts", "names", "ires", "cs", "gets", "arr", "limits", "ins", "aws", "values", "terms", "arg", "rs", "uments", "s", "stats", "flags", "Args", "atts", "its", "xs", "uns", "mus", "GS", "ags"], "nret": [" narg", "NRET", "Narg", "dret", "narg", "nalt", "NRet", "Nret", "cnargs", "Nrets", " nRet", "srets", "dRET", "nRET", "nRet", "pnret", "nback", " nback", " nrets", "pnrets", "sargs", "cnarg", "sarg", "Nalt", "pnback", "dRet", "cnalt", "Nargs", "nrets", " nRET", " nalt", "drets", "pnalt", "Nback", "sret", "cnret"], "rets": ["ards", "ails", "vals", "aus", "bits", "ces", "res", "gs", "ses", "els", "atives", "runs", "fs", "rows", "uds", "aux", "ns", "tn", "ants", "ets", "states", "tails", "ocks", "ts", "qs", "uts", "ires", "gets", "ats", "urs", "aws", "ds", "fits", "outs", "tests", "ls", "utes", "tes", "rs", "unts", "lists", "RET", "events", "acs", "uments", "sets", "des", "ints", "als", "sts", "flags", "its", "uns", "fts", "finals", "results"], "sphb": ["smphr", " smphu", "smphc", "sphba", "saphu", "sphrb", "sphr", " sphbb", "smphl", " sphl", "sphyb", " sphr", "spscp", "sphiba", "smphba", "sppr", "sphyu", "smphrb", "spscb", " smphr", " sphu", "sfxc", "sphp", " smpha", " smphb", "sphbb", " smphrb", " smphl", " sphc", "smphb", "sphl", "sphya", "saphbb", " smphp", "sphyr", "sshl", " spha", "smphbb", "sshc", "sfxl", "sphu", "smphu", "smpha", "sfxr", "smphp", "sphybb", " sphba", "sppb", "saphb", "sphibb", "spscbb", "sphc", "sphib", "spscba", " sphrb", "sshb", "spha", "skhrb", " sphp", "sppbb", "skhb", "skhbb", " smphc", "sphyrb", "sphip", "sfxb", "sshr", " smphbb", "sapha", " smphba"], "spc": ["splpc", " spcs", " spcu", "spcr", "apf", "apunc", "splC", "mpcu", "spepc", "ppca", "shci", "apcu", "ppcu", "aspc", "splc", " spsc", "apci", "speunc", " spunc", "aspca", "spec", "mpcr", "ppcr", "ppc", " spci", "speC", " spf", "spsc", "apcs", "shc", "spf", "apsc", "specu", "spcu", "shf", "mpc", "apc", " sppc", "shsc", "spci", " spC", "spunc", "spcs", "mpca", "spC", "spca", "aspcu", "splunc", "aspcr", "specs", "sppc"], "buid": ["gui", "suID", "luID", "guid", "cuID", " buID", "lui", "cuId", " buids", "bui", "luid", "guID", "buids", "uuids", "uuId", "buId", "suId", "uuID", "cuids", "buID", "guId", " buId", "uuid", "suid", "cuid", "luId", " bui"], "state": ["ose", "data", "n", "is", "ate", "result", "length", "ort", "node", "local", "tag", "event", "store", "lock", "states", "r", "reg", "reset", "t", "len", "key", "State", "STATE", "status", "out", "name", "fire", "style", "id", "secret", "trust", "error", "size", "value", "un", "unit", "st", "row", "target", "type", "start", "i", "index", "resource", "test", "err", "port", "set"], "ret": ["rev", "nt", "res", "nl", "result", "ert", "get", "jp", "val", "rt", "net", "ne", "tn", "mem", "tr", "det", "reply", "reset", "nat", "elt", "ts", "tech", "dt", "len", "vt", "ref", "ft", "gt", "Ret", "out", "status", "secret", "arg", "mt", "RET", "error", "flag", "def", "resp", "back", "re", "alt", "ptr", "rest", "success", "it", "err", "lit"]}}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n", "idx": 25636, "substitutes": {"value": ["data", "VALUE", "v", "sv", "vp", "create", "max", "zero", "scale", "val", "node", " compute", "instance", "see", "set", "current", "tv", "new", "t", "key", "total", "bin", "unknown", "p", "hw", "buffer", "name", "values", "currently", "fee", "number", "min", "size", "eth", "byte", "unit", "Value", "now", "ue", "type", "expression", "index", "hello", "attribute", "test", "length", "w"], "errp": ["timerp", " Errpr", " ErrP", "sprpd", "timerpd", "usrP", " errP", " Errp", "sprpr", " Errpd", " errphp", "usrp", "timerpr", " errpa", "errphp", "sprp", " Errpa", "errP", " Errlp", "sprlp", "errpa", "errpr", "errpd", "errlp", "timerlp", "usrpa", "usrphp", " Errphp"], "s": [" self", "sv", "sis", "v", "n", "is", "hs", "gs", "ms", "ses", "S", "fs", "ss", "r", "b", "ts", "state", "t", "ssl", "sb", "o", "p", "m", "e", "g", "sl", "ls", "es", "a", "rs", "ess", " ss", "st", "sys", "mos", "bs", "i", "c", "sq", "ps"]}}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n", "idx": 25669, "substitutes": {"path": ["dest", "v", "text", "dn", "th", "next", "raw", "anc", "self", "file", "local", "link", "config", "context", "join", "full", "Path", "r", "message", "pid", "cmd", "pkg", "current", "t", "where", "dir", "pat", "relative", "template", "time", "chain", "m", "pt", "name", "format", "root", "d", "route", "cp", "prefix", "package", "part", "error", "value", "h", "point", "pointer", "pattern", "progress", "PATH", "skip", "phi", "c", "transform", "x", "ath", "stat", "php", "empty", "temp", "index", "port", "length", "w"], "p": ["v", "ap", "pc", "vp", "n", "pre", "tp", "pard", "bp", "pa", "post", "wp", "lp", "jp", "sp", "pl", "pro", "r", "b", "pers", "pn", "pid", "pp", "pkg", "t", "ip", "pat", "m", "ping", "pt", "g", "pad", "P", "d", "cp", "rep", "q", "a", "part", "fp", "h", "pe", "point", "pointer", "np", "l", "y", "i", "pb", "c", "j", "pr", "pos", "ep", "php", "ps", "port"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n", "idx": 25670, "substitutes": {"ov": ["osh", "v", "vp", "oos", "oc", "offic", "ow", "obs", "uv", "fo", "iov", "ocr", "anon", "og", "ob", "hov", "nov", "oooo", "ove", "akov", "oss", "env", "ouch", "vo", "ware", "vv", "iv", "oh", "auth", " cov", "oid", "o", "OV", "ovan", "forge", "sov", "dev", "off", "oops", "nv", "liv", "oo", "aven", "oval", "ev", "always", "gov", "ova", "rov", "von", "od", "own", "vs", "once", "van", "av", "oa", "lov", "roc", "ovi", "vr", "kov"], "iter": ["init", "er", "v", "gen", "ir", "n", "ait", "enter", "former", "star", "ter", "ser", "master", "loop", "actor", "th", "next", "oder", "ator", "item", "tr", "seq", "reader", "r", "writer", "t", "ip", "coll", "ic", "expr", "chain", "buffer", "str", "inter", "iterator", "q", "list", "iver", " iterator", "h", "cer", "dr", "rer", "walker", "its", "Iter", "ptr", "ipper", "it", "inner", "est"], "any": ["never", "er", "args", "n", "gc", "none", "native", "ast", "each", "ns", "parent", "optional", "or", "reg", "can", "null", "current", "at", "new", "t", "this", "cs", "known", "arr", "other", "unknown", "by", "m", "Any", "g", "q", "must", "either", " ANY", "some", "ANY", "as", "sys", "same", "nas", "x", "empty", "maybe", "all", "raw"], "depth": ["priority", "tip", "dep", "conn", "roots", "driver", "scale", "ns", "level", "context", "dq", "tree", "path", "Depth", "dc", "stack", "debug", "rank", "DEP", "dr", "progress", "deep", "tips", "scope", "lvl", "ptr", "dim", "root"], "first": ["top", "pre", "result", "star", "util", "fr", "final", "next", "only", "First", "primary", "f", "initial", "after", "op", "full", "quick", "fc", "info", "current", "second", "new", "before", "unknown", "str", "header", "format", "name", "with", "fresh", "last", "must", "front", "part", "prev", "latest", "st", "use", "start", "head", "transform", "stat", "self", "all"]}}
{"project": "FFmpeg", "commit_id": "204cb29b3c84a74cbcd059d353c70c8bdc567d98", "target": 1, "func": "static av_cold int shorten_decode_close(AVCodecContext *avctx)\n\n{\n\n    ShortenContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < s->channels; i++) {\n\n        s->decoded[i] -= s->nwrap;\n\n        av_freep(&s->decoded[i]);\n\n        av_freep(&s->offset[i]);\n\n    }\n\n    av_freep(&s->bitstream);\n\n    av_freep(&s->coeffs);\n\n\n\n    return 0;\n\n}\n", "idx": 25672, "substitutes": {"avctx": ["AVtx", "avcontext", " avtx", "AVctx", "AVcontext", "Avtx", "camtx", "avectl", "avetx", "camctx", "avjac", "Avctx", "avecontext", " avjac", "Avctl", "avectx", "camjac", "AVjac", " avcontext", "Avcontext", " avctl", "avtx", "avctl", "camcontext"], "s": ["sv", "v", "bits", "settings", "hs", "is", "gs", "js", "ms", "bis", "S", "sam", "ns", "f", "ss", "b", "z", "ts", "qs", "state", "ops", "spec", "t", "cs", "less", "ats", "space", "sb", "p", "comm", "aws", "ds", "ls", "q", "os", "scl", "so", "rs", "sc", "ess", "h", "vs", "l", "sys", "stats", "bs", "sts", "als", "its", "sports", "c", "stat", "sq", "ps", "self", "sm", "w"], "i": ["qi", "ex", " I", "ms", " iter", "ix", "xi", "ami", "ii", "ip", "ei", "id", "io", "us", "zi", "y", "bi", "ind", "I", " ki", " li", "ci", " multi", "di", "u", "pi", " mi", "iu", "fi", " ti", "phi", " wi", "init", " j", "is", "me", "ij", "print", "ini", "gi", "hi", " bi", "remote", "sim", "ic", "m", "multi", "ri", "chain", " ii", " si", "\u0438", "im", " pi", " index", "j", "index", "si", "v", "gu", "li", " ni", "ai", "ji", "ki", "info", "t", "mi", "key", "mount", " m", "ims", "g", "q", " di", "uri", "h", "point", "ti", "batch", "x", "it", "ui"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,\n\n                                         src - (stride * 2),\n\n                                         stride, dst, stride);\n\n}\n", "idx": 25693, "substitutes": {"dst": [" dput", "dest", "dsput", " dsrc", "dsst", " Dsrc", "dsdest", " Dst", " dest", "sdest", "ddest", "Dsrc", "Dest", " Dput", " Dest", "sput", "Dput", "dsest", "dput", " ddest", "Dst", "sst", "dsrc", "sest"], "src": ["dest", "ipl", "ur", "sr", "in", "ser", "txt", "source", "rt", "comp", "inst", "rl", "gin", "loc", "r", "b", "supp", "rin", "iv", "bc", "RC", "sec", "req", "sb", "ins", "str", "sub", "sl", "dist", "cc", "imp", "rs", "sc", "cur", "img", "rc", "st", "s", "sys", "input", "ctr", "usc", "desc", "ptr", "sn", "ind", "length"], "stride": ["shrope", "STRend", "shrend", "strride", "strime", "strape", "constend", "shride", "strope", "Strride", "stape", " strape", " strend", "tsider", "privack", "STRope", " strIDE", "strido", "privido", "tride", "tsride", "strend", "stide", "STRido", "constride", "Strend", "StrIDE", "shrride", "Strape", " strider", "STRide", "constope", " strack", "constide", "Strope", "Stride", " strope", "privide", " strido", "tside", "trime", " strride", " strime", "strider", "STRack", "strack", "stIDE", "trider", "trride", "STRride", "privride", "tsime", "strIDE"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    uint32_t val;\n\n    int index;\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return 0;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    index = (addr >> 4) & 0xff;\n\n    switch(index) {\n\n    case 0x02: /* id */\n\n        val = s->id << 24;\n\n        break;\n\n    case 0x03: /* version */\n\n        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */\n\n        break;\n\n    case 0x08:\n\n        apic_sync_vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n", "idx": 25704, "substitutes": {"opaque": ["ospcode", "appcode", "ospcache", "appatile", "opatile", "occache", "ospatile", "appaque", "ocaque", "occode", "ospaque", "ocatile", "opcache", "appcache", "opcode"], "addr": ["Address", "v", "obj", "work", "adr", "on", "offset", "host", "link", "src", "ix", "tx", "store", "ace", "loc", "cmd", "info", "block", "address", "at", "t", "len", "ip", "ref", "align", "add", "hash", "hw", "pad", "dh", "inter", " address", "prefix", "id", "ad", "sys", "alias", "x", "ptr", "alloc", "set", "ctx"], "d": ["dm", "did", "v", "n", "dn", "dd", "db", "cd", "dos", "f", "gd", "dict", "r", "b", "dq", "di", "dt", "dc", "t", "D", "sd", "fd", "dat", "dev", "g", "ds", "da", "p", "e", "dh", "dy", "bd", "pd", "ed", "ad", "dr", "ld", "l", "c", "m", "ind", "w"], "s": ["sv", "sis", "bits", "obj", "gs", "ms", "ses", "changes", "sam", "details", "b", "state", "cmd", "sd", "p", "e", "aws", "ls", "rs", "series", "des", "as", "c", "ps", "results", "w", "n", "fs", "params", "ns", "full", "ts", "se", "less", "sb", "ins", "terms", "os", "a", "es", "vs", "stats", "sts", "args", "settings", "hs", "is", "ss", "r", "an", "spec", "cs", "ats", "m", "comm", "ds", "tes", "l", "sys", "ads", "j", "sn", "sq", "v", "js", "sp", "S", "qs", "sol", "t", "ims", "g", "sl", "tests", "sw", "h", "bs", "its", "xs", "socket"], "val": ["util", "ret", "tx", "loc", "VAL", "elt", " res", "len", "al", "el", "ref", "compl", "fail", "vol", "value", "def", " ret", "alt", "pr", "rol", "stat", " eval", " value", "il", " resp", "am", "Val", "pass", "lib", "doc", "sel", "crit", "pret", "abel", " al", "prop", "lit", "vals", " bl", "pol", "tag", " arg", "vec", "bl", "rel", "cal", "oval", "hal", "resp", "pal", "pos", "eval", "v", "res", "urg", "spot", "li", "serv", "valid", "pl", "ail", "aval", " el", "sol", "ival", "req", "fl", "cho", "point", "label", "it", "bal"], "index": ["sort", "max", "zero", "dd", "link", "ix", "instance", "loc", "ref", "status", "active", "depth", "id", "value", "location", "position", "type", "i", "ind", "set", "n", "iter", "offset", "host", "ne", "level", "connect", "di", "address", "version", "seek", "device", "check", "num", "open", "cycle", "handle", "order", "success", "length", "is", "timeout", "shape", "chain", "error", "unit", "row", "j", "pos", "empty", "date", "test", "page", "slice", "loop", "server", "valid", "config", "info", "sol", "find", "key", "code", "number", "list", "no", "size", "height", "point", "axis", "label", "Index", "batch", "x", "dim"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 25711, "substitutes": {"host_port": ["host_file", "Host_ports", "host_ports", "host_name", "host_PORT", " host_PORT", "Host_name", "Host_port", " host_file", " host_ports", "Host_PORT"], "errp": [" errping", " errps", "errpe", " errr", " Errps", "errorr", "rrping", "errorpe", " errP", "errping", " Errp", "excP", "excping", " errpe", "excp", "rrpa", "errps", "excpa", " errpa", "errorp", "errP", "errr", "rrp", "errpa", "rrP", " Errr", "errorps", " Errpe"], "iaddr": ["fadr", " ialloc", "fadd", "sicoord", "piaddr", "Iaddress", "sptr", "Iadd", "pialloc", " icoord", "piarp", "iadd", "sadd", " iaddress", "iiadr", "iipad", "iptr", "diaddr", "Iaddr", "iiaddr", "iiadd", "inarp", "iadr", "fptr", "icoord", "inalloc", "iiaddress", " iarp", "sadr", "pipad", " iadd", "iiptr", "Ipad", "ialloc", "ipad", "diptr", "iarp", " iptr", "inaddr", "faddr", "siaddr", "iaddress", "inpad", "dicoord", " ipad", "siptr"], "saddr": ["tsptr", "jsadr", "atsaddr", "jsadd", "jsaddress", "sptr", "jspkg", "atsadd", "sadd", " sadr", "Sadd", " sadd", "stsptr", "spkg", "Sptr", "jsptr", "jsaddr", " sptr", "Saddress", "saddress", "tsadd", "sadr", "stsadr", "tsaddr", "Saddr", "Spkg", "atsadr", "stsadd", " spkg", "ssadr", " saddress", "Sadr", "ssaddr", "ssptr", "atsptr", "ssadd", "tsadr", "stsaddr"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n", "idx": 25729, "substitutes": {"x0": [" x2", "x10", "y2", "x2", "dx0", "x7", "ex2", "xt10", "ix0", "ax7", "dx1", "axzero", "xt0", "xtzero", " xzero", "ixzero", "dx7", "X1", "X0", "dxzero", "ix1", "ix10", "tx1", "X2", "xzero", " x7", "ax0", "ex0", "xt1", "ex1", "ax1", " x10", "tx0"], "y0": ["dy1", "yy1", "iyzero", "yyzero", "oy1", "dynull", "ny8", "iy8", "ey0", "ey8", "iy0", " yZero", "oy1990", "ynull", " yStart", "nyZero", "ey00", "vyZero", "oy0", "nyarg", "Y1990", "iy1", "ny00", "vy0", "yarg", "eyarg", " yzero", "ny0", "iyarg", "iy00", "yZero", "dy1990", "Y1", "vyStart", "yStart", "vy1", "yzero", "yy0", "y00", "Y0", "dy0", "nyStart", "oynull", "y8", "y1990", "Ynull"], "x1": [" x2", "x2", "fx1", "y2", "rx0", "rx1", "rxOne", "z1", " x3", "X1", "yOne", "X0", "rx3", "z0", "y3", "x3", " xOne", "fxOne", "zOne", "rx2", "fx0", "X3", "xOne", "fx3"], "y1": ["y2", "iyOne", "iy3", "xy1", "iy1", "xy01", "yOne", "YOne", "tyOne", "y3", "xyOne", "x3", "x01", "iy01", "ty1", "Y1", "Y2", "y01", "Y0", "xy3", "ty2", " y2", "ty0", "xOne", " yOne"], "buf": ["v", "cv", "cache", "cast", "result", "ba", "cam", "db", "alph", "txt", "mem", "buff", "cb", "b", "vec", "rb", "var", "box", "cmd", "pool", "block", "pkg", "bc", "arr", "uf", "bin", "ref", "req", "doc", "buffer", "tab", "out", "queue", "pack", "table", "bn", "window", "fb", "bo", "list", "Buffer", "img", "Buff", "br", "map", "bs", "cap", "wb", "pb", "ff", "batch", "grid", "err", "ctx"], "x": ["ax", "xes", "ex", "v", "n", "xx", "k", "on", "inx", "xp", "ix", "wx", "xi", "tx", "r", "X", "z", "xxx", "ux", "xc", "ware", "ox", "dx", "t", "xt", "ity", "yx", "rx", "m", "p", "e", "fx", "d", "px", "base", "l", "xy", "xs", "i", "j", "index", "c", "y", "ice", "w"]}}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734, "substitutes": {"qiv": ["oxiv", "oxIV", "queryivist", "queryivable", "qivable", "checkiv", "requiv", "quiter", "quIv", " qtv", "dqIV", "dqiv", "dqival", " qistor", "acquiva", "acquivable", "giv", "dqtv", "giva", "qIV", " qiro", "sqiver", "gIV", "sqij", " qiver", "qivo", "qival", "queryivo", "giver", "quivo", "eqiver", "sqiv", "queryiv", "quij", "requivo", "qiver", "oxiver", "eqiter", "qistor", "sqIV", "queryij", "qiter", "checkIV", "quiro", "sqival", "oxiva", " qij", "queryiver", "checkival", " qIv", "qutv", "qiro", "quiver", "sqIv", "requiver", "quIV", "quiva", "acquiv", "qtv", "acquiver", "quivable", "queryiro", "eqiv", "qiva", "qIv", " qiter", "queryiva", "requivist", "quiv", "eqistor", "qij", "quistor", "qivist", "dqiver", "checkiver", "quivist"], "name": ["data", "n", "k", "text", "named", "local", "family", "valid", "common", "group", "NAME", "item", "r", "attr", "missing", "names", "path", "unique", "new", "comment", "key", "filename", "o", "str", "code", "active", "title", "prefix", "id", "part", "no", "size", "flag", "value", "equal", "search", "label", "word", "type", "ame", "alias", "c", "x", "normal", "Name", "term", "length", "w"], "qobj": ["sqobj", " qaddr", "dqObj", "aqobj", "iqrect", "qrect", "qso", "aqObj", "qelt", " qobject", "qog", "dqobj", "questObj", "questso", "qualrb", "eqconn", "qqconn", " qjs", "eqobject", "aqobject", "aqjs", "iqobj", "dqobject", "qbo", "qualconn", "questobj", "questrect", "eqobj", " qObj", "qualaddr", "qqobj", "sqelt", "qobject", "sqso", "sqog", "iqobject", "qqelt", " qso", "sqjs", "sqconn", "questobject", "qconn", "eqoy", "sqonet", "sqbo", "qjs", "querybo", "queryobj", "dqrect", "qaddr", " qconn", " qonet", "eqog", "queryconn", "eqbo", "qqrb", "sqoy", "qObj", "dqjs", "qualobj", "queryobject", "qqaddr", "questonet", "qonet", "eqelt", " qbo", " qog", "qqoy", "qrb", " qrb", "qoy", "iqObj", "questjs"]}}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static BufferPoolEntry *get_pool(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *cur = NULL, *last = NULL;\n\n\n\n    do {\n\n        FFSWAP(BufferPoolEntry*, cur, last);\n\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n\n        if (!cur)\n\n            return NULL;\n\n    } while (cur != last);\n\n\n\n    return cur;\n\n}\n", "idx": 25737, "substitutes": {"pool": ["cache", "pc", "vp", "work", "profile", "util", "server", "history", "host", "client", "config", "pro", "mem", "timeout", "slot", "protected", "context", "policy", "lock", "manager", "program", "PO", "ool", "pkg", "block", "pg", "wrapper", "padding", "http", "p", "chain", "Pool", "buffer", "connection", "out", "status", "hash", "queue", "cp", "list", "table", "window", "memory", "container", "type", "handle", "batch", "buf", "socket", "php", "alloc", "access", "network", "port"], "cur": ["obj", "ur", "kar", "loc", "cmd", "pg", "pkg", "func", "occ", "coll", "still", "sur", "sc", " ret", "now", " cr", "c", "entry", "result", "gc", "oc", "ocr", "cor", "Cur", " cont", "arr", "cat", " cursor", "str", " prev", "ah", "ct", "cp", "currently", " ob", "desc", "col", "buf", "ptr", "ctx", "pri", "cv", "gr", " Cur", "tr", "r", "current", "fac", "coord", " sc", "cf", "con", "rc", "dr", "cont", "ctr", "row", "tmp", "msg", "unc", "cmp", " curs", "serv", "cr", " rc", "public", "car", "req", " current", "stable", "err", "ch"], "last": ["tail", "nt", "first", "v", "nl", "max", "Last", "count", "stop", "length", "master", "final", "next", "th", "end", "show", "local", "parent", "most", "full", "set", "highest", "push", "new", "total", "las", "all", " Last", "best", "list", "base", "old", "nd", "ul", " LAST", "prev", "latest", "good", "leaf", "st", "l", "stable", "row", "tmp", "largest", "index", "empty", "entry", "est", "slave"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n\n                          int *end_pos2)\n\n{\n\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n\n        s->gb           = s->in_gb;\n\n        s->in_gb.buffer = NULL;\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        skip_bits_long(&s->gb, *pos - *end_pos);\n\n        *end_pos2 =\n\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n\n        *pos      = get_bits_count(&s->gb);\n\n    }\n\n}\n", "idx": 25738, "substitutes": {"s": ["sv", "hs", "is", "n", "gs", "js", "ms", "ses", "sa", "changes", "eps", "bis", "services", "S", "sam", "serv", "fs", "ns", "details", "store", "ss", "b", "r", "ts", "qs", "parts", "se", "setup", "t", "cs", "south", "less", "ats", "space", "sb", "ims", "p", "comm", "aws", "ds", "sl", "g", "ains", "ls", "sw", "es", "os", "so", "sg", "sync", "rs", "h", "vs", "l", "sys", "as", "acs", "stats", "sts", "bs", "y", "als", "c", "sq", "ps", "set"], "pos": ["limit", "bits", "pc", "n", "res", "offset", "post", "val", "Pos", "pl", "pro", "op", "seq", "loc", "body", "pid", "sol", "cond", "pres", "at", "len", "coord", "padding", "rot", "pat", "port", "add", "doc", "p", "ping", "pt", "out", "off", "pose", "rel", "os", "no", "def", "position", "vs", "num", "neg", "mon", "POS", "nos", "buf", "index", "proc", "prop", "ps", "po", "lit"], "end_pos": ["endlycomp", "end_comp", "endlypo", "stop_po", "end___neg", "end_ps", "end_mon", "end__loc", "ending___pid", "endlypos", "stop_comp", "ending_pos", "ending_pid", "end__ps", "end_limit", "end_loc", "ending___pos", "stop_post", "ending_mon", "stop_pos", "end___pid", "end_post", " end_loc", "endlypost", "end_pid", " end_ps", "end_po", "ending___neg", "ending_neg", "end__pos", "end__limit", "end_neg", " end_limit", "end___mon", "ending___mon", "end___pos"], "end_pos2": ["end_Pos2", "end_os2", "end_pt2", "end_pos02", "end_Pos3", "end_POS2", "end_ps02", "end_pos3", "end_size2", "end_Pos4", "end_po2", "end_pt3", "end_Pos02", "end_pt4", "end_neg2", "end_POS3", "end_POS4", "end_neg02", "end_pos4", "end_ps2"]}}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25741, "substitutes": {"bs": ["BS", "aus", "bits", "hs", "iss", "bis", "js", "gs", "bp", "ubis", "obs", "fs", "blog", "ns", "ubs", "ss", "b", "ts", "qs", "bos", "bc", "cs", "bl", "bes", "sb", "bps", "bh", "fps", "boxes", "aws", "ds", "outs", "bb", "ls", "locks", "cks", "rs", "bm", "vs", "aos", "lbs", "als", "sts", "its", "pb"], "sector_num": ["entryitynum", "entryityn", "ector_Num", "sector_NUM", "sector_un", "entry_num", "sectoridnumber", "sector_number", "entry_um", "sectorityum", " sector_un", "ector2nr", "character_n", "ector2Num", "sectoritymn", "sector2num", "secondaryidnum", "ector_num", "sector_n", "sectoritynum", "sector_no", "entryitycomb", "sectoridnr", "ector2number", "entryityum", "sector2nr", "ector2num", "secondary_nom", "sector_comb", "secondaryidnumber", "sectoridnom", "secondary_number", "sector_sum", "secondary_nr", "sector_nr", " sector_um", "sector2Num", "character_num", "sector_nom", "sectorityno", "character_sum", "sectoritycomb", "sector_um", " sector_mn", "entry_n", "sector2number", "ector_number", " sector_Num", "secondary_num", " sector_number", "sector_mn", "sectorityn", "secondaryidnr", "entry_comb", "secondaryidnom", " sector_no", "sector_Num", "ector_nr", "sectoridnum", "character_NUM", "sectoritynumber"], "buf": ["limit", "data", "v", "cv", "output", "text", "result", "half", "db", "bar", "end", "mem", "seq", "buff", "cb", "b", "vec", "rb", "box", "cmd", "block", "xff", "bytes", "func", "bc", "len", "BU", "bin", "uf", "w", "ref", "doc", "buffer", "out", "off", "queue", "nb", "window", "Buffer", "h", "img", "cur", "Buff", "br", "map", "tmp", "addr", "cap", "wb", "batch", "pb", "empty", "msg", "ff", "etc", "alloc", "port", "length", "raw"], "nb_sectors": ["nb_veackers", "nb_esors", "nb_sesbuilders", "nb_peors", "nb_bellers", "nb_seackers", "nb_sesllers", "nb_segments", "nb_suors", "nb_tegments", "nb_pectors", "nb_veors", "nb_sesctors", "nb_psegments", "nb_severs", "nb_vegments", "nb_psectors", "nb_spechers", "nb__sectors", "nb__pellers", "nb__seors", "nb__pectors", "nb_spectors", "nb_kectors", "nb_sedrivers", "nb_sesackers", "nb_sercs", "nb_beors", "nb_pevers", "nb_serctors", "nb_sechers", "nb_esbuilders", "nb_esctors", "nb_sullers", "nb_sesors", "nb_kegments", "nb_spellers", "nb_vedrivers", "nb_vevers", "nb_speivers", "nb__sellers", "nb_begments", "nb_secs", "nb_esackers", "nb_tectors", "nb_tecs", "nb_vebuilders", "nb_sergments", "nb_kedrivers", "nb_spegments", "nb__severs", "nb_speors", "nb_bedrivers", "nb_keors", "nb_teivers", "nb_pseors", "nb__pevers", "nb__peors", "nb_seors", "nb_vellers", "nb_psellers", "nb_seschers", "nb_suvers", "nb_vechers", "nb_seivers", "nb_specs", "nb_pellers", "nb_serivers", "nb_suctors", "nb_bectors", "nb_sellers", "nb_sebuilders", "nb_vectors"], "s": ["sv", "sis", "bits", "n", "hs", "is", "gs", "js", "bis", "ses", "S", "fs", "ns", "ss", "b", "plays", "ts", "t", "cs", "ats", "sb", "p", "aws", "ds", "sl", "g", "ls", "ares", "a", "rs", "h", "vs", "stats", "sts", "its", "i", "j", "c", "sn", "sq", "ps"], "offset": ["command", "url", "util", "ta", "sp", "mask", "end", "parent", "slot", "timeout", "op", "peer", "loc", "reset", "alloc", "info", "offs", "address", "block", "at", "area", "origin", "t", "coord", "shift", "rot", "offer", "padding", "ref", "align", "key", "o", "seek", "buffer", "pad", "out", "off", "bound", "Offset", "base", "tile", "mt", "trace", "error", "option", "prefix", "location", "position", "point", "pointer", "row", "addr", "type", "start", "alt", "index", "pos", "ptr", "et", "transform", "order", "batch", "entry", "port", "set"], "sectors": ["spelements", "velements", "desllers", "speports", "persectors", "pectors", "veurers", "vellers", "seurers", "persevers", "pellers", "spevers", "psectors", "desctors", "selements", "veports", "segments", "sexports", "desctions", "veters", "peors", "perseurers", "veors", "speors", "desters", "sections", "vections", "vegments", "seters", "spellers", "seports", " severs", "severs", " seors", " selements", " seurers", "sexors", "pseters", "psections", "seors", "spectors", "vevers", "pseors", "pselements", " sellers", "sellers", "psellers", "spegments", "sexctors", "vectors", "perseors", "pegments", "sexllers"], "sectors_per_block": ["sectors_PER_Block", "sectors_per_bit", "sectors_per__Block", "sectors_per__block", "sectors_PER_bit", "sectors_PER_byte", "sectors_per_group", "sectors_in_bin", "sectors_per_byte", "sectors_per__group", "sectors_per_bin", "sectors_Per_Block", "sectors_PER_block", "sectors_PER_group", "sectors_in_byte", "sectors_Per_blocks", "sectors_Per_block", "sectors_in_block", "sectors_per_blocks", "sectors_per_Block"], "ret": ["tail", "rev", "nt", "rem", "res", "result", "nz", "ter", "iter", "final", "val", "aux", "print", "rt", "net", "rets", "mem", "det", "tr", "ne", "reply", "r", "elt", "reset", "cmd", "t", "len", "Return", "fun", "arr", "conv", "cat", "deg", "ft", "expr", "gt", "Ret", "out", "not", "mt", "RET", "att", "cont", "ctr", " RET", "re", "alt", "j", "ptr", "et", "success", "it"], "footer": ["tuners", "Footner", "Footers", " Footers", "cooler", " Footeder", "throwner", "tuneder", "tunER", "coolner", "coolter", "coolER", "tuner", "throwER", " FootER", "footers", "footter", "Footeder", "FootER", "footeder", "footER", " Footer", "Footer", "Footter", "thrower", "throwter", "footner"]}}
{"project": "FFmpeg", "commit_id": "4ffe5e2aa5241f8da9afd2c8fbc854dcc916c5f9", "target": 1, "func": "static int read_old_huffman_tables(HYuvContext *s){\n\n#if 1\n\n    GetBitContext gb;\n\n    int i;\n\n\n\n    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);\n\n    if(read_len_table(s->len[0], &gb)<0)\n\n        return -1;\n\n    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);\n\n    if(read_len_table(s->len[1], &gb)<0)\n\n        return -1;\n\n\n\n    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n\n    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n\n\n\n    if(s->bitstream_bpp >= 24){\n\n        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n\n        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n\n    }\n\n    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n\n    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));\n\n\n\n    for(i=0; i<3; i++){\n\n        ff_free_vlc(&s->vlc[i]);\n\n        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);\n\n    }\n\n\n\n    generate_joint_tables(s);\n\n\n\n    return 0;\n\n#else\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"v1 huffyuv is not supported \\n\");\n\n    return -1;\n\n#endif\n\n}\n", "idx": 25748, "substitutes": {"s": ["sv", "v", "hs", "n", "is", "gs", "js", "bis", "ses", "changes", "ms", "in", "rates", "S", "fs", "reads", "ns", "details", "ss", "b", "ts", "qs", "parts", "ops", "se", "an", "t", "cs", "ssl", "gets", "ats", "less", "comments", "ims", "ins", "p", "http", "comm", "m", "aws", "ds", "ls", "sw", "os", "es", "a", "sg", "rs", "events", "h", "vs", "l", "sys", "as", "conf", "acs", "als", "sts", "bs", "stats", "its", "c", "sq", "y", "ps", "self", "set", "w"], "gb": ["sv", " rgb", "bridge", "gu", "args", "gs", "gc", "Gb", "db", "bf", "bg", " eg", "gd", "disabled", "gin", "cb", "tg", "b", "rb", "hub", "pg", "gp", "bytes", "bc", "gm", "rg", "ge", "yg", "sb", "deg", "gpu", " GB", "gt", "g", "bb", "py", "bd", " pg", "nb", "fb", "gov", "bm", "fg", "kb", "storage", "img", " g", "gg", "wb", "GB", "eg", " b", " rg", " db", "cfg", "mb"], "i": ["qi", "ex", " I", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "PI", "p", "e", "status", "depth", "id", "io", "us", "zi", "y", "bi", "ind", "I", "er", "to", "n", "json", "ci", " multi", "di", "iii", "pi", " mi", "iu", "iy", " ti", "phi", "ik", " j", "is", "me", "ij", "print", "f", "ini", "gi", "hi", "eu", " bi", "cli", "sim", "ri", "m", "multi", "chain", "ic", " ii", "\u0438", " si", "im", " pi", "j", "index", "si", "v", "gu", "in", "slice", "li", "ai", "ji", "ki", "info", "t", "mi", "mac", " m", "ims", "g", "name", "q", " di", "uri", "point", "err", "ti", "batch", "x", "it", "ui"]}}
{"project": "qemu", "commit_id": "7264961934130df50d151def5eb415efa2e28ec5", "target": 0, "func": "exynos4_boards_init_common(MachineState *machine,\n\n                           Exynos4BoardType board_type)\n\n{\n\n    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n", "idx": 25753, "substitutes": {"s": ["ches", "sv", "er", "v", "n", "is", "hs", "gs", "js", "sa", "ses", "ers", "fs", "S", "ns", "ss", "r", "b", "ts", "qs", "se", "t", "cs", "south", "ats", "sb", "m", "p", "g", "ds", "sl", "ls", "sw", "os", "es", "sg", "rs", "ies", "h", "sys", "us", "stats", "sts", "y", "sand", "bs", "its", "i", "sports", "c", "sq", "ps", "self", "w"], "mc": ["ma", "pc", "cmp", "machine", "md", "gc", "ms", "mic", "Mc", "vm", "mn", "mk", "lc", "di", "mx", "MC", "dc", "mi", "mp", "mac", "meta", "tm", "mm", "m", "cc", "cp", "mr", "nic", "mt", "bm", "tc", "c", "cm", "cfg", "mb"]}}
{"project": "FFmpeg", "commit_id": "29d46d7bce1c67852e4c6e22605144eb32b21072", "target": 1, "func": "static void json_print_section_header(WriterContext *wctx)\n\n{\n\n    JSONContext *json = wctx->priv;\n\n    AVBPrint buf;\n\n    const struct section *section = wctx->section[wctx->level];\n\n    const struct section *parent_section = wctx->level ?\n\n        wctx->section[wctx->level-1] : NULL;\n\n\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n\n        printf(\",\\n\");\n\n\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n\n        printf(\"{\\n\");\n\n        json->indent_level++;\n\n    } else {\n\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n        json_escape_str(&buf, section->name, wctx);\n\n        JSON_INDENT();\n\n\n\n        json->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n\n        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n\n        } else {\n\n            printf(\"{%s\", json->item_start_end);\n\n\n\n            /* this is required so the parser can distinguish between packets and frames */\n\n            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n\n                if (!json->compact)\n\n                    JSON_INDENT();\n\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n\n            }\n\n        }\n\n        av_bprint_finalize(&buf, NULL);\n\n    }\n\n}\n", "idx": 25787, "substitutes": {"wctx": ["sawpatch", "wacmd", "wdesc", "wdfx", "wdreq", "wdgc", "wgc", "Wtx", " wcfg", "wddesc", "wdbatch", "Wctx", "awkw", " wdesc", "rwcontext", "writerreq", "fwctx", "rwkw", "wcfg", "wmk", "nwctx", "wnp", "nwcp", "wtx", "wcontext", "kwctx", "wdcmd", "fwjac", "wdkw", "wcmp", "Wfx", "awfx", "wdat", "fwcfg", " wpx", "wfx", "Wpx", "walctx", " wdat", " wkl", "awcontext", "wapx", " wcmp", " wkw", "wanp", "wajac", "sawjac", "wacp", "kwcontext", "writercmd", " wgc", "sawctx", " wpkg", "wapatch", "wreq", "wactx", "fwcontext", " wfx", "kwcmp", "wcp", "watx", "wamk", "wkl", "wacontext", "kwnp", "writerctx", " wjac", "wdmk", "wagc", " wmk", "wkw", "wpatch", "wpkg", "wdpkg", "writerbatch", "wadat", "fwkl", "wcmd", "awjac", "fwtx", " wnp", "fwjp", "wddat", "rwpkg", "wdcp", "wareq", "wdctx", " wjp", "wbatch", "Wkw", "wakl", "Wcontext", "wabatch", "sawcp", "walcfg", "nwdesc", " wcp", "nwcontext", "wapkg", "wdpx", "wdtx", "wjp", "rwctx", "awpatch", "wjac", " wtx", "wpx", "awctx", "wdcontext", "walcontext", "wacmp", "waljp", "awcp", " wcontext", "rwfx"], "json": ["JSON", "ja", "ose", "xml", "data", "obj", "n", "js", "gc", "server", "ruby", "git", "aw", "txt", "opt", "params", "node", "mint", "config", "context", "kj", "tx", "database", "son", "journal", "javascript", "info", "tree", "spec", "jack", "html", "metadata", "update", "tm", "note", "m", "java", "format", "jj", "ml", "news", "export", "gov", "value", "sys", "np", "global", "stats", "twitter", "document", "module", "j", "wire", "media", "graph", "kw", "network", "csv", "ctx"], "buf": ["v", "cv", "obj", "btn", "bed", "result", " resp", "cam", "iter", "db", "bf", "txt", " buffer", "aux", "uv", "job", "mem", "seq", "tx", "uffy", "buff", "cb", "b", "vec", "kw", "rb", "norm", "box", "cmd", "block", "pool", "pg", "writer", "bytes", "pkg", "bc", " buff", "usr", "fac", "uf", "conv", "filename", "bh", "buffer", "tab", "out", "aka", "cf", "queue", "rw", "bn", "window", "Buffer", "img", "Buff", " bu", "aos", "tmp", "br", "bs", "builder", " b", "j", "pb", "batch", "msg", "etc", "bag", "port", "ctx"], "section": ["file", "there", "sect", "division", "header", "connection", "function", "environment", "line", "window", "value", "position", "session", "entry", "set", "action", "level", "setting", "journal", "version", "tab", "package", "array", "part", "region", "language", "ion", "operation", "data", "usage", "channel", "parent", "context", "group", "tag", "description", "heading", "second", "comment", "component", "sections", "definition", "table", "option", "container", "global", "j", "test", "network", "Section", "uration", "page", "server", "member", "feature", "node", "config", "item", "reader", "block", "setup", "area", "key", "man", "side", "format", "name", "number", "list", "element", "size", "child", "sector", "service", "port", "variable"], "parent_section": [" parent_option", "parent___sect", "parent_option", " parent_side", "parent_side", "parent___parent", "parent_sect", " parent_parent", "parent_item", "parent___channel", "parent___side", " parent_sect", "parent_sector", "parent___section", " parent_item", "parent___item", "parent_channel", " parent_channel", "parent_parent", " parent_sector"], "indent_level": ["indents_level", "indency_status", "indentextop", "indents_output", "indentsmaxlevel", "indent_group", "indency_group", "indent__limit", "indentmaxlimit", "indents_top", "indent_status", "indent_vel", "indent__top", "indentmaxoutput", "indentmaxlevel", "indentexlimit", "indent__level", "indentsmaxlimit", "indentsmaxoutput", "indent_output", "indency_level", "indent_limit", "indentmaxtop", "indent__output", "indency_vel", "indentexlevel", "indentexoutput", "indents_limit", "indent_top", "indentsmaxtop"]}}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810, "substitutes": {"memmap": ["memorystore", " memap", "memstore", "memorymap", "Memmap", "mmcache", "Memcache", "ramcache", "regmap", "mmcode", "MemMap", "Memap", " memapper", "regap", "memoryap", "memMap", "memapper", " memcache", "mmmap", "ramap", "ramMap", "memap", " memcode", "mmMap", "memcode", " memMap", "mmapper", "Memstore", "rammap", "memcache", "regapper", "ramstore", "memoryMap", "regcode", "mmap"], "irqmap": ["pirwmap", "pirqmap", "irwsm", "pirqtable", "irqtmap", "irqcap", "irqusm", "irQset", "irwmap", "pirqumap", "irqtable", "irQtable", "irwtable", "irQcap", "irwset", "pirqset", "pirqsm", "irqmaps", "pirqumaps", "irwcap", "irquset", "irqumap", "irqumaps", "pirqcap", "irqutable", "pirwset", "irqset", "irqucap", "pirqusm", "pirwtable", "irqtmaps", "irwmaps", "irqttable", "irqsm", "pirqutable", "irqtsm", "pirqmaps", "pirwcap", "irQmap"], "madt": ["radta", "radtu", "goodta", "adt", "madta", "mastwt", "medt", "medta", "mata", "medtu", " madta", "madT", "mawt", "adta", "radt", "mastT", "medT", "adwt", " madT", "mastta", "madwt", "mandt", "radT", "goodT", "goodt", "adT", "medwt", "goodwt", "mat", "mandtu", "mandT", "mandta", "madtu", " madwt", "maT", "mastt"], "gicd": ["giacbd", "genicda", "gicdb", "gicdir", "gicdx", "gicde", "genikdc", "giccdir", "gikda", "gocrdl", "gizdi", "gmicdx", "gricd", "giacdo", "genericondt", "gricdt", "gicds", "genicd", "gricdb", "gmicda", "garicdc", "garicd", "agicdj", "gicdo", "genicdo", "gaicda", "genicdt", "gizdj", "gicdl", "gizdb", "genericdir", "gicod", "gicsd", "gwicD", "gikdt", "gaicdb", "gaikda", "agizda", "gaicdl", "gaicdt", "genericond", "garicdl", "giced", "gaicdx", "Gikdi", "gaicdo", "gicond", "genaicdo", "gikdx", "giconbd", "giacdt", "giqd", "gizD", "agiacd", "gaicd", "gicda", "gicdn", "giccd", "gikdl", "gricdc", "gaicsd", "gicode", "gicondt", "genicdc", "gaicde", "agiacdo", "giacdir", "agiacsd", "gwicdi", "agicdn", "gricdl", "GikD", "gicosd", "gwicdb", "agicd", "glicd", "gicedb", "giccds", "gmicd", "gikD", "giacsd", "gizd", "agicde", "gikdc", "gaikdb", "giacd", "gmicdb", "giceda", "agicda", "genikdt", "giconda", "agicdo", "gaikdx", "glicdn", "gicdi", "genericd", "gicD", "gizda", "genericdt", "gicbd", "GicD", "giccdt", "gicondj", "giqds", "agizdj", "garicdb", "gikd", "giqdo", "agiacde", "gicondn", "gikdi", "genaicds", "genaicd", "genicdl", "giccda", "gaicdc", "gicdj", "agicsd", "gocrd", "genericonbd", "giacde", "genikdl", "giccbd", "gicdt", "gwicd", "giccdo", "gicondir", "glicdj", "giqda", "glicda", "gicodo", "genaicda", "genericondir", "Gicdb", "agizdn", "genikd", "gocrdb", "gaicds", "gizdn", "Gicd", "genicds", "gaikd", "gocrdc", "Gikdb", "gikdb", "genericbd", "gicedx", "Gicdi", "Gikd", "gicdc", "agizd"], "gic_msi": ["gic_mesi", "gic_ssis", "gic_mesig", "gic__ssid", "gic__msi", "gic_tsis", "gic_msid", "gic_tsi", "gic__ssi", "gic__ssig", "gic__msis", "gic_msis", "gic__msig", "gic_tsig", "gic_ssi", "gic_mesid", "gic_ssig", "gic__msid", "gic_mesis", "gic_tsid", "gic_msig", "gic__ssis", "gic_ssid"], "i": ["qi", " I", "ix", "xi", "ami", "ii", "p", "e", "status", "id", "zi", "c", "y", "bi", "ind", "I", "to", "n", "k", " pos", "ci", "di", " x", "u", "pi", " mi", "iu", " ti", "phi", " j", "is", "me", "ij", "f", "mu", "ini", "r", "gi", "hi", " bi", "ic", "sim", "m", "multi", "ri", " ii", " si", "im", "l", " pi", " index", "j", "index", "si", "v", "in", "li", "ai", "go", "ji", "ki", "info", "mi", " m", "ims", "o", "name", "q", " di", "h", "ti", "x", "it", "ui"], "gicc": ["genicc", "gikh", "micc", "ogisc", "mic", "geusc", "gik", "msgusc", "mgarc", "genique", "geninc", "gaitech", "generirc", "genirc", "agusc", "cerc", "gnarc", "ogiac", "cigg", "gpitech", "genivic", "gcci", "gique", " gario", " gusc", "ogifa", "msgerc", "gpusc", "generc", "mgifa", "ogitech", "ggusc", "genikh", "gerc", "garc", "goario", "genererc", "genario", "ogario", "gnifa", "msgicc", "agifa", "gpic", "gaisc", "gaicc", "gaario", "circ", "mgikh", "gnicc", "genarc", "gpics", "goivic", "goicc", "gaiac", " gic", "geicc", "ogicc", "gaics", "cicc", "gpivic", "gusc", "gnigg", "gic", "gencci", "ogivic", "goerc", " givic", "gitech", "gifa", "geario", "mario", "gniac", "generigg", "genaic", "agisc", "agicc", "oginc", "genericc", "msgcci", "msgique", "gpcc", "ginc", "gpicc", "geniac", "agaic", "gaic", "geik", "msgiac", "gnerc", "gocci", "goinc", "gairc", "gcc", " giac", "gisc", "genifa", "ogaic", "gics", "giac", " gcc", "gpik", "gnikh", "girc", "ggicc", "gario", "mcc", "genisc", "gnirc", "ggivic", "msgivic", "agario", "gpario", "givic", "agik", "mgicc", " gics", " gitech", "ggiac", "gigg", "gpiac", "gnisc", "goique"], "armcpu": ["Armpu", "romcpu", "smproc", "smcomputer", "warmcomputer", "warmproc", "smcp", "armcomputer", "Armgpu", "warmlinux", "armnic", "Armcpu", "armgpu", "armcu", "romcu", "armpu", "iamcu", "iamproc", "warmpu", "warmnic", "iamlinux", "warmcpu", "romproc", "smcpu", "amcpu", "Armnic", "iamcpu", "warmgpu", "ymproc", "ampu", "romlinux", "armcp", "armlinux", "armproc", "warmcp", "ymcomputer", "warmcu", "ymcpu", "ymcp", "amgpu", "amnic"], "gic_its": ["gic_ls", "gik2ms", "gik2ts", "gik_ms", "gik_its", "gic_ts", "gik_ls", "gic2ls", "gik2its", "gic2ms", "gic_ms", "gik2ls", "gic2ts", "gic2its", "gik_ts"]}}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n", "idx": 25813, "substitutes": {}}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n", "idx": 25814, "substitutes": {"klass": ["klad", "Klasses", "kazz", "Kazz", " kazz", "Klad", " klad", "wkls", "klasses", " kls", "Kls", "tkls", "tkazz", "tklass", "wklasses", " klasses", "wklass", "tklasses", "wklad", "Klass", "kls"], "data": [" dat", "init", "DATA", "res", "rec", "rew", "raw", "Data", "json", "mu", " datas", "attr", "func", "new", "bin", " DATA", "dat", "name", " sd", "ds", "d", "id", "def", "type", " Data", "ata", "w"], "uc": ["aus", "urn", "pc", "cmp", "ucc", "uk", "isc", "gc", "oc", "ub", "anc", "ugen", "uv", "ut", " unc", "ocr", "ou", "asc", "mc", "ci", "fc", "ud", "um", "xc", " su", "bc", "eu", "cu", " ac", "uf", "auc", "cus", "uh", "ac", "ec", "cc", "ach", "ct", "icc", "u", "nic", "lu", "ul", "orc", "pac", "uch", "soc", "etc", "uu", "uci", "us", "userc", "tc", "usc", "roc", "unc", "ust", "UC"]}}
{"project": "FFmpeg", "commit_id": "77d98898211eeb0241e8411428b0b364a6231744", "target": 1, "func": "static int pixlet_decode_frame(AVCodecContext *avctx, void *data,\n                               int *got_frame, AVPacket *avpkt)\n{\n    PixletContext *ctx = avctx->priv_data;\n    int i, w, h, width, height, ret, version;\n    AVFrame *p = data;\n    ThreadFrame frame = { .f = data };\n    uint32_t pktsize;\n    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);\n    pktsize = bytestream2_get_be32(&ctx->gb);\n    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid packet size %\"PRIu32\"\\n\", pktsize);\n    }\n    version = bytestream2_get_le32(&ctx->gb);\n    if (version != 1)\n        avpriv_request_sample(avctx, \"Version %d\", version);\n    bytestream2_skip(&ctx->gb, 4);\n    if (bytestream2_get_be32(&ctx->gb) != 1)\n    bytestream2_skip(&ctx->gb, 4);\n    width  = bytestream2_get_be32(&ctx->gb);\n    height = bytestream2_get_be32(&ctx->gb);\n    w = FFALIGN(width,  1 << (NB_LEVELS + 1));\n    h = FFALIGN(height, 1 << (NB_LEVELS + 1));\n    ctx->levels = bytestream2_get_be32(&ctx->gb);\n    if (ctx->levels != NB_LEVELS)\n    ctx->depth = bytestream2_get_be32(&ctx->gb);\n    if (ctx->depth < 8 || ctx->depth > 15) {\n        avpriv_request_sample(avctx, \"Depth %d\", ctx->depth);\n    }\n    ret = ff_set_dimensions(avctx, w, h);\n    if (ret < 0)\n        return ret;\n    avctx->width  = width;\n    avctx->height = height;\n    if (ctx->w != w || ctx->h != h) {\n        free_buffers(avctx);\n        ctx->w = w;\n        ctx->h = h;\n        ret = init_decoder(avctx);\n        if (ret < 0) {\n            free_buffers(avctx);\n            ctx->w = 0;\n            ctx->h = 0;\n            return ret;\n        }\n    }\n    bytestream2_skip(&ctx->gb, 8);\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n    p->color_range = AVCOL_RANGE_JPEG;\n    ret = ff_thread_get_buffer(avctx, &frame, 0);\n    if (ret < 0)\n        return ret;\n    for (i = 0; i < 3; i++) {\n        ret = decode_plane(avctx, i, avpkt, frame.f);\n        if (ret < 0)\n            return ret;\n        if (avctx->flags & AV_CODEC_FLAG_GRAY)\n            break;\n    }\n    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);\n    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);\n    *got_frame = 1;\n    return pktsize;\n}", "idx": 25828, "substitutes": {"avctx": ["avercookie", "jamcpu", "jamcb", "avecp", "abcp", " avcm", "abcb", "avecontext", "avecb", "awtx", "ajcam", "avertx", " avctl", "avcam", "devcookie", "navconn", "avecam", "navtx", " avtx", "jamtx", "avetx", "navctx", "avcpu", "devtx", "vrtx", "abcmp", "vrcp", " avcookie", "averconn", " avcontext", "avtx", "afctl", "avctl", " avcb", "afcp", "abctx", "awcm", "abtx", "aftx", "devctx", "avcontext", "vrctx", "afctx", "ajcp", "vrcmp", "avcb", "afcookie", "avconn", "averctl", "awcfg", "avercpu", "avcp", "avcmp", "aveconn", "afcontext", "avcm", "avercfg", " avcfg", "averctx", "avecmp", "avercb", "abcpu", "avcfg", "avectl", "ajconn", "awctx", "avecfg", "avcookie", "jamctx", "afconn", "navcookie", "ajctx", "afcam", "devconn", "avecm", "avectx"], "data": ["DATA", "obj", "video", "text", "result", "offset", "next", "frame", "Data", "raw", "json", "file", "content", "f", "action", "message", "example", "r", "body", "info", "block", "bytes", "image", "t", "padding", "bin", "ref", "o", "m", "str", "buffer", "feed", "name", "out", "format", "pad", "d", "a", "response", "window", "table", "id", "size", "value", "def", "map", "form", "buf", "extra", "x", "empty", "ata", "length"], "got_frame": ["gotopdepth", "new_channel", "gotopcode", "gotopframe", "new_code", "got_depth", "new_depth", "got_code", "gotopchannel", "got_channel", "new_frame"], "avpkt": [" avpwk", " avPkt", " avPvt", "avjpact", "avPvt", "averpkg", "avppkt", "avppwk", "avjpkt", "avppvt", "avpidkg", "avpadft", "avejpkt", "avjpck", "avpck", " avpvt", "avpadkt", "avepact", "avpct", "averpidkg", "avcpact", "avpbact", "avejpact", "averpkt", "averpetta", "averpft", "averpidetta", "avcpet", "avejpet", "avepet", "avpact", "avppft", "avpbkt", "avpbck", "avjpet", "avpidft", "avpvt", "avcpck", "avpkg", "avpidetta", "avppkg", "avpcwk", " avPct", "avPwk", " avpct", "avepck", "avppetta", "avepkt", "avppct", "avcpkt", "avpbet", "avpadetta", "averpidkt", " avPwk", "averpidft", "avPct", "avPkt", "avejpck", "avpft", "avpcvt", "avpcct", "avpadkg", "avpidkt", "avpckt", "avpwk", "avpetta", "avpet"], "ctx": ["acl", "cookie", "uint", "obj", "conn", "exec", "txt", "jp", "na", "aux", "that", "tx", "cb", "loc", "kt", "cmd", "pkg", "xc", "func", "ctl", "tm", "hw", "wcs", "px", "def", "conf", "np", "tk", "c", "nt", "history", "ns", "inst", "warn", "lc", "fc", "std", "bytes", "act", "cu", "dc", "ct", "cp", "crit", "check", "prefix", "addr", "module", "desc", "buf", "cm", "ctrl", "kw", "cfg", "_", "vals", "ca", "cv", "args", "iac", "cam", "xp", "wx", "parent", "context", "timeout", "pool", "new", "conv", "comm", "cf", "ck", "dad", "resp", "sys", "index", "proc", "etc", "abc", "v", "cmp", "co", "cas", "kl", "config", "mem", "bc", "setup", "gt", "cc", "jac", "ka", "tc", "batch", "scope", "utils"], "i": [" j", " f", " err", " ni", " pos", " offset", "t", " ip", " id", " bi", " m", " ii", " v", "id", " mi", " tid", " t", " it", " index", " e", " wi", "j", " info", "x", " b", " out", " fi", "I"], "w": ["v", "we", "n", "wr", "W", "wm", "wall", "wp", "weight", "aw", "wa", "wx", "f", "wl", "wd", "weights", "r", "z", "fw", "t", "win", "m", "hw", "wal", "wh", "wi", "g", "wn", "d", "nw", "sw", "wcs", "rw", "ew", "window", "wt", "wid", "l", "ww", "iw", "wb", "c", "x", "widget", "kw", "length"], "h": ["hr", "ih", "ph", "v", "n", "k", "history", "host", "hm", "f", "H", "b", "ha", "he", "hi", "hh", "html", "t", "oh", "sh", "kh", "hash", "m", "bh", "g", "ah", "dh", "d", "hang", "hz", "high", "hal", "hd", "l", "ho", "ht", "y", "it", "ch", "length"], "height": ["Height", "range", "th", "ty", "history", "host", "power", "bottom", "distance", "volume", "shape", "level", "resolution", "H", "quality", "he", "gy", "hei", "html", "padding", "kh", "hash", "buffer", "wh", "holes", "style", "rank", "view", "hang", "depth", "window", "high", "density", "size", "above", "grow", "memory", "era", "capacity", "radius", "gh", "gravity", "thus", "ht", "angle", "dim", "y", "widget", "ch", "length"], "ret": ["rev", "nt", "rem", "tif", "res", "nl", "result", "ter", "final", "ext", "txt", "jp", "val", "ll", "print", "rt", "tf", "valid", "mem", "rets", "after", "tr", "reset", "r", "elt", " Ret", "cmd", "usr", "ry", "len", "conv", "ref", "ft", "gt", "status", "Ret", "pret", "not", "mt", "RET", "flag", "value", "def", "dr", "try", "resp", " RET", "back", "alt", "re", "success", "err", "set"], "version": ["versions", "v", "video", "virtual", "Version", "currency", "server", "final", "none", "driver", "supported", "scale", "feature", "required", "mode", "grade", "f", "vision", "volume", "mint", "VERS", "tag", "tr", "level", "family", "beta", "major", "quality", "iso", "class", "vers", "spec", "current", "VER", "serial", "python", "sequence", "vector", "key", "release", "conv", "time", "hash", "status", "format", "name", "browser", "number", "alone", "depth", "title", "part", "option", "package", "size", "ison", "latest", "summary", "position", "vert", "type", "VERSION", "index", "order", "date", "test", "ver"], "p": ["ap", "pc", "n", "pa", "jp", "sp", "f", "r", "b", "pp", "t", "o", "m", "pt", "P", "d", "cp", "q", "rep", "a", "fp", "np", "pb", "c", "j", "pr", "ps"], "pktsize": ["pktsization", "pktssize", "pektesizer", "pkTSize", "puktsizer", "pektsiz", "pkTsiz", "pkutsizer", "pktypesiz", "pkTSizer", "pktionsiz", "pktsiz", "pklsizes", "pkTsized", "pkutsize", "pktersizes", "pkTSized", "pukTSize", "pkutssize", "pktsizes", "pektsize", "pktersization", "pkcsiz", "pktionsization", "pkutsiz", "pekutsizer", "pklsize", "pukutsource", "pektsizer", "pkcsized", "pktsate", "pukutsiz", "pkutsized", "pktersate", "pektesate", "pktsizer", "pkTSization", "pukutsized", "pektesize", "pktypesize", "pekutsiz", "pktypesizer", "puktsize", "pektesizes", "pektersizer", "pktionsize", "pktesizes", "pkTSiz", "pktessize", "pekutssize", "pktsized", "pklsizer", "pkcsize", "pektersize", "puktsized", "pklsate", "pkcsource", "pktionsizer", "pektersiz", "puktsiz", "pektsizes", "pktesate", "pkutsource", "pukTSiz", "pukTSizer", "puktsource", "pektersization", "pktypesized", "pukTSized", "pktersiz", "pkTSource", "pkTsizer", "pktersize", "pktesiz", "pktesize", "pekutsize", "pktersizer", "pektsization", "pktsource", "pkTsize", "pektssize", "pktesizer", "pektsate", "pukutsize"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831, "substitutes": {"mc": ["ma", "pc", "md", "cms", "gc", "ms", "mot", "anc", "mic", "mem", "Mc", "mn", "lc", "mk", "fc", "mx", "bc", "dc", "MC", "mi", "cs", "mac", "mp", "cci", "cus", "ac", "tm", "ic", "mm", "m", "cc", "icc", "mr", "nic", "mt", "tc", "vc", "c", "cm", "met", "ming", "nc"], "s390mc": [" s40MC", " s390mic", "s380mm", "s350mc", "s90c", "saturatedc", " s40mc", "s40mm", "s380c", " s390ms", "rs380c", "s30ms", "s30cc", "rs380mic", "s380cc", "saturatedmc", "s380mc", " s390mm", "s390cc", "rs380cc", " s40mic", "rs390c", "s90cc", "s390ms", "s390mic", "saturatedcc", "rs380mc", "s350mm", "s40MC", "s90mc", "s40mc", " s90mc", " s90mic", "s30mic", "s350mic", " s90cc", " s390cc", "s380mic", "s380MC", " s390MC", "rs390cc", "s40mic", "s30mc", "s90ms", " s40mm", "s390c", "rs390mic", "s90mic", "s350MC", "rs390mc", "s380ms", "saturatedmic", "s390mm", " s90ms", "s390MC"]}}
{"project": "FFmpeg", "commit_id": "d9fe6b926cd619c311e45e0ae352cf09713c482c", "target": 1, "func": "static int matroska_read_header(AVFormatContext *s)\n\n{\n\n    MatroskaDemuxContext *matroska = s->priv_data;\n\n    EbmlList *attachements_list = &matroska->attachments;\n\n    MatroskaAttachement *attachements;\n\n    EbmlList *chapters_list = &matroska->chapters;\n\n    MatroskaChapter *chapters;\n\n    MatroskaTrack *tracks;\n\n    uint64_t max_start = 0;\n\n    int64_t pos;\n\n    Ebml ebml = { 0 };\n\n    AVStream *st;\n\n    int i, j, k, res;\n\n\n\n    matroska->ctx = s;\n\n\n\n    /* First read the EBML header. */\n\n    if (ebml_parse(matroska, ebml_syntax, &ebml)\n\n        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)\n\n        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n        ebml_free(ebml_syntax, &ebml);\n\n        return AVERROR_PATCHWELCOME;\n\n    } else if (ebml.doctype_version == 3) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n    }\n\n    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)\n\n        if (!strcmp(ebml.doctype, matroska_doctypes[i]))\n\n            break;\n\n    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);\n\n    }\n\n    ebml_free(ebml_syntax, &ebml);\n\n\n\n    /* The next thing is a segment. */\n\n    pos = avio_tell(matroska->ctx->pb);\n\n    res = ebml_parse(matroska, matroska_segments, matroska);\n\n    // try resyncing until we find a EBML_STOP type element.\n\n    while (res != 1) {\n\n        res = matroska_resync(matroska, pos);\n\n        if (res < 0)\n\n            return res;\n\n        pos = avio_tell(matroska->ctx->pb);\n\n        res = ebml_parse(matroska, matroska_segment, matroska);\n\n    }\n\n    matroska_execute_seekhead(matroska);\n\n\n\n    if (!matroska->time_scale)\n\n        matroska->time_scale = 1000000;\n\n    if (matroska->duration)\n\n        matroska->ctx->duration = matroska->duration * matroska->time_scale\n\n                                  * 1000 / AV_TIME_BASE;\n\n    av_dict_set(&s->metadata, \"title\", matroska->title, 0);\n\n\n\n    if (matroska->date_utc.size == 8)\n\n        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));\n\n\n\n    tracks = matroska->tracks.elem;\n\n    for (i=0; i < matroska->tracks.nb_elem; i++) {\n\n        MatroskaTrack *track = &tracks[i];\n\n        enum CodecID codec_id = CODEC_ID_NONE;\n\n        EbmlList *encodings_list = &track->encodings;\n\n        MatroskaTrackEncoding *encodings = encodings_list->elem;\n\n        uint8_t *extradata = NULL;\n\n        int extradata_size = 0;\n\n        int extradata_offset = 0;\n\n        uint32_t fourcc = 0;\n\n        AVIOContext b;\n\n\n\n        /* Apply some sanity checks. */\n\n        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&\n\n            track->type != MATROSKA_TRACK_TYPE_AUDIO &&\n\n            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n\n                   track->type);\n\n            continue;\n\n        }\n\n        if (track->codec_id == NULL)\n\n            continue;\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            if (!track->default_duration)\n\n                track->default_duration = 1000000000/track->video.frame_rate;\n\n            if (!track->video.display_width)\n\n                track->video.display_width = track->video.pixel_width;\n\n            if (!track->video.display_height)\n\n                track->video.display_height = track->video.pixel_height;\n\n            if (track->video.color_space.size == 4)\n\n                fourcc = AV_RL32(track->video.color_space.data);\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            if (!track->audio.out_samplerate)\n\n                track->audio.out_samplerate = track->audio.samplerate;\n\n        }\n\n        if (encodings_list->nb_elem > 1) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR,\n\n                   \"Multiple combined encodings not supported\");\n\n        } else if (encodings_list->nb_elem == 1) {\n\n            if (encodings[0].type ||\n\n                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&\n\n#if CONFIG_ZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&\n\n#endif\n\n#if CONFIG_BZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&\n\n#endif\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {\n\n                encodings[0].scope = 0;\n\n                av_log(matroska->ctx, AV_LOG_ERROR,\n\n                       \"Unsupported encoding type\");\n\n            } else if (track->codec_priv.size && encodings[0].scope&2) {\n\n                uint8_t *codec_priv = track->codec_priv.data;\n\n                int offset = matroska_decode_buffer(&track->codec_priv.data,\n\n                                                    &track->codec_priv.size,\n\n                                                    track);\n\n                if (offset < 0) {\n\n                    track->codec_priv.data = NULL;\n\n                    track->codec_priv.size = 0;\n\n                    av_log(matroska->ctx, AV_LOG_ERROR,\n\n                           \"Failed to decode codec private data\\n\");\n\n                } else if (offset > 0) {\n\n                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n\n                    memcpy(track->codec_priv.data,\n\n                           encodings[0].compression.settings.data, offset);\n\n                    memcpy(track->codec_priv.data+offset, codec_priv,\n\n                           track->codec_priv.size);\n\n                    track->codec_priv.size += offset;\n\n                }\n\n                if (codec_priv != track->codec_priv.data)\n\n                    av_free(codec_priv);\n\n            }\n\n        }\n\n\n\n        for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n\n            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n\n                        strlen(ff_mkv_codec_tags[j].str))){\n\n                codec_id= ff_mkv_codec_tags[j].id;\n\n                break;\n\n            }\n\n        }\n\n\n\n        st = track->stream = avformat_new_stream(s, NULL);\n\n        if (st == NULL)\n\n            return AVERROR(ENOMEM);\n\n\n\n        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")\n\n            && track->codec_priv.size >= 40\n\n            && track->codec_priv.data != NULL) {\n\n            track->ms_compat = 1;\n\n            fourcc = AV_RL32(track->codec_priv.data + 16);\n\n            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);\n\n            extradata_offset = 40;\n\n        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")\n\n                   && track->codec_priv.size >= 14\n\n                   && track->codec_priv.data != NULL) {\n\n            int ret;\n\n            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,\n\n                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);\n\n            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);\n\n            if (ret < 0)\n\n                return ret;\n\n            codec_id = st->codec->codec_id;\n\n            extradata_offset = FFMIN(track->codec_priv.size, 18);\n\n        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")\n\n                   && (track->codec_priv.size >= 86)\n\n                   && (track->codec_priv.data != NULL)) {\n\n            fourcc = AV_RL32(track->codec_priv.data);\n\n            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);\n\n        } else if (codec_id == CODEC_ID_PCM_S16BE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;\n\n            }\n\n        } else if (codec_id == CODEC_ID_PCM_S16LE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;\n\n            }\n\n        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n\n            codec_id = CODEC_ID_PCM_F64LE;\n\n        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {\n\n            int profile = matroska_aac_profile(track->codec_id);\n\n            int sri = matroska_aac_sri(track->audio.samplerate);\n\n            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n\n            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);\n\n            if (strstr(track->codec_id, \"SBR\")) {\n\n                sri = matroska_aac_sri(track->audio.out_samplerate);\n\n                extradata[2] = 0x56;\n\n                extradata[3] = 0xE5;\n\n                extradata[4] = 0x80 | (sri<<3);\n\n                extradata_size = 5;\n\n            } else\n\n                extradata_size = 2;\n\n        } else if (codec_id == CODEC_ID_TTA) {\n\n            extradata_size = 30;\n\n            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            ffio_init_context(&b, extradata, extradata_size, 1,\n\n                          NULL, NULL, NULL, NULL);\n\n            avio_write(&b, \"TTA1\", 4);\n\n            avio_wl16(&b, 1);\n\n            avio_wl16(&b, track->audio.channels);\n\n            avio_wl16(&b, track->audio.bitdepth);\n\n            avio_wl32(&b, track->audio.out_samplerate);\n\n            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);\n\n        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n\n                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n\n            extradata_offset = 26;\n\n        } else if (codec_id == CODEC_ID_RA_144) {\n\n            track->audio.out_samplerate = 8000;\n\n            track->audio.channels = 1;\n\n        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||\n\n                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {\n\n            int flavor;\n\n            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,\n\n                          0, NULL, NULL, NULL, NULL);\n\n            avio_skip(&b, 22);\n\n            flavor                       = avio_rb16(&b);\n\n            track->audio.coded_framesize = avio_rb32(&b);\n\n            avio_skip(&b, 12);\n\n            track->audio.sub_packet_h    = avio_rb16(&b);\n\n            track->audio.frame_size      = avio_rb16(&b);\n\n            track->audio.sub_packet_size = avio_rb16(&b);\n\n            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);\n\n            if (codec_id == CODEC_ID_RA_288) {\n\n                st->codec->block_align = track->audio.coded_framesize;\n\n                track->codec_priv.size = 0;\n\n            } else {\n\n                if (codec_id == CODEC_ID_SIPR && flavor < 4) {\n\n                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };\n\n                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];\n\n                    st->codec->bit_rate = sipr_bit_rate[flavor];\n\n                }\n\n                st->codec->block_align = track->audio.sub_packet_size;\n\n                extradata_offset = 78;\n\n            }\n\n        }\n\n        track->codec_priv.size -= extradata_offset;\n\n\n\n        if (codec_id == CODEC_ID_NONE)\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id);\n\n\n\n        if (track->time_scale < 0.01)\n\n            track->time_scale = 1.0;\n\n        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n\n\n        st->codec->codec_id = codec_id;\n\n        st->start_time = 0;\n\n        if (strcmp(track->language, \"und\"))\n\n            av_dict_set(&st->metadata, \"language\", track->language, 0);\n\n        av_dict_set(&st->metadata, \"title\", track->name, 0);\n\n\n\n        if (track->flag_default)\n\n            st->disposition |= AV_DISPOSITION_DEFAULT;\n\n        if (track->flag_forced)\n\n            st->disposition |= AV_DISPOSITION_FORCED;\n\n\n\n        if (!st->codec->extradata) {\n\n            if(extradata){\n\n                st->codec->extradata = extradata;\n\n                st->codec->extradata_size = extradata_size;\n\n            } else if(track->codec_priv.data && track->codec_priv.size > 0){\n\n                st->codec->extradata = av_mallocz(track->codec_priv.size +\n\n                                                  FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if(st->codec->extradata == NULL)\n\n                    return AVERROR(ENOMEM);\n\n                st->codec->extradata_size = track->codec_priv.size;\n\n                memcpy(st->codec->extradata,\n\n                       track->codec_priv.data + extradata_offset,\n\n                       track->codec_priv.size);\n\n            }\n\n        }\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_tag  = fourcc;\n\n            st->codec->width  = track->video.pixel_width;\n\n            st->codec->height = track->video.pixel_height;\n\n            av_reduce(&st->sample_aspect_ratio.num,\n\n                      &st->sample_aspect_ratio.den,\n\n                      st->codec->height * track->video.display_width,\n\n                      st->codec-> width * track->video.display_height,\n\n                      255);\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n            if (track->default_duration)\n\n                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);\n\n\n\n            /* export stereo mode flag as metadata tag */\n\n            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)\n\n                av_dict_set(&st->metadata, \"stereo_mode\", matroska_video_stereo_mode[track->video.stereo_mode], 0);\n\n\n\n            /* if we have virtual track, mark the real tracks */\n\n            for (j=0; j < track->operation.combine_planes.nb_elem; j++) {\n\n                char buf[32];\n\n                if (planes[j].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)\n\n                    continue;\n\n                snprintf(buf, sizeof(buf), \"%s_%d\",\n\n                         matroska_video_stereo_plane[planes[j].type], i);\n\n                for (k=0; k < matroska->tracks.nb_elem; k++)\n\n                    if (planes[j].uid == tracks[k].uid) {\n\n                        av_dict_set(&s->streams[k]->metadata,\n\n                                    \"stereo_mode\", buf, 0);\n\n                        break;\n\n                    }\n\n            }\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->sample_rate = track->audio.out_samplerate;\n\n            st->codec->channels = track->audio.channels;\n\n            if (st->codec->codec_id != CODEC_ID_AAC)\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n        }\n\n    }\n\n\n\n    attachements = attachements_list->elem;\n\n    for (j=0; j<attachements_list->nb_elem; j++) {\n\n        if (!(attachements[j].filename && attachements[j].mime &&\n\n              attachements[j].bin.data && attachements[j].bin.size > 0)) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");\n\n        } else {\n\n            AVStream *st = avformat_new_stream(s, NULL);\n\n            if (st == NULL)\n\n                break;\n\n            av_dict_set(&st->metadata, \"filename\",attachements[j].filename, 0);\n\n            av_dict_set(&st->metadata, \"mimetype\", attachements[j].mime, 0);\n\n            st->codec->codec_id = CODEC_ID_NONE;\n\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n\n            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if(st->codec->extradata == NULL)\n\n                break;\n\n            st->codec->extradata_size = attachements[j].bin.size;\n\n            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n\n\n\n            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n\n                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n\n                             strlen(ff_mkv_mime_tags[i].str))) {\n\n                    st->codec->codec_id = ff_mkv_mime_tags[i].id;\n\n                    break;\n\n                }\n\n            }\n\n            attachements[j].stream = st;\n\n        }\n\n    }\n\n\n\n    chapters = chapters_list->elem;\n\n    for (i=0; i<chapters_list->nb_elem; i++)\n\n        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid\n\n            && (max_start==0 || chapters[i].start > max_start)) {\n\n            chapters[i].chapter =\n\n            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n\n                           chapters[i].start, chapters[i].end,\n\n                           chapters[i].title);\n\n            av_dict_set(&chapters[i].chapter->metadata,\n\n                             \"title\", chapters[i].title, 0);\n\n            max_start = chapters[i].start;\n\n        }\n\n\n\n    matroska_add_index_entries(matroska);\n\n\n\n    matroska_convert_tags(s);\n\n\n\n    return 0;\n\n}\n", "idx": 25854, "substitutes": {"s": ["sv", "v", "n", "hs", "gs", "js", "ses", "fs", "S", "sp", "ns", "ss", "z", "ts", "spec", "t", "cs", "ats", "sb", "ins", "p", "e", "m", "aws", "ds", "g", "es", "a", "scl", "sg", "rs", "sc", "h", "as", "sys", "stats", "sts", "bs", "session", "sports", "c", "socket", "sq", "ps", "self", "set", "ctx"], "matroska": ["matrasker", " matryska", "matroka", " matrosjava", "matrisha", "mitroka", "matrosaka", "matcosha", "matrorsKA", "matstrosKA", "Matroska", "matrysker", " matrosko", "mitrosha", "mitroaka", "matriskaya", "matrusKA", "mitrisko", "matroko", "matricsla", "matstrosaka", "Matroki", "matstrosker", " matrysker", " matroskas", "matricska", "mitrosko", "matruska", "mitroska", " matrokas", "matroKA", "matroki", "matronesla", "metroskas", " matroko", "matcoska", "matroskas", "matrojava", "Matroaka", " matroka", "matrorsaka", "matrorski", "mitrosker", "matroskaya", " matrysjava", "matstroskaya", "masstrosKA", "matriska", "umatrusko", "matroaka", "matstroska", "matrosker", "matrosKA", "metroskaya", "umatruska", "matroker", "matrosha", "matrorska", "Matroski", "Matrosaka", "umatrosker", "matrsker", "mitroker", "masstroska", " matrosaka", "Matroka", "mitrosaka", "mitriska", "matrorsjava", "matcosko", "masroska", "mitrokas", "matrsaka", "mitroskaya", "matrokas", "matcoskaya", "matstroskas", "masrosker", "umatroska", "matronesKA", "mitrisha", "matrusko", "metstroskaya", "matricsKA", "matrosjava", "matrokaya", "matrysjava", "masrosKA", "matrorsker", "metrosaka", " matroha", "matronesker", "matrisko", "matrusha", "matrisaka", "matruskaya", "mitroskas", "matryska", "matrska", "matroneska", "matrosla", "umatroskas", "matraskas", "mitriskaya", "matraska", "masstrosker", "matroha", "matrsha", "matroski", "metstroska", "matrysaka", "matrsko", "matrusaka", "matrusker", "matrosko", "matriskas", "masstrosla", "umatruskas", "matricsker", "umatrusker", "MatroKA", "matrasko", "matruski", "matstrosla", "metroska", "matrskas", " matrysaka", "masrosla", "matruskas", "umatrosko", "MatrosKA", "metstrosaka", "metstroskas", " matrosha", " matrosker"], "attachements_list": ["attachement_LIST", "attachement_set", "attachement_list", "attachement_type", "attachements_set", "attachements_LIST", "attachements_type"], "attachements": ["attattachment", "attachment", "accachements", "attachMENTS", "attachments", "accachets", "attattachments", "attachesment", "attachesMENTS", "attacheMENTS", "accachts", "accacheMENTS", "attachests", "attachesments", "accachment", "accachMENTS", "attattachts", "attachets", "attachts", "accachments", "attattachMENTS", "attachement", "accachement"], "chapters_list": ["chapter_List", "chapters2list", "chapters_st", "chapter_st", "chapter_LIST", "chapters_List", "chapter_list", "chapters_LIST", "chapters2LIST", "chapters2List", "chapters2st"], "chapters": ["chards", "hapters", "cleaps", "echars", "chars", "achars", "clears", "charms", "chaps", "hars", "harms", "cards", " churches", "cleards", " chars", "hurches", "acharms", "churches", "achapters", "echaps", "cleapters", " charms", "cars", "echards", "achurches", "echapters", "caps", "capters"], "tracks": ["tags", "ks", "utters", "maps", "rows", "reads", "pages", "hops", "thumbnails", "orders", "acks", "forms", "pps", "staff", "heads", "reports", "charges", "lists", "ids", "bands", "dds", "events", "shows", "items", "shots", "aunts", "uploads"], "pos": ["limit", "top", "pc", "offset", "client", "params", "Pos", "pro", "slot", " position", "seq", "trans", "pid", "spec", "pres", "len", "meta", "port", "o", "p", "pt", "Position", "P", "pose", "os", "pi", "base", "no", "def", "position", "point", "pointer", "tmp", "POS", "start", "pr", "proc", "index", "ps", "po"], "st": ["sv", "ST", "ist", "St", "ast", "sp", "tt", "src", "ss", "se", "std", "sh", "str", "sl", "sw", "ct", "so", "sc", "stable", "tmp", "sts", "ost", "rest", "sn", "est", "bt", "ste", "ust"], "i": ["qi", "v", "is", "me", "in", "li", "f", "ix", "xi", "ai", "go", "ini", "ami", "gi", "ci", "z", "di", "hi", "ii", "t", "mi", "key", " bi", "ei", "cli", "ims", "o", "m", "e", "p", "multi", "sim", "g", "ui", "ic", " ii", "pi", "a", "depth", "\u0438", "im", "h", "ti", "zi", "index", "x", "c", "y", "it", "si", "bi", "ind", "I"], "j": ["v", "aj", "n", "js", "J", "ij", "jp", "jl", "kj", "ji", "z", "o", "p", "m", "jj", "g", "jump", "q", "jc", "bj", "uj", "l", "index", "x", "bi"], "k": ["v", "kid", "ks", "km", "kj", "ku", "ki", "kk", "ko", "key", "sk", "ok", "kh", "m", "kn", "ak", "ek", "ket", "ke", "q", "ck", "ka", "K", "tk", "ik", "kw", "kr"], "res": ["vals", "result", "js", "ms", "R", "Res", "resolution", "tx", "ss", "reset", "pres", "new", "req", "ref", "ins", "ress", "rel", "os", "rs", "vol", "RES", "rc", "resp", "us", "re", "rest", "ps", "err"]}}
{"project": "FFmpeg", "commit_id": "feb13aed794a7f1a1f8395159e9b077351348a34", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    SignatureContext *sic = ctx->priv;\n\n    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);\n\n    FineSignature* fs;\n\n\n\n    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };\n\n    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296\n\n    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...\n\n    */\n\n    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};\n\n    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};\n\n\n\n    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */\n\n    uint64_t intpic[32][32];\n\n    uint64_t rowcount;\n\n    uint8_t *p = picref->data[0];\n\n    int inti, intj;\n\n    int *intjlut;\n\n\n\n    uint64_t conflist[DIFFELEM_SIZE];\n\n    int f = 0, g = 0, w = 0;\n\n    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;\n\n    int64_t denom;\n\n    int i, j, k, ternary;\n\n    uint64_t blocksum;\n\n    int blocksize;\n\n    int64_t th; /* threshold */\n\n    int64_t sum;\n\n\n\n    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;\n\n\n\n    /* initialize fs */\n\n    if (sc->curfinesig) {\n\n        fs = av_mallocz(sizeof(FineSignature));\n\n        if (!fs)\n\n            return AVERROR(ENOMEM);\n\n        sc->curfinesig->next = fs;\n\n        fs->prev = sc->curfinesig;\n\n        sc->curfinesig = fs;\n\n    } else {\n\n        fs = sc->curfinesig = sc->finesiglist;\n\n        sc->curcoarsesig1->first = fs;\n\n    }\n\n\n\n    fs->pts = picref->pts;\n\n    fs->index = sc->lastindex++;\n\n\n\n    memset(intpic, 0, sizeof(uint64_t)*32*32);\n\n    intjlut = av_malloc_array(inlink->w, sizeof(int));\n\n    if (!intjlut)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < inlink->w; i++) {\n\n        intjlut[i] = (i*32)/inlink->w;\n\n    }\n\n\n\n    for (i = 0; i < inlink->h; i++) {\n\n        inti = (i*32)/inlink->h;\n\n        for (j = 0; j < inlink->w; j++) {\n\n            intj = intjlut[j];\n\n            intpic[inti][intj] += p[j];\n\n        }\n\n        p += picref->linesize[0];\n\n    }\n\n    av_freep(&intjlut);\n\n\n\n    /* The following calculates a summed area table (intpic) and brings the numbers\n\n     * in intpic to the same denominator.\n\n     * So you only have to handle the numinator in the following sections.\n\n     */\n\n    dh1 = inlink->h / 32;\n\n    if (inlink->h % 32)\n\n        dh2 = dh1 + 1;\n\n    dw1 = inlink->w / 32;\n\n    if (inlink->w % 32)\n\n        dw2 = dw1 + 1;\n\n    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        rowcount = 0;\n\n        a = 1;\n\n        if (dh2 > 1) {\n\n            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32;\n\n            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32;\n\n            a = (a == dh1)? dh2 : dh1;\n\n        }\n\n        for (j = 0; j < 32; j++) {\n\n            b = 1;\n\n            if (dw2 > 1) {\n\n                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32;\n\n                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32;\n\n                b = (b == dw1)? dw2 : dw1;\n\n            }\n\n            rowcount += intpic[i][j] * a * b * precfactor / denom;\n\n            if (i > 0) {\n\n                intpic[i][j] = intpic[i-1][j] + rowcount;\n\n            } else {\n\n                intpic[i][j] = rowcount;\n\n            }\n\n        }\n\n    }\n\n\n\n    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;\n\n\n\n    for (i = 0; i < ELEMENT_COUNT; i++) {\n\n        const ElemCat* elemcat = elements[i];\n\n        int64_t* elemsignature;\n\n        uint64_t* sortsignature;\n\n\n\n        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!elemsignature)\n\n            return AVERROR(ENOMEM);\n\n        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!sortsignature)\n\n            return AVERROR(ENOMEM);\n\n\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            blocksum = 0;\n\n            blocksize = 0;\n\n            for (k = 0; k < elemcat->left_count; k++) {\n\n                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n            }\n\n            sum = blocksum / blocksize;\n\n            if (elemcat->av_elem) {\n\n                sum -= 128 * precfactor * denom;\n\n            } else {\n\n                blocksum = 0;\n\n                blocksize = 0;\n\n                for (; k < elemcat->block_count; k++) {\n\n                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n                }\n\n                sum -= blocksum / blocksize;\n\n                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));\n\n            }\n\n\n\n            elemsignature[j] = sum;\n\n            sortsignature[j] = FFABS(sum);\n\n        }\n\n\n\n        /* get threshold */\n\n        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);\n\n        th = sortsignature[(int) (elemcat->elem_count*0.333)];\n\n\n\n        /* ternarize */\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            if (elemsignature[j] < -th) {\n\n                ternary = 0;\n\n            } else if (elemsignature[j] <= th) {\n\n                ternary = 1;\n\n            } else {\n\n                ternary = 2;\n\n            }\n\n            fs->framesig[f/5] += ternary * pot3[f%5];\n\n\n\n            if (f == wordvec[w]) {\n\n                fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];\n\n                if (w < 24)\n\n                    w++;\n\n            }\n\n            f++;\n\n        }\n\n        av_freep(&elemsignature);\n\n        av_freep(&sortsignature);\n\n    }\n\n\n\n    /* confidence */\n\n    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);\n\n    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);\n\n\n\n    /* coarsesignature */\n\n    if (sc->coarsecount == 0) {\n\n        if (sc->curcoarsesig2) {\n\n            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));\n\n            if (!sc->curcoarsesig1)\n\n                return AVERROR(ENOMEM);\n\n            sc->curcoarsesig1->first = fs;\n\n            sc->curcoarsesig2->next = sc->curcoarsesig1;\n\n            sc->coarseend = sc->curcoarsesig1;\n\n        }\n\n    }\n\n    if (sc->coarsecount == 45) {\n\n        sc->midcoarse = 1;\n\n        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));\n\n        if (!sc->curcoarsesig2)\n\n            return AVERROR(ENOMEM);\n\n        sc->curcoarsesig2->first = fs;\n\n        sc->curcoarsesig1->next = sc->curcoarsesig2;\n\n        sc->coarseend = sc->curcoarsesig2;\n\n    }\n\n    for (i = 0; i < 5; i++) {\n\n        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);\n\n    }\n\n    /* assuming the actual frame is the last */\n\n    sc->curcoarsesig1->last = fs;\n\n    if (sc->midcoarse) {\n\n        for (i = 0; i < 5; i++) {\n\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n\n        }\n\n        sc->curcoarsesig2->last = fs;\n\n    }\n\n\n\n    sc->coarsecount = (sc->coarsecount+1)%90;\n\n\n\n    /* debug printing finesignature */\n\n    if (av_log_get_level() == AV_LOG_DEBUG) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n\n        for (i = 0; i < 5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] );\n\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n\n        for (i = 0; i < SIGELEM_SIZE/5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] );\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n\n\n    if (FF_INLINK_IDX(inlink) == 0)\n\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n\n    return 1;\n\n}\n", "idx": 25859, "substitutes": {"inlink": ["cinframe", "cinline", "Inframe", "INlock", "cinlock", " inscan", "INlink", "outlock", "Inlock", " inLink", "outlink", "cinlink", "inlock", "inLink", "INline", "InLink", "Inlink", "inscan", "innline", " inlock", "outink", "Inline", "inframe", " inframe", "Inink", "outLink", "inink", "innlock", "innscan", "INscan", "innlink", " inink"], "picref": ["picReference", " picRef", "sciref", "sciReference", "Picreference", "sciRef", "picreference", " picReference", "Picdef", "Picref", "PicReference", "icRef", " picdef", "icreference", "picRef", "picdef", "PicRef", " picreference", "scireference", "icref", "icdef"], "ctx": ["init", "ca", "cmp", "cl", "conn", "gc", "jp", "context", "tx", "loc", "lc", "ci", "mc", "std", "xc", "pkg", "bc", "dc", "cu", "sec", "ref", "kh", "ic", "unc", "cc", "cf", "jac", "ct", "icc", "voc", "sys", "conf", "tc", "cm", "sci", "sq", "ctrl", "nc"], "sic": ["sie", "sis", "ih", "Sac", "isc", "ksh", "sat", "aci", "mic", "Si", "sil", "sac", "ci", "tic", "ics", "sec", "cus", "cci", "ic", "sing", "cens", "icc", "crit", "pac", "ritz", "itis", "aic", "SI", "webkit", "sit", "tc", "usc", "sci", "si", "tis"], "sc": ["ca", "cv", "pc", "cl", "isc", "gc", "anc", "sp", "sac", "ss", "asc", "lc", "cr", "mc", "ci", "psc", "bc", "dc", "cs", "sec", "SC", "ac", "uc", "ec", "ic", "unc", "cc", "sw", "icc", "esc", "scl", "sync", "osc", "arc", "rc", "sys", "tc", "sch", "Sc", "usc", "desc", "c", "cm", "scope", "sci", "sq", "ctrl", "nc", "ch"], "fs": ["pc", "hs", "gs", "js", "ms", "fr", "bf", "obs", "faces", "ils", "sf", "ns", "ss", "fc", "ts", "qs", "rys", "fn", "xf", "fw", "ics", "cs", "gets", "uf", "ats", "ims", "FS", "fd", "irs", "fps", "ours", "ds", "cf", "ls", "ows", "wcs", "Fs", "fb", "rs", "fp", "acs", "vs", "sys", "fi", "aos", "us", "cells", "bs", "flows", "fts", "files", "ps", "rss"], "pot3": ["op03", "op3", "pot0", "pot5", "pos03", "sky03", "pot03", "sky0", "pos5", "sky5", "sky3", "pos3", "op0", "op5", "pos0"], "wordvec": ["wordcap", "bytecap", "wordsvec", "wordscap", "wordsbuf", "bytebuf", "bytev", "charvec", "charcap", "charbuf", "wordbuf", "wordv", "wordsv", "charv", "bytevec"], "s2usw": ["s2ux", "s2sy", "s2uws", "s2uy", "s2usx", "s0psws", "s2usws", "s0psw", "s0usws", "s2psx", "s2sws", "s0psy", "s2sw", "s2psw", "s2usy", "s0usy", "s0psx", "s2psws", "s2psy", "s2uw", "s2sx", "s0usx", "s0usw"], "wordt2b": ["worde2b", "worde1bb", "worde2be", "wordt5be", "wordt2be", "worde2a", "wordt_be", "wordt1be", "wordt1a", "wordt5b", "wordt2a", "worde1b", "worde1be", "wordt1bb", "worde2bb", "worde1a", "wordt5bb", "wordt_a", "wordt2bb", "wordt_b", "wordt5a", "wordt_bb", "wordt1b"], "intpic": [" intarr", "intPic", "intsarr", " intfc", "intsfc", "intfc", "structarr", "structfc", "intspic", "intarr", "intsPic", "structPic", "structpic", " intPic"], "rowcount": ["runCount", "rowslength", "rowssum", "rowscount", "rowCount", "rowsCount", "rollcount", "rowsum", "rowlength", "runlength", "rolllength", "rollsum", "rollCount", "runsum", "runcount"], "p": ["v", "pc", "n", "pa", "jp", "op", "pp", "t", "ip", "o", "m", "pic", "g", "P", "d", "cp", "u", "rep", "pi", "fp", "h", "c", "pb", "pr"], "inti": ["intsi", "indsi", "interi", "indj", "indi", " intsi", "intersi", "interj"], "intj": ["intn", "intern", "in", "interb", "ij", "intb", " intb", "interj", "ib", " intn"], "intjlut": ["intgluts", "intjluts", "intlut", "intlute", " intgloud", " intjluts", " intgluts", "intluts", "intknut", "intloud", "intknute", "intjlute", "intglut", "intjloud", " intjlute", " intglut", " intjloud", "intgloud", "intglute", " intglute", "intknuts", "intknoud"], "conflist": ["conmlost", "conselist", "conmlist", "coflite", "conmlabel", "conflabel", "coclist", "conclite", "coflist", "conselite", "conselabel", "conclist", "conclost", "conclabel", "conmlite", "coclost", "conflite", "conselost", "coclite", "coflabel", "coclabel", "coflost", "conflost"], "a": ["ca", "v", "ap", "ba", "sa", "va", "am", "ar", "r", "an", "at", "area", "alpha", "ac", "o", "m", "e", "ae", "ak", "aa", "ab", "A", "au", "as", "c", "x"], "b": ["B", "v", "n", "ba", "db", "bf", "cb", "r", "rb", "eb", "bc", "m", "e", "g", "bb", "d", "be", "fb", "ab", "l", "bs", "c", "y", "bi"], "denom": ["genomin", "denoc", "enoc", "denoms", "gnomin", "gnoms", "genoms", "gnoc", "enomin", "gnom", "genom", "genoc", "enoms", "denomin", "enom"], "i": ["v", "n", "in", "li", "ix", "xi", "r", "ci", "ii", "t", "mi", "ic", "o", "m", "g", "u", "pi", "h", "l", "c", "x", "y", "I"], "j": ["v", "aj", "n", "J", "ij", "jp", "kj", "ji", "r", "z", "t", "je", "o", "m", "g", "jj", "jump", "q", "jc", "l", "br", "y", "dj", "ja"], "k": ["v", "n", "max", "km", "kind", "kj", "mk", "ku", "kk", "ko", "key", "kh", "o", "m", "ak", "ek", "u", "q", "ck", "ka", "K", "y", "tk", "c", "ik", "kw", "kr"], "ternary": ["ternaries", "ineral", "inerary", "ternical", "inerical", "tonical", "tonaries", "tonary", "ineraries", "internical", "ternal", "internaries", "internary", "tonal"], "blocksum": ["offsums", "blocksumm", "bsumm", "blocksums", "offsum", "ksumm", "ksum", "ksums", "ksumer", "offsumm", "blocksumer", "offsumer", "bsumer", "bsums", "bsum"], "blocksize": ["kspace", "rowsize", "blockspace", "rowsization", "rowside", "namesize", "ksization", "blocksization", "namesization", "ksize", "namespace", "blockside", "rowspace", "kside", "nameside"], "th": ["hr", "chron", "foot", "TH", "half", "each", "thin", "tr", "td", "third", "std", "oth", "bl", "sec", "sh", "kh", "bh", "ct", "eth", "h", "st", "thread", "ctr", "ths", "head", "ht", "proc", "kw", "ch"], "sum": ["ma", "gram", "count", "Sum", "sam", "scale", "mem", "mod", "um", "mult", "fac", "total", "bin", "add", "sim", "hash", "pack", "cal", "mean", "size", "vol", "num", "cum", "asm", "head", "dim", "sym", "prof"], "w": ["v", "n", "W", "wp", "wa", "wl", "wd", "r", "z", "fw", "t", "m", "wh", "g", "d", "nw", "sw", "u", "q", "rw", "h", "wt", "wb", "x", "y"], "f": ["v", "n", "fa", "r", "z", "F", "fc", "t", "o", "m", "e", "g", "cf", "d", "u", "ef", "h", "l", "fi", "ff", "c", "x"]}}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862, "substitutes": {"ahci": ["ohdi", "hki", "yahpi", "ashpi", "achci", "ayc", "ahlc", "ashcgi", "achelc", "ohcin", "yahnic", "akhcci", "achpi", "aycin", "yahcu", " ahpi", "ehco", "akhcit", "ohki", "akhco", "ohci", "ehcit", "ashclient", "akhnic", "yahci", "achecgi", "ashcin", "ehki", "ehdi", "aphdi", "aphpi", "ehcgi", "achec", "ohcit", "habci", "habcci", "ashcci", "yahcit", "aphcci", "ashcu", "ahki", "ahcci", "achepi", "ehc", "ohcirc", "ashcil", "achecci", "ashco", "yahcci", "achlc", "ehcil", "achdi", "achefi", "habdi", "ohco", "ashcos", "hcci", "ehfi", "ashki", "ahcil", "ehlc", "akhcu", "achecit", "hclient", "ahfi", "ayki", "akhclient", "ohcil", "ahnic", "habcin", " ahki", "acheco", "aydi", " ahdi", " ahcirc", "ohpi", "ahcu", "ehpi", "ahcit", " ahcu", "ehcin", "ahc", "ohcos", " ahnic", "aphci", "hcos", "hci", "ahcgi", "ahco", "achecin", "ehci", "ahcos", "achcin", "ahdi", "achenic", " ahco", "achcci", " ahcci", "hnic", "ashcit", "hcu", "ohcu", "ashlc", "ohcci", "ahclient", "ahcin", " ahcit", "ashfi", "akhki", "aycit", "hpi", "ashcirc", "akhci", "ayci", "aylc", "ahpi", "ashci", "ashdi", "acheci", "ahcirc"], "cmd": ["command", "obj", "vp", "method", "conn", "exec", "txt", "comp", "om", "cb", "phy", "kt", "pkg", "func", "ctl", "canon", "def", "qq", "form", "inv", "ind", "nt", "control", "op", "det", "wd", "norm", "process", "std", "grad", "act", "fun", "cod", "cat", "send", "quit", "bind", "tab", "kick", "ct", "cp", "call", "adv", "handle", "col", "buf", "cy", "qt", "prop", "ctrl", "cfg", "ctx", "wp", "opt", "mk", "fn", "mson", "fw", "cli", "cn", "comm", "cf", "ck", "mt", "rpm", "good", "ctr", "cont", "vc", "msg", "cmp", "md", "js", "Cmd", "ext", "cd", "job", "cr", "dq", "req", "draw", "pt", "cc", "help", "batch", "ch", "core"], "px": ["ax", "ex", "pc", "tp", "xx", "ms", "bp", " pos", "sp", "xp", "ix", "wx", "pl", "png", "ts", "xf", "mx", "xc", "dx", "act", "ip", "padding", "yx", "tm", "p", "pps", "pad", "pt", "fx", "ping", "pic", "cp", "pi", "prefix", "pex", "pixel", "lex", "pointer", "xy", "tmp", "addr", "xs", "pr", "pos", "x", "ps", "port", "yp", "ctx"], "tx": ["ax", "nt", "xml", "ex", "res", "text", "ta", "ty", "txt", "rt", "ix", "wx", "context", "mem", "op", "tr", "TX", "trans", "ts", "Tx", "xf", "mx", "ox", "t", "xt", "act", "dx", "ref", "tm", "str", "pt", "fx", "prefix", "mt", " ty", " TX", "def", "lex", "rix", "tmp", "addr", "tc", "word", "xs", "pr", "index", "x", "buf", "msg", "hea", "ctx"], "rx": ["ax", "ex", "rez", "res", "xx", "rew", "ty", "rip", "txt", "rr", "xp", "rt", "wx", "rl", "rex", "TX", "rb", "r", "ux", "rys", "xf", "rd", "xc", "ry", "mx", "ox", "act", "xt", "dx", "rax", "ri", "expr", "fx", "rw", "rm", "rs", "rc", "lex", "xs", "re", "pr", "x", "vr", "xff", "ctx"], "ptr": ["nz", "txt", "jp", "ix", "pointers", "rect", "loc", "inters", "vt", "ref", "p", "hw", "ping", "pointer", "Ptr", "pr", "ps", "ind", "ax", "pc", "tip", "ped", "offset", "inst", "trans", "ts", "address", "pad", "dev", "inter", "cp", "rep", "grow", "addr", "handle", "vr", "ctx", "tp", "xp", "rt", "tr", "ry", "fx", "py", "dr", "try", "ctr", "resp", "tmp", "proc", "index", "v", "md", "js", "fr", "ty", "eps", "sp", "prime", "checked", "esp", "pl", "push", "t", "xt", "req", "pt", "eth", "br", "x", "err", "yp"]}}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n", "idx": 25865, "substitutes": {"opaque": ["oposter", "poster", "Opatile", "OPatile", " opque", "ospeno", "Oplay", "osposter", "pacity", "oacity", "oeno", "ospaque", "ospacity", "peno", "opacity", "OPque", " opatile", " oplay", "openo", "Opque", "oplay", "opatile", "oaque", "ooster", "opque", "OPlay", "OPaque", "paque", "Opaque"], "addr": ["Address", "rev", "url", "obj", "cmp", "nl", "adr", "offset", "host", "ext", "src", "arp", "ix", "mem", "tag", "tx", "hl", "ack", "loc", "r", "state", "cmd", "attr", "address", "block", "act", "coord", "arr", "align", "ref", "add", "hash", "hw", "str", "pad", "name", "rel", " address", "prefix", "id", "mt", "ad", "rs", "dr", "help", "ord", "handle", "alias", "pos", "x", "ptr", "msg", "alt", "err"], "g": ["ig", "v", "gen", "gu", "gs", "gc", " G", "gr", "gl", "bg", "gd", "go", "og", "tg", "gi", "ger", "ag", "pg", "gp", "greg", "gb", "gm", "ge", "G", "m", "gt", "d", "gas", "q", "sg", "arg", "fg", "game", "h", "ga", "mg", "gg", "eg", "j", "c", "msg", "cfg"]}}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    int64_t size;\n\n    AVIOContext *pb  = s->pb;\n\n    WAVContext    *wav = s->priv_data;\n\n    AVStream *st;\n\n    uint8_t guid[16];\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_riff, 16))\n\n        return -1;\n\n\n\n    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */\n\n        return -1;\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_wave, 16)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find wave guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    size = find_guid(pb, guid_fmt);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find fmt guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* subtract chunk header size - normal wav file doesn't count it */\n\n    ff_get_wav_header(pb, st->codec, size - 24);\n\n    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);\n\n\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n\n\n    av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n    size = find_guid(pb, guid_data);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find data guid\\n\");\n\n        return -1;\n\n    }\n\n    wav->data_end = avio_tell(pb) + size - 24;\n\n    wav->w64      = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 25868, "substitutes": {"s": ["sv", "aus", "v", "pc", "n", "is", "gs", "js", "ms", "ses", "sa", "ctx", "fs", "S", "sp", "ns", "f", "ss", "b", "z", "ts", "qs", "t", "cs", "ssl", "south", "ats", "sb", "ins", "ims", "p", "comm", "m", "aws", "ds", "g", "out", "ls", "os", "a", "es", "sg", "rs", "sc", "summary", "h", "vs", "l", "sys", "conf", "stats", "sts", "bs", "its", "i", "j", "c", "sq", "ps", "sm", "w"], "ap": ["tap", " mp", "rap", "bp", "pa", "sp", " af", "ar", " sam", "op", " sp", "pp", " pars", "ip", "al", "mp", "ac", " p", "ad", "pac", "att", "ape", "aps", "np", "amp", "cap", "ep", "ps"], "size": ["max", "zero", "any", "message", "len", "align", "time", "e", "news", "window", "position", "capacity", "now", "type", "form", "gz", "c", "set", "to", "n", "gc", "offset", "small", "body", "address", "sent", "sh", "send", "dimension", "fee", "grow", "num", "length", "export", "data", "args", "count", "scale", "shape", "see", "z", "sum", "sample", "zone", "space", "buffer", "l", "global", "empty", "sn", "v", "cache", "member", "sp", "mem", "ize", "area", "code", "format", "g", "name", "sw", "ze", "number", "SIZE", "storage", "height", "span", "gravity", "dim", "Size"], "pb": ["obj", "vp", "lp", "txt", "jp", "tx", "stab", "cb", "b", "pg", "pkg", "patch", "p", "px", "np", "tk", "pr", "ps", "prot", "pc", "db", "pa", "client", "peer", "ob", "td", "rb", "ts", "pp", "cod", "sb", "cp", "bj", "fp", "wb", "buf", "ctx", "cv", "tp", "bp", "wp", "lb", "xp", "pan", "pid", "uf", "conv", "buffer", "py", "mt", "ib", "rpm", "sys", "resp", "pm", "proc", "msg", "PB", "mb", "sp", "pl", "pro", "tg", "at", "mp", "pod", "bh", "pt", "snap", "soc", "span", "jpg", "bs"], "wav": ["aus", "v", "cv", "acc", "ait", "cam", "wp", "raw", "aw", "txt", "uv", "aux", "wa", "mem", "wl", "mu", "tx", "mpeg", "waves", "voice", "web", "mson", "AV", "wave", "arr", "mp", "conv", "uf", "auc", "audio", "hw", "wi", "aft", "sw", "news", "craft", "rw", "pac", "fp", "ra", "ww", "au", " av", "av", "asm", "mus", "buf", "ech", "ff", "aver", "w"], "st": ["sv", "nt", "v", "obj", "ust", "stop", "fr", "ST", "th", "ist", "St", "ast", "sp", "tt", "ut", "src", "rt", "inst", "td", "step", "z", "stan", "ts", "se", "std", "sty", "new", "t", "art", "sh", "sb", "p", "str", "pt", "sl", "irst", "sw", "ct", "stream", "so", "nd", "mt", "sc", "tmp", "stable", "sts", "ost", "start", "stat", "sta", "sn", "rest", "ptr", "ste", "est", "ctx"], "guid": ["gruide", "GUid", "giiden", "juids", "camaid", "gnide", "ggid", "camids", "GuID", "uuaid", "camide", "gnido", "giide", "gruoid", "guaid", "guido", "euiden", "GUID", "guID", "Guids", "guard", "ggids", "uuids", "Guid", "uuide", "camid", "gruid", "guids", "gnid", "gruID", "euido", "giido", "eeiden", "Guoid", "giid", "juard", "guoid", "ggard", "gniden", "eeid", "eeido", "Guide", "Guaid", "Guido", "uuid", "guide", "GUide", "Guard", "juid", "Guiden", "euid", "guiden", "GUoid"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 25869, "substitutes": {"src": ["our", "dest", "ipl", "ur", "sr", "in", "ser", "source", "inst", "rl", "load", "supp", "usr", "iv", "gb", "sec", "sb", "secure", "scan", "sel", "sub", "sl", "stream", "check", "sur", "rs", "sc", "img", "rc", "s", "st", "cont", "sys", "input", "screen", "usc", "sn", "sq", "ch"], "dst": ["sbl", "dest", "rst", "adST", "scr", "dbl", " dcr", "Drc", "drc", "adst", " dest", "Dcr", "ddest", "dST", "Dbl", " dST", "rST", "dcr", "adest", "addest", " drc", " dbl", " ddest", "Dst", "rdest", "sst", "rest"], "src_size": ["src_length", "rc_space", "src_scale", "src_Size", "rc_size", "rc_length", "src_shape", "rc_scale", "src_space", "rc_Size", "rc_shape"], "i": ["init", "qi", "ex", "gu", " j", "n", "asi", "is", " I", "me", "li", "json", "ij", "jp", "print", "ix", "xi", "ai", "ini", "ji", "gi", "ci", "ki", "info", "di", "ik", "ii", "ip", "mi", " x", " bi", "cli", "sim", "ic", "p", "m", "multi", "status", "ri", "ui", " ii", "pi", "id", "\u0438", "im", "uri", "series", "iu", "us", " ti", "ti", "zi", "j", "batch", "x", "index", "phi", "y", "it", "si", "bi", "ind", "I"], "b": ["B", "v", "n", "ba", "bis", "db", "bg", "f", "ob", "cb", "rb", "bc", "gb", "t", "bin", "sb", "by", "o", "p", "e", "m", "bb", "d", "be", "u", "bound", "a", "nb", "base", "fb", "ab", "s", "l", "br", "bs", "back", "c", "x", "j", "y", "bi"], "g": ["ig", "gen", "gu", "n", "gs", "gc", "gr", "bg", "gray", "f", "gd", "group", "go", "gre", "tg", "gi", "reg", "ger", "pg", "gp", "gm", "gb", "rg", "ge", "G", "p", "e", "m", "gt", "green", "d", "u", "fg", "game", "ga", "l", "mg", "gh", "gg", "eg", "j", "c", "ug"], "r": ["n", "ur", "res", "sr", "range", "red", "gr", "R", "rr", "term", "rt", "f", "ar", "rl", "or", "cr", "rb", "reg", "attr", "usr", "rd", "rate", "t", "rg", "ri", "p", "e", "m", "rel", "d", "rar", "u", "mr", "rh", "rm", "rat", "rs", "rc", "dr", "l", "s", "br", "re", "pr", "c", "ro", "vr", "err", "rect", "w"], "rgb": ["rgg", "srpy", " rgd", "rcgg", "urgg", "urg", "rgd", "rgt", "rbgg", "srgb", "rrimg", "urimg", " rgg", "rrgb", "rcgd", "srimg", "srg", "trxy", "srval", "rbg", "rraspberry", " rgt", "raspberry", " rimg", "ratimg", "rrgt", " rggb", "trval", "rimage", "rbimage", "rpy", "rxy", "rg", "trgb", "rval", "rcgt", "ratgb", "rrbg", " rval", " rxy", " rgimage", " raspberry", "urgb", "rrgd", "srgg", "rbgb", "rcgb", " rpy", " rimage", "rrgg", "trpy", "srxy", " rg", "rataspberry", "rimg", " rggg", "ratbg", " rbg"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872, "substitutes": {"job": ["command", "work", "bug", "scene", "db", "obs", "jp", "node", "slot", "item", "ob", "lock", "journal", "cmd", "process", "dq", "web", "block", "cell", "image", "plot", "Job", "jj", "queue", "cp", "project", "package", "worker", "gov", "jar", "task", "jobs", "row", "module", "batch", "j", "msg"], "x": ["ax", "ex", "v", "on", "xp", "ix", "wx", "xi", "tx", "r", "X", "z", "xf", "ry", "at", "ox", "dx", "t", "xt", "lon", "yx", "rx", "m", "p", "fx", "g", "d", "min", "px", "lat", "position", "l", "xy", "ue", "xs", "i"], "y": ["v", "top", "iny", "Y", "ty", "ery", "ay", "b", "ym", "ey", "wy", "ye", "gy", "ry", "uy", "oy", "t", "yy", "ya", "my", "m", "p", "fy", "hy", "dy", "yl", "asy", "ny", "py", "yt", "ies", "yo", "iy", "xy", "ys", "axy", "i", "vy", "cy", "sy", "yer", "ch"], "w": ["v", "ex", "we", "n", "wr", "W", "wp", "ow", "wa", "wx", "wl", "wd", "z", "fw", "t", "win", "m", "hw", "p", "wh", "wn", "wi", "g", "nw", "d", "sw", "q", "ew", "rw", "window", "a", "ww", "wid", "wt", "l", "iw", "wb", "kw"], "h": ["ih", "ph", "v", "k", "th", "history", "H", "r", "ha", "z", "b", "hi", "hei", "hh", "t", "oh", "sh", "kh", "hash", "m", "bh", "p", "wh", "g", "ah", "dh", "d", "rh", "q", "high", "hd", "s", "height", "l", "ho", "gh", "i", "ht", "c", "ish", "ch", "length"], "entry": ["nt", "command", "RY", "owner", "enter", "and", "obj", "oe", "ient", "basic", "next", "member", "aux", "ent", "primary", "item", "event", "query", "or", "see", "store", "r", "manager", "info", "ry", "cell", "component", "match", "add", "qa", "connection", "attribute", "line", "queue", "import", "inter", "cue", "escape", "check", "element", "up", "error", "section", "insert", "cur", "def", "try", "row", "record", "tmp", "ue", "back", "field", "desc", "pair", "Entry", "ie", "access", "set"]}}
{"project": "qemu", "commit_id": "54f254f973a1b2ed0f3571390f4de060adfe23e8", "target": 0, "func": "static void uhci_async_complete_packet(USBPacket * packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCI_QH qh;\n\n    UHCI_TD td;\n\n    uint32_t link;\n\n    uint32_t old_td_ctrl;\n\n    uint32_t val;\n\n    uint32_t frame_addr;\n\n    int ret;\n\n\n\n    /* Handle async isochronous packet completion */\n\n    frame_addr = s->async_frame_addr;\n\n    if (frame_addr) {\n\n        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n        le32_to_cpus(&link);\n\n\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret == 2) {\n\n            s->async_frame_addr = frame_addr;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            val = cpu_to_le32(td.link);\n\n            cpu_physical_memory_write(frame_addr,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25925, "substitutes": {"packet": ["ppacket", "ppkt", "preset", "ppet", "preskt", "presacket", "packkt", "octacket", "octkt", "packacket", "octet"], "opaque": [" opoid", "Opaques", "opposit", "oppaque", "oboid", "popaques", "obaque", " opaques", "Oposit", "popaque", "opoid", "oposit", "opaques", "Opacity", "opacity", "oppacity", "oppaques", "obaques", "Opoid", "popacity", "poposit", "Opaque"], "s": ["sv", "sis", "settings", "n", "is", "hs", "gs", "js", "bis", "ses", "services", "sp", "S", "fs", "serv", "ns", "store", "ss", "r", "b", "ts", "state", "se", "spec", "sm", "t", "cs", "ssl", "https", "less", "space", "sb", "p", "m", "e", "status", "g", "sl", "ds", "d", "ls", "sw", "os", "es", "a", "rs", "h", "as", "sys", "stats", "sts", "bs", "y", "service", "i", "c", "socket", "sn", "sq", "ps", "self", "set"], "qh": ["requg", "requoh", "qoh", " qih", "iqhe", "quph", "qhe", "quh", "iqoh", "sqoh", "sqph", "queryhi", "sqh", "quih", "queryah", "queryhe", "qualoh", "qqx", " sqq", "qhi", "quah", "sqah", "sqe", "qux", "thinkph", "thinkhe", "queryh", " sqh", "qualhe", "quoh", "qqh", " sqih", "qih", "queryoh", "requhi", " qq", "sqx", "thinkoh", "qualh", "qx", "qug", "qph", "querye", "iqph", "queryg", "sqhe", "quq", "qqoh", "quhe", "thinkh", "quhi", "qq", "iqh", "requh", "qqph", "qe", "quale", "que", "qah", "qg"], "td": ["nt", "pc", "tif", "dll", "md", "tap", "tp", "dd", "dn", "db", "red", "th", "sam", "typ", "tt", "cd", "ent", "tf", " TD", "tn", "disabled", "tr", "tg", "elt", "ts", "ud", "cmd", "std", "rd", "dt", "t", "ssl", "ctl", "sd", "fd", "dat", "pt", "ds", "pd", "dh", "d", "bd", "trust", "nd", "ad", "edd", "att", "od", "hd", "TD", "ld", "def", "tmp", "tc", "tar", "tk", "ord", "dial", "pb", "desc", "cz", "ptr", "tl", "dl"], "link": ["weight", "low", "lock", "loc", "path", "lan", "ctl", "Link", "scan", "connection", "line", "style", "id", "links", "ln", "thread", "button", "map", "type", "le", "bolt", "ind", "enable", "control", "tool", "host", "load", "address", "ssl", "lib", "device", "cp", "linked", "bus", "base", "check", "lo", "task", "close", "open", "addr", "handle", "start", "ptr", "ctrl", "ink", "channel", "local", "ll", "parent", "group", "tag", "delay", "port", "chain", "rel", "share", "ld", "l", "target", "index", "lag", "network", "slave", "url", "page", "loop", "li", "frame", "disk", "sp", "source", "node", "block", "key", "light", "route", "stream", "list", "uri", "child", "label", "self"], "old_td_ctrl": ["old_td_rl", "old_td_compl", "old_sd_compl", "old_nd_ctr", "old_td_ctr", "old_th_ctrl", "old_nd_control", "old_td_cur", "old_nd_cur", "old_td_control", "old_sd_control", "old_sd_ctrl", "old_th_rl", "old_sd_ctr", "old_nd_ctrl", "old_th_trl", "old_th_ctr", "old_td_trl"], "val": ["data", "vals", "v", "rem", "il", "res", "util", "pol", "serv", "valid", "pl", "sil", "tx", "mod", "var", "VAL", "elt", "reg", "aval", "Val", "sol", "len", "al", "key", "vt", "lib", "el", "ref", "arr", "bin", "doc", "sel", "pt", "cho", "dev", "rel", "fail", "vet", "crit", "cal", "pret", "ev", "vol", "value", "def", "resp", "num", "alt", "col", "pr", "rol", "stat", "pal", "eval", "msg", "prop", "test", "ver", "bal", "ctx"], "frame_addr": ["frameLogcoord", "frame_coord", "framelystore", "frame2ptr", "frameLogag", " frame_store", "frameLogaddr", "frame_store", "frame_ref", "frame_address", " frame_src", "frame_ptr", " frame_address", "frame2addr", "Frame_ref", "Frame_addr", "frame___conn", "framelyaddr", "Frame_ptr", "Frame_address", " frame_ix", "framelyconn", " frame_ag", " frame_conn", "frame_rel", "frame2address", " frame_rel", " frame_ptr", "frame___addr", "frame2src", "frame_ix", "frame_src", "frame_ag", " frame_coord", "frame___ix", "frame_conn", " frame_mod", "frame_mod"], "ret": [" fut", "nt", "backed", "rem", "res", "result", "ter", "sat", " alt", "ext", "ll", "repl", "rt", "rets", "leg", "tr", "det", "reply", "reset", "elt", "cert", " Ret", "usr", "ry", "t", "len", "cat", "deg", "ft", "gt", "Ret", "out", "inter", "vet", "pret", "virt", "arg", "fit", "RET", "lt", "flag", "att", "def", "try", "resp", "cont", "back", "re", "alt", "success", "test", "err", "lit"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n", "idx": 25932, "substitutes": {"req": ["nt", "request", "cmp", "res", "urg", "rec", "dep", "quest", "fr", "js", "exec", "subject", "iq", "gr", "ext", "txt", "required", "jp", "rr", "low", "rss", "wx", "comp", "seq", "query", "ack", "r", "reg", "cmd", "dq", "pkg", "coord", "rx", "comm", "expr", "compl", "rel", "crit", "org", "q", "requ", "needed", "decl", "qt", "rpm", "good", "task", "cur", "resp", "ctr", "qq", "err", "ord", "require", "desc", "j", "inv", "msg", "sq", "ind", "ctx"], "bs": ["BS", "res", "iss", "gs", "ms", "bp", "fs", "ss", "ps", "ts", "bc", "cs", "bh", "ds", "bb", "es", "os", "bn", "hz", "ib", "bm", "vs", "as", "sys", "lbs", "us", "pb", "bi", "mb"], "serialising_in_flight": ["serialising_inleflight", "serialising_out_flight", "serialising_out_queue", "serialising_inleprocessing", "serialising_in_queue", "serialising_inqprocessing", "serialising_in_processing", "serialising_inqFlight", "serialising_inqflight", "serialising_inlequeue", "serialising_inqqueue", "serialising_out_Flight", "serialising_in_Flight", "serialising_out_processing", "serialising_inleFlight"]}}
{"project": "FFmpeg", "commit_id": "ac94b8bcc6cdba000ada0c84b4c287f7f37f2384", "target": 0, "func": "static int adpcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    ADPCMDecodeContext *c = avctx->priv_data;\n\n    ADPCMChannelStatus *cs;\n\n    int n, m, channel, i;\n\n    int block_predictor[2];\n\n    short *samples;\n\n    short *samples_end;\n\n    const uint8_t *src;\n\n    int st; /* stereo */\n\n\n\n    /* DK3 ADPCM accounting variables */\n\n    unsigned char last_byte = 0;\n\n    unsigned char nibble;\n\n    int decode_top_nibble_next = 0;\n\n    int diff_channel;\n\n\n\n    /* EA ADPCM state variables */\n\n    uint32_t samples_in_chunk;\n\n    int32_t previous_left_sample, previous_right_sample;\n\n    int32_t current_left_sample, current_right_sample;\n\n    int32_t next_left_sample, next_right_sample;\n\n    int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n\n    uint8_t shift_left, shift_right;\n\n    int count1, count2;\n\n    int coeff[2][2], shift[2];//used in EA MAXIS ADPCM\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    //should protect all 4bit ADPCM variants\n\n    //8 is needed for CODEC_ID_ADPCM_IMA_WAV with 2 channels\n\n    //\n\n    if(*data_size/4 < buf_size + 8)\n\n        return -1;\n\n\n\n    samples = data;\n\n    samples_end= samples + *data_size/2;\n\n    *data_size= 0;\n\n    src = buf;\n\n\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_IMA_QT:\n\n        n = buf_size - 2*avctx->channels;\n\n        for (channel = 0; channel < avctx->channels; channel++) {\n\n            int16_t predictor;\n\n            int step_index;\n\n            cs = &(c->status[channel]);\n\n            /* (pppppp) (piiiiiii) */\n\n\n\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n\n            predictor = AV_RB16(src);\n\n            step_index = predictor & 0x7F;\n\n            predictor &= 0xFF80;\n\n\n\n            src += 2;\n\n\n\n            if (cs->step_index == step_index) {\n\n                int diff = (int)predictor - cs->predictor;\n\n                if (diff < 0)\n\n                    diff = - diff;\n\n                if (diff > 0x7f)\n\n                    goto update;\n\n            } else {\n\n            update:\n\n                cs->step_index = step_index;\n\n                cs->predictor = predictor;\n\n            }\n\n\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n\n\n            samples = (short*)data + channel;\n\n\n\n            for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n\n                samples += avctx->channels;\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n\n                samples += avctx->channels;\n\n                src ++;\n\n            }\n\n        }\n\n        if (st)\n\n            samples--;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WAV:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n//        samples_per_block= (block_align-4*chanels)*8 / (bits_per_sample * chanels) + 1;\n\n\n\n        for(i=0; i<avctx->channels; i++){\n\n            cs = &(c->status[i]);\n\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n\n\n\n            cs->step_index = *src++;\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n\n        }\n\n\n\n        while(src < buf + buf_size){\n\n            for(m=0; m<4; m++){\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] & 0x0F, 3);\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] >> 4  , 3);\n\n                src++;\n\n            }\n\n            src += 4*st;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_4XM:\n\n        cs = &(c->status[0]);\n\n        c->status[0].predictor= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].predictor= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].step_index= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].step_index= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        if (cs->step_index < 0) cs->step_index = 0;\n\n        if (cs->step_index > 88) cs->step_index = 88;\n\n\n\n        m= (buf_size - (src - buf))>>st;\n\n        for(i=0; i<m; i++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] & 0x0F, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] & 0x0F, 4);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] >> 4, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] >> 4, 4);\n\n        }\n\n\n\n        src += m<<st;\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_MS:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n        n = buf_size - 7 * avctx->channels;\n\n        if (n < 0)\n\n            return -1;\n\n        block_predictor[0] = av_clip(*src++, 0, 6);\n\n        block_predictor[1] = 0;\n\n        if (st)\n\n            block_predictor[1] = av_clip(*src++, 0, 6);\n\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n\n        if (st){\n\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[0]];\n\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[0]];\n\n        c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[1]];\n\n        c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[1]];\n\n\n\n        c->status[0].sample1 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n\n        c->status[0].sample2 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n\n\n\n        *samples++ = c->status[0].sample2;\n\n        if (st) *samples++ = c->status[1].sample2;\n\n        *samples++ = c->status[0].sample1;\n\n        if (st) *samples++ = c->status[1].sample1;\n\n        for(;n>0;n--) {\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n\n            src ++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK4:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        c->status[0].predictor  = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = *src++;\n\n        src++;\n\n        *samples++ = c->status[0].predictor;\n\n        if (st) {\n\n            c->status[1].predictor  = (int16_t)bytestream_get_le16(&src);\n\n            c->status[1].step_index = *src++;\n\n            src++;\n\n            *samples++ = c->status[1].predictor;\n\n        }\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK3:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        if(buf_size + 16 > (samples_end - samples)*3/8)\n\n            return -1;\n\n\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n\n        c->status[0].step_index = src[14];\n\n        c->status[1].step_index = src[15];\n\n        /* sign extend the predictors */\n\n        src += 16;\n\n        diff_channel = c->status[1].predictor;\n\n\n\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n\n         * the buffer is consumed */\n\n        while (1) {\n\n\n\n            /* for this algorithm, c->status[0] is the sum channel and\n\n             * c->status[1] is the diff channel */\n\n\n\n            /* process the first predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the diff channel predictor */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n\n\n            /* process the first pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n\n\n            /* process the second predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the second pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_ISS:\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 0);\n\n        c->status[0].step_index = src[2];\n\n        src += 4;\n\n        if(st) {\n\n            c->status[1].predictor  = (int16_t)AV_RL16(src + 0);\n\n            c->status[1].step_index = src[2];\n\n            src += 4;\n\n        }\n\n\n\n        while (src < buf + buf_size) {\n\n            uint8_t v1, v2;\n\n            uint8_t v = *src++;\n\n            /* nibbles are swapped for mono */\n\n            if (st) {\n\n                v1 = v >> 4;\n\n                v2 = v & 0x0F;\n\n            } else {\n\n                v2 = v >> 4;\n\n                v1 = v & 0x0F;\n\n            }\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_XA:\n\n        while (buf_size >= 128) {\n\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n\n                avctx->channels);\n\n            src += 128;\n\n            samples += 28 * 8;\n\n            buf_size -= 128;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n        samples_in_chunk = bytestream_get_le32(&src) >> (1-st);\n\n\n\n        if (samples_in_chunk > buf_size-4-(8<<st)) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].step_index = bytestream_get_le32(&src);\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].predictor  = bytestream_get_le32(&src);\n\n\n\n        for (; samples_in_chunk; samples_in_chunk--, src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n        for (; src < buf+buf_size; src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA:\n\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n\n           each coding 28 stereo samples. */\n\n        if (buf_size < 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        samples_in_chunk = AV_RL32(src);\n\n        if (samples_in_chunk / 28 > (buf_size - 12) / 30) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid frame\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        src += 4;\n\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n\n\n\n        for (count1 = 0; count1 < samples_in_chunk/28;count1++) {\n\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n\n            src++;\n\n\n\n            shift_left  = (*src >> 4  ) + 8;\n\n            shift_right = (*src & 0x0F) + 8;\n\n            src++;\n\n\n\n            for (count2 = 0; count2 < 28; count2++) {\n\n                next_left_sample  = (int32_t)((*src & 0xF0) << 24) >> shift_left;\n\n                next_right_sample = (int32_t)((*src & 0x0F) << 28) >> shift_right;\n\n                src++;\n\n\n\n                next_left_sample = (next_left_sample +\n\n                    (current_left_sample * coeff1l) +\n\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n\n                next_right_sample = (next_right_sample +\n\n                    (current_right_sample * coeff1r) +\n\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n\n\n                previous_left_sample = current_left_sample;\n\n                current_left_sample = av_clip_int16(next_left_sample);\n\n                previous_right_sample = current_right_sample;\n\n                current_right_sample = av_clip_int16(next_right_sample);\n\n                *samples++ = (unsigned short)current_left_sample;\n\n                *samples++ = (unsigned short)current_right_sample;\n\n            }\n\n        }\n\n\n\n        if (src - buf == buf_size - 2)\n\n            src += 2; // Skip terminating 0x0000\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n\n        for(channel = 0; channel < avctx->channels; channel++) {\n\n            for (i=0; i<2; i++)\n\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n\n            shift[channel] = (*src & 0x0F) + 8;\n\n            src++;\n\n        }\n\n        for (count1 = 0; count1 < (buf_size - avctx->channels) / avctx->channels; count1++) {\n\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n\n                for(channel = 0; channel < avctx->channels; channel++) {\n\n                    int32_t sample = (int32_t)(((*(src+channel) >> i) & 0x0F) << 0x1C) >> shift[channel];\n\n                    sample = (sample +\n\n                             c->status[channel].sample1 * coeff[channel][0] +\n\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n\n                    c->status[channel].sample2 = c->status[channel].sample1;\n\n                    c->status[channel].sample1 = av_clip_int16(sample);\n\n                    *samples++ = c->status[channel].sample1;\n\n                }\n\n            }\n\n            src+=avctx->channels;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_R1:\n\n    case CODEC_ID_ADPCM_EA_R2:\n\n    case CODEC_ID_ADPCM_EA_R3: {\n\n        /* channel numbering\n\n           2chan: 0=fl, 1=fr\n\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n\n        int32_t previous_sample, current_sample, next_sample;\n\n        int32_t coeff1, coeff2;\n\n        uint8_t shift;\n\n        unsigned int channel;\n\n        uint16_t *samplesC;\n\n        const uint8_t *srcC;\n\n        const uint8_t *src_end = buf + buf_size;\n\n\n\n        samples_in_chunk = (big_endian ? bytestream_get_be32(&src)\n\n                                       : bytestream_get_le32(&src)) / 28;\n\n        if (samples_in_chunk > UINT32_MAX/(28*avctx->channels) ||\n\n            28*samples_in_chunk*avctx->channels > samples_end-samples) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n\n                                         : bytestream_get_le32(&src))\n\n                           + (avctx->channels-channel-1) * 4;\n\n\n\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n\n            srcC  = src + offset;\n\n            samplesC = samples + channel;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n\n            } else {\n\n                current_sample  = c->status[channel].predictor;\n\n                previous_sample = c->status[channel].prev_sample;\n\n            }\n\n\n\n            for (count1=0; count1<samples_in_chunk; count1++) {\n\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n\n                    srcC++;\n\n                    if (srcC > src_end - 30*2) break;\n\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n\n\n\n                    for (count2=0; count2<28; count2++) {\n\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                } else {\n\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n\n                    shift = (*srcC++ & 0x0F) + 8;\n\n\n\n                    if (srcC > src_end - 14) break;\n\n                    for (count2=0; count2<28; count2++) {\n\n                        if (count2 & 1)\n\n                            next_sample = (int32_t)((*srcC++ & 0x0F) << 28) >> shift;\n\n                        else\n\n                            next_sample = (int32_t)((*srcC   & 0xF0) << 24) >> shift;\n\n\n\n                        next_sample += (current_sample  * coeff1) +\n\n                                       (previous_sample * coeff2);\n\n                        next_sample = av_clip_int16(next_sample >> 8);\n\n\n\n                        previous_sample = current_sample;\n\n                        current_sample  = next_sample;\n\n                        *samplesC = current_sample;\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n\n                c->status[channel].predictor   = current_sample;\n\n                c->status[channel].prev_sample = previous_sample;\n\n            }\n\n        }\n\n\n\n        src = src + buf_size - (4 + 4*avctx->channels);\n\n        samples += 28 * samples_in_chunk * avctx->channels;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_EA_XAS:\n\n        if (samples_end-samples < 32*4*avctx->channels\n\n            || buf_size < (4+15)*4*avctx->channels) {\n\n            src += buf_size;\n\n            break;\n\n        }\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int coeff[2][4], shift[4];\n\n            short *s2, *s = &samples[channel];\n\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n\n                for (i=0; i<2; i++)\n\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n\n                shift[n] = (src[2]&0x0F) + 8;\n\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n\n            }\n\n\n\n            for (m=2; m<32; m+=2) {\n\n                s = &samples[m*avctx->channels + channel];\n\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n\n                        int level = (int32_t)((*src & (0xF0>>i)) << (24+i)) >> shift[n];\n\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        samples += 32*4*avctx->channels;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_AMV:\n\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = bytestream_get_le16(&src);\n\n\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n            src+=4;\n\n\n\n        while (src < buf + buf_size) {\n\n            char hi, lo;\n\n            lo = *src & 0x0F;\n\n            hi = *src >> 4;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n                FFSWAP(char, hi, lo);\n\n\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                lo, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                hi, 3);\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_CT:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SBPRO_4:\n\n    case CODEC_ID_ADPCM_SBPRO_3:\n\n    case CODEC_ID_ADPCM_SBPRO_2:\n\n        if (!c->status[0].step_index) {\n\n            /* the first byte is a raw sample */\n\n            *samples++ = 128 * (*src++ - 0x80);\n\n            if (st)\n\n              *samples++ = 128 * (*src++ - 0x80);\n\n            c->status[0].step_index = 1;\n\n        }\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n\n            while (src < buf + buf_size) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] >> 4, 4, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x0F, 4, 0);\n\n                src++;\n\n            }\n\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n\n            while (src < buf + buf_size && samples + 2 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 5        , 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x07, 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] & 0x03, 2, 0);\n\n                src++;\n\n            }\n\n        } else {\n\n            while (src < buf + buf_size && samples + 3 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 6        , 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    (src[0] >> 4) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x03, 2, 2);\n\n                src++;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SWF:\n\n    {\n\n        GetBitContext gb;\n\n        const int *table;\n\n        int k0, signmask, nb_bits, count;\n\n        int size = buf_size*8;\n\n\n\n        init_get_bits(&gb, buf, size);\n\n\n\n        //read bits & initial values\n\n        nb_bits = get_bits(&gb, 2)+2;\n\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n\n        table = swf_index_tables[nb_bits-2];\n\n        k0 = 1 << (nb_bits-2);\n\n        signmask = 1 << (nb_bits-1);\n\n\n\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n\n                c->status[i].step_index = get_bits(&gb, 6);\n\n            }\n\n\n\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n\n                int i;\n\n\n\n                for (i = 0; i < avctx->channels; i++) {\n\n                    // similar to IMA adpcm\n\n                    int delta = get_bits(&gb, nb_bits);\n\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n\n                    int k = k0;\n\n\n\n                    do {\n\n                        if (delta & k)\n\n                            vpdiff += step;\n\n                        step >>= 1;\n\n                        k >>= 1;\n\n                    } while(k);\n\n                    vpdiff += step;\n\n\n\n                    if (delta & signmask)\n\n                        c->status[i].predictor -= vpdiff;\n\n                    else\n\n                        c->status[i].predictor += vpdiff;\n\n\n\n                    c->status[i].step_index += table[delta & (~signmask)];\n\n\n\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n\n\n\n                    *samples++ = c->status[i].predictor;\n\n                    if (samples >= samples_end) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        src += buf_size;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_YAMAHA:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_THP:\n\n    {\n\n        int table[2][16];\n\n        unsigned int samplecnt;\n\n        int prev[2][2];\n\n        int ch;\n\n\n\n        if (buf_size < 80) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        src+=4;\n\n        samplecnt = bytestream_get_be32(&src);\n\n\n\n        for (i = 0; i < 32; i++)\n\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        /* Initialize the previous sample.  */\n\n        for (i = 0; i < 4; i++)\n\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        if (samplecnt >= (samples_end - samples) /  (st + 1)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (ch = 0; ch <= st; ch++) {\n\n            samples = (unsigned short *) data + ch;\n\n\n\n            /* Read in every sample for this channel.  */\n\n            for (i = 0; i < samplecnt / 14; i++) {\n\n                int index = (*src >> 4) & 7;\n\n                unsigned int exp = 28 - (*src++ & 15);\n\n                int factor1 = table[ch][index * 2];\n\n                int factor2 = table[ch][index * 2 + 1];\n\n\n\n                /* Decode 14 samples.  */\n\n                for (n = 0; n < 14; n++) {\n\n                    int32_t sampledat;\n\n                    if(n&1) sampledat=  *src++    <<28;\n\n                    else    sampledat= (*src&0xF0)<<24;\n\n\n\n                    sampledat = ((prev[ch][0]*factor1\n\n                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);\n\n                    *samples = av_clip_int16(sampledat);\n\n                    prev[ch][1] = prev[ch][0];\n\n                    prev[ch][0] = *samples++;\n\n\n\n                    /* In case of stereo, skip one sample, this sample\n\n                       is for the other channel.  */\n\n                    samples += st;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* In the previous loop, in case stereo is used, samples is\n\n           increased exactly one time too often.  */\n\n        samples -= st;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 25936, "substitutes": {"avctx": ["apconn", "aircu", "avercontext", "averctx", "aftx", "abctx", "avcontext", "vrsys", "airctx", "vrctx", "apcontext", " avtx", " avconn", "afctx", "abobj", "Avtx", "avercu", "abkb", "aversys", "ajtx", "aveobj", " avcu", "airconn", "aptx", "avobj", " avkb", "abconn", "avjac", "Avctx", "ajjac", "avecontext", "avercpp", "vrcu", " avjac", "avconn", "ajcontext", "avsys", "avecu", "avcpp", "abcontext", "ajctx", "avecpp", "averconn", "afjac", " avcontext", "averkb", "avkb", "Avcontext", "vrconn", " avobj", "avtx", "airsys", "aveconn", "afcontext", "apctx", "avectx", "Avconn", " avcpp", "avcu"], "data": ["DATA", "video", "to", "first", "text", "next", "frame", "Data", "message", "r", "body", "read", "block", "bytes", "image", "t", "len", "sample", "new", "padding", "bin", "audio", "p", "dat", "buffer", "pad", "feed", "str", "d", "values", "stream", "a", "window", "id", "size", "value", "input", "map", "batch", "ata", "length", "raw"], "data_size": ["DATA_index", "DATA_Size", "data00size", " data_Size", "DATA_SIZE", "data5dimension", "data2len", "dataPSize", "data5SIZE", " data_dimension", " data_SIZE", "data00dimension", "data_length", "data_SIZE", "data_dimension", "data5size", " data_index", "data2length", " data_resolution", "data_resolution", "dataPsize", " data_len", "data2Size", "data_len", "data2size", " data_length", "data00SIZE", "data_Size", "data00resolution", "data5resolution", "dataPSIZE", "DATA_size", "data_index", "dataPindex"], "avpkt": ["iverpacket", "iverpodkt", "avPwp", " avopct", "avpodkt", "avopacket", "avpodud", "avcpmt", "avPmsg", "iverpodacket", "avptxt", "iverpodtxt", "avPtxt", "iverpmsg", " avopkt", "avPud", "campkt", "avpct", "campwp", "avpcmt", "avpcacket", "avpacket", "campodud", "avopmsg", "iverpkt", "campct", "avopkt", "avpodacket", "avpwp", "campodct", "avdpkt", "iverpodmsg", "campodkt", "avcpacket", "avcpct", "avpodwp", " avpct", "avdpwp", "campodwp", "avpmt", " avopmt", "avPacket", "avdpud", "avpodtxt", " avpmt", "avcpkt", "avdpct", "iverptxt", "avPct", "avPkt", "avpud", " avpacket", "avpcct", "avopmt", "avopct", "avpckt", "avoptxt", "avpodct", " avopacket", "avpodmsg", "avpmsg", "campud"], "buf": ["v", "cv", "text", "txt", "mem", "seq", "buff", "cb", "b", "r", "vec", "rb", "box", "cmd", "block", "pkg", "bytes", "t", "bl", "uf", "doc", "p", "dat", "buffer", "pad", "queue", "window", "Buffer", "img", "tmp", "map", "br", "wb", "pb", "batch", "orig", "msg", "raw"], "c": ["v", "cv", "ca", "cmp", "co", "f", "b", "lc", "ci", "mc", "fc", "bc", "dc", "t", "ac", "ec", "p", "comm", "g", "cc", "ct", "cp", "a", "C", "con", "l", "conf", "tc", "vc", "cm", "ctx"], "cs": ["ca", "cv", "pc", "cmp", "ars", "hs", "ks", "gs", "js", "ms", "cons", "fs", "ns", "cb", "lc", "ci", "fc", "ts", "qs", "ics", "CS", "ats", "ac", "cus", "ec", "ins", "cc", "cf", "ds", "ls", "wcs", "cp", "cks", "rs", "Cs", "sc", "acs", "vs", "sys", "stats", "tc", "bs", "vc", "cm", "ps", "css", "csv"], "n": ["nt", "v", "k", "ns", "f", "mn", "r", "b", "z", "t", "len", "cn", "o", "p", "e", "ni", "en", "g", "N", "d", "u", "nb", "h", "l", "nn", "nm", "num", "j", "x", "index", "nc"], "m": ["middle", "dm", "v", "k", "mid", "mn", "r", "mc", "an", "gm", "M", "mi", "man", "o", "p", "min", "mut", "rm", "bm", "im", "h", "l", "nm", "num", "cm", "dim"], "channel": ["broad", "ann", "command", "video", "chron", "CHO", "camera", "face", "user", "cam", "frame", "member", "mode", "annels", "client", "monitor", "config", "anger", "context", "change", "message", "instance", "manager", "can", "chan", "category", "cell", "coord", "key", "component", "Channel", "version", "chain", "connection", "character", "name", "number", "course", "id", "part", "window", "section", "sc", "byte", "column", "pixel", "unit", "panel", "axis", "chip", "button", "row", "direction", "label", "field", "col", "batch", "index", "cm", "which", "attribute", "ind", "variable"], "i": ["v", "ir", "k", "in", "ai", "b", "ci", "di", "ii", "mi", "ip", "p", "pi", "id", "im", "l", "ti", "j", "index", "x", "y", "it", "si", "bi", "ind", "I"], "block_predictor": ["block_posteror", "block_posterive", "block_pensive", "block_predictory", "block_predictors", "block_posterors", "block_posterory", "block_Predictory", "block_Predictive", "block_pensory", "block_pensor", "block_Predictors", "block_pensors", "block_Predictor", "block_predictive"], "samples": ["tents", "sems", "nsample", "rsamples", "spents", "rsems", "rsamps", "Sources", "Sems", "Samples", "nsamps", " sample", "simens", "Samps", "sources", "sample", "rsources", "tamples", "spamples", "sents", "tamps", "nsamples", "spamps", "tores", "Sents", "samps", "sores", "Sores", " simens", "nsimens", " samps", "spores"], "samples_end": ["samples_ended", "samples_append", "samples2end", "samps_end", "samples_max", "samples2END", "samples_END", "samps_max", "samps_ended", "samps_start", "samples2ended", "samples_start", "samps_stop", "samps_append", "samples2max", "samps_END", "samples_stop"], "src": ["dest", "url", "ur", "sr", "iter", "ser", "in", "slice", "txt", "source", "inst", "rl", "loc", "r", "supp", "fc", "iv", "bc", "origin", "bin", "filename", "conv", "sb", "scan", "seek", "str", "buffer", "sub", "u", "stream", "syn", "seed", "rs", "sync", "sc", "fp", "img", "rc", "sys", "ctr", "input", "tmp", "addr", "bs", "proc", "ptr", "sn", "sq", "vr", "ind", "raw"], "st": ["stop", "ST", "offset", "next", "ist", "St", "sp", "end", "tt", "inst", "step", "r", "z", "se", "std", "t", "len", "sth", "str", "status", "out", "d", "sw", "nd", "sc", "storage", "l", "br", "ost", "start", "pos", "x", "ptr", "est", "sta", "rest", "it", "sn", "stat", "ste", "set"], "nibble": [" nig", "snbsp", "Nbsp", "snig", "snib", "Nibble", "nbsp", "snibble", "nig", "Nig", " nib", " nbsp", "nib", "Nib"], "diff_channel": ["diff_batch", " deltaPerChannel", " delta_Channel", "diffPerchannel", "diff_Channel", " deltaPerchannel", "diffPerdirection", " delta_batch", " delta_direction", "diffPerbatch", "diff_direction", " deltaPerbatch", " deltaPerdirection", " delta_channel", "diffPerChannel"], "samples_in_chunk": ["samples_in_cunks", "samples_in_Chunk", "samples_in_punks", "samples_in_Chunks", "samples_in_pack", "samples_in_cacket", "samples_in_punk", "samples_in_chunks", "samples_in_cunk", "samples_in_cack", "samples_in_Chack", "samples_in_chacket", "samples_in_packet", "samples_in_chack", "samples_in_Chacket"], "previous_left_sample": ["previous_left_system", "previous_left_Sample", "previous_left_space", "previous_right_system", "previous_right_space", "previous_right_Sample"], "previous_right_sample": ["previous_right___profile", "previous_left_mouse", "previous_right_profile", "previous_left_Sample", "previous_righttenancemouse", "previous_righttenanceSample", "previous_right___sample", "previous_righttenancesample", "previous_right___Sample", "previous_righttenanceprofile", "previous_right_mouse", "previous_left_profile", "previous_right___mouse", "previous_right_Sample"], "current_left_sample": ["current_leftxample", "current_left_Sample", "current_right_ample", "current_right_sound", "current_leftxSample", "current_left_ample", "current_right_Sample", "current_left_sound", "current_leftxsound", "current_leftxsample"], "current_right_sample": ["current_right_range", "current_left_channel", "current_left_Sample", "current_right_channel", "current_rightlysample", "current_right_Sample", "current_rightlyrange", "current_rightlychannel", "current_left_range", "current_rightlySample"], "next_left_sample": ["next_right_seed", "next_leftlyspace", "next_leftlyseed", "next_left_seed", "next_right_Sample", "next_left_Sample", "next_leftlySample", "next_leftlysample", "next_right_space", "next_left_space"], "next_right_sample": ["next_right_sound", "next_left_frame", "next_left_sound", "next_right_Sample", "next_left_Sample", "next_right_frame"], "coeff1l": ["coeff2z", "coff2b", "coeff0l", "coeff1L", "coeff1z", "coff2L", "coff1L", "coeff1b", "coff1b", "coff1l", "coff2z", "coeff0b", "coeff0z", "coeff0L", "coff2l", "coff1z", "coeff2L", "coeff2b"], "coeff2l": ["coeff4L", "coeff2ls", "coefficient1ls", "coeff4l", "coeff12ls", "coeff12ll", "coeff1ll", "coeff12L", "coefficient2L", "coeff1L", "coefficient2l", "coeff2ll", "coeff1ls", "coefficient2ll", "coefficient1L", "coeff4ls", "coeff4ll", "coefficient2ls", "coefficient1l", "coefficient1ll", "coeff2L", "coeff12l"], "coeff1r": ["coefficient1R", "coeff1dr", "coefficient2dr", "coeff3r", "coefficient1r", "coeff01R", "coeff2dr", "coefficient2r", "coeff3dr", "coeff3R", "coeff2R", "coeff1R", "coeff01r", "coefficient2l", "coeff01l", "coeff3l", "coeff01dr", "coefficient1dr", "coefficient2R", "coefficient1l"], "coeff2r": ["coeff2z", "coefficient1R", "coeff4r", "coeff3r", "coeff4l", "coefficient1z", "coefficient1r", "coeff3z", "coeff4R", "coefficient2r", "coeff1z", "coeff3R", "coeff2R", "coeff4z", "coeff1R", "coefficient2l", "coeff3l", "coefficient2R", "coefficient1l", "coefficient2z"], "shift_left": ["shift2left", "shift2l", "shift2right", "shift_l", " shift_l"], "shift_right": ["shift2left", " shift_Right", "shift_Right", "shift2Right", "shift2right", "shift1left", "shift1right", "shift_r", "shift1Right", "shift1r", " shift_r", "shift2r"], "count1": ["nameone", "commenty", "commentone", "name2", "comment1", "name1", "namey", "comment2", "county", " countone", "countone", " county"], "count2": ["County", "comment3", "commenty", "Count2", "comment1", " count3", "comment2", "Count1", "county", "count3", "Count3", " county"], "coeff": [" coef", "coneff", "coff", " coefficient", "conef", "COefficient", "COef", "conefficient", "conff", "coefficient", "coef", " coff", "COeff", "COff"], "shift": ["pull", "sort", "offset", "slice", "scale", "distance", "shr", "diff", "push", "hold", "center", "sh", "send", "align", "Shift", "dist", "window", "value", "reverse", "field", "hift", "transform", "index", "sq"], "predictor": ["ppriion", "epriptior", "pector", "peocolory", "posteror", "peredictensor", "pprioration", "peprior", "pictory", "patredictutor", "panchion", "panchutor", "priptorer", "prresentori", "periptori", "priptora", "peocolator", "patredictored", "priptensor", "patriptorer", "prresentessor", "pection", "predictory", "posponsori", "presentessor", "presentora", "pveyory", "prredictor", "patriptored", "patriptor", "ppriutor", "peredictable", "pjectator", "peredictutor", "prredictori", "puppetutor", "ppectorer", "prresentora", "patredictor", "prediction", "priptor", "predictensor", "epredictory", "posponsensor", "priptory", "predictori", "epriptory", "pocolable", "prentable", "pjectable", "peredictor", "periptor", "pjector", "pectutor", "pictior", "ppectensor", "predictora", "peocolable", "epriptoration", "peredictator", "predictessor", "puppetored", "perediction", "epredictor", "peredictori", "periptensor", "panchoration", "prredictora", "prentor", "prentator", "priptessor", "panchor", "predictable", "peocolor", "ppectori", "predictutor", "pictor", "predictorer", "posterora", "epriptor", "epredictoration", "pictoration", "prresentor", "peredictory", "presentori", "pveyor", "priptori", "epredictior", "posponsoration", "pveyoration", "prredictessor", "priptutor", "pocolator", "predictoration", "prentory", "priptior", "ppectutor", "patredictorer", "pocolory", "priptored", "peprioration", "posteressor", "pprior", "ppectoration", "pepriion", "posterori", "predictior", "presentor", "peredictoration", "priptoration", "patriptutor", "pectoration", "predictored", "pveyior", "puppetor", "pocolor", "predictator", "ppectored", "pjectory", "periptoration", "posponsor", "ppector", "puppetorer", "pepriutor"], "step_index": ["step67offset", " step2Index", "stepvalresult", "STEP_index", " step_i", "stepvalindex", "step2Index", " step_result", "stepxind", "step67index", "step2ind", "step_result", " step2index", "step2index", "step_number", "STEP_Index", " step_Index", " step2i", "step_position", "step_offset", " step_offset", "stepxposition", "status_position", "step2i", "step_Index", "step_i", "status_index", "stepvaloffset", "stepxindex", "STEP_ind", "step67result", "stepxnumber", "status_ind", "status_number", " step_ind", " step2ind", "step_ind"]}}
{"project": "FFmpeg", "commit_id": "50cbe09d8ced75422571d29bbec1f35a33a0d3ed", "target": 0, "func": "static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)\n\n{\n\n    int res;\n\n    HuffContext huff;\n\n    HuffContext tmp1, tmp2;\n\n    VLC vlc[2] = { { 0 } };\n\n    int escapes[3];\n\n    DBCtx ctx;\n\n    int err = 0;\n\n\n\n    if(size >= UINT_MAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    tmp1.length = 256;\n\n    tmp1.maxlength = 0;\n\n    tmp1.current = 0;\n\n    tmp1.bits = av_mallocz(256 * 4);\n\n    tmp1.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp1.values = av_mallocz(256 * sizeof(int));\n\n\n\n    tmp2.length = 256;\n\n    tmp2.maxlength = 0;\n\n    tmp2.current = 0;\n\n    tmp2.bits = av_mallocz(256 * 4);\n\n    tmp2.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp2.values = av_mallocz(256 * sizeof(int));\n\n\n\n    if(get_bits1(gb)) {\n\n        smacker_decode_tree(gb, &tmp1, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp1.current > 1) {\n\n            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,\n\n                        tmp1.lengths, sizeof(int), sizeof(int),\n\n                        tmp1.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[0].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping low bytes tree\\n\");\n\n    }\n\n    if(get_bits1(gb)){\n\n        smacker_decode_tree(gb, &tmp2, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp2.current > 1) {\n\n            res = init_vlc(&vlc[1], SMKTREE_BITS, tmp2.length,\n\n                        tmp2.lengths, sizeof(int), sizeof(int),\n\n                        tmp2.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[1].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping high bytes tree\\n\");\n\n    }\n\n\n\n    escapes[0]  = get_bits(gb, 16);\n\n    escapes[1]  = get_bits(gb, 16);\n\n    escapes[2]  = get_bits(gb, 16);\n\n\n\n    last[0] = last[1] = last[2] = -1;\n\n\n\n    ctx.escapes[0] = escapes[0];\n\n    ctx.escapes[1] = escapes[1];\n\n    ctx.escapes[2] = escapes[2];\n\n    ctx.v1 = &vlc[0];\n\n    ctx.v2 = &vlc[1];\n\n    ctx.recode1 = tmp1.values;\n\n    ctx.recode2 = tmp2.values;\n\n    ctx.last = last;\n\n\n\n    huff.length = ((size + 3) >> 2) + 3;\n\n    huff.maxlength = 0;\n\n    huff.current = 0;\n\n    huff.values = av_mallocz(huff.length * sizeof(int));\n\n\n\n    if (smacker_decode_bigtree(gb, &huff, &ctx) < 0)\n\n        err = -1;\n\n    skip_bits1(gb);\n\n    if(ctx.last[0] == -1) ctx.last[0] = huff.current++;\n\n    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;\n\n    if(ctx.last[2] == -1) ctx.last[2] = huff.current++;\n\n    if(huff.current > huff.length){\n\n        ctx.last[0] = ctx.last[1] = ctx.last[2] = 1;\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"bigtree damaged\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    *recodes = huff.values;\n\n\n\n    if(vlc[0].table)\n\n        ff_free_vlc(&vlc[0]);\n\n    if(vlc[1].table)\n\n        ff_free_vlc(&vlc[1]);\n\n    av_free(tmp1.bits);\n\n    av_free(tmp1.lengths);\n\n    av_free(tmp1.values);\n\n    av_free(tmp2.bits);\n\n    av_free(tmp2.lengths);\n\n    av_free(tmp2.values);\n\n\n\n    return err;\n\n}\n", "idx": 25937, "substitutes": {"smk": ["smack", "smuk", " smak", "smik", "symk", "svkg", "memuk", "skk", "svik", "svk", "schemk", "scheak", "schek", "simik", "svack", "mck", "symunk", "mk", "swkg", "mkg", "Smuk", "mak", "smak", "simak", "Smck", "memk", "skak", "symuk", "smck", "simck", "Smunk", "symck", "skkg", " smck", "swik", "memck", "simk", "swk", "smkg", "smunk", "simack", "skmk", "simmk", "memunk", "Smk", "smmk", "swack", " smkg", "schekg", "simkg"], "gb": ["gif", "sv", "bridge", "cv", "pc", "gs", "gc", "dd", "db", "ruby", "bf", "csv", "bg", "rl", "gd", "vm", "cb", "tg", "rb", "vd", "hub", "pg", "eb", "dt", "bytes", "gm", "erb", "rg", "yg", "sb", "gow", "hw", "gt", "g", "bb", "py", "px", "fb", "gov", "bm", "io", "kb", "gnu", "storage", "sys", "tmp", "vg", "gg", "GB", "gz", "eg", "pb", "cm", "again", "bt", "cfg", "rect", "mb"], "recodes": ["Recoded", "reccodes", "ccodes", "rccodes", "Recents", "rcents", "rcodes", "coded", "Recodes", "Reccodes", "codes", "cents", "recoded", "rcoded", "recents"], "last": ["first", "cache", "max", "count", "final", "next", "ast", "end", "parent", "used", "new", "total", "chain", "since", "list", "needed", "base", "old", "id", "prev", "latest", "cur", "st", "extra", "rest", "est"], "size": ["data", "n", "max", "count", "small", "scale", "sp", "huge", "mem", "shape", "ize", "message", "set", "z", "sum", "bytes", "new", "len", "sh", "total", "send", "space", "buffer", "g", "name", "sw", "fee", "SIZE", "s", "l", "capacity", "storage", "c", "empty", "sn", "Size", "length", "w"], "res": ["rev", "vals", "rem", "result", "count", " err", "js", "ms", "ser", "red", "cons", " Res", "val", "details", "ret", "Res", "ne", "reset", "r", "pers", " RES", "ps", "resh", "cond", "pres", "act", "pas", "cs", "der", "req", "expr", "status", "out", "ress", "rel", "clear", "yes", "rs", "RES", "def", "rc", "resp", "conf", "sys", "ber", "re", "i", "resource", "rest", "ver", "err", "results"], "huff": [" hUFF", "Huffy", "HUFF", " huf", "huffy", "hhUFF", "Huff", "huf", "hhuf", "hhuff", " huffy", "hhuffy", "hUFF", "Huf"], "tmp1": ["tmp9", "tmpOnce", "stuffone", "cmp11", "node1", "cmp5", " tmp6", "perm1", "tmp101", " tmp11", "tmp0", "node2", "perm9", "yyOnce", "stuffMap", "node3", "ppo6", "cmp0", "stuff2", "mpone", "ppo5", "tc1", "temp001", "tmpOne", "soc101", "stuff91", "mp1", "ppoOne", "temp101", "mp0", "temp2", "ppo101", "cmpone", "soc11", "mp2", "permone", " tmp0", " tmp3", "tmp001", " tmpone", "tempone", "tmp91", "tmpMap", "stuff1", "mpOne", "mp7", "node01", "soc01", "temp9", " tmpOnce", "tmp11", "etc01", "soc1", "mpOnce", "etc101", "mp01", "ppoone", "temp01", "tmp01", "yy3", "temp11", "etc1", "tc9", "tmp3", "permOne", "stuff11", "tmp7", "mpMap", "tmp5", "cmp2", " tmp101", "yy1", "mp91", "tc001", "mp6", "tcOne", " tmpMap", "mp5", "mp001", "ppo9", "mp11", "etc11", "mp3", "mp9", "temp1", " tmp7", "tmpone", "mp101", "tempOne", "ppo1", "temp7", "tmp6", "cmp1", " tmp5", " tmp91", "temp3", "temp0", "yy2", " tmp01"], "tmp2": ["tdtwo", "ppo2", "etc10", " tmpTwo", "tmpable", "prop22", " tmp14", "big", "func", "tcTwo", "temptwo", "expr2", "tmp02", "term02", "ppo14", "mp14", "def", "ppo02", "ppo5", "permtwo", "etc2", "temp5", "prop02", " tmp10", "mp1", " tmpable", "temp2", "mp2", "termtwo", " tmp3", "termable", "prop10", "expr02", "tc2", "perm2", "all", "_", "etcTwo", "proc02", "tmpTwo", "mpTwo", "tmp14", "tmptwo", "etc22", "new", "tmp3", "mp02", "td2", " tmptwo", "buffer", "tdable", "exprTwo", "tempTwo", " tmp02", "tmp5", "cont", "perm5", "term2", "td02", "prop2", "etctwo", "mp5", "tmp22", "mp3", "temp1", "temp02", "procTwo", "exprtwo", "etc02", "expr5", " tmp22", " tmp5", "temp3", "tmp10", "tc02", "proc2"], "vlc": ["tlc", "clpc", "wlcu", "wll", "cll", "tlcu", "wlc", "vlpc", "tll", "flpc", "vlcs", "flcs", "wlpc", "velC", "vrci", "fll", "vell", "tlci", "flc", "vrcu", "vrc", "wlC", "vlC", "vll", "velc", "clcs", "velpc", "vrl", "vrC", "wlcs", "vlcu", "wlci", "vlci", "clc", "vrpc"], "escapes": ["esales", "Escales", "escales", "encapes", "Escapes", "esape", "encape", "esapes", "Escaper", "Escape", "encaper", "escape", "escaper", "encales", "esaper"], "ctx": [" cx", "cv", "obj", " c", "gc", " kb", "txt", " cs", "parent", "context", "tx", "cb", "cmd", "xc", "bc", " context", " sc", "cc", "cf", " td", "cp", "tmp", "tc", "buf", "c", " loc", "kw", " cp", " cc"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int standard_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);\n\n    skip_bits(gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);\n\n    v->s.pict_type = get_bits(gb, 1);\n\n    if (v->s.avctx->max_b_frames)\n\n    {\n\n        if (!v->s.pict_type)\n\n        {\n\n            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;\n\n            else v->s.pict_type = B_TYPE;\n\n        }\n\n        else v->s.pict_type = P_TYPE;\n\n    }\n\n    else v->s.pict_type++;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_primary_header(v); break;\n\n    case BI_TYPE:\n\n    case B_TYPE: status = decode_b_picture_primary_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v->s.avctx, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25947, "substitutes": {"v": ["sv", "rev", "cv", "vp", "ve", "video", "n", "cam", "co", "qv", "val", "uv", "f", "qu", "vm", "form", "message", "b", "z", "vd", "detail", "pp", "env", "current", "lv", "vv", "iv", "tv", "t", "vt", "conv", "version", "m", "p", "e", "g", "view", "nv", "q", "window", "ev", "up", "vim", "value", "V", "h", "vs", "l", "etc", "av", "ov", "vc", "i", "j", "c", "inv", "x", "ver", "wire", "y", "vi", "vr", "ch", "w"], "gb": ["gif", " rgb", "cv", "gu", "bits", "bridge", "hog", "gs", "gc", "db", "Gb", "ruby", "ctx", "bf", "bg", "gd", "cb", "tg", "rb", "phy", "vd", "hub", "attr", "eb", "gy", "gm", "html", "rg", "uf", "fm", "yg", "sb", "bys", "gpu", "gt", "goo", "g", "bb", "py", "nb", "fb", "hz", "ib", "bm", "fg", "kb", "gnu", "gam", "xy", "bs", "vg", "gg", "GB", "eg", "bt", " db", "cfg", "mb"], "s": ["sv", "bits", "hs", "is", "gs", "js", "bis", "ms", "ses", "S", "fs", "ns", "go", "store", "ss", "b", "pers", "z", "ts", "an", "qs", "has", "parts", "se", "t", "cs", "ats", "sh", "esm", "sb", "ins", "ims", "p", "m", "comm", "g", "ds", "aws", "ls", "tests", "sw", "os", "es", "rs", "sc", "att", "h", "vs", "sys", "stats", "sts", "its", "i", "sports", "c", "temp", "ps", "set", "w"], "pict_type": ["stat_TYPE", "shit_trace", "pict_types", " pictutationchain", "feat_typ", "pictutationclass", "pictacyclass", "feat_TYPE", "aunt_operator", "pictencychain", "pictencyclass", "pictowerrole", "shit_type", "pict_chain", " pictutationclass", "pict_TYPE", "pictowerype", "shit_TYPE", " pictutationtype", " pictutationindex", "feat_type", "pictacychain", "pict_kind", "stat_name", "picturekind", "pictacytype", "pai_Type", "aunt_ype", "pict2type", "pictencyindex", " pict_chain", "pict_ype", "picture_length", "pict_role", "pictttrace", "pict_time", "pict_Type", "pictowertype", "picttTYPE", "pictutationindex", "pai_kind", "feat_name", "aunt_role", "pict2name", "pictureType", "pict_typ", "aunt_type", "pictutationtype", "pict_index", "pict2types", " pict_index", "stat_class", "pict_name", "pict_length", "picturetype", "shit_time", "pictttime", "pict_class", "pai_ype", " pict_class", "picture_name", "pict2length", "pict_trace", "pict_operator", "picture_type", "pictutationchain", "pictoweroperator", "picture_types", "stat_type", "pictacyindex", "pictureype", "pictttype", "pai_type", "pictencytype"]}}
{"project": "FFmpeg", "commit_id": "a18456a2032e49385447a1d0d2f146f65fe9a5e1", "target": 0, "func": "static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)\n\n{\n\n    FILE* f;\n\n    char line[1024];\n\n    char  cmd[1024];\n\n    FFServerIPAddressACL *acl = NULL;\n\n    int line_num = 0;\n\n    const char *p;\n\n\n\n    f = fopen(stream->dynamic_acl, \"r\");\n\n    if (!f) {\n\n        perror(stream->dynamic_acl);\n\n        return NULL;\n\n    }\n\n\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n\n\n\n    /* Build ACL */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL)\n\n            break;\n\n        line_num++;\n\n        p = line;\n\n        while (av_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0' || *p == '#')\n\n            continue;\n\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n\n    }\n\n    fclose(f);\n\n    return acl;\n\n}\n", "idx": 25948, "substitutes": {"stream": ["accept", "poll", "fr", "length", "Stream", "server", "loop", "filter", "driver", "host", "mode", "source", "src", "link", "channel", "context", "ocr", "platform", "store", "ack", "message", "reader", "pipe", "pool", "spec", "wrapper", "ssl", "sample", "stack", "metadata", "draw", "REAM", "http", "secure", "status", "feed", "buffer", "sl", "style", "steam", "sw", "view", "os", "stage", "window", "engine", "sync", "h", "st", "Steam", "console", "ream", "ost", "form", "hook", "transform", "socket", "download", "test", "port"], "c": ["v", "cl", "r", "b", "lc", "ci", "mc", "fc", "bc", "dc", "t", "ac", "w", "m", "e", "g", "cc", "d", "ct", "C", "h", "s", "rc", "tc", "vc", "ch", "ctx"], "f": ["far", "v", "n", "ile", "fr", "in", "fa", "bf", "fs", "file", "fo", "r", "b", "F", "fc", "fn", "xf", "lf", "t", "fac", "uf", "rf", "fm", "fd", "e", "fl", "buffer", "g", "out", "cf", "d", "fb", "af", "fp", "h", "l", "fi", "fe", "form", "i", "ff", "j", "y", "elf", "w"], "line": ["limit", "LINE", "command", "cl", "nl", "page", "range", "frame", "mode", "file", "link", "level", "load", "lin", "lock", "ole", "eline", "pipe", "block", "se", "lane", "path", "lf", "ine", "ip", "comment", "ode", "time", "m", "e", "header", "lines", "buffer", "chain", "list", "id", "ln", "lo", "l", "pe", "de", "point", "row", "pointer", "online", "label", "field", "pos", "le", "port", "Line"], "cmd": ["command", "args", "cl", "md", "text", "cmp", "ctx", "Cmd", "ext", "txt", "cd", "content", "op", "load", "quick", "pkg", "path", "act", "ip", "comment", "dir", "cod", "send", "req", "cli", "bind", "comm", "code", "name", "com", "cp", "call", "id", "arg", "nd", "def", "rc", "try", "point", "ctr", "cont", "addr", "vc", "desc", "col", "normal", "custom", "batch", "msg", "handle", "rn", "term", "cfg", "raw"], "acl": ["ap", "cache", "pc", "cl", "abl", "ACP", "acc", "nl", "gc", "cas", "AC", "anc", "client", "kl", "am", "anon", "wl", "policy", "ace", "lc", "fc", "null", "act", "ip", "ull", "auth", "al", "ac", "mac", " ACL", "cli", "fl", "g", "ah", "ak", "cp", "a", "list", "scl", "ul", "ACA", "fp", "acs", "v", "l", "resp", "cap", "alias", "pb", "alloc", "iam", "all", "ctx"], "p": ["v", "ph", "pc", "n", "vp", "pre", "to", "tp", "pard", "ap", "bp", "pa", "wp", "post", "lp", "jp", "sp", "pl", "pro", "r", "b", "pers", "pn", "pid", "pipe", "pp", "pkg", "t", "pass", "padding", "pat", "m", "ping", "pt", "g", "pad", "P", "d", "cp", "u", "q", "pi", "rep", "part", "perm", "fp", "h", "pe", "l", "point", "np", "pointer", "tmp", "i", "pr", "pb", "pos", "j", "col", "prop", "ps", "port"], "line_num": ["line_im", "Line_number", "Line2sum", "Line2num", "Line_im", "line_no", "line2im", "line_Num", "Line_NUM", "line2num", "Line_sum", "Line2im", "line2sum", "linePNUM", "Line_Num", "Line_no", "Line_num", "linePim", "Line_mult", "linePnum", "line_sum", "linePsum", "line_mult", "line_en", "line_NUM", "line2NUM", "line_number", "Line_en", "Line2NUM"]}}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n", "idx": 25958, "substitutes": {"blk": [" plck", "plk", " blkt", "plak", "plkt", "plkid", "blkid", " plak", "clk", " plk", " blkid", "clkt", " blak", "clck", "blck", "clak", "blkt", " plkid", "plck", "blak", " blck"], "argc": ["Argl", "targetcs", "argumentc", "calc", "Argfc", "argct", "targetc", "argsv", "argl", " argl", " argct", "argumentct", "argfc", "calfc", " argfc", "argcs", " argcs", "targetl", "calcs", "argsct", "argsc", "Argcs", "call", "argumentv", "argumentl", "Argc", "argscs", "targetv", "argsl"], "argv": ["argsvs", "argsV", "argb", "argV", "argf", "argumentc", "argp", "argsvin", "argsv", "argl", "regf", " argl", "argsb", "argvin", "argsm", "agp", "argumentp", "argumentvs", " argm", "agvr", "paramv", "argsf", " argf", "argvr", "Argm", "argm", "docm", "docc", "Argp", " argvs", " argV", "regv", "argsc", "regl", " argp", "Argv", "agc", " argb", "argumentv", "argumentb", "paramvs", "Argc", " argvin", "argsp", "argumentV", "agv", "docv", "argsvr", " argvr", "argsl", "paramV", "paramc", "docvin", "argvs", "regc"], "t1": ["v3", "T3", "t0", "tt1", "p1", "tt2", " t0", "T0", "T2", "T8", "t4", "v0", "tt3", "t64", " t8", "T64", "T4", "T1", "v2", "tt64", " t4", "p8", "t3", "t8", "v1", "p4", " t64", "p2", " t3"], "t2": ["v3", "T3", "t0", " ttwo", "p1", " t0", "dt2", "ttwo", "dt3", "T0", "at1", "t256", "T2", "t4", " t7", "at3", "p0", "dt1", "v7", "T02", "T7", " t256", "T4", "int1", "int256", "T1", "v2", " t02", "int4", " t4", "Ttwo", "attwo", "t3", "v1", "at2", "T256", "p2", "int2", "t7", " t3", "t02", "dt02"], "c": ["v", "cache", "pc", "n", "k", "co", "f", "comp", "ce", "lc", "b", "ci", "mc", "nc", "fc", "z", "ch", "bc", "t", " cont", "cs", "dc", "cod", "ac", "ec", "ic", "o", "p", "e", "code", "g", "cc", "cf", "ct", "cp", "a", "sc", "C", "con", " C", "arc", "cur", "l", "i", "col", " cr", "cut", "cm", "unc", "abc", "ind", " cc"], "ret": ["tail", "rev", "nt", "magic", "rem", "res", "nl", "result", "nz", "iter", "ter", "gc", "ext", "txt", "val", "ll", "print", "rt", "f", "rets", "reply", "tr", "store", "mem", "cb", "reset", "r", "bit", "elt", "ts", "std", "dt", "t", "len", "arr", "ref", "ft", "gt", "Ret", "out", "RT", "ct", "pret", "arg", "RET", "lt", "flag", "att", "def", "rc", "try", "resp", "back", "ord", "alt", "re", "err"], "offset": ["limit", "data", "command", "top", "frequency", "zero", "length", "range", "util", "sp", "local", "end", "slot", "timeout", "after", "op", "item", "store", "loc", "reset", "info", "offs", "address", "pkg", "image", "origin", "len", "coord", "shift", "padding", "before", "key", "ref", "total", "o", "seek", "time", "buffer", "name", "off", "out", "style", "bound", "oo", "Offset", "base", "id", "package", "trace", "error", "size", "needed", "window", "mt", "flag", "location", "position", "point", "pointer", "addr", "type", "skip", "start", "alias", "pos", "index", "ptr", "et", "order", "entry", "set"], "count": ["limit", "nt", "cache", "n", "max", "result", "zero", "iter", "found", "only", "amount", "cloud", "group", "more", "message", "table", "z", "cmd", "info", "find", "sum", "current", "Count", "t", "len", "collection", "comment", "total", "add", "time", "all", "code", "name", "ount", "ct", "call", "number", "q", "list", "nb", "base", "check", "part", "depth", "not", "size", "flag", "no", "counter", "latest", "child", "C", "try", "force", "cont", "non", "num", "record", "batch", "index", "order", "err", "ch", "length", "core"], "optind": ["optimptr", "altstart", "vertfind", " optbind", "opind", "Optindex", "optimstart", "OptIND", " optreq", "vertstart", "optionptr", "optionind", " optindex", "optstrong", "checkind", "optedstart", "optionreq", " optmind", "letind", "letbind", "optionine", "OptInd", "optimindex", "opinn", "optedbind", "optstart", "Optind", "optimmind", "altind", "optionint", "helpind", "optmind", "optfind", " optIND", "optIND", "helpfind", "optindex", "letmind", "optptr", "optimind", "checkint", "checkreq", "optionindex", "opIND", "altinn", "optionInd", "optimIND", "letIND", "optedinn", "optint", "optine", " optinn", "optbind", "opindex", "opbind", "checkine", "altIND", " optptr", " optint", "vertind", "optedind", "optedstrong", "vertstrong", "helpstart", "optimInd", " optstart", "optimbind", "opInd", "optInd", " optine", "optinn", "optionIND", "optedfind", "optreq", "helpstrong", "optiminn", "optedInd"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n", "idx": 25997, "substitutes": {"mr": ["hr", "nr", "wr", "adr", "sr", "ms", "gr", "irm", "rr", "MR", "hm", "yr", "rt", "ocr", "rl", "tr", "mn", "r", "rb", "cr", "mk", "lc", "RM", "vr", "mx", "Mr", "fm", "m", "ml", "rar", "MT", "rm", "mt", "lr", "rs", "ln", "bm", "rpm", "br", "pm", "drm", "pr", "rn", "kr"], "addr": ["url", "res", "adr", "offset", "ast", "ow", "ort", "src", "arp", "ix", "tx", "ack", "ace", "var", "ha", "attr", "address", "ag", "act", "art", "ip", "coord", "arr", "align", "ref", "add", "hash", "hw", "ash", "pad", "ress", "ak", "inter", "a", " address", "id", "mt", "ad", "rs", "eth", "wid", "as", "map", "oad", "ord", "alias", "ptr"], "size": ["max", "count", "ms", "length", "offset", "range", "small", "scale", "mode", "mem", "shape", "ize", " sizes", "body", "z", "bytes", "sum", "area", "len", "sec", "sh", "sized", "m", "sha", "code", "name", "fee", "SIZE", "storage", "iz", "s", "gz", "sn", "sy", "sq", "Size", "set"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n", "idx": 26003, "substitutes": {"vd": [" dd", "v", "ve", "dll", "md", "dn", "dd", "uv", "uds", "gd", "wd", "td", "ud", " od", "rd", "dt", "lv", "vv", "gb", "vt", "du", "cod", "erd", "sd", " sd", "pd", "d", "bd", "nv", "vid", "ed", "nd", "xd", "od", "hd", "ld", "kb", "VD", "vc", "udi", "vr", "dl"], "addr": ["Address", "obj", "nl", "conn", "arp", "loc", "elt", "kt", "cmd", "pkg", "func", "ac", "align", "ref", "add", "hash", "hw", "expr", "news", " address", "rs", "att", "map", "oa", "ame", "alt", "inv", "aj", "work", "adr", "iter", "aw", "host", "am", "ar", "aaa", "usr", "address", "ag", "grad", "act", "arr", "pad", "ah", "call", "u", "a", "ptr", "order", "rev", "tag", "hl", "mk", "gate", "attr", "adj", "coord", "ash", "ach", "mt", "ad", "ld", "dr", "ord", "pos", "sta", "alloc", "url", "md", "ext", "rr", "kl", "ace", "ack", "at", "gt", "ak", "ress", "eth", "hd", "alias"], "err": ["er", "res", "urg", "oe", "conn", "iter", "die", "fr", "bar", " Err", "rr", "ar", "aaa", "warn", "cr", "r", "usr", "attr", "der", "arr", "req", "erd", "e", "ah", "Er", "fee", "mr", "ef", "ev", "rs", "error", "dr", "resp", " er", " terr", "buf", "exc", "Error", "ptr", "msg", "rn", "kr", "ch"]}}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n", "idx": 26008, "substitutes": {"fs_ctx": ["fs__context", " fs2tx", " fs2ctx", "fs2obj", " fs_obj", " fs_context", "fs2tx", "fs_context", " fs2context", "fs2ctx", " fs2obj", "fs_obj", "fs__tx", "fs__obj", "fs2context", "fs__ctx", " fs_tx", "fs_tx"], "fs_path": [" fs2Path", " fs_Path", "fs_Path", "sys_Path", "fsmystream", " fs_context", " fs2stream", "sys_context", "fs_context", "fsmypath", "fs_stream", "fsmyPath", " fs2context", "fs2ctx", "fsmycontext", "sys_path", "fs2context", "fs2path", "fs2Path", "fs2stream", " fs2path", "sys_ctx", " fs_stream"], "stbuf": ["stdbuffer", "stbuff", "strbuff", " stbuffer", "stbuffer", "istbuff", "istbuf", "istcap", " stbuff", " stcap", "strcap", "stcv", "stdcv", "stcap", " stcv", "strbuf", "strbuffer", "stdbuf", "istbuffer", "stdbuff", "istcv"], "node": ["our", "data", "nt", "and", "cache", "n", "db", "post", "server", "bar", "aw", "link", "local", "valid", "job", "ack", "manager", "box", "tree", "cell", "t", "component", "ode", "Node", "line", "nb", "window", "good", "shot", "child", "brain", "leaf", "np", "row", "now", "session", "tmp", "field", "object", "normal", "index", "proc", "msg", "root", "slave"]}}
{"project": "FFmpeg", "commit_id": "f2e9a0ecbef5027f9532c49ffcdfc11d199f6150", "target": 1, "func": "static av_cold int qsv_decode_close(AVCodecContext *avctx)\n{\n    QSVOtherContext *s = avctx->priv_data;\n    ff_qsv_decode_close(&s->qsv);\n    qsv_clear_buffers(s);\n    av_fifo_free(s->packet_fifo);\n    return 0;\n}", "idx": 26030, "substitutes": {"avctx": ["avkw", "avcontext", "svcontext", "camkw", "avectl", " avtxt", "avtxt", "svctx", "avetxt", "camctx", "avjac", "Avctx", "avecontext", " avjac", "Avctl", "avectx", "camjac", " avkw", " avcontext", "Avcontext", " avctl", "svjac", "svkw", "avctl", "camcontext", "Avtxt"], "s": ["sv", "v", "hs", "is", "cl", "gs", "js", "fs", "S", "ns", "ss", "b", "ts", "qs", "cs", "less", "ats", "sb", "p", "m", "aws", "ds", "g", "ls", "q", "os", "ares", "a", "es", "rs", "ess", "sc", "acs", "h", "sys", "als", "bs", "sts", "its", "j", "c", "sq", "ps", "set"]}}
{"project": "FFmpeg", "commit_id": "c83002a4f8042ccfa0688a9a18e8fa0369c1fda8", "target": 1, "func": "int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n\n                                const char *buf)\n\n{\n\n    const char *text = NULL;\n\n    char new_line[2];\n\n    int text_len = 0;\n\n\n\n    while (*buf) {\n\n        if (text && callbacks->text &&\n\n            (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1 ||\n\n             !strncmp(buf, \"{\\\\\", 2))) {\n\n            callbacks->text(priv, text, text_len);\n\n            text = NULL;\n\n        }\n\n        if (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1) {\n\n            if (callbacks->new_line)\n\n                callbacks->new_line(priv, new_line[0] == 'N');\n\n            buf += 2;\n\n        } else if (!strncmp(buf, \"{\\\\\", 2)) {\n\n            buf++;\n\n            while (*buf == '\\\\') {\n\n                char style[2], c[2], sep[2], c_num[2] = \"0\", tmp[128] = {0};\n\n                unsigned int color = 0xFFFFFFFF;\n\n                int len, size = -1, an = -1, alpha = -1;\n\n                int x1, y1, x2, y2, t1 = -1, t2 = -1;\n\n                if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) {\n\n                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n\n                    len += close != -1;\n\n                    if (callbacks->style)\n\n                        callbacks->style(priv, style[0], close);\n\n                } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", c_num, &color, sep, &len) > 2) {\n\n                    if (callbacks->color)\n\n                        callbacks->color(priv, color, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", c_num, &alpha, sep, &len) > 2) {\n\n                    if (callbacks->alpha)\n\n                        callbacks->alpha(priv, alpha, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->font_name)\n\n                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n\n                } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) {\n\n                    if (callbacks->font_size)\n\n                        callbacks->font_size(priv, size);\n\n                } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) {\n\n                    if (an != -1 && buf[2] != 'n')\n\n                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n\n                    if (callbacks->alignment)\n\n                        callbacks->alignment(priv, an);\n\n                } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n", "idx": 26031, "substitutes": {"callbacks": ["calleners", "Callables", "callrers", " callsers", " callrers", "allosures", "callosures", "codback", "caneners", " Callabases", "allchers", "callbackblocks", "callingeners", "functionosures", "codables", "cacheboards", "cacheabases", "coinboards", "Callback", "callingands", "cochers", " callers", " callbs", "callbackbacks", "coinbs", " Callables", "callingosures", "licors", "canbanks", "coinbanks", "canbs", "cachebacks", "functionbacks", "callators", "liceners", "coineners", " callback", "callingbanks", "callbackables", "callingchecks", " callsrers", "allbs", "callchers", "cobacks", "callingchers", " Callbs", "cobs", " Callboards", "labors", "callingers", "callingbacks", "labeners", "callbackplugins", "codbacks", "callers", "licands", "labands", "callingbs", "callingators", "callables", "callingplugins", "callbs", "callingors", "labbacks", "callbanks", " callables", "callors", "canbacks", "allchecks", "callback", "functionators", "callingrers", "callplugins", "licbacks", "callchecks", "callboards", "callands", "Callbacks", "callabases", "allbacks", "cachebs", " callsbacks", "functionbs", " Callplugins", "coinabases", "callingblocks", "coinbacks", " Callbacks", " callblocks", "callblocks", "allators", "cochecks", "callingables", " callplugins"], "priv": ["rib", "rev", "pri", "deb", "conn", "Priv", "ctx", "txt", "sp", "phys", "pro", "mem", "nick", "policy", "prop", "cb", "reader", "var", "cert", "env", "usr", "pkg", "public", "pg", "attr", "sec", "vt", "private", "req", "pub", "dev", "cp", "pack", "org", "pi", "trust", "prefix", "pdf", "rc", "sys", "conf", "cap", "pr", "pb", "proc", "ptr", "alloc", "access", " Priv", "password", "riv"], "buf": ["txt", "src", "tx", "buff", "cb", "b", "read", "box", "cmd", "bang", "pg", "pkg", "ref", "canon", "off", "queue", "fb", "old", "Buffer", "def", "Buff", "np", "home", "pb", "term", "emb", "cast", "iter", "next", "history", "brace", "rb", "var", "usr", "bytes", "cat", "doc", "str", "pad", "bound", "pack", "bn", "nm", "num", "addr", "cap", "wb", "desc", "ptr", "kw", "length", "ctx", "limit", "rev", "raw", "lit", "cv", "cam", "bp", "bf", "vec", "pool", "coord", "uf", "conv", "port", "buffer", "bur", "front", "foo", "cur", "paren", "rc", "img", "ctr", "row", "pos", "proc", "orig", "msg", "etc", "loop", "bar", "keep", "mem", "env", "bc", "bin", "req", "aka", "quote", "br", "bs", "batch", "bu", "bt", "err", "xff"], "text": ["data", "nt", "command", "ty", "TEXT", "binary", "ext", "txt", "ut", "print", "content", "config", "context", "tag", "tx", "event", "buff", "message", "read", "writer", "path", "image", "t", "entry", "comment", "p", "translation", "str", "buffer", "code", "name", "quote", "tab", "format", "ct", "title", "prefix", "write", "old", "phrase", "value", "close", "cont", "color", "button", "br", "font", "word", "type", "select", "Text", "x", "empty", "msg", "inner", "term", "ind", "length"], "new_line": ["new_tab", "new_char", "newablelines", "new_lin", "ew_LINE", "newletblock", "New_link", "newletlines", "new_lines", " new_lines", "newablelin", "newerLine", "newletline", "new_link", "newerline", "newerlines", "New_Line", " new_tab", "new_LINE", " new_LINE", "New_lines", "new_row", "New_lin", "new_block", "newlettab", "New_char", "ew_line", "newerlink", " new_block", "newableline", " new_lin", "newablechar", "ew_Line", "New_line", "new_Line", "ew_row"], "text_len": ["text_ln", "txt_length", "text_length", "text_mem", " text_mem", "txt_ln", " text_Len", "txt_len", " text_gen", "text_Len", "txt_Len", "text_gen"], "style": ["make", "magic", "top", "parse", "sort", "script", "Style", "weight", "ty", "theme", "mode", "link", "sche", "show", "file", "estyle", "feature", "family", "tag", "lock", "ss", "prop", "set", "class", "state", "attr", "se", "block", "sty", "image", "t", "html", "comment", "styles", "sh", "lib", "o", "light", "code", "format", "name", "sl", "line", "status", "py", "te", "role", "size", "rule", "close", "s", "try", "color", "shadow", "tc", "type", "start", "head", "stat", "font", "date", "si", "css"], "c": ["v", "cache", "n", "count", "co", "ctx", "f", "comp", "cb", "b", "r", "fc", "cmd", "t", "cu", "dc", "cs", "cod", "ac", "ic", "o", "p", "m", "e", "code", "g", "cc", "ct", "cp", "css", "a", "C", "h", "con", "s", "rc", "l", "close", "color", "tc", "col", "unc", "ch", "w"], "sep": ["lookg", " seper", "serp", "peg", " seep", "sexg", " seit", "pseg", "geg", "pep", "eleep", "seper", "elep", "elem", "seit", "lookpa", "sexxp", "sexm", "geit", "serm", "psexp", "sem", " sepa", "serep", " sem", "pepa", "eleper", "peep", "sepa", " sexp", "lookep", "serper", "pexp", " seg", "psep", "peit", "sexp", "geep", "pem", "lookp", "seg", "gep", "seep"], "c_num": ["c_ref", "cp_num", "cp_um", "c2num", "c2sum", "cp_nam", " c_index", "c2no", "co_um", "c2um", "co_sum", "co_num", " c_number", "c_number", "c__mon", "c_mon", "cp_ref", "c_no", " c_mon", " c_ver", "c_sum", "c_ver", "c__num", "co_no", " c_Num", "c_nam", "c_index", "c_n", "c__Num", "c_Num", " c_n", "c_um", "c__n"], "tmp": ["cache", "cv", "obj", "cmp", "sp", "params", "tt", "uv", "td", "buff", "cb", "gb", "html", "mp", "sup", "cp", "prefix", "cur", "img", "rc", "np", "tc", "extra", "proc", "temp", "etc", "test", "ctx"], "len": ["rev", "ann", "gen", "args", "vals", "la", "cmp", "n", "count", "fin", "del", "lp", "sp", "val", "link", "ll", "gl", "comp", "lim", "mem", "seq", "den", "elt", "vec", "fn", "cmd", "bytes", "cond", "lif", "fun", "cod", "rot", "lib", "ref", "align", "lon", "compl", "p", "par", "en", "sl", "line", "Len", "ls", "call", "cp", "depth", "syn", "last", "no", "size", "ln", "ler", "ld", "wid", "l", "num", "open", "mat", "label", "cap", "mon", "pos", "ell", "msg", "dim", "err", "xff", "length", "lit"], "x1": [" x4", "p4", "x4", "p1", "p2", "y4"], "y1": ["y0", "y01", "t0", " y01", "t01", "x01", " y0", "t2", "t1", "x0"], "x2": ["rx2", "rx1", "xs2", "xs1", "rx02", "x02", "xs02", " x02"], "y2": ["i6", "i2", " y6", "x4", "i1", "x6", "y6", " y4", "y4", "i4"]}}
{"project": "FFmpeg", "commit_id": "2453f40602dd6f5fa670954ee733a4155675f645", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3],\n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n\n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now\n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 62; /* value 63 is not allowed */\n\n            }\n\n\n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\",\n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n\n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            assert(0); //cannot happen\n\n            code = 0;           /* kill warning */\n\n        }\n\n\n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j,\n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 26038, "substitutes": {"scale_code": ["scale_factor", "scale_operator", " scale_operator", "scaleityoperator", "scaleityfactor", "scaleitycode", "scaleitycodes", " scale_factor", "scale_codes", " scale_codes"], "scale_factors": ["scale_factores", "scale_factor", "scale_factsters", "scale_ctors", "scale_ctorset", "scale_Factories", "scale_actories", "scale_actorset", "scale_factsories", "scale_ctters", "scale_Factor", "scale_factorset", "scale_Factores", "scale_actor", "scale_factsors", "scale_factories", "scale_actors", "scale_ctories", "scale_Factors", "scale_actters", "scale_factsorset", "scale_factters", "scale_actores"], "sb_samples": ["sb_examps", "sb_seamples", "sb_samaces", "sb_ssamps", "sb_exources", "sb_ssores", "sb2exores", "sb_exores", "sb2examples", "sb_samamples", "sb_sores", "sb2sores", "sb_seaces", "sb_sources", "sb_samources", "sb_ssamples", "sb2samps", "sb_examples", "sb_seamps", "sb_samamps", "sb_tources", "sb_taces", "sb2samples", "sb_saces", "sb_seources", "sb2exources", "sb2sources", "sb_tamps", "sb_ssources", "sb_tamples", "sb2examps", "sb_samps", "sb_seores"], "sblimit": ["sbllimify", "sblumite", "splemify", "sblIMify", "sflumiter", "sblumIT", "splimit", "splemIT", "sblIMitate", "sblIMIT", "sblimitate", "sflumit", "sbllimit", "sblimiter", "sblimify", "sflimite", "sblIMite", "sblemitate", "sblemify", "sblemIT", "sbllimitate", "sblimIT", "sblIMiter", "splimIT", "sflumIT", "splimitate", "sflimIT", "sblemit", "sflimit", "sblemiter", "splemit", "sflimiter", "sblimite", "sbllimIT", "splimify", "sblumiter", "splemitate", "sblIMit", "sflumite", "sblemite", "sblumit"], "p": ["ap", "pc", "vp", "tp", "ph", "parse", "bp", "pa", "wp", "lp", "jp", "power", "f", "pl", "op", "pers", "pp", "pkg", "t", "ip", "m", "par", "ping", "pt", "g", "P", "d", "cp", "u", "q", "pi", "rep", "part", "perm", "pe", "point", "pm", "pb", "pr", "x", "c", "pair", "y", "prop", "ps"], "vmax": [" vpy", "Vright", "volmin", "qvmax", "vMax", "svmax", "volgt", "Vmax", "vconf", "cvprint", "vax", "nmax", "svmin", "nMax", "VMax", "nmin", "svMAX", "nMAX", "volpy", "vpy", "volMax", " vax", "nax", "avMax", " vMAX", "VMAX", "qvprint", "vdefault", "svax", " vgt", "cvdefault", "volmax", "qvconf", "cvconf", "avMAX", "vgt", "cvmax", "Vgt", " vright", "vprint", "volMAX", "Vmin", " vdefault", "svMax", "svgt", " vconf", "vmin", " vmin", "avright", " vprint", "vMAX", "avmax", "svpy", "Vax", " vMax", "avax", "qvdefault", "vright"], "v": ["sv", "ve", "vp", "cv", "qv", "va", "val", "uv", "f", "vm", "vr", "vo", "lv", "tv", "vv", "iv", "vt", "conv", "m", "dev", "d", "values", "u", "nv", "q", "ev", "value", "vol", "V", "h", "vs", "l", "av", "vert", "ov", "vc", "x", "inv", "y", "vi", "ver", "w"], "n": ["nt", "nr", "nl", "max", "ot", "na", "nu", "net", "ns", "ne", "mn", "r", "b", "nan", "t", "len", "cn", "m", "g", "N", "d", "nw", "nv", "q", "nb", "nd", "no", "size", "l", "nn", "nm", "num", "np", "ng", "c", "Ni", "x", "sn", "y", "nc", "w"], "i": ["qi", "init", "ex", "is", "iq", "me", "in", "li", "ij", "iat", "f", "ix", "xi", "ai", "ami", "ini", "b", "ci", "z", "ki", "ik", "di", "um", "at", "ie", "ii", "t", "ip", "mi", "by", "ri", "m", "multi", "o", "e", "out", "jj", "ic", "q", "pi", "a", "id", "im", "io", "iu", "s", "l", "point", "ti", "zi", "x", "ia", "phi", "c", "y", "it", "si", "bi", "ind", "I"], "j": ["obj", "aj", "to", "js", "fr", "J", "jo", "c", "json", "ij", "jp", "jl", "f", "job", "ret", "kj", "ji", "b", "r", "z", "t", "key", "o", "m", "str", "e", "jj", "g", "off", "d", "jump", "be", "q", "uj", "bj", "jc", "bo", "h", "l", "br", "bs", "y", "x", "dj", "ion", "ja", "it", "jit", "bi", "ind"], "k": ["ph", "kid", "ks", "uk", "unk", "kl", "km", "kind", "kj", "b", "mk", "z", "ku", "kt", "ki", "kk", "t", "ko", "key", "ijk", "sk", "ac", "kh", "ok", "m", "g", "kick", "ak", "kn", "ek", "q", "ke", "ck", "ka", "K", "tk", "wk", "c", "kin", "ik", "kw", "kr"], "code": ["data", "cause", "command", "reason", " Code", "count", "offset", "next", "content", "action", "change", "tag", "event", "ce", "description", "message", "state", "info", "codes", "Code", "sign", "second", "sequence", "comment", "key", "cod", "component", "ode", "note", "status", "header", "name", "cc", "function", "definition", "call", "check", "id", "error", "size", "close", "force", "try", "use", "label", "cycle", "coe", "type", "condition", "one", "desc", "c", "pos", "test", "entry", "ind", "ch", "length"], "index": ["ex", "max", "zero", "link", "val", "ix", "lock", "instance", "loc", "state", "note", "scan", "time", "connection", "status", "id", "value", "location", "position", "capacity", "type", "ind", "set", "result", "iter", "offset", "level", "connect", "iso", "address", "check", "close", "EX", "num", "open", "cycle", "start", "ion", "order", "success", "length", "is", "count", "initial", "timeout", "shape", "gate", "second", "zone", "out", "option", "error", "search", "try", "row", "condition", "pos", "date", "test", "network", "page", "scroll", "slice", "loop", "node", "change", "info", "find", "key", "update", "draw", "number", "list", "write", "seed", "size", "point", "axis", "label", "Index", "x", "ice", "port"], "d1": ["doup", " d7", "do7", "fdone", "none", " done", "D1", " d5", "bd0", "dOne", "do5", "bdOne", "Done", " d0", "v7", "n5", "n0", "fd1", "d5", "d7", "d0", "v5", " dup", "n1", "bdone", "do1", "DOne", "fd2", "v1", "D2", "vup", "done", "fdOne", "bd5", "bd1", "bd2", "dup"], "d2": ["da2", " d42", "da5", "ntwo", "dd1", "D1", "da42", "n02", " d5", "D3", "dtwo", " d02", "D02", "dd3", "d3", " d3", "d5", "Dtwo", "dd2", "da3", "d42", "dd02", "D2", "n2", "d02", "bd3", "bd42", "bd5", "bd2", " dtwo"], "sf": ["alf", "df", "sv", "vp", "tif", "tp", "hs", "sr", "gs", "ty", "bf", "zz", "sp", "fs", "fo", "csv", "f", "tf", "stab", "see", "ss", "supp", "buff", "php", "sol", "xf", "fw", "lf", "ssl", "ctl", "sh", "sk", "uf", "rf", "fm", "sb", "sd", "hw", "fd", "fy", "fx", "sl", "cf", "ds", "si", "sw", "ze", "fee", "rm", "scl", "bj", "ssh", "SF", "ief", "fi", "sql", "qq", "isf", "pb", "sn", "sy", "sq", "rn", "sm"]}}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 26059, "substitutes": {"opaque": ["oppaque", "oboch", "obaque", " opaques", "onetossibly", " opane", "obossibly", "opane", "opaques", "onetaques", " opossibly", "onetoch", "oppaques", "obaques", " opoch", "oppane", "ipane", "ipaque", "ipaques", "onetaque", "opoch", "opossibly"], "irq": ["iorquest", "iraqi", "iroq", "rirquest", "pirquire", " irquest", "iraforce", "irmquire", "irdq", "iorq", "iorqi", "irque", "rrqq", "rinqq", "iordq", "irQ", "pirdq", "irmq", "iroque", "rirqi", "rinquire", " irque", "pirqu", "pirquest", "rrq", "irmqu", "pirq", "rirdq", "irquest", "irqq", "irqu", " sirq", "irforce", "ibrquire", "earquire", "iraqu", "iroquest", "rirq", "ibrquest", " sirforce", "irmquest", "irtquest", "ibrq", "irtqu", " irqu", "rinq", "earQ", "pirforce", "irtq", "irquire", "irtque", " sirqi", "earq", "iraq", "rrquire", " sirqu", "ibrqu", "rinQ", "rrQ", "earqq", "irqi", "iroqu", "pirqi"], "s": ["sv", "sis", "v", "hs", "iss", "gs", "js", "sa", "ses", "fs", "S", "sam", "serv", "ns", "ss", "r", "ts", "sol", "se", "spec", "t", "cs", "less", "sb", "sim", "m", "comm", "p", "g", "sl", "ds", "ls", "so", "syn", "rs", "ess", "sc", "acs", "soc", "h", "sys", "vs", "als", "sts", "bs", "stats", "i", "c", "sq", "ps", "self", "sm"], "vec": ["rib", "rev", "sv", "ve", "v", "cv", "vp", "cast", "js", "ele", "cam", "val", "serv", "uv", "ret", "seq", "buff", "veh", "var", "kt", "cmd", "vre", "vr", "spec", "vo", "feat", "resh", "lv", "vv", "iv", "VID", "vector", "vt", "verb", "conv", "req", "ec", "coll", "Vector", "sel", "expr", "dev", "vet", "wcs", "crit", "nv", "virt", "ev", "miss", "def", "vs", "des", "vert", "vc", "vy", "buf", "desc", "vi", "ver", "enc"]}}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 26061, "substitutes": {"i": ["qi", " I", "yi", " iter", "ix", "xi", "ii", "oi", "ei", "my", "e", "status", "zi", "y", "bi", "ind", "I", "iter", " li", "ci", " multi", "di", " x", "pi", " mi", "iu", "fi", " ti", "phi", " wi", " my", "init", " j", "is", "me", "ij", "ini", "gi", " im", "hi", " id", " bi", "cli", "sim", "ic", "m", "multi", "chain", "ri", " p", " ii", " n", "\u0438", " si", "im", " pi", " index", " info", "index", "si", " err", "li", " ni", "ai", "ji", "ki", "info", "mi", " m", "ims", "list", " di", "uri", "ti", "batch", "x", "it", "asi", "ui"], "decoded": ["descaled", " decrypted", "decrypted", "Decressed", " decode", "deressed", "Decoded", "encanded", "encoded", "deccoded", "deanded", " decleted", "decanded", "descrypted", "enccoded", "decaled", "derypted", "strrypted", "descode", " decaled", "desccoded", "decleted", "decode", "decressed", "descanded", "strcoded", "deoded", " deccoded", "strleted", "Deccoded", "descressed", "encaled", "stroded", "Decrypted", "encrypted", "encleted", "descoded", "encode"], "test_cases": ["test5case", "test67lets", " test_posts", "test67case", "test_lets", "test_posts", " test_case", "test5cases", "test5posts", "test__cases", "test67cases", "testcasecase", "Test_case", "test_atts", "test__steps", "test_case", "test__bags", "test67times", " test_lets", "dev__bags", "test5atts", "test__caps", "dev_caps", " test_atts", "test_times", "test_caps", "dev__caps", "dev__steps", "dev_cases", "test_steps", "test_bags", "dev_bags", "dev__cases", "testcaseatts", "Test_times", "dev_steps", "testcasecases", " test_times", "Test_cases", "testcaseposts"], "obj": ["nt", "n", "js", "db", "ist", "obs", "ot", "txt", "stick", "ut", "ent", "nu", "pl", "inst", "ob", "og", "rect", "buff", "rb", "elt", "cmd", "utt", "pkg", "adj", "ox", "t", "act", "arr", "cod", "oid", "o", "bh", "copy", "pt", "out", "Object", "org", "os", "imp", "so", "bo", "bj", "Obj", "att", "od", "img", "resp", "cont", "xy", "tmp", "np", "obo", "oj", "tk", "object", "j", "pr", "onet", "et", "it", "po", "wo", "ctx"], "str": ["v", "url", "n", "text", "fr", "gr", "txt", "sp", "jp", "print", "ns", "priv", "tr", "seq", "cr", "r", "t", "bl", "STR", "arr", "buffer", "pt", "g", "name", "sl", "dat", "rel", "sw", "out", "Str", "String", "mt", "vol", "s", "st", "dr", "ctr", "nm", "cont", "br", "sts", "bs", "desc", "j", "pr", "buf", "msg", "temp", "err", "enc"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n", "idx": 26069, "substitutes": {"qdev": ["gev", "Qdev", "qqev", "qdevice", "qudata", "qev", "qudef", "Qdef", " qdevice", "qudev", "gdef", "Qdevice", "iqdev", " qdef", "iqev", "qdata", "qqdef", "iqdef", "qudevice", "qpad", "gpad", "qdef", "Qdata", "qqpad", "qqdev", " qdata", "iqpad", "gdev"], "dev": ["nt", "v", "obj", "gu", "md", "dep", "sky", "cam", " devs", "DEV", " env", " def", "serv", "aux", "local", "pro", "priv", "tech", "mem", "det", " vo", "go", "var", " des", "cmd", "block", "spec", "serial", "dem", "comment", "unknown", "pub", "sd", "doc", "hw", "pad", "device", "Dev", "d", "ev", "app", "adv", "develop", " priv", "def", "des", "de", " device", " prod", "van", "av", "form", "desc", "ver", "raw"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int gen_sub_bitmap(TeletextContext *ctx, AVSubtitleRect *sub_rect, vbi_page *page, int chop_top)\n\n{\n\n    int resx = page->columns * BITMAP_CHAR_WIDTH;\n\n    int resy = (page->rows - chop_top) * BITMAP_CHAR_HEIGHT;\n\n    uint8_t ci, cmax = 0;\n\n    int ret;\n\n    vbi_char *vc = page->text + (chop_top * page->columns);\n\n    vbi_char *vcend = page->text + (page->rows * page->columns);\n\n\n\n    for (; vc < vcend; vc++) {\n\n        if (vc->opacity != VBI_TRANSPARENT_SPACE) {\n\n            cmax = VBI_NB_COLORS;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (cmax == 0) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"dropping empty page %3x\\n\", page->pgno);\n\n        sub_rect->type = SUBTITLE_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if ((ret = avpicture_alloc(&sub_rect->pict, AV_PIX_FMT_PAL8, resx, resy)) < 0)\n\n        return ret;\n\n    // Yes, we want to allocate the palette on our own because AVSubtitle works this way\n\n    sub_rect->pict.data[1] = NULL;\n\n\n\n    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,\n\n                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],\n\n                            0, chop_top, page->columns, page->rows - chop_top,\n\n                            /*reveal*/ 1, /*flash*/ 1);\n\n\n\n    fix_transparency(ctx, sub_rect, page, chop_top, cmax, resx, resy);\n\n    sub_rect->x = ctx->x_offset;\n\n    sub_rect->y = ctx->y_offset + chop_top * BITMAP_CHAR_HEIGHT;\n\n    sub_rect->w = resx;\n\n    sub_rect->h = resy;\n\n    sub_rect->nb_colors = (int)cmax + 1;\n\n    sub_rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n    if (!sub_rect->pict.data[1]) {\n\n        av_freep(&sub_rect->pict.data[0]);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    for (ci = 0; ci < cmax; ci++) {\n\n        int r, g, b, a;\n\n\n\n        r = VBI_R(page->color_map[ci]);\n\n        g = VBI_G(page->color_map[ci]);\n\n        b = VBI_B(page->color_map[ci]);\n\n        a = VBI_A(page->color_map[ci]);\n\n        ((uint32_t *)sub_rect->pict.data[1])[ci] = RGBA(r, g, b, a);\n\n        av_dlog(ctx, \"palette %0x\\n\", ((uint32_t *)sub_rect->pict.data[1])[ci]);\n\n    }\n\n    ((uint32_t *)sub_rect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0);\n\n    sub_rect->type = SUBTITLE_BITMAP;\n\n    return 0;\n\n}\n", "idx": 26075, "substitutes": {"ctx": [" cx", "ca", "cv", "obj", "cmp", "conn", "cam", "cas", "unk", "iat", "jp", "net", "context", "timeout", "tx", "cpp", "cb", "kg", "kt", "cmd", "pool", "pkg", "xc", "act", "dc", "cu", "ctl", "conv", "req", "tm", "mom", "hw", "cc", "jac", "ct", "cp", "crit", "wcs", "ck", "check", "sc", "Context", "ctr", "np", "tmp", "conf", "tc", "sys", "addr", "resp", "c", "cm", "msg", "qt", "ctrl", "kw", "nc", "cfg"], "sub_rect": ["subPrdial", "homeserverrest", "suburtr", "suburtxt", "sublettip", "sub_coord", "sub_hist", "sub_tip", "sub_tri", "short_tip", "subpycoll", " sub_mat", "subPrrect", "subserverrect", "subvalrect", "srcpyRect", " sub_err", "src_err", "test_void", "subpylat", "subtround", "subthemod", "srcpyrect", "sub_cmd", "sub_Rect", "sub_dial", "super_coord", "subPrdir", "Sub_dir", "sub___dir", "subvalrest", "test_rect", "Sub_Rect", "sub_mod", "subthecoord", "short_rect", "Sub_lat", "sub___dial", "sing_rect", "singobjregion", " sub_hist", "sing___Rect", "sub_dir", "sub_obj", "home_tri", "home_rest", "sing_tar", "sub_assert", "sub_err", "subpyRect", " sub_dial", "home_rect", "home_round", "subpyrect", "subobjdial", "sub___rect", "homeserverround", " sub_obj", "test_round", "short_dir", "subtherect", "sing_coll", "subobjrest", "subPrtip", " sub_region", "subletdial", "subvalobj", "test_assert", "sing___desc", "short_dial", "sub_region", "subserverround", "suburrect", "subobjcoll", "subtrect", "sing_Rect", "subpyassert", "subjrect", "super_mod", "subtvoid", "sub_txt", "subvalregion", "short___rect", "subletrect", "subjround", "sub_rest", "super_rect", "sub_tar", "subobjregion", "sing___rect", "short___dir", "Sub_tr", "sing_desc", "sub_mat", "short___dial", "suburRect", "subjtri", "sub_void", "homeserverrect", "sub_round", "sub___txt", "subpyregion", "singobjrect", "sing_hist", "subserverrest", "subobjRect", "homeservertri", "sub___tip", "subtassert", "singobjRect", "sub_coll", "srcpyerr", "singobjcoll", "subobjrect", "sub_lat", "Sub_cmd", "subpycmd", "Sub_rect", "sub___desc", "Sub_txt", "subjrest", "sub___tr", "subpyvoid", "subpyround", " sub_rest", "sub_tr", " sub_Rect", "subservertri", "sub_desc", "src_Rect", "sub___rest", "short___tip", "Sub_obj", "src_rect", "sub___Rect", "subpyerr", "sing_region", "subletdir"], "page": ["office", "file", "net", "message", "report", "pg", "image", "plot", "p", "ping", "line", "window", "application", "np", "record", "form", "c", "pc", "next", "pages", "pp", "address", "wiki", "web", "html", "total", "meta", "doc", "tab", "device", "pi", "site", "num", "module", "cm", "order", "Page", "apache", "parent", "context", "mu", "event", "see", "pool", "pty", "buffer", "view", "table", "age", "pixel", "row", "document", "wait", "date", "network", "cache", "parse", "v", "post", "server", "frame", "node", "config", "go", "block", "article", "wikipedia", "code", "number", "list", "phrase", "size", "pdf", "point", "word", "port"], "chop_top": ["chumb___origin", "chopptTOP", "chopptoffset", "chumb___bottom", "chpop_tops", "chop___origin", "chop_html", "choppttop", "chang_top", "chop_offset", "chop_bottom", "chpop_bottom", "chop_height", "chopp__bottom", "chhop_to", "chop___bottom", "chopp_upper", "chopp_height", "chumb___top", "chopptto", "chumb___y", "chop_below", "chhop_offset", "chpop_to", "chumb_y", "chang_client", "chumb_bottom", "chop__top", "chang_TOP", "chip_below", "chop_upper", "chopmmbelow", "chop___y", "chop_to", "chhop_top", "chop__bottom", "chopmmtop", "chopp__upper", "chumb_top", "chop_y", "chop__upper", "chhop_TOP", "chang_to", "chip_top", "chang_bottom", "chopp_top", "chop__height", "chip_bottom", "chopmmbottom", "chop_tops", "chop___top", "chpop_top", "chang_html", "chop_origin", "chopp_bottom", "chopp__height", "chumb_origin", "chopp__top", "chop_client", "chop_TOP"], "ci": ["ca", "co", "li", "cia", "cd", "ai", "ce", "cb", "ki", "di", "xc", "ii", "dc", "ico", "cs", "cod", "lic", "cci", "ic", "ct", "cp", "fi", "ti", "ia", "c", "cm", "si", "bi"], "ret": ["nt", "rem", "res", "result", "gc", "final", "val", "aux", "print", "ll", "rt", "mem", "rets", "mel", "reset", "reg", "elt", "ry", "t", "len", "vt", "ref", "req", "ft", "gt", "status", "Ret", "out", "pret", "not", "fit", "RET", "value", "att", "def", "try", "resp", "cont", "progress", "tmp", "back", "re", "alt", "j", "it"], "vc": ["sv", "v", "cv", "vp", "pc", "ve", "cil", "VC", "qv", "uv", "WC", "wx", "ix", "vm", "vin", "vl", "veh", "lc", "vec", "var", "mk", "forcer", "voice", "vd", "fc", "vo", "xc", "lv", "vv", "cu", "vt", "cul", "lic", "conv", "ic", "coll", "cf", "vet", "voc", "wcs", "vine", "nv", "ev", "vol", "av", "vg", "vi", "vy", "c", "ht", "ctrl", "vr"], "vcend": ["ccend", "grecent", "gcend", "vccend", " vcd", " vrecent", "gdesc", "trecent", "vend", "cend", " vhend", "tpent", "gpent", "tcend", "vrecent", " vdesc", "vdesc", "tdesc", "vhend", "vccd", " vend", "vpent", "ccd", "vcd", "chend", "vchend", " vpent"]}}
{"project": "FFmpeg", "commit_id": "41a052a6badc9ed672a810a40b8e54af5d093b5d", "target": 1, "func": "int opt_default(const char *opt, const char *arg)\n\n{\n\n    const AVOption *oc, *of, *os, *oswr;\n\n    char opt_stripped[128];\n\n    const char *p;\n\n    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;\n\n\n\n    if (!(p = strchr(opt, ':')))\n\n        p = opt + strlen(opt);\n\n    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n\n\n\n    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,\n\n                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n\n#if CONFIG_SWSCALE\n\n    sc = sws_get_class();\n\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        // XXX we only support sws_flags, not arbitrary sws options\n\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    swr_class = swr_get_class();\n\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (oc || of || os || oswr)\n\n        return 0;\n\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n\n    return AVERROR_OPTION_NOT_FOUND;\n\n}\n", "idx": 26087, "substitutes": {"opt": ["obj", "vp", "max", "txt", "jp", "comp", "ret", "after", "optim", "loc", "oss", "cmd", "pkg", "pres", "ip", "options", "ref", "expr", "off", "IT", "np", "ost", "alt", "pr", "c", "stat", "term", "w", "dest", "tip", "opted", "oop", "iter", "offset", "op", "var", "png", "ts", "pp", "usr", "feat", "cat", "str", "cp", "crit", "prefix", "fp", "num", "buf", "pair", "prop", "init", "top", "tp", "intern", "wp", "ot", "fo", "rt", "anon", "timeout", "tag", "tr", "attr", "spec", "adj", "hop", "out", "Opt", "OP", "option", "lt", "iop", "tmp", "j", "orig", "proc", "msg", "cmp", "text", "rop", "ext", "sp", "pl", "slot", "mem", "block", "nom", "t", "ok", "pt", "pot", "cho", "snap", "x", "it"], "arg": ["ax", "args", "v", "aug", "urg", "star", "iter", "aw", "ext", "val", "local", "arp", "it", "ar", "mem", "ret", "op", "tag", "ack", "var", "reg", "loc", "asc", "cmd", "pp", "ag", "agg", "alg", "arr", "bin", "rg", "pat", "ref", "req", "add", "doc", "par", "gt", "argument", "call", "vol", "flag", "Arg", "addr", "target", "param", "buf", "msg", "prop", "err", "w"], "oc": ["obj", "pc", "co", "ow", "ot", "ocation", "ocal", "om", "ocr", "ocon", "ob", "og", "op", "loc", "toc", "oss", "bc", "ox", "oci", "ok", "ac", "oid", "uc", "ec", "o", "voc", "cp", "org", "oo", "osc", "arc", "rc", "soc", "ov", "ost", "roc", "c", "unc", "alloc", "nc", "oco", "OC"], "of": ["alf", "ol", "er", "obj", "to", "oft", "oe", "oga", "on", "ot", "oln", "Of", "om", "omp", "ob", "ou", "or", "at", "less", "ok", "el", "other", "osi", "o", "ont", "en", "off", "cf", "out", "por", "from", "org", "with", "ong", "so", "ous", "bj", "af", "io", "orf", "des", "fi", "oa", "OF", "one", " fo", "et", "unc", "wo"], "os": ["ose", "ol", "oS", "pc", "is", "oes", "on", "obs", "ot", "dos", "om", "ob", "op", "ss", "oss", "ts", "ops", "OS", "at", "cs", "ok", "oid", "osi", "o", "out", "ds", "ls", "ows", "oo", "osa", "osc", "io", "s", "sys", "us", "bs", "oa", "ost", "i", "oos", "oses"], "oswr": ["owr", " osWR", " osw", " osrw", "ossvr", "oWR", "osw", "OSWR", "orw", "ossw", "osrw", "OSrw", "osvr", "osWr", "OSWr", " osvr", "osswr", "ossrw", "OSvr", " osWr", "OSwr", "osWR", "OSw", "oWr"], "opt_stripped": ["opt_improged", "opt_stripled", "opt_impropled", "opt__strops", "opt__stripping", "opt__stropped", "opt_strippacked", "opt_impropped", "opt_supping", "opt_strapped", "opt_ripacked", "opt_sued", "opt_supped", "opt_wrapping", "opt_strippping", "opt__strips", "opt_strips", "opt_stried", "opt_rips", "opt_strapled", "opt_stropping", "opt_stropped", "opt_striped", "opt_strops", "opt_cropping", "opt__stropping", "opt_striged", "opt_wrapled", "opt_crops", "opt_straged", "opt_ripped", "opt_wraged", "opt_cropacked", "opt__stripped", "opt_ripping", "opt_stripacked", "opt_stripps", "opt_cropped", "opt_stripping", "opt_wrapped", "opt_wraed", "opt_strippped"], "p": ["v", "ph", "pc", "n", "tp", "pre", "dp", "bp", "wp", "lp", "jp", "sp", "f", "op", "r", "b", "pp", "t", "padding", "o", "m", "par", "pt", "P", "per", "d", "cp", "u", "q", "fp", "s", "l", "i", "pr", "pos", "c", "j", "pb", "x", "ps"], "cc": ["ca", "cv", "pc", "cmp", "cl", "acc", "gc", "co", "cca", "lc", "ci", "mc", "bc", "dc", "cs", "ac", "uc", "ec", "cf", "ct", "cp", "ck", "con", "rc", "soc", "CC", "ctr", "tc", "roc", "c", "unc", "ctrl", "nc", "ctx"], "fc": ["cv", "pc", "co", "fr", "f", "tf", "loc", "lc", "fn", "func", "bc", "dc", "cs", "ac", "conv", "uc", "ec", "fl", "FC", "format", "cf", "vol", "fp", "con", "rc", "soc", "fi", "col", "ff", "c", "unc", "nc"], "sc": ["sv", "cv", "pc", "cl", "isc", "gc", "co", "ser", " Sc", "anc", "sp", "scale", "config", "sac", "ss", "loc", "lc", "asc", "mc", "bc", "dc", "cs", "sec", "SC", "uc", "ec", "cf", "sw", "ct", "scl", "esc", "osc", "arc", " SC", "rc", "soc", "sys", "tc", "Sc", "c", "scope", "sci", "sq", "nc", "set"], "swr_class": ["swr___classes", "swer_group", "swrr_Class", "swer_class", "swr___group", "swrr_class", "swrr_CLASS", "swr__file", "swr__class", "swr__Class", "swr_classes", "swr_Class", "swr_CLASS", "swr___class", "swr_group", "swr__CLASS", "swrr_file", "swer_classes", "swr_file"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090, "substitutes": {"base": ["bas", "pre", "ba", "zero", "basic", "bp", "domain", "master", "server", "bar", "bare", "bf", "range", "scale", "file", "local", "prime", "bg", "valid", "common", "parent", "binding", "based", "beta", "full", "b", "bid", "bit", "ase", "used", "big", "block", "se", "address", "tree", "area", "origin", "alpha", "key", "padding", "space", "m", "all", "chain", "buffer", "format", "name", "active", "status", "Base", "bus", "prefix", "id", "check", "use", "stable", "bs", "shadow", "type", "start", "alias", "pse", "c", "normal", "bu", "bi", "root", "set", "mb"], "aux1_base": ["aux1_back", "aux1_Base", "aux2_Base", "aux2_full", "auxone_back", "aux1__base", "aux1_full", "aux2_bas", "auxone_Base", "auxone_buffer", "aux1___old", "aux2_old", "aux1__Base", "aux1_buffer", "aux1___bas", "aux1___base", "aux1__old", "auxone_base", "aux1_bas", "aux2_name", "aux1__ref", "aux1_name", "aux1___ref", "aux1__full", "aux1_old", "aux1__bas", "aux2_ref", "aux1_ref", "aux1__name"], "aux2_base": ["aux1_Base", "aux2_Base", "aux2_bas", "aux1_buffer", "aux2_bare", "aux1_bas", "aux4_bare", "aux1_bp", "aux2_name", "aux2_bp", "aux4_base", "aux4_bas", "aux2_buffer", "aux4_name"], "irq": ["rqu", "IRqs", "irp", "rq", "IRq", " cirq", "mrqs", "IRQ", "irqs", "irQ", "mrq", "IRqu", "mirQ", "mrp", "irqu", "ibrqs", " cirqu", "ibrQ", " cirQ", "mirq", "ibrq", "rQ", "ibrp", " cirqs", "mrQ", "rqs", "mirp", "mirqs"], "fdc_tc": ["fdec_tc", "fdc8tx", "fdec_t", "fdec_TC", "fdcftc", "fdc_tx", "fdsc_tc", "fdc_t", "fdsc_fc", "fdsc_tx", "fdc_TC", "fdc_tm", "fdc8tc", "fdcftm", "fdcftx", "fdc_fc", "fdc8tm", "fdc8fc", "fdcffc", "fdsc_tm"], "dev": ["Device", "data", "nt", "v", "ve", "gu", "obj", "res", "conn", "dd", "db", "cam", "DEV", "serv", "priv", "mem", "go", "det", "tr", "var", "cmd", "di", "dem", "sh", "DE", "sd", "p", "hw", "pad", "g", "device", "ds", "Dev", "d", "debug", "out", "os", "ev", "ad", "adv", "h", "def", "des", "sys", "de", " device", "conf", "av", "dis", "ver", "w"], "s": ["sv", "v", "bits", "args", "n", "is", "gs", "js", "ms", "ses", "changes", "eps", "sp", "S", "fs", "ties", "ns", "ss", "b", "z", "ts", "se", "spec", "t", "cs", "ats", "space", "sb", "ins", "ims", "p", "comm", "g", "ds", "sym", "d", "ls", "sw", "tests", "os", "es", "sync", "rs", "series", "h", "vs", "l", "sys", "as", "des", "stats", "bs", "als", "sts", "its", "y", "i", "j", "c", "socket", "sq", "ps", "self", "set"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n\n{\n\n    if (!mb_x) {\n\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n\n    } else {\n\n        return mb_y ? mode : HOR_VP8_PRED;\n\n    }\n\n}\n", "idx": 26100, "substitutes": {"mode": ["command", "wise", "md", "me", "none", "only", "power", "scale", "primary", "kind", "tag", "MODE", "mod", "state", "cmd", "nom", "key", "mit", "ode", "mm", "time", "m", "code", "status", "format", "name", "style", "Mode", "option", "role", "error", "size", "position", "use", "module", "type", "transform", "dim", "move"], "mb_x": ["MB_y", "MB_z", "MB_xy", "mb_xy", "mb_z", "emb_m", "MB_x", "mb_m", "emb_x", "emb_y", "emb_X", "mb_X"], "mb_y": ["mb_ty", "bb_x", "tmpableyy", "mb__y", "mb__ny", "md_x", "tmp_x", "bb_y", "mb_ey", "tmp_yy", "bb_yy", "mbablex", "bb_i", "tmp_y", "mb___ty", "md_y", "md_ty", "tmpableny", "mbabley", "tmp_ny", "mbableyy", "mb___y", "mb__x", "mb_ny", "mb___x", "tmpabley", "tmpablex", "mb___ey", "mbableny", "mb_yy", "md_ey", "mb_i", "mb__yy"]}}
{"project": "FFmpeg", "commit_id": "da34e4e13238b755bb0e6ebf549015797d9b4467", "target": 1, "func": "static struct ResampleContext *create(struct ResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear,\n\n        double cutoff, enum AVSampleFormat format, enum SwrFilterType filter_type, double kaiser_beta, double precision, int cheby, int exact_rational){\n\n    soxr_error_t error;\n\n\n\n    soxr_datatype_t type =\n\n        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :\n\n        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :\n\n        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :\n\n        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :\n\n        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :\n\n        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :\n\n        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :\n\n        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;\n\n\n\n    soxr_io_spec_t io_spec = soxr_io_spec(type, type);\n\n\n\n    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);\n\n    q_spec.precision = linear? 0 : precision;\n\n#if !defined SOXR_VERSION /* Deprecated @ March 2013: */\n\n    q_spec.bw_pc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : q_spec.bw_pc;\n\n#else\n\n    q_spec.passband_end = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : q_spec.passband_end;\n\n#endif\n\n\n\n    soxr_delete((soxr_t)c);\n\n    c = (struct ResampleContext *)\n\n        soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);\n\n    if (!c)\n\n        av_log(NULL, AV_LOG_ERROR, \"soxr_create: %s\\n\", error);\n\n    return c;\n\n}\n", "idx": 26110, "substitutes": {"c": ["v", "n", "k", "ctx", "f", "config", "ar", "cb", "b", "lc", "ci", "r", "bc", "t", "cs", "dc", "p", "m", "e", "g", "cc", "d", "ct", "cp", "a", "C", "h", "con", "s", "cur", "l", "tc", "cm", "err", "ch", "w"], "out_rate": ["in_rates", "out_range", "out_rates", "out_frequency", "in_frequency", "in_range"], "in_rate": ["in_rates", "out_range", "out_rates", "out_frequency", "in_frequency", "in_range"], "filter_size": ["sample_scale", "filter_shape", "sample_shape", "filter_scale", "sample_offset", "filter_offset", "sample_size"], "phase_shift": ["pha_size", "pha_shift", "phase_scale", "phase_type", "phasemmscale", "phase_size", "pha_type", "phasemmshift", "phasemmsize", "pha_scale", "phasemmtype"], "linear": ["priority", "central", "standard", "k", "zero", "olar", "loop", "final", "physical", "binary", "scale", "local", "kl", "initial", "lin", "major", "lambda", "margin", "positive", "serial", "random", "len", "alpha", "total", "relative", "time", "line", "rel", "repeat", "flex", "ln", "equal", "model", "location", "l", "ear", "regular", "length"], "cutoff": ["bitoff", "filterover", " cutdown", "cutoffs", "cutdown", "critover", "clipoff", "tipbefore", "cutover", "cropOFF", " cuton", "critoffer", "setoffs", "tipdown", "critOFF", "cutoffer", "setoff", "cutbefore", "critoff", "bitoffset", "breakon", "breakoff", " cutOff", "setoffset", "cropoff", "cutup", " cutOFF", "cleanbefore", "setOff", "tipoffer", "tipoff", "cuton", "butup", "buton", " cutbefore", "cropon", "butOFF", "filteroffer", "clipoffer", "bitoffs", " cutoffs", "clipOFF", " cutup", " cutover", " cutoffer", " cutoffset", "breakOFF", "cleanoff", "cleandown", "cleanoffer", "cutOFF", "clipon", "filterOFF", "bitOff", "butoff", "cropoffer", "breakup", "filteroff", "cutoffset", "cutOff"], "format": ["limit", "init", "data", "and", "settings", "method", "sort", "pre", "length", "domain", "filter", "Format", "only", "scale", "file", "sche", "print", "feature", "f", "valid", "channel", "fix", "after", "policy", "spec", "address", "feat", "category", "path", "act", "t", "interface", "sequence", "cat", "version", "all", "function", "status", "name", "api", "style", "list", "base", "prefix", "mt", "option", "size", "old", "model", "unit", "lat", "l", "use", "force", "pattern", "pretty", "service", "map", "type", "field", "form", "module", "transform", "it", "err", "port", "set"], "filter_type": ["filter_time", "filter_types", " filter_time", " filter_types"], "kaiser_beta": ["kaiser2beta", "kaiser1Beta", "kaiser2alpha", "kaise2alpha", "kaise2Beta", "kaiser1alpha", "kaiser1phi", "kaiser5Beta", "kaiser1beta", "kaise_alpha", "kaiser5phi", "kaise2beta", "kaise2phi", "kaiser5beta", "kaiser_alpha", "kaiser5alpha", "kaise_beta", "kaiser_Beta", "kaiser2phi", "kaiser2Beta", "kaise_Beta", "kaiser_phi", "kaise_phi"], "cheby": [" chebys", "blego", "dieBy", "wheby", "cheBy", "scheby", "cueBY", "cueby", "cheBY", "dieby", "wheBY", "bleBY", "whebys", "chego", "scheBY", "blebys", " cheBY", "cuebys", "scheBy", "bleby", "wheBy", "chebys", "diebys", " chego", "schebys", "dieBY", "cuego"], "exact_rational": ["exactoredquality", "exactoredrational", "exactistsample", "exactistrational", "exactor_quality", "exactedquality", "exactistquality", "exactoredsample", "exactedvalue", "exactor_value", "exact_value", "exactedsample", "exactor_rational", "exactoredvalue", "exact_quality", "exactor_sample", "exactedrational", "exactistvalue", "exact_sample"], "error": ["command", "data", "parse", "ERROR", "errors", "rec", "scale", "channel", "query", "event", "r", "iso", "info", "ror", "e", "code", "function", " Error", "base", "sc", "close", "Error", "extra", "angle", "attribute", "exc", "err"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113, "substitutes": {"opaque": ["obacity", "Opatile", " opque", "obque", "ropen", "ropatile", " opacity", "obaque", " opaques", "pacity", "ipacity", "patile", "ropacity", "opaques", "opacity", "Opacity", "ropaque", "obaques", "opatile", "ipaque", "open", "Open", "ipaques", "pen", "opque", "ipque", "paque", "Opaque"], "buf": ["data", "cv", "bar", "bf", "txt", "mem", "og", "seq", "buff", "cb", "b", "rb", "vec", "cmd", "block", "bytes", "bc", "BU", "bl", "uf", "ref", "doc", "p", "buffer", "tab", "bb", "queue", "bound", "late", "window", "fb", "Buffer", "Buff", "br", "map", "cap", "wb", "batch", "pb", "msg", "raw"], "pos": ["pc", "offset", "oc", "Pos", " offset", "pro", " position", "op", "loc", "pid", "spec", "pres", "origin", "len", "port", "ref", "o", "p", "pt", "off", "pose", "from", "os", "base", "no", " len", "def", "position", "pointer", "num", "conf", "POS", "start", "index", "ptr", "ps", "po", "length"], "size": ["ose", "n", "count", "offset", "small", "notice", "scale", "mode", "shape", "ize", "message", "body", "set", "sum", "sent", "len", "send", "space", " Size", "m", "en", "since", "fee", "needed", "loss", "SIZE", "iz", "type", "start", "gz", "c", "empty", "sn", "Size", "length"], "s": [" self", "sv", "sis", " us", "v", "hs", "is", "iss", "gs", "js", "bis", "ses", "sa", "S", "ns", "store", "ss", "r", "b", "ts", "qs", " os", "se", "cs", "ssl", "less", "ins", "p", "comm", "sl", "ds", "ls", "q", "es", "a", "rs", "ess", "acs", " ss", "as", "h", "als", "bs", "session", "sts", "y", "stats", "ass", "c", "sq", "ps"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n", "idx": 26117, "substitutes": {"type": ["command", "request", "range", "txt", "typ", "file", "link", "lock", "instance", "state", "ico", "time", "p", "status", "ping", "style", "id", "role", "value", "position", "now", "y", "set", "result", "tool", "day", "level", "action", "address", "total", "version", "inter", "pe", "module", "handle", "ver", "all", "length", "_", "create", "tp", "kind", "parent", "shape", "event", "null", "spec", "token", "year", "sequence", "http", "rel", "table", "title", "error", "unit", "try", "index", "temp", "test", "currency", "ty", "Type", "source", "family", "ype", "change", "class", "info", "block", "t", "key", "template", "code", "name", "number", "rule", "TYPE", "types", "scope", "port"], "clock": ["profile", "lock", "instance", "reset", "ctl", "ac", "cker", "time", "contact", "watch", "tz", "craft", "course", "position", "console", "c", "php", "penter", "pc", "work", "chron", "gc", "tool", "tick", "client", "load", "version", "Clock", "forth", "ct", "cp", "check", "cycle", "library", "length", "tp", "count", "chart", "print", "vision", "timeout", "step", "pool", "year", "sequence", "conv", "ock", "shop", "controller", "ck", "sync", "always", "poll", "cl", "frequency", "currency", "loop", "server", "starter", "mint", "job", "config", "ack", "block", "boot", "number", "liv", "list", "cpu", "counter", "soc", "batch", "hello", "ch", "sky"]}}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n", "idx": 26136, "substitutes": {"opts": ["opps", "optws", "iopths", "operth", " opth", " opcs", "operps", "opth", "operts", "opws", "props", "iopws", "iopcs", " opps", "opty", "optts", " opws", "opcs", "iopts", "prots", "optcs", " opty", "operty", "proth", "opths", " opths", "proty", "optths"], "chr": ["cherrer", "ichrs", "cherr", "schR", " Chrt", "chrr", " cher", "chelr", "corrb", " Chrs", "ichrr", "Chrb", "chatrr", "Char", " Chr", " chrar", "echar", "echrt", "cherar", "chers", "chrb", "achrer", "schr", " chrr", "chrar", " chrb", " chsr", "corr", "chatrs", "echrb", "echrs", "CHrb", " chdr", "cherrb", "achrb", "chsr", "Chp", "chrs", "chrer", "ichr", "chatr", "chnr", " chrer", "Chnr", "cher", " chrt", "achry", "corar", "achp", "Chrc", "Chr", "cherry", "chry", "ichsr", "chatsr", " Chrar", "echr", " chnr", "Chdr", "schrb", "achar", "CHrc", "cordr", "acher", "chp", "ChR", "chlr", "chrt", " chp", "Cher", "achdr", "chert", "chrc", "echlr", " chlr", "chdr", "CHr", "schrc", "echdr", "CHR", "chernr", "chR", " chry", " chrs", "achr"], "s": ["sv", "n", "is", "hs", "gs", "js", "ses", "fs", "S", "ns", "ss", "b", "r", "ts", "qs", "spec", "t", "cs", "ssl", "save", "less", "ats", "sb", "o", "p", "g", "ds", "ls", "q", "os", "a", "es", "css", "rs", "h", "sys", "ys", "stats", "sts", "bs", "session", "its", "als", "i", "c", "socket", "sq", "ps", "self", "set", "w"], "tty": ["println", "TY", "ty", "txt", "tt", "tf", "quiet", "tx", "reader", "pipe", "kt", "null", "token", "username", "writer", "ctor", "t", "ctl", "vt", "key", "private", "filename", "shell", "pty", "password", "slave", "tab", "pt", "table", "title", "trust", " ty", "prefix", "sudo", "phrase", " t", "echo", "thread", "input", "tmp", "console", "tc", "type", "readable", "ptr", "tiny", "temp", "test", "term", "interface", "sett"], "master_fd": ["master_id", "slave_FD", "male_fc", "slave_win", "proxy_dev", "male_sd", "master____ld", "master_pid", "proxyingdev", " slave_dn", "master_sd", " slave_ld", " slave64ctx", " slave_ctx", "master____fd", "master_fp", "proxyingfd", "master_fa", "proxy_fd", "master64ctx", "proxyingds", "slave_id", "master64pipe", "master_pipe", "master_fi", "slave_fi", "master_dir", "master_FD", "master64df", "master64fd", "masteringfd", "slave_fp", "slave_dir", "master_df", "masteringpid", "master_ld", "master_fin", "proxy_pid", "master_win", "slave_lf", "proxy_ds", "master____dn", " slave64fd", "master_ds", "male_fa", "slave_pid", "masteringds", "master_fc", "male_fd", "masteringdev", "master_ctx", " slave64pipe", " slave_df", " slave64df", "proxyingpid", "master_dn", " slave_pipe", " slave_fin", "master_dev", "master____fin", "master_lf"], "slave_fd": ["slave_FD", "master_pid", "master_fp", " slave_dir", " slave_pid", "pty_dir", "pty_fc", "pty_fd", "master_dir", "slave_fp", "slave_port", "slave_dir", " slave_FD", "pty_FD", "slave_fc", " slave_ds", "master_ds", "slave_pid", "slave_ds", "master_port", " slave_fc"], "len": ["nt", "n", "cl", "nl", "cmp", "count", "fin", "li", "lp", "fil", "L", "ll", "kl", "pl", "mem", "lim", "seq", "elt", "z", "vec", "mil", "bytes", "lf", "lan", "bl", "el", "lon", "ref", "coll", "compl", "all", "str", "fl", "en", "sl", "Len", "ls", "Length", "list", "size", "ln", "enc", "ld", "wid", "l", "resp", "gz", "pos", "le", "err", "dl", "length"], "pty_name": ["pt_n", "pty_nam", "pty_len", "pty_NAME", "pipe_names", "pipe_no", "pipe_NAME", "pty_no", "pty_names", "pt_nam", "slave_path", "pty_n", "pty_Name", "slave_Name", "pt_name", "slave_names", "pipe_name", "slave_no", "pty_path", "pt_names", "slave_len", "slave_name"]}}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "substitutes": {"env": ["init", "er", "v", "ve", "obj", "vp", "enter", "conn", "server", "txt", "sp", "ext", "EN", "viron", "config", "esp", "context", "mem", "vm", "store", "manager", "state", "cmd", "info", "t", "stack", "w", "ec", "sb", "erd", "forge", "e", "code", "doc", "eng", "en", "environment", "dev", "ah", "ew", "te", "window", "ev", "esc", "engine", "worker", "stage", "h", "conf", "desc", "buf", "proc", "et", "entry", "cfg", "ctx"], "order_code": ["orderopcode", "order_no", "order_cmd", "Order_Code", "orderercode", " order_cmd", "orderNamecc", "Order_cc", "order_Code", "orderopcod", "orderername", "order_cc", "orderopCode", "orderNameCode", "orderNameno", "order_type", " order_name", "order_data", "orderertype", " order_data", "Order_cod", "ordererdata", "order_name", " order_Code", " order_type", "order_cod", "Order_no", "Order_code", "orderNamecode"], "r1": ["c2", "r6", "r2", "rank3", " r2", " r61", " rFirst", "rar2", "R0", "p1", "c1", "p6", "r3", "rank2", " r6", "c0", "r0", "rar1", "R1", "p0", " r0", "rank1", "trFirst", "rar61", "tr61", "rank0", "R6", "tr2", "tr1", "r61", "rarFirst", "rFirst", "p2", " r3", "c3", "R2"], "cpu_addr": ["gpu_address", "cpumyadd", "cpu__add", "cpumyaddr", "pu_src", "cpu_add", "cpu__addr", "cpu_ref", "cpu_src", "cpu_ptr", "pu_addr", "cpu_address", "cpu_conn", "gpu_ptr", "cpumyconn", "pu_ref", "gpu_addr", "gpu_add", "pu_add", "pu_conn", "cpu__conn"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb_1_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                     const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                     const uint16_t *abuf0, uint8_t *dest, int dstW,\n\n                     int uvalpha, enum PixelFormat dstFormat,\n\n                     int flags, int y, enum PixelFormat target,\n\n                     int hasAlpha)\n\n{\n\n    int i;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 = buf0[i * 2]     >> 7;\n\n            int Y2 = buf0[i * 2 + 1] >> 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    }\n\n}\n", "idx": 26154, "substitutes": {"i": ["qi", " I", "any", "ix", "xi", "ami", "ii", "oi", "origin", "ip", "ei", "p", "e", "status", "ori", "id", "depth", "io", "series", "zi", "c", "y", "bi", "ind", "I", "to", "n", "iter", "json", "load", "ci", "complete", "di", "iii", "pi", "iu", " ti", "phi", "init", " j", "is", "me", "ij", "print", "parent", "ini", "gi", "this", " bi", "cli", "ic", "sim", "m", "multi", "ri", "copy", "remote", " ii", "\u0438", "im", "dr", "l", "ski", "wait", "j", "index", "ia", "si", "v", "iri", "gu", "in", "slice", "li", "ai", "go", "ji", "item", "ki", "info", "t", "mi", "key", "ims", "name", "q", "list", "uri", "point", "err", "ti", "batch", "x", "it", "ui"], "A1": ["ATA01", "ATAone", " A7", "E1", " Aone", "E2", "HA7", "AM3", "CA3", "HAone", "AMOne", "ATOne", "G7", "Eone", "AM1", "AUOne", "CAOne", "HA1", "HA3", "ATA1", "ATAOne", "AT01", "G3", "AOne", "A3", "CA2", "GOne", "AU01", "HA2", "ATone", "AT1", "AM2", "HAOne", "A01", "CA1", " A3", "Aone", "EOne", "A7", " AOne", "AUone", "AU1", "G1"], "A2": ["LATwo", "A4", " A02", "ARtwo", " A4", "PTwo", "A02", " ATwo", "AR02", "Array2", "a2", "P05", "P2", "LA2", "GA2", "P4", "PAtwo", "HAtwo", "ArrayTwo", "a1", "a02", "PATwo", "GA02", "ATwo", "PA2", "aTwo", "GATwo", "ARTwo", "Atwo", "PA02", "LA4", " A05", "AR2", "HA2", "Array4", "GA1", "HA4", "A05", "HA02", "Array05", "HATwo"], "r": ["ren", "er", "v", "n", "k", "sr", "R", "rt", "f", "tr", "rb", "var", "usr", "t", "rg", "o", "p", "rx", "e", "m", "d", "rar", "u", "q", "mr", "a", "rs", "h", "rc", "dr", "l", "s", "br", "c", "x", "y", "ro", "vr", "w"], "g": ["er", "v", "gu", "n", "k", "gc", "gr", "bg", "f", "group", "gd", "go", "gp", "gy", "gb", "rg", "ge", "G", "m", "p", "e", "gt", "d", "u", "q", "a", "fg", "h", "dr", "l", "mg", "gg", "j", "c", "x", "y", "w"], "b": ["B", "v", "n", "ba", "bis", "db", "bg", "f", "ob", "rb", "z", "eb", "bc", "gb", "t", "bl", "lib", "o", "p", "e", "bb", "d", "be", "u", "bd", "a", "nb", "base", "ib", "h", "l", "br", "bs", "j", "c", "y", "bi", "w"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26158, "substitutes": {"s": ["sv", "v", "ex", "n", "is", "hs", "gs", "js", "sa", "ses", "S", "ns", "store", "ss", "r", "b", "z", "ts", "qs", "se", "spec", "ops", "t", "cs", "south", "less", "sh", "ats", "sb", "p", "e", "comm", "m", "g", "ds", "aws", "ls", "sw", "os", "a", "so", "es", "syn", "sync", "rs", "sc", "h", "st", "sys", "conf", "stats", "sts", "bs", "its", "sports", "c", "stat", "sq", "ps", "self", "set"], "sec": ["pri", "security", "n", "rec", "sr", "fin", "exec", "ser", "th", "next", "SEC", "seq", "td", "seconds", "ss", "loc", "reg", "se", "pas", "bc", "second", "secondary", "sect", "ec", "secure", "deg", "sd", "time", "str", "cc", "isec", "ct", "Sec", "esc", "syn", "sur", "section", "sc", "con", "rc", "st", "cur", "sys", "ctr", "sector", "tc", "sch", "desc", "j", "c", "stat", "proc", "ptr", "sq", "sn", "enc", "ctx"], "secn": ["Secd", "securitysn", "sectnan", "sectN", "sectn", "seqd", "condno", "priN", " secd", "procN", "seqno", "sectlen", "seqN", "rcsn", "securityN", "procnan", "securitymn", "prin", "seqnan", "prins", "securityns", "pricn", "rcN", " secns", "condmn", "Secsn", "rcn", "ecn", "seclen", "Secn", "securityno", "condN", "seqn", "seqmn", "rcns", "secnan", "condn", "secd", "descns", "securityn", "secno", "seqsn", "ecN", "seqns", "ecsn", "descN", "eccn", " seccn", "seqlen", "secN", "secsn", "secns", "ecns", "descsn", " secN", "procn", "proclen", "seccn", "secmn", "SecN", "descn", "Secns"], "src": ["dest", "ur", "sr", "ser", "th", "txt", "source", "inst", "tn", "loc", "r", "usr", "attr", "iv", "inf", "sh", "sb", "scan", "sub", "sup", "stream", "sur", "rs", "sc", "cur", "img", "rc", "st", "ctr", "sys", "tmp", "bs", "start", "proc", "ptr", "sn", " dst"], "sp": ["sv", "ap", "tp", "Sp", " esp", "bp", "lp", " Sp", "serv", "jp", "esp", "isp", "osp", "pp", "se", "ip", "SP", "mp", "sk", "sh", "space", "p", "sl", "prov", "sw", "ipp", "snap", "sc", "spl", "spe", "bsp", "span", "sch", "ep", "si", "ps", "sm"], "dp": ["broad", "drop", "df", "dm", "vp", "pc", "tp", "deb", "dep", "result", "adr", "db", "dd", "wp", "dk", "lp", "jp", "cd", "pend", "aaa", "wd", "delay", "pipe", "dq", "pp", "di", "pkg", "gp", "dt", "pas", "grad", "dc", "ip", "coord", "du", "DC", "mp", "p", "fd", "dat", "buffer", "ds", "pd", "dh", "d", "DP", "cp", "fp", "dr", "lat", "np", "xy", "pb", "buf", "ptr", "dim", "ps", "dl", "csv"], "i": ["qi", "ex", "gu", "asi", "is", "iq", "in", "ind", "li", " ni", "ij", "print", "ix", "xi", "ai", "ami", "ini", "gi", "ci", "info", "di", "ie", "ii", "oi", "mi", "ip", "mac", "ei", "cli", "ic", "sim", "p", "multi", "m", "ri", "ni", "spin", " ii", "pi", "\u0438", "ice", "size", "uri", "iu", "fi", " ti", "ti", "zi", "j", "index", "phi", "x", "dim", "y", "it", "si", "bi", "ui", "I"]}}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)\n\n{\n\n    uint64_t magic;\n\n    uint32_t opt;\n\n    uint32_t type;\n\n    uint32_t len;\n\n    uint32_t namelen;\n\n    int error;\n\n\n\n    *name = NULL;\n\n    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        error_setg(errp, \"failed to read list option magic\");\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    if (magic != NBD_REP_MAGIC) {\n\n        error_setg(errp, \"Unexpected option list magic\");\n\n        return -1;\n\n    }\n\n    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n\n        error_setg(errp, \"failed to read list option\");\n\n        return -1;\n\n    }\n\n    opt = be32_to_cpu(opt);\n\n    if (opt != NBD_OPT_LIST) {\n\n        error_setg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\",\n\n                   opt, NBD_OPT_LIST);\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {\n\n        error_setg(errp, \"failed to read list option type\");\n\n        return -1;\n\n    }\n\n    type = be32_to_cpu(type);\n\n    error = nbd_handle_reply_err(ioc, opt, type, errp);\n\n    if (error <= 0) {\n\n        return error;\n\n    }\n\n\n\n    if (read_sync(ioc, &len, sizeof(len)) != sizeof(len)) {\n\n        error_setg(errp, \"failed to read option length\");\n\n        return -1;\n\n    }\n\n    len = be32_to_cpu(len);\n\n\n\n    if (type == NBD_REP_ACK) {\n\n        if (len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n", "idx": 26160, "substitutes": {"ioc": ["iocom", " ioco", "piocom", "inocal", "oosc", "ciocal", "iniocol", " iosc", "tioc", "oocon", "cioco", "tioci", "nocon", "piOC", "inosc", "iect", "iocol", "tiocol", "iocy", "inoc", "inioc", "tiocy", "ioco", "pioc", "tioco", "pioco", "piect", "lioc", "liect", "noc", "piocon", "iocr", "ioci", "iniod", "liocr", "iosc", "iocal", "liosc", "pioci", "cioc", " iect", "piot", "liod", " iocon", "liocol", "oocom", "ciosc", "piocy", "iOC", "ooc", "iod", "lioci", "piosc", "piod", "not", "tiect", "tiosc", "oOC", " iocom", "ciocr", "oect", "liocal", "inocr", "ooco", "piocol", "ciocy", "nOC", "iniect", "iocon", " iOC", "iot", " iot"], "name": ["data", "n", "channel", "family", "mem", "NAME", "var", "cmd", "names", "path", "new", "comment", "key", "ref", "version", "p", "code", "buffer", "str", "out", "call", "id", "prefix", "part", "no", "base", "nam", "word", "ame", "alias", "c", "msg", "Name", "order", "w"], "errp": [" errr", "rrcp", "erm", "rerP", "eorpa", "aerp", "sprping", "nersp", " errpos", " errP", "sprpos", "errping", "rerpa", "errorcp", "errpc", "errorm", "rerp", "errorpa", "errps", " errv", "errg", "erd", "errpos", "rerpt", "errpt", "rrpat", "errr", "nerpatch", "rerpp", "arrpt", " errwp", "privp", "errpp", "diep", "errorv", "eorP", " errping", "errpat", "privnp", "errpatch", "aerr", "ercp", "rerpc", "diepc", "privpp", "rerps", "nerpc", " errpa", "erP", "eorp", "rersp", "eorpp", "rrP", "rrm", "arrg", " errps", "errd", "diesp", "diepatch", "erpp", "errorP", "resultcp", "privP", "erp", "errm", "sprp", "errorp", " errm", "arrp", "resultp", "errP", "errorpos", "erpat", "errorping", "rerg", "rerpatch", "errsp", "nerp", "sprP", "errwp", "rrv", "errv", "ernp", "aerwp", "eorg", "eorpt", "errnp", "errcp", "erwp", "rercp", "resultd", "eornp", "resultpat", "errorpp", "rrp", "errpa", "rrd", "arrpa", "errorps", "err"], "magic": ["cookie", "method", "zero", "generic", "ix", "tech", "cmd", "pkg", "auth", "options", "MAG", "hash", "header", "style", "id", "vol", "conf", "encrypted", "stat", "inv", "bug", "phys", "op", "policy", "iso", "meta", "version", "tab", "virt", "prefix", "part", "eric", "module", "mag", "init", "iq", "mid", "psy", "usage", "notice", "mode", "power", "volume", "kind", "tag", "xxx", "photo", "spec", "serial", "comment", "zone", "phot", "ic", "pic", "flag", "try", "icon", "Magic", "xx", "md", "seq", "info", "area", "mac", "metadata", "code", "format", "phone", "jar", "mist", "alias", "agic", "hello"], "opt": ["obj", "max", "util", "typ", "val", "net", "tx", "optim", "bit", "oss", "cmd", "options", "p", "expr", "off", "window", "id", "vert", "alt", "stat", "opted", "tip", "oop", "iter", "offset", "mot", "op", "ts", "usr", "feat", "cat", "num", "trial", "open", "order", "prop", "ver", "init", "psy", "ot", "mode", "rt", "timeout", "tag", "attr", "hop", "ox", "rot", "out", "Opt", "OP", "option", "fit", "lt", "xy", "pos", "temp", "alloc", "cmp", "ext", "serv", "mem", "slot", "info", "nom", "bin", "other", "pt", "pot", "cho", "format", "org", "list", "no", "size", "eff", "err"], "type": ["command", "sort", " kind", "file", "typ", "box", "dt", "what", "options", "where", "time", "p", "ping", "style", "id", "role", "color", "form", "set", "er", " Type", "to", "ped", "tool", "action", "op", "var", "um", "cat", "call", "check", "like", "part", "pe", "field", "start", "font", "ver", "all", "tp", "pre", "rt", "kind", "tag", "event", "spec", "rel", "mt", " ty", "try", " TYPE", "icon", " typ", "temp", "test", "cl", "ty", "Type", "family", "ype", "ack", "class", "block", "ror", "t", "other", "code", "pt", "no", "size", "rule", "TYPE", "types", "word", "err"], "len": ["nt", "gen", "data", "il", "n", "nl", "fin", "iter", "ind", "els", "del", "lp", "li", "L", "val", "ll", "kl", "mem", "lim", "seq", "hl", "lin", "loc", "mn", "elt", "vec", "lang", "bytes", "lf", "lan", "t", "lib", "lic", "el", "lon", "coll", "fl", "en", "sl", "ml", "Len", "ls", "late", "syn", "lt", "size", "ln", "enc", "ld", "wid", "l", "lex", "resp", "num", "label", "pos", "ell", "le", "msg", "tl", "err", "dl", "length", "lit"], "namelen": ["basellon", " Namelem", "namelon", "namearen", "namelize", "basellower", "namellens", "namELem", "scrib_", "namellower", "namelower", " Namelsize", "basellax", "namELens", "namELize", " Namelsem", "sequlen", "scriblen", "namellize", "namearax", "sanlen", "sequ_", "baselax", "namellon", " Namelens", "namellen", "namelsax", "baselower", "namelsower", "baselon", "namelens", " Namelsen", "namlen", "namellem", "nam_", "namELen", "namelsize", "namearon", "namelson", "namelsens", "baselen", " Namelsens", "namelem", "namelax", "namellax", "namearower", "namelsen", " Namelize", "san_", " Namelen", "namelsem", "basellen"], "error": ["command", "er", "ERROR", "errors", "bug", "result", "offset", "none", "feature", "end", "valid", "event", "or", "message", "ack", "r", "iso", "state", "complete", "info", "serial", "ror", "comment", "panic", "total", "coord", "relation", "danger", "draw", " ERROR", "e", "code", "status", "pad", "debug", " Error", "style", "rank", "fee", "loss", "option", "no", "size", "rc", "progress", "row", "start", "Error", "ion", "order", "success", "empty", "ro", "err", "length"]}}
{"project": "FFmpeg", "commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "target": 1, "func": "static int hwupload_query_formats(AVFilterContext *avctx)\n\n{\n\n    HWUploadContext *ctx = avctx->priv;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n\n    AVFilterFormats *input_formats = NULL;\n\n    int err, i;\n\n\n\n    if (!avctx->hw_device_ctx) {\n\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n\n               \"to upload frames to.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n\n    if (!ctx->hwdevice_ref)\n\n        return AVERROR(ENOMEM);\n\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n\n    if (!constraints) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n\n    output_pix_fmts = constraints->valid_hw_formats;\n\n\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n\n    if (!input_formats) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (input_pix_fmts) {\n\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n\n            if (err < 0) {\n\n                ff_formats_unref(&input_formats);\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n\n                   &avctx->outputs[0]->in_formats);\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&ctx->hwdevice_ref);\n\n    av_hwframe_constraints_free(&constraints);\n\n    return err;\n\n}\n", "idx": 26173, "substitutes": {"avctx": ["averca", "aveca", "avercontext", "AVtx", "aftx", "averctx", "afsys", "avehandle", "avcontext", "avecv", "AVcmp", "avecmp", " avtx", "afjp", "afctx", "AVctx", "AVcontext", "avca", "avjp", "avcv", " avcv", "avhandle", "aversys", "avesys", "afcrit", "avercrit", "wavca", "avercv", "avetx", "avecp", "wavcv", "aveobj", "afcmp", "avemsg", "averobj", "afhandle", "avercmp", "avobj", "avecontext", "avejp", " avmsg", "avercp", "avsys", "avmsg", "averjp", "avcrit", "avecrit", " avcp", "wavtx", "averhandle", "avcp", " avcontext", "avertx", "avcmp", " avobj", "avtx", " avcmp", "afcontext", "avectx", "avermsg", "wavctx"], "ctx": ["nt", "aus", "ca", "obj", "cv", "cmp", "cl", "conn", "gc", "co", "txt", "jp", "xp", "rt", "config", "kl", "context", "timeout", "wx", "tx", "cb", "loc", "lc", "mk", "alloc", "nc", "kt", "cmd", "pkg", "xc", "func", "pg", "bc", "act", "cu", "ctl", "ac", "req", "tm", "unc", "p", "hw", "comm", "cc", "cf", "jac", "ct", "cp", "ck", "prefix", "ka", "sc", "rc", "etc", "ctr", "np", "Conn", "tc", "today", "cm", "x", "proc", "utils", "CT", "ctrl", "kw", "abc", "cfg"], "constraints": ["constantacts", "concomplfree", "construres", "concontaints", "constrfree", "constracts", "contrains", "contraint", "aconstantaints", "constrats", "concontubs", "conjains", "constsacts", "constaints", "aconstrinters", "costrents", "comtaints", "constantaints", "Constraint", "constains", "constubs", "cospents", "constents", "conspitions", "constr_", "conjents", "convertaints", "Constubs", "comstraint", "cospitions", "costrats", "const_", " constraint", "comstrencies", "constsaints", "confst_", "constaint", "constsfree", "consts_", "concontains", " conjents", "comtencies", "Constaint", "contencies", "concompl_", "convertats", "constrains", "conbritions", " conjaint", "conspats", "comstrains", "constrinters", "containt", "constritions", "confstr_", "aconstrures", "conspents", "constfree", "cospats", "convertents", "aconstantinters", "contains", "constrencies", "convertitions", " conjains", "costraints", "contrubs", "conjaints", " constrains", "conformures", "Constrains", "containts", " constrents", "Constraints", "costritions", "contraints", " conjaints", "Constaints", "aconstantures", "confstrfree", "comtaint", "aconstraints", "conformacts", "aconstantacts", "cospaints", "conbrents", "constantinters", "aconstracts", "conspaints", "conbrats", "constsures", "contrents", "comstraints", "conformaints", "concontaint", "conjaint", "Construbs", "Constains", "contrencies", "constencies", "constsinters", "constrents", "conbraints", "construbs", "confstfree", "constantures", "comtains", "conforminters", "constraint"], "input_pix_fmts": ["input_pix_formts", "input_pix__famcs", "input_pix_flems", "input_pix_famters", "input_pix__fmats", "input_pix_mcs", "input_pix_mts", "input_pix_famts", "input_pix_fleats", "input_pix_mats", "input_pix_cmts", "input_pix_flets", "input_pix__fmcs", "input_pix_formats", "input_pix_formls", "input_pix_famodes", "input_pix_fmats", "input_pix_rmodes", "input_pix_mters", "input_pix_rmcs", "input_pix__famts", "input_pix_rmats", "input_pix_fncs", "input_pix_fmters", "input_pix_fnms", "input_pix_cmats", "input_pix_formodes", "input_pix__famats", "input_pix_famats", "input_pix_fmcs", "input_pix_fmls", "input_pix_rmls", "input_pix_cmms", "input_pix_cmcs", "input_pix_famls", "input_pix_fnts", "input_pix_fmms", "input_pix__fmters", "input_pix_fnats", "input_pix__fmts", "input_pix_fmodes", "input_pix_famcs", "input_pix__famters", "input_pix_flecs", "input_pix_fleters", "input_pix_cmters", "input_pix_rmts", "input_pix_fnters", "input_pix_rmters"], "output_pix_fmts": ["output_pix_fmters", "output_pix_formms", "output_pix_fxters", "output_pix_rmars", "output_pix_formars", "output_pix_fmms", "output_pix_fnters", "output_pix_cmats", "output_pix_famts", "output_pix_fmats", "output_pix_cmts", "output_pix_rmcs", "output_pix_fxts", "output_pix_rmats", "output_pix_fmcs", "output_pix_mters", "output_pix_rmters", "output_pix_rmts", "output_pix_cmters", "output_pix_mcs", "output_pix_famters", "output_pix_fncs", "output_pix_fxcs", "output_pix_mars", "output_pix_cmcs", "output_pix_mms", "output_pix_formts", "output_pix_famats", "output_pix_fnts", "output_pix_mats", "output_pix_fxats", "output_pix_rmms", "output_pix_fmars", "output_pix_famcs", "output_pix_fnats", "output_pix_mts"], "input_formats": ["input_handats", "input_formates", "input_streamels", "input_formations", "input_formatates", "input_formsations", "input_formuts", "input_streamats", "input_formels", "input_formsates", "input_facts", "input_parentorts", "input_formsats", "input_parentits", "input_forits", "input_factats", "input_famts", "input_formatations", "input_spets", "input_factels", "input_formsims", "input_transformuts", "input_famlations", "input_formsums", "input_forATS", "input_fmlations", "input_formsatted", "input_formatted", "input_regits", "input_compits", "input_handATS", "input_transformorts", "input_formslations", "input_famatted", "input_compATS", "input_handims", "input_formsulas", "input_formorts", "input_handts", "input_transformits", "input_formts", "input_speats", "input_formsels", "input_factates", "input_streamates", "input_compats", "input_regorts", "input_formims", "input_formulas", "input_formsATS", "input_formsts", "input_fmatted", "input_formATS", "input_facats", "input_factums", "input_famats", "input_parentuts", "input_fmts", "input_formums", "input_speations", "input_facATS", "input_compulas", "input_regats", "input_formatats", "input_speates", "input_formsits", "input_reguts", "input_forats", "input_formatts", "input_transformats", "input_fmats", "input_forulas", "input_facims", "input_formlations", "input_streamums", "input_formits", "input_parentats"], "err": ["rev", "er", "nr", "obj", "errors", "res", "oe", "fr", "iter", "die", "gr", "notice", "txt", "rr", "yr", "peer", "aaa", "or", "warn", "cr", "r", "rb", "elt", "norm", "ner", "cmd", "attr", "usr", "t", "inner", "der", "arr", "req", "cli", "e", "str", "eas", "ach", "rel", "Er", "rar", "fee", "mr", "ev", "lr", "error", "trace", "later", "score", "try", "resp", "conf", "ctr", "br", "drm", "gz", "buf", "Error", "c", "pr", "order", "msg", "it", "test", "kr", "cfg"], "i": ["qi", "init", "ir", "v", "ma", "n", "asi", "yi", "me", "iter", "li", "ix", "xi", "ai", "mu", "ami", "ji", "ini", "r", "gi", "ci", "ki", "di", "hi", "ii", "mi", "ip", "ei", "cli", "ims", "sim", "m", "p", "multi", "ic", "g", "ui", "pi", "id", "\u0438", "iu", "s", "us", "ti", "phi", "j", "index", "c", "zi", "batch", "y", "it", "si", "bi", "ind", "x", "I"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n", "idx": 26175, "substitutes": {"errp": ["dier", " errping", " erp", "thinkP", " errr", "dieP", "errpar", " err", "errorr", "rrping", "ferpa", "erping", "diepar", "thinkpa", " errP", "errorP", "errping", "errorcp", " errcp", " erpar", "errcp", "errorpa", "rrpa", "attrping", "erp", "diepa", "ferpar", "attrcp", " errpa", "erP", "errorp", "thinkp", "ferP", "attrP", "errP", "errr", "attrp", "rrp", "errpa", "errorping", "ferp", " errpar", "thinkpar", "rrP", "erpa", "diep", " erpa"], "win32_err": ["win64_error", "win64_buf", "win64_err", "win32__er", "win32__error", "win32_buf", "win64_msg", "win32_er", "win32__err", "win32_rr", "win32_error", "win32_dist", "win32_msg"], "fmt": ["Fmt", " ftt", "facformat", "xflt", " fMT", "Ftxt", "xftxt", "ftt", "facmt", "forprintf", "Flt", "frmt", "forformat", "frfm", "fMT", " fformat", "factt", "formt", "Fprintf", "ffm", "xfmt", "forMT", " ffm", "xfformat", "ftxt", "frformat", "Fformat", "fformat", "flt", "FMT", "frtt", " flt", "facfm", " ftxt"], "ap": ["ax", "aj", "tap", "vp", "tp", " mp", " pat", "rap", "pa", "apt", "sp", "sam", " sa", "arp", "ar", "op", " sp", " pad", " tap", " pc", " map", " op", "pp", "um", "at", "html", "ip", " ip", " ac", "al", "ac", "mp", "p", " sc", "pad", "api", " p", "apa", " rep", "ipp", "ab", "app", "snap", "up", "att", "ape", "aps", " sap", " av", " app", "av", "map", "cap", "amp", " cap", "AP", " sv", " cp"], "msg1": ["reason001", "msg51", " msg30", "imm51", " msgOne", " msgp", "msgOne", "Msg2", "lem30", "Msg0", " msg001", "cmd3", "msg3", "msg30", "reason1", "reason2", "msg0", "goodp", " msg3", "lem2", "Msg1", "Msg30", "imm1", "lem1", "good1", "MsgOne", "reasonp", "imm3", " msg51", "Msg3", "imm2", "msg001", "good2", "good001", "Msg51", "lemOne", " msg0", "cmd0", "msgp", "cmd1", "cmd2"], "msg2": ["msg82", "ogTwo", "og82", "gent2", "msg02", " msgTwo", "gem82", "gtwo", "gent1", "Msg2", " msgB", "ogB", "msg3", "msgtwo", "msgTwo", "message2", "g1", " msg02", "Msgtwo", " msg3", " msg82", "Msg1", "gemTwo", "gem2", "gent02", "Msg02", "message1", "g2", "Msg3", "msgB", "message3", " msgtwo", "og2", "g3", "gemB"]}}
{"project": "FFmpeg", "commit_id": "0114c571d4c8cc1036850ced924683709390681a", "target": 1, "func": "void ff_MPV_frame_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n   } else if((s->error_count || s->encoding || !(s->avctx->codec->capabilities&CODEC_CAP_DRAW_HORIZ_BAND)) &&\n\n              !s->avctx->hwaccel &&\n\n              !(s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) &&\n\n              s->unrestricted_mv &&\n\n              s->current_picture.f.reference &&\n\n              !s->intra_only &&\n\n              !(s->flags & CODEC_FLAG_EMU_EDGE)) {\n\n        int hshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_w;\n\n        int vshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_h;\n\n        s->dsp.draw_edges(s->current_picture.f.data[0], s->current_picture.f.linesize[0],\n\n                          s->h_edge_pos, s->v_edge_pos,\n\n                          EDGE_WIDTH, EDGE_WIDTH,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[1], s->current_picture.f.linesize[1],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[2], s->current_picture.f.linesize[2],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n    }\n\n\n\n    emms_c();\n\n\n\n    s->last_pict_type                 = s->pict_type;\n\n    s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f.quality;\n\n    if (s->pict_type!= AV_PICTURE_TYPE_B) {\n\n        s->last_non_b_pict_type = s->pict_type;\n\n    }\n\n#if 0\n\n    /* copy back current_picture variables */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (s->picture[i].f.data[0] == s->current_picture.f.data[0]) {\n\n            s->picture[i] = s->current_picture;\n\n            break;\n\n        }\n\n    }\n\n    assert(i < MAX_PICTURE_COUNT);\n\n#endif\n\n\n\n    if (s->encoding) {\n\n        /* release non-reference frames */\n\n        for (i = 0; i < s->picture_count; i++) {\n\n            if (s->picture[i].f.data[0] && !s->picture[i].f.reference\n\n                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {\n\n                free_frame_buffer(s, &s->picture[i]);\n\n            }\n\n        }\n\n    }\n\n    // clear copies, to avoid confusion\n\n#if 0\n\n    memset(&s->last_picture,    0, sizeof(Picture));\n\n    memset(&s->next_picture,    0, sizeof(Picture));\n\n    memset(&s->current_picture, 0, sizeof(Picture));\n\n#endif\n\n    s->avctx->coded_frame = &s->current_picture_ptr->f;\n\n\n\n    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);\n\n    }\n\n}\n", "idx": 26183, "substitutes": {"s": ["sv", "ans", "gs", "ms", "ses", "changes", "services", "details", "b", "parts", "ops", "comments", "styles", "bes", "p", "aws", "ls", "ains", "ges", "rs", "sc", "sets", "as", "us", "als", "sports", "c", "y", "ags", "ps", "csv", "w", "n", "ers", "erences", "fs", "ties", "ns", "ants", "states", "ts", "has", "se", "less", "ins", "es", "a", "os", "ies", "events", "vs", "stats", "sts", "args", "ports", "hs", "is", "ss", "cs", "ats", "m", "comm", "ds", "tes", "ids", "sys", "j", "sq", "eds", "js", "S", "qs", "t", "gets", "ims", "g", "tests", "sw", "ess", "h", "bs", "its", "aunts"], "i": ["v", " j", "is", " c", "b", "ci", "ii", "t", "ati", "mi", " bi", " m", "o", "m", "p", " ii", "pi", " v", "l", " pi", " ti", "ti", "j", "c", "it", "si", "bi", "I"]}}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191, "substitutes": {"f": ["flow", "df", "v", "util", "fr", "exec", "bf", "fs", "file", "fo", "print", "sf", "tf", "full", "b", "r", "F", "fc", "info", "xf", "um", "fw", "lf", "t", "fac", "uf", "inf", "rf", "fm", "ref", "ac", "o", "fd", "p", "e", "m", "fl", "fx", "g", "cf", "d", "ct", "fee", "q", "ef", "fb", "part", "fal", "af", "fp", "fg", "h", "conf", "fe", "fi", "fab", "form", "i", "ff", "c", "x", "of", "self", "w"], "buf": ["init", "data", "dest", "v", "cv", "obj", "cache", "result", "iter", "bar", "ctx", "bf", "txt", "end", "mem", "mu", "tr", "seq", "buff", "cb", "b", "rb", "vec", "var", "mb", "loc", "cmd", "block", "pkg", "bc", "bl", "arr", "uf", "w", "bin", "ref", "p", "str", "buffer", "off", "queue", "fb", "Buffer", "h", "cur", "img", "Buff", "br", "map", "tmp", "addr", "cap", "batch", "pb", "ptr", "msg", "orig", "pos", "err", "length", "raw"], "size1": ["position1", " sizeone", "style001", "styleone", "SIZEOne", " sizeOne", "style1", "SIZE0", "positionone", "size2", "sizeOne", "type2", "ize01", "size0", "size001", "offset2", " size01", "offset01", "SIZE1", "style0", "ize2", "position0", "type1", "sizeone", " size0", " size2", "SIZE2", "type0", "typeOne", "size01", "offset1", "ize1", "position001", " size001"], "size": ["max", "gs", "zero", "any", "message", "ce", "len", "al", "e", "status", "style", "id", "s", "capacity", "now", "type", "i", "c", "le", "set", "w", "ose", "il", "n", "offset", "small", "body", "sent", "south", "total", "send", "sized", "st", "all", "length", "is", "count", "notice", "scale", "shape", "z", "sum", "space", "m", "empty", "sn", "si", "v", "sp", "ize", "t", "shift", "code", "g", "name", "since", "number", "no", "SIZE", "iz", "h", "storage", "height", "scope", "x", "Size", "negative"], "l": ["limit", "er", "v", "la", "il", "n", "nl", "loop", "li", "ly", "lp", "lay", "L", "lb", "ll", "kl", "pl", "rl", "hl", "lin", "loc", "lc", "b", "z", "lv", "lf", "len", "al", "lib", "el", "shell", "o", "m", "all", "p", "fl", "g", "sl", "ls", "d", "u", "list", "ul", "lt", "ln", "lr", "h", "lo", "ld", "s", "i", "dL", "c", "j", "ell", "le", " L", "it", "tl", "dl", "length", "lit"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "substitutes": {"addr": ["Address", "data", "obj", "res", "adr", "max", "tp", " err", " alk", "conn", "offset", "mid", "irm", "src", "rt", "ix", "mem", "ar", "ret", "load", "wd", " ptr", "tx", " arg", "loc", "r", "ack", "hl", "igh", "rid", "reg", "cmd", "attr", "address", "ag", "at", "act", "xt", "len", "coord", "arr", "dir", "ref", "req", "add", "pad", "pt", "dh", "inter", "rel", " address", " wr", "id", "mt", "ad", "rs", "eth", " ax", "dr", "rc", " amp", "oad", "cap", "ord", "alt", "pos", "ptr", "arity", " dst", " tid", "err", " plat"], "rom": ["prem", "rem", "res", "stim", "red", "irm", "serv", "ram", "any", "rock", "om", "ocr", "rim", "dom", "r", "chrom", "arm", "cr", "rum", "norm", "cmd", "stan", "rd", "ox", "dem", "nom", "rax", "m", "mom", "comm", "rx", "com", " chrom", "crypt", "mr", "rep", "rm", "ck", "ROM", "rs", "rob", "tom", "dr", "rc", "lex", "mos", "gem", "prom", "rome", "drm", "roma", "ost", "roc", "rol", "cm", "ro", "rn", "ind", "core"]}}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226, "substitutes": {"opaque": ["spaque", "opulse", "oulse", " opaques", "spque", "spaques", "iopque", " Opulse", "OPaques", "iopaque", "opane", "opaques", "OPane", "OPque", " oplay", " Opaques", "iopane", "iopaques", "oplay", "olay", " Oplay", " opulse", "oaque", "oaques", "spane", "opque", " Opaque", "OPaque"], "param": ["command", "dm", "jp", "ram", "pas", "ref", "add", "unknown", "mm", "p", "canon", "arg", "park", "def", "conf", "form", "Param", "attribute", "term", "ann", "rem", "client", "params", "monitor", "am", "var", "dem", "argument", "project", "check", "prefix", "package", "mark", "num", "nam", "module", "cm", "prop", "pri", "local", "tag", "program", "pai", "sum", "comment", "m", "admin", "view", "cal", "error", "im", "resp", "pm", "prom", "index", "iam", "sm", "parse", "meter", "member", "config", "common", "mem", "item", "info", "man", "par", "pt", "name", "ams", "aram", "min", "mont", "property", "service", "asm"], "pagesize": [" pagessize", "blockssize", "imagesized", "Pagesz", "blocksize", "pagesz", "PagesIZE", "planesize", "imagesizer", "blocksIZE", "pagesized", "blocksz", " pagesizer", "pagesizer", " pagesz", "planesized", "pagesiz", " pagesiz", "imagesiz", "Pagesize", "pagespeed", "mapsized", "imagesize", "mapspeed", "blocksized", " pagesized", "pagessize", "mapsize", "mapsizer", "blocksizer", "planesizer", " pagespeed", "planespeed", "Pagessize", "pagesIZE", " pagesIZE", "blocksiz"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234, "substitutes": {"regs": ["regds", "sects", "Regrs", "memrs", "secds", "Regds", "regrs", " regS", "mems", "Regals", "RegS", "secals", "regals", " regns", "Regts", "memals", "regns", "Regns", "regS", " regrs", "secrs", "memS", "secs", " regds", "regts", " regals", "secns", "Regs", " regts"], "frame": ["flow", "iframe", "request", "scene", "face", "profile", "fr", "range", "rame", "next", "feature", "channel", "file", "source", " Frame", "f", "frames", "context", "event", "lock", "ace", "dict", "step", "reset", "state", "process", "hole", "block", "hide", "feat", "fake", "fram", "t", "sequence", "image", "zone", "component", "version", "chain", "header", "buffer", "code", "function", "connection", "line", "cf", "style", "framework", "call", "base", "window", "locked", "trace", "error", "role", "def", "force", "point", "row", "session", "target", "type", "module", "field", "object", "word", "scope", "orig", "ptr", "Frame", "ctx"], "frame_addr": ["profile_offset", "profile_addr", "range_addr", "frame_add", "range_pat", "frame___pat", "frame_pos", "range____addr", "range____pos", "frame_address", "frame_ptr", " frame_address", "Frame_addr", "Frame_ptr", "Frame_address", "frame____addr", " frame_add", "profile_ptr", "frame_offset", " frame_ptr", "frame___addr", "frame____pat", "frame_pat", " frame_id", "range____pat", "range_pos", "frame___pos", "frame____pos", "frame_id"], "blocked": ["blacked", "glocked", "flock", "flacked", " blacked", "flanned", "sloved", "BLOCK", "glOCK", "Blocking", "BlOCK", "BLocking", "BLocked", "slocked", "blocking", "block", "bloved", "BLock", "glock", "gloved", "slOCK", "blanned", "blOCK", "brocked", " block", "Block", "Bloved", "glocking", "bracked", "slocking", "Blocked", "flocked", "brock", "branned", " blanned"], "target_set": [" target_SET", "target2set", "arg2sets", "taskvalset", "target_list", "target2setting", "target___set", "targetlysets", "targetingset", "target2name", "targetlysc", " target_list", " target_tag", "targetvalset", "target2sets", "targetvalsets", "targetvalsetting", "target_setting", "targetlyname", "target_Set", "target_SET", " target_Set", "target_tag", "task_setting", "arg_sc", "arg_set", "arg_sets", "target_sets", "taskvalsets", "target___list", "targetingSET", "task_sets", "arg2sc", "targetlyset", "targetingtag", "task_set", "taskvalsetting", "arg2set", "arg2name", "arg_name", "target_sc", "target___Set", "target2sc", "target_name"], "r0": ["r2", "errzero", "r1", "Roval", " r2", "R0", "p1", "rarzero", "err1", " rzero", "rzero", "err2", "mr2", "R1", "rar1", "p0", "mroval", "rar0", "Rzero", "err0", " r1", " roval", "mr0", "pzero", "roval", "p2", "mr1", "R2"], "i": ["qi", "v", " j", "n", "is", "me", "ms", "in", "li", "ix", "xi", "ai", "ami", "ini", "gi", "ci", "z", "ki", "info", "di", "hi", "ii", "t", "oi", "mi", "ip", "ei", "cli", "sim", "ic", "m", "multi", "ri", "p", "e", "g", "ui", " ii", "pi", "id", "\u0438", "im", "uri", "io", "l", "fi", "span", "ti", "phi", "j", "c", "x", "zi", "index", "y", "it", "si", "bi", "ind", "I"]}}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 26242, "substitutes": {"dev": ["Device", "nt", "er", "v", "ve", "dm", "res", "conn", "DEV", "devices", "serv", "pro", "mem", "hid", "go", "an", "spec", "dem", "doc", "watch", "hw", "p", "pad", "sd", "device", "ds", "Dev", "d", "debug", "os", "ev", "ad", "adv", "def", "des", "de", "sys", "proc", "test", "ver", "self", "w"], "s": ["sv", "v", "obj", "n", "is", "gs", "js", "ses", "S", "serv", "ns", "go", "ss", "r", "b", "ts", "state", "se", "an", "t", "cs", "sb", "o", "sd", "p", "m", "e", "g", "ds", "sl", "out", "ls", "d", "es", "a", "os", "so", "rs", "h", "sys", "sts", "y", "i", "c", "utils", "sq", "ps", "self"], "info": ["data", "isu", "res", "is", "user", "txt", "fo", "f", "details", "kind", "rt", "op", "class", "Info", "information", "t", "inner", "ip", "auth", "inf", "conv", "where", "by", "o", "INFO", "name", "os", "check", "id", "io", "sys", "conf", "fi", "now", "type", "ti", "i", "j", "ro", "si"], "bsp": [" bl", "bridge", "abl", "bitcoin", "is", "Sp", " esp", "rap", "bp", "gc", "wp", "dp", "loop", "lp", "bf", "sp", "jp", "ns", "esp", "gap", "shr", "sil", "isp", " sp", "b", "osp", "bol", "elt", "xf", "eb", "ffff", "bc", "gb", "lf", "ip", "bl", "SP", "space", "sb", "ic", "bps", "p", "wic", "biz", "cf", "pic", "sw", "cp", "px", "ab", "sync", "split", "lt", "sc", "nob", "soc", "fp", "lbs", "np", "br", "tmp", "bs", "amp", "fi", "i", "pb", "bt", "ps"]}}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n", "idx": 26243, "substitutes": {"base": ["limit", "bas", "create", "eta", "zero", " bases", "basic", "bp", "offset", "db", "pa", "bare", " Base", "bf", "server", "scale", "source", "local", "mask", "f", "based", "store", "b", "bid", "ase", "state", "null", "se", "address", "origin", "ip", "key", "ASE", "ref", "p", "m", "bind", "buffer", "e", "out", "name", "root", "chain", "Base", "ada", "bound", "nb", "prefix", "id", "last", "cpu", "h", "balance", "target", "type", "range", "re", "i", "start", "index", "pos", "scope", "y", "bu", "bal", "mb"], "s": ["sv", "v", "settings", "args", "hs", "is", "gs", "js", "sa", "ses", "changes", "eps", "services", "S", "fs", "source", "params", "ns", "details", "ss", "b", "r", "states", "ts", "qs", "state", "se", "spec", "t", "cs", "ats", "sb", "ims", "ins", "p", "m", "comm", "status", "aws", "ds", "sl", "out", "ls", "os", "a", "es", "sync", "rs", "ies", "h", "vs", "sys", "service", "sts", "bs", "stats", "its", "i", "c", "sq", "ps", "self", "set", "w"], "clk": ["blk", "plc", "plk", "clp", "llk", "lp", "slc", "Clck", "blm", " clck", "cltk", "ltk", "clm", "lltk", "plp", "Clk", "lck", "Clm", "slk", "clik", "llp", " clik", "Clik", "llck", " clp", "clck", " cltk", "blck", "blik", "slp", "Clc", "clc", "plck", "Clp", " clm", "slck", "lk"], "iomemtype": ["iomimerpe", "iomormType", "xiemType", "iomepe", "iomimpe", "iomemposition", "iomimertype", "iomimerType", "xiEMpe", "iemempe", "xiemype", "iomimype", "xiemtype", "iometertype", "xiimerposition", "iomimerype", "iomormposition", "xiimerpe", "iometerType", "iemimerplate", "iememype", "iomympe", "iemimerype", "iomymtype", "xiEMType", "iomemplate", "iomempe", "iemimerpe", "iemimertype", "xiimertype", "iomeemposition", "iomEMype", "xiimerType", "xiEMype", "xiempe", "iememtype", "iometerype", "iometerpe", "iomormtype", "iomimType", "iomymplate", "iememplate", "iomormpe", "iomeemType", "xiEMtype", "iomymype", "iomemype", "iomimerplate", "iomemType", "iomEMType", "iomimerposition", "iomimtype", "iometype", "iomEMpe", "iomeempe", "xiemposition", "iomeemtype", "iomeype", "iomeplate", "iomEMtype"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n", "idx": 26245, "substitutes": {"vs": ["sv", "vals", "v", "cv", "vp", "hs", "is", "ks", "gs", "js", "ms", "obs", "fs", "ils", "uv", "ns", "VS", "vm", "ss", "pages", "ps", "ts", "vers", "qs", "ops", "vv", "cs", "vt", "ds", "ls", "views", "es", "rs", "s", "ys", "bs", "vg", "its", "Vs", "vc", " VS", "vi", "vr"], "x": ["ax", "xml", "ex", "v", "n", "xx", "on", "xp", "wx", "ix", "xi", "tx", "X", "z", "wy", "xxx", "xf", "xe", "xc", "current", "at", "dx", "t", "xt", "ox", "act", "key", "el", "yx", "mm", "rx", "p", "m", "fx", "ct", "pi", "px", "lat", "height", "l", "xy", "xs", "c"], "y": ["v", "iny", "Y", "sky", "yi", "ty", "yr", "ery", "ay", "or", "b", "ym", "z", "wy", "ey", "ye", "gy", "ry", "hot", "uy", "oy", "t", "yy", "ya", "by", "p", "my", "hy", "asy", "ny", "py", "yes", "yt", "ies", "yo", "sys", "iy", "xy", "axy", "ys", "row", "yd", "vy", "cy", "c", "sy", "yet", "yer", "ch"], "w": ["ex", "v", "n", "W", "wr", "wp", "ow", "xp", "wa", "wx", "wl", "wd", "r", "fw", "win", "m", "hw", "wh", "wn", "wi", "g", "pt", "nw", "d", "sw", "wcs", "ew", "rw", "window", " W", "ww", "wid", "wt", "iw", "wb", "kw"], "h": ["hr", "ih", "ph", "v", "hs", "k", "th", "ow", "hl", "H", "b", "ha", "z", "he", "hi", "hei", "hh", "html", "him", "oh", "sh", "kh", "m", "hw", "bh", "p", "g", "ah", "rh", "q", "hp", "hd", "height", "ho", "ht", "c", "it", "ish", "ch"], "i": ["qi", "init", "v", "is", "yi", " I", "iter", "in", "li", "ij", "f", "ix", "it", "xi", "Si", "ai", "ami", "ini", "ji", "b", "gi", "ci", "ki", "di", "ik", "hi", "ii", "oi", "ip", "mi", "ei", "ic", "PI", "p", "m", "multi", "ri", "o", "iii", "u", "pi", "ori", "\u0438", "im", "uri", "iu", "l", "us", "ti", "zi", "ia", "phi", "ie", "si", "bi", "ui", "I"], "j": ["v", "aj", "obj", "n", "js", "fr", "J", "jo", "li", "ot", "ij", "jp", "jl", "json", "job", "ret", "kj", "ne", "ji", "b", "z", "di", "jas", "adj", "at", "ii", "t", "je", "note", "o", "m", "p", "jj", "g", "off", "bot", "jac", "jump", "si", "q", "uj", "jc", "bj", "bo", "im", "try", "l", "br", "bs", "oj", "pr", "dj", "ja", "it", "jit", "bi", "err"], "has_fg": ["having_fg", "has____bg", "having_usr", "having_bg", "having____bg", "having____cfg", " has_opt", " has_fig", "has____cfg", "has___fg", "hasAopt", "has___fig", "hasAbg", "has_cfg", "having____usr", "having____fg", "last_nz", "hasAfg", "has___opt", "hasAfig", "has_nz", "last_cmd", "has____usr", "has_usr", "has_opt", "having_cfg", "has_cmd", "has____fg", "has_fig", "has___bg"], "has_bg": ["has_fab", "has______bg", " has_pic", "having_bg", "has______background", "had_bg", "has_bb", "has___cmd", "has___pic", "had_fg", " has_bp", "has___fg", "has______bp", " has___bg", " has_background", "has_pic", "has___fab", "has___background", "has_background", " has___bp", "had_fab", "has___bp", "having_BG", " has___pic", "has_exc", "has_BG", "having_bb", "has_bp", "has_cmd", "has___bg", "has______pic", " has___background", "having_exc", "had_cmd"], "last_fg": ["last___pu", "last_css", "last_fab", "old_sty", "last_font", "old___bg", "last___css", "old___css", "old___sty", "last_sty", "old_css", "old___fg", "last_buf", "last64bg", " last_FG", " last_font", "last64fg", "old_bg", "last64err", " last_err", "last_err", "last___sty", "last_pu", "old_fg", "last___fab", "last_FG", " last_pu", " last_fab", "last___bg", "last___fg", "last64FG", " last_buf"], "last_bg": ["last_gy", " last_gy", " last_db", "last_db", " last_BG", "last___bp", " last_rg", "last_background", "last___gd", "last___gg", "last___gy", " last_background", "last___sb", "highest_gd", " last_gg", "highest_bp", "last_gd", "last_rg", "last_BG", " last_bp", "last_gg", "highest_sb", "last___BG", "last_sb", "highest_bg", "last___bg", "last_bp"], "vd": ["sv", "dm", "v", "ve", "vp", "df", "md", "dd", "db", "server", " dh", "uv", "uds", "vision", "gd", "vm", "wd", "td", "ud", "dt", "lv", "vv", "gb", "vt", "sb", "erd", "sd", "fd", "ds", "pd", "dh", "d", "bd", "nv", "vid", "nd", "xd", "dds", "od", "hd", "dr", "ld", "VD", "vg", "vc", "dj", "udi", "vi", "vr", "dl"]}}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 26251, "substitutes": {"bs": ["BS", "bits", "bas", "hs", "ks", "bis", "gs", "js", "bp", "obs", "bf", "fs", "blog", "ns", "ss", "b", "bid", "ps", "ts", "qs", "bos", "bc", "cs", "bl", "bes", "sb", "bps", "bh", "ds", "bb", "ls", "bn", "cks", "rs", "bm", "bsp", "vs", "lbs", "sts", "its", "pb", "bt", "bi"], "sector_num": ["sectorIDtemp", "sectorIDman", " sector_temp", "sectorNameNum", "sectorNamenumber", " sector_man", " sector_Num", " sector_number", "sector1Num", "sector_temp", "sector_number", "sector1max", "sector_man", "sectorIDnum", "sector_Num", "sectorIDnumber", "sectorNamenum", "sector1num", "sector1number", "sector_max", " sector_max", "sectorNamemax"], "buf": ["accept", "data", "v", "cv", "obj", "ctx", "bf", "txt", "mem", "seq", "buff", "cb", "b", "vec", "rb", "cmd", "block", "bytes", "bc", "new", "uf", "ref", "buffer", "queue", "fb", "Buffer", "img", "Buff", "tmp", "br", "cap", "wb", "pb", "batch", "msg", "raw"], "nb_sectors": ["nb_traves", "nb_ectors", "nb_traors", "nb_veves", "nb_speors", "nb_serors", "nb_vecs", "nb_seriers", "nb_traivers", "nb_seitors", "nb_neors", "nb_spectors", "nb_neves", "nb_seors", "nb_peitors", "nb_speriers", "nb_tractors", "nb_serriers", "nb_traitors", "nb_nectors", "nb_evers", "nb_travers", "nb_seivers", "nb_secs", "nb_specs", "nb_sercs", "nb_veivers", "nb_pectors", "nb_veors", "nb_eitors", "nb_veriers", "nb_eivers", "nb_pevers", "nb_severs", "nb_seves", "nb_neivers", "nb_vectors", "nb_serctors", "nb_peivers"], "async_ret": ["async___Ret", "assync_del", "async_res", "async___res", "asyncixret", "asyncixres", "assync_ret", "async___del", "asyncixreply", "async_return", "assync_len", "async___ret", "async__RET", "async__nt", "assync_nt", "assync_reply", "async__ret", "async_len", "assync_flag", "async___reply", "async_flag", "assync_alt", "async_Ret", "async_out", "assync_out", "async_del", "assync_return", "assync_RET", "async__res", "async_nt", "assync_res", "async_rt", "assync_Ret", "async_alt", "async_reply", "async__Ret", "asyncixreturn", "async___out", "async___return", "assync_rt", "async__rt", "async_RET"], "acb": [" acB", "ecba", " acsb", "ACbh", "pacb", "facb", "pacrb", "facB", "ACb", "acbb", "acbh", "ascb", "ecB", "acob", "ACsb", "acB", "ascbh", "facob", "acsb", "ecbb", "icb", "icbb", "ACrb", "ecb", "icba", "ACB", " acba", "ascB", "ascob", "acrb", "pacsb", " acrb", "pacB", "acba", " acbb", "facbh", "ACob", "icB"], "iov": [" narr", "ih", "iph", "iev", "vp", " mus", " announcer", "iq", " multimedia", " mor", " resp", "Iv", " unim", "isco", "qv", " civ", "ij", "ibl", " vib", " vec", "rio", " VII", "igroup", " mosqu", "veh", "iva", "nov", "chrom", "ux", "voice", "dq", "vo", "pkg", "username", "tv", "iv", " vom", " io", "nom", "vector", "minecraft", "conv", " bio", " morale", " mech", " motiv", " volley", "voc", "liv", "imp", "iol", " vers", "uj", " impulse", "iop", "rov", "nil", " pir", "iu", " rav", "ichael", "iw", "river", "av", "drm", "ech", "inv", " inver", "ever", "iour", "vr", " imb", " supporters", " repertoire"], "qiov": ["aqiol", " qiro", "queryiro", "qovi", "qviour", "qurolet", "qqiro", "queryiour", "sqiol", "qqiov", "qqiour", "qviov", "aqveh", "sqiov", "qqiv", "qiol", "sqrolet", "qiv", "queryiv", "aqiov", "qiour", "qveh", "sqveh", "qiro", "quiov", "queryiov", "quveh", "qrolet", "qvrolet", " qiour", " qiv", "qvovi", "aqrolet", "quiol"]}}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26257, "substitutes": {"cpu": ["linux", "bench", "pc", "gc", "conn", "util", "upt", "ruby", "anc", "rom", "jp", "nu", "apache", "comp", "rt", "aq", "mem", "mu", "vm", "ack", "core", "process", "cmd", "pool", "processor", "hap", "setup", "pu", "cu", "boot", "clock", "ork", "cli", "gpu", "p", "hw", "aco", "pt", "cc", "cp", "u", "ck", "nic", "rpm", "gnu", "rc", "uu", "chip", "np", "us", "cum", "home", "CP", "buf", "CPU", "c", "proc", "nc", "ctx"], "env": ["command", "obj", "conn", "txt", "uv", "outer", "net", "vm", "ce", "cb", "ner", "cmd", "vv", "image", "vt", "el", "ec", "e", "hw", "header", "environment", "nv", "window", "here", "conf", "console", "vert", "nc", "entry", "er", "runner", "next", "Environment", "manager", "eh", "kh", "doc", "dev", "eng", "device", "ah", "cp", "equ", "vs", "pe", "param", "ov", "desc", "buf", "et", "export", "ctx", "eco", "cv", "chart", "apache", "ent", "context", "event", "query", "menu", "door", "goal", "operator", "worker", "cur", "rc", "tmp", "head", "extra", "proc", "enc", "v", "ve", "oe", "server", "eni", "ext", "ee", "disk", "node", "end", "viron", "config", "common", "gear", "den", "editor", "code", "en", "eve", "org", "ew", "esc", "ef", "ev", "engine", "era", "core"], "sregs": ["sredps", "scmds", "sroundges", "scmdacs", "powersconnensions", "srenditions", "sgrgs", "powersregensions", "scmdims", "sregjs", "sreplacs", "sREGs", "sregges", "sregitions", "powersconns", "awsregments", "srends", "unsrounds", "srogs", "srogations", "sREGjs", "slocims", "smemges", "slocacs", "sregls", "awsregs", "gesregils", "sREGps", "srendles", "sreplils", "itsregts", "unsroundgs", "sres", " sREGs", "sreggs", "gesregims", "slocils", "sgraphges", "awsservjs", "SREGes", "sconns", "unsregations", "smems", "itsregies", " sREGjs", "surgensions", "SREGn", " sregensions", " sgraphs", "sregations", "Sregn", "Sregs", "gesregs", "sgrjs", "smemn", "sredn", "swarns", "srecls", "gesregacs", "sargges", "sarchs", "sREGses", "srealensions", "sroggs", "srects", "srendjs", "sregensions", "powersconnitions", " sREGgs", " sgraphjs", "sargs", "slocs", "itsregs", "unsregs", "srecs", "SREGs", "srecges", "sstatis", "sgrs", "srejs", "spatternges", " srecensions", "srogis", "smemes", "gesreplims", "sconnses", "sstatgs", "itsrecges", "sstats", "itsrecs", "spatternments", "surgs", "sroundis", "sregacs", "gesrepls", "spatterns", " sregjs", "itsrecies", "sservges", " sregges", "srealses", "srendses", "Sregps", "scmdils", " sgraphles", "sregils", "sgrses", "surgls", "awsregges", "itsrects", "sstatations", "sregings", "unsreggs", "swarnjs", "srounds", "sarchgs", "powersregs", "sorgensions", " sregings", "Sreges", "srendensions", "sregles", " srecings", " sgraphges", "SREGps", "powersconnses", "srepls", "swarnls", "sgraphles", "sargies", "sargts", "srealitions", "sredes", "sroundgs", "srecings", "spatternjs", "unsroundis", "sreds", "sregps", "sorgs", " sregles", "gesreplils", "unsroundations", "sregments", "sservments", " sreggs", "sservjs", "sREGgs", "sreals", " srecs", " srecls", "smemps", "sregses", "sroundies", "sregims", "sregis", "powersregses", "sregn", "itsregges", "sgraphs", "awsservments", "sreges", "sservs", "srecensions", "sreplims", "smemments", "sservles", " sregls", "sarchjs", "sgraphjs", "sregts", "sorgls", "sconnensions", " sREGses", "sregies", "sconnitions", "srendges", "awsservs", "gesreplacs", "sroundts", "sorgings", "surgings", "sroundations", "smemjs", "sarchses", "sREGes", "awsregjs", "awsservges", " sregses", "powersregitions", "srels", "unsregis", "sREGn", "srecies"], "ret": ["nt", "rem", "v", "res", "result", "gc", "ter", "red", "git", "ext", "txt", "val", "print", "rt", "f", "rets", "tr", "det", "reset", "elt", " Ret", "cmd", "ry", "t", "Return", "len", "ref", "deg", "hash", "ft", "code", "gt", "status", "Ret", "out", "inter", "mt", "RET", "flag", "def", "fi", "resp", " RET", "alt", "re", "j", "err"], "i": ["qi", "ex", " I", "jp", "ix", "xi", "ami", "b", "ii", "oi", "ip", "ei", "status", "id", "io", "series", "us", "zi", "y", "bi", "ind", "I", "er", "to", "json", "ci", "di", "um", "u", "pi", "iu", "fi", "phi", "esi", "all", "init", " j", "is", "me", "ij", "f", "ini", "gi", "z", "hi", "eu", "this", " bi", "remote", "sim", "ri", "m", "multi", "cli", "ic", "chain", " ii", " si", "\u0438", "im", "dr", "try", "l", "j", "index", "si", "v", "gu", "in", "li", "sp", "ai", "ji", "ki", "info", "t", "mi", "key", "ims", "g", "name", "q", "list", "uri", "err", "ti", "batch", "x", "it", "tim", "ui"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    uint32_t ram_offset;\n\n    qemu_irq *pic;\n\n    qemu_irq *cpu_pic;\n\n    int sd;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    integratorcm_init(ram_size >> 20);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],\n\n                       cpu_pic[ARM_PIC_CPU_FIQ]);\n\n    icp_pic_init(0xca000000, pic[26], NULL);\n\n    icp_pit_init(0x13000000, pic, 5);\n\n    pl031_init(0x15000000, pic[8]);\n\n    pl011_init(0x16000000, pic[1], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 26259, "substitutes": {"ram_size": ["ram_cache", "ram_name", "mem_size", "ram_lock", "ram67lock", "ram_fee", "ram_count", "ram67fee", "mem_addr", "ram_type", " ram_fee", "mem_name", "cpu_type", "cpu_count", "mem_set", "ram67size", "ramptsize", "ram_limit", "ram_set", " ram_SIZE", "cpu_SIZE", " ram_lock", " ram_cache", " ram_limit", "ram_SIZE", "cpu_size", "ram_addr", "ramptoffset", "ramptlimit"], "vga_ram_size": ["vga_ram2SIZE", "vga_mem_space", "vga_ram2size", "vga_ram_space", "vga_ram_SIZE", "vga_mem_size", "vga_mem_name", "vga_ram2space", "vga_ram_name", "vga_ram2name", "vga_mem_SIZE"], "boot_device": ["bootdevnumber", "boot_number", "bootabledevice", "boot_model", "bootdevdev", "cpu_device", "cpu_number", "cpu_dev", "bootabledev", "bootdevmodel", "bootablemodel", "bootablenumber", "boot_dev", "bootdevdevice"], "ds": ["eds", "ks", "dd", "db", "DS", "eps", "uds", "vd", "di", "dt", "cs", "du", "dev", "dh", "ls", "d", "bd", "os", "rs", "dds", "Ds", "dr", "des", "sys", "ys", "bs", "xs", "ps"], "kernel_filename": ["kernel_module", " kernel_file", "kernel_device", " kernel_module", "kernel_file", " kernel_device"], "kernel_cmdline": ["kernel_commandl", "kernel_extline", "kernel_extpath", "kernel_ctrpath", "kernel_cmdl", "kernel_commandline", "kernel_ctrline", "kernel_cmdpath", "kernel_commandpath", "kernel_extl", "kernel_ctrl"], "initrd_filename": ["initrd_exe", "initrdfileexe", "initrdfilefil", "initrdfilepath", "initrd_path", "initrar_path", "initrar_filename", "initrar_fil", "initrdfilefilename", "initrar_exe", "initrd_fil"], "cpu_model": ["CPU_mode", "cpu_models", "CPU_Model", "gpu_type", "CPU_model", "cpu2model", " cpu_type", " cpu_library", "CPU_models", "pu_brand", "cpu_type", "cpu_link", "cpu_Model", "gpu_model", "cpu2type", "pu_Model", "cpu_brand", "cpu_library", "pu_link", "pu_model", "cpu_mode", "cpu2mode", "gpu_mode"], "env": ["init", "sv", "er", "v", "cv", "obj", "ped", "conn", "js", "loader", "sp", "end", "ent", "priv", "context", "tx", "attr", "eu", "em", "vt", "shell", "ec", "sb", "hw", "e", "dev", "en", "environment", "ah", "eas", "eng", "org", "nv", "ew", "esc", "window", "ev", "ef", "here", "virt", "worker", "up", "cur", "con", "vs", "conf", "np", "tmp", "cap", "pen", "proc", "ptr", "et", "ps", "enc", "set", "ctx"], "ram_offset": ["space_Offset", "space_offset", "mem_address", "ramxaddr", "rammoffer", "mem_size", "rammlayout", "ram0size", "ram0start", "ram_start", "space_layout", "mem_addr", "ram0offset", "ramxsize", "space_offer", "ramxstart", "mem_offset", "rammoffset", "ram_address", " ram_start", "ramxoffset", "ram_offer", "ram_Offset", "mem_start", "ram_addr", "ram_layout", "rammOffset"], "pic": ["magic", "ig", "iac", "pc", "pick", "script", "cam", "js", "pa", "pol", "tick", "lp", "rip", "txt", "sp", "jp", "sam", "mic", "pan", "pl", "fig", "sac", "mc", "capt", "png", "ts", "pin", "pp", "spec", "spr", "pres", "pit", "ics", "cs", "pins", "mac", "lic", "pict", "ac", "lib", "ic", "doc", "p", "picture", "par", "ping", "str", "pot", "wit", "style", "py", "vine", "pi", "nic", "virt", "eric", "pac", "snap", "vol", "shot", "record", "cap", "sim", "pen", "pr", "Pic", "caps", "pet", "ps"], "cpu_pic": ["cpu_mic", "util67mic", "cpu67chat", "cpu_pict", "cpuptpic", "cpu__script", "componentmychat", "cpuptjp", "cpu__p", "cpu2pic", "componentmypic", "cpu_script", "cp_pc", "cpu_chat", "cpu2pipe", "componentmypict", "cpu___capt", "util67pic", "pu_pic", "cpumychat", "cp_pipe", "pu_p", "cpu67pc", "component_pic", "cpu__pic", "cpu_pc", "cp_pic", "pu_nic", "cpu2ic", "component_capt", "component_pict", "util67pc", "cpu67capt", "pu_script", "util_mic", "cpu_nic", "cpumycapt", "cpu_p", "cpu___pic", "util67jp", "cpu67jp", "cpu67pict", "component_chat", "cpumypic", "cpu_jp", "cpu67mic", "util_jp", "util_pc", "cpu2pc", "componentmycapt", "cpu_capt", "util_pic", "cpu_pipe", "cpu_ic", "cpuptpc", "cp_ic", "cpu___pict", "cpu__nic", "cpu___chat", "cpuptmic", "cpu67pic", "cpumypict"], "sd": ["sv", "md", "dd", "dk", "db", "disk", "sp", "sam", "cd", "ix", "gd", "td", "ss", "vd", "ud", "std", "sid", "dis", "south", "sh", "sk", "sb", "fd", "dev", "pd", "d", "da", "bd", "san", "nd", " SD", "sc", "od", "hd", "ld", "des", " sh", "sn", "sy", "SD", "si", "ind", "dl", "sky"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n", "idx": 26291, "substitutes": {"mon": ["ann", "dm", "chron", "mons", "conn", "util", "meter", "Mon", "MON", "sam", "monitor", "mint", "mir", "mu", "dom", "mn", "manager", "den", "demon", "mx", "timer", "mi", "coord", "man", "bin", "mit", "cat", "mm", "m", "comm", "my", "admin", "Monitor", "mut", "min", "san", "mt", "mun", "von", "mont", "unit", "rain", "map", "mat", " monitor", "onet", "sm"], "qdict": ["dqd", "dqdict", "qqdict", "qd", " qd", "dqmap", "qqmap", "qdb", "qmap", " qmap", "qqd", "dqdb", "qqdb", " qdb"], "bdev_list": ["bmem_listed", "bswlistlist", "bdevishlist", "bDev_List", "bdev_List", "bsw_dict", "bdev__no", "bdevlistlist", "bDev_map", "bdevishlisted", "bsw_list", "bsw_map", "bdev_collection", "bdevishmap", "bdev_dict", "bdev_lists", "bdevishst", "bdev_no", "bDev_no", "bDev_lists", "bdevlistdict", "bdev__list", "bswlistcollection", "bdevlistcollection", "bdev_map", "bmem_map", "bswlistdict", "bdev_listed", "bswlistmap", "bdev_st", "bmem_st", "bmem_list", "bDev_list", "bdev__map", "bdevlistmap", "bsw_collection"], "bdev": ["bver", " brent", "brdef", "bbrent", "bcDev", "Bdevice", "rdec", "bcdoc", "rbdev", "btdef", "sbdev", "dbver", "bbdec", "bDev", "brev", "Bver", "pev", "sbev", "bgdevice", "lver", "bdef", "bev", "bcev", "pdef", " bDev", "rserv", "bdevice", "btver", "Bpriv", "pdev", "rbver", "sbDev", "bdec", "bpriv", "ldev", "btdev", " bdoc", " bev", "bdoc", "rdevice", "brdevice", "rbdevice", "bgdev", "bbev", "rdev", "ldevice", "bbdevice", "bcdev", "dbdevice", "rbpriv", "sbdoc", "brdev", " bpriv", "bbdef", "bbserv", "bbver", "bgdec", "dbdev", "pdevice", "bserv", " bdevice", "BDev", " bdef", "brent", "lDev", "btrent", "dbev", "Bdev", "bbdev", "bgserv", " bver"], "err": ["er", "obj", "errors", "res", "urg", "iter", "die", "fr", "bar", "gr", "notice", "txt", "fam", "rr", "aaa", "cb", "r", "cmd", "attr", "usr", "ch", "timer", "der", "coord", "arr", "erd", "e", "str", "dev", "ah", "Er", "fee", "mr", "ev", "rs", "error", "resp", "conf", "sys", "buf", "Error", "proc", "msg", "order", "exc", "kr", "cfg"]}}
{"project": "FFmpeg", "commit_id": "49cf36f4e3e9183611859af1a07dc6a82ab47288", "target": 1, "func": "static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 26294, "substitutes": {"ctx": [" cx", "nt", "init", "ca", "cv", "pc", "cmp", "obj", "work", "acl", "js", "gc", "conn", "cas", "history", "anc", "jp", "aux", "xp", "kl", "wx", "kind", "context", "timeout", "config", "tx", "wd", "cb", "lc", "kt", "fc", "cmd", "pkg", "xc", "std", "bc", "act", "dc", "cu", "ctl", "req", "abc", "unc", "p", "hw", "bh", "cc", "jac", "cf", "ct", "cp", "wcs", "ck", "px", "prefix", "pause", "sc", "resp", "conf", "np", "tmp", "Context", "tc", "sys", "xs", "gz", "desc", "today", "proc", "etc", "kw", "nc"], "frm": ["FrM", "frgm", " frgm", "fxmi", "flgm", "Frgm", "drv", "frek", "fxp", "fam", "frmm", "frk", "frv", "fremm", "flv", "frem", "frn", "fermm", "grp", "drM", "Frn", "frmt", "fn", "flM", " fram", "grmi", "Fram", "fram", " frk", "fxm", "grmt", "fm", " frn", "frM", "frp", " frmt", "Frm", "fermt", "frmi", "drgm", "fgm", " frmm", " frmi", "ferk", "ferm", "Frv", "grm", "flm", "drm", "fremt", "fxmt", " frp"], "npixels": ["npris", "wpixels", "pngixel", "wpris", "pnips", "npix", "nrix", "nsixels", "pnris", "pnixels", "pairs", "npixel", "pngoms", "npairs", "npips", "pnixel", "wpixel", "ncix", "nixels", " npips", " npinches", " npixel", "ncixels", "nsixel", "pngixels", "nix", "ncixel", "npoms", "pnginches", "nsips", " npoms", "nsris", "pixel", "nairs", "vpixels", "vpoms", "wpix", "nixel", "vpixel", "vpinches", "wpinches", "pixels", "nrips", "wpips", "npinches", "ncairs", "nrixels", "pix", " npix", "nrinches"], "dst": ["dest", "sdist", "dand", "dsts", "dast", " dbr", " dnd", " dest", "sdbr", " dist", "ddest", " dsts", "dnd", "Dest", "dist", "dadest", "Dsts", "sdsts", "sdst", "Dnd", "Dbr", " ddest", "Dst", "Ddest", "Dist", "dbr", "daest"]}}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306, "substitutes": {"obj": ["nt", "ex", "v", "cmp", "sky", "js", "oc", "obs", "gr", "txt", "ij", "jp", "ob", "og", "cmd", "attr", "gm", "act", "t", "o", "comm", "bh", "hw", "expr", "pt", "org", "ck", "id", "bj", "gov", "Obj", "att", "resp", "cont", "tmp", "obo", "tk", "object", "j", "ht", "onet", "it", "vr", "rect", "ctx"], "s": ["sv", "sis", "hs", "is", "iss", "gs", "js", "ms", "ses", "fs", "S", "ns", "ss", "b", "set", "ts", "se", "ats", "sb", "o", "sl", "ds", "ls", "es", "so", "rs", "su", "st", "sys", "stats", "sts", "bs", "j", "sq", "ps", "sm"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315, "substitutes": {"opaque": ["obacity", "obempty", "ropatile", " opacity", "obaque", " opaques", "popatile", "popaque", "OPaques", " opempty", "OPacity", "ropacity", "ropute", "opaques", "opacity", " opatile", "opempty", "ropaque", "obaques", "popute", "OPempty", " opute", "opatile", "popacity", "OPaque", "opute"], "data": ["command", "DATA", "cache", "obj", "rec", "result", "zero", "ta", "Data", "aw", "mode", "params", "val", "client", "content", "details", "config", "ne", "that", "action", "join", "query", "store", "reader", "report", "state", "info", "missing", "spec", "writer", "area", "this", "image", "al", " DATA", "where", "by", "p", "dat", "str", "dev", "name", "da", "device", "d", "rel", "still", "view", "list", "table", "window", "ad", "error", "no", "roy", "value", "size", "delete", "def", "share", "type", "form", "batch", "ATA", "ion", "extra", "empty", "index", "ata", "self", "results"], "co": ["cv", "oc", "cons", "ctx", "cro", "fo", "local", "go", "ob", "loc", "ci", "can", "cor", "vo", "ror", "cu", "ko", "ico", "coord", "CO", "cod", "mi", "coll", "o", "aco", "com", "cho", "bo", "con", "lo", "ra", "soc", "cover", "mo", "coe", "Co", "c", "ro", "nc", "que", "po", "wo", "flo"]}}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n", "idx": 26320, "substitutes": {"mon": ["ann", "dm", "mons", "vis", "conn", "mond", "Mon", "meter", "mot", "MON", "don", "monitor", "mint", "mir", "mem", "jon", "mu", "dom", "mn", "manager", "amon", "isen", "demon", "pai", "den", "tem", "mi", "man", "mm", "m", "wat", "admin", "por", "mong", "mut", "min", "san", "mt", "mind", "mun", "von", "mont", "num", "mat", " monitor", "zon", "onet", "met"], "qdict": [" qdir", "dqdict", "qd", " qd", "questmd", "qualdb", "qcompl", "qbody", "qualdot", "requdir", "qmap", "querydir", "dqdel", "questdel", "requparams", "qparams", "qdir", "questparams", "qtbind", "qmd", "requdict", " qparams", "questtable", "requmap", "questcond", "dqdef", "requcond", "qqmd", "qdot", "qqcompl", "dqbind", "requdb", " qbind", "qqdb", "querydict", "questlist", "qqdict", "qtd", "questbody", "dqlist", " qdef", "qtdef", "requtable", "qcond", "requcompl", "qqmap", "qualmap", "qualdict", " qbody", "dqd", "qqdot", " qcond", "qtable", "questdir", "qlist", "qtdict", "querytable", " qmd", "dqbody", "questdict", " qcompl", "qdel", "qdb", "questcompl", " qlist", "qdef", "qbind", "requdot", "qqdir", " qdel", "querycompl"], "ret_data": ["aux_Data", "retrowDATA", "ret_Data", "retJdata", "retJData", "retrowimage", "ret_DATA", "retrowData", "aux_data", "retJDATA", "retrowdata", "retJimage", "aux_image", "ret_image", "aux_DATA"], "protocol": ["protication", "prototype", "pronocol", "interol", "prootype", "scheication", "patol", "proication", "interocol", "propocol", "pronotype", "protistor", "patocol", "protoid", "patolean", "propotype", "patication", "patistor", "scheocol", "scheotype", "interotype", "scheoid", "patotype", "procol", "pronication", " protication", "proid", "propol", "protolean", "prication", "pronoid", "proistor", "protol", "protype", "propolean", " prototype", " protistor", "proocol", "interolean"], "fdname": ["fcnew", "fdon", "fdstable", "flon", "fbnew", "fdnam", "fbname", "fnno", "flnames", "fcstable", " fidnew", "fedname", "fdid", "FDnam", "fnname", " fidmax", "FDname", "fedame", " fidon", "fdmax", "fnstable", "fednam", "flname", "FDid", "fcname", "dfname", " fidame", "fdnew", "flmax", "fdno", " fidni", "fedid", "fnni", "dfon", "fbno", "fdni", " fidname", "fcno", " fidid", "fcnam", "dfmax", "fcni", " fidnam", "FDame", "dfnames", " fidstable", " fidnames", "fdnames", "fbnam", "fdame", " fidno"], "s": ["sv", "v", "n", "js", "fs", "S", "sam", "f", "ss", "r", "spec", "t", "ssl", "sb", "p", "m", "sd", "e", "g", "ds", "d", "ls", "es", "a", "sg", "rs", "h", "sys", "stats", "sts", "session", "bs", "i", "j", "c", "socket", "sq", "ps", "w"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "substitutes": {"ioc": ["tiocon", "ioco", "iuoco", "iuoc", "tioco", "iuocon", "iuoci", "ioci", "tioci", "eioc", "iocon", "eioci", "eiocon", "eioco"], "condition": ["reason", "command", " thread", " command", " computation", " status", " dependency", " argument", "event", "process", " completion", " constraint", " reason", "cond", "Condition", " input", " requisite", " connection", "connection", "ition", " contract", "check", "ITION", "choice", " chain", " error", "when", " conditional"], "user_data": ["user_content", "user____content", " user_DATA", " user_input", "user_dat", "User_DATA", "user____dat", "User_data", "user_input", "user____DATA", "User_content", "user____data", "user_DATA", "User_dat"], "task": ["data", "nt", "command", "request", "work", "master", "unk", "source", "node", "link", "config", "job", "parent", "tx", "event", "ask", "process", "missing", "t", "key", "total", "release", "req", "chain", "connection", "out", "name", "project", "course", "table", "tty", "worker", "problem", "role", "thread", "activity", "input", "piece", "session", "target", "form", "index", "resource", "Task", "msg", "asks", "test", "term", "slave"], "tioc": ["atiOC", "itiocon", "utiocy", "atioc", "atiocy", "piol", "atioci", "tiocl", "tioci", "iiocl", "tiocy", "atiocl", "pioc", "tioco", "itioc", "piocon", "itaoc", " tioci", "atiol", "itiocy", "piocy", "itaOC", "tiOC", "utioci", " tioco", "itaoci", "atiocon", "tiol", "nioci", "tiocon", "iioc", "nioc", " tiocy", "itaocl", "iioci", "iiOC", "nioco", "utioco", "niocy", "utioc", "itiol"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26333, "substitutes": {"s": ["ches", "sv", "sis", "hs", "is", "gs", "js", "ms", "ses", "bis", "changes", "fs", "S", "ns", "details", "ss", "states", "ts", "ops", "cs", "gets", "ats", "bes", "sb", "ins", "ims", "comm", "aws", "ds", "ls", "ains", "ares", "os", "es", "tes", "rs", "ies", "events", "h", "vs", "des", "sys", "ys", "als", "sts", "bs", "stats", "its", "uns", "aunts", "ps", "self"], "sci_level": ["sci_value", " sci_levels", "sci___type", "sciacylevel", "sciacyleft", "sci___count", "scaleacylow", "scale_goal", "sci_low", "sci_state", "sci_count", "scale_left", "sci_goal", " sci_count", "sciacylow", "sci_left", " sci_value", "scaleacyleft", "sci_levels", "sci___levels", " sci_state", "scaleacylevel", "sci___level", "sciacygoal", "scale_low", "scaleacygoal", "sci_type", "scale_level", " sci_type"], "pmsts": ["amsts", " pmst", "pmces", "rpmns", "gmeps", "pkgcasts", "pmgs", "rpmsts", "pxrs", " pmgs", "mpinces", "amcasts", " pmcasts", " pmplays", "mpst", "pmctr", " pmctr", "amplays", "pkgsts", "pmst", " pmeps", "mpgs", "pmeps", "pxinces", " pmces", " pmns", "mpeps", "rpmces", "amces", " pminces", "pkgst", "amst", "gmsts", "pmrs", "pxsts", "pminces", "pxctr", "mpsts", "pmplays", "pkgplays", "mpctr", "pmns", "amns", " pmrs", "pmcasts", "gmgs", "mprs", "gmst"]}}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_key_prefix(WriterContext *wctx)\n\n{\n\n    FlatContext *flat = wctx->priv;\n\n    const struct section *parent_section = wctx->section[wctx->level-1];\n\n\n\n    printf(\"%s\", flat->section_header[wctx->level].str);\n\n\n\n    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n\n        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n\n            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n\n        printf(\"%d%s\", n, flat->sep_str);\n\n    }\n\n}\n", "idx": 26360, "substitutes": {"wctx": ["rwpy", "wscmp", "wsctl", "wacmd", "wdreq", "rwtx", "wdgc", "wgc", "wsdc", "Wpkg", "Wtx", "writergc", "rwcmp", "Wctx", "wssys", "rwcontext", "wxctx", "writerreq", "rwcm", " wgl", "wtx", "wsys", "wdpy", "wrcmp", "wcontext", "writerpy", "wdalloc", "wrctx", "wtctx", " wdc", "wcmp", "wdgl", "wscontext", " wcontext", "wctl", "wtcontext", " wcmp", "wstx", "wdcmp", " wsys", "wacm", " wpkg", "rwreq", "wpy", "wxctl", " wpy", "wreq", "wactx", " wcmd", "wtsys", "rwgc", "wsctx", " wctl", "wacontext", "writerctx", "wdc", "wxtx", "wpkg", "wdpkg", "Wpy", " wcm", "wcmd", "wspkg", "rwcmd", "wxcmp", "wdctx", "wgl", "walloc", "wcm", " walloc", "Wcontext", "Wgl", "wdtx", "rwctx", " wtx", "wrdc", "wdcontext", "wtcmp", "rwalloc", "wrpkg"], "flat": ["util", "sat", "final", "plan", "atten", "local", "raft", "tf", "parent", "tx", "full", "fat", "pool", "feat", "at", "utf", "nan", "wide", "single", "oat", "uf", "conv", "cat", "hat", "fl", "format", "cf", "clean", "late", "san", "mt", "fare", "old", "att", "wt", "nil", "lat", "cont", "stable", "mat", "layout", "batch", "normal", "dim", "tiny", "plain", "ctx"], "parent_section": [" parent_option", "parent___sect", "parent_option", "parent___option", "parent___sections", "parent___sector", "parent___Section", " parent_sections", "parent_sections", "parent_sect", " parent_sect", "parent_sector", "parent___section", "parent_Section", " parent_entry", " parent_Section", "parent_entry", " parent_sector"]}}
{"project": "FFmpeg", "commit_id": "b97d21e4d6813498f458777ff42c7eab1eed3adf", "target": 1, "func": "static int sdp_parse_fmtp_config_h264(AVStream *stream,\n\n                                      PayloadContext *h264_data,\n\n                                      char *attr, char *value)\n\n{\n\n    AVCodecContext *codec = stream->codec;\n\n    assert(codec->codec_id == CODEC_ID_H264);\n\n    assert(h264_data != NULL);\n\n\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n\n        h264_data->packetization_mode = atoi(value);\n\n        /*\n\n         * Packetization Mode:\n\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n\n         *                      and 29 (FU-B) are allowed.\n\n         */\n\n        if (h264_data->packetization_mode > 1)\n\n            av_log(codec, AV_LOG_ERROR,\n\n                   \"Interleaved RTP mode is not supported yet.\");\n\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n\n        if (strlen(value) == 6) {\n\n            char buffer[3];\n\n            // 6 characters=3 bytes, in hex.\n\n            uint8_t profile_idc;\n\n            uint8_t profile_iop;\n\n            uint8_t level_idc;\n\n\n\n            buffer[0]   = value[0];\n\n            buffer[1]   = value[1];\n\n            buffer[2]   = '\\0';\n\n            profile_idc = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[2];\n\n            buffer[1]   = value[3];\n\n            profile_iop = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[4];\n\n            buffer[1]   = value[5];\n\n            level_idc   = strtol(buffer, NULL, 16);\n\n\n\n            av_log(codec, AV_LOG_DEBUG,\n\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n\n                   profile_idc, profile_iop, level_idc);\n\n            h264_data->profile_idc = profile_idc;\n\n            h264_data->profile_iop = profile_iop;\n\n            h264_data->level_idc   = level_idc;\n\n        }\n\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n\n        codec->extradata_size = 0;\n\n        codec->extradata      = NULL;\n\n\n\n        while (*value) {\n\n            char base64packet[1024];\n\n            uint8_t decoded_packet[1024];\n\n            int packet_size;\n\n            char *dst = base64packet;\n\n\n\n            while (*value && *value != ','\n\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n\n                *dst++ = *value++;\n\n            }\n\n            *dst++ = '\\0';\n\n\n\n            if (*value == ',')\n\n                value++;\n\n\n\n            packet_size = av_base64_decode(decoded_packet, base64packet,\n\n                                           sizeof(decoded_packet));\n\n            if (packet_size > 0) {\n\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n\n                                          codec->extradata_size +\n\n                                          FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!dest) {\n\n                    av_log(codec, AV_LOG_ERROR,\n\n                           \"Unable to allocate memory for extradata!\");\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                if (codec->extradata_size) {\n\n                    memcpy(dest, codec->extradata, codec->extradata_size);\n\n                    av_free(codec->extradata);\n\n                }\n\n\n\n                memcpy(dest + codec->extradata_size, start_sequence,\n\n                       sizeof(start_sequence));\n\n                memcpy(dest + codec->extradata_size + sizeof(start_sequence),\n\n                       decoded_packet, packet_size);\n\n                memset(dest + codec->extradata_size + sizeof(start_sequence) +\n\n                       packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n                codec->extradata       = dest;\n\n                codec->extradata_size += sizeof(start_sequence) + packet_size;\n\n            }\n\n        }\n\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\",\n\n               codec->extradata, codec->extradata_size);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26367, "substitutes": {"stream": ["accept", "data", "video", "Stream", "filter", "channel", "source", "each", "context", "ocr", "shape", "store", "message", "reader", "ack", "read", "spec", "stack", "pod", "REAM", "ec", "http", "seek", "chain", "secure", "feed", "connection", "steam", "sw", "window", "sync", "enc", "input", "console", "open", "session", "ream", "form", "transform", "socket", "port"], "h264_data": ["h26467not", "h323_session", "h264__Data", "happy_details", "hutil67not", "h26400Data", "h2645session", "hutil_DATA", "hutil67data", "h264ptData", "h264ptdefault", "h264__data", "h264__DATA", "h323ptsession", "h544_status", "hutil67DATA", "happyptData", "hutil_connection", "h26400options", "hutil67connection", "h264_default", "h323_data", "h2645data", "h64_ata", "hutil_data", "happy_Data", "h64_config", "h323ptdata", "h264_Data", "happy_options", "happy_data", "h264__params", "h264_window", "h264ptwindow", "h26467DATA", "h264_session", "h264_cache", "h264_config", "happyptoptions", "h264ptconnection", "h264_options", "h2645default", "h264_status", "h26400data", "h544_DATA", "h323_window", "happyptdetails", "h264acData", "h26400details", "h204_cache", "h323ptwindow", "h264_connection", "h264ptsession", "h204_config", "h264ptdata", "h264_params", "h323_default", "h2645window", "h64_data", "h264acsettings", "h544_Data", "h264ptdetails", "h264_DATA", "h544_settings", "h544_data", "h264ptoptions", "h26467data", "happyptdata", "h204_data", "h264ptnot", "h64_cache", "hutil_not", "h264acstatus", "h26467connection", "h323ptdefault", "h264_settings", "h264_details", "h264acdata", "h544_params", "h264ptDATA", "h264_ata", "h264_not"], "attr": ["rib", "data", "cmp", "tp", "acc", "wr", "urg", "adr", "apt", "typ", "tt", "rr", "rt", "priv", "op", "tag", "tr", "var", "reg", "elt", "imm", "cmd", "pkg", "spr", "adj", "key", "req", "p", "str", "dev", "eas", "wcs", "rm", "adv", "perm", "att", "addr", "tk", "atts", "pr", "stat", "ptr", "msg", "attribute", "prop", "vr", "err", "ctx"], "value": ["command", "vp", "range", "val", "message", "b", "tree", "image", "what", "unknown", "function", "queue", "values", "byte", "position", "button", "input", "now", "type", "attribute", "entry", "set", "output", "result", "json", "example", "process", "python", "vector", "total", "version", "pack", "array", "package", "ue", "field", "pair", "length", "all", "raw", "data", "pre", "get", "parent", "initial", "tag", "see", "description", "null", "current", "new", "this", "comment", "operator", "always", "option", "unit", "try", "document", "expression", "media", "widget", "test", "VALUE", "v", "cache", "variable", "text", "server", "feature", "node", "content", "valid", "block", "key", "padding", "code", "format", "name", "list", "element", "up", "bo", "size", "rule", "Value", "property", "label", "word", "batch", "hello", "password"], "codec": ["libec", "codeeco", "codener", "Codisc", "cmdc", "codoc", "Codocol", "chocol", " codisc", "odoc", "codac", "chisc", "codisc", "codc", "libeca", "odisc", "codeco", "modec", "Codoe", "chec", "Codac", "odc", "cateco", "cmdec", "catEC", " codener", " codiac", "codect", "codeEC", "odstream", "codstream", "codeeca", "odac", "Codeca", "codef", "codeca", "catec", "Codef", "Coderer", " codoc", "coder", "codender", "modeco", "Cododer", "Codstream", "cdstream", "codeec", " codef", "Codener", "Codc", " codender", " codocol", "mododer", "codeerer", "cdec", "CodEC", "cmdEC", "Codiac", "codoe", "chef", "liberer", "codeoe", "odEC", "modEC", "Codec", "coderer", "liboe", "cdac", "cec", "cododer", "codEC", "cEC", "chEC", "modect", "cmdisc", "codeiac", "catect", "codiac", "codocol", "odec", "Codoc", "cdoc", "codeect", "modener", " codEC", "cener", "choc", "chener", "codeender", "Codender"], "buffer": ["limit", "command", "cache", "bridge", "result", "face", "profile", "page", "db", "iter", "server", "bar", "length", "filter", "history", "print", "store", "buff", "message", "b", "append", "database", "block", "sequence", "save", "vector", "comment", "stack", "match", "template", "seek", "password", "function", "header", "queue", "stage", "absolute", "table", "paste", "window", "base", "package", "phrase", "bo", "sync", "trace", "Buffer", "memory", "screen", "button", "row", "document", "buf", "batch", "callback", "empty", "texture", "temp", "entry", "commit", "variable"], "profile_idc": ["profile_trycd", "profile__idsh", "profileListadac", "profile_idn", "profileListadc", "profile_idem", "profile__idc", "profile_idx", "profile_ideC", "profileListidc", "profile_aidc", "profile__idci", "profile_idemc", "profile_idsco", "profile_inh", "profile_sourcel", "profile_nameh", "profile_idedc", "profileListidn", "profile_idac", "profile_idemx", "profile__idco", "profile_aidx", "profile_ideac", "profile_mainn", "profile_idemcd", "profile_Idc", "profile_inc", "profile_idco", "profile_inl", "profile_idel", "profile_adc", "profile_IDci", "profile_tryco", "profile_idl", "profileListadm", "profile_idemco", "profile__idl", "profile_adn", "profile_mainc", "profile_IDx", "profile_idci", "profile_sourcedc", "profile_idsc", "profile_inci", "profile__idx", "profile_adac", "profile_mainm", "profile_idsx", "profile_iddc", "profileListidac", "profile_tryc", "profileListadn", "profile_aidci", "profile_idm", "profile_IDa", "profile_sourceC", "profile__idsci", "profile_nameci", "profile_aida", "profile__idsco", "profile_namec", "profile_idsdc", "profile_idcd", "profile_idsl", "profile_Ida", "profile_Idx", "profile__idh", "profile__idsl", "profile_iden", "profile_idC", "profile_ida", "profile_mainac", "profile_namel", "profile_sourcec", "profile_idsh", "profileListidm", "profile__idsx", "profile_idec", "profile__idsc", "profile_idh", "profile_adm", "profile__idscd", "profile_tryx", "profile_idsC", "profile_idscd", "profile_IDc", "profile_Idci", "profile__idcd", "profile_idsci"], "profile_iop": ["profile_iov", "history_orp", "result_orp", "person_ival", "volume_wikipedia", "profile_op", "profileAccessorp", "person_iop", "prof_ios", "prof_iov", "history_iov", "profile_ep", "history_iop", "profile_iot", "profile_ip", "profile2iop", "profileAccessiop", "result_iop", "profiletwikipedia", "profile_ios", "result_iot", "profile2orp", "person_osp", "prof_iop", "profiletiop", "profiletios", "history_iot", "profile2iov", "volume_istor", "result_op", "profileAccessiot", "profile_istor", "profile_wikipedia", "prof_ep", "volume_ios", "volume_iop", "profile2iot", "profiletistor", "person_ip", "profile_osp", "profile_orp", "profileAccessiov", "profile_ival"], "level_idc": ["level_pyl", "level_idtc", "level__idc", "level_Idtc", "level__idep", "level_sidci", "level_idec", "level_idsl", "level_ipcu", "level_oidc", "level_identtc", "level_Ide", "level_numci", "level_Idp", "level_idl", "level__idp", "level_idsdc", "level_ipC", "level_Idcu", "level_Idc", "level_ide", "level_sidC", "level_hideci", "level_iql", "level_oidC", "level_iqc", "level_idsc", "level_idetc", "level_sidc", "level_pyc", "level_numc", "level_identC", "level_identc", "level_numlc", "level_ipc", "level_ipe", "level_idsa", "level_idsx", "level_showe", "level_oidci", "level_idci", "level_idsci", "level__idC", "level_idlc", "level_pyci", "level_hidel", "level_oidlc", "level_showC", "level_iddc", "level__ideC", "level_idep", "level_ida", "level_numC", "level_idcu", "level_hidedc", "level_showc", "level_idC", "level_sidlc", "level_identp", "level_showcu", "level_IdC", "level_idp", "level__idetc", "level_idx", "level_hidec", "level_iqx", "level__idec", "level_pydc", "level__idtc", "level_ideC", "level_iqa"], "base64packet": ["base64picketer", "base32packET", "base32octet", "base32packets", "base64Packacket", "base64pickacket", "base32packetter", "base64packeter", "base32pickets", "base64picket", "base64Packeter", "base32octets", "base64octetter", "base32packacket", "base64Packet", "base64mixetter", "base64pickets", "base64mixET", "base32octET", "base64compET", "base64octet", "base64octET", "base64mixets", "base64octets", "base64packET", "base32octetter", "base32picket", "base64Packets", "base64bucket", "base32pickacket", "base64compets", "base64competter", "base64buckets", "base32picketer", "base32packeter", "base64buckacket", "base64mixet", "base64bucketer", "base64compet", "base64packetter", "base64packacket", "base64packets", "base32packet"], "decoded_packet": ["decoded_payer", "decoded_octets", "decoded_payets", "decoded_payacket", "decoded_packsets", "decoded_packer", "decoded_packset", "decoded_packser", "decoded_payet", "decoded_octer", "decoded_packets", "decoded_packsacket", "decoded_packacket", "decoded_octet", "decoded_octacket"], "packet_size": ["packets_size", "packets_count", "packets_length", "packet_length", "packet_SIZE", "packet_count", "packets_SIZE"], "dst": ["rbl", "_", "cmp", "rst", "dbl", "desst", "fstr", "descr", "dstr", "cmd", "fst", "rstr", "desstr", "fcr", "dcr", "def", "cont", "fbl", "rcr", "desbl", "of", "raw"]}}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388, "substitutes": {"filename": ["n", "subject", "Filename", "ename", "txt", "fil", "file", "fs", "source", "family", "f", "kl", "directory", "kj", "description", "journal", "fn", "username", "names", "path", "FIL", "metadata", "p", "buffer", "format", "name", "title", "prefix", "size", "ln", "fp", "location", "stem", "nil", "nm", "ames", "jpg", "ame", "buf", "stat", "files", "length", "FN"], "total_size": ["total_name", "Total_Size", "totalmodname", "Total_name", "total_mem", "Total_mem", "totalmodSize", "total_Size", "Total_size", "totalmodmem", "totalmodsize"], "backing_file": ["backingetybuffer", "backingetyformat", "backing_data", "backding_file", "backding_format", "backing_buffer", "backding_data", "backding_buffer", "backingetydata", "backingetyfile"], "backing_format": ["backoring_type", "backing__file", "backoring__data", "backing_data", "backoring_file", "backoring__format", "backing_type", "backing__type", "backoring__file", "backing__format", "backoring_data", "backoring_format", "backing__data", "backoring__type"], "flags": ["versions", "tags", "magic", "args", "bits", "settings", "fields", "mode", "params", "mask", "fs", "details", "kind", "actions", "weights", "ants", "headers", "ops", "FLAG", "comments", "status", "format", "features", "properties", "heads", "locks", "links", "flag", "Flags", "stats", "types", "missions", "ags"], "cluster_size": ["cluster_length", "cluster_Size", "clusters_length", "cluster2size", "closer_name", "closer2name", "cluster2Size", "closer2Size", "clusters_size", "closer_SIZE", "closer2SIZE", "clusters_count", "cluster2SIZE", "closer2size", "closer_Size", "cluster_name", "closer_size", "cluster2name", "clusters_SIZE", "cluster_SIZE", "cluster_count"], "prealloc": ["prepavailable", "prepfree", "Prealloc", "Prefree", "preproc", "autoproc", "prepproc", "autoalloc", "prefree", "Preproc", "Preavailable", "autoavailable", "prepalloc", "autofree", "preavailable"], "options": ["abilities", "versions", "tags", "vals", "args", "settings", "bits", "errors", "currency", "opt", "params", "details", "config", "actions", "weights", "optional", "ts", "headers", "ops", "offs", "parts", "info", "spec", "objects", "styles", "Options", "sections", "name", "features", "outs", "properties", "values", "oops", "wcs", "option", "stats", "phones", "types", "caps", "length"], "version": ["versions", "magic", "software", "v", "bits", "command", "Version", "currency", "usage", "feature", "power", "mode", "family", "vision", "level", "tag", "description", "program", "vers", "spec", "VER", "serial", "sequence", "release", "hash", "time", "status", "format", "name", "features", "style", "number", "depth", "package", "generation", "option", "size", "flag", "value", "section", "sector", "direction", "type", "VERSION", "date", "ver", "interface"], "errp": ["errpb", " errping", "rrping", " errpb", "errorP", " errP", "errping", "rrpb", "erp", "errorp", "erP", "errP", "erpb", "rrp", "errorping", "errorpb", "rrP"], "cluster_bits": ["cluster___size", "cluster_length", "cluster_bs", "cluster2bs", "cluster2size", "clique___locks", "cluster___ops", "cluster_changes", "clique_locks", "clust_changes", "clusterPstates", "clique___bits", "clutter___size", "cluster_plugins", "cluster_parts", "clique_obs", "clocker_ops", "clusterablebits", "cluster_jobs", "clust_size", "clusterableobs", "cluster_codes", "clique_bits", "clutter___bits", "cluster_its", "clutter_size", "clutter___bit", "clusterPlocks", "clique___obs", "clutter_bit", "cluster___plugins", "cluster_locks", "clusteritycodes", "cluster___parts", "cluster_pieces", "clocker___bits", "cluster___changes", "clutter_bits", "cluster_ops", "clocker___ops", "cluster_tops", "cluster___bits", "clusterablelocks", "cluster_obs", "clocker_parts", "cluster_states", "clutter___pieces", "cluster_bit", "clust_length", "clique_states", "clusteritylength", "clusterPobs", "clusterPbits", "cluster___states", "clust_codes", "clust_plugins", "clique___states", "cluster___obs", "clusteritybits", "cluster___bit", "cluster2bits", "clutter_pieces", "clocker_bits", "cluster___locks", "cluster___pieces", "cluster2tops", "clusterablestates", "clocker___parts", "clusteritysize", "clust_bits"], "bs": ["BS", "bits", "bas", "ks", "bis", "js", "gs", "bp", "bf", "obs", "fs", "ns", "ubs", "ps", "ts", "qs", "uts", "bos", "bc", "cs", "bl", "sb", "bh", "ds", "bb", "ls", "bd", "os", "bn", "cks", "rs", "bm", "vs", "sys", "lbs", "aos", "br", "its", "pb", "bt", "bi"], "header": ["profile", "lp", "Header", "txt", "file", "protected", "tree", "writer", "line", "HEAD", "window", "position", "pr", "attribute", "term", "entry", "owner", "er", "offset", "history", "filter", "client", "peer", "policy", "body", "journal", "address", "wrapper", "handler", "response", "package", "part", "section", "drm", "module", "layout", "handle", "data", "master", "channel", "parent", "layer", "tr", "event", "description", "heading", "null", "fn", "spec", "comment", "component", "buffer", "definition", "table", "title", "error", "summary", "dr", "row", "document", "head", "index", "magic", "xml", "cache", "fr", "member", "primary", "content", "detail", "headers", "block", "public", "padding", "metadata", "name", "number", "list", "h", "hd", "tar"], "refcount_table": ["refcount_cache", "refcountsdata", "refcache_TABLE", "refcount_data", "refcache_data", "refcount_TABLE", "refcache_cache", "refcountstable", "refcache_table", "refcountsTABLE", "refcountscache"], "local_err": ["local____error", "local__buf", "local__rr", "local_r", "local_error", "local____err", "local____notice", " local_error", "global_err", "local__err", " local_notice", " local_buf", "local_rr", "local__r", "local_notice", "local_buf", " local_rr", "local2buf", "global_buf", "local2er", "local2err", " local_r", "local_er", "global_er"], "ret": ["nl", "val", "after", "mel", "reset", "elt", "cmd", "dt", "len", "ref", "status", "arg", "att", "def", " RET", "ber", "alt", "nt", "rem", "ure", "result", "gc", "ne", "det", " Ret", "usr", "arr", "cat", "pat", "ft", "Ret", "inter", "pret", "not", "RET", "back", "re", "desc", "rest", "lit", "final", "del", " alt", "get", "ort", "ll", "print", "rt", "rets", "tr", "ry", "mt", "try", "resp", "cont", "sys", "eval", "plain", "url", "res", "ter", "ext", "reg", "t", "gt", "rm", "gov", "br", "err", "rect"]}}
{"project": "FFmpeg", "commit_id": "3dea28cc2ef22861347918b6740c4c05c46a6614", "target": 0, "func": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= -1;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb= 1<<16;\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n", "idx": 26390, "substitutes": {"h": ["ih", "ph", "v", "hs", "cache", "k", "conn", "gc", "th", "history", "host", "hm", "f", "mem", "go", "hl", "event", "H", "b", "z", "he", "info", "pp", "hh", "html", "oh", "sh", "eh", "kh", "uh", "el", "hash", "p", "hw", "bh", "m", "comm", "en", "hist", "ah", "dh", "g", "header", "q", "rh", "here", "hz", "hp", "hd", "dr", "help", "l", "j", "ht", "c", "temp", "it", "ch", "w"], "i": ["qi", "gu", " j", "is", "iq", " c", "bi", " I", " err", "yi", "iter", "ind", "me", "li", "in", " ni", " pos", "ij", " iter", "f", "ix", "xi", "ri", "ai", "mu", "ini", "gi", "ci", "uni", "ki", " multi", "di", "ii", "t", "mi", " bi", "ei", " m", "sim", " vi", "m", "p", "ims", "multi", "chain", "cli", "ui", " p", " ii", "q", "pi", " mi", " l", "iu", "PI", "span", " pi", " ti", " index", "ti", "zi", "phi", "batch", "x", "index", "j", "y", "it", "si", "asi", " si", "I"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n", "idx": 26396, "substitutes": {"opaque": ["ropaques", " opque", "obque", "obaque", " opaques", "ropque", "opsiera", "boaque", " opiera", "opaques", "opsaques", " opasus", "ropasus", "ropaque", "boasus", "obaques", "boaques", "opiera", "boque", "opsaque", "opasus", "opque", "opsque", "obiera"], "addr": ["Address", "work", "adr", "offset", "host", "src", "arp", "rt", "ar", "tx", "tr", "ack", "loc", "r", "trans", "cmd", "attr", "address", "at", "act", "coord", "ref", "add", "hw", "pad", "dh", "inter", " address", "id", "ad", "rs", "eth", "dr", "now", "oad", "handle", "ord", "pos", "x", "ptr", "alloc", "err"], "val": [" value", " cal", " pref", "v", " bl", "abl", "vals", "data", "pol", "ctx", "serv", "valid", "it", "mem", "ret", " valid", "tx", "loc", "VAL", "bit", "aval", "state", " update", "sol", "Val", "ival", " seq", "al", " weight", "vt", "ref", " lac", "sel", "p", " vol", " tx", " v", " ty", " msg", "value", "vol", " al", "buf", "pos", "rol", " eval", " slot", "lit"], "d": ["dm", "n", "dn", "dd", "db", "f", "dict", "r", "b", "dq", "di", "dc", "t", "draw", "o", "D", "sd", "p", "dat", "fd", "g", "ds", "da", "pd", "e", "debug", "bd", "cal", "ad", "od", "h", "ld", "dr", "de", "ade", "done", "j", "c", "dra", "m", "ind", "w"], "reg": ["ig", "rem", "res", "rec", "db", "red", "gr", "rr", "repl", "rt", "mem", "ret", "tr", "loc", "r", "rg", "ref", "Reg", "g", "ress", "rel", "rar", "rm", "region", "REG", "br", "map", "re", "eg", "rol", "disc", "ptr", "ro", "mb"]}}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void abort_codec_experimental(AVCodec *c, int encoder)\n\n{\n\n    const char *codec_string = encoder ? \"encoder\" : \"decoder\";\n\n    AVCodec *codec;\n\n    av_log(NULL, AV_LOG_FATAL, \"%s '%s' is experimental and might produce bad \"\n\n            \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",\n\n            codec_string, c->name);\n\n    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);\n\n    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n\n        av_log(NULL, AV_LOG_FATAL, \"Or use the non experimental %s '%s'.\\n\",\n\n               codec_string, codec->name);\n\n    exit(1);\n\n}\n", "idx": 26428, "substitutes": {"c": ["v", "cv", "pc", "cl", "n", "cmp", "gc", "co", "anc", "f", "ce", "lc", "b", "mc", "fc", "bc", "t", "cs", "cu", "cod", "ac", "w", "ec", "coll", "p", "comm", "e", "g", "cc", "com", "ct", "cp", "wcs", "enc", "C", "con", "h", "rc", "l", "cont", "conf", "tc", "vc", "cand", "etc", "abc", "ch", "ctx"], "encoder": ["ecoder", " encode", "ecoding", "ecancer", "encoded", "ecuter", "ecoded", "ecode", " encater", "decoded", " encuter", " encator", "encancer", " encancer", "decater", "octoding", " encoded", "octoded", "octater", "decode", "decator", "decancer", "octoder", "encator", "decoder", "encuter", "ecator", "encoding", "decuter", "encater", "decoding", " encoding", "encode"], "codec_string": ["codoc_String", "codoc_prefix", "codec___string", "codisc_string", "codec_String", "codec___strip", "codisc_strip", "codec_prefix", "codoc_str", "codoc_string", "codec_strings", "codec_strip", "codisc_str", "codoc_ring", "codec_str", "codec___str", "codoc_strings", "codec_ring"], "codec": ["cosec", "Codef", " codep", "odef", " codoc", "Codex", "Codoe", "Codisc", " codesc", "staesc", "codoc", "cosisc", "staex", "codEC", " codef", "staec", " codoe", "cdep", "Codep", " codisc", "odoc", "odec", "Codoc", "codex", "cdoc", "codisc", "cdec", "CodEC", " codEC", "codoe", "cosep", "codesc", "cosEC", "cdef", "staEC", "odep", "Codec", " codex", "Codesc", "cdoe", "codep", "codef"]}}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}", "idx": 26435, "substitutes": {"c": ["v", "cache", "f", "b", "lc", "ci", "fc", "t", "cs", "dc", "w", "ac", "p", "m", "e", "g", "cc", "d", "ct", "u", "a", "sc", "C", "h", "s", "tc", "x", "ctx"], "dst": [" dput", "dsput", "dsts", "ldput", " dsrc", "dsst", "dssts", "dsdest", "ddest", " dsts", "Dsrc", "dST", " dST", "ldST", "Dsts", "Dput", "DST", "dput", " ddest", "Dst", "ldst", "Ddest", "ldsrc", "dsrc"], "dstWidth": [" dstLen", "destHeight", "dstwidth", "dstW", "dstLen", " dblLen", "dbrWidth", "DestHeight", "drcWidth", "DstW", "dstPath", " dstwidth", "destWidth", "drcLen", "dbrHeight", "DstWidth", "drcPath", "destPath", "destW", "drcHeight", "DestPath", "dsrcW", "DestWidth", " dblwidth", "dsrcWidth", "dblwidth", " dblWidth", "dblWidth", "drcwidth", "DestW", "dbrW", "dblLen", " dstW", "DstPath", "drcW", "DstHeight", "dsrcLen", "dstHeight", " dblW", "dsrcwidth", "dbrPath", "dblW"], "src": ["dest", "sr", "in", "ser", "iter", "txt", "source", "aux", "rt", "stock", "inst", "rl", "seq", "loc", "r", "b", "supp", "usr", "pkg", "iv", "RC", "sec", "bin", "req", "sb", "ins", "secure", "str", "copy", "sub", "sl", "cc", "sup", "pack", "sur", "syn", "sync", "rs", "sc", "cur", "img", "rc", "st", "s", "cont", "input", "bs", "usc", "desc", "proc", "sn", "sq", "raw"], "srcW": ["srcWeight", "srcLength", " srcWeight", "rcLength", "sourceWidth", " srcLength", "rcW", "sourceWeight", "rcWidth", "srcWidth", " srcWidth", "sourceW", "sourceLength", "rcWeight"], "xInc": ["xyinc", " xIncre", " xCond", "exInc", "exIncre", "xyInc", " xinc", "XInc", "xCond", "xinc", "exinc", "XCond", "XIncre", "xyCond", "exINC", "XINC", " xINC", "xyINC", "Xinc", "xINC", "xIncre"], "i": ["qi", "v", "asi", "is", "iq", " Xi", " I", "iter", "li", "ij", " iter", " li", "f", "ix", "xi", "ai", "ini", "b", "gi", "ci", "z", "r", "ki", " multi", "di", "ii", "oi", "mi", "ip", " bi", "ei", "sim", "ims", "m", "multi", "ic", "ri", "p", "e", "ui", " ii", "pi", "id", " mi", " di", "im", "iu", "l", "ski", "span", " pi", " ti", "ti", "zi", "phi", "j", "x", "batch", "index", "y", "it", "si", "bi", "ind", " my", "I"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_i_mbs(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    MpegEncContext *s = &v->s;\n\n    int current_mb = 0; /* MB/Block Position info */\n\n    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,\n\n        *p_cbpcy /* Pointer to skip some math */;\n\n\n\n    /* Reset CBPCY predictors */\n\n    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n\n\n\n    /* Select ttmb table depending on pq */\n\n    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];\n\n    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];\n\n    else v->ttmb_vlc = &vc9_ttmb_vlc[2];\n\n\n\n    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)\n\n    {\n\n        /* Init CBPCY for line */\n\n        *((uint32_t*)previous_cbpcy) = 0x00000000;\n\n        p_cbpcy = v->previous_line_cbpcy+4;\n\n\n\n        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)\n\n        {\n\n            /* Get CBPCY */\n\n            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);\n\n\n\n            s->ac_pred = get_bits(gb, 1);\n\n\n\n            /* TODO: Decode blocks from that mb wrt cbpcy */\n\n\n\n            /* Update for next block */\n\n#if TRACE > 2\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,\"\n\n                   \" cbpcy=%i%i%i%i\\n\", current_mb,\n\n                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],\n\n                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],\n\n                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);\n\n#endif\n\n            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);\n\n            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);\n\n            current_mb++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26437, "substitutes": {"v": ["sv", "rev", "cv", "vp", "n", "ve", "video", "qv", "va", "uv", "f", "vm", "message", "b", "r", "env", "um", "lv", "vv", "iv", "tv", "t", "vt", "conv", "version", "o", "p", "m", "e", "dev", "g", "view", "nv", "q", "ed", "ev", "value", "V", "h", "vs", "l", "us", "av", "ver", "vc", "i", "j", "c", "x", "inv", "wire", "ov", "y", "vi", "vr", "w"], "gb": ["gif", "sv", "cv", "gs", "gc", "db", "Gb", "ctx", "bf", "uv", "bg", "gd", "cb", "tg", "rb", "vd", "hub", "pg", "gm", "uf", "sb", "gt", "g", "ds", "bb", "py", "bd", "nb", "bn", "fb", "sg", "bm", "kb", "img", "bs", "vg", "gg", "wb", "GB", "gz", "buf", "pb", "cm", "bt", "cfg", "csv", "mb"], "s": ["sv", "sis", "gs", "ms", "ses", "changes", "services", "details", "b", "parts", "ops", "p", "sd", "ls", "rs", "sc", "as", "us", "als", "i", "sports", "c", "mys", "ps", "csv", "n", "bis", "fs", "ns", "states", "ts", "se", "south", "less", "sh", "sb", "ins", "d", "os", "a", "es", "vs", "st", "ys", "stats", "sts", "ctx", "settings", "hs", "is", "f", "ss", "spec", "cs", "ats", "conv", "m", "ds", "l", "sys", "j", "sn", "sq", "js", "S", "qs", "t", "ims", "o", "g", "tests", "ows", "sw", "q", "sg", "h", "bs", "its", "x"], "cbpcy": ["cbpcsty", "rbpcvy", "cbcply", "bufpcy", "nbcpyr", "cbfsty", "rbpmy", "cbphpoway", "cbpcwy", "callbackfmy", "bufpyr", "cbpyr", "corephpce", "nbcpcy", "cbjpsty", "rbpccy", "cbphpce", "cbpcin", "cbfcy", "cbpmy", "cbnpcy", "cbpby", "cbpwy", "cbpointcin", "cbpccu", "callbackfky", "cbpsty", "nbpcy", "cbphpyth", "bufappcu", "rbpcy", "nbcpby", "cbpcky", "cbnpyth", "cbappyr", "cbnpce", "cbpointmy", "cbpcyr", "cbappcu", "corephpoway", "cbpccy", "nbpyr", "cbphply", "cbpncy", "rbpccin", "cbphpcy", "corephpyth", "nbpby", "cbcpyr", "bufappcy", "cbpccin", "rbpcmy", "nbply", "callbackpcy", "corepyth", "cbppyr", "cbpyth", "callbackfsty", "cbpply", "cbjpky", "callbackpky", "cbpcu", "cbpce", "rbpvy", "cbpnyth", "rbpcin", "corepcy", "cbpagecy", "cbppby", "cbpointcy", "nbcply", "corepce", "cbppwy", "cbfky", "callbackfcy", "cbpoway", "cbply", "cbpcmy", "cbphpby", "cbpagevy", "cbcpcy", "cbpointvy", "callbackpmy", "cbphpyr", "cbnpoway", "cbpagecin", "cbppcu", "cbppcy", "cbpcvy", "corephpcy", "bufappwy", "cbpky", "bufpwy", "cbjpmy", "bufappyr", "cbpnoway", "cbjpcy", "cbcpby", "cbpagemy", "cbappwy", "corepoway", "cbpnce", "cbfmy", "cbpvy", "callbackpsty", "cbappcy", "bufpcu"], "previous_cbpcy": ["previous_cbpody", "previous_gobpintry", "previous_cbnpcr", "previous_cbparyr", "previous_cbnpwy", "previous_cbpsy", "previous_cbwpsty", "previous_bcpcre", "previous_cbpincy", "previous_cbpy", "previous_cfgpyr", "previous_gobpinyth", "previous_cbnpcy", "previous_cfgpsct", "previous_cbcpcr", "previous_cbpayth", "previous_cbcly", "previous_cbwpcy", "previous_cbpintry", "previous_sbply", "previous_bcbcre", "previous_cbbcy", "previous_cbparck", "previous_abbpsty", "previous_debparyr", "previous_cbtpsty", "previous_cbtpy", "previous_debparcy", "previous_cbperwy", "previous_bcpck", "previous_cbpatry", "previous_cbparty", "previous_cbnply", "previous_gobpyth", "previous_gobpcre", "previous_sbpce", "previous_cbtpcy", "previous_cbbcre", "previous_cbcpcy", "previous_cbpscy", "previous_bcbck", "previous_cbply", "previous_cbpwy", "previous_cbcply", "previous_cbperct", "previous_cbpct", "previous_cbparwy", "previous_cbpck", "previous_debparsty", "previous_gobptry", "previous_cbpacre", "previous_cfgpscy", "previous_cbcce", "previous_cbpincre", "previous_cbtpody", "previous_cbpreyr", "previous_abbpsody", "previous_abbpcy", "previous_cbpresty", "previous_cfgpct", "previous_sbcpcr", "previous_cbnpce", "previous_cbwpyr", "previous_bcbwy", "previous_gobpcy", "previous_sbpcr", "previous_cbpsody", "previous_abbpsy", "previous_cbprecy", "previous_cbwpcre", "previous_gobpincre", "previous_bcbcy", "previous_cbccr", "previous_cbpyth", "previous_abbpody", "previous_cbparcre", "previous_abbpssty", "previous_abbpy", "previous_debpyr", "previous_cbptry", "previous_debpcre", "previous_cbpcre", "previous_cbpartody", "previous_cbpsyr", "previous_cbpsty", "previous_cbpartcy", "previous_debpcy", "previous_cbprecre", "previous_bcpcy", "previous_debparcre", "previous_cbpinyth", "previous_sbcpce", "previous_cfgpcy", "previous_debpsty", "previous_sbpcy", "previous_cbcpce", "previous_sbcpcy", "previous_cbparsty", "previous_cbbwy", "previous_cbpssty", "previous_cbprewy", "previous_sbcply", "previous_abbpscy", "previous_cbpacy", "previous_cfgpsyr", "previous_cbnpck", "previous_cbccy", "previous_cbpcr", "previous_cbperyr", "previous_cbpyr", "previous_cbnpcre", "previous_cbpsct", "previous_cbpswy", "previous_cfgpswy", "previous_cfgpwy", "previous_cbbck", "previous_bcpwy", "previous_cbpce", "previous_cbpercy", "previous_gobpincy", "previous_cbpartsty", "previous_cbprect", "previous_cbparcy"], "predicted_cbpcy": ["predicted_cbccry", "predicted_curpyr", "predicted_cbphpwy", "predicted_cbphpyr", "predicted_cbfpyr", "predicted_cbcyr", "predicted_cbpcry", "predicted_curphpwy", "predicted_curpcry", "predicted_cbpwy", "predicted_cbccy", "predicted_curphpcry", "predicted_curpcy", "predicted_cbpyr", "predicted_cbphpcry", "predicted_cbfpcy", "predicted_cbfpwy", "predicted_cbfpcry", "predicted_cbphpcy", "predicted_curphpcy", "predicted_curphpyr", "predicted_curpwy", "predicted_cbcwy"], "p_cbpcy": ["p_cbpingyr", "p_cbpade", "p_cblpci", "p_rbpcy", "p_wblpcy", "p_cbPocy", "p_gbcptry", "p_cbpccr", "p_cbpingcr", "p_cinhsty", "p_cbhocy", "p_bbpccr", "p_gbpsty", "p_cbopcy", "p_cblpty", "p_cbpcny", "p_cbpdry", "p_cbpctry", "p_cbpatry", "p_wbpcy", "p_rbcpzy", "p_cbpingry", "p_cinhde", "p_cbpsy", "p_cbpsyr", "p_cbcpzy", "p_cvmci", "p_gbcpsty", "p_CBPry", "p_wblpyr", "p_bbpccy", "p_cvcpcy", "p_gbpcu", "p_cbccy", "p_cblpocy", "p_cbgyr", "p_cbjptry", "p_cbpaocy", "p_cbghey", "p_cbpchey", "p_CBpcy", "p_cvcpsty", "p_cbhcy", "p_cvcpny", "p_cbpty", "p_cvpmy", "p_bbphey", "p_cbhsty", "p_cbcocy", "p_cbgcy", "p_cvptry", "p_cbpdcy", "p_cvpny", "p_cbpccy", "p_cbpcsty", "p_cbpde", "p_cvmcy", "p_rbcpcy", "p_cinhocy", "p_cbpingocy", "p_cbjpcy", "p_cbgcr", "p_cblpyr", "p_wbpty", "p_cinpsty", "p_cbpmy", "p_bbpcy", "p_cbPry", "p_cbcpry", "p_rbpzy", "p_cbpingsy", "p_cbctry", "p_cbpasty", "p_cbpci", "p_cbcsty", "p_cinpde", "p_cbpsty", "p_cbpczy", "p_wblpty", "p_cblpsy", "p_gbpcy", "p_cinpocy", "p_wbpci", "p_cbcpsty", "p_bbpcyr", "p_cblpry", "p_cvpcy", "p_cbpsci", "p_cbpcry", "p_cbpyr", "p_bbpyr", "p_cbpacy", "p_cbpcu", "p_cbpdzy", "p_rbcpry", "p_cinhcy", "p_gbcpcy", "p_cbcpmy", "p_cbhde", "p_cbpzy", "p_cvmmy", "p_cbpscy", "p_cvpsty", "p_cbcpci", "p_cbjpsty", "p_wbpyr", "p_cbcde", "p_cblpcy", "p_cbopyr", "p_cbpcyr", "p_cbcpcy", "p_CBpsy", "p_cbpny", "p_CBpocy", "p_cbpinghey", "p_CBPsy", "p_cbPcy", "p_cbpry", "p_gbptry", "p_cbphey", "p_gbcpcu", "p_cbopci", "p_CBpry", "p_cbpany", "p_cbmmy", "p_cbPsy", "p_wblpci", "p_cbpcr", "p_cbcptry", "p_cbmci", "p_cbmcy", "p_cbptry", "p_cbopty", "p_rbpry", "p_cbccu", "p_CBPocy", "p_cbcpny", "p_cbjpcu", "p_CBPcy", "p_bbpchey", "p_cbcpcu", "p_bbpcr", "p_cvpci", "p_cvcptry", "p_cbpocy", "p_cblpmy", "p_cinpcy", "p_cbpingcy"], "mb_y": ["bb_x", "bb__y", "MB_y", "mb__y", "mbtimex", "bb__yy", "bb__ey", "mb__ey", "MB_x", "bb_y", "bb__ye", "mb_ey", "bb_yy", "MB_j", "mb_my", "mbtimemy", "MB_yy", "mb_j", "mb__ye", "mbtimeey", "mbtimey", "bb_ye", "bb_my", "mb_ye", "bb_ey", "mb_yy", "mb__yy"], "mb_x": ["mb_el", "mb_inner", "mp__xy", "mb__y", "ib_wx", "mb__inner", "mgpoy", "mp_ex", "mb_xy", "mbpoinner", "mbpoex", "mg_x", "mp__x", "ib_y", "mp_y", "mp_x", "mg_inner", "mbpox", "mp_xy", "mgpox", "mp__y", "mb__x", "mbpoy", "mb__xy", "mg_ex", "mb_wx", "ib_x", "mgpoex", "mb_ex", "mgpoinner", "ib_el", "mp__ex", "mg_y", "mb__ex"], "current_mb": [" current_bound", "current2MB", " current_ob", "current_mp", "current2mt", " current_mp", " current2mb", "current2bound", "current_ob", " current_MB", " current2bound", " current_mt", "current_MB", "current_mt", "current2mb", " current2MB", " current2mt", "current_bound"]}}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443, "substitutes": {"dev": ["Device", "nt", "dm", "v", "obj", "ve", "md", "usb", "dd", "cam", "db", "ctx", "DEV", "devices", "disk", "priv", "hid", "mem", "go", "tr", "var", "dem", "sd", "hw", "p", "pad", "g", "device", "ds", "Dev", "d", "window", "ev", "ad", "adv", "app", "des", "de", "sys", "home", "proc", "dis", "ver", "w"], "s": ["sv", "v", "hs", "is", "n", "gs", "js", "ms", "ses", "services", "sam", "S", "fs", "sp", "ns", "f", "ss", "b", "r", "ts", "qs", "has", "sol", "state", "spec", "t", "cs", "less", "sb", "ins", "p", "comm", "m", "e", "aws", "ds", "g", "out", "ls", "d", "q", "os", "a", "rs", "h", "l", "sys", "as", "als", "sts", "y", "bs", "i", "j", "c", "sq", "ps", "sm", "w"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 26451, "substitutes": {"ctrl": ["acl", "cv", "bitcoin", "cmp", "cl", "control", "co", "exec", "Controller", "history", "Ctrl", "jp", "aux", "config", "rl", "tr", "cb", "cr", "lc", "rb", "Control", "nc", "fc", "manager", "cmd", "attr", "ctl", "req", " cur", "compl", "comm", "forge", "cfg", "tab", "cc", "cf", "ach", "controller", "ls", "ct", "cp", "rh", "trl", "cur", "rc", "ctr", "cont", "addr", "cap", "cm", "ptr", "tl", "ch", "ctx"], "c": ["v", "ca", "cache", "cl", "k", "n", "cv", "gc", "co", "cmp", "ctx", "cd", "f", " cc", "cb", "cr", "lc", "r", "ci", "b", "ce", "fc", "mc", "attr", "current", "t", "cs", "dc", "cu", "fac", "ac", "cat", "uc", "ec", "cn", "p", "chain", "cc", "cf", "ach", "d", "ct", "cp", "a", "id", "enc", "sc", "C", "h", " C", "rc", "con", "l", "cont", "cur", "tc", "col", " cr", "x", "cm", "unc", "nc", "ch", "w"]}}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n", "idx": 26458, "substitutes": {"s": ["sv", "gs", "ms", "ses", "changes", "services", "details", "store", "state", "parts", "ops", "p", "status", "aws", "ls", "so", "rs", "sc", "series", "conf", "als", "c", "stat", "y", "ps", "set", "w", "sa", "fs", "params", "ns", "ts", "se", "ssl", "south", "less", "sb", "ins", "os", "es", "vs", "st", "stats", "sts", "args", "ports", "settings", "hs", "is", "ss", "spec", "cs", "ats", "m", "comm", "ds", "sync", "sys", "j", "sm", "js", "eps", "S", "sp", "source", "qs", "ims", "g", "sl", "sw", "h", "service", "bs", "its", "asm", "self"], "desc": ["dest", "data", "obj", "cmp", "md", "rec", "sort", "ser", "ind", "ext", "txt", "cd", "gd", "DES", "seq", "tr", "dict", "description", "asc", "loc", "td", "cmd", "info", "dc", "sec", "comment", "cod", "dir", "req", "ec", "doc", "sd", "str", "dev", "sub", "ds", "dist", "d", " Desc", "esc", "decl", "Desc", "sc", "good", "def", "rc", "des", "cont", "de", "tmp", "buf", "pb", "cript", "disc", "ptr", "dim", "msg", "test", "ript", "err", "enc", "ctx"], "descptr": [" descpr", "descriptionaddr", " descpointer", "descriptionptr", "descpr", "descriptionPtr", "decpointer", "testptr", "depptr", "decptr", " descPtr", "scptr", "scpointer", "deprect", "Descaddr", "descoffset", " descaddr", "escrect", "descaddr", "testoffset", "descpointer", "descPtr", "decPtr", "testpointer", "testPtr", "escptr", "escaddr", "decaddress", "descaddress", "descriptionpointer", "depPtr", "escoffset", "scoffset", "escPtr", "DescPtr", "Descpointer", "escaddress", "Descptr", "deppointer", "scPtr", "escpointer", "descrect", " descaddress", "descriptionpr", " descrect", "Descpr"], "i": ["qi", "ex", " I", "any", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "p", "spin", "status", "ori", "window", "id", "io", "series", "us", "zi", "y", "bi", "ind", "I", " ki", "n", "history", "client", "gl", " li", "ci", " multi", "di", "pi", " mi", "iu", "fi", " ti", "phi", "length", "is", "me", "ij", "print", "f", "ini", "gi", "hi", "remote", "cli", "ic", "sim", "multi", "m", "chain", "ri", "rel", " ii", "\u0438", " si", "im", "l", "ski", "j", "index", "si", "iri", "v", "gu", "li", " ni", "ai", "ji", "info", "mi", "key", "ims", "o", "g", "q", "list", "uri", "err", "ti", "batch", "x", "it", "ui"]}}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468, "substitutes": {"bus": ["Bus", "book", "conn", "util", "build", "lock", "box", "state", "dir", "status", "line", "queue", "id", "kit", "vol", "us", " BUS", "home", "bolt", "interface", "usb", "host", "phys", "body", "hub", "board", "device", "bb", "os", "back", "handle", "buf", " buses", "BUS", "length", "ctx", "data", "kind", "group", "gate", "proxy", "component", "port", "bur", "controller", "ck", "sync", "sys", "target", "vc", "root", "bridge", "machine", "loop", "way", "stick", "disk", "serv", "config", "ack", "ud", "block", "hand", "bc", "boot", "mount", "route", "list", "bo", "child", "piece", "bs", "ship", "self"], "fdt": ["fftn", "peddt", "dlt", "fxtx", "pedt", "ffdt", "pedtn", "dldt", "fbdt", "fdtx", "ffT", "fdT", "fft", "fbt", "fxtd", "fdtd", "efftd", "fbtd", "pedT", "fdtn", "fxdt", "fbtx", "fddt", "efft", "fxt", "efftx", "dltn", "dlT", "effdt"], "qdev": ["qupro", "qualdebug", "qualtr", "eqdebug", "dqdev", "eqpro", "qudec", "eqdev", "qtr", "eqtr", " qde", "qde", "qdec", "sqde", "qutr", "qqdec", "dqdef", "qualdev", "qdebug", "qudev", "sqmem", "qqserv", "sqdec", "dqde", "sqserv", " qdef", "qpro", "qumem", "sqpro", "qudebug", "qserv", "quserv", " qpro", "dqpro", "sqdev", "sqdef", "qmem", "qqmem", "qdef", "qqdev", "qualpro"], "qdevs": [" qdivos", "qdatan", "qcmdp", "qdivm", "qDevos", "qdataS", "qbufos", "qqdevers", "qtdefaults", "qDevm", "QDevS", "qdevjs", "qdevS", "QdevS", "qqdevss", "qdivS", "qDevss", "aqwarnjs", "qcmders", "qdatap", "qtdefaultn", "qtdefaultS", "aqdevs", "qdefaultn", "qDevS", "qdevicesids", " qdivs", " qdivS", "Qdevjs", "qwarnjs", "qdefaults", "Qdevs", "qdevicess", "qqdefaulters", "qevS", "qdevn", "aqwarnids", "qdefaultS", "qevs", " qdevos", "qdefaultss", "qdefaultp", "qevm", "qdevm", "qDevjs", "Qdevm", "qdevids", "qtdevn", "qtdevp", "qqdevs", "qevjs", "qcmds", "qbufm", "qqdefaultss", "qdevos", "qDevers", "qdivos", "qwarnids", "aqdevids", "qdevicesjs", "qdatas", "qcmdss", "QDevs", "qtdefaultp", "QDevm", "QDevjs", " qdevm", "qbufS", "qdefaulters", "qcmdids", "qdevers", "aqdevjs", "qqdefaultS", "qcmdS", "qbufs", "qcmdn", "qDevs", "qtdevs", "qdevss", "qbufjs", "qtdevS", "qqdevS", "qcmdjs", "qwarns", " qdevS", "qqdefaults", " qdivm", "aqwarns", "qdivs", "qdevp"], "kid": [" kh", "ih", "ker", "hs", "k", "ks", "Kid", "sky", "kids", "ctx", "kok", "jp", "kl", "kind", "kj", "mk", "kt", "ki", "pid", "kk", "sid", "tek", "ko", "ijk", "sk", "kh", "kn", "wcs", "ket", "ke", "ck", "id", "kit", "ka", "kb", "hd", "king", "tk", "wk", "ik", "kw", "kr", "kg"], "i": ["qi", "gu", "n", " j", "iq", "is", "me", "ind", "li", " ni", "ij", " iter", "ix", "xi", "ai", "ini", "ji", "gi", "ci", "mc", "ki", "info", "di", "hi", "ii", "mi", " x", " bi", " m", "ic", "sim", "m", "multi", "ims", "ri", "ni", "e", "ui", "o", "my", " ii", "pi", "id", " mi", "\u0438", "im", "iu", "l", "ish", "fi", " ti", "ti", "zi", "j", "phi", "x", "index", "y", "it", "si", "bi", " si", "I"], "num": ["nt", "gen", "rem", "n", "max", "count", "hum", "alph", "ind", "final", "na", "nu", "node", "net", "common", "pl", "ret", "mod", "mn", "pn", "uni", "prim", "um", "sum", "mult", "nom", "len", "coord", "fun", "total", "add", "draw", "doc", "m", "multi", "p", "NUM", "en", "note", "off", "number", "cal", "nb", "id", "ul", "no", "snap", "mun", "perm", "con", "nm", "nn", "np", "us", "cum", "nam", "mat", "mon", "col", "index", "pos", "desc", "dim", "msg", "temp", "tim", "un", "Num", "set"], "dev": ["v", "rem", "gu", "ve", "md", "cam", "conn", "dd", "DEV", "val", "serv", "fo", "pro", "tech", "det", "pert", "wd", "var", "cmd", "dem", "sd", "cho", "device", "Dev", "d", "ev", "ad", "adv", "att", "def", "hd", "des", "de", "av", "disc", "prop", "test", "w"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472, "substitutes": {"env": ["init", "er", "v", "cv", "vp", "ve", "enter", "obj", "conn", "ten", "iter", "server", "end", "serv", "viron", "net", "outer", "uv", "context", "vm", "gear", "den", "cmd", "info", "block", "usr", "dt", "vv", "timer", "act", "eh", "shell", "req", "rod", "ec", "erd", "forge", "e", "hw", "chain", "eng", "en", "environment", "dev", "ah", "code", "org", "nv", "ew", "window", "ev", "engine", "here", "gov", "worker", "cur", "vs", "era", "addr", "ov", "desc", "buf", "proc", "msg", "exc", "entry", "ctx"]}}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n", "idx": 26480, "substitutes": {"env": ["init", "er", "v", "cv", "obj", "oe", "conn", "db", "server", "ee", "EN", "end", "Environment", "config", "context", "mem", "hl", "event", "cb", "manager", "state", "ner", "vv", "vt", "w", "shell", "ec", "sb", "erd", "e", "code", "buffer", "dev", "en", "environment", "ah", "sw", "te", "esc", "window", "ev", "ew", "worker", "ef", "engine", "here", "h", "con", "era", "pe", "conf", "open", "walker", "ov", "desc", "buf", "et", "order", "nc", "network", "neck", "ctx"], "f1": ["ft2", " f0", "for001", "uf9", "f01", "Fpre", "v0", "F1", "ft9", "for2", "fpre", "ft1", "uf01", "uf2", "f001", "F2", "v01", "f9", "F0", "for1", "f0", "v2", "F01", "F001", "ft01", " f9", "uf1", "form2", "v1", "formpre", " f01", "form001", "forpre", "form1"], "f2": ["sf02", "v02", "f02", "ftwo", "Ftwo", " f02", "uf02", "sfTwo", "F1", "float2", "vTwo", "sf2", "uf2", "F2", "v2", "F02", "fTwo", "uf1", "float02", " ftwo", "floatTwo", "uftwo"]}}
{"project": "FFmpeg", "commit_id": "2f9ca64556cba9a7edcca9a1c55923a60022937d", "target": 0, "func": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    AVDictionary *tmp = NULL;\n\n    const char *proto_name = NULL;\n\n    int ret;\n\n\n\n    av_dict_copy(&tmp, opts, 0);\n\n    av_dict_copy(&tmp, opts2, 0);\n\n\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n\n        if (url[6] == '+' || url[6] == ':')\n\n            proto_name = avio_find_protocol_name(url + 7);\n\n    }\n\n\n\n    if (!proto_name)\n\n        proto_name = avio_find_protocol_name(url);\n\n\n\n    if (!proto_name)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // only http(s) & file are allowed\n\n    if (av_strstart(proto_name, \"file\", NULL)) {\n\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n\n                url);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n\n        ;\n\n    } else\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n\n        ;\n\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n\n        ;\n\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (c->http_persistent && *pb && av_strstart(proto_name, \"http\", NULL)) {\n\n        ret = open_url_keepalive(c->ctx, pb, url);\n\n        if (ret == AVERROR_EXIT) {\n\n            return ret;\n\n        } else if (ret < 0) {\n\n            if (ret != AVERROR_EOF)\n\n                av_log(s, AV_LOG_WARNING,\n\n                    \"keepalive request failed for '%s', retrying with new connection: %s\\n\",\n\n                    url, av_err2str(ret));\n\n            ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n        }\n\n    } else {\n\n        ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n    }\n\n    if (ret >= 0) {\n\n        // update cookies on http response with setcookies.\n\n        char *new_cookies = NULL;\n\n\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n\n\n        if (new_cookies) {\n\n            av_free(c->cookies);\n\n            c->cookies = new_cookies;\n\n        }\n\n\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n\n    }\n\n\n\n    av_dict_free(&tmp);\n\n\n\n    if (is_http)\n\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n\n\n    return ret;\n\n}\n", "idx": 26481, "substitutes": {"s": ["sv", "v", "settings", "n", "hs", "gs", "js", "sa", "ses", "sp", "fs", "S", "f", "ns", "ss", "b", "r", "ts", "spec", "t", "cs", "ssl", "sb", "p", "e", "m", "ds", "ls", "os", "a", "es", "rs", "sc", "h", "l", "sys", "conf", "tc", "sts", "session", "j", "socket", "sq", "ps", "set", "ctx"], "pb": ["_", "pc", "vp", "tp", "dp", "bp", "pa", "wp", "ub", "lp", "jp", "lb", "typ", "sp", "tf", "pl", "pro", "cb", "mb", "rb", "pp", "pkg", "func", "mp", "uf", "sb", "pub", "p", "pt", "cp", "fp", "def", "np", "pm", "tc", "bs", "tk", "wb", "ht", "PB", "ctx"], "url": ["obj", "ur", "nl", "util", "file", "loc", "path", "https", "el", "mail", "ls", "fail", "window", "id", "location", "external", "term", "un", "il", "result", "db", "host", "json", "gl", "load", "ob", "full", "norm", "web", "html", "ssl", "Url", "str", "impl", "base", "ul", "handle", "all", "raw", "data", "www", "git", "get", "email", "ll", "f", "hl", "r", "cert", "null", "remote", "http", "buffer", "browser", "rel", "lr", "l", "row", "msg", "date", "xml", "res", "text", "page", "server", "job", "rl", "item", "mount", "fl", "format", "name", "sl", "org", "list", "github", "URL", "uri", "use", "err", "dl"], "opts": ["vercs", "copds", "copTS", "ropcs", "ropts", " opcs", "opms", "procs", " opds", "ropms", "roptions", " opTS", "options", "optts", "verms", "opcs", "prots", "optcs", "proms", "optds", "verts", "optTS", "copcs", "vertions", "protions", "opds", "opTS", "copts"], "opts2": ["oputs1", "opps4", "opt1", "opts3", "opTS3", "oputs2", "opts4", "opt2", "props3", "opTS4", "prot2", "opdsTwo", "opds1", "protsTwo", "opTS2", "oputsTwo", "props2", "prots2", "opts1", "opTS02", "prot1", "opps3", "opds2", "prots02", "props02", "prots3", "opps02", "protTwo", "prots1", "optsTwo", "optTwo", "props4", "opts02", "opps2", "prots4"], "is_http": ["iswebhtml", "is_HTTP", " is_html", " is_https", "is_html", "iswebhttps", "is_https", "iswebhttp", "iswebHTTP", " is_HTTP"], "c": ["v", "cv", "ca", "cl", "pc", "cam", "co", "gc", "f", "cb", "ce", "lc", "b", "mc", "fc", "bc", "dc", "t", "cs", "cu", "ac", "conv", "w", "ec", "coll", "p", "m", "comm", "g", "cc", "cf", "com", "ct", "cp", "sc", "C", "con", "h", "cur", "l", "cont", "conf", "tc", "cm", "abc", "enc", "ctx"], "tmp": ["nt", "cache", "cv", "obj", "cmp", "emp", "ctx", "txt", "sp", "opt", "tt", "aux", "tf", "pro", "mem", "aaa", "td", "buff", "cb", "rb", "mk", "pkg", "t", "this", "vt", "mp", "metadata", "tm", "tab", "out", "cp", "table", "etc", "np", "tar", "buf", "proc", "empty", "msg", "temp", "mb"], "proto_name": ["proto__prefix", "profromNamename", "propo2names", "proto0ame", "proto0NAME", "proto_size", "proto2names", "proto2NAME", "probe_word", "proTO_num", "proto__key", "profromNamenumber", "profromNameparent", "protoamename", "proto_no", "proto_prefix", "protoNameame", "protoNamestr", "proto_info", "proto2Name", "proco2NAME", "propo2name", "profrom_name", "profixed_call", "proto_Name", "proto_number", "probe_cache", "protoJname", "proco_Name", "proto__name", "proco_NAME", "protoNamename", "proto0name", "proto_num", "proocol_Name", "proTO_name", "probe_name", "propo_prefix", "proto2prefix", "proto___number", "protonameName", "prototdefault", "proocol_name", "proto2ame", "proocol_default", "propo2prefix", "prototName", "profrom_str", "proto0Name", "proto_str", "protoJid", "proco_ame", "proto_path", "probe_path", "protonamedefault", "proto_id", "prototcomment", "propo_name", "protoJsearch", "proportamename", "proocol_comment", "proto___str", "proocol_key", "profixed_NAME", "proto__Name", "proport_names", "proto___parent", "proTO_Name", "protonamestr", "proto___Name", "propo_parent", "profrom_parent", "proto_default", "propo_names", "protoNamenumber", "proportamelink", "proto_call", "protonamename", "proco2Name", "proTO_prefix", "proto_search", "proto_comment", "proport_name", "proocol_type", "protoNamefield", "proto_key", "profixed_name", "protoetyfield", "protoamelink", "proto_link", "proport_link", "protoamenames", "proco2ame", "proto_type", "proto_names", "protonameparent", "proto_field", "proto_word", "protonamecomment", "profromNamestr", "proto2parent", "proto2name", "proportamenames", "proto_cache", "propo2parent", "proto___comment", "proto___name", "protonamenumber", "proco2name", "proco_name", "proto_NAME", "protoNameparent", "protoetyname", "protoetyame", "prototname", "profrom_number", "proto_parent", "proto_ame"], "ret": ["nt", "rem", "il", "res", "result", "get", "val", "print", "ll", "rt", "rets", "mel", "tr", "r", "reset", "elt", " Ret", "t", "Return", "len", "ref", "ft", "gt", "Ret", "out", "rm", "mt", "RET", "flag", "att", "try", "resp", " RET", "re", "alt", "err"]}}
{"project": "qemu", "commit_id": "1dbd2fd9cbf29c74131e439ce80fb2efde56ee32", "target": 0, "func": "static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n\n{\n\n    int ret = -EINVAL, idx;\n\n    struct rdma_cm_id *listen_id;\n\n    char ip[40] = \"unknown\";\n\n    struct rdma_addrinfo *res;\n\n    char port_str[16];\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        rdma->wr_data[idx].control_len = 0;\n\n        rdma->wr_data[idx].control_curr = NULL;\n\n    }\n\n\n\n    if (rdma->host == NULL) {\n\n        ERROR(errp, \"RDMA host is not set!\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n    /* create CM channel */\n\n    rdma->channel = rdma_create_event_channel();\n\n    if (!rdma->channel) {\n\n        ERROR(errp, \"could not create rdma event channel\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    /* create CM id */\n\n    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);\n\n    if (ret) {\n\n        ERROR(errp, \"could not create cm_id!\");\n\n        goto err_dest_init_create_listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n", "idx": 26485, "substitutes": {"rdma": ["drbase", "rdgo", "drmu", "redmar", "redMA", "ridcal", "ridna", "ldmc", "ridmm", "ldcal", "ridbase", "ridmo", "rodmas", "rodmedia", "rdcal", "rendna", "rrmac", "ddmon", "rrman", "rendgo", "rrMA", "redmag", "rdsta", "rustmm", "ridmi", "drrule", "ddmo", "rownMA", "rodma", "ardsche", "ndermar", "ruma", "rustam", "ndersche", "rtmedia", "ridMA", "drfa", "rtsta", "redme", "radman", "rdmar", "rdman", "rdme", "rnfa", "ddma", "redmedia", "rnmon", "ndercal", "drma", "nderMA", "rdbase", "drsche", "rdm", "rrfa", "radmu", "rodmm", "rusta", "rnrule", "rdmm", "rumag", "rodwa", "rodmu", "rodm", "ridmc", "ddmac", "drMA", "rodna", "rodpa", "drman", "redmi", "rtma", "ridka", "rownma", "rogam", "ldmac", "rendmag", "drm", "rdMA", "ridwa", "redm", "ridsche", "rogmas", "radma", "rdam", "drmon", "rodmo", "ardma", "rdmon", "rodmi", "rnma", "rdmedia", "ddfa", "rdfa", "rodman", "ridmac", "ldma", "nderna", "redsta", "ldmo", "rdka", "rdmac", "ardm", "rownm", "rdmas", "redlia", "rownmar", "ridme", "rendma", "rodmc", "rwwa", "rogma", "ridman", "nderm", "ridma", "rownfa", "rodmac", "redka", "redman", "rendsta", "ridsta", "rendsche", "drpa", "nderma", "rdmc", "rdpa", "rdna", "rogmm", "ridmedia", "ddrule", "rdrule", "ldna", "rugo", "rwma", "rrma", "rodMA", "rdlia", "ddna", "rrmo", "rownman", "ardbase", "redma", "drmedia", "rdmo", "rdmag", "rdsche", "rdmu", "ldsche", "rustma", "radpa", "drlia", "rodka", "rodlia", "rtme", "rdmi", "ridm", "rustmas", "redgo", "rendmc", "rwmm", "rdwa", "rodam", "rwmc"], "errp": ["rerphp", "errpost", "sprwp", " erp", " erpress", " errpress", "errwp", "errpy", "rrpy", "arrP", " erP", "errv", "confpress", "eorpa", "eorpost", "yrpa", "yrphp", "lrpress", " errP", "rerv", "sprphp", "confphp", "lrp", "ererphp", "yrp", "confpa", "ererv", "rerp", "sprv", "errps", "arrpost", "rrr", "erpress", "erp", "rerps", "rerpy", "lrpa", "errphp", "rrps", "erP", "sprp", "erpost", "eorP", "eorp", "arrp", "erpy", "errP", "errr", "rerr", "rrp", "erps", "errpa", "yrpress", "errpress", "arrpa", "confp", "rerwp", "erpa", "ererwp", "ererp", "err", "lrphp"], "idx": ["idxes", "Idk", "Idux", "dxes", "indst", "indk", "likex", "dxs", "idux", "indx", "indX", "idk", "adst", "adux", "idnz", " idxes", "indxs", "indnz", "idxs", "IDx", "dx", "idix", "dex", "likeix", "idex", "indexx", "adxs", "IdX", "indexk", "indexX", "indexux", "indix", " idix", "Idxs", "IDxs", "adx", "idX", "likeX", " idst", " idX", "Idx", "indexxs", "adix", " idxs", " idex", " idnz", "IDxes", "likenz", "IDex", "idst", "adex", "index", " idux", "indux", "Idix"], "listen_id": ["listen__pid", "listener_name", "listener_ident", "listEN_id", "listen___data", "listen_data", "listen__info", "listEN_pid", "listen__ID", "listen_name", "listener_id", "listen_info", "listener_data", "listener_info", "listEN_ID", "listen___name", "listen___info", "listen__name", "listen_ID", "listEN_name", "listen__ident", "listen___id", "listen__id", "listen_ident", "listen_pid"], "ip": ["IP", "ips", " sip", "ap", "ex", "tif", "tip", "tp", "hip", "iter", "wp", "rip", "host", "sp", "mask", "link", "arp", "ix", "op", "isp", "pipe", "pp", "address", "block", "pkg", "hop", "inet", "mac", "ock", "zip", "ic", "p", " IP", "name", "cp", "imp", "ipp", "a", "id", "up", "fp", "np", "addr", "cap", "ep", "i", "alias", "et", "php", "it", "port"], "res": ["rev", "er", "rem", "rez", "vals", "obj", "result", "conn", "red", "gr", "rt", "details", "ret", "Res", "ack", "r", "reg", "reset", "info", "pres", "pas", "ref", "req", "rek", "remote", "rx", "expr", "status", "out", "ress", "rep", "response", "here", "rs", "RES", "rc", "resources", "resp", "progress", "re", "resource", "rest", "msg", "ps", "err", "results", "raw"], "port_str": [" transport_str", "port2arr", "port_data", " transport_list", "ports_str", " port_data", "ports_sl", " port2str", "port_list", "port_sl", " transport_STR", "portpylen", "portpyStr", "port2str", "portpystr", "port2data", "ports_Str", "portpysl", " port_fr", " transport_data", " port2arr", "port_Str", "port2br", "port_len", "port2fr", "port_arr", " port2data", "port_br", "ports_len", "port_fr", " port_arr", "port_STR", " port_br", " port2br"], "e": ["er", "ex", "ve", "oe", "ele", "me", "eur", "ffe", "E", "ee", "ea", "eeee", "ent", "f", "ne", "ce", "r", "elt", "se", "xe", "eu", "eb", "ei", "ge", "el", "eh", "ec", "o", "p", "m", "eng", "en", "ae", "g", "d", "ed", "es", "te", "a", "ev", "element", "ef", "h", "pe", "de", "ue", "entity", "re", "eg", "ep", "c", "x", "et", "le", "ie", "w"]}}
{"project": "qemu", "commit_id": "2d26512b45b5236fa521c4492608fe9fb5bedf46", "target": 0, "func": "int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t/*\n\n\t * Force to even boundary.\n\n\t */\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t */\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n", "idx": 26489, "substitutes": {"m": ["dm", "v", "n", "md", "ms", "me", "f", "am", "mem", "vm", "mod", "b", "r", "mc", "z", "imm", "em", "gm", "M", "t", "mi", "this", "man", "mac", "o", "p", "mm", "g", "d", "mr", "a", "mt", "bm", "perm", "h", "l", "mat", "mo", "module", "i", "j", "x", "cm", "msg", "y", "sm"], "len": ["nt", "il", "n", "cl", "nl", "cmp", "li", "lp", "L", "val", "ll", "kl", "pl", "mem", "lim", "seq", "loc", "lc", "elt", "z", "mn", "lang", "lan", "t", "al", "lib", "el", "lon", "p", "en", "sl", "ml", "Len", "ls", "min", "Length", " l", "lt", "size", "ln", "h", "l", "num", "mat", "pos", "le", "msg", "length", "lit"], "w": ["tw", "ex", "W", "wr", "wm", "rew", "weight", "b", "writer", "p", "hw", "e", "wal", "wh", "wcs", "rw", "window", "y", "term", "n", "aw", "wd", "var", "win", "wat", "d", "a", "wt", "wb", "kw", "all", "raw", "we", "cam", "wp", "power", "f", "wx", "wa", "r", "z", "sum", "fw", "new", "wi", "out", "nw", "l", "words", "wk", "temp", "v", "cache", "way", "end", "mem", "wl", "go", "weights", "t", "man", "g", "sw", "q", "ew", "up", "h", "iw", "word", "x", "ui", "self"], "c": ["v", "ca", "pc", "n", "cache", "count", "gc", "co", "oc", "f", "b", "lc", "z", "r", "xc", "t", "cs", "dc", "cu", "ec", "ic", "cn", "p", "g", "cc", "d", "ct", "cp", "u", "a", "sc", "C", "h", "rc", "l", "cont", "cm", "unc", "ch"], "s_util": ["s___util", "s_universal", "g_il", "sptutil", "s___pkg", "s_utils", " s_il", "l2utils", " s_ul", "sptuniversal", "s2il", "l_utils", "s___urg", "g_utils", "l_urg", "s_pkg", " s_pkg", "s_ul", "sptil", "s2util", "s2utils", "l2urg", "s2urg", "s_il", " s_utils", "l2util", "l2il", "g_util", "sptutils", "s_urg", "s___il", "s___utils", "l_il", "g_universal"], "s": ["sv", "v", "pc", "n", "is", "gs", "sa", "ms", "ns", "ss", "b", "r", "z", "ts", "t", "cs", "p", "sd", "g", "ls", "d", "es", "a", "os", "rs", "sc", "l", "xs", "i", "x", "si", "ps"], "l_util": ["l__utils", "s_utils", "l__util", "s_alloc", "l_utils", "lmsil", "lmsutil", "lmsutils", "s_il", "lmsalloc", "l_alloc", "l__il", "l_il", "l__alloc"], "mlen": ["milade", "mmend", "mnend", "mna", " mlength", "lllen", "malad", "ulade", "mlade", "malun", "malang", "mxaren", "fmlain", "mnin", "milan", "mma", "milenum", "fmlatten", "ulon", "mratten", "millen", "fmlaren", "llen", "llength", "mmain", "ulend", "malain", "mlad", "mnad", "llain", "MLan", "mmang", "melen", "mnEN", "mxain", "mlena", "mlEN", "mnen", "ulan", "mmen", "mnenge", "malenge", "fmlenn", "mlize", "mmate", "milen", "mmun", "mneng", "MLa", "mlax", "milize", "llad", "malan", "MLatten", "mlense", "mnenum", " mlEN", "MLeng", "mla", "malatten", "milon", "maleng", "mman", "mlatten", "mnan", "mrena", "mlate", "mmeng", "llon", "mnate", "mnang", "mlaren", "llize", "millaren", " mllen", " mlist", "mnon", "mlan", "mlenn", "malon", "mraren", "milain", "fmlen", "malin", "millena", "fmlena", "mlain", "malate", "mlenum", "mleng", "ulength", "mmin", "mlang", "mlin", "millatten", "mlun", "melatten", "mnax", "MList", "mnist", "mlon", "mnun", "mmoen", "ulen", "ullen", "mlength", "mnoen", "llaren", "melense", "malense", "malax", "malen", " mlan", "mnense", "mren", "mnatten", "mloen", "mlist", "mnade", "malenum", "mxen", "mlenge", "mlend", "MLen", "MLEN", "mmenge", "mllen", "llenn", "malize", " mlatten", "llan", "mnain", "mmax", "mxenn", "uloen"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 26496, "substitutes": {"as": ["aus", "sis", "cast", "ras", "is", "ars", "asse", "sa", "ms", "ast", "each", "ns", "am", "ar", "ay", "ask", "oss", "an", "ag", "at", "AS", "cs", "las", "ias", "eas", "ach", "ak", "ams", "with", "pack", "os", "a", "es", "ab", "As", "rs", "aos", "us", "bs", "nas", "ass"], "buffer": ["command", "zero", "profile", "buff", "message", "b", "append", "read", "header", "function", "queue", "window", "byte", "value", "Buffer", "position", "map", "type", "interface", "result", "db", "offset", "iter", "address", "vector", "send", "pad", "device", "base", "package", "screen", "addr", "handle", "buf", "ptr", "length", "raw", "limit", "data", "context", "shape", "program", "null", "pool", "dirty", "sequence", "comment", "table", "tty", "error", "memory", "row", "target", "document", "callback", "index", "empty", "cache", "bridge", "page", "server", "binary", "block", "padding", "template", "stream", "engine", "phrase", "write", "size", "alias", "batch", "port"], "len": ["la", "count", "link", "ll", "pl", "mem", "seq", "loc", "ail", "elt", "lan", "bl", "win", "lib", "ref", "fl", "en", "Len", "ls", "lt", "size", "ln", "ld", "num", "addr", "type", "alt", "length"], "is_write": ["is__read", "isfulwait", "isEnread", "is_writ", "is_delete", " is_writ", "isfulwrite", " is_wait", " is_read", "is_wait", "isEnwrite", "isEndelete", "isfulchange", " is_delete", "is__writ", " is_change", "is__only", "isEnonly", "is_read", "is__write", "is_change", " is_only", "isfulread", "is_only"], "access_len": ["access_addr", " access_max", "accessmingcompl", "access_str", " access_priv", " access_Len", "priLengthreq", " access_lon", " access2gen", "accessetyLen", "access_lon", "access___str", "priLengthcompl", "access_ln", " access2lon", "access_loc", "pri_compl", " access2lang", "access_compl", "access___ld", "accessminglen", "access_Len", " access2len", "accessLengthlen", "pri_len", "accesstlon", "access2gen", "accessetycomp", " access_lang", "access_comp", "access2lon", "access2lang", "priLengthln", "accesstlen", "pri_ln", "access67len", "access_lang", "accessitycompl", " access_str", " access_comp", "priLengthlen", "access2len", "access_max", "access___max", "accessmingreq", "pri_req", "access67lon", "accessetylen", " access_gen", "accessitylen", "accessetyaddr", " access_ld", "accessLengthreq", "access_gen", "access___Len", "accesstgen", "accessityln", "access_req", "access67lang", "accessLengthln", "accessmingln", " access_loc", "access_priv", "accessityreq", "accessLengthcompl", "accesstlang", "access_ld", "access67gen", " access_addr", "access___len"], "l": ["la", "v", "il", "n", "nl", "li", "ly", "lp", "els", "lb", "L", "ll", "kl", "pl", "level", "rl", "hl", "lin", "lc", "z", "lv", "lf", "lan", "t", "al", "el", "m", "p", "fl", "g", "sl", "ml", "line", "ls", "d", "list", "lt", "size", "ln", "h", "lo", "ld", "s", "i", "j", "dL", " L", "le", "it", "tl", "dl", "length", "lit"]}}
{"project": "FFmpeg", "commit_id": "44d854a518f97cb65090420b0b9f55611a0ea932", "target": 1, "func": "static av_cold int atrac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    int version, delay, samples_per_frame, frame_factor;\n\n    const uint8_t *edata_ptr = avctx->extradata;\n\n    ATRAC3Context *q = avctx->priv_data;\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Channel configuration error!\\n\");\n\n\n    }\n\n\n\n    /* Take care of the codec-specific extradata. */\n\n    if (avctx->extradata_size == 14) {\n\n        /* Parse the extradata, WAV format */\n\n        av_log(avctx, AV_LOG_DEBUG, \"[0-1] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown value always 1\n\n        edata_ptr += 4;                             // samples per channel\n\n        q->coding_mode = bytestream_get_le16(&edata_ptr);\n\n        av_log(avctx, AV_LOG_DEBUG,\"[8-9] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  //Dupe of coding mode\n\n        frame_factor = bytestream_get_le16(&edata_ptr);  // Unknown always 1\n\n        av_log(avctx, AV_LOG_DEBUG,\"[12-13] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown always 0\n\n\n\n        /* setup */\n\n        samples_per_frame    = SAMPLES_PER_FRAME * avctx->channels;\n\n        version              = 4;\n\n        delay                = 0x88E;\n\n        q->coding_mode       = q->coding_mode ? JOINT_STEREO : STEREO;\n\n        q->scrambled_stream  = 0;\n\n\n\n        if (avctx->block_align !=  96 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 152 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 192 * avctx->channels * frame_factor) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown frame/channel/frame_factor \"\n\n                   \"configuration %d/%d/%d\\n\", avctx->block_align,\n\n                   avctx->channels, frame_factor);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (avctx->extradata_size == 10) {\n\n        /* Parse the extradata, RM format. */\n\n        version                = bytestream_get_be32(&edata_ptr);\n\n        samples_per_frame      = bytestream_get_be16(&edata_ptr);\n\n        delay                  = bytestream_get_be16(&edata_ptr);\n\n        q->coding_mode         = bytestream_get_be16(&edata_ptr);\n\n        q->scrambled_stream    = 1;\n\n\n\n    } else {\n\n        av_log(NULL, AV_LOG_ERROR, \"Unknown extradata size %d.\\n\",\n\n               avctx->extradata_size);\n\n\n    }\n\n\n\n    /* Check the extradata */\n\n\n\n    if (version != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version %d != 4.\\n\", version);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (samples_per_frame != SAMPLES_PER_FRAME &&\n\n        samples_per_frame != SAMPLES_PER_FRAME * 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of samples per frame %d.\\n\",\n\n               samples_per_frame);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (delay != 0x88E) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of delay %x != 0x88E.\\n\",\n\n               delay);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (q->coding_mode == STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Normal stereo detected.\\n\");\n\n    else if (q->coding_mode == JOINT_STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Joint stereo detected.\\n\");\n\n    else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown channel coding mode %x!\\n\",\n\n               q->coding_mode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (avctx->block_align >= UINT_MAX / 2)\n\n\n\n\n    q->decoded_bytes_buffer = av_mallocz(FFALIGN(avctx->block_align, 4) +\n\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (q->decoded_bytes_buffer == NULL)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    /* initialize the MDCT transform */\n\n    if ((ret = ff_mdct_init(&q->mdct_ctx, 9, 1, 1.0 / 32768)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        av_freep(&q->decoded_bytes_buffer);\n\n        return ret;\n\n    }\n\n\n\n    /* init the joint-stereo decoding data */\n\n    q->weighting_delay[0] = 0;\n\n    q->weighting_delay[1] = 7;\n\n    q->weighting_delay[2] = 0;\n\n    q->weighting_delay[3] = 7;\n\n    q->weighting_delay[4] = 0;\n\n    q->weighting_delay[5] = 7;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        q->matrix_coeff_index_prev[i] = 3;\n\n        q->matrix_coeff_index_now[i]  = 3;\n\n        q->matrix_coeff_index_next[i] = 3;\n\n    }\n\n\n\n    avpriv_float_dsp_init(&q->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    ff_fmt_convert_init(&q->fmt_conv, avctx);\n\n\n\n    q->units = av_mallocz(sizeof(*q->units) * avctx->channels);\n\n    if (!q->units) {\n\n        atrac3_decode_close(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avcodec_get_frame_defaults(&q->frame);\n\n    avctx->coded_frame = &q->frame;\n\n\n\n    return 0;\n\n}", "idx": 26512, "substitutes": {"avctx": ["avejac", "avkw", "wavconn", "avertmp", "avepkg", " avcmd", "afkt", "avaltx", "wavcu", "avwcs", "ajcmp", "averkt", "ajtx", "ajconf", "auconn", "wavpkg", "avhandle", " avpkg", "abconf", "avecp", "averjac", "averpid", "wavhandle", "afcmp", "abcp", "wavcmp", "avecontext", "avconf", "absys", "avejp", "jamkw", "avecb", "aukw", "avecu", "wavctl", "ajpkg", "augc", "wavcmd", "navcp", "avertx", "wavgc", "wavcrit", "avgc", "varwcs", "averpkg", " avtx", "ajsys", "avercu", "ajcfg", "aversys", "jamtx", "afcfg", "avetx", "navctx", "avtxt", "avetxt", "ajcb", "avct", " avsys", "autx", "ajcontext", "avsys", "abcontext", "abcmp", "avegc", "wavtmp", "varsys", "ajjp", "avtmp", "wavtx", "afjac", "afkw", "averconn", " avcontext", "avertxt", "avtx", "wavkt", " avcmp", "afctl", "avctl", "averconfig", "abctx", "wavctx", "wavcp", " avconf", "avconfig", "avect", "avercontext", "abtx", " avkt", "aftx", "avehandle", "avcontext", "afctx", "ajcp", "avesys", "avjp", "ajtxt", "avcmd", "auctx", " avct", "avercmd", "avcb", "avecmd", "aveconf", "ajpid", "avaljac", "ajjac", "afpkg", "avpkg", "avewcs", "avconn", "wavconfig", "abcmd", "aucrit", "ajkw", "avecrit", "averhandle", "avcp", "avcmp", "aveconn", "afcontext", "varctx", "averconf", "avercfg", "averctx", " avcfg", "navcfg", "varcontext", "avetmp", "aveconfig", "avercb", "avcfg", "avectl", "aftmp", "ajconn", "avalctx", "avaltmp", "avekt", "abpkg", "avjac", "avecfg", "wavkw", "wavcontext", "jamctx", "averct", "afconn", "afcmd", "averjp", "ajctx", "avcrit", "avpid", " avcp", "ajcmd", "afpid", " avwcs", "navcontext", "jampkg", "avectx", "ajkt", "avkt", "avcu"], "i": ["v", "ir", "n", "is", "ij", "iat", "ai", "b", "ci", "ii", "t", "ip", "mi", "m", "p", "pi", "id", "im", "ti", "j", "index", "x", "c", "it", "si", "bi", "I"], "ret": ["res", "result", "ter", "txt", "jp", "val", "aux", "ll", "rt", "mem", "reply", "rets", "new", "fun", "ft", "status", "out", "Ret", "rel", "rm", "mt", "RET", "alt", "re"], "version": ["versions", "v", "result", "count", "Version", "offset", "actor", "driver", "feature", "channel", "mode", "scale", "distance", "vision", "action", "level", "timeout", "volume", "description", "step", "state", "vers", "VER", "serial", "sequence", "vector", "sample", "component", "time", "status", "format", "dimension", "name", "number", "depth", "error", "size", "section", "ception", "position", "sector", "direction", "type", "VERSION", "batch", "index", "order", "ver", "length"], "delay": ["priority", "frequency", "dp", "offset", "effect", "del", "driver", "scale", "distance", "timeout", "policy", "description", "hold", "hide", "remember", "dq", "sequence", "rate", "duration", "shift", "zip", "time", "buffer", "sleep", "debug", "late", "response", "seed", "sync", "error", "memory", "position", "label", "skip", "wait", "slow", "dl", "length", "speed"], "samples_per_frame": ["samples_per_fram", "samples_per2frames", "samples_PER_frames", "samples_per2frame", "samples_PER_stream", "samples_PER_frame", "samples_per_frames", "samples_per2sequence", "samples_per_stream", "samples_per_sequence", "samples_PER_sequence", "samples_PER_fram"], "frame_factor": ["framexfact", "framelexscale", "force67per", "frame_scale", "filter_fact", "frame_actor", "filter_domain", "filterxdomain", "frame10number", "filterxfactor", "frame_fact", "framelexper", "force_loader", "frame_relation", "frame67domain", "frame67per", "framexdomain", "frame10relation", "block_actor", "frame_loader", "framemodoperator", " frame_number", "force_scale", "frame10factor", "frame_operator", "block_operator", "framemodfactor", "frame67fact", "frame_step", " frame_step", " frame_fact", "framemodactor", "frame_number", "frame_per", "framelexloader", "force_factor", "filterxfact", "filter_factor", "frame_domain", "force67factor", "framemodlower", "frame67factor", "block_lower", "framexfactor", "force67loader", "frame_lower", "frame67scale", "framelexfactor", "frame10fact", "force67scale", "force_per", " frame_relation", "block_factor", "frame67loader"], "edata_ptr": ["edata___ptr", "edata__pers", "edelta_fp", "edadata_pointer", "edadata_prot", "edata_pt", "edata3tp", "edata_addr", "edra_pers", "edATA_ptr", "edata_ps", "edadata_tp", "edapo_Ptr", "edata3inter", "edata_tp", "edataacps", "edadata48prot", "edapo48tp", "edata_sp", "edata_pointer", "edra_ptr", "edata___pointer", "edata_pers", "edadata48pt", "edata_prime", "edata_prot", "edelta_ptr", "edapo48inter", "edata__pointers", "edapo48ptr", "edata48prot", "edadata48ptr", "edataacpointers", "edATA_pointer", "edadata_ptr", "edata2prime", "edata_deg", "edata___fp", "edoff_ps", "edata__ptr", "edata_grad", "edoff_ptr", "edata_ctr", "edadata_pt", "edata3ptr", "edapo_inter", "edata2pt", "edata_pointers", "edra_pt", "edata___addr", "edola_grad", "edoff_pers", "edata48pt", "edapo48Ptr", "edata2prot", "edapo_ptr", "edata_fp", "edata48ptr", "edadata_fd", "edata3Ptr", "edata_tr", "edATA_tr", "edadata_prime", "edATA_sp", "edola_ptr", "edelta_addr", "edata48Ptr", "edadata48prime", "edata_inter", "edATA_addr", "edata2ptr", "edapo_tp", "edelta_pointer", "edataacpers", "edola_tr", "edola_ctr", "edata48prime", "edATA_deg", "edataacptr", "edata_fd", "edata_Ptr", "edata__pt", "edata48tp", "edoff_pointers", "edata48inter", "edra_pointers"], "q": ["qi", "er", "v", "cv", "ve", "cache", "k", "iq", "quest", "qv", "eq", "f", "aq", "qu", "query", "tx", "r", "z", "dq", "qs", "pkg", "t", "w", "req", "quit", "p", "e", "qa", "m", "g", "cc", "quote", "queue", "d", "ck", "requ", "h", "qq", "ue", "Q", "j", "c", "sq", "quant", "qt", "it", "que", "ch", "ctx"]}}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 26530, "substitutes": {"opaque": ["achc", "opc", "ocgate", " opque", "achaque", "achgate", " opc", "ocaque", "opque", "opgate", " opgate", "ocque", "achque", "occ"], "addr": ["Address", "data", "obj", "adr", "offset", "src", "arp", "arch", "mem", "tx", "hl", "ace", "loc", "var", "r", "cmd", "info", "address", "pkg", "at", "act", "coord", "arr", "pat", "ref", "add", "hash", "hw", "gt", "pad", "name", "dh", "a", " address", "mt", "ad", "rs", "eth", "dr", "point", "xy", "handle", "ord", "pos", "x", "ptr", "index", "alloc", "err", "self", "ctx"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531, "substitutes": {"a": ["ma", "v", "n", "ba", "sa", "result", "val", "f", "am", "ar", "aaa", "r", "an", "area", "t", "new", "this", "ac", "o", "p", "m", "e", "g", "out", "ach", "d", "aa", "u", "ab", "app", "up", "A", "h", "s", "as", "l", "i", "ia", "c", "x", "y", "w"], "b": ["B", "v", "to", "ba", "db", "bf", "f", "cb", "r", "rb", "eb", "bc", "gb", "new", "t", "sb", "by", "m", "e", "p", "bh", "out", "g", "bb", "d", "be", "base", "ab", "fb", "h", "l", "bs", "pb", "c", "i", "j", "y", "bt", "bi", "w"]}}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535, "substitutes": {"vs": ["sv", "vals", "v", "bits", "ports", "hs", "args", "vp", "ks", "gs", "js", "ms", "ves", "changes", "services", "obs", "fs", "docs", "blogs", "ns", " cs", "details", "VS", "pages", "ss", "ts", "qs", "vers", "ops", "vv", "cs", "vt", "ims", "ins", "lines", "ds", "ls", "ups", "values", "views", "wcs", "es", "otes", "rs", "lists", "s", "bs", "sts", "atts", "its", "Vs", "vc", "xs", "flags", "alls", "inv", "ver", "caps", "ps"], "i": ["qi", " key", "ex", " port", " I", " iter", " ex", "ix", "xi", "ami", "ii", "oi", "ip", "my", "e", "id", "us", "y", "bi", "ind", "I", " mc", "iter", " pos", " li", "ci", " multi", "di", "pi", "base", " mi", "iu", "fi", " ti", "phi", " wi", " my", " j", "is", "iq", "me", "print", "ini", "gi", "hi", " bi", "cli", "sim", "ic", "m", "multi", "chain", "ri", " ii", " si", "im", "l", " pi", " index", " info", "index", "j", "si", "gu", " c", " err", "in", "li", " ni", "ai", "ji", "ki", "mi", " m", "ims", " di", "uri", "point", " it", "ti", "x", "it", "ui"]}}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538, "substitutes": {"spapr": [" spipR", " spipr", "spappr", "asprapw", " spapp", "aspapres", "spapcr", "spapprb", "spamprr", "sprapres", "spipr", " spapsR", "spapsw", " spipp", " spaprb", " spiprr", "spapsar", "spapw", "spaperr", "spapsR", " spapsrb", "spaper", "spapscr", "sprapw", "spipp", "asprapres", "sprapar", "sprapr", " spapsr", "spapsr", "spapsres", "aspapw", "spapar", "spapeR", "spampcr", "asprapr", "aspapr", "spapear", "spapsrb", "spaperes", "spappR", "spappcr", " spapR", "spapp", "spaprb", "spiprr", "spaprr", "spapres", "spapR", "spapew", "spampr", "asprapar", " spapscr", " spapcr", "spipR", "spapep", "spamprb", "spampR", " spaprr", "aspapar", "spampp"], "entry": ["command", "xml", "nt", "RY", "office", "enter", "obj", "result", "next", "member", "link", "ent", "it", "job", "item", "event", "or", "instance", "ace", "see", "se", "writer", "eu", "ry", "cell", "image", "interface", "comment", "key", "match", "quit", "add", "e", "ment", "buffer", "attribute", "line", "inter", "import", "cue", "escape", "table", "list", "window", "ENT", "element", "section", "insert", "delete", "cur", "try", "row", "record", "entity", "field", "index", "empty", "Entry", "ie", "inner", "set"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n", "idx": 26540, "substitutes": {"sccb": [" sccbd", "scedb", "sdcbs", "sCCbd", "socb", "sCCb", "succbd", "scebd", "socbc", "saccb", "succfb", "sctrlnb", "sccc", "scknb", "sccafb", "sckba", "simplecusbc", "nsclbb", "dsuccbs", "sccadb", "scedbs", "sctrlb", "sccbc", "simpleccbc", "desuccb", " scfc", "lesscusb", "tsckrb", "sckbc", "sckab", "scusb", "scastab", "sclfb", "simpleccnb", "scusc", "nscldb", "lesscusfb", "scusfb", "scerb", "sckrb", "lesscusnb", "tsccbd", "sCCbe", "sccbr", "lesscusbr", "scccb", "sccbb", "tsccb", "sccbs", "jsclbb", "saccbs", "scfbd", "sccnb", "dsccerb", "scusnb", "saccbb", "sckbd", "dscccb", "sccrb", "desuccbc", "desccfb", "nsccerb", "scusbc", "succbc", "jsccb", "scfc", "nsclerb", "sccbd", "sclba", "tsckba", " scfbd", " sccc", "sccabd", "simplecusb", "nsccdb", "sccbe", "desccbc", "desuccfb", "sclb", "sCCc", "simpleccb", "sclnb", "socab", "sccba", "scastb", "jsccbs", "lessccb", "sctrlbr", "succcb", "lessccbr", "dsccb", "dsuccb", "sccfb", "desuccbd", "sccaerb", "sclbc", " sccbe", " scfbe", "jsccab", "nsclb", "sclbs", "scederb", "sclbb", "sceb", "sclbr", "sccerb", "dsccbs", "sdcerb", "desccbd", "nsccb", "scastbs", "sclrb", "dsuccerb", "nsccbb", "sdcb", "scfb", "scfbe", "succerb", "succb", "simplecusnb", "sccab", "socnb", "lessccnb", "jsclb", "lessccfb", "sccabc", "scusab", "saccab", "sccabb", "scastbb", "scusbr", "jsccbb", "sceba", "tsccba", "scldb", "scusbe", "sclbd", "dsucccb", "scedcb", "sckb", " scfb", "sclab", "desccb", "sctrlfb", "scusbd", "tsckbd", "sccdb", "tsckb", "succbs", "simplecusab", "jsclab", "jsclbs", "sdccb", "tsccrb", "sclerb", "simpleccab"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n", "idx": 26543, "substitutes": {"json": ["JSON", "ose", "xml", "obj", "kid", "js", "gc", "graph", "final", "ij", "txt", "job", "kj", "jay", "mn", "report", "son", "dump", "journal", "cmd", "javascript", "jas", "tree", "mson", "jack", "html", "metadata", "doc", "my", "java", "format", "jj", "jac", "gov", "yt", "latest", "nil", "np", "xy", "stats", "mos", "bs", "oj", "document", "j", "lost", "ja", "test", "closed", "sky"], "name": ["init", "v", "n", "k", "on", "named", "ext", "local", "comp", "NAME", "item", "var", "cmd", "attr", "names", "path", "nan", "key", "p", "e", "str", "par", "prefix", "id", "def", " names", "nm", "label", "nam", "word", "type", "ame", "start", "j", "c", "normal", "order", "Name"], "val": [" fut", " value", "vals", "v", "obj", "pol", "ctx", "serv", "local", "valid", "it", " valid", "tx", "VAL", "aval", "Val", "ival", "len", "al", "ref", " lac", "doc", "pt", "sl", " v", " lit", "px", " ty", "value", "vol", " al", "def", " aval", "num", "xy", "pos", "x", "index", "eval", " eval", " slot", "test", "lit"]}}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26552, "substitutes": {"s": ["ches", "sv", "sis", "v", "hs", "is", "n", "gs", "js", "ms", "ses", "changes", "erences", "S", "fs", "serv", "ns", "details", "ss", "states", "ts", "qs", "parts", "cs", "gets", "ats", "bes", "sb", "ins", "ims", "m", "comm", "aws", "ds", "sl", "ls", "ains", "ares", "os", "es", "rs", "ies", "vs", "des", "sys", "ys", "als", "sts", "bs", "stats", "its", "uns", "c", "ps", "w"], "sci_level": [" sci_levels", "sci_index", "sciacylevel", "ei_level", " sci_lvl", " sci_quality", "ei_l", "sciacysuccess", "sci_lvl", "sci_success", "sciacylvl", "ei_success", "sci_levels", " sci_index", "sci_status", "sciacyl", " sci_status", "ei_lvl", "sci_l", "sci_quality"], "pmsts": ["iamstates", "rpmst", "amsts", "hmsts", " pmlists", " pmst", "rpminces", "rpmants", "cmst", "mns", " pmants", "pmservices", "cmsts", "rpmsta", "hmsta", "rpmsts", "iamservices", "pmants", "pmstates", "rpmstates", " pmcasts", "mlists", "tmsts", " pmars", "pmst", "tmars", "hmstates", "pmlists", "iamsta", "tmcasts", "tmants", " pmns", " pminces", "msts", "hmservices", "pmists", "mists", "iamsts", "rpmcasts", "rpmservices", " pmists", "pminces", "pmars", "amlists", "cminces", "pmns", "amns", "pmcasts", "rpmars", "amists", "pmsta"]}}
{"project": "FFmpeg", "commit_id": "beefafda639dd53fc59c21d8a7cf8334da9a1062", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n", "idx": 26559, "substitutes": {"s": ["sv", "ex", "gs", "ms", "ses", "changes", "details", "b", "parts", "comments", "bes", "p", "aws", "ls", "so", "rs", "series", "as", "conf", "als", "i", "sports", "c", "sym", "y", "ps", "set", "w", "n", "bis", "fs", "ns", "ar", "ants", "ts", "se", "less", "sb", "ins", "es", "os", "a", "ies", "stats", "sts", "settings", "hs", "is", "ss", "r", "z", "an", "spec", "cs", "ats", "comm", "ds", "sys", "sq", "v", "js", "source", "qs", "t", "ims", "ows", "sw", "h", "bs", "its", "x"], "crc": ["cron", "pc", "lcRC", "ccc", "curirc", "curRC", " cdr", "rcRC", "rccc", "rcron", "pdr", "hdr", " ccc", "prib", "lcirc", " cce", "crib", "circ", "ctrc", "lcrc", "cRC", "cdr", " cRC", "hrc", "ctron", "curce", "currc", "cc", "cce", "ctcc", "prc", "hrib", " cron", "ctRC", " crib", "hc", "lcce", "rcrc", " circ", " cc"], "S": ["BS", "B", " B", "SR", "W", "SAM", "RAW", "ST", " T", "SM", "TS", "DS", "R", "SS", "L", "SEC", "RS", "Si", "SA", "Set", " N", "H", " IS", "X", "U", "F", "STAT", "NS", " SS", "M", "SP", "SOURCE", "G", "D", "IS", "P", "SK", "T", "N", "SE", "String", "O", "SF", "A", "V", "C", " C", "SI", "JS", "SL", "US", "Session", "Sample", "SER", "Source", "GS", "Q", "CS", "SU", "set", "I"], "bit": ["and", "B", "bits", "sat", "binary", "mask", "ut", "slot", "tag", "or", "mod", "b", "lock", "bool", "state", "digit", "block", "big", "jit", " BIT", "t", "key", "bin", "version", "p", "status", "out", "Bit", "number", "BIT", "base", "id", "bo", "lt", "byte", "flag", "position", "point", "back", "word", "field", "i", "ion", "pair", "x", "it", "test", "ch", "set"]}}
{"project": "FFmpeg", "commit_id": "42f9132218ca11a8e9a3c82a175b46bca092113e", "target": 0, "func": "static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n    MXFContext* mxf = s->priv_data;\n\n    int64_t seekpos;\n\n    int ret;\n\n    MXFIndexTable *t;\n\n\n\n    if (mxf->nb_index_tables <= 0) {\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n\n\n    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)\n\n        return ret;\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    mxf->current_edit_unit = sample_time;\n\n    } else {\n\n        t = &mxf->index_tables[0];\n\n\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n\n         * this also means we allow seeking before the start */\n\n        sample_time = FFMAX(sample_time, 0);\n\n\n\n        if (t->fake_index) {\n\n            /* behave as if we have a proper index */\n\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n\n                return sample_time;\n\n        } else {\n\n            /* no IndexEntryArray (one or more CBR segments)\n\n             * make sure we don't seek past the end */\n\n            sample_time = FFMIN(sample_time, st->duration - 1);\n\n        }\n\n\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)\n\n            return ret;\n\n\n\n        ff_update_cur_dts(s, st, sample_time);\n\n        mxf->current_edit_unit = sample_time;\n\n        avio_seek(s->pb, seekpos, SEEK_SET);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26568, "substitutes": {"s": ["sv", "v", "args", "settings", "n", "hs", "is", "gs", "js", "ms", "changes", "erences", "fs", "S", "src", "sp", "sam", "ns", "f", "ss", "b", "ts", "qs", "spec", "cs", "south", "less", "ats", "space", "sb", "ims", "p", "comm", "m", "aws", "ds", "g", "ls", "os", "a", "es", "rs", "sc", "h", "l", "sys", "conf", "acs", "vs", "stats", "sts", "bs", "als", "its", "i", "sports", "c", "x", "j", "sq", "ps", "ch", "set", "ctx"], "stream_index": ["streamIdind", "channel_ind", "stream_offset", "channel_key", "stream_info", "sample_info", "sample_index", "stream_key", "channel_index", "sample_offset", "stream_ind", "stream_id", "channel_id", "sample_ind", "streamIdindex", "streamIdinfo", "streamIdoffset"], "sample_time": ["sample_weight", "sam_sequence", "batch_time", "sampleletransform", "samplevallength", "samplettransform", "ample_times", "sample_frequency", "samplejtype", "sample_hash", "sampleleTime", "samplelytype", "sample_transform", "sample00file", "sample_rate", "transformTimeruntime", "samplematTime", " sample_Time", "spring_Time", "sampleTimetext", "sample_post", "sample68times", "ample_length", "transform_text", "sampleminglength", "samplelogtimes", "samplelettransform", "sample2rate", "sample67time", "sam_length", "samplejweight", "ample2size", "amplelogtime", "batchletime", "sample00length", "ample_total", "sample2times", "sampleityhash", "samplemattime", "sample_query", "sample_Time", "transform_runtime", "sample_form", "samplevaltree", "springlyquery", "transformTimetime", "sample68time", "ample_size", "sample2query", "sample___hash", "batch_timer", "springlytime", "sample68form", "sample2TIME", "sampleityfrequency", "sample_total", "Sample_Time", "sample67post", "ample_post", "ample_tag", "ample2times", "sample_when", "sampleTimetimes", "sample_text", "sam_state", "springlyTime", "batchleTime", "Sample_frequency", "sample___frequency", "sample___Time", "sample2time", "Sample_form", "transform_Time", "sampleTimeTIME", "ample_rate", "sampleTimeTime", "sampleitytime", " sample_when", "sam_time", " sample_length", " sample_type", "samplevaltimes", "samplevaltransform", "samplemattext", "transform_time", "ample_transform", "sample2type", "sample2Time", "spring_query", "ample2rate", " sample_times", "samplejTime", "samplettime", "sample_runtime", " sample_TIME", "samplematruntime", "sample_set", "samplelyquery", "sample_timer", "springlytype", "transformTimeTime", "sample_length", "samplelytime", "ample_file", "sample68Time", "samplelogfile", "samplettree", "ample_Time", " sample_weight", "sample_TIME", "sample00time", "samplemingtime", "samplemingTime", "amplelogtimes", "batchletransform", "batch_transform", "Sample_hash", "batch_Time", "samplelettimer", "sample00total", "Sample_times", "samplevalstate", "sample2size", "sample_size", "sampleityTime", "Sample_time", "samplelogtime", "spring_time", "sample_tree", "samplemingtransform", " sample_rate", "sample_file", "samplejtime", "sample00sequence", "ample_tree", "sample_state", "sampleletime", "ample_time", "samplevalsequence", "amplelogtotal", "sample___time", "sampleTimetime", "samplelettime", "samplettimes", "ample2time", "sample00state", "spring_type", "sample_sequence", "sample00times", "sample_times", "samplelyTime", "transformTimetext", "sampleletimer", "sample67tag", "samplevaltime", "sampleletTime", "batchletimer", " sample_set", "sample_tag", "sample_type", "sampleTimeruntime", "amplelogfile", "samplelogtotal"], "flags": ["tags", "args", "settings", "bits", "nl", "fields", "ventions", "fs", "Flag", "faces", "mask", "details", "frames", "weights", "ants", "bool", "cmd", "FLAG", "func", "cs", "options", "comments", "styles", " Flags", "ats", "fps", "status", "features", "posts", "properties", "wcs", "reports", "locks", "ents", "ensions", "flag", "Flags", "ints", "types", "atts", "lag", "ags"], "st": ["sv", "obj", "ust", "stop", "util", "ST", "th", "ist", "St", "ast", "sp", "tt", "ut", "src", "end", "inst", "tr", "store", "stab", "ss", "step", "set", "z", "ts", "state", "se", "std", "sh", "stack", "ft", "sth", "str", "status", "pt", "sl", "irst", "sw", "ct", "stream", "so", "stage", "must", "mt", "sc", "storage", "h", "cont", "stable", "sts", "ost", "start", "stat", "sta", "et", "sn", "rest", "est", "ste", "sm", "ctx"], "seconds": ["bits", "errors", "settings", "gs", "js", "ms", "ions", "erences", "obs", "fs", "sf", "frames", "amples", "timeout", "rets", "actions", "anos", "urations", "states", "ts", "vers", "qs", "uts", "bytes", "second", "abytes", "sites", "https", "sec", "ations", "days", "bes", "steps", "games", "years", "times", "sections", "sb", "users", "uses", "feet", "forms", "ages", "values", "terms", "utes", "reports", "workers", "models", "resources", "jobs", "videos", "bs", "strings", "flows", "classes", "missions", "utils", "files", "uploads", "months"], "mxf": [" mfg", "gmffe", "Mfif", "mxfif", "mxffe", "matxe", "emxff", " mwe", "esmfg", "mxfo", "modulexf", "bmxf", "bmfg", "gxe", "mxe", " mffe", "gxf", "emxe", "nfx", "gfx", "mxff", "matxff", "matwe", "Mxf", "esmxe", "nfo", "mxxf", "hxc", "hfx", "mxc", "modulexe", " mxc", "gmfo", "mcf", " mxe", "Mcf", "gxff", "emwe", "hxf", " mxd", "modulecf", "mfo", "nxf", " mfx", "bmxd", "gmxf", "gmfif", "hfo", "matxf", " mxff", "mfx", "mxd", "nxc", "esmxf", "esmxd", " mfif", "modulefif", "emfx", "mffe", "emxf", "mwe", " mcf", "bmxe", "Mxe", " mfo", "mfif", "mfg"], "seekpos": ["ekoffset", "walkposition", "ekPos", "ekposition", "walkpos", "scanPos", "selectPOS", "referencePos", "scrollposition", "scanpo", "seekPos", "seekoffset", "scanpos", "scanposition", "scrolloffset", "seekPOS", "referenceposition", " seekPos", "referencepos", "selectposition", " seekPOS", " seekpo", "ekpos", "seekpo", "selectPos", "scrollpos", " seekposition", "selectpos", " seekoffset", "scrollPos", "walkPOS", "seekposition", "referencepo", "walkPos"], "ret": ["rev", "nt", "rem", "res", "nl", "result", "ert", "ral", "final", "get", "ext", "over", "val", "ll", "print", "rt", "net", "rets", "mem", "det", "after", "tr", "reset", "elt", "cert", "reg", "pas", "ry", "Return", "ref", "ft", "gt", "Ret", "out", "fail", "pret", "not", "mt", "RET", "value", "att", "def", "nil", "try", "resp", "cont", "back", "re", "alt", "et", "success", "it"], "t": ["nt", "v", "to", "tap", "n", "tp", "tu", "ta", " T", "ot", "txt", "tt", "ent", "rt", "tf", "mint", "f", "tr", "td", "tx", "tg", "b", "r", "ts", "tree", "dt", "at", "vt", "tm", "o", "p", "m", "pt", "tab", "g", "T", "ct", "te", "a", "table", "lt", "wt", "h", "att", "l", "tmp", "tc", "y", "ti", "type", "i", "c", "x", "got", "et", "temp", "it", "bt", "tl", "w"]}}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587, "substitutes": {"ifm": ["fifmt", "ifr", "tifn", "nilmt", "ibn", "ifk", "ifmm", " ifnm", "fifmc", "imgd", "ifcm", "iftm", " ifmi", "fifk", "figm", " ifi", " ifs", "itermi", "ifg", "endifm", "strm", "limmi", "ifp", "iamm", "imggm", "efm", " ifd", "labelm", "iffm", "ivt", "fifmm", "icmd", "ifty", "ifgm", "iftp", "limcm", "iterl", "iftd", "figmi", "iffmi", "ibmm", "expmm", " ifr", " ifam", "labelmn", " ifk", "labeln", "imgnm", "fifmi", "iffg", " ifn", " ifmt", "actman", "iffgm", "thenmm", "ifmd", "ivm", "expmx", "nilm", "fft", "liml", "ifmc", "itd", "labelms", "limm", "iammi", "Ifd", "labellem", "iffy", "iffr", " ifp", "iffam", "labelt", "ifn", " ifgm", "iffp", "ifmi", "iffmd", "iaml", " ifmm", " ifq", "imp", "imgam", "strmi", "iffnm", "nilmi", "figt", "efp", "iftmn", "endifd", "imgmi", "invn", "unlesssm", "efmt", "iffq", "icm", "acts", "ifmn", "ifq", "tifnm", "ifmt", "tifg", "invms", " ift", "fifp", "nilmc", "ibgm", "invm", "ift", "ifsm", " ifms", "figsm", "strmod", "strmd", "ffmn", "ifl", "actg", "labelmi", "expm", "actgm", "ifam", "iffmod", "invmi", "actn", "fiftm", "iterm", "ifnm", " ifman", " iftm", "endifms", "tifm", "ifti", "actl", "ibm", "Ifm", "itmn", "unlesst", "fifl", "unlessmi", "actmt", " ifl", "ifi", "Ifn", "iffd", "ifms", "fifr", "iffn", "actnm", "iamcm", "ifs", " iflem", "actp", "itermc", "icmod", " ifsm", "endifn", "fifmx", "imgk", "imm", "icmi", "fflem", "thenm", "ifmx", "ity", "thenmx", "ifft", "unlesss", "itermt", "imn", "imi", "iffmn", "fifm", "unlessn", "ifmod", "ifman", " ifcm", "actmm", "imgm", "ivr", "fifd", "ffm", "thenmi", "iflem", "efl", "ifd", "ifftm", "ivq", "expmi", "unlessm", "unlessman", "actm", " ifmn", "itm", "ify", "Ifms", "iftn"], "ifqt": ["tifq", "svqq", " ifdt", "tifqq", "tifqi", "ifq", "ifvt", " ifqa", "IFq", "ifmat", "defqt", "defqi", "ffq", " ift", "Ifqt", "tifqa", "efvt", "tifvt", "ift", "tifmat", " ifqq", "defdt", "ffqt", "Ifq", "svvt", "IFqt", "Ift", "ffqa", "svmat", " ifq", "efqq", "tifdt", "IFqa", "svqt", "efqt", "ifqq", "ifqi", "Ifqa", "tifqt", "ifqa", "efmat", "ifdt", "defq", " ifqi", "ffqq", "IFt"], "slirp": ["salrirp", "splirpa", "splmirpatch", "slererpa", "slirpid", "slirmv", "slererp", "splirmp", "sslirpid", "splarport", "slairpa", "slarl", "splirtp", "slvrp", "slirkp", "liircphp", "slrirbp", "splrirp", "splirtpi", "slibrps", "islirvp", "selirsp", "slpirp", "slairbp", "selirp", "slyrphp", "slarp", "liirp", "splirtjp", "sslirve", "splarpi", "slirv", "slairport", "slircpo", "slierpa", "islairvp", "slorm", "sldirphp", "slirjp", "slarpi", "splirport", "glpirpo", "slirmps", "slirpa", "plierp", "liirphp", "slircpa", "salirport", "slpirjp", "slyrpc", "plirpen", "slrirpen", "splrirpa", "slircp", "slirtjp", "slirmpi", "slirkvp", "slirbp", "slirg", "sldirport", "slirpi", "slrinport", "slwarphp", "splirps", "glirport", "slirtpi", "liirl", "slvrport", "slirocp", "islirbp", "splarp", "slibrn", "slirlp", "splirg", "glpirp", "slirtphp", "sslirm", "plierpen", "slrirpatch", "splirtcp", "selibrsp", "slrinphp", "slirkbp", "slibrsp", "slpirpo", "slirpy", "slirmn", "slpircp", "slirpatch", "splirmpi", "splirphp", "slirpin", "sllrpc", "selirv", "islairp", "islirpid", "plirphp", "selibrn", "slairpatch", "splirjp", "slirl", "slirping", "splmirpi", "slwarp", "glpirport", "slrirpa", "sliverpi", "slierpd", "salrirport", "sllrcp", "slrinpi", "salrirpatch", "slirlcp", "slpirport", "slrirpid", "slrirport", "glirpa", "slrirm", "slirpc", "glirp", "sslierpa", "slirkpid", "slwarpin", "slairg", "sldirpi", "slirtp", "slererping", "slirphp", "slvrpatch", "slirsp", "slirn", "sslierping", "slarphp", "salirp", "spllrpa", "slirps", "slpirpa", "plierphp", "slrirp", "slirtcp", "slrirpd", "slorp", "slorpa", "salirpa", "slierm", "slircport", "slrirpo", "slmircp", "salrirpa", "slrirps", "slyrm", "slwarg", "slorpin", "slircphp", "splmirphp", "slierps", "slibrp", "slpirsp", "selibrv", "slirvp", "splirpc", "slierphp", "liircp", "slpirv", "slirop", "splrirg", "sllrpa", "slircve", "splrirpin", "liircpy", "slirport", "slyrpid", "slirpen", "slyrpa", "spllrcp", "splirpi", "slirm", "splmirp", "slircping", "slairpin", "slrirvp", "slrinp", "splarphp", "splirpin", "splirm", "slierpid", "sslirping", "sliverpatch", "slirtpatch", "sslierpid", "slierp", "slrirpin", "slmirpi", "slirmcp", "slrirphp", "slvrpa", "sslierp", "slarpy", "slrirg", "plierps", "slwarpen", "slmirp", "splircp", "slyrp", "slirve", "slererve", "sliverphp", "slairp", "glirpo", "sliverp", "slircl", "sldirp", "slpirn", "spllrpc", "slyrcp", "slarport", "slwarpa", "splirp", "slierpen", "splirmps", "slierping", "slibrv", "islairbp", "sllrp", "glpirpa", "splirpatch", "slirlpi", "slirlps", "spllrp", "sliropc", "liircl", "liirpy", "slirpd", "slmirpatch", "slirmp", "slyrl", "slyrpd", "islairpid", "slpirpi", "selibrp", "slirpo", "slierve", "sliropa", "islirp", "slibrcp", "sslirpa", "slibrpi", "slwarps", "plirps", "slmirjp", "sslirpd", "splirmcp", "slwarm", "plirp", "slmirphp", "slircpy", "sslierpd", "sslirp", "sslierve", "slyrpy", "selirn", "salirpatch", "slairvp", "sslierm", "slirmsp", "slairpid"], "if_queued": ["if_queumed", "if__quesued", "if_queueued", "if_queueue", "if_execlected", "if__queues", "if__queuing", "if_queueless", "if_paued", "if_paues", "if_paueless", "if_fiued", "if_queues", "if_quesuing", "if_execumed", "if_queueues", "if__quesuing", "if_quesumed", "if_Queued", "if_queueumed", "if_meues", "if_execues", "if_queue", "if_continue", "if_meued", "if_queied", "if_queuated", "if_fiuing", "if__quesumed", "if_quesueless", "if_queuer", "if_execued", "if_Queuer", "if_quesuated", "if__queumed", "if_queuing", "if_quesued", "if_meueless", "if__queue", "if_queslected", "if_Queuing", "if_continumed", "if_quelected", "if__queued", "if_quesues", "if_queuelected", "if_fiied", "if__quelected", "if_quesue", "if_Queied", "if__quesues", "if_continuing", "if_meuated", "if_queueuing", "if_pauated", "if__queslected", "if__quesue", "if_fiuer", "if_continued"], "ifq_so": ["ifrequ_so", "iff_pri", "ifdq_sel", "ifrequ_SO", "ifrequ_sel", "ifq__SO", "ifq2SO", "ifq__num", "iff_since", "ifdq_pri", "ifq_since", "ifq_sel", "ifq__sel", "iff_so", "ifq2since", "ifq__so", "ifdq_since", "ifq2so", "ifdq_so", "ifq_num", "iff_SO", "ifq2pri", "ifq_pri", "ifrequ_num", "ifq_SO"], "so_queued": ["so_Queuing", "so2quesue", "so_quesued", "so_queueue", "so_queuing", "so2quesued", "so2queue", "so_queueued", "so2queued", "so_queueuer", "so2quesuer", "so2quesuing", "so2queuer", "so_queue", "so_queuer", "so2queuing", "so_quesuer", "so_Queuer", "so_queueuing", "so_Queue", "so_quesue", "so_Queued", "so_quesuing"], "requeued": ["Requeue", "requeanted", "requeilled", "crequemented", "requesmented", "Requeanted", "reketued", "REqueuated", "requeueilled", "Requeueued", "requer", "repeanted", "requerilled", "reqressed", "reciued", "requesued", "requesuated", "requed", "requeueued", "Requeued", "requemented", "requeuer", "requated", "reqanted", "repeued", "requerue", "reciressed", "requeueue", "requeruated", "crequesuated", "REqueued", "requeuated", "requerued", "REqueilled", "reque", "Requeueue", "reqmented", "crequesmented", "reciuated", "REqueueuated", "requesressed", "crequesued", "repeuer", "reketue", "Requeueuer", "crequeressed", "crequesressed", "REqueue", "REqueueue", "crequeued", "recimented", "repeue", "Requeuer", "requeressed", "reketuated", "requeueanted", "requeueuated", "requeue", "crequeuated", "REqueueued", "Requeueanted", "REqueueilled", "requeueuer", "reketilled"]}}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595, "substitutes": {"check": ["command", "exec", "link", "comp", "store", "lock", "report", "checks", "run", "read", "image", "add", "scan", "status", "fail", "clean", "old", "def", "form", "entry", "set", "make", "work", "control", "CHECK", "filter", "load", "warn", "full", "process", "complete", "save", "match", "send", "call", "cp", "rank", "problem", "task", "close", "start", "handle", "transform", "operation", "init", "get", "look", "scale", "print", "context", "query", "see", "step", "upload", "processing", "comment", "out", "view", "ck", "clear", "sync", "error", "delete", "search", "good", "condition", "wait", "empty", "download", "test", "parse", "cache", "cmp", "post", "checked", "show", "valid", "ack", "block", "find", "update", "ok", "req", "draw", "code", "import", "Check", "help", "analysis"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n", "idx": 26599, "substitutes": {"STATUS_PARAM": ["STATUS_VAR", "STATUS_ARM", "STATUS_PAR", "STATUS_PAM", "STATUS_PARM", "STATUS_ARAR", "STATUS_PM", "STATUS_PARAMS", "STATUS_VM", "STATUS_VAMS", "STATUS_ARAMS", "STATUS_PAMS", "STATUS_PARAR", "STATUS_VAM", "STATUS_ARAM"], "zSign": ["oSIGN", "izMask", "tsign", "ZMod", "gzSign", "osign", "ziMask", "ziIncre", " zsign", "zhMod", "izSign", "gzSIGN", "zForm", " zForm", "ozForm", "ZRank", "tSIGN", "zMod", " zSIGN", "gzsign", "zhsign", "zhMask", "ziForm", "zhRank", "ZSign", "zSIGN", "zRank", " zMod", "tSign", "ozIncre", " zRank", "ozMask", "ziSign", "zhSign", "oSign", "zMask", "izsign", " zMask", "zsign", "izSIGN", " zIncre", "zIncre", "ozSign", "gzMask", "zhSIGN"]}}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620, "substitutes": {"intp": ["acpc", "intpt", "intpid", "interm", "interpc", "extpid", "intpa", "acp", "intpc", "intm", "acm", "extpa", "acpa", " intpc", " intm", "extp", "inetpt", "interpa", "inetp", "inetpa", "interp", " intpid", "extpt", "inetpid", " intpa", " intpt"], "ret": ["nt", "backed", "rem", "res", "gc", "ter", "red", " alt", "val", "print", "rt", "f", "rets", "mem", "__", "tr", "det", "leg", "reset", "reg", "elt", " Ret", "bool", "ry", "Return", "t", "len", "cat", "ref", "lit", "deg", "ft", "str", "gt", "status", "Ret", "out", "inter", "rm", "not", "mt", "RET", "flag", "def", "try", "cont", " RET", "back", "re", "alt", "j", "et", "prop", "mb"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642, "substitutes": {"s": ["sv", "v", "hs", "is", "n", "gs", "js", "ms", "ses", "changes", "services", "S", "fs", "ns", "ss", "b", "ts", "qs", "parts", "ops", "t", "cs", "south", "less", "ats", "sb", "ins", "comm", "m", "aws", "ds", "ls", "sw", "ares", "os", "a", "es", "rs", "ies", "h", "vs", "as", "l", "st", "stats", "bs", "sts", "als", "its", "c", "sq", "ps", "set"], "p": ["v", "ap", "pc", "vp", "tap", "parse", "tp", "pre", "n", "bp", "pa", "wp", "post", "lp", "jp", "sp", "op", "b", "r", "pers", "pp", "pkg", "at", "t", "ip", "m", "ping", "pad", "g", "pt", "P", "d", "cp", "rep", "q", "a", "part", "up", "perm", "fp", "h", "l", "pe", "resp", "np", "pm", "y", "i", "pb", "c", "j", "php", "ps", "w"]}}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n", "idx": 26653, "substitutes": {"errp": ["rrpress", " erp", " erpress", " errr", " errpress", "arrP", " err", " errP", "arrr", "rrr", "arrbp", "erp", "erbp", "errbp", "erP", "arrp", "errP", "errr", "rrp", " errbp", "errpress", "err"], "cs": ["pc", "ces", "hs", "ks", "gs", "js", "ms", "cas", "fs", "ns", "ss", "ps", "ts", "qs", "ics", "ats", "cus", "ec", "ims", "cc", "ds", "cf", "ls", "ows", "wcs", "cp", "ck", "cks", "rs", "Cs", "sc", "acs", "s", "rc", "sys", "ys", "sts", "bs", "its", "c", "caps", "CS", "css", "ctx"], "cpu": ["linux", "runner", "pc", "bench", "cache", "sky", "gc", "util", "cam", "ctx", "node", "aux", "net", "aq", "phy", "pid", "process", "cmd", "pkg", "processor", "pu", "cu", "boot", "lib", "clock", "ork", "gpu", "hw", "cow", "kernel", "cp", "ck", "nic", "px", "hz", "pixel", "nn", "chip", "np", "us", "cum", "c", "CPU", "proc", "socket", "prof", "core"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n", "idx": 26663, "substitutes": {"l2hdr": ["l2haddr", "l2Hst", "l2phst", "l2hspar", "l2thaddr", "l2thdr", "l3hdr", "l2phpar", "l1thpar", "l2Hint", "l2thDR", "l2phaddr", "l1hDR", "l3hDR", "l2phint", "l3hst", "l1hdr", "l2thpar", "l3phint", "l2HDR", "l2ohint", "l2hint", "l2Hdr", "l1hpar", "l1thaddr", "l2ohDR", "l3hint", "l2ohdr", "l3phst", "l2hsDR", "l1haddr", "l3phdr", "l2phDR", "l2phdr", "l2ohst", "l2hDR", "l2hst", "l1thDR", "l3phDR", "l1thdr", "l2hpar", "l2hsdr", "l2hsaddr"], "iphdr": ["ihder", "phder", "ipder", "iphtr", "ophdr", "aphder", "ihdr", "ericdro", "aphdat", "phyder", "ipd", "iphd", "ericdr", "ipdr", "phdr", "ihdro", "phd", "iphbr", "ihdat", "phyd", "ophdat", "ophtr", "iphstr", "ihtr", "ericd", "phbr", "ipbr", "aphdr", "iphdat", "iphder", "ihstr", "ihd", "ericder", "ipstr", "phydr", "iphdro", "phstr", "aphtr", "phydro", "ihbr", "ophder"], "new_ip_off": ["new_ipxpos", "new_ip_fun", "new_IP_fun", "new_op_offset", "new_ipableoff", "new_ip_offset", "new_ipableon", "new_op_off", "new_ip_on", "new_ipxon", "new_ipablefun", "new_IP_off", "new_ipxoff", "new_IP_on", "new_op_on", "new_ip_pos"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 26671, "substitutes": {"a": ["ma", "ca", "aj", "la", "ap", "ba", "sa", "na", "am", "ar", "aaa", "an", "at", "area", "act", "\u00e0", "ity", "ac", "ae", "da", "ach", "d", "aa", "apa", "ab", "up", "A", "s", "au", "as", "oa", "ao", "ia", "i", "sta", "ata"], "b": ["B", "v", "ba", "bis", "db", "bp", "bar", "f", "ob", "rb", "eb", "bc", "blue", "sb", "by", "p", "g", "bb", "d", "be", "nb", "base", "ab", "fb", "ib", "s", "br", "bs", "i", "c", "j", "bi"], "env": ["er", "v", "obj", "vp", "conn", "db", "server", "chart", "qv", "txt", "sp", "jp", "end", "EN", "viron", "config", "context", "mem", "tx", "cb", "manager", "block", "stack", "shell", "req", "ec", "e", "code", "hw", "dev", "en", "environment", "ah", "nv", "te", "engine", "ev", "worker", "window", "vs", "conf", "En", "buf", "proc", "kw", "ctx"]}}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n", "idx": 26673, "substitutes": {"bsum": ["bssum", "thsub", "bissum", "thsum", "bsam", "psum", "gsus", "cksumer", "gsub", "bpsam", "gsul", "nsus", "cksumm", "BSsum", "bitssum", "bitsumm", "nsum", "thsus", "bisumm", "psrub", "ckssum", " basesum", "bpsumm", "bsub", "cksam", "nsub", "bpssum", "bpsum", "nsul", " basesumm", "bitsumer", "bsumm", " basesrub", "cksum", "thsul", "pssum", "BSumm", "bisumer", "bsul", "bitsam", "bitsum", "bisum", " basessum", "bsrub", "psumm", "bsumer", "bsus", "BSrub", "gsum", "BSum"], "i": ["n", "adr", "iter", "li", "ij", "iat", "ix", "xi", "ai", "gi", "ci", "di", "attr", "pp", "ii", "t", "mi", "ip", "ic", "by", "p", "e", "m", "multi", "ui", "d", "pi", "id", "im", "y", "ti", "phi", "j", "index", "x", "php", "it", "si", "bi", "ind", "I"], "sum": ["nt", "cache", "v", "acc", "cmp", "sort", "result", "count", "zero", "tu", "Sum", "sa", "max", "aw", "sam", "ut", "mem", "go", "mu", "n", "mod", "report", "set", "mix", "um", "new", "html", "comment", "total", "uf", "sh", "match", "add", "sim", "hash", "doc", "mm", "status", "out", "pack", "cal", "ul", "mean", "trace", "size", "share", "summary", "su", "sc", "score", "vol", "au", "st", "num", "us", "tmp", "cum", "j", "index", "temp", "si", "un", "all"]}}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n", "idx": 26680, "substitutes": {"dev": ["Device", "data", "nt", "v", "ve", "sky", "cam", "dd", "exec", " devs", "ctx", "DEV", "stick", "disk", "devices", "tech", "go", "env", "spec", "iv", "serial", "scan", "sd", "hw", "pad", "name", "device", "ds", "Dev", "d", "debug", "os", "pi", "ev", "ad", "adv", "def", "des", "vs", "de", "sys", " device", "ptr", "dis", " Dev", "test", "ver", "w"], "errp": ["errpb", " errping", " errps", "rrping", "usrping", " errpb", "errping", "rrpc", "errpc", "Erpc", "Erpb", "errps", "rrpa", "usrp", "rrpb", " errpa", "rrps", "usrps", " errpc", "Erp", "rrp", "errpa", "usrpa"], "ics": ["ips", "args", "bits", "is", "iss", "ks", "isc", "js", "nz", "ric", "oc", "icks", "cons", "ICS", "isk", "mic", "ns", "ix", "isch", "icons", "iris", "checks", "his", "ts", "ick", " ic", "qs", "ox", "ires", "ico", "cs", "ats", "cus", "las", "rics", "ic", "ins", "ims", "ec", "irc", "pic", "ds", "ls", "wcs", "icc", "nic", "px", "ents", "eric", "ices", "rs", "acs", "IC", "vs", "ris", "stats", "bs", "xs", "its", "ik", "ps", "css"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n", "idx": 26701, "substitutes": {"vs": ["sv", "vals", "v", "vp", "hs", "iss", "ks", "gs", "ms", "bp", "eps", "obs", "fs", "ns", "VS", "vm", "ss", "vd", "ps", "ts", "qs", "cs", "vt", "ins", "ims", "ds", "ls", "values", "es", "rs", "s", "us", "stats", "bs", "sts", "atts", "its", "Vs", "vc", "ov", "vr"]}}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n", "idx": 26711, "substitutes": {"sch": ["her", "ih", "hs", "ksh", "gr", "sp", "sche", "sam", "isch", "ss", "cr", "mk", "shed", "tg", "orsche", "oss", "chan", "rys", "sol", "tek", "Sch", "ssl", "https", "sh", "sk", "kh", "roth", "sb", "sd", "ich", "eng", "cfg", "sl", "shop", "sw", "rh", "css", "sg", "ssh", "urus", "osc", "sc", "soc", "chid", "sys", "chip", "cht", "gh", "hed", "tk", "wk", "ech", "disc", "chu", "igm", "kr", "ch"], "orb": ["rib", "orbit", "nut", "emb", "usb", "opl", "om", "urb", "gob", "ob", "ore", "umb", "osp", "bol", "mol", "orp", "eb", "erb", "orget", "arb", "obb", "org", "ori", "vor", "orn", "bj", "rob", "orm", "orf", "absor", "ior", "rab", "ocl", "ogg", "obar", "etc", "mor", "mb"], "s": ["sv", "sis", "ex", "n", "is", "tp", "hs", "gs", "js", "sp", "fs", "S", "sam", "ns", "f", "ss", "z", "ts", "qs", "sol", "spec", "cs", "less", "sh", "sb", "sd", "comm", "m", "g", "sl", "ds", "ls", "sw", "es", "os", "so", "rs", "sc", "h", " ss", "vs", "sys", "conf", "us", "stats", "sts", "ass", "c", "sports", "y", "ps", "set", "w"]}}
{"project": "qemu", "commit_id": "e25cad6921ef78c8e2b7a4f59b03545bd675a9ad", "target": 1, "func": "static int sd_snapshot_delete(BlockDriverState *bs,\n\n                              const char *snapshot_id,\n\n                              const char *name,\n\n                              Error **errp)\n\n{\n\n    unsigned long snap_id = 0;\n\n    char snap_tag[SD_MAX_VDI_TAG_LEN];\n\n    Error *local_err = NULL;\n\n    int fd, ret;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;\n\n    uint32_t vid;\n\n    SheepdogVdiReq hdr = {\n\n        .opcode = SD_OP_DEL_VDI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26725, "substitutes": {"bs": ["BS", "bits", "hs", "gs", "bis", "bi", "bp", "js", "obs", "fs", "blog", "bg", "ns", "ss", "b", "ts", "bos", "bc", "cs", "bl", "sb", "bh", "ds", "bb", "ls", "bd", "os", "rs", "bm", "vs", "lbs", "sts", "its", "pb", "bt", "ps"], "snapshot_id": ["snapshot___data", "snapot_ID", "snapsnap_ids", "snapot2id", "snapshot2ID", "snapshot_data", "snapshot___name", "snapshot_ids", "snapot2name", "snapshot___ID", "snapshot_tag", "snapot2ID", "snapsnap_data", "snapsnap_ref", "snapsnap_no", "snapshot2data", "snapshot___id", "snapsnap_tag", "snapot2data", "snapshot__id", "snapot_id", "snapshot_no", "snapshot2no", "snapot_name", "snapot_data", "snapshot_name", "snapshot_info", "snapshot2id", "snapshot__ref", "snapshot_ref", "snapsnap_id", "snapshot2name", "snapshot__tag", "snapshot_ID", "snapsnap_name", "snapsnap_info", "snapshot__name"], "name": ["data", "create", "n", "ename", "named", "mem", "group", "tag", "NAME", "description", "b", "run", "class", "cmd", "names", "path", "comment", "key", "dir", "filename", "zone", "ref", "space", "version", "status", "format", "table", "title", "id", "base", "part", "no", "error", "snap", "prefix", "value", "package", "size", "nm", "label", "nam", "word", "type", "ame", "alias", "Name", "w"], "errp": [" errps", "warnpa", "warnp", "cerpc", "errorpc", " errP", "errorP", "errpc", "cerps", "errps", "erp", "cerP", "cerp", " errpa", "erP", "errorp", " errpc", "warnP", "errP", "errpa", "erpa", "errorps"], "snap_tag": ["aptmmtoken", "snapPtag", "snapjcard", "snap_log", "shot_log", "shot_string", "snapmmtag", "snaplytoken", "snap_token", "snap_id", "shot_tag", " snap_name", " snap_tags", " snap2cat", "snapistname", "apt_token", "shot_pack", "snapptname", "shot_var", "snapjtag", " snap_hash", "shot_name", "snapjmt", "snap2tags", "shot_id", "aptmmhash", "snap_string", "aptmmid", "snapjid", "snapttags", "snapptvar", "snap_field", "snaplytag", " snap_cat", "snap_pack", "snaptname", "snapPname", "snap2cat", " snap_field", "snap_hash", "snap_card", "snap2tag", "snaptcat", "snappttag", "snap_name", " snap_string", "apt_id", "snaplyid", "snapisthash", "snap_tags", "snapisttag", " snap2tags", "snapPlog", "shot_mt", "apt_tag", "shot_card", "snapmmid", "snaplyhash", "snapmmhash", "snap_mt", "snapmmtoken", "snapthash", "snapttag", "apt_hash", "aptmmtag", "snap_var", " snap2tag", "snapPvar", "snap_cat", "snapptlog"], "local_err": [" local_bar", "local_usr", "localaxybar", "localaxyerr", "local____error", "foreign_err", "local____err", "local_error", "local____notice", "local___arr", "foreign_usr", "foreignErnotice", " local___msg", "local_notice", "local____usr", "foreignErusr", "local_msg", "localErusr", " local___arr", "local___msg", "local_res", "localErerror", "foreignErerr", "local_arr", "foreign_notice", " local___err", " local_arr", " local_msg", "local_bar", "foreignErerror", "foreign_error", "localErerr", "localErnotice", "localaxyres", " local_res", "local___err"], "fd": [" fut", "df", " f", "fin", "dd", "db", "fr", "fa", "bf", " fin", "fs", "cd", " fid", "file", "f", "gd", " ff", "td", "fat", "FD", "fc", "ud", "pid", "fn", "dt", "lf", "dir", "dat", "ds", "d", "bd", "fee", "id", " dur", "nd", "af", "fp", "ld", "fi", "dl", "ff", " fs"], "ret": ["rev", "nt", "rem", "tif", "res", "nl", "result", "fin", "gc", "ter", "db", "final", "val", "ll", "rt", "rets", "mem", "leg", "tr", "det", "cb", "reset", "elt", "cert", "nat", "bool", " Ret", "complete", "dt", "new", "t", "len", "fun", "ref", "deg", "ft", "gt", "status", "Ret", "out", "vet", "rm", "id", "not", "mt", "RET", "lt", "flag", "def", "try", "fi", "cont", "failed", "back", "done", "re", "alt", "j", "ptr", "success", "it", "err", "set", "lit"], "buf": ["rev", "data", "v", "cv", "vp", "ba", "cam", "gc", "db", "raw", "ctx", "txt", " buffer", "mem", "seq", "tx", "buff", "cb", "b", "rb", "r", "vec", "box", "cmd", "pkg", "bytes", "act", "dc", "uf", "bin", "ref", "doc", "buffer", "aka", "off", "queue", "window", "fb", "Buffer", "cur", "img", "rc", "br", "tmp", "cap", "wb", "desc", "pb", "batch", "ff", "bt", "prop", "bag", "err", "w"], "s": ["sv", "v", "bits", "settings", "n", "is", "hs", "gs", "js", "sa", "bis", "ses", "fs", "S", "sp", "ns", "ss", "b", "ts", "state", "t", "cs", "ats", "sb", "ins", "p", "g", "ds", "ls", "os", "a", "es", "rs", "sc", "h", "vs", "st", "sys", "conf", "as", "stats", "sts", "its", "c", "socket", "sn", "ps", "sm"], "vid": [" pid", "rev", " wid", "v", "vis", "mid", "gc", " rev", "cas", " tv", " pos", "irt", "val", "uv", " guid", "seq", "rid", "var", "bid", "vd", "pid", "vr", "lang", "uid", " sid", "sid", "dt", "tv", "VID", "lan", "len", " virt", "vt", "oid", "wat", "visible", " lid", " rid", " tx", "id", " vers", "virt", " VID", "wid", "vs", " av", "vc", " vis", " tid", " resid"], "rsp": ["rtp", "rcSP", "Rsw", " rSP", "Rtp", "rcsw", " rtp", "RSP", " rsw", "rctp", "rcsp", "Rsp", "rsw", "rSP"]}}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726, "substitutes": {"f": ["alf", "v", "fr", "bf", "fs", "file", "fo", "ent", "sf", "tf", "b", "r", "z", "F", "fc", "fn", "xf", "fw", "lf", "t", "fac", "uf", "inf", "rf", "fm", "o", "fd", "p", "e", "m", "ft", "g", "fx", "cf", "d", "u", "q", "ef", "fb", "fed", "af", "fp", "h", "s", "l", "fi", "conf", "form", "ff", "c", "x", "temp", "w"], "opaque": ["opz", "openaque", " opos", " opz", "openos", "ipz", "ipos", "openz", "ipaque", "opos", "opencode", " opcode", "ipcode", "opcode"], "ret": [" fut", "backed", "obj", "nz", "txt", "jp", "val", "aux", "net", "leg", "cb", "reset", "elt", "run", "cmd", "len", "vt", "ref", "oret", "deg", "expr", "status", "jump", "arg", "locked", "att", "def", " RET", "ber", "alt", "nt", "rem", "result", "det", " Ret", "usr", "fun", "arr", "cat", "ft", "str", "Ret", "inter", "pret", "RET", "addr", "back", "re", "desc", "ptr", "rest", "success", "lit", "rev", "final", "git", " alt", "print", "ll", "rt", "rets", "tr", "r", "cert", "ry", "new", "out", "vet", "mt", "lt", "flag", "dr", "try", "resp", "cont", "sys", "tmp", "plain", "url", "res", "ter", "red", "ext", "valid", "reg", "Return", "t", "secure", "pub", "code", "gt", "rm"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)\n\n{\n\n    int i, n, n2;\n\n    float alpha;\n\n\n\n    n  = 1 << ln;\n\n    n2 = n >> 1;\n\n\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);\n\n\n\n    for (i = 0; i < n2; i++) {\n\n        alpha     = 2.0 * M_PI * i / n;\n\n        mdct->costab[i] = FIX15(cos(alpha));\n\n        mdct->sintab[i] = FIX15(sin(alpha));\n\n    }\n\n\n\n    return 0;\n\nfft_alloc_fail:\n\n    mdct_end(mdct);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 26730, "substitutes": {"avctx": ["avgc", "vctx", "cvctx", "vercu", "averctx", "avercontext", "vctl", " avgc", "avcontext", "verctx", "svcontext", " avtx", " avconn", "avercu", "vcontext", " avcu", "svctx", "avergc", "svconn", "cvctl", "svgc", "avconn", "vconn", "cvcontext", "vercontext", "vertx", "averconn", "cvconn", " avcontext", "avertx", " avctl", "avtx", "avctl", "avcu"], "mdct": ["cmdect", " mdcont", " mdCT", "cmdkt", "dmcat", "mpcont", "mdect", "mnwt", "mnct", " mdoc", "mdt", "cmdoc", "mpwt", "mnt", "dmect", " mdtt", "cmdtt", "mpnt", "mnoc", "mdtt", "mditt", "dmcrit", "mdoc", "mdkt", "mdcrit", "mplt", " mdlt", "mnCT", "mnkt", "cmdlt", "mnect", " mdect", "mnitt", "mnnt", "cmdt", " mditt", "cmdCT", "mdnt", "mdcat", "mdCT", "mncrit", "mpct", "cmdcat", "mdlt", "dmnt", "mdwt", "dmct", "cmdwt", "mncat", " mdkt", "mpt", "cmdnt", "mncont", " mdnt", "dmCT", "cmditt", "mdcont", "mntt", "cmdct", "cmdcrit", "cmdcont"], "ln": ["nl", "weight", "li", " ni", "oln", "kl", "ns", " lvl", "tn", "lin", "vl", "loc", "mn", "pn", "margin", "fn", "lf", "len", "lines", "wn", "line", "ls", " fn", "nb", "ul", "bn", " l", " nm", "lr", "gn", " len", "con", "l", "nn", "span", "label", "lvl", "sn", "lag", "rn", "ind", "dl"], "i": ["qi", "v", "is", "batch", " I", "ind", "li", "ij", "print", "f", "ix", "it", "xi", "ai", "ini", "ji", "gi", "ci", "ki", "info", "di", "ik", "um", "ii", "this", "ip", "mi", "ei", "sim", "ic", "m", "multi", "p", "o", "status", "chain", "ui", "ri", " ii", "q", "pi", "\u0438", "uri", "series", "iu", "ish", "point", "fi", "span", "ti", "zi", "phi", "c", "x", "index", "j", "y", "ie", "si", "bi", "ice", "all", "I"], "n": ["nt", "v", "k", "nl", "dn", "na", "nu", "ns", "f", "ne", "mn", "b", "z", "an", "fn", "nan", "t", "len", "cn", "o", "m", "p", "ni", "en", "g", "N", "d", "nb", "size", "gn", "l", "nn", "nm", "num", "np", "j", "c", "x", "sn", "nc", "network"], "n2": [" n1", " n256", "l02", "nt02", "N256", "N2", "N02", "ntwo", "i62", "nc2", "n02", "N1", "ltwo", "an02", "i2", "nt2", "l1", "i02", " n3", "nt62", "n62", "dntwo", "l3", "n256", "nttwo", "n1", " n62", " ntwo", "dn2", "an2", "nc1", " n02", "Ntwo", "an3", "itwo", "antwo", "l2", "n3", "nc256"], "alpha": ["Delta", "ma", "acl", "la", "ph", "acc", "eta", "face", "ta", "alph", "weight", "fa", "scale", "power", "prime", "beta", "asc", "ace", "instance", "lambda", "ani", "iso", "xa", "info", "ppa", "pp", "hi", "ati", "Alpha", "al", "upper", "ac", "HA", "mad", "p", "sha", "qa", "pi", " delta", "a", "prefix", " gamma", "capital", " \u03b1", "aff", "ho", " amp", "factor", "balance", "phi", "ia", "alias", "pha", "angle", "igma", "si"]}}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26734, "substitutes": {"env": ["sv", "er", "v", "ve", "cv", "vp", "ten", "conn", "db", "uv", "Environment", "viron", "end", "config", "esp", "context", "estate", "tx", "hl", "store", "event", "cmd", "usr", "setup", "vt", "eh", "req", "ec", "erd", "e", "hw", "eng", "en", "environment", "dev", "ah", "kernel", "sw", "org", "nv", "esc", "ew", "window", "ev", "te", "ef", "here", "worker", "def", "vs", "conf", "global", "addr", "param", "exc", "inv", "et", "msg", "kw", "network", "cfg", "set"], "tb": ["ttbr", "tsb", "tp", "ptb", " tfb", " tv", "mbc", "tenb", "ttrb", "ptv", "mfb", "tfb", "ttv", " tbt", "tch", "itv", "ttb", "tbt", "tenbc", "tsbr", "ttbt", "mv", "trb", "tv", "ttp", "ptp", "tenv", " tch", "tbc", "ptbr", " trb", "ttch", "tsv", " tp", "itbt", "tsp", "ptch", "itrb", "tenfb", " tbc", "tbr", "itb", "mb"], "search_pc": ["search_pb", " searchingpb", "match_PC", " searchingpc", " search_pb", "match_proc", "match_pc", "search_PC", "searchingp", " search_proc", "searchablepc", "searchablepb", " search_PC", "searchingproc", "searchingPC", "searchablePC", "searchingpb", " searchingPC", "search_proc", "searchablep", "match_p", "searchingpc", "search_p", " searchingproc", "searchableproc"], "insn_count": ["insns_count", "insn_size", "insn_cache", "insn_c", "insns_size", "insns_cache", "insns_c"], "ctx": ["acl", "obj", "max", "conn", "util", "txt", "jp", "aux", "kj", "tx", "cb", "loc", "kt", "cmd", "pkg", "xc", "func", "pg", " context", "ac", "p", "hw", "tz", "sc", "conf", "np", "tk", " cx", "nt", " cla", "gc", "ns", "wd", "lc", "act", "cu", "kh", "ct", "cp", "crit", "prefix", " k", "addr", "handle", "ctrl", "kw", "cfg", "ca", "cv", "local", "xp", "rt", "wx", "context", "timeout", "hl", "fw", "conv", " sc", "cf", "rc", "resp", "ctr", "xy", "tmp", "Context", "sys", "index", "proc", "msg", "unc", "alloc", "abc", "cmp", "co", "config", "t", "req", "gt", "cc", "jac", "esc", "ww", "tc", "xs", "scope", "x", "utils", " cc"], "ctxp": ["ktfp", "ectxp", "CTfp", "ktxy", "ectxt", "ectfp", "ktxp", "ctfp", "ctxy", "ctxt", "ectxy", "CTxp", "CTxt", "CTxy", "ktxt"], "pc_start": ["pc__begin", "pc__end", "pc2offset", "pc__start", "p_start", "p_int", "pc_end", "pc2end", "proc_end", "proc_next", "PC_start", "pc_next", "PC_offset", "proc_start", "pc2begin", "pc__offset", "pc_offset", "PC_end", "pc_int", "pc2next", "proc_begin", "PC_begin", "pc_begin", "p_end", "pc2int", "pc2start"], "insn": ["psn", "ainsns", "psns", "ainsn", "inns", "inc", "insns", "ingn", "insgn", "psc", "ainsc", "psgn", "ainsgn", "insc", "inn"], "gen_opc_end": ["gen_opn_ptr", "gen_opn_start", "gen_opr_end", "gen_opc_ptr", "gen_opr_ptr", "gen_opc_start", "gen_opc_buf", "gen_opn_end", "gen_opr_buf", "gen_opn_buf"], "bp": ["vp", "tap", "tp", "bis", "bi", "pa", "wp", "lp", "bf", "jp", "lb", "sp", "hit", "bg", "xp", "esp", "cb", "rb", "b", "cmd", "gp", "bc", "bl", "sb", "p", "bh", "bb", "cp", "nb", "fb", "bj", "fp", "hp", "kb", "bsp", "lbs", "np", "bs", "tk", "BP", "vc", "pb", "proc", "bt", "ps"], "j": ["init", "v", "aj", "obj", "n", "k", "js", "J", "jo", "next", "ot", "ij", "jp", "json", "jl", "prime", "f", "kj", "tr", "ji", "r", "step", "z", "adj", "t", " jump", "o", "p", "my", "str", "jj", "g", "d", "jump", "q", "uj", "jc", "gov", "ju", "no", "h", "l", "br", "i", "index", "x", "dj", "ja", "it", "ch"], "ret": ["rev", "nt", "rem", "res", "result", "nz", "ert", "ext", "val", "ll", "rt", "tf", "rets", "tn", "tr", "r", "reset", " Ret", "cmd", "usr", "ry", "true", "Return", "xt", "len", "fun", "ref", "ft", "gt", "Ret", "out", "biz", "arg", "mt", "RET", "def", "try", "ctr", "cont", "resp", "back", "re", "alt", "err"], "num_insns": ["num_lscs", "num_inns", "num_nsns", "num_inssts", "num_inn", "num_insni", "num_insts", "num_itsls", "num_psn", "num_itsns", "num_itscs", "num_nsxs", "num_synns", "num_intersns", "num_itsn", "num_pscs", "num_synn", "num_inni", "num_intersni", "num_insn", "num_INSns", "num_intersn", "num_inls", "num_pssts", "num_insxs", "num_lssts", "num_lsns", "num_INSni", "num_inxs", "num_insls", "num_nsn", "num_synxs", "num_incs", "num_inscs", "num_interscs", "num_psns", "num_INScs", "num_lsn", "num_INSn"], "max_insns": ["max_vsxs", "max_vsns", "max_insons", "max_nscs", "max_incs", "max_ainsons", "max_inports", "maxWconsans", "max_isings", "max_consans", "maxWinsans", "max_inons", "max_isinn", "max_nsn", "max_linsns", "max_ings", "max_alsns", "max_linsls", "max_insgs", "maxWconsn", "maxWconsgs", "max_alsans", "maxWinsn", "max_vsn", "max_inns", "max_inxs", "max_insls", "max_linsports", "max_consgs", "max_alsn", "max_inls", "max_linsons", "max_nsns", "max_inqs", "max_nsqs", "max_ainsn", "max_consns", "maxWinsns", "max_linsqs", "maxWconsns", "max_linscs", "max_ainsports", "max_consn", "max_inscs", "max_linsn", "max_ainscs", "max_ainsls", "max_isinxs", "max_insn", "max_vsgs", "max_inans", "max_insxs", "max_insports", "max_inn", "max_insans", "maxWinsgs", "max_alsgs", "max_ainsns", "max_insqs", "max_isinns"], "lj": ["lluj", "eljs", "llj", "slj", "llkj", "lldj", "eljl", "liuj", "ljl", "lJ", "lng", "lifr", "llgh", "slz", "llv", "elz", "luj", "lbbj", "laj", "leftuj", "llth", "laJ", "lbjs", "elj", "ludj", "lji", "lujs", "elJ", "lij", "sljs", "lgh", "lajl", "lth", "eluj", "lfr", "lijl", "luth", "lbkj", "liji", "lijs", "slJ", "elfr", "lljs", "llaj", " lJ", "lv", "liz", "lbji", "lbgh", "lcbj", " lbj", "lcng", "lcjs", "ljs", "lz", "likj", "lcj", "leftj", "llz", "liJ", " lng", "ldj", " ljs", "sldj", "llji", "lbj", "lkj", "lbng", " lv", "ligh", "liv", "slth", "leftjs", "elv", "leftaj", "sluj", " luj", " laj", "lafr"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738, "substitutes": {"vs": ["sv", "vals", "v", "vp", "is", "ks", "gs", "js", "ms", "ves", "obs", "fs", "params", "uv", "ns", "VS", "ss", "vd", "ps", "ts", "qs", "vers", "ops", "cs", "vt", "sb", "ims", "ds", "ams", "ls", "es", "rs", "s", " ss", "sys", "stats", "bs", "Vs", "vr"], "job": ["command", "runner", "work", "bug", "result", "db", "J", "bar", "build", "obs", "next", "jp", " jobs", "node", "common", "vision", "pro", "item", "ob", "tag", "b", "run", "cor", "program", "process", "photo", "cmd", "journal", "block", "state", "sum", "new", "cell", "image", "coord", "m", "Job", "sub", "figure", "queue", "bot", "library", "out", "py", "package", "worker", "up", "some", "task", "jobs", "row", "module", "j", "batch", "order", "entry", "set"]}}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745, "substitutes": {"client": ["cache", "pc", "cl", "conn", "co", "server", "channel", "local", "quick", "public", "block", "proxy", "cell", "t", "cod", "cli", "remote", "contact", "connection", "buffer", "active", "project", "window", "con", "Client", "child", "open", "service", "session", "stable", "batch", "c", "hello", "entry", "ch", "core"], "nb_fds": ["nb_mns", "nb_mds", "nb_fdeds", "nb_dns", "nb_mks", "nb_fd", "nb_tfrs", "nb_feds", "nb_frs", "nb_cns", "nb_cks", "nb_md", "nb_tfeds", "nb_fdcs", "nb_dks", "nb_dd", "nb_cds", "nb_tfds", "nb_fks", "nb_dds", "nb_fns", "nb_cd", "nb_fdrs", "nb_fdds", "nb_fcs", "nb_tfcs"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749, "substitutes": {"n": ["nt", "v", "nl", "conn", "on", "na", "nu", "node", "ns", "net", "ne", "r", "b", "an", "fn", "new", "t", "w", "cn", "o", "m", "p", "g", "en", "N", "nw", "d", "nv", "a", "nb", "no", "gn", "l", "nn", "nm", "np", "num", "ng", "i", "j", "sn", "nor", "y", "rn", "nc", "ctx"], "cmd": ["command", "cmp", "md", "cl", "conn", "oc", "Cmd", "cd", "cb", "cr", "mk", "dq", "ch", "cell", "ctl", "send", "req", "quit", "m", "comm", "cc", "cf", "ct", "cp", "crit", "q", "call", "sc", "ctr", "cont", "np", "batch", "cm", "msg", "cfg", "ctx"], "sq": ["qi", "sv", "parse", "iq", "sa", "gs", "conn", "ksh", "eq", "zz", "sf", "aq", "qu", "tn", "seq", "query", "cb", "supp", "ack", "squ", "dq", "qs", "pkg", "ship", " q", "t", "cs", "square", "sh", "rf", "sb", "sing", "p", "qa", "g", "sub", "cc", "cf", "aws", "ct", "pack", "q", "scl", "sync", "sc", "h", "cur", "s", "np", "qq", "tk", "Q", "buf", "qt", "ctrl", "rn", "SU", "ctx"], "c": ["v", "ca", "cache", "cl", "pc", "gc", "co", "oc", "cd", "comp", "config", "f", "cb", "cr", "lc", "ce", "ci", "cor", "fc", "ch", "xc", "cu", "cs", "t", "dc", "ac", "p", "comm", "cc", "cf", "ct", "cp", "call", "C", "con", "cur", "rc", "etc", "l", "cont", "conf", "tc", "cm", "unc", "enc", "ctx"]}}
{"project": "FFmpeg", "commit_id": "72a6244b5d554d7fdfdeb04c174750c7a2c52f83", "target": 0, "func": "void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,\n\n                                int start, int end, int fast_gain, int is_lfe,\n\n                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,\n\n                                uint8_t *dba_lengths, uint8_t *dba_values,\n\n                                int16_t *mask)\n\n{\n\n    int16_t excite[50]; /* excitation */\n\n    int bin, k;\n\n    int bndstrt, bndend, begin, end1, tmp;\n\n    int lowcomp, fastleak, slowleak;\n\n\n\n    /* excitation function */\n\n    bndstrt = bin_to_band_tab[start];\n\n    bndend = bin_to_band_tab[end-1] + 1;\n\n\n\n    if (bndstrt == 0) {\n\n        lowcomp = 0;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);\n\n        excite[0] = band_psd[0] - fast_gain - lowcomp;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);\n\n        excite[1] = band_psd[1] - fast_gain - lowcomp;\n\n        begin = 7;\n\n        for (bin = 2; bin < 7; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp1(lowcomp, band_psd[bin], band_psd[bin+1], 384);\n\n            fastleak = band_psd[bin] - fast_gain;\n\n            slowleak = band_psd[bin] - s->slow_gain;\n\n            excite[bin] = fastleak - lowcomp;\n\n            if (!(is_lfe && bin == 6)) {\n\n                if (band_psd[bin] <= band_psd[bin+1]) {\n\n                    begin = bin + 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        end1=bndend;\n\n        if (end1 > 22) end1=22;\n\n\n\n        for (bin = begin; bin < end1; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp(lowcomp, band_psd[bin], band_psd[bin+1], bin);\n\n\n\n            fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n            slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);\n\n        }\n\n        begin = 22;\n\n    } else {\n\n        /* coupling channel */\n\n        begin = bndstrt;\n\n\n\n        fastleak = (s->cpl_fast_leak << 8) + 768;\n\n        slowleak = (s->cpl_slow_leak << 8) + 768;\n\n    }\n\n\n\n    for (bin = begin; bin < bndend; bin++) {\n\n        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n        excite[bin] = FFMAX(fastleak, slowleak);\n\n    }\n\n\n\n    /* compute masking curve */\n\n\n\n    for (bin = bndstrt; bin < bndend; bin++) {\n\n        tmp = s->db_per_bit - band_psd[bin];\n\n        if (tmp > 0) {\n\n            excite[bin] += tmp >> 2;\n\n        }\n\n        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);\n\n    }\n\n\n\n    /* delta bit allocation */\n\n\n\n    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {\n\n        int band, seg, delta;\n\n        band = 0;\n\n        for (seg = 0; seg < FFMIN(8, dba_nsegs); seg++) {\n\n            band = FFMIN(49, band + dba_offsets[seg]);\n\n            if (dba_values[seg] >= 4) {\n\n                delta = (dba_values[seg] - 3) << 7;\n\n            } else {\n\n                delta = (dba_values[seg] - 4) << 7;\n\n            }\n\n            for (k = 0; k < dba_lengths[seg]; k++) {\n\n                mask[band] += delta;\n\n                band++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26774, "substitutes": {"s": ["sv", "v", "settings", "n", "sa", "gs", "S", "params", "fs", "ss", "b", "r", "z", "state", "spec", "t", "sb", "o", "p", "e", "m", "g", "ds", "d", "u", "es", "a", "h", "stats", "i", "j", "c", "x", "sq", "ps", "self", "w"], "band_psd": ["band0psd", "band_postd", "band2prds", "band_PSdd", "band_psD", "band_ssd", "bandDpsds", "band_pxd", "band_csrd", "band_portsd", "band_dsda", "band_psdt", "band_postda", "bandMempsd", "band_csdd", "bandetpsd", "band_capsdc", "band2prd", "band_capspd", "band_psdat", "band_insdd", "band_PSsd", "band_psdf", "band_prdd", "bandetpostd", "band2asdd", "band_pds", "band_inssd", "bandDpssd", "band_alssd", "band_resds", "band_persd", "band2prsd", "band_portsdt", "band_postds", "band_prl", "band_psdo", "band_pd", "band_epsda", "band0psdd", "band_posd", "band_lasdd", "bandMemlasds", "band2pssd", "bandetpsda", "band__psu", "band_rasl", "band__psd", "band_epsdt", "band_asdd", "band_pu", "band_psdk", "band_alsd", "band2psrd", "band_PSda", "band_prdc", "band2psd", "band_PSdk", "band_pru", "band2prdu", "band_dsds", "band_PSds", "band_prD", "band_lasd", "band_prdt", "band_perrd", "band2psdict", "band_ssdd", "band2asd", "band_psdc", "band0epsdd", "band_pxu", "band2prdict", "band_pseds", "band_pspd", "band2prpd", "band_psei", "band_perspd", "band_rasd", "band_pi", "band_psds", "band_psdu", "band_lasds", "band_possd", "band_emsds", "band2psl", "band_sssd", "band_rasdict", "band_persdict", "band_portsds", "band_pD", "bandMemlasd", "band2psds", "band_pseD", "band_prds", "bandetpostdk", "band2asrd", "band2psdu", "band_epsds", "band_epsdd", "band_perdd", "band_psu", "bandetpostds", "bandMempsds", "band_PSd", "band_emspd", "bandetpostda", "band2prl", "band_dssd", "band2psdd", "band_psed", "band_psdd", "band_asd", "band__pssd", "bandetpsdk", "band_prsd", "bandDpsd", "band2asdo", "band_dsd", "band_PSdt", "band_capsd", "band_prpd", "band_persl", "band_csd", "bandDepsds", "band_resd", "band_dsdk", "band__pd", "band_portsdf", "band_insd", "band_prd", "band_emsd", "bandDepssd", "band_csdo", "band_psdict", "band_raspd", "band_resdt", "band_asdo", "band_psl", "band_capsds", "band_PSdat", "bandMempsdd", "band_pri", "bandDepsd", "band0epssd", "band_epsd", "band_PSdu", "bandMemlasdd", "band_psi", "band_prdict", "band_alsdu", "band2psdo", "band_dsdt", "band_postdk", "bandDepsdt", "band_asrd", "band0pssd", "band_psda", "band_perdo", "band0epsd", "band_epssd", "band_resdf", "bandDpsdt", "band_prdu", "bandetpsds", "band_psrd", "band_epsdat", "band_pxsd", "band_posda", "band_pssd", "band2pspd", "band_prdf", "band_alsds", "band_perd", "band__pu", "band_emsdc"], "start": ["init", "first", "top", "stop", "in", "offset", "range", "next", "get", "f", "Start", "wind", "r", "step", "art", "len", "shift", "key", "time", "p", "m", "e", "seek", "from", "id", "last", "size", "st", "l", "try", "row", "i", "j", "pos", "x", "head", "rest", "index", "it", "set"], "end": ["dest", "v", "max", "stop", "fin", "mid", "ended", "ext", "ort", "after", "END", "append", "set", "env", "until", "len", "win", "send", "add", "e", "all", "eng", "en", "End", "ending", "last", "nd", "ension", "size", "h", "close", "est", "rest", "length"], "fast_gain": ["fastnessadj", "soft_loss", "fastityalign", "softlyloss", "fast_strength", " fast_weight", "fast_charge", "fastlycorrect", "fastlyalign", "fastnessgain", "fastJquality", "softlygain", "fastnessstrength", "fast_wave", "fastityacc", "fastJwave", " fast_acc", "fastitycorrect", "slow_strength", "fast_adj", "soft_gain", "fast_acc", "fastitycharge", "fastlyloss", "slow_adj", "softlycorrect", "fast_align", "fastlygain", "fastitygain", "soft_align", " fast_quality", "fast_loss", " fast_wave", "fastaccharge", "soft_correct", "fastJweight", "fast_weight", "fastJgain", "fast_correct", "softlyalign", "fastityloss", " fast_charge", "fast_quality", "slow_gain", "fastacgain", "fastacacc"], "is_lfe": ["is_lifed", "is_ltpe", "isHlamo", "is_elfec", "is_ffet", "is_lfel", "is_lfed", "is_lifec", "is_flec", "is_lifo", "is_lte", "is_flee", "isHlame", "is_lamed", "is_olfd", "is_ffd", "isHlamed", "isHlfo", "is_lifet", "is_ldel", "is_ffe", "is_fifd", "is_lted", "is_luel", "is_life", "is_ffel", "isHlfpe", "is_lfet", "is_lfec", "is_elfe", "is_elfet", "is_fife", "is_lfo", "is_olfe", "isHlfed", "is_lfd", "is_flet", "is_fifet", "is_lto", "is_lifee", "is_elfee", "isHlampe", "is_olfed", "is_lued", "is_lfpe", "isHlfe", "is_ffee", "is_lifpe", "is_lde", "is_lame", "is_fle", "is_ffed", "is_lampe", "is_fifed", "is_lamo", "is_lded", "is_olfet", "is_luee", "is_lue", "is_ldee", "is_lfee"], "dba_mode": ["dfa_mode", "dfa_type", "dfa_opt", "dba_type", "dba_opt", "dba2mode", "dba_rate", "dba2opt", "dba2rate", "dfa_rate", "dba2type"], "dba_nsegs": ["dba_nmsgs", "dba_nbeg", "dba_npersegs", "dba_nbeps", "dba_mbeg", "dba_nmsgments", "dba_nbegs", "dba_nperseps", "dba_nseps", "dba_mseps", "dba_mbeps", "dba_nsegments", "dba_nmsps", "dba_nbegments", "dba_mbegs", "dba_nseg", "dba_nperseg", "dba_npersegments", "dba_msegments", "dba_mseg", "dba_nmsg", "dba_msegs", "dba_mbegments"], "dba_offsets": ["dba_locsets", "dba_possets", "dba_loces", "dba_offses", "dba_posizes", "dba_poses", "dba_mses", "dba_posets", "dba__loces", "dba_locets", "dba_msizes", "dba__offses", "dba_locizes", "dba__offssets", "dba__offsizes", "dba__offsets", "dba_msets", "dba_offsizes", "dba__locets", "dba__locizes", "dba__locsets", "dba_mssets", "dba_offssets"], "dba_lengths": ["dba_seqls", "dba_otherens", "dba__lengthens", "dba_seqens", "dba__lengthls", "dba_seqs", "dba_lengthls", "dba_otherths", "dba_others", "dba_paths", "dba_pathens", "dba_seqths", "dba_lengthths", "dba__seqths", "dba__seqs", "dba_pathls", "dba__lengths", "dba__seqls", "dba_otherls", "dba__seqens", "dba_lengthens", "dba_pathths", "dba__lengthths"], "dba_values": ["dba__vals", "dba__maps", "dba__states", "dfa_values", "dfa_states", "dfa_vals", "dba_vals", "dba_maps", "dba_states", "dba__values", "dfa_maps"], "mask": ["cache", "offset", "filter", "mode", "config", "shape", "tag", "lock", "ask", "bit", "box", " masks", "key", "match", "sk", "scan", "buffer", "ak", "pack", "clean", "list", "window", "id", "flag", "pixel", "conf", "map", "batch"], "excite": ["occit", "equit", "Excrite", "occrite", "excitation", "ExcITE", " excrite", " excge", "recite", "recITE", " excites", "resprite", "Excitation", "Excge", "respitation", "occites", "equite", "Excit", "respit", " excitation", "Excites", "excites", "recit", "equites", "excITE", "excit", " excit", "excge", "equrite", "excrite", "occite", "recites", "Excite", "occge", " excITE", "respite"], "bin": ["gen", "sort", "conn", "comb", "sam", "ix", "gin", "buff", "cb", "b", "bit", "box", "cmd", "dir", "scan", "spin", "bank", "id", "kit", "byte", "ln", "brain", "session", "hook", "i", "bi", "un", "ind", "ann", "n", "umi", "bis", "db", "ruby", "ben", "don", "ran", "rb", "body", "png", "mix", "win", "lib", "fun", "butt", "by", "bind", "ang", "device", "bot", "pack", "bound", "hang", "bn", "nb", "inn", "nn", "num", "back", "skin", "sun", "inner", "init", "bed", "local", "bg", "tag", "border", "pid", "cgi", "con", "pixel", "ebin", "gem", "pal", "index", "pos", "proc", "kin", "bridge", "cache", "in", "slice", "loop", "binary", "buck", "slot", "mem", "go", "bid", "rin", "bool", "pin", "bat", "obin", "mi", "abin", "min", "snap", "size", "gn", "span", "batch"], "k": ["n", "kid", "f", "km", "kind", "mk", "b", "ki", "spec", "kk", "key", "ok", "sk", "ac", "m", "p", "seek", "g", "ak", "ek", "ck", "conf", "K", "j", "x", "ik", "kw", "w"], "bndstrt": ["bNDbrt", "bndnamen", "bndbrts", "bNDbrty", "bndseql", "bondstrmt", "bondstringn", "bndstrl", "bndbrt", "bndseqty", "bndbreakt", "bndseqT", "bndStrty", "bndbrty", "bndstrts", "bndseqts", "bndstrp", "bndrp", "bndstrtp", "bNDbrT", "bNDbrts", "bndstrn", "bNDbrtp", "bndrt", "bondstringmt", "bndbrtp", "bndbrT", "bndStrT", "bndbreakts", "bndnamep", "bondstrt", "bNDstrts", "bNDstrty", "bndstringmt", "bondstrn", "bndbreakT", "bndrn", "bNDstrT", "bndbreaktp", "bNDstrtp", "bndbrl", "bondstringt", "bNDstrt", "bndrmt", "bndstrmt", "bondstrp", "bndstrty", "bndstrT", "bNDstrl", "bndStrl", "bndstringp", "bndnamemt", "bondstringp", "bndstringt", "bndstringn", "bndseqt", "bndStrt", "bNDbrl", "bndseqtp", "bndnamet"], "bndend": ["bnden", "fndend", "fendstart", "fenden", "bndended", "fendnet", "bmdend", "fndstart", "bngstart", "bndEnd", "benden", "bfindended", "brendend", "brenden", "brendstart", "brendnet", "fnden", "bondEnd", "brord1", "brnd1", "brordEnd", "brndEnd", "bendnet", "bintend", "bnd1", "bint1", "bord1", "bngEnd", "bfindend", "brndstart", "bmdstart", "borden", "bintstart", "brngended", "brndended", "brngEnd", "bordEnd", "brngstart", "brngend", "bngend", "brordend", "brordstart", "fndnet", "bfindEnd", "bmd1", "bfindstart", "bondend", "bordend", "brndend", "bondended", "bndstart", "bngended", "bndnet", "bondstart", "bmdEnd", "bintEnd", "fendend", "bendend", "bordstart", "bendstart", "bordnet"], "begin": ["init", "make", "bridge", "create", "pre", "half", "mid", "range", "don", "bottom", "local", "ran", "pend", "go", "EGIN", "bor", "rb", "bid", "run", "can", "hide", "mis", "center", "save", "Begin", "mount", "gain", "update", "add", "bind", "goal", "termin", "minimum", "be", "bound", "min", "late", "month", "pause", "mark", "snap", "paren", "con", "num", "span", "may", "gan", "pen", "batch", "pair", "head", "kin", "un", "commit", "set", "consider"], "end1": ["End1", " end0", "nd1", "End3", "END2", "END7", "ended6", "end7", "End2", " end2", "end01", "end2", "nd3", "End0", "nd0", "nd01", " end7", "endOne", " end8", "startOne", "end3", "nd2", "ended2", "END1", "start0", "ended1", "END6", "End7", "end0", " end3", "end8", "END01", "start2", "nd8", "end6", "ended0", " end01", "END0", "ENDOne", "End01", "start1", "End8", "EndOne", " end6"], "tmp": ["cmp", "acc", "jp", "params", "src", "common", "timeout", "tag", "lock", "cmd", "ip", "mp", "other", "mut", "prefix", "snap", "perm", "img", "unit", "etc", "np", "tc", "batch", "pos", "extra", "temp", "test", "ind"], "lowcomp": ["littlefac", "fullfac", "flowcom", "levelcomp", "lowComp", "ownop", " lowcmp", "fullcom", "quickcom", "levelcmp", "Lowcrit", " lowcomponent", "condcp", "owncom", "levelcomponent", "quickcomp", "slowcmp", " lowfac", "oldcom", "smallcomp", "slowcp", "condComp", "slowprop", "slowcom", " lowproc", "longcmp", "owncmp", " lowprop", "lowproc", "highcmp", "lowcomm", "lowcrit", "quickproc", "slowcomponent", "condcom", "highcomp", "lowfac", "littlecomp", "littlecond", "fullcomp", "LowComp", "longcp", "slowcomp", "flowcomp", "Lowcmp", "lowprop", "lowcomponent", "slowcond", "owncomp", " lowcp", "quickcmp", "owncomponent", "Lowcomp", "flowcmp", " lowcomm", "Lowcom", "locom", " lowComp", "highcond", "quickprop", "lowcp", "condcomp", "littlecom", "lowcom", "oldcomponent", "lowop", "locmp", "locomp", "smallprop", "quickcomponent", "Lowcond", "loop", "lowcmp", "lowcond", "smallcmp", " lowcond", "levelcomm", "oldcomp", "smallcom", "highComp", "locrit", "longcom", " lowcom", "slowComp", "flowcp", "fullcond", "Lowcp", "slowop", "slowproc", " lowcrit", "slowcomm", "oldcmp", "longcomp"], "fastleak": ["fastleaky", "fastlaky", "fastchak", "fastcleake", "slowoleak", "fastchaky", "slowbleaky", "lowbleake", "fastbleak", "slowleaker", "lowbleak", "fastcleak", "fastlak", "fastleake", "fastolease", "fastpleaker", "fastblease", "fastsleak", "fastsleaked", "fastsleaky", "fastpleake", "fastbleaky", "fastbleake", "lowleaky", "slowleake", "lowbleaky", "fastlease", "slowbleak", "fastcleaky", "fastplease", "slowoleake", "slowbleake", "fastlake", "slowbleaker", "fastoleak", "slowolease", "fastchaked", "fastsleake", "fastcleaker", "fastbleaked", "lowbleaked", "fastlaker", "fastleaker", "lowleake", "fastleaked", "fastoleake", "lowleaked", "fastpleak", "slowoleaker", "fastoleaker", "fastbleaker", "slowleaky", "lowleak", "slowlease", "fastchake"], "slowleak": ["slowsleak", "slowseake", "deepleaking", "slowsleek", "slowseak", "slowcleek", " slowleake", "slowsleake", "deepbleaking", " slowleap", "slowbleap", "slowsleap", "slowseek", "slowleek", "slowcleaking", "slowleap", " slowleek", " slowsleek", "slowbleek", "slowseap", "slowseaking", "slowleake", "slowcleak", "slowleaking", "slowbleak", "deepleake", "slowbleake", "deepbleek", " slowsleap", " slowsleak", " slowsleake", "deepleak", "deepbleak", "slowcleake", "deepleek", "deepbleake", "slowbleaking"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776, "substitutes": {"s": ["sv", "n", "is", "hs", "gs", "js", "ms", "ses", "sp", "S", "sam", "serv", "source", "ns", "store", "ss", "r", "ts", "qs", "sol", "se", "spec", "south", "less", "sh", "ats", "secondary", "space", "sb", "ims", "comm", "g", "ds", "sl", "aws", "ls", "d", "sw", "os", "a", "so", "sync", "rs", "acs", "st", "as", "sys", "span", "stats", "sts", "bs", "als", "service", "asm", "sq", "ps", "set"], "x": [" cx", "ax", "ex", "v", "xp", "ix", "f", "xi", "wx", "tx", "X", "ux", "z", "ry", "at", "dx", "ox", "t", "xt", "coord", "rx", "p", "m", "fx", "d", "a", "px", "position", "l", "xy", "xs", "i", "c"], "y": ["top", "v", "iny", "Y", "icy", "any", "very", "ery", "ay", "asia", "b", "ym", "ey", "ye", "gy", "ry", "hot", "uy", "oy", "t", "yy", "ya", "o", "p", "my", "m", "iley", "hy", "dy", "asy", "ny", "py", "a", "yt", "ies", "iy", "xy", "axy", "ys", "hey", "i", "vy", "cy", "sy", "yer", "sky"], "w": ["v", "ex", "we", "n", "wr", "W", "wall", "rew", "weight", "wp", "aw", "ow", "wx", "wa", "f", "wl", "wd", "wind", "r", "z", "fw", "t", "win", "m", "hw", "p", "wal", "wh", "wn", "pt", "nw", "d", "wen", "sw", "ew", "rw", "a", "window", "ww", "wid", "wt", "l", "iw", "wb", "kw"], "h": ["v", "ph", "ih", "f", "H", "b", "ha", "r", "hi", "hei", "hh", "t", "html", "oh", "eh", "kh", "uh", "hash", "m", "bh", "hw", "p", "wh", "e", "ah", "dh", "d", "u", "rh", "q", "a", "depth", "high", "hz", "hd", "height", "l", "ho", "gh", "phi", "i", "ht", "c", "it", "ish", "err", "ch"], "rect": ["ren", "unt", "vp", "res", "red", "json", "txt", "opt", "client", "print", "rt", "tr", "store", "dict", "r", "vec", "round", "cmd", "complete", "spec", "feat", "RECT", "area", "der", "nav", "vt", "dir", "butt", "req", "remote", "assert", "expr", "pt", "rel", "project", "rm", "rent", "prefix", "list", "region", "def", "dr", "lat", "cont", "mat", "addr", "err", "tar", "form", "dial", "pr", "desc", "select", "ptr", "Rect", "rest", "vr", "ind", "port"], "redraw_fifo_last": ["redraw_fifO_last", "redraw_fifpo_last", "redraw_fifo__scope", "redraw_fifpo_count", "redraw_fifO_max", "redraw_fifpo_scope", "redraw_fifO_next", "redraw_fifo_max", "redraw_fifo__count", "redraw_fifo_count", "redraw_fifo_scope", "redraw_fifo_next", "redraw_fifo__last"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n", "idx": 26777, "substitutes": {"dc": ["df", "dm", "pc", "dp", "dd", "oc", "cd", "td", "lc", "mc", "ci", "fc", "di", "dt", "bc", "cs", "ctl", "DC", "ec", "ic", "doc", "cc", "da", "ds", "ct", "sc", "rc", "dr", "sys", "tc", "vc", "desc", "cm", "disc", "kw", "nc", "ctx"], "d": ["data", "dm", "v", "n", "dd", "db", "cd", "gd", "p", "wd", "td", "tg", "b", "r", "z", "di", "dt", "dx", "t", "dir", "D", "sd", "m", "e", "dat", "fd", "ds", "da", "pd", "g", "dh", "bd", "ed", "nd", "ad", "h", "dr", "s", "l", "de", "ld", "i", "y", "dl", "w"], "c": ["v", "cv", "pc", "ca", "n", "cache", "k", "gc", "co", "f", "ce", "cr", "lc", "b", "mc", "ci", "fc", "cor", "r", "xc", "bc", "cu", "t", "cs", "cat", "ac", "uc", "ec", "cn", "ic", "p", "m", "e", "g", "cc", "com", "cf", "ct", "cp", "u", "a", "sc", "C", "con", "cur", "rc", "s", "l", "tc", "vc", "col", "i", "cm", "cy", "y", "nc", "ch"], "x": ["ax", "xml", "v", "ex", "n", "xx", "k", "co", "on", "ctx", "xp", "ix", "wx", "xi", "tx", "r", "b", "z", "ux", "X", "xa", "xf", "xe", "xc", "at", "mx", "ox", "t", "dx", "xt", "ic", "o", "rx", "p", "m", "e", "g", "u", "a", "px", "xd", "h", "con", "nex", "s", "l", "xy", "xs", "i", "y", "w"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 26780, "substitutes": {"spapr": ["spipar", " spipR", " spipr", "spopar", "spapre", " spapar", "spopr", "spipr", " spipre", "spopre", " spipar", "spapar", "spAPar", "spAPR", "spipre", " spapR", "spopR", "spapR", "spipR", "spAPre", " spapre", "spAPr"], "token": ["init", "ails", "urn", "kid", "Token", "Id", "ens", "ix", "ident", "kt", "ts", "oken", "sid", "ires", "doc", "fd", "aws", "from", "os", "secret", "worker", "wt", "wid", "session", "ti", "root"], "nargs": [" narg", "nbgs", "ngs", "narg", "nsarg", " nparams", "tparams", "nsArgs", " nArgs", "targ", "nparams", "targs", "nsargs", " ngs", "tArgs", "nbarg", "nbparams", "nbargs", "nsgs", "tgs", "nArgs"], "args": ["facts", "data", "vals", "init", "res", "gs", "fields", "ms", "js", "arms", "els", "ens", "fs", "params", "rows", "ties", "aux", "ns", "arn", "frames", "ret", "actions", "ants", "ts", "qs", "info", "parts", "spec", "names", "orders", "ires", "arr", "gets", "limits", "ins", "ims", "aws", "ds", "ls", "values", "terms", "arg", "dates", "rs", "ids", "keys", "uments", "s", "types", "flags", "Args", "als", "xs", "atts", "uns", "its", "words", "pos", "GS", "ptr", "ags"], "nret": ["nnrets", "nnret", "nnreturn", "NRet", "Nret", "Nrets", " nRet", "nRet", " nreturn", " nrets", "Nreturn", "norret", "nrets", "nreturn", "norreturn", "norRet", "norrets", "nnRet"], "rets": ["ails", "vals", "ces", "res", "ates", "gs", "js", "cas", "els", "windows", "ens", "fs", "rows", "uds", " secrets", "ns", "details", "ret", "ants", "aults", "states", "ets", "tails", "reset", "ts", "qs", "uts", "ires", "der", "urs", "aws", "ds", "outs", "ls", "values", "utes", "secret", "ents", "tes", "rs", "RET", "ids", "lists", "events", "def", "uments", "des", "ints", "als", "sts", "ads", "flags", "its", "fts", "finals", "ptr", "results"], "id": ["rev", "er", "kid", "mid", "in", "Id", "end", " fid", "f", "ret", "tx", "rid", "bid", "ident", "pid", "ts", "info", "uid", "sid", "ip", "key", "ref", "oid", "fd", "m", "name", "en", "d", "from", "ed", "a", "os", "base", "vid", " ID", "ad", "ids", "h", "des", "ID", "type", "iden", "i", "it", " tid"], "start": ["init", "first", "n", "date", "pre", "stop", "iter", "offset", "in", "get", "end", "Start", "wind", "r", "step", "reset", "trans", "ts", "find", "art", "t", "started", "origin", "shift", "len", "time", "p", "seek", "pad", "d", "from", "q", "base", "size", "st", "try", "now", "i", "j", "pos", "rest", "it", "begin", "set"], "r3": ["r2", "R3", " r2", "rcThree", "r1", "rThree", " r7", "r5", "R5", " rThree", "vr3", "RThree", "vr1", "r7", " r1", " r03", "R7", "rthree", "vrthree", "vrThree", "R03", "rc3", "rcthree", "rc7", "rc5", " rthree", "rc2", "rc1", "r03", "rc03", " r5", "R2"], "cs": ["cv", "ces", "pc", "ars", "acts", "ks", "gs", "gc", "ms", "js", "cms", "cas", "cons", "fs", "ns", "checks", "ps", "fc", "ts", "cmd", "qs", "nc", "ics", "ac", "cus", "ec", "cn", "ins", "cc", "cf", "ds", "ls", "wcs", "cp", "ct", "ck", "cks", "rs", "Cs", "sc", "acs", "rc", "vs", "cer", "ctr", "stats", "tc", "bs", "sts", "its", "c", "caps", "CS", "css", "csv", "ctx"], "cpu": ["linux", "runner", "pc", "bench", "tp", "gc", "util", "cam", "none", "loader", "ctx", "nu", "node", "bean", "common", "vm", "uart", "ace", "process", "processor", "gp", "pu", "cu", "clock", "cn", "gpu", "aco", "cow", "efficiency", "cp", "ck", "nic", "ka", "score", "CP", "CPU", "c", "proc", "socket", "onet", "stat", "core"], "env": ["owner", "er", "ve", "v", "cv", "obj", "cookie", "sv", "oe", "js", "conn", "db", "agent", "eps", "next", "ee", "end", "ent", "viron", "esp", "priv", "context", "gear", "ce", "cb", "ts", "cmd", "eu", "der", "vt", "ei", "ote", "el", "eh", "ec", "esm", "shell", "e", "dev", "en", "environment", "eas", "ah", "te", "ew", "ef", "ev", "window", "esc", "here", "equ", "engine", "cer", "vs", "era", "ue", "desc", "buf", "scope", "proc", "et", "ie", "exc", "entry", "enc", "ctx"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792, "substitutes": {"bus": ["Bus", "bridge", "cache", "book", "cast", "gen", "usb", "util", "conn", "db", "master", "loop", "bar", "build", "driver", "way", "host", "local", "phys", "lock", "box", "hub", "state", "block", "hand", "board", "bc", "proxy", "boot", "lib", "uses", "mount", "http", "chain", "connection", "dev", "device", "bur", "controller", "os", "base", "sync", "def", "sys", "us", "bs", "back", "buf", "boss", "BUS", "ctx"], "address": ["Address", "dest", "command", "request", "offset", "range", "master", "link", "action", "directory", "lease", "ay", "shape", "message", "execute", "description", "ace", "set", "path", "sequence", "private", "name", "device", "ress", "controller", "route", "number", "reference", "trace", "age", "location", "position", "capacity", "property", "service", "addr", "condition", "type", "handle", "alias", "i", "index", "resource", "order", "operation", "attribute", "network", "port", "interface"], "recv": ["preq", "Recc", "Reccv", "RECvs", " reccv", " recvs", "reccv", "Recq", " recvert", "recvs", "recvP", "RECvP", "Recvert", "recvert", "recq", "precv", " recq", "prevert", "RECv", "RECc", " recvP", "Recv", "Recvs", "RecvP", " recc", "prev", "recc"], "qdev": ["qd", " qd", " qDev", "dqdev", "qvar", "Qdev", "qqev", "Qev", "qDev", "qdevice", "qev", "dqDev", " qdevice", "qqdevice", "qudev", "Qdevice", "QDev", "dqdevice", "qqvar", "qumem", "qqDev", "dqvar", "qud", "qqd", " qmem", "qudevice", "qmem", " qvar", "qqmem", "qqdev", "dqev"], "slave": ["dest", "command", "owner", "bridge", "ve", "data", "result", "sa", "ser", "master", "server", "aw", "sp", "link", "node", "source", "binding", "volume", "lease", "peer", "tle", "join", "store", "query", "instance", " slaves", "sama", "pipe", "gate", "se", "info", "station", "handler", "proxy", "save", "ssl", "mi", "shift", "sh", "sb", "copy", "dev", "sl", "device", "si", "sub", "seat", "pause", "seed", "role", "sudo", "worker", "ssh", "engine", "unit", "thread", "pe", "task", "ale", "ave", "stable", "session", "disable", "tmp", "alias", "index", "tie", "attribute", "test", "port"]}}
{"project": "FFmpeg", "commit_id": "8a57ca5c6a1c0ad28afa7ea6f824981e6761cce1", "target": 0, "func": "static int aasc_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    AascContext *s = avctx->priv_data;\n\n    int compr, i, stride;\n\n\n\n    s->frame.reference = 3;\n\n    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &s->frame)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    compr = AV_RL32(buf);\n\n    buf += 4;\n\n    buf_size -= 4;\n\n    switch (avctx->codec_tag) {\n\n    case MKTAG('A', 'A', 'S', '4'):\n\n        bytestream2_init(&s->gb, buf - 4, buf_size + 4);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    case MKTAG('A', 'A', 'S', 'C'):\n\n    switch(compr){\n\n    case 0:\n\n        stride = (avctx->width * 3 + 3) & ~3;\n\n        for(i = avctx->height - 1; i >= 0; i--){\n\n            if(avctx->width*3 > buf_size){\n\n                av_log(avctx, AV_LOG_ERROR, \"Next line is beyond buffer bounds\\n\");\n\n                break;\n\n            }\n\n            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n\n            buf += stride;\n\n            buf_size -= stride;\n\n        }\n\n        break;\n\n    case 1:\n\n        bytestream2_init(&s->gb, buf, buf_size);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n\n        return -1;\n\n    }\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FourCC: %X\\n\", avctx->codec_tag);\n\n        return -1;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 26819, "substitutes": {"avctx": ["avejac", "wavconn", "vercu", "avepkg", "wavcu", "avwcs", "AVcontext", "ahctx", "wavpkg", " avpkg", "avecp", "averjac", "wavcmp", "Avctx", "ahpkg", "navcu", "avecontext", "avejp", "avercp", "wavcf", "awtx", "avecu", "ajpkg", "ahconn", "afwcs", "avertx", "avgc", "averpkg", "averwcs", " avjp", "vrcontext", "awcmp", "navtx", " avtx", " avconn", "avca", "avercu", "ajcfg", "avetx", "navctx", " avcu", "avercmp", " avtxt", "avtxt", "vrtx", "wavjac", "ajcontext", "wavcfg", "ajjp", "wavtx", "averconn", " avcontext", "avertxt", "avtx", " avcmp", "abjp", "abctx", "wavctx", "avecf", "averca", "aveca", "avercontext", "abtx", "aftx", " avgc", "avcontext", "verctx", "vrctx", "afctx", "Avtx", "avjp", "wavtxt", "ajwcs", "verjac", "afpkg", "vrcu", " avjac", "avpkg", "avconn", "ajgc", "vercontext", "avcp", "avcmp", "aveconn", "afcontext", "awjp", "avercfg", "avcf", "ahmom", "AVtx", "averctx", " avcfg", "avmom", "avecmp", "afjp", "AVconn", "AVctx", "avcfg", "wavca", "ajconn", "avergc", "abpkg", "avercf", "avjac", "awctx", "avecfg", "wavcontext", "afcu", "averjp", "ajctx", "wavmom", " avcp", "ajmom", "navcontext", "Avcontext", "avectx", "Avconn", "avcu"], "data": ["DATA", "bits", "cache", "text", "offset", "next", "frame", "Data", "history", "content", "f", "actions", "mu", "load", "message", "read", "block", "bytes", "area", "t", "sequence", "sample", "padding", "bin", "options", "ref", "o", "p", "m", "str", "buffer", "feed", "pad", "lines", "d", "values", "stream", "a", "window", "package", "id", "size", "value", "memory", "def", "input", "flags", "done", "type", "start", "batch", "extra", "empty", "ata", "length", "w"], "data_size": ["data_length", "buf_size", "data_len", "buf_Size", "data_Size", "buf_len", "buf_length"], "avpkt": ["avpodsth", "avcpunt", "avcpgt", "avpackkt", "avpodkt", "avpmit", "avefdu", "avepkg", "avPdu", "avvpacket", "afpacket", "afpsth", "avpsth", "afpgt", "avpct", "avpdu", "avefkt", "avpunt", "avpamit", "avpakt", "avpbgt", "avfkg", "avvpunt", "avpacket", "avpbacket", "avefkg", "afcpkt", "afcpgt", "avpbsth", "avefct", "avpodacket", "avpbkt", "avpackdu", "afpunt", "avfct", "avepct", "avcpacket", "avpkg", "afcpmit", "afcpsth", "avpaacket", "afcpacket", "avPkg", "avvpmit", "afpmit", "avpaunt", "avvpkt", "avpodgt", "avepkt", "avcpsth", "avfdu", "avcpkt", "afpkt", "avPct", "avPkt", "avfkt", "avpackkg", "avpackct", "avepdu", "avcpmit", "afcpunt", "avpgt"], "buf": ["broad", "limit", "cv", "result", "db", "bp", "raw", "txt", "end", "pro", "mem", "lim", "keep", "mu", "seq", "buff", "cb", "b", "vec", "capt", "var", "rb", "box", "cmd", "loc", "block", "pool", "alloc", "bytes", "bc", "len", "bl", "BU", "arr", "uf", "bin", "fac", "ref", "port", "shift", "p", "buffer", "aka", "off", "queue", "cp", "late", "window", "fb", "Buffer", "h", "img", "cur", "Buff", "ctr", "br", "tmp", "addr", "cap", "wb", "batch", "pos", "ptr", "msg", "ff", "prop", "orig", "norm", "err", "xff", "ctx"], "s": ["sv", "sis", "v", "n", "is", "hs", "gs", "js", "bis", "ses", "changes", "S", "fs", "ns", "f", "details", "tx", "ss", "ants", "b", "ts", "qs", "parts", "ops", "cs", "less", "ats", "gets", "ims", "ins", "p", "m", "g", "sl", "ds", "aws", "ls", "ains", "sw", "ares", "os", "es", "sg", "tes", "rs", "ess", "ies", "h", "vs", "l", "sys", "as", "acs", "als", "bs", "sts", "y", "its", "stats", "j", "c", "sports", "sq", "ps", "self", "ctx"], "compr": ["_", "v", "romPr", "cmp", "compPr", "corpr", "comexpr", "comPr", "comppol", "COMpr", "Comper", "comp", "Comexpr", "COMPr", "romp", "comppl", "romPR", "Compl", "func", "cepr", "cePR", "COMpol", "compl", " comper", "comPR", " compl", "corpol", "comppr", "comper", "call", " comPR", "corPr", "corpl", "compol", "def", " comp", "compper", "cePr", "Compr", "cep", "COMpl", "compexpr", " comPr", " comexpr", "rompr", "raw"], "i": ["qi", "iri", "v", "ir", "n", "li", "ij", "ix", "xi", "ic", "mu", "ai", "ini", "b", "gi", "ci", "mc", "z", "ki", "di", "hi", "ii", "oi", "mi", "ip", "cli", "ims", "sim", "m", "e", "p", "multi", "ni", "o", "ui", "ri", "d", "u", "pi", "id", "\u0438", "io", "iu", "l", "ti", "phi", "j", "index", "x", "zi", "c", "y", "it", "si", "bi", "ind", "I"], "stride": ["divider", "strue", "strenge", "stringider", "slick", "strride", "stick", "strice", "charid", "Strate", "stider", "stringide", "Strine", " strue", "stringick", " strIDE", "stenge", " strine", "strick", "slider", "true", "divride", "tride", "rate", "divue", " strate", "stide", " strid", "stid", "strate", "strid", "StrIDE", " strider", "ride", "slide", "slIDE", "charice", "Stride", "divide", "rIDE", "stice", "stringIDE", " strride", "strider", " strice", "charenge", "strine", "stIDE", "trider", "charide", "trride", "rine", " strenge", "strIDE"]}}
{"project": "FFmpeg", "commit_id": "de6df46120367b7d49d9d7c0971cbe36368b840a", "target": 1, "func": "int ff_h264_field_end(H264Context *h, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n#if CONFIG_ERROR_RESILIENCE\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        ff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);\n        ff_er_frame_end(&h->er);\n    }\n#endif /* CONFIG_ERROR_RESILIENCE */\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n    h->current_slice = 0;\n    return err;\n}", "idx": 26836, "substitutes": {"h": ["hr", "ih", "ph", "v", "hs", "k", "rem", "cache", "th", "ctx", "history", "host", "zh", "each", "hm", "f", "go", "hl", "http", "H", "b", "his", "z", "he", "ha", "info", "pp", "has", "hi", "hh", "html", "oh", "sh", "eh", "kh", "uh", "hash", "m", "bh", "header", "hw", "p", "comm", "g", "ah", "dh", "wh", "dev", "d", "sw", "rh", "q", "window", "here", "hz", "hal", "hp", "hd", "dr", "help", "l", "ho", "gh", "handle", "j", "ht", "x", "c", "it", "ch", "w"], "in_setup": ["in_Setup", "in_run", "inPrecontrol", " in_Setup", "inPrestart", "inflightcontrol", "inPreSetup", " in_control", "in_boot", "inPresetup", " in_boot", "inflightsetup", " in_push", "inPostsetup", "inflightSetup", "inPostrun", "inPostpush", "in_control", "inflightrun", "inflightpush", " in_run", "inflightstart", " in_test", " in_start", "inPostSetup", "in_push", "in_test", "in_start"], "avctx": ["ahcmp", "avejac", "wavconn", "ahcmd", "averloc", " avcmd", "AVcontext", "wavjp", "ahctx", "averjac", "vrgc", "svctx", "wavcmp", "savctx", "avecontext", "avecb", "AVcu", "AVjac", "awtc", "wavcmd", "savjac", "wavgc", "avgc", "svtx", "evcontext", "evtx", " avtx", " avconn", "avercu", "vrnp", "avetx", " avcu", "avercmp", "savgc", "svgc", "wavjac", "wavloc", "avegc", "awcontext", "wavtx", " avcontext", "avetc", "savcontext", "svjp", "avtx", "savjp", "wavctx", "evctx", "ahloc", "avercontext", "avcontext", "vrctx", "savcb", "avjp", "avcmd", "avercmd", "wavcb", "avcb", "avecmd", " avjac", "avconn", "awcfg", "avcmp", "aveconn", "avernp", "avnp", "AVtx", " avcfg", "averctx", "AVconn", "AVctx", "avtc", "avcfg", " avtc", "avergc", "avjac", "awctx", "avloc", "avecfg", "wavcontext", "avenp", "savtx", "vrcmd", "avectx", "evconn", "avcu"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26841, "substitutes": {"s": ["sv", "bits", "gs", "ses", "changes", "services", "details", "store", "pers", "state", "parts", "ops", "comments", "p", "status", "ls", "so", "rs", "als", "sports", "c", "stat", "ps", "set", "n", "bis", "fs", "ns", "states", "ts", "se", "ssl", "less", "sh", "sb", "d", "es", "os", "vs", "st", "stats", "sts", "rest", "ports", "settings", "hs", "is", "ss", "r", "spec", "cs", "ats", "http", "m", "comm", "ds", "syn", "sync", "search", "sys", "sq", "js", "cons", "eps", "S", "serv", "qs", "t", "gets", "ims", "sl", "sw", "h", "acs", "bs", "its", "asm", "self"], "value": ["data", "VALUE", "v", "cache", " quantity", "variable", "max", "weight", "feature", "val", "message", " amount", " data", "block", "address", "sum", "image", "vector", " input", " measurement", "padding", " instance", " Value", "total", "key", "code", "buffer", "operator", " message", "values", "number", " v", "window", "byte", "memory", "V", "unit", "position", "Value", "property", "ue", "type", "field", "expression", "index", "x", "hello", "attribute", "length"], "size": ["n", "is", "count", "zero", "offset", "small", "scale", "shape", "ize", "message", "see", "body", "set", "z", "used", "sum", "len", "zone", "send", "space", "e", "name", "fee", "number", "needed", "window", "id", "equal", "SIZE", "height", "capacity", "position", "num", "start", "index", "empty", "Size", "si", "length"], "i": ["init", "v", "gu", " j", "n", "is", " I", "iter", "li", "ix", "xi", "ai", "ini", "gi", "ci", "di", "at", " count", "ie", "ii", "mi", "ip", " bi", " m", "sim", "ic", "m", "p", "multi", "g", "ui", " ii", " n", "u", "pi", "id", "im", " t", "iu", "l", "fi", "us", " ti", " index", "ti", "zi", "j", "c", "x", "phi", "batch", "index", "y", "it", "si", "bi", "ind", "I"], "data_count": [" data_counter", "dataOBid", " data_id", "data_current", " data_Count", "total_max", "data_start", "DATA_count", "DATA_max", "total_size", "length_current", "data_limit", "data_id", "dataOBcount", "data_cache", "data_length", "DATA_start", "total_count", " data_code", "total_length", "dataOBcounter", "data_buf", "data_counter", "length_buf", "data_code", "data_Count", " data_cache", "data_max", "data_size", " data_length", "dataOBCount", "DATA_length", "length_limit", "length_count"]}}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848, "substitutes": {"opts": ["opttto", "ioptes", "optto", " opls", "opttes", "optr", "operts", "iopcs", "opeds", " opteds", "optts", "opertes", "opercs", "ioptr", "opcs", "iopts", "optls", " optls", "optes", " optto", "optcs", "opttr", " optts", "opertr", "opls", "opteds", " opeds", " opttto"], "filename": ["v", "kan", "n", "Filename", "ename", "ername", "txt", "fs", "source", "file", "family", "fil", "f", "json", "directory", "fn", "username", "path", "o", "fd", "p", "name", "prefix", "fp", "nil", "nm", "ames", "ame", "til", "which", "files", "length", "FN"], "chr": ["ichrt", "chear", "chtrb", "icht", "cherr", "ichrs", "cherresult", " chrc", "chrt", " chrb", " chrt", "achusr", "achrc", " cht", "achdr", "chrn", "Chrt", "cherc", "chel", " chl", "Chrc", "echrb", "chert", "Chr", "chrc", "chl", "clrc", "clar", "chusr", "echrs", "achl", "clrt", "ochr", " chdr", "ochar", "chero", "ochrc", "cherrb", "chdr", "cherrn", " chro", "cherl", "ochrt", "echl", "chtrn", "Char", "achrb", "echr", "echar", "echdr", "echrt", "clr", "echresult", "echrc", "echro", "chro", "cherb", "chet", " chusr", "chtr", "chrs", "ichr", "chers", "chtresult", "echrn", "echt", "cht", "cherusr", "chrb", "chresult", "achr", "cher"], "s": ["sv", "v", "ports", "n", "is", "gs", "bis", "js", "ses", "sam", "source", "S", "fs", "ns", "f", "ss", "r", "b", "ts", "qs", "spec", "cs", "ssl", "less", "ats", "sb", "ins", "o", "p", "m", "g", "ds", "u", "os", "a", "es", "rs", "sc", "h", "storage", "sys", "stats", "sts", "session", "bs", "i", "j", "c", "socket", "sq", "si", "ps", "csv", "w"]}}
{"project": "FFmpeg", "commit_id": "a91d82b5cc7d828ea9779aae1595f60e7e257d29", "target": 1, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n\n    // However the Coding Technologies decoder check uses 6 patches\n\n    if (sbr->num_patches > 6) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26862, "substitutes": {"ac": ["ap", "iac", "pc", "acc", "ca", "oc", "AC", "anc", "mic", "am", "sac", "ace", "ack", "mc", "fc", " cac", "an", "ica", "act", "fac", "mac", "ec", "ic", "coll", " lac", "cc", "jac", "ach", "ak", "a", "ad", "pac", "acer", "acs", "aic", "ia", "c", "enc", "Ac"], "sbr": ["wslr", "jslr", "alsbre", " scr", "tbre", "isbr", "alsctr", " shr", "lshr", "hsBR", "portsbn", "owshr", "pshr", "wsron", "sBR", "tsbr", "itsarr", "changesbr", "hsbr", "statsbr", "insbr", "unsbro", "arbre", " sber", "owsbre", "qsbre", "nsvr", "statsvr", "esbr", "isadr", "sron", "Sbr", "iesbre", " sBR", "lesshr", "psbn", "sbor", "portshr", "nsBR", "qsrid", "isbt", "isocr", "ishr", "isbro", "portsocr", "slr", "esfr", "psbro", "unsfr", "tshr", " sdr", "qsbr", "wsBR", "isreg", "portsber", "fsber", "Spre", "isbuf", "asbro", "tsbre", "hsbd", "jsreport", "jsbl", "islr", "csvr", "wsbr", "socr", "lsBR", "wbre", "arhr", "iesbt", "sber", "esreg", "portsfr", "stsbre", " sbl", "owsbr", "fsbor", "SBR", "jsbre", "esbt", "srid", "arbr", "eshr", "sform", "itsbre", "itsbr", "msbp", "psbr", "shr", "hshr", "esbp", "gespre", "cspr", "sbm", "esBR", "jsbr", "lessber", "esvr", "svr", "hsbre", "gesbre", "changesbre", "sprot", " sron", "esref", "spr", "vesbm", "hsbl", "fsfr", "isber", "msvr", "msbre", "unsbr", "vesocr", " svr", "sbd", "nsbre", "str", "iesgr", "mstr", "isbm", "unsstr", "fsbre", "Sbre", "tBR", "gsarr", "wshr", "itsprot", "asadr", "wber", "gesbr", "mbre", "Shr", "jsdb", "isberry", "isbor", "alsform", "isBR", "sbp", "Sreg", "sdr", "sbl", "qsarr", "isbn", "jsfr", "sdb", "sbn", "statsbre", "arbro", "psbre", "scr", "wbr", "nsbr", "isctr", "unsbre", "esbor", "isform", "qsprot", "psocr", "asbre", "sbro", "esbre", " sadr", "csbr", "sfr", "ispre", "inscr", "jsBR", "stsbr", "isarr", "geshr", "isstr", "gsbre", "msbro", "jsreg", "tsbro", "lessbr", "nshr", "msbr", "sreg", "asBR", "jshr", "tbuf", " str", "portsbr", "sadr", "qspre", "stsadr", "jsbor", "isfr", "changesref", "sstr", "statsberry", "fsbr", "asbr", " sbre", "isbl", "jspr", "wsdb", "sgr", "sbre", "fshr", "tbr", "vesber", "qsgr", "asbl", "sbt", "changeshr", "jsrid", "sberry", "iesrid", "owsber", "sreport", "jsberry", "sref", "gsstr", "jsron", "csbor", "msstr", " sbro", "lsron", "instr", "tsber", "jsvr", " sfr", "lessbre", "lsbre", "spre", " sbd", "mbr", "unsbp", "sbuf", "qsbro", "alsbr", "whr", "vesbr", "isbre", "sctr", "nsdr", "isbd", "stsfr", "isron", "lsbr", "portsbre", "isdb", "sarr", "iesreport", "Sbuf", "jsbt", "marr", "qsberry", "insron", "jsgr", "iesberry", "isvr", "gsbr", "iesbr", "ispr", "msreg", "asber"], "i": ["qi", "ir", "n", "iter", "in", "li", "ij", "ix", "xi", "ai", "ini", "ji", "b", "gi", "ci", "ki", "info", "di", "hi", "ie", "ii", "mi", "ip", "key", "ei", "ic", "ri", "m", "p", "multi", "e", "ui", "u", "pi", "id", "\u0438", "iu", "ish", "fi", "y", "ti", "phi", "j", "zi", "x", "index", "ik", "it", "si", "bi", "ind", "I"], "k": ["kan", "n", "kid", "ks", "uk", "work", "max", "dk", "unk", "mask", "isk", "f", "km", "kind", "kl", "kj", "kar", "mk", "ask", "ku", "b", "kt", "ki", "mc", "kk", "ko", "key", "ijk", "sk", "ok", "kh", "o", "m", "ikk", "seek", "p", "out", "cc", "kick", "ak", "kn", "ek", "g", "cp", "jj", "ke", "ck", "q", "kit", "ka", "h", "kb", "ski", "num", "K", "tk", "wk", "j", "c", "usk", "ik", "it", "kw", "kr", "ind", "ch"], "num_patches": ["num_patcs", "num_plotists", "num_patatches", "num_patchs", "num_patchhes", "num_funatches", "num_potched", "num_aptps", "num_potters", "num_pats", "num_Patches", "num_matters", "num_potcher", "num_patcher", "num_matcher", "num_mutches", "num_padters", "num__matatches", "num_patternches", "num_plotters", "num_patchched", "num_patchatches", "num_patternched", "num_patched", "num_winches", "num_mutatches", "num_plotches", "num_padched", "num__patches", "num_matatches", "num_patps", "num_Pathes", "num_patists", "num_wincs", "num_patchcher", "num_patchcs", "num_patchches", "num_batchers", "num_funches", "num__patatches", "num_watchches", "num_matcs", "num_patchists", "num_patternters", "num_watchters", "num_mutched", "num_aptters", "num_patchers", "num_batcs", "num__matches", "num_patchchers", "num_matchers", "num_matches", "num_patternments", "num_motches", "num_potches", "num_motters", "num_patters", "num_patments", "num_batps", "num_motcs", "num_mathes", "num_patchters", "num_batters", "num_patchments", "num_bats", "num_batched", "num_Patched", "num_batches", "num_winched", "num_patchps", "num_pathes", "num__patched", "num_padatches", "num_watchists", "num_patterns", "num_padches", "num_funters", "num_funched", "num__matched", "num_batments", "num_aptched", "num_aptches", "num_matched", "num_patternchers", "num_winters", "num_motchers"]}}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 26873, "substitutes": {"p": ["v", "pc", "n", "vp", "pa", "sp", "jp", "f", "pl", "op", "r", "b", "pp", "pkg", "t", "o", "m", "par", "g", "P", "d", "cp", "q", "pi", "a", "fp", "h", "np", "param", "i", "j", "c", "pb", "y", "ps", "w"], "info": ["init", "data", "parse", "is", "text", "result", "count", "user", "in", "iter", "ready", "bar", "ist", "history", "link", "fo", "local", "success", "f", "config", "about", "op", "r", "report", "bit", "z", "state", "sum", "Info", "information", "t", "ip", "comment", "inf", "where", "update", "mi", "add", "o", "INFO", "http", "status", "time", "py", "os", "list", "check", "id", "error", "def", "try", "conf", "fi", "row", "now", "num", "progress", "type", "i", "j", "ion", "stat", "index", "order", "it", "inner", "entry", " inf"]}}
{"project": "FFmpeg", "commit_id": "0de1319ee0109facefe9804ffe0f0d0df36b27ad", "target": 0, "func": "static int http_start_receive_data(HTTPContext *c)\n\n{\n\n    int fd;\n\n\n\n    if (c->stream->feed_opened)\n\n        return -1;\n\n\n\n    /* Don't permit writing to this one */\n\n    if (c->stream->readonly)\n\n        return -1;\n\n\n\n    /* open feed */\n\n    fd = open(c->stream->feed_filename, O_RDWR);\n\n    if (fd < 0) {\n\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    c->feed_fd = fd;\n\n\n\n    if (c->stream->truncate) {\n\n        /* truncate feed file */\n\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n\n        ftruncate(c->feed_fd, FFM_PACKET_SIZE);\n\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n\n    } else {\n\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n\n    lseek(fd, 0, SEEK_SET);\n\n\n\n    /* init buffer input */\n\n    c->buffer_ptr = c->buffer;\n\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n\n    c->stream->feed_opened = 1;\n\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n\n    return 0;\n\n}\n", "idx": 26880, "substitutes": {"c": ["v", "cv", "ca", "cl", "n", "pc", "cache", "gc", "co", "cam", "oc", "anc", "cd", "f", "ce", "cr", "r", "b", "ci", "lc", "fc", "mc", "nc", "cb", "can", "ch", "z", "xc", "at", "bc", "dc", "cs", "cu", "cod", "ac", "ec", "coll", "cn", "p", "chain", "unc", "ic", "com", "cc", "cf", "d", "ct", "cp", "call", "sc", "C", "con", "rc", "cont", "conf", "tc", "vc", "cm", "etc", "ctrl", "abc", "enc"], "fd": ["df", " f", "fin", "dd", "db", "fr", "ctx", "bf", "fa", " fin", "fs", "file", " fid", "f", "gd", " df", "wind", " ff", "td", "ini", "cb", "FD", "elt", "fc", "pid", "fn", "ud", "std", "dt", "func", "cond", "lf", "dir", "uf", "fm", "sd", "dat", "fl", "ds", "pd", "cf", "d", " td", "aft", "bd", "fee", "stream", "fb", "nd", "fed", "ln", "fp", "io", "hd", "ld", "fi", "fe", "handle", "form", "ff", "gz", "dra", "ptr", "ind", "dl", "flo"]}}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884, "substitutes": {"opaque": ["Opaques", " opque", "obque", "cataque", "obaque", " opaques", "OPaques", "catque", "opaques", "OPque", "obaques", "Opque", "cataques", "opque", "OPaque", "Opaque"], "func": ["obj", "cast", "util", "wrap", "job", "closure", "cb", "apply", "fc", "fn", "cmd", "wrapper", "fw", "act", "cu", "coord", "fun", "fac", "conv", "fd", "function", "FC", "cc", "cf", "imp", "con", "Function", "tc", "callback", "c", "proc", "cand", "ff", "unc", "kw", "nc", "ctx"], "f": ["v", "n", "conn", "fr", "bf", "fs", "file", "fo", "b", "r", "F", "fc", "fn", "fw", "t", "fac", "uf", "fm", "o", "fd", "p", "e", "fl", "buffer", "g", "out", "cf", "d", "u", "fb", "fp", "h", "l", "fi", "open", "i", "c", "ff", "proc", "w"], "line": ["LINE", "nl", "profile", "range", "val", "link", "file", "net", "store", "lock", "message", "cmd", "path", "lf", "len", "note", "header", "queue", "ln", "def", "force", "normal", "le", "entry", "Line", "iter", "lin", "body", "eline", "se", "lane", "cat", "str", "tab", "device", "base", "part", "lo", "pe", "handle", "limit", "data", "mid", "look", "print", "query", "ine", "sequence", "comment", "cli", "chain", "buffer", "out", "stay", "flag", "try", "l", "row", "online", "msg", "parse", "text", "page", "in", "frame", "valid", "pipe", "detail", "block", "cell", "key", "stack", "code", "lines", "name", "list", "no", "word", "port"], "buf": ["obj", "txt", "file", "val", "ret", "buff", "cb", "b", "read", "box", "cmd", "pkg", "path", "lf", "que", "queue", "window", "fb", "Buffer", "Buff", "map", "pb", "iter", "db", "history", "load", "rb", "bytes", "cat", "doc", "str", "pad", "tab", "nb", "cap", "wb", "desc", "prop", "cfg", "ctx", "raw", "rev", "data", "cv", "ba", "bp", "rt", "vec", "pool", "uf", "conv", "buffer", "cur", "img", "good", "row", "tmp", "orig", "msg", "temp", "etc", "bag", "bar", "mem", "seq", "block", "bin", "req", "lines", "aka", "br", "batch", "err", "port"], "bus_num": ["bus8no", " bus_NUM", "bus_nr", "bus_NUM", "bus_no", " bus_Num", "device_num", "bus8mon", " bus_no", "bus_number", "bus_sum", "busityNUM", "busitynum", "busityno", "bus64num", "device_nr", " bus_number", "bus_mon", "device_no", "bus64no", "bus_Num", "bus64sum", " bus_mon", "device_sum", "bus8num", "bus64nr", "bus8Num"], "addr": ["Address", "rev", "url", "obj", "adr", "nl", "iter", "offset", "host", "src", "arp", "ar", "ret", "wd", "ace", "loc", "ack", "cb", "cmd", "attr", "address", "ag", "pkg", "usr", "act", "ip", "coord", "arr", "mac", "ac", "align", "ref", "add", "seek", "pad", "rel", "id", "prefix", "ad", "rs", "eth", "rc", "dr", "np", "home", "oad", "ord", "alias", "alt", "pos", "ptr"], "speed": ["limit", "command", "reason", "priority", "drive", "sort", "count", "weight", "offset", "driver", "stick", "scale", "power", "sp", "kind", "timeout", "policy", "delay", "description", "sex", "powered", "state", "performance", "spec", "serial", "rate", "interface", "ssl", "send", "species", "version", "secure", "scan", "status", "spin", "device", "efficiency", "style", "kick", "sw", "rank", "loss", "engine", "sync", "error", "size", "score", "sys", "peed", "pretty", "service", "type", "slow", "sn", "Speed", "port", "length"], "device_count": ["bus_counter", "devicePonly", "bus_id", "busPonly", "device_cache", "devicePcounter", "busPcounter", "device_counter", "device_num", "device_only", "bus_code", "device_id", "busPcode", "serial_cache", "serial_count", "devicePcode", "bus_only", "serial_num", "bus_count", "device_code", "devicePcount", "busPcount"], "class_id": ["classesityident", "classitytype", "classesityid", "product_info", "class_info", "classityinfo", "class_ident", "classesityname", "classityids", "classes_ident", "class_name", "classityname", "class_type", "classitykind", "classityident", "product_ids", "classesitytype", "classes_id", "classes_name", "product_kind", "classes_type", "class_kind", "class_ids", "classityid"], "product_id": ["product2info", "device_name", "product8ide", "productTypeid", "product2index", "product8id", "product___name", "product_index", "product8interface", "device_ide", " product_index", "product_ID", "productWid", " product_num", "product_info", "product_interface", "product___num", "productTypename", "product8name", "product5info", "device_interface", "product_comment", "product2id", "productOide", " product_ID", "product5type", "productOname", "device_id", " product2id", "product_num", "productOid", "product___id", " product_info", "product2type", " product_type", "productWcomment", " product_only", "product_type", "productOinterface", " product2info", "product5id", "product5index", "productTypecomment", "productWonly", " product_comment", "product___ID", "product_ide", " product2type", "productWname", "product_only", "productTypeonly", " product2index"], "vendor_id": ["vendor_info", "vendor5name", "vistor_num", "vistor_name", "vince_name", "vendor_num", "vender_num", "vendor_name", "vendor5id", "vince_path", "vince_type", "vistor_oid", "vender_id", "vender_rank", "vendor_ident", "vendor_oid", "vince_id", "vender_ident", "vendor_type", "vendor5num", "vender_name", "vendor5rank", "vistor_id", "vender_info", "vendor_path", "vendor_rank"], "product_name": ["productnamepath", "component_Name", "product_Name", "product_info", "component_info", "productnamenamed", "productnametype", "component_name", "product_path", " product_path", " product_named", "productnamename", "component_type", " product_type", "product_named", "product_type"]}}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "substitutes": {"oc": ["pc", "co", "mot", "ot", "ocation", "ocr", "ocon", "ob", "og", "loc", "asc", "mc", "toc", "orp", "bc", "oci", "ok", "ac", "oid", "uc", "ec", "ic", "o", "aco", "voc", "cp", "org", "nic", "osc", "arc", "soc", "oad", "ost", "vc", "roc", "ogg", "unc", "alloc", "nc", "oco", "OC"], "data": ["init", "DATA", "cache", "output", "dll", "res", "rec", "result", "dd", "Data", "config", "reg", "info", "di", "func", "boot", "bin", "dat", "dev", "name", "ds", "out", "d", "def", "ata", "raw"], "pcc": ["ppck", "pcct", "cpce", "pbb", "PCC", "apCC", "ppbb", " pce", "procc", "precc", "Pac", "pccc", "ppce", "prect", "pebb", " pbb", "ppct", "cpcca", " pac", "apac", "pecca", "pct", "pCC", "pcCC", "prouc", "cpct", "puc", " pck", "pecc", " pCC", "pce", "Pct", "apcc", "procca", "pcca", "proct", "pcfc", "precca", "pac", " pcca", "ppcc", "cpcc", "pfc", " pacc", " pfc", "preuc", " puc", "ppcca", "Pacc", "pck", " pct", "Pcc", "apacc", "Pfc", "peck", "pacc"], "cc": ["isc", "conn", "ce", "mc", "cmd", "xc", "func", "lf", "ctl", "ac", "cci", "uc", "ec", "coll", "craft", "sc", "c", "disc", "nc", "pc", "cast", "control", "gc", "lc", "ci", "fc", "pp", "cu", "ssl", "lib", "LC", "ct", "cp", "BC", "CC", "cy", "cm", "ctrl", "ctx", "ca", "cv", "acc", "erc", "ll", "cca", "city", "kk", "cs", "cn", "cf", "icc", "ck", "sync", "con", "rc", "cont", "inc", "vc", "unc", "enc", "cache", "cl", "cmp", "ucc", "xx", "co", "cd", "config", "go", "CCC", "bc", "cell", "code", "bec", "soc", "tc"], "dc": ["df", "ca", "iac", "pc", "cmp", "rec", "dp", "gc", "co", "dd", "cam", "cd", "cca", "lc", "mc", "fc", "di", "dt", "bc", "cs", "ctl", "DC", "ac", "mac", "uc", "ec", "ds", "da", "d", "cp", "rc", "dr", "de", "tc", "vc", "c", "disc", "unc", "nc", "ctx"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "substitutes": {"vc": ["sv", "obj", "vp", "isc", "lp", "irm", "jp", "WC", "uv", "vm", "vin", "vl", "cb", "kt", "cmd", "pkg", "xc", "vv", "iv", "vt", "ac", "cci", "hw", "ich", "ls", "wcs", "craft", "att", "form", "c", "inv", "nc", "nt", "pc", "cil", "oc", "lc", "ci", "fc", "pp", "ch", "dc", "cu", "bb", "ek", "cp", "cm", "ctrl", "vr", "ctx", "cv", "VC", "ow", "ll", "xp", "wx", "hl", "mk", "gp", "fw", "lv", "cs", "lic", "ic", "cn", "cf", "ach", "voc", "ib", "cont", "sys", "v", "cmp", "serv", "aq", "rl", "dq", "bc", "gm", "cc", "ev", "tc", "ht", "ship", "dl"]}}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935, "substitutes": {"env": ["init", "sv", "v", "obj", "vp", "js", "conn", "self", "next", "server", "uv", "Environment", "viron", "end", "config", "context", "policy", "gear", "cb", "manager", "state", "pp", "bc", "this", "vt", "shell", "ec", "sb", "m", "e", "code", "buffer", "eng", "en", "environment", "ah", "dev", "ew", "esc", "engine", "window", "ev", "worker", "gov", "sc", "h", "vs", " environment", "desc", "buf", "proc", "ptr", "qt", "entry", "port", "ctx"]}}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "substitutes": {"env": ["obj", "vp", "conn", "uv", "ut", "net", "vm", "store", "cb", "ner", "cmd", "pkg", "pg", "vt", "ei", "ec", "erd", "tm", "hw", "e", "environment", "nv", "window", "np", "vert", "tk", "inv", "er", "ect", "Environment", "manager", "rb", "eh", "shell", "eng", "dev", "ah", "vs", "addr", "param", "desc", "et", "qt", "commit", "ctx", "cv", "context", "hl", "attr", "erb", "esm", "nw", "worker", "rc", "global", "network", "v", "enter", "dn", "server", "disk", "end", "config", "req", "code", "en", "dh", "org", "esc", "ew", "ef", "ev", "ka", "h", "era"], "intno": ["inno", "innum", " intnum", "pointno", "intnum", "altn", "intNo", "altno", "INTNo", " intdo", "INTnos", "interNO", "altNO", " intn", " intnos", "actco", "intereno", " intNO", "Intno", "iterno", "pointdo", "Intnumber", "actno", "indno", "INTno", "pointco", "inteno", "idn", "indnumber", "intNO", "innerno", "idNO", "intdo", "actNo", "innernos", " intNo", "iterdo", "innerNo", "iternum", "iddo", "innerNO", "intnumber", "interno", " intnumber", "pointnos", "actdo", "pointna", "altdo", "IntNO", "intnos", "indo", "indna", "pointnumber", "iterna", "pointnum", "intna", "INTnumber", "INTNO", "INTnum", "internos", " inteno", "inna", "indnum", "interNo", "Intnum", "intn", "internum", "internumber", "pointeno", "idno", "interdo", "interco", " intna", "pointNo", "intco"], "is_int": ["is_inter", "is_uint", "is_i", "isOneint", " is_win", "isUint", " is_intel", "is_win", "isUinternal", "isUstr", " is_uint", "ishintel", "ishstr", " is_str", "is_str", "is_internal", "ishwin", "ishint", " is_i", "isUinter", "isOnei", "is_intel", " is_inter", "isOneuint", " is_internal", "isOnestr"], "error_code": ["error_msg", "error___codes", "ror_msg", "error___msg", "ror_codes", "error___mode", "error___code", "ror_mode", "error_codes", "error_mode", "ror_code"], "next_eip": ["next___uipp", "next_eeip", "next_seip", "next2seIP", "next___uid", "next2ei", "next___uip", "next___eip", "next_eiph", "next_egid", "next_eid", "next_eipp", "next_egip", "next_erid", "next_egiph", "next_seips", "next_seIP", "next_ei", "next_gi", "next_eeips", "next_eripp", "next___eiph", "next2eip", "next_uid", "next___uiph", "next_eei", "next_uiph", "next_uip", "next2sei", "next_eriph", "next_eIP", "next_erip", "next___eipp", "next_eips", "next_sei", "next2seip", "next___eid", "next_gip", "next_egipp", "next2eIP", "next_uipp", "next_eeIP", "next_gIP", "next_gips", "next2eips", "next2seips"], "is_hw": ["is_iw", "is_aux", "is_pkg", " is_pkg", " is_iw", " is_cpu", "is_cpu", "is_ht", "is_hop", " is_aux", " is_ht", " is_hop"], "dt": ["dm", "ect", "tif", "tp", "dn", "dp", "dd", "ta", "db", "lp", "txt", "iat", "tt", "rt", "tn", "td", "elt", "kt", "dq", "t", "dc", "ctl", "tm", "dat", "tz", "ds", "dh", "d", "ct", "mt", "tc", "tk", "pb", "DT", "et", "qt", "bt", "dl", "ctx"], "ptr": ["obj", "pc", "tip", "tp", "adr", "dep", "bp", "ind", "next", "sp", "jp", "prime", "src", "mem", "inst", "pointers", "tr", " sp", "loc", " pointer", "ts", "address", "attr", "ip", "coord", "arr", "ref", "req", "deg", "p", "expr", "buffer", "pt", "pad", "off", "inter", "rel", " address", "mt", " ref", "eth", "cur", "rc", "dr", "ctr", "pointer", "np", "br", "addr", "Ptr", " addr", "handle", "ep", "pr", "pos", "index", "err", "rect", "ctx"], "ssp": ["snd", "ssd", "snl", "tsb", "ssb", "ssl", "sexp", "sexl", "tsl", "tsp", "tsd", "sexd", "sexb", "snp", "snb"], "type": ["tp", "sort", "count", "weight", "ty", "slice", "range", "Type", "sp", "typ", "link", "kind", "action", "ype", "tag", "change", "lock", "otype", "set", "class", "state", "block", "address", "t", "what", "ip", "key", "version", "time", "p", "e", "code", "ping", "status", "name", "style", "pack", "table", "id", "option", "role", "error", "size", "rule", "flag", "value", "TYPE", "pe", "types", "map", "field", "start", " error", "index", " typ", "test", "ver", "port", "length"], "dpl": [" dfl", "dfl", "lpl", "lPL", "lpr", "ffl", "dPL", "dpr", "lfl", " dPL", "fpr", "fPL", " dpr", "fpl"], "selector": ["rective", "rector", "electori", "connective", "electors", "rectors", "connectors", "selective", "selectori", "rectori", "connectori", "selectors", "connector", "elective", "elector"], "ss_dpl": ["ss_lsl", "ss_fcl", "ss_sbl", "ss_dcl", "ss_fbl", "ss_ssl", "ss_fpl", "ss_scl", "ss_lbl", "ss_fsl", "ss_dsl", "ss_lpl", "ss_lcl", "ss_spl", "ss_dbl"], "cpl": ["dcPL", "cpt", "dcpl", "dcpp", "cpp", "mpp", "mpt", "dpp", "dPL", "mPL", "dcpt", "cPL", "dpt", "mpl"], "has_error_code": ["has_success_error", "has_error_codes", "has_err_codes", "has_err_code", "has_error_time", "has_error__codes", "has_error_Code", "has_error_error", "has_err_Code", "has_success_time", "has_success_Code", "has_error__code", "has_error__error", "has_error__time", "has_success_codes", "has_success_code"], "new_stack": ["raw_st", "new_scope", "new_struct", "raw_scope", "raw_stack", "raw_struct", "new_st"], "shift": ["init", "sort", "range", "scale", "change", "shr", "delay", "diff", "push", "hold", "block", "sum", "sh", "send", "align", "Shift", "hash", "seek", "sup", "rank", "depth", "window", "id", "flag", "share", "map", "skip", "start", "hift", "transform", "pos", "index", "set"], "e1": [" e7", "ee1", "eOne", "ee7", " e3", "ee3", "ee0", " eOne", "xe1", "e5", "ee2", "aeone", "ae1", "aeOne", "xeone", "te0", " e5", " eone", "e0", "ae2", "xe2", "te3", "ee5", "te1", "te5", " e0", "eone", "e7", "e3", "xeOne", "te2", "te7"], "e2": ["er02", "eeTwo", " e7", "ee1", "eTwo", "me2", "E1", "er5", " e3", "Etwo", "ee3", "E2", "ee0", " etwo", "e4", "element2", "er1", " eTwo", "er0", "er2", "ee4", "ee2", "me7", "ei1", "e5", "ei2", "E7", "ei4", " e5", "me3", "e0", "E3", "e02", "er4", " e4", "element4", "metwo", "ee5", "er3", " e0", "E4", "ee02", " e02", "e7", "elementTwo", "e3", "etwo", "ei3", "element1"], "offset": ["limit", "sort", "scroll", "slice", "end", "op", "lock", "address", "origin", "ip", "seek", "off", "mt", "error", "flag", "pointer", "skip", "alt", "transfer", "ff", "pos", "index", "start", "extra"], "esp": ["ap", "tp", "rap", "bp", "eps", "exec", "lp", "sp", "asp", "xp", "ns", "isp", "reset", "esi", "eb", "ip", "sb", "p", "expr", "cp", "exe", "es", "imp", "ef", "fp", "resp", "xy", "addr", "ep", "et", "ps", "rss", "yp"], "old_eip": ["old_seIP", "old_seisp", "old_ceips", "old_nisp", "old_eIP", "old_seib", "old_esip", "old_eeip", "old___ei", "old_eib", "old_eips", "old_eiph", "old_ei", "old_esips", "old___eeisp", "old_eipt", "old_eep", "old_dipt", "old_nips", "old_ceiph", "old_aeep", "old_aeip", "old_meip", "old___eei", "old_mei", "old_eei", "old_ceIP", "old_eeisp", "old_seips", "old_eeib", "old_ni", "old_dIP", "old_aeipt", "old_seiph", "old_esiph", "old_eeep", "old_meIP", "old_eeips", "old_dep", "old___eeip", "old_esIP", "old_ceip", "old_meipt", "old_seep", "old___eips", "old_seip", "old___eisp", "old_meib", "old___eip", "old_meep", "old_sei", "old_nip", "old_dip", "old_eisp", "old___eeips", "old_aeIP"], "sp_mask": ["sp_ms", "sp_lock", "p_lock", "p_match", "sp_match", "p_mask", "p_ms"], "mask": ["limit", "bits", "sort", "max", "result", "count", "ms", "zero", "weight", "master", "filter", "mode", "scale", "Mask", "tag", "lock", "ask", "mk", "hold", "mx", "sum", "sign", "key", "sk", "arr", "hash", "m", "code", "pack", "id", "clear", "mt", "mark", "window", "miss", "flag", "ape", "map", "flags", "types", "skip", "batch", "transform", "set", "mb"]}}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945, "substitutes": {"env": ["sv", "obj", "vp", "txt", "uv", "vm", "cb", "cmd", "vv", "vt", "ec", "erd", "forge", "e", "hw", "environment", "nv", "window", "here", "conf", "entry", "w", "er", "db", "policy", "manager", "rb", "eh", "doc", "eng", "dev", "ah", "fee", "equ", "vs", "ov", "desc", "et", "order", "ctx", "data", "cv", "ent", "context", "event", "em", "esm", "stage", "worker", "global", "proc", "msg", "etc", "network", "enc", "v", "ve", "enter", "server", "ext", "disk", "ee", "end", "viron", "config", "gear", "info", "stack", "code", "en", "dh", "eve", "org", "ew", "ef", "ev", "up", "h", "era", "err", "self"]}}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 26946, "substitutes": {"cpu": ["linux", "bench", "pc", "hog", "tp", "conn", "gc", "upt", "ruby", "ctx", "jp", "node", "apache", "phys", "net", "mem", "vm", " pc", "core", "process", "cmd", "pool", "processor", "hap", "mx", "ilo", "pu", "cu", "boot", "mac", "clock", "ork", "gpu", "hw", "java", "buffer", "aco", "cc", "kernel", "crypt", "device", "cp", "window", "sync", "memory", "gnu", "sys", "chip", "handle", "CPU", "proc", "c", " CPU", "socket", " cp", "prof", " proc"], "hash": ["data", "cache", "ih", "profile", "node", "primary", "tag", "ha", "has", "attr", "sum", "t", "key", "sh", "total", "kh", "ref", "version", "sha", "Hash", "ash", "ping", "hw", "name", "header", "dh", "crypt", "rh", "check", "array", "size", "h", "height", "ho", "chip", "conf", "map", "addr", "handle", "index", "ptr", "ch", "password"], "secondary": ["ary", "security", "chron", "sharp", "master", "final", "small", "physical", "binary", "primary", "iary", "weak", "missing", "sensitive", " external", "second", "ssl", "sec", "single", "remote", "critical", "unknown", "secure", "exclusive", "secret", "shared", "specific", "multiple", "screen", "SI", "sys", "global", "foreign", "external", "shadow", "special", " supplementary", "si", " primary", "negative"], "ptem": ["pastemi", "pteem", "pteme", "aptev", "pasteem", "iptee", "pasteme", " pteme", "monteme", "iptev", "montem", "pastem", "ptemi", "ptee", "aptee", " ptev", "aptem", "apteme", "ptev", "apteem", "aptemi", "ipteme", "monteem", "montemi", " ptee", "iptem"], "pte": ["ptyea", "ptye", "ctee", "apte", "ctec", "arto", "ppel", "artel", "artem", "porto", "ptea", "ptyet", "cto", "artec", "ppee", "ploadet", "portec", "pto", "ptel", "ptee", "ppem", "ploadee", "aptee", "artee", "ptyee", "aptet", "ptet", "arte", "portee", "ppe", "aptea", "ploade", "portel", "cte", "ploadea", "porte", "ptec", "portem"], "env": ["er", "v", "her", "ve", "conn", "db", "next", "eni", "ext", "node", "serv", "viron", "net", "config", "priv", "context", "mem", "end", "vm", "den", "state", "cmd", "eh", "ec", "doc", "e", "code", "eng", "en", "environment", "dev", "ds", "ah", "org", "nv", "ew", "window", "ev", "engine", "worker", "enc", "con", "vs", "pe", "conf", "map", "cap", "pen", "buf", "head", "proc", "ptr", "et", "entry", "cfg", "ctx"], "i": ["qi", "ex", " I", " iter", "ix", "xi", "ii", "ip", "ei", "p", "e", "id", "s", "zi", "y", "bi", "ind", "I", "n", "ci", " multi", "di", "by", "u", "pi", " mi", "iu", " ti", "phi", " my", "init", " j", "is", "me", "ini", "gi", "hi", " bi", "cli", "sim", "ic", "m", "multi", "ri", " ii", "\u0438", " si", "im", "l", " pi", " index", "j", "index", "si", "v", "in", "li", " ni", "ai", "ji", "t", "mi", " m", "o", "g", " di", "span", "ti", "x", "it", "ui"], "token": ["prototype", "recorded", "zero", "found", "txt", "typ", "lock", "message", "reset", "identified", "state", "tree", "processor", "note", "p", "scan", "header", "status", "kn", "window", "value", "pointer", "record", "session", "tk", "normal", "attribute", "TO", "output", "n", "Token", "result", "tool", "json", "TN", "WT", "timer", "vector", "match", "statement", "device", "needed", "response", "prefix", "wt", "joined", "field", "data", "KEN", "channel", "local", "null", "buffer", "table", "tty", "trigger", "callback", "index", "KEY", "created", "variable", "node", "oken", "setup", "t", "single", "key", "ok", "template", "number", "list", "seed", "rule", "present", "span", "label", "tar", "word", "scope", "socket", "password"], "pte0": ["ptye01", "pteleNo", "ptme0", "pteeZero", "ptee050", "porteZero", "ptoe0", "ptee2", "aptee255", "pto0", "ptee8", "ptoId", "ptele0", "ptea255", "ptoe2", "portee2", "ptemzero", "ptE2", "ptoNo", "apte0", "pteId", "ptea0", "porte6", "ptezero", "ptee255", "ptee1", "ptoe1", "apteNo", "ptE1", "ptem00", "ptele1", "pteezero", "aptee0", "ptome0", "porte2", "ptmezero", "pteleZero", "porteeZero", "portee050", "apte1", "ptoe255", "ptea01", "ptelement050", "apte8", "aptee00", "pte050", "ptee6", "ptelement6", "pteaZero", "ptye0", "ptme00", "ptee01", "pte6", "portee0", "apteId", "porte8", "apte00", "porte050", "ptE8", "ptE0", "pteeId", "ptea8", "ptee0", "pte01", "porte1", "portee1", "pteNo", "pte2", "pte8", "ptem0", "ptelement1", "porte0", "ptome1", "porte01", "aptezero", "apteeId", "aptee8", "ptyeZero", "ptome050", "apteezero", "ptome6", "pteleId", "pte255", "ptoe8", "ptye1", "portee8", "pte00", "apteeNo", "portee6", "portee01", "pteeNo", "ptme1", "pto1", "apte255", "ptelement0", "pteZero", "ptea1", "aptee1", "ptem1", "ptee00"], "pte1": ["ptende91", "pte2", "ptte1", "ptei6", "ptee6", "pointe0", "porte0", "ptreeOne", "pter0", "ptoe6", "pte91", "porteeOne", "ptte91", "portee3", "ptee1", "ptte2", "ptee2", "pointe2", "ptoe0", "ptoe1", "pointe6", "pte6", "pointee91", "portee0", "ptee3", "ptree0", "pointee3", "pointe3", "ptee0", "ptee91", "ptoeOne", "ptende2", "pointe1", "pteOne", "porteOne", "ptende1", "ptei1", "pte3", "ptoe2", "ptei0", "ptei3", "porte3", "porte1", "ptree1", "ptree3", "pointeOne", "pointee2", "ptte0", "pter1", "pointe91", "ptende0", "portee1", "pteeOne", "ptoe3", "pointee6", "pointeeOne", "pterOne", "pointee0", "pter2", "pointee1"], "pte_index": ["pte_head", "pte12index", "ptee_block", "pte8index", "ptee_Index", "pte12Index", "pte12block", "pte_key", "ptoe_index", "ptee_index", "pte_path", "pte8find", "pte_size", "pte2Index", "ptee_path", "pte__no", "pte2key", "pte_Index", "pte_no", "pte_type", "ptoe_Index", "pte__type", "pte8Index", "ptoe_key", "ptee_num", "pte8head", "pte_num", "pte_block", "pte__num", "pte_find", "pte12path", "ptee_find", "ptoe_size", "pte2index", "ptee_type", "ptee_head", "pte__index", "pte2size", "ptee_no"]}}
{"project": "FFmpeg", "commit_id": "39f7620d76c7a133535ed7a535f7a74fefa6e435", "target": 0, "func": "static av_cold int dcadec_init(AVCodecContext *avctx)\n\n{\n\n    DCAContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->core.avctx = avctx;\n\n    s->exss.avctx = avctx;\n\n    s->xll.avctx = avctx;\n\n    s->lbr.avctx = avctx;\n\n\n\n    ff_dca_init_vlcs();\n\n\n\n    if (ff_dca_core_init(&s->core) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (ff_dca_lbr_init(&s->lbr) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ff_dcadsp_init(&s->dcadsp);\n\n    s->core.dcadsp = &s->dcadsp;\n\n    s->xll.dcadsp = &s->dcadsp;\n\n    s->lbr.dcadsp = &s->dcadsp;\n\n\n\n    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);\n\n\n\n    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {\n\n    case 0:\n\n        s->request_channel_layout = 0;\n\n        break;\n\n    case AV_CH_LAYOUT_STEREO:\n\n    case AV_CH_LAYOUT_STEREO_DOWNMIX:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT0:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT1:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_WARNING, \"Invalid request_channel_layout\\n\");\n\n        break;\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n\n    avctx->bits_per_raw_sample = 24;\n\n\n\n    return 0;\n\n}\n", "idx": 26947, "substitutes": {"avctx": ["avval", "vcmp", "wavval", " avcmd", "wavcu", "averpa", "AVcontext", "ajtx", " avpkg", "avpa", "averjac", "savctx", "avecontext", "avercp", "awtx", "AVjac", "ajcam", "avertx", "AVobj", "vartx", "avcam", "vrtxt", "averpkg", " avjp", "vrcontext", "navtx", " avtx", " avconn", "avercu", "avqt", "avetx", "navctx", "avcpu", "vanjp", " avcu", " avtxt", "avtxt", "vrtx", "avetimeout", "avtimeout", "wavjac", "abcontext", "vanpa", "vanctx", "wavtx", " avcontext", "savcu", "savcontext", " avobj", " avval", "avertxt", "avtx", " avcmp", "AVpkg", "abctx", "wavctx", "avconfig", "avercontext", "abtx", "aftx", "avecpu", "avcontext", "verctx", "AVcfg", "vrctx", "navjp", "varqt", "afctx", "vrjp", "avjp", "afobj", "avcmd", "vrcmp", "avecmd", "averqt", " avconfig", "avobj", "verconn", " avjac", "avpkg", "avconn", " avcpu", "avercam", "varnp", "awcfg", "vercontext", "vertx", "avercpu", "avcp", "avcmp", "vcmd", "afcontext", "varctx", "avernp", "vrjac", "avercfg", "avnp", " avnp", "vctx", "averctx", " avcfg", "AVtx", "vantx", "avertimeout", " avtimeout", "afjp", "averval", "AVctx", "aveconfig", "vcontext", "avcfg", "abconn", "avjac", "awctx", "wavcontext", "ajcu", "averjp", "ajctx", "vrconfig", "wavcam", "savcp", " avcp", " avpa", "vrcmd", "navcontext", "awcp", "avectx", " avqt", "avcu"], "s": ["sv", "obj", "gs", "ms", "ses", "changes", "services", "sam", "details", "store", "b", "pers", "state", "ops", "comments", "bes", "aws", "ls", "so", "rs", "des", "as", "conf", "als", "i", "sports", "c", "y", "uploads", "ps", "set", "w", "er", "bis", "erences", "fs", "params", "ns", "full", "ants", "states", "ts", "has", "se", "save", "south", "less", "sb", "ins", "os", "es", "vs", "stats", "sts", "all", "ports", "settings", "args", "hs", "is", "rates", "f", "ss", "spec", "cs", "ats", "conv", "comm", "ds", "tes", "j", "sq", "v", "js", "S", "source", "serv", "qs", "t", "gets", "ims", "g", "sl", "sw", "ess", "acs", "bs", "its", "self"]}}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) {\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t i, j;\n\n\n\n    vc->mapping_count=get_bits(gb, 6)+1;\n\n    vc->mappings=(vorbis_mapping *)av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));\n\n\n\n    AV_DEBUG(\" There are %d mappings. \\n\", vc->mapping_count);\n\n\n\n    for(i=0;i<vc->mapping_count;++i) {\n\n        vorbis_mapping *mapping_setup=&vc->mappings[i];\n\n\n\n        if (get_bits(gb, 16)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\");\n\n            return 1;\n\n        }\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->submaps=get_bits(gb, 4)+1;\n\n        } else {\n\n            mapping_setup->submaps=1;\n\n        }\n\n\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->coupling_steps=get_bits(gb, 8)+1;\n\n            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            for(j=0;j<mapping_setup->coupling_steps;++j) {\n\n                mapping_setup->magnitude[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                // FIXME: sanity checks\n\n            }\n\n        } else {\n\n            mapping_setup->coupling_steps=0;\n\n        }\n\n\n\n        AV_DEBUG(\"   %d mapping coupling steps: %d \\n\", i, mapping_setup->coupling_steps);\n\n\n\n        if(get_bits(gb, 2)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%d. mapping setup data invalid. \\n\", i);\n\n            return 1; // following spec.\n\n        }\n\n\n\n        if (mapping_setup->submaps>1) {\n\n            mapping_setup->mux=(uint_fast8_t *)av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));\n\n            for(j=0;j<vc->audio_channels;++j) {\n\n                mapping_setup->mux[j]=get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        for(j=0;j<mapping_setup->submaps;++j) {\n\n            skip_bits(gb, 8); // FIXME check?\n\n            mapping_setup->submap_floor[j]=get_bits(gb, 8);\n\n            mapping_setup->submap_residue[j]=get_bits(gb, 8);\n\n\n\n            AV_DEBUG(\"   %d mapping %d submap : floor %d, residue %d \\n\", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26971, "substitutes": {"vc": ["sv", "nt", "v", "cv", "vp", "pc", "ve", "wr", "VC", "ow", "irm", "uv", "serv", "WC", "xp", "wx", "vm", "wd", "vin", "vl", "veh", "lc", "mk", "vd", "ant", "fc", "cmd", "voice", "pp", "vo", "xc", "lv", "vv", "bc", "tv", "dc", "cs", "iv", "vt", "conv", "fax", "coll", "ic", "hw", "gt", "dev", "cc", "vet", "voc", "wcs", "vine", "nv", "craft", "course", "px", "ev", "ib", "vol", "vs", "av", "vg", "vert", "vy", "form", "c", "ht", "inv", "etc", "vi", "vr", "csv", "sky"], "gb": ["gif", "bridge", "cv", "hog", "bits", "gs", "gc", "wm", "db", "abi", "Gb", "ruby", "ub", "ctx", "bf", "raw", "binary", "uv", "bg", "gd", "aaa", "vm", "cb", "tg", "rb", "phy", "vd", "buff", "rect", "hub", "attr", "eb", "gp", "bytes", "gy", "pg", "gm", "html", "arb", "vt", "rg", "lib", "sb", "gpu", "fps", "gt", "goo", "g", "bb", "py", "pi", "nb", "fb", "ib", "bm", "kb", "gnu", "img", "storage", "gam", "sys", "gh", "bs", "vg", "gg", "wb", "GB", "eg", "gz", "pb", "cm", "bt", "cfg", "csv", "mb"], "i": ["qi", "v", "k", "n", "asi", "batch", "me", "in", "li", "ij", "any", "f", "ix", "it", "xi", "ri", "ai", "ami", "ini", "go", "ji", "instance", "b", "gi", "ci", "iso", "info", "di", "ii", "t", "mi", "ip", "key", "ei", "ims", "sim", "m", "p", "e", "multi", "my", "g", "ui", "ic", "o", " ii", "pi", "id", "kit", "\u0438", "im", "iu", "s", "l", "ish", "fi", "point", "ti", "phi", "c", "x", "index", "zi", "ia", "y", "ie", "si", "bi", "ind", "I"], "j": ["ja", "v", "aj", "obj", "k", "n", "kid", "js", "fr", "J", "jo", "json", "ij", "jp", "jl", "it", "ix", "job", "kj", "ji", "prop", "b", "z", "jas", "ii", "t", "je", "key", "other", "yy", "kh", "sim", "m", "p", "str", "jj", "g", "jac", "jump", "q", "ev", "uj", "jc", "bj", "ju", "att", "br", "us", "ng", "oj", "c", "x", "index", "dj", "y", "ie", "bi", "ind", "ch"], "mapping_setup": ["mapping_track", "matching_setup", "mutationerrunner", "mappinglistsetup", "mording_success", "mapping___request", "mapping1prefix", "mutation_test", "mapping_create", "matching___sequence", "mappingpttrack", "mappinglistsuccess", "mutationersetup", "mappingptresponse", "mapping_des", "mapping1prep", "mappingersetup", "mitation_status", "mappingingSetup", "maming_Setup", "mappingingsummary", "mappingacSetup", "mapper_data", "mording___success", "mapping_share", "mappingacsite", "matching___store", "manting_Setup", "mappingacsetup", "mapping_check", "mappinglistcreate", "matching_prep", "mapping___sequence", "mapping_sequence", "mapping67Setup", "mapping1des", "mapping8response", "mapping67check", "mapping8summary", "mangling_Setup", "mangling_site", "matchingersetup", "mapping2track", "mapping_prefix", "mappingersummary", "mantingingsummary", "mapping_prep", "mitation_response", "mapper_request", "mutationerupdate", "mapping_tool", "mapping_summary", "mappingacprep", "mappingptstatus", "mapping_data", "matching_des", "mitation_setup", "matchingersite", "mitation8response", "matching_prefix", "manglingacsite", "matching_track", "mappingptstore", "mapping8des", "manting_setup", "mapping_request", "mutation_setup", "mappingersite", "maming_setup", "mapping67data", "mapping_success", "mappingptshare", "matching_join", "mapping___prefix", "mapping1setup", "mappingptSetup", "mantingingsetup", "matching_store", "mapping67setup", "mappingerupdate", "mappingptsetup", "mutation_update", "mappingingshare", "mapping1join", "mapping8site", "mapping___Setup", "mitation_des", "mappingptdes", "mantingingshare", "mapping_response", "mappinglisttool", "mapping___track", "mapping2store", "mapping___prep", "mappinglisttest", "mapping_test", "mutationertest", "mapping2sequence", "mapping_config", "mutation_runner", "mapper_setup", "mapping_Setup", "mitation8des", "mappingingsetup", "mapping_update", "manglingacsetup", "mording___tool", "maming_success", "mangling_setup", "mappingerrunner", "mapping___store", "mitation8status", "manting_share", "mappinglistupdate", "mording_create", "mapping2setup", "mapping_status", "mapping___success", "matchingersummary", "mapping1site", "mapper_prep", "mapping___tool", "matching_sequence", "mitation8setup", "mappingptsequence", "mording_setup", "mapping_runner", "mappingptsummary", "mording___setup", "mapping1Setup", "maming_response", "mording___create", "mapper_Setup", "mapping_store", "mapper_check", "matching___setup", "mapping_site", "mangling_prep", "matching_site", "mapping___site", "mappinglistrunner", "matching_summary", "matching___track", "mantingingSetup", "mording_tool", "mapping___create", "mappingertest", "mapping___des", "mapping_join", "manglingacSetup", "mapping8setup", "manting_summary", "mapping___setup", "matching_Setup", "manglingacprep", "mapping8status"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987, "substitutes": {"dev": ["nt", "v", "obj", "md", "sky", "cam", "conn", "DEV", "serv", "pro", "mem", "iv", "dem", "ref", "p", "hw", "pad", "wh", "device", "Dev", "d", "ach", "ev", "ad", "adv", "att", "od", "def", "h", "de", "addr", "home", "proc", "ptr", "ch", "w"], "taddr": ["paddress", " tptr", "vaddress", "vtaro", "vmap", "tptr", "taro", "vaddr", " tadd", "tadd", " tmap", "padd", " taro", "vtadd", "pmap", "vtaddress", "pptr", "tmap", "paddr", "paro", "vptr", " taddress", "taddress", "vtaddr"], "val": ["data", "vals", "v", "res", "pol", "ctx", "serv", "valid", "f", "pl", "mem", "ret", "seq", "tx", "var", "VAL", "vec", "reg", "bit", "b", "aval", "Val", "sol", "elt", "ival", "t", "len", "bl", "al", "vt", "arr", "ac", "ref", "doc", "p", "m", "sel", "fl", "pt", "sl", "fee", "cal", "arg", "value", "vol", "l", "resp", "num", "alt", "buf", "pr", "x", "rol", "eval", "msg", "it", "test", "err", "all", "lit"]}}
{"project": "FFmpeg", "commit_id": "066fff755a5d8edc660c010ddb08474d208eeade", "target": 0, "func": "static void vp6_parse_coeff_models(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    VP56Model *model = s->modelp;\n\n    int def_prob[11];\n\n    int node, cg, ctx, pos;\n\n    int ct;    /* code type */\n\n    int pt;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    memset(def_prob, 0x80, sizeof(def_prob));\n\n\n\n    for (pt=0; pt<2; pt++)\n\n        for (node=0; node<11; node++)\n\n            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {\n\n                def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            }\n\n\n\n    if (vp56_rac_get(c)) {\n\n        for (pos=1; pos<64; pos++)\n\n            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))\n\n                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);\n\n        vp6_coeff_order_table_init(s);\n\n    }\n\n\n\n    for (cg=0; cg<2; cg++)\n\n        for (node=0; node<14; node++)\n\n            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))\n\n                model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);\n\n\n\n    for (ct=0; ct<3; ct++)\n\n        for (pt=0; pt<2; pt++)\n\n            for (cg=0; cg<6; cg++)\n\n                for (node=0; node<11; node++)\n\n                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {\n\n                        def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    }\n\n\n\n    if (s->use_huffman) {\n\n        for (pt=0; pt<2; pt++) {\n\n            vp6_build_huff_tree(s, model->coeff_dccv[pt],\n\n                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);\n\n            vp6_build_huff_tree(s, model->coeff_runv[pt],\n\n                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);\n\n            for (ct=0; ct<3; ct++)\n\n                for (cg = 0; cg < 6; cg++)\n\n                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n\n                                        vp6_huff_coeff_map, 12,\n\n                                        &s->ract_vlc[pt][ct][cg]);\n\n        }\n\n        memset(s->nb_null, 0, sizeof(s->nb_null));\n\n    } else {\n\n    /* coeff_dcct is a linear combination of coeff_dccv */\n\n    for (pt=0; pt<2; pt++)\n\n        for (ctx=0; ctx<3; ctx++)\n\n            for (node=0; node<5; node++)\n\n                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);\n\n    }\n\n}\n", "idx": 26988, "substitutes": {"s": ["sv", "v", "settings", "n", "is", "hs", "gs", "js", "ses", "fs", "S", "ns", "f", "ss", "r", "b", "ts", "qs", "se", "spec", "t", "cs", "less", "ats", "sb", "ins", "o", "p", "m", "e", "times", "aws", "ds", "g", "ls", "os", "a", "es", "rs", "sc", "h", "sets", "sys", "stats", "sts", "bs", "i", "sq", "ps", "w"], "c": ["v", "cv", "ca", "n", "cache", "cl", "pc", "gc", "co", "f", "context", "ce", "b", "lc", "mc", "r", "fc", "nc", "xc", "bc", "dc", "t", "cs", "cu", "ac", "cus", "uc", "ec", "cn", "ic", "p", "m", "e", "chain", "g", "cc", "com", "cf", "jac", "cp", "u", "a", "sc", "C", "con", "h", "rc", "l", "cont", "as", "tc", "vc", "cm", "unc", "abc", "ch"], "model": ["command", "v", "Model", "db", "server", "frame", "member", "filter", "mode", "link", "ll", "config", "mem", "vm", "policy", "mod", "message", "manager", "address", "handler", "mi", "man", "relation", "mail", "el", "remote", "sim", "mm", "m", "p", "dev", "ml", "controller", "project", "rm", "table", "response", "base", "app", "models", "bm", "rule", "l", "map", "module", "form", "transform", "leader", "network", "sm", "mb"], "def_prob": ["defingcacheba", "def_predob", "def_cob", "def_profB", "def_purx", "defingprob", "def_purbe", "def_preb", "def_prib", "def_prg", "def_comb", "def_Probe", "def_prop", "def_Proba", "def_purba", "def_probf", "def_Proc", "def_prx", "def_coc", "def_comc", "defingproB", "def_proB", "def_comp", "def_proc", "def_Prob", "def_Prop", "def_prc", "def_prbe", "def_comf", "def_profbf", "defingcacheb", "def_prof", "def_cacheba", "def_Prox", "def_cachebf", "def_cacheb", "defingproba", "def_Proob", "def_prox", "def_cacheB", "def_proba", "def_prb", "def_predx", "defingcacheB", "def_func", "def_Prof", "def_coba", "def_cobe", "def_prba", "def_predp", "defingcachebf", "def_pric", "def_prog", "def_preob", "def_Prog", "def_fung", "defingprobf", "def_proob", "def_prep", "def_purb", "def_probe", "def_profba", "def_profb", "def_prex", "def_predb", "def_prif", "def_funb", "def_funbe", "def_prip"], "node": ["our", "cookie", "obj", "kid", "zero", "conn", "nu", "net", "stroke", "kt", "box", "cmd", "tree", "note", "function", "connection", "wn", "depth", "id", "nd", "value", "leaf", "non", "np", "now", "session", "type", "nie", "nc", "ind", "nt", "nut", "pc", "n", "kan", "holder", "gc", "day", "nce", "host", "client", "peer", "ne", "td", "pn", "son", "process", "station", "cod", "ode", "device", "part", "pe", "nn", "num", "ng", "back", "edge", "col", "ptr", "onet", "inner", "wo", "and", "tp", "mid", "local", "ent", "parent", "event", "token", "hop", "component", "port", "annot", "remote", "nw", "unit", "card", "row", "tmp", "ano", "yn", "degree", "index", "msg", "post", "server", "member", "cd", "slot", "go", "cell", "t", "stone", "en", "Node", "name", "generation", "seed", "no", "bo", "snap", "od", "child", "point", "entity", "x"], "cg": ["cmg", "cfgo", " cog", "xcged", "cachew", " cyg", "cacheyg", "acmsg", "cgp", "casemg", "ecmg", "cogr", " cgi", "cdbg", " ctg", "caseg", "cgd", "congg", "cw", "ecge", "casege", "cgt", " cw", "vcgi", "conyg", "cog", "lcmsg", "vcg", "ccg", " cgo", "acgm", "xcg", "ccgu", "csg", "lcgm", " cgt", "cachegg", "cged", "ucg", "ucgt", "cmsg", "acgd", " cgs", "cfgs", "dcgi", "congi", " cmsg", "congm", "cgr", "cgg", "cyg", "cacheg", "dcgs", "ccw", " cgu", "ccgr", "ucog", "dcgo", "cachegp", "cfg", "cdg", "ecg", "cachegm", "cogu", "cfgm", "lcged", "cachegt", "cgm", "congr", "xcmsg", "cacheog", "vcgd", "ccgm", "casegu", "ccge", "cgi", "cfgi", "cachegu", "cgu", "cong", "vcgm", "acg", " cgg", " cgp", "acgr", "acgi", " cgr", "ucgu", "acsg", "ccmg", "xcgm", "cfgu", " cgm", " cbg", "ctg", "cdmsg", "cachetg", "consg", "conmsg", "cfgr", "cgs", " cged", "cogm", "cge", "dcg", "cdgi", "conbg", "ccgp", "cctg", "ecgu", " csg", "cbg", " cgd", "lcg", "cgo"], "ctx": ["nt", "obj", "cmp", "co", "ot", "txt", "cd", "context", "tx", "ant", "cb", "loc", "kt", "cmd", "act", "ac", "gt", "pot", "cc", "cf", "jac", "cp", "ctr", "np", "tmp", "tc", "xs", "col"], "pos": ["nt", "pc", "n", "res", "offset", "post", "ot", "sp", "val", "client", "Pos", "kat", "pl", "pro", "slot", "parent", "tx", "loc", "trans", "pid", "spec", "pres", "cond", "at", "act", "po", "len", "pass", "key", "rot", "pat", "add", "doc", "p", "pad", "out", "pot", "pose", "apo", "pi", "os", "px", "part", "no", "def", "position", "point", "resp", "num", "row", "neg", "POS", "col", "pr", "index", "prop", "ps", "ind", "port"], "ct": ["nt", "gen", "unt", "obj", "ect", "cot", "pent", "cent", "nut", "count", "tp", "cats", "cv", "sat", "Ct", "apt", "ot", "opt", "tt", "cd", "ent", "rt", "net", "ant", "capt", "nc", "kt", "cmd", "ppa", "dt", "cond", "act", "t", "ctl", "vt", "fact", "cat", "pat", "cod", "sect", "cn", "ft", "percent", "pot", "cf", "vet", "crit", "cp", "lat", "ctr", "cont", "sit", "tmp", "mat", "tc", "cap", "col", "cart", "ptr", "et", "stat", "CT", "bt", "ht"], "pt": ["nt", "ipt", "pc", "n", "tp", "chron", "conn", "pa", "points", "apt", "ot", "txt", "sp", "typ", "rt", "pl", "slot", "pan", "tx", "td", "pn", "kt", "ts", "pid", "cmd", "pool", "pp", "pkg", "pg", "ppa", "dt", "pit", "t", "act", "plot", "pat", "port", "pty", "p", "gt", "pot", "ds", "pd", "tz", "vet", "py", "cp", "px", "part", "bo", "mt", "wt", "mont", "lat", "pton", "point", "ept", "PT", " pts", "pr", "ptr", "et", "ht", "qt", "col", "j", "ps", "po", "set"]}}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n", "idx": 26993, "substitutes": {"opts": ["optals", "opTS", "copTS", "popals", "popts", "OPTS", " opt", "opps", "opt", " opopt", "OPcs", " ops", "cops", "optopt", "OPopt", "ops", "props", "propt", "popcs", "OPals", "opfs", " opps", "OPs", "optts", " oppt", "optt", "opcs", "iopts", "oppt", "copts", "copfs", "OPt", "prots", "optcs", "iopps", "iopt", "opals", "optTS", "opopt", "pops", "OPfs", "ioppt", "optfs", "prot", "OPts"], "v": ["sv", "cv", "vp", "ve", "qv", "uv", "f", "it", "vm", "var", "b", "vo", "tv", "iv", "t", "vt", "conv", "o", "m", "p", "g", "u", "q", "nv", "ev", "gener", "vu", "V", "h", "s", "vs", "l", "av", "ov", "ver", "vy", "j", "vc", "i", "c", "inv", "pr", "vi", "vr", "w"], "userdef": ["userdefinition", "usedef", "usrdf", "mapdefined", "userdefined", "mapDef", "Userdefinition", "Userdef", " userdefined", "usrDef", "usrdef", "useDef", "userDef", " userDef", "mapdefinition", " userdefinition", "usrdefined", "Userdefined", "useref", " useref", "Useref", " userdf", "userdf", "UserDef", "mapdef", "usedf", "usref"]}}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n", "idx": 27000, "substitutes": {"bs": ["BS", "aus", "bits", "bas", "hs", "iss", "bis", "gs", "js", "bp", "bf", "obs", "fs", "blog", "ns", "ubs", "ss", "b", "ps", "ts", "bos", "bc", "cs", "bl", "bes", "sb", "bh", "fps", "ds", "bles", "ls", "rs", "bm", "lbs", "ys", "aos", "its", "bi"], "sector_num": ["sectorIdmult", "sector_coord", " sector_mult", "sectorIdmon", "sector_no", "sector2number", "sectorIdnum", " sector_mon", " sector_number", "sector_mult", "sectorIdnumber", "sector_number", "sector2mon", " sector_no", "sector_mon", "sector2mult", "sector2num", " sector_coord"], "nb_sectors": ["nb_speors", "nb_veicators", "nb_vecs", "nb_pseors", "nb_pecs", "nb_peors", "nb_spectors", "nb_seors", "nb_perseors", "nb_persectors", "nb_segments", "nb_seicators", "nb_seivers", "nb_speivers", "nb_secs", "nb_specs", "nb_veivers", "nb_veors", "nb_perseicators", "nb_psegments", "nb_pseicators", "nb_persegments", "nb_vegments", "nb_psectors", "nb_vectors", "nb_pectors", "nb_peivers"], "pnum": ["PNUM", "gnumer", "panum", "panumer", "pnumer", "gnum", "gnumeric", "gnnum", "PNum", "penumer", "PNnum", "pngumer", "pngum", "penUM", "penum", "pngumeric", "PNumer", "pannum", "pennum", "penumeric", "pnUM", "panUM", "pnumeric", "pnnum", "pngnum"], "s": ["sis", "v", "hs", "gs", "js", "ms", "ses", "fs", "S", "serv", "sp", "source", "ns", "sam", "store", "ss", "b", "ts", "qs", "state", "sol", "spec", "t", "cs", "south", "less", "ats", "space", "sb", "p", "m", "g", "ds", "sl", "ls", "q", "os", "es", "a", "rs", "ess", "h", " ss", "sys", "conf", "ys", "service", "stats", "sts", "its", "als", "j", "c", "sn", "sq", "ps", "self"], "offset": ["limit", "data", "to", "output", "result", "zero", "ta", "length", "range", "usage", "sp", "ut", "f", "peer", "slot", "timeout", "esi", "block", "address", "attr", "OFF", "t", "len", "origin", "shift", "offer", "padding", "metadata", "ref", "o", "p", "seek", "pad", "buffer", "off", "style", "bound", "Offset", "window", "tile", "trace", "error", "size", "response", "fp", "location", "position", "point", "pointer", "row", "balance", "field", "layout", "start", "pos", "index", "et", "attribute", "entry", "port", "set"]}}
{"project": "qemu", "commit_id": "c5b9729ae918b890905e00870ffc08c9b56e6d17", "target": 0, "func": "void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_ulong page, end;\n\n\n\n    LOG_SWTLB(\"%s entry %d val \" TARGET_FMT_lx \"\\n\", __func__, (int)entry,\n\n              val);\n\n    entry &= 0x3F;\n\n    tlb = &env->tlb[entry].tlbe;\n\n    /* Invalidate previous TLB (if it's valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate old TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);\n\n    /* We cannot handle TLB size < TARGET_PAGE_SIZE.\n\n     * If this ever occurs, one should use the ppcemb target instead\n\n     * of the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n", "idx": 27007, "substitutes": {"entry": ["nt", "RY", "enter", "ient", "ries", "zero", "link", "ent", "print", "item", "query", "event", "or", "instance", "ident", "se", "address", "ry", "path", "ie", "cell", "comment", "key", "match", "ref", "p", "e", "line", "inter", "import", "q", "escape", "table", "window", "id", "element", "existent", "ENT", "value", "insert", "byte", "search", "def", "lo", "try", "cur", "point", "pointer", "pixel", "row", "record", "field", "start", "deep", "index", "x", "ptr", "Entry", "it"], "val": ["range", "ret", "tx", "VAL", "elt", "state", "al", "vt", "el", "ref", "mail", "p", "status", "line", "fail", "role", "vol", "value", "byte", "def", "pr", "ind", "db", "var", "Val", "doc", "sel", "dev", "inter", "crit", "check", "lo", "num", "col", "buf", "ptr", "prop", "ctx", "data", "vals", "pol", "local", "event", "ry", "try", "resp", "row", "index", "eval", "msg", "test", "v", "res", "rec", "serv", "valid", "pl", "mem", "slot", "item", "reg", "ival", "key", "update", "pt", "cho", "ev", "x", "it", "err", "bal"], "tlb": ["tblog", "ktlb", "temerb", " tbl", "attbh", "tmlb", "tslbs", "temlbs", "nlb", "ktzb", "ttbl", "netlb", "Tlr", "antkb", "tlp", "plp", " tdl", "ttlab", "tlam", "ylad", "tylbs", "tlad", "aretlab", "netlad", "temlp", "otlb", "itlp", " tlp", "stbl", "Tlb", "attlbs", "llb", "Tlam", "terblog", "antlbs", " terb", "tkb", "llbs", "fbl", "Tlad", "ktlbs", "atlp", "itlb", "flb", "tmbl", "stlbs", " tlad", "tyblog", "latdl", "aretsb", " tbh", " tkb", "ttlam", "wtlab", "wtlb", "tbh", "tslr", "ptlp", "ntbl", "tmlbs", "netlab", "lbl", " tzb", "tsomb", "tomb", "ttkb", "tlbs", "terlbs", "ptbl", "nlp", " tlbs", "llp", " tlamm", "timelbs", "otlab", "atbl", " tsb", " tlam", "stlp", "latlb", "netlbs", "attlp", "flp", "antzb", "tszb", "ttlb", "fsb", "terlab", "latlab", " tomb", "ptlb", "wtlp", "latlp", "temlb", "llab", "antlab", "itlab", " tblog", "tlab", "ttlp", "Tlab", "tslb", "antlb", "attlb", "ttben", "antlr", "Tben", "ylp", "wtbl", "Tlbs", "ttlbs", " tlr", "ntlbs", "ptlbs", "otlp", "ylab", "atlab", "attlad", "tmerb", "tsb", "timelamm", "tterb", "otlad", "latlr", "stlb", "ktomb", "flab", "plb", "ptlr", "ylbs", "aretlb", "antben", "tben", "tlamm", "wtlbs", "itlbs", "otbl", "atlbs", "plbs", "ntlp", "Tlp", "wtdl", "otlbs", "tzb", "aretlp", "tdl", "atlb", "timelb", "timelp", "tbl", "tlr", "antlam", "latlbs", "tylab", "tslp", "attzb", "ntlb", "pbl", "atlamm", "nlr", "terlb", "otlr", "antbh", "ylb", "terb", " tlab", "tylb"], "page": ["request", "url", "pc", "rec", "result", "max", "count", "me", "post", "server", "next", "sp", "node", "link", "net", "pl", "item", "go", "pages", "see", "message", "step", "pid", "pp", "address", "pg", "ip", "key", "update", "ref", "p", "m", "code", "e", "pt", "out", "g", "line", "number", "ew", "table", "window", "list", "phrase", "site", "size", "age", "counter", " PAGE", "pe", "point", "pointer", "fe", "row", "record", "PA", "start", "j", "c", "index", "ptr", "order", " Page", "Page", "ice", "port"], "end": ["limit", "dest", "max", "stop", "fin", "wall", "offset", "conn", "ended", "next", "ent", "pend", "wind", "END", " End", "append", "until", "len", "win", "send", "add", "p", "e", "eng", "en", "End", "ending", "id", "ender", "nd", "last", "size", "h", "close", "st", "num", "hend", "ue", "start", "ep", "index", "est", "order", "rest", "begin", "port", "length"]}}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n", "idx": 27021, "substitutes": {"private": [" pub", " self", "local", "primary", "priv", "protected", "Private", " data", "pid", "public", " unused", " shared", "secret", "base", "shared", "uri", " priv", "sys", "tmp", "inner", "password", "slave"], "global": [" fatal", " atomic", " Global", "final", " final", "local", "parent", " group", " last", " remote", " result", " generic", " shared", " unique", "Global", " local", " glob", " module", " size", " binary", " globally", " foreign", " g", " tf", " shadow", " transient", " gl", " scope"], "index": ["page", "weight", "filter", "level", "lock", "info", "block", "address", "key", "match", "oid", "version", "hash", "scan", "window", "id", "base", "flag", "position", "num", "row", "Index", "batch", "pos", "order", "ind", "port"], "mask": ["bits", "domain", "weight", "offset", "filter", "mode", "config", "Mask", "shape", "tag", "lock", "ask", "bit", "block", "address", "key", "match", "hash", "scan", "pack", "prefix", "flag", "map", "flags", "target", "module", "field", "set"], "entry": ["nt", "command", "parse", "RY", "member", "link", "ent", "term", "low", "job", "common", "item", "query", "event", "see", "instance", "cmd", "se", "info", "address", "ry", "cell", "this", "interface", "image", "comment", "key", "component", "match", "add", "e", "connection", "attribute", "line", "inter", "import", "view", "q", "escape", "list", "check", "existent", "element", "error", "delete", "search", "def", "try", "input", "row", "record", "word", "alias", "pair", "Entry", "ie", "inner", "set"], "msg": ["reason", "nt", "rem", "obj", "data", "md", "gs", "ms", "gr", "txt", "mem", " MSG", "go", "og", "message", "mn", "mk", "body", "med", "cmd", "pkg", "gp", "sent", "gm", "mp", "ge", "send", "mail", " m", "sim", "doc", "m", "comm", "str", "pub", "mess", " message", "g", "out", "list", "sg", "mt", "Msg", "mg", "resp", "tmp", "gz", "j", "cm", "err", "cfg", "mb"], "cnt": ["countcount", "count", "cund", "cct", "CNT", "ctnc", "ccount", " cNT", "COUNT", " cnc", "cpt", "uncnt", "cOUNT", "cnc", "countNT", "countOUNT", "uncNT", " count", "Count", "ctpt", "ucnt", "Ccount", "ucOUNT", " cnd", "cNT", "ctnt", "cnd", "countnt", "ctount", "Cnc", "cuNT", "Cpt", "ucNT", " cct", "cuct", "cunt", "Cnt", "uncct", " cpt", "uccount", "uncnd"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 27045, "substitutes": {"opaque": ["Opaques", "appque", "Opatile", "spaque", "spque", "popatile", "spaques", "ipacity", "popaque", "opaques", "popque", "opacity", "appatile", "spatile", "appacity", "Opque", "opatile", "ipaque", "popacity", "ipaques", "opque", "ipque", "appaque", "ipatile", "Opaque"], "sprn": ["polnm", "shrN", "prN", "srnn", "srnr", "sprnn", "polnc", "sprN", "prnc", " scrnr", "prnm", "sprnr", "polN", "poln", "sprne", "srne", "shrn", " scrne", "shrnm", "sprnm", "prn", " sprnn", "shrnc", "srn", " sprne", " scrn", " sprnr", "sprnc", " scrnn"], "ctx": [" cx", "ca", "cv", " temporarily", "obj", "urg", "conn", "gc", "co", "gr", "ij", "iat", "jp", "context", "tx", "cb", "loc", "alloc", "care", "pkg", "xc", "bc", " gorilla", " context", "ac", "req", "qa", "fx", "cc", "jac", "cf", "gas", "voc", "ct", "sc", "cur", "aos", "tmp", "tk", "batch", "c", "proc", "ptr", "j", "unc", "ctrl", "kw", "nc", "ind"]}}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046, "substitutes": {"s": ["sv", "sis", "gs", "ms", "ses", "changes", "services", "details", "store", "b", "p", "sd", "aws", "ls", "so", "rs", "sets", "as", "conf", "als", "i", "sports", "c", "y", "ps", "results", "set", "w", "er", "bis", "fs", "ns", "states", "ts", "se", "save", "ssl", "less", "sb", "ins", "d", "os", "es", "ies", "vs", "st", "stats", "sts", "sie", "hs", "is", "ss", "r", "spec", "cs", "ats", "http", "m", "comm", "ds", "summary", "l", "sys", "sq", "sm", "js", "S", "source", "serv", "qs", "t", "ims", "g", "sl", "sw", "sg", "h", "bs", "its", "asm", "self"], "sector_num": ["sector2n", "ector_mon", "sector_nm", "section_n", "ector_Num", " sector_n", "sector__mon", "ser_num", "sector1den", "sector_number", "sector___den", "sector1number", "ector2Num", "sector___num", "sector2num", " sector_nom", "ector_num", "sector__nm", "sector_n", "ector2number", "sector_den", "sector_nam", " sector_nm", "ser_den", "ector2num", "sector1num", "sector___number", "ser_number", " sector_nam", "sector2Num", "sector_nom", "ector2mon", "sector_mon", "section_number", "sector__n", "section_mon", "sector__num", "sector2number", "ector_number", " sector_mon", " sector_Num", "sector2mon", "section_num", "sector_Num"], "ret": ["nt", "v", "res", "result", "ter", "get", "ext", "ll", "rt", "f", "net", "rets", "tr", "r", "elt", "nat", " Ret", "ts", "usr", "t", "len", "ft", "gt", "status", "Ret", "out", "mt", "RET", "att", "nil", "try", "l", "cont", "sys", " RET", "alt", "re", "it", "set", "lit"], "n": ["ren", "nt", "v", "nr", "k", "nl", "dn", "on", "none", "na", "nu", "ns", "net", "ne", " N", "mn", "b", "nat", "z", "fn", "names", "nan", "new", "t", "len", "cn", "note", "m", "p", "en", "g", "out", "N", "d", "nw", "number", "u", "nb", "nd", "no", "gn", "ln", "l", "nn", "nm", "num", "np", "ng", "i", "j", "c", "sn", "nor", "y", "it", "rn", "nc", "un", "w"], "n1": ["gnPart", "n9", "gnONE", "nONE", "nanONE", "nons", "en1", "gnary", "sn9", "snary", "nOne", " n61", " N2", "gn61", "enPart", " n01", " N01", "sn1", "snpart", "nn2", "npart", " nOne", "sn61", "gnpart", "nan1", " n2", "n61", "n0", "nn61", "snOne", "nn01", " N1", " N61", "sn0", " n9", "ne1", "gnons", "ne0", "snons", " nPart", "nanpart", "neOne", "snONE", "ne9", "gn0", "n01", "n2", "nary", "en0", " n0", "en61", "nn1", " nons", "nan61", " nary", "gn1", "nPart"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n", "idx": 27048, "substitutes": {}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUState **lastp;\n\n          CPUState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          /* TODO: Free CPU state.  */\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n                target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* libc does special remapping of the return value of\n\n         * sys_getpriority() so it's just easiest to call\n\n         * sys_getpriority() directly rather than through libc. */\n\n        ret = get_errno(sys_getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            if (put_user_s64(ret, arg4))\n\n                goto efault;\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            if (put_user_s64(res, arg4))\n\n                goto efault;\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(abi_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(abi_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n                    pstrcpy(tde->d_name, tnamelen, de->d_name);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2\n\n                        && put_user_ual(deathsig, arg2))\n\n                        goto efault;\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2))\n\n                    goto efault;\n\n                orig_fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr (cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                if (arg1 == TARGET_SSI_IEEE_RAISE_EXCEPTION) {\n\n                    /* Old exceptions are not signaled.  */\n\n                    fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                    /* If any exceptions set by this call, and are unmasked,\n\n                       send a signal.  */\n\n                    /* ??? FIXME */\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how = arg1;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(arg1, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n\tif (cmd == -TARGET_EINVAL)\n\n\t\treturn cmd;\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n        {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n#endif\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 27056, "substitutes": {"cpu_env": ["cpu__window", "cpu___env", "cpueryenvironment", "pu_window", "cpueryenv", "cpu___era", "cpueryen", "pu_en", "cpu__env", "cpu_era", "cpu__priv", "pu_priv", "cpu___environment", "cpu__en", "cpu__environment", "cpu_conn", "cpu_den", "cpu_priv", "cpu_environment", "pu_den", "cpu_en", "cpu_window", "cpueryconn", "pu_era", "cpu__den", "pu_environment", "pu_conn", "cpu___en", "pu_env"], "num": ["n", "result", "zero", "final", "th", "na", "val", "nu", "valid", "f", "mn", "fn", "um", "sum", "new", "t", "nom", "note", "m", "NUM", "en", "off", "name", "number", "nb", "id", "no", "con", "unit", "nm", "conf", "np", "nam", "mon", "index", "x", "tim", "un", "Num", "ctx"], "arg1": ["doc1", " arg01", "doc0", "par3", "args2", "args3", "doc3", "param1", "param3", "argument1", "argument4", "argument0", "args4", "param0", "arg0", "param01", "doc01", "argument2", "arg01", "par2", "args1", "args0", "argument3", "par0", "par1", " arg0"], "arg2": ["Arg5", "args2", "tag02", "tag4", "tag5", "tag1", "arg02", "Arg02", "args3", " arg02", "args4", "tag3", "tag2", "argument2", "args5", "args1", "argument5", "argument3", "Arg2", "argument1", "Arg3", "args02"], "arg3": ["doc1", "Arg5", "arg03", "Arg4", "date03", "args2", "doc5", "val3", "val1", "args3", "doc3", "Arg03", "argument03", "argument4", "date4", "args4", "date5", "val2", "Arg1", " arg03", "doc03", "doc2", "args5", "args1", "argument5", "val5", "argument3", "Arg2", "date3", "argument1", "Arg3"], "arg4": ["longfour", "agg44", " arg44", "args3", "agg6", "args44", "arg44", "prop434", "args4", "propfour", " arg434", "arg434", "args6", "agg4", " argfour", "long434", "argfour", "agg3", "long3", "prop4", "long4", "prop3"], "arg5": ["level5", "doc55", "ag05", "tag5", "doc5", "arg25", "level45", "level55", " arg05", "arg55", "argument05", "tag55", "ag5", "ag25", "argument4", "ag4", "doc05", "doc45", "level05", "tag45", "arg05", "argument5", "argument25", "tag05", "arg45", " arg25"], "arg6": ["doc8", " arg16", "ig9", "doc7", "ig7", "Arg8", "doc6", "Arg9", "arg9", "flag2", "Arg7", "Arg6", "arg8", "arg7", "argument8", "ig8", "flag16", "flag8", "argument2", "argument6", "ig6", "argument16", " arg8", "flag6", "doc9", "arg16"], "ret": ["nt", "nl", "result", "nz", "gc", "ter", "offset", "red", "ext", "jp", "val", "print", "net", "rt", "f", "reply", "mem", "tr", "reset", "r", "z", "read", " Ret", "class", "pas", "ry", "Return", "len", "xt", "t", "arr", "fun", "ref", "ft", "str", "gt", "Ret", "out", "name", "g", "arg", "mt", "no", "RET", "flag", "def", "try", "resp", "back", "alt", "re", "j", "success", "err", "mb"], "st": ["nt", "ST", "ist", "St", "sp", "ut", "store", "ss", "se", "std", "sty", "stack", "ft", "str", "ct", "sw", "mt", "sc", "ld", "sts", "ost", "est", "rest", "ste", "ust"], "stfs": [" stfc", " stf", "STfc", "stps", "stfc", "stackfc", "STfs", " stps", "STps", "STf", "stackps", "stackf", "stackfs", "stf"], "p": ["ap", "pc", "n", "tp", "vp", "pre", "bp", "pa", "wp", "page", "post", "lp", "sp", "jp", "f", "pro", "pl", "op", "r", "b", "pers", "pn", "pid", "pp", "pkg", "pg", "patch", "t", "ip", "mp", "pat", "pod", "o", "m", "par", "ping", "pt", "g", "P", "pd", "per", "d", "cp", "rep", "pi", "part", "fp", "perm", "h", "l", "pe", "point", "np", "pm", "y", "pb", "c", "proc", "pr", "j", "php", "it", "ps", "port", "w"], "ts": ["vals", "ports", "hs", "tp", "ks", "gs", "js", "ms", "TS", "ots", "ols", "tt", "ns", "tn", "tr", "tx", "ss", "ets", "ps", "qs", "ops", "pas", "ics", "t", "cs", "pins", "ats", "tm", "times", "ims", "Ts", "ins", "pt", "tz", "ds", "ls", "wcs", "mt", "tes", "lt", "rs", "wt", "vs", "aps", "ys", "stats", "tc", "sts", "als", "its", "bs", "GS", "tips", "tl", "tis"], "lastp": ["basec", "oldP", " lastcp", "lastm", " lastc", "defaultpa", "lastc", " lastr", " lastwp", "firstP", "basepa", " lastpa", "nextp", "firstps", "lastwp", "firstr", "defaultp", "Lastm", "basecp", "Lastpa", " lastm", "firstpid", "lastcp", "firstpa", "defaultm", "firstp", "nextr", " lastP", "basep", "defaultP", "lastr", "lastpid", "nextpid", "nextP", "LastP", " lastps", "lastps", "lastpa", "oldwp", "firstcp", "firstc", " lastpid", "oldps", "Lastp", "lastP", "firstwp", "oldp"]}}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058, "substitutes": {"sys_type_name": ["sys_name_str", "sys_name_name", "sys_type_info", "sys_name2str", "sys_name2code", "sys_type2info", "sys_type_str", "sys_type2name", "sys_type2code", "sys_type_code", "sys_name_code", "sys_name2info", "sys_name_info", "sys_name2name", "sys_type2str"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)\n\n{\n\n    int i;\n\n    INIT_CLIP\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride /= sizeof(pixel);\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n}\n", "idx": 27081, "substitutes": {"_dst": [" _dST", "devtsrc", "_dsost", "_tpt", "devdpt", "_sst", "_dsST", "_dsrc", "_tst", "_ssrc", "_doest", "_dsest", "_Dest", "_dest", "_doST", "_doost", "_tsrc", "_tist", "_Dpt", "devtst", "_dpt", "_sist", "_DST", "_dist", "devtist", " _Dest", " _Dost", "_Dist", "devtpt", "_spt", "_dsst", " _DST", " _Dst", " _dost", "devdst", "_dost", " _dest", "_Dost", "devdsrc", "_Dsrc", "_Dst", "devdist", "_dST"], "_block": [" _type", "__lock", "_lock", "_box", "__bl", " _bl", "__box", "_bl", "__type", " _box", "__block", "_type", " _lock"], "stride": ["relice", "relIDE", "stome", "strride", "privipe", "stider", "strope", "stise", "volade", "STRitud", "styleide", " strIDE", " strided", "STRided", "strerve", "STRome", "volider", "privine", "STRide", "Strope", "Stride", "privide", "volise", "priverve", "strine", "strided", "volide", "slerve", "strice", "styleride", "stipe", "relide", "stade", "volride", "stritud", "STRider", "suspine", "styleIDE", "stIDE", "STRride", "privride", "styleade", "voline", " strade", "STRine", "Strine", "spide", "STRIDE", "STRope", " strine", "stine", "stide", "strise", "stice", " strope", "stripe", " strride", "STRice", "strade", "slice", "spade", "relride", "suspitud", "slipe", "suspride", "spise", "suspide", "STRipe", "slide", "spider", "slome", "stitud", "slride", "STRade", "Strided", "strider", "strome", "STRerve", "strIDE"], "i": ["qi", " I", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "p", "e", "status", "ite", "depth", "id", "io", "series", "zi", "y", "ish", "bi", "ind", "I", "er", "il", " li", "ci", " multi", "di", "upper", "version", "iii", "u", "pi", " mi", "iu", "fi", " ti", "phi", "init", "ir", " j", "is", "iq", "me", "ij", "print", "f", "ini", "gi", "hi", "this", " bi", "cli", "ri", "ic", "sim", "m", "multi", " ii", " si", "\u0438", "im", "dr", "try", " pi", " index", "ia", "j", "index", "si", "iri", "v", "in", "li", " ni", "ai", "item", "ji", "go", "ki", "info", "mi", " m", "ims", "g", "name", "q", "list", "uri", "point", "err", "ti", "batch", "x", "it", "ui", "port"], "dst": ["dsts", "dddest", "adst", " dest", "duist", "redst", " dsts", "Dpret", "deadstart", "tct", "deadbt", "deadst", " ddest", "Dgest", " dct", " dist", "ddost", "Dstart", "donestart", "dest", "duest", "dstart", "debugstart", "deadstore", "deadost", "redist", "sdost", "dust", "dgest", "dbsp", "adbsp", "sdst", "Dist", "redsts", "Dbt", "debugst", "adpret", "sdstore", "tst", "Dct", "redgest", "dbt", "adstart", "donepret", "tdest", "ldgest", "debugpret", " dgest", "ddst", "Dsts", "Dst", "ddstart", "test", "dstore", "Dstore", "dost", "dusts", "donebsp", "dct", "ddest", "sdpret", "ldist", "Dest", "dist", "deadpret", "dpret", "donest", "ddgest", "Dost", "redest", "debugbsp", "ldst", "Ddest", "ddbt"], "block": ["BL", "method", "zero", "profile", "link", "file", "join", "lock", "loc", "bit", "box", "image", "ip", "hash", "p", "line", "window", "byte", "def", "record", "map", "type", "set", "k", "control", "filter", "client", "plugin", "load", "blocking", "lib", "total", "version", "pack", "check", "base", "bus", "part", "model", "open", "module", "field", "object", "library", "all", "data", "wall", "local", "group", "event", "layer", "spec", "new", "bl", "zone", "chain", "buffer", "out", "view", "sync", "Block", "pixel", "unit", "row", "condition", "proc", "network", "cache", "cl", "user", "loop", "frame", "disk", "mask", "config", "mem", "blocks", "bin", "other", "number", "list", "bo", "no", "snap", "rule", "point", "use", "piece", "label", "word"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 27083, "substitutes": {"s": ["sv", "v", "n", "is", "gs", "js", "ms", "ses", "ctx", "S", "ns", "ss", "b", "r", "ts", "t", "cs", "ats", "sb", "ins", "p", "e", "m", "g", "ds", "os", "es", "sg", "rs", "sc", "h", "sys", "sts", "its", "i", "j", "c", "ps", "self", "sm", "w"], "insn": ["ainssn", "pinsns", "timessn", "stsnin", "pinsn", "kinsn", "rsn", "pinssn", "alsns", "insns", "timesn", "stsgn", "stssn", "istssn", "insoln", "rssn", "timesne", " insgn", "inspn", "timespn", "istsns", "retssn", "outssn", " pinsns", "outsns", "retsnin", "pssn", "pspn", "ainson", "linssn", "retsns", "yspn", "insne", "stsn", "outsn", " pinsn", "kinson", "psn", "alssn", "linsgn", "rsgn", "inssn", "alsn", "alsgn", "stsns", "outsgn", "rsns", "pson", "linsn", " insns", "rsnin", "outne", "ysne", "ainspn", "ainsns", "ainsn", "outpn", "insgn", " pinssn", "ainsoln", "yssn", "inson", "istsn", "outn", " inssn", "kinspn", "kinssn", " pinsoln", "retsn", "istsgn", " insoln", "insnin", "ysn", "pinsgn"], "mos": ["tor", " mus", "ros", "mid", "ms", "rans", "mot", " nos", "mph", "mic", "dos", "asis", "doi", "mn", "mc", "mol", "OS", "mx", "mis", "mi", "las", " Mos", "osi", "mm", "los", "phis", "ls", "Mos", "mr", "os", "px", "mt", "rs", "osa", "mes", "sys", "bs", "mo", "mon", "omo", "mus", "mys", "oses", "mas", "mor"], "type": ["_", "tp", "co", "tool", "ty", "day", "Type", "typ", "file", "kind", "ype", "change", "tag", "otype", "r", "phy", "ime", "state", "info", "cmd", "spec", "dt", "t", "ico", "ror", "key", "where", "ox", "o", "p", "time", "m", "ping", "name", "py", "like", "mt", "role", "error", "con", "TYPE", "pe", "types", "form", "col", "stat", " typ", "y", "test", "ver"], "rm": ["rem", "res", "irm", "rom", "typ", "raf", "rr", "ram", "rt", "mem", "rl", "ru", "mn", "r", "reg", "arm", "rb", "RM", "cmd", "ror", "rf", "ref", "remote", "m", "rx", "mr", "nb", "mt", "lr", "rs", "bm", "orm", "rob", "rpm", "rc", "nm", "mo", "drm", "re", "ro"], "cond": ["ond", "Cond", "cmp", "n", "res", "control", "CON", "co", "red", "none", "cons", "cd", "comp", "then", "tx", "lock", "mod", "loc", "cb", "reg", "bool", "cmd", "xc", "func", "bc", "act", "fun", "cod", "ref", "p", "bind", "code", "fl", "cc", "cf", "ct", "cp", "check", "pred", "rob", "con", "def", "rc", "close", "cont", "conf", "resp", "condition", "col", "pr", "pos", "cut", "when", "test", "ind", "ctx"], "rn": ["nr", "rem", "n", "cmp", "nl", "dn", "unn", "ibr", "rom", "loc", "rr", "rt", "RN", "arn", "rl", "norm", "mn", "r", "pn", "arm", "rb", "cb", "rin", "cmd", "fn", "RM", "rf", "cn", "rx", "oren", "rar", "cp", "mr", "nb", "bn", "lr", "ln", "rob", "rpm", "rc", "nm", "nn", "inc", "roc", "ptr", "ro", "nc"], "op": ["cmp", "false", "oop", "co", "oc", "rop", "ot", "opt", "ort", "typ", "jp", "pop", "comp", "it", "ob", "opp", "Op", "loc", "cop", "bit", "oss", "cmd", "ops", "attr", "at", "hop", "ox", "ip", "rot", "ok", "ac", "o", "p", "operator", "cp", "oper", "pred", "OP", "rob", "ep", "pr", "pos", "prop", "ver"], "nzcv": ["zzcv", "gzcv", "gzCV", "nzvc", "zzfc", "rssnv", "Nazuv", "zfc", "rssuv", "zznv", "rssvc", "nzCV", "zzCV", "tzcv", "gznv", "Naznv", "znv", "nzvr", "nznv", "tzCV", "tzfc", "gzuv", "Nazcv", "rsscv", "zCV", "tzvr", "nzuv", "deepcv", "zzvr", "deepnv", "zzuv", "zcv", "zuv", "zvr", "deepuv", "Nazvc", "nzfc", "deepCV", "zzvc"], "tcg_flags": ["tcgi_options", "tcg_actions", "tcg_bits", "tcg__options", "tcg_bugs", "tcv_mask", "tcg__mask", "tcg8mask", "tcg8fs", "tcv_fs", "tcgi_bits", "tcgi_flag", "tcv_bugs", "tcgi_args", "tcg__bugs", "tcgc_flags", "tcg8bugs", "tcg_mask", "tcg__flag", "tcg_options", "tcg_args", "tcv_flags", "tcg_flag", "tcg__bits", "tcgc_bits", "tcg___flags", "tcg__fs", "tcg__args", "tcg_fs", "tcg___bits", "tcgc_actions", "tcg___actions", "tcgi_flags", "tcg__flags", "tcg8flags"]}}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n", "idx": 27088, "substitutes": {"bit": ["limit", "top", "bits", "bug", "git", "hit", "slot", "tag", "lock", "b", "pin", "block", "t", "ip", "bin", "ac", "rot", "status", "g", "out", "Bit", "bot", "ct", "ong", "BIT", "id", "base", "bo", "lt", "flag", "byte", "task", "lat", "word", "type", "field", "mon", "col", "i", "x", "it", "bt", "bi", "port", "lit"], "map": ["safe", "cache", "ap", "Map", "maps", "link", "mask", "node", "mem", "shape", "MAP", "load", "store", "lock", "dict", "block", "tree", "allow", "image", "mp", "hash", "m", "code", "buffer", "pack", "view", "late", "list", "table", "window", "app", "share", "age", "mg", "use", "cap", "module", "batch", "index", "msg", "set", "mb"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100, "substitutes": {"ctx": ["nt", "ca", "cv", "pc", "cmp", "work", "obj", "cl", "conn", "gc", "co", "anc", "history", "txt", "jp", "aux", "xp", "kl", "wx", "that", "context", "kj", "tx", "wd", "cb", "mk", "mc", "kt", "cmd", "pool", "pkg", "xc", "bc", "act", "ctl", "ok", "req", "tm", "p", "hw", "comm", "cc", "cf", "tz", "jac", "ct", "cp", "wcs", "crit", "ck", "window", "mt", "sc", "cur", "resp", "ctr", "np", "tmp", "sys", "tc", "addr", "Context", "xs", "dl", "c", "cm", "today", "ctrl", "kw", "nc", "cfg"], "blocking": ["broad", "being", "enabled", "cl", "joining", "using", "sharing", "learning", "fully", "checked", "quiet", "speaking", "timeout", "optional", "policy", "lock", "full", "starting", "bool", "checking", "block", "including", "available", "majority", "blocks", "ssl", "ocking", "friendly", "status", "exclusive", "locked", "always", "advertising", "leasing", "excluding", "latest", "running", "restricted", "loading", "locking", "confirmed", "limited", "forcing", "poll", "partial"]}}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107, "substitutes": {"id": ["and", "url", "kid", "mid", "db", "aid", "ide", "Id", "link", " fid", "f", "hid", "tag", "event", "rid", "ident", "pid", "info", "uid", "t", "ref", "oid", "hash", "p", "time", "code", "name", "d", "q", "vid", "ad", " ID", "ids", "ID", "type", "c", " tid"], "response": ["init", "data", "xml", "request", "v", "output", "ve", "res", "question", "result", "page", "server", "next", "json", "answer", "valid", "config", "volume", "parent", "reply", "query", "message", "example", "description", "reset", "detail", "block", "tree", "image", "sequence", "vector", "relative", "relation", "onse", "version", "doc", "hash", "translation", "connection", "api", "line", "definition", "view", "q", "os", "list", "window", "array", "reference", "yes", "es", "memory", "search", "def", "position", "resp", "now", "service", "Response", "document", "object", "pos", "success", "entry", "all"], "ret": ["nt", "v", "rem", "res", "result", "ert", "ter", "val", "ll", "rt", "f", "rets", "tr", "det", "r", "elt", "cert", "reset", "read", "at", "t", "xt", "cat", "ref", "ft", "gt", "pt", "Ret", "out", "en", "inter", "rm", "pret", "rat", "mt", "RET", "lt", "flag", "att", "def", "des", "cont", "re", "alt", "j", "et", "pet", "it", "lit"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129, "substitutes": {"env": ["v", "conn", "node", "viron", "context", "tx", "cb", "vt", "ec", "e", "eng", "en", "environment", "dev", "nv", "window", "ev", "gn", "vs", "conf", "map", "buf", "proc", "et", "kw", "cfg"], "ctx": ["obj", "conn", "exec", "ksh", "txt", "jp", "aux", "tx", "cb", "loc", "kt", "cmd", "pkg", "xc", "ctl", "tm", "hw", "wcs", "window", "sc", "conf", "np", "except", "tk", "c", "nc", "ind", "ann", "nt", "gc", "history", "ci", "act", "dc", "cu", "ct", "cp", "handle", "cm", "qt", "ctrl", "kw", "cfg", "init", "ca", "cv", "xp", "wx", "context", "this", "conv", "cf", "ck", "rc", "resp", "Context", "sys", "index", "msg", "cmp", "js", "cas", "config", "bc", "setup", "req", "mom", "cc", "jac", "cpu", "tc", "xs", "asm"], "op2": [" op3", "op4", "ops256", "opTwo", "ops02", "oop2", "cop4", "oop1", " op256", "ops4", "op3", "opcome", "ops2", "copTwo", "rop2", " op02", "OPTwo", "OP32", "op02", "cop2", "OP02", "ops3", "Op2", "op256", "oper02", "OP4", "OP2", "rop32", "op1", "op32", "oper4", "rop4", "oopcome", "cop32", "OPcome", "OP1", "OP3", "Opcome", "ropTwo", "Op1", "oper2", " op4", "oper256"], "r1": ["r2", " r61", " r2", "l0", "cr61", "R0", "r0", "R1", "cr2", " r0", "r61", "l61", "l2", "cr1", "R2"], "l1": ["r2", "l0", " l4", "slasso", "el1", " l0", "L0", "sl0", "r0", "sl4", "L1", "el2", "r4", "l4", "rasso", "el0", " lasso", " l2", "lasso", "l2", "sl1", "L2"], "tmp": ["obj", "emp", "txt", "sam", "uv", "aux", "src", "buff", "cmd", "pkg", "gb", "vt", "yy", "tm", "p", "perm", "np", "qq", "term", "ind", "nt", "tif", "result", "aaa", "td", "appy", "var", "html", "tab", "cp", "base", "buf", "data", "top", "cv", "tt", "wx", "mk", "attr", "new", "this", "pty", "out", "py", "front", "cur", "img", "resp", "orig", "proc", "empty", "msg", "etc", "temp", "test", "v", "cache", "MP", "cmp", "stuff", "sp", "mint", "tg", "gm", "tem", "t", "mp", "up", "snap", "tc", "tar", "angle", "err"]}}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148, "substitutes": {"dev": ["Device", "data", "nt", "v", "ve", "gu", "obj", "md", "res", "usb", "dd", "conn", "db", "cam", "DEV", "devices", "disk", "val", "priv", "mem", "tech", "det", "var", "di", "block", "iv", "serial", "dem", "sh", "kh", "p", "sd", "hw", "pad", "cho", "device", "out", "Dev", "d", "ach", "pi", "ev", "ad", "develop", "adv", "od", "def", "des", "de", " device", "av", "cand", "ptr", " Dev", "ver", "w"], "qs": ["ips", "vals", "hs", "ues", "qus", "iq", "gs", "ks", "ms", "ksh", "fs", "uds", "reads", "ns", "details", "qu", "query", "ts", "dq", "gm", " queries", "cs", "ires", "gets", "ats", "ims", "ins", "irs", "qa", "aws", "ds", "ls", "ows", "q", "cks", "rs", "vs", "eks", "ques", "ys", "qq", "sts", "bs", "als", "fts", "sq", "qt", "ps", "ctx"], "arch": ["ir", "iph", "installed", "exec", "alph", "mot", "ext", "ar", "platform", "var", "reg", "arm", "bit", "cmd", "pp", "ag", "alg", "act", "art", "auth", "mac", "eh", "arr", "och", "ec", "Arch", "comm", "str", "eng", "ach", "os", "imp", "archs", "ev", "ARCH", "app", "old", "cpu", "arc", "h", "img", "rc", "ra", "brand", "form", "proc", "ver", "ch", "prot"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static unsigned long iv_decode_frame(Indeo3DecodeContext *s, \n                                     unsigned char *buf, int buf_size) \n{\n  unsigned int hdr_width, hdr_height,\n    chroma_width, chroma_height;\n  unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;\n  unsigned char *hdr_pos, *buf_pos;\n  buf_pos = buf;\n  buf_pos += 18;\n  fflags1 = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  fflags3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  fflags2 = *buf_pos++;\n  buf_pos += 3;\n  hdr_height = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  hdr_width = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;\n  chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;\n  offs1 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs2 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 8;\n  hdr_pos = buf_pos;\n  if(fflags3 == 0x80) return 4;\n  if(fflags1 & 0x200) {\n    s->cur_frame = s->iv_frame + 1;\n    s->ref_frame = s->iv_frame;\n  } else {\n    s->cur_frame = s->iv_frame;\n    s->ref_frame = s->iv_frame + 1;\n  }\n  buf_pos = buf + 16 + offs1;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width, \n    hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(hdr_width, 160));\n  if (!(s->avctx->flags & CODEC_FLAG_GRAY))\n  {\n  buf_pos = buf + 16 + offs2;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  buf_pos = buf + 16 + offs3;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  }\n  return 8;\n}", "idx": 27151, "substitutes": {"s": ["sv", "v", "ex", "ports", "n", "is", "hs", "sis", "gs", "js", "ms", "ses", "changes", "bis", "eps", "S", "ns", "details", "ss", "b", "ts", "qs", "ops", "spec", "se", "t", "cs", "https", "south", "less", "comments", "sb", "ins", "ims", "p", "e", "comm", "aws", "ds", "ls", "os", "es", "sg", "rs", "h", "l", "sys", "conf", "stats", "sts", "y", "bs", "its", "als", "c", "x", "sn", "sq", "ps", "set"], "buf": ["data", "cv", "text", "bp", "db", "bar", "next", "ctx", "src", "end", "mem", "seq", "buff", "cb", "b", "vec", "rb", "loc", "cmd", "block", "bytes", "uf", "bin", "ref", "sb", "p", "str", "buffer", "off", "queue", "paste", "Buffer", "cur", "img", "Buff", "ctr", "br", "tmp", "cap", "wb", "pb", "batch", "pos", "msg", "orig", "ff", "begin", "err", "xff", "raw"], "buf_size": ["buf_ize", " buf_len", " buf_ize", "buf_len"], "hdr_width": ["hdr10body", "hDR_length", "holderptwidth", "hdr_position", "holder_width", "hdr_length", "hdr10width", "hDR_content", "hDR_weight", "hdr___mag", "hr_width", "hdr_body", "hdr_weight", "holderptmag", "holderptposition", "hdr___position", "hDR_width", "holder_position", "holder_body", "hdr_size", "hdr___body", "hdr_content", "hdrptbody", "hdr_mag", "hr_size", "hdr10position", "hr_len", "holder_mag", "hdr___width", "hdr10mag", "hdrptwidth", "holderptbody", "hdrptmag", "hdrptposition", "hdr_len", "hr_length"], "hdr_height": ["hdr1height", "hdr5power", "hdr5width", "hdr5depth", "hdr1padding", "hdr2depth", "hdr2width", "hdr1width", "hDR_width", "hdr2height", "hdr_power", "hdr_size", "hDR_arch", "hdr_arch", "hDR_padding", "hdr_depth", "hdr_padding", "hDR_depth", "hDR_power", "hDR_size", "hDR_height", "hdr5height", "hdr1depth", "hdr2power"], "chroma_width": ["chroma_weight", "chromA_width", "chromA_size", "chroma_size", "chromA_weight", "chroma2weight", "chroma2size", "chroma_length", "chroma2width", "chromia_width", "chroma_widget", "chromia_widget", "chromia_length", "chromia_height"], "chroma_height": ["chromao____height", "chromao_length", "chroma_history", "chromao_read", "chroma_size", "chroma____length", "chromao_html", "chromao____length", "chroma_length", "chroma____height", "chromo_length", "chromao____html", "chroma_html", "chromao____read", "chromao_height", "chromo_history", "chroma_read", "chromo_size", "chromo_height", "chroma____read", "chroma____html"], "fflags1": ["ffvlags01", "ffolags01", "fflaps01", "ffolags1", "fflugs1", "fflag01", "fflages2", "ffvlages01", "fflugs2", "fflag1", "fflages0", "fflages01", "ffolags6", "ffvlags2", "fflages1", "ffolag6", "ffvlugs7", "ffolags2", "fflags7", "fflags6", "ffolag01", "fflag6", "fflugs7", "ffligs7", "ffligs2", "fflags01", "ffvlages1", "fflages6", "ffvlugs1", "fflag2", "ffolag2", "ffvlagesOne", "fflaps7", "ffolag1", "ffligs0", "ffvlags7", "ffvlags0", "fflags0", "ffligsOne", "fflaps1", "fflagsOne", "fflaps2", "ffvlugs2", "fflaps6", "ffvlags1", "fflagesOne", "ffligs01", "ffligs1", "ffvlages0", "fflagOne", "fflag0", "ffvlagsOne"], "fflags2": ["ffflags2", "fflats1", "fflumps32", "fflugs12", "ffflatts2", "fflages2", "fflides2", "ffslags3", "fflugs2", "fflides1", "fflats4", "fflugs32", "fflags12", "fflages3", "ffslags2", "fflatts1", "fflages12", "fflumps2", "fflages32", "ffslages3", "fflats2", "fflugs3", "ffslages2", "ffflatts1", "ffflags01", "fflats01", "fflags32", "fflumps12", "fflags4", "fflatts2", "ffslags32", "ffflatts01", "ffflags4", "fflags01", "fflides4", "ffflags1", "ffslags12", "ffslages32", "fflatts4", "fflatts01", "fflumps3", "ffslages12", "ffflatts4", "fflides01"], "fflags3": ["fflages8", "ffklags21", "fflges3", "ffklags8", "fflugs0", "fflatsThree", "ffllags2", "fflinks3", "ffslags3", "ffklags0", "fflages0", "ffklages3", "fflages21", "fflacks2", "fflag23", "fflages3", "fflacks3", "fflags23", "ffslags2", "fflags21", "fflats2", "fflugs3", "fflag4", "fflinks23", "ffslags4", "fflacks4", "ffklages0", "ffslacks3", "fflinks4", "fflges8", "fflats3", "fflags4", "ffslacks2", "fflag3", "ffllag2", "ffllag3", "ffslacks23", "fflaps3", "ffslags23", "fflges21", "fflugs8", "fflag2", "fflagsThree", "ffklags3", "ffklages21", "ffklages8", "ffllagThree", "fflags0", "fflags8", "fflinks2", "ffllags3", "fflacks23", "fflaps2", "fflugs21", "ffslacks4", "fflapsThree", "fflges0", "fflagThree", "ffllagsThree"], "offs1": ["topsone", "hands0", "pieces001", "piecesOne", "timesOne", "times1", "offs0", "outs2", "pieces1", "times001", "vals1", "vals001", "offsOne", "pointersOne", "offsone", "tops1", "hands1", "outs1", "vals2", "outs0", "hands2", "valsone", "tops001", "vals0", "outsone", "pointers001", "outs001", "pointers1", "offs001", "tops2"], "offs2": ["uts02", "ops02", "ops1", "uts2", "outs2", "pointers12", "ops12", "ops2", "odsTwo", "outsTwo", "pointers2", "offs12", "pointers02", "outs02", "outs1", "uts1", "pointersTwo", "ods2", "ods12", "opsTwo", "utsTwo", "offs02", "ods02", "offsTwo"], "offs3": ["stocks15", "uts2", "tops3", "outs2", "outsThree", "uts5", "stocksthree", "stocks3", "tops1", "utsthree", "stocks5", "outs1", "uts1", "odsthree", "ods3", "uts3", "offsThree", "topsThree", "outs3", "ods15", "offsthree", "utsThree", "uts15", "ods5", "offs15", "offs5", "tops2"], "offs": ["vals", "utters", "pieces", "pointers", "actions", "cuts", "amps", "ts", "uts", "ops", "pres", "orders", "blocks", "stones", "styles", "limits", "hands", "bps", "ims", "boxes", " offsets", "outs", "off", "tops", "ups", "assets", "heads", "locks", "nes", "helps", "keys", "sets", "aps", "ints", "cells", "bs", "uns", "tips", "nos", "finals", "caps"], "hdr_pos": ["hdr2val", "hbr_pos", "hdr_position", "hbr_position", "hDR_loc", "hdr_mon", "hdr_val", "hbr_po", "hdr_po", "hdr_loc", "hbr_mon", "hdr2pos", "hdr2loc", "hDR_val", "hdr2position", "hDR_pos", "hDR_position"], "buf_pos": ["buf64pose", "bufencache", "buf2p", "buffer_position", "buf___neg", "cache_pid", "buf_cos", "buf_prop", "buf12pos", "poolptos", "buf2po", "queue_pos", "buf__mon", "buf_top", "bufmmcos", "bufenpos", " buf_top", "buf0neg", "buf64cache", "buftxcos", "cbtpost", "buftpost", "buf___loc", "buf___pos", "buftxpo", "buf12sum", "buf_pose", "uf2pos", "buf5ps", "buf_os", "bufptpos", "buf12po", "uf2po", "buf_pro", "uf_os", "bufldpointer", " buf_sum", "buf_cache", "bufmmpid", "uf_Pos", "bufenpose", "bufgrloc", "buf__pos", "buf__po", "buf__position", "uf2os", "buf2cos", "block_pid", "cache___pos", "buffer_pos", "bufxposition", "bufmmpos", "buf0pos", "bufmmpres", "bufptos", "cache_cos", "bufldpos", "buftxpost", "uf2mon", "batch_pos", "bufxpos", "cache_pres", "buftxpos", "batch_len", "buf_len", "bufgrpointer", "bufptpost", "buf_p", "bufgrpo", "cache_pos", "uf_pose", "buf_post", "queue_loc", "uf_loc", "bufldtop", " buf_ps", "buf__p", "buf_pointer", "bufgrpath", "uf_po", "buf_sum", "cb_pos", "queue_path", "uf_prop", "pool_post", "buf___p", "uf_position", "pool_os", "buf5prop", "buf2mon", "buf___position", "buffer_po", "buf64po", "uf_neg", "cache___pres", "buf__neg", "cb_po", " buf_p", "buf___len", " buf_pro", "buf2pid", "uf_p", "uf_pid", "block_pos", "buf_pres", "buf12pointer", "buf2os", "buf___pid", "buf5po", "buffer_len", "block_position", "uf_pos", "buf0pid", " buf_pointer", "uf_cache", " buf_pose", "uf_ps", "batch_position", " buf_po", "buf__pid", "bufxgo", "bufgrpos", "queue_neg", "buf_Pos", "bufenpo", "buf_loc", "buftpo", "buf___pres", "buf__os", "batch_go", "cache___pid", "uf_mon", "buf_po", "buf___cos", "buf_mon", "buf2pres", "buf2pos", "cb_post", "cbtpo", "buftcos", "buf_go", "buf2len", "buf_position", "cache___cos", "buf0po", "buf___po", "batch__len", "buftpointer", "buf_ps", "queue_pres", "buf_neg", "batch_po", "batch__pos", "buf64pos", "bufgrpres", "queue_p", "cb_cos", "buf_pid", "cbtcos", "buftpos", "buf__loc", "batch__position", "bufgrsum", "poolptpos", "cbtpos", "buf_path", "buf__len", "poolptpost", "buf2loc", "batch__po", "block_po", "pool_pos", "bufttop", "buf2position", "buf5pos"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 27169, "substitutes": {"env": ["sv", "er", "v", "ve", "her", "vp", "tp", "cv", "conn", "ten", "db", "ter", "server", "actor", "uv", "Environment", "viron", "net", "config", "tx", "vm", "policy", "manager", "ner", "cmd", "gate", "setup", "act", "vt", "eh", "ec", "erd", "e", "hw", "eng", "en", "environment", "dev", "ah", "eas", "sw", "org", "nv", "te", "ew", "window", "ev", "esc", "here", "worker", "gov", "h", "vs", "pe", "era", "conf", "addr", "buf", "inv", "msg", "exc", "entry", "network", "enc"], "tb": ["ptB", " tbl", "pbr", "nbf", "tsb", "ptb", "tsbf", " tfb", " tv", "tsbl", "tfb", "ptv", "ttb", "prb", "tB", "tsbr", "ttbl", "ttfb", "trb", "tv", "nbr", "pB", "tbl", "ptbr", "ptbf", "ptrb", " tB", "portb", "ptbl", "portfb", "nb", "nbl", " trb", "tsv", "tbe", "ptbe", "portbl", "tsbe", "tbf", "pb", " tbe", " tbr", "tbr"], "search_pc": ["search_pb", "search__PC", "search__pc", " search_pb", "Search_fc", "search_PC", " search_proc", "search_fc", "search__pr", "search__fc", " search_PC", "searchingproc", "searchingPC", "searchingpb", "search_pr", "Search_PC", "search_proc", "searchingpc", "Search_pc", "Search_pr"], "ctx": ["acl", "obj", "nz", "conn", "txt", "jp", "aux", "that", "tx", "cb", "loc", "instance", "kt", "cmd", "pkg", "xc", "func", " context", "ctl", "ref", "hw", "tz", "here", "sc", "def", "conf", "np", "tk", "tnc", "set", " cx", "nt", " cm", " mc", "gc", "ns", "wd", "lc", "fc", "std", "cond", "act", "cu", "dc", "tab", " cmd", "ct", "cp", " cpu", "crit", "yes", "HK", "addr", "module", "cm", "ptr", "ctrl", "kw", " cp", "cfg", "ca", "cv", "wx", "context", "city", "mk", "fn", "kk", "fw", " sc", "cf", " tx", "ck", "rc", "ctr", "resp", "xy", "tmp", "index", "msg", "etc", " tcp", "cmp", " c", "co", " gp", " kb", " tc", "info", "req", "gt", "qa", "cc", "jac", "ka", "tc", "xs", "scope", "x", "utils", " cc"], "ctxp": ["ttxt", "ttfx", "ttyp", "CTyp", "ttxp", "ctyp", "ptxt", "CTfx", "ptfx", "ptxp", "ctxt", "ptyp", "CTxp", "CTxt", "ctfx"], "table": ["db", "master", "bean", "tf", "tr", "TABLE", "block", "address", "t", "able", "chain", "header", "buffer", "tab", "code", "Table", "rule", "try", "stable", "map", "type", "atable", "batch", "scope", "index", "transform", "inner", "ch"], "handler": ["command", "er", "holder", "server", "filter", "context", "tx", "policy", "event", "message", "reader", "handled", "manager", "parser", "hand", "processor", "header", "buffer", "Handler", "worker", "rule", "h", "hook", "handle", "callback", "proc", "test"], "pc_start": ["pc__end", "proc_first", "pc2offset", " pc_addr", "pc2addr", "pc__start", "PC_space", "pc00step", "pc_step", "PC_step", "pc_end", "pc_space", "pc2end", "proc_end", "pc00space", "PC_start", "proc_start", "pc_first", " pc_end", "pc_addr", "pc_offset", "pc00end", "PC_end", "pc__first", "pc00start", "pc2start", " pc_offset"], "gen_opc_end": ["gen_opc2buf", "gen_opcs_buf", "gen_opc2max", "gen_opc2start", "gen_opcs_END", "gen_opcs_End", "gen_opc__end", "gen_opc__buf", "gen_opc__start", "gen_opc_max", "gen_opc__max", "gen_opcs_end", "gen_opc_start", "gen_opcs_ends", "gen_opc2end", "gen_opc_END", "gen_opc_buf", "gen_opc_ends", "gen_opc_End", "gen_opcs_max", "gen_opcs_start"], "j": [" i", "v", "aj", "obj", " dj", "k", "n", "js", "fr", "J", "jo", "next", "json", "ij", "jp", "jl", "job", "ix", "it", "kj", "tr", "ji", " maj", "step", "z", "jas", "adj", "Ja", "key", "p", "str", "pt", "jj", "g", "off", "d", "jump", " ii", " n", "q", "ev", "jc", "uj", "bj", " l", "bo", "gov", "att", "h", "try", "l", "br", "ng", "y", "oj", "i", "pr", "dj", " J", "x", "ja", " jump", "jit", "ind"], "lj": ["litj", "eljs", "llj", "slj", "llkj", "olconn", "litng", "ylj", "eljp", " lconn", "lJ", " ljo", "ljump", "ledj", "lng", " lja", "ljo", "klja", "laj", "llng", "lej", "oljo", "elj", "lji", "litkj", " ldj", "elJ", "lij", "ylja", "sljs", " lkj", "slaj", "kldj", "slji", "olJ", " lji", "lijump", "olji", "liji", "lijs", "ylng", "leja", "lljs", "yljs", "ulj", " lJ", "olj", "oljs", "litja", "klj", "litjs", "llja", "lljump", "litji", "lijp", "ljs", "lejs", "liconn", "likj", "uljump", "kljs", "liJ", " ljp", "ljp", "ldj", " ljs", "olaj", "ulkj", "lkj", "ling", "lijo", "ulng", "litJ", "lconn", "lja", " laj"]}}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171, "substitutes": {"argv": ["Argb", "Argl", "argsvs", "argb", "argf", "agx", "argumentc", "argp", "argsv", "argl", " argl", "argsb", "argsm", "argumentp", "callx", "argumentm", " argm", "argsf", " argf", "argm", "argumentx", " argvs", "callv", "argsc", "argumentf", "callm", "Argv", "agc", "Argf", "argumentv", " argx", "callc", "argumentl", "Argc", "argumentb", "agv", "agvs", "argx", "argsp", "argsl", "Argp", "argvs", "argsx"], "argc": ["argumentt", "Argl", "ArgC", "argf", "Argcache", "argumentC", "argce", "argumentc", "argct", "Argct", " argct", "argC", "argl", " argl", "argumentct", "opce", "opc", " argf", "argcs", "argsca", " argcs", " argC", " argcache", "argumentcache", "opf", "argsc", "agl", "argumentca", "Argcs", "opv", "argcache", "argca", "Argv", "argst", "agc", "Argf", "Argce", " argce", "argumentl", "Argc", "argt", "agv", " argca", " argt", "argsl", "agcs"], "ide_idx": ["ide_basedxc", "ide_ideex", "ide___idex", "ide_ideno", "ide_Idz", "ide_idexs", "ide_idc", "ide_basedxs", "ide_idexc", "ide___idxi", "ide_latc", "ide_latxi", "ide_basedx", "ide_idg", "ide___ideex", "ide_idxc", "ide___idx", "ide_indg", "ide_Idx", "ide_Idy", "ide_latx", "ide_idey", "ide_ideg", "ide_idz", "ide___idc", "ide_idec", "ide_Idno", "ide_basedno", "ide_idexi", "ide___idexi", "ide_idy", "ide___idec", "ide_idex", "ide_idxs", "ide_latex", "ide_indx", "ide_Idxc", "ide_indz", "ide_indxs", "ide_idxi", "ide_Idxs", "ide_idez", "ide_idno"], "i": ["qi", "v", "to", " j", "asi", "n", "is", " I", "in", "ind", "li", "ij", "f", "ix", "xi", "ai", "go", "ini", "Ti", "Xi", "gi", "z", "ci", "ki", "di", "hi", "ii", "oi", "t", "mi", "ip", " bi", " Ai", "cli", "ims", "sim", "m", "p", "e", "multi", "ic", "ri", "u", "pi", "id", "\u0438", "im", "h", "iu", "l", " pi", "adi", "ti", "phi", "j", "c", "x", "index", "zi", "y", "it", "si", "bi", "ui", "I"]}}
{"project": "FFmpeg", "commit_id": "e13f860ac8a5a7d803059d1553773cf2a446d3f2", "target": 0, "func": "static int decode_vol_header(MpegEncContext *s, GetBitContext *gb){\n\n    int width, height, vo_ver_id;\n\n\n\n    /* vol header */\n\n    skip_bits(gb, 1); /* random access */\n\n    s->vo_type= get_bits(gb, 8);\n\n    if (get_bits1(gb) != 0) { /* is_ol_id */\n\n        vo_ver_id = get_bits(gb, 4); /* vo_ver_id */\n\n        skip_bits(gb, 3); /* vo_priority */\n\n    } else {\n\n        vo_ver_id = 1;\n\n    }\n\n//printf(\"vo type:%d\\n\",s->vo_type);\n\n    s->aspect_ratio_info= get_bits(gb, 4);\n\n    if(s->aspect_ratio_info == FF_ASPECT_EXTENDED){\t    \n\n        s->aspected_width = get_bits(gb, 8); // par_width\n\n        s->aspected_height = get_bits(gb, 8); // par_height\n\n    }else{\n\n        s->aspected_width = pixel_aspect[s->aspect_ratio_info][0];\n\n        s->aspected_height= pixel_aspect[s->aspect_ratio_info][1];\n\n    }\n\n\n\n    if ((s->vol_control_parameters=get_bits1(gb))) { /* vol control parameter */\n\n        int chroma_format= get_bits(gb, 2);\n\n        if(chroma_format!=1){\n\n            printf(\"illegal chroma format\\n\");\n\n        }\n\n        s->low_delay= get_bits1(gb);\n\n        if(get_bits1(gb)){ /* vbv parameters */\n\n            get_bits(gb, 15);\t/* first_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* first_half_vbv_buffer_size */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 3);\t/* latter_half_vbv_buffer_size */\n\n            get_bits(gb, 11);\t/* first_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */               \n\n        }\n\n    }else{\n\n        // set low delay flag only once so the smart? low delay detection wont be overriden\n\n        if(s->picture_number==0)\n\n            s->low_delay=0;\n\n    }\n\n\n\n    s->shape = get_bits(gb, 2); /* vol shape */\n\n    if(s->shape != RECT_SHAPE) printf(\"only rectangular vol supported\\n\");\n\n    if(s->shape == GRAY_SHAPE && vo_ver_id != 1){\n\n        printf(\"Gray shape not supported\\n\");\n\n        skip_bits(gb, 4);  //video_object_layer_shape_extension\n\n    }\n\n\n\n    skip_bits1(gb);   /* marker */\n\n    \n\n    s->time_increment_resolution = get_bits(gb, 16);\n\n    \n\n    s->time_increment_bits = av_log2(s->time_increment_resolution - 1) + 1;\n\n    if (s->time_increment_bits < 1)\n\n        s->time_increment_bits = 1;\n\n    skip_bits1(gb);   /* marker */\n\n\n\n    if (get_bits1(gb) != 0) {   /* fixed_vop_rate  */\n\n        skip_bits(gb, s->time_increment_bits);\n\n    }\n\n\n\n    if (s->shape != BIN_ONLY_SHAPE) {\n\n        if (s->shape == RECT_SHAPE) {\n\n            skip_bits1(gb);   /* marker */\n\n            width = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            height = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            if(width && height){ /* they should be non zero but who knows ... */\n\n                s->width = width;\n\n                s->height = height;\n\n//                printf(\"width/height: %d %d\\n\", width, height);\n\n            }\n\n        }\n\n        \n\n        s->progressive_sequence= get_bits1(gb)^1;\n\n        if(!get_bits1(gb)) printf(\"OBMC not supported (very likely buggy encoder)\\n\");   /* OBMC Disable */\n\n        if (vo_ver_id == 1) {\n\n            s->vol_sprite_usage = get_bits1(gb); /* vol_sprite_usage */\n\n        } else {\n\n            s->vol_sprite_usage = get_bits(gb, 2); /* vol_sprite_usage */\n\n        }\n\n        if(s->vol_sprite_usage==STATIC_SPRITE) printf(\"Static Sprites not supported\\n\");\n\n        if(s->vol_sprite_usage==STATIC_SPRITE || s->vol_sprite_usage==GMC_SPRITE){\n\n            if(s->vol_sprite_usage==STATIC_SPRITE){\n\n                s->sprite_width = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_height= get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_left  = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_top   = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n            }\n\n            s->num_sprite_warping_points= get_bits(gb, 6);\n\n            s->sprite_warping_accuracy = get_bits(gb, 2);\n\n            s->sprite_brightness_change= get_bits1(gb);\n\n            if(s->vol_sprite_usage==STATIC_SPRITE)\n\n                s->low_latency_sprite= get_bits1(gb);            \n\n        }\n\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        \n\n        if (get_bits1(gb) == 1) {   /* not_8_bit */\n\n            s->quant_precision = get_bits(gb, 4); /* quant_precision */\n\n            if(get_bits(gb, 4)!=8) printf(\"N-bit not supported\\n\"); /* bits_per_pixel */\n\n            if(s->quant_precision!=5) printf(\"quant precission %d\\n\", s->quant_precision);\n\n        } else {\n\n            s->quant_precision = 5;\n\n        }\n\n        \n\n        // FIXME a bunch of grayscale shape things\n\n\n\n        if((s->mpeg_quant=get_bits1(gb))){ /* vol_quant_type */\n\n            int i, v;\n\n            \n\n            /* load default matrixes */\n\n            for(i=0; i<64; i++){\n\n                int j= s->dsp.idct_permutation[i];\n\n                v= ff_mpeg4_default_intra_matrix[i];\n\n                s->intra_matrix[j]= v;\n\n                s->chroma_intra_matrix[j]= v;\n\n                \n\n                v= ff_mpeg4_default_non_intra_matrix[i];\n\n                s->inter_matrix[j]= v;\n\n                s->chroma_inter_matrix[j]= v;\n\n            }\n\n\n\n            /* load custom intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n                    \n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n            }\n\n\n\n            /* load custom non intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n\n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= v;\n\n                    s->chroma_inter_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= last;\n\n                    s->chroma_inter_matrix[j]= last;\n\n                }\n\n            }\n\n\n\n            // FIXME a bunch of grayscale shape things\n\n        }\n\n\n\n        if(vo_ver_id != 1)\n\n             s->quarter_sample= get_bits1(gb);\n\n        else s->quarter_sample=0;\n\n\n\n        if(!get_bits1(gb)) printf(\"Complexity estimation not supported\\n\");\n\n\n\n        s->resync_marker= !get_bits1(gb); /* resync_marker_disabled */\n\n\n\n        s->data_partitioning= get_bits1(gb);\n\n        if(s->data_partitioning){\n\n            s->rvlc= get_bits1(gb);\n\n            if(s->rvlc){\n\n                printf(\"reversible vlc not supported\\n\");\n\n            }\n\n        }\n\n        \n\n        if(vo_ver_id != 1) {\n\n            s->new_pred= get_bits1(gb);\n\n            if(s->new_pred){\n\n                printf(\"new pred not supported\\n\");\n\n                skip_bits(gb, 2); /* requested upstream message type */\n\n                skip_bits1(gb); /* newpred segment type */\n\n            }\n\n            s->reduced_res_vop= get_bits1(gb);\n\n            if(s->reduced_res_vop) printf(\"reduced resolution VOP not supported\\n\");\n\n        }\n\n        else{\n\n            s->new_pred=0;\n\n            s->reduced_res_vop= 0;\n\n        }\n\n\n\n        s->scalability= get_bits1(gb);\n\n\n\n        if (s->scalability) {\n\n            GetBitContext bak= *gb;\n\n            int ref_layer_id;\n\n            int ref_layer_sampling_dir;\n\n            int h_sampling_factor_n;\n\n            int h_sampling_factor_m;\n\n            int v_sampling_factor_n;\n\n            int v_sampling_factor_m;\n\n            \n\n            s->hierachy_type= get_bits1(gb);\n\n            ref_layer_id= get_bits(gb, 4);\n\n            ref_layer_sampling_dir= get_bits1(gb);\n\n            h_sampling_factor_n= get_bits(gb, 5);\n\n            h_sampling_factor_m= get_bits(gb, 5);\n\n            v_sampling_factor_n= get_bits(gb, 5);\n\n            v_sampling_factor_m= get_bits(gb, 5);\n\n            s->enhancement_type= get_bits1(gb);\n\n            \n\n            if(   h_sampling_factor_n==0 || h_sampling_factor_m==0 \n\n               || v_sampling_factor_n==0 || v_sampling_factor_m==0){\n\n               \n\n//                fprintf(stderr, \"illegal scalability header (VERY broken encoder), trying to workaround\\n\");\n\n                s->scalability=0;\n\n               \n\n                *gb= bak;\n\n            }else\n\n                printf(\"scalability not supported\\n\");\n\n            \n\n            // bin shape stuff FIXME\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 27201, "substitutes": {"s": ["sv", "ears", "gs", "ms", "ses", "changes", "services", "scripts", "details", "store", "pers", "parts", "ops", "orders", "comments", "styles", "p", "aws", "ls", "rs", "als", "sports", "c", "uploads", "ps", "results", "n", "bis", "fs", "ns", "ants", "states", "ts", "se", "less", "steps", "sb", "ins", "es", "os", "ies", "vs", "stats", "sts", "ports", "settings", "hs", "is", "rates", "ss", "spec", "cs", "ats", "m", "comm", "ds", "tes", "ids", "sys", "sq", "eds", "js", "eps", "S", "qs", "t", "mods", "ims", "lines", "tests", "sw", "views", "sg", "h", "bs", "its"], "gb": [" rgb", "bits", "gs", "dd", "range", "vm", "gin", "cb", "buff", "phy", "pg", "tm", "gpu", "fb", "gnu", "gg", "eg", "gz", "pb", "csv", "pc", "gc", "db", "ruby", "json", "gd", "td", "rb", "vd", "hub", "um", "bytes", "html", "lib", "sb", "bb", "nb", "mg", "gh", "wb", "cfg", "raw", "args", "cv", "git", "bf", "bg", "buffer", "goo", "py", "kb", "img", "sys", "xy", "gem", "vg", "got", "mb", "gif", "google", "cache", "Gb", "cd", "tg", "eb", "bc", "gm", "rg", "gt", "g", "sg", "storage", "bs", "GB", "bt", "rect"], "height": ["Height", "ih", "build", "history", "scale", "volume", "shape", "resolution", "quality", "info", "image", "padding", "total", "version", "hash", "inches", "rank", "pi", "depth", "high", "density", "size", "h", "grow", "angle", "dim", "length"], "vo_ver_id": ["vo_version_name", "vo_version_flag", "vo_ver_code", "vo_version_ids", "vo_ver_name", "vo_ver____index", "vo_ver_info", "vo_ver____id", "vo_version_code", "vo_version_type", "vo_version_index", "vo_ver____ids", "vo_version_id", "vo_ver_type", "vo_ver____info", "vo_ver_ids", "vo_ver_index", "vo_version_info", "vo_ver_flag"]}}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "void ff_init_me(MpegEncContext *s){\n\n    MotionEstContext * const c= &s->me;\n\n    c->avctx= s->avctx;\n\n\n\n    ff_set_cmp(&s->dsp, s->dsp.me_pre_cmp, c->avctx->me_pre_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_cmp, c->avctx->me_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_sub_cmp, c->avctx->me_sub_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.mb_cmp, c->avctx->mb_cmp);\n\n    \n\n    c->flags    = get_flags(c, 0, c->avctx->me_cmp    &FF_CMP_CHROMA);\n\n    c->sub_flags= get_flags(c, 0, c->avctx->me_sub_cmp&FF_CMP_CHROMA);\n\n    c->mb_flags = get_flags(c, 0, c->avctx->mb_cmp    &FF_CMP_CHROMA);\n\n\n\n/*FIXME s->no_rounding b_type*/\n\n    if(s->flags&CODEC_FLAG_QPEL){\n\n        c->sub_motion_search= qpel_motion_search;\n\n        c->qpel_avg= s->dsp.avg_qpel_pixels_tab;\n\n        if(s->no_rounding) c->qpel_put= s->dsp.put_no_rnd_qpel_pixels_tab;\n\n        else               c->qpel_put= s->dsp.put_qpel_pixels_tab;\n\n    }else{\n\n        if(c->avctx->me_sub_cmp&FF_CMP_CHROMA)\n\n            c->sub_motion_search= hpel_motion_search;\n\n        else if(   c->avctx->me_sub_cmp == FF_CMP_SAD \n\n                && c->avctx->    me_cmp == FF_CMP_SAD \n\n                && c->avctx->    mb_cmp == FF_CMP_SAD)\n\n            c->sub_motion_search= sad_hpel_motion_search; // 2050 vs. 2450 cycles\n\n        else\n\n            c->sub_motion_search= hpel_motion_search;\n\n    }\n\n    c->hpel_avg= s->dsp.avg_pixels_tab;\n\n    if(s->no_rounding) c->hpel_put= s->dsp.put_no_rnd_pixels_tab;\n\n    else               c->hpel_put= s->dsp.put_pixels_tab;\n\n\n\n    if(s->linesize){\n\n        c->stride  = s->linesize; \n\n        c->uvstride= s->uvlinesize;\n\n    }else{\n\n        c->stride  = 16*s->mb_width + 32;\n\n        c->uvstride=  8*s->mb_width + 16;\n\n    }\n\n\n\n    // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it\n\n    if((c->avctx->me_cmp&FF_CMP_CHROMA) && !s->dsp.me_cmp[2]){\n\n        s->dsp.me_cmp[2]= zero_cmp;\n\n    }\n\n    if((c->avctx->me_sub_cmp&FF_CMP_CHROMA) && !s->dsp.me_sub_cmp[2]){\n\n        s->dsp.me_sub_cmp[2]= zero_cmp;\n\n    }\n\n    c->hpel_put[2][0]= c->hpel_put[2][1]=\n\n    c->hpel_put[2][2]= c->hpel_put[2][3]= zero_hpel;\n\n\n\n    c->temp= c->scratchpad;\n\n}\n", "idx": 27203, "substitutes": {"s": ["ches", "sv", "args", "bits", "hs", "eds", "is", "gs", "js", "ms", "ses", "changes", "bis", "erences", "fs", "S", "ties", "source", "ns", "details", "ss", "b", "ts", "qs", "has", "ops", "parts", "cs", "south", "less", "ats", "bes", "gets", "sb", "ims", "o", "m", "e", "ins", "times", "http", "aws", "ds", "ls", "sw", "os", "es", "rs", "app", "ies", "acs", "vs", "as", "sys", "your", "sets", "h", "stats", "sts", "bs", "y", "its", "sports", "rest", "aunts", "sq", "ps", "set", "w"], "c": ["ca", "cv", "pc", "cl", "cache", "gc", "co", "cam", "anc", "cd", "content", "comp", "ar", "ce", "cr", "lc", "cb", "mc", "can", "fc", "ci", "nc", "xc", "bc", "dc", "cs", "cu", "comments", "cod", "ac", "conv", "uc", "ec", "coll", "cn", "m", "p", "ic", "chain", "unc", "com", "cc", "cf", "g", "ct", "cp", "call", "u", "cal", "sc", "C", "con", "cur", "rc", "l", "cont", "conf", "arc", "tc", "vc", "cm", "etc", "abc", "err", "enc", "csv", "ctx"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void filter(MpegAudioContext *s, int ch, short *samples, int incr)\n\n{\n\n    short *p, *q;\n\n    int sum, offset, i, j, norm, n;\n\n    short tmp[64];\n\n    int tmp1[32];\n\n    int *out;\n\n\n\n    //    print_pow1(samples, 1152);\n\n\n\n    offset = s->samples_offset[ch];\n\n    out = &s->sb_samples[ch][0][0][0];\n\n    for(j=0;j<36;j++) {\n\n        /* 32 samples at once */\n\n        for(i=0;i<32;i++) {\n\n            s->samples_buf[ch][offset + (31 - i)] = samples[0];\n\n            samples += incr;\n\n        }\n\n\n\n        /* filter */\n\n        p = s->samples_buf[ch] + offset;\n\n        q = filter_bank;\n\n        /* maxsum = 23169 */\n\n        for(i=0;i<64;i++) {\n\n            sum = p[0*64] * q[0*64];\n\n            sum += p[1*64] * q[1*64];\n\n            sum += p[2*64] * q[2*64];\n\n            sum += p[3*64] * q[3*64];\n\n            sum += p[4*64] * q[4*64];\n\n            sum += p[5*64] * q[5*64];\n\n            sum += p[6*64] * q[6*64];\n\n            sum += p[7*64] * q[7*64];\n\n            tmp[i] = sum >> 14;\n\n            p++;\n\n            q++;\n\n        }\n\n        tmp1[0] = tmp[16];\n\n        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];\n\n        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];\n\n\n\n        /* integer IDCT 32 with normalization. XXX: There may be some\n\n           overflow left */\n\n        norm = 0;\n\n        for(i=0;i<32;i++) {\n\n            norm |= abs(tmp1[i]);\n\n        }\n\n        n = av_log2(norm) - 12;\n\n        if (n > 0) {\n\n            for(i=0;i<32;i++) \n\n                tmp1[i] >>= n;\n\n        } else {\n\n            n = 0;\n\n        }\n\n\n\n        idct32(out, tmp1, s->sblimit, n);\n\n\n\n        /* advance of 32 samples */\n\n        offset -= 32;\n\n        out += 32;\n\n        /* handle the wrap around */\n\n        if (offset < 0) {\n\n            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), \n\n                    s->samples_buf[ch], (512 - 32) * 2);\n\n            offset = SAMPLES_BUF_SIZE - 512;\n\n        }\n\n    }\n\n    s->samples_offset[ch] = offset;\n\n\n\n    //    print_pow(s->sb_samples, 1152);\n\n}\n", "idx": 27237, "substitutes": {"s": ["sv", "ex", "v", "is", "hs", "gs", "js", "ms", "ses", "bis", "S", "fs", "source", "ns", "ss", "b", "ts", "parts", "se", "spec", "t", "cs", "ssl", "less", "sb", "http", "m", "comm", "o", "g", "ds", "ls", "sw", "os", "a", "so", "sg", "rs", "sc", "h", "sys", "conf", "stats", "sts", "bs", "c", "sq", "ps", "set"], "ch": ["v", "chron", "cl", "ih", " y", "count", "sky", " chunk", "chart", "ctx", "zh", "history", "channel", " cs", "cb", "b", "chrom", "z", "cha", "cor", "chan", "cs", "sh", " h", "kh", "och", "chain", "code", "ich", "pt", "cho", "ach", "cp", "Ch", "h", "ched", "chip", "cht", "CH", "sch", "c", "x", "ech", "et", "ht", "y", "batch", "chn"], "samples": [" sources", "mores", "insources", "Samples", " sizes", "Sounds", "tizes", "nsamps", "Samps", "ssamps", "mamps", "insents", "insamples", "tources", "ssources", "ssamples", "tamples", "sounds", "tamps", "sents", " sents", "insamps", " sounds", "mamples", "sizes", "nsamples", "samps", "ssizes", " sores", "sores", "Sores", "mounds", "nsources", " samps", "nsents", "sources"], "incr": ["integrat", "isecr", "isecerr", "incur", "isecrs", "incrn", "INCrn", "incrr", " Incrs", " Incerr", " Incur", "integr", " incrs", "incrat", "integrn", "ignrr", " incerr", "ignrat", "ignr", "integrr", "incerr", "INCr", "INCrat", " incur", "incrs", "ignrn", " Incr", "isecur", "INCrr"], "p": ["er", "ap", "v", "pc", "vp", "tp", "pre", "pa", "post", "wp", "lp", "jp", "sp", "f", "pro", "ar", "op", "b", "pp", "pkg", "pg", "t", "ip", "mp", "pat", "m", "par", "pt", "P", "per", "cp", "u", "pi", "a", "app", "up", "perm", "pe", "point", "np", "pm", "y", "pb", "c", "x", "pr", "php", "proc", "ps"], "q": ["qi", "question", "v", "cv", "ve", "k", "iq", "ur", "count", "quest", "cache", "eq", "f", "aq", "qu", "query", "quad", "b", "z", "dq", "qs", "pp", "pkg", "t", "ip", "mp", "sh", "req", "qual", "comm", "qa", "m", "g", "quote", "queue", "cf", "cp", "u", "requ", "view", "check", "window", "l", "pe", "qq", "pm", "ue", "Q", "cap", "form", "c", "sq", "x", "quant", "qt", "w"], "sum": ["ma", "v", "cache", "acc", "cast", "result", "count", "sa", "tu", "Sum", "hum", "zero", "weight", "sam", "volume", "mem", "see", "process", "usr", "um", "t", "fac", "comment", "total", "ac", "match", "add", "sim", "doc", "m", "mm", "hash", "status", "g", "ui", "ount", "u", "cal", "base", "ul", "tex", "mean", "size", "vol", "sc", "summary", "un", "score", " SUM", "st", "gam", "use", "rup", "num", "us", "SI", "cum", "tim", "index", "c", "stat", "dim", "sym", "si", "ind", "set"], "offset": ["init", "length", "scroll", "sp", "iat", "ut", "end", "ix", "slot", "timeout", "loc", "offs", "address", "t", "origin", "ip", "shift", "padding", "ref", "o", "seek", "buffer", "pad", "off", "bound", "Offset", "base", "tile", "seed", "error", "size", "pixel", "location", "position", "l", "point", "pointer", "start", "batch", "index", "pos", "angle", "et", "order", "si", "entry", "ui", "set"], "i": ["qi", "ex", "ix", "xi", "ami", "ii", "oi", "ip", "ei", "e", "status", "id", "io", "zi", "c", "y", "bi", "ind", "set", "I", "er", "iter", "ci", "di", "iii", "u", "pi", "iu", "iy", "vi", "ik", "init", "is", "iq", "me", "ij", "print", "f", "ini", "gi", "hi", "cli", "ri", "sim", "m", "ic", "multi", "chain", "\u0438", "im", "dr", "try", "l", "ia", "index", "ie", "si", "itime", "ma", "v", "gu", "in", "li", "ai", "ji", "ki", "info", "at", "ity", "t", "mi", "key", "mac", "ims", "o", "g", "uri", "h", "ti", "x", "it", "ui"], "j": ["v", "aj", "k", "js", "fr", "J", "jo", "json", "ij", "jp", "jl", "f", "job", "ne", "kj", "ji", "b", "r", "z", "adj", "at", "t", "el", "sim", "o", "m", "jj", "g", "jump", "jc", "uj", "bj", "no", "im", "att", "l", "br", "oj", "c", "x", "dj", "pr", "ion", "ja", "it", "jit", "bi", "ind"], "norm": ["init", "nt", "res", "max", "alph", "scale", "nu", "uv", "term", "ns", "net", "mem", "ne", "mn", "dot", "vec", "diff", "nom", "fun", "sim", "note", "mom", "dev", "dist", "N", "u", "nv", "nb", "not", "loss", "Norm", "no", "orm", "iz", "unit", "nn", "non", "num", "np", "nm", "eff", "form", "ord", " norms", "normal", "nor", "it", "nc", "err", "NOR"], "n": ["nt", "nr", "v", "nl", "na", "nu", "ns", "ne", "mn", "r", "fn", "nan", "t", "len", "cn", "o", "m", "ni", "N", "d", "nw", "ny", "nv", "u", "nb", "nd", "no", "yes", "ln", "nm", "nn", "num", "np", "ng", "normal", "c", "sn", "nor", "y", "nc"], "tmp": ["video", "nt", "v", "cv", "MP", "obj", "tp", " mp", "cache", "cmp", "to", "tu", "vp", "emp", "js", "txt", "sp", "tt", "uv", "aux", "rt", "tf", "timeout", "ob", "td", "appy", "buff", "mb", "b", "upload", "pkg", "gb", "new", "t", "html", "lib", "mp", "uf", "tm", "zip", "mm", "m", "cp", " temp", "bow", "table", "nb", "snap", "perm", "img", "etc", "resp", "np", "qq", "amp", "xy", " amp", "tc", "tar", "buf", "ht", "proc", "ptr", "temp", "test", "ctx"], "tmp1": ["tmpOne", "obj0", "txt0", "tmp2", "obj2", "mp1", "mp5", "obj1", "objOne", "node1", "mp0", "temp2", "txtOne", "mp3", " tmp2", "temp1", "temp4", "tmp0", "mp2", "node0", " tmp0", "node2", " tmp3", "tmp3", "txt2", "node5", " tmp4", "tempOne", "cmp3", "mpOne", "tmp4", "cmp1", " tmp5", "tmp5", "cmp0", "mp4", "txt1", "cmp2", "temp0", " tmpOne", "txt3"], "out": ["nt", "v", "obj", "output", "to", "ex", "result", "in", "ot", "net", "mem", "b", "bit", "null", "OUT", "new", "t", "o", "m", "off", "g", "outs", "Out", "list", "size", "io", "c", "x", "pos", "temp", "it", "set", "w"]}}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254, "substitutes": {"cs": ["pc", "ars", "ras", "ks", "is", "js", "ms", "cas", "fs", "ns", "ss", "ps", "ts", "cus", "ac", "cc", "ds", "ls", "ups", "wcs", "cp", "cks", "rs", "sc", "acs", "s", "sts", "bs", "c", "caps", "CS", "css"], "run": ["flow", "ve", "runner", "work", "begin", "in", "range", "Run", "build", "runs", "rt", "job", "ran", "load", "go", "ru", "r", "report", "process", "cmd", "car", "pass", "man", "boot", "add", "out", "name", "call", "rm", "old", "running", "rc", "ra", "unit", "nn", "use", "row", "gem", "runtime", "render", "ro", "play", "un", "commit", "set", "raw"], "cpu": ["linux", "pc", "result", "sky", "gc", "ctx", "frame", "jp", "phys", "net", "mem", "ret", "vm", "pid", "process", "processor", "mx", "ilo", "gb", "pu", "cu", "lan", "boot", "mac", "clock", "cn", "gpu", "hw", "copy", "out", "cf", "cp", "ck", "cal", "nic", "thread", "uu", "sys", "cum", "c", "proc", "CPU", "alloc", "prof", "core"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n", "idx": 27256, "substitutes": {"dev": ["Device", "data", "nt", "v", "ve", "md", "res", "cam", "DEV", "val", "serv", "end", "priv", "mem", "go", "det", "wd", "den", "var", "phy", "cmd", "block", "spec", "dem", "der", "doc", "out", "device", "debug", "Dev", "d", "train", "ev", "ad", "develop", "vol", "def", "des", "de", "desc", "buf", "disc", "test", "ver", "err", "enc", "w"], "bus": ["Bus", "bridge", "gen", "book", "bug", "cast", "cache", "loop", "build", "way", "driver", "host", "disk", "mask", "local", "family", "tag", "join", "lock", "full", "b", "used", "box", "state", "block", "hand", "di", "bill", "board", "func", "proxy", "boot", "mount", "chain", "buffer", "status", "queue", "controller", "project", "os", "base", "byte", "us", " BUS", "bs", "home", "back", "vc", "object", "buf", "pos", "socket", "proc", "handle", "test", "BUS", "bolt", "root", "length"], "iommu_bus": ["iommu_chain", "iommeu_queue", "iommeu_us", "iommu_config", "iommuit___us", "iommumybus", "iommu_bool", "iommu___box", "iommu00back", "iommtu_Bus", "iommuaterbox", "iommU_boot", "iommau_task", "iommu00task", "iommtu_bus", "iommu___bus", "iommu_Bus", "iommu5bal", "iommu_gen", "iommuit___box", "iommU_box", "iommuit_bus", "iommu___proc", "iommau00bus", "iommU_bridge", "iommeu_bus", "iommu_box", "iommuf_db", "iommumychain", "iommu5dev", "iommu_task", "iommu_db", "iommu_bal", "iommnu_cache", "iommuaterbus", "iommuaterbool", "iommuaterdb", "iommcu_proc", "iommeu_bridge", "iommu00config", "iommumycache", "iommtu_gen", "iommu5bus", "iommu___Bus", "iommu5box", "iommupybook", "iommu_bridge", "iommo_bus", "iommuf_bus", "iommu_dev", "iommau00task", "iommu_bs", "iommu00bus", "iommau_back", "iommo_book", "iommu1cache", "iommcu_box", "iommumylength", "iommupybox", "iommuf_bool", "iommcu_bus", "iommuit_box", "iommu___us", "iommau_bus", "iommu_book", "iommu_length", "iommu_back", "iommcu_Bus", "iommuf_box", "iommau00back", "iommuit_bs", "iommu_cache", "iommo_back", "iommo_dev", "iommuit___bs", "iommuit_us", "iommuit___bus", "iommnu_length", "iommu_proc", "iommupyback", "iommnu_bus", "iommu1bus", "iommau_config", "iommu_boot", "iommtu_box", "iommu___bs", "iommnu_chain", "iommU_bus", "iommo_bal", "iommu_us", "iommupybus", "iommu_queue", "iommo_box", "iommau00config", "iommu1chain", "iommu1length"]}}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257, "substitutes": {"dst": ["dest", "Dtt", "didst", "adht", "idest", "idnd", "idnt", "lst", "tnt", "tst", "dsts", "lest", " dsrc", "dnt", " dht", "adst", "mst", " dnd", " dest", "dtt", "didest", "dht", " dcp", "sdest", "depest", "lsrc", "ddest", " dsts", "Dsrc", "dST", "dnd", "Dest", "dcp", " dtt", " dST", "sdcp", "mht", "Dsts", "adest", "ldest", "depsrc", "didtt", "depST", "sdsts", "DST", "adnd", "sdst", "Dcp", "tnd", "Dst", " dnt", " ddest", "mnd", "idst", "Ddest", "depst", "dsrc", "mest", "didsrc", "test"], "src": ["via", "dest", "init", "ur", "sr", "ser", "source", "serv", "rt", "inst", "rl", "op", "ack", "loc", "ssl", "sec", "conv", "sb", "sing", "scan", "rx", "sel", "str", "sub", "cc", "irst", "sur", "syn", "sync", "rs", "sc", "cur", "img", "rc", "st", "s", "sys", "tmp", "inc", "addr", "start", "ptr", "sn"], "fcc_offset": ["fccmmindex", "fccmmerror", "fccmminfo", "fCC_offset", "fcc_index", "fCC2no", "fCC_info", "fcc_no", "fccmmoffset", "fCC_pad", "fCC_error", "fcc_start", "fCC_padding", "fcc2index", "fccmmstart", "fCC_start", "fccmmno", "fcc_info", "fcc2no", "fCC2offset", "fcc_pad", "fCC_index", "fCC_no", "fcc_error", "fCC2index", "fcc2offset", "fcc_padding"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_decode(AVCodecContext *avctx,\n\n                         void *data, int *data_size,\n\n                         AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    AVSubtitle *sub = data;\n\n    const uint8_t *p, *p_end;\n\n    int segment_type;\n\n    int page_id;\n\n    int segment_length;\n\n    int i;\n\n\n\n    av_dlog(avctx, \"DVB sub packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    if (buf_size <= 6 || *buf != 0x0f) {\n\n        av_dlog(avctx, \"incomplete or broken packet\");\n\n        return -1;\n\n    }\n\n\n\n    p = buf;\n\n    p_end = buf + buf_size;\n\n\n\n    while (p_end - p >= 6 && *p == 0x0f) {\n\n        p += 1;\n\n        segment_type = *p++;\n\n        page_id = AV_RB16(p);\n\n        p += 2;\n\n        segment_length = AV_RB16(p);\n\n        p += 2;\n\n\n\n        if (p_end - p < segment_length) {\n\n            av_dlog(avctx, \"incomplete or broken packet\");\n\n            return -1;\n\n        }\n\n\n\n        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||\n\n            ctx->composition_id == -1 || ctx->ancillary_id == -1) {\n\n            switch (segment_type) {\n\n            case DVBSUB_PAGE_SEGMENT:\n\n                dvbsub_parse_page_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_REGION_SEGMENT:\n\n                dvbsub_parse_region_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_CLUT_SEGMENT:\n\n                dvbsub_parse_clut_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_OBJECT_SEGMENT:\n\n                dvbsub_parse_object_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAYDEFINITION_SEGMENT:\n\n                dvbsub_parse_display_definition_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAY_SEGMENT:\n\n                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);\n\n                break;\n\n            default:\n\n                av_dlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\",\n\n                        segment_type, page_id, segment_length);\n\n                break;\n\n            }\n\n        }\n\n\n\n        p += segment_length;\n\n    }\n\n\n\n    return p - buf;\n\n}\n", "idx": 27261, "substitutes": {"avctx": ["wavfc", "avepkg", " avcmd", "ravctx", "ajcmp", "AVcontext", "ajtx", "wavpkg", " avpkg", "avecp", "averjac", "abcp", "ravcu", "avecontext", "avejp", "avercp", "ajtmp", "avecu", "ravcli", "wavctl", " avcli", "ajpkg", "wavcmd", "avertx", " avctl", "ravcontext", "ajcli", "ravctl", "averpkg", "vrctl", " avjp", "vrcontext", " avtx", "avdyl", "afcfg", "ajctl", "avetx", " avcu", "avercmp", "avefc", "avreq", "vrtx", "abcontext", "avcli", "ajjp", "avtmp", "averconn", " avcontext", "avtx", " avcmp", "afctl", "avctl", "wavcp", "abctx", "wavctx", "abtx", "avcontext", "verctx", "vrctx", "ajreq", "afctx", "abtmp", "ajcp", "avjp", "avcmd", "avercmd", "verctl", "avecmd", "avedyl", "abctl", "ajjac", " avjac", "avfc", "avpkg", "avconn", "averctl", "vercontext", "vertx", "avcp", "avcmp", "aveconn", "AVctl", "avercfg", " avreq", "AVtx", "averctx", "avecmp", "avereq", "averreq", "avetmp", "AVctx", "ravdyl", " avdyl", "avcfg", "avectl", "ajconn", "abpkg", "avjac", "avecfg", "ajcu", "afcmd", "ajctx", "avectx", "averfc", "avcu"], "data": ["DATA", "v", "obj", "res", "text", "offset", "Data", "txt", "aux", "content", "f", "ns", "mu", "tx", "join", "message", "info", "block", "bytes", "image", "t", "area", "padding", "bin", "pat", "m", "dat", "buffer", "feed", "pad", "name", "format", "dev", "d", "rel", "a", "table", "window", "id", "package", "size", "value", "def", "resp", "input", "tmp", "map", "type", "form", "batch", "pos", "empty", "ata", "length", "raw"], "data_size": ["data_length", "buffer_Size", "buffer_size", "data_len", "buffer_length", "data_Size", "buffer_len"], "avpkt": ["avcppt", "AVcpck", "afpj", "avepacket", "avnkg", "avnck", "AVpacket", "AVcpacket", "avpbj", "avpj", "avspacket", "avppkt", "avjpkt", "avepkg", "afpett", "avjpett", "avcpett", "afpacket", "avppck", "avnacket", "avpck", "avjpacket", "avpbett", "avnpacket", "afcpj", "avnpkg", "avnkt", "avpacket", "avpbacket", "afcpkt", "avcpkg", "avpbkt", "avspkg", "avspkt", "avjpj", "avcpacket", "avpkg", "avcpck", "avppkg", "avenppt", "avppt", "afcpacket", "avnppt", "avenpkt", "AVcpkg", "afcpett", "AVpkt", "avsppt", "aveppt", "avepkt", "avcpj", "avcpkt", "afpkt", "avenpacket", "AVpck", "avpett", "avenpkg", "AVpkg", "avnpkt", "avppacket", "AVcpkt"], "buf": ["v", "cv", "max", "bp", "aw", "txt", "end", "mem", "lim", "tr", "buff", "cb", "b", "rb", "vec", "read", "loc", "box", "cmd", "pool", "pkg", "pg", "bytes", "bc", "new", "len", "bl", "arr", "uf", "bin", "conv", "ref", "fun", "port", "doc", "dat", "buffer", "str", "pad", "queue", "cp", "pack", "late", "paste", "window", "Buffer", "cur", "img", "rc", "Buff", "np", "br", "tmp", "cap", "wb", "pb", "batch", "ff", "ptr", "pos", "msg", "prop", "begin", "err", "xff", "raw"], "ctx": ["nt", "cv", "obj", "cmp", "pc", "conn", "co", "util", "cas", "txt", "jp", "xp", "rt", "config", "wx", "context", "mem", "tx", "cb", "loc", "kt", "fc", "cmd", "fn", "pkg", "xc", "bc", "setup", "act", "dc", "cu", "this", "ctl", "conv", "ac", "req", "tm", "unc", "hw", "comm", "cc", "cf", "ct", "cp", "crit", "fp", "resp", "conf", "np", "tmp", "Context", "tc", "sys", "cm", "etc", "ctrl", "kw", "cfg"], "sub": ["cmp", "rec", " subs", "ub", "unk", "ext", "sam", "aux", "seq", "tx", "mod", "uc", "sel", "tab", "sl", "rel", "sup", "part", "sc", "su", "Sub", "tmp", "desc", "pb", "msg", "ch", "set"], "p": ["ap", "v", "pc", "vp", "tp", "pre", "dp", "bp", "pa", "wp", "page", "post", "lp", "jp", "sp", "f", "it", "pro", "pl", "op", "after", "b", "pid", "php", "pp", "pool", "pkg", "at", "t", "ip", "pat", "pod", "m", "par", "ping", "pt", "g", "pad", "per", "P", "d", "cp", "u", "q", "pi", "a", "part", "up", "fp", "perm", "h", "pe", "point", "l", "np", "progress", "pb", "pr", "pos", "c", "j", "x", "ptr", "ps", "port", "w"], "p_end": ["page_size", "dp_off", "dp___final", "ptMemfin", "pMemfin", "p___min", "pwstart", "p___off", "p___fin", "dp___end", "p_ended", "page_ends", "p___start", "p_off", "p_begin", "pMemend", "p_ends", "ap_ended", "pwend", "p___end", "p_size", "pt_end", "p_start", "pMemended", "dp_final", "ptMemended", "p___final", "ptMemend", "dp___start", "p_fin", "p_final", "pwfinal", "pt_ended", "dp_end", "page_end", "ap_start", "p_min", "pwoff", "ap_end", "pt_min", "dp___off", "pMemmin", "page_begin", "pt_fin", "ptMemmin", "p___ended", "dp_start"], "segment_type": ["segmentnesscolor", "seportion___id", "segmentitylength", "segmentitytypes", "segementitycolor", "segement_color", "segment___format", "segmentationtypes", "segmentnessTYPE", "segment_TYPE", "segement_TYPE", "segementitylength", "sement_length", "segmentityTYPE", "segment___Type", "segmentityid", "seportion___format", "segment_id", "segment___type", "segmentationlength", "segmentitytype", "segmentationtype", "sement_id", "sement_types", "segmentitycolor", "segment_Type", "sement_type", "seportion_Type", "seportion_format", "segement_length", "seportion___Type", "seportion_id", "segmentationid", "segment_format", "segment_color", "seportion_type", "segmentnesslength", "segement_type", "seportion___type", "segementityTYPE", "segementitytype", "segmentnesstype", "segment___id", "segment_types"], "page_id": ["page_mid", "pageitypid", "page___id", "page_pid", "point_start", "pagevisionid", "page_time", " page_type", "point___id", "pageityid", "pagevisionstart", "point_id", "pageityID", " page_no", "page_start", "page_class", "page____iden", "page_iden", "page___type", "page___ID", "page_ID", "point_class", " page_mid", "point___type", "page____time", " page_pid", "pagevisiontype", " page_ID", "page___mid", "pageitymid", "pageactype", "point___start", "pagevisionclass", "pageactime", "page___pid", "pageacid", "point___class", "page_type", "page_no", "pageaciden", "page___start", "point_type", "page____id", " page_time", "page____type", "page___class", " page_iden"], "segment_length": ["segmentitysize", "segment2length", "segment_long", "segmentityduration", "sement_height", "segment2type", "segment_height", "seportionitylength", "sement_size", "segment_end", "sement_type", "segement2type", "sement_name", "segmentityname", "segment2len", "seportion_size", "sement_duration", "segment_len", "segmentallength", "segmentitylength", "sement_long", "seportion_end", "segmentitylong", "segment_count", "segement2Length", "segmentationcount", "segmentalsize", "segment2Length", "seportionitysize", "segment_duration", "segmentationsize", "segement_Length", "seportionityend", "segmentalheight", "sement_len", "segement2len", "segmentationlength", "segmentitytype", "segement_length", "segmentityend", "segmentationlen", "segmentallong", "seportion_type", "sement_count", "sement_length", "segement2length", "seportion_length", "segment_name", "segment_Length", "segment_size", "segement_len", "segmentityheight", "segement_type", "seportionitytype"], "i": ["qi", "ex", "n", "is", "ms", "me", "in", "slice", "li", "ix", "xi", "ri", "ai", "ami", "ini", "ji", "gi", "ci", "z", "ki", "info", "di", "hi", "ii", "oi", "ip", "mi", "ei", "cli", "ic", "o", "m", "multi", "sim", "ims", "g", "ui", "status", "chain", " ii", "pi", "\u0438", "im", "iu", "l", "span", "ti", "phi", "j", "index", "x", "c", "zi", "y", "it", "si", "bi", "ind", "I"]}}
{"project": "qemu", "commit_id": "04088adbe0c5adca66adb6022723362ad90ed0fc", "target": 0, "func": "static void *mpc8544_load_device_tree(target_phys_addr_t addr,\n\n                                     uint32_t ramsize,\n\n                                     target_phys_addr_t initrd_base,\n\n                                     target_phys_addr_t initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    void *fdt = NULL;\n\n#ifdef CONFIG_FDT\n\n    uint32_t mem_reg_property[] = {0, ramsize};\n\n    char *filename;\n\n    int fdt_size;\n\n    int ret;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    qemu_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n", "idx": 27266, "substitutes": {"addr": ["Address", "url", "adr", "conn", "db", "host", "store", "var", "state", "attr", "address", "coord", "dir", "ref", "add", "hash", "sha", "name", "dh", "id", "eth", "dr", "map", "type", "handle", "ptr", "mb"], "ramsize": ["gramcount", "memSize", "gramize", "RAMcount", " ramSIZE", " ramcount", "ramSIZE", "ramcount", "RAMize", "ramize", " ramspace", "RAMSIZE", "RAMsize", "gramSIZE", "memspace", "ramSize", "gramspace", "ramspace", "gramsize", " ramSize", "gramSize", " ramize", "memsize"], "initrd_base": ["initaddr_Base", "initrd2start", "initrend2size", "initrend2name", "initrb_count", "initrend_start", "initrd__base", "initrd__Base", "initrd__offset", "initrend_name", "initaddr_base", "initrd_Base", "initrd__size", "initrd2size", "initrb_base", "initrd2base", "initrd_start", "initrb_size", "initrend2base", "initaddr_bas", "initrd2name", "initrd_bas", "initrd_based", "initrd__bas", "initrd__count", "initrb_offset", "initaddr_based", "initrend_size", "initrd_count", "initrend2start", "initrd_offset", "initrd_name", "initrd__based", "initrend_base"], "initrd_size": ["initrd2width", "initrd67base", "initrd2size", "initrt_SIZE", "initrd67size", "initrd67name", "initrd2base", "initrb_base", "initrb_width", "initrb_size", "initrb_name", "initrd_SIZE", "initrt_name", "initrd2name", "initrd_string", "initrt_size", "initrt_string", "initrd67width", "initrd_name", "initrd_width"], "kernel_cmdline": ["kernel_mdstring", "kernel_callLine", "kernel_commandstring", "kernel_Cmdline", "kernel_Cmdstring", "kernel_CmdLine", "kernel_cmdLine", "kernel_mdLine", "kernel_cmdeline", "kernel_callline", "kernel_commandeline", "kernel_Cmdeline", "kernel_commandLine", "kernel_commandline", "kernel_cmdstring", "kernel_mdline", "kernel_calleline"], "fdt": ["fdp", "fint", "ddc", "dfo", "fdty", "dfwt", "formT", "dfn", "fmte", "formty", "pdp", "dfT", "dfp", "dlc", "bdts", "bdv", "fdc", "fdts", "tdt", "fdwt", "ddz", "ddt", "bdT", "dlT", "fdte", "bdt", "aftwt", "pdt", "fdn", "fdz", "ffT", "fmb", "fdT", "fft", "fdv", "ffts", "ff2", "ftte", "tdwt", "dlz", "finb", "dftr", "aftT", "fdtm", "ffty", "fdo", "fftm", "tdtr", "aftt", "dbt", "ffwt", "dfc", "dln", "dfv", "fmT", "pdtm", "dlv", "td2", "ffp", "tdo", "dfz", "df2", "dftm", "ddn", "ftb", "dbtr", "pdts", "fmt", "ftT", "dlt", "ftt", "finte", "dfts", "tdts", "finT", "tdT", "dbwt", "dlts", "formwt", "aftty", "formt", "dbo", "fd2", "dft", "fdtr", "fdb"], "mem_reg_property": ["mem_mem_property", "mem_reg_properties", "mem_mem_address", "mem_mem_properties", "mem_mem_attribute", "mem_mem_style", "mem_reg_prop", "mem_reg_attribute", "mem_reg_style", "mem_reg_address", "mem_mem_prop"], "filename": ["ren", "println", "FH", "n", "nl", "Filename", "ename", "json", "txt", "fil", "source", "file", "src", "family", "jl", "SourceFile", "f", "directory", "kj", "kl", "sbm", "knife", "png", "journal", "fn", "folder", "fle", "username", "path", "FIL", "there", "origin", "SOURCE", "fd", "buffer", "aka", "name", "prefix", "ln", "fp", "latest", "present", "location", "nil", "lua", "nm", "sql", "river", "tmp", "ames", "jpg", "ame", "gettable", "til", "rir", "existent", "files", "rn", "length", "FN"], "fdt_size": ["fdr_size", "fdr2Size", "fdt_count", "fdt2size", "fdT_len", "fdT_size", "fdT_Size", "fdr2count", "fdt_len", "fdr_name", "fdr2name", "fdr2size", "fdt2name", "fdt2Size", "fdr_Size", "fdt2len", "fdT_count", "fdt_name", "fdr_count", "fdt2count", "fdt_Size"], "ret": ["rev", "nt", "backed", "rem", "obj", "il", "n", "res", "tif", "result", "ert", "nz", "iter", "sat", "final", "ben", "del", "get", "ext", "val", "print", "ll", "rt", "net", "mem", "rets", "tn", "tr", "det", "mel", "reset", "elt", "cert", " Ret", "bool", "usr", "pas", "t", "Return", "len", "fun", "arr", "hash", "ft", "expr", "compl", "gt", "Ret", "out", "alf", "rm", "arg", "mt", "RET", "flag", "att", "def", "nil", "try", "resp", "cont", " RET", "back", "alt", "re", "desc", "j", "success", "err", "rect"], "dirp": ["_", "drawjp", "dn", "exec", "dialp", "dnp", "DIRsp", "dialn", "Dirpt", "threadd", "Dirp", "dirsp", "drd", "dird", "dialnp", "dirt", "func", "drawn", "ctl", "threadp", "DE", "Dird", "dirnp", "ds", "drawp", "drawnp", "dirn", "DIRp", "bd", " dird", "dialjp", "drsp", "threadpt", " dirpt", "Dirt", "fp", "def", "dirjp", "cont", "DIRd", "Dirsp", "dirpt", "ptr", "drt", "drp", "DIRt", "djp"], "dp": ["df", "dm", " d", "vp", "tp", "deb", "dep", "dn", "dd", " gp", "wp", "pa", "bp", "lp", "jp", "cd", "wd", "pipe", "dq", "pkg", "dt", "pas", "dc", "dir", "DC", "p", "ds", "pd", "dh", "DP", "d", "cp", "fp", "dr", "np", "pb", "dj", "ptr", "dl"], "buf": ["data", "cv", "obj", "text", "result", "db", "alph", "loop", "bar", " buffer", "seq", "buff", "cb", "b", "rb", "vec", "var", "pool", "block", "pkg", "bytes", "uf", "cat", "p", "str", "buffer", "queue", "cp", "bd", "pack", "rw", "window", "Buffer", "cur", "img", "Buff", "br", "row", "tmp", "cap", "wb", "desc", "batch", "pb", "msg", "font", "alloc", "err", "raw"]}}
{"project": "FFmpeg", "commit_id": "3a25c707fae3c6e99fdda40474c3d74be24cc4c3", "target": 0, "func": "static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = av_new_stream(c->fc, c->fc->nb_streams);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = CODEC_TYPE_DATA;\n\n    st->start_time = 0; /* XXX: check */\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if(sc->chunk_count && (!sc->stts_count || !sc->sample_to_chunk_sz ||\n\n                           (!sc->sample_size && !sc->sample_count))){\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        sc->sample_count = 0; //ignore track\n\n        return 0;\n\n    }\n\n    if(!sc->time_rate)\n\n        sc->time_rate=1;\n\n    if(!sc->time_scale)\n\n        sc->time_scale= c->time_scale;\n\n    av_set_pts_info(st, 64, sc->time_rate, sc->time_scale);\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_AUDIO &&\n\n        !st->codec->frame_size && sc->stts_count == 1)\n\n        st->codec->frame_size = av_rescale(sc->time_rate, st->codec->sample_rate, sc->time_scale);\n\n\n\n    if(st->duration != AV_NOPTS_VALUE){\n\n        assert(st->duration % sc->time_rate == 0);\n\n        st->duration /= sc->time_rate;\n\n    }\n\n    sc->ffindex = st->index;\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR, \"stream %d, error opening file %s: %s\\n\",\n\n                   st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));\n\n    } else\n\n        sc->pb = c->fc->pb;\n\n\n\n    switch (st->codec->codec_id) {\n\n#ifdef CONFIG_H261_DECODER\n\n    case CODEC_ID_H261:\n\n#endif\n\n#ifdef CONFIG_H263_DECODER\n\n    case CODEC_ID_H263:\n\n#endif\n\n#ifdef CONFIG_MPEG4_DECODER\n\n    case CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width= 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n#ifdef CONFIG_VORBIS_DECODER\n\n    case CODEC_ID_VORBIS:\n\n#endif\n\n        st->codec->sample_rate= 0; /* let decoder init parameters properly */\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->sample_to_chunk);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n\n\n    return 0;\n\n}\n", "idx": 27272, "substitutes": {"c": ["v", "cache", "pc", "cv", "cam", "co", "gc", "oc", "anc", "f", "config", "ce", "cb", "lc", "b", "ci", "mc", "fc", "cor", "can", "cr", "xc", "bc", "dc", "cs", "t", "cu", "this", "ac", "uc", "ec", "abc", "p", "m", "e", "chain", "g", "cc", "cf", "ct", "call", "cp", "icc", "C", "con", "cur", "rc", "l", "cont", "conf", "tc", "vc", "etc", "nc", "enc", "ctx"], "pb": ["cv", "pc", "vp", "tp", "bp", "pa", "wp", "ub", "lp", "sp", "lb", "jp", "client", "phys", "pro", "pl", "ob", "cb", "rb", "b", "fc", "pp", "pkg", "eb", "pg", "func", "bc", "gb", "dc", "uf", "mp", "sb", "bps", "ec", "p", "bh", "bb", "cp", "px", "nb", "fb", "ab", "fp", "conf", "np", "tc", "amp", "tk", "wb", "buf", "proc", "cm", "PB", "ctx"], "atom": ["xml", "ap", "ext", "ot", "typ", "comp", "om", "config", "item", "op", "tg", "ym", "attr", "ag", "at", "tem", " term", "t", " om", "oms", "other", "tm", "chem", "m", "p", "com", "name", "from", "atomic", "tom", " tem", " com", "orm", "tmp", "mat", "tc", "tar", "msg", "prop", "ata", "term", " exc", " plat", "raw"], "st": ["sv", "obj", "stop", "th", "src", "ut", "net", "store", "loc", "elt", "kt", "pres", " est", "so", "nd", "ost", "stat", "ste", "set", "ust", "nt", "first", "ist", "ast", "inst", "td", "stan", "ts", "se", "usr", "std", "sh", "ft", "sth", "str", "stra", "ct", "sts", "start", "desc", "rest", "et", "ST", "St", "tt", "rt", "step", "art", "stage", "must", "mt", "cont", "tmp", "sta", "sn", "test", "cl", "sp", "at", "put", "t", "sec", "pt", "sl", "irst", "dist", "sw", "storage", "stable", "it", "est"], "sc": ["sv", "isc", "zero", "anc", "src", "mic", " subsc", "mc", "ctl", "uc", "ec", "scl", "osc", "cer", "Sc", "usc", "disc", "nc", "pc", "gc", "tch", "asc", "lc", "capt", "ci", "fc", "psc", "cu", "dc", "SC", "scrib", "sh", "ct", "sic", "sch", "desc", "ctrl", "ctx", "ca", "cv", "acc", "cam", "ser", "scale", "sche", "sac", "ss", "spec", "cs", "cgi", "icc", "decl", "must", "sync", "rc", "cont", "proc", "sq", "enc", "cl", "cmp", "co", "cas", "cons", "sp", "cle", "cr", "squ", "bc", "sec", "mp", "ok", "cc", "sw", "esc", "ka", "soc", "tc", "scope", "sci", "ch"], "ret": [" fut", "rev", "nt", "v", "rem", "res", "virtual", "result", "ter", "red", "ral", " alt", "val", "print", "ll", "rt", "tf", "net", "rets", "mem", "det", "r", "reset", "bit", "elt", "reg", " Ret", "at", "t", "len", "ref", "ft", "gt", "status", "Ret", "out", "inter", "not", "mt", "fit", "RET", "value", "def", "try", "resp", "ber", "back", "alt", "re", "it"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libschroedinger_encode_init(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroVideoFormatEnum preset;\n\n\n\n    /* Initialize the libraries that libschroedinger depends on. */\n\n    schro_init();\n\n\n\n    /* Create an encoder object. */\n\n    p_schro_params->encoder = schro_encoder_new();\n\n\n\n    if (!p_schro_params->encoder) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unrecoverable Error: schro_encoder_new failed. \");\n\n        return -1;\n\n    }\n\n\n\n    /* Initialize the format. */\n\n    preset = ff_get_schro_video_format_preset(avctx);\n\n    p_schro_params->format =\n\n                    schro_encoder_get_video_format(p_schro_params->encoder);\n\n    schro_video_format_set_std_video_format(p_schro_params->format, preset);\n\n    p_schro_params->format->width  = avctx->width;\n\n    p_schro_params->format->height = avctx->height;\n\n\n\n    if (set_chroma_format(avctx) == -1)\n\n        return -1;\n\n\n\n    if (avctx->color_primaries == AVCOL_PRI_BT709) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_HDTV;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_625;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_525;\n\n    }\n\n\n\n    if (avctx->colorspace == AVCOL_SPC_BT709) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_HDTV;\n\n    } else if (avctx->colorspace == AVCOL_SPC_BT470BG) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_SDTV;\n\n    }\n\n\n\n    if (avctx->color_trc == AVCOL_TRC_BT709) {\n\n        p_schro_params->format->transfer_function = SCHRO_TRANSFER_CHAR_TV_GAMMA;\n\n    }\n\n\n\n    if (ff_get_schro_frame_format(p_schro_params->format->chroma_format,\n\n                                  &p_schro_params->frame_format) == -1) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This codec currently supports only planar YUV 4:2:0, 4:2:2\"\n\n               \" and 4:4:4 formats.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p_schro_params->format->frame_rate_numerator   = avctx->time_base.den;\n\n    p_schro_params->format->frame_rate_denominator = avctx->time_base.num;\n\n\n\n    p_schro_params->frame_size = avpicture_get_size(avctx->pix_fmt,\n\n                                                    avctx->width,\n\n                                                    avctx->height);\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (!avctx->gop_size) {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"gop_structure\",\n\n                                         SCHRO_ENCODER_GOP_INTRA_ONLY);\n\n\n\n        if (avctx->coder_type == FF_CODER_TYPE_VLC)\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"enable_noarith\", 1);\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"au_distance\", avctx->gop_size);\n\n        avctx->has_b_frames = 1;\n\n        p_schro_params->dts = -1;\n\n    }\n\n\n\n    /* FIXME - Need to handle SCHRO_ENCODER_RATE_CONTROL_LOW_DELAY. */\n\n    if (avctx->flags & CODEC_FLAG_QSCALE) {\n\n        if (!avctx->global_quality) {\n\n            /* lossless coding */\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_LOSSLESS);\n\n        } else {\n\n            int quality;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_CONSTANT_QUALITY);\n\n\n\n            quality = avctx->global_quality / FF_QP2LAMBDA;\n\n            if (quality > 10)\n\n                quality = 10;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"quality\", quality);\n\n        }\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"rate_control\",\n\n                                         SCHRO_ENCODER_RATE_CONTROL_CONSTANT_BITRATE);\n\n\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"bitrate\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_INTERLACED_ME)\n\n        /* All material can be coded as interlaced or progressive\n\n           irrespective of the type of source material. */\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"interlaced_coding\", 1);\n\n\n\n    schro_encoder_setting_set_double(p_schro_params->encoder, \"open_gop\",\n\n                                     !(avctx->flags & CODEC_FLAG_CLOSED_GOP));\n\n\n\n    /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger\n\n     * and libdirac support other bit-depth data. */\n\n    schro_video_format_set_std_signal_range(p_schro_params->format,\n\n                                            SCHRO_SIGNAL_RANGE_8BIT_VIDEO);\n\n\n\n    /* Set the encoder format. */\n\n    schro_encoder_set_video_format(p_schro_params->encoder,\n\n                                   p_schro_params->format);\n\n\n\n    /* Set the debug level. */\n\n    schro_debug_set_level(avctx->debug);\n\n\n\n    schro_encoder_start(p_schro_params->encoder);\n\n\n\n    /* Initialize the encoded frame queue. */\n\n    ff_schro_queue_init(&p_schro_params->enc_frame_queue);\n\n    return 0;\n\n}\n", "idx": 27296, "substitutes": {"avctx": ["avercci", "wavconn", "avepkg", " avcmd", "uvContext", " avca", " avcci", "AVcontext", "wavpkg", "avsrc", "avxc", "avecp", "uvcontext", "navcf", "avecontext", "avercp", "navnp", " avkj", "avmsg", "avstat", " avstat", "averstat", "avertx", "navqt", "averxc", "avermsg", "averpkg", "wavkl", " avjp", "vrcontext", "avvoc", "avestat", "avkl", " avtx", "avca", "navvoc", "aversys", "avqt", "avetx", "navctx", "avemsg", "vrtx", "wavnp", "ajcontext", "avsys", "avcci", "wavsys", "wavcfg", "ajjp", "avtmp", "wavtx", "averconn", " avcontext", "navconfig", "avtx", "wavkt", "avekl", "uvjp", "averconfig", "wavcp", "wavctx", "avecf", " avContext", "avconfig", "avekj", "aveca", "avercontext", "avkj", "averca", " avxc", "avcontext", "verctx", "vrctx", "varqt", "avervoc", "avesys", "avjp", "avcmd", "navmsg", "avercmd", "avecmd", "averqt", "navtmp", "avpkg", "avconn", "vercontext", "varvoc", "vercfg", "navkt", "avcp", "aveconn", "avContext", "varctx", "avernp", "navkj", "avercfg", "avcf", "avecci", "avnp", "averctx", "AVtx", " avcfg", " avtmp", "navcfg", "vrtmp", "AVxc", "avetmp", "ajContext", "AVctx", "uvctx", "versrc", "aversrc", "avcfg", "avekt", "avercf", "avecfg", "navkl", "wavcontext", "avenp", "varconfig", "ajctx", " avcp", "navcontext", "avectx", " avsrc", "avkt"], "p_schro_params": ["p_schrob_param", "p_schrotparams", "p_schlo_params", "p_schroessparams", "p_schrowparams", "p_schro_caps", "p_schro_manager", "p_schrecingresources", "p_schrojams", "p_schrowspec", "p_schroitypoints", "p_schrob_settings", "p_schrotnames", "p_schled_caps", "p_schro__params", "p_schro2points", "p_schroingtypes", "p_schro_plugins", "p_schled_services", "p_schros_points", "p_schro__param", "p_schro__settings", "p_schro_pps", "p_schled_las", "p_schro_names", "p_schro_data", "p_schroingparams", "p_schrob_ams", "p_schlo_marks", "p_schrecingtypes", "p_schro_resources", "p_schrotplugins", "p_schros_params", "p_schlo_spec", "p_schro_spec", "p_schro_types", "p_schro_points", "p_schlo_args", "p_schlo_ams", "p_schrogresources", "p_schroingams", "p_schro_args", "p_schroaphfiles", "p_schroaphparams", "p_schro_marks", "p_schlo_settings", "p_schrob_params", "p_schrec_types", "p_schro_param", "p_schrotmarks", "p_schroingpps", "p_schro__ams", "p_schroingresources", "p_schros_ams", "p_schroessservices", "p_schroesslas", "p_schrojmanager", "p_schroesscaps", "p_schrecingparams", "p_schrec_params", "p_schro2data", "p_schro2args", "p_schrogparams", "p_schro2ams", "p_schro_las", "p_schrogtypes", "p_schroityams", "p_schrob_names", "p_schroaphmembers", "p_schroityargs", "p_schro_members", "p_schled_params", "p_schros_manager", "p_schro_ams", "p_schrojparams", "p_schrec_resources", "p_schrowmarks", "p_schro_settings", "p_schrob_marks", "p_schro_services", "p_schros_data", "p_schlo_members", "p_schro2params", "p_schrob_plugins", "p_schro_ports", "p_schlo_pps", "p_schlo_names", "p_schros_args", "p_schlo_files", "p_schlo_ports", "p_schro_files", "p_schroityparams"], "preset": ["PRESetter", "resset", "Presetter", "presentet", "prespect", "PRESset", " prespect", "resetter", "presetter", "reset", "presET", "PresET", "PRESET", "Presence", "PRESet", " presset", "resence", "presset", "respect", "presentetter", "presence", " presET", "presentence", "Prespect", "Preset", "resET", "Presset", "presentET"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311, "substitutes": {"system_memory": [" system2mem", "system_mem", "system_media", "system2mem", "system2media", "system2memory", " system2media", " system_mem", " system_media", " system2memory", " system2storage", "system2storage", "system_storage", " system_storage"], "base": ["ma", "data", "bas", "eta", "zero", " bases", "ases", "bp", "domain", "server", " Base", "bf", "f", "based", "mb", "b", "ase", "null", "address", "area", "space", "m", "p", "buffer", "name", "root", "Base", "bound", "os", "id", "size", "cpu", "memory", "h", "as", "sys", "stable", "bs", "re", "i", "x", "bal", "binding"], "txirq": ["hexirqi", "txirqu", "txpirQ", "txirquire", "rxrinqu", "txvirch", "txiterq", "txrinch", "xmirp", "txiterqi", "txiroqi", "txdrq", "txvirqu", "rxirch", "hexiterq", "txiterquire", "txiroquire", "txiroq", "xmirque", "hexirquest", "txvirQ", "txirquest", "txmirch", "txmirqi", "txrinq", "txirQ", "rxrinq", "txmirquire", "xmirq", "rxirqu", "txpirp", "txdrch", "txdrp", "hexiterquire", "xirq", "txmirque", "txirp", "txrinQ", "xirp", "hexirq", "txirque", "txpirqu", "rxrinch", "txrinqu", "xirch", "txiroquest", "txmirquest", "txiterquest", "hexirquire", "txpirch", "txirch", "hexiterquest", "xirque", "rxirQ", "rxrinQ", "txvirq", "txmirq", "hexiterqi", "txdrque", "xmirch", "txmirp", "txpirq", "txpirque", "txirqi"], "rxirq": ["rxiorqi", "rxibrqi", "rxiorreq", "lexirch", "fxirch", "rxiterch", "rxdrq", "lexpirqu", "lexirquest", "rxerquest", "rxirch", "rxiraqu", "uxirqq", "uxiorreq", "rxibrqq", "rxiorqq", "rxerch", "fxirq", "fxpirq", "rxiterp", "uxirreq", "rxpirql", "fxirp", "rxpirquest", "rxiorq", "rxpirch", "rxirach", "rxirql", "rxirqu", "rxirqi", "uxirqi", "rxdrch", "lexirq", "lexpirq", "rxerqu", "lexpirch", "rxkarreq", "rxpirp", "rxiraquest", "rxibrq", "fxpirp", "rxiterq", "uxirq", "rxkarqi", "rxiterql", "rxibrreq", "lexpirquest", "uxiorqq", "rxirreq", "rxkarqq", "uxiorqi", "rxkarq", "rxpirq", "rxpirqu", "fxpirql", "rxirp", "rxiraq", "fxpirch", "uxiorq", "rxirqq", "rxdrql", "rxdrp", "fxirql", "lexirqu", "rxirquest", "rxerq"], "dma": ["nna", "nmas", "ldmic", "mna", "mmic", "mMA", "ldna", "ldma", "nma", "dpa", "ldmas", "Dma", "dmic", " dmas", "Dmas", "mma", "DMA", " dna", " dMA", "npa", " dmic", " dpa", "dna", "mmas", "dMA", "dmas", "mpa"], "clk": ["blk", "clz", "CLkh", "CLk", "blks", " clz", "clks", " clkh", "blkh", "clkh", "CLz", " clks", "CLks", "blz"], "s": ["sv", "bits", "gs", "ms", "changes", "services", "sam", "details", "store", "b", "pers", "comments", "p", "e", "aws", "ls", "rs", "conf", "als", "i", "c", "stat", "uploads", "ps", "set", "w", "n", "sa", "ers", "fs", "params", "ns", "states", "ts", "has", "se", "less", "sb", "ins", "os", "a", "es", "ies", "vs", "stats", "sts", "ports", "settings", "args", "hs", "is", "ss", "r", "an", "spec", "cs", "ats", "space", "m", "comm", "ds", "l", "sm", "v", "js", "S", "qs", "t", "ims", "g", "sl", "tests", "sw", "h", "service", "bs", "its"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[subblock_no];\n\n    int c_off = part_sizes_w[block_type];\n\n\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n\n    if(subblock_no == 3)\n\n        c_off = -1;\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n", "idx": 27317, "substitutes": {"r": ["er", "v", "nr", "hr", "n", "res", "k", "sr", "result", "ur", "gr", "R", "rr", "rt", "f", "ar", "tr", "or", "rb", "b", "usr", "rd", "t", "this", "rg", "rf", "o", "p", "e", "m", "g", "d", "rar", "mr", "q", "rw", "rs", "h", "rc", "l", "dr", "br", "rer", "re", "c", "x", "resource", "ro", "kr", "err", "w"], "block_type": ["Block_type", "Block_index", "blockitytype", "block2name", "pixellettag", "pixel_mode", "blockitymode", "Block_no", "pixelletno", "pixel_tag", "blockTypeindex", "block_index", "blockletmode", "blockTypename", "blockitytag", "pixellettype", "block_name", "Block_name", "pixel_no", "blockTypetype", "block_no", "block_tag", "blocklettag", "blocklettype", "blockTypeno", "pixel_type", "block_mode", "block2type", "blockityno", "pixelletmode", "block2no", "blockletno", "block2index"], "subblock_no": ["subblock08no", "subblock_sha", "subblock_number", "subblock_nos", "subBlock_number", "subblock08nos", "subblock2number", "subblock2type", "subBlock_no", "subblock08number", "subblock_type", "subblock2no", "subblock08sha", "subblock_index", "subBlock_nos", "subblock2nos", "subblock_name", "subBlock_name", "subBlock_type"], "dmv_no": ["dmvjNO", "dmv_nos", "dmav_no", "dmv2nos", "dmav_pos", "dmvjnos", "dmvjpos", "dmv_pos", "dmv2pos", "dmvjno", "dmv_NO", "dmv2NO", "dmav_nos", "dmv2no", "dmav_NO"], "s": ["sv", "ears", "gs", "ms", "ses", "b", "https", "p", "aws", "ls", "rs", "sc", "conf", "als", "session", "c", "y", "ps", "w", "er", "n", "fs", "ns", "ts", "se", "ssl", "south", "less", "sb", "ins", "d", "u", "es", "os", "a", "ies", "vs", "stats", "sts", "settings", "hs", "is", "sr", "f", "ss", "z", "spec", "cs", "ats", "conv", "space", "times", "http", "m", "comm", "ds", "l", "sys", "sql", "sq", "sm", "v", "js", "S", "sp", "t", "ims", "o", "g", "sl", "sw", "h", "bs", "its", "xs", "x", "self"], "A": ["IA", "W", "ACT", "An", "AC", "All", "R", "S", "AB", "L", "GA", "EA", "EMA", "AAA", "UA", "Ar", "SA", "H", "LA", "Array", "AR", "Area", "CA", "At", "AV", "Alpha", "M", "AS", "AF", "ACE", "API", "HA", "AT", "BA", "G", "D", "AN", "NA", " AA", "ALL", "P", "JA", "T", "AA", "N", "AL", "ACC", "a", "As", "V", "Answer", " a", "K", "AU", "AP", "This", "AM", "I"], "B": ["BI", "Y", "CB", "BL", "J", "E", "R", "S", "L", "AB", "IB", "DB", "OB", "b", "F", "USB", "FB", "Chain", "BR", "VB", "BY", "M", "RB", "BU", "Bar", "BA", "G", "D", "Other", "BB", "Bs", "PB", "P", "T", "N", "BM", "BC", "BER", "BE", "NB", "Z", "Bytes", "LIB", "TB", "V", "Buffer", "OR", "WB", "Builder", "GB", "LB", "BT", "BF", "I"], "C": ["Y", "CB", "CE", "CON", "E", "CN", "R", "S", "L", "Cl", "X", "F", "Chain", "CA", "EC", "Code", "CNN", "M", "CV", "Cache", "DC", "G", "CL", "D", "YC", "LC", "CI", "P", "CG", "T", "N", "CM", "BC", "CU", "CW", "V", "CC", "Q", "CP", "Co", "c", "CR", "CT", "CS", "I"], "i": ["v", "ir", "in", "li", "ij", "f", "xi", "ai", "ci", "ii", "mi", "ic", "o", "m", "p", "h", "iu", "l", "iy", "ti", "ia", "x", "ik", "si", "bi", "I"], "j": ["v", "aj", "k", "n", "js", "J", "ij", "jp", "kj", "ji", "b", "z", "ii", "t", "je", "o", "m", "p", "jj", "g", "jump", "q", "jc", "l", "xy", "y", "ja"], "mx": ["ma", "ax", "ex", "xx", "nz", "ms", "ll", "wx", "km", "xi", "mu", "tx", "mn", "mk", "xc", "dx", "sk", "yx", "mm", "zx", "ml", "px", "MX", "nm", "xy", "ng", "xs", "yp", "kg"], "my": ["ma", "md", "mid", "ms", "me", "vm", "mn", "mk", "mc", "mis", "gm", "mi", "mp", "yy", "mm", "m", "wn", "ml", "ny", "py", "mr", "mt", "yo", "nm", "xy", "pm", "mb"]}}
