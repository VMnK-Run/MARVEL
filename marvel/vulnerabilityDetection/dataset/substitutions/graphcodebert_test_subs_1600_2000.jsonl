{"project": "qemu", "commit_id": "cca1af8c4d2ef6449fd61494ba2cb087b838011c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n\n                            int opc)\n\n{\n\n    int addr_regl, addr_reg1, addr_meml;\n\n    int data_regl, data_regh, data_reg1, data_reg2;\n\n    int mem_index, s_bits;\n\n#if defined(CONFIG_SOFTMMU)\n\n    void *label1_ptr, *label2_ptr;\n\n    int sp_args;\n\n#endif\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(CONFIG_SOFTMMU)\n\n    uint8_t *label3_ptr;\n\n# endif\n\n    int addr_regh, addr_reg2, addr_memh;\n\n#endif\n\n    data_regl = *args++;\n\n    if (opc == 3)\n\n        data_regh = *args++;\n\n    else\n\n        data_regh = 0;\n\n    addr_regl = *args++;\n\n#if TARGET_LONG_BITS == 64\n\n    addr_regh = *args++;\n\n#endif\n\n    mem_index = *args;\n\n    s_bits = opc & 3;\n\n\n\n    if (opc == 3) {\n\n#if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n        data_reg1 = data_regh;\n\n        data_reg2 = data_regl;\n\n#else\n\n        data_reg1 = data_regl;\n\n        data_reg2 = data_regh;\n\n#endif\n\n    } else {\n\n        data_reg1 = data_regl;\n\n        data_reg2 = 0;\n\n    }\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n    addr_reg1 = addr_regh;\n\n    addr_reg2 = addr_regl;\n\n    addr_memh = 0;\n\n    addr_meml = 4;\n\n# else\n\n    addr_reg1 = addr_regl;\n\n    addr_reg2 = addr_regh;\n\n    addr_memh = 4;\n\n    addr_meml = 0;\n\n# endif\n\n#else\n\n    addr_reg1 = addr_regl;\n\n    addr_meml = 0;\n\n#endif\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    tcg_out_opc_sa(s, OPC_SRL, TCG_REG_A0, addr_regl, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_imm(s, OPC_ANDI, TCG_REG_A0, TCG_REG_A0, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_A0, TCG_REG_A0, TCG_AREG0);\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_meml);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T0, TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n    tcg_out_opc_reg(s, OPC_AND, TCG_REG_T0, TCG_REG_T0, addr_regl);\n\n\n\n# if TARGET_LONG_BITS == 64\n\n    label3_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BNE, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_memh);\n\n\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, addr_regh, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    reloc_pc16(label3_ptr, (tcg_target_long) s->code_ptr);\n\n# else\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n# endif\n\n\n\n    /* slow path */\n\n    sp_args = TCG_REG_A0;\n\n    tcg_out_mov(s, sp_args++, addr_reg1);\n\n# if TARGET_LONG_BITS == 64\n\n    tcg_out_mov(s, sp_args++, addr_reg2);\n\n# endif\n\n    tcg_out_movi(s, TCG_TYPE_I32, sp_args++, mem_index);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T9, (tcg_target_long)qemu_ld_helpers[s_bits]);\n\n    tcg_out_opc_reg(s, OPC_JALR, TCG_REG_RA, TCG_REG_T9, 0);\n\n    tcg_out_nop(s);\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xff);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 24);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 24);\n\n        break;\n\n    case 1:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xffff);\n\n        break;\n\n    case 1 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 16);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 16);\n\n        break;\n\n    case 2:\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    case 3:\n\n        tcg_out_mov(s, data_reg2, TCG_REG_V1);\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    label2_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO, 0);\n\n    tcg_out_nop(s);\n\n\n\n    /* label1: fast path */\n\n    reloc_pc16(label1_ptr, (tcg_target_long) s->code_ptr);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_V0, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addend) + addr_meml);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_V0, TCG_REG_V0, addr_regl);\n\n\n\n    addr_reg1 = TCG_REG_V0;\n\n#endif\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_LBU, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_imm(s, OPC_LB, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 1:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LHU, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 1 | 4:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n", "idx": 16352, "substitutes": {"s": ["sts", "g", "rs", "a", "c", "h", "sq", "js", "i", "os", "ss", "sc", "sg", "in", "ns", "session", "e", "ts", "m", "sys", "b", "ctx", "v", "n", "x", "ds", "ses", "w", "S", "gs", "cs", "ps", "t", "comm", "hs", "j", "p"], "args": ["GS", "bes", "ks", "bugs", "aws", "changes", "pointers", "ums", "xs", "limits", "js", "cats", "func", "ants", "values", "names", "params", "orders", "nets", "doc", "ns", "ims", "Args", "arms", "ags", "types", "arg", "arr", "ids", "actions", "ts", "bs", "members", "ctx", "parts", "aw", "icks", "ams", "ians", "fields", "axis", "md", "faces", "atts", "points", "qs", "ds", "vals", "ars", "flags", "gs", "gets", "keys", "results", "cs", "seconds", "blocks", "tags", "fs", "terms", "amps"], "opc": ["operc", "copuc", "ripfc", "OPc", "opsbc", "OPce", "operpc", "jpfc", "operuc", " opce", "opce", "ripco", "OPco", "opsf", "OPca", "copc", " opcs", "ripc", "copcs", "opsc", "jppc", "optpc", "opbc", "jpc", "copca", "opfc", "opco", "opersc", "oppc", "OPf", "coppc", "optf", "OPbc", "OPpc", "rippc", "OPcs", " opca", "oppuc", "jpco", "opca", "copce", "opcs", "opf", "copsc", "opppc", "optbc", "opspc", "oppsc", "optc", "OPfc", "opuc"], "addr_regl": ["addr_remli", "addr_randn", "addr_memle", "addr_romli", "addr_res2", "addr_legl", "addr_regli", "addr_gemh", "addr_mem2", "addr_rem1", "addr_res1", "addr_rem2", "addr_memb", "addr_memli", "addr_mod1", "addr_remL", "addr_memn", "addr_remn", "addr_geml", "addr_rand1", "addr_regle", "addr_gem1", "addr_legle", "addr_modl", "addr_regn", "addr_rom2", "addr_ren", "addr_re1", "addr_romL", "addr_randb", "addr_remle", "addr_leg2", "addr_mem1", "addr_roml", "addr_reml", "addr_gemle", "addr_regb", "addr_modL", "addr_regL", "addr_remb", "addr_rom1", "addr_resli", "addr_reL", "addr_legli", "addr_randl", "addr_memL", "addr_resl", "addr_rel"], "addr_reg1": ["addr_disc2", "addr_register1", "addr_register2", "addr_rm1", "addr_memn", "addr_reg9", "addr_mem0", "addr_disc9", "addr_mem9", "addr_addr1", "addr_group2", "addr_disc1", "addr_region2", "addr_rmn", "addr_disc0", "addr_reg0", "addr_REG1", "addr_addr2", "addr_rega", "addr_REG2", "addr_group1", "addr_regiona", "addr_REGone", "addr_rml", "addr_regone", "addr_mema", "addr_mem2", "addr_groupl", "addr_memone", "addr_REGa", "addr_registerl", "addr_registern", "addr_regionone", "addr_addrn", "addr_region1", "addr_addrl", "addr_groupn", "addr_regn", "addr_rm2", "addr_mem1"], "addr_meml": ["addr_sim1", "addr_histl", "addr_memory2", "addr_Mem2", "addr_memli", "addr_mod1", "addr_memory1", "addr_emh", "addr_siml", "addr_modh", "addr_liml", "addr_histh", "addr_modll", "addr_emli", "addr_limli", "addr_Memh", "addr_mem2", "addr_templ", "addr_temph", "addr_memo", "addr_memll", "addr_limh", "addr_simh", "addr_tempv", "addr_memv", "addr_memoryl", "addr_memoryll", "addr_memoryli", "addr_simll", "addr_memoryr", "addr_limo", "addr_memr", "addr_modl", "addr_Meml", "addr_Memli", "addr_memoryh", "addr_eml", "addr_histli", "addr_emr", "addr_hist2", "addr_limv", "addr_tempo", "addr_mem1", "addr_limr"], "data_regl": ["data_memle", "data_registerle", "data_winh", "data_rele", "data_reso", "data_regle", "data_REGo", "data_res2", "data1regl", "data_re2", "data_winyl", "data_rel", "data_register1", "data_mem2", "data_memo", "data_siml", "data_register2", "data_rands", "data_winl", "data_sim1", "data_registerL", "data_rego", "data1registerl", "data1register2", "data_regyl", "data_registero", "data_mem1", "data_REGl", "data_eg1", "data_mapl", "data_wins", "data_urg2", "data_egl", "data1registerL", "data_ego", "data_resls", "data1regle", "data1reg2", "data_mapyl", "data_urgls", "data_simel", "data_resl", "data_memel", "data_regs", "data1registerle", "data_registerl", "data_reL", "data_REG2", "data1regL", "data_eg2", "data_regL", "data_maph", "data_REGls", "data_urgo", "data_meml", "data_regel", "data_regls", "data_randl", "data_sim2", "data_urgl", "data_registerel", "data_randh", "data_randyl", "data_memL", "data_maps"], "data_regh": ["data__repr", "data_reeith", "data__cregh", "data_reshl", "data_crehl", "data_grepr", "data_rufl", "data_respr", "data_resgr", "data_arregh", "data_reehl", "data_resith", "data2grech", "data2gregr", "data2gregh", "data_ruch", "data_resht", "data2repr", "data_arrefl", "data__creht", "data_rugh", "data_crekr", "data_regr", "data_reegh", "data2rech", "data_cregr", "data_reht", "data__crepr", "data_arrech", "data_reith", "data2regr", "data_ruph", "data__reht", "data_recgr", "data_repr", "data2regh", "data_rupr", "data__regr", "data_gregr", "data_gregh", "data_crepr", "data_rech", "data_resch", "data_grech", "data_creht", "data_arrepr", "data_resfl", "data__regh", "data_refl", "data_creith", "data_rekr", "data_resph", "data_greph", "data_recpr", "data_reskr", "data__cregr", "data_recht", "data_rehl", "data_crech", "data_recgh", "data_resgh", "data_reekr", "data_reph", "data2grepr", "data_cregh"], "data_reg1": ["data_reg0", "data_rem1", "data_remone", "data_greg100", "data_res2", "data_memOne", "data_greg2", "data_loc1", "data_rom2", "data_locOne", "data_mem2", "data_res100", "data_memone", "data_regOne", "data_loc2", "data_resone", "data_rom1", "data_mem1", "data_leg2", "data_rm2", "data_rm1", "data_rmone", "data_rml", "data_greg1", "data_legone", "data_rm100", "data_roml", "data_rem2", "data_res1", "data_royOne", "data_leg1", "data_romone", "data_gregone", "data_rem0", "data_reg100", "data_meml", "data_roy2", "data_roy1", "data_mem0", "data_regone", "data_leg0"], "data_reg2": ["data_relTwo", "data_reg4", "data_regL", "data_REGL", "data_addr12", "data_regb", "data_addr2", "data_REG2", "data_loc2", "data_res3", "data_meml", "data_rem1", "data_remTwo", "data_memb", "data_re1", "data_res2", "data_rel1", "data_mem4", "data_re4", "data_locb", "data_mem1", "data_mem12", "data_re2", "data_loc1", "data_memTwo", "data_rem2", "data_rel2", "data_addr1", "data_res1", "data_reml", "data_loc12", "data_mem2", "data_addrb", "data_reg3", "data_re3", "data_rell", "data_mem3", "data_res4", "data_memL", "data_reL", "data_reg12", "data_REG1", "data_regTwo"], "mem_index": ["memmattype", "mem_ind", "mem_type", "Mem_size", " mem_pos", " mem_connect", "mem__ind", "memmatpos", "Mem_address", "mem__index", "mem2index", "mem_size", "mem_connect", "mem2address", " mem_type", "mem2size", "mem_pos", "mem2ind", "memmatconnect", "mem_address", "mem__address", "Mem_index", "Mem_ind", "mem__size", "memmatindex"], "s_bits": ["g_count", " s_flags", "s__bits", "s__flags", "g_flags", "s_bs", "s_count", " s_bs", "g_bits", "s_flags", "s__bs"], "label1_ptr": ["label3_tr", "label3_req", "label3_pt", "label3__pt", "label1_req", "label1__ptr", "label1__req", "label1__pt", "label3__tr", "label3__ptr", "label1_tr", "label1_pt", "label3__req", "label1__tr"], "label2_ptr": ["label3_tr", "label3_pointer", "label3_pt", "label2_pointer", "label2_tr", "label2_pt"], "sp_args": ["sh_pos", "sp_index", "sh__index", "sh__vals", "sp__index", "sh_index", "spallargs", "sp__vals", "sp__pos", "sp_pos", "spallvals", "sh_args", "sh__pos", "sh_vals", "spallpos", "spallindex", "sp_vals", "sh__args", "sp__args"], "label3_ptr": ["label3_pointer", "label3_pt", "label1_src", "label1_pointer", "label1_pt", "label3_src"], "addr_regh": ["addr_gregh", "addr_gregt", "addr_rouci", "addr_resci", "addr_preph", "addr_rouph", "addr_repr", "addr_reci", "addr_resgr", "addr_preci", "addr_auql", "addr_rergr", "addr_regr", "addr_resgt", "addr_respr", "addr_prepr", "addr_resql", "addr_resgo", "addr_cregr", "addr_reseth", "addr_rough", "addr_begt", "addr_auhl", "addr_rergh", "addr_rego", "addr_grehl", "addr_auph", "addr_pregh", "addr_roupr", "addr_resgh", "addr_grego", "addr_bego", "addr_greql", "addr_reeth", "addr_augh", "addr_greph", "addr_reph", "addr_resph", "addr_rerhl", "addr_creeth", "addr_reshl", "addr_begh", "addr_regt", "addr_rereth", "addr_beph", "addr_rehl", "addr_crehl", "addr_reql", "addr_cregh"], "addr_reg2": ["addr_reml", "addr_register1", "addr_leg1", "addr_register2", "addr_memtwo", "addr_store22", "addr_leg5", "addr_reg5", "addr_remj", "addr_mem22", "addr_storetwo", "addr_store2", "addr_leg4", "addr_reg4", "addr_register22", "addr_store1", "addr_mem2", "addr_rem1", "addr_memj", "addr_rem2", "addr_eg2", "addr_regj", "addr_eg1", "addr_mem5", "addr_reg22", "addr_egj", "addr_egl", "addr_registertwo", "addr_mem4", "addr_leg2", "addr_regtwo", "addr_mem1"], "addr_memh": ["addr_mapel", "addr_histl", "addr_mth", "addr_mtl", "addr_mindh", "addr_mbb", "addr_mindel", "addr_memoryol", "addr_map1", "addr_mind1", "addr_modh", "addr_mtb", "addr_memen", "addr_memol", "addr_memel", "addr_histh", "addr_memoryp", "addr_histol", "addr_maph", "addr_mapb", "addr_Memh", "addr_mindb", "addr_Memb", "addr_memoryl", "addr_mtp", "addr_moden", "addr_mbh", "addr_memp", "addr_mbel", "addr_modl", "addr_Meml", "addr_histen", "addr_memoryh", "addr_memoryb", "addr_memoryen", "addr_memb", "addr_modol", "addr_mb1", "addr_Memp", "addr_mem1"]}}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGLabel *lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                TCGLabel *lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_ctzi_tl(cpu_R[rd], cpu_R[ra], -1);\n\n            tcg_gen_addi_tl(cpu_R[rd], cpu_R[rd], 1);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_clzi_tl(cpu_R[rd], cpu_R[ra], TARGET_LONG_BITS);\n\n            tcg_gen_subfi_tl(cpu_R[rd], TARGET_LONG_BITS, cpu_R[rd]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 16360, "substitutes": {"dc": ["lc", "DC", "df", "cm", "disc", "td", "dl", "rc", "fc", "icc", "mc", "dt", "sc", "dat", "tc", "dm", "da", "pc", "nc", "cc", "xc", "bc", "oc", "ds", "ec", "di", "dp", "cd"], "insn": ["inn", "stsnc", "inspn", "psoln", "kssn", "INSpan", "attsoln", "vsne", "pinssn", "insns", "ksns", "kinsoln", "stsnr", "insgn", " insgn", "pinsne", "insoln", "atsne", "ainsnr", "ainsns", "tsgn", "intersnr", "statsne", " insne", "vssn", "pinspan", "tsns", "stsn", "intersn", "statsn", "attssn", "risoln", "kinssn", "kinsn", "interssn", "INSn", " inspn", "psno", "insnc", "rissn", "intnc", "retsno", "inssn", "tssn", "ainsgn", "psn", "atsgn", "atsn", "risnc", "statsgn", "retssn", "retsoln", "intsn", "kinsno", "retsn", " insns", "ingn", "intoln", "INSsn", "ainsn", "intersnc", " inssn", "attsn", "risn", "INSne", "intn", "tsn", "ksgn", "vsn", "inns", "insnr", "pssn", "insno", "ainssn", "pinsn", "ksn", "stssn", "vspan", "attsnc", "ainsnc", "inspan", "insne", "atspn", "statspn"], "op0": ["pop1", "hop0", "opt0", "OP5", "hop1", "oop1", "opt2", "pop2", "OP2", "oop50", "p1", "pop5", "p0", "pop0", "OP1", "OP0", "oop0", "op5", "hop5", "op50", "hop2", "opt50", " op50", "oop2"], "op1": ["cop01", " op01", "opOne", "cop3", "p01", "OP2", "Op6", " op3", "cop2", "p1", "op01", "Op1", "op3", "p3", "Op0", "OPOne", "OP3", "Op2", "OP1", "op6", "OpOne", "copOne", "p2", "cop0", "cop6", "Op3", "Op01", "cop1", " op6"], "op2": ["tip6", "ip5", "tip5", "oplet", "opt2", "tip2", "tip1", "iplet", "opt5", "ip1", "optlet", "ip2", "op6", "ip6", "op5", " op5", " op6", "opt1", " oplet"], "ra": ["RA", "rain", "from", "rf", "dra", "rs", "Ra", "a", "ta", "tra", "ri", "rum", "tar", "rx", "rc", "rar", "ring", "ras", "ro", "ata", "res", "loc", "rap", "ur", "da", "r", "aria", "ma", "era", "ora", "area", "rou", "po", "ina", "raf", "ar", "ru", "alpha", "au", "ba", "ran", "art", "rom", "dr", "cro", "stra", "sa", "la", "ara", "rn", "rise", "red"], "rb": ["rid", "lr", "rt", "nb", "rib", "bb", "hr", "rf", "rs", "mr", "vr", "ri", "wb", "fb", "rc", "rob", "rl", "rar", "ro", "rg", "RB", "pb", "rr", "cb", "sr", "r", "rw", "erb", "b", "reb", "sb", "raf", "ru", "rab", "db", "lb", "rub", "ob", "rn"], "rd": ["rid", "lr", "rt", "hr", "fd", "cr", "nder", "rf", "rs", "dra", "mr", "bd", "ri", "nd", "rh", "rx", "td", "rc", "rl", "rar", "rob", "pr", "fr", "ro", "rg", "rr", "ird", "r", "sr", "rat", "rw", "d", "RD", "dd", "raf", "ru", "dr", "rm", "ld", "rn", "cd", "red"], "lab": ["tmp", "ls", "lc", "px", "label", "box", "cell", "reg", "ub", "ox", "ref", "Lab", "LAB", "ind", "bus", "disc", "lit", "fc", "tab", "ab", "abb", "loc", "pb", " lb", "pl", "cb", "star", "l", "el", "local", " bab", " label", "hub", "xc", "val", "gb", "lb", "abel", "col", "lib", "ann", "els", "bl", "ob", " labels", "la", "sel", "cd"]}}
{"project": "qemu", "commit_id": "225d02cd1a34d5d87e8acefbf8e244a5d12f5f8c", "target": 1, "func": "int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n", "idx": 16365, "substitutes": {"timeout": ["blocking", "cache", "password", "shape", "duration", "event", "address", "table", "message", "time", "out", "print", "wait", "span", "timer", "status", "limit", "seconds", "OUT", "dt", "target", "client", "global", "total", "state", "period", "latest", "option", "directory", "unit", "tmp", "window", "to", "slot", "update", "delay", "service", "size", "port", "buffer", "version", "watch", "sleep", "history", "socket", "instance", "policy", "number", "resolution", "python", "ssl", "try", "alert", "type", "tt", "always", "lock", "Timeout", "note", "sequence", "height", "localhost", "value", "network", "call", "local", "missing", "data", "tv", "start", "t", "response"], "add": ["new", "extra", "pad", "sum", "attr", "ext", "end", "en", "pkg", "init", "update", "inc", "part", "a", "shift", "plus", "lat", "push", "post", "ad", "diff", "len", "amount", "acc", "pos", "del", "adding", "added", "sub", "build", "append", "cal", "att", "set", "check", "ac", "grow", "apply", "d", "num", "import", "ord", "attach", "Add", "total", "dd", "late", "mk", "alpha", "ADD", "save", "make", "addr", "dev", "mod", "AD", "adder", "step"], "delta": ["idummy", "felta", "dynam", "rata", "indelta", "fata", "dta", "adta", "sdta", "sdelta", "Dynam", "lynam", " delt", "drelta", "lta", "sdota", "Delt", "lelta", "lata", "relta", " dota", "drelt", "Delta", "adelt", "rota", "lelt", "lota", "relt", "drota", "indata", "sdelt", " dummy", "indummy", "dummy", "Data", " data", "idelt", "dota", "Dota", "fota", "adota", "data", "drynam", "indelt", "delt", "indota", "adelta", "felt", "idelta"]}}
{"project": "FFmpeg", "commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "target": 1, "func": "static int ftp_abort(URLContext *h)\n\n{\n\n    static const char *command = \"ABOR\\r\\n\";\n\n    int err;\n\n    static const int abor_codes[] = {225, 226, 0};\n\n    FTPContext *s = h->priv_data;\n\n\n\n    /* According to RCF 959:\n\n       \"ABOR command tells the server to abort the previous FTP\n\n       service command and any associated transfer of data.\"\n\n\n\n       There are FTP server implementations that don't response\n\n       to any commands during data transfer in passive mode (including ABOR).\n\n\n\n       This implementation closes data connection by force.\n\n    */\n\n\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n\n        ftp_close_both_connections(s);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    } else {\n\n        ftp_close_data_connection(s);\n\n    }\n\n\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n\n        /* wu-ftpd also closes control connection after data connection closing */\n\n        ffurl_closep(&s->conn_control);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16370, "substitutes": {"h": ["ih", "ht", "bh", "th", "host", "hw", "hd", "hh", "H", "c", "rh", "hal", "eh", "he", "hu", "sh", "hz", "handle", "hm", "oh", "ah", "l", "dh", "m", "here", "ph", "b", "v", "kh", "k", "hl", "history", "x", "http", "w", "hp", "it", "her", "hi", "zh", "t", "hash", "hs", "p"], "command": ["program", " Command", "action", "execute", "connection", "method", "reason", "channel", "content", "service", "password", "buffer", "error", "attribute", "pattern", "event", "power", "argument", "address", "function", "sequence", "request", "message", "value", "call", "mode", "template", "history", "Command", "comment", "description", "cmd", "control", "data", "communication", "controller", "character", "operation", "response"], "err": ["kr", "lr", "Error", "ok", "attr", "cr", "br", "later", "er", "mr", "fer", "c", "fee", "nr", "cer", "test", "iter", "oe", "js", "i", "Er", "pr", "warn", "fr", "error", "doc", "elt", "cb", "rr", "actor", "arr", "r", "gr", "buf", "my", "sys", " terr", "here", "off", "txt", "v", "n", "gz", "out", "code", "cert", "ev", "state", "late", "str", "trace", "notice", "ner", "msg", "dr", "raw", "try", "plain", "usr", "die", "ptr", "t", "conf", "cfg", "rn", "z", "cor"], "abor_codes": ["gob_codes", "abor2codes", "abor2code", "abor_names", "gob_code", "abor_code", "gob_names", "ab_names", "ab_code", "abor2odes", "ab_codes", "ab_odes", "abor_odes", "abor2names", "gob_odes"], "s": ["ls", "is", "sl", "sts", "sv", "rs", "g", "aws", "a", "c", "sq", "sm", "hs", "js", "self", "q", "os", "ss", "sc", "y", "ns", "r", "l", "ts", "sys", "sp", "es", "b", "v", "n", "has", "sb", "stats", "ds", "qs", "w", "S", "gs", "ssl", "cs", "ps", "t", "sh", "z", "j", "p"]}}
{"project": "FFmpeg", "commit_id": "a4fec9a7eab842ea5eea1b1ee98624356cb31422", "target": 1, "func": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n    written++;\n    channel_id = hdr & 0x3F;\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       return AVERROR(EAGAIN);\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;", "idx": 16385, "substitutes": {"h": ["f", "ih", "hr", "window", "ht", "bh", "th", "g", "cache", "conn", "host", "hw", "hh", "H", "c", "rh", "uh", "hs", "hal", "q", "eh", "he", "hz", "handle", "r", "hm", "ah", "oh", "l", "dh", "m", "here", "ph", "b", "v", "k", "kh", "hl", "history", "s", "html", "http", "w", "hp", "hi", "zh", "ch", "t", "hash", "sh", "each"], "p": ["f", "g", "pkg", "P", "fp", "jp", "a", "c", "q", "cp", "pp", "np", "pb", "r", "lp", "pc", "wp", "m", "d", "b", "v", "n", "o", "pa", "x", "w", "t", "j"], "chunk_size": ["chunkedsize", "chunk_count", "chunkedlength", "chacket_SIZE", "chunk_length", "chunkedcount", "chacket_length", "chacket_size", "chacket_count", "chunkedSIZE", "chunk_SIZE"], "prev_pkt_ptr": ["prev_pkg2tr", "prev_pkg_tr", "prev_pkt_obj", "prev_pkg_ptr", "prev_pkt2obj", "prev_pck_ptr", "prev_pkt_addr", "prev_pkg2ptr", "prev_pkt_pad", "prev_pkt_req", "prev_pkg_req", "prev_pck_obj", "prev_pkt_pt", "prev_pck_addr", "prev_pkg_pt", "prev_pkt_Ptr", "prev_pkg2obj", "prev_pkg_obj", "prev_pkt2ptr", "prev_pkt_tr", "prev_pkt2pad", "prev_pkg_pad", "prev_pkg2pad", "prev_pkt2tr", "prev_pck_Ptr"], "nb_prev_pkt": ["nb_prev_npacket", "nb_prev_npck", "nb_prev_Pkt", "nb_prev_nacket", "nb_prev_pnt", "nb_prev_npnt", "nb_prev_Packet", "nb_prev2pnt", "nb_prev_ipck", "nb_prev_Pck", "nb_prev2pkt", "nb_prev2npnt", "nb_prev_nck", "nb_prev_ipkt", "nb_prev_Pnt", "nb_prev2packet", "nb_prev_pck", "nb_prev_packet", "nb_prev_nnt", "nb_prev2npck", "nb_prev2pck", "nb_prev_ipnt", "nb_prev_nkt", "nb_prev2npacket", "nb_prev_ipacket", "nb_prev2npkt", "nb_prev_npkt"], "hdr": ["ihdr", "thheader", "Hheader", "tgt", "khpar", "ihDR", "ahrs", "hmt", "whdr", "dhdr", "phdr", "thmt", "Hmt", "thdr", "phpar", "wgt", "Hpar", " hrd", "ohbr", "wrid", " hld", "whDR", "wrd", "ihrs", "ahdr", "hgt", "trd", "phDR", "hDR", "khdr", "wdr", " hrc", "hrs", "ahbr", "hrid", " hDR", "hbr", "hpar", "ihrc", "Hbr", "hhdr", " hrs", " hdc", "dhld", "ahDR", "phbr", "Hdr", "hrc", " hbr", "ohDR", "thDR", "hdc", "ohdr", "hrd", "HDR", "ohrc", "trid", "hhDR", " hrid", " hgt", "ohrs", "whld", "tdr", "khbr", "hheader", "hhheader", "hhmt", "hld", "dhdc", "dhDR", "whdc", "khDR"], "buf": ["prop", "cv", "block", "bh", "box", "cache", "vec", "etc", "bag", "read", "pb", "ctx", "var", "req", "mem", "buff", "proc", "extra", "act", "br", "tx", "iter", "bar", "fb", "Buff", "cp", "rb", "pos", "obj", "cb", "cmd", "pg", "msg", "bl", "usr", "og", "que", "tmp", "window", "ext", "pkg", "err", "good", "port", "buffer", "cap", "conv", "loc", "orig", "resp", "ah", "BU", "kw", "txt", "uf", "desc", "next", "cur", "seq", "fw", "pool", "raw", "ptr", "comm", "bs", "batch", "ref", "ctr", "wb", "func", "Buffer", "bytes", "doc", "img", "pause", "rw", "b", "gz", "late", "str", "data", "addr", "bu", "queue", "foo"], "channel_id": [" channel_key", "char_id", " channel_Id", "shortityid", "channel_no", "channel___ident", "channelityuid", "channel2no", " channel_mid", "channelIpart", "character_status", "channelIDid", "channel___id", " channel_str", "channel_side", "channelityiden", "channelitypid", "channelIDident", "channelIdi", "filter_link", "channelIDorig", "short_id", "channel_part", "channelIDdb", "channel_db", "channelIId", " channel_i", "character_Id", "channel5id", "shortityID", " channel_side", "channel___info", "channel_type", "channelIstatus", "channelIDID", "channelitycode", "channel2id", "channelNamestr", "channel_pid", "character_pid", "channelityident", "character_part", "channel_link", " channel_type", "filter_orig", "channelityId", "channel_i", "channel5tag", "channelIDuid", "channel_info", "channel_key", " channel_db", "short_ID", " channel_code", "channel_ID", "channelityID", "channelNameside", "filter_id", "channel_mid", "channel_code", " channel_ident", "channelIDiden", "channelIdid", " channel_info", "short_uid", "channel_status", "character_id", "channel_iden", "char_tag", "channelIdinfo", "channelIDlink", "channel_ident", "channel_Id", "channelNameid", "channel_tag", "channel2info", "character_side", " channel_no", "channel2i", "channel_uid", "channelIid", "channelNamemid", "channel5link", "channelityside", "channelityid", "channelIdno", "channel_str", "shortityuid", "shortityiden", "short_iden", "channel_orig", "character_ident", "char_link"], "timestamp": ["simetime", "timeetime", "timetime", "extestamp", "simestamp", "timeability", "timtime", "extetime", "simtime", "timeestamp", "exttime", "timability", "simability", "extability"], "size": ["extra", "length", "sum", "zone", "offset", "sn", "speed", "info", "sent", "shape", "name", "buffer", "SIZE", "scale", "dim", "len", "ize", "bytes", " sizes", "max", "address", "height", "small", "summary", "id", "time", "total", "space", "s", "Size", "send", "course", "changed", "description", "empty", "notice", "data", "capacity", "count", "storage", "general", "number", "resolution", "sized", "timeout"], "ts_field": ["tsityid", "its_table", "TS_value", "tsistlabel", "tsityfield", "tsxtype", "tslistfield", "TS_field", "tsitytype", "itslistfield", "tsettag", "ts_tag", "tslisttable", "ts_option", "ats_option", "ts___fields", "TS_fields", "tsetfields", "ts___value", "tsitytable", "tsetfield", "ts_bit", "its_field", "its_type", "itslisttype", "tsxfield", "ats_field", "its_id", "itslisttable", "tsistField", "ats_Field", "TS_tag", "ts_fields", "tslisttype", "ts_table", "tsxtable", "ts_label", "ts_Field", "tslistid", "tsetvalue", "ts___tag", "ats_label", "ats_bit", "ts_value", "ts_id", "ats_fields", "itslistid", "ts___field", "tsxid", "tsistfields", "tsistfield", "ts_type"], "type": ["extra", " kind", "length", "offset", "action", "ype", "what", " ty", "test", "oe", " typ", "info", "role", "term", "style", "shape", "error", "like", "version", "ime", "event", "class", " t", "kind", "ver", "types", "spec", " error", "date", "id", "ping", "owner", "time", "other", "total", "ty", "TYPE", "state", "description", " family", "where", "trace", "key", " types", "file", "status", "format", "relation", "pe", "typ", "tag", "scope", "field", "t", "Type", "tp", "name"], "ret": ["rt", "extra", "gt", "ref", "final", "result", "not", "lit", "rem", "def", "len", "tr", "res", "elt", "read", "obj", "ll", "re", "r", "got", "resp", "rev", "Ret", "RET", "tf", "value", "ern", "txt", "back", "out", "ft", " Ret", "reset", "val", "rets", "alt", "mem", "status", "dr", "it", "nt", "aux", "try", "mt", "ptr", "il", "t", "red", "ry"], "toread": ["tourady", "toresade", "ntoready", "ntoread", "torstad", "toresady", "tournd", "tourade", "torstady", "ntorstad", "tourad", "torstade", "toresad", "toreade", "torend", "ntorend", "ntorstade", "toready", "toresnd", "torstnd", "ntorstady", "ntorstnd", "ntoreade"], "prev_pkt": ["prev_peacket", "prev_bptx", "prev_ptx", "prev_rkg", "prev_Pnt", "prev_ckt", "prev_iptx", "prev_compqt", "prev_plet", "prev_packlet", "prev_cacket", "prev_pact", "prev_cpacket", "prev_packkt", "prev_cet", "prev_Pmsg", "prev_cpqt", "prev_packdt", "prev_packwk", "prev_pmsg", "prev_rwk", "prev_wett", "prev_ipkt", "prev_pekt", "prev_cpet", "prev_rqt", "prev_pelt", "prev_Pet", "prev_Pelt", "prev_compkt", "prev_cpkt", "prev_ipacket", "prev_Packet", "prev_bpdu", "prev_pkg", "prev_ipelt", "prev_peulse", "prev_compkg", "prev_iplet", "prev_pwk", "prev_ract", "prev_ret", "prev_pett", "prev_pnt", "prev_peelt", "prev_cpkg", "prev_bplet", "prev_wacket", "prev_packact", "prev_cpnt", "prev_nmsg", "prev_pqt", "prev_Pulse", "prev_cpmsg", "prev_wkt", "prev_ipulse", "prev_nnt", "prev_nacket", "prev_cett", "prev_Pett", "prev_wet", "prev_nkt", "prev_pet", "prev_packdu", "prev_ipdu", "prev_rdt", "prev_bpkt", "prev_packtx", "prev_pdu", "prev_pulse", "prev_compet", "prev_rkt", "prev_packet", "prev_Pkt", "prev_pdt"], "written": ["linked", "done", "played", "en", "itted", "connected", "ended", "loaded", "ritten", "led", "recorded", "readable", "sent", "built", "len", "documented", "bytes", "read", "balanced", "called", "finished", "wat", "reported", "checked", "held", "numbered", "num", "adjusted", "broken", "rawn", "rew", "started", "writer", "Written", "n", "out", "made", "packed", "future", "writ", "writing", "changed", "used", "count", "write", "wrote", "encrypted", "stretched", "output", "number", "initialized", "w", "said", "ordered", "printed", "hidden", "created", "updated", "generated"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "void eeprom93xx_write(eeprom_t *eeprom, int eecs, int eesk, int eedi)\n\n{\n\n    uint8_t tick = eeprom->tick;\n\n    uint8_t eedo = eeprom->eedo;\n\n    uint16_t address = eeprom->address;\n\n    uint8_t command = eeprom->command;\n\n\n\n    logout(\"CS=%u SK=%u DI=%u DO=%u, tick = %u\\n\",\n\n           eecs, eesk, eedi, eedo, tick);\n\n\n\n    if (! eeprom->eecs && eecs) {\n\n        /* Start chip select cycle. */\n\n        logout(\"Cycle start, waiting for 1st start bit (0)\\n\");\n\n        tick = 0;\n\n        command = 0x0;\n\n        address = 0x0;\n\n    } else if (eeprom->eecs && ! eecs) {\n\n        /* End chip select cycle. This triggers write / erase. */\n\n        if (eeprom->writable) {\n\n            uint8_t subcommand = address >> (eeprom->addrbits - 2);\n\n            if (command == 0 && subcommand == 2) {\n\n                /* Erase all. */\n\n                for (address = 0; address < eeprom->size; address++) {\n\n                    eeprom->contents[address] = 0xffff;\n\n                }\n\n            } else if (command == 3) {\n\n                /* Erase word. */\n\n                eeprom->contents[address] = 0xffff;\n\n            } else if (tick >= 2 + 2 + eeprom->addrbits + 16) {\n\n                if (command == 1) {\n\n                    /* Write word. */\n\n                    eeprom->contents[address] &= eeprom->data;\n\n                } else if (command == 0 && subcommand == 1) {\n\n                    /* Write all. */\n\n                    for (address = 0; address < eeprom->size; address++) {\n\n                        eeprom->contents[address] &= eeprom->data;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        /* Output DO is tristate, read results in 1. */\n\n        eedo = 1;\n\n    } else if (eecs && ! eeprom->eesk && eesk) {\n\n        /* Raising edge of clock shifts data in. */\n\n        if (tick == 0) {\n\n            /* Wait for 1st start bit. */\n\n            if (eedi == 0) {\n\n                logout(\"Got correct 1st start bit, waiting for 2nd start bit (1)\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"wrong 1st start bit (is 1, should be 0)\\n\");\n\n                tick = 2;\n\n                //~ assert(!\"wrong start bit\");\n\n            }\n\n        } else if (tick == 1) {\n\n            /* Wait for 2nd start bit. */\n\n            if (eedi != 0) {\n\n                logout(\"Got correct 2nd start bit, getting command + address\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"1st start bit is longer than needed\\n\");\n\n            }\n\n        } else if (tick < 2 + 2) {\n\n            /* Got 2 start bits, transfer 2 opcode bits. */\n\n            tick++;\n\n            command <<= 1;\n\n            if (eedi) {\n\n                command += 1;\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits) {\n\n            /* Got 2 start bits and 2 opcode bits, transfer all address bits. */\n\n            tick++;\n\n            address = ((address << 1) | eedi);\n\n            if (tick == 2 + 2 + eeprom->addrbits) {\n\n                logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\",\n\n                       opstring[command], address, eeprom->contents[address]);\n\n                if (command == 2) {\n\n                    eedo = 0;\n\n                }\n\n                address = address % eeprom->size;\n\n                if (command == 0) {\n\n                    /* Command code in upper 2 bits of address. */\n\n                    switch (address >> (eeprom->addrbits - 2)) {\n\n                        case 0:\n\n                            logout(\"write disable command\\n\");\n\n                            eeprom->writable = 0;\n\n                            break;\n\n                        case 1:\n\n                            logout(\"write all command\\n\");\n\n                            break;\n\n                        case 2:\n\n                            logout(\"erase all command\\n\");\n\n                            break;\n\n                        case 3:\n\n                            logout(\"write enable command\\n\");\n\n                            eeprom->writable = 1;\n\n                            break;\n\n                    }\n\n                } else {\n\n                    /* Read, write or erase word. */\n\n                    eeprom->data = eeprom->contents[address];\n\n                }\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {\n\n            /* Transfer 16 data bits. */\n\n            tick++;\n\n            if (command == 2) {\n\n                /* Read word. */\n\n                eedo = ((eeprom->data & 0x8000) != 0);\n\n            }\n\n            eeprom->data <<= 1;\n\n            eeprom->data += eedi;\n\n        } else {\n\n            logout(\"additional unneeded tick, not processed\\n\");\n\n        }\n\n    }\n\n    /* Save status of EEPROM. */\n\n    eeprom->tick = tick;\n\n    eeprom->eecs = eecs;\n\n    eeprom->eesk = eesk;\n\n    eeprom->eedo = eedo;\n\n    eeprom->address = address;\n\n    eeprom->command = command;\n\n}\n", "idx": 16406, "substitutes": {"eeprom": ["eimprim", "edeprom", "edepdom", "eiprim", "eegprom", "eEPchrom", "peppcom", "eypcm", "eperom", "seyproc", "neepercm", "eepsrom", "seeeprom", "eepom", "eppprom", "seEPprom", "edeprim", "eepcom", "eebprom", "seepchrom", "seEProm", "eeepom", "eepprom", "eoprome", "eegdom", "eemrom", "seyprum", "epprom", "eiprem", "eepron", "seeprum", "eeeprim", "esegrom", "edegrom", "peepram", "seepram", "eypprom", "peekrom", "esegrim", "ieecrom", "eepsrim", "peekprom", "neeperprom", "zeeprom", "eepsrum", "eiprom", "meecrom", "eekrim", "zeesprom", "eeperrum", "peepcm", "ieEProm", "eekrum", "eekcm", "eyprom", "eimprem", "eecprom", "eegrem", "peepsrom", "ieecrim", "eseprem", "eeekrom", "eipram", "neepcm", "meepom", "eypom", "peeprom", "eemrome", "eyprim", "eemcm", "seiprom", "eepram", "eaperum", "eeprim", "esegrem", "erepom", "ieecarm", "eecom", "eespchrom", "edegdom", "eeperron", "eebrom", "eeyprom", "eekram", "jeethrim", "eiprome", "seyprim", "seyprom", "eeperprom", "eegrom", "eecchrom", "eEPdem", "eegchrom", "eypchrom", "eeeplam", "eimproc", "eebchrom", "ieecchrom", "meeprom", "ieEPram", "zeeprum", "eyproc", "ereprom", "ieEPrim", "eeparm", "eopcm", "seipprom", "jeethrome", "eekdem", "jeethrom", "eecram", "epearm", "neepprom", "epprum", "meecram", "eepsprom", "edegrim", "jeeprome", "seipram", "zeesprum", "eperim", "eebarm", "eoprom", "peepsram", "seEProme", "zeespchrom", "seEPchrom", "seepprom", "eeekprom", "eseprome", "eepdem", "seypom", "eepsom", "eimprom", "eipprom", "eEPcm", "eegroc", "eremrome", "eeprome", "eebcm", "eypram", "neeperrom", "eepsram", "eespram", "zeespcm", "eesprom", "eppcm", "eethrom", "eepchrom", "jeethom", "eeplam", "eapeom", "eaperom", "eecrim", "eimprome", "eipcom", "eEPron", "eremrom", "edegdem", "neeperrome", "eepercm", "eyplam", "meecrim", "pepprom", "seeeprum", "seeeperrom", "epron", "meepram", "eekrom", "seeproc", "seeprim", "epeom", "epprim", "seepron", "eppdem", "ieeprim", "eeglam", "eepdom", "zeepchrom", "neeprome", "seiprim", "seepom", "eekcom", "eesprum", "peekcom", "peeparm", "eEPom", "peepprom", "meecom", "eaperim", "eeperrom", "eethrim", "peppcm", "eegram", "epechrom", "expchrom", "peekram", "eyprome", "eEPrim", "eyprum", "eEPprom", "eekprom", "ieepchrom", "eprome", "meeprim", "seeepprom", "eEProme", "eeyplam", "eeprum", "erepcm", "eimplam", "eeyprim", "eipom", "eeperrome", "eegcm", "eremcm", "ereprome", "eegrim", "eekrome", "eeekdem", "eekom", "eepcm", "eppom", "eepsarm", "esegrome", "eecdem", "peepsprom", "edepdem", "seeprome", "peepsarm", "eopprom", "eeperram", "jeeprim", "seypchrom", "ieepram", "eeeprom", "exprim", "eppram", "eegrome", "eEPram", "neeprom", "eegarm", "eecrom", "eeyproc", "eseprim", "seeeperrum", "eypcom", "eekchrom", "seeeperram", "peppram", "eprom", "exproc", "eegom", "eespcom", "eespcm", "eremom", "ieeprom", "eethrome", "seEPron", "eethom", "eeekom", "ieepprom", "eebram", "eegdem", "eeproc", "eperome", "eppdom", "eeepdem", "eeeproc", "eeperom", "exprom", "eeprem", "seeprom", "ieeparm", "seeeperprom", "peepcom", "eeperchrom", "eebrum", "eppcom", "zeepcm", "seEPom", "eemom", "eEProm", "eseprom", "jeepom", "eecarm", "eebrim", "eeepprom", "jeeprom", "seeepram", "ieEPprom"], "eecs": ["eects", "eECs", "eeces", "eepes", "eescjs", "eeeeescks", " eecjs", "eescols", "eeeeesccs", "eercrates", "geebds", "eegts", "eecks", "eebds", "eercs", "eepcs", "eefrs", "eeeeecs", "seecis", "eeeeeccs", "eecds", "geebts", " eocjs", "seecrs", "eoces", "eepts", "peecis", "peecos", "eefcs", "geecs", "eegis", "eebs", "eepjs", "seeges", "eocjs", "peeprs", "eecis", "eegs", "peeprates", "eesccs", "eescks", "eeeeecks", "eefks", "eepos", " eocs", "peepes", "eescs", "geects", "eegrates", "eesces", "peepos", "seegrs", "eocols", "geeces", "peecrates", "eepks", "eefes", "eekos", "seecs", "eepds", "geecds", "geebs", " eoces", "eeeeescs", "peepols", "eecols", "peegps", "eefos", "eegols", "peecols", "eescis", "eecrates", "peecps", "eegps", "eeps", "peegis", "seegs", "eocs", "eekis", "peegs", "eeccs", "eECes", "seeces", "peecrs", "eefs", "eegds", " eocols", "eerces", "eecos", "eescps", " eecols", "eeprates", "eecps", "eeprs", "eECrs", "eekps", "eescos", "eebes", "seegis", "eecrs", "eepis", "geebes", "eeks", "peegos", "eegrs", "eegos", "eepols", " eeces", "peeces", "peecs", "peeps", "eecjs", "eercols", "eECis", "eeges", "eebts"], "eesk": ["eedskk", "eeski", "edski", "eksu", "reeskh", "epsks", "leesky", "reesks", "edsh", "ekski", "eedso", "eesks", "reesh", "reeso", "epsk", "leesk", "eedsu", "eesok", "reesok", "edsk", "eksh", "eeso", "eksok", "epskk", "eedsk", "eksk", "eeskh", "leeskh", "eesu", "eesh", "eedsks", "eedskh", "reesk", "eeskk", "epsky", "eedsky", "reeski", "ekskk", "eksky", "ekso", "eksks", "leesks", "reesu", "reesky", "eesky", "edsok"], "eedi": ["edediu", "seedi", "seedin", "emeds", "ededz", "wolfii", "seediu", "ededI", "ededi", "emedi", "eadI", "ededpi", "eedii", "ededin", "eedI", "eadi", "seedo", "emedI", "emedmi", "emediu", "seeds", "emedo", "ededish", "ededo", "emedish", "ededii", "wolfi", "ededmi", "seedmi", "emedpi", "eedpi", "eedish", "wolfI", "seedI", "eeds", "emedz", "eedmi", "wolfo", "eadish", "eadpi", "emedin", "seedii", "eedo", "eedin", "ededs", "seedz", "eedz", "eediu"], "address": ["component", "action", "random", "execute", "page", "route", "document", "iterator", "memory", "pointer", "password", "shape", "store", "attribute", "ip", "event", "table", "message", "activity", "trace", "active", "command", "alias", "offset", "email", "clock", "distance", "interface", "readable", "order", "device", "target", "Address", "reference", "date", "index", "client", "race", "code", "state", "comment", "context", "ase", "element", "controller", "direction", "directory", "process", "variable", "resource", "length", "location", "host", "ice", "array", "confirmed", "condition", "point", "delay", "service", "size", "port", "relative", "buffer", "balance", "angle", "prefix", "number", "adr", "module", "batch", "phrase", "entity", "position", "payment", "padding", "remote", "sequence", "request", "network", "value", "gate", "description", "data", "domain", "operation", "base", "addr", "ace", "hello"], "tick": ["block", "action", "shift", "butt", "pointer", "chip", "shape", "event", "patch", "check", "insert", "script", "time", "tty", "trace", "frame", "timer", "command", "tz", "snap", "nice", "normal", "new", "pad", "offset", "_", "clock", "tx", "test", "stick", "style", "dt", "shock", "repeat", "tip", "tim", "zero", "date", "index", "click", "race", "comment", "cmd", "empty", "loop", "stop", "tag", "trigger", "step", "window", "length", "cell", "scroll", "slot", "push", "delay", "byte", "tc", "commit", "cycle", "watch", "ock", "trial", "task", "token", "jump", "tt", "always", "ox", "dx", "TX", "mill", "lock", "icker", "pick", "ck", "draw", "payment", "padding", "bytes", "roll", "quote", "ick", "sequence", "sync", "call", "ping", "ctl", "xe", "topic", "exec", "tv", "magic", "addr", "start", "t", "timeout", "choice"]}}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 16410, "substitutes": {"opaque": ["ropossus", "oplay", "roplay", "opllay", "Opca", "opute", "Opque", " opque", "oplaque", "oplicate", "Opute", "boute", "opossus", "opque", "oplossus", "Opaque", "ropaque", " opossus", " opicate", " opute", "boaque", "boca", " opca", "opca", " oplay", "ropicate", "boque", "opicate"], "iothread": ["phioththread", "ioshread", "irothlock", "phiothlock", "irothride", "iothreadable", "ithread", "phiothreader", "iheartreader", "lioretric", "iforeread", "ionseale", "ioretreader", "irothstream", "girostreader", "ioothread", "iothparse", "iththread", "aiforerecord", "iopathreader", "iothric", "eothreader", "lioretplay", "ihatereadable", "giothreading", "irothreader", "ireetreader", "ireetread", "eostread", "phiclothreader", "ihatereader", " iothstream", "irostreader", "iologread", "eostword", "iostword", "ioshwrite", "iostread", "ciologreader", "ihateload", "ioretparse", "iopathparse", "ciologread", "iforereader", "iheartread", "aiforeread", "pioothale", "iforthprint", "iothplay", "liothric", "girostreadable", "ithlock", "ihateread", "ioothride", "ioretplay", "ciothread", "iouthplay", "ioretric", "liothplay", "iostwrite", "iouthric", "iclothlock", "giothwrite", "ihandreader", "eothreadable", "iothprint", "gioretread", "pioothread", "ihandride", "piothale", "iothride", "piothread", " iouthstream", "ireetword", "ireetreadable", "gioretparse", "ciologwrite", "irostreadable", "ioththread", "iostload", "giostread", "irothwrite", "giothload", "ioshrecord", "iopathreading", "ioretreading", "ioshplay", " iouthwrite", "phiclothread", "giostreader", "iouthreader", "girostload", "ciologride", "iclothreading", "giothread", "ionseride", "iothlink", "ciothreader", "ciothride", "iforthride", "iforerecord", "iothstream", "iforthreader", "ioshreadable", "phiclothlock", "iothrecord", "ioshreader", "ionseread", "giothlink", "girostread", "iforthrecord", "iothreading", "aiforereadable", "iothlock", "iroththread", "iothword", "pioothride", "irothlink", "iouthstream", "iostlink", "iopathread", "ioretread", " iothwrite", "phicloththread", "ioothale", "iclothread", "lioretwrite", "eostreader", "giothparse", "iostreader", "ioretstream", "iforthread", "giothreader", "eothword", " iouthreader", "pioothprint", "liothwrite", "gioretreading", "iclothparse", "gioretreader", "iforereadable", "aiforereader", " iouthread", "iologride", "giothreadable", "ionseprint", "liothread", "iologwrite", "piothride", "aiothrecord", "iothale", "ciothwrite", "giostwrite", "ioothprint", "ihandwrite", "iforthreadable", "aiothreader", "ioretwrite", "iothreader", "eostreadable", " iothreader", "iheartword", "eothread", "iclothreader", "ioshric", "ithreader", "aiothreadable", "iologreader", "iologlink", "iothload", "iforthale", "icloththread", "aiothread", "iouthwrite", "irothread", "ihandread", "irostread", "lioretread", "piothprint", "iheartreadable", "irostload", "phiothread", "iostreadable", "giostlink", "iothwrite", "iouthread"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 16412, "substitutes": {"avctx": ["avpkg", "vpkg", "AVpkg", "avectx", "avtx", "aftx", " avcontext", "AVctx", " avtxt", "avetx", "avecontext", "avcfg", " avtx", "avtxt", "AVcontext", "vtxt", "AVtxt", "afcontext", " avpkg", "avcontext", "afcfg", "vcontext", "vctx", "avecfg", " avcfg", "afctx"]}}
{"project": "qemu", "commit_id": "3c3e88a814ef4eb8b2f8bf81863baec24838d998", "target": 0, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n", "idx": 16415, "substitutes": {"obj": ["tmp", "org", "act", "object", "bh", "attr", "ref", "hw", "pkg", "conn", "onet", "ex", "xy", "js", "os", "ot", "cont", "obs", "np", "elt", "inst", "att", "objects", "resp", "rect", "Object", "txt", "ctx", "o", "out", "po", "oj", "cmd", "phys", "op", "nt", "ob", "oid", "Obj", "bo", "j", "ist"], "v": ["f", "cv", "sv", "g", "vr", "c", "h", "conv", "vs", "vy", "p", "V", "iv", "lv", "r", "l", "m", "d", "vi", "qv", "vm", "b", "o", "vim", "vis", "ev", "ve", "vc", "uv", "nv", "mint", "w", "vt", "inv", "av", "t", "j", "vp"], "name": ["type", "alias", "label", "attr", " NAME", "cn", "nam", "part", "a", " names", "title", "info", "size", "term", "names", "error", "named", "path", "id", "var", "n", "code", "key", "val", "str", "Name", "NAME", "prefix", "data", "mem", "common", "ann", "w", "word", " Name", "tag", "ident", "t", "ame", "p"], "opaque": ["openus", "ipz", "opz", "openatile", "openaque", "opus", "operatile", "operus", "ipatile", "openz", "opatile", "operz", "ipaque", "operaque", "ipus"], "errp": [" errping", "errping", "rrp", "rrr", "errorr", "rrping", " errP", "err", "errorp", "errorping", "erping", "erP", "errorP", "errP", "rrP", "erp", "errr", " errr"], "value": ["unit", "text", "length", "type", "result", "array", "VALUE", "distance", " Value", "property", "widget", "bar", "memory", "size", "values", "json", "port", "buffer", "position", "scale", "attribute", "ue", "p", "select", "max", "message", "checked", "qv", "Value", "index", "total", "state", "key", "val", "description", "trace", "data", "output", "tv", "w", "oval", "hello", "field", "vp"], "mr": ["hr", "kr", "lr", "mer", "rs", "vr", "cm", "rl", "Mr", "rar", "memory", "wm", "mc", "pr", "drm", "ml", "tr", "rg", "mir", "shr", "rr", "ur", "sr", "r", "gr", "pm", "rw", "m", "mn", "ocr", "gm", "spr", "rpm", "rm", "adr", "bm", "usr", "mt", "mar", "MR", "rn", "RM"], "dimm": ["diam", "Dim", "dimp", "daimm", "dedgm", "piam", "Diam", "Dimm", "dim", "dagm", "pim", "digm", "pimm", " dimp", " dim", "daigm", "dem", " dem", "daimp", "dedimm", " dgm", "dedigm", " diam", " digm", "pem", "Dem", "dgm", "dedimp"]}}
{"project": "qemu", "commit_id": "d0e7605ee0d91c3737052127a79199ddab3ff653", "target": 0, "func": "pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1)\n\n{\n\n    pflash_t *pfl;\n\n    int32_t chip_len;\n\n\n\n    chip_len = sector_len * nb_blocs;\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n    pfl = qemu_mallocz(sizeof(pflash_t));\n\n    /* FIXME: Allocate ram ourselves.  */\n\n    pfl->storage = qemu_get_ram_ptr(off);\n\n    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,\n\n                                         pfl);\n\n    pfl->off = off;\n\n    pfl->base = base;\n\n    pfl->chip_len = chip_len;\n\n    pfl->mappings = nb_mappings;\n\n    pflash_register_memory(pfl, 1);\n\n    pfl->bs = bs;\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);\n\n    }\n\n#if 0 /* XXX: there should be a bit to set up read-only,\n\n       *      the same way the hardware does (with WP pin).\n\n       */\n\n    pfl->ro = 1;\n\n#else\n\n    pfl->ro = 0;\n\n#endif\n\n    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);\n\n    pfl->sector_len = sector_len;\n\n    pfl->width = width;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    pfl->ident[0] = id0;\n\n    pfl->ident[1] = id1;\n\n    pfl->ident[2] = id2;\n\n    pfl->ident[3] = id3;\n\n    pfl->unlock_addr[0] = unlock_addr0;\n\n    pfl->unlock_addr[1] = unlock_addr1;\n\n    /* Hardcoded CFI table (mostly from SG29 Spansion flash) */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (AMD/Fujitsu) */\n\n    pfl->cfi_table[0x13] = 0x02;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x27;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x36;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write (NA) */\n\n    pfl->cfi_table[0x20] = 0x00;\n\n    /* Typical timeout for block erase (512 ms) */\n\n    pfl->cfi_table[0x21] = 0x09;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x0C;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x01;\n\n    /* Max timeout for buffer write (NA) */\n\n    pfl->cfi_table[0x24] = 0x00;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x0A;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x0D;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(chip_len);\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = sector_len >> 8;\n\n    pfl->cfi_table[0x30] = sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    return pfl;\n\n}\n", "idx": 16419, "substitutes": {"base": ["pad", "us", "alias", "from", "block", "bind", "offset", "br", "boot", "ref", "bit", "as", "based", "map", "a", "origin", "root", "memory", "size", "i", "Base", "buffer", "bottom", "server", "bp", "ip", "re", "max", "ram", "m", "id", "cpu", "local", "b", "balance", "back", "area", "out", "history", "basic", "ase", "db", "full", "bare", "prefix", "file", "storage", "mem", "bal", "bound", "bas", "bin", "start", "bf", "bu", "mb", "name", "p"], "off": ["f", "pad", "ff", "from", "block", "bind", "offset", "ext", "boot", "end", "offs", "ref", "raw", "_", "map", "a", "ex", "origin", "hand", "info", "i", "os", "order", "ip", "pos", "low", "obj", "OFF", "loc", "att", "set", "buf", "zero", "ap", "id", "now", "local", "b", "ori", "o", "out", "reset", "on", "mem", "it", "oa", "of", "bas", "Off", "start", "op", "addr", "at", "dev", "offer", "name", "p"], "bs": ["ls", "bb", "ks", "bh", "boot", "bits", "rs", "ubs", "bi", "ops", "BS", "js", "lbs", "os", "bp", "obs", "vs", "bytes", "blog", "ns", "cb", "hz", "pb", "ms", "sys", "ts", "its", "fps", "bid", "b", "bed", "bg", "bis", "bn", "sb", "bc", "ba", "stats", "bos", "bps", "bl", "bas", "bm", "gs", "cs", "bles", "ps", "aos", "fs", "bes"], "sector_len": ["sector_Len", "sector67size", "tor_fin", "pixel_len", "sectorLengthlvl", "sector_li", "chip_Len", "sectorLengthlen", "chip_l", "sector67li", "sector_lin", "chip_size", "sector_val", "sectorLengthsize", "sector_loc", "sector_fin", "pixel_lvl", "tor_len", "pixel_li", "chip_fin", "sector67len", "sector_size", "sector67lvl", "chip_li", "sector_l", "sectorLengthli", "sector_lvl", "pixel_size", "tor_loc", "chip_lin", "tor_val"], "nb_blocs": ["nb_bliged", "nb_bloades", "nb_BLocs", "nb_blocials", "nb_BLocitions", "nb_blocationsed", "nb_blocationss", "nb_bliges", "nb_bloces", "nb_bloadals", "nb_blocationses", "nb_glocS", "nb_bligitions", "nb_blOCals", "nb_bloced", "nb_BLOCitions", "nb_bloads", "nb_blOCes", "nb_gloces", "nb_glOCs", "nb_BLOCed", "nb_bligs", "nb_glOCS", "nb_glOCes", "nb_blocals", "nb_glOCals", "nb_glocs", "nb_blOCs", "nb_blOCed", "nb_blOCitions", "nb_BLoces", "nb_blocis", "nb_blocationsitions", "nb_glocals", "nb_blocitions", "nb_bloadS", "nb_blocies", "nb_BLOCs", "nb_BLoced", "nb_blociS", "nb_blocS", "nb_BLOCes", "nb_blOCS"], "nb_mappings": ["nb_fapper", "nb_masks", "nb_sairs", "nb_mapper", "nb_mairs", "nb_links", "nb_Minks", "nb_matinks", "nb_Mapper", "nb_fappers", "nb_sappings", "nb_sappers", "nb_lappings", "nb_mappers", "nb_sapper", "nb_Mairs", "nb_matappers", "nb_matasks", "nb_Mappers", "nb_lasks", "nb_matappings", "nb_Masks", "nb_fairs", "nb_minks", "nb_lappers", "nb_Mappings", "nb_fappings"], "id0": ["ID0", " id5", "rid5", "kid2", "id5", "rid8", "sid00", "sid0", "id00", "ID5", "sid2", " id00", "ID8", " id8", "kid1", "rid00", "ID00", "sid1", "kid00", "rid0", "id8", "kid0"], "id1": ["ID0", "ident2", "id01", "kid8", "ID01", " id01", "ident1", "ID3", "ID2", "ID1", "ID8", "ident01", " id11", " id8", "kid3", "ID11", "ident11", "id11", "id8", "kid1", "kid0"], "id2": [" id5", "Id1", "ident2", "ident4", "id02", "id5", " id02", "ident1", "Id2", "Id4", "type5", "vid02", "vid4", "Id02", "type4", "vid2", "type02", "ident02", "type2", "vid5", " id4", "id4"], "id3": ["oid03", " id5", "oid5", "id5", "sid3", "ID03", "Id3", "ID3", "Id5", "Id03", "id23", "ID2", "sid2", " id23", "ID4", "id03", "oid23", "oid3", "Id23", "sid03", " id4", "sid4", "id4", " id03"], "unlock_addr0": ["unlock_address3", "unlock2ptr0", "unlock_ptr_", "unlock_addr3", "unlock_mt3", "unlock2addr0", "unlock2ptr3", "unlock_address_", "unlock2addr3", "unlock_id0", "unlock_address0", "unlock_ptr1", "unlock_ptr0", "unlock_id2", "unlock_ptr2", "unlock2ptr_", "unlock_mt_", "unlock_id1", "unlock2addr_", "unlock_addr2", "unlock_id3", "unlock_addr_", "unlock_mt0", "unlock_ptr3"], "unlock_addr1": ["unlock_dr01", "unlock_addr3", "unlock_addr01", "unlock_ptr1", "unlock_ptr2", "unlock_dr3", "unlock_dr2", "unlock_dr1", "unlock_addr2", "unlock_ptr01", "unlock_ptr3"], "pfl": ["pingfc", "pflush", " pft", "clientf", "policyvl", "pll", "Pform", "Pfc", "cpFl", "pcll", "pill", "pcflo", "mfr", "pisw", "postfl", "PFL", "Ply", "appl", "postvl", "pifil", "apff", "pcatt", "ppfp", "ppfr", "cFl", "pform", " pfr", "exppol", " pll", " ply", " pfc", "postoft", "parval", "pcompl", "pject", "pival", " pval", "parsecompl", "parseflo", "pflo", "Ppl", "pff", "policyfl", "parsell", "parsefly", "pinkl", "csl", "pacoll", "pgl", "patfl", "clientcompl", "pcff", "pingFL", "pf", "pFl", "npfd", "Pfr", "cpfl", " pform", "expfl", "pcsl", "psl", " pcoll", "preflo", "pif", "Pflush", "pcfc", "cfl", "cpf", "ppatt", "pingll", "parsefl", "pingcoll", "mFl", "pipl", "pfc", "expfc", "parsely", "nppl", " ppol", "clientfol", " pject", "pingvl", "pfil", "clientfil", "pingfly", "Pcoll", "Psl", "pinpol", "pingval", "ipfl", "clientfl", "pcpt", "postcompl", "Pkl", "pingcompl", "expfr", "pigl", " pfd", "ipcoll", "ppl", "piform", "pcfd", " pf", "formfil", "ply", "pingfd", "expfil", "pafl", "cpfd", "apsl", "pifr", "patvl", "patoft", "pckl", " pfp", "pifl", " ppt", "pingflo", "cpflo", "apfd", "pingflush", "pcf", "expvl", " psl", "pkl", "pingfl", "pift", "expkl", "clientFL", "pcfol", " psw", "pcfil", " pflo", "pafol", "parsepl", "pinfl", "parfil", "cpFL", "cpsl", "expgl", "Pfl", "pifd", "pinll", "Pgl", "prepol", "pFL", "formpol", " pvl", "piject", "ppol", "mfl", "pingpl", "picompl", "cpfr", " pfly", "cpfp", " pfol", "cflo", " ppl", "npfr", "ppt", "expcompl", "ipform", "Pflo", "pcfl", "apfl", "pfr", "pcpol", "pcft", "pvl", "prefil", "pingfol", " pflush", "pfly", "ppFl", "Pfd", "pft", "formflo", "expfd", "mpl", "pcflush", " pkl", "pingpol", "Psw", "pcoll", "apll", " poft", " pFl", "clientflo", "npfl", " pfil", "parfl", "patt", "cpkl", "Pfp", " pcompl", " pFL", "prefl", "apject", "cpatt", "pval", "clientfp", "policygl", "cpff", "ppfl", "patcompl", "formfl", "ppflo", "pipt", "parsefr", "ppkl", "parform", "pfp", "pafd", "ipFL", "clientpol", "PFl", "expflush", "psw", "poft", "cppl", "policyfc", "pfol", " pgl", "parsevl", "pfd"], "chip_len": ["chip_min", "chip33compl", "nice_len", "pixel_len", "sector_num", "chip_addr", "sector_del", "chip_lim", "chip_mem", "chip_size", "chipmoplen", "chipxls", "chip33lim", "chip_vec", "chip_en", "chipxlen", "pixel_mem", "nice_loss", "chip_del", "pixel_vec", "sector_min", "sector_addr", "sector_loc", "nice_loc", "chip_compl", "sector_length", "chip33del", "chipxnum", "chip_num", "sector_lim", "chip_length", "chip_loss", "sector_compl", "chip_loc", "chipmopsize", "sector_ls", "chipxlength", "nice_size", "chip33len", "chip_ls", "chipmoploss", "pixel_en", "chipmoploc"]}}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n", "idx": 16422, "substitutes": {"s": ["ls", "is", "sl", "sts", "ains", "sv", "rs", "states", "aws", "h", "c", "sq", "ops", "sm", "js", "service", "os", "store", "ss", "serv", "ess", "ns", "obj", "e", "ms", "ats", "sim", "ts", "d", "sys", "es", "v", "n", "se", "space", "sb", "state", "ds", "ses", "S", "sam", "gs", "cs", "sa", "t", "als", "fs", "hs", "p"], "path": ["text", "prop", "alias", "piece", "box", "th", "ref", "host", "chain", "pred", "pointer", "eth", "ata", "device", "pattern", "kind", "PATH", "Path", "pt", "m", "pod", "txt", "mat", "template", "ath", "key", "md", "prefix", "full", "cmd", "str", "transform", "w", "msg", "node", "module", "partial", "name", "p"], "mode": ["tm", "ode", "type", "mit", "MODE", "test", "mm", "Mode", "role", "size", "mask", "def", "dim", "power", "spec", "dm", "im", "move", "max", "dem", "m", "mid", "code", "key", "md", "member", "ase", "data", "de", "mem", "deg", "status", "mac", "perm", "pro", "module", "command", "mt", "ace", "mod", "range", "name"]}}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical (CPUState *env, mmu_ctx_t *ctx,\n\n                           target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 16431, "substitutes": {"env": ["proc", "org", "window", "ku", "cv", "rod", "act", "config", "equ", "end", "ext", "en", "conn", "er", "NV", "vv", "init", "hw", "tx", "viron", "ef", "info", "ov", "worker", "eh", "enter", "server", "gear", "vs", "net", "np", "obj", "eni", "event", "enc", "e", "ah", "buf", "conf", "den", "network", "here", "vm", "eas", "v", "global", "ev", "era", "code", "ve", "ei", "ew", "context", "app", "cmd", "environment", "desc", "et", "cur", "nv", "ec", "uv", "vt", "inv", "erd", "eng", "dev", "t", "esc", "exc"], "ctx": ["proc", "crit", "cf", "act", "cv", "config", "conn", "pkg", "hw", "tx", "qu", "anc", "abc", "ck", "func", "mc", "dt", "cp", "sc", "conv", "etc", "jac", "np", "obj", "kt", "cb", "loc", "unc", "tc", "resp", "buf", "ac", "nc", "cc", "kw", "ct", "ctl", "Conn", "history", "acl", "bc", "xc", "context", "mk", "alloc", "cmd", "ctrl", "pg", "x", "req", "tk", "exec", "nt", "addr", "cmp", "conf", "cfg", "p"], "eaddr": ["oaddr", "rolldriver", " oxDR", "aeder", "ewer", "eeddr", " oxdr", " oxdress", "dddr", "alkdr", "oadtr", "alkder", "eedder", "eddDR", "oadhr", "adder", "alker", "awder", "reamdr", "rollr", "edddriver", "reamder", "aeddr", "awr", "eddr", "edder", "rolldr", "eadtr", "edddr", "oadDR", "eddtr", "dddriver", " elDR", "reamDR", " eldress", "ddDR", "oaddress", "awdr", "ewdriver", "ewder", "alkdriver", "eeddriver", "eadder", "awer", "ewdr", "ddr", "rollDR", " eldr", "ader", "reamdriver", "eaddriver", "eadDR", "eedDR", "oader", "aedtr", "eddder", " elhr", "adr", "addr", "eader", " oxhr", "eadhr", "eadr", "eaddress"], "rw": ["nb", "rt", "RW", "rf", "hw", "sw", "vr", "iw", "nr", "wb", "rx", "rh", "rl", "rb", "tw", "rack", "wn", "rr", "wx", "r", "wp", "rss", "nw", "kw", "rew", "aw", "ew", "wa", "write", " rc", "fw", " shr", "w", "xf", "rd", " w", "wr"], "in_plb": ["in___PLb", "in_pcb", "in_pld", "in_plx", "in_cld", "in_iplB", "in_plbs", "in_pla", "in_iplad", "in___plb", "in_PLx", "in2plB", "in___pla", "in_clx", "in2plad", "in_ipla", "in_palB", "in_cla", "in_pala", "in___pld", "in2ipla", "in_perz", "in_palad", "in_iplb", "in___PLx", "in_pcad", "in2iplb", "in_pca", "in_plz", "in_perb", "in2plb", "in_perbs", "in2iplB", "in___PLa", "in_clb", "in_PLd", "in___plx", "in_plB", "in___PLd", "in_la", "in_pcB", "in_PLb", "in_lb", "in2pla", "in_palb", "in_lx", "in_plad", "in_PLa", "in2iplad", "in_ld"], "ret": ["f", "rt", "gt", "ref", "result", "rem", "def", "cont", "conv", "len", "tr", "res", "pert", "elt", "re", "flag", "att", "rel", "resp", "pet", "RET", "Ret", "ter", "rev", "num", "off", "txt", "back", "out", "ft", "nz", "reset", "over", "val", "print", "rets", "gb", "cmd", "desc", "rot", "count", "alt", "deg", "status", "fun", "rm", "nt", "usr", "mt", "ptr", "t"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_xvmc_field_end(MpegEncContext *s)\n\n{\n\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n\n    assert(render);\n\n\n\n    if (render->filled_mv_blocks_num > 0)\n\n        ff_mpeg_draw_horiz_band(s, 0, 0);\n\n}\n", "idx": 16437, "substitutes": {"s": ["f", "ls", "is", "sts", "sv", "rs", "ins", "as", "a", "c", "sq", "sac", "h", "js", "ss", "sg", "details", "ns", "spec", "session", "set", "e", "ms", "ats", "ts", "m", "b", "v", "sb", "stats", "ds", "qs", "ses", "S", "gs", "cs", "ps", "t", "comm", "fs", "p"], "render": ["proc", "f", "rend", "config", "run", "nder", "bind", "end", "prof", "result", "update", "rendered", "vr", "h", "Render", "report", "draw", "plot", "fr", "pen", "res", "select", "review", "spec", "re", "match", "feat", "r", "buf", "rev", "rect", "respond", "spr", "print", "cmd", "reflect", "data", "html", "pair", "material", "frame", "format", "transform", "save", "view", "raw", "stat", "tag", "snap", "eng", "field"]}}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 16449, "substitutes": {"mr": ["hr", "kr", "br", "rs", "mx", "MT", "vr", "rh", " MR", "Mr", "rar", "mp", "wm", "mc", "drm", "ml", "rb", "rg", "shr", "rr", "sr", "r", "hm", "ms", "gr", " rm", "m", "mn", "mk", "dr", "rm", "adr", "bm", "mt", "MR", "rn", "RM"]}}
{"project": "FFmpeg", "commit_id": "c96f3750c22ef1576a46140f3101e3585041f41f", "target": 0, "func": "pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)\n\n{\n\n    char temp[GET_MODE_BUFFER_SIZE];\n\n    char *p= temp;\n\n    static const char filterDelimiters[] = \",/\";\n\n    static const char optionDelimiters[] = \":\";\n\n    struct PPMode *ppMode;\n\n    char *filterToken;\n\n\n\n    ppMode= av_malloc(sizeof(PPMode));\n\n\n\n    ppMode->lumMode= 0;\n\n    ppMode->chromMode= 0;\n\n    ppMode->maxTmpNoise[0]= 700;\n\n    ppMode->maxTmpNoise[1]= 1500;\n\n    ppMode->maxTmpNoise[2]= 3000;\n\n    ppMode->maxAllowedY= 234;\n\n    ppMode->minAllowedY= 16;\n\n    ppMode->baseDcDiff= 256/8;\n\n    ppMode->flatnessThreshold= 56-16-1;\n\n    ppMode->maxClippedThreshold= 0.01;\n\n    ppMode->error=0;\n\n\n\n    memset(temp, 0, GET_MODE_BUFFER_SIZE);\n\n    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: %s\\n\", name);\n\n\n\n    for(;;){\n\n        char *filterName;\n\n        int q= 1000000; //PP_QUALITY_MAX;\n\n        int chrom=-1;\n\n        int luma=-1;\n\n        char *option;\n\n        char *options[OPTIONS_ARRAY_SIZE];\n\n        int i;\n\n        int filterNameOk=0;\n\n        int numOfUnknownOptions=0;\n\n        int enable=1; //does the user want us to enabled or disabled the filter\n\n\n\n        filterToken= strtok(p, filterDelimiters);\n\n        if(filterToken == NULL) break;\n\n        p+= strlen(filterToken) + 1; // p points to next filterToken\n\n        filterName= strtok(filterToken, optionDelimiters);\n\n        av_log(NULL, AV_LOG_DEBUG, \"pp: %s::%s\\n\", filterToken, filterName);\n\n\n\n        if(*filterName == '-'){\n\n            enable=0;\n\n            filterName++;\n\n        }\n\n\n\n        for(;;){ //for all options\n\n            option= strtok(NULL, optionDelimiters);\n\n            if(option == NULL) break;\n\n\n\n            av_log(NULL, AV_LOG_DEBUG, \"pp: option: %s\\n\", option);\n\n            if(!strcmp(\"autoq\", option) || !strcmp(\"a\", option)) q= quality;\n\n            else if(!strcmp(\"nochrom\", option) || !strcmp(\"y\", option)) chrom=0;\n\n            else if(!strcmp(\"chrom\", option) || !strcmp(\"c\", option)) chrom=1;\n\n            else if(!strcmp(\"noluma\", option) || !strcmp(\"n\", option)) luma=0;\n\n            else{\n\n                options[numOfUnknownOptions] = option;\n\n                numOfUnknownOptions++;\n\n            }\n\n            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;\n\n        }\n\n        options[numOfUnknownOptions] = NULL;\n\n\n\n        /* replace stuff from the replace Table */\n\n        for(i=0; replaceTable[2*i]!=NULL; i++){\n\n            if(!strcmp(replaceTable[2*i], filterName)){\n\n                int newlen= strlen(replaceTable[2*i + 1]);\n\n                int plen;\n\n                int spaceLeft;\n\n\n\n                if(p==NULL) p= temp, *p=0;      //last filter\n\n                else p--, *p=',';               //not last filter\n\n\n\n                plen= strlen(p);\n\n                spaceLeft= p - temp + plen;\n\n                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){\n\n                    ppMode->error++;\n\n                    break;\n\n                }\n\n                memmove(p + newlen, p, plen+1);\n\n                memcpy(p, replaceTable[2*i + 1], newlen);\n\n                filterNameOk=1;\n\n            }\n\n        }\n\n\n\n        for(i=0; filters[i].shortName!=NULL; i++){\n\n            if(   !strcmp(filters[i].longName, filterName)\n\n               || !strcmp(filters[i].shortName, filterName)){\n\n                ppMode->lumMode &= ~filters[i].mask;\n\n                ppMode->chromMode &= ~filters[i].mask;\n\n\n\n                filterNameOk=1;\n\n                if(!enable) break; // user wants to disable it\n\n\n\n                if(q >= filters[i].minLumQuality && luma)\n\n                    ppMode->lumMode|= filters[i].mask;\n\n                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))\n\n                    if(q >= filters[i].minChromQuality)\n\n                            ppMode->chromMode|= filters[i].mask;\n\n\n\n                if(filters[i].mask == LEVEL_FIX){\n\n                    int o;\n\n                    ppMode->minAllowedY= 16;\n\n                    ppMode->maxAllowedY= 234;\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        if(  !strcmp(options[o],\"fullyrange\")\n\n                           ||!strcmp(options[o],\"f\")){\n\n                            ppMode->minAllowedY= 0;\n\n                            ppMode->maxAllowedY= 255;\n\n                            numOfUnknownOptions--;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == TEMP_NOISE_FILTER)\n\n                {\n\n                    int o;\n\n                    int numOfNoises=0;\n\n\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        char *tail;\n\n                        ppMode->maxTmpNoise[numOfNoises]=\n\n                            strtol(options[o], &tail, 0);\n\n                        if(tail!=options[o]){\n\n                            numOfNoises++;\n\n                            numOfUnknownOptions--;\n\n                            if(numOfNoises >= 3) break;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK\n\n                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){\n\n                    int o;\n\n\n\n                    for(o=0; options[o]!=NULL && o<2; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        if(o==0) ppMode->baseDcDiff= val;\n\n                        else ppMode->flatnessThreshold= val;\n\n                    }\n\n                }\n\n                else if(filters[i].mask == FORCE_QUANT){\n\n                    int o;\n\n                    ppMode->forcedQuant= 15;\n\n\n\n                    for(o=0; options[o]!=NULL && o<1; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        ppMode->forcedQuant= val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if(!filterNameOk) ppMode->error++;\n\n        ppMode->error += numOfUnknownOptions;\n\n    }\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode);\n\n    if(ppMode->error){\n\n        av_log(NULL, AV_LOG_ERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name);\n\n        av_free(ppMode);\n\n        return NULL;\n\n    }\n\n    return ppMode;\n\n}\n", "idx": 16452, "substitutes": {"name": ["type", "length", "alias", "label", "filter", "part", "c", "a", "title", "size", "term", "buffer", "names", "version", "null", "len", "path", "id", "v", "n", "time", "out", "code", "key", "comment", "package", "prefix", "Name", "data", "NAME", "file", "filename", "mem", "common", "format", "w", "word", "base", "source", "letter", "t", "ame"], "quality": ["equality", "length", "condition", "distance", "depth", "Q", "Quality", "ity", "q", "scale", "priority", "version", " Quality", "frequency", "ness", "sequence", "value", "level", "mode", "language", "comment", "media", "weight", "confidence", "format", "limit", "availability", "qual"], "temp": ["tmp", "tm", "type", "cache", "emp", "unt", "result", "jp", "pre", "c", "iter", "test", "ta", "mm", "memory", "mp", "Temp", "buffer", "cp", "null", "tr", "pi", "tem", "max", "tc", "tim", "cu", "buf", "pid", "m", "pt", "txt", "v", "var", "n", "mode", "out", "template", "vp", "empty", "prefix", "data", "mem", "w", "current", "raw", "base", "input", "ptr", "ps", "t"], "p": ["f", "tmp", "pad", "ep", "g", "pkg", "fp", "P", "c", "h", "pid", "post", "mp", "pr", "position", "q", "cp", "bp", "y", "pos", "pp", "pi", "pl", "lp", "pc", "wp", "pt", "m", "d", "ap", "ph", "ping", "sp", "b", "v", "pa", "n", "vp", "up", "w", "it", "start", "at", "ps", "t", "tp", "j"], "filterDelimiters": ["filterDelimiter", "filterDelamitERS", "filterDelimiterer", "filterDelimiterors", "filterDelipiterers", "filterDelipitors", "filterDelipiterters", "filterDelimiterERS", "filterDelimitters", "filterDelimITers", "filterDelimITters", "filterDelamitsERS", "filterDelimitors", "filterDelimitizters", "filterDelimitizers", "filterDelipiters", "filterDelamitters", "filterDelimitsERS", "filterDelipiterERS", "filterDelipitters", "filterDelamitsers", "filterDelimitser", "filterDelipitERS", "filterDelimitsors", "filterDelimITer", "filterDelimitizors", "filterDelimitsters", "filterDelamiter", "filterDelamitsters", "filterDelipiterors", "filterDelamiters", "filterDelamitser", "filterDelimiterers", "filterDelimitsers", "filterDelimitizERS", "filterDelimitERS", "filterDelimiterters", "filterDelimITERS"], "optionDelimiters": ["optionDelimiterers", "optionDelimitser", "optionDelimiter", "optionDelimiterer", "optionDelimitsERS", "optionDelimitors", "optionDelemiter", "optionDelimmITer", "optionDelimitators", "optionDelimitsators", "optionDelimmitERS", "optionDelamitsters", "optionDelimitsters", "optionDelimmiter", "optionDelimiterters", "optionDelimITters", "optionDelimITERS", "optionDelimitizors", "optionDelimitsers", "optionDelimmitters", "optionDelimITer", "optionDelimmITers", "optionDelemitsters", "optionDelamitters", "optionDelemitsers", "optionDelimitizERS", "optionDelamitERS", "optionDelimitizters", "optionDelimitERS", "optionDelimmITters", "optionDelemitters", "optionDelamitsors", "optionDelamiters", "optionDelimriter", "optionDelimmiters", "optionDelemitators", "optionDelimritters", "optionDelimiterators", "optionDelimriters", "optionDelamitors", "optionDelimiterors", "optionDelimITers", "optionDelimitters", "optionDelamitsers", "optionDelimitizers", "optionDelimitsors", "optionDelemitsators", "optionDelimritators", "optionDelimiterERS", "optionDelemiters", "optionDelemitser", "optionDelimmITERS", "optionDelamitsERS"], "ppMode": [" ppStyle", "dpMode", "suppMod", "cppSession", "cppTheme", " ppMODE", " ppMember", "xxTheme", "pgMod", " ppSettings", "ppoTheme", "ppMu", " ppDef", "pgModel", "suppTheme", "oppEngine", "appModule", "phpMu", "pdUser", "procModule", "pportMode", "ppoMODE", "oppMu", "ptModel", "appMODE", "cpModule", "pMod", "dpMember", "plMODE", "ppeMode", "pdMod", "oppDef", "bpTheme", "bpMode", "portMod", "suppMode", "ppoEngine", "pingMode", "pdMode", "pxMod", "portEngine", "ptMode", "oppUser", "pMode", "plRole", "ppeTheme", "phpTheme", "bpModule", "ppeUser", "plStyle", "procSettings", " ppMod", "ppMODE", " ppTheme", "cppMode", "ppMember", "ppModule", "ppUser", "ppoUser", "ppRole", "oppMod", "appTheme", "pEngine", "pingModule", " ppUser", "procMode", "ppoSession", "cppEngine", "ppeForce", "xxModule", " ppEngine", "ptMod", "PPTheme", "ppoMode", "ppModel", "ppoForce", "xxMode", "pxMember", "ppMod", "cppDef", "phpMode", "ppStyle", "phpSession", "procMODE", "portMODE", "pgTheme", "cppMu", "ppDef", "PPMu", "ppForce", "dpMod", "PPSettings", "pxMODE", "pMODE", "ppoModule", "pportStyle", "ppoMod", "suppModel", "dpMODE", "PPModule", "ppSettings", "pportMODE", "cpMod", "bpMod", "plMode", "cpMode", "portMode", "ppTheme", " ppRole", "PPMODE", "oppMode", "ppoMu", "pxMode", "ppEngine", "ppSession", "cpTheme", " ppModule", "cppMODE", "xxMODE", "pingMu", "pportRole", "pingTheme", "ptTheme", "oppForce", "appMode", "pdModule", "cppModule", "oppModule", "oppMODE", "pgMode", "oppTheme", "PPMode"], "filterToken": ["FilterName", "sortType", "FilterTok", "FilterInitial", "frequencyTO", "transformParser", "profileTO", "FilterToken", " filterTokens", "transformInitial", "sortToken", "profileTokens", "formatToken", "frequencytoken", "filterTO", " filterParser", "profileToken", "filName", " filterTO", "filTok", "filterParser", "filToken", "sorttoken", "frequencyTokens", "filInitial", "transformName", "filterTok", "filterTokens", "filterNode", "transformNode", "frequencyToken", "transformTokens", "FilterType", "formattoken", "formatName", "sortNode", " filtertoken", "FilterTokens", "filtertoken", " filterNode", "filterType", "transformToken", "sortName", "filType", "profiletoken", "transformTok", "sortParser", "filterInitial"], "filterName": ["FilterName", "stopName", " filtername", " filterKey", "profilename", "FilterNames", " filterTag", "tagName", "FilterToken", "filtername", "sortToken", "stopNames", " filterCount", "formatToken", "filName", "formatKey", "mapname", "tagKey", "sortname", "filToken", "hashName", "stopToken", "filNAME", "filterNAME", "optionToken", " filterNames", "profileName", " filterNAME", "tagToken", "mapName", "hashNAME", "tagTag", "hashname", "mapToken", "filterCount", "formatName", "sortNAME", "optionType", "stopNAME", "optionNAME", "optionName", "formatTag", "filterKey", "FilterNAME", "hashCount", "mapNAME", "filterType", "filType", "sortName", " filterType", "profileCount", "profileNAME", "filterTag", "filterNames"], "option": ["unit", "opt", "alias", "cho", "action", "open", "label", "block", "filter", "entry", "ption", "condition", "second", "test", "channel", "point", "term", "attribute", "TION", "consider", "select", "event", "item", "argument", "table", "section", "menu", "value", "question", "zero", "record", "Option", "other", "trial", "comment", "key", "instance", "empty", "prefix", "feature", "alt", "pair", "translation", "relation", "op", "operation", "command", "optional", "tag", "answer", "field", "category", "timeout"], "options": ["opt", "ptions", "bits", "ops", "versions", "args", "settings", "values", "names", "params", "styles", "pins", "events", "objects", "errors", "actions", "ts", "weights", "members", "Options", "times", "vals", "flags", "comments", "results", "tags", "terms"], "OPTIONS_ARRAY_SIZE": ["OPTIONS_ARRAY_Size", "OPTIONS_ARArray_POS", "OPTIONS_ARArray_TYPE", "OPTIONS_ARArray_SIZE", "OPTIONS_ARRAY_POS", "OPTIONS_ARArray_Size", "OPTIONS_ARRAY_TYPE"], "i": ["f", "c", "ai", "info", "li", "y", "ip", "in", "pi", "ni", "r", "e", "ci", "l", "m", "index", "id", "b", "I", "n", "ii", "x", "it", "mi", "limit", "t", "j"], "numOfUnknownOptions": ["numOfunknownValues", "numOfInvalidItems", "numofKnownItems", "numofUnknownOptions", "numofUnknownItems", "numOfKnownOptions", "numofUnknownValues", "numOfUnknownOption", "numOfunknownItems", "numOfInvalidOption", "numOfUnknownItems", "numofKnownValues", "numOfunknownOptions", "numOfKnownItems", "numOfKnownOption", "numofKnownOptions", "numofUnknownOption", "numOfInvalidOptions", "numofKnownOption", "numOfInvalidValues", "numOfUnknownValues", "numOfunknownOption", "numOfKnownValues"], "error": ["danger", "Error", "extra", "type", "offset", "rank", "result", "warning", "err", "info", "order", "debug", "bug", "ERROR", "address", "errors", "progress", "value", "ack", "comment", "alpha", "feature", "success", "command", "loss", "ror", "timeout", "volume"]}}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16465, "substitutes": {"bs": ["ls", "sts", "bh", "bits", "rs", "ubs", "outs", "iss", "asis", "BS", "js", "lbs", "os", "ss", "bp", "obs", "blog", "vs", "ns", "ims", "pb", "ubis", "ms", "ts", "locks", "its", "fps", "acs", "b", "bis", "sb", "bc", "cks", "bos", "ds", "ses", "http", "bps", "aus", "bl", "gs", "bm", "cs", "ps", "aos", "fs", "hs", "bes"], "l1_index": ["l1_sequence", "l0_index", "l1__index", "l0_Index", "l1_Index", "l1__ind", "l1_ind", "l0_address", "l1_x", "l0_ind", "l1__x", "l1__address", "l0_sequence", "l1_address", "l0_x"], "s": ["ls", "is", "sts", "sv", "rs", "bits", "ubs", "ins", "a", "h", "sis", "plays", "js", "css", "os", "ss", "ies", "vs", "ns", "ims", "spec", "ats", "ts", "sys", "its", "locks", "acs", "b", "v", "bis", "sb", " ss", "stats", "ds", "http", "ses", "less", "qs", "S", "ssl", "gs", "gets", "cs", "sa", "ps", "fs", "hs", "p"], "buf": ["tmp", "window", "cf", "cv", " vec", "block", "box", " buffer", "br", "cache", "nm", "ctr", "page", "cam", "pkg", "result", "vec", "tx", "iter", "wb", "err", "bar", "tab", "Buff", "port", "dq", "buffer", "cap", "Buffer", "cp", "rb", "tr", "bp", "doc", "img", "obj", "cb", "pb", "rw", "off", "b", "ctx", "var", "txt", "uf", "out", "code", "priv", "bc", "str", "cmd", "db", "data", "desc", "next", "cur", "mem", "seq", "msg", "bl", "raw", "buff", "pool", "pack", "usr", "queue", "p"], "l1_start_index": ["l1_start_i", "l1_end_line", "l1_end_position", "l1_end_index", "l1_startddata", "l1_start_line", "l1_end_i", "l1_start_position", "l1_end_Index", "l1_startdindex", "l1_startdIndex", "l1_end_data", "l1_startdlocation", "l1_start_status", "l1_end_location", "l1_end_status", "l1_end_num", "l1_start_location", "l1_end_ind", "l1_start_data", "l1_start_Index", "l1_start_num", "l1_start_ind"], "i": [" I", "is", "bi", "gi", "ind", "init", " mi", "iter", "c", "xi", "point", "ki", "ai", "inner", "or", "port", "li", "ui", "ic", "y", "ip", "io", "in", " ii", "\u0438", "ims", "pi", "iu", "qi", "u", "im", "r", "zi", "ci", "e", "l", "sim", "m", "me", "index", "id", "ji", "I", "o", "n", "ii", "ti", "print", "fi", "phi", "ix", "x", "di", " ni", "it", "mi", " j", "ie", "uri", "ij", "ini", "multi", "j", "si", "batch"], "ret": ["rt", "ne", "ext", "gt", "ref", "result", "jp", "cat", "not", "lit", "rem", "tail", "nl", "def", "cont", "dt", "len", "tr", "res", "del", "net", "gc", "elt", "ll", "re", "att", "r", "expr", "resp", "arr", "det", "RET", "Ret", "ter", "pt", "txt", "back", "out", "ft", "cert", "nz", " Ret", "reset", "val", "fi", "rets", "print", "cmd", "alt", "arg", "deg", "it", "fun", "rm", "nt", "try", "pret", "usr", "mt", "reply", "plain", "t", "red", "pat"]}}
{"project": "qemu", "commit_id": "f46e9a0b9911fcfbc13f85f3a8808067990a0f5c", "target": 0, "func": "static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n\n{\n\n    uintptr_t host_start, host_map_start, host_end;\n\n\n\n    last_bss = TARGET_PAGE_ALIGN(last_bss);\n\n\n\n    /* ??? There is confusion between qemu_real_host_page_size and\n\n       qemu_host_page_size here and elsewhere in target_mmap, which\n\n       may lead to the end of the data section mapping from the file\n\n       not being mapped.  At least there was an explicit test and\n\n       comment for that here, suggesting that \"the file size must\n\n       be known\".  The comment probably pre-dates the introduction\n\n       of the fstat system call in target_mmap which does in fact\n\n       find out the size.  What isn't clear is if the workaround\n\n       here is still actually needed.  For now, continue with it,\n\n       but merge it with the \"normal\" mmap that would allocate the bss.  */\n\n\n\n    host_start = (uintptr_t) g2h(elf_bss);\n\n    host_end = (uintptr_t) g2h(last_bss);\n\n    host_map_start = (host_start + qemu_real_host_page_size - 1);\n\n    host_map_start &= -qemu_real_host_page_size;\n\n\n\n    if (host_map_start < host_end) {\n\n        void *p = mmap((void *)host_map_start, host_end - host_map_start,\n\n                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (p == MAP_FAILED) {\n\n            perror(\"cannot mmap brk\");\n\n            exit(-1);\n\n        }\n\n\n\n        /* Since we didn't use target_mmap, make sure to record\n\n           the validity of the pages with qemu.  */\n\n        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n\n    }\n\n\n\n    if (host_start < host_map_start) {\n\n        memset((void *)host_start, 0, host_map_start - host_start);\n\n    }\n\n}\n", "idx": 16483, "substitutes": {"elf_bss": ["elf_rsc", "elf_bst", "elf_gst", "elf_bsc", "elf_rss", "elf_bsy", "elf___bss", "elf_pss", "elf__bst", "elf_pass", "elf__psc", "elf___bass", "elf___rbss", "elf_boss", "elf___rbass", "elf_bass", "elf___rbsy", "elf__pst", "elf_gss", "elf_psc", "elf_rSS", "elf_bcss", "elf___bsy", "elf_psy", "elf_arbass", "elf_bSS", "elf_rbass", "elf_arbss", "elf_gsc", "elf_gSS", "elf_rbss", "elf_rbsy", "elf_pst", "elf_bess", "elf_pcss", "elf_poss", "elf_rbcss", "elf_pess", "elf_rbess", "elf_arbcss", "elf__pss", "elf_rboss", "elf_pSS", "elf_arbsy", "elf__bSS", "elf__bsc", "elf___rbcss", "elf__bss", "elf___bcss", "elf_rst", "elf__pSS"], "last_bss": ["last_bgn", "last_rbcss", "last_pess", "last_fess", "last_abSS", "last_sbss", "last_gess", "last_vcss", "last_vws", "last_fst", "last_vSS", "last_bws", "last_bSS", "last_bcss", "last_pSS", "last_nbSS", "last_blss", "last_nbws", "last_grss", "last_sboss", "last_bst", "last_fass", "last_rss", "last_aboss", "last_pgn", "last_bass", "last_boss", "last_sbcss", "last_abcss", "last_abss", "last_vss", "last_nbcss", "last_bess", "last_prss", "last_rbss", "last_rbSS", "last_rass", "last_gss", "last_gst", "last_nbss", "last_sbSS", "last_pss", "last_fss", "last_blcss", "last_rbws", "last_rcss", "last_brss", "last_pass", "last_pcss", "last_gass", "last_blgn", "last_rgn", "last_blass", "last_poss"], "prot": ["prop", "type", "ht", "header", "offset", "ext", "bits", "pkg", " protocol", "method", "virtual", "ef", "protected", "eth", "style", " PROT", "def", "version", "tr", "io", "net", " protocols", "aff", "top", "phy", "Prot", "iot", "tf", "txt", "mat", "ocol", " proto", "lag", "prototype", "rot", "cmd", "policy", "chron", "phys", "desc", "next", "col", "supported", "format", "seq", "pro", "tif", "stat", "tech", "platform", "pat"], "host_start": ["Host_try", "host_Start", "host64offset", "host_next", "hosttfrom", "host09begin", "host64first", "host_first", "host_try", "node_start", "hosttoffset", " host_started", "Host_store", "host_started", " host_begin", "hosttend", "Host_end", " host_base", " host_Start", "host_begin", "Host_offset", "node09start", "host09next", "host1start", "host1begin", "host64start", "node09end", "host_offset", "host1next", "node_end", "host09start", "host_store", "host64begin", "host09end", "host_base", "node09begin", "host_from", "node_begin", "Host_start", " host_first", "host1end", "node09next", "hosttstart", " host_offset", "Host_from", "node_next"], "host_map_start": ["host_set_begin", "host_map_need", "host_map_left", "host_mapingneed", "host_map_offset", "host_mapingstep", "host_map_init", "host_list_size", "host_list_start", "host_mapingend", "host_cap_offset", "host_cache_size", "host_set_init", "host_cache_left", "host_cap_start", "host_set_end", "host_start_start", "host_cache_begin", "host_cache_init", "host_map_begin", "host_set_start", "host_cap_size", "host_list_end", "host_cache_start", "host_start_step", "host_map_size", "host_map_step", "host_start_need", "host_mapingstart", "host_map_stop", "host_cache_end", "host_cache_offset", "host_start_end", "host_map_end"], "host_end": ["server_begin", "host7begin", "host7ends", "server_ends", "host7start", "host_ending", "Host_ending", "host_End", "Host_end", "host_begin", "localhost_id", "host_ends", "Host_End", "server_end", "port_End", "host_ended", "localhost_stop", "port_end", "localhost_end", "host_size", "server_start", "host_stop", "host_id", "host7end", "Host_start", "port_ended", "localhost_size", "port_start"], "p": ["f", "g", "pkg", "P", "jp", "fp", "pre", "c", "h", "post", "i", "per", "q", "cp", "y", "pp", "np", "pb", "pl", "u", "php", "r", "lp", "pc", "l", "wp", "m", "ap", "d", "imp", "ping", "v", "pa", "pic", "pro", "perm", "pe", "t", "rep", "tp", "j"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_biwgt_4x4multiple_msa(uint8_t *src,\n\n                                      int32_t src_stride,\n\n                                      uint8_t *dst,\n\n                                      int32_t dst_stride,\n\n                                      int32_t height,\n\n                                      int32_t log2_denom,\n\n                                      int32_t src_weight,\n\n                                      int32_t dst_weight,\n\n                                      int32_t offset_in)\n\n{\n\n    uint8_t cnt;\n\n    uint32_t load0, load1, load2, load3;\n\n    v16i8 src_wgt, dst_wgt, wgt;\n\n    v16i8 src0, src1, src2, src3;\n\n    v16i8 dst0, dst1, dst2, dst3;\n\n    v8i16 temp0, temp1, temp2, temp3;\n\n    v8i16 denom, offset, add_val;\n\n    int32_t val = 128 * (src_weight + dst_weight);\n\n\n\n    offset_in = ((offset_in + 1) | 1) << log2_denom;\n\n\n\n    src_wgt = __msa_fill_b(src_weight);\n\n    dst_wgt = __msa_fill_b(dst_weight);\n\n    offset = __msa_fill_h(offset_in);\n\n    denom = __msa_fill_h(log2_denom + 1);\n\n    add_val = __msa_fill_h(val);\n\n    offset += add_val;\n\n\n\n    wgt = __msa_ilvev_b(dst_wgt, src_wgt);\n\n\n\n    for (cnt = height / 4; cnt--;) {\n\n        LOAD_4WORDS_WITH_STRIDE(src, src_stride, load0, load1, load2, load3);\n\n        src += (4 * src_stride);\n\n\n\n        src0 = (v16i8) __msa_fill_w(load0);\n\n        src1 = (v16i8) __msa_fill_w(load1);\n\n        src2 = (v16i8) __msa_fill_w(load2);\n\n        src3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        LOAD_4WORDS_WITH_STRIDE(dst, dst_stride, load0, load1, load2, load3);\n\n\n\n        dst0 = (v16i8) __msa_fill_w(load0);\n\n        dst1 = (v16i8) __msa_fill_w(load1);\n\n        dst2 = (v16i8) __msa_fill_w(load2);\n\n        dst3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        XORI_B_4VECS_SB(src0, src1, src2, src3, src0, src1, src2, src3, 128);\n\n\n\n        XORI_B_4VECS_SB(dst0, dst1, dst2, dst3, dst0, dst1, dst2, dst3, 128);\n\n\n\n        ILVR_B_4VECS_SH(src0, src1, src2, src3, dst0, dst1, dst2, dst3,\n\n                        temp0, temp1, temp2, temp3);\n\n\n\n        temp0 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp0);\n\n        temp1 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp1);\n\n        temp2 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp2);\n\n        temp3 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp3);\n\n\n\n        SRA_4VECS(temp0, temp1, temp2, temp3,\n\n                  temp0, temp1, temp2, temp3, denom);\n\n\n\n        temp0 = CLIP_UNSIGNED_CHAR_H(temp0);\n\n        temp1 = CLIP_UNSIGNED_CHAR_H(temp1);\n\n        temp2 = CLIP_UNSIGNED_CHAR_H(temp2);\n\n        temp3 = CLIP_UNSIGNED_CHAR_H(temp3);\n\n\n\n        PCKEV_B_STORE_4_BYTES_4(temp0, temp1, temp2, temp3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n    }\n\n}\n", "idx": 16498, "substitutes": {"src": ["url", "rt", "sl", "tmp", "length", "ser", "rs", "st", "ins", "sn", "ctr", "sq", "copy", "rx", "rc", "rl", "sur", "urg", "cont", "scale", "sc", "comp", "in", "rol", "syn", "sub", "img", "dist", "loc", "load", "iv", "inst", "target", "sr", "sort", "buf", "scan", "sys", "dest", "hl", "s", "str", "obs", "lb", "filename", "cur", "raw", "source", "addr", "usr", "input", "ptr", "sel", "bs"], "src_stride": ["src_provide", "src_grice", "src_strider", "src_slope", "src_strride", "src_divide", "src_brine", "src_divIDE", "src_collide", "src_provope", "src_depthride", "src_collage", "src_bride", "src_brid", "src_provage", "src_strage", "src_slice", "src_collope", "src_grid", "src_strIDE", "src_slage", "src_strope", "src_strine", "src_depthide", "src_trice", "src_divider", "src_gride", "src_provice", "src_STRride", "src_STRider", "src_collice", "src_STRIDE", "src_divride", "src_brice", "src_trid", "src_depthider", "src_depthIDE", "src_grine", "src_slide", "src_STRide", "src_trine", "src_strid", "src_tride", "src_strice"], "dst": ["Dest", "Dnd", " dnd", "Dst", "fdest", "Ddest", "dest", "fdnd", "fdst", "dnd", "ddest", " dest", " ddest", "fddest"], "dst_stride": ["dst_trider", "dst_drride", "dst_collid", "dst_drider", "dst_tride", "dst_drid", "dst_collide", "dst_collride", "dst_trride", "dst_strid", "dst_strride", "dst_collider", "dst_strider", "dst_trid", "dst_dride"], "height": ["window", "length", "type", "block", "th", "rank", "cache", "chain", "shift", "h", "tx", "depth", "size", "shape", "buffer", "style", "dim", "bottom", "padding", "y", "read", "max", "grow", "vol", "rows", "available", "index", "kw", "row", "ctx", "stack", "history", "through", "ty", "capacity", "count", "x", "status", "resolution", "base", "density", "Height", "range", "volume"], "log2_denom": ["log2_enom", "log2_derom", "log2_denormal", "log2_genomin", "log2_denomin", "log2_genoms", "log2_donoms", "log2_derot", "log2_enum", "log2_DenOM", "log2_genom", "log2_Denom", "log2_enOM", "log2_derOM", "log2_genOM", "log2_donom", "log2_denum", "log2_enot", "log2_Denum", "log2_deroms", "log2_Denoms", "log2_denot", "log2_derum", "log2_Denormal", "log2_donomin", "log2_denoms", "log2_Denomin", "log2_donormal", "log2_deromin", "log2_Denot", "log2_denOM"], "src_weight": ["src2hack", "sslmmweight", "ctrl_weight", "src___id", "srcmmfee", "ack_weight", "sslmmfee", "src___hack", "src_dim", "src___index", "ack___index", "src_id", "ctrl_Weight", "srcmyid", "src_mean", "sslmmspeed", "ssl_weight", "src_fee", "ack___id", "src___dim", "src_hack", "src___weight", "src_Weight", "src___mean", "src_index", "ack_mean", "srcmyweight", "ssl_speed", "srcityid", "ack___mean", "ssl_fee", "ssl_width", "src___Weight", "ctrl_hack", "src2dim", "src2weight", "ack_index", "srcityindex", "srcmymean", "srcmmspeed", "src_speed", "srcmmweight", "sslmmwidth", "src2Weight", "ack_id", "srcmmwidth", "src_width", "srcityweight", "ctrl_dim", "ack___weight", "srcitymean", "srcmyindex"], "dst_weight": ["drc_weight", "dst___weights", "dnd_weights", "dest_frequency", "dst_power", "dst_weights", "dst_money", "drc_default", "dstThefrequency", "dstThemoney", "dnd_power", "dnd_Weight", "dst___weight", "dnd_weight", "dstTheweight", "dst_Weight", "dest_weight", "dstTheweights", "dest_weights", "dest_money", "dst_link", "dst_frequency", "dst___money", "dst_default", "drc_link", "dst___frequency"], "offset_in": [" offset_cin", "offset____nin", "scroll____nin", "scroll_inc", "offset___inc", "offset____inc", "offset67in", "scroll_ex", " offset_IN", "offset_nin", "offset2nin", "alias___ex", "offset___nin", "offset____ex", "alias_in", "offset___gin", "scroll_nin", "offset_IN", "offset_cin", "alias_ex", "offset___in", "set_inc", "offset___ex", "offset2ex", "offset67IN", "alias_nin", "offset67cin", "offset_inc", "offset_ex", "offset_int", "scroll_in", "offset67In", "offset__int", "scroll____inc", "offset__in", "offset____in", "offset2inc", "offset67ex", "offset_In", "set_int", "alias___in", "set_in", "offset__inc", "offset67nin", "alias___gin", "offset2in", "offset_gin", " offset_In", "alias_gin", "offset67gin", "alias___nin", "scroll____in", "scroll____ex"], "cnt": ["acnd", "acnt", "pcount", "pcnd", "cct", "acct", "cNT", "pcnt", "pcNT", "Cnt", " cNT", "Cct", "CNT", "acNT", "Count", " ccount", "ccount", "acount", " cct", "uncNT", "unccount", "Cnd", "count", "cnd", " count", "uncnt", "uncount", "Ccount", "account"], "load0": ["loader2", "loader0", "load8", "LOAD2", "loader1", "pick1", "pick0", " load8", "LOAD0", "LOAD1", "loader8", "pick8", "loader3"], "load1": ["load01", "pick11", "pick01", "require2", "require4", "read3", "loader2", "load4", "loader11", " load4", "read2", "read4", "loader1", "require10", "pick1", "load10", " load11", "read1", " load10", " load01", "load11", "loader3", "read10", "pick2", "require1", "loader01"], "load2": ["fail8", "require2", "read3", "loader2", "fail3", "fail1", "play02", "load8", " load02", "read2", "play3", "fail2", "play1", "loader1", "play2", "loader02", "require3", " load8", "load02", "loader8", "read1", "fail02", "read02", "loader3", "require8", "require1"], "load3": ["pay3", "fail0", "pack1", "fail3", "loader2", "play6", " load103", "pack2", "load103", "LOAD2", "pack3", "play3", "fail2", " load5", "loader5", "play1", "loader1", "play2", "loader6", "pay2", "pay103", "LOAD3", "LOAD1", "fail103", "pay0", "LOAD5", "loader3", "load5", "load6", "pack6"], "src_wgt": ["src_Wgs", "src_awgz", "src_rlt", "src_wwht", "src_wwgz", "src_Wgt", "src_wg", "src__wdr", "src_wlt", "src_rgt", "src_wrlt", "src_wwgt", "src_Wg", "src_rht", "src_wwger", "src_rdr", "src2wrger", "src_wrht", "src_rgz", "src_wdr", "src2wht", "src_rger", "src_Wgz", "src2wrgt", "src__awlt", "src2wgz", "src_awdr", "src_wrgz", "src_rwgs", "src__awgz", "src__awgt", "src_wrdr", "src2wrht", "src__awdr", "src_awgt", "src_wgs", "src_rwgz", "src_rwgt", "src_rg", "src_wht", "src__wlt", "src__wgz", "src_wger", "src_rgs", "src2wgt", "src_rwg", "src_wrgt", "src__wgt", "src2wger", "src2wrgz", "src_wgz", "src_wrger", "src_awlt"], "dst_wgt": ["dst_wmt", "dst_wgs", "dst2hrt", "dst_ewmt", "dst_wgz", "dst_awgt", "dst2wrt", "dst_Wgz", "dst_rrt", "dst___wagt", "dst___awtg", "dst_wrt", "dst___wagb", "dst_wagn", "dst_ewtg", "dst_ewgt", "dst2hgt", "dst_wrgb", "dst2wgs", "dst_wrtg", "dst_Wgt", "dst_trt", "dst___wmt", "dst2wgt", "dst_tgz", "dst_hgt", "dst_awtg", "dst2wgz", "dst_hgz", "dst___wgt", "dst_wrlt", "dst_Wgn", "dst_wgn", "dst_ewlt", "dst_wagz", "dst_awmt", "dst___wtg", "dst_Wgb", "dst_wagt", "dst_tgt", "dst2hgz", "dst_wlt", "dst_wrgn", "dst_hrt", "dst_wrmt", "dst___wgz", "dst_awlt", "dst_tgs", "dst___wlt", "dst___wgb", "dst___awlt", "dst_wtg", "dst___awgt", "dst_wrgt", "dst___wagz", "dst_wgb", "dst___wagn", "dst2hgs", "dst_wrgz", "dst_hgs", "dst___awmt", "dst_rgs", "dst_rgt", "dst_wagb", "dst___wgn", "dst_rgz"], "wgt": ["ewgt", "vgt", "wmt", " wgz", "wbgs", "ewgs", "Wgt", " wgs", "vmt", "Wmt", "vgz", "wbgn", "Wrt", "wbgt", "ewrt", "wbrt", "wgn", "wgz", "vrt", "Wgz", " wrt", "wrt", " wgn", "wgs", " wmt", "ewgn"], "src0": ["sr00", "rc1", "src00", "rc3", "source_", "src_", "source1", "sr1", "sr3", "source0", "loc3", "rc_", "rc00", "loc00", "rc0", " src_", "loc1", "sr0", "loc0"], "src1": ["rc1", "source2", "srcOne", "rc3", "sr2", "source1", "rc2", "sr1", "sr3", "rc11", "sourceOne", " srcOne", "sr11", "src11", "rcOne", " src11"], "src2": ["srTwo", "rc1", "source2", "srcTwo", "sr2", "src01", "source1", "rc2", "sr1", "source0", "sr01", "rc01", "source01", "rc0", "sourceTwo", "rcTwo", "sr0"], "src3": ["rc1", "source2", "source03", "rc3", "rc2", "source1", "source3", "rc03", "src43", " src03", "rc43", " src43", "source43", "src03"], "dst0": ["lest1", "ddest1", "dist0", "dist1", "lst2", "lst0", "lest2", "dest0", "dest1", "lest3", "lst3", "ddest2", "lest0", "ddest3", "lst1", "dist3", "dest2", "dist2", "dest3", "ddest0"], "dst1": ["dst91", "dist0", " dist0", "dist1", "dist91", "dstop1", "dstop2", "dstop91", "dest0", "dest1", " dist1", "dstop0", " dst91", "dest91", "dest2", " dist91", " dist2", "dist2"], "dst2": ["dset2", "dint4", "dint3", "idset4", "idst3", "dset4", "dest4", "dst4", "dint2", "dset3", "idst2", "idset2", "dest2", "idst4", "idset3", "dest3"], "dst3": [" dsp2", "drciii", "dist1", " dsp3", " dstiii", "dspiii", "dsp2", "distiii", "drc3", " dspiii", "dsp3", "dsp1", "dist3", "drc2", "dstiii", "drc1", " dsp1", "dist2"], "temp0": ["tmp1", "tmp00", "level0", " temp00", "level1", "level00", "tmp0", "tmp2", "level2", "temp00"], "temp1": ["tem0", "tc01", "temp01", "tem2", "tem1", " temp01", "tc0", "tc1", "tem01", "tc2"], "temp2": ["Temp2", "test2", "Temp02", "temp02", "Temp1", "tempTwo", " tempTwo", "test02", "TempTwo", " temp02", "test1", "testTwo"], "temp3": ["Temp2", "tmp1", "Temp1", "tmp3", "tmp2", "Temp3"], "denom": ["Denom", "lenot", " denot", "Denoms", "denorm", "monoms", "lenorm", "Denum", " denoms", "lenom", "lenum", "monum", "monom", "denoms", " denum", "denum", "Denot", "Denorm", "monorm", "denot", " denorm"], "offset": ["bit", "type", "length", "attr", "block", "scroll", "end", "slot", "tile", "ref", "shift", "point", "temp", "origin", "xy", "i", "seed", "size", "Offset", "position", "ot", "order", "len", "error", "attribute", "pos", "padding", "elt", "loc", "unc", "set", "value", "num", "index", "off", "out", "key", "val", "rot", "weight", "alt", "bound", "start", "addr", "timeout"], "add_val": ["add_VAL", "add67val", " add_v", "add67cal", "add_cal", "added_val", "add2val", "add2value", " add_value", "add_value", "added_cal", "add67pol", "add_v", "added_pol", "add_pol", "add2VAL", " add_VAL"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,\n\n                              TCGReg arg1, intptr_t arg2)\n\n{\n\n    int opi, opx;\n\n\n\n    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);\n\n    if (type == TCG_TYPE_I32) {\n\n        opi = LWZ, opx = LWZX;\n\n    } else {\n\n        opi = LD, opx = LDX;\n\n    }\n\n    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);\n\n}\n", "idx": 16501, "substitutes": {"s": ["f", "is", "sl", "g", "rs", "scl", "a", "c", "h", "sq", "js", "ss", "sc", "ns", "set", "r", "ts", "m", "es", "b", "n", "sb", "ds", "qs", "ses", "w", "S", "gs", "cs", "ps", "t", "conf", "fs", "p"], "type": ["get", "all", "ype", "ref", "test", "otype", "role", "port", "or", "style", "dt", "error", "y", "like", "null", "p", "al", "class", "kind", "ver", "re", "types", "e", "function", "sys", "now", "id", "ping", "ct", "o", "time", "ty", "TYPE", "state", "key", "cmd", "et", "file", "no", "format", "pe", "typ", "at", "mt", "t", "range", "Type", "tp", "name", "ry"], "ret": ["rt", "reg", "ext", "gt", "ref", "result", "complete", " RET", "std", "iter", "err", "rl", "rem", "des", "def", "res", " arg", "re", "arg", "resp", "det", "RET", "Ret", "rev", "sys", " Ret", "back", "out", "reset", "val", "rets", "cmd", "desc", "alt", "mem", "status", "lib", "fun", "nt", "try", "reply", "red", "ry"], "arg1": [" targ2", "arg0", " arg0", "argOne", " argOne", " targ3", "tagOne", "Arg2", " targ0", " arg3", "tag01", " Arg1", "Arg01", " arg01", "ArgOne", "arg3", "tag1", "arg01", "tag2", "Arg1", " Arg0", " Arg3", " targ1", " Arg2"], "arg2": ["arg0", " arg0", "Arg2", "ig2", "Arg3", " arg3", "vol1", "arg02", " argtwo", "val2", "val1", "ig1", "arg3", "argtwo", "Arg1", "valtwo", "val02", "voltwo", "vol2", "Arg0", "ig3", "ig0", " arg02", "vol02"], "opi": ["optis", " oppi", "osti", " opdi", "ropiu", " popi", " apI", "OPpi", "copci", " opis", "Opin", "OpI", " apis", "ropui", "ostpi", " popI", "opin", " popis", "ostui", "ropi", "OPis", "OPdi", "opci", "opI", "OPi", "opbi", "oppi", " apin", "OPiu", "ostbi", "optiu", "ropci", "ropbi", " api", "coppi", "opti", "copiu", " opui", " popin", "opis", " opiu", " opbi", "Opi", "opdi", "OPci", "opui", "roppi", "copi", "opiu", "optdi", "Opis"], "opx": [" optx", " opxe", "OPxe", " opex", "aptx", " opX", "optx", "OPtx", " opxx", "OPx", "OPX", "hopxs", "opX", "hopix", "epX", "opxe", "opex", "epex", "eprx", " Opex", "opxx", "oprx", "opxs", " Opx", "opix", "epxx", "apx", "OPix", "hopX", "prerx", " oprx", " Opxs", " Opxx", "preX", " opix", "hopx", "epxs", "prex", "epx", "OPxs", "prexx", "apX", "apxe", " opxs"]}}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16507, "substitutes": {"mon": [" Mon", "mer", "mut", "mit", "ox", "admin", "mx", "cond", "mm", "onet", "cat", "min", "man", "mont", "util", "mu", "tem", "dm", "hog", "monkey", "wat", "monitor", "m", "MON", "den", "Mon", "meter", "ston", "mat", "mn", "om", "dom", "met", "chron", "mun", "ann", "sym", "mi", "mt", "med", "comm", "annot", "mons", "san"], "qdict": ["sqcompl", "sqdict", "qualdom", "questd", "questmap", "qualcompl", "qqd", "qualmap", "qmd", "qqdom", "qmap", "qqmap", "questmd", "questdict", "qqcompl", "sqmd", "qualdict", "qdom", "qd", "sqd", "sqmap", "sqdom", "qqdict", "qcompl", "qqmd"], "bs": ["ls", "bb", "bh", "ach", "bits", "bi", "ubs", "iss", "xs", "aps", "BS", "js", "lbs", "aches", "ras", "bp", "obs", "vs", "ns", "pb", "ubis", "ms", "ts", "locks", "its", "acs", "b", "bed", "bis", "sb", "bc", "s", "cks", "oss", "bos", "ds", "vals", "bps", "aus", "bl", "gs", "bas", "bm", "ists", "cs", "boxes", "bu", "blocks", "aos", "ps", "fs", "bes"], "bs1": ["cs1", "ns0", "bs2", "BS0", "bes2", "bus2", "besig", "cs4", "obs4", "bis11", "ns3", "bs4", "ns4", "obs6", "bes11", "ubs4", "bis1", "obs3", "bes1", "ns2", "obs64", "tsig", "ts1", "BS1", "ubs0", "bs64", "obs11", "busig", "BS4", "bus1", "bis4", "cs6", "bis3", "ts2", "bs3", "ps0", "ps2", "bes3", "ubs1", "besone", "bs0", "bs11", "tsone", "ts3", "obs1", "bis6", "ts0", "ps3", "bis64", "ps1", "bis0", "ubs2", "bsone", "busone", "cs0", "bes64", "bs6", "bsig", "obs0", "ns1", "BS2"], "err": ["kr", "Error", "attr", "cr", "later", "br", "rs", "er", "conn", "mr", "h", "oe", "iter", "fee", "cer", "ex", "Er", "inner", "or", "warn", "fr", "urg", "eor", "error", "res", "der", "obj", "elt", "cb", "rr", "norm", "ns", "r", "arr", "resp", "buf", "gr", "errors", "e", "ah", "sys", "conf", "off", "txt", "eas", "aaa", "ev", "gz", "out", "esp", "ocr", "ez", "ei", "str", "cmd", "msg", "dr", "erd", "usr", "ch", "ptr", "exc", "rn"], "name": ["new", "text", "type", "label", "alias", "nm", "ref", "cn", "nam", "part", "title", "info", "nl", "names", "order", "spec", "ni", "named", "path", "id", "ma", "local", "b", "n", "family", "key", "comment", "str", "prefix", "NAME", "Name", "data", "filename", "no", "w", "word", "ame", "admin"]}}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n", "idx": 16521, "substitutes": {"obj": ["tmp", "org", "act", "ht", "object", "conn", "hw", "bj", "ind", "so", "pkg", "obo", " ob", "onet", "ex", "js", "self", "os", "ot", "ic", "rb", "y", "obs", "img", "ns", "cb", "elt", "inst", "att", "src", "objects", "this", "sys", "id", "off", "txt", "ctx", "o", "po", "obb", "oc", "app", "cmd", "et", "tk", "ent", "op", "node", "ob", "nt", "oid", "addr", "og", "typ", "comm", "cmp", "bs", "Obj", "j", "ist"], "name": ["nam", "def", "al", "read", "named", "key", "filename", "old", "word", "node", "ame", "normal", "new", "alias", "xml", "nm", "title", "order", "null", "ns", "spec", "path", "code", "comment", "source", "ident", "admin", "p", "resource", "ext", "create", "err", "parent", "size", "term", "unknown", "error", "version", "class", "prefix", "on", "no", "range", "label", "attr", "part", "property", "info", "search", "names", "form", "r", "sequence", "list", "value", "id", "local", "n", "family", "missing", "description", "str", "NAME", "Name", "data", "common", "format", "base", "start", "t"], "type": ["unit", "length", "ype", "test", "otype", "title", "info", "role", "valid", "size", "style", "shape", "buffer", "version", "y", "error", "class", "kind", "ver", "types", "rel", "form", "sequence", "check", "value", "id", "ping", "time", "family", "TYPE", "key", "state", "ty", "where", "trace", "link", "file", "pe", "base", "typ", "tag", "t", "range", "Type"], "get": ["parse", "open", "g", "update", "gener", "use", "info", "ge", "ret", "draw", "def", "grab", "q", "access", "del", "like", "util", "read", "export", "build", "select", "load", "handle", "eval", "check", "query", "help", "call", "value", "rieve", "print", "cmd", "Get", "GET", "exec", "it", "make", "find", "gets", "field", "show", "getting", "give"], "set": ["parse", "end", "create", "update", "test", "use", "delete", "clear", "store", "setup", "sc", "server", "del", "util", "read", "select", "spec", "ver", "form", "check", "help", "apply", "value", "sys", "un", "enable", "sets", "se", "send", "reset", "change", "et", "write", "up", "site", "save", "make", "op", "hide", "place", "start", "mod", "add", "san"], "release": ["close", "resource", "throw", "sem", "execute", "require", "quire", "fail", "update", "test", "ca", "use", "delete", "develop", "launch", "manager", "slave", "grab", "LEASE", "forge", "ro", "version", "util", "load", "lease", "re", "commit", "reference", "available", "value", "leased", "un", "destroy", "mor", "broad", "hold", "leases", "Release", "released", "fire", "ase", "save", "establish", "make", "snap", "process", "may", "leasing", "range"], "opaque": ["popaque", "composition", "popula", "opute", "paque", " opatile", "opatile", "OPute", "boaques", "pca", "operaque", "opacity", "compacity", "OPaque", "OPacity", "compaque", "popatile", "operaques", "operosition", "OPca", "compaques", "popacity", "ipute", "patile", "pute", " opacity", " opula", "pacity", "oposition", "boosition", "ipca", "operacity", "ipaque", "boacity", "boaque", "opula", "opca", "pula", "opaques", "ipacity"], "errp": ["acerr", "rrp", "rrr", "erpb", " ercp", "rrpd", " erpb", "err", "rrpb", " erp", "rrcp", "acerp", " errpb", "erpd", "errpb", "errpd", " err", " errcp", "errcp", "erp", "acerpb", "errr", "acerpd", " errr"], "prop": ["plot", "def", "pp", "np", "pb", "pid", "zip", "po", "key", "mk", "val", "Prop", "req", "verb", "supp", "rest", "decl", "proc", "test", "pose", "temp", "lit", "pr", "cp", "pos", "bug", "spec", " Prop", "expr", "opp", "prot", "cmd", "phys", "par", "msg", "tag", "rep", "cfg", "pred", "p", "tmp", "opt", "pkg", "term", "port", "comp", "elt", "pl", "feat", "resp", "buf", "pt", "agg", "desc", "rop", "col", "pro", "try", "ptr", "crit", "coord", "attr", "ref", "jp", "gp", "property", "mp", "properties", "func", "grab", "acc", "xp", "att", "ph", "dest", "priv", "dep", "perm", "op", "stat", "ps", "j"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n", "idx": 16524, "substitutes": {"machine": ["present", "zone", "hard", "shell", "computer", "host", "connection", "mount", "walker", "linux", "mc", "manager", "server", "device", "power", "engine", "handler", "mom", "smart", "message", "dem", "sim", "model", "m", "monitor", "cpu", "series", "vm", "money", "local", "mode", "gate", "achine", "template", "state", "instance", "green", "managed", "controller", "di", "mac", "domain", "node", "module", "command", "process", "Machine", "iso", "hello", "spin", "keeper"], "cpu_model": ["cpu_class", "pu_type", "cpu_mode", " cpu_mode", " cpu_module", "pu_attribute", "cpu_module", "cpuaxyattribute", "CPU_attribute", "cpuPromodel", "cputimemode", "CPU_type", "cpu_domain", " cpu_class", "cputimeattribute", "cpu_link", "pu_domain", "CPU_Model", " cpu_link", "cputimedomain", "pu_status", "CPU_model", "cpu_Model", "cpuProdomain", "cpu_type", "cpu_status", "cpuPromode", "cpuProattribute", "cpuaxytype", "cputimemodel", " cpu_models", "pu_mode", "cpuaxyModel", "pu_model", "cpu_models", "cpu_attribute", "cpuaxymodel"], "kernel_filename": ["console_username", "system_binary", "kernelamebinary", "kernel___username", "kernel___pdf", "kernelfilebinary", "kernelamesource", "board_wit", "kernelfilefile", "kernelamefilename", "system_file", "kernel_source", "kernelistfile", "console___binary", "console___filename", "boardamefilename", "board_source", "kernelameusername", "kernel___source", "ernel_file", "console___command", "boardamepdf", "system_filename", "kernelamecommand", "kernel___binary", "kernel_family", "console___username", "board_pdf", "kernel_file", "kernel___command", "boardamesource", "kernelistdir", "kernel_username", "kernel_pdf", "system_dir", "kernelistbinary", "kernelfiledir", "kernelistfilename", "kernel_binary", "ernel_original", "ernel_family", "kernel_original", "kernelamewit", "boardamewit", "console_filename", "kernel_wit", "kernel_dir", "board_filename", "console_command", "kernelamepdf", "ernel_filename", "console_binary", "kernelfilefilename", "kernel___wit", "kernel___filename", "kernel_command"], "kernel_cmdline": ["kernel_mdLine", "kernel_commandlines", "kernel_cookLine", "kernel_cmdLine", "kernel_commandline", "kernel_genLine", "kernel_commandtype", "kernel_condline", "kernel_cooktype", "kernel_condspec", "kernel_readLine", "kernel_cmdde", "kernel_condLINE", "kernel_commandLine", "kernel_condLine", "kernel_genln", "kernel_cmdtype", "kernel_cssline", "kernel_cmdspec", "kernel_gentype", "kernel_genline", "kernel_cssLINE", "kernel_readline", "kernel_catsline", "kernel_mdline", "kernel_cookline", "kernel_readde", "kernel_cssspec", "kernel_readln", "kernel_catsde", "kernel_cmdln", "kernel_cssLine", "kernel_commandspec", "kernel_commandln", "kernel_mdlines", "kernel_catsLine", "kernel_cmdlines", "kernel_cookln", "kernel_cmdLINE", "kernel_commandLINE", "kernel_catsln", "kernel_commandde"], "initrd_filename": ["initrt__cmd", "initrdityfile", "initrdetyfile", "initrd_fle", "initrd__filename", "initrt__files", "initrdityfilename", "initrr_files", "initrt_file", "initrr_fp", "initdrmetyfile", "initdrm_cmd", "initrdmmcmd", "initrdetyfilename", "initdrmetycmd", "initrd__file", "initrdmmfiles", "initrar_FILE", "initrdmmfile", "initrd___files", "initrd_files", "initdrmetyfilename", "initrd__cmd", "initdrm_filename", "initrd_fp", "initrr_filename", "initrd_FILE", "initrd_cmd", "initrt__filename", "initrdetytty", "initrr_file", "initrdityFILE", "initrd___filename", "initrt_cmd", "initrt_files", "initrar_file", "initrdityfle", "initrd_tty", "initrd__files", "initrt__file", "initdrmetytty", "initrd___fp", "initrd_file", "initdrm_file", "initdrm_tty", "initrar_fle", "initrdmmfilename", "initrar_filename", "initrd___file", "initrdetycmd", "initrt_filename"], "s": ["sl", "is", "sts", "g", "rs", "sv", "states", "so", "a", "h", "sq", "c", "sis", "sm", "i", "os", "ss", "y", "ns", "e", "sys", "ts", "m", "sing", "sp", "b", "se", "space", "sports", "sb", "socket", "state", "stats", "ds", "ses", "w", "S", "sam", "gs", "sa", "ps", "t", "fs", "p"], "dinfo": ["odii", "DInfo", "Dinf", " dii", "dlinformation", "sdinf", "didquery", "dinner", "sdinner", "odnotice", "diiter", "dlinf", "Dii", "pinner", "adcomment", "ddinfo", "pinf", "didinf", "ddcache", "odInfo", "sdInfo", "dinit", "dcache", "sdcomment", "sdentry", "sdinit", "dquery", "dii", "odinf", "adInfo", "dlinfo", " diter", "diINFO", "didconf", "Dno", "daconf", "dlnotice", " dno", " dconf", "dentry", "adentry", " dINFO", " dinit", "daquery", "diinfo", " dcache", "pinit", " dInfo", "dinformation", "Dinfo", "dditer", " dcomment", " dquery", " dentry", " dinf", " dinner", "didiso", "didno", "dInfo", "dicache", "odinformation", "adinfo", " dnotice", "diter", "dainfo", "dnotice", "Diso", "pinfo", " diso", "dINFO", "dno", "dconf", "didinfo", "odinfo", "ddINFO", "dinf", "dcomment", " dinformation", "diso", "sdinfo"], "sysmem": ["syphys", "ysphys", "sysm", " sysmemory", "ysm", "skymem", "ysmb", "skym", "ysmemory", "sysmb", "sysMem", "sysmemory", "sysphys", " sysmb", "systemMem", " sysMem", "skymemory", "symemory", "symem", "systemmemory", "ysmem", "skyphys", "sym", "ysMem", "systemmem", "systemmb"]}}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)\n\n{\n\nPOWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);\n\n#ifdef ALTIVEC_USE_REFERENCE_C_CODE\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));\n\n      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));\n\n      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));\n\n      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#else /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;\n\n    register vector unsigned char perm = vec_lvsl(0, pixels);\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      pixelsv1 = vec_ld(0, (unsigned char*)pixels);\n\n      pixelsv2 = vec_ld(16, (unsigned char*)pixels);\n\n      blockv = vec_ld(0, block);\n\n      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);\n\n      blockv = vec_avg(blockv,pixelsv);\n\n      vec_st(blockv, 0, (unsigned char*)block);\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#endif /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n}\n", "idx": 16536, "substitutes": {"block": ["blocking", "box", "random", "ip", "Block", "check", "out", "link", "frame", "limit", "snap", "new", "bit", "object", "offset", "tx", "side", "pos", "wall", "group", "zero", "index", "row", "global", "context", "empty", "loop", "bl", "blocks", "name", "p", "unit", "window", "disk", "header", "BL", "chain", "map", "channel", "point", "parent", "buffer", "byte", "load", "commit", "model", "record", "k", "book", "prefix", "x", "file", "no", "number", "image", "range", "batch", "type", "label", "open", "lock", "draw", "board", "mask", "position", "pixel", "line", "height", "list", "num", "id", "bin", "base", "pack", "volume"], "pixels": [" puls", "psixels", "mixels", "pips", "Peters", "ppixels", "pipers", "ipixels", "muli", "npixel", "pix", "pseters", "psixel", " pixel", "Pixel", "cpuls", "cpeters", "cpixel", "dkins", "Piles", "psipers", "Pels", "modes", "dixels", "psuls", " pipers", "psuli", "ppels", "cpipers", " pels", "Pix", "psips", "ipipers", "puls", "deters", "apipers", "peters", " poms", "piles", "Pixels", "ppix", "dixel", " pix", "pkins", "mips", "poms", "ipixel", "apix", "apixel", "mipers", "mixel", "npixels", "moms", "podes", " peters", "psodes", "puli", "cpuli", "ppipers", "pixel", " piles", "apixels", "ipiles", "npeters", "npix", "ppiles", "npipers", "psoms", "pels", "Pipers", " pkins", " podes", "cpixels", " pips", "npels", "npiles", "pskins"], "line_size": [" line_number", " line_space", "line_SIZE", "line_height", " line_SIZE", "line_space", "line8scale", "line_width", " line_count", "line8number", "line_number", " line_height", " line_scale", "line_count", "line8SIZE", "line8size", "line8count", "line_scale", " line_width", "line8space"], "h": ["hr", "ih", "bh", "ht", "header", "hh", "H", "c", "uh", "q", "eh", "he", "y", "head", "ha", "hz", "r", "hm", "oh", "height", "l", "m", "b", "kh", "k", "n", "v", "his", "hl", "history", "x", "loop", "w", "it", "hi", "ch", "t", "hash", "hs", "p"], "i": ["us", "is", "init", "a", "ip", "y", "ami", "ims", "qi", "e", "v", "I", "ii", "phi", "hi", "t", "f", "iy", "ui", "\u0438", "pi", "im", "uli", "index", "w", "mi", "multi", "p", " I", "g", "gi", "ind", "chain", "xi", "err", "ki", "ex", "cli", "ai", "q", "li", "io", "iu", "by", "um", "ci", "l", "sim", "m", "me", "eu", "ti", "x", "try", "ij", "si", "bi", "info", "ic", "in", "zi", "this", "d", "id", "gu", "b", "n", "through", "ei", "ix", "di", "it", "ini", "z", "j"], "pixelsv1": ["pixelsen1", "petersv1", "petersvons", "pixelsenanta", "pixelsvanta", "pipersv10", "petersveons", "pixelssv2", "pixelsl1", "pipersv0", "pixv9", "pixelsp10", "pixelssv0", "pixelssv1", "pixelsV1", "petersveon", "pixelsvon", "pixelsveon", "pixelsm2", "pipersp0", "petersvon", "pipersp2", "pixelsp0", "pixelsl9", "pipersv2", "pixelsvvanta", "pixelsv10", "pixelsV10", "pixelsenon", "pixelsv4", "pixelsV0", "pixelsV2", "pixelsp1", "pixelsenons", "pipersp10", "pixelssv10", "pixelsvvons", "pixelsveons", "pipersv1", "pixelsve1", "petersveanta", "pixv4", "pixelsm1", "pixelsm4", "pipersp1", "pixelsl2", "pixelsv0", "pixelsvons", "pixelsm9", "petersvanta", "pixelsveanta", "pixelsvvon", "pixelsvv1", "pixelsp2", "pixv1", "pixelsv9", "petersve1", "pixv2", "pixelsl4"], "pixelsv2": ["pixelsav1", "pixelsver1", "pixf2", "pixelsV02", "pixelsav9", "pixelsvertwo", "pipsv1", "pixelsl1", "pixelsvc2", "pixelsav3", "pixv9", "picksvtwo", "picksver1", "pixelsV1", "pixelsl02", "pipsv2", "picksv2", "picksv1", "pixelsvc1", "pixelsf2", "pixelsV6", "pixelsv3", "pixelsvctwo", "pipsl02", "pipsl1", "pixelsV2", "pixf9", "pipsl6", "picksvertwo", "picksver2", "pipsv6", "pixelsv02", "pixf1", "pixelsf3", "pixelsl2", "pipsl2", "pixelsf9", "pixelsver2", "pixelsvtwo", "pixelsf1", "pixelsv6", "pixf3", "pixelsav2", "pipsv02", "pixelsl6", "pixelsav6", "pixv3", "pixv1", "pixelsv9", "pixv2", "pixelsav02"], "pixelsv": ["pentsi", "pipersp", "pipsf", " pairsl", "pixelsl", "pipsp", "pipersl", " pairsf", " pixelsf", "pulsei", "pentsv", " pixelsi", "pixelsconv", " pipsi", "pairsl", " pairsp", " pairsv", " pixelsconv", "pairsp", "pairsv", "pulsev", "pipsv", "pipsl", "pixelsp", " pipsconv", "pixelsf", "pipsconv", "pipsi", "pulseconv", "pixelsi", "pipersf", " pixelsl", " pipsv", " pixelsp", "pulsel", " pipsl", "pentsl", "pentsconv", "pipersv", "pairsf"], "blockv": ["linep", " blockp", "lineg", "blockp", "linkv", "Blockp", " blockvi", "Blockv", "boxv", "lockV", "linev", "block_", " block_", "lockv", "box_", "blockg", "boxj", "blockV", "BlockV", " blockV", "lockj", "Blockg", "boxp", "linkV", " blockg", "blockj", " blockj", "linkvi", "boxV", "blockvi", "lockp", "lock_", "lineV", "Blockvi"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n", "idx": 16542, "substitutes": {"blkdev": [" blckden", "blckdef", "blksswitch", "blksden", "blkerdevice", "blkerDev", "bltkden", " blckdev", "blksdevice", "blckDev", "blckswitch", "blkDev", "blkden", "blkerserver", " blkDev", "blktdef", "blksdev", "blckden", "blkserver", " blckdef", " blckdevice", "bltkdev", "blckserver", " blckserver", "blckdev", "blkerswitch", " blkswitch", " blkdef", "blktserver", "bltkdevice", " blkdevice", "blkclient", "blktdev", "bltkDev", "blkswitch", "blunkDev", "blkdevice", " blckDev", " blkserver", " blckswitch", "blunkdev", "blunkclient", "blkerdev", "blksclient", "blckclient", " blckclient", " blkden", "blktDev", "blunkdevice", "blckdevice", "blksDev", "blkdef", "blkerdef", " blkclient"], "ioreq": ["liressoquest", "ioveqi", " ioresql", "iorerc", "ioserquest", "liressoqu", "iorich", " ioresq", "iorec", " iorerq", "pioresqs", "liressoquant", "pioreqs", " ioreqi", "ioreql", "liorequ", "ioringquest", "ioresquest", " iorequest", " iorerc", "iorerqi", "piorerqs", " ioresquest", "ioveqs", " iorerqs", " iorec", "iressoq", "iressoquant", "ioresqs", "iorequest", "iorequant", "lioreq", "piorequant", "piorerquest", "ioringqu", "pioresquest", "ioriqs", "iareql", "ioresq", "piorech", "iorenquest", " iorerqi", " ioreql", "pioresquant", "iareqs", "piorequest", "iressoquest", "iorerq", "ioresquant", "iorerqu", "ioringquant", "iorench", "iressoqu", "ioreqs", "ioserquant", "iorenq", "liressoq", "iorenqs", " ioreqs", "ioserq", "ioriq", "iorerquant", "piorerq", "iorequ", "iarequest", "iorerquest", "iorech", "piorerch", "iorerql", "ioserqs", "iareq", "pioresq", "ioveq", "liorequest", " ioresqs", "ioreqi", "iorerqs", "iorerch", "ioriquest", "liorequant", "pioreq", "ioringq", "iovec", "ioresql"]}}
{"project": "qemu", "commit_id": "6c7565028c272c4c6f2a83c3a90b044eeaf2804a", "target": 0, "func": "static int interface_client_monitors_config(QXLInstance *sin,\n\n                                        VDAgentMonitorsConfig *monitors_config)\n\n{\n\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n\n    QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);\n\n    int i;\n\n    unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);\n\n\n\n    if (qxl->revision < 4) {\n\n        trace_qxl_client_monitors_config_unsupported_by_device(qxl->id,\n\n                                                               qxl->revision);\n\n        return 0;\n\n    }\n\n    /*\n\n     * Older windows drivers set int_mask to 0 when their ISR is called,\n\n     * then later set it to ~0. So it doesn't relate to the actual interrupts\n\n     * handled. However, they are old, so clearly they don't support this\n\n     * interrupt\n\n     */\n\n    if (qxl->ram->int_mask == 0 || qxl->ram->int_mask == ~0 ||\n\n        !(qxl->ram->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {\n\n        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,\n\n                                                            qxl->ram->int_mask,\n\n                                                            monitors_config);\n\n        return 0;\n\n    }\n\n    if (!monitors_config) {\n\n        return 1;\n\n    }\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n    /* limit number of outputs based on setting limit */\n\n    if (qxl->max_outputs && qxl->max_outputs <= max_outputs) {\n\n        max_outputs = qxl->max_outputs;\n\n    }\n\n#endif\n\n\n\n    memset(&rom->client_monitors_config, 0,\n\n           sizeof(rom->client_monitors_config));\n\n    rom->client_monitors_config.count = monitors_config->num_of_monitors;\n\n    /* monitors_config->flags ignored */\n\n    if (rom->client_monitors_config.count >= max_outputs) {\n\n        trace_qxl_client_monitors_config_capped(qxl->id,\n\n                                monitors_config->num_of_monitors,\n\n                                max_outputs);\n\n        rom->client_monitors_config.count = max_outputs;\n\n    }\n\n    for (i = 0 ; i < rom->client_monitors_config.count ; ++i) {\n\n        VDAgentMonConfig *monitor = &monitors_config->monitors[i];\n\n        QXLURect *rect = &rom->client_monitors_config.heads[i];\n\n        /* monitor->depth ignored */\n\n        rect->left = monitor->x;\n\n        rect->top = monitor->y;\n\n        rect->right = monitor->x + monitor->width;\n\n        rect->bottom = monitor->y + monitor->height;\n\n    }\n\n    rom->client_monitors_config_crc = qxl_crc32(\n\n            (const uint8_t *)&rom->client_monitors_config,\n\n            sizeof(rom->client_monitors_config));\n\n    trace_qxl_client_monitors_config_crc(qxl->id,\n\n            sizeof(rom->client_monitors_config),\n\n            rom->client_monitors_config_crc);\n\n\n\n    trace_qxl_interrupt_client_monitors_config(qxl->id,\n\n                        rom->client_monitors_config.count,\n\n                        rom->client_monitors_config.heads);\n\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);\n\n    return 1;\n\n}\n", "idx": 16566, "substitutes": {"monitors_config": ["monvisors_config", "monors_conf", "monagers_config", "monvisors_control", "monvisors___Config", "moners_config", "monitors00config", "monistors_cfg", "monifiers_error", "monitors____config", "monvisors_Config", "moners_conf", "monitorsetricoutput", "monitors___def", "monitorsureerror", "monitors_Config", "monistors___def", "monitors1error", "monitors_cfg", "monitors_desc", "monifiers_storage", "monvisors_spec", "monistors_config", "monitorsureexec", "monifiers_exec", "monitors_error", "monitors____control", "monvisors___control", "monitors1storage", "monvisors___config", "monitorsistexec", "monitors____name", "monitors___control", "monifiers_config", "monifiersureconfig", "monitorsistconfig", "monitors_name", "monitors_conf", "monitors___state", "monitors1config", "monitors_output", "monitors_conn", "monitors____conn", "monagers_control", "monitorsureconfig", "monitorsisterror", "monitors00conn", "monagers_name", "monitors___cfg", "monitors00name", "monistors_def", "monitorsiststorage", "monagers_conn", "monitorsetricconfig", "monitors___config", "monitorsetricdesc", "monors_desc", "monitorsurestorage", "monitors_control", "monistors___state", "moners_diff", "monitors00control", "monitors_diff", "monitors___spec", "monitors_spec", "monitors_storage", "monitors_exec", "monistors___cfg", "monistors___config", "monifiersureerror", "monitors___Config", "monitors1exec", "monistors_state", "monors_output", "monvisors___spec", "monifiersurestorage", "monors_config", "monitorsetricconf", "monitors_def", "monifiersureexec", "monitors_state"], "qxl": ["quxlock", "qtryf", " qxlc", "quxyla", "iqexml", "qumxf", "eqkd", "qexld", " quxlc", "quxml", "qxmllt", "qqxel", "iqxld", " qtxml", "queryxls", " qlexlc", "quxf", "qdxli", "quxyli", "queryrxli", "qqxl", "qxeslb", "qxilb", "qtryll", "quxhl", "qdxl", "requxl", "qxxlb", " quxhl", "qqxyel", "qxly", "qrxl", "queryrxl", "qrxlp", "sqxxlt", "chargenzlb", " quxla", "qlexls", "chargexlb", "qxid", "qixql", "requxal", "qlexl", "qxxlc", "quxli", "quxll", "qqxml", "qrxli", "qxeshl", "qwxld", "qtxql", "quxfl", "queryxl", "qxmllc", "qoverlay", "qxil", "qxpli", "iqexll", "qlexly", " qxlp", "qmxf", "qxdl", "qoverl", "qtxlay", "quxylb", "qbylb", "requxel", "iqxl", "qexl", "qxesli", "queuexL", "quxly", "qtxl", "qtxlb", "queueixL", "qmxly", "qoxln", "eqklock", "qumxhl", "requxala", "qoxf", "qtxla", "quxl", "qxli", " qlexld", "qxfl", "qxlt", "quxlc", "qxeslay", "qdxll", "chargexlay", "qrxel", "qpxml", " qxli", "qxL", "queryxln", "chargexl", "qxyfl", "qtryl", "qlexli", "qxphl", "qoxil", "qrxln", "qrxls", "qxyln", "quxyln", "requxael", "qxala", "qxlb", "eqxlock", "qoverlb", "qumxli", "qxylb", "qnzlb", "qxyla", "qxyml", "qxmlla", "qxclp", "qlexhl", "qxls", "qxcl", "qxxl", "qumxll", "qoverlt", "qwxlc", "iqexld", "sqxxl", "qoxll", "qoxlb", "qxal", "queryxli", "qxesly", "qxxlay", "chargenzlay", "qoxfl", "qxyls", "qxel", "qumxl", "qxyli", "qexll", "qixL", "qxmll", "requxla", "qpxld", "qxmlhl", "qmxli", "qpxll", " qxhl", "qxpl", "eqxl", "qqxyls", "queryrxln", "qxyel", "qxll", "queryrxls", "qxxli", "qxxlt", "qlexld", "qxln", "qxyl", "qbyfl", "quxyfl", "qoxl", "iqexl", "qxpml", "qxdli", "iqxml", "qoxli", "iqxll", "qxhl", "qklb", "qxlp", "qwxl", "queuexl", "qdxla", "qpxl", "quxlb", "qmxil", "qpxL", "qqxyml", "qtryil", "quxla", "sqxlt", "eqkl", " qlexl", "qpxql", "qbyl", "qdxld", "qtxlp", "qxxld", "qxld", "qlexel", " qxml", "qdxml", " qtxl", "qxesl", "qbyln", "qqxls", "qumxil", "qmxl", "qxael", "qxmllb", "qxplc", "qtxml", "qoxls", "qxf", "sqxxlb", "queueixl", "qxdln", "qxml", "quxyml", "qxlock", "qwxli", "sqxlb", "qmxhl", "qrxml", " qtxlp", "qlexml", "qxilock", "eqxlb", "qnzl", "qklock", "qmxll", "quxd", "qxla", "qkd", "qxd", " quxl", "qnzlay", "sqxlay", "qumxly", " qlexli", "qxmllay", "sqxxlay", "qxdls", "qlexlc", "queueixql", "queuexql", "quxln", "qxcml", "qxpla", "eqxd", "eqklb", "sqxl", "qkl", " qxla", "qtxel", "qqxyl", "qixl", "quxil", "qtxL", "qxlay", "qexml", " qxld", "qxlc", "quxyl", "chargenzl", "qxql"], "rom": ["irm", "rib", "rain", "reg", "ost", "cr", "rs", "mr", "ROM", "yan", "recomm", "rum", "mm", "ri", "cm", "rock", "rob", "rem", "rar", "gom", "drm", "serv", "rax", "ro", "gra", "res", "rol", "gem", "norm", "re", "r", "ram", "rome", "rim", "iam", "dem", "roma", "tom", "rss", "cpu", "chrom", "mn", "om", "ocr", "dom", "prom", "roy", "cmd", "arm", "ran", "rpm", "aram", "rm", "dr", "stan", "sky", "radio", "prem", "comm", "rd", "rep", "roc", "red", "ry"], "i": [" n", "us", " I", "is", "g", "bi", "gi", " mi", "c", "xi", "ai", "batch", " v", "li", "ui", "ic", "y", "ami", "in", "ip", " ii", "pi", "iu", " t", "u", "qi", "im", "e", "ci", " k", "sim", "m", "l", "me", "index", " pi", "v", "k", "I", " c", "n", "ii", "ti", "phi", "ix", " l", "x", " ti", " x", " m", "di", " ni", "it", "mi", " j", " e", "ini", "multi", "j", "si", "p"], "monitor": ["component", "profile", "minimum", "program", "execute", "map", "mate", "channel", "connect", "port", "manager", "device", "username", " mate", "match", "gray", "monkey", "watch", "param", "minute", "Monitor", "ctor", "member", "proxy", "mark", "command", "timeout", "batch"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);\n\n\n\n    /*\n\n     * virtio pci bar layout used by default.\n\n     * subclasses can re-arrange things if needed.\n\n     *\n\n     *   region 0   --  virtio legacy io bar\n\n     *   region 1   --  msi-x bar\n\n     *   region 4+5 --  virtio modern memory (64bit) bar\n\n     *\n\n     */\n\n    proxy->legacy_io_bar  = 0;\n\n    proxy->msix_bar       = 1;\n\n    proxy->modern_io_bar  = 2;\n\n    proxy->modern_mem_bar = 4;\n\n\n\n    proxy->common.offset = 0x0;\n\n    proxy->common.size = 0x1000;\n\n    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;\n\n\n\n    proxy->isr.offset = 0x1000;\n\n    proxy->isr.size = 0x1000;\n\n    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;\n\n\n\n    proxy->device.offset = 0x2000;\n\n    proxy->device.size = 0x1000;\n\n    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;\n\n\n\n    proxy->notify.offset = 0x3000;\n\n    proxy->notify.size =\n\n        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;\n\n    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus) &&\n\n        !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    } else {\n\n        /*\n\n         * make future invocations of pci_is_express() return false\n\n         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.\n\n         */\n\n        pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n", "idx": 16585, "substitutes": {"pci_dev": ["pdo_ev", "pci_Dev", "pki_Dev", "pci_link", "pci_spec", "pki_adv", "pci_adv", "pdo_adv", "pci_serial", "pdo_serial", "pcioglink", "pdi_spec", "pciogdev", "pci2dev", "pki_dev", "pci2device", "pciogDev", "pdi_device", "pdi_ev", "pciogadv", "pki_link", "pci2Dev", "pdi_Dev", "pdi_dev", "pci_ev", "pdo_dev", "pci_device", "pci2ev"], "errp": ["erP", " errpar", "erpar", "arrpar", "arrp", "errP", " errps", "erps", "erp", "arrP", "errps", " errP", "errpar", "arrps"], "proxy": ["component", "library", "XY", "cache", "forward", "page", "use", "xy", "linux", "password", "pointer", "address", "friend", "query", "project", "po", "reflect", "cas", "PRO", "http", "reply", "show", "alias", "roxy", "report", "json", "device", "target", "php", "embed", "handler", "reference", "index", "client", "template", "wrapper", "controller", "tor", "prime", "profile", "java", "ice", "create", "native", "service", "port", "callback", "manager", "version", "shadow", "go", "phy", "engine", "driver", "Proxy", "force", "history", "socket", "instance", "x", "pro", "view", "module", "token", "reverse", "pse", "builder", "connection", "ion", "lock", "gp", "settings", "slave", "server", "select", "remote", "sync", "call", "ping", "super", "primary", "pin", "apache", "echo", "web", "cone", "hello", "cci", "response", "timeout"], "k": ["kr", "ks", "c", "ker", "ck", "kernel", "K", "kt", "kind", "spec", "set", "tc", "ka", "aka", "m", "kw", "cc", "km", "lass", "o", "j", "kid", "key", "kk", "t", "ko", "kit", "p"]}}
{"project": "FFmpeg", "commit_id": "cf6914e27f14cf2b5a66e25f5cf3549ceabb1648", "target": 0, "func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *data_size, AVPacket *pkt)\n\n{\n\n    CDXLVideoContext *c = avctx->priv_data;\n\n    AVFrame * const p = &c->frame;\n\n    int ret, w, h, encoding, format, buf_size = pkt->size;\n\n    const uint8_t *buf = pkt->data;\n\n\n\n    if (buf_size < 32)\n\n        return AVERROR_INVALIDDATA;\n\n    encoding        = buf[1] & 7;\n\n    format          = buf[1] & 0xE0;\n\n    w               = AV_RB16(&buf[14]);\n\n    h               = AV_RB16(&buf[16]);\n\n    c->bpp          = buf[19];\n\n    c->palette_size = AV_RB16(&buf[20]);\n\n    c->palette      = buf + 32;\n\n    c->video        = c->palette + c->palette_size;\n\n    c->video_size   = buf_size - c->palette_size - 32;\n\n\n\n    if (c->palette_size > 512)\n\n        return AVERROR_INVALIDDATA;\n\n    if (buf_size < c->palette_size + 32)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp < 1)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp > 8) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    if (format) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)\n\n        return AVERROR_INVALIDDATA;\n\n    if (!encoding && c->palette_size && c->bpp <= 8) {\n\n        avctx->pix_fmt = PIX_FMT_PAL8;\n\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n\n        if (c->palette_size != (1 << (c->bpp - 1)))\n\n            return AVERROR_INVALIDDATA;\n\n        avctx->pix_fmt = PIX_FMT_BGR24;\n\n    } else {\n\n        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",\n\n                              encoding, c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    p->reference = 0;\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (encoding) {\n\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n\n                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!c->new_video)\n\n            return AVERROR(ENOMEM);\n\n        if (c->bpp == 8)\n\n            cdxl_decode_ham8(c);\n\n        else\n\n            cdxl_decode_ham6(c);\n\n    } else {\n\n        cdxl_decode_rgb(c);\n\n    }\n\n    *data_size      = sizeof(AVFrame);\n\n    *(AVFrame*)data = c->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 16602, "substitutes": {"avctx": ["avejp", " avcp", " avcu", "averctx", "avtimeout", "avcfg", "navcmp", "navctx", "afcontext", " avcmp", "avconfig", "avcontext", "ivercmp", "iverca", "avecb", "avcp", " avconn", "wavconfig", "avectx", " avcontext", "navcontext", "averconfig", "avcb", "avconn", "avjac", "avesys", "ivertimeout", "savconfig", "avertimeout", "wavjac", "savcontext", "savcp", "avecp", " avjp", "cvjp", "navcu", "aveconn", "avtmp", "cvctx", "aftx", "avsys", "avetx", "avecontext", " avtx", " avca", "navtx", "avercontext", "averca", "ivercontext", "avcu", "avcmp", "avetmp", "navsys", "wavctx", "wavpkg", "avecfg", " avcfg", "navcfg", "afctx", "avpkg", " avconfig", "iverctx", " avtimeout", "avtx", "cvcontext", "savpkg", " avcb", " avsys", "avejac", "avecmp", "avca", "avercb", "savjac", "avjp", "afcu", "avercp", " avtmp", "aveconfig", "avertmp", "savconn", "navcp", "iverjp", "savctx", "cvtx", "avepkg"], "data": ["f", "text", "window", "pad", "length", "type", "multiple", "video", "a", "content", "size", "batch", "buffer", "def", "ata", "padding", "bytes", "body", "mu", "dat", "message", "d", "m", "value", "DATA", "o", "area", "Data", "package", "frame", "bin", "image", "raw", "input", "t"], "data_size": [" data_count", " data_len", " data_length", "data_len", "data_count", "data_length"], "pkt": [" ppt", "ppt", "pcKT", "paacket", " pdu", "Pkt", "Pct", "packkt", "Pdu", "packpt", "ppqt", "pckt", "Packet", "pqt", "pppt", "mkt", " pet", " pKT", "packqt", "pet", "macket", "paux", "ppkt", "pakt", " pqt", " packet", "ppet", " pux", "paKT", "pcacket", "pux", "packet", "pKT", "pct", "mdu", "mct", " pct", "pcux", "pdu"], "c": ["f", "cf", "lc", "cv", "cmp", "cr", "g", "cache", "cam", "chain", "C", "ca", "content", "cm", "err", "fc", "rc", "abc", "com", "anc", "ed", "mc", "cont", "ic", "cp", "conv", "comp", "sc", "etc", "gc", "unc", "tc", "cu", "e", "ci", "can", "ac", "pc", "l", "nc", "con", "m", "call", "cc", "b", "ctx", "v", "ct", "n", "bc", "xc", "uc", "ce", "vc", "coll", "col", "cur", "ec", "comments", "at", "cs", "comm", "t", "co", "conf", "dc", "cd"], "p": ["f", "pkg", "P", "fp", "jp", " P", "q", "cp", "conv", "pp", "np", "pb", "r", "pc", "m", "d", "b", "v", "pa", "n", "vp", "pe", "op", "ps", "t", "rep", "j"], "ret": ["rt", "f", "gt", "ref", "result", "iter", "err", "rem", "def", "cont", "len", "tr", "res", "elt", "Return", "flag", "re", "r", "rel", "resp", "det", "RET", "Ret", "match", "value", "el", "v", "back", "out", "ft", " Ret", "reset", "val", "rets", "print", "alt", "mel", "mem", "status", "it", "nt", "aux", "try", "mt", "t"], "w": ["f", "window", "g", "hw", "sw", "iw", "wd", "mm", "wb", "win", "ex", "size", "wn", "wx", "r", "wal", "wi", "rw", "l", "wp", "d", "nw", "m", "b", "v", "n", "ww", "aw", "ew", "wa", "wh", "x", "wind", "fw", "W", "word", "we", "wid", "wt", "wr"], "h": ["hr", "ih", "high", "length", "ht", "bh", "ho", "g", "host", "hd", "hh", "H", "uh", "hs", "q", "he", "y", "ish", "ha", "hm", "height", "oh", "ah", "l", "m", "ph", "b", "kh", "v", "k", "n", "o", "hl", "him", "history", "hang", "mk", "wh", "phi", "hi", "ch", "t", "hash", "sh", "z", "j"], "encoding": ["enryption", "decoding", "decryption", "compaling", "caling", "cryption", "Encryption", "Encaling", "encuration", "enaling", "ecression", "compryption", "ecryption", "enoder", "compression", "ecuration", "decuration", "coder", "encoder", "ecoder", "Encression", "ecaling", "encression", "compoding", "enuration", "encryption", "ecoding", "coding", "Encoding", "enoding", "decoder", "encaling"], "format": ["unit", "f", "ff", "act", "type", "label", "offset", "action", "filter", "fp", "method", "video", "test", "title", "fc", "size", "term", "style", "scale", "conv", "version", "padding", "pattern", "pi", "spec", "feat", "note", "form", "function", "table", "ats", "options", "fm", "v", "mat", "mode", "template", "color", "family", "Format", "apache", "option", "prefix", "feature", "html", "file", "atter", "frame", "status", "transform", "command", "tag", "mt", "pretty", "name"], "buf": ["proc", "tmp", "pad", "cv", "length", "block", "br", "nm", "ref", "pkg", "cam", "vec", "args", "fac", "wb", "err", "fb", "Buff", "func", "xff", "buffer", "grab", "cap", "Buffer", "conv", "rb", "len", "workers", "bytes", "pos", "img", "doc", "np", "cb", "pb", "orig", "arr", "r", "num", "txt", "b", "ctx", "var", "uf", "mat", "packed", "late", "alloc", "cmd", "db", "str", "desc", "lim", "req", "mem", "deg", "seq", "words", "vals", "msg", "bl", "raw", "buff", "begin", "boxes", "emb", "queue", "font", "t", "bs", "batch"]}}
{"project": "FFmpeg", "commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "target": 1, "func": "static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)\n\n{\n\n    uint32_t opcode_size, offset;\n\n    uint8_t *dst, *dend, mask = 0, color = 0;\n\n    const uint8_t *src, *send, *opcodes;\n\n    int i, j, op = 0;\n\n\n\n    i = bytestream2_get_byte(&c->gb);\n\n    if (i) {\n\n        if (code & 0x10) {\n\n            int align;\n\n\n\n            align = bytestream2_tell(&c->gb) & 3;\n\n            if (align)\n\n                bytestream2_skip(&c->gb, 4 - align);\n\n        }\n\n        do {\n\n            int page, val, x, y;\n\n            val    = bytestream2_get_be16(&c->gb);\n\n            page   = val >> 14;\n\n            x      = (val & 0x7F) * 2;\n\n            y      = ((val >> 7) & 0x7F) * 2;\n\n            dst    = c->frame[page] + x + y * c->width;\n\n            dend   = c->frame[page] + c->frame_size;\n\n            offset = (x & 0x7F) * 2;\n\n            j      = bytestream2_get_le16(&c->gb) + offset;\n\n            do {\n\n                offset++;\n\n                if (dst + 3 * c->width + 4 > dend)\n\n                    return AVERROR_INVALIDDATA;\n\n                read4x4block(c, dst, c->width);\n\n                if ((offset & 0x3F) == 0)\n\n                    dst += c->width * 3;\n\n                dst += 4;\n\n            } while (offset < j);\n\n        } while (--i);\n\n    }\n\n\n\n    dst  = c->frame[c->current_frame];\n\n    dend = c->frame[c->current_frame] + c->frame_size;\n\n    do {\n\n        set_src_position(c, &src, &send);\n\n        if ((src + 3 * c->width + 4 > send) ||\n\n            (dst + 3 * c->width + 4 > dend))\n\n            return AVERROR_INVALIDDATA;\n\n        copy_block4(dst, src, c->width, c->width, 4);\n\n        i++;\n\n        if ((i & 0x3F) == 0)\n\n            dst += c->width * 3;\n\n        dst += 4;\n\n    } while (i < c->video_size / 16);\n\n\n\n    opcode_size = bytestream2_get_le16(&c->gb);\n\n    bytestream2_skip(&c->gb, 2);\n\n\n\n    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    opcodes = pkt + bytestream2_tell(&c->gb);\n\n    bytestream2_skipu(&c->gb, opcode_size);\n\n\n\n    dst = c->frame[c->current_frame];\n\n\n\n    for (i = 0; i < c->height; i += 4, dst += c->width * 3)\n\n        for (j = 0; j < c->width; j += 4, dst += 4) {\n\n            int opcode, k = 0;\n\n            if (op > opcode_size)\n\n                return AVERROR_INVALIDDATA;\n\n            if (j & 4) {\n\n                opcode = opcodes[op] & 15;\n\n                op++;\n\n            } else {\n\n                opcode = opcodes[op] >> 4;\n\n            }\n\n\n\n            while (block_sequences[opcode][k]) {\n\n                offset = c->width * 2;\n\n                code   = block_sequences[opcode][k++];\n\n\n\n                switch (code) {\n\n                case 2:\n\n                    offset = 0;\n\n                case 3:\n\n                    color = bytestream2_get_byte(&c->gb);\n\n                case 4:\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_color_mask(dst + offset, c->width, mask, color);\n\n                    break;\n\n                case 5:\n\n                    offset = 0;\n\n                case 6:\n\n                    set_src_position(c, &src, &send);\n\n                case 7:\n\n                    if (src + offset + c->width + 4 > send)\n\n                        return AVERROR_INVALIDDATA;\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_src_mask(dst + offset, c->width, mask, src + offset);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 16614, "substitutes": {"c": ["f", "cf", "lc", "cv", "cr", "config", "g", "cache", "cam", "chain", "C", "ca", "err", "cm", "content", "fc", "rc", "anc", "abc", "com", "mc", "self", "cont", "ic", "cp", "sc", "etc", "gc", "cb", "unc", "tc", "enc", "e", "cu", "ci", "form", "ac", "pc", "l", "nc", "d", "con", "call", "check", "cc", "b", "v", "ctx", "ct", "n", "cl", "bc", "ce", "coll", "cur", "ec", "cod", "cs", "t", "ch", "comm", "cmp", "co", "conf", "dc", "cd", "p"], "pkt": ["vdu", "npctx", "vctx", " pkg", "vkg", " pdu", "pkg", "vkt", "pctx", " pctx", "npdu", "npkt", "npkg", "pdu"], "code": [" reason", "text", "ode", "type", "codes", "length", "bit", "cache", "ice", " co", " status", "reason", "test", "channel", "content", "rc", "size", " Code", "buffer", "Code", "error", " whence", "coe", "event", "e", "ci", "message", "value", "index", "id", "cc", " mode", "mode", "time", " change", "state", "ce", " ecc", "count", " coding", "cod", " cmd", " chunk", "image", "command", "ch", "co"], "opcode_size": ["opcode___name", "opcode_start", "opcodes_name", "opcode___size", "opcode___start", "opcodes_start", "opcode___area", "opcode_area", "opcode_name", "opcodes_area", "opcodes_size"], "offset": ["to", "f", "length", "block", "attr", "step", "scroll", "end", "slot", "tile", "location", "fp", "shift", "point", "origin", "xy", "size", "pointer", "mask", "Offset", "position", "buffer", "ui", "ot", "error", "ip", "pos", "padding", "io", "line", "loc", "set", "item", "um", "address", "e", "height", "value", "index", "sp", "off", "row", "o", "time", "skip", "angle", "key", "reset", "slice", "data", "seek", "next", "start", "addr", "range", "z", "timeout", "p"], "dst": ["Dest", "block", "Dstart", "lST", "Dpend", "dot", "def", "dput", "dsest", "read", " dnd", "dsrest", "odend", "adst", "dsset", "odstart", "dsend", "new", "bit", "_", "lnd", "odst", "dsint", "cont", "dset", "dspend", "dist", " dint", "Dot", "dstart", "Dend", "idst", "oduse", "DST", "Dist", "idST", "Dst", "dST", "adist", "idstart", "dpend", "idend", "sdst", "byte", "fST", "Dset", "sdend", "Drest", " dest", " dot", "idnd", " dset", " dist", "lest", "dnd", "bdpend", "dint", "bdput", "dsput", "sdST", "duse", "dsst", "fnd", " duse", " drest", " dST", "copy", "idest", "drest", "lstart", "fst", "bdst", "Dput", "lend", "adest", "lst", "call", "dest", "adend", "Duse", " dstart", "fend", "bdend", "Dint", "sdot"], "dend": ["mst", "vends", "psend", "fnd", "fended", "lEND", "pended", "dended", "pend", "vend", " dsend", "pnd", " dended", "pst", "lending", "fst", "dEND", "mends", "lend", "vst", "pends", "fends", "Dnd", " dnd", "wended", "lended", "dends", "fsend", "mending", "Dend", "dending", "mend", "wend", "Dended", "wst", " dEND", "wending", "wEND", "vending", " dends", "Dst", "wnd", " dending", "dnd", "fend", "dsend", "fending"], "src": ["url", "rt", "sl", "tmp", "ser", "attr", "rs", "st", "ins", "sn", "ind", "ctr", "trans", "fp", "fc", "rc", "gin", "size", "inner", "cont", "sc", "in", "pos", "sub", "iv", "read", "loc", "img", "inst", "sr", "r", "sync", "sys", "dest", "sp", "txt", "ctx", "sb", "s", "slice", "cmd", "cur", "source", "addr", "start", "ptr", "input", "usr"], "send": ["get", "jump", "bind", "end", "sv", "ceive", "g", "sn", "push", "init", "trans", "sw", "nd", "pose", "use", "speed", "sent", "size", "q", "sc", "fin", "pos", "body", "read", "set", "handle", "sys", "num", "sp", "se", "force", "out", "late", "Send", "slice", "seek", "write", "save", "msg", "find", "source", "start", "eng", "show", "share"], "opcodes": ["popcodes", "OPcodes", "popcode", "popnames", "pnames", "OPnames", "pcode", "opbits", "popbits", "opnames", "OPbits", "pbits", "pcodes", "OPcode"], "i": ["f", "is", "g", "bi", "a", "iter", "xi", "cli", "ai", "ia", "port", "li", "ic", "ui", "ip", "io", "iat", "in", "pi", "iu", "u", "e", "r", "ci", "l", "m", "d", "index", "id", "b", "v", "I", "o", "n", "ii", "ti", "phi", "ix", "di", "it", "mi", "hi", "start", "ij", "ini", "multi", "si", "p"], "j": ["jl", "jump", "J", "g", "slot", "ja", "bj", "jp", "shift", "jc", "js", "json", "kj", "q", "fr", "pos", "jj", "aj", "r", "vol", "l", "d", "ji", "index", "sp", "off", "b", "v", "k", "dj", "o", "n", "uj", "it", "ij", "z", "si", "p"], "align": ["anch", "pad", "length", "coord", "alias", "wrap", "pal", "chain", "inc", "shift", "aug", " anchor", "lock", "adjust", "ag", "hal", "ia", "tail", "order", "len", "padding", "repeat", "aff", "al", "match", "rel", "ac", "margin", "hold", "aligned", "balance", "join", "lag", "skip", "angle", "hang", "alpha", " angle", "alter", " overlap", "pair", "ignment", "mark", "ang", "ign", "half", "gap", "adj", "cmp", "range", " aligned", " alignment"], "page": ["window", "block", "cache", "ref", "chain", "point", "post", "parent", "pointer", "port", "plot", "position", "order", "ip", "pos", "pp", "line", "go", "pi", "pl", "month", "pc", "cycle", "pid", "pt", "num", "index", "id", "sp", "row", "Page", "total", "key", "pg", "count", "link", "next", "site", "wait", "frame", "mark", "loop", "number", "age", "pool", "pe", "base", "node", "p"], "val": ["f", "unit", "bit", "ref", "slot", "pal", "tx", "test", "Val", "point", "xy", "valid", "VAL", "ret", "def", "len", "cal", "al", "V", "loc", "elt", "pl", "item", "eval", "ul", "vol", "l", "value", "pt", "index", "el", "local", "b", "v", "var", "angle", "key", "state", "data", "count", "mem", "bal", "vals", "mark", "aval", "it", "vt", "base", "lib", "ival", "il", "dev", "sel", "p"], "x": ["f", "to", "px", "xt", "ox", "ax", "location", "dx", "tx", "xi", "lat", "rx", "xs", "ex", "xy", "point", "ip", "xp", "fx", "wx", "l", "d", "m", "index", "path", "v", "n", "xc", "axis", "ix", "lon", "xa", "w", "z", "start", "xf", "xx", "X", "p"], "y": ["ny", "sy", "lat", "xy", "iy", "ym", "asy", "ay", "ot", "ies", "vy", "yo", "height", "my", "ey", "yy", "b", "fy", "v", "n", "row", "yr", "ty", "key", "axy", "yt", "col", "cy", "ly", "py", "sky", "gy", "Y", "ch", "hy", "z"], "op": ["bit", "hop", "jp", "inc", "update", "ops", "oe", "copy", "oper", "ot", "prev", "cp", "ip", "pos", "OP", "im", "um", "ap", "sp", "o", "Op", "eff", "oc", "pop", "operation", "cmp", "co", "p"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n", "idx": 16628, "substitutes": {"env": ["org", "cv", "er", "js", "pen", "forge", "vs", "pp", "np", "pb", "e", "v", "ctx", "uv", "Environment", " en", "hw", "oe", "ef", " ens", "cp", "obj", "eni", "cb", "nw", "el", "ev", "code", "esp", "hl", "console", "state", " esp", "context", "db", "environment", "nv", "pe", "skin", "dev", "esc", "rn", "vp", "tmp", "window", " environment", "end", "en", "conn", "peer", "self", "te", "manager", "enter", "ee", "engine", "ah", "buf", "sp", "ve", "sb", "desc", "vt", "ptr", "sv", "ja", "jp", "worker", "server", "vm", "ei", "ew", "ner", "et", "ec", "addr"], "fptag": ["fcqtog", "fptags", "faptags", "fptagged", " fctagen", "feptag", "fepttag", "Fpttag", "fiptag", "sptag", "fpropagen", "fiptags", "fctagen", "fcqtags", "fctang", "fqtog", "fportang", "fptype", "fctagged", "fctag", "fportag", "feptagger", "faptagger", "fpretag", "fqtags", "fctype", "ftpagger", "fptagger", "fiptog", "fpttag", "fctagger", "fptagen", "Fptagn", "fptog", "ftopagger", "ftoptag", "fntagged", " fptang", "fpropag", "fcptagger", "faptog", "ftpag", "fpointtag", "fpropagn", "fqtagger", " fctang", "faptag", "fntagger", "fcptags", "ftopagn", "fiptagger", "fportagger", "Fctagger", "fpretype", "Fctagn", "fptagn", "Fcttag", "fptang", "sptagger", " fctagged", "fpointagger", "spretype", "spretag", " fptagged", "ftpagen", " fctagger", "Fctag", "fpretagger", " fctagn", "Fptagger", "fcqtagger", "feptagn", "fcqtag", "fpointype", "ftopag", "Fptag", "fcptog", "fportagged", " fptagen", "fcptag", "fctagn", "fntang", "fpropagger", " fptagn", "fprettag", "fntag", "spttag", " fctag", "fqtag", "sprettag", "fcttag", "fpointag", " fptagger", "ftpagn", "spretagger", "sptype"], "i": ["is", "iri", "bi", "er", "gi", "ind", "init", "iter", "ri", "xi", "point", "ki", "cli", "ai", "info", "oi", "q", "li", "ic", "ui", "ip", "y", "io", "in", "\u0438", "pi", "iu", "qi", "im", "zi", "ci", "this", "me", "m", "sim", "index", "ji", "v", "I", "PI", "ii", "ti", "ei", "print", "fi", "phi", "ix", "x", "di", "uri", "it", "mi", "ie", "at", "ij", "iso", "ini", "multi", "si", "p"], "j": ["f", "jl", "jump", "J", "br", "g", "bi", "ja", "jp", "c", "jc", "h", "js", "pr", "json", "kj", "q", "fr", "y", "pos", "jj", "jac", "aj", "u", "r", "l", "m", "pt", "ji", "index", "d", "b", "v", "k", "n", "o", "dj", "uj", "x", "jit", "it", "ij", "z", "si", "p"], "fpuc": ["cpusc", "fpun", "vpsc", "vpauc", "gpacc", "fpsc", "fpuf", "puuc", "gpauc", "fmuf", "puusc", "lpauc", "tpauc", "vpusc", "fguc", "jpuc", "fpucc", "psc", "wpusc", "gpusc", "bpauc", " gpuid", "cpuc", "fpbc", "wpauc", "puc", "pacc", "fgusc", "fpauc", "fmbc", "fgauc", " gpbc", "vpuc", "fpuid", "fpacc", "fgun", "vpucc", "wpun", "lpsc", "jpuf", "cpauc", "fpusc", "bpuc", "bpusc", "jpuid", "fmuid", " gpuf", "pauc", "wpuc", "lpusc", "jpbc", "tpsc", "gpsc", " gpuc", "cpsc", "tpusc", "pusc", "gpuc", "lpuc", "lpucc", "puacc", "bpucc", "fmuc", "cpun", "tpuc"], "fp1": ["jp0", "vp0", " gp0", "vp1", "tp0", "jp2", "tp2", "vp2", "p1", "p0", " gp1", "jp1", "fp2", "tp1", "p2", " gp2", "fp0"], "fp": ["f", "fd", "cf", "ff", "nil", "ppo", "FP", "cfg", "fe", "pkg", "jp", "yp", "gp", "fc", "mp", "pr", "func", "cp", "conv", "bp", "fx", "xp", "pp", "p", "np", "cb", "pb", "php", "fg", "lp", "ulp", "buf", "wp", "tf", "ap", "fps", "sp", "fm", "ctx", "uf", "ft", "esp", "png", "spr", "fi", "VP", "file", "filename", "fw", "bf", "csv", "ptr", "ps", "fn", "il", "fs", "tp", "vp"]}}
{"project": "FFmpeg", "commit_id": "5dbb63feefb9070d6fbb5fc16406813f14aa7f9b", "target": 0, "func": "static int decode_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic;\n\n    int err, i, ret, video_index, audio_index, subtitle_index;\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    AVFormatParameters params, *ap = &params;\n\n\n\n    video_index = -1;\n\n    audio_index = -1;\n\n    subtitle_index = -1;\n\n    is->video_stream = -1;\n\n    is->audio_stream = -1;\n\n    is->subtitle_stream = -1;\n\n\n\n    global_video_state = is;\n\n    url_set_interrupt_cb(decode_interrupt_cb);\n\n\n\n    memset(ap, 0, sizeof(*ap));\n\n\n\n    ap->width = frame_width;\n\n    ap->height= frame_height;\n\n    ap->time_base= (AVRational){1, 25};\n\n    ap->pix_fmt = frame_pix_fmt;\n\n\n\n    err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if(genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    err = av_find_stream_info(ic);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if(ic->pb)\n\n        ic->pb->eof_reached= 0; //FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < ic->nb_streams; i++) {\n\n        AVCodecContext *enc = ic->streams[i]->codec;\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n        switch(enc->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if ((audio_index < 0 || wanted_audio_stream-- > 0) && !audio_disable)\n\n                audio_index = i;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            if ((video_index < 0 || wanted_video_stream-- > 0) && !video_disable)\n\n                video_index = i;\n\n            break;\n\n        case CODEC_TYPE_SUBTITLE:\n\n            if (wanted_subtitle_stream-- >= 0 && !video_disable)\n\n                subtitle_index = i;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (show_status) {\n\n        dump_format(ic, 0, is->filename, 0);\n\n        dump_stream_info(ic);\n\n    }\n\n\n\n    /* open the streams */\n\n    if (audio_index >= 0) {\n\n        stream_component_open(is, audio_index);\n\n    }\n\n\n\n    if (video_index >= 0) {\n\n        stream_component_open(is, video_index);\n\n    } else {\n\n        if (!display_disable)\n\n            is->show_audio = 1;\n\n    }\n\n\n\n    if (subtitle_index >= 0) {\n\n        stream_component_open(is, subtitle_index);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    for(;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER\n\n        if (is->paused && !strcmp(ic->iformat->name, \"rtsp\")) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int stream_index= -1;\n\n            int64_t seek_target= is->seek_pos;\n\n\n\n            if     (is->   video_stream >= 0) stream_index= is->   video_stream;\n\n            else if(is->   audio_stream >= 0) stream_index= is->   audio_stream;\n\n            else if(is->subtitle_stream >= 0) stream_index= is->subtitle_stream;\n\n\n\n            if(stream_index>=0){\n\n                seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q, ic->streams[stream_index]->time_base);\n\n            }\n\n\n\n            ret = av_seek_frame(is->ic, stream_index, seek_target, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            }else{\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (is->audioq.size > MAX_AUDIOQ_SIZE ||\n\n            is->videoq.size > MAX_VIDEOQ_SIZE ||\n\n            is->subtitleq.size > MAX_SUBTITLEQ_SIZE) {\n\n            /* wait 10 ms */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n        if(url_feof(ic->pb)) {\n\n            av_init_packet(pkt);\n\n            pkt->data=NULL;\n\n            pkt->size=0;\n\n            pkt->stream_index= is->video_stream;\n\n            packet_queue_put(&is->videoq, pkt);\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret != AVERROR_EOF && url_ferror(ic->pb) == 0) {\n\n                SDL_Delay(100); /* wait for user event */\n\n                continue;\n\n            } else\n\n                break;\n\n        }\n\n        if (pkt->stream_index == is->audio_stream) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* disable interrupting */\n\n    global_video_state = NULL;\n\n\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        av_close_input_file(is->ic);\n\n        is->ic = NULL; /* safety */\n\n    }\n\n    url_set_interrupt_cb(NULL);\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16651, "substitutes": {"arg": ["reg", "parse", "g", "ax", "ref", "jp", "inc", "args", "Arg", "ag", "in", "doc", "ig", "p", "gc", "ary", "ark", "argument", "arr", "ac", "pc", "call", "v", "param", "ctx", "ar", "val", "pg", "ive", "it", "w", "op", "og", "il", "arc", "arp"], "is": ["get", "isp", "ik", "bi", "bits", "as", "ins", "iss", "init", "ir", "ics", "ism", "ais", "ri", "tis", "mis", "ai", "js", "ia", "was", "os", "ot", "isi", "pas", "ip", "isf", "ish", "in", "ris", "ims", "pi", "isl", "inst", "ist", "ib", "isin", "im", "ms", "IS", "sys", "num", "its", "id", "has", "parts", "bis", "iris", "ar", "s", "are", "isa", "it", "ois", "lis", "ists", "isc", "iso", "il", "ps", "bs", "sis", "rest", "Is", "si", "es"], "ic": ["aic", "ik", "ics", "inc", "c", "ica", "nic", "icon", "fc", "ai", "ici", "abc", "icc", "mc", "ia", "ab", "ican", "ot", "voc", "IC", "ip", "iat", "ico", "iac", "gc", "ric", "ib", "tc", "ick", "ci", "sic", "ac", "pc", "rec", "ctx", "ct", "pic", "mic", "tic", " nic", "oc", "acl", "bc", "ix", "ive", "vc", "ec", "ict", "it", "lic", "irc", "ij", "isc", "eric", "wic", "iq", "co", "icing"], "err": ["er", "dy", "c", "cer", "js", "or", "asm", "fr", "rr", "e", "yr", "val", "req", "timer", "ler", "plain", "cor", "ere", "cr", "br", "nr", "iter", "inner", "order", "len", "rb", "cb", "norm", "hz", " Err", "cmd", "notice", "msg", "usr", "ch", "die", "conf", "cfg", "rn", "ber", "Error", "mr", "eor", "error", "elt", "resp", "buf", "my", "m", "txt", "aaa", " er", "count", "dr", "raw", "try", "ptr", "kr", "lr", "attr", "later", "ctr", "fer", "fee", "rar", "Er", "res", "der", "r", "arr", "score", "ter", "sys", "gz", "n", "late", "str", "ner", "erd", "ger", "outer", "t"], "i": ["bi", "gi", "ind", "chain", "ir", "init", "c", "xi", "ai", "oi", "batch", "li", "ui", "ip", "y", "iat", "in", "\u0438", "ami", "ims", "pi", "iu", "qi", "im", "e", "zi", "ci", "sim", "m", "me", "index", "id", "ji", "v", "I", "n", "o", "ii", "ti", "ei", "fire", "instance", "ix", "x", "di", "it", "mi", "start", "ij", "ini", "multi", "j", "si", "p"], "ret": ["rt", "ber", "xt", "br", "ext", "gt", "ref", "result", "jp", "iter", "lt", "rem", "def", "dt", "fin", "del", "tr", "res", "net", "elt", "ll", "re", "rel", "arr", "r", "resp", "att", "det", "rev", "Ret", "RET", "ter", "txt", "mat", "back", "out", "ft", " Ret", "nz", "backed", "reset", "val", "rets", "fi", "cmd", "print", "desc", "alt", "success", "mem", "deg", "dr", "it", "rm", "nt", "fun", "try", "addr", "usr", "mt", "reply", "pret", "t"], "video_index": ["video_size", "video_path", "audio_path", "video32index", "video_device", "video_stream", "video_number", "video32device", "video32stream", "video_id", "audio_number", "audio_size", "audio_id", "video32path", "audio_stream", "audio_device"], "audio_index": ["media_index", "audio_long", "media_stream", "media_number", "audio_number", "media_id", "audio_id", "audio_stream", "media_long"], "subtitle_index": ["subTitle_Index", "subname_length", "subTitle_offset", "subtitle_Index", "subtitle_length", "subname_id", "subname_number", "subTitle_stream", "subname_index", "subtitle_stream", "subtitle_offset", "subTitle_index", "subtitle_number", "subtitle_id"], "pkt1": ["opkt1", " pet3", "packet0", "opkt0", "packet3", "pelt2", "packet2", "pkt3", "opkt2", "pet1", "pkt2", " pet2", " pet0", " pkt0", "opacket1", "opacket0", " pet1", "pelt1", "pet0", "pelt0", " pkt2", "pqt1", " pkt3", "pqt2", "pqt3", "pet3", "pkt0", "opacket2", "pet2", "packet1", "pqt0"], "pkt": ["Pct", "cpacket", "packet", "pct", "cpact", "Pkt", "Packet", " packet", "Pact", "pact", " pct", "cpkt", " pact", "cpct"], "params": [" parameters", "rs", " pan", "as", " pars", "jp", "map", "args", " caps", "aps", "amps", "js", "mp", " args", "cap", " props", "cp", "pps", "pas", "pos", "spec", "types", "ac", "pc", "caps", "options", "fps", " paras", "kw", "ctx", "param", "pa", " stats", "parts", "pres", " ps", "ams", "s", " parts", "par", "ars", " fps", "ps", "conf", " pairs", "p"], "ap": ["amp", "attr", "ep", "ax", "apt", "map", "AP", "aps", "ag", "mp", "aph", "ad", "ab", "cap", "cp", "ip", "acc", "pp", "p", "al", "pb", "att", "set", "rap", "im", "aj", "arr", "ac", "tap", "wp", "el", "sp", "and", "pa", "acl", "apa", "ar", "app", "ast", "html", "ape", "par", "mem", "am", "art", "ars", "hap", "mac", "op", "av", "ipp", "at", "addr", "snap", "ps", "api", "arp"], "timestamp": [" timance", "metest", "timeetime", "Timeline", "Timestamp", "temeline", "stimetime", " timemark", "stimance", "metestamp", "temement", "stimemark", "metetime", "momest", "talest", "Timest", "talination", "imance", "temination", "timemark", "stimestamp", "temest", "Timination", "timest", "timeinal", "tminal", "meteline", "timination", "imemark", "temetime", "tmestamp", "timeest", "imestamp", "momestamp", "tmeline", "momement", "Timement", "Timetime", "taleline", "talestamp", "timeeline", "metinal", "timetime", "timinal", "imetime", "timement", "temestamp", " timetime", "mometime", "tmetime", "timeestamp", "timeline", "timance"], "enc": ["act", "ENC", "conn", "sec", "anc", "rc", "fc", "conv", "comp", "iv", "loc", "kt", "ac", "pc", "nc", "kw", "ack", "rec", "txt", "oc", "et", "coll", "ec", "lang", "cod", "ent", "exc"]}}
{"project": "FFmpeg", "commit_id": "608708009f69ba4cecebf05120c696167494c897", "target": 1, "func": "static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ADPCMDecodeContext *c = avctx->priv_data;\n    ADPCMChannelStatus *cs;\n    int n, m, channel, i;\n    short *samples;\n    const uint8_t *src;\n    int st; /* stereo */\n    int count1, count2;\n    int nb_samples, coded_samples, ret;\n    nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);\n    if (nb_samples <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of samples in packet\\n\");\n    }\n    /* get output buffer */\n    c->frame.nb_samples = nb_samples;\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (short *)c->frame.data[0];\n    /* use coded_samples when applicable */\n    /* it is always <= nb_samples, so the output buffer will be large enough */\n    if (coded_samples) {\n        if (coded_samples != nb_samples)\n            av_log(avctx, AV_LOG_WARNING, \"mismatch in coded sample count\\n\");\n        c->frame.nb_samples = nb_samples = coded_samples;\n    }\n    src = buf;\n    st = avctx->channels == 2 ? 1 : 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ADPCM_IMA_QT:\n        /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).\n           Channel data is interleaved per-chunk. */\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int16_t predictor;\n            int step_index;\n            cs = &(c->status[channel]);\n            /* (pppppp) (piiiiiii) */\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n            predictor = AV_RB16(src);\n            step_index = predictor & 0x7F;\n            predictor &= 0xFF80;\n            src += 2;\n            if (cs->step_index == step_index) {\n                int diff = (int)predictor - cs->predictor;\n                if (diff < 0)\n                    diff = - diff;\n                if (diff > 0x7f)\n                    goto update;\n            } else {\n            update:\n                cs->step_index = step_index;\n                cs->predictor = predictor;\n            }\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            samples = (short *)c->frame.data[0] + channel;\n            for (m = 0; m < 32; m++) {\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n                samples += avctx->channels;\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n                samples += avctx->channels;\n                src ++;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WAV:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for(i=0; i<avctx->channels; i++){\n            cs = &(c->status[i]);\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n        }\n        for (n = (nb_samples - 1) / 8; n > 0; n--) {\n            for (i = 0; i < avctx->channels; i++) {\n                cs = &c->status[i];\n                for (m = 0; m < 4; m++) {\n                    uint8_t v = *src++;\n                    *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);\n                    samples += avctx->channels;\n                    *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 3);\n                    samples += avctx->channels;\n                }\n                samples -= 8 * avctx->channels - 1;\n            }\n            samples += 7 * avctx->channels;\n        }\n        break;\n    case CODEC_ID_ADPCM_4XM:\n        for (i = 0; i < avctx->channels; i++)\n            c->status[i].predictor= (int16_t)bytestream_get_le16(&src);\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].step_index= (int16_t)bytestream_get_le16(&src);\n            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n        }\n        for (i = 0; i < avctx->channels; i++) {\n            samples = (short *)c->frame.data[0] + i;\n            cs = &c->status[i];\n            for (n = nb_samples >> 1; n > 0; n--, src++) {\n                uint8_t v = *src;\n                *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);\n                samples += avctx->channels;\n                *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 4);\n                samples += avctx->channels;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_MS:\n    {\n        int block_predictor;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        block_predictor = av_clip(*src++, 0, 6);\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        if (st) {\n            block_predictor = av_clip(*src++, 0, 6);\n            c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n            c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        }\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n        if (st){\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n        }\n        c->status[0].sample1 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n        c->status[0].sample2 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n        *samples++ = c->status[0].sample2;\n        if (st) *samples++ = c->status[1].sample2;\n        *samples++ = c->status[0].sample1;\n        if (st) *samples++ = c->status[1].sample1;\n        for(n = (nb_samples - 2) >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_DK4:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n            *samples++ = cs->predictor;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_DK3:\n    {\n        unsigned char last_byte = 0;\n        unsigned char nibble;\n        int decode_top_nibble_next = 0;\n        int end_of_packet = 0;\n        int diff_channel;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n        c->status[0].step_index = src[14];\n        c->status[1].step_index = src[15];\n        /* sign extend the predictors */\n        src += 16;\n        diff_channel = c->status[1].predictor;\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n         * the buffer is consumed */\n        while (1) {\n            /* for this algorithm, c->status[0] is the sum channel and\n             * c->status[1] is the diff channel */\n            /* process the first predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the diff channel predictor */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n            /* process the first pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n            /* process the second predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the second pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_ISS:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v1, v2;\n            uint8_t v = *src;\n            /* nibbles are swapped for mono */\n            if (st) {\n                v1 = v >> 4;\n                v2 = v & 0x0F;\n            } else {\n                v2 = v >> 4;\n                v1 = v & 0x0F;\n            }\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WS:\n        while (src < buf + buf_size) {\n            uint8_t v = *src++;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_XA:\n        while (buf_size >= 128) {\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n                avctx->channels);\n            src += 128;\n            samples += 28 * 8;\n            buf_size -= 128;\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n        src += 4; // skip sample count (already read)\n        for (i=0; i<=st; i++)\n            c->status[i].step_index = bytestream_get_le32(&src);\n        for (i=0; i<=st; i++)\n            c->status[i].predictor  = bytestream_get_le32(&src);\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n        }\n        break;\n    case CODEC_ID_ADPCM_EA:\n    {\n        int32_t previous_left_sample, previous_right_sample;\n        int32_t current_left_sample, current_right_sample;\n        int32_t next_left_sample, next_right_sample;\n        int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n        uint8_t shift_left, shift_right;\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n           each coding 28 stereo samples. */\n        src += 4; // skip sample count (already read)\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n        for (count1 = 0; count1 < nb_samples / 28; count1++) {\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n            src++;\n            shift_left  = 20 - (*src >> 4);\n            shift_right = 20 - (*src & 0x0F);\n            src++;\n            for (count2 = 0; count2 < 28; count2++) {\n                next_left_sample  = sign_extend(*src >> 4, 4) << shift_left;\n                next_right_sample = sign_extend(*src,      4) << shift_right;\n                src++;\n                next_left_sample = (next_left_sample +\n                    (current_left_sample * coeff1l) +\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n                next_right_sample = (next_right_sample +\n                    (current_right_sample * coeff1r) +\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n                previous_left_sample = current_left_sample;\n                current_left_sample = av_clip_int16(next_left_sample);\n                previous_right_sample = current_right_sample;\n                current_right_sample = av_clip_int16(next_right_sample);\n                *samples++ = (unsigned short)current_left_sample;\n                *samples++ = (unsigned short)current_right_sample;\n            }\n        }\n        if (src - buf == buf_size - 2)\n            src += 2; // Skip terminating 0x0000\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n    {\n        int coeff[2][2], shift[2];\n        for(channel = 0; channel < avctx->channels; channel++) {\n            for (i=0; i<2; i++)\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n            shift[channel] = 20 - (*src & 0x0F);\n            src++;\n        }\n        for (count1 = 0; count1 < nb_samples / 2; count1++) {\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n                for(channel = 0; channel < avctx->channels; channel++) {\n                    int32_t sample = sign_extend(src[channel] >> i, 4) << shift[channel];\n                    sample = (sample +\n                             c->status[channel].sample1 * coeff[channel][0] +\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n                    c->status[channel].sample2 = c->status[channel].sample1;\n                    c->status[channel].sample1 = av_clip_int16(sample);\n                    *samples++ = c->status[channel].sample1;\n                }\n            }\n            src+=avctx->channels;\n        }\n        /* consume whole packet */\n        src = buf + buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_R1:\n    case CODEC_ID_ADPCM_EA_R2:\n    case CODEC_ID_ADPCM_EA_R3: {\n        /* channel numbering\n           2chan: 0=fl, 1=fr\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n        int32_t previous_sample, current_sample, next_sample;\n        int32_t coeff1, coeff2;\n        uint8_t shift;\n        unsigned int channel;\n        uint16_t *samplesC;\n        const uint8_t *srcC;\n        const uint8_t *src_end = buf + buf_size;\n        int count = 0;\n        src += 4; // skip sample count (already read)\n        for (channel=0; channel<avctx->channels; channel++) {\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n                                         : bytestream_get_le32(&src))\n                           + (avctx->channels-channel-1) * 4;\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n            srcC  = src + offset;\n            samplesC = samples + channel;\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n            } else {\n                current_sample  = c->status[channel].predictor;\n                previous_sample = c->status[channel].prev_sample;\n            }\n            for (count1 = 0; count1 < nb_samples / 28; count1++) {\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n                    srcC++;\n                    if (srcC > src_end - 30*2) break;\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n                    for (count2=0; count2<28; count2++) {\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n                        samplesC += avctx->channels;\n                    }\n                } else {\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n                    shift = 20 - (*srcC++ & 0x0F);\n                    if (srcC > src_end - 14) break;\n                    for (count2=0; count2<28; count2++) {\n                        if (count2 & 1)\n                            next_sample = sign_extend(*srcC++,    4) << shift;\n                        else\n                            next_sample = sign_extend(*srcC >> 4, 4) << shift;\n                        next_sample += (current_sample  * coeff1) +\n                                       (previous_sample * coeff2);\n                        next_sample = av_clip_int16(next_sample >> 8);\n                        previous_sample = current_sample;\n                        current_sample  = next_sample;\n                        *samplesC = current_sample;\n                        samplesC += avctx->channels;\n                    }\n                }\n            }\n            if (!count) {\n                count = count1;\n            } else if (count != count1) {\n                av_log(avctx, AV_LOG_WARNING, \"per-channel sample count mismatch\\n\");\n                count = FFMAX(count, count1);\n            }\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n                c->status[channel].predictor   = current_sample;\n                c->status[channel].prev_sample = previous_sample;\n            }\n        }\n        c->frame.nb_samples = count * 28;\n        src = src_end;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_XAS:\n        for (channel=0; channel<avctx->channels; channel++) {\n            int coeff[2][4], shift[4];\n            short *s2, *s = &samples[channel];\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n                for (i=0; i<2; i++)\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n                shift[n] = 20 - (src[2] & 0x0F);\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n            }\n            for (m=2; m<32; m+=2) {\n                s = &samples[m*avctx->channels + channel];\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n                        int level = sign_extend(*src >> (4 - i), 4) << shift[n];\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n                    }\n                }\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_AMV:\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n        c->status[0].step_index = bytestream_get_le16(&src);\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n            src+=4;\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            char hi, lo;\n            lo = *src & 0x0F;\n            hi = *src >> 4;\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n                FFSWAP(char, hi, lo);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                lo, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                hi, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_CT:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case CODEC_ID_ADPCM_SBPRO_4:\n    case CODEC_ID_ADPCM_SBPRO_3:\n    case CODEC_ID_ADPCM_SBPRO_2:\n        if (!c->status[0].step_index) {\n            /* the first byte is a raw sample */\n            *samples++ = 128 * (*src++ - 0x80);\n            if (st)\n              *samples++ = 128 * (*src++ - 0x80);\n            c->status[0].step_index = 1;\n            nb_samples--;\n        }\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n            for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] >> 4, 4, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x0F, 4, 0);\n            }\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n            for (n = nb_samples / 3; n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 5        , 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x07, 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] & 0x03, 2, 0);\n            }\n        } else {\n            for (n = nb_samples >> (2 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 6        , 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    (src[0] >> 4) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x03, 2, 2);\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_SWF:\n    {\n        GetBitContext gb;\n        const int *table;\n        int k0, signmask, nb_bits, count;\n        int size = buf_size*8;\n        init_get_bits(&gb, buf, size);\n        //read bits & initial values\n        nb_bits = get_bits(&gb, 2)+2;\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n        table = swf_index_tables[nb_bits-2];\n        k0 = 1 << (nb_bits-2);\n        signmask = 1 << (nb_bits-1);\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n            for (i = 0; i < avctx->channels; i++) {\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n                c->status[i].step_index = get_bits(&gb, 6);\n            }\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n                int i;\n                for (i = 0; i < avctx->channels; i++) {\n                    // similar to IMA adpcm\n                    int delta = get_bits(&gb, nb_bits);\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n                    int k = k0;\n                    do {\n                        if (delta & k)\n                            vpdiff += step;\n                        step >>= 1;\n                        k >>= 1;\n                    } while(k);\n                    vpdiff += step;\n                    if (delta & signmask)\n                        c->status[i].predictor -= vpdiff;\n                    else\n                        c->status[i].predictor += vpdiff;\n                    c->status[i].step_index += table[delta & (~signmask)];\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n                    *samples++ = c->status[i].predictor;\n                }\n            }\n        }\n        src += buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_YAMAHA:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n        }\n        break;\n    case CODEC_ID_ADPCM_THP:\n    {\n        int table[2][16];\n        int prev[2][2];\n        int ch;\n        src += 4; // skip channel size\n        src += 4; // skip number of samples (already read)\n        for (i = 0; i < 32; i++)\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n        /* Initialize the previous sample.  */\n        for (i = 0; i < 4; i++)\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n        for (ch = 0; ch <= st; ch++) {\n            samples = (short *)c->frame.data[0] + ch;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int index = (*src >> 4) & 7;\n                unsigned int exp = *src++ & 15;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n                    if(n&1) sampledat = sign_extend(*src++, 4);\n                    else    sampledat = sign_extend(*src >> 4, 4);\n                    sampledat = ((prev[ch][0]*factor1\n                                + prev[ch][1]*factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    prev[ch][1] = prev[ch][0];\n                    prev[ch][0] = *samples++;\n                    /* In case of stereo, skip one sample, this sample\n                       is for the other channel.  */\n                    samples += st;\n                }\n            }\n        }\n        break;\n    }\n    default:\n        return -1;\n    }\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n    return src - buf;\n}", "idx": 16664, "substitutes": {"avctx": ["navcpu", "avctl", "avectl", "afhandle", "avercc", "abcmp", " avcp", "afctl", "abcontext", "averctx", "avcfg", "AVtx", " avcpu", "navctx", " avcmp", "avhandle", "abcp", "ajcu", "avcontext", " avctl", "vcontext", "avcp", " avconn", "abhistory", "apctx", "avectx", "AVcp", "vtx", " avcontext", "navcontext", "AVctx", "avconn", "averconn", "avjac", "AVjac", "AVcontext", "avecmd", "afpkg", "avkl", "abcpu", "navctl", " avpkg", "abtx", "apcmd", "apconn", "vctx", "avercu", "avehandle", "averpkg", "avcmd", "avecp", "avhistory", "aptx", "aveconn", "averkl", " avhistory", "abctx", "ajcfg", "avetx", "avecontext", " avtx", "avercontext", "avecu", "AVcmp", "avcpu", "avcu", "avcmp", "ajpkg", "vconn", "avecfg", " avcfg", "afctx", "avpkg", "avercfg", "avtx", "avejac", "avecmp", "avercmp", "avcc", "ajcc", " avcmd", "apcontext", "abhandle", "avertx", "afcp", "avekl", "averhistory", "abctl", "afcc", "ajctx", " avkl", "abjac", "avepkg"], "data": ["f", "text", "window", "pad", "length", "type", "block", "extra", "offset", "header", "cache", "filter", "video", "map", "args", "content", "feed", "size", "values", "batch", "buffer", "ata", "padding", "bytes", "body", "read", "mu", "dat", "align", "da", "r", "rel", "message", "d", "value", "id", "options", "DATA", "o", "Data", "fields", "empty", "next", "frame", "output", "w", "flags", "bin", "raw", "image", "input", "t", "name", "p"], "got_frame_ptr": ["got_frames_ptr", "got_frame_handle", "got_frame2pointers", "got_frame2pointer", "got_frames_pointers", "got_frame_pointers", "got_frame_pointer", "got_frames_handle", "got_frame2ptr", "got_frame2handle", "got_frames_pointer"], "avpkt": ["ajpkl", "avdkg", "avvkt", "vanpkt", "avpkg", "avPkg", "avPkt", "avfkl", "vanpct", "avPct", "avpwt", "avfkt", "avPst", "ajvkt", "avpackfx", "ajpkt", "avdst", "ajvdu", "avpfx", "avpkl", "avwpacket", "vanpardu", "ajvwt", "vanparkt", " avPst", " avpacket", "avvkl", "avpdu", "avvwt", "avapkt", " avPkt", "avparfx", "avwpst", "avpackdu", "avdacket", "avapdu", "avparkt", "avdkt", " avpkg", " avPkg", "avpardu", "avapkl", "ajpwt", "avPfx", "ajpdu", "avpct", "vanparfx", "ajvkl", "avfwt", "avpackkt", "avwpkg", " avPacket", " avpst", "avvdu", "avfdu", "avPdu", "vanpdu", "avparct", "avwpkt", "avPacket", "avpackct", "avpst", "avpacket", "avapwt", "vanpfx", "vanparct"], "buf": ["proc", "tmp", "window", "cv", "length", "block", "bh", "br", "cache", "ref", "nm", "pkg", "map", "vec", "rc", "buffer", "rb", "bytes", "doc", "img", "pos", "cb", "pb", "loc", "path", "b", "ctx", "txt", "uf", "late", "cmd", "db", "mem", "seq", "msg", "bin", "buff", "raw", "ptr", "queue", "batch"], "c": ["f", "cf", "lc", "cv", "cr", "g", "cache", "cam", "cn", "C", "ca", "cm", "fc", "com", "abc", "anc", "rc", "mc", "cont", "cp", "comp", "etc", "gc", "cb", "tc", "cu", "ci", "ac", "pc", "l", "con", "d", "cc", "b", "ctx", "v", "ct", "cl", "bc", "xc", "ce", "vc", "ec", "t", "comm", "cmp", "co", "conf", "dc", "cd", "p"], "cs": ["ls", "cf", "lc", "cv", "sts", "ks", "rs", "cn", "ics", "cus", "fc", "js", "css", "ants", "cons", "cp", "sc", "vs", "ns", "tc", "ci", "ms", "pc", "CS", "Cs", "ts", "ats", "cc", "acs", "ctx", "wcs", "cks", "vc", "stats", "ds", "ec", "qs", "gs", "csv", "ps", "cmp", "bs", "fs", "hs"], "n": ["nb", "ne", "g", "nm", "en", "na", "sn", "cn", "len", "nn", "net", "ns", "ni", "nc", "num", "d", "v", "k", "mn", "nu", "N", "t", "rn", "j", "p"], "m": ["f", "mut", "nm", "M", "mult", "sm", "cm", "min", "mc", "man", "dim", "mu", "im", "dm", "r", "middle", "l", "num", "v", "mid", "mn", "mode", "msg", "mi", "bm", "t", "p"], "channel": ["component", "unit", "window", "label", "coord", "cell", "config", "column", "slot", "counter", "connection", "chain", "ind", "peer", "entity", "part", "bean", "camera", "cam", "cm", "chip", "panel", "sc", "pixel", "version", "server", "chn", "face", "button", "can", "section", "annels", "monitor", "index", "id", "CHO", "client", "broad", "row", "mode", "key", "change", "course", "axis", "member", "instance", "chron", "col", "direction", "frame", "status", "ann", "chan", "character", "number", "command", "queue", "Channel", "field", "category", "chapter", "batch"], "i": ["f", "ind", "ir", "ai", "ip", "y", "pi", "im", "e", "ci", "l", "index", "id", "v", "k", "I", "ii", "ti", "x", "di", "it", "mi", "t", "j", "p"], "samples": ["samp", "tources", "ssamp", "Samp", "samps", "ssources", "tamples", "ssamples", "tamps", "tamp", "Sources", "sizes", "ssamps", "sources", "Samples", "ssizes", "Samps", "Sizes"], "src": ["proc", "url", "tmp", "length", "ser", "from", "offset", "rs", "ref", "sample", "sn", "ctr", "fp", "ind", "iter", "sq", "std", "origin", "fc", "rc", "stream", "seed", "sc", "conv", "syn", "sub", "img", "np", "loc", "inst", "sr", "r", "scan", "sync", "sys", "dest", "txt", "b", "sb", "str", "seek", "stats", "filename", "raw", "supp", "source", "addr", "ptr", "input", "bs"], "st": ["ost", "tt", "sw", "ste", "nd", "std", "stage", "sta", "stream", "size", "sth", "rest", "pos", "iat", "p", "inst", "set", "r", "St", "est", "d", "sp", "ST", "ct", "out", "state", "str", "x", "status", "it", "stop", "w", "start", "at", "t", "z", "step", "ist"], "count1": ["length3", "code0", " count3", "code3", "length1", "code2", "length2", " count0", "length0", "count3", "count0", "code1"], "count2": ["conf02", "Count02", "Count3", "length3", "conf3", "lengthtwo", "count02", "length2", "conftwo", "count3", "counttwo", "Count2", "Counttwo", "conf2", "length02"], "nb_samples": ["nb_shaves", "nb_sutes", "nb_Sabilities", "nb_isances", "nb_spamps", "nb_Sizes", "nb_taves", "nbntsutes", "nb67samples", "nb_mizes", "nb_Samps", "nb_sips", "nb_gizes", "nb_absumps", "nbntservips", "nb_samp", "nb_mabilities", "nb_psizes", "nb_bannels", "nb_nizes", "nb_shucks", "nb_sucks", "nb_servips", "nb_exizes", "nb_absaves", "nb_isaves", "nb_Samples", "nb67sots", "nbntsamps", "nb_psamp", "nb_servutes", "nb_damples", "nb_mamps", "nb_stringsamps", "nb_spots", "nb_shamples", "nb67samps", "nb67spamples", "nb__samples", "nb_bizes", "nb_bamples", "nb_sumps", "nb_sizes", "nb_gamps", "nb__sizes", "nb__psizes", "nb_spores", "nb_examps", "nb_dizes", "nb__psamples", "nb_swots", "nb_shumps", "nb_dacks", "nbntsips", "nb_sannels", "nb_absucks", "nb_sances", "nb_swores", "nb_Sacks", "nb_namples", "nbntservamples", "nb_tamples", "nb_sabilities", "nb_servamps", "nbntservamps", "nb_swamples", "nb_tumps", "nb67sores", "nb_spamples", "nb_nances", "nbntsamples", "nb_sores", "nb_namp", "nb_stringsips", "nb_examples", "nb_exannels", "nb_stringsutes", "nb_gamples", "nb_saves", "nb_servamples", "nb_isamples", "nb_damps", "nb_stringsamples", "nb_absamples", "nb67spamps", "nb__psamp", "nb_nocks", "nb_Samp", "nb_naves", "nb_tucks", "nb_sots", "nb_backs", "nb67spots", "nb_gabilities", "nb_psamples", "nb__samp", "nb_sacks", "nb_bamps", "nb_socks", "nb_samps", "nbntservutes", "nb_Sannels", "nb67spores", "nb_isocks", "nb_mamples", "nb_swamps"], "coded_samples": ["coded_samps", "coded_seamps", "coded_sample", "coded_hamples", "coded_Sample", "coded_seumbers", "coded_sounds", "coded_examps", "coded_seample", "coded_osamps", "coded_isamples", "coded_Samples", "coded_exents", "coded_alamples", "coded_Sples", "coded_nims", "coded_nents", "coded_pounds", "coded_seamples", "coded_alples", "coded_pamples", "coded_gamples", "coded_pides", "coded_sents", "coded_isamps", "coded_pamps", "coded_sumbers", "coded_hucks", "coded_isample", "coded_namples", "coded_sples", "coded_isumbers", "coded_osamples", "coded_namps", "coded_gims", "coded_Sims", "coded_sucks", "coded_Sucks", "coded_exples", "coded_Sents", "coded_sides", "coded_pples", "coded_gents", "coded_pucks", "coded_hples", "coded_alides", "coded_sims", "coded_osents", "coded_osples", "coded_examples", "coded_Sumbers", "coded_hamps", "coded_Samps", "coded_gamps", "coded_alounds"], "ret": ["new", "rt", "tmp", "reg", "gt", "ref", "result", "err", "not", "rem", "cont", "dt", "fin", "len", "tr", "res", "elt", "ll", "re", "flag", "resp", "det", "RET", "Ret", "rev", "progress", "txt", "mat", "back", "out", " Ret", "reset", "val", "rets", "alt", "mem", "deg", "last", "it", "fun", "rm", "nt", "reply", "t", "repl", "red"], "predictor": ["prejectory", "priptor", "pstickored", "pochractor", "predictored", "practutor", "pereciitor", "ipictionori", "pochutor", "ipictionoring", "priptractor", "priptoral", "padaptractor", "pstickory", "ipredictoring", "ipictionory", "pocoltor", "pjectoring", "ipredictory", "propectator", "preredictor", "peredictor", "ppredor", "peredictoring", " predicttor", "ipredictori", "preciitor", "ppectator", "pereciutor", "perecior", "pictionor", "pocolory", "padaptor", "ipredictor", "ppredoring", "proxory", "padaptitor", "proredictator", "pocoloral", "proredictor", "pepriractor", "pictionori", " pocolor", "pictionory", "pprior", "peredictutor", "predictator", "ppriractor", "predictractor", "predicttor", "ppredory", "predictori", "pictionoring", "predictoral", "proxori", "peprioring", "pprioral", "precior", "peprior", "pocoloring", "prediction", "prejector", "predictutor", "pstickator", "predictory", "prerediction", "pocolor", "prejectori", "pription", "practoral", "practtor", "pjectori", "peredictoral", "proredictored", "preredictory", "ppredori", "priptoring", "pjectory", "proxion", " predictoral", "pripttor", "pochor", "pochitor", "practor", "padaptutor", "ppector", "priptory", "prejection", "peredictractor", "ppectored", "pocolator", "pstickor", "pjection", " pocoloral", "preciutor", "peredictitor", " predictutor", "propectory", "proxor", "preciractor", "propectored", " pocolutor", "pprioring", "predictoring", "priptutor", "priptori", "ipictionor", "pocolutor", "ppectory", "preredictori", "pjector", "peprioral", "pereciractor", "propector", "proredictory", "pocolractor", "pocolored", " pocoltor", "predictitor"], "step_index": [" step_num", "stepxi", "step2i", "step1Index", " step_is", " step_Index", "step2index", "step2ind", "stepxIndex", " step2size", " step_size", "step2Index", "step2size", "step_level", "step_id", "step_num", " step2num", "STEP_level", " step2number", "step1number", " step2is", "step_i", "step2number", "step1index", " step2ind", "stepxind", " step_ind", "step_Index", "step_is", "step_ind", "step2num", "STEP_ind", "stepxindex", "STEP_id", "step_number", " step_number", " step2index", " step2Index", " step2i", "STEP_index", " step_i", "step_size", "step1num", "step2is"]}}
{"project": "qemu", "commit_id": "a38648290ee277c7cb8a53eabdcdb08bb7a9f23f", "target": 1, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16666, "substitutes": {"req": ["org", "rh", "fr", "low", "rr", "qq", "ctx", "md", "quest", "http", "deg", "rpm", "needed", "rd", "xml", "tx", "test", " requ", "rx", "dq", "dist", "expr", "progress", "rec", "esp", "wrapper", "cmd", "compl", "forced", "required", "msg", "inv", "usr", "conf", "pkg", "require", "ind", "sq", "err", "good", "rl", "q", "comp", "wx", "resp", "buf", "tf", "history", "prefix", "desc", "cur", "seq", "pro", "aux", "range", "crit", "rt", "coord", "config", "ref", "rc", "worker", "urg", "requ", "tr", "res", "qt", "rel", "r", "gr", "request", "rss", "sys", "eq", " sched", "exec", "queue", "ps"], "i": ["is", "init", "c", "y", "ip", " ii", "ims", "qi", "v", "I", "PI", "ii", "phi", " ti", " j", "hi", "t", "f", "iter", "ui", "\u0438", "pi", "im", "ms", "index", " pi", "client", "ie", "mi", "name", "multi", "p", "g", "gi", "ind", "chain", "user", "ri", "xi", "point", "ki", "ex", "cli", "ai", "q", "li", "ql", "iu", " bi", "ci", "sim", "m", "me", "ti", "x", " m", "uri", "ski", "si", "bi", "info", " v", "ic", "in", "zi", "ji", "id", "n", "ei", "ix", "di", "it", "ini", "j", "oi"], "sign": ["trade", "pay", "close", "is", "act", "sum", "mut", "sem", "wrap", "SIGN", "ind", "shift", "sq", "min", "trust", "size", "mask", "draw", "scale", "sc", "ss", "pen", "diff", " SIGN", "ig", "go", "sd", "spec", "set", "round", "ver", "align", "form", "Sign", "se", "gate", "pres", "angle", "sha", "s", "operator", "fix", "grad", "mark", "just", "ign", "sa", "sch", "sche", "mod", "dig", "sh", "add", "si"], "tmp": ["dust", "tar", "xy", "trap", "etc", "np", "pp", "top", "qq", "wp", "zip", "ctx", "var", "v", "tty", "mk", "bt", "uv", "buff", "ghost", "mb", "snap", "cmp", "new", "pad", "extra", "st", "test", "nd", "temp", "cp", "diff", "null", "obj", "gm", "db", "gb", "msg", "nt", "MP", "p", "prime", "tm", "pkg", "vv", "result", "tg", "good", "mmm", "mobi", "tc", "buf", "m", "tf", "sp", "txt", "uf", "vt", "ptr", "rt", "attr", "tt", "emp", "tn", "mm", "td", "mp", "img", "stuff", "gz", "mint", "perm", "t", "pretty"]}}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static char *choose_pixel_fmts(OutputStream *ost)\n\n{\n\n    if (ost->keep_pix_fmt) {\n\n        if (ost->filter)\n\n            avfilter_graph_set_auto_convert(ost->filter->graph->graph,\n\n                                            AVFILTER_AUTO_CONVERT_NONE);\n\n        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)\n\n            return NULL;\n\n        ost->pix_fmts[0] = ost->st->codec->pix_fmt;\n\n        return ost->pix_fmts;\n\n    }\n\n    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {\n\n        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));\n\n    } else if (ost->enc->pix_fmts) {\n\n        const enum PixelFormat *p;\n\n        AVIOContext *s = NULL;\n\n        uint8_t *ret;\n\n        int len;\n\n\n\n        if (avio_open_dyn_buf(&s) < 0)\n\n            exit_program(1);\n\n\n\n        p = ost->enc->pix_fmts;\n\n        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };\n\n            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,\n\n                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };\n\n            }\n\n        }\n\n\n\n        for (; *p != PIX_FMT_NONE; p++)\n\n            avio_printf(s, \"%s:\", av_get_pix_fmt_name(*p));\n\n        len = avio_close_dyn_buf(s, &ret);\n\n        ret[len - 1] = 0;\n\n        return ret;\n\n    } else\n\n        return NULL;\n\n}\n", "idx": 16693, "substitutes": {"ost": ["rend", "hop", " nost", "sta", "oster", "drm", "etc", "mont", "inst", "wp", "sty", "ast", "old", "art", "ict", "osta", "oid", "rest", "past", "st", "ogg", "lost", "omm", "ot", "ird", "embed", "expr", "tto", "wikipedia", "htt", "oss", "nt", "aft", "usr", "mt", "wart", "irst", "lov", "oad", "host", "rog", "otype", "post", "os", "rost", "hyd", "utt", "ood", "poll", "gob", "ocr", "yt", "dit", "ust", "ob", "roc", "ond", "rt", "OST", "tt", "ox", "ott", "mm", "ud", "boost", "bott", "ous", "obs", "wn", "must", "est", "rss", "ord", "oth", "ty", "stone", "rom", "upload", "news", "stat", "od", "ist"], "p": ["f", "pat", "ep", "pkg", "P", "jp", "fp", "a", "h", "c", "i", "pr", "per", "q", "cp", "ip", "bp", "pp", "np", "pb", "u", "php", "r", "lp", "pc", "wp", "pt", "ap", "m", "sp", "v", "pa", "o", "vp", "par", "pro", "perm", "op", "pe", "ps", "t", "rep", "tp", "j"], "s": ["ls", "is", "sts", "g", "rs", "ins", "a", "c", "h", "ops", "js", "i", "os", "ss", "ns", "ms", "ats", "ts", "sys", "its", "es", "b", "n", "sb", "stats", "ds", "S", "gs", "cs", "ps", "t", "bs", "fs", "hs"], "ret": ["new", "tmp", "final", "result", "conv", "pas", "res", "gc", "re", "resp", "buf", "RET", "Ret", "rev", "uf", "out", "reset", "val", "alt", "mem", "status", "vals", "nt", "tag", "mt"], "len": ["ls", "length", "en", "Len", "ref", "vec", "c", " bl", "err", "cap", " Len", "l", "el", "n", " length", "str", " clen", " l", "file", "mem", "lib", "ln", "t", "L", "cmp", "name"]}}
{"project": "FFmpeg", "commit_id": "5e2202d6f3ac2f3afd714a62437ca6b24f75c09f", "target": 1, "func": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)\n\n{\n\n    char buffer[32];\n\n    if (time) {\n\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));\n\n        av_metadata_set2(metadata, \"creation_time\", buffer, 0);\n\n    }\n\n}\n", "idx": 16700, "substitutes": {"metadata": ["profile", "adata", "header", "config", "xml", "map", "tar", "ATA", "info", "memory", "properties", "json", "ad", "ka", "aka", "message", "pdf", "m", "summary", "options", "about", "template", "basic", "met", "dirty", "database", "latest", "md", "maybe", "package", "data", "managed", "google", "node", "directory", "mt", "iso", "meta", "details", "partial"], "time": ["tm", "window", "type", "length", "offset", "ype", "year", " timestamp", " Time", "end", "user", "clock", "info", "timeout", "size", "func", "TIME", "runtime", "duration", "ime", "event", "set", "im", "tim", "month", "check", "message", "sync", "value", "date", "now", "path", "id", "ts", "hour", "mode", "code", "template", "before", "Time", "inter", "comment", "context", "instance", "str", "UTC", "IME", "trace", "data", "timer", "transform", "stop", "node", "start", "mt", "created", "t", "etime", "name"], "buffer": ["text", "window", "pad", "bb", "length", "block", "header", "offset", "cache", "page", "result", "iter", "interface", "screen", "document", "stream", "memory", "Buffer", "server", "null", "byte", "bytes", "line", "read", "engine", "button", "table", "buf", "message", "index", "b", "row", "record", "stack", "comment", "context", "data", "mem", "output", "raw", "buff", "base", "command", "limit", "queue", "variable", "batch"]}}
{"project": "qemu", "commit_id": "6982d6647ea98544f76d5ef40ddc23115ff44a77", "target": 1, "func": "static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            printf(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                return timer->config;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                return timer->config >> 32;\n\n            case HPET_TN_CMP: // comparator register\n\n                return timer->cmp;\n\n            case HPET_TN_CMP + 4:\n\n                return timer->cmp >> 32;\n\n            case HPET_TN_ROUTE:\n\n                return timer->fsb >> 32;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return s->capability;\n\n            case HPET_PERIOD:\n\n                return s->capability >> 32;\n\n            case HPET_CFG:\n\n                return s->config;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl \\n\");\n\n                return 0;\n\n            case HPET_COUNTER:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick;\n\n            case HPET_COUNTER + 4:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick >> 32;\n\n            case HPET_STATUS:\n\n                return s->isr;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16708, "substitutes": {"opaque": ["OPque", "oposter", " opane", "Opacity", "obcache", "opacity", " opque", "OPaque", "OPcache", "compacity", "opane", "Opane", "compaque", "obaque", "obque", " opaques", "OPaques", "opque", " opacity", "opcache", " opcache", "composter", "Opaque", "Oposter", "compane", " oposter", "obaques", "opaques"], "addr": ["pad", "tmp", "act", "alias", "coord", "block", "offset", "attr", "gt", "oad", "host", "hw", "ref", "conn", "init", "pkg", "tx", "ash", "point", "i", " address", "ad", "asm", "pos", "obj", "kt", "loc", "align", "hz", "src", "address", "arr", "r", "Address", "dh", "now", "ack", "off", "ctx", "ock", "var", "ord", "gate", "inter", "state", "alloc", "cmd", "ix", "prefix", "atom", "x", "seek", "alt", "mem", "oa", "adr", "z", "ptr", "mt", "ace", "mb", "hash", "__", "add", "name", "arp"], "s": ["is", "er", "as", "states", "a", "h", "c", "sm", "js", "vs", "ims", "e", "objects", "v", "ches", "o", "tes", "stats", "qs", "ses", "less", "ers", "als", "ments", "terms", "ries", "aws", "sw", "xs", "aps", "ports", "ss", "ns", "obj", "spec", "ms", "actions", "parts", "ations", "state", "an", "vals", "w", "S", "results", "sis", "hs", "p", "sl", "sts", "rs", "sq", "self", "os", "ands", "sim", "m", "sp", "sb", "ssl", "gs", "ists", "comm", "bs", "ls", "sv", "changes", "erences", "ats", "ts", "sys", "its", "sets", "b", "n", "eds", "ds", "ps", "t", "fs", "es"], "cur_tick": ["cur_tz", "curJtick", "cur_ick", "curxick", " cur_loop", " cur_trigger", "curptloop", " cur_cycle", " cur_stick", "curvtick", "cor__tick", "curxtoken", "curpttick", "curmmick", "cor_tz", "cur__tick", "curitycycle", "curvpick", "cor_ick", "cor__cycle", "cur_trigger", "curPbyte", "cur___tick", "curPtick", "curMtoken", "cur_stick", "curptcycle", "curtpoll", " cur_tz", "curpttty", " cur_pick", "cur__ick", "curptick", " cur_token", "curmmtick", "cor__ick", " cur_byte", " cur_ick", "cur___stick", "curMick", "cur___ick", "cur_cycle", "curmmpick", "cur_loop", "cor_cycle", "curPpick", "curxtick", "curPick", "cur_poll", "cur_tty", "cur__tz", "cur__cycle", "cor_tick", "curMtick", "curpttoken", "curtstick", "curityick", " cur_tty", "cur_byte", "cur_pick", " cur_poll", "curJtty", " cur_shot", "curvpoll", "cur___pick", "curitytz", "curxtrigger", "cur_mill", "cor__tz", "curvick", "curtick", " cur_mill", "cur_shot", "curmmbyte", "curptshot", "curJloop", "curMtrigger", "curttick", "curJcycle", "cur_token", "curitytick", "curtpick"], "index": ["act", "length", "label", "block", "type", "offset", "rank", "open", "action", "ref", "location", "ind", "Index", "vector", "tx", "iter", "test", "point", "lock", "ex", "info", "i", "pointer", "seed", "size", "position", "shape", "range", "order", "error", "pos", "obj", "loc", "set", "address", "check", "height", "scan", "can", "zero", "num", "id", "row", "ctx", "gate", "code", "dd", "angle", "key", "context", "val", "axis", "db", "ix", "cmd", "slice", "x", "seek", "link", "loop", "status", "node", "find", "typ", "input", "hash", "timeout"], "timer": ["tm", "taker", "program", "header", "cell", "Timer", "later", "runner", "er", "counter", "processor", "mr", "peer", "tower", "clock", "test", "iter", "cer", "tar", "temp", "parser", "walker", "worker", "term", "thread", "browser", "dt", "duration", "iler", "player", "event", "actor", "tem", "tim", "tc", "handler", "menu", "ter", "tom", "monitor", "byter", "writer", "meter", "time", "cker", "loader", "state", "wrapper", "finder", "trace", "atom", "task", "span", "imer", "tick", "tz", "ger", "trigger", "transfer", "t", "ramer", "variable", "timeout"]}}
{"project": "qemu", "commit_id": "bd8b92d5c8387c2c94f06665514c05000169fafd", "target": 1, "func": "void usb_claim_port(USBDevice *dev, Error **errp)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    assert(dev->port == NULL);\n\n\n\n    if (dev->port_path) {\n\n        QTAILQ_FOREACH(port, &bus->free, next) {\n\n            if (strcmp(port->path, dev->port_path) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (port == NULL) {\n\n            error_setg(errp, \"usb port %s (bus %s) not found (in use?)\",\n\n                       dev->port_path, bus->qbus.name);\n\n            return;\n\n        }\n\n    } else {\n\n        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), \"usb-hub\") != 0) {\n\n            /* Create a new hub and chain it on */\n\n            usb_create_simple(bus, \"usb-hub\");\n\n        }\n\n        if (bus->nfree == 0) {\n\n            error_setg(errp, \"tried to attach usb device %s to a bus \"\n\n                       \"with no free ports\", dev->product_desc);\n\n            return;\n\n        }\n\n        port = QTAILQ_FIRST(&bus->free);\n\n    }\n\n    trace_usb_port_claim(bus->busnr, port->path);\n\n\n\n    QTAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    dev->port = port;\n\n    port->dev = dev;\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n", "idx": 16717, "substitutes": {"dev": ["wd", "ad", "def", " ov", "debug", "event", "patch", "det", "vol", "dem", "env", "v", "var", "val", "md", "dis", "req", "mem", " def", "api", " priv", "add", "proc", "pad", "Dev", "iver", "hw", "test", "des", "serv", "device", "obj", "dist", "sd", " spec", "spec", "ev", "db", "cmd", "Device", "usb", "w", "nt", "die", "conf", "ext", "conn", "ind", " device", "dn", "ex", "valid", "util", "iv", "go", "loc", "driver", "buf", "pt", "ve", "desc", "pro", "serial", "prov", "tech", "did", "cam", "info", "doc", "ver", "att", "rel", "d", "den", "sys", "gu", "dest", "priv", " adm", "dd", "dep", "app", "DEV", "de", "ds", "av", "fo", " doc", "od", " devs"], "errp": ["rerp", "errping", "rrp", "rrr", "derp", "erm", "rrping", "errm", "ferpe", "err", " errP", "errpc", "derm", " errpa", "derping", "derr", "ferpc", "strpc", "errpa", "errpe", "erpa", "rerr", "ferp", "erping", "rerpa", "strP", "ferP", "strp", " errpc", "errP", "strpe", "rrm", "erp", " errpe", "errr", " errr"], "bus": ["us", "is", "box", "bh", "block", "cache", "ass", "cat", "cus", "kernel", "store", "way", "cast", "vol", "ctx", "trace", "http", "gen", "proc", "bridge", "br", "bits", "mount", "docker", "bar", "stick", "pos", "bug", "soc", "hub", "back", "state", "Bus", "db", "BUS", "phys", "loop", "usb", "nt", "tag", " BUS", "disk", "conn", " busy", "host", "chain", "user", "self", "os", "util", "bur", "driver", "um", "buf", "cpu", "ack", "book", "bc", "proxy", "used", "pool", "bs", "bo", "config", "boot", "US", "lock", "bill", "uss", "hand", "ck", "board", "bank", "bool", "plug", "handle", "ac", "sync", "local", "bid", "b", "data", "bal", "lib", "kit"], "port": [" sport", "page", "P", "seat", "pport", "priority", "pen", "pp", "pit", "table", "project", "pc", "message", "pid", "var", "be", "out", "po", "key", "val", "trace", "limit", "bridge", "pad", "entry", "test", "pose", "report", "ports", "pr", "ot", "cp", "null", "device", "pos", "pan", "export", "pi", "target", "tip", "vision", "ORT", "path", "index", "client", "pe", "tag", "mt", "name", "p", "profile", "unit", "to", "length", "ported", "peer", "point", "post", "pipe", "buffer", "version", "phy", "pt", "pod", "mobile", "ve", "proxy", "next", "file", "pro", "pool", "eport", "ptr", "range", " transport", "type", "mit", "connection", "gp", "per", "position", "server", " Port", "ver", "handle", "ort", "list", "import", "ping", "it", "Port", "queue", "PORT"], "nfree": ["nFREE", "mFree", "mfree", "NFREE", "Navailable", "mavailable", "unavailable", " navailable", "Nfree", "nFree", "NFree", "unfree", "Nused", "mused", "navailable", " nFREE", "unFree", " nFree", "unFREE"], "nused": ["cneeded", "ntused", "nneeded", "newneeded", "ntneeded", "newfree", "newused", "nUsed", "cfree", "newUsed", "cused", "ntUsed", "ntfree", "cUsed"]}}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static void vmxnet3_update_features(VMXNET3State *s)\n\n{\n\n    uint32_t guest_features;\n\n    int rxcso_supported;\n\n\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,\n\n                                               devRead.misc.uptFeatures);\n\n\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n\n              s->lro_supported, rxcso_supported,\n\n              s->rx_vlan_stripping);\n\n    if (s->peer_has_vhdr) {\n\n        qemu_peer_set_offload(qemu_get_queue(s->nic),\n\n                        rxcso_supported,\n\n                        s->lro_supported,\n\n                        s->lro_supported,\n\n                        0,\n\n                        0);\n\n    }\n\n}\n", "idx": 16723, "substitutes": {"s": ["ls", "is", "sl", "sts", "sv", "rs", "st", "as", "states", "aws", "fs", "changes", "so", "a", "c", "sq", "h", "ops", "js", "ports", "des", "os", "store", "ss", "params", "ies", "vs", "details", "ns", "ims", "spec", "set", "pers", "ms", "als", "ts", "d", "m", "its", "b", "v", "n", "se", "sb", "services", "stats", "ds", "qs", "ses", "less", "w", "S", "gs", "cs", "ps", "t", "bs", "comm", "sis", "hs", "p"], "guest_features": ["guestlyrelations", "guarent_fits", "guEST_members", "guESTlyfeatures", "guility_feature", "guility_links", "guest_forms", "guestlyfits", "guESTlyabilities", "guestlyreports", "guestfulreports", "guarentlyreports", "guestfulterms", "guestXreports", "guess_features", "guarent_features", "guarentlyfeatures", "guess_flags", "guestlyfeatures", "guestfulfeatures", "guest2feature", "guestmatmembers", "guest_abilities", "guestmatabilities", "guest_results", "guest_flags", "guest2forms", "guest_reports", "guest_links", "guest____features", "guEST_abilities", "guhouse_abilities", "guestXfits", "guestfulabilities", "guest2links", "guestlytimes", "guarentlyrelations", "guESTlymembers", "guest2features", "guestmattimes", "guestXrelations", "guest_terms", "guhouse_terms", "guarent_reports", "guess_results", "guestmatfeatures", "guestlyabilities", "guestlymembers", "guhouse_features", "guestfulresults", "guest_fits", "guESTlytimes", "guestXfeatures", "guarentlyfits", "guility_forms", "guest_times", "guEST_features", "guest_relations", "guest_faces", "guest____links", "guess_faces", "guility_features", "guarent_relations", "guest_feature", "guest_members", "guestfulfits", "guest____feature", "guest____forms", "guhouse_results", "guEST_times", "guestfulrelations"], "rxcso_supported": ["rxcso67Supported", "rxcsi_supported", "rxcsi67Supported", "rxcSO_powered", "rxcSO_allowed", "rxcso_powered", "rxcso__support", "rxcsi67supp", "rxcsi_supp", "rxcso_allowed", "rxcSo_enabled", "rxcso_supp", "rxcso__supported", "rxcsi67enabled", "rxcso67enabled", "rxcSO_supported", "rxcsi_enabled", "rxcSo_support", "rxcSo_supported", "rxcso__enabled", "rxcso67supported", "rxcso_enabled", "rxcsi67supported", "rxcso_support", "rxcso67supp", "rxcso_Supported", "rxcsi_Supported"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int virtio_blk_exit_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n\n\n    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);\n\n    return virtio_exit_pci(pci_dev);\n\n}\n", "idx": 16724, "substitutes": {"pci_dev": ["pci2info", "pci__ev", "pcu_priv", "pdi_def", "pci_Dev", "pci_devices", "pci__dev", "pci__device", "pcu_devices", "pci_priv", "pct_device", "pciablecur", "pci2priv", "pci_info", "pct_ev", "pci2devices", "pci_cur", "pct_cur", "pci2dev", "pci__def", "pdi_device", "pct_dev", "pdi_ev", "pciabledevice", "pcu_info", "pdi_Dev", "pciableev", "pcu_dev", "pdi_dev", "pci_def", "pci_ev", "pciabledev", "pci_device"], "proxy": ["prime", "profile", "alias", "cache", "bus", "reverse", "xy", "roxy", "info", "pipe", " proxies", "service", "linux", "clone", "port", "manager", "slave", "server", "version", "shadow", "device", "phy", "master", "boss", "target", "Proxy", "remote", "friend", "project", "ping", "client", "super", "primary", "one", "cas", "link", "pse", "x", "PRO", "pro", "reply", "dev", "response", "cor", "sup"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A = 0xffff<<14;\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]    ) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16727, "substitutes": {"ubuf0": ["ubux0", "abbuf2", "ubimg0", "ubuffer0", "ubufee", "ubool2", "abbuf19", "ubimg1", "ubuffer1", "abbuf047", "ubool0", "ubbuf2", "ubuf047", "abuf19", "ubbuf0", "ubux047", "ubimg2", "abuf1", "abbuf1", "ubuf2", "ubuffer047", "abuf0", "ubool19", "ubimg19", "abuf2", "abuf047", "abbuf0", "abufee", "abbufee", "ubbuf19", "ubbufee", "ubuxee", "ubuf19", "ubux1", "ubool1", "ubufferee", "ubbuf1", "ubbuf047"], "vbuf0": ["bbuf0", "bbuffer1", "qbuf2", "bbuf3", "vbuff1", "qbuf0", "qbuf1", "vbuff0", "vbuffer0", "bbuf1", "quf3", "quf0", "vuf2", "vbuffer3", "bbuffer3", "vuf0", "bbuffer0", "vbuff2", "bbuffer2", "vbuff3", "vbuffer2", "qbuf3", "bbuf2", "quf2", "vuf1", "vbuf2", "vbuf3", "vuf3", "vbuffer1", "quf1"], "i": ["f", "is", "bi", "gi", "ind", "chain", "a", "c", "ri", "xi", "point", "ki", "err", "ex", "cli", "ai", "info", "ini", "oi", "batch", "li", "ui", "ic", "ip", "y", "io", "\u0438", "ami", "in", "pi", "iu", "qi", "im", "e", "zi", "ci", "l", "sim", "m", "me", "index", "id", "ji", "list", "b", "v", "k", "I", "n", "o", "ii", "ti", "phi", "ix", "x", "status", "di", "it", "mi", "ij", "t", "ski", "multi", "z", "j", "si", "p"], "R": ["RA", "RR", "HR", "M", "P", "H", "C", "RE", "RI", "T", " r", "RL", "GR", "D", "F", "V", "RB", "r", "I", "A", "RF", "SR", "AR", "RO", "RC", "W", "S", "N", "RG", "Y", "DR", "U", "L", "E", "MR", "BR", "RGB", "X"], "G": ["Gh", "J", "g", "GV", "M", "GB", "Gs", "H", "C", "Q", "GC", "GR", "GA", "GP", "F", "Gr", "V", "GU", "GG", "GD", "GE", "LG", "VG", "BG", "Gb", "Gu", "GI", "GT", "GH", "Graphics", "gg", "CG", "GM", "W", "RG", "Y", "Ge", "PG", "L", "U", "GF"], "B": ["SB", "J", "BL", "M", "P", "GB", "H", "C", "BM", "Q", "BA", "T", "Base", "AB", "D", "F", "V", "BC", "BW", "Z", "b", "Bar", "A", "BG", "I", "WB", "TB", "Br", "W", "N", "Y", "DB", "L", "E", "BB", "BR", "U"], "ubuf1": ["umbuf2", "umuf0", "umbuf4", "umuf1", "ubuff2", "ubbuf2", "ubuff0", "umuf2", "ubbuf0", "ubuff1", "ubump1", "ubuf2", "umuf4", "ubump4", "ubump0", "umbuf1", "ubuff4", "ubbuf4", "ubump2", "ubuf4", "umbuf0", "ubbuf1"]}}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n", "idx": 16728, "substitutes": {"packet": ["ppets", "tenets", "presacket", "ppacket", "tenpet", "octets", "octacket", "tenet", "packkt", "packpet", "pkt", "preset", "pet", "pppet", "ppet", "packacket", "preskt", "tenacket", "presets", "octkt", "pets", "octet", "octpet", "packets"], "opaque": ["popvious", "popaque", "operque", " opvious", "Opque", "operosit", "operaque", "popque", " opaques", "popaques", "Opois", "opque", "opois", "Oposit", "oppush", "oposit", " opush", "oppaque", "Opaque", "opvious", "oppaques", "oppvious", "opush", "poposit", "popois", "operois", "opaques", "popush"], "s": ["ls", "sl", "is", "sts", "g", "rs", "as", "ins", "a", "c", "sq", "h", "xs", "js", "i", "q", "os", "ss", "ess", "ies", "ns", "e", "ats", "d", "m", "its", "ts", "es", "b", "n", "o", "sb", "stats", "ds", "qs", "ses", "w", "S", "gs", "cs", "ps", "t", "fs", "j", "p"], "async": ["assapter", "lasAsync", "asAsync", "lasync", "AsAsync", "ASynchronous", "assync", "asload", "aync", "asesync", "asapter", "lassync", "Async", "ASsync", "lasynchronous", "aseload", " ASapter", " ASync", "aseapter", "aload", "assload", "ASync", "resync", "aseync", "asyn", "asynchronous", "assynchronous", "aseynchronous", "ASAsync", "asssync", "ressync", " ASynchronous", "resyn", "Asynchronous", "Assync", "resynchronous", " ASsync", "assyn", "lasyn", "aynchronous"]}}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n", "idx": 16735, "substitutes": {"reg": ["rt", "g", "cache", "REG", "ref", "map", "pre", "temp", "mp", "ret", "rem", "res", "gc", "loc", "rr", "re", "r", "gr", "m", "rec", "txt", "eg", "out", "state", "ru", "db", "gov", "pg", "prefix", "Reg", "mem", "grid", "rm", "nt", "addr", "ptr", "tag", "adj", "mt", "rep", "mb", "p"], "q": ["f", "qa", "g", "sq", "qu", "Q", "i", "mp", "dq", "ip", "ue", "qt", "aq", "qq", "qi", "max", "quant", "query", "m", "qv", "eq", "v", "k", "count", "x", "req", "qs", "quit", "w", "queue", "iq", "t", "conf", "z", "j", "p"], "tmp": ["prime", "nb", "rt", "pad", "cv", "new", "cmp", "offset", "tt", "nm", "cache", "pkg", "tn", "map", "test", "nr", "mm", "temp", "mp", "ret", "cp", "np", "img", "cb", "qq", "max", "r", "buf", "m", "ap", "num", "sp", "v", "ctx", "out", "mk", "db", "gov", "x", "cur", "uint", "msg", "mint", "rm", "nt", "buff", "start", "needed", "ptr", "mb", "mt", "snap", "t", "tp", "p"], "size": ["type", "length", "ose", "ne", "g", "cache", "sv", "sn", "c", "nl", "shape", "style", "SIZE", "scale", "dim", "len", "ize", "group", "e", "small", "l", "sync", "m", "network", "v", "k", "mode", "code", "space", "Size", "empty", "count", "scope", "dimension", "t", "sh", "z", "name", "p"], "n": [" len", "na", " ans", "sn", " nin", "c", "h", " nm", "after", "i", " nu", " number", " ii", "np", "un", "v", "o", "out", "nu", "gn", " j", "node", "f", " i", "nm", "nr", "len", "ns", "norm", " net", "nw", "index", "s", "an", "ln", "w", "nt", "N", "name", "p", " ng", "all", "ne", "g", "en", " ns", "ind", "cn", " sn", "ren", "dn", "yn", "nn", "go", "ll", "nor", "l", "m", "k", " fn", " na", "nan", " num", "on", "number", "no", "raw", "fn", "batch", "tn", " out", " ne", "nl", " name", "names", "wn", "note", "remote", "ng", "nc", "d", "num", "mn", " iter", " no", " ni", "t", "j"], "t0": ["t2", "T0", "at0", "T5", "t047", "t3", "tn", "tu0", "tu1", "t6", "T8", "tsn", " t3", "T6", "tm1", "t5", "kt6", "at047", "pt047", " t2", "kt1", "te0", "tm8", "te5", "kt0", "p1", "ts1", " tk", "p0", " T1", "Tn", "pk", " T2", "t8", "pt0", " t6", "tmn", " t047", "tu5", "te1", "ts0", "ts8", "tm0", "p2", "tk", "pt3", " Tk", " T0", "at3", "T1"], "t1": ["template8", "t2", "T0", "at0", "teOne", "te8", "typeone", "t9", "T10", "t6", "type1", "template1", "T2", "teone", "type0", " t2", "t64", "tone", "T9", "te2", "template2", "Tone", "type64", "atOne", "atone", "type4", "tOne", "at1", "te6", " t4", "type2", "t8", " t9", "at4", "at6", " t6", "template64", "te64", "at9", "t4", "t10", "te1", "T4", " tOne", " tone", "type8", "type10", "T1", " t10"]}}
{"project": "qemu", "commit_id": "f892291eee376505cfec8b6cade7ccf952a6d3e0", "target": 0, "func": "static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n", "idx": 16752, "substitutes": {"dist": ["depend", "conn", "dx", "add", "ind", " redist", "du", "df", "distance", "wd", "err", "delay", "disc", "draw", "def", "dt", "dim", "diff", "del", "att", "driver", "dm", "form", "dir", "resp", "det", "dem", "progress", "d", "txt", "dj", "dd", "missing", "dep", "Dist", "md", "dis", "cmd", "str", "desc", "reflect", "grad", "req", "ds", "exec", "lib", "dr", "dev", "conf", "rest", "ist"], "errp": ["errorpress", "lrpkg", "eorpkg", "errup", "errping", " errpoint", "ererpc", "ierpoint", "errorr", "dercp", "derp", "ererpa", "aerp", "ierg", "eorP", "eorpost", "eorg", " errP", "errpc", "ierP", "errpress", "errorp", "derping", "ererp", "eorpoint", "aerping", "errpa", "lrg", "confp", "ererpun", " errpun", "errpoint", "errorcp", "errorpa", "aercp", "ierp", "ererr", "errorup", "aerpress", "errorpun", "errpost", "ierpost", "errorping", "erercp", "eorp", "derpress", "ierpkg", "confpa", "confup", " errpc", "errP", "errg", "lrpost", "errcp", "confcp", "ererup", "errorpc", "lrp", "errpkg", "errr", "errpun", " errr"]}}
{"project": "FFmpeg", "commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "target": 1, "func": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n", "idx": 16755, "substitutes": {"avctx": ["Avctx", "aptx", "avctl", "Avctl", "avectx", "avtx", "Avtx", "aftx", " avcontext", " avtc", "avetx", "avecontext", " avtx", "apcontext", "afcontext", "avcontext", " avctl", "aftc", "apctl", "avtc", "Avcontext", "apctx", "afctx", "avetc"], "gbc": ["ergdb", "gcc", " gcm", "pgpc", "gensc", "pgbo", "pgfc", "gupc", "pgbc", "gatesec", " gbitcoin", "gobt", " gcache", "igcm", "gosec", "lbc", "gbitcoin", "gamecurrency", "gcm", "gamebus", "gamecb", "gubc", "googlebitcoin", "gucc", "gencc", " ggc", "gdb", "ergbt", "gatemc", "gfc", "jsc", " gfc", "lcc", "gsec", "gsc", "googlecurrency", "jxc", "jfc", " gpc", " gvc", "godb", "jcc", "gamedc", "gatedc", " gcurrency", " gcc", "jpc", " gdc", "gamebc", " gsec", " gsc", "gatecache", "gdc", "gamecc", "gatedb", "gamebitcoin", "gamesec", "ggc", "igbus", "googlebc", "gbt", "gbus", "gpc", "gmc", "igbc", " gbus", "igvc", "gbo", " gxc", "gcache", "gcurrency", "gobc", "gocache", "gatebc", "guvc", "gvc", " gbo", "gatecb", "jbc", " gmc", "ergbc", "genbc", "gatebus", "jbo", "gcb", "gomc", "lvc", "gatebt", "googlecc", " gcb", "lpc", "gatevc", "gategc", "genxc", "gamecm", "iggc", "gxc"], "pal": ["pad", "label", "cell", "phal", "phil", "pill", "sal", "cam", " palette", "ali", "le", " style", "batch", "pixel", " val", " cal", "p", "al", "pread", " pill", "cal", "pl", " pad", "ell", "pol", " PAL", "list", " ph", "cel", "el", "ph", "lam", "color", "Pal", "theme", "val", " al", "cloth", "isal", "col", "pro", "bl", "olor", "pack", " pl", " Pal", " oval", "pat"], "colors": ["olours", "icolORS", "colours", "colorors", " colores", "colores", " colours", "olores", "colorlections", "Colors", "icolors", "colorORS", "olors", "ColORS", "collections", "colorores", "Colours", "icollections", "Collections", "Colores", "colORS", " colORS", "icolores", "olORS"], "i": [" n", "us", " I", "bi", " li", "ind", "init", " mi", "c", "xi", "ki", " index", "ex", "ai", " v", "li", "ui", "ic", "in", " ii", "ims", "pi", "iu", "qi", "im", "zi", "ci", "sim", "m", "me", "id", "uli", "index", " pi", " err", "I", " c", " iter", "ii", "ti", "phi", "ix", "x", " ti", " x", "span", " m", "di", "it", "mi", " j", " multi", "hi", "iq", "ini", "multi", "j", "si", "batch"], "r": ["kr", "rt", "lr", "hr", " rg", "cr", "attr", "rs", "er", "rf", "mr", "ir", "vr", "c", "nr", "ri", "rh", "err", "rx", "rc", "rl", "rar", " R", "fr", "ro", "rb", "tr", "rg", "res", "rr", "re", "ur", "sr", "rate", "ra", "d", "R", "ar", "ru", "x", "dr", "rm", "usr", "t", "rd"], "g": ["gd", "gi", "tg", "gio", "gp", "greg", "gre", "ge", "gravity", "mg", "rg", "p", "go", "ig", "gc", "gem", "group", "fg", "yg", "gr", "l", "gu", " G", "gz", "eg", "bg", "j", "erg", "gm", "gb", "pg", "G", "gn", "gg", "msg", "gs", "gy", "ger", "og", "ug", "gh", "ga"], "b": ["nb", "bb", "bit", "br", "bi", "blue", "B", "a", "c", "wb", "fb", "bar", "ab", "rb", "bp", "u", "ib", "l", "eb", "bg", "be", "o", "bis", "sb", "bc", "db", "gb", "beta", "ba", "x", "bl", "bin", "bas", "ob", "bf", "t", "bs", "bo", "j", "p"]}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n", "idx": 16767, "substitutes": {"a": ["act", "ach", "aws", "aaaa", "c", "sta", "ia", "anta", "ab", "ata", "ao", "aa", "ya", "r", "air", "acs", "eas", "v", "aaa", "A", "apa", "va", "app", "ar", "ba", "an", "am", "oa", "aux", "at", "la", "ace", "t", "ea", "ae", "admin", "ga"], "b": ["bb", "g", "bi", "blue", "another", "B", "c", "fb", "ab", "rb", "bp", "y", "abb", "pb", "ib", "d", "eb", "v", "n", "hub", "back", "be", "bis", "other", "sb", "bc", "db", "gb", "ba", "bin", "ob", "bf", "t", "bs", "facebook"]}}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,\n\n                                      uint32_t index, int reg)\n\n{\n\n    struct kvm_cpuid2 *cpuid;\n\n    int i, max;\n\n    uint32_t ret = 0;\n\n    uint32_t cpuid_1_edx;\n\n\n\n    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {\n\n        return -1U;\n\n    }\n\n\n\n    max = 1;\n\n    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {\n\n        max *= 2;\n\n    }\n\n\n\n    for (i = 0; i < cpuid->nent; ++i) {\n\n        if (cpuid->entries[i].function == function &&\n\n            cpuid->entries[i].index == index) {\n\n            switch (reg) {\n\n            case R_EAX:\n\n                ret = cpuid->entries[i].eax;\n\n                break;\n\n            case R_EBX:\n\n                ret = cpuid->entries[i].ebx;\n\n                break;\n\n            case R_ECX:\n\n                ret = cpuid->entries[i].ecx;\n\n                break;\n\n            case R_EDX:\n\n                ret = cpuid->entries[i].edx;\n\n                switch (function) {\n\n                case 1:\n\n                    /* KVM before 2.6.30 misreports the following features */\n\n                    ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA;\n\n                    break;\n\n                case 0x80000001:\n\n                    /* On Intel, kvm returns cpuid according to the Intel spec,\n\n                     * so add missing bits according to the AMD spec:\n\n                     */\n\n                    cpuid_1_edx = kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);\n\n                    ret |= cpuid_1_edx & 0x183f7ff;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(cpuid);\n\n\n\n    return ret;\n\n}\n", "idx": 16771, "substitutes": {"env": ["org", "window", "esm", "cv", "config", "shell", "end", "en", "er", "hw", "conn", "estate", "init", "h", "viron", "ef", "ov", "self", "eh", "serv", "enter", "server", "forge", "vs", "eye", "obj", "engine", "e", "ah", "buf", "here", "vm", "v", "ctx", "ev", "stack", "ei", "ew", "context", "environment", "gov", "pg", "et", "req", "cur", "nv", "ec", "vt", "inv", "erd", "eng", "dev", "esc", "vp"], "function": ["component", "f", "library", "job", "type", "length", "program", "resource", "action", "lambda", "connection", "method", "condition", "test", "interface", "role", "service", "func", "callback", "region", "version", "attribute", "event", "power", "unc", "form", "address", "section", "Function", "expression", "table", "reference", "r", "value", "unction", "functional", "script", "code", "family", "package", "trace", "full", "feature", "frame", "number", "format", "fun", "word", "operation", "command", "module", "domain", "fn", "FUN", "name", "normal"], "index": ["is", "type", "length", "all", "action", "run", "alias", "location", "connection", "ind", "ion", "Index", "condition", "interface", "point", "connect", "search", "info", "pointer", "valid", "position", "IND", "order", "region", "version", "error", "address", "expression", "sequence", "can", "reference", "value", "num", "id", "row", "rule", "code", "key", "context", "active", "x", "link", "number", "operation", "image", "find", "command", "hash", "name", "si"], "reg": ["org", "type", "country", "config", "regular", "g", "br", "REG", "ref", "ion", "map", "ex", "func", "or", "asm", "order", "region", "res", "pattern", "re", "r", "form", "address", "reference", "eg", "script", "rule", "state", "key", "registered", "Reg", "format", "fun", "tag", "addr", "cond", "name", "red"], "cpuid": ["cpvid", "cssido", "pkgvid", " tcpunt", "cpuuint", "cuu", "cmpuid", "compuid", " cpud", " cpsu", "cmpud", "catud", "cpud", "cpuazz", "cpusu", "pkguid", "pkgud", "skyuf", "ctxuid", "ctxud", "ctuid", " cpvid", "cpuuf", "cssuid", "cpazz", "cpusid", "cpupid", "cpuvoid", "pcu", "cpuf", "cpuuid", "cpuhn", "cid", "csshn", "ctxuu", "ctud", " cpid", "cpunt", " cpvoid", "cphn", " cpunt", " cppid", "cssudi", "cmpupid", " cpuu", "catu", "skyudi", "skyvoid", "pcpid", "ctxu", "skyuid", "compvoid", "cpuint", "cpsid", "cpido", "cssuu", "cpuupid", "cmpvid", " cpuf", "compu", "ctuu", "cssvoid", "cpu", "compsid", "catuu", "cpsu", "zipsu", "cmpuf", " cpazz", "cmpido", " cpsid", "cpuu", "cuid", " cpuint", " cpudi", "ipuu", " tcpuid", "ipupid", "cppid", "cmpuu", "cssupid", "cpuudi", "comppid", "cpudi", " cphn", "cpvoid", "zipuid", "pkguf", "ipido", "cssuint", " cpu", " tcpuu", "catuid", "ctu", "pcuid", "cunt", " tcpid", " cpupid", "zipazz", "zipuint", "ipuid", "cpid", "pcsid"], "i": ["f", "is", " I", "g", "bi", "iri", "gi", "ind", "ri", "xi", "cli", "ai", "info", "ini", "json", "oi", "li", "ui", "ic", "ip", "y", "ami", "\u0438", " ii", "go", "io", "pi", "iu", "qi", "im", "e", "zi", "ci", "ms", "sim", "m", "me", "id", "ji", "series", "uli", "list", "v", "I", "n", "o", "ii", "ti", "ei", "key", "fi", "phi", "ix", "x", "di", "uri", "it", "mi", " j", "ie", "hi", "ij", "t", "multi", "j", "si", "batch"], "max": ["prime", "new", "window", "act", "length", "end", "ax", "cache", "final", " MAX", "mx", "chain", "map", "min", "ex", "rem", "size", "MAX", "q", "scale", "len", "res", "net", "top", "head", "r", "check", "ms", "grow", "Max", "m", "num", "conf", "id", "row", "v", "k", "n", "total", "maximum", "full", "count", "x", "next", "last", "pool", " Max", "base", "limit", "huge", "mod", "t", "range", "rest", "j", "p"], "cpuid_1_edx": ["cpuid_1_edix", "cpuid_1_edw", "cpuid_1_dedex", "cpuid_1_ledw", "cpuid_1_dy", "cpuid_1_dedw", "cpuid_1_dedpx", "cpuid_1_dedX", "cpuid_1_exex", "cpuid_1_dedix", "cpuid_1_eex", "cpuid_1_dex", "cpuid_1_ledx", "cpuid_1__edw", "cpuid_1_dx", "cpuid_1_exw", "cpuid_1__ledix", "cpuid_1_ledex", "cpuid_1__edex", "cpuid_1_exix", "cpuid_1_edex", "cpuid_1_exx", "cpuid_1_eeex", "cpuid_1_dX", "cpuid_1_exy", "cpuid_1_dedx", "cpuid_1_edy", "cpuid_1_edX", "cpuid_1_eeX", "cpuid_1_expx", "cpuid_1_eepx", "cpuid_1__edx", "cpuid_1_exX", "cpuid_1__edix", "cpuid_1_ledix", "cpuid_1__ledx", "cpuid_1_edpx", "cpuid_1__ledw", "cpuid_1__ledex"]}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n\n                          uint8_t **bufptr, DumpState *s)\n\n{\n\n    GuestPhysBlock *block = *blockptr;\n\n    hwaddr addr;\n\n    uint8_t *buf;\n\n\n\n    /* block == NULL means the start of the iteration */\n\n    if (!block) {\n\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n\n        *blockptr = block;\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        if (bufptr) {\n\n            *bufptr = block->host_addr;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    *pfnptr = *pfnptr + 1;\n\n    addr = pfn_to_paddr(*pfnptr);\n\n\n\n    if ((addr >= block->target_start) &&\n\n        (addr + s->page_size <= block->target_end)) {\n\n        buf = block->host_addr + (addr - block->target_start);\n\n    } else {\n\n        /* the next page is in the next block */\n\n        block = QTAILQ_NEXT(block, next);\n\n        *blockptr = block;\n\n        if (!block) {\n\n            return false;\n\n        }\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        buf = block->host_addr;\n\n    }\n\n\n\n    if (bufptr) {\n\n        *bufptr = buf;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16780, "substitutes": {"blockptr": ["buspointer", "lockaddr", "blocktr", " blockpointer", "busptr", "lockpert", "buspert", "blockpointer", "blockpert", "locktr", " blockctr", "lockptr", "blockaddr", " blockpert", " blocktr", "chainptr", "boxaddr", "lockctr", "bustr", "lockpointer", "chaintr", "boxptr", "boxtr", "boxctr", "boxpointer", "blockctr", "chainpointer", "chainaddr"], "pfnptr": ["pfndesc", "pdndesc", "pfinptr", " pdnptr", "pdnrel", "pnnpointer", "ptnct", "pcnpert", "pfnoffset", "phpfnptr", "pfnpointer", "pfillpert", "pfunctionaddr", "pfinaddr", "pcnstr", " pdnrel", " pfnct", "pfnstr", "pfunpointer", " pdndesc", "pfnct", "pdnaddr", "pcdnrel", "pdnpointer", " pfnaddr", "pnnrel", "plnrel", " pfndesc", "phpfnpert", "prelstr", "pfnpert", "plnptr", "pcdnptr", " pfnPtr", " pnnaddr", "pfnrect", "prelptr", " pdnobj", "Pfnrel", "pfillptr", "pnnaddr", "pconnptr", "plnpointer", "pfnrel", " pfnpointer", "phprelstr", "pfunpert", "pbnpointer", "pfunptr", "ptnaddr", "phprelptr", "phpfndesc", "plnobj", "pfnobj", "pdnrect", "pnnPtr", " pfnrect", "pconnrel", "pcdnoffset", "Pfnoffset", "ptndesc", "pfillstr", "Pnnrel", "pnnrect", "pfilldesc", "pdnct", "pfinrect", " pnnrect", "Pnnptr", " pfnpert", "pconnoffset", "pcndesc", "phprelpert", "pfunPtr", "preldesc", " pdnct", "pcnptr", " pdnaddr", "prelpert", "pbnptr", "pnnpert", "pfinpointer", "pnnoffset", "pconnPtr", "PnnPtr", "pbnobj", "pnnptr", " pdnpointer", "Pfnptr", "pfunctionptr", "pfnPtr", "ptnptr", "pcdnPtr", " pfnrel", "PfnPtr", " pfnobj", "Pnnoffset", "pfunctionct", "pdnobj", "pbnrel", "pdnptr", " pnnpointer", " pnnptr", "pfnaddr", "phpreldesc", "pfunctiondesc", "phpfnstr"], "bufptr": ["fbpointers", "bufferPtr", "fbptr", "bufrect", "ufcert", "captr", "buffproc", "imgtr", "buffertr", "buftr", " bufctr", "fbrect", "cappointer", "uftr", "buffrob", "buffpointers", "bufftr", "bufPtr", "capcert", "queueptr", " bufpointer", "bufferobj", "queuetr", "buffobj", "bufobj", "ufobj", "rafptr", "capptr", "bufcert", "bufferptr", " buftr", " bufrob", "bufproc", "bufctr", "buffrect", "bufrob", "ufPtr", "rafctr", "bufpointer", "rafrob", "buffctr", "queueproc", "imgpointer", " bufpointers", "buffpointer", "imgptr", "bufpointers", "buffPtr", "raftr", "imgcert", "fbpointer", " bufrect", "ufpointer", "buffptr", "ufproc", "ufptr"], "s": ["is", "states", "fs", "h", "c", "sm", "js", "ies", "vs", "ims", "e", "series", "stats", "ses", "less", "ries", "sw", "xs", "ss", "ns", "obj", "session", "ms", "parts", "space", "services", "state", "times", "S", "dev", "blocks", "conf", "p", "sts", "rs", "ops", "sq", "size", "self", "os", "set", "m", "sp", "socket", "sb", "sol", "ssl", "gs", "comm", "tags", "si", "ls", "sv", "settings", "info", "ats", "ts", "d", "sys", "its", "sets", "b", "n", "ix", "ds", "ps", "t", "details", "j", "es"], "block": ["blocking", "box", "init", "def", "man", "ip", "event", "Block", "address", "check", "friend", "un", "single", "link", "word", "node", "command", "snap", "hash", "field", "new", "bridge", "bit", "object", "bus", "tx", "json", "null", "side", "device", "wall", "obj", "re", "group", "zero", "row", "OCK", "space", "empty", "full", "an", "loop", "bl", "inv", "tag", "scope", "blocks", "name", "p", "unit", "window", "disk", "BL", "chain", "map", "condition", "channel", "point", "self", "panel", "manager", "buffer", "unknown", "error", "byte", "load", "set", "commit", "none", "model", "sp", "cl", "record", "history", "bc", "instance", "prefix", "x", "escape", "no", "pool", "raw", "image", "blank", "bo", "type", "ref", "filter", "method", "part", "mm", "lock", "info", "mask", "line", "ver", "rel", "sync", "list", "network", "local", "join", "bin", "pack"], "addr": [" res", " fmt", "eth", "ip", "np", " pad", "address", " arr", " ip", " err", "sha", " rel", "oa", "tz", "hash", "add", "arp", "url", "pad", "act", "alias", "br", "offset", "tx", "iter", " align", " act", "len", "pos", "obj", "src", "Address", "alpha", "cmd", " rev", "ress", "mt", " href", " aid", "name", "p", "end", "rs", "pkg", "lat", "err", " add", " url", "elt", "loc", "ack", "dr", "adr", "at", "ptr", "rt", "coord", "attr", "ref", "rc", "nl", "tr", "res", "align", "r", "arr", "id", "gz", "ord", "n", " amp", "ix", " conn", "alt", "start", "ace"], "buf": ["window", "ff", "cv", "tmp", "box", "br", "offset", "end", "nm", "pkg", "page", "vec", "bar", "tab", "Buff", "ret", "port", "func", "buffer", "cap", "Buffer", "rb", "bp", "bytes", "img", "cb", "pb", "loc", "fg", "cast", "dest", "b", "ctx", "var", "uf", "alloc", "cmd", "next", "mem", "seq", "ann", "bl", "bin", "buff", "pool", "raw", "bf", "queue", "pack", "ptr", "limit", "nom", "batch"]}}
{"project": "qemu", "commit_id": "280d373579558f73a8b70e329d9a6206933d3809", "target": 0, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta->nb_clusters > 0 &&\n\n            (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS)) {\n\n            qcow2_mark_dirty(bs);\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta != NULL) {\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            run_dependent_requests(s, l2meta);\n\n            g_free(l2meta);\n\n            l2meta = NULL;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    if (l2meta != NULL) {\n\n        run_dependent_requests(s, l2meta);\n\n        g_free(l2meta);\n\n    }\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 16783, "substitutes": {"bs": ["ls", "bh", "bits", "rs", "ubs", "bi", "outs", "BS", "js", "lbs", "os", "ss", "bp", "obs", "vs", "ns", "pb", "ubis", "ts", "sys", "its", "b", "bis", "sb", "bc", "lb", "cks", "bt", "ds", "bos", "qs", "bps", "aus", "gs", "bm", "cs", "aos", "fs", "hs", "bes"], "sector_num": ["sector10num", "sector_number", "ector_num", "section_number", " sector_mon", "sector2NUM", "section_num", " sector_nr", "ector_Num", "sector2mon", "sector2number", " sector_number", "sector_NUM", "section_mult", "sector2orig", "sector_mult", "section_mon", "section_NUM", "sector_orig", "section_orig", "sector_Num", "sector2num", "sector10NUM", "ector_coord", "sector_mon", "sector_coord", "sector_nr", "sector10mon", "sector2nr", "ector_n", "sector10orig", "sector_n"], "remaining_sectors": ["remaining_peors", "remaining_erctions", "remaining_eronents", "remaining_psegments", "remaining_vebers", "remaining_pebers", "remaining_erllers", "remaining_pectors", "remaining_segments", "remaining_veonents", "remaining_meonents", "remaining_veters", "remaining_vegments", "remaining_meors", "remaining_vections", "remaining_pecs", "remaining_spectors", "remaining_erctors", "remaining_mectors", "remaining_sexctors", "remaining_seors", "remaining_psellers", "remaining_sebers", "remaining_secs", "remaining_peters", "remaining_pseors", "remaining_sections", "remaining_vectors", "remaining_seters", "remaining_vecs", "remaining_seonents", "remaining_speors", "remaining_spegments", "remaining_psectors", "remaining_sexbers", "remaining_veors", "remaining_pegments", "remaining_specs", "remaining_vellers", "remaining_sellers", "remaining_psections", "remaining_pseonents", "remaining_sexters", "remaining_megments", "remaining_sexors"], "qiov": ["quiour", "oxdyl", "qrov", "iqiour", "oxiov", " qiour", "oxiour", "quiov", "qudyl", " qiev", "oxiev", "qdyl", "qiev", " qrov", "iqrov", " qdyl", "qurov", "iqiov", "quiev", "iqiev", "qiour"], "s": ["ls", "is", "bes", "sts", "sv", "rs", "bits", "aws", "changes", "a", "h", "sq", "c", "settings", "ares", "js", "i", "os", "ss", "vs", "details", "ns", "ims", "spec", "set", "ms", "ats", "ids", "actions", "ts", "sys", "its", "sp", "es", "b", "v", "sets", "bis", "sb", "services", "stats", "ds", "qs", "less", "w", "S", "abilities", "gs", "ssl", "sam", "comments", "cs", "ps", "t", "comm", "fs", "hs", "j", "p"], "index_in_cluster": ["index_in_clructure", "index_in_Cluster", "index_in_pluster", "index_in_gloser", "index_in_scructure", "index_in_clust", "index_in_chuster", "index_in_Closer", "index_in_Clust", "index_in_lructure", "index_in_chusters", "index_in_luster", "index_in_scust", "index_in_lust", "index_in_closer", "index_in_glusters", "index_in_lusters", "index_in_scusters", "index_in_choser", "index_in_glust", "index_in_gluster", "index_in_plusters", "index_in_ploser", "index_in_scuster", "index_in_Clusters", "index_in_plructure", "index_in_clusters", "index_in_plust"], "n_end": ["index_begin", "indexvaltail", "index_size", "index_edge", "N_END", "n00size", "N_End", "n_size", "n_ended", "n_END", "n2End", "indexvalbegin", "n2end", "index_end", "index00edge", "n_start", "n00end", " n_ended", "indexvalend", "n_begin", "nvaltail", "index00end", "n_tail", "n_num", "N_num", "n_edge", "nvalending", "indexvalending", "nvalend", "n2num", "n00ending", "n00edge", "n_End", "N_end", "index_ends", "index_ending", "nvalbegin", "n_ending", "index00ending", " n_start", "n_ends", "index_post", "index00size", "n2END", "index_tail", "n_post"], "ret": ["rt", "pat", "tt", "gt", "ref", "result", "test", " RET", "iter", "lt", "err", "rem", "big", "cont", "len", "tr", "res", "elt", "Return", "ll", "re", "flag", "arg", "RET", "Ret", "rev", "ter", "tf", "back", "out", "ft", "cert", "nz", " Ret", "val", "rets", "print", "cmd", "alt", "mel", "mem", "deg", "encrypted", "fun", "nt", "mt", "t", "tech", "job"], "cur_nr_sectors": ["cur_nr_veors", "cur_nr_psectors", "cur_nr_spelements", "cur_nr_vegments", "cur_nr_spegments", "cur_nr_segments", "cur_nr_pectors", "cur_nr_seors", "cur_nr_serctors", "cur_nr_peors", "cur_nr_sergments", "cur_nr_velements", "cur_nr_vevers", "cur_nr_pselements", "cur_nr_servers", "cur_nr_selements", "cur_nr_spectors", "cur_nr_vectors", "cur_nr_psegments", "cur_nr_serors", "cur_nr_pegments", "cur_nr_pseors", "cur_nr_severs", "cur_nr_pevers", "cur_nr_speors"], "cluster_offset": ["clusters_offset", "cluster_meta", "clusters_addr", "cluster__data", "clusters_size", "cluster_addr", "clandra____data", "clandra_offset", "cluster____id", "cluster_id", "cluster___addr", "clandra____offset", "clusters_data", "cluster____data", "clandra_id", "clandra_addr", "cluster___offset", "clandra_data", "clusters_meta", "clandra____id", "cluster__offset", "cluster__meta", "cluster____offset", "cluster_size", "clandra____addr", "cluster___id", "cluster___data", "cluster____addr", "cluster__addr"], "hd_qiov": ["hd_giev", "dh_2", "hd_Qiev", "hd_qveh", "hd_sqiov", "hd_2", "hd_Qovi", "hd_sqveh", "hd_qurov", "hd_Qrov", "hd_quroid", "hd_qroid", "dh__", "hd_qovi", "hd_quiev", "hd_Qroid", "hd_qrov", "hd_groid", "hd_qiev", "hd_sqiour", "hd_viov", "hd_giov", "hd_Qiour", "hd__", "hd_Qiov", "hd_vveh", "hd_viour", "hd_Qveh", "hd_qiour", "hd_sqovi", "hd_grov", "hd_vovi", "hd_quiov"], "cluster_data": ["clusters_offset", "cluster2offset", "clusters_data", "cluster2buffer", "cluster_cache", "cluster___offset", "clusters_buffer", "cluster___cache", "cluster___buffer", "cluster2cache", "cluster2data", "cluster___data", "clusters_cache", "cluster_buffer"], "l2meta": [" l_data", "l1eta", "l5eta", "lopherpolicy", " l2metadata", "nl2Meta", "nl2metadata", "l2metadata", "l2data", "l3policy", "nl2eta", "l4metadata", "ltopolicy", "l3metadata", " l2data", " l_meta", "l4met", " l3meta", " l3Meta", "l4data", "l3Meta", "L2settings", "lophersettings", "lophermeta", "l_data", "nl1eta", " l_metadata", " l_Meta", "l5met", " l3eta", "l4Meta", "l2policy", "L3policy", "l3meta", "L3metadata", "nl1meta", "ltosettings", "l5meta", "l3data", "nl1Meta", "nl1metadata", " l3met", "l_meta", " l2met", "L2meta", "L2policy", "nl2meta", "l5Meta", "l3met", "l2settings", "l4eta", " l2Meta", "ltometa", "l4meta", "L3settings", "L3meta", "ltometadata", "l2Meta", "l_Meta", "L2metadata", "l_metadata", "l1meta", "l1metadata", " l2eta", "l2eta", "l3settings", "l3eta", "l2met", "lophermetadata", "l1Meta"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16787, "substitutes": {"dev": ["pad", "Dev", "th", "attr", "end", "conn", "hw", "cam", "test", "h", "wd", "info", "des", "self", "ad", "def", "server", "device", "iv", "go", "dist", "loc", "debug", "ver", "att", "obj", "home", "det", "scan", "d", "sys", "env", "v", "var", "ctx", "ev", "priv", "dd", "ve", "dep", "app", "val", "md", "dis", "db", "cmd", "DEV", "Device", "de", "mem", "ow", "adv", "w", "nt", "av", "raw", "addr", "pro", "conf", "add"], "value": ["unit", "type", "length", "block", "VALUE", "test", "size", "values", "port", "buffer", "range", "scale", " val", "attribute", "version", "device", "ue", "byte", "ness", "address", "message", "num", "Value", "index", "v", "code", "total", "key", "val", "instance", "weight", "data", "number", "current", "field", "name"], "dest": ["Dest", "tmp", "opt", "coord", "end", "ref", "st", "result", "trans", "iter", "std", "temp", "lit", "cont", "pas", "tr", "doc", "img", "dist", "master", "loc", "orig", "target", "src", "table", "resp", "path", "txt", "priv", "out", "cas", "mem", "w", "bin", "source", "usr", "ptr", "rest", "decl"], "len": ["vec", "h", "syn", "val", "mem", "limit", "cmp", "fl", "lan", "offset", "lt", "iter", "lit", "ret", "dt", "pos", "el", "index", "hl", "total", "empty", "lim", "lon", "full", "compl", "ln", "msg", "fun", "nt", "ld", "length", "all", "end", "en", "Len", "conn", "err", "size", "dim", "conv", "fin", "elt", "loc", "ll", "resp", "l", "sp", "ptr", "ls", "type", "ref", "Length", "trans", "lf", "nl", "bytes", "lp", "n", " length", "str", "alt", "lib", "format", "bin", "addr", "L", "t"], "desc": ["reg", "config", "ext", "conn", "cam", "sec", "cor", "test", "disc", "td", "info", "rc", "des", "def", "dim", "sc", "diff", "ript", "doc", "der", "sub", "dist", "loc", "pb", "feat", "resp", "det", "rec", "ctx", "cd", "priv", "dep", "comment", "description", "cmd", "asc", "req", "ds", "seq", "dr", "pro", "Desc", "pri", "ptr", "fn", "cmp", "esc", "conf", "dc", "decl"], "buf": ["tmp", "window", "prop", "cv", "box", " buffer", "br", "gt", "ref", "cache", "pkg", "vec", "tx", "iter", "cat", "wb", "temp", "err", "good", "Buff", "ret", "port", "buffer", "cap", "Buffer", "rb", "tr", "bytes", "doc", "img", "obj", "cb", "pb", "loc", "pool", "src", "max", "arr", "rw", "off", "b", "ctx", "var", "txt", "uf", "priv", "out", "str", "cmd", "db", "data", "cur", "mem", "seq", "msg", "bl", "raw", "buff", "bin", "nt", "addr", "ptr", "queue", "batch"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n", "idx": 16792, "substitutes": {"machine": ["computer", "host", "chain", "channel", "mm", "mc", "device", "net", "power", "session", "handler", "ram", "me", "monitor", "model", "m", "vm", "achine", "state", "instance", "link", "task", "frame", "node", "image", "process", "Machine"], "cpu": ["CPU", "proc", "bench", "disk", "boot", "conn", "processor", "computer", "mx", "hw", "bus", "clock", "c", "xi", "nic", "linux", "memory", "chip", "cp", "util", "gc", "np", "mu", "cu", "pc", "pai", "vm", "ctx", "core", "achine", "phys", "gpu", "mem", "pool", "node", "process", " CPU", "pu", "p"], "dinfo": ["dInfo", "DInfo", "Dinf", "Dfo", " dfo", "dfi", "linfo", "adfo", "adinfo", " ddetails", "lINFO", " dINFO", "Dfi", "adInfo", "ldready", "dready", " dInfo", "dinformation", "Dinfo", "dbfi", "finfo", " dready", "lddetails", "dbinfo", "lInfo", "dbInfo", "finf", "dINFO", " dfi", "ddetails", "dinf", "Dinformation", " dinf", "dbinf", "ldInfo", "ldinfo", " dinformation", "adinformation", "dfo", "linformation", "Dready", "fInfo", "Ddetails"], "be": ["obe", "ble", " Bo", "ere", "cho", "br", "ne", "end", "fe", "st", "bd", "oe", " ne", "use", "ge", "ed", "le", "or", "beat", "te", " bo", "ot", "scale", "he", "ze", "ue", "Be", "by", " probe", "e", " BE", "ke", "BE", " Be", "eb", " b", "b", " pe", "enable", "se", "ve", "ide", "are", "ape", " we", "abe", "loop", "itte", " he", "z", "it", "ob", "we", " ba", "\u662f", "ch", "ae", "bo", "bes"], "address_space_mem": ["address_space_mt", "address_space_ram", "address_space_reg", "address_store_mt", "address_store_ram", "address_space2mem", "address_space2ram", "address_space_ref", "address_store_reg", "address_store_mem", "address_space2ref"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n", "idx": 16794, "substitutes": {"ctx": ["cf", "cv", "Context", "pkg", "hw", "chain", "ctr", "jp", "tx", "wd", "ca", "cm", "anc", "cp", "sc", "care", "iat", "jac", "gc", "loc", "unc", "wx", "tc", "cu", "nc", "cc", "kw", "txt", "ct", "wcs", "xc", "bc", "context", "alloc", "cmd", "cas", "cmp", "co"], "notifier": ["Notifiers", " notifer", "notifer", "Noticator", "identifiers", "notification", "signressor", "signifier", "signifer", "indifer", "identifer", " notressor", "NOTifiable", "Notifer", "Notification", "NOTifer", "noticator", "indifier", "identifier", "indification", "Notifier", "indifiable", "Notressor", " notification", "signification", " noticator", "notressor", "NOTifier", "notifiers", " notifiable", "notifiable", " notifiers", "identicator", "NOTification"], "is_external": ["is_internal", "is42external", "is42unique", " is_extra", "is42outside", "is_binary", " is_unique", "is_unique", "is_extra", " is_internal", " is_outside", " is_binary", "is_outside", "is42internal"], "io_read": ["io__run", "io_write", "io___write", "io2readable", "i_reader", "io_send", "io__read", "i_send", "io__readable", "io_reader", "io___read", "io_readable", "io___run", "io_run", " io_run", " io__readable", "io2read", " io__write", " io__run", "i_read", " io_readable", "io__write", "io2reader", " io_write", "i_readable", "io___readable", "io2send", " io__read"], "io_poll": ["iotPreflect", "iowpull", "io_write", "ioPreflect", "iowpoll", "io____write", "ioPpull", "io_connect", "iot_poll", "api_connect", "ioPwrite", "api____poll", "ioPpoll", "iot_pull", "iot_reflect", "api_pull", "io_reflect", "iot_write", "io_pull", "iotPpoll", "iowconnect", "iotPwrite", "io____poll", "api_write", "api____pull", "api____connect", "iowwrite", "api____write", "iotPpull", "api_poll", "io____pull", "io____connect"]}}
{"project": "FFmpeg", "commit_id": "f6687bf5f8989d397cdef6d9d05bcb13a7ef8c4f", "target": 0, "func": "void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,\n\n                   uint8_t *iv, int decrypt)\n\n{\n\n    int i;\n\n\n\n    while (count > 0) {\n\n        if (decrypt) {\n\n            xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = dst[i] ^ iv[i];\n\n                memcpy(iv, src, 8);\n\n            }\n\n        } else {\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = src[i] ^ iv[i];\n\n                xtea_crypt_ecb(ctx, dst, dst, decrypt);\n\n                memcpy(iv, dst, 8);\n\n            } else {\n\n                xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n            }\n\n        }\n\n\n\n        src   += 8;\n\n        dst   += 8;\n\n        count -= 8;\n\n    }\n\n}\n", "idx": 16795, "substitutes": {"ctx": ["tmp", "rt", "act", "cv", "cf", "conn", "hw", "ctr", "cn", "jp", "tx", "ca", "cm", "rc", "ck", "urg", "cp", "sc", "etc", "iat", "jac", "obj", "qt", "cb", "kt", "gc", "wx", "tc", "cu", "resp", "cpp", "con", "sys", "cc", "kw", "ct", "ctl", "xc", "context", "cmd", "cas", "x", "fw", "pool", "nt", "bm", "cmp", "co", "conf", "batch"], "dst": ["dlna", " drc", " dict", "dust", "delst", "indsrc", "dstr", "dlstr", "dput", "dsest", " dct", "ddrest", "dsbr", "dlpt", "dtct", "dssts", "dsrest", " dpt", "delrest", " dna", "pdst", "dict", "rest", "dsrc", " Dst", "dpl", "dupt", "pdest", "dna", "dsp", " dsrc", "ddst", "dost", "idst", "dsstr", " dput", "pdpt", " dfr", " dpl", "dfr", "idpt", " dsp", " Dost", " dstr", "dtst", "dssrc", "dslt", "pdict", "sest", "rst", "dtlt", " ddest", "dufr", "indsts", "delsts", "rbr", "dbr", " dest", "ddna", " Dsrc", "dsts", "idfr", " dsts", "lest", "dlt", "ddput", "ddpt", "dspt", "dsst", "dsct", "lct", "dsost", "inddest", " drest", "sst", "dusp", "dsdest", " dost", " dbr", "rpt", "dlput", "dlrest", "drest", "dlpl", "indst", "dlst", "lst", "dest", "ddict", "dtest", " dlt", "lrc", "ddest", "dpt", "drc", "dct", "delsrc", "sct", "dspl", "idsp", " Dct"], "src": ["proc", "rt", "sl", "length", "ser", "rs", "st", "ins", "sn", "ctr", "ind", "sec", "init", "vr", "sq", "std", "ipl", "fc", "rc", "stream", "rl", "sels", "inner", "func", "sur", "urg", "cont", "sc", "syn", "sub", "img", "loc", "inst", "sr", "enc", "ul", "rect", "sync", "sys", "dest", "txt", "hl", "sb", "s", "str", "cmd", "desc", "vc", "cur", "ipp", "ssl", "supp", "source", "addr", "usr", "ptr", "ch", "fn", "via", "sel", "bs", "tp"], "count": [" n", "length", "sum", "th", "all", " call", " len", "offset", "counter", "ctr", "ind", "result", "c", "ount", "depth", "CC", "size", " cont", "buffer", "cont", "len", "amount", "repeat", "flag", "Count", "check", "cast", "cycle", "list", "call", "num", "index", "con", "cc", "n", "ct", " c", " start", "code", "force", "total", " length", "cmd", " num", "coll", "next", "current", "nt", "find", " code", "start", "try", "ch", " size", "conf", "z", "name"], "iv": ["ih", "rib", "cv", "act", "block", "attr", "ext", "iver", "sv", "vv", "ctr", "ind", "init", "vr", "test", "iter", "err", "icon", "rc", "ov", "seed", "Iv", "or", "ot", "ic", "crypt", "ip", "iat", "der", "driver", "enc", "tip", "buf", "iov", "rect", "env", "off", "v", "ith", "zip", "ev", "var", "bc", "oc", "rot", "ive", "vc", "col", "nv", "ec", "uv", "auth", "tv", "uint", "mix", "ipp", "ie", "it", "hash", "ij", "ptr", "typ", "ipher", "iq", "ch", "IV", "rn", "vp"], "decrypt": ["decryption", " decrol", "desrypt", "encrol", "Deccrypt", "decode", "ecry", "encure", "encrypt", " decure", "decipher", "ecipher", "desrypted", "desipher", "DECrypted", " decryption", " decipher", " deccrypt", "ecryption", "decure", "declryption", "decry", "ecode", "enccrypt", " decry", "descrypt", " decrypted", "Decry", "Decrypt", "descrol", "declode", "decrypted", "decrol", "Decode", "deccrypt", "DECryption", "eccrypt", " decode", "descode", "desryption", "encrypted", "declrypt", "DECcrypt", "descrypted", "descryption", "DECrypt", "ecrypted", "desccrypt", "encode", "declure", "ecrypt", "encryption"], "i": ["us", "is", "er", "init", "y", "ip", "ami", " ii", "qi", "menu", "v", "I", "PI", "ii", "print", "phi", "status", " j", "hi", "t", "json", "ui", "\u0438", "pi", "php", "im", "ms", "client", "mi", "ie", "iso", "name", "multi", "gi", "ind", "chain", "ri", "xi", "point", "ki", "ex", "cli", "ai", "parent", "q", "li", "io", "iu", "ni", "ci", "my", "l", "sim", "m", "me", "ti", "x", " m", "uri", "try", "at", "ij", "eric", "ski", "si", "batch", "bi", "copy", "info", " v", "ic", "in", "remote", "r", "zi", "this", "list", "id", "ji", "ei", "fi", "ix", "di", "it", "ini", "j", "oi"]}}
{"project": "FFmpeg", "commit_id": "6241e8a3821d971755217652dff01f3a45580820", "target": 0, "func": "static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    AVRational time_base = {1, 1000};\n\n    uint32_t start, end;\n\n    AVChapter *chapter;\n\n    uint8_t *dst = NULL;\n\n    int taglen;\n\n    char tag[5];\n\n\n\n    decode_str(s, pb, 0, &dst, &len);\n\n    if (len < 16)\n\n        return;\n\n\n\n    start = avio_rb32(pb);\n\n    end   = avio_rb32(pb);\n\n    avio_skip(pb, 8);\n\n\n\n    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);\n\n    if (!chapter) {\n\n        av_free(dst);\n\n        return;\n\n    }\n\n\n\n    len -= 16;\n\n    while (len > 10) {\n\n        avio_read(pb, tag, 4);\n\n        tag[4] = 0;\n\n        taglen = avio_rb32(pb);\n\n        avio_skip(pb, 2);\n\n        len -= 10;\n\n        if (taglen < 0 || taglen > len) {\n\n            av_free(dst);\n\n            return;\n\n        }\n\n        if (tag[0] == 'T')\n\n            read_ttag(s, pb, taglen, &chapter->metadata, tag);\n\n        else\n\n            avio_skip(pb, taglen);\n\n        len -= taglen;\n\n    }\n\n\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);\n\n    av_free(dst);\n\n}\n", "idx": 16808, "substitutes": {"s": ["f", "ls", "is", "sts", "sv", "rs", "as", "ins", "aws", "a", "c", "sq", "h", "aps", "js", "self", "os", "ss", "sc", "ns", "spec", "r", "e", "ats", "ts", "sys", "its", "local", "es", "b", "v", "ctx", "n", "sb", "stats", "ds", "qs", "ses", "w", "S", "gs", "cs", "ps", "t", "bs", "fs", "hs", "p"], "pb": ["proc", "nb", "tmp", "px", "bb", "cv", "amp", "bh", "PB", "pkg", "bj", "fp", "jp", "wb", "td", "fb", "mp", "batch", "asm", "cp", "rb", "bp", "np", "pp", "phy", "cb", "patch", "pl", "gc", "stab", "lp", "pm", "buf", "resp", "pc", "wp", "pt", "erb", "ap", "sp", "eb", "b", "ctx", "txt", "pa", "uf", "vp", "sb", "gb", "pg", "lb", "tk", "bps", "pro", "pool", "typ", "ob", "bf", "snap", "bs", "dp", "tp", "p"], "len": ["vec", "val", "mem", "lic", "cmp", "fl", "mil", "lan", "offset", "lt", "iter", "lit", "pos", "el", "total", "lim", "lon", " l", "compl", "ln", "msg", "nt", "ld", "length", "all", "en", "Len", "size", "conv", "fin", "elt", "loc", "ll", "pl", "enc", "l", "sp", " clen", "next", "lang", "seq", "repl", "ls", "lc", "label", "kl", "dl", "lf", "fc", "nl", "ml", "bytes", "ell", "lp", "rev", "num", "local", "n", " length", "alt", "lib", "format", "L", "t", "z"], "ttag": ["mtag", "ktag", "ttags", "ttagger", "mtags", "ktagger", "ktagg", "otag", "otagg", "mtagg", "mtagger", "ktags", "otags", "otagger", "ttagg"], "extra_meta": [" extra2data", "extra_data", "extra_metadata", " extra2meta", "extra___desc", " extra2desc", " extra_metadata", "extra2desc", " extra2metadata", "extra2metadata", "extra2data", " extra_data", "extra___data", "extra2meta", " extra_desc", "extra_desc", "extra___meta", "extra___metadata"], "start": ["from", "get", "offset", "open", "rank", "st", "step", "init", "trans", "part", "shift", " beg", "use", "origin", "size", "ad", "position", "starting", "pos", "top", "load", "loc", "set", "check", "index", "Start", "sp", "time", "before", "space", "first", "wind", "next", "begin", "art", "it", "stop", "op", "base", "range", "rest", "name"], "end": ["ending", "close", "length", "offset", "ext", "st", "en", "wrap", "add", "ended", "End", "until", "fail", "nd", "then", "size", "except", "ad", "ender", "fin", "ue", "util", "line", "event", "roll", "ell", "enc", "max", "est", "id", "END", "out", "send", "eff", "ek", "ape", "begin", "last", "ent", "stop", "bound", "it", "east", "exec", "eng", "range", "rest"], "chapter": ["component", "prop", "page", "c", "plot", "man", "patch", "table", "friend", "shop", "artist", "series", "course", "character", "verb", "cmp", "proc", "entry", "Chapter", "virtual", "title", "root", "chart", "cont", "wiki", "soc", "student", "handler", "progress", "client", "voice", "lot", "change", "context", "toc", "cloth", "msg", "joined", "ch", "metadata", "p", "tmp", "cell", "header", "year", "cop", "chain", "peer", "result", "channel", "parent", "self", "comp", "version", "record", "book", "history", "morph", "instance", "cue", "lc", "cho", "config", "connection", "trans", "part", "plugin", "server", "item", "month", "section", "chron", "podcast", "format"], "dst": ["rend", "drasp", "pnd", "sdsp", "nct", "Ddest", " dct", "desct", "ntd", " dpt", "wst", " dtd", "wST", "desST", "msts", "mst", "nst", "mbr", "destd", "pdest", "wost", "dsp", "pst", "fdsts", "sdpt", "dost", "drast", "wend", "dradest", "Dsts", "pct", "Dst", "dST", "Dsp", "dsnd", "dend", "psp", "dtd", "sddest", "fdst", " dsp", "fdbr", "desst", " dend", "sdst", "rost", "tsp", "rst", " ddest", "nST", "sdost", "dbr", "dsts", " dsts", "psts", "dnd", "tsts", "dspt", "dsst", "dsct", "ppt", "rST", "tdest", "sdnd", " dST", " dost", " dbr", "tst", "mpt", "fdpt", "ddest", "dpt", "dct", "sdct", "draost"], "taglen": ["taglib", "aglength", "monthlen", " taglon", " taggen", "buglen", "TAGlen", "wordlen", "bugln", "tasklon", "buglength", "charlength", "loglen", "wordl", "monthgen", " taglength", "agname", "logln", "tasklin", "TAGlength", " tagname", "aglen", "loglib", " tagln", "taglength", "bitln", "wordlength", " taglin", "TAGln", "bitlen", "charlen", "tagLen", "buglin", "charLen", " taglib", "TAGLen", "tasklen", "monthLen", " tagl", "agLen", "ticklength", "buglib", "loglon", "wordln", "bugl", "wordlon", "buglon", "tagname", "taggen", "charname", "tasklength", "bitLen", "monthln", "tagl", "tickln", " tagLen", "ticklen", "bitgen", "taglin", "tagln", "taglon", "tickLen", "TAGlon"], "tag": ["pad", "tmp", "prop", "type", "bit", "Tag", "attr", "sum", "reg", "pkg", "map", "part", "test", "cat", "tar", "ag", "mp", "tail", "ad", "TAG", "name", "ot", "comp", "error", "byte", "bad", "go", "bag", "bug", "att", "match", "arg", "feat", "flag", "set", "date", "id", "ack", "local", "row", "var", "param", "back", "agg", "mat", "other", "key", "comment", "prefix", "data", "et", "feature", "pair", "col", "format", "msg", "word", "image", "token", "pack", "at", "stat", "mod", "tags", "field", "add", "step"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n", "idx": 16812, "substitutes": {"env": ["proc", " environment", "end", "en", "test", "tx", "h", "eh", "obj", "e", "buf", "con", "dest", "txt", "v", "ctx", "param", "ev", "code", "context", "db", "environment", "req", "cur", "vt", "pe", "eng", "conf"], "ram_addr": ["am_addr", "am_add", "ram2ref", "gram_ref", "am_ptr", "rammyaddr", "am_ref", "ram_ord", "rammyord", "rammyadd", "ram2add", "ram_pos", "ram_add", "ram2addr", "gram_address", "ram_address", " ram_ord", "ram_ptr", " ram_add", "am_address", "am_pos", " ram_ref", "ram2pos", "ram2ptr", "rammyref", "gram_addr", "ram2address", "ram_ref"], "page_index": ["pagezIndex", "page_Index", "page_ind", "page_alias", "cycleNameindex", "pageingdepth", "cycleNameprefix", "page_object", "pageNamealias", "pageNameindex", "page_strength", "page_depth", " page_number", "Page_object", " page_link", "Page_ind", "cycleNamealias", "Page_number", "pageingnumber", "pageNameIndex", " page_depth", "page00value", "cycle_index", " page_Index", "page_value", " page_value", "cycle_Index", "page00depth", "cycle_alias", "pageingvalue", "pagezalias", "pagezindex", "pageingindex", "cycleNameIndex", "page00number", "page_prefix", "page_link", "pageNameprefix", "Page_index", "page00index", "page_number", "pagezprefix", " page_strength", "cycle_prefix"], "ret": ["rt", "tmp", "prop", "reg", "get", "ext", "ref", "final", "result", " RET", "not", "report", "ert", "rem", "valid", "def", "cont", "tr", "res", "elt", "Return", "class", "re", "arg", "att", "flag", "resp", "det", "RET", "Ret", "ter", "sys", " Ret", "out", "ft", "back", "inter", "print", "val", "alt", "mem", "status", "nt", "pret", "reply", "t"], "temp": ["tmp", "tm", " result", "attr", " output", "cache", "result", "pre", "test", "fac", "term", "Temp", " temperature", " mem", "buffer", "null", " t", "dat", "tem", "tc", "EMP", "pt", "index", "txt", " term", " Temp", "v", "template", " tmp", " wr", "data", "alt", "storage", "mem", "status", " temporary", "w", "vt", "pool", " ptr", " buf", "limit", "ptr", "t"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 16829, "substitutes": {"ctx": ["tmp", "cf", "act", "cv", "window", "ok", "config", "conn", "Context", "pkg", "ctr", "hw", "jp", "tx", "c", "wd", "ca", "cm", "anc", "parent", "ck", "mc", "setup", "cp", "sc", "conv", "jac", "obj", "gc", "kt", "cb", "wx", "tc", "sys", "cc", "kw", "txt", "ct", "ctl", "history", "wcs", "bc", "xc", "context", "mk", "cmd", "ctrl", "cas", "uj", "prefix", "req", "cur", "tk", "exec", "nt", "cmp", "cfg", "batch"], "pfds": ["pfdrs", "pfscs", "pfsds", "pifcs", "pfsrs", "pfrs", " pifns", "pfsns", " pifrs", "pifrs", " pifcs", " pfns", "pfns", " pfcs", "pfdcs", " pfrs", "pfdds", "pfdns", "pfcs", "pifds", " pifds", "pifns"], "npfd": ["pnfp", "npdat", "npds", " npda", "nbfd", "pnFD", "pndat", " npdat", "pnds", "ndat", "nfd", " npFD", "npda", "ncFD", "nda", "npFD", "ncfd", "nbfp", "nbds", "nFD", "pnda", "pnfd", "ncfp", "nbFD", "npfp", "ncds"], "timeout": ["unit", "opt", "ffff", "block", "tt", "sec", "lock", "delay", " duration", "size", "uration", "buffer", "duration", "Timeout", "frequency", " t", "check", "ts", "time", "out", " seconds", "period", "policy", "wait", "resolution", "tv", "seconds", " threshold"]}}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void aarch64_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&aarch64_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {\n\n        aarch64_cpu_register(&aarch64_cpus[i]);\n\n    }\n\n}\n", "idx": 16842, "substitutes": {"i": [" n", " I", "is", "bi", " my", "gi", "ind", "init", " mi", "c", "ri", "xi", "point", "ki", "cli", "ai", "port", "batch", "oi", "li", "ui", "ic", "ip", "y", "\u0438", " ii", "ims", "pi", "iu", "qi", "mu", "im", " bi", "ci", "zi", "my", "sim", "m", "index", "ji", "gu", " pi", "ori", "v", " err", "I", " c", "ii", "key", "ei", "ti", "print", "phi", "fi", "ix", " l", "x", " m", "di", "it", "mi", " j", " multi", "ij", "iq", "uu", "ini", "multi", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "substitutes": {"opaque": ["popaque", "iopacity", "popus", "opacity", "operaque", "iopane", "opane", "operaques", "obaque", " opaques", "popacity", "obacity", "ogane", " opacity", " opula", "ogaque", "popane", "ogacity", "operacity", "obula", "ogus", "opula", "opus", "obaques", "iopus", "iopaque", "operula", "opaques"], "offset": ["pad", "alias", "length", "location", "slot", "shift", "ta", "point", "origin", "tab", "pointer", "mask", "Offset", "position", "style", "buffer", "priority", "padding", "attribute", "pos", "set", "address", "index", "id", "off", "o", "area", "code", "alloc", "prefix", "seek", "count", "op", "bound", "command", "start", "addr", "scope", "oid", "range", "field", "name"], "value": ["block", "vector", "content", "use", "password", "eth", "priority", "amount", "attribute", "address", "message", "v", "key", "val", "maximum", "weight", "status", "transform", "word", "field", "entry", "VALUE", "test", "VAL", "values", "json", "style", "true", "null", "ue", "expression", "function", "now", "zero", "index", "mode", "code", "template", "total", "wire", "state", "package", "option", "input", "dev", "variable", "when", "name", "vp", "unit", "length", "sum", "all", "result", "parent", "ay", "self", "unknown", "buffer", "version", "byte", "set", "example", "record", "number", "no", "python", "raw", "try", "text", "type", "get", "label", "initial", "always", "fee", "property", "widget", "flow", "position", "scale", "server", "padding", "select", "request", "Value", "see", "operator", "description", "echo", "data", "feature", "format", "current", "hello"], "size": ["window", "length", "sum", "type", "shift", "fee", "style", "cap", "SIZE", "scale", "len", "ize", "address", "message", "n", "area", "code", "space", "Size", "weight", "count", "mem", "start", "z", "name"], "s": ["is", "er", "fs", "h", "sm", "js", "i", "store", "y", "ies", "vs", "ims", "o", "tes", "stats", "qs", "less", "ses", "comments", "als", "terms", "eps", "ports", "des", "ants", "ss", "ns", "obj", "spec", "parts", "bis", "sports", "services", "S", "cs", "rates", "conf", "hs", "p", "sl", "sts", "rs", "sq", "service", "os", "q", "set", "pers", "m", "sb", "gs", "ssl", "comm", "bs", "ls", "sv", "ins", "so", "changes", "settings", "ears", "r", "request", "ats", "sync", "ts", "sys", "its", "b", "n", "se", "uploads", "ds", "ps", "t", "details", "j", "es"]}}
{"project": "qemu", "commit_id": "3b2e934463121f06d04e4d17658a9a7cdc3717b0", "target": 0, "func": "static inline uint32_t nvic_gprio_mask(NVICState *s)\n\n{\n\n    return ~0U << (s->prigroup + 1);\n\n}\n", "idx": 16870, "substitutes": {"s": ["is", "sts", "g", "rs", "sv", "aws", "a", "c", "h", "sq", "js", "ss", "ns", "r", "e", "ats", "ts", "sys", "m", "es", "b", "v", "n", "bis", "sb", "ds", "ses", "S", "gs", "t", "bs", "hs", "j", "p"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n", "idx": 16879, "substitutes": {"fds": [" fbs", "fdrs", "tybs", "fsbs", " fdos", "fts", " fda", "fda", "Fcs", "fsds", " fels", "fdos", "sfds", "afps", "afrs", "fDs", " fuds", "nys", " fcs", "fsdos", "fels", "formdes", "fsels", "afds", "fbs", "Fuds", "fdes", "bfds", "sfdos", "hds", "tyels", "foreda", "frs", "nda", "Fds", "fps", "formdos", "sfda", "nDs", " fDs", "bfda", "fuds", "foreds", "foredos", "fdts", "fdds", "hys", "nds", "tydos", "foredes", "afts", "fys", " fts", "hcs", "bfys", "sfdes", " fps", "fdps", " fys", "Fys", "tyds", "formds", " frs", "fcs", "huds", "bfDs", "formda"], "ret": ["new", "f", "rt", "get", "reg", "ext", "g", "gt", "ref", "conn", "end", "result", "sec", "lt", "err", "def", "cont", "dt", "len", "tr", "res", "net", "p", "elt", "gc", "cb", "set", "re", "r", "arg", "resp", "flag", "buf", "RET", "Ret", "ter", "num", "txt", "v", " Ret", "ft", "out", "code", "back", "inter", "cert", "reset", "val", "gb", "x", "alt", "success", "mem", "no", "lib", "vt", "nt", "try", "usr", "mt", "t", "j", "red", "ry"]}}
{"project": "qemu", "commit_id": "77a5a0001bd9eaee9da7dc8f0b69702d56b0cc67", "target": 0, "func": "static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 16888, "substitutes": {"bs": ["is", "bb", "ks", "bh", "rs", "as", "bd", "BS", "lbs", "ss", "bp", "vs", "ns", "ts", "bis", "sb", "bc", " ss", "cks", "ds", "bos", "ses", "qs", "gs", "bm", "bf", "cs", "ps", "fs"], "offset": [" o", "type", "from", "block", "scroll", "ref", " seek", "shift", "origin", "tab", "pointer", "size", "Offset", "amount", "pos", "top", "set", "zero", "index", "off", " start", " offsets", "seek", " off", "base", "start", "oid"]}}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n", "idx": 16890, "substitutes": {"v": ["f", "cv", "sv", "g", "vv", "NV", "a", "h", "c", "size", "values", "q", "conv", "y", "vs", "p", "V", "iv", "u", "lv", "r", "l", "m", "qv", "value", "vm", "env", "b", "n", "ev", "o", "ve", "va", "change", "s", "x", "vc", "uv", "nv", "tv", "w", "vt", "limit", "t", "j", "vp"], "i": ["us", "is", "bi", "gi", "in", "ind", "chain", "init", "ri", "xi", "ex", "cli", "ai", "info", "oi", "li", "ic", "ui", "ip", "y", "io", "\u0438", " ii", "ami", "ims", "pi", "iu", "qi", "u", "im", "e", "zi", "ci", "ms", "my", "l", "sim", "m", "me", "index", "id", "uli", "eu", "k", "I", "o", "ii", "ti", "ei", "fi", "phi", "ix", "x", "span", "di", "uri", "it", "mi", "ie", "ini", "multi", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924, "substitutes": {"oc": ["org", "ost", "oca", "ok", "c", "oe", "OC", "mc", "os", "ot", "ic", "voc", "loc", "unc", "soc", "ac", "pc", "nc", "oco", "ctx", "o", "ocr", "bc", "uc", "alloc", "oci", "roc", "toc", "vc", "ec", "ob", "oid", "od", "co", "ocation", "orp"], "data": ["new", "config", "dll", "bus", "rc", "func", "draw", "mc", "def", "ata", "res", "doc", "mu", "dat", "d", "rec", "DATA", "out", "Data", "dd", "instance", "desc", "ds", "di", "bin", "name"], "occ": ["org", "cf", "ok", "rog", "inc", "Rec", "oe", "Occ", "OC", "fc", "usc", "rc", "abc", "orp", "icc", "mc", "anc", "func", "acc", "etc", "obj", "orm", "loc", "soc", "unc", "ac", "nc", "con", "rown", "rec", "bec", "ocr", "orc", "xc", "oci", "gov", "coll", "ec", "circ", "cci", "erc", "ob", "oid", "co", "exc", "roc"], "cc": ["cf", "lc", "ucc", "cn", "inc", "craft", "c", "ca", "ld", "disc", "cm", "fc", "CC", "rc", "lf", "ck", "icc", "mc", "func", "cont", "sc", "acc", "etc", "gc", "BC", "ll", "tc", "cu", "ci", "ac", "pc", "nc", "con", "cca", "rec", "cl", "ctx", "cd", "ctl", "ct", "bec", "code", "dd", "bc", "xc", "uc", "cmd", "ctrl", "cong", "control", "ce", "vc", "coll", "ec", "cy", "lib", "erc", "cs", "isc", "xx", "cmp", "co", "cci", "roc"], "dc": ["cf", "lc", "DC", "cam", "c", "bd", "cat", "ca", "disc", "fc", "rc", "ck", "mc", "sc", "acc", "gc", "iac", "unc", "tc", "da", "ac", "pc", "nc", "d", "cca", "rec", "ctx", "ctl", "nz", "bc", "uc", "db", "vc", "ds", "ec", "di", "cs", "cmp", "co", "dp", "cd"]}}
{"project": "qemu", "commit_id": "d99598cc9929ad6993ad3d19d9b1ec1d891f0d7f", "target": 1, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n", "idx": 16930, "substitutes": {"opaque": ["oplay", "oppque", "roplay", "opllay", "oppacity", "oplacity", "opacity", " opque", "ropiera", "oplaque", "ipiera", " opiera", "opiera", "opplay", "opque", "iplay", " opacity", "oplque", "oppaque", "ropaque", "ipaque", " oplay"], "addr": ["url", "tmp", "to", "pad", "alias", "attr", "offset", "bind", "rs", "ref", "host", "pkg", "trans", "map", "a", "tx", "wd", "nl", "ad", "len", "ip", "res", "pos", "obj", "ns", "loc", "kt", "src", "handle", "r", "address", "arr", "buf", "Address", "id", "ack", "ctx", "var", "state", "str", "cmd", "prefix", "data", "alt", "pair", "dr", "msg", "adr", "ress", "ptr", "mt", "ace", "hash", "add", "name", "arp"], "f": ["fd", "cf", "fab", "fl", "ff", "fal", "g", "rf", "fe", "fp", "h", "fac", "fb", "fc", "lf", "af", "i", "fr", "F", "u", "e", "r", "tf", "d", "fa", "fm", "v", "b", "alf", "uf", "o", "ft", "sf", "fi", "x", "file", "fw", "w", "bf", "fo", "xf", "fn", "t", "fs", "p"], "c": [" n", "lc", "cmp", "cr", "g", "cache", "chain", "cn", "C", "h", "cm", "com", "fc", "rc", "i", "mc", "cont", "cp", "sc", "len", "gc", "unc", "tc", "cu", "r", "ci", "e", "ac", "pc", "l", "nc", "d", "m", "con", "call", "cc", "cl", "v", "k", "ct", "out", "n", "b", "ctx", "bc", "s", "uc", "ce", "count", "x", " count", "cur", "vc", "cod", "ec", " C", "cs", "ch", "t", "co", "conf", " cc", "dc", " cs", "p"]}}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n", "idx": 16933, "substitutes": {"dest": ["Dest", "them", "tmp", "prop", "opt", "coord", "sum", "result", "trans", "sec", "test", "iter", "temp", "document", "origin", "good", "draw", "port", "shape", "cont", "order", "del", "tr", "etc", "doc", "dist", "master", "way", "loc", "export", "target", "src", "dat", "est", "d", "num", "local", "txt", "global", "priv", "out", "comment", "prototype", "desc", "req", "deg", "output", "msg", "word", "tif", "usr", "comb", "dev", "foreign", "created", "nom", "rest", "decl"], "source": ["unit", "component", "from", "sum", "config", "ind", "init", "SOURCE", "part", "copy", "interface", "use", "origin", "info", "service", "inner", "draw", "seed", "size", "style", "store", "parent", "params", "comp", "sc", "in", "ource", "master", "spec", "session", "src", "match", "item", "check", "query", "message", "any", "sim", "now", "Source", "sp", "subject", "local", "secure", "se", "rule", "before", "template", "see", "other", "join", "comment", "s", "str", "it", "sky", "image", "start", "scope", "input", "supp", "name"], "i": ["is", "iri", "init", "c", "y", "ip", "ami", " ii", "ims", "qi", "v", "I", "ii", "key", "print", "phi", " ti", "status", " multi", "hi", "t", " ki", "f", " di", " Li", "ui", "\u0438", "pi", "im", "uli", "index", " pi", "mi", "multi", " I", "g", "gi", "ind", "chain", "ri", "xi", "point", "ki", "cli", "ai", "port", "li", "iu", " bi", "ci", "my", "l", "sim", "m", "me", "k", "ti", "x", "uri", "ij", "ski", "si", "batch", "bi", " mi", "info", "ic", "in", "remote", "zi", "asi", "id", "ji", "ei", "fi", "ix", "di", " ni", "it", "ini", "j", "oi"]}}
{"project": "FFmpeg", "commit_id": "b00fb157bae79f9735910064585fd95b8c123003", "target": 0, "func": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n\n{\n\n    const uint8_t *src_end = src + src_size;\n\n    int x = 0, y = 0;\n\n\n\n#define INC_XY(n) \\\n\n    x += n; \\\n\n    if (x >= width) { \\\n\n        y++; \\\n\n        if (y >= height) \\\n\n            return 0; \\\n\n        x = 0; \\\n\n    }\n\n\n\n    while (src_end - src >= 2) {\n\n        uint8_t v = *src++;\n\n        if (v > 0 && v < 0xC0) {\n\n            do {\n\n                int length = FFMIN(v, width - x);\n\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n\n                INC_XY(length);\n\n                v   -= length;\n\n            } while (v > 0);\n\n            src++;\n\n        } else if (v >= 0xC1) {\n\n            v -= 0xC0;\n\n            do {\n\n                int length = FFMIN3(v, width - x, src_end - src);\n\n                if (src_end - src < length)\n\n                    break;\n\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n\n                INC_XY(length);\n\n                src += length;\n\n                v   -= length;\n\n            } while (v > 0);\n\n        } else {\n\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16984, "substitutes": {"avctx": ["Avctx", "ajctl", "avctl", "Avctl", "avcas", "AVcp", " avcas", " avcp", " avcontext", "savcas", "AVctx", "avconn", "ajcontext", "AVcontext", "AVcas", "ajconn", "Avconn", "avcontext", " avctl", "ajctx", "savcontext", "avcp", "savcp", " avconn", "savctx", "Avcontext"], "dst": ["Dest", "bst", "dht", "cht", "lST", "disest", "lnd", "dsdest", "deht", "pnd", "cst", "dsht", "pst", "disST", "dispt", "disst", "dept", "blt", "lst", "llt", "lsts", "dest", "plt", "Dpt", "cdest", "ddest", "dpt", "bsts", "DST", "cpt", "bnd", "Dst", "dST", "dsts", "psts", "lest", "dnd", "dlt", "lpt", "dedest", "dspt", "dsst"], "src": ["sn", "init", "c", "stream", "i", "seed", "syn", "np", "inst", "scan", "ith", "stack", "uv", "supp", "tp", "sup", "proc", "url", "offset", "st", "sec", "nr", "inner", "sur", "cont", "sub", "u", "sr", "ur", "rec", "hl", "s", "source", "usr", "input", "cs", "tmp", "sl", "length", "ser", "th", "rs", "ind", "sq", "rl", "size", "comp", "conv", "iv", "loc", "sp", "txt", "sb", "bc", "x", "cur", "seq", "ptr", "bs", "rt", "ctr", "ins", "rc", "sc", "in", "img", "r", "sync", "sys", "sing", "dest", "cc", "gz", "b", "slice", "addr", "start"], "src_size": ["ser_size", "src_dim", "ser_Size", "src_time", "rc_time", "rc_size", "src_SIZE", "ser_SIZE", "rc_Size", "src_Size", "rc_dim"], "height": ["stroke", "length", "h", "depth", "size", "gravity", "radius", "shape", "padding", "y", "build", "rows", "grow", "hub", "history", "acity", "oom", "hang", "wh", "axy", "holes", "resolution", "ows", "density", "Height", "ch", "loss"], "linesize": ["inespan", "framesization", "usersizer", "framesizer", "inespace", "linspan", "linesized", "dsized", "inesized", "lineize", "linsized", "inesIZE", "linesiz", "lineizer", "inesize", "usersze", "linesization", "linespan", "dsize", "lineIZE", "linesze", "blocksizer", "blockspace", "linsiz", "inesizer", " linesze", "blocksize", "usersization", "linespace", " linesizer", "linesIZE", "framesize", "inesiz", "dspan", "linepace", "framesze", "usersize", "dsiz", "linesizer", " linesization", "blocksIZE", "linsize"], "src_end": [" src_begin", "src___start", "src___end", "src_next", "src___next", "src_begin", " src_start", "rc_begin", "source_end", "source_END", "rc_size", "rc_end", "source_start", "rc_start", "src_END", "rc_next", "src_start"]}}
{"project": "FFmpeg", "commit_id": "9aa0606e87a221eba935ed675c1cd5ca94832e28", "target": 0, "func": "static int hls_read_seek(AVFormatContext *s, int stream_index,\n\n                               int64_t timestamp, int flags)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i;\n\n    int64_t seek_timestamp;\n\n    int valid_for = -1;\n\n\n\n    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->playlists[0]->finished)\n\n        return AVERROR(ENOSYS);\n\n\n\n    seek_timestamp = stream_index < 0 ? timestamp :\n\n                     av_rescale_rnd(timestamp, AV_TIME_BASE,\n\n                                    s->streams[stream_index]->time_base.den,\n\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n\n\n    if (s->duration < seek_timestamp)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* check first that the timestamp is valid for some playlist */\n\n        struct playlist *pls = c->playlists[i];\n\n        int seq_no;\n\n        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {\n\n            /* set segment now so we do not need to search again below */\n\n            pls->cur_seq_no = seq_no;\n\n            valid_for = i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (valid_for < 0)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* Reset reading */\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->input) {\n\n            ffurl_close(pls->input);\n\n            pls->input = NULL;\n\n        }\n\n        av_free_packet(&pls->pkt);\n\n        reset_packet(&pls->pkt);\n\n        pls->pb.eof_reached = 0;\n\n        /* Clear any buffered data */\n\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n\n        pls->pb.pos = 0;\n\n\n\n        pls->seek_timestamp = seek_timestamp;\n\n        pls->seek_flags = flags;\n\n\n\n        /* set closest segment seq_no for playlists not handled above */\n\n        if (valid_for != i)\n\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n\n    }\n\n\n\n    c->cur_timestamp = seek_timestamp;\n\n\n\n    return 0;\n\n}\n", "idx": 16986, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "as", "aws", "changes", "a", "sq", "settings", "js", "os", "ss", "sc", "sg", "bytes", "p", "ns", "spec", "ats", "actions", "ts", "sys", "m", "its", "bs", "acs", "b", "n", "o", "parts", "sports", "stats", "ds", "qs", "ses", "w", "S", "comments", "gs", "cs", "comm", "t", "ps", "conf", "fs", "hs", "es"], "stream_index": ["ream_index", "stream_num", "stream_code", "stream_ind", "peer_error", "streamityindex", " stream_Index", "streamNamelength", "stream_Index", " stream_length", "peer_code", "stream_number", "stream_name", "stream_connected", "streamityind", "stream_length", "stream_error", "streamityIndex", "streamityconnected", "ream_number", "ream_name", "streamNameindex", "streamNameconnected", "streamNameIndex", "streamityerror", "ream_num", "streamitylength", "peer_ind", " stream_connected", "streamitycode", "peer_index"], "timestamp": ["timency", " timeless", "timeetime", "Timeline", "Timestamp", "tunestamp", " timement", "Timest", "primement", "tunency", "Timeless", "Timency", "primeless", "timest", "primestamp", "tmest", "tmestamp", "timeest", "primest", " timest", "tmeline", "Timement", "Timetime", "timeeline", "tunest", "timement", "timetime", "timeency", "tmetime", "timeline", "timeless", "timeestamp"], "flags": ["levels", "length", " Flags", "acts", "bits", "uses", "ints", "fs", "changes", "args", "settings", "aps", "limits", "mask", "properties", "ants", "values", "lines", "styles", "heads", "grades", "events", "ags", "flag", "types", "ents", "Flags", "allows", "actions", "ts", "locks", "ats", "fps", "options", "weights", "parts", "lag", "FLAG", "wcs", "fields", "frames", "times", "atts", "stats", "words", "status", "vals", "files", "comments", "posts", "cs", "tags", "ps", "rates", "features", "details", "sets"], "c": ["f", "cf", "lc", "cv", "cmp", "cr", "config", "g", "cache", "cam", "C", "ca", "cm", "ex", "com", "fc", "rc", "mc", "cont", "cp", "sc", "etc", "gc", "cb", "tc", "enc", "cu", "ci", "ac", "pc", "l", "nc", "con", "cc", "b", "ctx", "v", "ct", "n", "cl", "bc", "ar", "ce", "vc", "ec", "cs", "ch", "comm", "t", "co", "conf", "dc", "cd", "p"], "i": ["is", "ik", "init", "y", "ip", " ii", "ims", "qi", "e", "series", "v", "I", "o", "ii", "phi", " j", "hi", "t", "f", "iter", "iy", "json", "ui", "\u0438", "pi", "im", "index", "mi", "ie", "iq", "multi", "name", "p", "to", " I", "gi", "ind", "chain", "ri", "xi", "point", "ki", "cli", "ai", "li", "go", "iu", "ci", "l", "sim", "me", "m", "history", "ti", "x", "try", "ij", "si", "batch", "bi", "info", "ic", "in", "remote", "zi", "id", "ji", "gu", "n", "ei", "ix", "di", "it", "ini", "j", "oi"], "seek_timestamp": ["seek_stimporal", "seek___dimporal", "seek_timency", "seek_timetz", "seek_stimenth", "seek_dimest", "seekedwaitence", "seek_momestamp", "seek_dimotype", "seek_timeamp", "seek_nowemark", "seekabletimamp", "seek_timesetz", "seek_Timestation", "seek_numestamp", "seek_timeence", "seekableTimtime", "seek_metificate", "seekabletimtime", "seek67simest", "seek_dimporal", "seek_timeetime", "seek67timaration", "seek_terminetz", "seek_nowestamp", "seek_terminetime", "seek_Timaration", "seek_Timency", "seekableTimamp", "seek_waitetime", "seek_stimestamp", "seekedwaitestamp", "seek_timesency", "seek_simestation", "seek_waitetz", "seek_timificate", "seek_numetz", "seek_timesest", "seek_timamp", "seekedtimetz", "seek67simestation", "seekabletimestamp", "seek_Timtime", "seek_mediestamp", "seek_numetime", "seek_basestamp", "seek_numence", "seek_timaration", "seekedtimestamp", "seek_simestamp", "seek_metotype", "seek_timtime", "seek___timenth", "seek_nowotype", "seekableTimest", "seek_stimest", "seekedwaitetz", "seekedtimetime", "seekedtimence", "seek67timestation", "seek_mediest", "seek_simest", "seekedwaitetime", "seek67simaration", "seek_metestamp", "seek_timporal", "seek_Timestamp", "seek_timeest", "seek_waitence", "seek_timeestamp", "seek_basetime", "seek_timemark", "seek_Timenth", "seek_timetime", "seek_momency", "seek_mediaration", "seek___dimest", "seek_timestation", "seek_momest", "seek_Timest", "seek_typest", "seek_timpace", "seek___dimestamp", "seek_mediestation", "seek_simaration", "seek_terminpace", "seek___timporal", "seek67timest", "seek_typtime", "seek_timespace", "seek_waitestamp", "seek_Timetz", "seek_timest", "seekableTimestamp", "seek_dimenth", "seek_Timamp", "seek_Timporal", "seek_dimestamp", "seek_dimificate", "seek___dimenth", "seek_timesetime", "seek_typamp", "seek_timotype", "seek_timence", "seek_timeetz", "seek_metemark", "seek67simestamp", "seek_dimemark", "seekabletimest", "seek_basetz", "seek_timenth", "seek67timestamp", "seek_baspace", "seek___timestamp", "seek___timest", "seek_mometz", "seek_nowificate", "seek_terminestamp", "seek_timesestamp", "seek_typestamp"], "pls": ["prns", "lookjs", "ptts", "clts", "logjs", "plys", "lookies", "palgs", "Plats", "Pls", " pli", "pats", "pli", "plds", "Plns", "spljs", " plies", " plns", "legis", "legies", "replts", "pljs", "PLts", "implands", "splongs", " plds", "plges", "PLjs", "prjs", "splgs", " plats", "paljs", "legs", "splts", "splats", "PLs", "ptains", "implgs", " plts", "clgs", "paties", "replgs", "palts", "logs", "repljs", "pts", " plis", "lookts", "logi", "plts", "plv", "plugs", "Places", "splds", "spls", "plgs", "patges", "plats", " plgs", "pals", "plands", "prts", "plis", "impls", "logis", "Pljs", "plugjs", "splis", " plands", "plyands", "splv", "ptjs", "splains", "Plis", " plains", "logts", "legongs", "spli", " pljs", "replands", "pris", "plies", "plns", "prs", "splges", "plongs", "splaces", "looks", "patts", " plv", "ptds", "places", "clies", "plygs", "pries", "repls", "cls", "palands", "cljs", "splies", "Plts", "plugv", "loggs", "plains", "replies", " plges", "palies", "palis", "Plgs", "ptgs", "palongs", " places"], "seq_no": ["seq_one", "seq_index", "seq_No", "seq_n", "seq_ao", "seq10no", "seq23no", "seqznr", "seqzindex", "cmp_nr", "seq10No", " seq_one", "seqableone", "seq23nr", "seq23ao", " seq_index", "seqzno", "seqableNo", "seqableno", "seqendo", "cmp_ao", " seq_do", "seq10n", "seq_nr", "seq23index", "seqenno", " seq_No", "seq_do", "cmp_index", " seq_n", "seq10one", "cmp_no", "seqenindex", "seqablen", "seqzao"]}}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assigned_initfn(struct PCIDevice *pci_dev)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    uint8_t e_intx;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    if (!kvm_enabled()) {\n\n        error_report(\"pci-assign: error: requires KVM support\");\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&\n\n        !dev->host.function) {\n\n        error_report(\"pci-assign: error: no host device specified\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * Set up basic config space access control. Will be further refined during\n\n     * device initialization.\n\n     */\n\n    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);\n\n    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);\n\n    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_BIST, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);\n\n    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);\n\n    memcpy(dev->emulate_config_write, dev->emulate_config_read,\n\n           sizeof(dev->emulate_config_read));\n\n\n\n    get_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n", "idx": 16999, "substitutes": {"pci_dev": ["pci__ev", "pdi_Dev", "pdi_def", "pdi_dev", "pci_def", "pci_ev", "pci_Dev", "pci__def", "pdi_ev", "pci__dev"], "dev": ["prop", "h", "wd", "ad", "def", "np", "debug", "home", "query", "det", "scan", "dem", "env", "v", "var", "hid", "out", "val", "req", "mem", "new", "proc", " Dev", "Dev", "hw", "sw", "test", "develop", "rem", "des", "serv", "device", "obj", "sd", "off", "row", "ev", "cmd", "db", "nv", "w", "ow", "nt", "conf", "roy", "p", "th", "end", "conn", "host", "pkg", " device", "unknown", "util", "go", "loc", "orig", "enc", "buf", "ve", "desc", "cur", "pro", "serial", "raw", "aux", "tech", "attr", "cam", "info", "ov", "draw", "server", "tr", "res", "att", "ver", "form", "any", "d", "num", "gu", "local", "priv", "app", "prom", "DEV", "data", "de", "adv", "av", "pack", "eng", " devs"], "e_intx": ["e2indx", "e_indx", "e_intr", "e2intx", "e2indv", "e_idv", "e2indr", "e2intr", "e_uintv", "e_idr", "e_intv", "e_indv", "e_uintx", "e_uintr", "e_idx", "e2intv", "e_indr"], "r": ["f", "rt", "Error", "attr", "ach", "rs", "er", "h", "err", "rc", "or", "error", "p", "rr", "e", "ra", "l", "b", "R", "race", "ry", "ar", "ran", "w", "rin", "usr", "ror", "rans"], "local_err": ["local__cr", "local_exc", "local_buf", "local_", " local_", "local__buf", "self_cr", "local_cr", "self_buf", "self_err", "self_exc", "local__err", "Local_", "global_", "local__exc"]}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n", "idx": 17004, "substitutes": {"xendev": ["xendeman", "xappendoc", "xenedeman", "xindef", "xinderv", "xenterv", "xesendedev", "wxindev", "xendeddev", "xendedev", "xendedown", "xndoc", "wxinddev", "xpendoc", "xesenddev", "xenddev", "xendoc", "xenedev", "xesenderv", "xnddev", "xesendeddev", "xappendeman", "xpendev", "xpenedev", "xendef", "xentev", "xappendev", "xentdev", "xendedoc", "wxinderv", "xendederv", "xenedown", "xndef", "wxendev", "xentef", "xpenedeman", "xpendeman", "xappendown", "xesendev", "xendown", "xenderv", "wxendef", "xpenedown", "xpenedoc", "xindev", "wxenddev", "xesendederv", "xnderv", "xesendedoc", "xesendoc", "wxenderv", "xinddev", "xenedoc", "xpendown", "xindoc", "xendedeman", "xndev", "wxindef"]}}
{"project": "FFmpeg", "commit_id": "1e901ffc619459944ae7102428f48972cd899caa", "target": 0, "func": "static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)\n\n{\n\n    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&\n\n        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {\n\n        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&\n\n            timestamp < st->pts_wrap_reference)\n\n            return timestamp + (1ULL<<st->pts_wrap_bits);\n\n        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&\n\n            timestamp >= st->pts_wrap_reference)\n\n            return timestamp - (1ULL<<st->pts_wrap_bits);\n\n    }\n\n    return timestamp;\n\n}\n", "idx": 17009, "substitutes": {"st": ["sn", "sm", "stage", "sta", "store", "etc", "mont", "inst", "stack", "sty", "ast", "storage", "art", "stan", "lo", "rd", "co", "rest", "act", "ost", "sw", "ste", "std", "nd", "ss", "net", "obj", "s", "nt", "usr", "mt", "stable", "ld", "step", "irst", "sl", "th", "sts", "utt", "set", "pt", "sp", "cl", "ST", "ct", "history", "desc", "ust", "ent", "tt", "sv", "so", "spect", "tra", "td", "draw", "sc", "sth", "must", "ut", "form", "St", "est", "ts", "se", "str", "et", "sam", "stat", "ace", "t", "sh", "z", "each", "ist"], "timestamp": ["timeestone", "Timtim", "Timestamp", "tomestamp", "tomed", "timed", "magsequence", "timemark", "momitude", "testestamp", "timmediately", "timetz", "timificate", "timeener", "pixelestamp", "timpoint", "timepoint", "capestamp", "poolemark", "poolmediately", "messumn", "timeumn", "timitude", "Timetz", "messestamp", "tripest", "tripestamp", "messatile", "capest", "documentemark", " timtime", "timeemark", "captim", "statificate", "statestamp", "timtime", " timest", "testumn", "broadener", "pixelemark", " timumn", "Timpoint", "tripetz", "broadestone", "Timest", "statemark", "statmediately", "testatile", "timest", "magitude", " timinal", "triptim", "broadestamp", "documentificate", "timeatile", "timeest", "capetz", "messpoint", "tomsequence", "poolestamp", "impoint", "momed", "timeestamp", "tomitude", "imtime", "timumn", "documentestamp", "timestone", "timsequence", "iminal", "broademark", "pixelener", "Timumn", "timeinal", "poolificate", "timener", "timtim", "imestamp", "pixelestone", "timatile", "momestamp", "magestamp", "timetime", "timinal", "maged", "momsequence", "documentmediately", " timpoint", "testpoint"]}}
{"project": "qemu", "commit_id": "41a2b9596c9ed2a827e16e749632752dd2686647", "target": 0, "func": "static void ide_atapi_cmd_reply_end(IDEState *s)\n\n{\n\n    int byte_count_limit, size, ret;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"reply: tx_size=%d elem_tx_size=%d index=%d\\n\",\n\n           s->packet_transfer_size,\n\n           s->elementary_transfer_size,\n\n           s->io_buffer_index);\n\n#endif\n\n    if (s->packet_transfer_size <= 0) {\n\n        /* end of transfer */\n\n        ide_transfer_stop(s);\n\n        s->status = READY_STAT;\n\n        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n\n        ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n        printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n    } else {\n\n        /* see if a new sector must be read */\n\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n\n            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);\n\n            if (ret < 0) {\n\n                ide_transfer_stop(s);\n\n                ide_atapi_io_error(s, ret);\n\n                return;\n\n            }\n\n            s->lba++;\n\n            s->io_buffer_index = 0;\n\n        }\n\n        if (s->elementary_transfer_size > 0) {\n\n            /* there are some data left to transmit in this elementary\n\n               transfer */\n\n            size = s->cd_sector_size - s->io_buffer_index;\n\n            if (size > s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = s->lcyl | (s->hcyl << 8);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            if (byte_count_limit == 0xffff)\n\n                byte_count_limit--;\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 17012, "substitutes": {"s": ["is", "er", "as", "states", "fs", "a", "h", "c", "args", "sm", "js", "i", "store", "y", "ies", "vs", "ims", "ids", "v", "utils", "has", "tes", "stats", "http", "qs", "ses", "less", "ers", "als", "bits", "aws", "sw", "xs", "des", "ss", "serv", "ns", "events", "obj", "spec", "ms", "parts", "bis", "sports", "services", "full", "times", "w", "S", "results", "source", "cs", "conf", "sis", "hs", "p", "sl", "sts", "g", "rs", "south", "ops", "sq", "self", "os", "conv", "set", "m", "sb", "gs", "ssl", "ows", "gets", "comm", "ys", "ls", "sv", "ins", "changes", "so", "settings", "search", "ions", "params", "r", "ats", "sync", "ts", "d", "sys", "its", "b", "ties", "n", "se", "tests", "ds", "ps", "t", "details", "z", "j", "es"], "byte_count_limit": ["byte_size_lock", "byte_count\u05bccontrol", "byte_count\u05bclimits", "byte_length_limits", "byte_list_limited", "byte_count\u05bclock", "byte_length_lock", "byte_list_lock", "byte_size_limits", "byte_count_lock", "byte_size_limit", "byte_count_limited", "byte_size_lim", "byte_count_lim", "byte_list_limits", "byte_list_limit", "byte_count\u05bclimit", "byte_length_limit", "byte_count_limits", "byte_count_control", "byte_size_control"], "size": ["sn", "shift", "args", "use", "shape", "big", "max", "address", "grow", "small", "fit", "message", "time", "sha", "send", "capacity", "storage", "mem", "status", "limit", "huge", "add", "new", "offset", "min", "mini", "len", "body", "export", "now", "zero", "area", "space", "total", "empty", "notice", "full", "general", "name", "to", "length", "sum", "scroll", "g", "largest", "south", "sent", "buffer", "dim", "set", "l", "sp", "member", "used", "count", "no", "number", "range", "fee", "speed", "city", "SIZE", "scale", "padding", "ize", "too", "bytes", "large", "height", "any", "num", "yes", "gz", "n", "see", "Size", "description", "data", "format", "news", "start", "sh", "timeout"], "ret": ["f", "rt", "tmp", "reg", "get", "gt", "ref", "st", "result", "err", "lit", "after", "rc", "rem", "sent", "tail", "def", "cont", "dt", "len", "res", "elt", "re", "flag", "r", "arg", "resp", "got", "failed", "RET", "Ret", "rev", " Ret", "back", "nz", "git", "reset", "val", "rets", "count", "alt", "mem", "deg", "fun", "nt", "try", "usr", "mt", "t", "hash", "repl", "j", "red"], "lba": [" lva", "llda", "liba", "lina", "bba", "lfa", "llba", "nlbal", "bbe", "lva", "lata", "nlba", "bva", "nlBA", "lta", "lifa", "nlda", "lpa", "lBA", "llbe", "llta", "llna", "lna", "lita", "lbe", "lda", "llBA", "llpa", "llva", "laba", "bpa", "lana", " lpa", " lda", "lafa", "lbal", "llbal", "llfa", " lBA", " lbal", " lbe"]}}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17021, "substitutes": {"opaque": ["OPque", " opane", "OPane", "oppsolete", "opacity", "OPaque", " opque", "opane", "OPacity", "obaque", " opaques", "obque", "OPac", "OPaques", "obacity", "obane", " opac", "opque", " opacity", " opsolete", "oppaque", "opsolete", "oppac", "oppaques", "OPsolete", "opac", "opaques"], "addr": ["url", "pad", "rt", "alias", "coord", "attr", "offset", "rs", "oad", "ref", "hw", "a", "tx", "err", "ag", " address", "ad", "res", "pos", "loc", "align", "src", "address", "arr", "r", "Address", "work", "ac", "now", "id", "index", "ack", "off", "ord", "ctx", "inter", "alloc", "cmd", "grad", "x", "alt", "mem", "dr", "adr", "at", "ptr", "hash", "ace", "start", "mt", "add"], "val": ["bit", "all", "ref", "slot", "pal", "tx", "test", "Val", "fee", "xy", "valid", "VAL", "ret", "values", "def", "bool", "serv", "res", "cal", "al", " value", "elt", "arg", "rel", "eval", "buf", "vol", "pol", "value", "num", "pt", "v", "ctx", "sol", "grad", "weight", "data", "count", "x", "alt", "mem", "bal", "vals", "vt", "bl", "ival", "sel"], "s": ["ls", "sl", "is", "rs", "c", "h", "sis", "sm", "i", "q", "ss", "ess", "ns", "ms", "ts", "m", "d", "sp", "b", "v", "n", "o", "bis", "sb", "state", "sol", "stats", "qs", "ses", "w", "S", "gs", "ps", "t", "bs", "fs", "hs", "p"], "saddr": [" saddress", "svaddr", "Saddr", " sadd", "svcoord", " sptr", "saddress", "svpad", "Sadd", "wsaddr", " sadr", "Saddress", "spad", "ssaddr", "scoord", "Scoord", "ssadr", "wsaddress", "wscoord", "ssaddress", "sadd", "ssptr", "sadr", "wspad", "sptr", "Spad", "svaddress"]}}
{"project": "qemu", "commit_id": "7ce21016b69b512bf4777965a4292318f2bc7544", "target": 0, "func": "int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors)\n\n{\n\n    int max_discard;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n\n        return -EIO;\n\n    } else if (bs->read_only) {\n\n        return -EROFS;\n\n    }\n\n\n\n    bdrv_reset_dirty(bs, sector_num, nb_sectors);\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {\n\n        return 0;\n\n    }\n\n\n\n    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;\n\n    while (nb_sectors > 0) {\n\n        int ret;\n\n        int num = nb_sectors;\n\n\n\n        /* align request */\n\n        if (bs->bl.discard_alignment &&\n\n            num >= bs->bl.discard_alignment &&\n\n            sector_num % bs->bl.discard_alignment) {\n\n            if (num > bs->bl.discard_alignment) {\n\n                num = bs->bl.discard_alignment;\n\n            }\n\n            num -= sector_num % bs->bl.discard_alignment;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_discard) {\n\n            num = max_discard;\n\n        }\n\n\n\n        if (bs->drv->bdrv_co_discard) {\n\n            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);\n\n        } else {\n\n            BlockDriverAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,\n\n                                            bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                return -EIO;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += num;\n\n        nb_sectors -= num;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17030, "substitutes": {"bs": ["bb", "bh", "ubs", "states", "bd", "BS", "js", "bp", "vs", "ims", "pb", "eb", "bec", "stats", "qs", "abilities", "als", "bes", "bits", "outs", "aws", "ports", "lbs", "ns", "obj", "hz", "ib", "ubis", "ms", "bis", "cks", "irms", "vals", "aus", "bl", "cs", "aos", "hs", "sts", "rs", "css", "blog", "stones", "eks", "locks", "bing", "bn", "sb", "tops", "bc", "uts", "bps", "gs", "bm", "boxes", "ls", "ins", "changes", "books", "obs", "bytes", "bys", "ats", "ts", "sys", "its", "fps", "bsp", "b", "bos", "ds", "bas", "bf", "bles", "ps", "lets", "fs", "banks"], "sector_num": ["sector_name", "section_Num", "slave9n", "sectoritynum", "slave9num", "iter_NUM", "iterNamenum", "sector_number", "section_number", " sector_nom", "sector9nb", "sectoritynam", " sector_Num", "tier_tim", "sectorityNum", "tier_num", "sector1name", "sector_nom", "sector9Num", " sector_desc", " sector_gen", "section_num", "sector1number", "slave_n", "sector_gen", "sector_net", "iterNamena", "tier_nam", "sector_tim", "sector1NUM", " sector_nr", "sector_mun", "sectoritytim", "sector1nom", " sector_name", "iter_num", "sector9n", "sector2mon", "sector2number", "iterNamecomm", " sector_number", "sectorNamenum", "sectorjnom", "slave_mun", "sector_NUM", "sector_comm", "section_mon", "sectorNamecomm", "sectoritygen", "slave9nb", "sectorjnum", "sector9master", "sector_Num", "iter_comm", "sector_desc", "sector2num", "sector9num", "sector_master", "sector1desc", "sectorjnumber", " sector_master", "sector1comm", "sector_mon", "sectorNamena", "slave_nb", "sector_nr", "sector_na", "sector_nb", "sectoritymaster", "sector1num", "sectorjdesc", "tier_net", "sectorNameNUM", "sector2Num", "sector1nr", "slave9mun", "slave_num", "sector9mun", "sector9gen", "iter_na", "sector1na", "iterNameNUM", "sector_nam", "sector_n", "sectoritynet", "sector1Num"], "nb_sectors": ["nb_shgments", "nb_seicas", "nb_vections", "nb_speriers", "nb_gegments", "nb_temims", "nb_sesctors", "nb_shctors", "nb_sykers", "nb_pections", "nb_temors", "nb_severs", "nb_veriers", "nb_sections", "nb_mectors", "nb_seriers", "nb_sesims", "nb_temctors", "nb_mevers", "nb_gectors", "nb_shors", "nb_vevers", "nb_seors", "nb_geicas", "nb_seims", "nb_syvers", "nb_spegments", "nb_beicas", "nb_speors", "nb_beors", "nb_sekers", "nb_veors", "nb_sourcegments", "nb_syctors", "nb_vectors", "nb_veims", "nb_geors", "nb_begments", "nb_sesgments", "nb_syors", "nb_suors", "nb_sesivers", "nb_seivers", "nb_meors", "nb_sukers", "nb_bectors", "nb_pevers", "nb_suvers", "nb_suctors", "nb_sesors", "nb_pectors", "nb_peors", "nb_seurers", "nb_temivers", "nb_segments", "nb_veicas", "nb_sourceurers", "nb_mections", "nb_veurers", "nb_sesriers", "nb_vekers", "nb_sourcectors", "nb_spectors", "nb_veivers", "nb_shurers", "nb_vegments", "nb_sourceors"], "max_discard": ["max_Discment", "max_DiscARD", "max_dcard", "max_decord", "max2iscARD", "max_decARD", "max_discount", "max_destart", "max2iscart", "max_decarded", "max_disount", "max_regard", "max_Discards", "max_Discad", "max_regad", "max_Discord", "max_dcARD", "max_iscard", "max_iscart", "max_diffard", "max2discart", "max2discARD", "max_disord", "max_dcarded", "max_decards", "max_Discordon", "max_discord", "max_subordon", "max_disordon", "max_decard", "max_discordon", "max_destment", "max_regord", "max_disards", "max_diffarded", "max_destount", "max_decment", "max2iscarded", "max2discard", "max_discment", "max_disad", "max2iscard", "max_disart", "max_discuster", "max_discards", "max_Discart", "max_diffart", "max2discarded", "max_Discount", "max_dcart", "max_Discuster", "max_disarded", "max_decuster", "max_subment", "max_iscarded", "max_diffARD", "max_iscARD", "max_discart", "max_Discard", "max_Discarded", "max_disment", "max_disard", "max_destard", "max_discarded", "max_subard", "max_regards", "max_subarded", "max_discad", "max_discARD"], "ret": ["new", "rt", "url", "tmp", "get", "reg", "ne", "ext", "gt", "ref", "result", "iter", "err", "not", "lit", "rem", "def", "flag", "len", "tr", "res", "pas", "del", "elt", "Return", "gc", "re", "arg", "r", "arr", "resp", "att", "det", "RET", "Ret", "ter", "progress", "got", "num", "failed", "local", "back", "out", " Ret", "ft", "nz", "inter", "reset", "val", "rets", "print", "fi", "empty", "x", "alt", "mem", "nt", "rm", "try", "mt", "tree", "t", "rest", "red", "ry"], "acb": [" acbc", "acbl", "abcbl", "ancv", "acbc", " acbl", "bcsb", "fcv", "abcb", "bcv", "aconbd", " acbd", "fcsb", "ancbd", "aconb", "ancb", "acerb", "acB", "acaB", "bcbd", "aconbl", "acabt", "acab", "aconB", "acerbc", "acbd", "abcB", "acerbt", "acabc", "fcb", "fcbd", " acB", " acbt", "acv", "acbt", "bcb", "abcbd", "acsb", "ancsb", "acerB"]}}
{"project": "qemu", "commit_id": "aff3f0f150769ec4f97c6e2cefe91c4a0377b548", "target": 0, "func": "static void xlnx_ep108_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"Xilinx ZynqMP EP108 board\";\n\n    mc->init = xlnx_ep108_init;\n\n    mc->block_default_type = IF_IDE;\n\n    mc->units_per_default_bus = 1;\n\n    mc->ignore_memory_transaction_failures = true;\n\n}\n", "idx": 17043, "substitutes": {"mc": ["tm", "lc", "cf", "mr", "mx", "cn", "coat", "c", "mm", "nic", "cm", "disc", "anc", "fc", "mp", "icc", "ic", "cp", "ml", "MC", "gc", "ns", "tc", "ci", "ms", "ac", "pc", "mot", "nc", "m", "cca", "cc", "cms", "mn", "mic", "tic", "bc", "oc", "mk", "md", "colm", "mint", "mac", "mi", "bm", "isc", "mt", "cmp", "co", "cci", "Mc", "dc"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                             TCGReg rd, TCGReg rn, uint64_t limm)\n\n{\n\n    unsigned h, l, r, c;\n\n\n\n    assert(is_limm(limm));\n\n\n\n    h = clz64(limm);\n\n    l = ctz64(limm);\n\n    if (l == 0) {\n\n        r = 0;                  /* form 0....01....1 */\n\n        c = ctz64(~limm) - 1;\n\n        if (h == 0) {\n\n            r = clz64(~limm);   /* form 1..10..01..1 */\n\n            c += r;\n\n        }\n\n    } else {\n\n        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */\n\n        c = r - h - 1;\n\n    }\n\n    if (ext == TCG_TYPE_I32) {\n\n        r &= 31;\n\n        c &= 31;\n\n    }\n\n\n\n    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);\n\n}\n", "idx": 17048, "substitutes": {"s": ["is", "sts", "ains", "g", "rs", "aws", "ex", "js", "q", "ss", "sc", "ns", "e", "m", "ts", "d", "es", "b", "v", "ctx", "n", "sb", "x", "ds", "w", "S", "gs", "cs", "ps", "t", "fs", "p"], "insn": ["inn", "linsn", "inne", "linssn", " statsne", "tsn", " statsgn", "linsgn", "insgn", " insgn", "linsne", "cssn", " statssn", "csne", " inssn", "ingn", "tsgn", " statsn", "inssn", "tssn", "csn", "csgn", "tsne", " insne", "insne"], "ext": ["new", "text", "extra", "act", "type", "opt", "xt", "config", "end", "ref", "ox", "ind", "init", "tx", "err", "ex", "ef", "ret", "def", "tr", "xp", "obj", "qt", "class", "enc", "EXT", "Ext", "ect", "rev", "tf", "prot", "txt", "v", "ct", "out", "esp", "inter", "alg", "cmd", "str", "desc", "x", "yt", "et", "cur", "req", "external", "ec", "format", "aux", "typ", "tif", "eng", "ch", "ptr", "t"], "rd": ["rid", "hr", "rt", "kr", "lr", "cr", "rs", "rf", "mr", "rog", "nd", "ri", "rh", "rx", "rc", "rl", "rob", "rar", "fr", "ro", "rb", "rg", "rr", "ird", "ra", "rw", "d", "orn", "RD", "ru", "ds", "dr", "erd", "rm", "ld", "red"], "rn": ["lr", "rt", "cv", "reg", "cr", "rf", "mr", " rh", "cn", "rog", "vr", "nd", "dn", "rh", "rx", "rc", "rl", "rar", "nl", "drm", "ro", "rb", "rg", "rr", "re", "ra", "rw", " rm", " re", " intr", "orn", "rov", " fr", "rm", "RN", "ld", "roc"], "limm": ["limgm", "plmn", "temkm", "milmi", "miln", "Limdm", "profmn", "limn", " limgm", "Limmt", "comdm", "temmi", "limmi", "limr", " slimm", "plm", "limcm", " slimkm", "comcm", "locdm", "locm", "temM", "samm", "samms", " limM", "Limm", "plmt", "lammt", "limmt", "gemm", " limitM", "profmt", "ligmn", "gemM", "gemr", "limdm", " limitm", "dimM", "ligmt", "dimgm", "dimr", " limpm", "limM", "profm", " limitkm", "limkm", "limmn", "temm", " slimn", " limn", "lamm", " slimM", "ligm", "locmt", "comm", "dimm", "sammt", "commt", "milpm", " limr", "limms", "limpm", "lammn", "Limcm", " limitmi", "milm", "profms", "sammn", "plms", "ligms", "loccm", " limmi", " slimmi", "lamms", " slimpm", "gemgm"], "h": ["hr", "f", "ih", "high", "th", "bh", "ht", "g", "ho", "hd", "ir", "hh", "H", "rh", "hs", "hal", "i", "q", "he", "y", "ha", "u", "hm", "oh", "ah", "dh", "d", "m", "ph", "v", "k", "n", "kh", "hl", "phi", "x", "dr", "w", "hi", "ch", "L", "t", "sh", "z", "j", "p"], "l": ["lr", "ls", "sl", "lc", "g", "lt", "lit", "i", "le", "nl", "li", "ml", "len", "lin", "loc", "ll", "pl", "u", "lv", "lp", "m", "d", "el", "b", "v", "n", "lu", "hl", "lb", "lang", "ly", "ln", "lo", "il", "L", "ld", "z", "j", "p"], "r": ["lr", "rt", "hr", "f", "cr", "br", "g", "rs", "er", "mr", "vr", "nr", "a", "rx", "err", "rc", "rl", "rar", "i", "pr", "q", "ro", "rb", "res", "rr", "u", "re", "ur", "sr", "e", "m", "d", "rec", "b", "R", "v", "n", "k", "ar", "x", "dr", "w", "rm", "range", "z", "j", "red", "p"], "c": ["cf", "lc", "cv", "cr", "g", "cache", "cn", "C", "ca", "cm", "fc", "rc", "com", "i", "mc", "cont", "cp", "sc", "cal", "gc", "cb", "u", "tc", "cu", "ci", "e", "pc", "m", "con", "cut", "d", "cc", "cl", "v", "ct", "n", "bc", "ce", "col", "cur", "ec", "cs", "ch", "t", "co", "dc", "z", "p"]}}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  bool smm_enabled,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,\n\n                      pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->smm_enabled = smm_enabled;\n\n\n\n    pm->enable_tco = true;\n\n    acpi_pm_tco_init(&pm->tco_regs, &pm->io);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),\n\n        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 17072, "substitutes": {"lpc_pci": ["lpc_mce", "lpc_sco", "lpc_mki", "lpc_ipce", "lpc_cmi", "lpc_moci", "lpc_dcm", "lpc_pki", "lpc_pce", "lpc_lci", "lpc_pca", "lpc_dco", "lpc_mcu", "lpc_propc", "lpc_pcu", "lpc_sci", "lpc_proci", "lpc_poci", "lpc_mco", "lpc_dcu", "lpc_pco", "lpc_dmi", "lpc_dci", "lpc_lcu", "lpc_scm", "lpc_ppc", "lpc_lca", "lpc_ipcu", "lpc_lmi", "lpc_ipci", "lpc_mcm", "lpc_ippc", "lpc_cco", "lpc_coci", "lpc_ppi", "lpc_pmi", "lpc_doci", "lpc_ccm", "lpc_ccu", "lpc_dce", "lpc_pcm", "lpc_mci", "lpc_dca", "lpc_cca", "lpc_ski", "lpc_dpi", "lpc_dki", "lpc_dpc", "lpc_propi", "lpc_ipcm", "lpc_ippi", "lpc_cci", "lpc_procm"], "pm": ["px", "program", "wd", "asm", "ami", "pp", "master", "pb", "dm", "pc", "dem", "wp", "activity", "imm", "po", "rpm", "rm", "gem", "nm", "test", "temp", "rem", "wm", " npm", "json", "cp", "pi", "power", "em", "im", "ram", "hm", "ms", "gm", "db", "pg", " am", "mi", "mt", "process", "dev", "PM", "mod", "vp", "p", "tmp", "mr", "pkg", "cm", "post", "service", "term", "pl", "um", "my", "m", "pn", "pt", "policy", "member", "am", "pool", "module", "bm", "mx", "cam", "mm", "mp", "ym", "vm", "param", "pa", "vim", "dd", "ams", "prom", "sam", "nom"], "smm_enabled": ["smmm_enabled", "smi_en", "smmm_enable", "smmetricen", "smm_enable", "smmablepowered", "smmm_supported", "smi_available", "smm_powered", "smm_supported", "smmm_powered", "smmetricenabled", "smmableenable", "smmetricavailable", "smi_enabled", "smmableenabled", "smm_en", "smm_failed", "smm_disabled", "smi_failed", "smm_available", "smmm_disabled", "smmetricfailed"], "sci_irq": ["sci_mrz", "sci_mirck", "sci_prqs", "sci_mirqs", "sci_pirQ", "sci_irqs", "sci_pirq", "sci_mrq", "sci_mrck", "sci_mrqs", "sci_prz", "sci_mirq", "sci_irQ", "sci_irz", "sci_arq", "sci_pirqs", "sci_prQ", "sci_prq", "sci_arqs", "sci_arck", "sci_mrQ", "sci_irck", "sci_pirz"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, bool isread,\n\n                       unsigned int op0, unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    const ARMCPRegInfo *ri;\n\n    TCGv_i64 tcg_rt;\n\n\n\n    ri = get_arm_cp_reginfo(s->cp_regs,\n\n                            ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP,\n\n                                               crn, crm, op0, op1, op2));\n\n\n\n    if (!ri) {\n\n        /* Unknown register; this might be a guest error or a QEMU\n\n         * unimplemented feature.\n\n         */\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch64 \"\n\n                      \"system register op0:%d op1:%d crn:%d crm:%d op2:%d\\n\",\n\n                      isread ? \"read\" : \"write\", op0, op1, crn, crm, op2);\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    /* Check access permissions */\n\n    if (!cp_access_ok(s->current_el, ri, isread)) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (ri->accessfn) {\n\n        /* Emit code to perform further access permissions checks at\n\n         * runtime; this may result in an exception.\n\n         */\n\n        TCGv_ptr tmpptr;\n\n        TCGv_i32 tcg_syn;\n\n        uint32_t syndrome;\n\n\n\n        gen_a64_set_pc_im(s->pc - 4);\n\n        tmpptr = tcg_const_ptr(ri);\n\n        syndrome = syn_aa64_sysregtrap(op0, op1, op2, crn, crm, rt, isread);\n\n        tcg_syn = tcg_const_i32(syndrome);\n\n        gen_helper_access_check_cp_reg(cpu_env, tmpptr, tcg_syn);\n\n        tcg_temp_free_ptr(tmpptr);\n\n        tcg_temp_free_i32(tcg_syn);\n\n    }\n\n\n\n    /* Handle special cases first */\n\n    switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n\n    case ARM_CP_NOP:\n\n        return;\n\n    case ARM_CP_NZCV:\n\n        tcg_rt = cpu_reg(s, rt);\n\n        if (isread) {\n\n            gen_get_nzcv(tcg_rt);\n\n        } else {\n\n            gen_set_nzcv(tcg_rt);\n\n        }\n\n        return;\n\n    case ARM_CP_CURRENTEL:\n\n        /* Reads as current EL value from pstate, which is\n\n         * guaranteed to be constant by the tb flags.\n\n         */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        tcg_gen_movi_i64(tcg_rt, s->current_el << 2);\n\n        return;\n\n    case ARM_CP_DC_ZVA:\n\n        /* Writes clear the aligned block of memory which rt points into. */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        gen_helper_dc_zva(cpu_env, tcg_rt);\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        gen_io_start();\n\n    }\n\n\n\n    tcg_rt = cpu_reg(s, rt);\n\n\n\n    if (isread) {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            tcg_gen_movi_i64(tcg_rt, ri->resetvalue);\n\n        } else if (ri->readfn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_get_cp_reg64(tcg_rt, cpu_env, tmpptr);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_ld_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    } else {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            /* If not forbidden by access permissions, treat as WI */\n\n            return;\n\n        } else if (ri->writefn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_set_cp_reg64(cpu_env, tmpptr, tcg_rt);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_st_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        /* I/O operations must end the TB here (whether read or write) */\n\n        gen_io_end();\n\n        s->is_jmp = DISAS_UPDATE;\n\n    } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n        /* We default to ending the TB on a coprocessor register write,\n\n         * but allow this to be suppressed by the register definition\n\n         * (usually only necessary to work around guest bugs).\n\n         */\n\n        s->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n", "idx": 17082, "substitutes": {"s": ["ls", "is", "sts", "ains", "sv", "rs", "ins", "as", "scl", "sw", "changes", "south", "a", "c", "h", "sq", "sm", "js", "i", "os", "ss", "sc", "serv", "ies", "y", "ns", "r", "e", "ms", "ats", "ts", "m", "sys", "its", "es", "v", "ties", "n", "ctx", "sb", "stats", "ds", "an", "ses", "S", "gs", "cs", "ps", "t", "fs", "hs", "j", "p"], "insn": ["rsn", "nsnv", "nsn", "arsnw", "nsc", "insnv", "insnw", "arsn", "insc", "nsnw", "arsnv", "rsnv", "rsnw", "arsc", "rsc"], "isread": ["iswrite", "isRead", "isreader", "bisreader", "isfread", "Isreader", "Isread", "bisread", "tiswrite", " indisreadable", "iREAD", "isreading", "isREAD", " isreadable", "ireader", " isREAD", "Iswrite", " isreading", "isfreadable", " indiswrite", "miswrite", "bisreadable", "tisreadable", "misreading", "ISwrite", "tisread", "Isreadable", " indisRead", "ISread", "IsRead", "IsREAD", "misread", "isfwrite", " iswrite", "ISreader", "iread", "tisreader", "misreadable", " indisread", " isreader", "isreadable", "iwrite", "isfreading", "ISreadable", " isRead"], "op0": ["tip0", "top1", "oper1", "op00", "oper02", "hop0", "cop5", "rop25", "oper5", "hop1", "OP25", "rop1", " op02", "tip1", "OP2", "top00", "OP00", "oper00", "op25", "top0", "rop0", "tip02", "cop00", "oper0", "OP1", "OP0", " op25", "rop2", "op5", "cop0", "top5", "hop2", "hop00", "cop1", " op00", "op02"], "op1": ["top1", "iop51", " op01", "opp51", "oom16", "pop1", "top2", "OP01", "oom1", "pop2", "op51", "OP2", " op3", "opp2", "iop1", "op01", "iop3", "pop01", "pop3", "op16", " op51", "op3", "iop0", "OP16", "pop0", "oom2", "oom01", "OP1", "opp1", "opp3", "top16", "opp0", "opp01", "top01"], "op2": ["OP6", "hop3", "ops4", "pop1", "oper3", " op02", "pop2", "OP2", "Op6", " op3", "ops2", "op3", "oop6", "ops02", "OP02", "pop0", "OP3", "pop02", "Op2", "oper0", "oper6", "OP0", "OP1", "op6", "Op4", "ops3", " op4", "hop4", "Op3", "op4", "hop02", "oper2", "hop2", " op6", "oop4", "op02", "oop3", "oop2"], "crn": ["prns", "ocrw", "crl", "crns", "ocrn", " crnt", "CrN", "cyn", "Crn", "crnt", "ocrns", "ctrm", "crg", "rcn", "trm", "ctrns", "prw", "ctrn", "ocrm", "rcN", " crw", "prn", "ctrl", "crw", "rcns", "prm", "rcm", " crN", "ocrnt", "trn", "cyns", "rcg", "Crg", "Crm", " crg", "trl", "rcnt", "cym", "crN", "trns", "cyl", " crns"], "crm": ["solm", "crv", "crnm", "sprm", "Crnm", " crml", "prl", "crl", "ocrn", "cher", "chemn", "chenm", " crpm", "ocrl", "prmt", " crr", "soln", "Crmn", "prv", "crmt", "sprn", "crmn", "solv", "crml", "solpm", "ocrm", "sprml", " crnm", "prn", "prpm", " crv", "crr", " crmn", "prm", "ocrmt", "crpm", "Crm", "Crr", "prml", " crl", " crmt", "chem"], "rt": ["rid", "tm", "tri", "reg", "tt", "rf", "rs", "vr", "tx", "rx", "rc", "rl", "ret", "dt", "ro", "rb", "RT", "rr", "tc", "sr", "r", "src", "rat", "rw", "pt", "sys", "irt", "rec", "ctx", "ct", "ti", "rot", "rd", "it", "vt", "rm", "nt", "rin", "addr", "ptr", "mt", "t", "wt", "rn"], "ri": ["rid", "tri", "reci", "rik", "iri", "rf", "ir", "xi", "ki", "rx", "stri", "ai", "RI", "rob", "i", "uti", "li", "ria", "ro", "io", "ris", "ico", "pi", "ric", "re", "ni", "rir", "cu", "ci", "wi", "rio", "ra", "ati", "vi", "udi", "ii", "ti", "rie", "fi", "ru", "rip", "iro", "uri", "di", "rom", "mi", "adr", "hi", "rin", "ara", "via", "ini", "co", "rise", "si", "ry"], "tcg_rt": ["tcge_rt", "tcG_rl", "tcg__rel", "tcg___rl", "tcg_addr", "tcg_RT", "tcg_rel", "tcgi__vr", "tcg__RT", "tcg__vr", "tcfg_vt", "tcgi__rt", "tcgi_rel", "tcg_pt", "tcg_tx", "tcg___fr", "tcg_fr", "tcG__rt", "tcgi_rt", "tcfg_rec", "tcg_rn", "tcgi_vr", "tcG__rl", "tcg__tx", "tcfg_rt", "tcgi__rel", "tcfg_rn", "tcG_tx", "tcg__fr", "tcG_rt", "tcg___tx", "tcg_rec", "tcg_rl", "tcg__rl", "tcg_vt", "tcgi_RT", "tcG__fr", "tcgi__RT", "tcg__rt", "tcg_vr", "tcG__tx", "tcge_RT", "tcg___rt", "tcge_addr", "tcG_fr", "tcge_pt"], "tmpptr": ["htmipptr", "tmppTr", "tmPPpr", "simpptr", "tmPPTr", "tcppsmt", "simPPt", "tmppsTR", "tmpsTR", "tmPPptr", " tempppr", "tmppTR", "tmpsmt", "tmppvr", "htmppvr", "htmppTR", "tmpxt", "tmmktr", "tmppsmt", "simPPptr", " tempptr", "tmpxTR", "htmippTR", " tempxpr", "simppt", " temppgr", "tcppth", "tmippt", "simppdr", "tmppdr", "tmmkmt", "tmppgr", "tmppmt", "tmmkth", "tmpxpr", " tempxtr", "htmippvr", " tempxTr", "tmptTR", "tmmpt", "tcpptr", "tcppsth", "tmmppr", "tmmpgr", "tcppstr", "tmppth", "htmpptr", "tmppptr", "tmippdr", "tcppTR", "tmppstr", "tmippvr", "tmmptr", "tmPPdr", "tmmpTr", "tmpttr", "tcppmt", " tempxgr", "tmippptr", "tmppsth", "tcppsTR", "tmpppr", "tmipptr", "tmmpdr", "simPPtr", "tmPPtr", "tmpstr", "tmpxvr", "tmptt", "tmPPgr", "tmppt", "tmippTR", "htmppt", "tmPPt", "tmpsth", "htmippt", "tmpxgr", "tmpxtr", "tmpxTr", "tmmkTR", "tmmpptr", " temppTr", "simPPdr", "tmptvr", "simppptr"], "tcg_syn": ["tcmg_mn", "tcg_icon", "tcg_sy", "tcg_trans", "tcg____syn", "tcmg___sym", "tcg___win", "tcg_sym", "tcmg___syn", "tcgb_sn", "tcmg___yn", "tcog_sim", "tcg____sim", "tcg____sn", "tcog_syn", "tcog_rec", "tcgb____sn", "tcg___trans", "tcsg_trans", "tcg_sim", "tcsg___trans", "tcsg___icon", "tcsg_icon", "tcmg_syn", "tcgb____syn", "tcg_win", "tcgb____sy", "tcg___mn", "tcsg___syn", "tcog_chron", "tcg___yn", "tcg_chron", "tcg_rec", "tcg_sn", "tcsg_syn", "tcg___icon", "tcg___sym", "tcmg___mn", "tcgb_syn", "tcgb____sim", "tcmg_yn", "tcg___syn", "tcg_mn", "tcsg___win", "tcsg_win", "tcgb_sy", "tcgb_sim", "tcmg_sym", "tcg____sy", "tcg_yn"], "syndrome": ["syrdolor", "syndrace", "syundrome", "sycondropy", "symdrome", "syddrone", "syntrome", "sycondrone", "cyndrone", "cyntrome", "Syddrace", "cyndrom", "syntroma", "Syndolor", "syundroma", "symdrom", "Syntrome", "cyntrone", "syndrom", "Syntolor", "syrdroma", "syddropy", "syundrace", "Syndrome", "syundrom", "syrdrome", "sycondrom", "syndroma", "Syndrom", "syntrace", "cyntrom", "syrdrom", "syntolor", "Syndrace", "Syddroma", "symdroma", "syddroma", "syndolor", "syndrone", "Syddrome", "syntrom", "Syntroma", "symdolor", "sycondrome", "Syddrom", "syntropy", "syddrom", "cyndropy", "syntrone", "Syntrom", "syddrace", "cyntropy", "syndropy", "syddrome", "Syndroma", "cyndrome"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n", "idx": 17085, "substitutes": {"data": ["window", "from", "block", "initial", "cache", "entry", "map", "info", "valid", "json", "def", "ata", "device", "read", "load", "mu", "dat", "reader", "session", "da", "group", "table", "d", "zero", "accept", "DATA", "join", "Data", "state", "db", "normal", "with", "raw", "image", "input", "partial", "batch"], "json_string": ["jsonletString", "json_data", "jsonitydata", "json_block", "json_String", "jsonitystring", "son_block", "json_component", " json_str", " json_String", "jsonletstring", "json1data", "json_str", "json1format", " json_component", "json1block", "son_format", "jsonityformat", "json1string", "son_string", "jsonletstr", "json_format", "jsonletcomponent", "son_data", "jsonityblock"]}}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n", "idx": 17092, "substitutes": {"mon": ["demon", "mut", "mill", "cond", "mos", "mm", "mitter", "man", "mont", "dat", "tem", "dm", "pers", "wat", "dem", "mons", "monitor", "den", "MON", "sim", "Mon", "meter", "ston", "mat", "mn", "dom", "met", "jon", "dis", "ran", "mun", "an", "ann", "mi", "sam", "mt", "admin", "san"]}}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 17101, "substitutes": {"ivgen": ["actgeneration", "ivGen", "actgen", "iveget", "ivgd", " ivlen", "ivegd", " ivstore", "evlen", "ivegener", "iverange", "ivconfig", "evgd", "iveGen", " ivgener", "ivemsg", " ivbuild", "evgen", "ivdef", "IVmsg", "actgener", "iverconfig", "ivgate", "ivmsg", "IVgeneration", " ivgate", " ivgeneration", "ivergener", "ivergen", "actconfig", "ivedef", "ivgeneration", " ivmsg", "evgener", "ivget", "ivlen", "ivstore", "ivergeneration", "actdef", "iveconfig", "ivgener", "iverdef", "iverget", "ivegeneration", "actget", " ivGen", "ivegen", " ivrange", "ivrange", "ivergate", "ivestore", "iverGen", "ivermsg", "iverstore", "ivbuild", "IVbuild", "IVgen", " ivgd", "ivelen", "iverbuild", "ivegate", "iverrange"], "key": ["act", "box", "ice", "chain", "a", "KEY", "icon", "password", "seed", "ay", "i", "y", "ip", "sk", "iv", "by", "air", "query", "check", "ey", "ke", "id", "v", "k", "Key", "mk", "data", "x", "ek", "et", "pair", "mac", "source", "keys", "ch", "hash", "name", "p"], "nkey": [" ntime", "snKey", "niv", "ynhash", "pnkey", "sntime", "ntime", "snhash", "ynmix", "ynkey", "nmix", "NKey", "pniv", "pnmix", "nKey", "Nkey", "yniv", " nmix", "snkey", "pnhash", "Ntime", " nKey", " niv", "Nhash"], "errp": [" errping", "errping", " erP", "lerr", "errorr", " erh", "err", "errpc", " errP", "lerpc", " erping", " erp", "errorp", " errpa", "lerpp", "errpa", "erps", "lerp", "eorr", "errps", "eorpa", " errps", "errorh", "errh", "errorpp", "erpa", "errpp", "errorping", "eorps", "eorp", " errh", " errpc", "errP", "errorP", " errpp", "erp", "errorpc", "errr", " errr"], "salt": ["samp", " salted", "asodium", "sall", "ssodium", " sALT", "Sref", "ssamp", "sref", "SALT", "asalt", "sass", "sALT", "siv", "nsodium", "nsass", "nsig", "sodium", " sref", " sig", "nsall", "Sass", "asALT", "nsiv", "sig", " siv", "salted", "nsref", " sass", " sall", "ssalt", "asiv", " samp", "nsALT", "Salt", "ssalted", " sodium"], "nhash": ["dhash", "nfilter", "snHash", "onhandle", "nufilter", "csum", "ntrust", "snfilter", "dhex", "nsearch", "nukey", "dsum", "nhandle", "nhex", "nmessage", " nsum", "snmac", "cnmessage", "Ntrust", "ncsearch", "chash", "snhash", "snmessage", "nchash", "nutrust", "nuHash", "msearch", "numac", "Nh", "cnhash", "dkey", "sntrust", "Nhandle", "onkey", "cnkey", "nmac", "nusearch", "onh", "nckey", "cnmac", "nuhash", "Nkey", "Nfilter", " nhex", "NHash", "dmessage", "mhash", " nhandle", "chex", " nh", "nh", "ncmac", "ckey", "mmac", "snkey", "onhash", "nsum", "nHash", "mkey", "dmac", "Nhash"], "nsalt": ["NSalt", "nisalted", "nsplain", "nsalted", "unsig", "nsort", " nsole", " nshot", "netsort", "nsnum", "NSash", "NSole", " nsort", "nsig", "unsal", " nsal", " nsplain", "nisalt", "stsig", "nishot", "nameshot", " nsig", "netsole", "nsul", "namesalted", "unsplain", "NSalted", "nsole", "stsal", "stsplain", "namesnum", "nshot", "nasalt", "namesalt", " nsul", "nasalted", " nsnum", "nasash", "nsash", "netsalt", "stsalt", "nasort", "unsalt", " nsalted", "nasole", "nisnum", "nsal", " nsash", "nasul", "netsul"], "essiv": ["ensiv", "essedvv", "essesive", " essiva", "hessiver", "esive", "essij", "ssiv", "essesistor", "essediv", "ensivation", "hessiv", "cessiv", "essedivation", "esiv", "essediver", "ccessive", "ccessistor", "essistor", "ossiv", "ssistor", "ossive", "hessiov", "cessive", "hessistor", "ccessiver", "essiver", "ssiver", "hessive", "accessiver", "essedij", "essesiver", "ssive", "ensiver", "essive", "ssiva", "cessistor", "essiov", "accessiv", "esiver", " essive", "ossiva", "ensvv", "accessivation", "accessvv", "hessij", "cessiva", " essiver", "ossiver", "essvv", "essivation", "assiov", "essediov", "esistor", "ccessiv", "assij", "essesiv", "ensive", "ensiva", "essiva", "cessiver", "assiv", "assiver"]}}
{"project": "FFmpeg", "commit_id": "bb6f51aeab88a252cf08f5a0ec26ab41ae2d74a2", "target": 1, "func": "static void mpeg1_encode_sequence_header(MpegEncContext *s)\n\n{\n\n        unsigned int vbv_buffer_size;\n\n        unsigned int fps, v;\n\n        int n;\n\n        UINT64 time_code;\n\n        \n\n        if ((s->picture_number % s->gop_size) == 0) {\n\n            /* mpeg1 header repeated every gop */\n\n            put_header(s, SEQ_START_CODE);\n\n            \n\n            /* search closest frame rate */\n\n            {\n\n                int i, dmin, d;\n\n                s->frame_rate_index = 0;\n\n                dmin = 0x7fffffff;\n\n                for(i=1;i<9;i++) {\n\n                    d = abs(s->frame_rate - frame_rate_tab[i]);\n\n                    if (d < dmin) {\n\n                        dmin = d;\n\n                        s->frame_rate_index = i;\n\n                    }\n\n                }\n\n            }\n\n \n\n            put_bits(&s->pb, 12, s->width);\n\n            put_bits(&s->pb, 12, s->height);\n\n            put_bits(&s->pb, 4, 1); /* 1/1 aspect ratio */\n\n            put_bits(&s->pb, 4, s->frame_rate_index);\n\n            v = s->bit_rate / 400;\n\n            if (v > 0x3ffff)\n\n                v = 0x3ffff;\n\n            put_bits(&s->pb, 18, v);\n\n            put_bits(&s->pb, 1, 1); /* marker */\n\n            /* vbv buffer size: slightly greater than an I frame. We add\n\n               some margin just in case */\n\n            vbv_buffer_size = (3 * s->I_frame_bits) / (2 * 8);\n\n            put_bits(&s->pb, 10, (vbv_buffer_size + 16383) / 16384); \n\n            put_bits(&s->pb, 1, 1); /* constrained parameter flag */\n\n            put_bits(&s->pb, 1, 0); /* no custom intra matrix */\n\n            put_bits(&s->pb, 1, 0); /* no custom non intra matrix */\n\n\n\n            put_header(s, GOP_START_CODE);\n\n            put_bits(&s->pb, 1, 0); /* do drop frame */\n\n            /* time code : we must convert from the real frame rate to a\n\n               fake mpeg frame rate in case of low frame rate */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            time_code = s->fake_picture_number * FRAME_RATE_BASE;\n\n            s->gop_picture_number = s->fake_picture_number;\n\n            put_bits(&s->pb, 5, (UINT32)((time_code / (fps * 3600)) % 24));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / (fps * 60)) % 60));\n\n            put_bits(&s->pb, 1, 1);\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / fps) % 60));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code % fps) / FRAME_RATE_BASE));\n\n            put_bits(&s->pb, 1, 1); /* closed gop */\n\n            put_bits(&s->pb, 1, 0); /* broken link */\n\n        }\n\n\n\n        if (s->frame_rate < (24 * FRAME_RATE_BASE) && s->picture_number > 0) {\n\n            /* insert empty P pictures to slow down to the desired\n\n               frame rate. Each fake pictures takes about 20 bytes */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            n = ((s->picture_number * fps) / s->frame_rate) - 1;\n\n            while (s->fake_picture_number < n) {\n\n                mpeg1_skip_picture(s, s->fake_picture_number - \n\n                                   s->gop_picture_number); \n\n                s->fake_picture_number++;\n\n            }\n\n\n\n        }\n\n        s->fake_picture_number++;\n\n}\n", "idx": 17113, "substitutes": {"s": ["us", "is", "er", "as", "a", "c", "h", "args", "js", "y", "ies", "vs", "details", "ims", "ches", "tes", "stats", "qs", "ses", "less", "comments", "ers", "als", "eps", "aws", "sw", "xs", "ports", "ants", "ss", "sg", "ns", "events", "spec", "ms", "parts", "bis", "sports", "an", "w", "S", "results", "cs", "conf", "sis", "hs", "p", "sts", "ains", "rs", "ops", "sq", "self", "os", "pers", "my", "l", "m", "sb", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "settings", "search", "params", "r", "ats", "ts", "sys", "its", "se", "sql", "eds", "tests", "ds", "ps", "t", "fs", "es"], "vbv_buffer_size": ["vbv_buffer_length", "vbv_Buffer_Size", "vbv_buffer_number", "vbv_buffer_SIZE", "vbv_buffer_Size", "vbv_Buffer_length", "vbv_Buffer_SIZE", "vbv_Buffer_size"], "fps": ["f", "ls", "px", "bits", "ints", "eps", "fp", "aps", " frames", "js", "ports", "ips", "pps", "iles", "res", "vs", "bytes", "xp", "ns", "pins", "ims", "hz", "ms", "ats", "mins", "ts", "its", "Hz", "faces", "Mbps", "frames", "html", "photos", "points", "frame", "vals", "bps", "flags", "base", "seconds", "ps", "rates", "bs", "fs", "amps", "vp"], "v": ["f", "cv", "all", "sv", "bits", "g", "vv", "vr", "h", "ov", "q", "conv", "version", "y", "vs", "p", "V", "iv", "u", "ver", "lv", "r", "vol", "rev", "l", "m", "qv", "vi", "value", "b", "ev", "vid", "o", "ve", "wire", "va", "val", "x", "vc", "html", "uv", "nv", "mint", "w", "vt", "vo", "av", "current", "it", "tv", "inv", "dev", "t", "j", "vp"], "n": ["f", "ne", " len", "g", "nm", "na", " nan", " ns", "nn", "ns", "ni", "e", "l", "b", "o", " N", " fn", "nan", "x", "Ns", " m", "no", " ni", "N", "t", "z", "name", "p"], "time_code": ["time2rate", "time_Code", "Time_Code", "time67Code", " time_Code", "Time_page", " time_count", "timelynumber", "time_page", " time2code", " time2Code", " time_rate", "Time_code", "timelyCode", "time_number", "timelycode", "time2Code", "time67code", "time_codes", "timelypage", "time2codes", "Time_number", "time_count", "time_rate", "time2code", "time67count", "time2count", " time2count", " time_codes"], "i": ["us", "is", "bi", "gi", "ind", "init", "iter", "xi", "point", "ai", "info", "ini", "oi", "batch", "q", "li", "ui", "ic", "ip", "y", "\u0438", " ii", "ims", "pi", "iu", "qi", "im", "zi", "ci", "my", "ms", "l", "sim", "m", "me", "id", "index", "ji", "I", "ii", "ti", "print", "fi", "phi", "ix", "x", " x", "di", "uri", "it", "mi", " j", "ie", "hi", "t", "multi", "j", "si", "p"], "dmin": [" dmid", "pMin", "dMin", "dcMin", "Dm", "Dmins", "dcmid", " dMin", "Dmin", " dmax", "dcmin", "ponly", "DMin", "dmax", "Dmid", "dcmax", "adMin", "dm", "djmins", "djm", "Donly", " dminimum", "dminimum", "djmin", "pminimum", "donly", " dmins", "dmid", "dmins", "adminute", "Dminimum", "pmin", "djMin", "Dminute", "dminute", " dm", " dminute", " donly", "admin", "Dmax"], "d": ["f", "fd", "done", "did", "g", "dra", "dy", "ind", "du", "df", "bd", "dn", "delay", "min", "dl", "dot", "des", "digit", "dq", "def", "day", "dt", "dim", "diff", "del", "D", "dos", "dist", "sd", "dat", "dL", "da", "ded", "dm", "dh", "l", "m", "dj", "dd", "dom", "md", "db", "de", "ds", "deg", "di", "dr", "dev", "dig", "t", "dp", "pd", "cd", "p"], "fake_picture_number": ["fake_picture_name", "fake_picture__number", "fake_picture__num", "fake_picture_code", "fake_photo_code", "fake_photo_name", "fake_picture__no", "fake_photo_no", "fake_picture__name", "fake_photo_number", "fake_picture_no", "fake_picture_num", "fake_picture__code", "fake_photo_num"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n", "idx": 17118, "substitutes": {"dst": ["Dest", "rdest", "fdst", "dsv", "Dv", "fddest", "dssrc", "rpt", " dsrc", "dsest", "dv", "rst", " ddest", "fdpt", " dv", "dest", " dpt", "ddest", "dpt", " dest", "fdest", "Dst", "Dsrc", "rest", "dsrc", "dsst"], "src": ["rt", "sl", "ser", "rs", "st", "ctr", "sn", "ind", "ins", "sec", "sq", "rc", "rl", "gin", "inner", "usc", "dq", "urg", "cont", "sc", "comp", "in", "img", "iv", "dist", "loc", "inst", "sr", "r", "ur", "sys", "now", "dest", "cc", "b", "txt", "hl", "sb", "s", "str", "req", "cur", "RC", "uint", "supp", "source", "addr", "start", "input", "ptr"], "stride": ["STRiding", "drime", "STRide", "Stride", "slide", "Strend", "streamide", " stripe", "Stripe", "constide", "striding", "trider", "streamipe", "prividing", " strride", "slipe", "trides", "stripe", "drride", "strid", "constride", "dride", "streamride", "privride", " strange", "STRid", " strides", "Strride", " striding", "strime", "strend", "streamend", "privange", "STRides", "STRride", " strend", "dripe", "slime", "strride", " strider", "constider", "strides", "constime", "strider", "trid", "STRime", "privide", "tride", "slride", "strange", "STRange", " strime", " strid", "STRider"]}}
{"project": "FFmpeg", "commit_id": "57cd2f7777a316a447301a7d4b5d1c01da200661", "target": 0, "func": "static av_cold int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, h264_id, mps_id, ac3_id, dts_id, lpcm_id, j;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n    int audio_bitrate;\n\n    int video_bitrate;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd   =  (CONFIG_MPEG1VCD_MUXER  && ctx->oformat == &ff_mpeg1vcd_muxer);\n\n    s->is_svcd  =  (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer);\n\n    s->is_mpeg2 = ((CONFIG_MPEG2VOB_MUXER  && ctx->oformat == &ff_mpeg2vob_muxer) ||\n\n                   (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer) ||\n\n                   (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer));\n\n    s->is_dvd   =  (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer);\n\n\n\n    if (ctx->packet_size) {\n\n        if (ctx->packet_size < 20 || ctx->packet_size > (1 << 23) + 10) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Invalid packet size %d\\n\",\n\n                   ctx->packet_size);\n\n            goto fail;\n\n        }\n\n        s->packet_size = ctx->packet_size;\n\n    } else\n\n        s->packet_size = 2048;\n\n    if (ctx->max_delay < 0)     /* Not set by the caller */\n\n        ctx->max_delay = AV_TIME_BASE*7/10;\n\n\n\n    s->vcd_padding_bytes_written = 0;\n\n    s->vcd_padding_bitrate_num   = 0;\n\n\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n\n\n    mpa_id  = AUDIO_ID;\n\n    ac3_id  = AC3_ID;\n\n    dts_id  = DTS_ID;\n\n    mpv_id  = VIDEO_ID;\n\n    h264_id = H264_ID;\n\n    mps_id  = SUB_ID;\n\n    lpcm_id = LPCM_ID;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        st     = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        avpriv_set_pts_info(st, 64, 1, 90000);\n\n\n\n        switch (st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (!s->is_mpeg2 &&\n\n                (st->codec->codec_id == AV_CODEC_ID_AC3 ||\n\n                 st->codec->codec_id == AV_CODEC_ID_DTS ||\n\n                 st->codec->codec_id == AV_CODEC_ID_PCM_S16BE))\n\n                 av_log(ctx, AV_LOG_WARNING,\n\n                        \"%s in MPEG-1 system streams is not widely supported, \"\n\n                        \"consider using the vob or the dvd muxer \"\n\n                        \"to force a MPEG-2 program stream.\\n\",\n\n                        avcodec_get_name(st->codec->codec_id));\n\n            if (st->codec->codec_id == AV_CODEC_ID_AC3) {\n\n                stream->id = ac3_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_DTS) {\n\n                stream->id = dts_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_PCM_S16BE) {\n\n                stream->id = lpcm_id++;\n\n                for (j = 0; j < 4; j++) {\n\n                    if (lpcm_freq_tab[j] == st->codec->sample_rate)\n\n                        break;\n\n                }\n\n                if (j == 4)\n\n                    goto fail;\n\n                if (st->codec->channels > 8)\n\n                    return -1;\n\n                stream->lpcm_header[0] = 0x0c;\n\n                stream->lpcm_header[1] = (st->codec->channels - 1) | (j << 4);\n\n                stream->lpcm_header[2] = 0x80;\n\n                stream->lpcm_align     = st->codec->channels * 2;\n\n            } else {\n\n                stream->id = mpa_id++;\n\n            }\n\n\n\n            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).\n\n             * Right now it is also used for everything else. */\n\n            stream->max_buffer_size = 4 * 1024;\n\n            s->audio_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (st->codec->codec_id == AV_CODEC_ID_H264)\n\n                stream->id = h264_id++;\n\n            else\n\n                stream->id = mpv_id++;\n\n            if (st->codec->rc_buffer_size)\n\n                stream->max_buffer_size = 6 * 1024 + st->codec->rc_buffer_size / 8;\n\n            else {\n\n                av_log(ctx, AV_LOG_WARNING,\n\n                       \"VBV buffer size not set, using default size of 130KB\\n\"\n\n                       \"If you want the mpeg file to be compliant to some specification\\n\"\n\n                       \"Like DVD, VCD or others, make sure you set the correct buffer size\\n\");\n\n                // FIXME: this is probably too small as default\n\n                stream->max_buffer_size = 230 * 1024;\n\n            }\n\n            if (stream->max_buffer_size > 1024 * 8191) {\n\n                av_log(ctx, AV_LOG_WARNING, \"buffer size %d, too large\\n\", stream->max_buffer_size);\n\n                stream->max_buffer_size = 1024 * 8191;\n\n            }\n\n            s->video_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            stream->id              = mps_id++;\n\n            stream->max_buffer_size = 16 * 1024;\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n        stream->fifo = av_fifo_alloc(16);\n\n        if (!stream->fifo)\n\n            goto fail;\n\n    }\n\n    bitrate       = 0;\n\n    audio_bitrate = 0;\n\n    video_bitrate = 0;\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        int codec_rate;\n\n        st     = ctx->streams[i];\n\n        stream = (StreamInfo *)st->priv_data;\n\n\n\n        if (st->codec->rc_max_rate ||\n\n            st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            codec_rate = st->codec->rc_max_rate;\n\n        else\n\n            codec_rate = st->codec->bit_rate;\n\n\n\n        if (!codec_rate)\n\n            codec_rate = (1 << 21) * 8 * 50 / ctx->nb_streams;\n\n\n\n        bitrate += codec_rate;\n\n\n\n        if ((stream->id & 0xe0) == AUDIO_ID)\n\n            audio_bitrate += codec_rate;\n\n        else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            video_bitrate += codec_rate;\n\n    }\n\n\n\n    if (s->user_mux_rate) {\n\n        s->mux_rate = (s->user_mux_rate + (8 * 50) - 1) / (8 * 50);\n\n    } else {\n\n        /* we increase slightly the bitrate to take into account the\n\n         * headers. XXX: compute it exactly */\n\n        bitrate    += bitrate / 20;\n\n        bitrate    += 10000;\n\n        s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n        if (s->mux_rate >= (1<<22)) {\n\n            av_log(ctx, AV_LOG_WARNING, \"mux rate %d is too large\\n\", s->mux_rate);\n\n            s->mux_rate = (1<<22) - 1;\n\n        }\n\n    }\n\n\n\n    if (s->is_vcd) {\n\n        int64_t overhead_rate;\n\n\n\n        /* The VCD standard mandates that the mux_rate field is 3528\n\n         * (see standard p. IV-6).\n\n         * The value is actually \"wrong\", i.e. if you calculate\n\n         * it using the normal formula and the 75 sectors per second transfer\n\n         * rate you get a different value because the real pack size is 2324,\n\n         * not 2352. But the standard explicitly specifies that the mux_rate\n\n         * field in the header must have this value. */\n\n        // s->mux_rate = 2352 * 75 / 50;    /* = 3528 */\n\n\n\n        /* The VCD standard states that the muxed stream must be\n\n         * exactly 75 packs / second (the data rate of a single speed cdrom).\n\n         * Since the video bitrate (probably 1150000 bits/sec) will be below\n\n         * the theoretical maximum we have to add some padding packets\n\n         * to make up for the lower data rate.\n\n         * (cf. VCD standard p. IV-6 ) */\n\n\n\n        /* Add the header overhead to the data rate.\n\n         * 2279 data bytes per audio pack, 2294 data bytes per video pack */\n\n        overhead_rate  = audio_bitrate * 2294LL * (2324 - 2279);\n\n        overhead_rate += video_bitrate * 2279LL * (2324 - 2294);\n\n\n\n        /* Add padding so that the full bitrate is 2324*75 bytes/sec */\n\n        s->vcd_padding_bitrate_num = (2324LL * 75 * 8 - bitrate) * 2279 * 2294 - overhead_rate;\n\n#define VCD_PADDING_BITRATE_DEN (2279 * 2294)\n\n    }\n\n\n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n        s->pack_header_freq = 1;\n\n\n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* the standard mandates that there are only two system headers\n\n         * in the whole file: one in the first packet of each stream.\n\n         * (see standard p. IV-7 and IV-8) */\n\n        s->system_header_freq = 0x7fffffff;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        stream                = ctx->streams[i]->priv_data;\n\n        stream->packet_number = 0;\n\n    }\n\n    s->system_header_size = get_system_header_size(ctx);\n\n    s->last_scr           = AV_NOPTS_VALUE;\n\n    return 0;\n\n\n\nfail:\n\n    for (i = 0; i < ctx->nb_streams; i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 17120, "substitutes": {"ctx": ["cv", "c", "setup", "etc", "jac", "np", "kt", "inst", "check", "aka", "wp", "grad", "cas", "req", "tz", "cmp", "co", "dc", "proc", "cf", "act", "hw", "tx", "std", "xs", "rx", "mc", "dt", "cp", "obj", "cb", "cu", "wcs", "context", "alloc", "cmd", "aus", "nt", "conf", "cfg", "tnc", "conn", "pkg", "cm", "except", "conv", "loc", "wx", "tc", "ka", "resp", "kw", "txt", "ct", " cx", "bc", "ctrl", "prefix", "desc", "x", "pool", "aux", "crit", "config", "ref", "Context", "that", "jp", "kl", "fc", "anc", "abc", "ck", "func", "sc", "xp", "gc", "unc", "nc", "sys", "cc", "ctl", "xc", "github", "ann", "nih", "addr", "timeout"], "s": ["is", "sn", "c", "js", "y", "vs", "details", "ims", "ids", "v", "utils", "stats", "qs", "less", "status", "als", "aws", "sw", "ports", "ss", "sg", "ns", "spec", "ms", "actions", "bis", "sports", "services", "S", "results", "cs", "rates", "hs", "p", "sts", "g", "rs", "sq", "q", "os", "set", "pers", "m", "locks", "sb", "x", "gs", "ows", "bs", "ls", "sv", "ins", "scl", "so", "changes", "settings", "su", "ats", "ts", "its", "sets", "b", "se", "uploads", "ds", "csv", "ps", "t", "fs", "es"], "bitrate": ["Bitrate", "bandrates", " bitwidth", "bitrates", "BitRate", "bandwidth", "Bitrates", "bitRate", "bandRate", "Bitwidth", "bandrate", " bitrates", " bitRate", "bitwidth"], "i": ["f", "ir", "a", "c", "ia", "ip", "y", "io", "pi", "iu", "e", "ci", "l", "m", "id", "index", "b", "v", "I", "n", "ii", "ti", "it", "mi", "ij", "t", "p"], "mpa_id": ["mpba_info", "mpbaoename", "mpba_mid", "mpa___id", "mpa___type", "mpa_info", "mpba_name", "mpa_mid", "mpa___name", "mpaoemid", "mpba_id", "mpaoename", "mpo_id", "mpaoeid", "mpo_ID", "mpa_ID", "mpbaoemid", "mpaoeinfo", "mpbaoeid", "mpa___info", "mpa_name", "mpo_type", "mpa___ID", "mpbaoeinfo", "mpa_type", "mpa___mid"], "mpv_id": ["mpv_no", "mpb_ID", "mpv_mid", "mpv_ID", "mpb_mid", "mpb_no", "mpb_id"], "h264_id": ["h264__ids", "hv_ID", "hv_name", "hv_ids", "h264__id", "h264_ID", "h264__ID", "hv_id", "h264_ids", "h264__name", "h264_name"], "mps_id": ["mcs_ids", "mcs_type", "mpsetid", "mpsgids", "mpsgmid", "mps_mid", "mpsgtype", "mpsetids", "mps_type", "mcs_id", "mpsettype", "mpsetmid", "mpsgid", "mcs_mid", "mps_ids"], "ac3_id": ["ac3___id", "ac3_m", "acd_mid", "acd_db", "ac3___ids", "ac3_db", "ac3___db", "acd_ids", "ac3___type", "acd_m", "acd_id", "ac3_mid", "acd_type", "ac3_type", "ac3_ids"], "dts_id": ["new", "dss__ID", "dts_ID", "dss_ID", "config", "_", "dss_ids", "dss_id", "dts__ID", "dss_mid", "dts__id", "func", "def", "dss__mid", "conv", "dss__id", "dts__ids", "call", "dts_mid", "dtsgids", "ctl", "dtsgmid", "jpg", "cmd", "dss__ids", "dts_ids", "dtsgID", "dts__mid", "cmp", "dtsgid"], "lpcm_id": ["lpm_ids", "lpm_ID", "lpcm_ids", "lpm_num", "lpcm_ID", "lpm_id", "lpcm_num"], "j": ["f", "jump", "J", "g", "jp", "jc", "js", "json", "kj", "q", "jj", "p", "l", "m", "ji", "b", "v", "k", "n", "dj", "o", "gm", "uj", "jit", "ij", "z", "job"], "st": ["tmp", "sl", "us", "th", "sts", "sv", "sn", "sw", "ste", "std", "sm", "sta", "ss", "sc", "serv", "sth", "inst", "St", "sp", "ST", "ct", "se", "str", "mt", "ch", "sh", "rest", "ist"], "stream": ["sl", "sn", "sw", "video", "Stream", "tx", "cm", "info", "sc", "io", "iv", "spec", "src", "form", "ack", "v", "o", "instance", "ream", "REAM", "data", "ive", "status", " info"], "audio_bitrate": ["audio_boardrate", "audio_bitsnumber", "audio_byteRate", "audio_bitsrate", "audio_boardRate", "audio_byterate", "audio_bitRate", "audio_boardnumber", "audio_bytenumber", "audio_bitnumber", "audio_bitsRate"], "video_bitrate": ["video_bitram", "video_byterate", "video_minrate", "video_minram", "video_bitrace", "video_minRate", "video_byterace", "video_byteram", "video_bitRate", "video_minrace", "video_byteRate"], "audio_bound": ["audio_max", "audio_connected", "volume_max", "audio___bind", "audio___connected", "audio_bind", "volume_bind", "audio___max", "volume_connected", "volume_bound", "audio___bound"], "video_bound": ["video_position", "video_device", "channel_bind", "channel_device", "channel_bound", "channel_position", "video_bind"]}}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,\n\n                              int mm_flags)\n\n{\n\n    const int bit_depth      = avctx->bits_per_raw_sample;\n\n    const int high_bit_depth = bit_depth > 8;\n\n\n\n    c->prefetch = prefetch_mmx2;\n\n\n\n    if (!high_bit_depth) {\n\n        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;\n\n        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;\n\n        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;\n\n        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;\n\n\n\n        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;\n\n        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;\n\n        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;\n\n        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;\n\n    }\n\n\n\n    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {\n\n        if (!high_bit_depth) {\n\n            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;\n\n\n\n            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;\n\n            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;\n\n        }\n\n\n\n        if (CONFIG_VP3_DECODER && HAVE_YASM) {\n\n            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;\n\n            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;\n\n        }\n\n    }\n\n    if (CONFIG_VP3_DECODER && HAVE_YASM)\n\n        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;\n\n\n\n    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||\n\n                               avctx->codec_id == CODEC_ID_THEORA)) {\n\n        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;\n\n        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;\n\n    }\n\n\n\n    if (CONFIG_H264QPEL) {\n\n        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );\n\n\n\n        if (!high_bit_depth) {\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );\n\n        } else if (bit_depth == 10) {\n\n#if HAVE_YASM\n\n#if !ARCH_X86_64\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n#endif\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n#endif\n\n        }\n\n\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );\n\n    }\n\n\n\n#if HAVE_YASM\n\n    if (!high_bit_depth && CONFIG_H264CHROMA) {\n\n        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;\n\n    }\n\n    if (bit_depth == 10 && CONFIG_H264CHROMA) {\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;\n\n        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;\n\n    }\n\n\n\n    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;\n\n\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;\n\n\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;\n\n    } else {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext;\n\n    }\n\n#endif\n\n}\n", "idx": 17124, "substitutes": {"c": ["f", "cf", "lc", "cr", "config", "g", "cache", "chain", "cam", "C", "ca", "cm", "fc", "rc", "abc", "com", "anc", "mc", "cont", "ic", "cp", "sc", "etc", "gc", "unc", "tc", "enc", "e", "cu", "ci", "can", "ac", "pc", "l", "nc", "d", "con", "call", "check", "cc", "b", "ctx", "v", "ct", "bc", "xc", "uc", "ce", "coll", "ec", "w", "at", "cs", "t", "co", "conf", "arc", "dc", "z", "p"], "avctx": ["avhw", "avercv", "avtmp", "AVtmp", " avhw", "avectx", "avertxt", "navjac", "avejp", "averjp", "avejac", " avcontext", "navcontext", "AVctx", "averctx", "savcmp", "avjac", "navtxt", "avtxt", "averhw", "avercontext", "AVcontext", "AVcmp", "avjp", "avcv", "averjac", "navctx", " avtmp", " avcmp", "avcmp", "navhw", "avcontext", "savcontext", "savtmp", " avcv", "avetxt", "savctx", "navcv", "navjp"], "mm_flags": ["MM_flag", "MM_flags", "MM_features", "mm2flags", "mm2features", "mm2flag", "MM00Flags", "mm2Flags", "MM00flags", "mm00Flags", "mm_flag", "MM00flag", "mm00features", "mm00flags", "MM00features", "mm_Flags", "mm00flag", "MM_Flags", "mm_features"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        vseq->seq_parameter_set_id = 0;\n\n\n\n        vseq->level_idc = avctx->level;\n\n\n\n        vseq->max_num_ref_frames = 2;\n\n\n\n        vseq->picture_width_in_mbs  = priv->mb_width;\n\n        vseq->picture_height_in_mbs = priv->mb_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1;\n\n        vseq->seq_fields.bits.frame_mbs_only_flag = 1;\n\n        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;\n\n        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;\n\n        vseq->seq_fields.bits.pic_order_cnt_type = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            vseq->frame_cropping_flag = 1;\n\n\n\n            vseq->frame_crop_left_offset   = 0;\n\n            vseq->frame_crop_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            vseq->frame_crop_top_offset    = 0;\n\n            vseq->frame_crop_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            vseq->frame_cropping_flag = 0;\n\n        }\n\n\n\n        vseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1;\n\n            // There is a large enum of these which we could support\n\n            // individually rather than using the generic X/Y form?\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                vseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                vseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                vseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                vseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n\n            avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||\n\n            avctx->colorspace      != AVCOL_SPC_UNSPECIFIED) {\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format             = 5; // Unspecified.\n\n            mseq->video_full_range_flag    = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            // These enums are derived from the standard and hence\n\n            // we can just use the values directly.\n\n            mseq->colour_primaries         = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coefficients      = avctx->colorspace;\n\n        }\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n\n\n        vseq->vui_fields.bits.timing_info_present_flag = 1;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->num_units_in_tick = avctx->framerate.num;\n\n            vseq->time_scale        = 2 * avctx->framerate.den;\n\n            mseq->fixed_frame_rate_flag = 1;\n\n        } else {\n\n            vseq->num_units_in_tick = avctx->time_base.num;\n\n            vseq->time_scale        = 2 * avctx->time_base.den;\n\n            mseq->fixed_frame_rate_flag = 0;\n\n        }\n\n\n\n        if (ctx->va_rc_mode == VA_RC_CBR) {\n\n            priv->send_timing_sei = 1;\n\n            mseq->nal_hrd_parameters_present_flag = 1;\n\n\n\n            mseq->cpb_cnt_minus1 = 0;\n\n\n\n            // Try to scale these to a sensible range so that the\n\n            // golomb encode of the value is not overlong.\n\n            mseq->bit_rate_scale =\n\n                av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4);\n\n            mseq->bit_rate_value_minus1[0] =\n\n                (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1;\n\n\n\n            mseq->cpb_size_scale =\n\n                av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4);\n\n            mseq->cpb_size_value_minus1[0] =\n\n                (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1;\n\n\n\n            // CBR mode isn't actually available here, despite naming.\n\n            mseq->cbr_flag[0] = 0;\n\n\n\n            mseq->initial_cpb_removal_delay_length_minus1 = 23;\n\n            mseq->cpb_removal_delay_length_minus1         = 23;\n\n            mseq->dpb_output_delay_length_minus1          = 7;\n\n            mseq->time_offset_length = 0;\n\n\n\n            // This calculation can easily overflow 32 bits.\n\n            mseq->initial_cpb_removal_delay = 90000 *\n\n                (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness /\n\n                priv->hrd_params.hrd.buffer_size;\n\n\n\n            mseq->initial_cpb_removal_delay_offset = 0;\n\n        } else {\n\n            priv->send_timing_sei = 0;\n\n            mseq->nal_hrd_parameters_present_flag = 0;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->CurrPic.picture_id = VA_INVALID_ID;\n\n        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {\n\n            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;\n\n            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;\n\n        }\n\n\n\n        vpic->coded_buf = VA_INVALID_ID;\n\n\n\n        vpic->pic_parameter_set_id = 0;\n\n        vpic->seq_parameter_set_id = 0;\n\n\n\n        vpic->num_ref_idx_l0_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_active_minus1 = 0;\n\n\n\n        vpic->pic_fields.bits.entropy_coding_mode_flag =\n\n            ((avctx->profile & 0xff) != 66);\n\n        vpic->pic_fields.bits.weighted_pred_flag = 0;\n\n        vpic->pic_fields.bits.weighted_bipred_idc = 0;\n\n        vpic->pic_fields.bits.transform_8x8_mode_flag =\n\n            ((avctx->profile & 0xff) >= 100);\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n    }\n\n\n\n    {\n\n        mseq->profile_idc = avctx->profile & 0xff;\n\n\n\n        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)\n\n            mseq->constraint_set1_flag = 1;\n\n        if (avctx->profile & FF_PROFILE_H264_INTRA)\n\n            mseq->constraint_set3_flag = 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17128, "substitutes": {"avctx": ["vcfg", "AVconn", "svcmp", "varconf", "cvcmp", "avtx", "cvcontext", "vardoc", "cvctx", "navconf", "vtx", " avcontext", "vrcfg", "svtx", "AVctx", "avconn", "vrdoc", " avtx", "avcfg", "varcfg", "AVcontext", "AVtx", "vrconf", "navctx", "svcontext", " avcmp", "vrctx", "avcmp", "avcontext", "avconf", "vcmp", "vcontext", "avdoc", "svcfg", " avconn", "vctx", "navdoc", "vrtx", "vconn", "cvtx", "varctx", "navcfg", "vrcontext", "svctx"], "ctx": ["org", "cv", "offic", "def", "setup", "etc", "iat", "np", "kt", "pb", "wp", "mk", "grad", "req", "mem", "auth", "cmp", "proc", "cf", "act", "hw", "tx", "xs", "root", "mc", "lbs", "cp", "net", "obj", "cb", "cu", "expr", "context", "alloc", "cmd", "pg", "phys", "aco", "nt", "conf", "cfg", "tmp", "conn", "pkg", "err", "util", "loc", "wx", "tc", "resp", "eu", "kw", "txt", "ct", "history", "bc", "kb", "policy", "prefix", "ctrl", "desc", "aux", "ptr", "fn", "comm", "rt", "ppo", "config", "that", "wordpress", "abc", "rc", "fc", "func", "urg", "xp", "doc", "gc", "unc", "handle", "rect", "sys", "ctl", "xc", "lib", "exec", "perm", "pri", "addr"], "vseq": ["svsequ", "vref", " vnext", " vsequence", "convseq", "varzip", "vdesc", "ftest", "vzip", "svbuf", "fzip", "vvtest", "vmcomp", " vdesc", "vreq", "convcoll", "varcrit", "svseq", "avvec", "convtest", "vmseq", "vmbuf", "vvec", "nvzip", "vstr", "vtdesc", "tvstruct", "evpse", "Vbuf", "verdesc", "vstruct", "nvseq", "avsequence", "invreq", "vvstruct", "invseq", "invvec", "nvpse", "avseq", "tvsel", "convsequence", "Vseq", "vcomp", " vref", "vmsequ", " vcomp", "invzip", "evsequ", "vmvec", " vqueue", "vervec", " vzip", "tvclus", "versim", " vcrit", "invsequence", "revdesc", "lbuf", "vtnext", "Vpse", "evtest", "fsequ", "Vsequ", "vtsequ", "vvsel", "wirezip", " vtest", "vtzip", " vvec", "vcoll", "fpse", "wiredesc", "evbuf", "varcoll", "revnext", "fvec", "evzip", " vbuf", "vvvec", "Vsequence", "svstr", "verseq", "fseq", "lsequ", "nvsequ", "tvseq", "wireseq", " vsel", "vsel", "vartest", "vtseq", "vvsequ", "Vtest", " vcoll", " vreq", "nvvec", "lseq", " vstruct", " vsequ", "vclus", " vpse", "vmstr", "revseq", "vvseq", "varseq", " vclus", "varbuf", "vpse", "vsequ", "Vzip", "freq", "avpse", "Vvec", "vsequence", "vmtest", "evqueue", "avsequ", "varqueue", "vnext", "Vstruct", "vbuf", "invprintf", "varsequence", "revzip", "varvec", "vsim", "lstruct", "Vref", "verzip", "varsequ", "versequence", "invref", "invsequ", "avcrit", " vstr", "wiresim", "varprintf", "svtest", "vvclus", "vqueue", "vcrit", "svcomp", " vsim", "vtest", "vttest", "evseq", "versequ"], "vpic": [" vfp", "avseq", "vfp", "mpict", "mfp", "avpict", "vpict", " vpict", "avfp", "mpic", "avpic"], "priv": ["proc", "org", "Priv", "prop", "attr", "config", "conn", "pkg", "cam", "sec", "tx", "err", "info", "pub", "pr", "Pri", "cap", "serv", "cp", "loc", "pi", "soc", "rel", "rev", "caps", "sp", "env", "txt", "eas", "pres", "policy", "alloc", "gov", "pg", "riv", "phys", "rot", "mem", "auth", "lib", "pro", "perm", "private", "pri", "dev", "rep", "conf", "cfg"], "mseq": [" mvec", "vmsequ", "mvec", "vmseq", "tseq", "vmsequence", " msequence", "msequ", "tvec", " msequ", "vmvec", "tsequ", "msequence", "tsequence"], "i": [" li", "a", "c", " out", "h", " init", "li", " ii", "im", " bi", "m", "id", " pi", "b", "v", "I", "n", " c", "ii", "ei", " l", "x", " j", "ij", "t", " gp", "j", "p"]}}
{"project": "qemu", "commit_id": "0d6ff71ae3c7ac3a446d295ef71884a05093b37c", "target": 0, "func": "void if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    bool from_batchq, next_from_batchq;\n\n    struct mbuf *ifm, *ifm_next, *ifqt;\n\n\n\n    DEBUG_CALL(\"if_start\");\n\n\n\n    if (slirp->if_start_busy) {\n\n        return;\n\n    }\n\n    slirp->if_start_busy = true;\n\n\n\n    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n        ifm_next = slirp->if_fastq.ifq_next;\n\n        next_from_batchq = false;\n\n    } else if (slirp->next_m != &slirp->if_batchq) {\n\n        /* Nothing on fastq, pick up from batchq via next_m */\n\n        ifm_next = slirp->next_m;\n\n        next_from_batchq = true;\n\n    } else {\n\n        ifm_next = NULL;\n\n    }\n\n\n\n    while (ifm_next) {\n\n        ifm = ifm_next;\n\n        from_batchq = next_from_batchq;\n\n\n\n        ifm_next = ifm->ifq_next;\n\n        if (ifm_next == &slirp->if_fastq) {\n\n            /* No more packets in fastq, switch to batchq */\n\n            ifm_next = slirp->next_m;\n\n            next_from_batchq = true;\n\n        }\n\n        if (ifm_next == &slirp->if_batchq) {\n\n            /* end of batchq */\n\n            ifm_next = NULL;\n\n        }\n\n\n\n        /* Try to send packet unless it already expired */\n\n        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {\n\n            /* Packet is delayed due to pending ARP resolution */\n\n            continue;\n\n        }\n\n\n\n        if (ifm == slirp->next_m) {\n\n            /* Set which packet to send on next iteration */\n\n            slirp->next_m = ifm->ifq_next;\n\n        }\n\n\n\n        /* Remove it from the queue */\n\n        ifqt = ifm->ifq_prev;\n\n        remque(ifm);\n\n\n\n        /* If there are more packets for this session, re-queue them */\n\n        if (ifm->ifs_next != ifm) {\n\n            struct mbuf *next = ifm->ifs_next;\n\n\n\n            insque(next, ifqt);\n\n            ifs_remque(ifm);\n\n\n\n            if (!from_batchq) {\n\n                /* Next packet in fastq is from the same session */\n\n                ifm_next = next;\n\n                next_from_batchq = false;\n\n            } else if (slirp->next_m == &slirp->if_batchq) {\n\n                /* Set next_m and ifm_next if the session packet is now the\n\n                 * only one on batchq */\n\n                slirp->next_m = ifm_next = next;\n\n            }\n\n        }\n\n\n\n        /* Update so_queued */\n\n        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {\n\n            /* If there's no more queued, reset nqueued */\n\n            ifm->ifq_so->so_nqueued = 0;\n\n        }\n\n\n\n        m_free(ifm);\n\n    }\n\n\n\n    slirp->if_start_busy = false;\n\n}\n", "idx": 17133, "substitutes": {"slirp": ["pliterc", "sslirpi", "slirpkg", "splarpad", "sslierpy", "scheirpid", "blirps", "sslpirpy", "slirapkg", "slierpid", "slrirpre", "plirq", "islirp", "slirpart", "slibrping", "slirapad", "slirpid", "sldirping", "slwarl", "spldirpress", "splwarpi", "slibrl", "sliterq", "slrirm", "slirops", "slpirpid", "slierpatch", "slvrpid", "slmirp", "sligrpress", "pliterping", "sliverp", "slmirpre", "slirlc", "slierc", "blibrpy", "sliterp", "islibrl", "blibrpc", "splarpid", "slibrpy", "slirq", "slwarr", "collirapad", "sslierl", "slirping", "sliryl", "slererpkg", "slirel", "dlirlp", "blibrps", "sldirpi", "slarpi", "blibrph", "slIRpy", "slirpatch", "collirapkg", "sligrp", "slrirph", "isldirp", "sliberc", "islirr", "sslirpy", "slirop", "slierpa", "sliercp", "slyrpart", "sliropatch", "slirpc", "sldirpa", "slyrpi", "plibrc", "slererpad", "slierpi", "sslierpi", "blibrpi", "blirpid", "slire_", "slarpe", "slirep", "slierq", "splarp", "slierpre", "slirlp", "slirpy", "slrirpa", "slpirpre", "slirpad", "slirpre", "splirpart", "islibrpress", "sslpirpi", "collirapar", "scheiverps", "sslirl", "slibr_", "sliverpid", "sslierp", "islibrp", "slererpar", "slirl", "pliterq", "sliberp", "slierpe", "sslire_", "slirlpa", "sliryp", "sldirq", "slmirph", "Slircp", "isldircp", "sliterpc", "splwarp", "sldirpress", "plirc", "Slpircp", "isldirpi", "slwarp", "Slpirm", "collirap", "slarp", "slibrp", "splwarpart", "splwarpre", "sliverpe", "dlirp", "blibrpa", "scheiverpid", "slrirpad", "slirr", "sliverpi", "pliterp", "slirpress", "slpirpatch", "sslir_", "splirp", "sliterps", "slierl", "slirps", "slvrp", "splirq", "sslierping", "slirph", "slrirp", "sliverps", "Slirpatch", "slyrp", "collirpar", "slirlr", "dlirpa", "ssliert", "sslirpe", "plibrp", "blirpy", "slpirc", "slirer", "slirpi", "slierpy", "islirpi", "sslirpre", "splarcp", "collirpkg", "slir_", "sligrpa", "collirp", "slibrr", "sliropc", "slvrpy", "Slpirp", "islircp", "sslirping", "sldircp", "sslirt", "slibrm", "splirpre", "slvrping", "splirpa", "slpirt", "slibrpress", "slmirpa", "slrirping", "blirpa", "sslpirpre", "slierp", "slirec", "slrirpkg", "slirpar", "isldirping", "slibrpi", "slirepress", "slibrpid", "scheiverp", "slererp", "slwarpart", "sliverpatch", "slierpress", "islirl", "slibrpa", "sliropid", "scheiverpatch", "slwarpre", "slpircp", "slarping", "plirping", "blibrp", "slpirq", "slibrcp", "slarpy", "slierpad", "sliberping", "blirpi", "sslierpe", "slibrps", "islirping", "slierping", "blirpre", "sliterc", "slibrpc", "scheirpatch", "slircp", "plirp", "slpirpi", "splirpress", "slIRp", "blibrpre", "slIRping", "slirap", "slirm", "slarpid", "sliterping", "slrircp", "blirpc", "spldirp", "plibrpi", "blibrpid", "sliryt", "slyrpre", "sliterpi", "slmirpi", "blirping", "scheirps", "slirt", "spldirpa", "blirp", "slarcp", "sliert", "dlirlr", "spldirq", "slpirping", "slarpre", "slierr", "blirph", "slmirpart", "slwarpi", "Slirm", "slirypy", "slpirm", "slwarpress", "slirepa", "sldirp", "Slirp", "slibrc", "plirpi", "slirapar", "slyr_", "slibrpre", "splirpid", "dlirlc", "slpirl", "scheirp", "Slpirpatch", "plibrping", "sliverping", "dlirc", "slirc", "dlirlpa", "islibrr", "dlirr", "blibrping", "collirpad", "slierps", "splircp", "sslirp", "slpirp", "splirpad", "slrirpatch", "slibrq", "slpirpad", "sslpirp", "slibrph", "islirpress", "slirpe", "slirpa", "sligrq", "slibrpatch", "sliberpi", "splirpi", "slIRpid", "slpirpy", "slrirpar", "slarpad", "slrirpi", "sliropi"], "from_batchq": ["from_queueqs", "from_blockqs", "from_batqq", "from_batqs", "from_blockqq", "from_fastq", "from_batchqueue", "from_batchqu", "from_batchck", "from_workqu", "from_batchqq", "from_queueq", "from_fastQ", "from_batqueue", "from_workq", "from_workqs", "from_fastfresh", "from_batfresh", "from_blockqueue", "from_batq", "from_blockq", "from_queuequeue", "from_batchQ", "from_batck", "from_workck", "from_batqu", "from_batQ", "from_fastqueue", "from_batchqs", "from_batchfresh", "from_queueqq"], "next_from_batchq": ["next_from_launchg", "next_from_batchg", "next_from_bataq", "next_from_flatrequ", "next_from_batchrequ", "next_from2batchqu", "next_from_cleanq", "next_from_broadq", "next_fromvbatchq", "next_from_cacheq", "next_from_flatq", "next_from2fastqu", "next_from_broadqu", "next_from2fastquery", "next_from_batchdq", "next_from_batchk", "next_from_batg", "next_from__batchq", "next_from_launchqu", "next_from_atchq", "next_from_flatqs", "next_from__batchdq", "next_from_fastlock", "next_from_atchdq", "next_fromvfastrequ", "next_from_batchqueue", "next_from_cleandq", "next_from_batchaq", "next_from_batcheq", "next_from_batk", "next_from_batchlock", "next_from2fastQ", "next_from_fastQ", "next_from_batQ", "next_from__atchlock", "next_from__atchq", "next_from_atchg", "next_from2batchQ", "next_fromvbatcheq", "next_from_flateq", "next_from_fastdq", "next_from_broadquery", "next_from_cacherequ", "next_from_batchz", "next_fromvbatchrequ", "next_fromvbatchqs", "next_from__atchdq", "next_from_workaq", "next_from_launchqueue", "next_from_flatQ", "next_from_patchqu", "next_from2fastq", "next_fromvfasteq", "next_from_globalaq", "next_from_patchq", "next_from_fastq", "next_from__atchquery", "next_from_atchquery", "next_from_globalk", "next_from_globalQ", "next_fromvfastqs", "next_from_cacheqs", "next_from2batchq", "next_from_globalq", "next_from_batchquery", "next_from_batq", "next_from_fastqu", "next_fromvfastq", "next_from_flatquery", "next_from_broadQ", "next_from_fastquery", "next_from2batchquery", "next_from_workk", "next_from_flatqu", "next_from_fasteq", "next_from_atchlock", "next_from_batz", "next_from_launchq", "next_from__batchquery", "next_from_fastrequ", "next_from_workQ", "next_from__batchlock", "next_from_fastqs", "next_from_cleanlock", "next_from_patchQ", "next_from_batchQ", "next_from_launchz", "next_from_batchqu", "next_from_cleanquery", "next_from_workq", "next_from_launchQ", "next_from_cacheeq", "next_from_batchqs", "next_from_patchqueue", "next_from_atchz"], "ifm": ["ifdm", "imcm", "fifm", "efm", "ifarm", "fifmi", "ifom", "affM", "itm", "immi", "iffdm", " ifcm", "ifcm", " ifrm", "ifnum", "iamarm", "actma", "ifmd", " ifM", "iman", "ifan", "imm", "invm", "expmn", "iwmd", "fifd", "iftmodule", "uhmi", "invnm", "uhm", "imd", "tifm", "mitom", "efmt", " ifd", "iwmt", "itermi", "elsemi", "imma", " ifmi", "actM", "iftmi", "ifrm", "iamm", " ifp", "ifmi", "affm", "Ifm", "itmt", " ifnm", "elsemn", "iwmn", "ibmt", "ifd", "iterp", "actmt", "invpm", "itnum", "iwm", "ibd", "iftd", "iamom", " ifmodule", "itermm", "iterd", "iffM", "tifgm", "Ifgm", "affname", "fifmt", "elsem", "ibp", "iftarm", "ifpm", "iffnm", "iffd", "iamma", "mitm", "mitM", "IFrm", "IfM", "iftom", "itermt", "iffm", "IFm", "fifmm", "itd", "ifma", "immt", "mitmi", " ifpm", " ifan", "ibmm", "fifmodule", " ifom", "efmn", "IFdm", "iftm", "ifname", "ifmm", "fifmn", "iammt", "iftM", "actm", "itgm", " ifdm", "ifM", "iammi", "iftname", "uhM", "expmt", "tifpm", "efmd", "fifan", "actgm", "iterm", "expmd", "ifnm", "ifgm", "iffnum", "ifmn", "itermodule", "iftnm", " ifname", "Ifmt", "uhom", "tifnm", "ibmodule", " ifarm", "affmodule", "invgm", "fifcm", "ifp", "ibm", "itnm", "ifmodule", "actmi", "expm", "elsemt", "iffrm", "ifmt", "itM", " ifmt", "IFM", "itermn", " ifgm", "iftnum"], "ifm_next": ["ifma_ne", "ifm__prev", "ifgm_dn", "ifm__future", "ifm_ne", "ifmi_output", "ifgm___next", "ifmi_dev", "ifm_be", "ifr_buf", "ifm__next", "ifr_pre", "ifm____chain", "ifn_inv", "ifm_output", "ifm___want", "ifgm_adj", "ifm___future", "ifm_pre", "ifm__Next", "ifmistnext", "ifm__pred", "ifnm_ne", "ifmiistpred", "ifr__next", "ifmistoutput", "ifm_link", "ifnm_continue", "iflem_conn", "ifgm_next", "ifm___dn", "ifr__buf", "ifr_next", "ifm____inv", "ifgm___future", "ifm_trace", "ifr_Next", "ifmi_next", "ifm__buf", "ifam_link", "ifr_prev", "ifmistpred", "ifgm___prev", "ifr__Next", "ifm_pred", "ifm___next", "ifma_dev", "iflem_trace", "ifgm_future", "ifmi_be", "ifnm_next", "ifn_next", "ifmUdev", "ifmiistnext", "ifam_future", "ifma_pre", "ifm__output", "ifam_ne", "ifn_chain", "ifm____next", "ifm___prev", "ifmi_prev", "ifn_ne", "ifmUnext", "ifm_continue", "ifm__dn", "ifm_buf", "ifmi_pred", "ifm_prev", "ifr_ne", "ifnm_prev", "ifmiistoutput", "ifmUpre", "ifr__prev", "ifm_conn", "ifgm_prev", "iflem_gen", "ifma_next", "ifm_gen", "iflem_next", "ifm_dn", "ifam_next", "ifm_chain", "ifgm_want", "ifm_want", "ifm____ne", "ifm_dev", "ifm_forward", "ifm_future", "ifgm___dn", "ifm___adj", "ifr_forward", "ifm_inv", "ifm_Next", "ifmUne", "ifm_adj"], "ifqt": ["limqt", " ifreq", "ifvt", "limbt", "gifq", "ifq", " ifq", "ifreq", "iffqa", " ifvt", "IFqt", "imvt", " ifbt", "iffvt", "imq", "iffqt", "imqq", "exqt", "IFvt", "ifqq", "gifqt", "exqa", "IFqa", "exreq", "iffbt", "IFreq", "exvt", " ifqa", "imqt", "gifvt", " ifqq", "limvt", "limqa", "gifqq", "ifqa", "ifbt"], "next": ["new", "to", "tmp", "ne", "end", "response", "forward", "result", "iter", "nd", " NEXT", "info", "after", "valid", "nl", "draw", "big", "li", "prev", "null", "obs", "line", "head", "append", "set", "false", "max", "target", "ng", "network", "path", "zero", "txt", "j", "front", "future", "skip", "send", "missing", "latest", "first", "gov", "data", "link", "last", "current", "node", "start", "ptr", "z", "step", "Next"]}}
{"project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "target": 0, "func": "static void handle_ti(ESPState *s)\n\n{\n\n    uint32_t dmalen, minlen;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_ti;\n\n        return;\n\n    }\n\n\n\n    dmalen = s->rregs[ESP_TCLO];\n\n    dmalen |= s->rregs[ESP_TCMID] << 8;\n\n    dmalen |= s->rregs[ESP_TCHI] << 16;\n\n    if (dmalen==0) {\n\n      dmalen=0x10000;\n\n    }\n\n    s->dma_counter = dmalen;\n\n\n\n    if (s->do_cmd)\n\n        minlen = (dmalen < 32) ? dmalen : 32;\n\n    else if (s->ti_size < 0)\n\n        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;\n\n    else\n\n        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;\n\n    trace_esp_handle_ti(minlen);\n\n    if (s->dma) {\n\n        s->dma_left = minlen;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        esp_do_dma(s);\n\n    }\n\n    if (s->do_cmd) {\n\n        trace_esp_handle_ti_cmd(s->cmdlen);\n\n        s->ti_size = 0;\n\n        s->cmdlen = 0;\n\n        s->do_cmd = 0;\n\n        do_cmd(s, s->cmdbuf);\n\n    }\n\n}\n", "idx": 17141, "substitutes": {"s": ["us", "is", "as", "states", "a", "h", "c", "args", "sm", "js", "vs", "details", "ims", "e", "has", "stats", "http", "qs", "ses", "less", "ers", "als", "bits", "st", "aws", "sw", "xs", "ss", "serv", "https", "ns", "events", "spec", "ms", "parts", "sports", "an", "S", "cs", "conf", "hs", "p", "sl", "sts", "g", "rs", "ops", "sq", "self", "os", "set", "m", "sp", "sb", "ar", "sol", "gs", "ssl", "gets", "comm", "bs", "ls", "sv", "ins", "changes", "so", "settings", "r", "ats", "sync", "ts", "reads", "its", "sys", "b", "ties", "n", "se", "ds", "ps", "t", "fs", "z", "j", "es"], "dmalen": ["dbalenge", "dmanan", "dmadan", "dltallender", " dstalens", "datalen", "dbaloen", "didchloren", "dmlenge", "damatan", "dmaleng", "redmalens", "dmoneng", "damaten", "didchlorsten", "dmalah", "damalen", " dmalenge", "didmalien", "dmalength", "dmetalen", "delmanen", "dmachen", " dmaseng", "Dstalency", " dstallen", "delmenatten", "dhalense", "dmonresh", "dlhalense", "dlmalense", " dmaleng", "dlayatten", "dmatan", "dlayaren", "delmanhen", "dmlan", "damatah", "dmasEN", " dmalEN", " dstalener", "Dstalener", " dmalain", "dmonenn", "delmenenge", "dmacender", "dlasenn", "dmalenc", "dmelim", "dstalain", "dstalen", " dmallen", " dmasEN", "dhalenc", " dmlen", "dmetaleni", "delmalhen", "redmacenn", "dbalain", "dmaloen", "dmasener", "dlayenge", "damalenge", "dmanenge", "dmacens", "dltallenn", "didmalsten", "dmalim", " dmlenn", "dchlorien", "dmetalaren", " dmasener", "dmurenc", "redmalen", "didmalen", "dmlah", " dmalens", "dmilens", "dcolmeng", "datallen", "dlmalenn", "dmaceni", "dmenatten", "Dmalen", "redmacen", "dmalsten", "delmaneni", "dstalens", "dlmalEN", "dmleng", " dmalenn", "dmasength", "dmalaren", "dstalEN", "dhalEN", "dlayender", "redmalaren", "dstalresh", "dcolmain", "delmaleni", "dcolmEN", "dstromoen", "dmaseng", "dmaden", "dmanen", "dlmalender", "Dmalener", "dmalens", "delmanaren", "dstromen", "dmenenge", "dcolmen", "dmalhen", "datalens", "redmacens", "dmonen", "dlasens", "dmenener", "dtallenn", "dstalaren", "dmanah", "dstaleng", "dmlen", "didchlorien", "dmonener", "dstromien", "dmaneni", " dstalenge", "delmenener", "dmalan", " dmasength", "delmalaren", "dmadength", "dmasim", "dstalenn", "datalenc", "dmalien", "dmalener", "dstallen", "dmallen", " dmalim", "dlayener", "dmalresh", "dlayenn", "dmuren", " dmleng", "dmelen", "dmalenn", "dmatah", "dstalatten", "dlmalen", "dlhalenc", "dmenen", "dlmalenc", "dmacen", "dcolmener", "dmalense", "dlasaren", "datalener", "dchloroen", " dmlener", "dmaten", "dmadim", "dmanaren", "delmalatten", "dmanhen", "dtallen", "dstalency", " dmalan", "dcolmenge", "redmacaren", "dmalency", "redmalenn", "dmaleni", "dmelength", "dbalsten", "dlmalaren", "dchloren", "dmatenge", "dmlenn", "dmasan", "dmalender", "dtallaren", "damalan", "dstromsten", "delmalener", "dmillen", " dmasan", "dmurEN", "dlasen", "dltallaren", " dmalength", "dbalener", "dtallender", "dbalen", "dlhalEN", "dlayen", "didchloroen", "dmetalhen", "dstalenge", "dmasen", "Dstalresh", "dmalenge", "dmacenn", "damatenge", " dmasim", "delmenen", "damalah", " dmalener", "dmacaren", "delmalen", "Dstalen", "datalEN", " dstalen", "dmelan", " dmasen", "Dmalency", "dlhalen", "dhalen", "dchlorsten", "dmalEN", "datalense", "didmaloen", "dmlener", "delmalenge", "dmilen", "dmilener", " dstalain", "dmalatten", "dltallen", "dmurense", "dbalien", "Dmalresh", "dmalain", "dstalener", "dmonency"], "minlen": ["smalllen", "minlength", "Minlen", "smalllength", "minln", "mincoll", "rainlength", "memberlength", " minlength", "minimumlength", "minimumlen", "minlf", "Minlength", " mincompl", "memberln", "Mincompl", " minlf", "Minlon", "smallcoll", "minfin", "minimumlon", "aminlon", "rainlon", "rainlen", "MINlength", "memberfin", " minen", "minimumfin", "minlon", "MINen", "partialcoll", "smallcompl", "memberlen", "smalllf", "partiallf", "partiallength", "aminlength", "MINlen", "smallfin", "minelt", "Minen", "partiallen", "Minelt", " minlon", "minen", "minimumln", "minimumcompl", "aminelt", "MINcompl", "Minln", "mincompl", " minfin", "Minfin", "MINlon", "aminlen", " mincoll", "rainelt"]}}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n", "idx": 17152, "substitutes": {}}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n", "idx": 17172, "substitutes": {"scon": ["stsconst", "sCon", "sconst", "insconst", "insmon", "sconn", "rsmon", "insconn", "insgate", "stscon", "hsdo", "sbon", "insbon", "hsbon", "Scons", "smon", "jsco", "Sconst", "ascons", "inscon", "rsCon", "wsconn", "jsdo", " sbon", "stsdial", " smon", "ascon", "jscons", "SCon", "statsconst", "ismon", "jscon", "rsco", "Scon", "scons", "wscons", "iscons", "hsconn", "stsconn", "statsmon", " sdial", " sco", "Sco", "asconn", " scons", "sdo", "jsCon", "sco", "rscons", "sconv", "hscon", "sdial", "jsbon", "isconn", "Sconv", " sCon", "wsconv", "inscons", " sgate", "rsconn", " sconst", "statsgate", " sconn", "jsconn", "asconv", "rscon", "Sdial", "sgate", "Sconn", "iscon", "wscon", " sdo", "statscon"], "buf": ["new", "window", "cv", "bb", "block", " buffer", "br", "ref", "map", "vec", "wb", "fb", "Buff", "buffer", "cap", "Buffer", "rb", "bytes", "doc", "img", "cb", "BU", "b", "v", "txt", "uf", "bc", "data", "cur", "mem", "seq", "msg", "bound", "buff", "queue", "que", "p"], "size": [" Size", "sn", "shift", "c", "use", "shape", "amount", "address", "e", "message", "small", "time", "sha", "send", "capacity", "storage", "needed", "sw", "style", "len", "device", "pos", "body", "zero", "now", "area", "code", "space", "empty", "notice", "scope", "name", "to", "length", "sum", "g", "en", "sample", "sent", "port", "ze", "go", "set", "l", "m", "sp", "count", "number", "type", "get", "fee", "info", "SIZE", "scale", "padding", "ize", "height", "num", "n", "see", "Size", "equal", "format", "t", "z"]}}
{"project": "qemu", "commit_id": "d3aea641a4002e0abe940c65d318ef38eda245df", "target": 1, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}", "idx": 17199, "substitutes": {"opaque": ["octque", "Opque", "ipque", " Opaco", "opsaco", "opacity", "Opaco", "opsaque", " opque", "opsoch", " opaques", "octaques", "opque", " opacity", "octaque", "Opaque", "opsque", " Opque", "ipaque", " Opoch", " Opaque", "ipaques", "opoch", "octacity", "Opoch", "opaco", "opaques", "ipacity"], "dev": ["prop", "wd", "ad", "def", "debug", "patch", "cast", "det", "dem", "env", "v", "var", "out", "val", "mem", "add", "proc", "pad", "Dev", "hw", "develop", "stick", "des", "pr", "serv", "device", "obj", "spec", "ev", "db", "cmd", "ow", "w", "nt", "die", " door", "conn", "pkg", "hd", " device", " des", "dn", "nav", "term", " mem", "unknown", " av", "go", "loc", "buf", "watch", "ve", "desc", "cur", "pro", "raw", "cho", "attr", "cam", " dw", "pub", "doc", "der", "att", "ver", "form", "d", "van", "den", "gu", "priv", " adm", "om", "app", "DEV", "av", "addr", "fo"]}}
{"project": "FFmpeg", "commit_id": "e62ef8f2dbf1ac0a197310f2be69c93b89f838c2", "target": 0, "func": "static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)\n\n{\n\n    int ch, bw_code;\n\n\n\n    if (cutoff) {\n\n        /* calculate bandwidth based on user-specified cutoff frequency */\n\n        int fbw_coeffs;\n\n        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);\n\n        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;\n\n        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);\n\n    } else {\n\n        /* use default bandwidth setting */\n\n        /* XXX: should compute the bandwidth according to the frame\n\n           size, so that we avoid annoying high frequency artifacts */\n\n        bw_code = 50;\n\n    }\n\n\n\n    /* set number of coefficients for each channel */\n\n    for (ch = 0; ch < s->fbw_channels; ch++) {\n\n        s->bandwidth_code[ch] = bw_code;\n\n        s->nb_coefs[ch]       = bw_code * 3 + 73;\n\n    }\n\n    if (s->lfe_on)\n\n        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */\n\n}\n", "idx": 17203, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "g", "ins", "eps", "aws", "so", "sw", "a", "c", "h", "sq", "ops", "ex", "aps", "settings", "js", "service", "ants", "os", "ss", "sc", "conv", "vs", "details", "ns", "ims", "spec", "e", "r", "ats", "ts", "sys", "its", "es", "v", "n", "se", "bis", "sports", "sb", "services", "stats", "ds", "qs", "less", "status", "w", "S", "comments", "ssl", "gs", "cs", "ps", "t", "bs", "als", "fs", "hs", "comm", "p"], "cutoff": ["dropoffer", " cutoffer", "bitoff", "cutfunction", "celloffset", "bitoffs", "limitoffset", "payoffer", "payoff", "cutoffer", "paydown", "payfunction", "utoff", "dropoffset", "dropoffs", "utoffset", " cutoffset", "utoffs", "celloff", "limitpoint", "cutdown", "cutOff", "cutpoint", "dropdown", "cutoffset", "dropOff", "cuttingoff", "CutOff", "cutoffs", "cuttingoffset", " cutdown", "paypoint", "bitoffer", "payoffset", "Cutoffset", "celloffer", "dropoff", " cutoffs", "Cutoffs", "utOff", "bitoffset", "limitfunction", "limitoff", "cuttingpoint", " cutOff", "celloffs", "Cutoff", "cuttingfunction"], "ch": ["anch", "ble", "ih", "chu", "cho", "ht", "br", "ach", "th", "cell", "ind", "cht", "channel", "c", "h", "qu", "och", "i", "ay", "chip", "chart", "q", "ot", "cp", "y", "chn", "p", "go", "sk", "pl", "ech", "Ch", "el", "ph", "client", "ich", "cl", "v", "k", "kh", "bot", " unch", "history", " CH", "mk", " chip", "wh", "chron", "x", "tch", "cha", "col", "cur", "bat", "uch", "chan", " chunk", "zh", "chat", "sch", "isch", "CH", "sh", "j", "batch"], "bw_code": ["bwStatuscodes", "bwk_mode", "bsw_channel", "bsw_code", "bw_channel", "bw_coded", "bw_codes", "bag_code", "bagmycodes", "bw_class", "bwk_ode", "bw__codes", "bsw_codes", "bw__ode", "bw_line", "bw__class", "bagmycode", "bwa_codes", "bag_codes", "bw___code", "bwa_line", "bware_class", "bwk_code", "bwStatuscode", "bware_ode", "bwmycodes", "bware_code", "bware_codes", "bwareStatuscodes", "bwareStatuscode", "bwmycode", "bw_Code", "bagmycoded", "bwmycoded", "bag_coded", "bag_Code", "bw___codes", "bwareStatusode", "bwa_code", "bwa_Code", "bsw_div", "bwStatusclass", "bwareStatusclass", "bw___channel", "bw_ode", "bw_mode", "bwk_Code", "bw__code", "bagmyCode", "bwmyCode", "bw___div", "bw_div", "bwStatusode"], "fbw_coeffs": ["fbw_Coeff_", "fbw_coefls", "fbw_coeffes", "fbw_cofficls", "fbw_coffs", "fbw_coeff_", "fbw_coff_", "fbw_cofficts", "fbw_coeffices", "fbw_goeffs", "fbw_coefs", "fbw_coeffS", "fbw_coffS", "fbw_coefS", "fbw_coof_", "fbw_goeffices", "fbw_Coff_", "fbw_goefficS", "fbw_coefts", "fbw_Coffs", "fbw_Coeffls", "fbw_coofS", "fbw_Coffls", "fbw_goeffes", "fbw_coffls", "fbw_coeffls", "fbw_coffes", "fbw_Coeffs", "fbw_CoeffS", "fbw_coofs", "fbw_coef_", "fbw_coefficls", "fbw_coefficS", "fbw_coeffics", "fbw_coffics", "fbw_coeffts", "fbw_cofficS", "fbw_CoffS", "fbw_coofls", "fbw_goeffics", "fbw_coefficts", "fbw_goeffS", "fbw_coefes"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"movq \"MANGLE(bm01010101)\", %%mm4           \\n\\t\"\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",4), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",4), %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"movq                %%mm0, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"pand                %%mm4, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm0, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm1           \\n\\t\"\n\n        \"movd                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movd                %%mm1, (%2, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $4, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[4*i + 1];\n\n        dstV[i]= src1[4*i + 3];\n\n    }\n\n#endif\n\n    assert(src1 == src2);\n\n}\n", "idx": 17206, "substitutes": {"dstU": ["dSTU", "dndU", " dstUp", "fdstO", " dSTUT", " dSTU", " dstUV", "dstrO", "fdostBU", "dsetu", "dstoreBU", "dstoreU", "fdostO", "fdstU", "dstoreUD", " ddestO", "dstUp", "dostO", "dstO", " ddestu", "dstu", "ddestu", "dsetU", "ddestEU", "fdostU", "dmtU", "dmtBU", "dstEU", "dostBU", "dstru", " ddestEU", "dndUT", " dSTUp", "dputUV", "dmtO", "dstBU", "dputU", "dostU", "fdstUD", " dstu", " dstUT", "dputUT", " dSTUV", "dputUp", " ddestU", " dstEU", " dstO", "dSTUp", "dSTUT", "dmtUD", "dSTUV", "dndUp", "dstUD", "dstoreO", "dstrEU", "ddestO", "ddestU", "dsetO", "dostUD", "dstUV", "dndUV", "dstrU", "fdostUD", "dsetEU", "fdstBU", "dstUT"], "dstV": ["dsrcV", "sstVI", "drcVI", "sstV", "dndU", " dndVI", " dstUV", "dportU", " dndV", "srcVI", " dndG", "dputN", "srcV", "dsrcVI", "dportV", "drcV", "dndV", "dndN", "dSTJ", " dstVI", "drcU", "dsrcG", "dportVI", "srcU", "ddestUV", "dstJ", "dstL", "dndVI", " dSTL", "dSTV", " dstL", "dcpUV", "dndG", "dputVI", "dputU", "dSTL", " dstJ", "dstN", "ddestL", "drcN", "dcpL", "ddestV", " dSTUV", "dputV", "dportG", "dsrcU", "dcpJ", "dstG", "ddestJ", " dSTV", "sstN", "dSTUV", "dstVI", " dndU", " dSTJ", "dstUV", " dstG", "sstU", "srcN", "dcpV"], "src1": ["supp1", " src0", "rc1", "source2", "srcOne", "rc3", "source1", "rc2", "supp2", "source0", "inst0", "inst2", "source3", "src3", "rc4", "sourceOne", "source4", " srcOne", "supp0", "rc0", "src0", " src3", "inst4", "src4", "inst1", "rcOne"], "src2": ["src5", " src0", "rc1", "source2", "rc3", " src5", "source1", "rc2", "source0", "source3", "src3", "rc5", "source5", "rc0", "src0", " src3"], "unused": ["Unchecked", "unuse", "UnUsed", "unalchecked", " unchecked", "unalUsed", "unalused", "unchecked", " unuse", "unaluse", "unUsed", "Unuse", " unUsed", "Unused"], "i": ["us", "is", "M", "init", "ami", " ii", "qi", "v", " err", "I", "out", "ii", "key", "print", "phi", "span", "status", " j", "f", "ui", "\u0438", "pi", "php", "index", "mi", "name", "multi", " I", "gi", "chain", "ind", "ri", "xi", "point", "err", "ki", "ex", "cli", "ai", "parent", "li", "iu", "ci", "sim", "m", "me", "sp", "ti", "uri", "ij", "si", "batch", "bi", "info", " v", "ic", "in", "remote", "r", "zi", "this", "id", "gu", "b", "n", "ei", "slice", "ix", "di", "it", "ini", "j", "oi"]}}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n", "idx": 17240, "substitutes": {"machine": ["library", "zone", "cell", "spin", "config", "shell", "connection", "chain", "channel", "sm", "STATE", "parent", "mass", "self", "manager", "device", "power", "session", "handler", "agent", "dem", "sim", "model", "network", "monitor", "m", "me", "money", "vm", "achine", "template", "history", "state", "instance", "policy", "task", "domain", "module", "process", "Machine", "iso", "ch", "world", "normal"]}}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,\n\n                               unsigned int len)\n\n{\n\n    unsigned int offset;\n\n    int i;\n\n\n\n    offset = 0;\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n\n                                  elem->in_sg[i].iov_len,\n\n                                  1, size);\n\n\n\n        offset += size;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++)\n\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n\n                                  elem->out_sg[i].iov_len,\n\n                                  0, elem->out_sg[i].iov_len);\n\n}\n", "idx": 17242, "substitutes": {"vq": ["vue", "vqu", "vpqu", "fue", "fque", "fqu", "vpque", " vue", "vpq", "vque", " vque", "vpue", "fq", " vqu"], "elem": ["delem", "seemn", " elev", "celement", "elelement", "elelem", "seelement", " emn", "Element", "oelev", "edlement", "Elem", "eleg", "celem", "execoe", "eept", "eelement", "eom", "enseterm", " element", "elelements", "eterm", "delev", "belement", "elems", "celems", "seelev", "meterm", " eelement", "melement", "eld", "enselem", "delement", "elete", "elell", "seelem", "edlements", " elems", " eld", "gelev", "element", "entlem", "celev", "Elev", "feterm", "melem", " eoe", "felement", "eeld", "belete", "elev", " eom", " eleg", " elete", "beom", "gelement", "execlem", "entld", "ept", "edlem", " eterm", "oelem", "ensell", "emn", " ept", "felems", "eelem", "eleom", "oemn", "geleg", "Elems", "elements", "gelem", "deoe", "entpt", "oelement", "eleterm", "celeg", " elements", "eleelement", "elelete", " ell", "entlement", "eoe", "felem", "ell", "belem", "execlev", "execlement", "edom", "enseelement", "melems"], "len": ["ls", "lc", "length", "lan", "cmp", "all", "end", "en", "Len", "kl", "lf", "le", "nl", "size", "bytes", "nn", "pos", "elt", "ll", "lp", "l", "list", "el", "un", "n", "hl", "lon", "full", "count", "mem", "seq", "ln", "limit", "addr", "ptr", "il", "L", "t"], "offset": ["window", "pad", "length", "alias", "initial", "end", "scroll", "location", "tile", "offs", "map", "shift", "a", "oe", "point", "origin", "le", "size", "pointer", "Offset", "position", "buffer", "seed", "mask", "SIZE", "error", "padding", "pos", "attribute", "OFF", "loc", "align", "set", "max", "address", "table", "l", "index", "off", "o", "space", "reset", "trace", "prefix", "et", "seek", "bound", "base", "limit", "start", "oid", " size", "ace", "t"], "i": ["is", "init", "y", "ip", "ami", " ii", "ims", "qi", "e", "series", "v", "I", "ii", "print", "phi", " ti", "status", " j", "f", "json", "ui", "\u0438", "pi", "im", "index", "mi", "source", "name", "multi", " I", "g", "gi", "ind", "chain", "ri", "xi", "point", "ki", "cli", "ai", "parent", "li", "go", "iu", " bi", "ci", "my", "sim", "m", "me", "history", "ti", "x", "uri", "at", "ij", "ski", "si", "batch", "bi", "info", "ic", "in", "remote", "zi", "this", "any", "list", "id", "ji", "gu", "ei", "fi", "ix", "di", "it", "ini", "j", "oi"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n", "idx": 17246, "substitutes": {"state": ["component", "is", "estate", "cache", "states", "init", "h", "STATE", "trust", "store", "al", "check", "monitor", "out", "print", "trace", "stats", "status", "command", "close", "st", "test", "style", "device", "spec", "now", "the", "area", "space", "S", "scope", "tag", "name", "p", "resource", "point", "self", "port", "q", "error", "l", "m", "history", "policy", "up", "range", "initial", "config", "shell", "that", "trans", "State", "info", "this", "request", "list", "call", "local", "se", "n", "see", "output", "current", "base", "stat", "start", "ace", "t"], "queue": ["f", "\u00fc", "block", "cache", "Queue", "entry", "test", "channel", "qu", "archive", "Q", "pipe", "port", "dq", "buffer", "q", "ue", "line", "quote", "ques", "menu", "buf", "sequence", "message", "list", "question", "force", "ux", "stack", "space", "ued", "prefix", "file", "req", "frame", "seq", "topic", "msg", "grid", "pool", "command", "range", "que", "batch"], "errp": ["ererpc", "ererpa", " errP", "errpc", "errorp", " errpa", "ererp", "errorpe", "errpa", "erps", "errorps", "erpe", "errpe", "errps", "cerp", " errps", "ererP", "erP", "cerP", "cerpc", "errorP", "errP", " errpc", "cerpa", "erp", " errpe"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "g", "shell", "ins", "sw", "so", "south", "a", "h", "sq", "sm", "hs", "js", "os", "ss", "serv", "ns", "ims", "set", "ms", "ats", "series", "ts", "sys", "sp", "es", "b", "se", "n", "space", "sb", "ast", "stats", "ds", "qs", "ses", "less", "S", "sam", "gs", "ssl", "cs", "sa", "ps", "bs", "als", "fs", "sh", "j", "si", "p"], "i": [" I", "bi", "gi", "ind", "init", "ri", "xi", "ki", "cli", "ai", "info", "ini", "oi", "batch", "name", "li", "ui", "ic", "y", "ip", "io", "\u0438", " ii", "ims", "pi", "iu", "qi", "im", " bi", "ci", "zi", "sim", "m", "me", "index", "ji", "gu", "ori", "v", "I", "o", "ii", "ti", "key", "ei", "phi", "fi", "ix", "fire", "x", "di", "uri", "it", "mi", " j", "hi", "ij", "iq", "t", "multi", "j", "si", "p"], "e": ["ele", "f", "ne", "g", "er", "entity", "a", "oe", "ef", "ex", "ed", "ge", "le", "te", "ye", "ibe", "ze", "ue", "p", "eeee", "ee", "u", "r", "est", "l", "eur", "eu", "el", "EEE", "eb", "b", "eg", "o", "xe", "ev", "se", "be", "ei", "eff", "element", "ce", "et", "de", "ec", "ent", "ie", "pe", "it", "E", "t", "ea", "ae", "es"]}}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n", "idx": 17258, "substitutes": {"s": ["us", "is", "sl", "ls", "sts", "g", "rs", "sv", "ins", "scl", "sw", "south", "a", "c", "sq", "h", "sm", "js", "i", "self", "os", "q", "ss", "sc", "sg", "p", "ns", "ims", "session", "set", "r", "ats", "ts", "sys", "its", "b", "ctx", "ties", "n", "se", "space", "sb", "x", "ds", "qs", "ses", "an", "w", "S", "gs", "source", "cs", "comm", "t", "ps", "fs", "j", "es"], "label_index": ["label___len", " label_len", "l_i", "label_pos", "label___pos", "l_num", " label_i", "label_axis", "l_index", "label_len", "l_Index", " label_number", "label_i", " label_pos", "label_Index", "label_num", "label___number", "label___index", " label_axis", "label_number"], "l": ["lr", "ls", "sl", "lc", "jl", "label", "tl", "g", "lt", "kl", "dl", "rl", "le", "nl", "li", "ml", "ll", "pl", "dL", "lv", "lp", "m", "el", "b", "v", "lu", "j", "lay", "lb", "ol", " m", "ln", " lit", "lis", " pl", "la", "il", "L", "NL", "ld", "yl", "p"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n", "idx": 17266, "substitutes": {"pci_dev": ["pci__ev", "pci2Dev", "pdi_Dev", "pct_device", "pdi_dev", "pci2dev", "pci2device", "pci_ev", "pci_Dev", "pci__Dev", "pdi_device", "pct_dev", "pdi_ev", "pci_device", "pct_Dev", "pct_ev", "pci__dev", "pci2ev", "pci__device"], "region_num": ["Region1num", "region1num", "Region1mon", "region1mon", " region_mon", "Region1nom", "region0mon", "Region_num", "region_um", "region1no", "region0num", "Region1no", "Region_mon", " region_um", " region_NUM", "region_mon", "Region_no", "region0nom", "region_no", "region_NUM", "region_nom", "region1nom", "Region_nom", "region0no"], "addr": ["arch", "ash", "wd", "js", "eth", "ad", "store", "ip", "iat", "np", "address", "dh", "ctx", "var", "grad", "req", "mem", "hash", "add", "arp", "url", "pad", "act", "offset", "gt", "ag", "order", "pos", "obj", "src", "Address", "index", "off", "hl", "alloc", "db", "cmd", "phys", "msg", "usr", "rid", "ext", "conn", "host", "pkg", "hd", "map", "lat", "err", "port", "elt", "dir", "sp", "prefix", "x", "on", "dr", "adr", "at", "ptr", "rt", "coord", "attr", "ref", "rc", "mg", "urg", "res", "fx", "ha", "align", "rel", "arr", "handle", "r", "rev", "sys", "id", "ord", "gate", "str", "ix", "alt"], "size": ["length", "offset", "g", "sy", "st", "sn", "fee", "scale", "len", "ize", "bytes", "body", "loc", "set", "max", "address", "ram", "mode", "Size", "desc", "count", "mem", "msg", "iz", "sh", "z", "name"], "type": ["ype", " ty", " TYPE", " typ", "style", "dt", "error", "y", " t", "kind", "types", "address", "id", " Type", "time", "TYPE", "state", "pe", "op", "typ", "tag", "start", "t", "Type", "name", "p"], "d": ["new", "fd", "done", "f", "g", "er", "dx", "add", "ind", "result", "bd", "c", "dn", "du", "dl", "ed", "dal", "des", "json", "ad", "dt", "del", "red", "D", "dos", "y", "der", "sd", "dat", "dm", "da", "r", "dh", "l", "m", "id", "b", "v", "k", "dj", "n", "o", "ct", "j", "dd", "pd", "dom", "send", "md", "db", "de", "ds", "di", "w", "it", "dict", "mod", "rd", "ld", "dc", "z", "cd", "p"], "s": ["is", "sts", "sv", "rs", "fs", "a", "h", "sq", "c", "js", "i", "os", "store", "ss", "y", "ns", "sd", "spec", "set", "r", "e", "m", "ts", "sys", "sp", "b", "v", "n", "se", "bis", "sb", "stats", "ds", "w", "S", "ssl", "gs", "ps", "t", "bs", "sis", "p"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 17267, "substitutes": {"dev": ["Dev", "hw", "cam", "sw", "des", "ad", "def", "serv", "device", "sd", "ver", "att", "dm", "det", "dem", "v", "ev", "dd", "md", "dis", "DEV", "de", "ds", "mem", "w", "pro", "serial", "nt"], "vmsd": ["mmesd", "mmsdn", "vmesdn", "vmesds", "mtsd", "vmesD", "mmsn", "vvsd", "mmesD", "vmesd", "vpsds", "vpsD", "vtsdk", "mmesn", "mmsd", "vvsn", "vomssd", "vmssd", "vtsd", "vmsn", "vvsdn", "vmsdk", "vvsD", "vpsd", "mmsD", "vomsdk", "vtsds", "mmesdn", "mtssd", "vvsdk", "mtsds", "mmesds", "vvssd", "vpssd", "vpsdn", "vomsds", "vmsD", "vvsds", "mtsdk", "vmessd", "mmessd", "vtssd", "vomsd", "vmsds", "vmesn", "mmsds", "vpsn", "mmsdk", "vmsdn", "mmssd"], "opaque": ["oppacity", "ipacement", "compatile", "ipulence", "ipasus", "Opacity", "opatile", "opacity", "compacity", "Opasus", "ospaque", "compaque", "bitaque", "Opulence", "ipatile", "ospacity", "opadic", " opacity", "oppaco", "opasus", "bitacity", " opadic", "opacement", "oppaque", "Opaque", "ospatile", "bitaco", " opulence", "ipaque", "compacement", "oppadic", " opasus", "opaco", " opaco", "ipacity", "bitadic", "opulence", "ospacement"], "se": ["ele", "ese", "ene", "sl", "ser", "Se", "parse", "ne", "sem", "sv", "entry", "so", "sec", "she", "ste", "ge", "le", "te", "ade", "he", "ze", "ue", "sed", "sle", "set", "e", "sea", "est", "cle", "ke", "sex", "exe", "see", "ry", "ve", "send", "ide", "ase", "ce", "ses", "SE", "ent", "ie", "pe", "try", "sa", "ense", "spe", "sche", "sel", "we", "ae", "ine", "ace", "pse", "es"], "new_se": [" new_ke", "new__se", " new_ge", "new__sel", " new_sel", " new_ce", "new_pe", "new_ce", "new__ge", "new_ke", " new_pe", "new__ce", "new_ge", "new_sel"]}}
{"project": "qemu", "commit_id": "47d3df2387ed6927732584ffa4159c26d9f4dee8", "target": 0, "func": "static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n", "idx": 17274, "substitutes": {"xenfb": ["xensenfab", " xopenfab", "xedenfb", "xoenplug", "xensenfb", "xeenfab", "xopenfb", "xeenplug", " xenframework", "xENframework", "txenfab", " xenfab", "txoenplug", "xoenwb", "xensenplug", "xopenbb", "txenplug", "xenframework", " xopenbb", "xedenfab", " xenbb", "xedenbb", " xopenframework", "xoenfb", "xenwb", "txoenwb", "txoenfb", "txoenfab", " xopenfb", "xENfab", "xeenwb", "xensenwb", "txenwb", "txenfb", "xenplug", "xopenfab", "xeenfb", "xopenframework", "xoenfab", "xedenframework", "xenbb", "xENbb", "xENfb", "xenfab"], "rel_x": ["broad_wx", "rel__ex", "rel_width", "relixwx", "relityx", "broadixz", "rel_xp", "broad_x", " rel__ex", "attrityxp", " rel_m", " rel_full", "relixx", "attrityxs", "relityxs", "rel__full", "relactm", "relixy", "attr_width", "broad_y", "rel_wx", "rel_full", "relixz", "relitywidth", "relactex", "relactx", "rel__x", "rel_xs", "relactfull", " rel__x", "rel_ex", "attr_xp", "broadixy", "broad_z", "attr_x", "attritywidth", "rel_m", "relityxp", " rel_ex", "attr_xs", " rel__m", "broadixwx", "rel__m", " rel__full", "attrityx", "broadixx"], "rel_y": ["relityx", "ref_y", "rel_Y", "rel2lon", "reljz", "relaxyx", "relityp", "rel2y", "rep_Y", "rep_yt", "relaxyp", "relaxyyt", "rep_ya", "rel2Y", "rel_ya", "rep_lon", "repaxyyt", "rel_yt", "reljtarget", "rep_p", "reljy", "relaxyy", "ref_x", "repaxyy", "reljx", "relityy", "relityyt", "rep_x", "repaxyx", "ref_target", "repaxyp", "rel2ya", "rel_lon", "rel_target", "ref_z", "rel_p", "rep_y"], "rel_z": ["relaxyz", "relaxyuz", "relptz", "ref_Z", "relmtpos", " rel_zh", "relptZ", "compl_pos", "rel_pos", "relptcos", "relmtz", "compl_uz", "relaxypos", "relmtZ", "rel_Z", "rel_zh", "relptpos", "ref_pos", "rel_cos", "rel_uz", "relmtcos", "ref_z", "compl_z", "ref_cos"], "event": ["component", "action", "content", " msg", "after", " message", " ev", "attribute", "e", "address", "message", "advert", " err", "out", "frame", "command", "ame", " events", "act", "object", "entry", "complete", "test", "json", "style", "device", " exc", "spec", "session", "handler", "index", "Event", "ev", "state", "comment", "context", "package", "empty", "full", " exception", " image", "msg", "tag", "ception", "dev", "exc", "name", "vent", "all", "header", "result", "condition", "point", "claim", "post", "self", "except", "error", "cal", " arg", "load", "ee", "commit", " error", "ack", "instance", "policy", "task", "on", "ent", "view", "image", "alert", "text", "config", "initial", "entity", "reason", "info", "press", "request", "import", "network", "se", "rule", "app", "output", "age", " e", "t", "response"]}}
{"project": "FFmpeg", "commit_id": "435535e41159fbe7423a12078d684329a554776d", "target": 1, "func": "static int read_header(AVFormatContext *s,\n\n                       AVFormatParameters *ap)\n\n{\n\n    JVDemuxContext *jv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *vst, *ast;\n\n    int64_t audio_pts = 0;\n\n    int64_t offset;\n\n    int i;\n\n\n\n    avio_skip(pb, 80);\n\n\n\n    ast = av_new_stream(s, 0);\n\n    vst = av_new_stream(s, 1);\n\n    if (!ast || !vst)\n\n        return AVERROR(ENOMEM);\n\n\n\n    vst->codec->codec_type  = CODEC_TYPE_VIDEO;\n\n    vst->codec->codec_id    = CODEC_ID_JV;\n\n    vst->codec->codec_tag   = 0; /* no fourcc */\n\n    vst->codec->width       = avio_rl16(pb);\n\n    vst->codec->height      = avio_rl16(pb);\n\n    vst->nb_frames          =\n\n    ast->nb_index_entries   = avio_rl16(pb);\n\n    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);\n\n\n\n    avio_skip(pb, 4);\n\n\n\n    ast->codec->codec_type  = CODEC_TYPE_AUDIO;\n\n    ast->codec->codec_id    = CODEC_ID_PCM_U8;\n\n    ast->codec->codec_tag   = 0; /* no fourcc */\n\n    ast->codec->sample_rate = avio_rl16(pb);\n\n    ast->codec->channels    = 1;\n\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n\n\n\n    avio_skip(pb, 10);\n\n\n\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n\n    if (!ast->index_entries)\n\n        return AVERROR(ENOMEM);\n\n\n\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n\n    if (!jv->frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    offset = 0x68 + ast->nb_index_entries * 16;\n\n    for(i = 0; i < ast->nb_index_entries; i++) {\n\n        AVIndexEntry *e   = ast->index_entries + i;\n\n        JVFrame      *jvf = jv->frames + i;\n\n\n\n        /* total frame size including audio, video, palette data and padding */\n\n        e->size         = avio_rl32(pb);\n\n        e->timestamp    = i;\n\n        e->pos          = offset;\n\n        offset         += e->size;\n\n\n\n        jvf->audio_size = avio_rl32(pb);\n\n        jvf->video_size = avio_rl32(pb);\n\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n\n\n\n        if (avio_r8(pb))\n\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n\n        jvf->video_type = avio_r8(pb);\n\n        avio_skip(pb, 1);\n\n\n\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n\n        audio_pts += jvf->audio_size;\n\n\n\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n\n    }\n\n\n\n    jv->state = JV_AUDIO;\n\n    return 0;\n\n}", "idx": 17280, "substitutes": {"s": ["proc", "ls", "is", "sts", "sv", "rs", "g", "as", "ins", "aws", "a", "c", "sq", "js", "os", "ss", "sc", "bp", "sg", "in", "ns", "ms", "ats", "pc", "bs", "ts", "m", "sys", "its", "es", "b", "v", "n", "sb", "ds", "span", "ses", "aus", "S", "gs", "cs", "snap", "ps", "t", "comm", "fs", "hs", "j", "p"], "ap": ["amp", "ep", "apt", "aps", "mp", "cap", "cp", "ip", "bp", "pp", "al", "np", "att", "pl", "tap", "ac", " mp", "sp", "pa", " sp", "ar", " sap", "ape", "am", " p", "op", "ps", "tp"], "jv": ["gtv", "jjtv", "Jvp", " jV", "jjj", "jjvm", "jV", "jjvc", " jvr", "gvr", "jj", "Jv", "jpj", " jvm", " jtv", "gvp", " jj", "jpvm", "jvp", "jpvr", "jjV", "jtv", "jvc", "Jvc", " jvc", "jjvp", "jjv", "jvm", "jvr", " jvp", "JV", "jjvr", "jpv", "gv"], "pb": ["proc", "nb", "cv", "bb", "ub", "PB", "pkg", "bj", "fp", "jp", "tf", "wb", "gp", "fb", "td", "mp", "tab", "asm", "cp", "conv", "rb", "bp", "xp", "pp", "np", "gc", "cb", "obj", "pl", "tc", "ib", "stab", "lp", "pm", "buf", "resp", "pc", "wp", "pt", "prot", "pid", "erb", "sp", "eb", "b", "ctx", "bot", "pa", "uf", "vm", "txt", "vp", "sb", "db", "pg", "lb", "req", "span", "tk", "oa", "pool", "typ", "ob", "bf", "emb", "mt", "snap", "dp", "tp", "p"], "vst": ["vth", "svsw", " vso", "evst", "svste", "vrust", "ovost", "svstore", "vust", "vestore", "evstable", "vpst", "cvst", "vsw", "avst", "vrST", "vstable", "vrst", "vost", "vrse", " vrest", " vstore", "vrste", "vstore", "svstd", "cvust", " vust", "cvost", "svth", " vstd", "vse", "verst", "avrest", "vect", "svct", "verth", "vso", "vST", "uvstd", " vest", "evST", "webst", "svrest", "jost", "verso", "verrest", "svust", "ovst", "uvST", "vesw", "vest", "uvst", "svest", "ovust", "jstra", "vstra", " vse", "vpstd", " vsw", "svst", "vstd", "avust", " vct", "svse", "vpest", " vstable", "webest", "evest", "vct", "vrest", "webrest", "avth", "evstd", "ovstra", "webstable", "vste", "cvstra", " vste", "avest", "evstra", "verust", "vpstable", "versw", "uvstra", "jst", " vth", "avstable", "svso", "vrstra", "just", "vrstd", "avstd"], "ast": ["as", "a", "tar", "archive", "ed", "sta", "asting", "ad", "asm", "store", "master", "ait", "inst", "cast", "wp", "aw", "ank", "md", "quest", "Ast", "mem", "art", "stan", "command", "rest", "past", "ost", "st", "sw", "test", "std", "was", "ain", "ma", "and", "esta", "ase", "empty", "an", "aft", "mt", "irst", "ief", "sts", "all", "hd", "aster", "post", "af", "mast", "asts", "ab", "access", "some", "ess", "walk", "um", "wal", "ah", "best", "core", "acl", "am", "ust", "raw", "aste", "tt", "rank", "ance", "asted", "apt", "AST", "anc", "amd", "aid", "must", "att", "ac", "est", "any", "ts", "eas", "exec", "av", "ace", "ard", "each", "ist"], "offset": ["pad", "length", "scroll", "ref", "tile", "slot", "location", "shift", "point", "origin", "pointer", "Offset", "position", "padding", "error", "amount", "pos", "unk", "audio", "set", "address", "index", "off", "o", "skip", "data", "seek", "count", "next", "frame", "metadata", "start", "annot", "timeout"], "i": ["f", "bi", "a", "c", "iter", "xi", "err", "ai", "li", "ui", "ip", "y", " ii", "pi", "u", "set", "im", " bi", "ci", "r", "l", "m", "index", "id", "b", "v", "k", "I", "o", "n", "ii", "slice", "x", "di", "mi", " j", "ij", "t", "z", "j", "si", "p"]}}
{"project": "FFmpeg", "commit_id": "4fb3efd2c17c419cb7a170e5438b35453ceaaf30", "target": 0, "func": "static int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9\n\n    // Ref (MP4): ISO/IEC 14496-12:2012\n\n\n\n    if (track->enc->color_primaries == AVCOL_PRI_UNSPECIFIED &&\n\n        track->enc->color_trc == AVCOL_TRC_UNSPECIFIED &&\n\n        track->enc->colorspace == AVCOL_SPC_UNSPECIFIED) {\n\n        if ((track->enc->width >= 1920 && track->enc->height >= 1080)\n\n          || (track->enc->width == 1280 && track->enc->height == 720)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt709\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT709;\n\n        } else if (track->enc->width == 720 && track->height == 576) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt470bg\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT470BG;\n\n        } else if (track->enc->width == 720 &&\n\n                   (track->height == 486 || track->height == 480)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming smpte170\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;\n\n        } else {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, unable to assume anything\\n\");\n\n        }\n\n        switch (track->enc->color_primaries) {\n\n        case AVCOL_PRI_BT709:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_BT709;\n\n            break;\n\n        case AVCOL_PRI_SMPTE170M:\n\n        case AVCOL_PRI_BT470BG:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_SMPTE170M;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* We should only ever be called by MOV or MP4. */\n\n    av_assert0(track->mode == MODE_MOV || track->mode == MODE_MP4);\n\n\n\n    avio_wb32(pb, 18 + (track->mode == MODE_MP4));\n\n    ffio_wfourcc(pb, \"colr\");\n\n    if (track->mode == MODE_MP4)\n\n        ffio_wfourcc(pb, \"nclx\");\n\n    else\n\n        ffio_wfourcc(pb, \"nclc\");\n\n    switch (track->enc->color_primaries) {\n\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_PRI_SMPTE170M:\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->color_trc) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->colorspace) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_SPC_BT470BG:\n\n    case AVCOL_PRI_SMPTE170M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n\n\n    if (track->mode == MODE_MP4) {\n\n        int full_range = track->enc->color_range == AVCOL_RANGE_JPEG;\n\n        avio_w8(pb, full_range << 7);\n\n        return 19;\n\n    } else {\n\n        return 18;\n\n    }\n\n}\n", "idx": 17288, "substitutes": {"pb": ["tmp", "px", "cv", "bb", "amp", "PB", "pkg", "bj", "fp", "jp", "wb", "fb", "mp", "buffer", "cp", "rb", "bp", "p", "pp", "np", "cb", "gc", "pl", "tc", "lp", "resp", "buf", "tap", "pc", "pm", "wp", "pt", "erb", "bsp", "b", "ctx", "pa", "uf", "sb", "pg", "lb", "tk", "pool", "buff", "emb", "mb", "bs", "dp", "tp", "vp"], "track": ["trade", "trip", "allow", "tab", "store", "setup", "rack", "mont", "review", "rr", "move", "check", "query", "project", "scan", "work", "met", "skip", "send", "trace", "reflect", "req", "transform", "find", "add", "tp", "trak", "complete", "report", "sur", "consider", "round", "session", "sort", "tracking", "summary", "row", "contact", "comment", "package", "cmd", "Track", "mt", "metadata", "tm", "pkg", "require", "claim", "care", "jj", "stab", "match", "install", "tf", "ack", "txt", "record", "seek", "task", "tk", "token", "try", "tracks", "batch", "rt", "jump", "tt", "kick", "rank", "tn", "search", "ck", "tr", "roll", "att", "note", "handle", "form", "sync", "list", "call", "rule", "train", "sound", "btn", "feature", "follow", "upload", "stat"]}}
{"project": "qemu", "commit_id": "eaf136f9a21e02a2f55346e44d2d88df37b2cde3", "target": 0, "func": "static int slirp_socket_load(QEMUFile *f, struct socket *so)\n\n{\n\n    if (tcp_attach(so) < 0)\n\n        return -ENOMEM;\n\n\n\n    so->so_urgc = qemu_get_be32(f);\n\n    so->so_ffamily = qemu_get_be16(f);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        so->so_faddr.s_addr = qemu_get_be32(f);\n\n        so->so_fport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_faddr and so_lport\\n\");\n\n    }\n\n    so->so_lfamily = qemu_get_be16(f);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        so->so_laddr.s_addr = qemu_get_be32(f);\n\n        so->so_lport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_laddr and so_lport\\n\");\n\n    }\n\n    so->so_iptos = qemu_get_byte(f);\n\n    so->so_emu = qemu_get_byte(f);\n\n    so->so_type = qemu_get_byte(f);\n\n    so->so_state = qemu_get_be32(f);\n\n    if (slirp_sbuf_load(f, &so->so_rcv) < 0)\n\n        return -ENOMEM;\n\n    if (slirp_sbuf_load(f, &so->so_snd) < 0)\n\n        return -ENOMEM;\n\n    slirp_tcp_load(f, so->so_tcpcb);\n\n\n\n    return 0;\n\n}\n", "idx": 17301, "substitutes": {"f": ["fd", "cf", "ff", "fl", "g", "rf", "fe", "fp", "c", "h", "fac", "ef", "fb", "fc", "lf", "ex", "ile", "q", "fr", "y", "fx", "F", "um", "e", "r", "form", "ac", "l", "d", "tf", "m", "fa", "b", "fm", "v", "ct", "o", "uf", "out", "k", "ft", "sf", "fi", "full", "file", "fw", "w", "it", "of", "bf", "fo", "xf", "inf", "fn", "t", "conf", "fs", "z", "fed", "p"], "so": ["dylib", "sy", "cache", "sn", "rh", "le", "syn", "SO", "oh", "inho", "So", "o", "out", "po", "where", "sky", "hi", "lo", " s", "sel", "co", "ho", "sw", "ss", "ro", "obj", "ico", "soc", "cu", "shi", "s", "mo", "ce", "ow", "usr", "iso", "esh", "dev", "say", " o", "sl", "sum", "th", "ne", "os", "li", "stro", "go", "set", "sim", "sp", "ve", "lah", "since", "no", "pro", "py", "ssl", "sa", "ski", "bs", "bo", "si", "cho", "ox", "dll", "info", "oooo", "su", "server", "sc", "must", "ver", "sync", "num", "sing", "yes", "se", "see", "stone", "thus", "oso", "di", "sam", "fo", "ko", "sh"]}}
{"project": "qemu", "commit_id": "22f2e344748370b2e13888ba1057ebea2579970c", "target": 0, "func": "static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n", "idx": 17307, "substitutes": {"info": ["f", "type", "parse", "entry", "init", "ion", "update", "iter", "fee", "interface", "ki", "good", "report", "tab", "i", "unknown", "def", "os", "error", "Info", "doc", "details", "kind", "note", "by", "address", "check", "query", "request", "work", "help", "now", "num", "index", "id", "local", "off", " inf", "txt", " Info", "about", "INFO", "history", "ii", "comment", "fi", "where", "notice", "one", "data", "req", "success", "http", "follow", "jo", "exec", "it", "py", "op", "tif", "hi", "try", "fo", "inf", "show", "conf", "information", "add", "name", "job"], "dest": ["Dest", "tmp", "prop", "coord", "end", "st", "chain", "neg", "trans", "sec", "test", "iter", "cat", "temp", "lit", "origin", "port", "cont", "pas", "tr", "pos", "net", "master", "loc", "dist", "orig", "target", "src", "dat", "rel", "buf", "est", "d", "path", "sys", "sp", "txt", "v", "global", "n", "priv", "out", "gate", "ord", "gov", "desc", "asc", "alt", "req", "deg", "seq", "w", "gen", "source", "addr", "ptr", "dev", "dc", "rest", "decl"], "len": [" n", "ls", " offset", "fl", "length", "lan", "mil", "en", "Len", " pos", "vec", " bl", "mult", "iter", "yn", "lit", "lf", "le", "size", "fin", "syn", "pos", "bytes", "elt", "ll", "fil", "enc", "ell", "rel", " Len", "vol", "l", "den", "el", "imm", "sp", "von", "n", "mat", "mid", "val", " length", "lim", "lon", " l", "compl", " le", "coll", "mun", "gn", "seq", "alt", "ln", "mem", "fun", "inv", "gen", " en", "t", "wid", "cmp", "ld", "cond", " lang", "name"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)\n\n{\n\n    int next_avc    = h->is_avc ? 0 : buf_size;\n\n    int nal_index   = 0;\n\n    int buf_index   = 0;\n\n    int nals_needed = 0;\n\n\n\n    while(1) {\n\n        int nalsize = 0;\n\n        int dst_length, bit_length, consumed;\n\n        const uint8_t *ptr;\n\n\n\n        if (buf_index >= next_avc) {\n\n            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);\n\n            if (nalsize < 0)\n\n                break;\n\n            next_avc = buf_index + nalsize;\n\n        } else {\n\n            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);\n\n            if (buf_index >= buf_size)\n\n                break;\n\n        }\n\n\n\n        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,\n\n                                 next_avc - buf_index);\n\n\n\n        if (ptr == NULL || dst_length < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        buf_index += consumed;\n\n\n\n        bit_length = get_bit_length(h, buf, ptr, dst_length,\n\n                                    buf_index, next_avc);\n\n        nal_index++;\n\n\n\n        /* packets can sometimes contain multiple PPS/SPS,\n\n         * e.g. two PAFF field pictures in one packet, or a demuxer\n\n         * which splits NALs strangely if so, when frame threading we\n\n         * can't start the next thread until we've read all of them */\n\n        switch (h->nal_unit_type) {\n\n        case NAL_SPS:\n\n        case NAL_PPS:\n\n            nals_needed = nal_index;\n\n            break;\n\n        case NAL_DPA:\n\n        case NAL_IDR_SLICE:\n\n        case NAL_SLICE:\n\n            init_get_bits(&h->gb, ptr, bit_length);\n\n            if (!get_ue_golomb(&h->gb))\n\n                nals_needed = nal_index;\n\n        }\n\n    }\n\n\n\n    return nals_needed;\n\n}\n", "idx": 17308, "substitutes": {"h": ["f", "ih", "act", "ht", "bh", "host", "hw", "hd", "hh", "H", "c", "rh", "hal", "self", "q", "eh", "he", "event", "sh", "hz", "handle", "r", "hm", "ah", "oh", "l", "ac", "m", "ph", "b", "v", "kh", "k", "ctx", "hl", "history", "context", "w", "hp", "ch", "dev", "comm", "t", "hash", "hs", "j", "p"], "buf": ["proc", "tmp", "window", "cf", "cv", "ff", "block", "box", "br", "bh", "cache", "pkg", "cam", "vec", "wb", "bar", "Buff", "buffer", "cap", "Buffer", "cp", "rb", "bp", "bytes", "doc", "bag", "np", "p", "cb", "pb", "arr", "aka", "b", "v", "txt", "uf", "vp", "bc", "late", "alloc", "cmd", "data", "cur", "mem", "seq", "msg", "raw", "buff", "ob", "bin", "bf", "queue", "foo", "que", "batch"], "buf_size": [" buf_string", " buf2length", "buff_type", " buf_SIZE", " buf_speed", "buf_speed", "buf2speed", " buf_length", " buf_limit", " buf2index", "buff_length", "buf00size", "buf_length", "buf2scale", "buf_type", " buf2speed", "buf2length", "buf2SIZE", "buf_string", " buf2size", "uf_size", "uf_SIZE", "buf00string", "buf00index", "buf_index", "buf2size", " buf_scale", " buf_index", "buf_scale", "buf_limit", "buf2index", "buf_SIZE", "uf_index", "buff_index", "buff_size", "buf00limit"], "dst_length": ["dest_Length", "dest_distance", "dst_len", "dsttLength", "dst___index", "dest_count", "dsttcount", "dst___length", "dtd_Length", "dstablelength", "dtdabletranslation", "dsttlen", "dest_len", "dstabletranslation", "dst_count", "dest_length", "dtd_translation", "dtdableLength", "dst_translation", "dst_index", "dtdableshape", "dstttranslation", "dstableshape", "dst___count", "dsttlength", "dsttindex", "dtd_length", "dst_shape", "dest_code", "dest_index", "dtdablelength", "dst_Length", "dst___len", "dstableLength", "dst_distance", "dtd_shape", "dsttshape", "dst_code"], "bit_length": ["port5len", "bit_needed", "bit_position", "bit_Length", "bit2length", "bit5needed", " bit_distance", "bit2needed", "port_needed", "bit5Length", "bit36length", "bitmatposition", "bit48code", "port5Length", "port5length", "bit5length", "bit_distance", "bitmatcode", "bit_code", "bit48info", "port5needed", "block_position", " bit_vector", "block48length", "bit48length", "bit36info", "bit_vector", "block_info", "block_code", "port_len", "block48info", "block_length", "bit5len", "bit2Length", "bit2len", "block48code", "port_length", "bitmatlength", "port_Length", "bitmatinfo", "bit36position", " bit_Length", "bit_info", "bit48position", "block48position", "bit36code", "bit_len"], "consumed": ["cserved", "conumption", "csume", "csumption", "csused", "consused", "Consused", " consuming", "preserved", " unconsume", " unconsuming", "conused", "Conserved", "conserved", "presumption", "conume", " consumption", " consume", "Consumed", "Consumption", "Consume", "conumed", "presume", "consuming", "Consuming", " unconsumption", " unconsumed", "consume", "presumed", "consumption", "csumed"], "ptr": ["prime", "pad", "coord", "offset", "br", "ref", "ctr", "ind", "pointers", "crop", "jp", "fp", "push", "iter", "copy", "temp", "err", "td", "rc", "pointer", "pr", "buffer", "tr", "pos", "np", "iv", "loc", "handle", "r", "address", "arr", "rect", "pc", "pt", "ts", "cut", "index", "sp", "inters", "ctx", "code", "inter", "Ptr", "dep", "alloc", "cmd", "next", "cur", "mem", "dr", "buff", "addr", "rep", "tp", "j", "p"], "nal_index": ["nal_ind", "naldixindex", "nal_offset", "naltpoint", "nal_point", "naldixoffset", "naltindex", "nbal_level", "naltnumber", "nbal_point", "nale_value", "nalixoffset", "nalixin", "nbal_Index", "naldixin", "nbal_ind", "nald_offset", "nbal_index", "nal_number", "nale_Index", "naldixid", "nal_Index", "nald_in", "nal_id", "nald_id", "nale_index", "nalixindex", "nal_level", "nalixid", "nal_in", "nal_value", "nbal_number", "nald_index"]}}
{"project": "qemu", "commit_id": "e514fc7e1231c6d95011e448e6c626f2bb6f3cd8", "target": 0, "func": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n\n                             const E1000E_RxRing *rxr,\n\n                             const E1000E_RSSInfo *rss_info)\n\n{\n\n    PCIDevice *d = core->owner;\n\n    dma_addr_t base;\n\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n\n    size_t desc_size;\n\n    size_t desc_offset = 0;\n\n    size_t iov_ofs = 0;\n\n\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n\n    size_t size = net_rx_pkt_get_total_len(pkt);\n\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n\n    const E1000E_RingInfo *rxi;\n\n    size_t ps_hdr_len = 0;\n\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n\n\n\n    rxi = rxr->i;\n\n\n\n    do {\n\n        hwaddr ba[MAX_PS_BUFFERS];\n\n        e1000e_ba_state bastate = { { 0 } };\n\n        bool is_last = false;\n\n        bool is_first = true;\n\n\n\n        desc_size = total_size - desc_offset;\n\n\n\n        if (desc_size > core->rx_desc_buf_size) {\n\n            desc_size = core->rx_desc_buf_size;\n\n        }\n\n\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n\n\n        if (ba[0]) {\n\n            if (desc_offset < size) {\n\n                static const uint32_t fcs_pad;\n\n                size_t iov_copy;\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > core->rx_desc_buf_size) {\n\n                    copy_size = core->rx_desc_buf_size;\n\n                }\n\n\n\n                /* For PS mode copy the packet header first */\n\n                if (do_ps) {\n\n                    if (is_first) {\n\n                        size_t ps_hdr_copied = 0;\n\n                        do {\n\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n\n                                           iov->iov_len - iov_ofs);\n\n\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                      iov->iov_base, iov_copy);\n\n\n\n                            copy_size -= iov_copy;\n\n                            ps_hdr_copied += iov_copy;\n\n\n\n                            iov_ofs += iov_copy;\n\n                            if (iov_ofs == iov->iov_len) {\n\n                                iov++;\n\n                                iov_ofs = 0;\n\n                            }\n\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n\n\n                        is_first = false;\n\n                    } else {\n\n                        /* Leave buffer 0 of each descriptor except first */\n\n                        /* empty as per spec 7.1.5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n", "idx": 17314, "substitutes": {"d": ["fd", "f", "did", "dra", "dx", "bd", "c", "dn", "du", "h", "ad", "dq", "dt", "D", "da", "dm", "dir", "e", "r", "dh", "l", "m", "id", "b", "core", "dd", "dom", "db", "ds", "di", "dr", "w", "t", "dc", "cd", "p"], "base": ["f", "extra", "pad", "bit", "length", "offset", "bi", "end", "based", "chain", "h", "bar", "origin", "ias", "parent", "root", "i", "size", "Base", "buffer", "store", "bottom", "server", "len", "bp", "orig", "set", "da", "address", "m", "ma", "id", "index", "client", "bid", "b", "pa", "back", "area", "basic", "ase", "db", "prefix", "file", "bal", "it", "domain", "bound", "bas", "start", "bu", "stable", "bs", "meta", "bo", "kit", "p"], "desc": ["rib", "label", "ext", "init", "bd", "ribe", "disc", "err", "rc", "des", "def", "cont", "sc", "ript", "res", "doc", "sub", "dist", "loc", "pb", "dir", "resp", "buf", "rec", "txt", "DES", "ctx", "cd", "code", "comment", "description", "cmd", "asc", "req", "mem", "seq", "msg", "pro", "Desc", "dict", "cmp", "esc", "dc", "name"], "desc_size": ["desc10offset", "desc_unit", "dest_len", "descalheight", "comment67go", "Desc_offset", "desc_start", "comment67height", "comment_start", "desc_len", "des_size", "des_ize", "comment_size", "desc67size", "dest10unit", "dest_unit", "dest10len", "desc10size", "desc_ize", "desc_height", "comment67start", "desc10len", "des_sum", "dest10size", "dest10offset", "des_copy", "desc67start", "desc_go", "desc_copy", "descalgo", "desc10unit", "desc_sum", "desc67height", "desc_offset", "dest_size", "comment67size", "descalstart", "desc_length", "comment_height", "desc67go", "Desc_length", "comment_go", "Desc_size", "Desc_sum", "descalsize", "dest_offset"], "iov": ["ih", "inn", "iol", "vr", "iw", "veh", "river", "uart", "serv", "conv", "voc", "server", "io", "iv", "iu", "iam", "rio", "vers", "v", "ev", "ei", "ilo", "iop", "verb", "vo", "ever", "iph", "vp"], "rxi": ["rmi", "hci", " rzi", "rpi", "Rri", "rXi", "rozi", "Rci", "wpi", "rofi", " rXi", "rzi", "Rxi", "rri", "wXi", "rfi", "roXi", "rdmi", "hpi", "Rzi", "rtmi", "wxi", "roci", "rdci", " rri", "rdXi", " rci", "roxi", "rci", "rdfi", "rdri", "rtri", "rtci", "rdxi", "rtxi", "hXi", "wci", " rpi", "Rfi", " rmi", "hxi", "rori", "RXi"], "ba": [" br", "box", "aba", "br", " ca", "na", "as", " a", "aaaa", "a", "bd", " bl", "ta", "bean", "ca", "bar", "abc", "BA", "ro", "bp", "ea", "aa", "ha", "pb", "da", "ka", "buf", " BA", "ra", "fa", "ena", " b", "ava", "b", "pa", "aaa", "bc", "va", "wa", "rab", "aco", "bl", "oa", "una", "sa", "la", "ps", "aos", "bs", "bu", "dc", "bo"], "fcs_pad": ["fcsitypad", "fcs_size", "fls__size", "fcsityoffset", "fcs__pad", "fls__pad", "fls_free", "fls_pad", "fcs__offset", "fls_offset", "fcs__size", "fls__free", "fcs__free", "fcs_free", "fls__offset", "fcsitysize", "fls_size", "fcsityfree", "fcs_offset"], "iov_copy": ["iovaccopy", "iovaccop", "iov_offset", "io_cop", "iovacrepeat", "io_repeat", "iov_cop", "iov_repeat", "io_offset", "io_copy", "iovacoffset"]}}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static int cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n\n{\n\n    int sx = 0, sy = 0;\n\n    int dx = 0, dy = 0;\n\n    int depth = 0;\n\n    int notify = 0;\n\n\n\n    /* make sure to only copy if it's a plain copy ROP */\n\n    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||\n\n        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {\n\n\n\n        int width, height;\n\n\n\n        depth = s->vga.get_bpp(&s->vga) / 8;\n\n        if (!depth) {\n\n            return 0;\n\n        }\n\n        s->vga.get_resolution(&s->vga, &width, &height);\n\n\n\n        /* extra x, y */\n\n        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;\n\n        sy = (src / ABS(s->cirrus_blt_srcpitch));\n\n        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;\n\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n\n\n        /* normalize width */\n\n        w /= depth;\n\n\n\n        /* if we're doing a backward copy, we have to adjust\n\n           our x/y to be the upper left corner (instead of the lower\n\n           right corner) */\n\n        if (s->cirrus_blt_dstpitch < 0) {\n\n            sx -= (s->cirrus_blt_width / depth) - 1;\n\n            dx -= (s->cirrus_blt_width / depth) - 1;\n\n            sy -= s->cirrus_blt_height - 1;\n\n            dy -= s->cirrus_blt_height - 1;\n\n        }\n\n\n\n        /* are we in the visible portion of memory? */\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\n            (sx + w) <= width && (sy + h) <= height &&\n\n            (dx + w) <= width && (dy + h) <= height) {\n\n            notify = 1;\n\n        }\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n\n                      s->vga.vram_ptr + s->cirrus_blt_srcaddr,\n\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n\n\n    if (notify) {\n\n        dpy_gfx_update(s->vga.con, dx, dy,\n\n                       s->cirrus_blt_width / depth,\n\n                       s->cirrus_blt_height);\n\n    }\n\n\n\n    /* we don't have to notify the display that this portion has\n\n       changed since qemu_console_copy implies this */\n\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t\ts->cirrus_blt_height);\n\n\n\n    return 1;\n\n}\n", "idx": 17325, "substitutes": {"s": ["is", "as", "states", "args", "reports", "js", "y", "ies", "vs", "details", "ims", "rows", "ids", "v", "has", "stats", "qs", "ses", "less", "als", "terms", "bes", "bits", "eps", "aws", "sw", "ports", "ants", "ss", "grades", "ns", "events", "spec", "ms", "parts", "bis", "sports", "S", "results", "cs", "conf", "sis", "hs", "ges", "sts", "g", "rs", "south", "ops", "sq", "ex", "self", "os", "l", "mods", "sb", "gs", "gets", "ows", "comm", "bs", "ls", "sv", "ins", "changes", "settings", "params", "r", "erences", "ats", "ts", "sys", "its", "reads", "se", "eds", "tests", "ds", "ps", "t", "fs", "es"], "dst": ["Dest", "nst", "Dyn", "host", "hyn", " dST", "hnt", "dyn", " dnt", "ddth", "nth", "dnt", " dost", "gost", "gST", "hst", "gst", "dset", "nset", "hest", "rth", "rst", "dth", "ddst", "hST", "dest", "dost", "ddyn", " dth", "ddest", "nsts", "rset", "rsts", " dset", "Dst", "dST", "dsts", " dsts", "gnt", "Dth", "hth"], "src": ["lr", "rt", "sl", "hr", "ser", "th", "bh", "g", "st", "ctr", "ins", "sec", "vr", "sq", "std", "rx", "origin", "rc", "rl", "eth", "urg", "sc", "syn", "obs", "in", "sub", "iv", "loc", "inst", "sr", "r", "dir", "sync", "sys", "dest", "b", "v", "txt", "hl", "desc", "req", "cur", "fw", "source", "addr", "usr", "ptr", "start"], "w": ["window", "th", "g", "hw", "sw", "iw", "wd", "wb", "win", "ex", "q", "y", "wx", "r", "wi", "rw", "l", "d", "nw", "m", "kw", "v", "wl", "ww", "ew", "wa", "wh", "weight", "x", "fw", "W", "ow", "wid", "we", "ch", "wt", "wr", "p"], "h": ["hr", "ih", "f", "ht", "bh", "g", "hei", "ho", "hw", "hop", "hd", "hh", "H", "c", "a", "depth", "hs", "i", "q", "he", "y", "ish", "head", "ha", "hz", "r", "e", "hm", "oh", "l", "m", "d", "ph", "b", "v", "n", "hl", "x", "html", "hi", "ch", "t", "hash", "sh", "z", "j", "p"], "height": ["high", "ih", "window", "length", "volume", "ht", "rank", "hei", "hh", "depth", "xy", "size", "gravity", "radius", "shape", "buffer", "dim", "scale", "padding", "y", "power", "max", "headers", "ph", "v", "time", "history", "total", "ty", "angle", "hang", "wh", "weight", "count", "capacity", "x", "html", "resolution", "ows", "sky", "density", "Height", "ch", "hash"]}}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17328, "substitutes": {"bs": ["ls", "sts", "bh", "bits", "ubs", "outs", "iss", "aws", "BS", "js", "lbs", "ss", "bp", "obs", "blog", "vs", "ns", "ubis", "ms", "ts", "its", "acs", "b", "bis", "sb", "bc", "cks", "bos", "ds", "ses", "aus", "gs", "cs", "aos", "las", "als", "fs", "hs", "bes"], "l1_index": ["l1_num", "l7__index", "l7__label", "l3_index", "l7_Index", "l7_index", "l1__index", "l7__ind", "l1__num", "l1_Index", "l3_position", "l3_address", "l1__ind", "l1_ind", "l1__position", "l7_ind", "l3_num", "l1__label", "l1__Index", "l1__address", "l1_address", "l7_label", "l1_label", "l1_position", "l7__Index"], "s": ["ls", "is", "sts", "sv", "rs", "ins", "sn", "aws", "a", "h", "sq", "sis", "js", "css", "os", "ss", "serv", "ies", "y", "vs", "ns", "ats", "ts", "sys", "its", "b", "v", "bis", "sb", "stats", "ds", "http", "ses", "qs", "S", "ssl", "gs", "cs", "sa", "ps", "fs", "hs", "p"], "buf": ["text", "window", "cf", "cv", "tmp", "block", "ff", " buffer", "br", "ref", "ctr", "pkg", "cam", "result", "vec", "iter", "wb", "err", "bar", "fb", "tab", "port", "buffer", "cap", "fr", "Buffer", "cp", "rb", "tr", "bytes", "bag", "img", "cb", "pb", "arr", "rw", "eb", "b", "v", "var", "txt", "uf", "ctx", "code", "bc", "str", "cmd", "data", "desc", "next", "cur", "mem", "seq", "loop", "msg", "bl", "raw", "buff", "pool", "pack", "queue", "alph"], "l1_start_index": ["l1_end_length", "l1_end_len", "l1_stop_index", "l1_start_length", "l1_end_position", "l1_stop_ind", "l1_end_index", "l1_stop_Index", "l1_start_position", "l1_start_Index", "l1_end_Index", "l1_start_len", "l1_end_point", "l1_start_ind", "l1_start_point"], "i": [" I", "is", "bi", "gi", "ind", "init", "a", "c", "iter", "ri", "xi", "point", "ai", "ini", "inner", "or", "port", "li", "ui", "ic", "y", "ip", "io", "in", " ii", "\u0438", "ims", "pi", "iu", "qi", "im", "e", "zi", "ci", "my", "ms", "l", "sim", "m", "me", "index", "ji", "v", "k", "I", "o", "n", "ii", "ti", "print", "fi", "phi", "ix", "x", "span", "di", "uri", "it", "mi", " j", "ie", "ij", "iq", "t", "multi", "yi", "j", "si", "p"], "ret": ["rt", "xt", "ext", "gt", "en", "result", "leg", "lt", "err", "rem", "def", "cont", "dt", "len", "tr", "res", "ben", "elt", "gc", "ll", "re", "flag", "r", "att", "arg", "det", "RET", "Ret", "ter", "tf", "arr", "vet", "txt", "back", "out", "ft", "code", "nz", "git", "val", "fi", "print", "rets", "cmd", "alt", "mem", "deg", "status", "no", "it", "fun", "nt", "aux", "try", "pret", "usr", "mt", "ptr", "addr", "t", "red"]}}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n                   VhostBackendType backend_type)\n{\n    uint64_t features;\n    int i, r;\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n        close((uintptr_t)opaque);\n        return -1;\n    }\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n        close((uintptr_t)opaque);\n        return -errno;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n    if (r < 0) {\n        goto fail;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n    if (r < 0) {\n        goto fail;\n    }\n    for (i = 0; i < hdev->nvqs; ++i) {\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);\n        if (r < 0) {\n            goto fail_vq;\n        }\n    }\n    hdev->features = features;\n    hdev->memory_listener = (MemoryListener) {\n        .begin = vhost_begin,\n        .commit = vhost_commit,\n        .region_add = vhost_region_add,\n        .region_del = vhost_region_del,\n        .region_nop = vhost_region_nop,\n        .log_start = vhost_log_start,\n        .log_stop = vhost_log_stop,\n        .log_sync = vhost_log_sync,\n        .log_global_start = vhost_log_global_start,\n        .log_global_stop = vhost_log_global_stop,\n        .eventfd_add = vhost_eventfd_add,\n        .eventfd_del = vhost_eventfd_del,\n        .priority = 10\n    };\n    hdev->migration_blocker = NULL;\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n        error_setg(&hdev->migration_blocker,\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n        migrate_add_blocker(hdev->migration_blocker);\n    }\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n    hdev->n_mem_sections = 0;\n    hdev->mem_sections = NULL;\n    hdev->log = NULL;\n    hdev->log_size = 0;\n    hdev->log_enabled = false;\n    hdev->started = false;\n    hdev->memory_changed = false;\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n    return 0;\nfail_vq:\n    while (--i >= 0) {\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n    }\nfail:\n    r = -errno;\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n    QLIST_REMOVE(hdev, entry);\n    return r;\n}", "idx": 17329, "substitutes": {"hdev": ["hdserial", "ohcase", "hostev", "ahdev", "ehDEV", "vdev", "Hdata", "ahDEV", " hobj", "hidev", "ohver", "hDevice", "Hinfo", " hev", "bhcast", "htdevice", "Hconn", " hDEV", "ahcmd", "thcast", "hdDEV", "Hsys", "ehev", "hpad", "hdebug", "hwindow", "hsys", "vdata", "vDEV", "hver", "hicase", "shcast", "ehdef", " hcam", " hcast", "hev", "ohdebug", "hostdev", "ehdebug", "shev", "ehdata", "bhdevice", "hmvar", "Hev", "ohcache", "vcam", " hinfo", "hdef", "ehcache", "hostdevice", "hddevice", " hDevice", "htev", " hdebug", "ohobj", "hconn", "ehcam", " hdata", "Hserial", "ohev", "ohwindow", "ehdevice", "ohDEV", "ehsys", " hpad", "thdev", " hvar", "hmdev", "shdevice", "Hdev", "hinfo", "hostserial", "hvar", "ohvar", "hcam", "ehpad", " hcache", "hserial", "ohdevice", "bhDevice", "hobj", "hiobj", "htdev", " hver", "Hver", "Hdef", " hcmd", "vconn", " hsys", "ohinfo", "hddev", "Hcam", "vdef", "ohdev", "hidevice", "vdevice", "ehcmd", " hdef", " hdevice", "hcast", "htDEV", "hcase", "ehcast", "hDEV", "hcmd", "shdev", "ehdev", "thdevice", "thDevice", " hserial", "vev", "ehconn", "bhdev", "hdata", "ohserial", "hmdevice", " hwindow", "ahdevice", "hdevice", "ohdata", " hcase", "ohpad", "Hdevice", "hcache", "hmwindow"], "opaque": ["OPserver", "observer", "operaco", "oplay", "opent", "operque", " opener", "paque", "operatile", "pserver", " opatile", "opatile", "postque", "opacity", "operaque", " opque", "OPaque", "postacity", "operener", "postatile", "OPacity", "operaques", "obaque", "ocaco", " opaques", "OPaques", "obacity", "opque", " opacity", "operlay", "pacity", "play", "paques", "opserver", "operacity", " opent", "pent", "opener", "operent", " oplay", "ocener", "ocaque", "obaques", "ocque", "opaco", "opaques", "postaque", " opaco"], "backend_type": ["backendetyype", "backendpytype", "backend7ype", "backendetytype", "backend_role", "backend7name", "backbindetyname", "backbind_ype", "backserver_type", "backendetytypes", "backend_path", "backbind_name", "backendetypath", "backbind_type", "backbindetyclass", "backend_name", "backend7type", "backend_ype", "backserver_role", "backendpyrole", "backserver_path", "backendetyname", "backend_class", "backbindetyype", "backserver_types", "backbind_class", "backendetyrole", "backend_types", "backbindetytype", "backend7class", "backendetyclass", "backendpypath", "backendpytypes"], "features": [" capabilities", "fts", "modules", "relations", "bugs", "acts", "bits", "ributes", "ints", "states", "changes", "fixes", "mas", "versions", " feat", "settings", "fc", "reports", " frames", "ports", "properties", "names", "ensions", "players", "workers", "pins", "events", " Features", "feat", "types", "classes", "rows", "forms", "actions", "performance", "effects", "options", "issues", "weights", "sections", " interfaces", "Features", "services", "orts", "faces", "fields", "eatures", "devices", "frames", "facts", "feature", "tests", "stats", "plugins", "words", "vals", "format", "files", "flags", "abilities", "results", "tags", "items", "details"], "i": ["f", "is", "bi", "gi", "ind", "chain", "c", "h", "xi", "err", "cli", "info", "ai", "ia", "ini", "batch", "q", "li", "ui", "ic", "ip", "y", "io", "\u0438", " ii", "ami", "pi", "iu", "qi", "u", "im", "e", "ci", "zi", "l", "me", "m", "asi", "id", "ji", "index", "v", "I", "n", "ii", "ei", "ti", "phi", "ix", "x", "di", "it", "mi", "ie", "hi", "try", "t", "multi", "j", "si", "p"], "r": ["kr", "rt", "lr", "hr", "resource", "cr", "br", "run", "g", "rs", "rf", "er", "mr", "entry", "result", "ir", "h", "c", "nr", "ren", "err", "rc", "rar", "pr", "or", "attr", "rem", "q", "fr", "radius", "ret", "ro", "rb", "tr", "res", "rg", "error", "rr", "re", "ur", "sr", "arr", "rw", "m", "d", "row", "R", "record", "ry", "ar", "dr", "rm", "t", "rd", "repl", "rn", "response", "j", "p"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 17337, "substitutes": {"bs": ["ls", "sts", "bh", "ks", "bits", "rs", "ubs", "outs", "ins", "iss", "ics", "BS", "js", "lbs", "ss", "bp", "obs", "blog", "vs", "bytes", "ns", "ims", "hz", "soc", "ubis", "ms", "ats", "ts", "sys", "its", "fps", "b", "bis", "bn", "sb", "bc", "cks", "irms", "bos", "ds", "qs", "ses", "bps", "aus", "gs", "bas", "cs", "boxes", "ps", "aos", "las", "als", "fs", "hs", "bes", "es"], "sector_num": ["unit_ident", "sectorNamenom", "unitityident", "sectorNamenum", "sector_Num", "sectorNameNum", "unititydec", "sectorityident", "sectoritynum", "sector9num", "sectorityhex", "sectorNamedec", "sector9hex", "unititynum", " sector_nom", "unit_dec", "sector9ident", "sector_hex", " sector_Num", "sectorNamehex", "sector9dec", "unit_num", "sectoritydec", "sector_pub", " sector_sym", "sector_nu", " sector_nu", "sector_dec", "unit_hex", "sector_nom", "unitityhex", "sector_ident", "sectorNameident", "sectorNamenu", "sectorNamepub", " sector_pub", "sector_sym", "sectorNamesym"], "buf": ["proc", "tmp", "window", "cv", "block", "br", "vec", "wb", "bar", "fb", "Buff", "buffer", "cap", "q", "Buffer", "rb", "bytes", "doc", "img", "p", "read", "cb", "pb", "aka", "BU", "b", "v", "txt", "uf", "bc", "str", "cmd", "db", "alloc", "data", "cur", "mem", "seq", "msg", "raw", "buff", "bin", "queue", "batch"], "nb_sectors": ["nb_heors", "nb_hectors", "nb_seivers", "nb_ieors", "nb_vevers", "nb_vechers", "nb_serriers", "nb_seors", "nb_psecs", "nb_hechers", "nb_sears", "nb_estors", "nb_psevers", "nb_sechers", "nb_pevers", "nb_hears", "nb_estctors", "nb_serors", "nb_veors", "nb_iears", "nb_vears", "nb_serivers", "nb_serctors", "nb_iectors", "nb_veivers", "nb_pectors", "nb_peors", "nb_vectors", "nb_severs", "nb_veriers", "nb_estivers", "nb_pecs", "nb_seriers", "nb_iechers", "nb_secs", "nb_psectors", "nb_vecs", "nb_pseors", "nb_estriers"], "drv": ["rdc", "drch", "ldvs", "delver", "Drvr", "drve", "drih", "derV", "srl", "driv", "srx", "drw", "drf", " drver", "DRvr", "drl", "Drve", " drw", "crch", "DRj", "crv", "crvs", "Drver", "mrx", "crc", "drav", "drV", "src", " drj", "drx", "drver", " drV", " drvr", "rdx", "mrv", "vrv", " drh", " drf", "srv", "srch", "vrf", "vrj", "DRV", "rdl", "ldch", "Drh", "Drv", "DRv", " drve", "drj", "Drw", "derv", "drivr", " drav", "drive", "Drav", "delv", "delav", "mrl", "derj", "rdv", "rdf", "ldc", "ldv", "srvs", "dervr", "mrc", "vrvr", "drc", "drh", "drvr", "delw", "rdj", "rdvr", "drvs"], "ret": ["rt", "get", "xt", "ext", "gt", "ref", "en", "result", "leg", " RET", "lt", "err", "lit", "rem", "def", "cont", " alt", "flag", "fin", "del", "res", "elt", "ll", "re", "arg", "r", "resp", "arr", "det", "RET", "Ret", "rev", "ter", "num", "vet", "el", "txt", "back", "out", " Ret", "cert", "code", "reset", "val", "rets", "rot", "cmd", "str", "alt", "compl", "mem", "deg", "fun", "nt", "pret", "t", "repl", "red"], "len": ["ls", "sl", "fl", "length", "lan", "all", "en", "Len", "vec", "lt", "lit", "dl", "lf", "valid", "le", "size", "nl", "li", "fin", "del", "syn", "pos", "bytes", "elt", "ll", "fil", "pl", "ell", "lp", "resp", "vol", "l", "el", "sp", "n", "val", "str", "empty", "lim", "lon", "full", "compl", "mem", "seq", "lib", "ln", "els", "fun", "lis", "nt", "t", "L", "cmp", "ld"], "rd_ops": ["drLoper", "dr_reads", "drLreads", "rd_reads", "rdpooper", "rdporeads", "rd_bytes", "rdLoper", "dr_bytes", "drLbytes", "rdLreads", "dr_ops", "rdpobytes", "drLops", "rdpoops", "dr_oper", "rdLbytes", "rdLops", "rd_oper"]}}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n", "idx": 17341, "substitutes": {"p1": [" pOne", "perm0", "tp0", "tp2", "P3", "P2", " p0", "pOne", "v1", "P0", "p0", "v0", "p3", "P1", "tpOne", "p81", "v81", "perm81", "POne", "perm3", "P81", "perm1", "tp1", "v3"], "p2": ["point02", "jp6", "cp2", "jp0", " p02", "p6", " p6", "jp2", "tp0", "tp2", " p0", "point2", "p0", "point6", "p02", "cp02", "tp6", "cp1", "cp6", "point1"], "cdt": ["pdt", "sdt", " cdte", "cdg", "codte", "cdte", "cedt", "coddt", "codts", "pde", "cttd", " cddt", "codrt", " cde", "sdg", "cdtd", "pdts", "cedte", "cdts", "cdrt", "pdte", "ctte", "codg", "ctt", " cdrt", "cdx", " cdtd", "codt", " cdts", "ctx", "cedx", "code", "cddt", "sdrt", "cde", "sddt", " cdg", " cdx", "cedtd"], "r": ["lr", "rt", "f", "cr", "br", "attr", "g", "rf", "er", "rs", "mr", "vr", "c", "nr", "ri", "h", "err", "rc", "i", "rar", "q", "fr", "ro", "rb", "tr", "res", "rr", "u", "re", "rate", "sr", "ur", "d", "m", "R", "v", "ar", "rd", "it", "dr", "rm", "t", "range", "rn", "red", "p"], "b": ["nb", "ble", "bb", "binary", "bh", "br", "bi", "blue", "B", "a", "c", "h", "wb", "fb", "bar", "i", "ab", "rb", "body", "cb", "ib", "l", "d", "eb", "v", "bg", "be", "reb", "back", "sb", "bc", "db", "gb", "ba", "bl", "bin", "bound", "ob", "base", "bf", "bu", "mb", "t", "bs", "bo", "p"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,\n\n                        const AVFrame *ref)\n\n{\n\n    PSNRContext *s = ctx->priv;\n\n    double comp_mse[4], mse = 0;\n\n    int j, c;\n\n    AVDictionary **metadata = avpriv_frame_get_metadatap(main);\n\n\n\n    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,\n\n                      (const uint8_t **)ref->data, ref->linesize,\n\n                       main->width, main->height, comp_mse);\n\n\n\n    for (j = 0; j < s->nb_components; j++)\n\n        mse += comp_mse[j] * s->planeweight[j];\n\n\n\n    s->min_mse = FFMIN(s->min_mse, mse);\n\n    s->max_mse = FFMAX(s->max_mse, mse);\n\n\n\n    s->mse += mse;\n\n    for (j = 0; j < s->nb_components; j++)\n\n        s->mse_comp[j] += comp_mse[j];\n\n    s->nb_frames++;\n\n\n\n    for (j = 0; j < s->nb_components; j++) {\n\n        c = s->is_rgb ? s->rgba_map[j] : j;\n\n        set_meta(metadata, \"lavfi.psnr.mse.\", s->comps[j], comp_mse[c]);\n\n        set_meta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n\n    }\n\n    set_meta(metadata, \"lavfi.psnr.mse_avg\", 0, mse);\n\n    set_meta(metadata, \"lavfi.psnr.psnr_avg\", 0, get_psnr(mse, 1, s->average_max));\n\n\n\n    if (s->stats_file) {\n\n        fprintf(s->stats_file, \"n:%\"PRId64\" mse_avg:%0.2f \", s->nb_frames, mse);\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"mse_%c:%0.2f \", s->comps[j], comp_mse[c]);\n\n        }\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"psnr_%c:%0.2f \", s->comps[j],\n\n                    get_psnr(comp_mse[c], 1, s->max[c]));\n\n        }\n\n        fprintf(s->stats_file, \"\\n\");\n\n    }\n\n\n\n    return main;\n\n}\n", "idx": 17350, "substitutes": {"ctx": ["tmp", "act", "cv", "conn", "Context", "hw", "pkg", "init", "jp", "tx", "cm", "anc", "js", "ck", "mc", "ic", "cp", "sc", "conv", "jac", "np", "obj", "tc", "ac", "con", "cc", "kw", "k", "ct", " cx", "bc", "xc", "context", "mk", "cmd", "lex", "x", "conf", "p"], "ref": ["f", "ror", "br", "g", "rf", "ef", "info", "Ref", "rc", "rem", "tab", "self", "def", "range", "fr", "q", "ro", "res", "master", "re", "rel", "r", "rev", "reference", "m", "vm", "b", "v", "Reference", "primary", "db", "link", "phys", "REF", "alt", "external", "mem", "lib", "base", "ob", "foreign", "conf", "repl", "p"], "s": ["us", "is", "er", "as", "fs", "a", "h", "args", "sm", "js", "i", "store", "styles", "y", "vs", "ims", "e", "series", "single", "v", "utils", "o", "stats", "storage", "qs", "ses", "less", "http", "comments", "als", "f", "st", "aws", "sw", "shared", "ss", "https", "ns", "export", "sd", "spec", "sort", "ms", "parts", "space", "services", "state", "tools", "w", "S", "hs", "p", "sl", "sts", "g", "rs", "simple", "south", "sq", "ex", "service", "self", "os", "set", "l", "m", "sb", "gs", "sa", "comm", "bs", "tags", "ls", "esm", "sv", "changes", "so", "settings", "info", "search", "scripts", "this", "ats", "ts", "sys", "its", "b", "se", "n", "sql", "tests", "ds", "sym", "sam", "csv", "ps", "t", "details", "z", "es"], "comp_mse": ["comp_amsex", "comp_rse", "comp_emse", "comp_lse", "comp_Mse", "comp_msene", "comp_cte", "comp_msese", "comp_msze", "comp_ampe", "comp_mese", "comp_rest", "comp_pte", "comp_lte", "comp_nest", "comp_nte", "comp_imse", "comp_cse", "comp_emte", "comp_amese", "comp_lpe", "comp_amte", "comp_fmse", "comp_emene", "comp_mest", "comp_mste", "comp_mme", "comp_ppe", "comp_Mte", "comp_rmte", "comp_lene", "comp_rsee", "comp_cme", "comp_amene", "comp_pse", "comp_lme", "comp_lze", "comp_npe", "comp_msme", "comp_pese", "comp_msex", "comp_Mze", "comp_fmte", "comp_nse", "comp_mte", "comp_amze", "comp_imze", "comp_fmge", "comp_rmse", "comp_msse", "comp_amge", "comp_rte", "comp_Mpe", "comp_amse", "comp_lese", "comp_mssex", "comp_imsex", "comp_rmsee", "comp_cene", "comp_mze", "comp_fmene", "comp_imese", "comp_mge", "comp_nese", "comp_rmest", "comp_msee", "comp_mpe", "comp_mene", "comp_nsee", "comp_emge"], "j": ["er", "js", "i", "fr", "y", "jac", " ii", "v", "dj", "o", "oj", "req", "kat", " J", " i", "jl", "jah", "br", "ju", "json", "ot", "jet", "obj", "im", "el", "off", "Ja", "ev", "kid", "uj", "ie", "ch", "adj", " dj", "job", "p", "g", "ind", "jc", "q", "jj", "by", "je", "l", "pt", "m", "k", "x", "jit", "jo", "dr", "at", "ij", "bo", " n", "jump", "J", "ja", "bj", "jp", "ion", "ijk", "kj", "tr", "aj", "att", "ng", "ji", "b", "n", "eg", "str", "ix", "it", "t", "z"], "c": ["f", "cf", "lc", "cv", "cr", "g", "cache", "chain", "cn", "C", "jc", "h", "ca", "cm", "com", "fc", "abc", "i", "rc", "mc", "cont", "cp", "sc", "gc", "cb", "unc", "u", "cu", "r", "ci", "ac", "l", "m", "cut", "cc", "v", "k", "ct", "cd", "o", "code", "color", "bc", "uc", "ce", "count", "col", "ec", "cs", "ch", "t", "co", "dc", "cor", "p"], "metadata": ["java", "adata", "binary", "header", "config", "xml", "sample", "mx", "tar", "settings", "ATA", "memory", "json", "chart", "shared", "definition", "params", "drm", "setup", "ata", "np", "annot", "note", "ka", "xxx", "message", "pdf", "m", "summary", "generic", "options", "template", "vp", "dd", "met", "primary", "database", "wrapper", "latest", "md", "cmd", "package", "data", "managed", "storage", "mem", "rpm", "magic", "directory", "source", "csv", "mt", "layout", "meta", "details", "partial", "license", "detail"], "nb_frames": ["num_frame", "nb__images", "num_images", "num_series", "nb__frame", "nb__series", "nb_frame", "nb__obs", "num_flows", "num_obs", "nb_series", "nb__flows", "nb_obs", "nb__frames", "num_frames", "nb_images", "nb_flows"]}}
{"project": "FFmpeg", "commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "target": 1, "func": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n\n{\n\n    EbmlList *index_list;\n\n    MatroskaIndex *index;\n\n    int index_scale = 1;\n\n    int i, j;\n\n\n\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n\n        return;\n\n\n\n    index_list = &matroska->index;\n\n    index      = index_list->elem;\n\n    if (index_list->nb_elem &&\n\n        index[0].time > 1E14 / matroska->time_scale) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n\n        index_scale = matroska->time_scale;\n\n    }\n\n    for (i = 0; i < index_list->nb_elem; i++) {\n\n        EbmlList *pos_list    = &index[i].pos;\n\n        MatroskaIndexPos *pos = pos_list->elem;\n\n        for (j = 0; j < pos_list->nb_elem; j++) {\n\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n\n                                                              pos[j].track);\n\n            if (track && track->stream)\n\n                av_add_index_entry(track->stream,\n\n                                   pos[j].pos + matroska->segment_start,\n\n                                   index[i].time / index_scale, 0, 0,\n\n                                   AVINDEX_KEYFRAME);\n\n        }\n\n    }\n\n}\n", "idx": 17353, "substitutes": {"matroska": ["matrisica", "matrisaka", "mitraski", "matrsaka", "mitrasha", "matrickscki", "mitrosha", "atrotsku", "Matrski", "matriskaya", "matrisko", "atroskaya", "catrickskaya", "matstroskaya", "macroskas", "atrotskas", "mitreska", "matrasha", "catroscki", "matresko", "matrisrika", "matstroseka", "matrsko", "matrasaka", "mitreseka", "matcoscki", "matrusaka", "mrosko", "matreskaya", "atrotskaya", "matrosaka", "matruskaya", "matrorsica", "mitroseka", "matcosaka", "matrotski", "atrosku", "macrisko", "Matrosky", "mitroska", "matrusko", "matriseka", "mitresko", "matrosha", "matreseka", "catrickska", "Matrsaka", "matruska", "atroska", "matrickskaya", "matrickskas", "matrotsha", "mitrosko", "matroskaya", "macriskas", "matroscki", "matrorska", "matriskas", "matrotskas", "matrasrika", "mitroskaya", "mrisko", "matroki", "matriska", "matstroska", "mitrasaka", "macrosaka", "mrisrika", "matraski", "Matrosko", "matrska", "matrokaya", "catricksaka", "mitrosaka", "matrosko", "matrisky", "Matrosaka", "catroska", "matroaka", "catrosaka", "macroska", "mitraska", "atrotska", "matrusky", "matreska", "matrotskaya", "mriska", "mrisica", "catrickscki", "matrorsrika", "matroha", "Matrisky", "macrosko", "matrotska", "matrisku", "matrusku", "matrosica", "matroky", "matroko", "macriska", "matrokas", "matruskas", "Matrsko", "catroskaya", "matrosrika", "matroseka", "matrorsko", "Matriska", "matraska", "matstrosko", "atroskas", "Matroska", "matrocki", "matrotsaka", "matricksaka", "matcoskaya", "Matrisko", "mrosrika", "Matrisaka", "matroskas", "mitroski", "macrisaka", "matcoska", "mrosica", "mitreskaya", "matrski", "matrasica", "matrotsku", "matroski", "matrosky", "matricksko", "matroka", "matrasko", "mroska", "Matrska", "matrosku", "matrickska", "Matroski"], "index_list": ["index_stack", "indexingLIST", "zero_string", "index2len", "index09string", "index_LIST", "index_dict", "zero_LIST", "index09table", "pos2listed", "zero_list", "index2dict", "pos2len", "index2LIST", "index1List", " index_dict", "index2list", "list_list", "indexingstack", "indexinglisted", "pos2LIST", "index_lists", "zeroingstring", "indexinglist", "indexinglen", "index09List", "ind_list", "indexingstring", "pos_listed", "zeroinglist", "index_listed", "list_set", "index09stack", "index2table", "index09dict", "pos_LIST", "ind_li", "index_table", "ind_List", "index_string", "pos_len", "index1pair", "index1li", " index_table", "list_List", "list_lists", "index_set", "index2List", "index_List", "pos2list", "index_pair", "index_li", "zeroingstack", "zero_stack", "index_len", "index09LIST", "index2listed", "ind_pair", " index_List", "index09list", "index1list", "zeroingLIST"], "index": ["type", "length", "config", "action", "rank", "cache", "create", "offset", "route", "ind", "Index", "map", "update", "test", "point", "lock", "archive", "allow", "info", "connect", "search", "delete", "post", "position", "store", "scale", "order", "error", "version", "attribute", "select", "loc", "note", "address", "sort", "check", "query", "can", "table", "cycle", "list", "zero", "path", "id", "num", "date", "value", "row", "level", "n", "see", "key", "slice", "axis", "active", "instance", "seek", "link", "count", "x", "view", "node", "image", "find", "only", "range", "name"], "i": ["us", "is", "g", "bi", "gi", "ind", "ri", "xi", "ki", "ex", "ai", "info", "ia", "q", "li", "ui", "ic", "y", "in", "ami", "ip", " ii", "io", "ims", "pi", "iu", "u", "by", "im", "e", "zi", "ci", "my", "l", "sim", "m", "me", "ji", "v", "I", "n", "o", "ii", "ti", "ei", "phi", "ix", "x", "di", "uri", "it", "mi", "ie", "hi", "at", "ij", "ini", "multi", "yi", "si", "p"], "j": ["job", "jl", "jump", "J", "br", "g", "ja", "bj", "jp", "c", "jc", "js", "pr", "json", "kj", "q", "fr", "tr", "y", "jj", "obj", "bo", "aj", "att", "by", "je", "e", "l", "m", "ji", "el", "b", "v", "k", "n", "dj", "bot", "o", "ev", "other", "key", "oj", "uj", "x", "next", "jit", "jo", "it", "ij", "z", "p"], "pos_list": ["pos_listed", "pos_pool", "rotetqueue", "pos2list", "rot_queue", "po_LIST", "pos2listed", "po_List", "posetlist", "rot_List", "posetList", "po2lists", "pos_LIST", "po2list", "rot_list", "rotetlist", "po2LIST", "po_lists", "posetpool", "pos2LIST", " pos_listed", " pos_lists", "pos_List", " pos_dict", "rotetList", "po_list", "pos2lists", "posetqueue", "pos_lists", "rotetpool", "pos2List", "pos_queue", "pos_dict", "pos2dict", "rot_pool", "po2List"], "pos": ["us", "px", "coord", "offset", "Pos", "rank", "slot", "ref", "nos", "tx", "pose", "lat", "point", "info", "ports", "pr", "port", "position", "os", "params", "serv", "def", "res", "doc", "loc", "pi", "spec", "pl", "rel", "pet", "resp", "pc", "pt", "path", "num", "id", "off", "row", "pres", "po", "val", "rot", "POS", "seek", "oss", "points", "on", "seq", "no", "pro", "find", "tag", "start", "ps", "co", "cond", "p"], "track": ["trip", "trak", "tmp", "tm", "rank", "kick", "ctr", "require", "mount", "claim", "stage", "report", "stream", "tab", "search", "deck", "port", "store", "rack", "tr", "band", "rr", "round", "roll", "session", "handle", "match", "tracking", "check", "sort", "song", "table", "form", "sync", "num", "ack", "rec", "row", "hold", "record", "txt", "race", "train", "contact", "skip", "fire", "sound", "comment", "trace", "reflect", "cmd", "seek", "task", "Track", "mark", "metadata", "transform", "node", "find", "try", "tag", "token", "tracks", "field", "step", "batch"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;\n\n    }\n\n}\n", "idx": 17357, "substitutes": {"samples": ["cpled", "sans", "itsonents", " songs", "itsamples", "sprints", "sererences", "cans", "sples", "itsviews", "cviews", "servamples", "samamps", "jsults", " subes", " spled", "isults", "cults", "schanges", "commchanges", " sviews", "servults", "slamps", "aronents", "tsamples", "jsamps", "tsprints", "commubes", "jsamples", "sourses", "commongs", "slacks", "assprints", "sviews", "unschanges", "serences", "sacks", "stracks", "commprints", " sreports", "isensions", "insensions", "samps", "ssources", " sources", "aramples", "sensions", "unsresults", "insples", "assubes", "unsourses", "tsongs", "arerences", "messviews", "unsiffs", " sonents", "ssamps", "wsensions", "insamples", "arfaces", "alsamples", "commamples", "messonents", "sults", "slources", "sreports", "samviews", "sresults", "tsples", "slamples", " sprints", "commresults", "wsiffs", "messreports", "commources", "camps", " sults", "assources", "jsans", "sampled", "isples", "seramples", "serfaces", "servensions", " samps", "sonents", "servples", " sacks", " sans", "commourses", "isamples", "samamples", "insults", "alsourses", "sfaces", " sfaces", "alschanges", "siffs", "seronents", " serences", "assamples", "wstracks", "unsensions", "ssamples", "songs", "isiffs", "itsreports", "wsamples", "ssacks", "unstracks", "unsamples", "sources", "messamples", "alsresults", "commples", " sples", "spled", "camples", "subes", "istracks"], "i": ["us", "is", "iri", "init", "ip", "y", "ami", " ii", "ims", "qi", "v", " err", "I", "o", "ii", "key", "esi", "print", "phi", " ti", " j", " multi", "t", " ki", " di", "ir", "iter", "ui", "\u0438", "pi", "im", "index", " pi", "mi", "iq", "multi", "name", " I", "g", " my", " li", "gi", "ind", "chain", "ri", " axis", "xi", "ki", "cli", "ai", "li", "io", "iu", " bi", "ci", "sim", "me", "m", "ti", " is", "x", " m", "uri", "at", "ij", " me", "si", "batch", "bi", " mi", " index", "ic", "in", " key", "zi", "this", "asi", "id", "ji", " iter", "ei", " it", "fi", "ix", "di", " ni", "it", "ini", "z", "j", "oi"]}}
{"project": "qemu", "commit_id": "fb506e701e9bafa3e0685747c1c98962c52d1962", "target": 1, "func": "static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 17362, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "aws", "changes", "sw", "c", "h", "sq", "args", "sis", "aunts", "ops", "settings", "js", "i", "ports", "params", "ss", "ies", "vs", "details", "ns", "events", "spec", "ears", "e", "r", "ats", "sync", "ts", "d", "m", "sys", "es", "v", "n", "se", "sports", "sb", "services", "tests", "stats", "ds", "qs", "ses", "less", "S", "gs", "cs", "ps", "t", "bs", "comm", "fs", "hs", "j", "p"], "errp": ["errorpress", "eorpress", "errping", "rrp", "derp", "rrping", "derps", "eorpad", "diep", "nerpad", "errpc", "errpress", "errorp", "nerps", "nerjp", "errorpe", "errpa", "erps", "errorpad", "errpe", "errps", "eorpa", "derjp", "errorpa", "errpad", "errjp", "diepc", "nerpa", "rrpc", "nerpress", "rrpe", "erjp", "errorping", "eorp", "diepe", "erP", "nerP", "errP", "dieping", "nerp", "errorpc", "erp", "derP"], "x86_iommu": ["x86_iomau", "x86_piommue", "x86_iompue", "x86_iomatu", "x86_piomu", "x86_tommus", "x86_iuemsue", "x86_iophermu", "x86_iomn", "x86_iomtu", "x86_iromul", "x86_iommmu", "x86_iomacu", "x86_iompmu", "x86_iomu", "x86_iommuu", "x86_iomptu", "x86_iuemsul", "x86_iormul", "x86_iummus", "x86_iompu", "x86_piomcu", "x86_tomu", "x86_iormu", "x86_iommcu", "x86_iopherus", "x86_iuommuu", "x86_iemsul", "x86_iommus", "x86_piommn", "x86_iummu", "x86_iemsu", "x86_iromu", "x86_piommcu", "x86_iormuu", "x86_piommul", "x86_iompul", "x86_piommu", "x86_iomuu", "x86_piommmu", "x86_iommn", "x86_iromue", "x86_iormue", "x86_iummmu", "x86_iemsue", "x86_tomus", "x86_iommue", "x86_iuommul", "x86_iromn", "x86_piomul", "x86_iemsuu", "x86_piommtu", "x86_iompcu", "x86_piomue", "x86_iomul", "x86_piomtu", "x86_iompn", "x86_iomamu", "x86_iommtu", "x86_tommmu", "x86_iuemsuu", "x86_iomus", "x86_iuemsu", "x86_iuommu", "x86_iomue", "x86_iomcu", "x86_piomn", "x86_iommul", "x86_iuommue", "x86_tommu", "x86_iopheru"]}}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n", "idx": 17370, "substitutes": {"hw": ["irm", "ih", "act", " inh", "ht", "hop", "hd", "aws", "hh", "pkg", "iw", "igm", "h", "wd", "rh", "ay", "dq", "phy", "ha", "mph", "hz", "sh", "wx", "hm", "wi", "dh", "hip", "wp", "nw", "ich", "ctx", "ether", "how", "him", "ew", "cmd", "igh", "vc", "wind", "fw", "ksh", "hp", "w", "ow", "haw", "shake", "we", "hs"], "as": [" os", "us", "asa", "ak", "ass", "a", "ais", "sac", "ag", "ias", "was", "As", "ras", "pas", " av", "ac", "ap", "nas", "acs", "pa", "has", "AS", " AS", "ams", "ar", "ase", "mes", "ast", "oss", "an", " am", "am", "ars", "aus", "las", "sa", "aos", " As", "bs", " us"]}}
{"project": "FFmpeg", "commit_id": "fe6eea99efac66839052af547426518efd970b24", "target": 1, "func": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n\n{\n\n    NSVContext *nsv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st[2] = {NULL, NULL};\n\n    NSVStream *nst;\n\n    AVPacket *pkt;\n\n    int i, err = 0;\n\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n\n    uint32_t vsize;\n\n    uint16_t asize;\n\n    uint16_t auxsize;\n\n\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\n\n\nnull_chunk_retry:\n\n    if (pb->eof_reached)\n\n        return -1;\n\n\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n\n        err = nsv_resync(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state == NSV_FOUND_NSVS)\n\n        err = nsv_parse_NSVs_header(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n\n        return -1;\n\n\n\n    auxcount = avio_r8(pb);\n\n    vsize = avio_rl16(pb);\n\n    asize = avio_rl16(pb);\n\n    vsize = (vsize << 4) | (auxcount >> 4);\n\n    auxcount &= 0x0f;\n\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n\n           auxcount, vsize, asize);\n\n    /* skip aux stuff */\n\n    for (i = 0; i < auxcount; i++) {\n\n        uint32_t av_unused auxtag;\n\n        auxsize = avio_rl16(pb);\n\n        auxtag = avio_rl32(pb);\n\n        avio_skip(pb, auxsize);\n\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n\n    }\n\n\n\n    if (pb->eof_reached)\n\n        return -1;\n\n    if (!vsize && !asize) {\n\n        nsv->state = NSV_UNSYNC;\n\n        goto null_chunk_retry;\n\n    }\n\n\n\n    /* map back streams to v,a */\n\n    if (s->nb_streams > 0)\n\n        st[s->streams[0]->id] = s->streams[0];\n\n    if (s->nb_streams > 1)\n\n        st[s->streams[1]->id] = s->streams[1];\n\n\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n\n        nst = st[NSV_ST_VIDEO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n\n        av_get_packet(pb, pkt, vsize);\n\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n\n        pkt->dts = nst->frame_offset;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        for (i = 0; i < FFMIN(8, vsize); i++)\n\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n\n                   i, pkt->data[i]);\n\n    }\n\n    if(st[NSV_ST_VIDEO])\n\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n\n\n    if (asize && st[NSV_ST_AUDIO]) {\n\n        nst = st[NSV_ST_AUDIO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n\n        /* read raw audio specific header on the first audio chunk... */\n\n        /* on ALL audio chunks ?? seems so! */\n\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n\n            uint8_t bps;\n\n            uint8_t channels;\n\n            uint16_t samplerate;\n\n            bps = avio_r8(pb);\n\n            channels = avio_r8(pb);\n\n            samplerate = avio_rl16(pb);\n\n            if (!channels || !samplerate)\n\n                return AVERROR_INVALIDDATA;\n\n            asize-=4;\n\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                   bps, channels, samplerate);\n\n            if (fill_header) {\n\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n\n                if (bps != 16) {\n\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n\n                }\n\n                bps /= channels; // ???\n\n                if (bps == 8)\n\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n\n                samplerate /= 4;/* UGH ??? XXX */\n\n                channels = 1;\n\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                       bps, channels, samplerate);\n\n            }\n\n        }\n\n        av_get_packet(pb, pkt, asize);\n\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n\n            /* on a nsvs frame we have new information on a/v sync */\n\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n\n                   nsv->avsync, pkt->dts);\n\n        }\n\n        nst->frame_offset++;\n\n    }\n\n\n\n    nsv->state = NSV_UNSYNC;\n\n    return 0;\n\n}\n", "idx": 17381, "substitutes": {"s": ["ls", "is", "sts", "g", "rs", "sv", "ins", "pkg", "aws", "scl", "a", "c", "sq", "js", "os", "ss", "sc", "ns", "set", "e", "ats", "ts", "m", "its", "conf", "sys", "sp", "es", "b", "v", "ctx", "n", "socket", "sb", "stats", "ds", "qs", "ses", "span", "w", "S", "gs", "cs", "comm", "t", "bs", "ps", "fs", "hs", "j", "p"], "fill_header": [" fill2Header", "Fill_headers", " fill2header", "Fill_head", " fill2headers", " fill_Header", " fill2head", "Fill_header", " fill_headers", "Fill_Header", " fill_head"], "nsv": ["namestv", "nsvm", "sntv", "namesvr", "nsV", "stsver", "lsV", "namesvm", " nsvc", "csvc", "snve", "msvr", "tsvs", "nspr", "stsvc", "nsver", "stspr", "stsv", "lsvt", "nstv", "namesvp", "rotsvp", "nsvs", "tsvc", "nsvc", "msvc", "atsv", "stsvt", "snvt", "lsv", "nsvt", "nsvp", "csvr", "namesvc", "tsv", "nvs", "lstv", "msv", "snvc", "snvs", "lsvc", "rotsv", "atsvs", "atsV", "tsvr", "snvr", "rotsvm", " nspr", "csvs", "namesvs", "atsvc", "rotsver", "namesver", "stsvp", "lspr", "nv", "lsvr", "lsvs", "msvs", "nvc", "namesv", "stsvm", "snv", "namesV", "csve", " nsvt", "nsvr", "nvt", "csv", "nsve", "csvt", "namesve"], "pb": ["proc", "tm", "cv", "amp", "bh", "PB", "pkg", "tp", "bj", "fp", "jp", "peer", "tx", "wb", "gp", "td", "mp", "cp", "conv", "rb", "bp", "sc", "xp", "pp", "p", "np", "cb", "pan", "pl", "tc", "stab", "lp", "pm", "buf", "pc", "wp", "pt", "tf", "prot", "ap", "sys", "sp", "client", "b", "ctx", "erb", "pa", "uf", "sb", "db", "cmd", "pg", "lb", "phys", "prefix", "span", "tk", "pro", "pool", "rpm", "ssl", "buff", "tif", "emb", "snap", "mt", "ps", "bs", "dp", "pd", "vp"], "st": ["us", "sl", "sts", "sw", "so", "ste", "nd", "std", "sta", "ss", "sth", "ut", "St", "est", "pt", "sp", "cl", "ST", "ct", "se", "ft", "ust", "it", "bl", "mt", "sh", "rest", "ist"], "nst": ["Nst", "nsts", "nct", " nsw", "cnsts", "Nsts", " nct", " nsts", "cnst", "nsw", "cnsw", "cnct", "Nct", "Nsw"], "pkt": ["prqt", "cpacket", "packet", "cpnt", "pracket", " pqt", "cpkt", "cpqt", "pqt", " packet", "prnt", " pnt", "prkt", "pnt"], "i": ["us", "g", "bi", "gi", "ind", "chain", "c", "xi", "err", "ki", "ex", "cli", "ai", "iy", "ini", "oi", "q", "li", "ic", "ui", "y", "in", "ip", "ami", " ii", "go", "ims", "pi", "iu", "qi", "\u0438", "im", " bi", "ci", "zi", "l", "sim", "m", "asi", "index", "me", "gu", " err", "I", "n", "ii", "ti", "ei", "print", "phi", "ix", "x", " ti", " x", " m", "di", "it", " j", "mi", "hi", "ij", "t", "multi", "j", "si", "batch"], "auxcount": ["auxcounter", " auxmatch", "uxCount", "avsize", "uxsize", "auount", "auxc", "ausize", "uxc", "auCount", "faxcounter", "faxCount", "avount", "uxcounter", "avc", " auxcounter", "auxount", "faxmatch", "auxCount", "uxcount", "aucount", "avcount", " auxCount", " auxount", "faxsize", "faxcount", " auxc", "auxmatch", "uxmatch", "avCount"], "vsize": [" vize", "avwidth", "varset", "avheight", "iverize", " vexport", "cvsize", "vtotal", "avsize", "vunit", "Vstorage", "Vheight", "uvsize", "vvoffset", "vvstorage", "svtotal", "vcount", "vSIZE", "avset", "avize", "svsize", "evstorage", "vstorage", "avstorage", "vheight", "varize", "Vsize", "iverset", "evsize", "evwidth", " vstorage", " vwidth", "svize", "vexport", " vcount", "iverstorage", "evize", "Vize", "vcsize", "svcount", "vvsize", "avtotal", "cvexport", "varsize", " vgrow", "vwidth", "avSIZE", "vcexport", "avcount", "voffset", "uvoffset", "vvSIZE", "vgrow", "vcgrow", " vtotal", "svwidth", "vvize", "cvgrow", "varstorage", "uvize", "iversize", " vunit", "vcunit", "vize", "vvheight", "cvunit", "avoffset", "uvSIZE", "vset"], "asize": ["alsized", "arsiz", "arsize", " asource", "rasize", "Asize", "asizer", "alsizer", "asource", "_", "c", "aosource", "func", "msource", " asizer", "Asized", "rasource", "asiz", "atsize", "atsource", "aosize", "Asource", "alsiz", "msiz", "arsized", " asized", "aosizer", "alsize", "txt", "aosized", "atsiz", "asized", "rasizer", "msize", "rasiz", "Asizer", "arsizer", "rasized", "msizer", "atsizer"], "auxsize": ["ausum", "avsize", "auxSize", "uxmem", "avSize", "uxsize", "vcount", "afsize", "avize", "afize", " auxmem", "auxsum", "ausize", " auxsum", "auxmem", "auxize", "uxize", "auize", " auxSize", "vSize", "uxcount", "uxSize", "aucount", "avcount", "afmem", "afcount", " auxize", "vize", "uxsum"], "av_unused": ["av_nonused", "av_nused", "av_Unused", "av_Unuse", "av2unuse", "av2unset", "av2unus", "av_nuse", "av_nset", "av2Unset", "av_nonuse", "av2Unus", "av_nus", "av_nonset", "av_unset", "av2unused", "av_unus", "av_nonus", "av_Unset", "av2Unused", "av2Unuse", "av_unuse", "av_Unus"], "NSVStream": ["CSVSStream", "NSVCStream", "NSVSStream", "NSVSView", "NSVCView", "CSVStream", "NSVView", "NSVStreamer", "NSVGStreamer", "NSVSStreamer", "NSVCStatus", "CSVView", "NSVGStream", "NSVCStreamer", "NSVGView", "NSVGStatus", "NSVSStatus", "CSVSView", "NSVStatus", "CSVSStreamer", "CSVStreamer", "CSVSStatus", "CSVStatus"], "priv_data": ["priv_cache", "public___data", "public___buf", "priv___cache", "priv_block", "priv__buf", "priv_buf", "priv___data", "privmsgcache", "priv__cache", "public___block", "priv___block", "privmsgbuf", "priv___buf", "public_cache", "privmsgblock", "priv__data", "public___cache", "public_block", "privmsgdata", "priv__block", "public_data", "public_buf"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411, "substitutes": {"f": ["fd", "cf", "window", "ff", "g", "rf", "fp", "c", "df", "h", "fac", "fb", "fc", "af", "lf", "q", "fr", "F", "e", "r", "form", "ac", "l", "d", "tf", "m", "fa", "b", "v", "fm", "o", "uf", "out", "sf", "fi", "full", "x", "file", "fw", "w", "bf", "fo", "xf", "fn", "t", "fs", "p"], "opaque": ["Opent", "ipaques", "opent", "ipent", "Opaque", "compaque", "compaques", "Opacity", "compent", "opaques", "ipacity", "ipaque", "opacity", "compacity", "Opaques"], "ret": [" res", " RET", "cat", "after", "def", "ben", "det", "RET", "out", "val", "print", "reflect", "grad", "deg", "rm", "mb", "new", "reg", "gt", "lt", "lit", "rem", "cont", "len", "net", " fut", "re", " Ret", "back", "ft", "code", "inter", "cmd", "nt", "mt", "red", "ry", "ber", "ext", "end", "result", "err", "elt", "flag", "arg", "resp", " jet", "vet", "txt", "cert", "git", "rets", "desc", "rier", "try", "pret", "rt", "nil", "ref", "final", "ctr", "jp", "bool", " alt", "tr", "res", "att", "rev", "Ret", "ter", "nz", "reset", "alt", "t", "j"]}}
{"project": "FFmpeg", "commit_id": "51e1cc16d3e89a785f3231065c4eb898a0401a93", "target": 1, "func": "matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            assert(size>0); // size <=3 is checked before size-=3 above\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n                uint8_t *pkt_data = data;\n                if (matroska->tracks[track]->encoding_scope & 1) {\n                    switch (matroska->tracks[track]->encoding_algo) {\n                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n                        offset = matroska->tracks[track]->encoding_settings_len;\n                        break;\n                    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n                        pkt_data = NULL;\n                        do {\n                            ilen = lace_size[n];\n                            olen = pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data,\n                                                  pkt_size+LZO_OUTPUT_PADDING);\n                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);\n                        if (result) {\n                            continue;\n                        }\n                        pkt_size -= olen;\n                        break;\n#ifdef CONFIG_ZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n                        z_stream zstream = {0};\n                        pkt_data = NULL;\n                        if (inflateInit(&zstream) != Z_OK)\n                            continue;\n                        zstream.next_in = data;\n                        zstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            zstream.avail_out = pkt_size - zstream.total_out;\n                            zstream.next_out = pkt_data + zstream.total_out;\n                            result = inflate(&zstream, Z_NO_FLUSH);\n                        } while (result==Z_OK && pkt_size<10000000);\n                        pkt_size = zstream.total_out;\n                        inflateEnd(&zstream);\n                        if (result != Z_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n#ifdef CONFIG_BZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n                        bz_stream bzstream = {0};\n                        pkt_data = NULL;\n                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n                            continue;\n                        bzstream.next_in = data;\n                        bzstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n                            result = BZ2_bzDecompress(&bzstream);\n                        } while (result==BZ_OK && pkt_size<10000000);\n                        pkt_size = bzstream.total_out_lo32;\n                        BZ2_bzDecompressEnd(&bzstream);\n                        if (result != BZ_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n                    }\n                }\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, pkt_size+offset) < 0) {\n                    av_free(pkt);\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                if (offset)\n                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n                memcpy (pkt->data+offset, pkt_data, pkt_size);\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n                matroska_queue_packet(matroska, pkt);\n            }\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "idx": 17412, "substitutes": {"track": ["trak", "bind", "offset", "rank", "attr", "ctr", "tn", "ind", "mount", "tar", "claim", "stream", "tab", "port", "brand", "store", "name", "order", "tr", "rack", "head", "dist", "round", "set", "match", "move", "sort", "tracking", "form", "roll", "check", "handle", "sync", "path", "index", "ack", "rec", "txt", "record", "row", "ct", "race", "time", "hold", "ord", "train", "dd", "fire", "str", "trace", "cmd", "Track", "seek", "count", "col", "mark", "metadata", "transform", "dr", "rm", "nt", "find", "token", "tag", "stat", "pack", "t", "tracks", "field", "step"], "st": ["rt", "sl", "tmp", "irst", "ost", "th", "sts", "tt", "end", "sn", "sw", "h", "ste", "nd", "std", "stage", "stream", "sta", "store", "fr", "sc", "tr", "obj", "inst", "set", "src", "cast", "St", "est", "pt", "sp", "ack", "ST", "se", "stack", "ct", "s", "str", "bt", "storage", "station", "dr", "stop", "sam", "nt", "stat", "z", "start", "mt", "ch", "stable", "t", "rest", "step", "p"], "pkt": ["pwk", "pbwk", "pft", " pft", "pbqt", " pqt", " pwk", "pqt", "pbkt", "cpqt", "cpwk", "cpkt", "pbft", "cpft"], "origdata": ["coorddata", "coordata", "Origata", "originaldata", "origdat", "limdata", "origata", "origindat", "Origdat", "origbytes", " origdat", "Origdata", "Origbytes", "coordstr", "originput", "coorddat", "originalinput", " origata", " origstr", "origindata", "limdat", "originata", "originbytes", "originalata", "coordbytes", " origbytes", " originput", "limata", "origstr", "liminput", "originaldat", "originstr"], "block_time": ["lock_time", "block_times", " block_rate", "block_rate", "lock_size", "blockingrate", "lock_times", " block_info", "lock_length", "block_info", "blockinglength", "block_length", "blockinginfo", "block_size", " block_length", "blockingtime"], "lace_size": ["block2length", "block_speed", "blockmentlen", "block2len", "line_speed", "blockmentsize", "line_len", "block_length", "block_len", "line_size", "blockmentlength", "block2speed", "block_size", "blockmentspeed", "block2size", "line_length"], "n": ["nb", "ne", "g", "na", "en", "nm", "sn", "cn", "c", "nr", "h", "dn", "i", "size", "len", "y", "pos", "nn", "np", "ns", "ni", "nor", "l", "nc", "d", "m", "k", "o", "mn", "nu", "s", "nan", "count", "an", "number", "ln", "nt", "N", "t", "z", "p"], "flags": ["bits", "ints", "tracks", "ops", "args", "settings", "mask", "values", "links", "ants", "styles", "heads", "events", "ags", "flag", "types", "ms", "Flags", "ats", "actions", "ts", "locks", "fps", "options", "weights", "members", "parts", "lag", "FLAG", "faces", "fields", "frames", "times", "stats", "vals", "status", "comments", "tags", "items", "acks", "features", "fs", "metadata"], "num": ["new", "nb", "extra", "window", "sum", "th", "block", "offset", "coord", "end", "nm", "reg", "sn", "nam", "mult", "nr", "valid", "rem", "dim", "cal", "set", "max", "um", "pn", "index", "id", "un", "local", "m", "row", "mon", "zero", "Num", "mn", "ord", "rec", "nu", "count", "uni", "mem", "mark", "common", "number", "no", "msg", "sam", "NUM", "node", "snap", "annot", "nom", "add"], "stream_index": ["stream_info", "draw_i", "streammatchid", "streamtloc", "streamxid", "stream_val", "boxityindex", "ream_id", "streamzinstance", "box_index", "stream9interface", "thread_pos", "draw_val", "streameindex", "ream_index", "video_position", "streamityi", "streamityindex", "streamxindex", "boxitysuccess", "track_index", "drawityval", "streamesuccess", "streammatchindex", "draw_index", "ream_name", "box_id", "drawityinstance", "box_success", "thread_id", "track_address", "stream_loc", "track_id", "stream_id", "streamtname", "stream_position", "stream_address", "reammatchindex", "drawityi", "streamityseed", "video_ind", "reammatchloc", "thread_index", "video_index", "reammatchname", "stream_name", "reammatchid", "streamzval", "stream_instance", "streameid", "ream_loc", "streammatchname", "stream_no", "stream_pos", "streamtindex", "streamzindex", "streamxinterface", "stream9index", "stream_success", "streamitysuccess", "boxityid", "streamtid", "thread_info", "track_interface", "stream9id", "stream_ind", "box_seed", "video_no", "stream_seed", "streamityid", "stream_i", "streamxaddress", "streamzi", "stream9address", "streamityval", "drawityindex", "streammatchloc", "streamityinstance", "stream_interface", "draw_instance", "streameseed", "boxityseed"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)\n\n{\n\n    c->high = 255;\n\n    c->bits = -16;\n\n    c->buffer = buf;\n\n    c->end = buf + buf_size;\n\n    c->code_word = bytestream_get_be24(&c->buffer);\n\n}\n", "idx": 17413, "substitutes": {"c": ["cf", "lc", "cv", "cr", "config", "cache", "cam", "h", "C", "ca", "err", "cm", "content", "fc", "anc", "rc", "com", "abc", "mc", "cont", "ic", "cp", "conv", "sc", "etc", "gc", "tc", "enc", "cu", "e", "ci", "ac", "pc", "l", "nc", "d", "con", "conf", "cc", "b", "v", "ct", "bc", "xc", "ce", "cand", "count", "coll", "ec", "cod", "at", "cs", "ch", "co", "ae", "dc", "z", "cd", "p"], "buf": ["tmp", "window", "ff", "cv", "bb", "block", "bh", " buffer", "br", "coord", "cache", "ref", "map", "vec", "h", "iter", "wb", "bar", "fb", "Buff", "port", "buffer", "cap", "true", "Buffer", "rb", "bp", "pos", "img", "p", "cb", "pb", "loc", "orig", "max", "ah", "num", "ered", "off", "b", "v", "txt", "ctx", "uf", "cmd", "db", "count", "cur", "mem", "seq", "begin", "msg", "bound", "buff", "ptr", "queue", "batch"], "buf_size": ["buf2SIZE", "buf_count", "buf2size", "buf1offset", "buff1height", "buf_height", "buff_handle", " buf_count", "buff_height", "buf_len", "bufwhandle", "buf1height", "buf_handle", "bufwheight", " buf_len", "buf_offset", "buff_offset", "buf_SIZE", " buf_SIZE", "buf2count", "bufwoffset", "buf1handle", "buff1size", "buff1offset", "buff1handle", "buf2len", "buf1size", "bufwsize", "buff_size"]}}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "int vring_pop(VirtIODevice *vdev, Vring *vring,\n\n              VirtQueueElement **p_elem)\n\n{\n\n    struct vring_desc desc;\n\n    unsigned int i, head, found = 0, num = vring->vr.num;\n\n    uint16_t avail_idx, last_avail_idx;\n\n    VirtQueueElement *elem = NULL;\n\n    int ret;\n\n\n\n    /* If there was a fatal error then refuse operation */\n\n    if (vring->broken) {\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* Check it isn't doing very strange things with descriptor numbers. */\n\n    last_avail_idx = vring->last_avail_idx;\n\n    avail_idx = vring->vr.avail->idx;\n\n    barrier(); /* load indices now and not again later */\n\n\n\n    if (unlikely((uint16_t)(avail_idx - last_avail_idx) > num)) {\n\n        error_report(\"Guest moved used index from %u to %u\",\n\n                     last_avail_idx, avail_idx);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* If there's nothing new since last we looked. */\n\n    if (avail_idx == last_avail_idx) {\n\n        ret = -EAGAIN;\n\n        goto out;\n\n    }\n\n\n\n    /* Only get avail ring entries after they have been exposed by guest. */\n\n    smp_rmb();\n\n\n\n    /* Grab the next descriptor number they're advertising, and increment\n\n     * the index we've seen. */\n\n    head = vring->vr.avail->ring[last_avail_idx % num];\n\n\n\n    elem = g_slice_new(VirtQueueElement);\n\n    elem->index = head;\n\n    elem->in_num = elem->out_num = 0;\n\n    \n\n    /* If their number is silly, that's an error. */\n\n    if (unlikely(head >= num)) {\n\n        error_report(\"Guest says index %u > %u is available\", head, num);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    if (vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(&vring->vr) = vring->vr.avail->idx;\n\n    }\n\n\n\n    i = head;\n\n    do {\n\n        if (unlikely(i >= num)) {\n\n            error_report(\"Desc index is %u > %u, head = %u\", i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        if (unlikely(++found > num)) {\n\n            error_report(\"Loop detected: last one at %u vq size %u head %u\",\n\n                         i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        desc = vring->vr.desc[i];\n\n\n\n        /* Ensure descriptor is loaded before accessing fields */\n\n        barrier();\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            ret = get_indirect(vring, elem, &desc);\n\n            if (ret < 0) {\n\n                goto out;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        ret = get_desc(vring, elem, &desc);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        i = desc.next;\n\n    } while (desc.flags & VRING_DESC_F_NEXT);\n\n\n\n    /* On success, increment avail index. */\n\n    vring->last_avail_idx++;\n\n    *p_elem = elem;\n\n    return head;\n\n\n\nout:\n\n    assert(ret < 0);\n\n    if (ret == -EFAULT) {\n\n        vring->broken = true;\n\n    }\n\n    if (elem) {\n\n        vring_unmap_element(elem);\n\n        g_slice_free(VirtQueueElement, elem);\n\n    }\n\n    *p_elem = NULL;\n\n    return ret;\n\n}\n", "idx": 17428, "substitutes": {"vdev": ["qscan", "vDEV", "vdevice", "vscan", "tdev", "wdev", "tscan", "vswitch", "qdev", "vmswitch", "vmdev", "vmdevice", " vdevice", "tDEV", "gdev", "gconn", "vmconn", " vconn", "gswitch", "wscan", " vswitch", "tdevice", "qdevice", "vconn", "qDEV", "wDEV", "gdevice", "wdevice"], "vring": ["vejing", "vpacking", "avding", "varjing", "varp", "varrap", " vling", "ving", "vtbing", "avning", "vtrap", "vearp", "vray", "avending", "verring", " vbinding", "varring", "varng", "uvring", "wringe", "svro", "veending", "varbinding", "vbing", "verig", " vjing", "svring", "evping", "vning", " vding", " vrap", "vering", "svringe", "avrap", "svning", "uvning", "avbing", " vro", " vending", "vararp", "vebinding", "varling", "vro", "svstring", "evrig", "yng", "avpacking", " ving", "vling", "veray", "vtringe", "avringe", "evring", "wstring", " vpacking", "evning", "yoss", "vstring", "varing", "svrig", " vping", "veding", "svping", "verap", "veling", " vstring", "veing", "vtring", "yjing", "wro", " voss", "vending", " vning", " vray", "svding", "vaross", " vringe", "avping", " varp", "uvping", "avring", "uvrig", "verding", "vringe", "vrig", "verjing", "vding", "svjing", "yring", "vjing", "svpacking", "vng", "wring", " vng", "verrig", "avray", "vrap", "vbinding", "voss", "vping", " vbing"], "p_elem": ["pqselement", "p_entlem", "pqelement", "p_selement", "pqelem", "pqselt", "p_selem", "p_Elev", "p_Element", "pqselev", "p_elt", "pqelt", "pqselem", "p_selt", "p_entlev", "p_elev", "p_Elt", "p_selev", "p_element", "pqelev", "p_entlement", "p_entlt", "p_Elem"], "desc": [" sect", " de", "lc", "label", "ext", "ind", "sec", " des", " dep", " msg", "disc", "ef", "info", "des", " description", " cont", "def", " dir", "cont", "sc", "diff", "ript", "prev", " resp", "doc", "sub", "dist", "loc", "dir", "buf", "summary", "rec", "txt", " prot", " dc", "cd", " describe", "bc", " enc", " diff", "description", "md", "str", "asc", " rev", "de", "ds", "ec", "cur", "seq", " shr", "req", "dr", " docs", "ent", "Desc", " dist", " cd", "dict", " doc", "dev", "cmp", "esc", "meta", "dc", " det", "decl"], "i": ["f", "us", "is", "bi", "ind", "init", "ir", "a", "h", "c", "xi", "ki", "ai", "li", "ic", "ui", "ip", "in", "y", "io", " ii", "ami", "pi", "inst", "u", "im", "e", "ci", "list", "m", "num", "index", "id", "b", "v", "I", "n", "o", "ii", "ti", "fi", "phi", "ix", "x", "di", "it", "mi", "start", "ij", "ini", "multi", "j", "si", "p"], "head": ["us", "block", "headed", "ax", "init", "shift", "h", "heading", "top", "max", "check", "before", "md", "first", "pop", "mem", "begin", "HEAD", "dict", "med", "add", "new", "ff", "offset", "Head", "min", "root", "then", "heads", "len", "pos", "body", "index", "off", "row", "back", "cmd", "loop", "window", "length", "sum", "th", "header", "end", "ind", "push", "hd", "map", "origin", "size", "orig", "set", "um", "headers", "front", "hang", "count", "next", "dr", "foot", "high", "rank", "mm", "depth", "ck", "tail", "tr", "doc", "form", "height", "list", "num", "id", "n", "it", "start", "each"], "avail_idx": ["availityidx", "availityidxf", "avail_keyx", "avail_idexf", "avail_Idx", "avail_db", "avail_idex", "avail_ridxt", "avail_midx", "avail_idexs", "avail_ridxc", "avail_idb", "avail_startx", "avail_keyxc", "avail_idxs", "avail_dxf", "avail_idxt", "avail_startxf", "avail_dx", "avail_midc", "avail_dxc", "avail_startox", "avail_idec", "avail_idexc", "availitystartxf", "avail_ideox", "avail_Idox", "avail_keyxes", "avail_midb", "avail_keyxs", "avail_codex", "avail_ridx", "avail_midxc", "avail_idexes", "availityidox", "avail_idxc", "avail_codext", "avail_midxf", "avail_Idxf", "avail_idc", "avail_codexc", "availitystartox", "avail_idxf", "avail_idxes", "avail_idox", "availitystartx", "avail_dc"], "last_avail_idx": ["last_avail_iden", "last_avail_idsxs", "last_avail_idj", "last_avail_idec", "last_avail_indy", "last_avail_idxf", "last_avail_midp", "last_avail_ity", "last_avail_inn", "last_avail_indn", "last_avail_uidy", "last_avail_idp", "last_avail_inx", "last_avail_uidj", "last_avail_Idg", "last_avail_ideg", "last_avail_idexc", "last_avail_midn", "last_avail_idg", "last_avail_idexs", "last_avail_ridp", "last_avail_indxf", "last_avail_idsx", "last_avail_Idx", "last_avail_ing", "last_avail_ridx", "last_avail_idex", "last_avail_midx", "last_avail_indx", "last_avail_idsxc", "last_avail_uidx", "last_avail_Idxc", "last_avail_idey", "last_avail_idn", "last_avail_idc", "last_avail_idexf", "last_avail_itj", "last_avail_itx", "last_avail_idej", "last_avail_uidc", "last_avail_iny", "last_avail_idxc", "last_avail_idxs", "last_avail_ridn", "last_avail_idsy", "last_avail_idy", "last_avail_itc", "last_avail_inxs"], "elem": [" element", " erem", "aelement", "perem", "enlev", "lelem", "neom", "lelev", "eeld", "elev", "eld", " eom", " elev", "belev", "erlement", "elelement", "selement", "elelem", "lelement", "endlement", "entlev", "berem", "legem", "elelev", "beom", "entlement", "elegem", "egem", "ept", "engem", "eval", "nelement", "erval", " eval", "endlem", "seom", "entval", "belem", "pelev", "erlev", "nelem", " eld", "enlement", " ept", "erlem", "selev", "aeld", "eelem", "peom", "element", "erem", "aelem", "endlev", "endom", "selem", "entlem", "eept", "enlem", "eelement", "eom", "nelev", "pelem", "aept"], "ret": ["rt", "url", "opt", "ext", " res", "gt", "ref", "result", " RET", "lt", "cat", "err", "lit", "ert", "rem", "nl", "def", "cont", "dt", "res", " resp", "net", "elt", "Return", "ll", "re", "att", "arg", "resp", "det", "RET", "Ret", "rev", "pt", "ts", "sys", "back", "out", "ft", " Ret", "nz", "reset", "over", "val", "rets", "print", "cmd", "str", "alt", "mem", "dr", "nt", "rm", "try", "at", "addr", "mt", "t"], "found": ["f", "fd", "done", "fl", "ff", "fe", "loaded", "iter", "recent", "good", "valid", "sent", "built", "inner", "seen", "pos", "body", "Found", "killed", " Found", "finished", "failed", "d", "num", "index", "n", "front", "missing", "finder", "used", "count", "old", "required", "fun", "fat", "find", "needed", "stable"]}}
{"project": "FFmpeg", "commit_id": "bc29acdc76fdbf70700cdc2f85fc2afb46e19e47", "target": 0, "func": "static int ftp_connect_control_connection(URLContext *h)\n\n{\n\n    char buf[CONTROL_BUFFER_SIZE], opts_format[20];\n\n    int err;\n\n    AVDictionary *opts = NULL;\n\n    FTPContext *s = h->priv_data;\n\n    const int connect_codes[] = {220, 0};\n\n\n\n    s->conn_control_block_flag = 0;\n\n\n\n    if (!s->conn_control) {\n\n        ff_url_join(buf, sizeof(buf), \"tcp\", NULL,\n\n                    s->hostname, s->server_control_port, NULL);\n\n        if (s->rw_timeout != -1) {\n\n            snprintf(opts_format, sizeof(opts_format), \"%d\", s->rw_timeout);\n\n            av_dict_set(&opts, \"timeout\", opts_format, 0);\n\n        } /* if option is not given, don't pass it and let tcp use its own default */\n\n        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,\n\n                         &s->conn_control_interrupt_cb, &opts);\n\n        av_dict_free(&opts);\n\n        if (err < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Cannot open control connection\\n\");\n\n            return err;\n\n        }\n\n\n\n        /* consume all messages from server */\n\n        if (!ftp_status(s, NULL, connect_codes)) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP server not ready for new users\\n\");\n\n            err = AVERROR(EACCES);\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_auth(s)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP authentication failed\\n\");\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_type(s)) < 0) {\n\n            av_dlog(h, \"Set content type failed\\n\");\n\n            return err;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17439, "substitutes": {"h": ["f", "ih", "hr", "ht", "th", "bh", "host", "hw", "hd", "hh", "H", "c", "rh", "hal", "eh", "he", "y", "tr", "ha", "sh", "hz", "handle", "r", "hm", "oh", "ah", "help", "dh", "m", "here", "ph", "b", "kh", "v", "k", "hl", "history", "http", "w", "hp", "her", "hi", "zh", "ch", "hash", "hs", "z", "j", "p"], "buf": ["proc", "tmp", "window", "ff", "cv", "block", "box", " buffer", "br", "bh", "ref", "fp", "iter", "wb", "rc", "Buff", "xff", "port", "buffer", "cap", "fr", "Buffer", "cp", "conv", "rb", "tr", "bytes", "p", "cb", "rw", "BU", " b", "off", "b", "v", "txt", "ctx", "uf", "vp", "str", "cmd", "pg", "data", "cur", "seq", "msg", "pool", "raw", "buff", "w", "bin", "ptr", "queue", "batch"], "opts_format": ["opts_data", "ops_mat", "opts_form", "optsxstring", "ops_style", "optsxformat", "ops_form", "optx_Format", "opt_data", "opt_string", "optx_style", "opts_size", "opts_string", "opt_Format", "ops_data", "optx_size", "opts_style", "opt_format", "ops_Format", "opts_mat", "opts_Format", "optx_format", "optsxdata", "optsxFormat", "ops_format"], "err": ["org", " res", " len", "er", "dy", "cer", "js", "i", "or", "fr", "rr", "e", "out", "trace", "timer", "deg", "plain", "cmp", "act", "cr", "br", "test", "nr", "iter", "pr", "warn", "eh", "order", "diff", "rb", "norm", "cb", "errors", " terr", "off", "ev", " Err", "cmd", "notice", "empty", " score", "msg", "usr", "die", "conf", "cfg", "rn", "all", "end", "rs", " ec", "mr", "ind", "term", "eor", "error", "elt", "resp", "here", "txt", "aaa", " er", " rc", "dr", "raw", " ptr", "ptr", "kr", "lr", "coord", "attr", "ctr", "fer", "fee", "rc", "Er", "urg", " cr", "res", " resp", "der", "actor", "arr", "r", "score", "any", "rev", "sys", "gz", "eas", "str", "ner", "it", "t"], "opts": ["oprs", "atuts", "opt", "iopps", "iopt", "optouts", "optt", "optts", "popTS", "popps", "opfs", "optpt", "iopouts", "optuts", "pps", "optfs", "att", "iopcs", "opps", "pts", "optrs", "pt", "copTS", "opTS", "popts", "optTS", "oppt", "optps", "copts", "copfs", "optcs", "OPcs", "iopfs", "coprs", "atts", "oputs", "coppt", "OPps", "opcs", "iopts", "OPouts", "copt", "ioprs", "poppt", "copps", "atps", "OPts", "opouts"], "s": ["ls", "sl", "is", "sts", "th", "sv", "rs", "g", "as", "aws", "so", "sw", "changes", "a", "c", "sq", "js", "i", "self", "os", "ss", "serv", "sc", "https", "y", "vs", "details", "ns", "ims", "sh", "spec", "set", "r", "ats", "l", "ts", "sys", "m", "its", "sp", "es", "b", "v", "n", "se", "parts", "sb", "x", "stats", "ds", "qs", "w", "S", "sym", "gs", "ssl", "source", "cs", "ps", "t", "bs", "comm", "fs", "hs", "z", "j", "p"], "connect_codes": [" connect_code", " connect_odes", "connectableids", "connect_files", "connect_odes", "connectablelines", "connect_code", "connectingids", " connect_lines", "connect_ids", "connectableodes", "connect_lines", "connectablecodes", " connect_files", "connectablecode", " connect_ids", "connectablefiles", "connectinglines", "connectingcodes"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449, "substitutes": {"dev": ["pad", "window", "Dev", "block", "end", "hw", "cam", " device", "test", "h", "develop", "info", "stick", "ad", "def", "store", "serv", "device", "go", "debug", "event", "ver", "spec", "driver", "dem", "d", "watch", "env", "v", "var", "ev", "gate", "dd", "ve", "dep", "devices", "md", "DEV", "link", "Device", "desc", "de", "mem", "exec", "di", "w", "serial", "nt", "addr", "die", "p"], "data": ["pad", "window", "reg", "attr", "offset", "as", "map", "a", "tx", "nd", "buffer", "ad", "ata", "device", "bytes", "p", "obj", "dat", "da", "r", "address", "any", "d", "m", "id", "DATA", "n", "Data", "aw", "val", "mem", "image", "addr", "start", "ptr", "t", "add", "batch"], "buf": ["pad", "ff", "cv", " bu", "box", "block", " buffer", "br", "bh", "ref", "map", "vec", " bl", " msg", "bar", "Buff", " buff", "buffer", "cap", "Buffer", "bytes", "doc", "cb", "arr", "b", "v", "var", "uf", "bg", "bc", "cmd", " avail", "mem", "seq", "msg", "bl", "bin", "buff", "bf", "queue", "batch"], "len": ["length", "lan", "end", "en", "Len", "ref", "trans", "vec", " bl", "h", "lit", "lf", "size", "nl", "ret", "cap", "fin", "pos", "bytes", "elt", "loc", "ll", "fil", "enc", "l", "num", "el", "n", " length", " clen", "lim", " l", "mem", "seq", "ln", "nt", "wid"]}}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static int is_intra_more_likely(ERContext *s)\n\n{\n\n    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;\n\n\n\n    if (!s->last_pic.f || !s->last_pic.f->data[0])\n\n        return 1; // no previous frame available -> use spatial prediction\n\n\n\n    undamaged_count = 0;\n\n    for (i = 0; i < s->mb_num; i++) {\n\n        const int mb_xy = s->mb_index2xy[i];\n\n        const int error = s->error_status_table[mb_xy];\n\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n\n            undamaged_count++;\n\n    }\n\n\n\n    if (s->avctx->codec_id == AV_CODEC_ID_H264 && s->ref_count <= 0)\n\n        return 1;\n\n\n\n    if (undamaged_count < 5)\n\n        return 0; // almost all MBs damaged -> use temporal prediction\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    // prevent dsp.sad() check, that requires access to the image\n\n    if (CONFIG_MPEG_XVMC_DECODER    &&\n\n        s->avctx->xvmc_acceleration &&\n\n        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)\n\n        return 1;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs\n\n    is_intra_likely = 0;\n\n\n\n    j = 0;\n\n    for (mb_y = 0; mb_y < s->mb_height - 1; mb_y++) {\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int error;\n\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n\n\n            error = s->error_status_table[mb_xy];\n\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n\n                continue; // skip damaged\n\n\n\n            j++;\n\n            // skip a few to speed things up\n\n            if ((j % skip_amount) != 0)\n\n                continue;\n\n\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n\n                int *linesize = s->cur_pic.f->linesize;\n\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n\n                    // FIXME\n\n                } else {\n\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n\n                }\n\n                is_intra_likely += s->mecc->sad[0](NULL, last_mb_ptr, mb_ptr,\n\n                                                   linesize[0], 16);\n\n                is_intra_likely -= s->mecc->sad[0](NULL, last_mb_ptr,\n\n                                                   last_mb_ptr + linesize[0] * 16,\n\n                                                   linesize[0], 16);\n\n            } else {\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n\n                   is_intra_likely++;\n\n                else\n\n                   is_intra_likely--;\n\n            }\n\n        }\n\n    }\n\n    return is_intra_likely > 0;\n\n}\n", "idx": 17452, "substitutes": {"s": ["is", "as", "fs", "a", "c", "h", "js", "y", "ies", "vs", "ims", "e", "v", "has", "stats", "http", "qs", "less", "ses", "comments", "als", "bits", "aws", "sw", "ss", "sg", "ns", "events", "spec", "ms", "parts", "space", "sports", "times", "full", "S", "results", "cs", "hs", "p", "sts", "g", "rs", "ops", "sq", "aunts", "ex", "self", "os", "m", "sb", "gs", "comm", "bs", "ls", "sv", "ins", "scl", "changes", "sac", "settings", "r", "ats", "ts", "sys", "its", "b", "ties", "n", "se", "ds", "csv", "ps", "t", "details", "es"], "is_intra_likely": ["is_intron_likely", "is_intra___probably", "is_intra___strong", "is_intra_worthy", "is_intras_strong", "is_intron_probably", "is_intras_likely", "is_intra_simple", "is_intra___simple", "is_intra_probably", "is_intras_simple", "is_intron_worthy", "is_intron_simple", "is_intras_probably", "is_intra_strong", "is_intra___likely"], "i": ["f", "us", "is", "bi", "gi", "ind", "init", "chain", "xi", "point", "ki", "ex", "cli", "ai", "info", "oi", "li", "ui", "ic", "ip", "y", "in", "\u0438", "ami", "ico", "ims", "pi", "iu", "qi", "u", "by", "im", "e", "zi", "ci", "my", "sim", "m", "me", "index", "id", "ori", "I", "n", "PI", "ii", "inter", "ti", "phi", "ix", "x", "di", "it", "ie", "mi", "try", "ij", "ini", "multi", "si"], "j": ["f", "jl", "jump", "J", "br", "g", "bj", "jp", "h", "jc", "c", "nr", "js", "json", "kj", "q", "fr", "y", "jj", "p", "aj", "r", "l", "m", "ji", "index", "b", "v", "k", "n", "dj", "o", "uj", "count", "jit", "it", "ij", "t", "z", "job"], "undamaged_count": ["undamage_nb", "undamage_list", "undamaged____case", "undamaged_Count", "undamage_cc", "undammanaged67Count", "undamaged67case", "undamaged_cc", "undamaged_list", "undamagededlength", "undamaged_score", "undamagededcount", "undamagededscore", "undamagedPcount", "undamaged____data", "undamaged67data", "undammanaged_case", "undamaged67Count", "undammanaged67case", "undamage_now", "undammanaged_data", "undamage_count", "undamagededCount", "undammanaged_count", "undamage_score", "undamage_counter", "undamaged____count", "undamaged_case", "undamaged_counter", "undammanaged67count", "undammanaged67data", "undamaged_nb", "undamaged_now", "undamage_length", "undamaged67count", "undamaged____Count", "undamaged_data", "undamagedPcc", "undamaged_length", "undamagedPnb", "undammanaged_Count", "undamage_Count"], "skip_amount": ["skip_adjust", "skipingpercent", " skip_percent", "skip_percent", "skipingamount", "skip_Amount", " skip_adjust", "skip_count", " skip_count", "skipingAmount", " skip_Amount"], "mb_x": ["mb_dx", "umb_xy", " MB_xy", "mb64dx", "mb_yx", "mb64xy", "mbPxy", "emb_xy", "emb_php", "db_xy", "umb_php", "mb64ix", " MB_dx", "mb__w", "mb_ex", "mbPx", "umb_x", "mb__x", "emb_y", "mb__z", "db_x", " MB_x", "mb_ix", "db_z", "mb_w", "db_w", "mb_xy", "emb_ex", "mb_php", "mb__xy", "mb_z", "mbPphp", "emb_x", "mb64x", " MB_ix", "emb_yx"], "mb_y": ["mb_yl", "mb_ey", "amb_Y", "mb___y", "mb__y", "mb___index", "ram_iy", "MB_index", "amb_yl", "mb_ny", "amb_y", "mb___cy", "mb7y", "mb_axy", "ram_i", "MB_x", "jpg_y", "mb__x", "mb___x", "MB_axy", "amb_ny", "mb_ye", "jpg_x", "mb7x", "mb_cy", "mb_Y", "mb_i", "mb7axy", "ram_x", "jpg_ey", "mb7ye", "mb__cy", "MB_y", "mb_iy", "jpg_z", "MB_ye", "mb_z", "ram_y", "mb_index", "MB_cy", "mb__index"], "AV_PICTURE_TYPE_I": ["AV_PICTURE_Type_IP", "AV_PICTURE_Type_T", "AV_PICTURE_Type_I", "AV_PICTURE_TYPE_IP", "AV_PICTURE_TYPE_IL", "AV_PICTURE_TYPE__IN", "AV_PICTURE_Type_IL", "AV_PICTURE_TYPE_II", "AV_PICTURE_TYPE__II", "AV_PICTURE_TYPE_T", "AV_PICTURE_TYPE_IN", "AV_PICTURE_TYPE__I", "AV_PICTURE_Type_II", "AV_PICTURE_Type_IN", "AV_PICTURE_TYPE__T"], "error": ["danger", "er", "or", "attribute", "debug", "event", "address", "e", "check", "query", "link", "storage", "relation", "command", "close", "stroke", "alias", "entry", "warning", "complete", "delete", "root", "style", "order", "bug", "panic", "re", "ERROR", "function", "errors", "progress", "row", "code", "comment", "change", "option", "alpha", "success", "ception", "iso", "ror", "detail", "resource", "Error", "length", "terror", "result", "channel", "err", "ignore", " Error", "force", "raise", "core", "angle", "instance", "no", "try", "type", "parse", "rank", "open", "ance", "ion", "lock", "info", "rage", "r", "owner", "description", "data", "feature", "it", "ory", "loss", "ace", "timeout", "volume"], "linesize": ["valsizes", " linesiz", "linesizes", "linesiz", "valsizer", "codesiz", "codesizer", "codesizes", " linesizes", "valsize", "codesize", " linesizer", "linesizer", "valsiz"]}}
{"project": "FFmpeg", "commit_id": "4d321bff85cf1e9b6a18b915af185494b5ea94b6", "target": 1, "func": "void Release(void *ctx)\n\n{\n\n    ContextInfo *ci;\n\n    ci = (ContextInfo *) ctx;\n\n\n\n    if (ci->cache) {\n\n        imlib_context_set_image(ci->cache->image);\n\n        imlib_free_image();\n\n        av_free(ci->cache);\n\n    }\n\n    if (ctx) {\n\n        if (ci->imageOverlaid) {\n\n            imlib_context_set_image(ci->imageOverlaid);\n\n            imlib_free_image();\n\n        }\n\n        ff_eval_free(ci->expr_x);\n\n        ff_eval_free(ci->expr_y);\n\n        ff_eval_free(ci->expr_R);\n\n        ff_eval_free(ci->expr_G);\n\n        ff_eval_free(ci->expr_B);\n\n        sws_freeContext(ci->toRGB_convert_ctx);\n\n        sws_freeContext(ci->fromRGB_convert_ctx);\n\n        av_free(ctx);\n\n    }\n\n}\n", "idx": 17480, "substitutes": {"ctx": ["crit", "tmp", "cf", "act", "cv", "rt", "bh", "ja", "pkg", "hw", "ind", "jp", "tx", "ca", "xs", "cm", "info", "anc", "ia", "ck", "mc", "cp", "voc", "sc", "xp", "jac", "gc", "qt", "kt", "cb", "unc", "unk", "wx", "tc", "obj", "cu", "resp", "sci", "rect", "pc", "cc", "kw", "txt", "ct", "bc", "xc", "context", "ce", "cmd", "cas", "x", "vc", "msg", "cs", "cmp", "co", "cfg", "que"], "ci": ["cf", "lc", "CI", "cgi", "aci", "parse", "ice", "c", "ca", "ki", "cm", "cil", "cli", "ai", "com", "fc", "i", "icc", "ic", "cont", "cp", "cit", "coe", "jac", "ico", "imi", "pi", "qi", "ni", "cu", "zi", "sci", "ati", "vi", "cc", "ct", "ctl", "see", "ii", "ti", "fi", "slice", "oci", "ctrl", "ce", "ix", "cand", "link", "cod", "circ", "di", "mi", "uci", "lic", "irc", "cs", "adi", "cia", "ace", "ini", "co", "cci", "yi", "ani", "cor"]}}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n", "idx": 17482, "substitutes": {"node": ["proc", "component", "tmp", "window", "ode", "f", "type", "object", "cache", "ref", "host", "page", "entry", "peer", "scene", "c", "bar", "post", "info", "root", "parent", "good", "self", "manager", "child", "slave", "server", "nn", "obj", "master", "event", "cb", "note", "remote", "handle", "handler", "list", "m", "nw", "num", "id", "index", "local", "row", "ctx", "k", "n", "key", "instance", "holder", "cmd", "desc", "Node", "container", "msg", "image", "nt", "source", "tree", "fn", "t", "field", "name", "normal"], "ret": ["rt", "tmp", "ext", " res", "gt", "result", "mult", "lt", "cat", "err", "ount", "ert", "rem", "pub", "def", "fr", " alt", "pas", "tr", "res", " resp", "net", "len", "elt", "re", "round", "arr", "flag", "resp", "det", "RET", "Ret", "ter", " terr", "num", "vet", "v", "out", "ft", "cert", "nz", "inter", "val", "rets", "print", "cmd", "compl", "alt", "success", "quad", "deg", "vt", "nt", "rm", "pret", "usr", "mt", "mb", "t", " sr", "j", "red", "pat"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n", "idx": 17513, "substitutes": {"s": ["is", "sv", "rs", "as", "aws", "scl", "a", "c", "h", "sq", "ss", "sg", "ns", "e", "ats", "es", "sb", "ds", "w", "S", "gs", "cs", "sa", "ps", "fs", "p"], "pb": ["cv", "bb", "ub", "tp", "fp", "jp", "mp", "cp", "rb", "bp", "pp", "np", "lp", "pm", "pc", "wp", " cp", "pa", "uf", "xb", "vp", "sb", "lb", " p", "bps", "bm", "pd", "p"], "in": ["f", "inn", "ins", "ind", "inc", "gin", "inner", "r", "m", "id", "IN", "mat", "pin", "ar", "val", "data", "bin", "rin", "input", "inf", "t", "In", "p"], "out": ["cache", "store", "table", "can", "check", "cast", "v", "o", "other", "print", "old", "status", "co", "new", "bit", "outs", "OUT", "ret", "ot", "serv", "null", "device", "net", "u", "quiet", "client", "off", "over", "cmd", "one", "w", "p", "unit", "all", "ne", "result", "chain", "update", "point", "post", "self", "buffer", "os", "soft", "conv", "version", "help", "batch", "boot", "flat", "Out", "bool", "server", "att", "note", "r", "arr", "sync", "list", "con", "b", "n", "data", "output", "it", "t"], "scaled": ["ascalled", "ascales", "escaled", "ascanded", "escalled", "expales", "scales", "scanded", "expalled", "ascaled", "escanded", "scalled", "expanded", "expaled", "escales"], "size": ["length", "zone", "offset", "g", "sample", "sn", "shift", "shape", "SIZE", "scale", "dim", "len", "sc", "ize", "set", "group", "max", "small", "zero", "num", "area", "si", "code", "space", "Size", "send", "empty", "count", "x", "capacity", "equal", "number", "resolution", "scope", "range", "z", "name"], "scale_idx": ["scale_indxc", "scale_idxc", "scale_adxc", "scale_indxs", "scale_indc", "scale_adxs", "scale_Idc", "scale_adc", "scale_Idxs", "scale_Idx", "scale_indx", "scale_idxs", "scale_adx", "scale_Idxc", "scale_idc"], "cb": ["lr", "cf", "cv", "coord", "nm", "crop", "cm", "bar", "xy", "rc", "clip", "func", "callback", "cap", "bp", "align", "src", "check", "CV", "checked", "cl", "CB", "family", "lb", "loop", "fun", "bound", "comb", "dc"], "lambda": ["lr", "appa", "igma", "lc", "prop", "lab", "mas", "aug", "distance", "ima", "clip", "params", "dist", "mu", "da", "tap", "imp", "margin", "lam", "lu", "slice", "phi", "alpha", "beta", "pha", "fun", "comb", "decl"], "uplim": ["uplam", "uiplrim", "uplrim", "uiplam", "umlim", "iupprim", "umlam", "upprim", "iuplim", "uppam", "iuplrim", "iuplam", "iuppib", "uplib", "iuppam", "uppim", "umlrim", "umlib", "uiplib", "iuppim", "iuplib", "uiplim", "uppib"], "bits": ["checks", "bit", "codes", "boot", "jobs", "outs", "ints", "planes", "ops", "limits", "ions", "bool", "heads", "bytes", "units", "pins", "ns", "ims", "ats", "its", "fps", "weights", "b", "parts", "bis", "holes", "points", "groups", "words", "vals", "bps", "bands", "flags", "base", "keys", "bf", "cs", "blocks", "items", "rates", "bs", "ps", "batch"], "ROUNDING": ["RoundingNING", "RINDing", "RINDING", "RANDED", "ROUNDNING", " Roundinging", "RANDNING", " RoundingING", " ROUNDED", "Roundinging", " ROUNDing", "RANDING", " ROUNDNING", "ROUNDED", "RINDNING", " RoundingNING", "RoundingED", "ROUNDing", "RINDED", " RoundingED", "RANDing", "RoundingING"], "i": ["us", "is", "g", "bi", "gi", "ind", "init", "chain", "c", "ri", "xi", "point", "cli", "ai", "info", "ini", "iy", "batch", "shape", "name", "ui", "ic", "li", "y", "ip", "ami", " ii", "ims", "pi", "iu", "qi", "im", "zi", "ci", "sequence", "this", "sim", "m", "me", "index", "id", "list", "v", "I", "n", "ii", "ei", "key", "ti", "fi", "phi", "slice", "ix", "prefix", "print", "x", "status", "di", "uri", "it", "mi", "loop", "ij", "iq", "t", "multi", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "dbb7405d8caad0814ceddd568cb49f163a847561", "target": 1, "func": "static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}", "idx": 17518, "substitutes": {"dev": ["proc", "pad", "Dev", "conn", "en", "hw", "er", "cam", "test", "develop", "info", "stick", "des", "draw", "ad", "def", "range", "serv", "server", "device", "go", "obj", "debug", "dist", "sd", "ver", "spec", "patch", "form", "det", "scan", "dem", "sys", "v", "ctx", "n", "ev", "hid", "var", "priv", "out", "ve", "app", "val", "devices", "cmd", "prom", "DEV", "desc", "Device", "de", "mem", "w", "pro", "serial", "nt", "it", "av", "adv", "raw", "conf", "p"], "d": ["fd", "done", "drivers", "f", "g", "dx", "ind", "bd", "c", "dn", "h", "std", "nd", "dl", "ad", "def", "dt", "D", "debug", "sd", "dat", "dm", "r", "da", "dh", "l", "m", "v", "n", "out", "dj", "o", "dd", "dom", "md", "db", "dis", "data", "de", "ds", "di", "dr", "z", "w", "dict", "t", "ld", "dc", "pd", "j", "p"], "pci_conf": ["pki_conn", "pci_config", "pci_con", "pci__config", "pcgi_conf", "pcgi_config", "pcu_con", "pai_config", "pdi_config", "pai_con", "pdi_cfg", "pci_conn", "pci__conf", "pcu_config", "pcgi_con", "pci_cfg", "pki_cfg", "pki_con", "pki_conf", "pcgi_conn", "pdi_conf", "pcu_conf", "pdi_map", "pci__cfg", "pai_conf", "pai_conn", "pci_map", "pci__map", "pcu_conn"]}}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n", "idx": 17534, "substitutes": {"pkt": ["repkt", " prt", "Pcmd", "perkg", "pskt", " pdu", "pkg", "prt", "pect", "pcmd", "Pkt", "psst", "repst", "cpct", "opacket", "Pkg", "Pct", "Pdu", "perkt", "pst", "Packet", "psrt", "spnt", "pekg", " pcmd", "spacket", "opkt", "cpnt", "spkt", "pekt", "Pnt", "peracket", " packet", "psacket", " pst", "repacket", "spdu", "cpacket", "packet", "pct", "opkg", " pkg", "opnt", "pecmd", " pct", "pernt", "cpkt", " pnt", "reprt", "pnt", "pdu"], "buf": [" br", "prop", " bu", "cv", "box", "bh", " buffer", "block", "vec", " msg", " buff", "bag", "np", "pb", "dat", "max", "cast", " arr", "var", "req", "mem", "begin", " cmd", "buff", "cmp", "proc", "nb", "ff", "br", "iter", "bar", "Buff", " bo", "rb", "cb", "off", " tmp", "alloc", "cmd", " ab", "tmp", "opt", " vec", "pkg", "buffer", "cap", "orig", "feat", "BU", " b", "txt", "uf", "bn", "bc", " avail", " wr", "desc", "cur", "seq", "ptr", "bs", "coord", "cam", " bl", "fac", "wb", " foo", "pub", "func", "Buffer", "tr", " resp", "img", " bar", "arr", "b", "data", "pack", "queue"], "res": ["us", "act", "reg", "rs", "mr", "result", "err", "rez", "Res", "rc", "js", "rem", "ret", "RES", "des", "func", "def", "os", "cons", "pas", "pos", "ver", "re", "max", "pers", "r", "resp", "ms", "vol", "rev", "gr", "expr", "arr", "out", "pres", "has", "state", "reset", "val", "sol", "vals", "resolution", "results", "nt", "ress", "cs", " Res", "ps", "bs", "rel", "rest", "red"], "fd": ["f", "window", "ff", "fl", "fine", "gd", "ind", "fp", "df", "nd", "ld", "td", "dl", "fc", "size", "ud", "port", "buffer", "fr", "dt", "fin", "duration", "ns", "cb", "sd", "dat", "da", "handle", "dir", "nc", "d", "pid", "poll", "index", "id", "FD", "ctx", "dd", "socket", "fi", "db", "desc", "seek", "file", "ds", "bf", "addr", "ptr", "fn", "fs", "dc", "fed"], "buf_descriptor": ["buf_descructer", "buf_desriptive", "buf_descryption", "buf_decripter", "buf_describors", "buf_decriptor", "buf_decripteur", "buf_escriptee", "buf_desccriptee", "buf_descdescors", "buf_descryptors", "buf_desccriptor", "buf_descveyory", "buf_descotion", "buf_descdescee", "buf_descotors", "buf_descructory", "buf_desccripteur", "buf_escribors", "buf_descdescory", "buf_desripter", "buf_decriptory", "buf_descriptors", "buf_desccripter", "buf_descriptory", "buf_descdescor", "buf_desription", "buf_escribory", "buf_desriptor", "buf_descripteur", "buf_describeur", "buf_descoter", "buf_describee", "buf_descryptor", "buf_desccription", "buf_descriptive", "buf_deccriptory", "buf_descructeur", "buf_descripter", "buf_deccripter", "buf_descructor", "buf_describer", "buf_escriptors", "buf_escriptor", "buf_description", "buf_deccriptor", "buf_descrypter", "buf_descveyive", "buf_descriptee", "buf_descveyor", "buf_escribee", "buf_describory", "buf_describor", "buf_desccriptors", "buf_desccriptive", "buf_desriptory", "buf_desccriptory", "buf_describive", "buf_descveyors", "buf_escribor", "buf_deccripteur", "buf_descotor", "buf_escriptory", "buf_desriptors"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 17548, "substitutes": {"opaque": ["operque", "operity", "Opque", "oplation", "oblation", "operaque", "iopque", "opity", "operaques", "obaque", "opient", "obient", "obque", "operlation", "obity", "opque", "Opaques", "Opaque", "Oplation", "iopity", "operient", "obaques", "iopaque", "opaques", "iopient"], "c2": ["pTwo", "gc2", "cp2", "p6", "cpTwo", "cc6", "gcTwo", "p1", " c6", "c6", "p02", "gc1", "cptwo", "cp1", "gctwo", "cc02", "ctwo", "c02", "ptwo", "p2", "cc1", " c1", "cc2", "cTwo", "c1", " c02"]}}
{"project": "qemu", "commit_id": "9217e26f43df4aab7deaea35b21caacc1f1f854b", "target": 1, "func": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n", "idx": 17553, "substitutes": {"bs": ["ls", "sts", "ks", "rs", "ubs", "iss", "BS", "js", "lbs", "os", "ss", "bp", "obs", "vs", "blog", "ns", "ms", "ats", "ts", "its", "b", "sb", "bc", "ds", "ses", "aus", "bl", "gs", "bm", "cs", "ps", "aos", "fs", "hs"], "sector_num": [" sector_number", "sector_id", "sector_Num", " sector_id", "sector_number", " sector_Num"], "buffer": ["window", "length", "binary", "block", "cache", "ref", "result", "vector", "channel", "document", "Buffer", "byte", "bytes", "face", "address", "table", "buf", "message", "uf", "comment", "data", "buff", "command", "base", "input", "batch"], "nb_sectors": ["nb_seds", "nb_seors", "nb_speors", "nb_speds", "nb_veds", "nb_veors", "nb_spectors", "nb_pectors", "nb_peors", "nb_vectors", "nb_specs", "nb_pecs", "nb_secs", "nb_peds", "nb_vecs"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "as", "fs", "h", "sq", "js", "ss", "ies", "ns", "set", "ats", "ts", "its", "es", "b", "v", "n", "sb", "stats", "ds", "qs", "ses", "an", "less", "S", "gs", "cs", "sa", "ps", "t", "sis", "j", "p"]}}
{"project": "FFmpeg", "commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "target": 1, "func": "static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n", "idx": 17554, "substitutes": {"fmt_ctx": ["fmt_context", "fmt2pkg", "flt_ctx", "fnt_cb", "fmt_cb", "fmt2tx", "flt_pkg", "fwk_ctx", "fmt2context", "fwk_cm", "fnt_context", "fmt_pkg", "fnt_ctx", "fmt2ctx", "fwk_pkg", "flt_tx", "fnt_pkg", "fmt_tx", "flt_context", "fmt_cm", "fwk_context"], "pkt": ["ppkg", "ppac", "cpet", "ppmt", "payet", "pkg", "ppacket", "pcnt", "Pet", "Pkt", "pac", " pmt", "pckt", "paykt", "Packet", "promt", "ppct", "lpacket", "pet", "lpkg", "payacket", "cpnt", "ppkt", " pac", "Pnt", " packet", "lpct", "ppet", "pcet", "prokt", "paynt", "pcacket", "cpacket", "packet", "pct", " pkg", "proacket", "pmt", "lpkt", " pct", "proac", "cpkt", "ppnt", "pnt"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17576, "substitutes": {"s": ["is", "states", "h", "c", "js", "asm", "store", "syn", "vs", "details", "ims", "v", "out", "stats", "http", "qs", "less", "ses", "comments", "als", "rest", "bits", "st", "eps", "sw", "ports", "ss", "serv", "ns", "spec", "parts", "bis", "sports", "services", "S", "cs", "hs", "p", "sl", "sts", "rs", "ops", "sq", "self", "cons", "os", "set", "pers", "acs", "sb", "gs", "gets", "comm", "bs", "ls", "sv", "changes", "so", "plays", "search", "sc", "r", "ats", "sync", "ts", "d", "sys", "its", "n", "se", "ds", "stat", "ps", "t", "fs", "sh", "es"], "value": ["unit", " measurement", "type", "length", "block", "sum", "cache", "VALUE", " Value", "property", " message", "memory", "values", "ay", " instance", "buffer", " v", "variable", "position", "padding", " input", "attribute", "byte", "ue", "V", "max", " amount", "address", "expression", "message", "Value", " quantity", "index", "v", "code", " data", "total", "key", "val", "description", "weight", "data", "x", "feature", "number", "image", "we", "hello", "field"], "size": ["is", "length", "sum", "zone", "offset", "fee", "position", "shape", "SIZE", "scale", "len", "ize", "body", "set", "e", "height", "message", "small", "zero", "num", "index", "id", "n", "see", "code", "space", "Size", "send", "empty", "count", "capacity", "equal", "number", "start", "needed", "z", "name", "si"], "i": [" n", "us", " I", "is", "g", "bi", "gi", "ind", "init", "chain", "c", "iter", "xi", " index", "ai", "batch", "li", "ic", "ui", "y", "ip", " ii", "pi", "iu", " t", "u", "im", "e", " bi", "zi", "ci", "l", "sim", "m", "id", "index", "gu", "v", "I", "n", "o", "ii", "ti", "fi", "phi", "ix", "x", " count", " ti", " m", "di", "it", "mi", " j", " multi", "ie", "at", "ini", "multi", "j", "si", "p"], "data_count": ["data__cache", "data__length", "DATA_length", " data_length", "data_code", "DATA_count", "DATA_sum", "DATA_current", "DATA_code", "data_Count", "data_sum", "data_max", "data_current", "dataCountmax", "data_counter", " data_cache", " data_max", "data_cache", "data_id", "DATA_id", "data__count", "data__index", " data_Count", "data_length", "dataCountCount", "DATA_cache", "dataCountcounter", " data_index", " data_counter", "data_index", "dataCountcount"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 17581, "substitutes": {"opaque": ["ipene", "OPque", "oplay", "metca", "oeter", "Opque", "oque", " opatile", "opeter", "ipque", "opatile", " opus", " opeter", " opque", "OPaque", "OPus", "obeter", "obaque", "obque", "metene", "opque", "oatile", "oaque", "metaque", "Opaque", "ipca", "metque", "OPlay", "Opus", "opene", "ipaque", "obatile", " opca", "opca", "opus", " oplay", "Oplay", " opene"], "addr": ["arch", "args", "i", "ad", "store", "np", "address", "work", "dh", "ctx", "var", "sha", "mem", "hash", "add", "adder", "arp", "pad", "act", "alias", "reg", "offset", "gt", "hw", "tx", "order", "len", "pos", "obj", "src", "expr", "Address", "now", "index", "off", "row", "hl", "inter", "state", "alloc", "cmd", "usr", "adj", "name", "end", "conn", "pkg", "confirmed", "ind", "map", "point", "err", "error", "added", "loc", "arg", "aro", "ack", "sp", "ock", "x", "dr", "bound", "adr", "ptr", "pat", "coord", "attr", "ref", "ctr", "urg", "res", "align", "handle", "arr", "r", "rev", "id", "ord", "gate", "ix", "data", "alt", "start"], "size": ["length", "sum", "type", "offset", "sy", "g", "sn", "fee", "shape", "SIZE", "scale", "len", "ize", "ze", "address", "e", "message", "small", "l", "grow", "m", "num", "sp", "gz", "n", "area", "code", "space", "sha", "Size", "state", "send", "empty", "count", "number", "scope", "iz", "sh", "z"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "g", "bits", "ins", "states", "a", "c", "sq", "h", "sm", "xs", "aps", "ares", "js", "service", "ants", "store", "os", "ss", "ess", "vs", "details", "ns", "ims", "spec", "r", "ats", "l", "ts", "sys", "its", "m", "sp", "es", "b", "acs", "sb", "services", "sol", "stats", "ds", "ses", "S", "sam", "ssl", "gs", "cs", "ps", "t", "bs", "als", "fs", "hs", "j", "p"], "ret": ["new", "rt", "f", "get", "reg", "xt", "jump", "g", "gt", "ref", "result", "jp", " RET", "lt", "lit", "rem", "cont", "len", "tr", "res", "re", "arg", "r", "flag", "det", "RET", "Ret", "rev", "value", "l", "txt", "v", " Ret", "out", "uf", "reset", "val", "rets", "print", "alt", "mem", "status", "last", "it", "rm", "nt", "try", "pret", "mt", "t", "rest"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n", "idx": 17587, "substitutes": {"dev": ["kr", "pad", "window", "Dev", "disk", "ach", "ref", "hw", "cam", "sw", " device", "vr", "h", "des", "ad", "def", "os", "serv", "device", "obj", "pi", "ver", "dm", "buf", "dem", "d", "v", "ctx", "ev", "priv", "dd", "ve", "devices", "md", "dis", "DEV", "Device", "de", "ds", "mem", "usb", "w", "pro", "serial", "nt", "adv", "ptr", "od", "p"], "s": ["sand", "ls", "is", "sl", "sts", "sv", "rs", "g", "as", "aws", "changes", "c", "sq", "h", "sis", "settings", "js", "i", "ports", "ss", "su", "details", "p", "ns", "spec", "set", "r", "ms", "ats", "l", "sync", "ts", "m", "its", "d", "sp", "conf", "b", "v", "se", "n", "sports", "sb", "services", "sol", "stats", "ds", "qs", "ses", "w", "S", "sam", "gs", "cs", "sa", "ps", "comm", "t", "fs", "hs", "j", "es"], "dinfo": ["dInfo", "DInfo", "Dinf", " dfo", "Dfo", "dlinformation", "fInfo", "linfo", "dxinfo", " dci", "pfo", "ffo", "dlinfo", " dInfo", "pInfo", "dinformation", "Dinfo", "dlinf", "pinfo", "finfo", "dxInfo", "dxinf", "lInfo", "dlInfo", "finf", "lfo", "dinf", "dxci", "pinf", "Dinformation", " dinf", "Dci", " dinformation", "dfo", "dci", "linf"], "bs": ["ls", "is", "us", "bb", "bh", "ks", "rs", "bits", "ubs", "bi", "bus", "bd", "BS", "js", "lbs", "ss", "bp", "obs", "vs", "ns", "pb", "ms", "ts", "sys", "its", "eb", "b", "bg", "bn", "bis", "sb", "bc", "gb", "ds", "bos", "bps", "bl", "gs", "bas", "bm", "cs", "ps", "aos", "fs", "bes", "es"]}}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n", "idx": 17596, "substitutes": {"data": ["ready", "cache", "content", "ad", "def", "definition", "ata", "al", "debug", "mu", "dat", "table", "query", "check", "work", "o", "out", "where", "old", "auth", "ae", "add", "done", "entry", "complete", "root", "report", "defined", "date", "client", "DATA", "area", "state", "db", "input", "dev", "partial", "step", "name", "window", "map", "good", "valid", "size", "unknown", "some", "set", "control", "desc", "up", "pro", "batch", "text", "initial", "final", "info", "dal", "draw", "display", "da", "rel", "form", "list", "d", "num", "call", "id", "rew", "Data", "made", "missing", "str", "output", "di", "format", "exec", "details"], "human": ["high", "demon", "visible", "hard", "natural", "initial", "friendly", "weak", "always", "host", "pure", "own", "user", "native", "virtual", "mouse", "Human", "you", "readable", "valid", "hun", "relative", "unknown", "sufficient", "soft", "display", "physical", "null", "low", "public", "person", "check", "localhost", "model", "humans", "money", "broad", "local", "health", "history", "fast", "dirty", "echo", "full", "wind", "graph", " Human", "shown", "transform", "machine", "raw", "serial", "ghost", "input", "hidden", "stable", "hello", "only", "show", "sudo", "nice", "pretty", "normal"]}}
{"project": "FFmpeg", "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7", "target": 0, "func": "static int get_riff(AVFormatContext *s, AVIOContext *pb)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    char header[8];\n\n    int i;\n\n\n\n    /* check RIFF header */\n\n    avio_read(pb, header, 4);\n\n    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */\n\n    avi->riff_end += avio_tell(pb); /* RIFF chunk end */\n\n    avio_read(pb, header+4, 4);\n\n\n\n    for(i=0; avi_headers[i][0]; i++)\n\n        if(!memcmp(header, avi_headers[i], 8))\n\n            break;\n\n    if(!avi_headers[i][0])\n\n        return -1;\n\n\n\n    if(header[7] == 0x19)\n\n        av_log(s, AV_LOG_INFO, \"This file has been generated by a totally broken muxer.\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 17597, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "g", "ins", "as", "aws", "scl", "a", "c", "sq", "ex", "js", "os", "ss", "sc", "conv", "sg", "ns", "ats", "ts", "m", "sys", "sp", "es", "b", "v", "ctx", "n", "ds", "ses", "w", "S", "aus", "gs", "cs", "sa", "ps", "t", "bs", "conf", "fs", "p"], "pb": ["proc", "px", "cv", "bb", "amp", "ub", "PB", "pkg", "bj", "jp", "tg", "wb", "gp", "td", "fb", "mp", "func", "cp", "bp", "np", "pan", "pp", "p", "phy", "pl", "cb", "tc", "lp", "buf", "pc", "wp", "pt", "vm", "client", "b", "ctx", "pa", "uf", "sb", "bc", "db", "pg", "lb", "phys", "apy", "tk", "pro", "ps", "bs", "dp", "tp", "vp"], "avi": ["ahi", "ave", "bi", "ja", "cam", "ta", "nav", "ano", "cli", "ai", "liv", "gra", "ami", " av", "jac", "pan", "eni", "iac", "pi", "audio", "iii", "wi", "pai", "ap", "vi", "avan", "eas", "v", "audi", "aaa", "AV", "bis", "apa", "wire", "ti", "iga", "au", "apy", "am", "opus", "mi", "av", "ij", "adi", "eric", "oti", "ani", "oi", "vp"], "header": ["block", "column", "er", "shift", "h", "Header", "heading", "pp", "head", "event", "top", "cover", "border", "table", "query", "message", "time", "key", "span", "frame", "command", "HEAD", "hash", "offset", "title", "pr", "dt", "len", "body", "index", "prot", "summary", "row", "layer", "comment", "tag", "metadata", "p", "window", "length", "scroll", "sample", "vv", "channel", "size", "port", "buffer", "version", "error", "buf", "headers", "txt", "dr", "fn", "lr", "text", "type", "filter", "part", "info", "position", "server", "padding", "tr", "line", "ver", "lp", "section", "list", "num", "data", "topic", "format", "timeout"], "i": ["to", " I", "is", "g", "bi", " li", "gi", "ind", " mi", "ri", "xi", "ki", " index", "ex", "ai", "ini", "oi", "batch", " v", "li", "ui", "ic", "y", "ip", "io", "\u0438", " ii", "in", "ims", "pi", "iu", "im", "tim", " bi", "ci", "zi", "l", "sim", "m", "asi", "index", "me", "id", "v", "I", "n", "ii", "ei", "ti", "phi", "ix", "x", " ti", "span", " m", "di", " ni", " p", "mi", " j", " multi", "it", "uri", "ij", "iq", "t", "ski", "multi", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t dsthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *src_addr)\n\n{\n\n    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);\n\n    struct ip6_option_hdr opthdr;\n\n    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);\n\n\n\n    while (bytes_left > sizeof(opthdr)) {\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read, optlen;\n\n\n\n        if (input_size < opt_offset) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,\n\n                                &opthdr, sizeof(opthdr));\n\n\n\n        if (bytes_read != sizeof(opthdr)) {\n\n            return false;\n\n        }\n\n\n\n        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1\n\n                                               : (opthdr.len + sizeof(opthdr));\n\n\n\n        if (optlen > bytes_left) {\n\n            return false;\n\n        }\n\n\n\n        if (opthdr.type == IP6_OPT_HOME) {\n\n            size_t input_size = iov_size(pkt, pkt_frags);\n\n\n\n            if (input_size < opt_offset + sizeof(opthdr)) {\n\n                return false;\n\n            }\n\n\n\n            bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                    opt_offset + sizeof(opthdr),\n\n                                    src_addr, sizeof(*src_addr));\n\n\n\n            return bytes_read == sizeof(src_addr);\n\n        }\n\n\n\n        opt_offset += optlen;\n\n        bytes_left -= optlen;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 17611, "substitutes": {"pkt": ["ipkt", "cpet", "mett", "het", "pingkg", "pkg", "mkg", "compkg", "pvc", "packkt", "pix", "hacket", "pingacket", "mkt", " pet", "spacket", "pingkt", "pet", "pett", "hett", " pix", "spet", "spix", "macket", "spkt", "pingvc", "cpix", "ipacket", " packet", "ipvc", "met", "compet", "compacket", "cpacket", "packet", "packacket", " punct", " pkg", "ipkg", "pinget", "punct", "compkt", "pingunct", "hkt", " pvc", "cpkt", "compunct", "packett"], "pkt_frags": ["pkt_tragged", "pkt_finag", "pkt_fings", "pkt_finatts", "pkt_brats", "pkt_brands", "pkt_brag", "pkt_trgs", "pkt_flagg", "pkt_finagg", "pkt_flats", "pkt_Frager", "pkt_tragg", "pkt_drages", "pkt_flagged", "pkt_dragg", "pkt_finags", "pkt_flands", "pkt_plager", "pkt_frats", "pkt_frag", "pkt_frages", "pkt_brgs", "pkt_fragg", "pkt_plags", "pkt_bratts", "pkt_bragged", "pkt_frands", "pkt_drags", "pkt_Frages", "pkt_fratts", "pkt_Fragged", "pkt_bragg", "pkt_brags", "pkt_Frags", "pkt_drag", "pkt_trags", "pkt_frager", "pkt_flatts", "pkt_fragged", "pkt_trats", "pkt_finagged", "pkt_trag", "pkt_flags", "pkt_flages", "pkt_plages", "pkt_drands", "pkt_flager", "pkt_flag", "pkt_frgs", "pkt_drats", "pkt_trages", "pkt_plagged"], "dsthdr_offset": ["dsthld_position", "dsthld_offset", "dsthdr_size", "dsthdr_Offset", "dsthdr_position", "dsthld_Offset", "dsthdr_len", "dsthdr_off", "dsthld_off"], "ext_hdr": ["ext_phld", "ext2shDR", "ext_thr", "ext2thdr", "ext_haddr", "ext2shaddr", "ext_whdef", "ext2thld", "ext_whDR", "ext_thdef", "ext_shDR", "ext2hDR", "ext_phdr", "ext2shr", "ext2haddr", "ext_hdef", "ext2hld", "ext_phaddr", "ext_hr", "ext_thdr", "ext_shdr", "ext2hr", "ext_phDR", "ext_hld", "ext_whr", "ext_shr", "ext2shdr", "ext_whdr", "ext2thDR", "ext_thaddr", "ext_thDR", "ext_hDR", "ext_phr", "ext2hdr", "ext_shaddr", "ext_thld", "ext2thaddr"], "opthdr": ["optrDR", "copthld", "opthrer", "opothdr", "opothDR", "opothrer", "pTHres", "opthsr", "hopthdr", "copthrer", "copthdr", "optrdr", " opthld", "opbyterdr", "pTHook", "opthsdr", "oppholder", "OPthdr", "opkhrid", "okthdr", "optwook", " opthrid", "OPphrr", " optholder", "optwheader", "opTHDR", "copothrer", "optholder", "opTHerr", "topthg", " optrdr", "pthr", "opothder", "opkhop", "opthheader", "hopthrr", "topTHder", "opthook", "opothg", "optwdr", "pthres", "opThrr", "opethDR", "okthDR", "opTHder", "optrr", "opthld", "opphr", "opthrr", "opthr", "opethrid", " opthr", " opphdr", "pTHheader", "opthsook", "opkholder", "okthook", "optherr", "opTHld", "opithrid", "opphres", "opethdr", "okTHdr", "opkhheader", "opThrid", "OPthop", "opThdr", "okTHook", "copothld", " opTHdr", "opthsrid", "opThr", "opstrr", "opphrid", "opphld", "hopthsrr", "coptherr", "OPphrid", "opithr", "hopthsdr", "pthheader", "okTHDR", "OPphr", "optherder", "opithdr", "opthg", "opbytererr", "opothld", "opghdr", "opghr", "opkhr", "optrrid", "copotherr", "opphrr", "opghrr", "opTHr", "opTHook", "opthDR", "OPthrr", " optrDR", "topTHdr", "OPphdr", "opthop", "hopthrid", "pthdr", "opthrid", " opTHld", "opphop", "opphdr", "opTHres", "topTHDR", "optwr", "opTHrid", "opstr", "optwres", "optherg", "pthook", "opthsrr", "opTHdr", "opTHrer", "pTHdr", "opthder", " oppholder", "optherdr", "optrld", "opithop", "topthder", "topTHg", "topthDR", " opTHr", "OPthrid", "opkhook", "hopthr", "opthsDR", "opthres", "hopthsrid", " opthDR", "OPthr", " optrrid", "opotherr", "opTHolder", "OPphop", "opbyterld", "opTHg", "opstdr", "copothdr", "optherDR", "hopthsr", "topthdr", "opkhdr", "opTHheader", "pTHr", " opphr", "opbyterrer", "optrook"], "bytes_read": ["bytes64Read", "bytes42reader", "bytes64read", "bytes_received", "tes_used", "bytes2received", "bytes2READ", "services42reader", "bytes5READ", "bytes64left", "bytes42received", "services42received", "bytes___read", "bytes42Read", "bytes_left", "tes_readable", "bytes_reader", "bytes2Read", "services_reader", "tes_reader", "tes_received", "tes_read", "bytes64used", "bytes_used", "services_Read", "bytes_readable", "bytes5read", "bytes___readable", "bytes_write", "bytes5received", "services42Read", "bytes_find", "services_received", "tes_write", "bytes___find", "services_read", "tes_READ", "bytes2left", "services42read", "bytes2read", "bytes42read", "tes_left", "tes_Read", "bytes_Read", "bytes_READ", "tes_find", "bytes2used"], "optlen": ["opfun", "optimlen", "potfun", "opLen", " optdel", "optdel", " optcoll", "altlon", "oopno", " opten", "optimno", "opteden", " optLen", "optLen", "optimgz", "potLen", "opteddel", "optedLen", "altlen", "altl", "optedcoll", "optedlon", "optln", "optedln", "optno", "optl", " optln", "ooplen", "optimLen", "optedlen", "oplen", "opgz", "altln", "altLen", "optfun", "optimcoll", "optlon", "opten", "opl", "opno", " optfun", "oplon", "potlen", "optcoll", "potl", "opln", " optl", "oopLen", "optimdel", "optgz", "oopgz", "optimen"]}}
{"project": "FFmpeg", "commit_id": "582552fb56ba6559cb1d094a7e7ae5dde3073c5c", "target": 0, "func": "static int altivec_uyvy_rgb32 (SwsContext *c,\n\n\t\t\t       unsigned char **in, int *instrides,\n\n\t\t\t       int srcSliceY,\tint srcSliceH,\n\n\t\t\t       unsigned char **oplanes, int *outstrides)\n\n{\n\n  int w = c->srcW;\n\n  int h = srcSliceH;\n\n  int i,j;\n\n  vector unsigned char uyvy;\n\n  vector signed   short Y,U,V;\n\n  vector signed   short vx,ux,uvx;\n\n  vector signed   short R0,G0,B0,R1,G1,B1;\n\n  vector unsigned char  R,G,B;\n\n  vector unsigned char *out;\n\n  ubyte *img;\n\n\n\n  img = in[0];\n\n  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);\n\n\n\n  for (i=0;i<h;i++) {\n\n    for (j=0;j<w/16;j++) {\n\n      uyvy = vec_ld (0, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);\n\n\n\n      uyvy = vec_ld (16, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);\n\n\n\n      R  = vec_packclp (R0,R1);\n\n      G  = vec_packclp (G0,G1);\n\n      B  = vec_packclp (B0,B1);\n\n\n\n      //      vec_mstbgr24 (R,G,B, out);\n\n      out_rgba (R,G,B,out);\n\n\n\n      img += 32;\n\n    }\n\n  }\n\n  return srcSliceH;\n\n}\n", "idx": 17615, "substitutes": {"c": ["f", "lc", "cv", "g", "cache", "cam", "a", "C", "h", "ca", "fc", "rc", "cont", "ic", "cp", "y", "u", "tc", "r", "e", "ci", "ac", "l", "m", "con", "cc", "b", "v", "ctx", "ct", "s", "ce", "coll", "w", "cs", "ch", "t", "co", "conf", "dc", "p"], "in": ["f", "inn", "is", "ins", "as", "inc", "mm", "err", "ex", "info", "gin", "inner", "din", "serv", "ic", "src", "im", "r", "ac", "l", "m", "conf", "con", "imp", "IN", "n", "s", "data", "up", "it", "bin", "raw", "arp", "at", "input", "inf", "t", "In", "p"], "instrides": ["inStrides", "instsides", "instsuments", "instride", "outstrades", "outStride", "outstruments", "inctrades", "inStride", "outStrides", "instside", "instsades", "inStruments", "inctruments", "outStrades", "instruments", "outstride", "instrades", "outStruments", "inStrades", "inctride", "inctrides"], "srcSliceY": ["srcSlsliceHeight", "srcSlaceZ", "srcSlICEHeight", "srcSlideH", "srcsliceY", "srcSliceZ", "srcPlICEZ", "srcsliceHeight", "srcSlaceH", "srcPliceH", "srcSlideY", "srcSlsliceY", "srcSliceX", "srcSlideX", "srcslsliceX", "srcSlideHeight", "srcslsliceHeight", "srcSlaceX", "srcSlsliceX", "srcSlideZ", "srcslsliceH", "srcSlICEZ", "srcPlICEH", "srcslsliceY", "srcSliceHeight", "srcSlICEY", "srcSlICEH", "srcPliceX", "srcPliceZ", "srcSlaceY", "srcsliceX", "srcPlICEY", "srcSlICEX", "srcPlICEX", "srcSlsliceH", "srcsliceH", "srcPliceY"], "srcSliceH": ["srcPliceHT", "srcSlideH", "srcSlICEHT", "srcSliceW", "srcPliceH", "srcSlideY", "srcSlipHT", "srcPlipW", "srcPlipH", "srcPlipY", "srcSlideHT", "srcSlICEW", "srcPliceW", "srcSlipW", "srcSlICEY", "srcSlICEH", "srcSliceHT", "srcPlipHT", "srcSlipH", "srcSlipY", "srcPliceY", "srcSlideW"], "oplanes": ["opanes", "planguages", "ixeledes", "ixelasms", "iplanes", "planes", "oclubes", "opasms", "iplane", "oclane", "plane", "iplanguages", "ixelushes", " overlasms", "oclanguages", "opushes", " overlanes", "opedes", "ixelanes", "oplanguages", " overledes", "oplushes", "oplasms", " overlushes", "opledes", "iplubes", "oplane", "oplubes", "plubes", "oclanes"], "outstrides": ["outspride", "inStrides", "outStriders", "outslids", "instride", "instriders", " outslids", " outslide", "outStrride", "inStriders", "instrride", "outstriides", "outctrids", " outstrids", " outstrends", "outstriride", " outstride", "outStride", "outStrends", "outstriders", "outspides", "outctrends", "outctride", "outStrides", "inStride", " outslides", "outslide", "outctrides", "outspiders", "outslends", "outstrride", "outstrids", "outstrends", "outspide", "outstride", "outstriiders", "outstriide", "inStrride", " outslends", "outslides", "outStrids"], "i": ["is", "bi", "ind", "init", "a", "h", "xi", "ki", "ex", "ai", "ia", "li", "ic", "ui", "y", "ip", "jj", " ii", "pi", "iu", "by", "im", "r", "zi", "ci", "l", "sim", "m", "me", "ji", "index", "id", "b", "v", "k", "I", "n", "o", "ii", "ti", "phi", "ix", "x", "di", "w", "it", "mi", "ie", "ij", "ini", "z", "si", "p"], "j": ["jl", "jump", "J", "br", "g", "ja", "bj", "jp", "ion", "h", "jc", "js", "json", "kj", "q", "fr", "y", "jj", "obj", "u", "aj", "r", "l", "m", "ji", "el", "b", "v", "k", "n", "o", "dj", "key", "oj", "ix", "uj", "x", "jit", "jo", "it", "ie", "try", "at", "ij", "adj", "bs", "z", "p"], "uyvy": ["kyxy", "yuvt", "ailyvy", "inkyvy", "yuuffy", "yumy", "ailymy", "uyvt", " toycam", "kyjoy", "oyvc", "oycam", "yuwy", "uymire", "icyachy", "yuvc", " toyvt", "ujmire", "etchupvy", "yuvy", "inkywx", "uuwy", "uuuffy", "kyvoy", "yuxy", "uycam", "ujbil", "ailyvin", "kywx", "inkyjoy", "uyachy", "kyuffy", "icyvy", "uymy", "etchupjoy", "kybil", "yubil", "etchupwy", "uuvy", "kymy", "yujoy", "uuty", " toywy", "uywy", "yucam", "ujwy", "uyuffy", "oyjoy", "ujachy", "inkywy", "kyty", "icymire", "yuty", " toyvy", "uyjoy", "kyvin", "uuvre", "oyvt", "yuachy", "icyvoy", "kyvre", "uyxy", "icyvre", "ujvre", "uyvc", "uuxy", "uyvre", "kyvy", "etchupvc", "uywx", "oyvy", "ailywy", "icywy", "uyvoy", "yuvoy", "yumire", "yuvre", "kywy", "ujvy", "uyvin", "uyty", "oywy", "oywx", "uybil", "yuvin"], "Y": ["Py", "XY", "J", "Ty", "M", "P", "H", "C", "My", "EY", "HT", "SY", "Q", "GY", "TH", "T", "AM", "Gy", "TY", "Year", "y", "ANY", "YY", "RY", "MY", "Z", "FY", "I", "A", " y", "O", "BY", "W", "S", "N", "E", "YC", "L", "X"], "U": ["UU", "Ut", "URI", "US", "UL", "M", "P", "UID", "H", "LU", "C", "AU", "User", "MU", "UC", "UD", "Up", "T", "Thu", "OU", "Unit", "Us", "UX", "u", " u", "GU", "SU", "Lu", "UV", "UE", "UP", "Mu", "EU", "I", "A", "UR", "You", "CU", "S", "W", "UT", "PU", "Users", "L", "Tu", "X", "UF", "UI"], "V": ["VO", "J", "Ve", "GV", "VOL", "NV", "M", "P", "TV", "VW", "H", "C", "Q", "VAL", "Va", "T", "It", "VC", "F", "USB", "Z", "UV", "VG", "v", "I", "A", "VA", "VI", "VM", "Vector", "Ver", "BY", "W", "S", "VS", "L", "E", "IV", "X", "UI"], "vx": ["nvxx", "uvX", "nvy", "uvxx", "cvx", "vX", "uvy", "cvxx", "vy", "nvX", "cvy", "cvX", "nvx", "vxx"], "ux": ["us", "XX", "ox", "tx", "rx", "rc", "linux", "def", "ui", "conv", "etc", "ue", "select", "UX", "u", "wx", "uf", "lu", "lux", "uc", "au", "ix", "uv", "lang", "aux", "uu", "foo", "xx", "vp"], "uvx": ["ufxy", "uvX", "ufX", "cvx", "uuX", "uuxy", "cvX", "uvxy", "ufw", "ufx", "uvw", "uuw", "uux", "cvw", "cvxy"], "R0": ["Ros", "B2", "RA0", "RA2", " R2", "G02", "GZero", "R2", "RA1", "RT1", "GId", " R02", "RTos", " Ros", "RA02", "RAId", "G2", "RT0", "BZero", "BId", "R02", "RZero", "RAZero", "RId", "Gos"], "G0": ["Bold", "B5", " G06", "G048", " Gold", "Greg048", "GG5", "g1", "Gold", "Group1", "Greg06", " G5", "BID", "RID", "Group06", "Greg1", "G06", "Greg0", "G5", "gID", "g0", "Group0", "GG0", " G048", "GGold", "GID", "Group048", "GG1"], "B0": ["Bzero", "Gzero", "B2", "BT0", "Y1", "Borg", "BR1", "BT1", "Y0", "Gorg", "G2", " B2", "BTorg", "BRzero", "V0", "BR0", " Borg", "Yzero", "BT2", "V1"], "R1": ["GMap", "LPU", "L0", "RONE", "RROne", "ROne", "RA0", "RPU", " R3", "R3", "RA1", "RAMap", " RPU", "GOne", "BOne", "RAONE", "RR1", "V0", "RA3", "L3", "GONE", "VONE", "RAPU", "V1", "L1", "RR0", "VMap", "RMap"], "G1": ["V001", " GPU", "Grone", " G2", "GrONE", "V2", "GrAP", " Gone", "RPU", "Group1", "R2", "Groupone", "GroupONE", "GAP", "Gr1", "VAP", "Gr0", " GONE", "G2", "GPU", "G001", "V0", " G001", "Group0", "Gr001", "GONE", "VPU", "V1", " GAP", "Gone"], "B1": ["T0", "B2", "C2", "V2", "T2", " B01", " B4", "G4", "G01", "GOne", "BOne", "C0", "G2", "B4", " BOne", "B01", " B2", "V01", "V0", "T4", "C1", "COne", "V1", "T1"], "R": ["RA", "RR", "RGB", "M", "P", "H", "C", "Q", " r", "RL", "GR", "ER", "D", "RT", "r", "I", "A", "AR", "RO", "W", "S", "N", "RG", "DR", "L", "E", "BR", "X"], "G": ["GS", "J", "g", "GV", "GROUP", "P", "GB", "H", "M", "C", "GRE", "GR", "GA", "GP", "D", "Gr", "Go", "GU", "GG", "LG", "BG", "Gu", "Graph", "GI", "Group", "Graphics", "GT", "W", "RG", "Ge", "PG", "L"], "B": ["J", "BL", "Bi", "M", "P", "GB", "H", "C", "NB", "GO", "BM", "BA", "T", "AB", "D", "BC", "BW", "b", "Bar", "I", "A", "BG", "LB", "WB", "O", "BY", "BO", "W", "BI", "BT", "N", "DB", "L", "BB", "BR", "BD"], "out": ["to", "tmp", "bit", "g", "ref", "outs", "array", "result", "a", "OUT", "err", "Out", "buffer", "ot", "io", "res", "u", "r", "buf", "b", "v", "n", "o", "str", "cmd", "data", "output", "w", "it", "bin", "at", "ch", "t", "p"], "img": ["f", "tmp", "url", "ht", "attr", "br", "th", "g", "ref", "jp", "aug", "h", "err", "fb", "mp", "fr", "pixel", "rb", "Image", "obj", "np", "p", "orig", "src", "im", "gif", "um", "arr", "buf", "m", "imp", "bg", "uf", "png", "pic", "images", "gm", "str", "gb", "html", "up", "uv", "it", "bl", "raw", "image", "ob", "emb", "ch", "og", "ij", "anim", "imag", "jpg"]}}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static void inc_refcounts(BlockDriverState *bs,\n\n                          BdrvCheckResult *res,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0)\n\n        return;\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17627, "substitutes": {"bs": ["ls", "bb", "bh", "rs", "bits", "ubs", "iss", "asis", "BS", "js", "lbs", "os", "ss", "vs", "ns", "ubis", "ts", "its", "b", "bis", "sb", "bc", "cks", "ds", "bos", "bps", "gs", "bles", "cs", "ps", "aos", "als", "fs", "hs"], "res": ["proc", "crit", "ber", "reg", "rek", "rs", "response", "ins", "result", "err", "rez", "Res", "rc", "js", "rem", "ret", "pr", "RES", "def", "cons", "ro", "pas", "re", "rel", "r", "expr", "resp", "gr", "pers", "rss", "ack", "pres", "wcs", "reset", "req", "vals", "resolution", "ress", "usr", "scope", "resh", "comm", "details", "cond", "rest", "red"], "refcount_table": ["refcountingmap", "refCount_Table", "refCount_tab", "refcount_tab", "refcount_map", "refcount_info", "refcountingtable", "refcountingtype", "refcount_type", "refCount_table", "refCount_info", "refcount_Table"], "refcount_table_size": ["refcount_TABLE_SIZE", "refcount_tab_size", "refcount_TABLE_size", "refcount_TABLE_number", "refcount_table2offset", "refcount_tab_SIZE", "refcount_table2number", "refcount_TABLE2number", "refcount_table2size", "refcount_tab_number", "refcount_TABLE2offset", "refcount_TABLE_offset", "refcount_table_offset", "refcount_table2SIZE", "refcount_TABLE2size", "refcount_table_number", "refcount_TABLE2SIZE", "refcount_table_SIZE"], "offset": ["length", "type", "block", "alias", "end", "location", "ref", "tile", "slot", "fp", "init", "peer", "shift", "point", "origin", "pointer", "seed", "Offset", "position", "padding", "amount", "attribute", "pos", "error", "align", "set", "address", "sector", "index", "off", "row", "o", "key", "reset", "slice", "trace", "prefix", "first", "seek", "et", "base", "addr", "ptr", "oid"], "size": ["window", "length", "sum", "type", "zone", "scroll", "sn", "south", "shift", "fee", "gravity", "style", "shape", "position", "name", "SIZE", "scale", "len", "amount", "ize", "padding", "bytes", "max", "height", "small", "zero", "si", "total", "Size", "state", "since", "empty", "capacity", "count", "storage", "number", "resolution", "sized", "dimension", "range", "timeout"], "s": ["ls", "sl", "ges", "sts", "sv", "rs", "g", "ins", "sn", "aws", "sw", "eps", "south", "a", "h", "c", "sq", "xs", "settings", "js", "os", "ss", "ies", "ns", "ims", "ats", "ts", "its", "sp", "b", "parts", "bis", "sb", "stats", "ds", "http", "ses", "less", "qs", "S", "sam", "gs", "abilities", "cs", "ps", "comm", "als", "fs", "hs", "p"], "start": [" Start", "from", "get", "rank", "end", "st", "init", "part", "pre", "iter", "shift", "use", "origin", "info", "starting", "store", "arts", "ish", "pos", "p", "top", "head", "set", "max", "check", "import", "started", "index", "Start", "sp", "before", "first", "wind", "seek", "next", "begin", "art", "it", "stop", "base", "range", "step", "ist"], "last": ["close", "length", "end", "st", "final", "based", "largest", "Last", "nd", "worst", "after", "tail", "bottom", "prev", "max", "table", "vol", "est", "l", "best", "n", "total", "most", "since", "latest", "first", "full", "ast", "next", "highest", "stop", "base", "scope", "stable", "las", "show", "rest", "reverse"], "cluster_offset": ["clusters_pointer", "clust_metadata", "clusters_offset", "clusterxoffset", "cluster32offset", "cluster_point", "cluster__position", "clluster_tile", "clust_address", "clicaxpoint", "clluster_point", "cluster_position", "cluster_address", "cluster32point", "clica_off", "cluster_id", "cluster_metadata", "cluster64offset", "clusterxoff", "clust_name", "cluster____name", "cluster_pointer", "clicaxoffset", "clust_Offset", "cluster64address", "clust_point", "cluster_slice", "cluster32off", "cluster64pointer", "clica_slice", "cluster____position", "clluster_index", "clusterxpoint", "clicaxoff", "cluster____offset", "clica_point", "cluster_index", "clusterxslice", "clicaxslice", "cluster_name", "cluster64Offset", "cluster__metadata", "clica_offset", "clust_offset", "cluster__offset", "cluster_tile", "cluster_Offset", "clust_id", "cluster____slice", "clust_pointer", "clust_position", "clusters_Offset", "cluster_off", "cluster32slice", "clust_slice", "clluster_offset"], "k": ["ikk", "kr", "ku", "ks", "kan", "ik", "g", "ak", "kl", "uk", "i", "ck", "kj", "wk", "q", "K", "acc", "jj", "sk", "unk", "kind", "u", "ka", "ac", "ke", "d", "m", "kw", "ack", "kh", "km", "n", "kid", "key", "mk", "isk", "kn", "ek", "kk", "ko", "z", "j", "p"], "check_errors": ["checkingerror", "read_error", "read_errors", "checkingresults", "check_error", "read_results", "checkingerrors", "check_results"], "corruptions": ["interruptions", "corregations", "corregions", "corartes", "corrites", "interregations", "corritibles", "interregibles", "interregions", "corruptibles", "interreges", "corritions", "corartions", "correges", "interruptations", "interruptibles", "corartations", "interruptes", "corruptations", "corritations", "corregibles", "corartibles", "corruptes"]}}
{"project": "qemu", "commit_id": "733f0b02c80c3a7106d8327a83948ab68db10ea7", "target": 0, "func": "void stw_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t v = tswap16(val);\n\n    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);\n\n}\n", "idx": 17641, "substitutes": {"addr": ["pad", "attr", "offset", "ref", "host", "hw", "pkg", "a", "h", "ash", "err", "ag", "eth", "ay", "ad", "asm", "store", "tr", "pos", "obj", "src", "handle", "r", "address", "arr", "Address", "work", "dh", "d", "id", "ack", "ctx", "gate", "hl", "cmd", "ix", "x", "mem", "dr", "adr", "at", "ptr", "t", "add"], "val": ["bit", "reg", "type", "all", "ref", "slot", "pal", "test", "tx", "Val", "sel", "fee", "valid", "VAL", "pr", "serv", "rol", "cal", "al", "arg", "vol", "pol", "ac", "value", "v", "abl", "state", "sol", "data", "mem", "bal", "vals", "aval", "vt", "bin", "t"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                int l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 17653, "substitutes": {"ctx": ["cv", "c", "wd", "document", "setup", "etc", "jac", "np", "kt", "mom", "check", "work", "utils", "mk", "today", "cas", "req", "mem", "command", "cmp", "co", "proc", "cf", "act", "hw", "tx", "std", "ca", "xs", "warn", "cp", "obj", "cb", "cu", "expr", "wcs", "context", "alloc", "cmd", "ksh", "nt", "scope", "conf", "cfg", "tmp", "tm", "window", "conn", "pkg", "ind", "cm", "conv", "loc", "wx", "tc", "ka", "resp", "cpu", "kw", "cl", "ct", "history", " cx", "prefix", "ctrl", "desc", "x", "aux", "batch", "crit", "lc", "config", "Context", "ctr", "scl", "that", "jp", "kl", "abc", "rc", "fc", "ck", "func", "sc", "xp", "gc", "qt", "unc", "nc", "sys", "cc", "gz", "ctl", "HK", "xc", "lex", "exec", "timeout"], "insn_bytes": ["insnpyresults", "insn_pieces", "insn_steps", "insnYbytes", "insn_items", "insnYitems", "insn8bytes", "inszn__tags", "insN_bytes", "inszn__errors", "insn_tags", "insnYerrors", "insN_times", "inszn_tags", "insn__items", "insnpypieces", "insnYtags", "insn3times", "inszn__bytes", "insn3bytes", "inszn__items", "insn8steps", "inszn_errors", "insn__tags", "insN_steps", "insn__errors", "inszn_items", "insn_results", "insen_results", "insnpybytes", "insn_times", "insen_pieces", "insn3steps", "insn__bytes", "inszn_bytes", "insen_bytes", "insn_errors", "insn8times"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n", "idx": 17664, "substitutes": {"slirp": ["SLierp", "slirlp", "slircf", "slirpy", "slrirpa", "Slpirf", "slirse", "glirlp", "slvirse", "selirpi", "SLierpa", "sliroP", "slarl", "Slpirp", "slircpi", "Slirf", "slirlg", "slrirf", "slpirse", "slirapy", "slirP", "slvirf", "selircg", "selircpi", "SLirP", "slrirr", "slirl", "slrirse", "swirr", "slirlping", "glirp", "slirlpa", "slierp", "plpirphp", "slirepa", "slpirpa", "slpirf", "swirpc", "plpirl", "sliraphp", "Slirse", "Slirp", "slibrf", "glirlv", "slarphp", "slibrpi", "slirphp", "SLirp", "SLirpa", "selirf", "selircf", "slarp", "slirepc", "Slirl", "glirlg", "slpirl", "slibrp", "plirl", "slrirg", "plpirp", "slirlv", "slrirpc", "slirping", "sliropa", "swirp", "swirpa", "slirg", "glirlpa", "selirp", "SLierP", "slpirr", "slirr", "slirtpa", "sliroping", "swrirpa", "slarpy", "plirphp", "sliral", "selirg", "slpirphp", "slpirp", "Slpirl", "slierping", "slrirp", "swrirr", "swrirpc", "SLirping", "slvirp", "slirv", "slirop", "slierpa", "slpirpc", "Slpirse", "selircp", "slirpc", "slircp", "slirtv", "slircg", "plirp", "glirv", "glirpa", "slrirl", "slirap", "slierP", "slirpa", "slierg", "slirtp", "slvirl", "slirer", "slirep", "SLierping", "glirg", "slirpi", "slirf", "slierv", "slibrg", "slrirpi", "plirpy", "slirtg", "slpirpy", "swrirp", "plpirpy", "slirlP"]}}
{"project": "qemu", "commit_id": "eda470e41a753070e057380a9a71e2ad7347f667", "target": 0, "func": "void scsi_req_abort(SCSIRequest *req, int status)\n\n{\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->ops->cancel_io) {\n\n        req->ops->cancel_io(req);\n\n    }\n\n    scsi_req_complete(req, status);\n\n    scsi_req_unref(req);\n\n}\n", "idx": 17670, "substitutes": {"req": ["org", "init", "js", "def", "fr", "bp", "low", "pp", "rr", "qq", "query", "ctx", "md", "quest", "needed", "cmp", "rest", "proc", "tx", "tek", "rem", "dq", "rb", "obj", "expr", "subject", "esp", "cmd", "compl", "forced", "required", "inv", "usr", "iq", "p", "job", "ext", "pkg", "require", "ind", "good", "q", "comp", "wx", "resp", "buf", "txt", "history", "prefix", "desc", "task", "cur", "seq", "pro", "bound", "aux", "comm", "crit", "ref", "ctr", "jp", "pub", "urg", "requ", "res", "qt", "rel", "gr", "request", "any", "call", "dep", "exec", "ps"], "status": ["type", "Status", "uses", "atus", " Status", "result", "sw", "size", "ity", "unknown", "scale", "sc", "error", "tr", "spec", "flag", "set", "check", "resp", "score", "sync", "progress", "id", "code", "state", "str", "active", "prefix", "count", "compl", "success", "wait", "deg", "msg", "current", "ssl", "stat", "details"]}}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n", "idx": 17678, "substitutes": {"i": ["is", "init", "ip", "y", " ii", "ims", "qi", "gl", "e", "v", "I", "ii", "key", "phi", " ti", " j", " multi", " ki", " di", " Li", "ui", "\u0438", "pi", "im", "ms", "index", " pi", " wi", "mi", "iq", "multi", "p", " I", " my", " li", "gi", "ind", "chain", "xi", "point", "ki", "ex", "cli", "ai", " Ti", "q", "li", "go", "iu", " bi", "ci", "l", "sim", "m", "me", "ti", "x", " m", "uri", " si", "ij", "ski", "si", "bi", " mi", "info", "ic", "in", " key", "zi", "list", "id", "ji", " iter", " it", "ix", "di", " ni", "it", "ini", "j"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 17682, "substitutes": {"entry": ["alias", "cell", "channel", "interface", "Entry", "info", "def", "diff", "spec", "match", "table", "query", "scan", "import", "row", "record", "se", "inter", "key", "member", "link", "cur", "ent", "machine", "range", "ry"], "dsdt": ["esdp", "cstd", "sddl", "ststd", "dossth", "dstd", "instd", "tesdm", "jsdat", "myst", "dsds", "insdt", "esdm", "bstd", "desDT", "mysdk", "adsds", "yst", "dstp", "desdat", "checkswt", "bsdt", "ksDT", "ddt", "eswt", "sddt", "cstp", "ksdat", "mysdt", "sdat", "estd", "sdtp", "esdt", "sDT", "checkstd", "dsstab", "std", "stsdt", "stsdp", "sdp", "nsDT", "csdat", "sddp", "testd", "ksdt", "dDT", "dtp", "checksdt", "dlstab", "dlsth", "nstd", "dssth", "nsdt", "dswt", "dldt", "mysDT", "checksdm", "destp", "dsdm", "sddat", "dldk", "dtd", "myssth", "dosdk", "mystd", "kstp", "ysdt", "adsDT", "sdtd", "ysdat", "dst", "teswt", "bsdat", "stsdat", "insdat", "sdDT", "esdat", "dsDT", "dsdk", "insdl", "bstp", "jsds", "adsdt", "sdt", "dosdt", "sds", "csdt", "csstab", "ystd", "nstp", "dosstab", "csdl", "jsDT", "desdt", "dsdl", "sdstab", "dsdat", "csdp", "tesdt", "mysdat", "dsdp", "adsdat", "csDT", "mysstab", "jsdt"], "sb_scope": ["bg_scope", "sf_depth", "bg_sp", "bg_sc", "sb_space", "sb_store", "sg_Scope", "bh_context", "sb_push", "bh_case", "sb_device", "sf_close", "sblydepth", "bh___cycle", "sb___cycle", "sg_window", "sb_close", "sbptcycle", "bh_cycle", "sb_context", "sg_device", "sf_push", "sg_space", "sb_window", "sb_sc", "bg_map", "sbptspace", "sg_scope", "sg_cycle", "sb_case", "sbptstore", "sg_shape", "bh___scope", "sg_store", "sb___scope", "sblypush", "sb_depth", "bh___case", "bh___context", "sblyclose", "sblyscope", "sb_shape", "bh_scope", "sb_Scope", "sf_scope", "sb_cycle", "sb___context", "sb_sp", "sb___case", "sb_map", "sg_sc", "sbptscope"], "scope": ["resource", "window", "chain", "root", "port", "style", "sc", "device", "kind", "spec", "group", "src", "dir", "scan", "project", "id", "index", "env", "var", "mode", "ev", "serial", "module", "trigger", "range"], "dev": ["pad", "window", "Dev", "disk", "attr", "block", "cho", "conn", "push", " device", "wd", "develop", "stick", "des", "def", "device", "util", "iv", "debug", "loc", "go", "sd", "ver", "reader", "buf", "scan", "vol", "dem", "den", "el", "tech", "gu", "env", "row", "v", "var", "ev", "priv", "dd", "ve", "app", "val", "devices", "development", "db", "cmd", "DEV", "data", "link", "Device", "de", "mem", "usb", "pro", "serial", "adv", "nt", "av", "addr", "stable", "ch", "range", "pu", "normal"], "method": ["proc", "prop", "attr", "action", "mount", "depth", "property", "METHOD", "func", "Method", "access", "util", "class", "spec", "src", "function", "m", "mid", "mode", "package", "cmd", "fun", "op", "magic", "module", "serial", "mod"], "field": ["f", "ff", "prop", "label", "attr", "mount", "pos", "Field", "util", "class", "spec", "address", "dir", "table", "id", "param", "var", "comment", "key", "fields", "prefix", "file", "col", "msg", "fun", "module", "tag"], "pkg": ["alias", "init", "gp", "plugin", "pub", "kg", "plug", "cp", "util", "kind", "dir", "sys", "imp", "ctx", "priv", "family", "package", "db", "prefix", "cmd", "phys", "packages", "lib", "msg", "gen", "aux", "pack", "addr", "cmp"], "crs": ["acrs", "pcds", "cds", "vps", "pccs", "vcs", "acds", "acps", "ccs", "vds", "cps", "accs", "pcps", "vrs", "pcrs"], "mem_ranges": ["mem_eranges", "mem_arrists", "mem_rays", "mem_arrots", "mem_arrays", "mem_erists", "mem_arranges", "mem_rots", "mem_arists", "mem_aranges", "mem_rists", "mem_erays", "mem_erots", "mem_arays", "mem_arots"], "io_ranges": ["io_rows", "io_Ranges", "io_rates", "io_Rows", "io_brows", "io_Rates", "io_rgasks", "io_brates", "io_rgows", "io_rgates", "io_rasks", "io_brasks", "io_Rasks", "io_rganges", "io_branges"], "pcms": ["picms", "ccvs", "ccms", "icMS", "pcvs", "ccMS", "icvs", "ccmb", "icms", "pcMS", "picmb", "pcmb", "icmb", "picMS", "picvs"], "bus": ["proc", "us", "block", "box", "config", "boot", "cache", "chain", "mount", "card", "lock", "board", "port", "bank", "plug", "way", "bug", "bid", "back", "book", "Bus", "BUS", "task", "bolt", "usb", "machine"], "i": ["g", "bi", "a", "c", " v", "li", "y", "io", "pi", "e", " bi", "ci", "l", "m", " b", " pi", "b", "v", "k", "I", "ii", "x", "di", " j", "t", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "3d6f761713745dfed7d2ccfe98077d213a6a6eba", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch64(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    unsigned int new_el = env->exception.target_el;\n\n    target_ulong addr = env->cp15.vbar_el[new_el];\n\n    unsigned int new_mode = aarch64_pstate_mode(new_el, true);\n\n\n\n    if (arm_current_el(env) < new_el) {\n\n        if (env->aarch64) {\n\n            addr += 0x400;\n\n        } else {\n\n            addr += 0x600;\n\n        }\n\n    } else if (pstate_read(env) & PSTATE_SP) {\n\n        addr += 0x200;\n\n    }\n\n\n\n    switch (cs->exception_index) {\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        env->cp15.far_el[new_el] = env->exception.vaddress;\n\n        qemu_log_mask(CPU_LOG_INT, \"...with FAR 0x%\" PRIx64 \"\\n\",\n\n                      env->cp15.far_el[new_el]);\n\n        /* fall through */\n\n    case EXCP_BKPT:\n\n    case EXCP_UDEF:\n\n    case EXCP_SWI:\n\n    case EXCP_HVC:\n\n    case EXCP_HYP_TRAP:\n\n    case EXCP_SMC:\n\n        env->cp15.esr_el[new_el] = env->exception.syndrome;\n\n        break;\n\n    case EXCP_IRQ:\n\n    case EXCP_VIRQ:\n\n        addr += 0x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n", "idx": 17699, "substitutes": {"cs": ["ls", "cv", "sts", "cell", "ks", "acts", "rs", "er", "ins", "fs", "c", "cus", "cm", "ares", "rc", "js", "ck", "css", "cons", "cp", "sc", "cases", "vs", "ns", "ces", "tc", "rys", "ms", "CS", "ts", "caps", "cc", "acs", "ctx", "wcs", "icks", "s", "ce", "cks", "ds", "ec", "ses", "qs", "uns", "gs", "csv", "ps", "otes", "bs", "ys", "hs"], "cpu": ["proc", "CPU", "arch", "bench", "ox", "conn", "runner", "hw", "mx", "processor", "cn", "clock", "c", "nic", "ex", "ck", "chip", "cp", "ork", "net", "np", "gc", "cu", "ka", "pc", "nc", "vm", "ctx", "core", "alloc", "cow", "cmd", "gpu", "ec", "mem", "rom", "node", "stat", "process", "ola", "pu", "tp"], "env": ["org", "cv", "er", "vd", "stage", "def", "forge", "gear", "vs", "np", "event", "e", "ect", "dh", "ctx", "v", "var", "arm", "uv", "timer", "ten", "equ", "hw", "entry", "email", "docker", "oe", "ef", "eh", "serv", "order", "cp", "net", "obj", "eni", "em", "el", "ev", "esp", "console", "context", "cmd", "environment", "db", "nv", "inv", "ie", "dev", "esc", "vp", "window", "erv", "end", "en", "conn", "dn", "err", "viron", "manager", "enter", "iv", "ee", "engine", "enc", "ah", "buf", "eur", "eu", "here", "era", "ve", "eve", "desc", "next", "ent", "esm", "config", "ov", "worker", "sc", "server", "der", "nc", "den", "vm", "eas", "eg", "ei", "ew", "ner", "et", "ec", "erd", "addr", "eng", "outer"]}}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n", "idx": 17700, "substitutes": {"obj": ["tmp", "org", "act", "opt", "object", "bh", "attr", "ref", "pkg", "onet", "xy", "js", "pr", "os", "ot", "cont", "obs", "elt", "att", "inst", "expr", "objects", "resp", "any", "id", "Object", "txt", "ctx", "o", "po", "oj", "cmd", "cod", "nt", "ob", "typ", "og", "t", "Obj", "bo"], "errp": ["erP", "errP", "Erp", "ErP", " errpp", "errpp", " errP", "errr", "erp", "erpp", "Erpp", "err", "Err", " errr"], "pcms": [" pcmm", "pcmes", " laccms", "pacms", "pcmm", "pacmas", "pccms", "micmas", " lacms", "cpmes", "micms", " pcmes", "czmm", "paccms", "pcmn", "czms", "pcmas", " lacmn", " lacmas", "czfs", "cpmm", "pacmn", "cpms", "micmn", "cpfs", "czmes", " pcfs", "pcfs", "miccms"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n", "idx": 17710, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "3dfbdb328ed9e88cebc6462c56cfe61e55850b2e", "target": 0, "func": "static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n\n{\n\n    int v;\n\n    int i = 0;\n\n    uint8_t state[CONTEXT_SIZE];\n\n\n\n    memset(state, 128, sizeof(state));\n\n\n\n    for (v = 0; i < 128; v++) {\n\n        unsigned len = get_symbol(c, state, 0) + 1;\n\n\n\n        if (len > 128 - i)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        while (len--) {\n\n            quant_table[i] = scale * v;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < 128; i++)\n\n        quant_table[256 - i] = -quant_table[i];\n\n    quant_table[128] = -quant_table[127];\n\n\n\n    return 2 * v - 1;\n\n}\n", "idx": 17723, "substitutes": {"c": ["f", "cf", "lc", "cr", "g", "C", "h", "fc", "rc", "abc", "com", "cont", "cp", "sc", "cb", "unc", "u", "tc", "r", "e", "ci", "cu", "ac", "l", "d", "m", "con", "cc", "b", "ct", "xc", "ce", "ec", "cs", "ch", "t", "dc", "p"], "quant_table": ["quant8interface", "private_database", "private_table", "draw_tree", "quant10file", "Quant_file", " quant_cache", "private_interface", "draw_table", "private8table", "draw_interface", "private_tab", "quantitytable", "quant12file", "draw8database", "quantationinterface", "quant_TABLE", "quant10cache", " quant2TABLE", "privateitytable", "privateityinterface", "quant_tab", "quant8database", "quant2buffer", "privateitytab", "quant_manager", "quant8table", "private_filter", "quant12translation", " quant2table", "quantationtable", "quant_buffer", "quant_file", "quant2cache", "quantationdatabase", " quant_TABLE", "private8TABLE", "quant8cache", "quant8tree", " quant2buffer", "quant_interface", "quant_total", "draw8tree", "quantitytotal", " quant_buffer", "quant2table", "Quant_cache", " quant_tab", "quant10table", "private8database", "quantationtree", "draw_database", "quantitymanager", "quant12table", "quant_filter", "quant_cache", " quant_total", "quantitybuffer", "Quant_translation", "Quant_table", "private_buffer", "privateitybuffer", "quantationtab", "quantationbuffer", "private_TABLE", "quant10translation", "quant8buffer", "draw8interface", "quant12cache", "quant_database", "quantityinterface", "quant2TABLE", "quant_tree", " quant2cache", "quant_translation", "private8filter", "quantitytab", "quant8filter", " quant_manager", "quant8TABLE", "draw8table"], "scale": ["unit", "type", "alias", "offset", "fail", "shift", "fee", "seed", "ALE", "draw", "radius", "size", "sc", "order", "error", "sign", "rate", "check", "score", "value", "Scale", " Scale", "grade", "sup", "force", "code", "slice", "ale", "alpha", "axis", "weight", "deg", "cale", "transform", "base", "step", "si"], "v": ["f", "cv", "ach", "sv", "g", "iver", "vv", "vector", "h", "ov", "q", "conv", "version", "y", "ip", "vs", "V", "iv", " V", "pi", "u", "im", "um", "lv", "l", "m", "d", "qv", "value", "vm", "b", "k", "n", "ev", "o", "var", "ve", "ii", "va", "val", "s", "x", "vc", "uv", "nv", "tv", "it", "vt", "w", "av", "at", "vert", "t", "z", "j", "p"], "state": ["new", "type", "length", "block", "config", "cache", "st", "states", "result", "init", "test", "State", "ate", "h", "lock", "STATE", "info", "memory", "size", "seed", "self", "buffer", "q", "store", "pointer", "range", "null", "in", "al", "handle", "scan", "l", "list", "index", "id", "local", "row", "n", "se", "out", "code", "key", "context", "data", "count", "next", "mem", "output", "start", "tag", "cs", "queue", "t", "hash", "name"], "len": ["ls", "sl", "lc", "length", "lan", "fl", "en", "Len", "vec", "h", "kl", "dl", "lf", "size", "le", "nl", "li", "fin", "nn", "elt", "al", "ll", "gl", "pl", "lv", "ell", "lp", "l", "den", "el", "var", "n", "mn", "s", "val", "str", "lon", " l", "data", "full", "coll", "mem", "seq", "ln", "fn", "L", "t", "il", "ld", "z"], "i": ["f", "is", "bi", "gi", "ind", "a", "h", "iter", "xi", "ki", "cli", "ai", "oi", "q", "li", "ic", "ui", "ip", "in", "y", "\u0438", " ii", "pi", "iu", "qi", "u", "im", "e", "ci", "zi", "l", "me", "m", "asi", "index", "id", "ji", "gu", "b", "k", "I", "o", "n", "PI", "ii", "ei", "s", "ti", "fi", "phi", "ix", "x", "di", "uri", "it", "mi", " j", "hi", "ij", "ini", "multi", "z", "j", "si", "p"]}}
{"project": "FFmpeg", "commit_id": "1eb57e1d9b59db0aa63348c21bf3290bd3f5efcb", "target": 0, "func": "static int tb_unreliable(AVCodecContext *c)\n\n{\n\n    if (c->time_base.den >= 101L * c->time_base.num ||\n\n        c->time_base.den <    5L * c->time_base.num ||\n\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n        c->codec_id == AV_CODEC_ID_H264)\n\n        return 1;\n\n    return 0;\n\n}\n", "idx": 17735, "substitutes": {"c": ["f", "cf", "lc", "cv", "cmp", "cr", "g", "cache", "a", "C", "content", "err", "cm", "abc", "fc", "rc", "com", "anc", "mc", "cont", "ic", "cp", "sc", "etc", "gc", "tc", "enc", "e", "cu", "ci", "ac", "pc", "nc", "con", "cc", "b", "v", "ctx", "ct", "n", "cl", "bc", "ce", "desc", "vc", "ec", "cod", "cs", "ch", "comm", "t", "co", "conf", "dc", "p"]}}
{"project": "FFmpeg", "commit_id": "0232f788b6b0855db1771dbf8d7174e2eda2ff45", "target": 1, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n\n\n    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);\n\n    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);\n\n    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);\n\n    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->in_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->out_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;\n\n\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\nav_assert0(s-> in.ch_count);\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n    s->in_buffer= s->in;\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count=\n\n        s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n\n\n\n\n\n    if(s->rematrix)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 17737, "substitutes": {"s": ["us", "is", "as", "states", "fs", "a", "c", "h", "args", "sm", "js", "styles", "y", "ies", "vs", "ims", "v", "has", "tes", "stats", "qs", "less", "ses", "comments", "ers", "als", "bits", "eps", "aws", "sw", "ports", "ss", "serv", "ns", "events", "obj", "spec", "ms", "parts", "sports", "services", "state", "w", "S", "source", "cs", "rates", "conf", "hs", "p", "sts", "rs", "simple", "south", "ops", "os", "set", "pers", "l", "m", "sb", "gs", "gets", "comm", "bs", "ls", "esm", "sv", "ins", "changes", "settings", "params", "sc", "in", "r", "erences", "ats", "ts", "sys", "its", "b", "n", "se", "eds", "tests", "ds", "sam", "ps", "t", "details", "z", "es"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int svq1_decode_init(AVCodecContext *avctx)\n\n{\n\n    MpegEncContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    MPV_decode_defaults(s);\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width+3)&~3;\n\n    s->height = (avctx->height+3)&~3;\n\n    s->codec_id= avctx->codec->id;\n\n    avctx->pix_fmt = PIX_FMT_YUV410P;\n\n    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames\n\n    s->flags= avctx->flags;\n\n    if (MPV_common_init(s) < 0) return -1;\n\n\n\n    init_vlc(&svq1_block_type, 2, 4,\n\n        &svq1_block_type_vlc[0][1], 2, 1,\n\n        &svq1_block_type_vlc[0][0], 2, 1);\n\n\n\n    init_vlc(&svq1_motion_component, 7, 33,\n\n        &mvtab[0][1], 2, 1,\n\n        &mvtab[0][0], 2, 1);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        init_vlc(&svq1_intra_multistage[i], 3, 8,\n\n            &svq1_intra_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_intra_multistage_vlc[i][0][0], 2, 1);\n\n        init_vlc(&svq1_inter_multistage[i], 3, 8,\n\n            &svq1_inter_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_inter_multistage_vlc[i][0][0], 2, 1);\n\n    }\n\n\n\n    init_vlc(&svq1_intra_mean, 8, 256,\n\n        &svq1_intra_mean_vlc[0][1], 4, 2,\n\n        &svq1_intra_mean_vlc[0][0], 4, 2);\n\n\n\n    init_vlc(&svq1_inter_mean, 9, 512,\n\n        &svq1_inter_mean_vlc[0][1], 4, 2,\n\n        &svq1_inter_mean_vlc[0][0], 4, 2);\n\n\n\n    return 0;\n\n}\n", "idx": 17742, "substitutes": {"avctx": ["ajctl", "devtx", "avctl", "avectl", "abcmp", " avcp", "afctl", "abcontext", "ajcam", "averctx", "avcfg", "ajconfig", "ajcontext", "AVcmd", "AVgp", "averkb", "AVtx", "navctx", "afcontext", " avcmp", "avhandle", "avconfig", "avcontext", " avctl", "ajjac", "avecb", "averhandle", "avcp", " avjac", "aycfg", "afconfig", "devctx", "devcmp", "avercv", "avectx", "vrpkg", "vrgp", " avcontext", "averconfig", "afreq", "AVctx", "avcb", "avjac", "navhandle", "avercam", "AVcontext", "avecmd", "avekb", "avcv", "aversys", "abtx", "avehandle", "avcmd", " avcam", "avecp", "absys", "devsys", "ajkb", "abctx", "avsys", "ajcfg", "avecontext", " avtx", "avercontext", "AVcmp", "ajreq", "averjac", "ayjac", "avcmp", "avegp", "avkb", "avgp", " avcfg", "ajcmd", "afctx", "aycmd", "avpkg", " avconfig", "AVpkg", "avtx", "ayctx", "avecmp", "avercmp", "avercb", "navcb", " avcmd", "avecv", "avertx", "aveconfig", "afcp", "vrctx", "ajcv", "ajctx", " avreq", "avepkg", "avreq", "avcam", "vrcmd", "navcv", "afcmp"], "s": ["us", "ls", "is", "sts", "sv", "rs", "g", "ins", "aws", "sw", "c", "sq", "sac", "h", "js", "ports", "os", "ss", "sc", "sg", "ns", "ims", "set", "pers", "ms", "ats", "l", "m", "ts", "d", "its", "conf", "es", "b", "v", "sports", "sb", "uploads", "x", "stats", "ds", "qs", "ses", "less", "aus", "S", "gs", "ows", "cs", "ps", "t", "bs", "comm", "fs", "p"], "i": ["us", "is", "er", "c", "h", "ip", "y", "ami", " ii", "qi", "e", "I", "ii", "print", "phi", " ti", "span", "status", " j", " multi", "hi", "t", " di", " pos", "ui", "\u0438", "pi", "tim", "index", " pi", "mi", "multi", "p", " I", "g", "gi", "ind", "ri", "xi", "ki", "err", "ex", "cli", "ai", "li", "iu", " bi", "ci", "me", "m", "sim", "ti", "x", " x", " m", " si", "ij", "si", "bi", " mi", " index", "info", " v", "ic", "in", "zi", "asi", "ji", "gu", " iter", "ix", "di", " ni", " p", " e", "it", "ini", "j", "oi"]}}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n\n                                     AVStream *st, RMStream *ast, int read_all)\n\n{\n\n    char buf[256];\n\n    uint32_t version;\n\n    int ret;\n\n\n\n    /* ra type header */\n\n    version = avio_rb16(pb); /* version */\n\n    if (version == 3) {\n\n        unsigned bytes_per_minute;\n\n        int header_size = avio_rb16(pb);\n\n        int64_t startpos = avio_tell(pb);\n\n        avio_skip(pb, 8);\n\n        bytes_per_minute = avio_rb16(pb);\n\n        avio_skip(pb, 4);\n\n        rm_read_metadata(s, 0);\n\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n\n            // fourcc (should always be \"lpcJ\")\n\n            avio_r8(pb);\n\n            get_str8(pb, buf, sizeof(buf));\n\n        }\n\n        // Skip extra header crap (this should never happen)\n\n        if ((startpos + header_size) > avio_tell(pb))\n\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n\n        if (bytes_per_minute)\n\n            st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        st->codec->sample_rate = 8000;\n\n        st->codec->channels = 1;\n\n        st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = AV_CODEC_ID_RA_144;\n\n        ast->deint_id = DEINT_ID_INT0;\n\n    } else {\n\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n\n        int codecdata_length;\n\n        unsigned bytes_per_minute;\n\n        /* old version (4) */\n\n        avio_skip(pb, 2); /* unused */\n\n        avio_rb32(pb); /* .ra4 */\n\n        avio_rb32(pb); /* data size */\n\n        avio_rb16(pb); /* version2 */\n\n        avio_rb32(pb); /* header size */\n\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n\n        avio_rb32(pb); /* ??? */\n\n        bytes_per_minute = avio_rb32(pb);\n\n        if (version == 4) {\n\n            if (bytes_per_minute)\n\n                st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        }\n\n        avio_rb32(pb); /* ??? */\n\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n\n        st->codec->block_align= avio_rb16(pb); /* frame size */\n\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n\n        avio_rb16(pb); /* ??? */\n\n        if (version == 5) {\n\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n\n        }\n\n        st->codec->sample_rate = avio_rb16(pb);\n\n        avio_rb32(pb);\n\n        st->codec->channels = avio_rb16(pb);\n\n        if (version == 5) {\n\n            ast->deint_id = avio_rl32(pb);\n\n            avio_read(pb, buf, 4);\n\n            buf[4] = 0;\n\n        } else {\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n            ast->deint_id = AV_RL32(buf);\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n        }\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(buf);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n\n\n        switch (st->codec->codec_id) {\n\n        case AV_CODEC_ID_AC3:\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            break;\n\n        case AV_CODEC_ID_RA_288:\n\n            st->codec->extradata_size= 0;\n\n            ast->audio_framesize = st->codec->block_align;\n\n            st->codec->block_align = coded_framesize;\n\n            break;\n\n        case AV_CODEC_ID_COOK:\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        case AV_CODEC_ID_ATRAC3:\n\n        case AV_CODEC_ID_SIPR:\n\n            if (read_all) {\n\n                codecdata_length = 0;\n\n            } else {\n\n                avio_rb16(pb); avio_r8(pb);\n\n                if (version == 5)\n\n                    avio_r8(pb);\n\n                codecdata_length = avio_rb32(pb);\n\n                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            ast->audio_framesize = st->codec->block_align;\n\n            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {\n\n                if (flavor > 3) {\n\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n\n                           flavor);\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ff_sipr_subpk_size[flavor];\n\n            } else {\n\n                if(sub_packet_size <= 0){\n\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ast->sub_packet_size;\n\n            }\n\n            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0)\n\n                return ret;\n\n\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            avio_rb16(pb); avio_r8(pb);\n\n            if (version == 5)\n\n                avio_r8(pb);\n\n            codecdata_length = avio_rb32(pb);\n\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                return -1;\n\n            }\n\n            if (codecdata_length >= 1) {\n\n                avio_r8(pb);\n\n                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0)\n\n                    return ret;\n\n            }\n\n            break;\n\n        default:\n\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n\n        }\n\n        if (ast->deint_id == DEINT_ID_INT4 ||\n\n            ast->deint_id == DEINT_ID_GENR ||\n\n            ast->deint_id == DEINT_ID_SIPR) {\n\n            if (st->codec->block_align <= 0 ||\n\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n\n                ast->audio_framesize * sub_packet_h < st->codec->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n        switch (ast->deint_id) {\n\n        case DEINT_ID_INT4:\n\n            if (ast->coded_framesize > ast->audio_framesize ||\n\n                sub_packet_h <= 1 ||\n\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_GENR:\n\n            if (ast->sub_packet_size <= 0 ||\n\n                ast->sub_packet_size > ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_SIPR:\n\n        case DEINT_ID_INT0:\n\n        case DEINT_ID_VBRS:\n\n        case DEINT_ID_VBRF:\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown interleaver %X\\n\", ast->deint_id);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (read_all) {\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            rm_read_metadata(s, 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17752, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "as", "a", "c", "sq", "js", "os", "ss", "sc", "vs", "p", "ns", "sd", "spec", "e", "ats", "bs", "ts", "m", "sys", "v", "se", "stats", "ds", "ses", "S", "gs", "cs", "spe", "ps", "t", "sa", "fs", "es"], "pb": ["proc", "nb", "tmp", "tm", "px", "bb", "amp", "cv", "ub", "PB", "pkg", "bj", "peer", "jp", "td", "fb", "mp", "tab", "asm", "cp", "rb", "bp", "xp", "pp", "np", "p", "cb", "gc", "pl", "obj", "tc", "stab", "um", "lp", "pm", "resp", "pc", "lv", "wp", "pt", "ap", "erb", "imp", "ping", "sp", "eb", "b", "ctx", "vm", "pa", "uf", "patch", "bot", "sb", "pg", "lb", "span", "tk", "pro", "msg", "pool", "py", "typ", "ob", "emb", "snap", "dp", "tp", "orp", "vp"], "st": ["rt", "irst", "put", "ost", "th", "sts", "tt", "sv", "sn", "sw", "ste", "std", "nd", "interface", "td", "sta", "store", "fr", "sc", "etc", "must", "ut", "inst", "set", "src", "St", "est", "ts", "pt", "sp", "ST", "se", "ct", "ft", "sty", "str", "et", "storage", "ust", "art", "no", "stop", "nt", "stat", "start", "usr", "mt", "stable", "sh", "rest", "ist"], "ast": ["act", "ost", "tt", "ref", "as", "sw", "asted", "a", "std", "aster", "AST", "af", "sta", "asting", "amd", "ad", "asts", "asm", "ab", "access", "ess", "master", "cast", "ac", "est", "ts", "ma", "acl", "aw", "ar", "md", "an", "mem", "am", "art", "ust", "sam", "stat", "aft", "at", "alert", "mt", "ard", "rest", "ist"], "read_all": ["read___default", "read___only", "read_default", "read___all", "write_all", "write_default", "read___total", "read_total", "write_only", "write_total", "read_only"], "buf": ["text", "tmp", "ff", "cv", "bh", " buffer", "br", "nm", "result", "iter", "wb", "err", "fb", "Buff", "port", "buffer", "cap", "Buffer", "cp", "rb", "bytes", "img", "bag", "cb", "kw", "b", "v", "uf", "out", "sb", "bc", "cmd", "pg", "data", "mem", "seq", "w", "msg", "raw", "buff", "bin", "mb", "font", "p"], "version": ["VER", "type", "length", "usage", "ersion", "final", "major", "ion", "versions", "channel", "interface", "tar", "depth", "stream", "currency", "port", "position", "order", "server", "class", "ver", "driver", "sequence", "section", "vision", "index", "grade", "vers", "v", "mode", "VERSION", "Version", "option", "package", "feature", "direction", "status", "format", "number", "command", "tag", "ception", "vert", "fish", "release", "step"], "ret": ["prop", "final", "result", "valid", "buffer", "conv", "etc", " resp", "Return", "flag", " conv", "resp", "RET", "Ret", "ter", "rev", "num", " compat", "val", "alt", "mem", "vals", "ruby", "response"], "bytes_per_minute": ["bytes_perJframe", "bytes_PER_minute", "bytes_Per_mini", "bytes_Per_min", "bytes_Per_minute", "bytes_per_minimum", "bytes_perThesecond", "bytes_per_frequency", "bytes_PER_second", "bytes_Per_minimum", "bytes_perTheminute", "bytes_Per_second", "bytes_perJsecond", "bytes_perJmin", "bytes_Per_frequency", "bytes_per_mini", "bytes_PER_day", "bytes_per_day", "bytes_Per_frame", "bytes_per_frame", "bytes_perJminute", "bytes_PER_min", "bytes_perThemin", "bytes_per_second", "bytes_per_min", "bytes_perThemini"], "flavor": ["FLaver", "Flavored", " flavored", "flavour", "flactor", " flavour", "favored", " flactor", "factor", "flaver", "favour", "FLavor", "Flavor", "favor", "faver", "flavored", "FLavour", "Flavour", "Flaver", "FLavored", "Flactor"], "sub_packet_h": ["sub_packets_size", "sub_packet_length", "sub_packets_header", "sub_packetctlength", "sub_packets_length", "sub_packets_h", "sub_packetctheader", "sub_packetcth", "sub_packet_header", "sub_packetctsize"], "coded_framesize": ["coded_onesidate", "coded_framize", "coded_imagesize", "coded_fieldsizer", "coded_framale", "coded_imagesizer", "coded_framesIZE", "coded_fieldsize", "coded_fieldsization", "coded_frameiz", "coded_onesize", "coded_codesale", "coded_minsize", "coded_framesizer", "coded_framesidate", "coded_onesizer", "coded_framIZE", "coded_minsidate", "coded_frameize", "coded_framesale", "coded_codesize", "coded_frameIZE", "coded_framsize", "coded_frameale", "coded_frameizer", "coded_framesization", "coded_imagesidate", "coded_codessize", "coded_frameization", "coded_minsicate", "coded_framesicate", "coded_onesicate", "coded_minsizer", "coded_framesiz", "coded_codesIZE", "coded_fieldsiz", "coded_framessize", "coded_imagesicate"], "sub_packet_size": ["sub_packets_size", "sub_packet_len", "sub_packet_length", "sub_packets_name", "sub_packets_length", "sub_packet__size", "sub_packet__name", "sub_packet_name", "sub_packets_len", "sub_packet__len", "sub_packet__length"], "codecdata_length": ["codecextra_length", "codecextra_location", "codecdata_start", "codecdata_location", "codecextra_start", "codecdata_byte", "codecextra_byte"]}}
{"project": "FFmpeg", "commit_id": "c5be6192f0a50eb8a2134c32b7d57f1d88736adf", "target": 1, "func": "int show_license(void *optctx, const char *opt, const char *arg)\n\n{\n\n    printf(\n\n#if CONFIG_NONFREE\n\n    \"This version of %s has nonfree parts compiled in.\\n\"\n\n    \"Therefore it is not legally redistributable.\\n\",\n\n    program_name\n\n#elif CONFIG_GPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_GPL\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 2 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_LGPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU Lesser General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#else\n\n    \"%s is free software; you can redistribute it and/or\\n\"\n\n    \"modify it under the terms of the GNU Lesser General Public\\n\"\n\n    \"License as published by the Free Software Foundation; either\\n\"\n\n    \"version 2.1 of the License, or (at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\"\n\n    \"Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public\\n\"\n\n    \"License along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#endif\n\n    );\n\n\n\n    return 0;\n\n}\n", "idx": 17765, "substitutes": {"optctx": ["optcb", " opttx", "optioncontext", "opcb", "optcontext", "optioncb", "optiontx", "opcontext", "optx", "opttx", "opctx", "optionctx", " optcb", " optcontext"], "opt": ["crit", "prop", "ext", "ref", "init", "tx", "Arg", "lit", "ret", "term", "def", "doc", "obj", "ver", "spec", "pot", "help", "dest", "txt", "var", "oc", "option", "cmd", "Opt", "op"], "arg": ["proc", "reg", "block", "ext", "ax", "ref", "user", "args", "Arg", "use", "ret", "doc", "ig", "event", "spec", "flag", "target", "argument", "call", "param", "var", "cmd", "par", "mem", "msg", "word", "op", "tag"]}}
{"project": "FFmpeg", "commit_id": "62c3c8ca78ee2da7dc20c2d6371866266c82966d", "target": 1, "func": "int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n\n                              int lower_transport, const char *real_challenge)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int rtx = 0, j, i, err, interleave = 0, port_off;\n\n    RTSPStream *rtsp_st;\n\n    RTSPMessageHeader reply1, *reply = &reply1;\n\n    char cmd[2048];\n\n    const char *trans_pref;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        trans_pref = \"x-pn-tng\";\n\n    else\n\n        trans_pref = \"RTP/AVP\";\n\n\n\n    /* default timeout: 1 minute */\n\n    rt->timeout = 60;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n     * RTSP stream */\n\n\n\n    /* Choose a random starting offset within the first half of the\n\n     * port range, to allow for a number of ports to try even if the offset\n\n     * happens to be at the end of the random range. */\n\n    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);\n\n    /* even random offset */\n\n    port_off -= port_off & 0x01;\n\n\n\n    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {\n\n        char transport[2048];\n\n\n\n        /*\n\n         * WMS serves all UDP data over a single connection, the RTX, which\n\n         * isn't necessarily the first in the SDP but has to be the first\n\n         * to be set up, else the second/third SETUP will fail with a 461.\n\n         */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n\n             rt->server_type == RTSP_SERVER_WMS) {\n\n            if (i == 0) {\n\n                /* rtx first */\n\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n\n                    if (len >= 4 &&\n\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n\n                                \"/rtx\"))\n\n                        break;\n\n                }\n\n                if (rtx == rt->nb_rtsp_streams)\n\n                    return -1; /* no RTX found */\n\n                rtsp_st = rt->rtsp_streams[rtx];\n\n            } else\n\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n\n        } else\n\n            rtsp_st = rt->rtsp_streams[i];\n\n\n\n        /* RTP/UDP */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n\n            char buf[256];\n\n\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n\n                port = reply->transports[0].client_port_min;\n\n                goto have_port;\n\n            }\n\n\n\n            /* first try in specified port range */\n\n            while (j <= rt->rtp_port_max) {\n\n                ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n\n                            \"?localport=%d\", j);\n\n                /* we will use two ports per rtp stream (rtp and rtcp) */\n\n                j += 2;\n\n                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,\n\n                               &s->interrupt_callback, NULL))\n\n                    goto rtp_opened;\n\n            }\n\n\n\n            av_log(s, AV_LOG_ERROR, \"Unable to open an input RTP port\\n\");\n\n            err = AVERROR(EIO);\n\n            goto fail;\n\n\n\n        rtp_opened:\n\n            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n\n        have_port:\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;\", trans_pref);\n\n            if (rt->server_type != RTSP_SERVER_REAL)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                     \"client_port=%d\", port);\n\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n            /* For WMS streams, the application streams are only used for\n\n             * UDP. When trying to set it up for TCP streams, the server\n\n             * will return an error. Therefore, we skip those streams. */\n\n            if (rt->server_type == RTSP_SERVER_WMS &&\n\n                (rtsp_st->stream_index < 0 ||\n\n                 s->streams[rtsp_st->stream_index]->codec->codec_type ==\n\n                    AVMEDIA_TYPE_DATA))\n\n                continue;\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/TCP;\", trans_pref);\n\n            if (rt->transport != RTSP_TRANSPORT_RDT)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                        \"interleaved=%d-%d\",\n\n                        interleave, interleave + 1);\n\n            interleave += 2;\n\n        }\n\n\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;multicast\", trans_pref);\n\n        }\n\n        if (s->oformat) {\n\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n\n                   rt->server_type == RTSP_SERVER_WMS)\n\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n\n        snprintf(cmd, sizeof(cmd),\n\n                 \"Transport: %s\\r\\n\",\n\n                 transport);\n\n        if (rt->accept_dynamic_rate)\n\n            av_strlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd));\n\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n\n            char real_res[41], real_csum[9];\n\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n\n                                              real_challenge);\n\n            av_strlcatf(cmd, sizeof(cmd),\n\n                        \"If-Match: %s\\r\\n\"\n\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n\n                        rt->session_id, real_res, real_csum);\n\n        }\n\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n\n            err = 1;\n\n            goto fail;\n\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n\n                   reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n\n                reply->transports[0].transport != rt->transport) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->lower_transport = reply->transports[0].lower_transport;\n\n            rt->transport = reply->transports[0].transport;\n\n        }\n\n\n\n        /* Fail if the server responded with another lower transport mode\n\n         * than what we requested. */\n\n        if (reply->transports[0].lower_transport != lower_transport) {\n\n            av_log(s, AV_LOG_ERROR, \"Nonmatching transport in server reply\\n\");\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        switch(reply->transports[0].lower_transport) {\n\n        case RTSP_LOWER_TRANSPORT_TCP:\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n\n            char url[1024], options[30] = \"\";\n\n\n\n            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)\n\n                av_strlcpy(options, \"?connect=1\", sizeof(options));\n\n            /* Use source address if specified */\n\n            if (reply->transports[0].source[0]) {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n\n                            reply->transports[0].source,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            } else {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            }\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n\n                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            /* Try to initialize the connection state in a\n\n             * potential NAT router by sending dummy packets.\n\n             * RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n", "idx": 17766, "substitutes": {"s": ["is", "sl", "sts", "sv", "rs", "st", "sec", "a", "c", "tx", "sq", "h", "js", "os", "ss", "ns", "spec", "set", "r", "e", "ts", "sys", "b", "v", "n", "se", "sb", "ds", "ses", "S", "gs", "sa", "ps", "t", "hs", "p"], "host": ["hook", "bind", "header", "nick", "conn", "hop", "connection", "peer", "h", "origin", "Host", "server", "ip", "target", "handle", "address", "query", "localhost", "path", "client", "subject", "owner", "link", "controller", "mac", "domain", "node"], "port": ["type", "page", "channel", "point", "gp", "stream", "pport", "ports", "ile", "porter", "cp", "server", "ip", "pp", "address", "ort", "pn", "client", "ocol", "rot", "file", "format", "Port", "eport", "ptr", "PORT", "p"], "lower_transport": ["lower_transflow", "lower2ransport", "lower_TransPort", "lower_ransports", "lower2ransports", "lower_taskband", "lower_transdrop", "lower_ransband", "lower_telePort", "lower_transports", "lower_transband", "lower_ransocol", "lower_portband", "lower_taskpport", "lower_transocol", "lower_telepport", "lower2ransPort", "lower2transports", "lower_ransPort", "lower_teleflow", "lower_taskflow", "lower_transPort", "lower_Transport", "lower_ransport", "lower_ransdrop", "lower_transpport", "lower2transPort", "lower_taskport", "lower_Transports", "lower_Transocol", "lower2transport", "lower_teleocol", "lower_teleport", "lower2ransocol", "lower_taskdrop", "lower_portport", "lower_portpport", "lower_teleband", "lower2transocol", "lower_ransflow", "lower_ranspport", "lower_portdrop", "lower_teleports"], "real_challenge": ["real_replenges", "real_replenge", "real_Challenges", "real_messenge", "real_challue", "real_messenges", "real_challchange", "real_messue", "real_replchange", "real_Challchange", "real_replue", "real_Challenge", "real_messchange", "real_challenges", "real_Challue"], "rt": ["rid", "tmp", "tm", "opt", "reg", "ht", "NT", "tt", "rs", "gt", "rf", "pkg", "hw", "apt", "hd", "ind", "vr", "tx", "lt", "nd", "lat", "rh", "rx", "rc", "rl", "ret", "ot", "dt", "fr", "ro", "rb", "res", "etc", "RT", "elt", "qt", "kt", "rr", "obj", "qq", "feat", "r", "rw", "rect", "ort", "sys", "irt", "rec", "ack", "txt", "ctx", "ct", "rot", "et", "vc", "req", "bt", "yt", "ant", "art", "dr", "vt", "it", "nt", "ssl", "rm", "rin", "ptr", "t", "mt", "rd", "wt", "rn", "tp"], "j": ["job", "jl", "jump", "J", "g", "bi", "ja", "bj", "jp", "h", "js", "json", "q", "ot", "li", "fr", "y", "jj", "pi", "aj", "r", "l", "ort", "m", "ji", "b", "v", "k", "n", "dj", "o", "uj", "x", "it", "ij", "t", "z", "p"], "i": ["iri", "bi", "gi", "ind", "ir", "jp", "ri", "xi", "ki", "ai", "ia", "oi", "li", "ui", "ic", "y", "ip", "io", "iat", "in", "jj", "ims", "pi", "iu", "qi", "u", "ni", "im", "iii", "zi", "ci", "r", "ami", "l", "m", "index", "id", "ji", "b", "v", "I", "n", "o", "ii", "ti", "ei", "phi", "ix", "x", "di", "it", "mi", "hi", "ij", "t", "ini", "multi", "si", "p"], "err": ["lr", "hr", "er", "ind", "init", "test", "iter", "fr", "error", "res", "elt", "cb", "rr", "arr", "progress", "txt", "gz", "aaa", "ei", "str", "lex", "req", "dr", "msg", "ch", "ptr", "rn"], "port_off": ["Port_on", " port_offs", " port_pos", "Port_Off", " port_block", "port_offset", "port_Off", "port2Off", "Port_offset", " port_offset", "port_on", "port_of", "PORT_on", " port_Off", "port_pos", "port2ex", "PORT_of", "port_block", "PORT_off", " port_OFF", "Port_off", "port_OFF", "port_offs", "Port_ex", "port2off", "port_ex", "PORT_OFF", "port2on"], "rtsp_st": ["rtsp_str", "rtsp___stack", "rtsping_ste", "rtsvp_stream", "rtspi_st", "rtspe_sty", "rtsp___ste", "rtspe_ste", "rtsvp_st", "rtsping_st", "rtsping_stack", "rtsping___stream", "rtsp__st", "rtsping_stream", "rtsp_ist", "rtsp___st", "rtspe_st", "rtsp__ost", "rtsp_stat", "rtspi_stat", "rtsping___st", "rtspi_ist", "rtsping___ste", "rtsp_stack", "rtsp_sty", "rtsping___stack", "rtsp___stream", "rtsp__stream", "rtspe_str", "rtsp_ste", "rtsp_stream", "rtsvp_ost", "rtsp_ost", "rtspi_stack"], "reply1": ["response_", "reply2", "answer1", "reply0", " reply0", "Reply1", " reply_", "response2", "response0", "answer2", "Reply2", "response1", "reply_", " reply2", "answer0", "answer_", "Reply0"], "reply": ["header", "response", "part", "reason", "report", "pipe", "ret", "ignore", "Reply", "rr", "match", "resp", "query", "request", "prefix", "notice", "replace", "link", "frame", "ply", "command", "try", "answer", "transfer", "repair", "rep", "repl"], "cmd": ["box", "bind", "ctr", "init", "Cmd", "params", "cp", "ip", "critical", "cb", "handle", "cast", "ctx", " command", "force", "Conn", "mode", "send", "control", "desc", "req", "auth", "msg", "op", "command", "comm", " auth", "batch"], "trans_pref": ["trans_prefer", "trans_prep", "trans_preference", "trans_prefixv", "trans_prifer", "trans_prov", "trans_prev", "trans_PREc", "trans_prefixp", "trans_prof", "trans_presfer", "trans_presc", "trans_priference", "trans_prip", "trans_prfer", "trans_prefixf", "trans_prefixc", "trans_prif", "trans_pric", "trans_profer", "trans_PREference", "trans_prefixfer", "trans_prv", "trans_prefixference", "trans_presf", "trans_proference", "trans_prec", "trans_prf", "trans_prference", "trans_PREp", "trans_presference", "trans_PREf"], "transport": ["serport", "teleports", "telepport", "ransports", "ranscmd", "ranscommand", "transfield", "transcmd", "Transcmd", "Transfield", "transocol", "transcommand", "switchfield", "switchport", "serpport", "ranspport", "transpport", "ransport", "teleocol", "switchcmd", "switchcommand", "serports", "transports", "Transport", "teleport", "Transcommand", "ransocol", "ransfield", "serocol"], "rtx": ["rxt", "rrxx", "ytox", "rrox", "btxt", "rtj", "ntxe", "prx", "btx", "prix", "catrx", "tdx", "trxf", "wtx", "catxi", "wtlex", "rrxt", "rox", "ttxi", "rwi", "htrx", "htxi", "tdux", "retxe", "rtxe", "rtxt", "rtxx", "lati", "rx", "catdx", "trux", "ttix", "txv", "rty", "prxx", "htdx", "retv", "ytxx", "latox", "prox", "tdox", "rdix", "irtx", "rtxf", "rtlex", "ttrx", "htx", "catx", "latX", "btox", "rdrox", "ntv", "rti", "txix", "rtX", "rdx", "gtx", "ttox", "latx", "maty", "wtxx", "matux", "ytx", "rdy", "trox", "rtv", "rdux", "latux", "ntx", "rtdx", "tti", "irtxi", "ttj", "btxi", "txdx", "retx", "rtrx", "txrox", "rwx", "matx", "gtix", "rxi", "rtox", "gtox", "rtxi", "retdx", "matX", "rdlex", "ttx", "ytxt", "irtxt", "ntdx", "ttdx", "rrx", "latix", "rwix", "rtrox", "rwj", "txlex", "gtxx", "ttxx", "wtix", "rtix", "wtox", "trx", "rdX", "wtrox", "txxe", "irtox", "latj", "txx", "tdxf", "laty", "rtux", "ttxt", "latxf"], "buf": ["proc", "window", "block", "box", "ctr", "map", "buffer", "cap", "Buffer", "conv", "cb", "cast", "off", "var", "uf", "code", "alloc", "data", "mem", "pool", "bin", "buff", "pack", "ptr", "comm"]}}
{"project": "FFmpeg", "commit_id": "24130234cd9dd733116d17b724ea4c8e12ce097a", "target": 0, "func": "static int parse_fmtp(AVFormatContext *s,\n\n                      AVStream *stream, PayloadContext *data,\n\n                      const char *attr, const char *value)\n\n{\n\n    AVCodecParameters *par = stream->codecpar;\n\n    int res, i;\n\n\n\n    if (!strcmp(attr, \"config\")) {\n\n        res = parse_fmtp_config(par, value);\n\n\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (par->codec_id == AV_CODEC_ID_AAC) {\n\n        /* Looking for a known attribute */\n\n        for (i = 0; attr_names[i].str; ++i) {\n\n            if (!av_strcasecmp(attr, attr_names[i].str)) {\n\n                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {\n\n                    *(int *)((char *)data+\n\n                        attr_names[i].offset) = atoi(value);\n\n                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)\n\n                    *(char **)((char *)data+\n\n                        attr_names[i].offset) = av_strdup(value);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17786, "substitutes": {"s": ["f", "is", "sv", "rs", "sw", "a", "c", "sq", "h", "os", "sc", "spec", "e", "ats", "d", "m", "v", "n", "se", "ar", "x", "ds", "w", "cs", "ps", "t", "p"], "stream": ["sl", "window", "length", "rend", "st", "chain", "sw", "trans", "Stream", "spect", "content", "shape", "store", "serv", "sc", "conv", "util", "read", "event", "spec", "src", "form", "message", "path", "ack", "v", "stack", "console", "context", "instance", "str", "ream", "desc", "ec", "transform", "view", "pool", "ssl", "response", "metadata"], "data": ["new", "text", "done", "extra", "length", "reg", "window", "action", "cache", "result", "trans", "map", "reason", "tx", "content", "info", "size", "buffer", "ata", "device", "obj", "mu", "dat", "da", "form", "table", "buf", "message", "this", "d", "zero", "rec", "DATA", "ctx", "Data", "context", "val", "str", "mem", "encrypted", "image", "addr", "dev", "partial", "name", "batch"], "attr": ["rt", "prop", "tmp", "type", "reg", "act", "br", "rs", "apt", "vr", "err", "pr", "urg", "fr", "attribute", "acc", "tr", "aff", "elt", "rr", "unc", "att", "arg", "r", "rel", "arr", "ack", "txt", "var", "key", "spr", "str", "cmd", "prefix", "atts", "desc", "req", "adv", "perm", "msg", "typ", "op", "tag", "addr", "adj", "cmp", "p"], "value": ["unit", "text", "type", "label", "block", "config", "result", "VALUE", "test", "content", "property", "widget", "size", "values", "buffer", "params", "attribute", "version", "expression", "buf", "message", "now", "Value", "index", "b", "v", "vp", "key", "comment", "context", "val", "description", "output", "format", "raw", "tag", "field", "conf", "variable", "name", "p"], "par": ["proc", "parse", "rs", "PAR", "pkg", "prep", "jp", "pre", "tar", "rem", "mp", "per", "Par", "params", "serv", "cp", "pas", "pp", "rel", "pers", "arr", "gr", "pol", "sys", "sp", "rec", "ctx", "var", "pa", "car", "param", "pres", "kar", "ar", "ran", "pair", "pro", "dr", "arp", "pri", "ps", "cmp", "conf", "tp", "p"], "res": ["resource", "ber", "reg", "sum", "rs", "result", "err", "Res", "js", "rem", "RES", "ret", "cons", "os", "resources", " RES", "der", "re", "rel", "r", "max", "resp", "ms", "vol", "gr", "pers", "yes", "out", "pres", "reset", "val", "sol", "req", "vals", "resolution", "results", "ress", "cs", " Res", "ons", "ps", "bs", "conf", "details", "rest", "red"], "i": ["them", "f", "is", "ik", "g", "bi", "gi", "ind", "init", "ir", "chain", "c", "h", "ri", "xi", "cli", "info", "ai", "oi", "batch", "ic", "li", "ui", "ip", "y", "io", "\u0438", "ims", "pi", "iu", "qi", "u", "gl", "im", "zi", "ci", "sim", "m", "me", "id", "index", "ji", "v", "I", "n", "o", "sql", "ii", "ti", "ei", "phi", "ix", "x", "status", "di", "uri", "it", "mi", "hi", "try", "ij", "iq", "ini", "multi", "yi", "z", "j", "si", "p"]}}
{"project": "FFmpeg", "commit_id": "4c8ca76965b1c29758246624940cbc529e7141f0", "target": 0, "func": "static int ffserver_set_int_param(int *dest, const char *value, int factor,\n\n                                  int min, int max, FFServerConfig *config,\n\n                                  const char *error_msg, ...)\n\n{\n\n    int tmp;\n\n    char *tailp;\n\n    if (!value || !value[0])\n\n        goto error;\n\n    errno = 0;\n\n    tmp = strtol(value, &tailp, 0);\n\n    if (tmp < min || tmp > max)\n\n        goto error;\n\n    if (factor) {\n\n        if (FFABS(tmp) > INT_MAX / FFABS(factor))\n\n            goto error;\n\n        tmp *= factor;\n\n    }\n\n    if (tailp[0] || errno)\n\n        goto error;\n\n    if (dest)\n\n        *dest = tmp;\n\n    return 0;\n\n  error:\n\n    if (config) {\n\n        va_list vl;\n\n        va_start(vl, error_msg);\n\n        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, error_msg, vl);\n\n        va_end(vl);\n\n    }\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 17787, "substitutes": {"dest": ["Dest", "to", "window", "prop", "opt", "coord", "end", "st", "result", "trans", "important", "decl", "iter", "temp", "err", "origin", "port", "slave", "cont", "del", "etc", "obj", "dist", "loc", "orig", "target", "src", "spec", "dat", "buf", "est", "d", "num", "index", "sp", "v", "out", "desc", "seek", "tif", "source", "start", "usr", "ptr", "addr", "dev", "ident", "comb", "nom", "rest", "name"], "value": ["unit", "text", "type", "initial", "array", "vector", "VALUE", "test", "content", "property", "valid", "values", "buffer", "scale", "server", "version", "attribute", "null", "select", "set", "address", "expression", "message", "ter", "Value", "index", "v", "code", "ty", "key", "change", "val", "data", "format", "save", "image", "source", "start", "input", "field", "variable", "name", "p"], "factor": ["prime", "lr", "fd", "f", "unit", "offset", "rf", "second", "part", "mult", "multipl", "fac", "currency", "product", "term", "or", "size", "tier", "per", "scale", " factors", "frac", "amount", "power", "actor", "rate", " Factor", "force", "mode", "area", "operator", "alpha", "beta", "fact", "Factor", "timer", "token", "tor", "xf", "comb", "font", "half", "t", "step"], "min": ["minimum", "from", "Min", "pre", "lt", "mini", "diff", "len", "version", "in", "amin", "sub", "loc", "small", "mins", "m", "v", "param", "Minimum", "minute", "MIN", "mn", "mean", "val", "lower", "span", "mi", "base", "start", "lo", "mod", "range", "p"], "max": ["prime", "ext", "end", "ax", "gt", "final", "wrap", "mx", " MAX", "c", "ca", "ex", "flow", "size", "pr", "MAX", "cap", "scale", "master", "Max", "m", "ma", "v", "n", "out", "maximum", "wh", "x", "last", "w", "current", "base", "dev", "med", "t", "mod", "range", "p"], "config": ["component", "cf", "cache", "conn", "connection", "Config", "chain", "sec", "init", "c", "fig", "channel", "interface", "settings", "fc", "rc", "ogg", "abc", "service", "com", "unknown", "cont", "setup", "sc", "scale", "attribute", "etc", "spec", "driver", "remote", "address", "check", "commit", "list", "con", "complex", "client", "subject", "txt", "ctx", "param", "ct", "secure", "gate", "bc", "state", "apache", "FIG", "operator", "cmd", "control", "gov", "cand", "data", "file", "desc", "storage", "communication", "capt", "format", "exec", "msg", "figure", "command", "process", "account", "adj", "comm", "t", "conf", "cfg"], "error_msg": ["debug_msg", "ror_Msg", "error___md", "error_mess", "error_mg", "ror_message", "debug_mag", "ror_msg", "error___message", "error_mag", " error_mag", "error_message", "error___Msg", "debug_mg", "error_md", "error___msg", "error_Msg", " error_Msg", " error_mess", "debug_cfg", "ror_md", "error_cfg"], "tmp": ["prop", "cv", "mut", " mk", "cache", "tar", "etc", "np", " dst", " mp", "ctx", "var", " sp", "mk", "uv", " temp", " quot", "verb", "buff", "mb", "snap", "cmp", " np", "tp", "sup", "nb", "offset", "test", "temp", "clip", "Temp", "ot", "cont", "cp", " src", "pos", "obj", "src", "expr", " old", " ta", "msg", "nt", "partial", "p", "prime", "tm", "sum", "pkg", "ind", "tg", "sq", "term", "elt", "loc", " t", "orig", "tc", "resp", "tf", "sp", "txt", "aaa", " tid", "prefix", "cur", "vt", " ptr", "ptr", "rt", "attr", "tt", "emp", "tn", "jp", "fac", "copy", "td", "mp", " resp", "img", "stuff", " pts", " amp", " prev", " temporary", "perm", "t", "nom", "timeout"], "tailp": ["lengthp", " Tailp", "ailps", "tailps", " tailps", "gestpa", "gypa", " tailpb", "gestP", "gestpb", "gypb", "tailP", " Tailjp", "gyp", "tailpb", "tailjp", " tailjp", " TailP", "gyP", "ailP", " tailP", "tailpa", "lengthps", "ailjp", "lengthP", "ailp", " tailpa", "gestp"], "vl": ["ele", " ml", "sl", "fl", "ls", "tle", "lan", "tl", "sv", " li", "vv", "vr", "lvl", "kl", "ipl", "dl", "rl", "nl", "ml", "iv", "VL", "ll", "isl", "pl", "lv", "ul", "vol", "l", "qv", "itle", "vet", "ava", "vel", "vi", "v", "ibl", "wl", "ev", "vid", "abl", "ve", "acl", "vc", "pel", "uv", "aval", "ln", "vo", "bol", "lic", "ival", " pl", " lvl", "ptr", " sl", "vp"]}}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n\n{\n\n    unsigned int tag;\n\n    int64_t size;\n\n\n\n    for (;;) {\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n        size = next_tag(pb, &tag);\n\n        if (tag == tag1)\n\n            break;\n\n        wav_seek_tag(pb, size, SEEK_CUR);\n\n    }\n\n    return size;\n\n}\n", "idx": 17792, "substitutes": {"pb": ["px", "bb", "cv", "ub", "PB", "pkg", "bj", "fp", "jp", "wb", "fb", "mp", "ab", "cp", "rb", "bp", "pp", "np", "p", "pread", "cb", "gc", "tc", "ib", "lp", "buf", "pc", "wp", "pt", "eb", "b", "pa", "uf", "xb", "sb", "bc", "obb", "gb", "pg", "lb", "tk", "aus", "emb", "bs", "tp", "vp"], "tag1": ["TAG0", "tagOne", "Tag0", " tag0", "TagOne", "Tag2", "Tag1", "ag1", "TAG2", "ag2", "tag2", " tagOne", "agOne", "TAG1", " tag2", "TAGOne", "tag0"], "tag": ["type", "sum", "Tag", "length", "offset", "reg", "tg", "cat", "tar", "ag", "tail", "style", "TAG", "len", "attribute", "pos", "ig", " event", " match", "event", "bug", " TAG", "match", " flag", "feat", " error", "message", "date", "id", "ping", "ack", "var", "code", " Tag", "key", "comment", "task", "next", "pair", "status", "format", "msg", "word", "stat", "token", "pack", "t", "field", "qual", "name", "p"], "size": ["length", "sum", "zone", "type", "ose", "offset", "end", "rank", "g", "fee", "speed", "port", "shape", "buffer", "position", "SIZE", "scale", "dim", "len", "ize", "pos", "large", "loc", "set", "max", "message", "small", "now", "num", "index", "summary", "sp", "v", "n", "time", "code", "space", "send", "Size", "s", "slice", "capacity", "count", "span", "status", "number", "msg", "needed", "start", "loss", "dimension", "t", "z", "name"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_6REGS && HAVE_INLINE_ASM\n\n    if (INLINE_AMD3DNOWEXT(cpu_flags)) {\n\n        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;\n\n    }\n\n    if (INLINE_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul_window = vector_fmul_window_sse;\n\n    }\n\n#endif\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_sse;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;\n\n        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;\n\n        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;\n\n        fdsp->butterflies_float   = ff_butterflies_float_sse;\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_avx;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_avx;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;\n\n    }\n\n}\n", "idx": 17803, "substitutes": {"fdsp": ["FDserv", "formservice", "fedsp", "dlSP", "formse", "fredspe", "formsp", "dfservice", "designpt", "iddse", "finsp", "dfns", "fdsync", "vdpp", "fdpl", "fmpt", "gdservice", "fdsm", "fredstr", "condsm", "ondsp", "fdtp", "dfpt", "fmsw", "finsw", "FDtp", "iddsync", "FDsp", "erdscope", "dfip", "ldspace", "ftss", "vdSP", "iddserv", "rodsp", "fedspace", "gdsp", "fmsp", "iddsp", "fcsync", "ondsc", "dfsw", "dlsp", "fcpl", "dnspe", "ftip", "dfsync", "fcpy", "fcsp", "fcns", "fdSP", "fdpage", "fredservice", "fdblock", "fredsw", "fredpl", "dlsc", "fredset", "fredsync", "fredns", "fcsw", "ftsp", "fdss", "fcspe", "gdsync", "fredss", "rodservice", "fredsp", "fredip", "fredblock", "fdspe", "finspace", "condservice", "ondspe", "fdserv", "condsp", "dfpp", "vdsp", "ondset", "ftstr", "montserv", "designsp", "dfpy", "designsync", "iddservice", "dfpl", "ffns", "dftp", "ffsp", "formstr", "fdip", "dfsp", "ondblock", "dfse", "erdservice", "ldserv", "ffspace", "ldtp", "dlpp", "FDspace", "dfSP", "fdscope", "montservice", "vdsc", "fdsc", "rodstr", "dfstr", "fingp", "dfss", "ondspace", "fdns", "condns", "gdserv", "dfset", "fdservice", "dfsc", "dnsc", "fcip", "fedsw", "dnspace", "erdsp", "fdgp", "ldsp", "fdpy", "ffservice", "fdstr", "montsp", "fcsm", "erdstr", "dnsp", "dfspe", "designss", "dfsm", "dfblock", "iddstr", "montpt", "dfspace", "fdse", "fcpt", "ffsync", "fredpage", "ondservice", "fdpt", "dfgp", "rodscope", "fdsw", "montsync", "fredserv", "fcservice", "dfpage", "ffpage", "fedgp", "ffserv", "montss", "ffspe", "fdpp", "fredpy", "fmpy", "ffsc", "fdset", "dfserv", "dfscope", "fdspace"]}}
{"project": "qemu", "commit_id": "096685fc2a955ea17d5363ab452e301be2b43873", "target": 1, "func": "static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n\n\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* INTC_REVISION */\n\n        return s->revision;\n\n\n\n    case 0x10:\t/* INTC_SYSCONFIG */\n\n        return (s->autoidle >> 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}", "idx": 17805, "substitutes": {"opaque": ["opent", "oppacity", "paque", " opatile", "opatile", "opacity", "oppatile", "OPaque", "OPcache", "oplaque", "oplac", " opaques", "oppent", "OPac", "OPaques", "patile", " opac", " opacity", "pacity", "opcache", " opcache", "oppaque", " opent", "pent", "opac", "oplaques", "opaques", "oplcache"], "addr": ["url", "pad", "arch", "coord", "offset", "ref", "location", "map", "rc", "i", "asm", "ad", "store", "order", "len", "res", "pos", "kt", "loc", "align", "src", "address", "r", "Address", "work", "dh", "aro", "off", "ord", "var", "gate", "inter", "alloc", "ix", "prefix", "seek", "bound", "adr", "at", "ptr", "mt", "start", "hash", "add", "arp"], "size": ["pad", "length", "type", "offset", "fee", "args", "SIZE", "len", "ize", "align", "set", "e", "address", "message", "num", "sp", "n", "area", "Size", "send", "weight", "data", "count", "mem", "start", "z", "name"], "s": ["is", "er", "ubs", "states", "a", "h", "ed", "js", "asm", "store", "ies", "ances", "v", "utils", "ches", "stats", "storage", "qs", "less", "span", "ers", "als", "ments", "bes", "outs", "aws", "parser", "ports", "ants", "ss", "serv", "grades", "ns", "ings", "soc", "spec", "session", "ms", "actions", "sports", "ations", "services", "ashes", "ays", "S", "rates", "hs", "p", "sl", "ges", "sts", "ains", "g", "rs", "south", "sq", "service", "resses", "os", "conv", "ands", "l", "m", "locks", "sp", "sb", "ing", "gs", "ssl", "ists", "sa", "comm", "bs", "ls", "sv", "changes", "ions", "browser", "scripts", "r", "erences", "ats", "ts", "sys", "its", "b", "n", "eds", "app", "iffs", "ds", "sam", "ps", "t", "fs", "flows", "es"], "bank_no": ["bank_po", "bank_n", "brain_yes", "bank_num", "ank_na", "brain_by", "ank_nos", "ank_number", " bank_index", "bank_yes", "bank_index", "bank08by", " bank_yes", "board_eno", "bank_value", " bank_number", "brain_value", "ank_0", "bank_name", " bank_n", "board_na", " bank_name", "ank_no", "board_no", "ank_eno", "bank_eno", "brain_no", "bank_number", " bank_No", "bank_na", "bank_by", "board_po", " bank_num", "bank08value", "ank_yes", "bank_nos", "bank08yes", "bank_No", "bank_0", "bank08no"], "line_no": ["LINE_ne", "line_NO", "line_spec", "line_ko", " line_No", " line_spec", "line2num", "block_num", "LINE_len", "block_number", "line_num", "line_len", "line_ne", "point_no", "line2name", " line_go", "line2no", "point_num", "LINE_no", "LINE_NO", "point_name", "line_No", "line_number", "point_NO", "block_no", "line_name", "line2NO", "block_ko", "line_go"], "bank": ["author", "library", "bb", "block", "cache", "er", "bush", "zer", " banks", "agency", "bag", "pb", "table", "query", "scan", "v", "var", "script", "Bank", "ank", "bang", "storage", "node", "field", "gem", "bridge", "alias", "jam", "parser", "ANK", "vote", "root", "rb", "black", "session", "ram", "leaf", "back", "comment", "package", "option", "db", "an", "tag", "account", "process", "dev", "conf", "p", "bay", "disk", "cell", "country", "ban", "service", "buffer", "ab", "go", "journal", "buf", "pod", "sp", "ack", "book", "sb", "instance", "file", "lang", "ang", "view", "fork", "ob", "batch", "type", "jump", "rank", "plugin", "flow", "board", "browser", "acc", "band", "import", "bid", "b", "rule", "slice", "lib", "sam", "bin", "base", "pack", "ger", "banks", "bet", "volume"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n", "idx": 17807, "substitutes": {"s": ["ls", "is", "sts", "ains", "sv", "rs", "as", "ins", "aws", "sw", "changes", "south", "states", "c", "h", "sq", "ops", "eps", "aunts", "ex", "js", "os", "params", "ss", "ies", "sg", "vs", "details", "ns", "ims", "spec", "set", "ms", "ats", "bs", "ts", "m", "sys", "es", "v", "se", "parts", "bis", "sports", "sb", "stats", "ds", "qs", "ses", "less", "http", "S", "comments", "gs", "cs", "ps", "t", "comm", "als", "fs", "hs", "p"], "range": ["resource", "length", "block", "offset", "random", "ref", "filter", "array", "chain", "route", "ge", "valid", "size", "mask", "radius", "ANGE", "q", "panel", "scale", "diff", "error", "res", "repeat", "Range", "align", "set", "max", "r", "remote", "spread", "ange", "rang", "rad", "scan", "call", "conf", "broad", "force", "lag", "angle", "slice", "axis", "trace", "lim", "feature", "resolution", "view", "bound", "domain", "limit", "scope", "release"], "xmin": ["ixstart", "ipos", "rxmin", "exmin", "xman", "axstart", "xfrom", "ixfrom", "exmax", "xstart", "ixmin", "axpos", "oxfrom", "imin", "mxman", "exbegin", "exonly", "mxmax", "rxonly", "ixmod", "oxmax", "ixbegin", "oxman", "xbegin", "istart", "axmod", "imod", "mxmin", "xonly", "ixpos", "ixman", "ixonly", "mxfrom", "ixmax", "xpos", "rxbegin", "rxmax", "axmin", "xmod", "oxmin"], "ymin": ["symin", "mmin", " yman", "mmax", "sypart", "nymin", "cyprev", "cymin", "ystart", "cypart", "nystart", "cystart", "ymman", "cyside", "xside", "symax", "nyside", "syside", "ymmax", "yprev", "syprev", "ymmon", "mman", "yside", "systart", " ymon", "ymmin", "yman", "ypart", "ymon", "mmon", "xprev", "nypart", "cymax"], "xmax": ["oxax", "ixlimit", "ixax", "rxmin", "exmin", "xend", "exend", "xref", "axtotal", "rxax", "ixref", "exlimit", "exmax", "ixmin", "exax", "Xmin", "exref", "ixtotal", "rxref", "yMAX", "axmax", "xax", "xMAX", "oxend", "oxmax", "xlimit", "rxend", "Xmax", "yax", "Xax", "ixmax", "rxmax", "exMAX", "XMAX", "extotal", "axlimit", "oxmin", "axax", "xtotal"], "ymax": ["pmatch", "iamain", "ymale", "ymaz", "iamin", "dmmax", "dmale", "ythux", "ymaja", "hemaja", "iamac", "ypux", "ymac", "ymain", "esmux", "ymux", "ymatch", "ythake", "ypin", "ypain", "ypmax", "pmmax", "dmaja", "esmax", "dmax", "esmajor", "symax", "ythajor", "ymmain", "ymajor", "symaja", "iamax", "ymmax", "ymake", "hemax", "ymmac", "ythax", "esmake", "symmax", "ypac", "ypake", "ypajor", "ypatch", "ymmin", "pmax", "hemmax", "ypaz", "hemale", "dmatch", "dmaz", "symale", "ypax", "pmaz"], "f_code": ["tf_code", "f_Code", "tf_value", "tf_flag", "f8Code", "f_value", " f_Code", "f_error", " f_error", "f8error", "f8code", "f_flag"]}}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "static int device_try_init(AVFormatContext *ctx,\n\n                           enum AVPixelFormat pix_fmt,\n\n                           int *width,\n\n                           int *height,\n\n                           uint32_t *desired_format,\n\n                           enum AVCodecID *codec_id)\n\n{\n\n    int ret, i;\n\n\n\n    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);\n\n\n\n    if (*desired_format) {\n\n        ret = device_init(ctx, width, height, *desired_format);\n\n        if (ret < 0) {\n\n            *desired_format = 0;\n\n            if (ret != AVERROR(EINVAL))\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    if (!*desired_format) {\n\n        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n\n            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||\n\n                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {\n\n                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",\n\n                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),\n\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));\n\n\n\n                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;\n\n                ret = device_init(ctx, width, height, *desired_format);\n\n                if (ret >= 0)\n\n                    break;\n\n                else if (ret != AVERROR(EINVAL))\n\n                    return ret;\n\n                *desired_format = 0;\n\n            }\n\n        }\n\n\n\n        if (*desired_format == 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"\n\n                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",\n\n                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,\n\n                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    *codec_id = avpriv_fmt_v4l2codec(*desired_format);\n\n    av_assert0(*codec_id != AV_CODEC_ID_NONE);\n\n    return ret;\n\n}\n", "idx": 17808, "substitutes": {"ctx": ["cv", "wd", "setup", "etc", "iat", "jac", "np", "kt", "check", "work", "pc", "wp", "cas", "req", "tz", "cmp", "co", "dc", "proc", "cf", "act", "hw", "tx", "ca", "mc", "cp", "obj", "cb", "cu", "wcs", "context", "cmd", "conf", "cfg", "tm", "window", "tnc", "conn", "pkg", "cn", "cm", "wx", "tc", "ka", "resp", "kw", "cl", "ct", "history", "bc", "prefix", "cur", "tk", "fn", "comm", "batch", "crit", "rt", "lc", "config", "jp", "kl", "fc", "rc", "abc", "ck", "kj", "sc", "xp", "pause", "gc", "unc", "this", "nc", "sys", "cc", "gz", "ctl", "xc", "addr"], "pix_fmt": ["pix_llt", "pix_tformat", "pix__vformat", "pix_vmt", "pix_ttm", "pix2flt", "pix_ctm", "pix_fwt", "pix_tmt", "pix2ftx", "pix_ltm", "pix__fwt", "pix2ftm", "pix_ftx", "pix_fformat", "pix_vwt", "pix_lformat", "pix_vformat", "pix_flt", "pix_vtm", "pix__fmt", "pix_ftm", "pix_lwt", "pix2fmt", "pix_clt", "pix_lmt", "pix__vmt", "pix__ftm", "pix_ltx", "pix__fformat", "pix_cmt", "pix__vwt", "pix_ctx", "pix__vtm", "pix_twt"], "height": ["window", "length", "volume", "ht", "th", "offset", "rank", "host", "h", "depth", "inches", "size", "radius", "style", "shape", "range", "bottom", "padding", "y", "above", " heights", "rows", "grow", "headers", "row", "upper", "history", "through", "ty", "angle", "hang", "frames", "count", "html", "capacity", "resolution", "w", "ows", "density", "ch", "hash"], "desired_format": ["desirement_title", "desired_type", "desired_spec", "desiry_size", "desiredUcolor", "desiredureformat", "desire_prefix", "desired_scale", "desiredachefeature", "desired_limit", "desirement_format", "desired_init", "desire_value", "desiredUsource", "desired_valid", "desfulexistingvalid", "desiredlylimit", "desired__format", "desiry_position", "desiredexistinglist", "desired_prefix", "desired_feature", "desiredexistingformat", "desiredurecache", "desiry_limit", "desired_value", "desired_filter", "desired_color", "desitted_write", "desirement_source", "desires__init", "desirementxsource", "desired___format", "desired_error", "desiredexistingchannel", "desired7data", "desiredxcolor", "desired_cache", "desitted_form", "desiredUtitle", "desired__value", "desired_channel", "desinished_format", "desiry_format", "desire_format", "desired___spec", "desired__type", "desired_Format", "desires__format", "desired_data", "desired7size", "desired_position", "desiry___filter", "desired__init", "desired67limit", "desiredxtitle", "desiredxsource", "desired_size", "desired_feat", "desires__type", "desiry___limit", "desiredexistingvalid", "desiredexistingFormat", "desinished_Format", "desirable_version", "desired_unit", "desire_type", "desired7format", "desired___init", "desired_list", "desired___feat", "desiredlyspec", "desires_init", "desiry_data", "desired_title", "desired_status", "desiredachescale", "desful_format", "desirementxtitle", "desiredlyfilter", "desirable_scale", "desirable_format", "desinished_type", "desired_write", "desired67format", "desire_status", "desiry___format", "desired___limit", "desinished_channel", "desires_type", "desiredlyformat", "desiry___spec", "desired67spec", "desired___filter", "desitted_format", "desfulexistinglist", "desful_valid", "desful_error", "desired___type", "desire_cache", "desiredacheversion", "desires__feat", "desirementxcolor", "desiredexistingerror", "desirement_color", "desiredurestatus", "desired7position", "desired__feat", "desirementxformat", "desiredxformat", "desiry_filter", "desiredUformat", "desiredexistingtype", "desired_version", "desired67filter", "desiredureprefix", "desiredacheformat", "desired_form", "desful_list", "desfulexistingerror", "desirable_feature", "desired_source", "desfulexistingformat", "desires_feat", "desitted_unit", "desiry_spec", "desires_format"], "codec_id": ["codiscityoid", "codecaphname", "codisc_oid", "codec_port", "codecalityfile", "codec_code", "codiscityname", "codec___file", "codec_bid", "codecityinfo", "codecalityid", "codec___bid", "codec_iden", "codec_oid", "codec_file", "codec___id", "codecityoid", "codendor_info", "codec_name", "codendor___name", "codoc_id", "codoc_iden", "codecalityname", "codiscityid", "codendor_id", "codendor_file", "codoc_name", "codendor___id", "codecityname", "codec_info", "codisc_info", "codecaphport", "codecalitybid", "codiscityinfo", "codendor___file", "codec___name", "codendor_name", "codendor_bid", "codendor___bid", "codecaphiden", "codecityid", "codoc_port", "codisc_name", "codecaphid", "codendor_code", "codisc_id"], "ret": [" res", "def", "fr", "RT", "RET", "out", "val", "print", "reflect", "mem", "deg", "rm", "rest", "f", "reg", "gt", "iter", "lt", "report", "rem", "cont", "dt", "len", "net", " fut", "re", "expr", "mat", "back", "ft", "inter", "cmd", "success", "fun", "nt", "mt", "rep", "ry", "ext", "result", "err", "ert", "valid", "port", "elt", "ll", "resp", "txt", "uf", "rets", "desc", "last", "dr", "tif", "try", "rt", "get", "ref", "jp", "func", "tr", "res", " resp", "att", "r", "arr", "rev", "Ret", "ort", "ter", "sys", "rect", "reset", "alt", "it", "il", "t"], "i": ["f", "to", "is", "g", "iri", "bi", "gi", "ind", "chain", "ir", "c", "iter", "ri", "xi", "err", "ki", "cli", "ai", "info", "ini", "json", "oi", "batch", "li", "ic", "ui", "y", "ip", "in", "iat", "io", "\u0438", "ims", "pi", "iu", "go", "im", "zi", "ci", "sim", "m", "id", "index", "ji", "v", "I", "n", "bis", "ii", "inter", "ti", "ei", "s", "phi", "ix", "status", "di", "uri", "it", "mi", "hi", "try", "ij", "t", "ski", "multi", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "2f0772c5b4818d4b2078be9dace0036d1030faee", "target": 1, "func": "static void lsi_soft_reset(LSIState *s)\n\n{\n\n    lsi_request *p;\n\n\n\n    DPRINTF(\"Reset\\n\");\n\n    s->carry = 0;\n\n\n\n    s->msg_action = 0;\n\n    s->msg_len = 0;\n\n    s->waiting = 0;\n\n    s->dsa = 0;\n\n    s->dnad = 0;\n\n    s->dbc = 0;\n\n    s->temp = 0;\n\n    memset(s->scratch, 0, sizeof(s->scratch));\n\n    s->istat0 = 0;\n\n    s->istat1 = 0;\n\n    s->dcmd = 0x40;\n\n    s->dstat = LSI_DSTAT_DFE;\n\n    s->dien = 0;\n\n    s->sist0 = 0;\n\n    s->sist1 = 0;\n\n    s->sien0 = 0;\n\n    s->sien1 = 0;\n\n    s->mbox0 = 0;\n\n    s->mbox1 = 0;\n\n    s->dfifo = 0;\n\n    s->ctest2 = LSI_CTEST2_DACK;\n\n    s->ctest3 = 0;\n\n    s->ctest4 = 0;\n\n    s->ctest5 = 0;\n\n    s->ccntl0 = 0;\n\n    s->ccntl1 = 0;\n\n    s->dsp = 0;\n\n    s->dsps = 0;\n\n    s->dmode = 0;\n\n    s->dcntl = 0;\n\n    s->scntl0 = 0xc0;\n\n    s->scntl1 = 0;\n\n    s->scntl2 = 0;\n\n    s->scntl3 = 0;\n\n    s->sstat0 = 0;\n\n    s->sstat1 = 0;\n\n    s->scid = 7;\n\n    s->sxfer = 0;\n\n    s->socl = 0;\n\n    s->sdid = 0;\n\n    s->ssid = 0;\n\n    s->stest1 = 0;\n\n    s->stest2 = 0;\n\n    s->stest3 = 0;\n\n    s->sidl = 0;\n\n    s->stime0 = 0;\n\n    s->respid0 = 0x80;\n\n    s->respid1 = 0;\n\n    s->mmrs = 0;\n\n    s->mmws = 0;\n\n    s->sfs = 0;\n\n    s->drs = 0;\n\n    s->sbms = 0;\n\n    s->dbms = 0;\n\n    s->dnad64 = 0;\n\n    s->pmjad1 = 0;\n\n    s->pmjad2 = 0;\n\n    s->rbc = 0;\n\n    s->ua = 0;\n\n    s->ia = 0;\n\n    s->sbc = 0;\n\n    s->csbc = 0;\n\n    s->sbr = 0;\n\n    while (!QTAILQ_EMPTY(&s->queue)) {\n\n        p = QTAILQ_FIRST(&s->queue);\n\n        QTAILQ_REMOVE(&s->queue, p, next);\n\n        g_free(p);\n\n    }\n\n    if (s->current) {\n\n        g_free(s->current);\n\n        s->current = NULL;\n\n    }\n\n}\n", "idx": 17833, "substitutes": {"s": ["us", "is", "er", "as", "fs", "h", "js", "i", "def", "y", "ies", "vs", "ims", "o", "has", "stats", "http", "qs", "ses", "less", "comments", "ers", "als", "terms", "bes", "rest", "new", "_", "ports", "cont", "ss", "sg", "ns", "spec", "ms", "parts", "bis", "space", "services", "cmd", "full", "an", "S", "bl", "results", "cs", "conf", "hs", "sts", "all", "g", "rs", "ads", "os", "comp", "set", "pers", "l", "m", "sp", "mods", "ar", "sol", "gs", "gets", "bs", "ls", "sv", "ins", "changes", "settings", "search", "params", "r", "ats", "sync", "ts", "sys", "its", "call", "con", "num", "n", "se", "ctl", "ix", "ds", "ps", "details", "es"], "p": ["g", "P", "c", "h", "i", "q", "cp", "y", "bp", "pp", "np", "pb", "r", "e", "lp", "pc", "m", "d", "sp", "b", "v", "n", "o", "w", "ps", "t", "tp", "j"]}}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n", "idx": 17877, "substitutes": {"s": ["is", "as", "states", "c", "h", "args", "js", "vs", "ims", "e", "series", "v", "has", "stats", "qs", "ses", "less", "status", "als", "bes", "bits", "eps", "aws", "sw", "xs", "ss", "ns", "obj", "spec", "ms", "state", "S", "source", "cs", "rates", "conf", "hs", "p", "sts", "ains", "g", "rs", "ops", "sq", "ex", "os", "conv", "ess", "set", "acs", "sb", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "settings", "ions", "this", "ats", "ts", "sys", "its", "b", "se", "ds", "ps", "t", "details", "es"], "icoef": ["icf", " icalf", "ciff", "groeph", "icefficients", "icoeff", "ICOf", " icff", "rioalf", "ciEF", "coff", "groEF", "coef", " icef", "ICOefficients", "cieph", "groalf", "icef", "cialf", "coalf", "groef", "ciefficients", "coeff", "cieff", " iceff", "rioeph", "icoff", "icoeph", "icoEF", "ICOalf", "icalf", "cif", "icoalf", "ICOef", "icof", "icoefficients", "rioEF", "rioef", "cief"], "pred": ["pull", "prop", "put", "fitted", "like", "pp", "debug", "patch", "ded", "cast", "pdf", "pop", "buff", "supp", "assert", "needed", "dict", "med", "sup", "proc", "ff", "rod", "pre", "test", "report", "stick", "pr", "powered", "obj", "dist", "embed", "expr", "mat", "tested", "compl", "cod", "adj", "red", "p", "tmp", "length", "binary", "bind", "prep", "ind", "push", "vest", "post", "sent", "surv", "iv", "loc", "sim", "pod", "ned", "pro", "pret", "ptr", "inf", "fn", "redict", "cond", "repl", "text", "Pred", "cho", "lab", "prof", "df", "pub", "roll", "rel", "arr", "priv", "vind", "ped", "ps", "ist"], "ich": ["irm", "arch", "ICH", "ik", "alth", "ship", "chest", "craft", "cht", "chip", "y", "ip", "owl", "ig", "ait", "integer", "quant", "shop", "iban", "ank", " chip", "isk", "hist", "capacity", "ict", "sky", "isch", "ethical", "bird", "anch", "act", "iver", "hw", "clock", "iter", "och", "iy", "orph", "chart", "ift", "ish", "im", "iam", "mot", "imp", "click", "esp", "contact", "cloth", "html", "ie", "ch", "sch", "iq", "resh", "chant", "ih", "ill", "clus", "iche", "ht", "host", "utch", "channel", "conv", "wife", "aff", "iv", "phy", " ch", "ech", "icht", "txt", "ether", "\u00e7", "morph", "oc", "x", "chid", "uch", "machine", "eric", "world", "batch", "ach", "nick", "ox", "animate", "iss", "entity", "Chip", "ike", "outh", "ench", "ic", "chn", "ick", "hip", "hai", "num", "igraph", "ord", "rich", "ix", "unch", "uth", "chan", "irc", "isc", "yout", "each", "choice"], "i": ["us", "is", "ik", "g", "iri", "bi", "gi", "ice", "ind", "init", "ir", "ri", "xi", "point", "ki", "ex", "cli", "ai", "ogi", "ic", "ui", "li", "isi", "ip", "y", "iat", "in", "\u0438", "ami", "io", "pi", "iu", "qi", "set", "ni", "im", "remote", "zi", "ci", "sim", "m", "me", "index", "ji", "gu", "client", "ori", "v", "I", "PI", "j", "si", "ii", "ti", "ei", "fi", "phi", "ix", "et", "di", "uri", "it", "mi", "ie", "mac", "hi", "at", "ij", "ch", "ini", "multi", "oi", "p"]}}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n", "idx": 17883, "substitutes": {"ds": ["uds", "ods", "ls", "sts", "ks", "rs", "iss", "bd", "xs", "dl", "js", "ads", "des", "os", "dos", "Ds", "ns", "ims", "sd", "ms", "sys", "d", "DS", "dd", "irs", "eds", "s", "db", "qs", "gs", "ys", "cs", "dds", "bs", "fs", "hs", "pd"], "src_x": ["rc_ex", " src_rx", "srcptxi", "src__ex", "rc_y", "src_rx", " src_ix", "srcptix", "rc_x", "src__y", "src_ex", "src_ix", "src_xi", " src_xi", "srcptx", "srcptrx", "src__x", "src__rx", "rc_rx"], "src_y": ["src_yy", "rc_vy", "rc_sy", "src_Y", " src_Y", "rc_y", " src_yy", "src2Y", "rc_x", "src2xy", "src_xy", " src_xy", "src2y", "src2yy", "src_sy", "src_vy"], "dst_x": ["dsrc_w", "dst_xi", "dst__ex", "dest_y", "dest_x", "dst__y", "dnt_xd", "dnt_fx", "dst__x", "dst_xd", "dstoxxi", "dest_ex", "dstoxx", "dst_rx", "dst__w", "dsrc_x", "dstoxfx", "dstoxxd", "dnt_x", "dnt_xi", "dsrc_rx", "dst_w", "dsrc_ex", "dst_ex", "dst_fx", "dest_w"], "dst_y": ["dst___ny", "ddest_x", "ddest_y", "ddest_o", "dout_ys", "dout_Y", "dst___o", "dsrc_y", "dst_cy", "dst_ys", "dst_Y", "ddest_ny", "dsrc_ey", "dsrc_x", "dout_y", "dout_cy", "dst_ey", "dst___x", "dst_o", "dst_ny", "dst___y"], "w": ["window", "hw", "sw", "iw", "wd", "mm", "wb", "win", " dw", "ex", "wk", "wn", "wx", "wal", "wi", "rw", "wp", "nw", "kw", "wl", "ww", "aw", "ew", "wa", "wh", "weight", "x", "wind", "fw", "W", "ow", "whe", "wid", "we", "wt", "wr", " W"], "h": ["high", "ih", "hr", "length", "ht", "bh", "th", "ho", "hei", "hd", "hh", "H", "c", "rh", "uh", "hs", "q", "he", "ish", "ha", "hz", "im", "height", "oh", "ah", "l", "m", "ph", "b", "kh", "v", "hl", "wh", "hi", "ch", "sh", "z", "p"], "vd": ["uds", "sv", "gd", "xd", "hd", "vr", "du", "df", "nd", "bd", "wd", "td", "dl", "nl", "ud", "dq", " sd", "dk", "sd", "lv", "dh", "d", "VD", "dj", "udi", "dd", "irs", "eds", "kb", "md", "gb", "vc", "nv", "dr", "vt", "od", "ld", "pd"], "vs": ["uds", "ls", "is", "sts", "ks", "sv", "rs", "ubs", "ins", "eps", "lists", "vr", "xs", "aps", "alls", "ov", "js", "ports", "values", "css", "lbs", "links", "os", "ues", "ss", "pps", "obs", "ns", "ims", "lv", "ms", "sys", "ts", "qv", "its", "vi", "fps", "es", "vers", "v", "vm", "ves", "Vs", "iffs", "vc", "atts", "views", "qs", "irms", "vals", "stats", "tv", "uv", "vt", "inv", "gs", "VS", "av", "gets", "cs", "flags", "otes", "ps", "bs", "ils", "fs", "hs", " cs", "vp"]}}
{"project": "qemu", "commit_id": "da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56", "target": 1, "func": "static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n", "idx": 17885, "substitutes": {"base": ["f", "bit", "bind", "na", "create", "based", "init", "c", "ban", "bar", "origin", "Base", "buffer", "store", "ic", "server", "bp", "null", "in", "gc", "re", "cast", "id", "bid", "b", "pa", "back", "out", "basic", "state", "db", "file", "last", "it", "bound", "bas", "raw", "bf", "scope", "bu", "mb", "start", "node", "bo", "pse", "p"], "card": ["crit", "cf", "cell", "parse", "craft", "c", "cat", "ca", "copy", "game", "bar", "com", "report", "role", "rar", "wild", "deck", "brand", "func", "ad", "def", "cap", "man", "ck", "cont", "order", "gc", "event", "star", "cards", "way", "roll", "php", "flag", "note", "cast", "can", "carry", "play", "Card", "cc", "row", "var", "car", "back", "book", "rule", "pass", "ARD", "comment", "ar", "ce", "cmd", "control", "member", "compl", "controller", "dr", "word", "command", "pack", "guard", "dev", "mod", "ard", "add", "flight"], "vevent": ["veent", "avevent", "iequest", "vection", "avequest", "aveevent", "oveevent", "tequest", "ovevent", "vequest", "avection", "seevent", "tevent", "veevent", "ievent", "section", "meent", "ieent", "tegent", "megent", "mevent", "ovection", "mequest", "vegent", "ovequest", "sequest", "sevent", "iegent", "teent"]}}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n", "idx": 17893, "substitutes": {"h": ["f", "ih", "window", "ht", "bh", "g", "host", "hw", "H", "c", "a", "i", "q", "he", "pp", "sh", "e", "hm", "oh", "ah", "l", "dh", "m", "d", "b", "v", "k", "n", "o", "ctx", "context", "mem", "w", "hp", "ch", "comm", "t", "hs", "j", "p"], "qscale": ["QScale", " qstep", "dqscene", " qcale", "Qscale", "iqcrop", "iqstep", "qsc", "sqscene", "Qscene", "sqscale", "qcale", "qScale", "dqsc", " Qcrop", "sqScale", "dqscale", " Qcale", "sqsc", " Qstep", "qcrop", "Qsc", " Qscale", "iqcale", "iqscale", "qscene", "dqScale", " qcrop", "qstep"]}}
{"project": "FFmpeg", "commit_id": "fe8c9420dd5bbc7a0c545e479da9118bcf311dd2", "target": 1, "func": "int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)\n\n{\n\n    int e;\n\n    int bit_count_start = get_bits_count(gb_host);\n\n    int header;\n\n    int bits_consumed;\n\n    GetBitContext gbc = *gb_host, *gb = &gbc;\n\n\n\n    header = get_bits1(gb);\n\n    if (header) {     //enable_ps_header\n\n        ps->enable_iid = get_bits1(gb);\n\n        if (ps->enable_iid) {\n\n            int iid_mode = get_bits(gb, 3);\n\n            if (iid_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"iid_mode %d is reserved.\\n\",\n\n                       iid_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_iid_par    = nr_iidicc_par_tab[iid_mode];\n\n            ps->iid_quant     = iid_mode > 2;\n\n            ps->nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];\n\n        }\n\n        ps->enable_icc = get_bits1(gb);\n\n        if (ps->enable_icc) {\n\n            ps->icc_mode = get_bits(gb, 3);\n\n            if (ps->icc_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"icc_mode %d is reserved.\\n\",\n\n                       ps->icc_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_icc_par = nr_iidicc_par_tab[ps->icc_mode];\n\n        }\n\n        ps->enable_ext = get_bits1(gb);\n\n    }\n\n\n\n    ps->frame_class = get_bits1(gb);\n\n    ps->num_env_old = ps->num_env;\n\n    ps->num_env     = num_env_tab[ps->frame_class][get_bits(gb, 2)];\n\n\n\n    ps->border_position[0] = -1;\n\n    if (ps->frame_class) {\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = get_bits(gb, 5);\n\n    } else\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = (e * numQMFSlots >> ff_log2_tab[ps->num_env]) - 1;\n\n\n\n    if (ps->enable_iid) {\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_iid_data(avctx, gb, ps, ps->iid_par, huff_iid[2*dt+ps->iid_quant], e, dt))\n\n                goto err;\n\n        }\n\n    } else\n\n        memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n\n\n    if (ps->enable_icc)\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_icc_data(avctx, gb, ps, ps->icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))\n\n                goto err;\n\n        }\n\n    else\n\n        memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n\n\n    if (ps->enable_ext) {\n\n        int cnt = get_bits(gb, 4);\n\n        if (cnt == 15) {\n\n            cnt += get_bits(gb, 8);\n\n        }\n\n        cnt *= 8;\n\n        while (cnt > 7) {\n\n            int ps_extension_id = get_bits(gb, 2);\n\n            cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);\n\n        }\n\n        if (cnt < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"ps extension overflow %d\\n\", cnt);\n\n            goto err;\n\n        }\n\n        skip_bits(gb, cnt);\n\n    }\n\n\n\n    ps->enable_ipdopd &= !PS_BASELINE;\n\n\n\n    //Fix up envelopes\n\n    if (!ps->num_env || ps->border_position[ps->num_env] < numQMFSlots - 1) {\n\n        //Create a fake envelope\n\n        int source = ps->num_env ? ps->num_env - 1 : ps->num_env_old - 1;\n\n        int b;\n\n        if (source >= 0 && source != ps->num_env) {\n\n            if (ps->enable_iid) {\n\n                memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));\n\n            }\n\n            if (ps->enable_icc) {\n\n                memcpy(ps->icc_par+ps->num_env, ps->icc_par+source, sizeof(ps->icc_par[0]));\n\n            }\n\n            if (ps->enable_ipdopd) {\n\n                memcpy(ps->ipd_par+ps->num_env, ps->ipd_par+source, sizeof(ps->ipd_par[0]));\n\n                memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));\n\n            }\n\n        }\n\n        if (ps->enable_iid){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (FFABS(ps->iid_par[ps->num_env][b]) > 7 + 8 * ps->iid_quant) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"iid_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        if (ps->enable_icc){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (ps->icc_par[ps->num_env][b] > 7U) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"icc_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        ps->num_env++;\n\n        ps->border_position[ps->num_env] = numQMFSlots - 1;\n\n    }\n\n\n\n\n\n    ps->is34bands_old = ps->is34bands;\n\n    if (!PS_BASELINE && (ps->enable_iid || ps->enable_icc))\n\n        ps->is34bands = (ps->enable_iid && ps->nr_iid_par == 34) ||\n\n                        (ps->enable_icc && ps->nr_icc_par == 34);\n\n\n\n    //Baseline\n\n    if (!ps->enable_ipdopd) {\n\n        memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n        memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    }\n\n\n\n    if (header)\n\n        ps->start = 1;\n\n\n\n    bits_consumed = get_bits_count(gb) - bit_count_start;\n\n    if (bits_consumed <= bits_left) {\n\n        skip_bits_long(gb_host, bits_consumed);\n\n        return bits_consumed;\n\n    }\n\n    av_log(avctx, AV_LOG_ERROR, \"Expected to read %d PS bits actually read %d.\\n\", bits_left, bits_consumed);\n\nerr:\n\n    ps->start = 0;\n\n    skip_bits_long(gb_host, bits_left);\n\n    memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n    memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n    memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n    memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    return bits_left;\n\n}\n", "idx": 17904, "substitutes": {"avctx": ["Avctx", "avectx", "avtx", "avecf", "abca", " avcp", "aftx", "vercp", "abcm", " avcontext", "avecmp", "avca", "avercmp", "AVctx", "averctx", "abctx", "avconn", "avetx", "avecontext", "avercontext", "AVcontext", "afca", "AVcmp", "Avconn", "afcm", "AVcf", "vercontext", "abtx", "avcmp", "avcontext", "avcf", "avcm", "avcp", " avconn", "avercf", "verctx", "verconn", "aveca", "avecm", "Avcp", "Avcontext", "afctx"], "gb_host": ["gb2Host", "db_handle", "nb_over", "gb_handle", "gb_ost", "gb_path", "gb2host", "db_Host", "cb_server", "cb_path", "db_host", "cb_host", "nb_host", "gb64host", "gb64over", "gb_Host", "gb64server", "nb_ost", "nb_server", "db_server", "gb64ost", "gb_over", "gb2handle", "gb2server", "gb_server"], "ps": ["fs", "js", "syn", "vs", "pp", "ims", "pb", "pc", "ctx", "stats", "abilities", "posts", "flags", "dates", "als", "tp", "eps", "aps", "ports", "pr", "pps", "cp", "pos", "ns", "ms", "parts", "times", "phys", "points", "vals", "results", "keys", "cs", "rates", "rep", "p", "sts", "rs", "ops", "PS", "ips", "css", "players", "pins", "rots", "types", "pers", "ands", "pt", "sp", "fields", "gs", "ists", "bs", "pse", "checks", "ls", "ins", "changes", "jp", "gp", "plays", "mp", "properties", "params", "ats", "ts", "its", "fps", "ping", "pa", "pres", "ds", "details", "pd"], "bits_left": ["bits_lower", " bits_low", " bits_lower", " bits_right", "bits_low", "bits_right"], "e": ["ep", "nee", "fe", "er", "c", "ed", "i", "le", "def", "event", "ffe", "eb", "o", "be", "eff", "ame", "ae", "_", "eps", "complete", "oe", "ef", "eh", "ue", "eeee", "el", "ev", "element", "ce", "ase", "one", "ie", "pe", "ea", "edge", "ne", "g", "en", "ate", "err", "ex", "ge", "te", "ade", "ee", "l", "me", "m", "eu", "ve", "x", "ent", "ome", "ele", "entity", "func", "line", "r", "est", "d", "n", "se", "eg", "xe", "ei", "et", "de", "ec", "it", "E", "t", "es"], "header": ["profile", "cf", "type", "block", "offset", "er", "ref", "hd", "part", "h", "iter", "c", "channel", "tar", "err", "Header", "heading", "size", "port", "buffer", "server", "len", "version", "error", "tr", "padding", "pp", "body", "head", "rr", "set", "border", "handle", "flag", "table", "check", "headers", "index", "num", "prot", "layer", "primary", "wcs", "member", "data", "chron", "frame", "status", "metadata", "format", "dr", "ptr", "meta", "name", "p"], "bits_consumed": ["bits_consume", "bits_Conserved", "bits_cserved", "bits_sume", "bits_served", "bits_csumed", "bits_conserved", "bits_consumption", "bits_csume", "bits_Consumed", "bits_sumed", "bits_sumption", "bits_csumption", "bits_Consumption", "bits_Consume"], "gb": ["nb", "bridge", "tm", "px", "bb", "g", "gt", "gd", "obo", "GB", "tg", "vd", "wb", "vg", "gp", "fb", "xy", "buffer", "cp", "rb", "rg", "sg", "bytes", "img", "gc", "phy", "cb", "pb", "um", "gif", "got", "buf", "pc", "eb", "vm", "gz", "ctx", "eg", "bg", "hub", "Gb", "gnu", "sb", "gm", "bc", "kb", "db", "pg", "html", "bt", "storage", "goo", "gg", "py", "raw", "gs", "ob", "bf", "csv", "mb", "ch", "ruby", "bs", "cfg", "gh"], "num_env": ["num_ev", "Num_dev", "num_environment", "nb_ee", "num___env", "num_den", "Num_env", "num__dev", "nb___den", "num___ee", "nom_env", "num__conn", "len_env", "nb___ext", "len_ext", "num_dev", "num__environment", "num_conn", "nom_den", "num_ee", "len_environment", "len_ev", "num__ev", "Num_conn", "nb_den", "nb_env", "nb___ee", "nom_dev", "num___ext", "nb_ext", "Num_ev", "nom_environment", "num___den", "num__ext", "num__env", "nb___env", "num_ext"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        int size;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 17908, "substitutes": {"s": ["ls", "sts", "sv", "rs", "g", "a", "c", "sq", "h", "os", "ss", "sg", "ns", "ats", "ts", "b", "v", "ds", "w", "S", "gs", "sa", "ps", "t", "bs", "fs", "p"], "st": ["rt", "irst", "sl", "ost", "th", "sts", "sn", "sw", "spect", "tx", "ste", "nd", "std", "stage", "stream", "sta", "store", "ss", "sc", "inst", "src", "ist", "St", "est", "pt", "sp", "ST", "se", "sb", "str", "storage", "art", "ust", "stop", "stra", "nt", "stat", "start", "stable", "mt", "t", "sh", "rest", "step", "pat"], "pkt": ["Pmt", "pwk", "psnt", "pskt", "ppmt", " pvt", "Pmsg", " pdu", "pdu", "opwk", "ppacket", "Pwk", "Pkt", "pkl", "fmsg", "opacket", "dacket", "Pct", "Pdu", "dnt", "dkt", " pmt", "Packet", " pkl", "opdu", "rdu", "ppct", "dkl", "rmsg", "Pvt", "pmsg", "fkt", "wpnt", "opkt", "ppkt", "fdu", "Pnt", "wpct", " packet", "psacket", " pwk", "ppmsg", "pct", "wpvt", "packet", " pmsg", "rkt", "pskl", "facket", "racket", "wpkt", "pmt", " pct", " pnt", "pnt", "pvt"], "desc": ["text", "label", "attr", "ext", "vec", "bd", "test", "ribe", "disc", "err", "dl", "info", "des", " Desc", "def", "cont", "dim", "sc", "diff", "ript", "sub", "obj", "dist", "described", "sort", "dir", "buf", "summary", "id", "rec", "txt", "cd", "DES", "dep", "comment", "description", "str", "md", "asc", "data", "ds", "seq", "msg", "pro", "Desc", "dict", "ptr", "dev", "cmp", "esc", "meta", "dc", "name"], "ret": ["rt", "tmp", "get", "xt", "gt", "ref", "result", "test", "lt", "err", "rem", "nl", "des", "buffer", "len", "tr", "res", "elt", "gc", "dist", "re", "rel", "arg", "resp", "buf", "RET", "Ret", "rev", "summary", "txt", "ft", "nz", "reset", "val", "rets", "alt", "success", "mem", "dr", "fun", "pro", "nt", "mt", "ptr", "rep"], "ast": ["act", "ost", "ief", "pat", "tt", "as", "asted", "a", "tx", "each", "test", "nd", "aster", "af", "AST", "sta", "ed", "asting", "mast", "ad", "asts", "store", "ab", "asm", "access", "ess", "must", "dist", "master", "ait", "kind", "att", "embed", "cast", "wat", "est", "any", "ts", "ma", "best", "ack", "and", "esp", "acl", "aw", "Ast", "mem", "am", "art", "exec", "aft", "at", "addr", "mt", "ace", "ard", "rest", "past", "ist"], "sub_demuxer": ["sub_demixers", "sub_demxier", "sub_democe", "sub_demxed", "sub_demuxor", "sub_demxer", "sub_democer", "sub_democier", "sub_promxer", "sub_demuploade", "sub_demuxe", "sub_demixe", "sub_democers", "sub_demixed", "sub_promuxier", "sub_demixer", "sub_promxier", "sub_demuxed", "sub_promuxer", "sub_demuploader", "sub_promxers", "sub_demuxers", "sub_promxe", "sub_demxor", "sub_demixor", "sub_demuploaded", "sub_demixier", "sub_demuploador", "sub_promuxers", "sub_promuxe", "sub_demxers", "sub_demuxier", "sub_demxe"], "time_base": ["Time_bas", "time_Base", "Time_Base", "time_bas", "Time_base"], "size": ["ose", "sn", "shift", "use", "shape", "head", "max", "address", "message", "small", "v", "time", "out", "send", "capacity", "span", "mem", "status", "limit", "extra", "offset", "sw", "min", "len", "pos", "body", "now", "mode", "area", "code", "total", "space", "empty", "notice", "full", "general", "dev", "name", "length", "sum", "g", "year", "south", "origin", "sent", "cap", "dim", "error", "set", "l", "sp", "count", "number", "sv", "fee", "speed", "rc", "SIZE", "scale", "sc", "ize", "bytes", "gc", "align", "height", "score", "num", "id", "gz", "n", "Size", "description", "data", "news", "start", "loss", "dump", "t", "z", "timeout"], "pb": ["proc", "nb", "tmp", "px", "bb", "cv", "bh", "ub", "PB", "pkg", "bj", "jp", "tg", "tx", "wb", "td", "fb", "mp", "tab", "ab", "cp", "rb", "bp", "xp", "np", "pp", "gc", "cb", "patch", "pan", "tc", "ib", "stab", "lp", "pm", "buf", "tap", "pc", "wp", "pt", "ap", "sp", "eb", "b", "ctx", "pa", "uf", "vp", "sb", "apa", "bc", "gb", "pg", "lb", "apy", "tk", "bps", "py", "buff", "emb", "ps", "bs", "dp", "tp", "p"], "pd": ["fd", " dab", "px", "ppo", "xd", "pkg", "tp", "hd", "dp", "bd", "df", "vd", "edd", "td", " dw", "dl", "pr", "ud", "dq", "def", "ad", "dt", "cp", " od", " sd", " dd", "np", "pp", "p", "pi", "sd", "PD", "pl", "php", "da", "pm", "ecd", "dh", "pdf", "d", "pc", " prod", "pod", "ph", " md", "dj", "vp", "dd", "po", " ep", "md", "ds", " pt", "pard", "py", " cd", " ad", "ps", "ped", " np", "od", " pdf", "ld", " td", "cd", "pat"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n", "idx": 17909, "substitutes": {"d": ["fd", "done", "did", "dx", "ind", "hd", "bd", "du", "dn", "nd", "dl", "draw", "ad", "dt", "dim", "D", "dos", "debug", "sd", "dat", "da", "dm", "r", "dh", "ord", "v", "dj", "n", "ct", "dd", "send", "md", "dis", "db", "de", "ds", "di", "dr", "dev", "dump", "ld", "dc", "pd", "cd", "p"]}}
{"project": "FFmpeg", "commit_id": "ac726a4f0cd2fb8619b478af51312a4282215f0e", "target": 0, "func": "static int movie_request_frame(AVFilterLink *outlink)\n\n{\n\n    AVFilterBufferRef *outpicref;\n\n    MovieContext *movie = outlink->src->priv;\n\n    int ret;\n\n\n\n    if (movie->is_done)\n\n        return AVERROR_EOF;\n\n    if ((ret = movie_get_frame(outlink)) < 0)\n\n        return ret;\n\n\n\n    outpicref = avfilter_ref_buffer(movie->picref, ~0);\n\n    ff_start_frame(outlink, outpicref);\n\n    ff_draw_slice(outlink, 0, outlink->h, 1);\n\n    ff_end_frame(outlink);\n\n    avfilter_unref_buffer(movie->picref);\n\n    movie->picref = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 17913, "substitutes": {"outlink": ["olinked", "outl", "OUTink", "OUTlinked", "outman", "unlinked", " outstream", "devline", "devzip", "outroute", "otline", "outlinked", "unlink", "cmdlinked", "bootroute", "outstream", "conlock", "OUTcheck", "cmdink", "conblock", "outcheck", "outink", "conl", "otloop", " outman", "conlinked", "OUTlink", "outgroup", "ol", "taskgroup", "outzip", "devlink", "outloop", "otlog", " outlock", "OUTzip", "olink", " outlog", "outLink", " outroute", "oblock", "devlinked", "tasklink", "otlink", "cmdlink", " outblock", "bootgroup", "conman", "conlink", "Outline", " outLink", "outblock", " outzip", " outl", "unman", "Outlink", " outlinked", "OutLink", " outink", "outlog", "cmdstream", "OUTline", "Outcheck", "outlock", " outcheck", " outloop", "bootlink", "OUTlog", "unlock", " outline", "outline", " outgroup", "OUTLink", "taskroute", "OUTstream", "OUTloop"], "outpicref": ["OUTpicref", " outpicdef", "outPicRef", "OUTpictureRef", "outmicob", "outPicob", "outnicmb", "OUTpicturereference", "outPicdesc", "OUTpicmb", "outpcdesc", "outPicreference", "outpictureRef", "outpictureref", "outpicturemb", "outpcRef", "outpinRef", "outpinref", "outpcreference", " outpicdesc", "outpicRef", " outpicRef", "outpicreference", "OUTpicturemb", " outPicob", " outPicdesc", "outmicdef", "outcamref", " outpicreference", " outpicob", "outpicob", "outnicRef", "outpindesc", " outPicRef", " outPicdef", "OUTpictureref", "outmicreference", "outnicref", "outcamreference", "outmicref", "outpinreference", "OUTpicRef", "outpicdef", "outpicdesc", " outPicreference", " outPicref", "outcamob", "outPicref", "outPicmb", "outnicreference", "OUTpicreference", "outpicturereference", "outPicdef", "outpcref", "outpicmb", "outcamdef"], "movie": ["mpeg", "program", "Movie", "runner", "monster", "cam", "scene", "gallery", "video", "iframe", "camera", "mob", "partial", "hero", "flash", "manager", "milo", "drm", "mmmm", "ami", "device", "mmm", "VIDEO", "rage", "player", "bug", "actor", "dm", "move", "picture", "menu", "my", "message", "maker", "m", "mor", "vm", "film", "mode", "core", "mobile", "motion", "voice", "ovie", "mo", "media", "notice", "member", "normal", "feature", "file", "frame", "material", "tv", "magic", "image", "module", "die", "dev", "transfer", "meta", "anim", "metadata", "job"], "ret": ["rt", "ber", "nil", "reg", "gt", "ref", "result", "test", "lt", " RET", "rem", "def", "cont", "len", "tr", "res", "elt", " fut", "re", "match", "r", "resp", "det", "RET", "Ret", "ter", "sys", "txt", "v", "mat", "back", "out", "ft", "cert", " Ret", "git", "reset", "val", "rets", "alt", "mel", "status", "it", "fun", "nt", "rm", "try", "mt", "t"]}}
{"project": "FFmpeg", "commit_id": "89d4d7d759a59e8535b267b7f5af757f731da712", "target": 1, "func": "static void process_client(AVIOContext *client, const char *in_uri)\n\n{\n\n    AVIOContext *input = NULL;\n\n    uint8_t buf[1024];\n\n    int ret, n, reply_code;\n\n    uint8_t *resource = NULL;\n\n    while ((ret = avio_handshake(client)) > 0) {\n\n        av_opt_get(client, \"resource\", AV_OPT_SEARCH_CHILDREN, &resource);\n\n        // check for strlen(resource) is necessary, because av_opt_get()\n\n        // may return empty string.\n\n        if (resource && strlen(resource))\n\n            break;\n\n\n    }\n\n    if (ret < 0)\n\n        goto end;\n\n    av_log(client, AV_LOG_TRACE, \"resource=%p\\n\", resource);\n\n    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n\n        reply_code = 200;\n\n    } else {\n\n        reply_code = AVERROR_HTTP_NOT_FOUND;\n\n    }\n\n    if ((ret = av_opt_set_int(client, \"reply_code\", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        av_log(client, AV_LOG_ERROR, \"Failed to set reply_code: %s.\\n\", av_err2str(ret));\n\n        goto end;\n\n    }\n\n    av_log(client, AV_LOG_TRACE, \"Set reply code to %d\\n\", reply_code);\n\n\n\n    while ((ret = avio_handshake(client)) > 0);\n\n\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    fprintf(stderr, \"Handshake performed.\\n\");\n\n    if (reply_code != 200)\n\n        goto end;\n\n    fprintf(stderr, \"Opening input file.\\n\");\n\n    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n\n        av_log(input, AV_LOG_ERROR, \"Failed to open input: %s: %s.\\n\", in_uri,\n\n               av_err2str(ret));\n\n        goto end;\n\n    }\n\n    for(;;) {\n\n        n = avio_read(input, buf, sizeof(buf));\n\n        if (n < 0) {\n\n            if (n == AVERROR_EOF)\n\n                break;\n\n            av_log(input, AV_LOG_ERROR, \"Error reading from input: %s.\\n\",\n\n                   av_err2str(n));\n\n            break;\n\n        }\n\n        avio_write(client, buf, n);\n\n        avio_flush(client);\n\n    }\n\nend:\n\n    fprintf(stderr, \"Flushing client\\n\");\n\n    avio_flush(client);\n\n    fprintf(stderr, \"Closing client\\n\");\n\n    avio_close(client);\n\n    fprintf(stderr, \"Closing input\\n\");\n\n    avio_close(input);\n\n\n}", "idx": 17929, "substitutes": {"client": ["component", "window", "close", "cell", "cgi", "config", "open", "cache", "conn", "connection", "chain", "user", "c", "channel", "plugin", "cli", "connect", "parent", "service", "product", "application", "self", "manager", "server", "null", "ip", "net", "util", "public", "session", "tc", "remote", "handler", "ci", "request", "pc", "this", "con", "call", "qualified", "local", "cl", "secure", "core", "template", "out", "Client", "socket", "wrapper", "context", "web", "cmd", "http", "container", "current", "view", "bound", "api", "collection", "response", "batch"], "in_uri": ["inUURI", "inUiri", "in_URI", "inPuri", "inPURI", "inUurl", " in_iri", " in_ui", "inUuri", " in_URI", " in_url", "in_ui", " in_ri", "inPfile", "inPri", "in_ri", "in_iri", "in_file", "in_url", " in_file"], "input": ["window", "from", "cgi", "config", "initial", "open", "conn", "connection", "entry", "init", "user", "interface", "Input", "cli", "rc", "valid", "i", "inner", "stream", "batch", "buffer", "q", "in", "io", "ip", "attribute", " inputs", "read", "reader", "form", "table", "query", "this", "request", "PUT", "import", "accept", "local", "out", "context", "instance", "cmd", "active", "focus", "http", "output", "exec", "view", "raw", "image", "command", "source", "start", "hidden", " context"], "buf": ["proc", "tmp", "text", "cv", "br", " buffer", "ref", "result", "iter", "fac", "wb", "err", "temp", "bar", "fb", "rc", " buff", "Buff", "buffer", "cap", "Buffer", "rb", "bp", "bytes", "bag", "read", "cb", "pb", "resp", "rw", "BU", "b", "v", "var", "ctx", "uf", "out", "txt", " buffers", "bc", "alloc", "db", "cmd", "data", "cur", "mem", "output", "seq", "msg", "w", "raw", "buff", "ob", "mb", "queue", "batch"], "ret": ["def", "RT", "RET", "v", "out", "print", "val", "deg", "status", "rm", "reply", "gt", "iter", "report", "rem", "json", "cont", "dt", "len", "net", "obj", "re", "progress", "back", "ft", "inter", "cmd", "success", "fun", "nt", "mt", "red", "job", "detail", "ry", "ber", "ne", "ext", "result", "del", "elt", "ll", "arg", "resp", "pt", "vet", "ct", "cert", "git", "rets", "proxy", "desc", "rier", "ent", "vt", "try", "inf", "repl", "rt", "ref", "ctr", "tr", "res", "att", "r", "got", "grain", "rev", "Ret", "sys", "live", "reset", "et", "alt", "format", "it", "tree", "t", "response", "j"], "n": ["nb", "ne", "g", "nm", "en", "na", "sn", "cn", "c", "nr", "dn", "non", "i", "nl", "size", "name", "len", "y", "nn", "np", "ns", "net", "norm", "ll", "note", "r", "e", "nor", "ng", "l", "nc", "d", "num", "m", "none", "b", "o", "nat", "nu", "nan", "count", "an", "no", "ln", "number", "nt", "N", "fn", "t", "z", "j", "p"], "reply_code": ["reply7number", "reply2cod", "repl7co", "reply_last", "repl7code", " reply2coe", "replyEstatus", "reply_codes", "reply7last", "replyingcont", "reply_status", "reply_Code", "replyEcode", " reply2code", "reply7code", "reply2coe", "reply00code", " reply2cont", "repl_cod", "response_code", "reply00cont", "reply2code", "replEstatus", "repl_code", "repl_status", "replyedcode", "reply_coded", "replyEcod", "reply_cod", "replyingcode", "response_ce", "replyednumber", " reply2reason", "reply_class", "reply00reason", "reply_co", "reply2reason", "reply_reason", "replyingreason", "replyECode", "reply00status", " reply_number", "repl_last", "respond_code", "reply2status", "reply2cont", "respond_class", " reply_coe", "respond_coded", "reply7co", "reply_ce", " reply2status", "replyingstatus", "respond_codes", "replECode", "reply_cont", " reply_cod", "replEcod", " reply2number", "repl7number", "replEcode", "reply_number", "repl_Code", " reply_reason", " reply_status", "reply2number", " reply2cod", "response_codes", "reply_coe", "replyedcod", "repl_number", "replyedcoe", "repl_co", " reply_cont", "repl7last"], "resource": ["component", "Resource", "page", "use", "memory", "pointer", "attribute", "exclusive", "max", "address", "message", "key", "rest", "url", "ro", "null", "reference", "include", "row", "space", "comment", "context", "controller", "directory", "source", "scope", "process", "name", "window", "binary", "response", "location", "confirmed", "result", "channel", "buffer", "region", "byte", "match", "record", "core", "color", "instance", "member", "prefix", "file", "uri", "image", "ptr", "range", "coord", "ref", "connection", "server", "res", "remote", "r", "handle", "sequence", "this", "value", "question", "network", "local", "folder", "primary", "description", "data", "feature", "output", "collection", "share", "release", "resources"]}}
{"project": "FFmpeg", "commit_id": "cec939597722663f322941b4c12e00a583e63504", "target": 1, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int16_t (*l1mv1)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[1][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int8_t *l1ref1 = &h->ref_list[1][0].ref_index[1][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n\n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col)\n\n               && (   (l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1)\n\n                   || (l1ref0[0]  < 0 && l1ref1[0] == 0 && ABS(l1mv1[0][0]) <= 1 && ABS(l1mv1[0][1]) <= 1\n\n                       && (h->x264_build>33 || !h->x264_build)))){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n\n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n\n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && (   l1ref0[x8 + y8*h->b8_stride] == 0\n\n                                              || (l1ref0[x8 + y8*h->b8_stride] < 0 && l1ref1[x8 + y8*h->b8_stride] == 0\n\n                                                  && (h->x264_build>33 || !h->x264_build)))){\n\n                    const int16_t (*l1mv)[2]= l1ref0[x8 + y8*h->b8_stride] == 0 ? l1mv0 : l1mv1;\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0] >= 0 ? h->map_col_to_list0[0][l1ref0[0]]\n\n                                                : h->map_col_to_list0[1][l1ref1[0]];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n                const int16_t (*l1mv)[2]= l1mv0;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n\n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                if(ref0 >= 0)\n\n                    ref0 = h->map_col_to_list0[0][ref0];\n\n                else{\n\n                    ref0 = h->map_col_to_list0[1][l1ref1[x8 + y8*h->b8_stride]];\n\n                    l1mv= l1mv1;\n\n                }\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17932, "substitutes": {"h": ["f", "ih", "window", "ht", "bh", "th", "g", "rs", "cache", "host", "hw", "hd", "sw", "hh", "H", "c", "rh", "hs", "hal", "q", "eh", "he", "pp", "hz", "handle", "r", "hm", "oh", "ah", "help", "dh", "l", "m", "here", "ph", "cc", "b", "ctx", "v", "ct", "k", "kh", "his", "hl", "history", "context", "http", "hp", "her", "ch", "ssh", "comm", "t", "hash", "sh", "j", "each", "p"], "mb_type": ["mg_TYPE", "mg_ty", "mb_name", "mblyTYPE", "emb_Type", "mbetytype", "mb_ty", "mbetynumber", "mb_test", "emb_ty", "emb_type", "mg_test", "emb_key", "mop_id", "mb_tag", "mbetyid", "mb_TYPE", "mbetyType", "mop_type", "mp_tag", "mblytest", "mb_value", "mb_Type", "mop_Type", "mglyTYPE", "mg_type", "mglyty", "mp_type", "mopetytype", "mop_number", "mbrictype", "mbrictest", "mp_value", "mopetyType", "mbricty", "mglytype", "mb_number", "mglytest", "mopetynumber", "mblyty", "mp_name", "mb_key", "mblytype", "mbricTYPE", "mb_id", "mopetyid"], "s": ["f", "ls", "is", "sl", "sts", "g", "rs", "sv", "as", "ins", "sw", "changes", "south", "a", "c", "sq", "xs", "js", "i", "ports", "shared", "os", "styles", "ss", "conv", "y", "ns", "ims", "sh", "u", "session", "spec", "e", "r", "ms", "ats", "l", "bs", "ts", "m", "sys", "its", "b", "v", "n", "parts", "mods", "sb", "stats", "ds", "qs", "less", "http", "an", "w", "S", "gs", "cs", "ssh", "ps", "t", "comm", "als", "fs", "hs", "j", "p"], "l1mv0": ["l1mvc1", "l1mvc10", "l1mq1", "l1Mv1", "l1Mv8", "l1mq8", "l1Mv0", "l1MV0", "l1mV8", "l1mV0", "l1mq0", "l1mV1", "l1mV10", "l1mvc0", "l1MV1", "l1mv10", "l1mvc8", "l1mq10", "l1Mv10", "l1MV8", "l1MV10", "l1mv8"], "l1mv1": ["l1mav2", "l1mp2", "l1mv01", "l1Mv1", "l1mV01", "l1Mv2", "l1Mv0", "l1MV0", "l1mav01", "l1mav1", "l1MV01", "l1mV0", "l1MV2", "l1mv2", "l1mV1", "l1MV1", "l1mV2", "l1mp0", "l1Mv01", "l1mp01", "l1mp1", "l1mav0"], "l1ref0": ["l1reference0", "l1mem2", "l3ref2", "l1mem3", "l1rel2", "l1ref2", "l3ref3", "l3reference0", "l3reference1", "l1mem1", "l3ref1", "l3reference2", "l1reference1", "l1reference3", "l1mem0", "l1rel0", "l1rel1", "l1reference2", "l1ref3", "l3ref0", "l1rel3", "l3reference3"], "l1ref1": ["l1reference0", "l1cache0", "l3rel0", "l3rel8", "l1cache2", "l3ref2", "l1cache1", "l1rel2", "l1ref2", "l3rel2", "l3ref1", "l1ref8", "l3ref8", "l1cache8", "l1reference1", "l1rel0", "l1rel1", "l1rel8", "l1reference2", "l3rel1", "l3ref0", "l1reference8"], "sub_mb_type": ["sub_MB_Type", "sub_emb_", "sub_MB_types", "sub_mb_", "sub_mb_mode", "sub_mbogType", "sub_MB_mode", "sub_db2", "sub_mbogmode", "sub_mb_Type", "sub_db_", "sub_mb_name", "sub_MB_type", "sub_mp_", "sub_mb_types", "sub_emb2", "sub_mb2", "sub_MB_name", "sub_mbogtypes", "sub_mbogtype", "sub_mp2"], "i8": ["ii6", "mi82", "ii16", "ii8", "mi16", "ii82", " i16", " i82", "i82", "i16", "mi6", " i6", "mi8", "i6"], "i4": ["i2", "I4", "ii8", "ii44", "I44", "ii4", "ii2", " i2", " i44", "i44", "I2", "I8"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        error_setg(errp, \"Image not in QED format\");\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        /* image uses unsupported feature bits */\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bdrv_get_device_name(bs), \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Round down file size to the last cluster */\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) /\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    /* Header size calculation must not overflow uint32_t */\n\n    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    /* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 17953, "substitutes": {"bs": ["ls", "is", "bb", "sts", "bh", "bits", "rs", "ubs", "bi", "outs", "ins", "asis", "BS", "js", "ads", "lbs", "os", "bp", "obs", "vs", "blog", "ns", "cb", "pb", "ubis", "ms", "ats", "ts", "sys", "its", "locks", "fps", "b", "bis", "bn", "sb", "bc", "ds", "bos", "ses", "bps", "aus", "bl", "gs", "bas", "bm", "bles", "cs", "boxes", "ps", "aos", "als", "fs", "hs", "bes", "es"], "options": ["opt", "config", "ptions", "ption", "fs", "ops", "settings", "properties", "values", "style", "params", "styles", "ts", "kw", "Options", "option", "features", "data", "stats", "vals", "keys", "scope", "tags", "meta", "details", "metadata", "es"], "flags": ["bits", "args", "settings", "mask", "properties", "ns", "kind", "ags", "types", "flag", "ms", "Flags", "ts", "mode", "FLAG", "fields", "cmd", "ds", "vals", "status", "files", "cs", "tags", "ps", "features", "fs"], "errp": ["iersp", "errpid", "rrp", " erP", "lerr", "rrr", "derp", " errsp", " errP", "ierP", "ierpb", " erp", "errorp", " erpp", "errsp", "lerp", "derpb", " errpb", "errps", " errps", "errpb", " errpid", "ierp", "errorpp", "lerps", "dersp", "errpp", " erpid", "errorpid", "lersp", "rrsp", "errorP", "errP", " errpp", "rrps", "errr", "derP", " errr"], "s": ["is", "as", "sn", "states", "fs", "a", "c", "h", "js", "y", "ies", "vs", "ims", "v", "ches", "stats", "qs", "ses", "less", "ers", "als", "terms", "bes", "bits", "aws", "sw", "ports", "orders", "ss", "ns", "events", "ms", "actions", "parts", "bis", "sports", "w", "S", "results", "cs", "rates", "hs", "p", "sl", "sts", "rs", "sq", "ares", "self", "os", "ess", "set", "l", "m", "locks", "sp", "sb", "ssl", "gs", "gets", "comm", "ys", "ls", "sv", "ins", "changes", "ions", "r", "ats", "ts", "sys", "its", "d", "b", "n", "tests", "ds", "sam", "ps", "t", "details", "j", "es"], "le_header": ["le_tag", "le_____header", "le_hash", "ile_cover", "le_Header", "le_info", "sle_comment", "leerlayer", "le_____Header", "le_peer", "leckinfo", "leerheader", "sle_layer", "ile_tag", "leckheader", "ile_header", "LE_hash", "LE_header", "le_cover", " le_info", "le_layer", "sle_peer", "leercomment", "leerpeer", "le_comment", "sle_header", "leckcomment", "LE_Header", "le_____hash", " le_comment"], "file_size": ["table_total", " file2size", "file_scale", "file_negative", " file_name", "fileXSIZE", "file9start", "file2ize", "image_size", "file9space", " file2sent", "file_rate", "file2name", "file_start", "table_offset", "ile_size", "file_sent", "file_space", "image_scale", "table_size", "file_name", "fileXnegative", "file2sent", " file_SIZE", " file_count", "ile_speed", "file64ize", "table_start", "fileXsize", "file_ize", " file_ize", "page_start", "image_SIZE", " file2ize", "ile_SIZE", " file_sent", "file64SIZE", "fileListspeed", "file_total", "fileListsize", "page_space", "page_rate", "filelistsize", "fileListmessage", "file9size", "file64count", "file_count", "fileListSIZE", "file64size", "fileliststart", "file_SIZE", "file_message", " file2name", "ile_message", "image_negative", "filelistoffset", "page_size", "file2size", "filelisttotal", "file9rate", "file_speed", "file_offset", "fileXscale"], "ret": ["rt", "ber", "reg", "jump", "end", "gt", "ref", "final", "result", "fail", " RET", "err", "lit", "rem", "def", "cont", "len", "tr", "res", "ben", "elt", "Return", "ll", "re", "flag", "resp", "RET", "Ret", "rev", "ter", "num", "value", " Ret", "out", "ft", "code", "inter", "reset", "git", "val", "rets", "print", "cmd", "x", "count", "alt", "mel", "deg", "status", "last", "fun", "nt", "try", "usr", "mt", "t", "ry"], "buf": ["text", "tmp", "pad", "cv", "ff", "box", "block", " buffer", "br", "cf", "ref", "result", "vec", "h", "iter", "tx", "err", "bar", "fb", "Buff", "tab", "xff", "buffer", "cap", "Buffer", "cp", "rb", "bytes", "doc", "img", "cb", "rw", "b", "row", "ctx", "var", "uf", "out", "txt", "str", "db", "data", "mem", "seq", "msg", "pool", "raw", "buff", "queue", "font"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_8w_msa(src - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 8);\n\n}\n", "idx": 17954, "substitutes": {"dst": ["Dest", " dST", "dbpt", "dsdest", "gST", "dssrc", "gst", "Ddest", " dsrc", "dsest", " ddest", "dbest", "dest", " dpt", "dbST", " dest", "dpt", "ddest", "gpt", "dbst", "Dst", "dST", "Dsrc", "gest", "dsrc", "dsst"], "src": ["rt", "sl", "ser", "th", "rs", "st", "ctr", "sn", "ind", "ins", "sec", "inc", "sq", "lat", "ipl", "rc", "rl", "usc", "dq", "sur", "sc", "comp", "in", "img", "sub", "dist", "loc", "np", "inst", "sr", "r", "ur", "sys", "now", "dest", "cc", "b", "hl", "sb", "s", "str", "desc", "cur", "RC", "supp", "source", "start", "addr", "input", "ptr", "rin"], "stride": ["shrride", "STRide", "strick", "slide", "strope", "streamide", "streamick", "sprie", "stringick", "shrice", " strope", "strice", "sprine", "slid", "shride", "STRice", " strade", "shrime", " strride", "trope", "spride", "drride", "strid", "dride", "sprope", " strides", "strime", "drid", "strade", "slade", " strick", "STRride", "slice", "slime", "stringide", "strride", " strie", "trie", "streamides", "strides", "streampe", "strie", "tride", "strpe", "STRime", " strpe", "strine", " strine", "slride", "stringpe", "stringides", "trine", " strid", "drade"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 17972, "substitutes": {"id": ["rid", "fd", "ID", "end", "iden", "du", " rid", "ad", "aid", "ip", "iv", " fid", "Id", "ids", "pid", "uid", "hid", "vid", "kid", " tid", "sid", "uri", " pid", "oid", "tag", "wid", "ident", "kill"], "backend": ["bookender", "audener", "backward", "audender", "Backener", "audend", "Backward", "throughender", "throughse", "backse", "Backse", " backward", "bookends", " backender", "backends", "bookward", "Backender", "backener", "Backends", "throughend", " backends", "Backend", "throughener", "bookend", "audse", "backender"], "ret": ["rt", "reg", "ref", "unt", "std", "lit", "des", "res", "kt", "re", "resp", "pet", "det", "rev", "Ret", "RET", "txt", "val", "rets", "et", "mem", "vt", "rm", "nt", "tor", "mt", "repl"], "errp": ["rrbp", " errping", "errping", "rrp", "rrping", "lerping", "err", " Errr", "lerbp", "lerp", "erps", "errps", " errps", " errbp", "lerps", " Errps", "errbp", " Errp", "erp", "rrps", "errr", " errr"], "opts": [" opTS", "opttes", "oppTS", " opjs", "opjs", "opte", "optts", " optes", "opfs", "iopjs", "iopTS", " opte", "prets", "preTS", "oppte", "oppts", "ioptes", "optes", "opTS", "prefs", " opfs", "optTS", "prete", "iopts", "oppfs", "optjs"], "filename": ["fd", "f", "nil", "ename", "FN", "kan", "nm", "original", "fp", "river", "title", "ames", "pen", "username", "ername", "fil", "src", "r", "m", "path", "txt", "v", "n", "o", "family", "stem", "Filename", "str", "prefix", "sid", "file", "output", "uri", "files", "w", "source", "til", "fn", "ame", "fs", "name", "p"], "chr": ["chreq", "chnran", "lookl", "cyr", "achrator", "achar", " cher", "chl", "echr", "chnadr", "chdr", "cherb", "Chr", "chadr", " chrt", "Char", " chrator", "chR", "cyrb", "chrc", "achl", "clsr", "acher", "Cher", "ochr", "chrb", "cheer", "cutrc", "ochrc", " chrb", "cutr", " chro", "cher", "achdr", "chresult", "schr", "chnl", "chero", "CHrc", "cutran", "lookresult", "chsr", "chnrc", "cutsr", "chereq", "cherrb", "cyl", "lookr", " chdr", "chrator", "chnr", " chrc", "achreq", "clr", "echrt", "chnsr", "echR", "Chl", "CHrt", " chl", " chresult", "cherreq", "chran", "CHr", "chnresult", "chel", "achro", "schrc", "chedr", " chadr", " chR", "ochrt", "cyrator", "chro", "ochdr", "clrc", "achr", "schrt", "chear", "CHdr", "chrt", "clran", "schR", "lookadr", "cherar", "echrc", "achrb", "cherr"], "s": ["ls", "is", "sts", "g", "sv", "rs", "ins", "as", "so", "sw", "a", "c", "h", "sq", "js", "i", "ss", "sc", "ns", "ims", "r", "e", "ats", "ts", "m", "sys", "es", "b", "v", "n", "bis", "space", "socket", "sb", "ds", "qs", "w", "S", "sam", "gs", "source", "cs", "ps", "t", "fs", "si", "p"]}}
{"project": "qemu", "commit_id": "7bbcb0afe715c36545bbbd872441c473927c1a4e", "target": 0, "func": "uint32_t HELPER(clz)(uint32_t x)\n\n{\n\n    int count;\n\n    for (count = 32; x; count--)\n\n        x >>= 1;\n\n    return count;\n\n}\n", "idx": 17981, "substitutes": {"x": ["f", "act", "zx", "bit", "xt", "ox", "tx", "c", "xi", "rx", "xs", "ex", "xy", " ax", "xff", "y", "xp", "fx", "xes", "p", "u", "wx", "max", "e", "check", " error", "checked", "zero", " tx", "ctx", "v", "ct", "ux", "xe", " xp", " cx", "xc", "ix", "xa", "number", "z", "xf", "xx", "t", " xx", "X", " ex"], "count": ["nb", "act", "length", "sum", "type", "all", "cache", "counter", "ctr", "ind", "result", "c", "C", "h", "ount", "err", "depth", "size", "self", "cloud", "child", "q", "cont", " possible", "flag", "found", "max", "Count", "match", " caught", "carry", "check", "cycle", "list", "d", "num", "index", "l", "v", "hold", "ct", " c", "force", "n", "code", "total", "out", "state", "val", "col", "loop", "number", "current", "nt", "ptr", "t", "hash", "z", "batch"]}}
{"project": "qemu", "commit_id": "96c9cff0ab986f3a0606e1a96c5b00e6a7c675c6", "target": 0, "func": "static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,\n\n                                       struct kvm_ppc_smmu_info *info)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    memset(info, 0, sizeof(*info));\n\n\n\n    /* We don't have the new KVM_PPC_GET_SMMU_INFO ioctl, so\n\n     * need to \"guess\" what the supported page sizes are.\n\n     *\n\n     * For that to work we make a few assumptions:\n\n     *\n\n     * - If KVM_CAP_PPC_GET_PVINFO is supported we are running \"PR\"\n\n     *   KVM which only supports 4K and 16M pages, but supports them\n\n     *   regardless of the backing store characteritics. We also don't\n\n     *   support 1T segments.\n\n     *\n\n     *   This is safe as if HV KVM ever supports that capability or PR\n\n     *   KVM grows supports for more page/segment sizes, those versions\n\n     *   will have implemented KVM_CAP_PPC_GET_SMMU_INFO and thus we\n\n     *   will not hit this fallback\n\n     *\n\n     * - Else we are running HV KVM. This means we only support page\n\n     *   sizes that fit in the backing store. Additionally we only\n\n     *   advertize 64K pages if the processor is ARCH 2.06 and we assume\n\n     *   P7 encodings for the SLB and hash table. Here too, we assume\n\n     *   support for any newer processor will mean a kernel that\n\n     *   implements KVM_CAP_PPC_GET_SMMU_INFO and thus doesn't hit\n\n     *   this fallback.\n\n     */\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO)) {\n\n        /* No flags */\n\n        info->flags = 0;\n\n        info->slb_size = 64;\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[0].page_shift = 12;\n\n        info->sps[0].slb_enc = 0;\n\n        info->sps[0].enc[0].page_shift = 12;\n\n        info->sps[0].enc[0].pte_enc = 0;\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[1].page_shift = 24;\n\n        info->sps[1].slb_enc = SLB_VSID_L;\n\n        info->sps[1].enc[0].page_shift = 24;\n\n        info->sps[1].enc[0].pte_enc = 0;\n\n    } else {\n\n        int i = 0;\n\n\n\n        /* HV KVM has backing store size restrictions */\n\n        info->flags = KVM_PPC_PAGE_SIZES_REAL;\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            info->flags |= KVM_PPC_1T_SEGMENTS;\n\n        }\n\n\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->slb_size = 32;\n\n        } else {\n\n            info->slb_size = 64;\n\n        }\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[i].page_shift = 12;\n\n        info->sps[i].slb_enc = 0;\n\n        info->sps[i].enc[0].page_shift = 12;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n        i++;\n\n\n\n        /* 64K on MMU 2.06 and later */\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->sps[i].page_shift = 16;\n\n            info->sps[i].slb_enc = 0x110;\n\n            info->sps[i].enc[0].page_shift = 16;\n\n            info->sps[i].enc[0].pte_enc = 1;\n\n            i++;\n\n        }\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[i].page_shift = 24;\n\n        info->sps[i].slb_enc = SLB_VSID_L;\n\n        info->sps[i].enc[0].page_shift = 24;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n    }\n\n}\n", "idx": 18015, "substitutes": {"cpu": ["proc", "CPU", "arch", "boot", "conn", "processor", "hw", "clock", "c", "nic", "upt", "anc", "linux", "ck", "chip", "cp", "ork", "sc", "np", "gc", "pp", "hz", "mu", "cu", "pc", "nc", "sys", "pid", "cc", "vm", "ctx", "o", "core", "alloc", "cow", "aco", "phys", "gpu", "mem", "ec", "mac", "node", "process", "pu", "tp", "p"], "info": ["cache", "init", "content", "def", "ip", "debug", "event", "check", "query", "message", "o", "time", "where", "trace", "link", "stats", "http", "mem", "status", "auth", "buff", "command", "dict", "api", "show", "information", "f", "entry", "warning", "iter", "report", "ret", "json", "ro", "Info", "obj", "function", "now", "index", "summary", "off", "row", "state", "comment", "notice", "success", "w", "iso", "conf", "admin", "name", "to", "sum", "response", "create", "result", "update", "user", "err", "good", "buffer", "error", "version", "io", "by", "help", "options", "txt", "about", "force", "history", "ti", "image", "try", "inf", "si", "type", "label", "parse", "config", "ref", "ion", "reason", "fee", "copy", "lock", "doc", "note", "request", "list", "value", "num", "import", "id", "local", "rule", "INFO", "app", "description", "fi", "data", "translation", "it", "op", "start", "fo", "t", "details", "edit"], "env": ["org", "cv", "er", "init", "stage", "kernel", "forge", "vs", "e", "query", "project", "ctx", "v", "req", "gen", "proc", "act", "equ", "hw", "ef", "eh", "serv", "cp", "net", "obj", "ev", "esp", "context", "ce", "environment", "cmd", "nv", "inv", "pe", "dev", "esc", "exc", "conf", "window", "ext", "end", "eco", "en", "conn", "manager", "enter", "engine", "enc", "buf", "ah", "eu", "here", "era", "ve", "eve", "desc", "next", "cur", "ptr", "config", "shell", "worker", "ench", "server", "nc", "con", "den", "network", "owner", "priv", "operator", "ew", "app", "web", "et", "door", "ec", "eng", "outer"], "cs": ["proc", "ls", "cf", "sts", "ks", "rs", "c", "cus", "js", "ck", "css", "os", "cp", "sc", "vs", "ns", "spec", "tc", "ac", "pc", "CS", "Cs", "sys", "ts", "cc", "acs", "ctx", "cms", "wcs", "s", "cks", "ds", "ec", "ys", "ps", "bs", "fs", "hs"], "i": ["iri", "init", "y", "ip", "ami", " ii", "iii", "e", "v", "I", "ii", "phi", "status", " j", "hi", "t", "f", "_", "C", "iy", "ui", "pi", "im", "index", "mi", "multi", "gi", "ind", "xi", "cli", "ai", "li", "iu", "ci", "sim", "m", "me", "ti", "x", "uri", "try", "ij", "si", "batch", "bi", "func", "ic", "in", "list", "ji", "id", "ei", "slice", "ix", "di", "exec", "it", "ini", "j"]}}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n", "idx": 18020, "substitutes": {"shift": ["pull", "pad", "window", "length", "offset", "ctr", "push", "delete", "size", "scale", "shr", "power", "align", "set", "hift", "move", "Shift", "sleep", "index", "off", "down", "back", "send", "reset", "ix", "pop", "count", "next", "save", "start", "ptr", "sh", "add", "sup"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n", "idx": 18038, "substitutes": {"bh": ["ih", "bb", " inh", "ht", "br", "hw", "bj", "hh", "h", "ash", "rh", "hs", "hal", "bp", "sbm", "ish", "phy", "hab", "hz", "osh", "orth", "pb", "ah", "dh", "bsp", "kh", "oth", "bec", "hub", "bis", "bn", "bash", "hl", "phi", "bang", "lb", "bt", "hap", "bl", "bol", "zh", "bf", "FH", "bs", "sh", "bo", "gh"], "ctx": ["tmp", "cf", "act", "cv", "conn", "Context", "pkg", "hw", "jp", "tx", "c", "ca", "cm", "anc", "parent", "ck", "func", "mc", "q", "cp", "sc", "jac", "np", "go", "obj", "loc", "cb", "ns", "gc", "wx", "tc", "unc", "handle", "kt", "cu", "buf", "ac", "nc", "index", "cc", "kw", "cl", "kh", "ct", "pa", "txt", "bc", "context", "kb", "cmd", "ctrl", "req", "cur", "mem", "msg", "nt", "scope", "cmp", "co", "cfg", "dc", "timeout", "p"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)\n\n{\n\n    SpiceTimer *timer;\n\n\n\n    timer = qemu_mallocz(sizeof(*timer));\n\n    timer->timer = qemu_new_timer(rt_clock, func, opaque);\n\n    QTAILQ_INSERT_TAIL(&timers, timer, next);\n\n    return timer;\n\n}\n", "idx": 18044, "substitutes": {"func": ["proc", "f", "new", "cf", "lc", "act", "from", "attr", "lambda", "c", "fac", " fun", "fc", "callback", "conv", "util", "obj", "cb", "unc", "tc", "function", "cast", "Function", "ac", "vol", "nc", "apply", "con", "sys", "kw", "b", "ctx", "FC", "data", "task", "fun", "inv", "aux", "fn", "fs", "cond", "job"], "opaque": ["oplay", "Opque", "ipque", "opacity", "operaque", " opque", "oblay", "obaque", " opaques", "obacity", "opque", " opacity", "operubis", "operlay", "Opaques", "opubis", "Opaque", " opubis", "operacity", "ipaque", "oplucent", "Oplucent", "ipaques", "obubis", " oplay", " oplucent", "iplucent", "opaques"], "timer": ["hr", "Timer", "er", "counter", "cer", "memory", "pointer", "duration", "event", "table", "monitor", "env", "time", " tc", "erer", "span", "mem", "imer", "seconds", "rer", "offer", "tp", "new", "taker", "nm", "clock", "iter", "temp", "inner", "cb", "tim", "handler", "context", "usr", "trigger", " td", "tmp", "tm", "window", "ser", "mr", "result", "peer", "older", "term", "manager", "buffer", "dim", "tc", "meter", "txt", "minute", "loader", "instance", "task", "tick", "vt", "ptr", "attr", "runner", "processor", "tn", "ctr", "uler", "final", "icker", "worker", "ender", "thread", "tr", "player", "actor", "item", "ter", "num", "writer", " meter", "tv", "mint", "ger", "outer", "tree", "ramer", "t", "timeout"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n", "idx": 18067, "substitutes": {"proxy": ["profile", "cache", "ref", "connection", "ion", "bus", "native", "interface", "roxy", "linux", "service", "parent", "clone", "port", "manager", "slave", "server", "version", "shadow", "device", "ip", "phy", "target", "Proxy", "remote", "driver", "reference", "network", "ping", "client", "v", "gate", "super", "socket", "pin", "wrapper", "cas", "x", "link", "node", "module", "source", "pse", "p"], "queue_no": ["queue_number", "queue2number", " queue_eno", "queue08no", " queue_number", " queue_No", "queue08eno", "queue_index", "queue_eno", "queue_No", "queue08No", "que_no", "queueingno", "que_No", "queue08number", "queue2No", "que_number", "queueingNo", "queueingindex", "que_index", "queueingnumber", "queue2no", "queue2eno"], "vector": [" sensor", "alias", " vec", " random", "random", "sv", "counter", "vec", " multiplier", "point", " index", " template", "xy", "iterator", "i", "seed", "manager", " v", " matrix", " counter", "version", "server", "V", " serial", " tv", " Vector", "sequence", "query", "message", "ctors", "series", "vi", "ector", " version", "row", "v", "template", " sequence", " dimension", "Vector", "ve", "ther", "feature", "VID", " vectors", "tv", "transform", "serial", "token", "t", "hello", " mosquito", "normal"], "msg": ["new", "get", "g", "vec", "Message", "reason", "err", "gp", "info", " message", "mag", "mg", "q", "essage", "y", "sg", "Msg", "event", "ms", "message", "m", "txt", "v", "gz", "mat", "out", "gm", "state", "cmd", "data", "phys", "req", "mem", "node", "command", "gs", "ch", "conf", "cfg", "j", "p"], "vq": [" vch", "viqueue", "vrock", "quq", "vqq", "vcl", "vich", " vock", "vrqueue", " vsq", "svqueue", "veque", "vch", "vicl", "svcl", "vequeue", " vqueue", " vque", "qq", " vqq", "viq", "qup", "qp", "vque", "vock", " vp", "svq", "vrq", "vrque", "qusq", "qqq", " vcl", "vqueue", "quqq", "veq", "veock", "qsq", "svch", "vsq", "vp"], "n": ["nb", "f", "ne", "g", "nm", "na", "sn", "cn", "c", "nr", "i", "nl", "nn", "np", "ns", "u", "r", "nor", "l", "nc", "m", "d", "nw", "v", "k", "o", "mn", "nu", "nv", "an", "w", "nt", "node", "N", "fn", "j", "p"], "irqfd": ["irqqflag", "irqualpd", "pirqdir", "irqfc", "irqdef", "irqualden", "iorqueryfun", "iorqtfd", "irquedef", "irquedb", "iorqueryfd", "irqueryfd", "irqdir", "virqfd", "irwikfd", "iroqfd", "pirqdb", "irchargefc", "irqden", "irchargepd", "pirqfd", "iorqfc", "irchargedef", "irqdisk", "irqusflag", "iorqf", "irdqdb", "irwikf", "irqflo", "irqadd", "virquestdf", "irdqpid", "irqueud", "irwikfc", "IRqqflo", "irqqdb", "irqueryud", "irquestfc", "irchargedisk", "iorqueryf", "iorqtdisk", "iroquefc", "irquestfd", "irqqdf", "IRqdb", "irqfun", "irqufd", "iroqdef", "IRqqfd", "irqpd", "irqafd", "IRqpid", "irqtpd", "irquefc", "arqflag", "iorqfun", "iriqfd", "irquestdb", "irsqfd", "irqqdir", "irsqdb", "irqusld", "irqqfd", "arqqflag", "piriqdd", "iorqfd", "pirqdd", "irwikfun", "iorqdisk", "piriqdir", "arqqld", "irqpid", "IRqflo", "virqfc", "irqusfd", "irdqflo", "arqfc", "irqtfd", "irchargeud", "IRqqdb", "irquepid", "irsqdf", "iriqdir", "irquefd", "iroquedef", "iorqueryfc", "arqqfd", "irqusfc", "iriqdb", "irqadir", "irqadb", "irchargeden", "iorqpd", "iroqueud", "irqdb", "iorqtden", "piriqdb", "iriqdd", "irqdf", "arqld", "irqualfd", "irqqflo", "virquestfd", "irqueryfun", "IRqfd", "irquflag", "irqld", "irqtden", "irdqfd", "iorqtpd", "irsqfc", "irqueflo", "irqflag", "irqqf", "piriqfd", "irqueryf", "irqqpid", "virqdb", "iroqud", "irqueryfc", "irqtdisk", "irqualdisk", "irqqfc", "IRqqpid", "irqufc", "irqf", "irqdd", "virqdf", "irchargefd", "irquld", "arqfd", "arqqfc", "iorqden", "virquestdb", "iroqfc", "iroquefd", "irquestdf", "virquestfc", "irquerydef", "irqqld", "irqud", "irqqdd", "irqqfun"], "ret": ["prop", " RET", "def", "ben", "det", "RET", "out", "val", "print", "reflect", "mem", "deg", "status", "rm", "mb", "reply", "hash", "rest", "reg", "gt", "iter", "lit", "report", "rem", "dt", "len", " fut", "re", "back", " Ret", "ft", "success", "mber", "fun", "nt", "mt", "red", "ry", "ber", "ext", "end", "result", "err", "del", "elt", "ll", "flag", "arg", "resp", "tf", "vet", "txt", "cert", "git", "rets", "desc", "last", "dr", "try", "pret", "ptr", "repl", "rt", "ref", "final", " alt", "tr", "res", "att", "arr", "rev", "Ret", "ter", "value", " retire", "nz", "reset", "alt", "t"], "users": ["drivers", "modules", "masters", "bugs", "jobs", "parents", "authors", "states", "people", "lists", "user", "versions", "videos", "names", "players", "heads", "workers", "units", "mails", "docs", "classes", "rows", "ids", "years", "headers", "members", "vers", "userc", " Users", "uploads", "devices", "packages", "holders", "plugins", "groups", "files", "owners", "keys", "dates", "Users", "items", "resources"]}}
{"project": "FFmpeg", "commit_id": "ddd86a2924b9bc67c406cd66ebb1fc8915cd60f7", "target": 1, "func": "static int output_packet(InputStream *ist,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    }\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_ostreams; i++) {\n\n        OutputStream *ost = &ost_table[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18077, "substitutes": {"ist": ["irm", "is", "meet", "ard", "ik", "iest", "estate", "pect", "exist", "pir", "iana", "store", "isi", "iat", "inst", "artist", "work", "wp", "ith", "hist", "ast", "igh", "pop", "art", "ict", "supp", "typ", "assert", "act", "st", "isting", "reat", "empt", "hw", "isted", "istant", "ilst", "elist", "ift", "dist", "ister", "ird", "tip", "lect", "wikipedia", "htt", "arde", "usr", "iz", "ld", "irst", "ht", "ief", "ext", "ire", "ind", "ism", "iw", "ert", "ess", "pt", "alist", "rust", "dit", "ust", "iop", "isd", "ists", "ij", "isen", "istar", "xt", "ont", "rank", "spect", "istically", "ush", "pick", "pas", "xp", "att", "ick", "istance", "istor", "est", "ort", "sys", "its", "dd", "IST", "ix", "et", "erd", "ista", "il", "iste", "each"], "ost_table": ["ostetstack", "ostrostack", "ostlaypool", "ort_table", "ostetlist", "ostlaystack", "ostrolist", "ostlaytable", "ortetlist", "ortetpool", "ost_list", "ort_list", "ostetpool", "ostlaylist", "ostettable", "ort_stack", "ost_stack", "ortetstack", "ostrotable", "ost_pool", "ortettable", "ort_pool", "ostropool"], "nb_ostreams": ["nb_ostreamds", "nb_istreamts", "nb_istreams", "nb_oststreams", "nb_iststreamts", "nb_ostreamts", "nb_ostlogls", "nb_ostlogs", "nb_oststreamts", "nb_ostlogts", "nb_ostsubds", "nb_oststreamls", "nb_ostreamls", "nb_ostsubts", "nb_ostsubls", "nb_istreamls", "nb_ostsubs", "nb_iststreams", "nb_iststreamls", "nb_iststreamds", "nb_istreamds", "nb_ostlogds", "nb_oststreamds"], "pkt": ["pdt", "pwk", "cpet", "ckat", "apshot", " pkat", " pdt", "pcnt", "pvc", "spwk", "pingacket", " pett", "respkat", "cpkg", "vpkl", "pingkt", " pet", "pett", "payacket", "opet", "ppkt", "pingvc", " pqt", "pckg", "Pshot", "patchett", "pkat", "apkg", "respkt", " pmsg", " pvc", "dwt", "ckt", "pdu", "apqt", "respacket", "vpkg", "paymsg", "dacket", "Pct", "pcwk", "Packet", "pqt", "pmsg", "pshot", "phpkg", "patchacket", "cpett", "pct", "vpkt", " pnt", "pckl", " pdu", "ppdu", "pkg", "Pkt", "pkl", "Pdu", "patchkt", "pckt", "apdt", "spacket", "pet", "respct", "spkt", "vpacket", "ppshot", " packet", "patchwt", "packet", "ppnt", "Pvc", "pwt", " pct", "phpacket", "phpkt", "apacket", "cct", "ppacket", "cpwk", "cpct", "ppwk", "opacket", "dkt", "paykt", "opdu", "cpdu", "cacket", "spett", "opkt", "pingct", " pwk", "cpdt", "apdu", "pcacket", "cpacket", "apmsg", " pkg", " pwt", "phpkl", "apkt", "payqt", "cpkt", "dett", "pnt"], "i": ["f", "g", "bi", "ind", "xi", "info", "pi", "iu", "im", "ci", "m", "index", "id", "b", "I", "n", "ii", "ti", "fi", "ix", "x", "mi", "ij", "t", "j", "si", "p"], "got_output": ["handledallwrite", "got_write", "handled_output", "got_bool", "gotalloutput", "handledalloutput", " got_Output", "got___put", "handled_write", "got___output", "handled_bool", " got_put", "handledallbool", "handledalldigital", "got_digital", "gotalldigital", "got___Output", "got_Output", "got_put", "handled_digital", "gotallbool", "gotallwrite"], "avpkt": ["avepkl", "cappet", "cappakt", "auxnkg", "craftpdu", "avmcmd", "avjpkg", " avcpck", "craftpdt", "avnpkl", "avpkl", "cappanet", "avapcmd", "avopkl", "avjptt", "wavnpwk", "avapkt", "cappacket", "avptt", "avcpct", "avdpet", "avapkl", "avnpck", "avdkt", "avipkt", "avepet", "avecacket", "avnpvt", "avepkt", " avcpkt", "auxnacket", "avpct", "avpnet", "avpbct", "avpvt", "avwpkl", "avdpkt", "wavnpkl", "craftpkt", "avwpkt", "avenpacket", "avdpkl", "avpcmd", "avcpvt", "aveopcmd", "avckt", "craftpadt", "aveckg", "avnpacket", "avnpchan", "avepchan", "avnkg", "wavpkt", "avpakt", "avcacket", "avopet", "avcpck", "avdkl", "avtpet", "aveptt", "avpbacket", "auxncmd", "avtpkt", "avtpnet", "cappaacket", "auxpkt", "wavnpkt", "wavpacket", "cappnet", "avmct", "avdpcmd", "avpet", "avtpdt", "cappkt", "avtpdu", "aveopkl", "auxpkg", "avpaet", "avenpchan", "avpacket", "avnpdu", "craftpadu", "avcpkt", "avckg", " avpct", "auxpcmd", "avnkt", "avcpchan", "aveopkt", "craftpaacket", "avnpkt", "avpdu", "craftpacket", " avpck", "avjpkt", "avwpet", "avnpdt", "avopacket", "avpchan", "avapkg", "avdacket", " avcpvt", "avnpwk", "wavnpacket", "avectt", "avnacket", "avpadt", "avipkg", " avpvt", "avepct", "wavpwk", "avmkt", "avpdt", "avnpct", "avepacket", "avjpacket", "aviptt", "avpkg", "aveopet", "wavpkl", "avncmd", "auxnkt", "auxpacket", "aveckt", "avpadu", "avopcmd", "avopnet", "avdwk", "avwpcmd", " avcpct", "avapacket", "avpwk", "avpaacket", "avtpacket", "avpck", "avpanet", "cappaet", "avcpacket", "avpbkt", "avctt", "avipacket", "avenpkt", "avpbchan", "craftpakt", "avmkg", "avmvt", "avmck", "avepkg", "avenpct", "avepcmd", "avmacket", "avapwk", "avopkt"], "duration": [" timeout", "f", "done", " loop", "run", " wait", "result", "err", "true", "repeat", " resp", "set", " begin", "resp", "progress", "time", "val", "wait", "alt", "begin", "no", "stop", "rest", "timeout", "ry"]}}
{"project": "FFmpeg", "commit_id": "af2ee6fc4921a81133c0915985e05781505c2ff8", "target": 0, "func": "static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n\n                                       SingleChannelElement *sce,\n\n                                       const float lambda)\n\n{\n\n    int q, w, w2, g, start = 0;\n\n    int i, j;\n\n    int idx;\n\n    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];\n\n    int bandaddr[TRELLIS_STAGES];\n\n    int minq;\n\n    float mincost;\n\n    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;\n\n    int q0, q1, qcnt = 0;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        float t = fabsf(sce->coeffs[i]);\n\n        if (t > 0.0f) {\n\n            q0f = FFMIN(q0f, t);\n\n            q1f = FFMAX(q1f, t);\n\n            qnrgf += t*t;\n\n            qcnt++;\n\n        }\n\n    }\n\n\n\n    if (!qcnt) {\n\n        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n\n        memset(sce->zeroes, 1, sizeof(sce->zeroes));\n\n        return;\n\n    }\n\n\n\n    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n    q0 = av_clip_uint8(log2(q0f)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n    q1 = av_clip_uint8(log2(q1f)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n    if (q1 - q0 > 60) {\n\n        int q0low  = q0;\n\n        int q1high = q1;\n\n        //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped\n\n        int qnrg = av_clip_uint8(log2(sqrt(qnrgf/qcnt))*4 - 31 + SCALE_ONE_POS - SCALE_DIV_512);\n\n        q1 = qnrg + 30;\n\n        q0 = qnrg - 30;\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n        if (q0 < q0low) {\n\n            q1 += q0low - q0;\n\n            q0  = q0low;\n\n        } else if (q1 > q1high) {\n\n            q0 -= q1 - q1high;\n\n            q1  = q1high;\n\n        }\n\n    }\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n\n\n    for (i = 0; i < TRELLIS_STATES; i++) {\n\n        paths[0][i].cost    = 0.0f;\n\n        paths[0][i].prev    = -1;\n\n    }\n\n    for (j = 1; j < TRELLIS_STAGES; j++) {\n\n        for (i = 0; i < TRELLIS_STATES; i++) {\n\n            paths[j][i].cost    = INFINITY;\n\n            paths[j][i].prev    = -2;\n\n        }\n\n    }\n\n    idx = 1;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {\n\n        start = w*128;\n\n        for (g = 0; g < sce->ics.num_swb; g++) {\n\n            const float *coefs = sce->coeffs + start;\n\n            float qmin, qmax;\n\n            int nz = 0;\n\n\n\n            bandaddr[idx] = w * 16 + g;\n\n            qmin = INT_MAX;\n\n            qmax = 0.0f;\n\n            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                if (band->energy <= band->threshold || band->threshold == 0.0f) {\n\n                    sce->zeroes[(w+w2)*16+g] = 1;\n\n                    continue;\n\n                }\n\n                sce->zeroes[(w+w2)*16+g] = 0;\n\n                nz = 1;\n\n                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {\n\n                    float t = fabsf(coefs[w2*128+i]);\n\n                    if (t > 0.0f)\n\n                        qmin = FFMIN(qmin, t);\n\n                    qmax = FFMAX(qmax, t);\n\n                }\n\n            }\n\n            if (nz) {\n\n                int minscale, maxscale;\n\n                float minrd = INFINITY;\n\n                //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n                minscale = av_clip_uint8(log2(qmin)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n                maxscale = av_clip_uint8(log2(qmax)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);\n\n                maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);\n\n                for (q = minscale; q < maxscale; q++) {\n\n                    float dist = 0;\n\n                    int cb = find_min_book(sce->sf_idx[w*16+g], sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);\n\n                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                        FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                        dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],\n\n                                                            q + q0, cb, lambda / band->threshold, INFINITY, NULL);\n\n                    }\n\n                    minrd = FFMIN(minrd, dist);\n\n\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + dist\n\n                               + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                for (q = 0; q < q1 - q0; q++) {\n\n                    if (!isinf(paths[idx - 1][q].cost)) {\n\n                        paths[idx][q].cost = paths[idx - 1][q].cost + 1;\n\n                        paths[idx][q].prev = q;\n\n                        continue;\n\n                    }\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            sce->zeroes[w*16+g] = !nz;\n\n            start += sce->ics.swb_sizes[g];\n\n            idx++;\n\n        }\n\n    }\n\n    idx--;\n\n    mincost = paths[idx][0].cost;\n\n    minq    = 0;\n\n    for (i = 1; i < TRELLIS_STATES; i++) {\n\n        if (paths[idx][i].cost < mincost) {\n\n            mincost = paths[idx][i].cost;\n\n            minq = i;\n\n        }\n\n    }\n\n    while (idx) {\n\n        sce->sf_idx[bandaddr[idx]] = minq + q0;\n\n        minq = paths[idx][minq].prev;\n\n        idx--;\n\n    }\n\n    //set the same quantizers inside window groups\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])\n\n        for (g = 0;  g < sce->ics.num_swb; g++)\n\n            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)\n\n                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];\n\n}\n", "idx": 18095, "substitutes": {"avctx": ["avcp", "AVctx", "averctx", "avercp", "AVsc", "aversc", "avercontext", "avcontext", "AVcp", "AVcontext", " avsc", " avcp", "avsc", " avcontext"], "s": ["is", "rs", "a", "c", "h", "sq", "js", "os", "ss", "sg", "ns", "e", "ats", "m", "es", "v", "sb", "ds", "S", "gs", "cs", "ps", "fs", "p"], "sce": ["desces", "desce", "cced", "statscle", "escent", "csck", "sces", "Ske", "sck", "scer", "asced", "psced", "Sced", "nsced", " sced", "oscle", "secing", "cces", "nske", "despe", "scle", "desced", "nspe", "statscer", " spe", "statsced", "csce", "cscent", "sece", "scing", "asce", "jsce", " sCE", "sse", "aske", "pscle", "statsce", "cscing", " sces", " ske", "aspe", "esck", "osced", "secent", "jsces", "oscer", "esce", "sCE", "nsce", "sced", "jsse", " sse", "Spe", "SCE", "cpe", "psce", "osce", "ske", "seck", "jsCE", "Sse", "Sces", "Sce", "escing", "spe", "pscer", "cce", "scent"], "lambda": ["appa", "igma", " func", " df", "ta", " foo", " dw", " delta", " dx", " mu", " sig", "mu", "da", " omega", "function", " gamma", " beta", "weights", "alpha", "phi", "beta", " formula", "pha", " bandwidth", " alpha", "bf", "xf", " lam"], "q": ["f", "qa", "c", "sq", "qu", "Q", "mp", "dq", "ue", "ql", "ig", "qt", "aq", "qi", "qq", "u", "e", "query", "m", "v", "ix", "iq", "t", "z", "p"], "w": ["window", "h", "wd", "wb", "win", "wx", "r", "wi", "rw", "wp", "m", "nw", "kw", "v", "n", "wl", "wa", "weight", "x", "fw", "W", "wt", "z", "p"], "w2": ["width02", " w02", "v3", "v2", "v02", "width3", "w3", "w02", " w4", " w3", "v4", "width2", "width4", "w4"], "g": ["gain", "gt", "gi", "tg", "c", "gp", "ge", "mg", "p", "gc", "go", "group", "m", "gz", "v", "b", "n", "bg", "gm", "pg", "G", "gg", "msg", "gen", "gs", "ga"], "i": ["is", "bi", "gi", "counter", "chain", "h", "c", "ri", "xi", "ki", "ex", "cli", "ai", "info", "oi", "name", "li", "ic", "ui", "ip", "in", "\u0438", "pi", "iu", "u", "im", "e", "zi", "ci", "l", "sim", "m", "asi", "id", "index", "me", "ji", "b", "v", "I", "o", "ii", "ti", "ei", "print", "phi", "ix", "x", "status", "di", "it", "mi", "ij", "ini", "multi", "z", "si", "p"], "j": ["jl", "jump", "J", "bi", "jp", "c", "js", "pos", "jj", "aj", "r", "l", "m", "ji", "index", "b", "v", "k", "n", "o", "ii", "uj", "ij", "z", "p"], "idx": ["idex", "idexs", "idxs", "idei", "midz", "midxs", "midi", "idi", "idez", " idz", "idz", " idi", " idxs", "midx"], "paths": ["threadss", "systemds", "threads", "threadids", "systems", "pathds", "systemids", "threadds", "systemss", "dirids", "pathids", "dirds", "dirs", "pathss", "dirss"], "TRELLIS_STAGES": ["TRELLIS_StATES", "TRELLIS_stATES", "TRELLIS_StAGES", "TRELLIS_stARS", "TRELLIS_INSTATES", "TRELLIS_StAGE", "TRELLIS_StARS", "TRELLIS_CARS", "TRELLIS_INSTages", "TRELLIS_CAGE", "TRELLIS_INSTAGES", "TRELLIS_STAGE", "TRELLIS_STARS", "TRELLIS_stAGES", "TRELLIS_CATES", "TRELLIS_Cages", "TRELLIS_INSTAGE", "TRELLIS_stAGE", "TRELLIS_Stages", "TRELLIS_CAGES", "TRELLIS_STages", "TRELLIS_STATES"], "bandaddr": ["bandaddress", "bindAddress", "baddr", "BandAddress", "bAddress", "bindaddress", "baddress", "bandAddress", "bindaddr", "boffset", "bindoffset", "Bandaddr", "Bandoffset", "Bandaddress", "bandoffset"], "minq": [" minQ", "maxq", "minimumq", "minqt", "maxqt", " minf", "minimumqt", " minqt", "minimumf", "minf", "maxQ", "maxf", "minQ", "minimumQ"], "mincost": ["modst", "minCost", "minimumcost", "modCost", "minimumCost", "minr", " minst", "modr", " minr", "minst", "modcost", " minCost", "minimumst", "minimumr"], "q0": [" qor", "qu1", "Qk", "requ0", "query0", "quk", "q10", "quzero", "quor", "sq0", "dq5", "qu5", "dq0", "questzero", "qu4", "q4", "requ1", "dqor", "iqzero", "iq0", "Q0", "qi1", "qu0", "quest00", "sq00", "query00", "sq5", "qarg", "Q2", "queu", "query10", "q5", " q00", "sq4", " q2", "qi0", "qk", "lock0", "qzero", "qu2", "sq1", "dq4", "qieu", " q10", "dq1", "qq2", "dqeu", "dq10", "dqarg", "q00", "lock1", "qu10", "Q1", "queryzero", "quest10", "requ4", "qor", "sqarg", "iq1", "qi00", "q2", "dq00", "dqzero", "qq0", "quest0", "qqk", "requ00", "lock00", " qzero", "lock10", "iq4", "quarg", "qu00", "dq2", "qq1", "qeu"], "q1": [" q11", " q2", "iqone", "iqr", " q4", "iq0", "iq1", "qu1", "qq3", "qu2", "quone", "qu3", "qq11", "qOne", "q2", "quest4", "dq4", "qu0", "quest1", " qone", "dq01", "dq1", "qqone", "qu11", "dq3", "qq2", "qur", "qq0", "qr", "quest0", "dq11", "quest01", "qu01", "dq0", "qone", "dq2", "quest11", "dqr", "q11", "dqOne", "qq1", "iqOne", "iq2", "questone", "q3", "qu4", "q4", "q01", " qOne", " q3", "quOne", "dqone"], "qcnt": [" qncnt", "thinkcctr", "qCount", "ncct", "nncount", "qncct", "qrcnc", "nncct", "quncnc", "qcrcount", "qncnc", " qcNT", "quncct", "qcountNT", "qcount", "qncnt", "thinkncct", "thinknccount", "nncnc", "qcrnt", "qcountount", "qnount", "qccount", "thinkncnt", "qcpt", "qcNT", "qrcnt", "eqcrowd", "quncount", "qcrowd", "thinkncctr", "qcctr", " qcnc", "eqcount", "eqcnt", "qCnt", "quncnt", "qcrct", "eqnrowd", " qcount", "qCnc", "qncNT", "ncnt", "qlcrowd", "qrct", "qcountnt", "thinkccount", " qncNT", "qncount", "eqnount", "qrcount", "qcnc", "thinkcct", " qncnc", "eqnpt", "qrnt", "qnrowd", "eqnnt", "ncnc", "qlcpt", "qlcount", "qnpt", "qcountnc", "ncount", "qCNT", "qcrctr", "eqcpt", "qrcct", "qrctr", "qcountrowd", "qcct", "qnnt", "qlcnt", " qncount", "qncctr", "nncnt", "thinkcnt", "qnccount", "qcountpt"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    /* Add footer to total size */\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 18138, "substitutes": {"fd": ["f", "ff", "fl", " df", "dra", "hd", "fp", "fs", "cond", "ind", "df", "wd", "ino", "fb", "fc", "lf", "dl", "sta", "ed", "ud", "ad", "fr", "fin", " fid", "elt", "sd", "unc", "dat", "handle", "form", "dir", "handler", "da", "pid", "d", "fa", "FD", "fm", "ctl", "dd", "fi", "db", "ds", "cod", "ln", "fat", " ff", "bf", "ptr", "fn", "dev", "rd", "ld", " td", "fed"], "buf": ["tmp", "cv", "bb", "block", "ref", "pkg", "map", "vec", "wb", "err", "fb", "bar", "Buff", "tab", "buffer", "cap", "Buffer", "rb", "bytes", "doc", "bag", "cb", "pb", "orig", "kw", "b", "v", "txt", "uf", "bc", "cmd", "data", "seq", "w", "msg", "raw", "buff", "bf", "pack", "queue", "p"], "total_size": ["totalJcount", "Total_Size", "totalJsize", " total_mem", "totalJSIZE", " total_count", "totalJmem", "total_mem", "totalTimetype", "total_count", "Total_SIZE", "total_SIZE", "totalTimeSIZE", "total_type", "totalTimesize", " total_type", "Total_size", " total_SIZE", "total_Size"]}}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n", "idx": 18142, "substitutes": {"ctx": ["tmp", "px", "conn", "Context", "pkg", "tx", "wd", "ca", "xs", "fc", "anc", "setup", "fx", "obj", "cb", "unc", "tc", "handle", "kw", "cc", "ct", " cx", "bc", "xc", "context", "cmd", "mem", "cmp", " context"], "fs": ["f", "fd", "ls", "cf", "rs", "tx", "df", "fc", "os", "obs", "fx", "FS", "vs", "ns", "ims", "ms", "sys", "ts", "fps", "cms", "Fs", "irs", "s", "sf", "file", "ds", "less", "fw", "files", "gs", "bf", "cs", "ps", "bs", "hs"], "entry": ["rent", "cell", "ind", "search", "def", "attribute", "obj", "event", "ary", "spec", "item", "match", "form", "import", "index", "row", "record", "se", "inter", "key", "instance", "cue", "data", "desc", "file", "ent", "ie", "image", "command", "try", "ptr", "quick", "ident", "Entry", "ror", "ry"], "result": ["new", "profile", "block", "end", "cache", "Result", "final", "page", "complete", "test", "nr", "report", "valid", "ret", "json", "buffer", "true", "su", "tr", "res", "event", "r", "dir", "table", "buf", "row", "record", "join", "out", "comment", "description", "data", "desc", "success", "cur", "results", "response"]}}
{"project": "qemu", "commit_id": "368d25881c94f9e09ef19a3d93e8fec797dbcd05", "target": 0, "func": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n\n                                        int w, int h)\n\n{\n\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n\n    size_t bytes;\n\n    int zywrle_level;\n\n\n\n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n\n        if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {\n\n            zywrle_level = 0;\n\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n\n        } else if (vs->tight.quality < 3) {\n\n            zywrle_level = 3;\n\n        } else if (vs->tight.quality < 6) {\n\n            zywrle_level = 2;\n\n        } else {\n\n            zywrle_level = 1;\n\n        }\n\n    } else {\n\n        zywrle_level = 0;\n\n    }\n\n\n\n    vnc_zrle_start(vs);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 1:\n\n        zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n\n        break;\n\n\n\n    case 2:\n\n        if (vs->clientds.pf.gmax > 0x1F) {\n\n            if (be) {\n\n                zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 4:\n\n    {\n\n        bool fits_in_ls3bytes;\n\n        bool fits_in_ms3bytes;\n\n\n\n        fits_in_ls3bytes =\n\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n\n\n\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n\n                            vs->clientds.pf.gshift > 7 &&\n\n                            vs->clientds.pf.bshift > 7);\n\n\n\n        if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n\n            if (be) {\n\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n\n          }\n\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n\n            if (be) {\n\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n    }\n\n    break;\n\n    }\n\n\n\n    vnc_zrle_stop(vs);\n\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n\n    vnc_write_u32(vs, bytes);\n\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n\n    return 1;\n\n}\n", "idx": 18150, "substitutes": {"vs": ["ks", "vd", "js", "styles", "ies", "details", "ims", "docs", "v", "stats", "uv", "qs", "posts", "terms", "bes", "bits", "eps", "xs", "cells", "ports", "videos", "values", "ants", "lbs", "ss", "pps", "nets", "grades", "ns", "events", "ms", "vi", "verts", "ves", "vals", "inv", "VS", "cs", "lights", "ils", "vp", "sts", "rs", "blogs", "vv", "ops", "helps", "aunts", "lines", "asts", "os", "caps", "vers", "tops", "Vs", "atts", "vt", "gs", "ists", "ires", "boxes", "bs", "ls", "pages", "sv", "ins", "changes", "lists", "vr", "ov", "names", "ues", "obs", "bys", "ts", "sys", "its", "fps", "vm", "orts", "iffs", "vc", "views", "ds", "ps", "otes", "fs", "es"], "x": ["yx", "px", "act", "xt", "xml", "ox", "ax", "xd", "dx", "mx", "c", "tx", "xi", "mm", "rx", "xs", "ex", "xy", "i", "ic", "ip", "xp", "fx", "p", "patch", "att", "wx", "any", "l", "m", "pt", "el", "v", "ctx", "ct", "xc", "ix", "lex", "on", "col", "it", "op", "at", "xx", "X", "ry"], "y": ["ny", "ery", "sy", "entity", "wy", "c", "xy", "i", "iy", "ym", "ay", "yl", "ye", "ot", "ia", "ic", "oy", "ies", "vy", "obj", "ya", "by", "my", "any", "ey", "sys", "yy", "b", "v", "o", "j", "ry", "axy", "yt", "col", "icy", "cy", "py", "uy", "gy", "try", "Y", "iny", "ys", "hy", "z", "asy", "p"], "w": ["window", "hw", "as", "sw", "iw", "wd", "mm", "wb", "win", "ex", "press", "q", "wn", "wx", "max", "wal", "wi", "rw", "wp", "m", "nw", "d", "kw", "rew", "wl", "ww", "aw", "ew", "wa", "wh", "str", "weight", "up", "W", "ow", "wr", "wid", "we", "wt", "z", "p"], "h": ["high", "hr", "ih", "ht", "bh", "th", " H", "hei", "hw", "as", "hd", "hh", "H", "c", "rh", "hs", "hal", "q", "eh", "he", "ish", "ha", "hz", "height", "oh", "ah", "m", "ph", "b", "v", "kh", "k", "hl", "history", "change", "wh", "html", "it", "hi", "ch", "hash", "sh", "z", "p"], "bytes": ["ls", "bits", "ints", "args", "ips", "size", "iles", "byte", "ies", "io", "ns", "rees", "Bytes", "ables", "ms", "rows", "tes", "amples", "gb", "frames", "ds", "words", "gs", "cs", "seconds", "bs", "amps"], "zywrle_level": ["zywrnemylevel", "zywrle2label", "zywrle_label", "zywrler_layer", "zywrle00level", "zywrlemystream", "zywrler_lvl", "zywrly_value", "zywrne_stream", "zywrple_level", "zywrnemystream", "zywrler_level", "zywrple_lvl", "zywrlemyerror", "zywrlemylevel", "zywrse_limit", "zywrne_level", "zywrple_message", "zywrly_level", "zywrle_levels", "zywrle55levels", "zywrle2level", "zywrle_value", "zywrle00value", "zywrle2levels", "zywrle_type", "zywrple_levels", "zywrly00depth", "zywrnemylevels", "zywrle00depth", "zywrle_message", "zywrnemyerror", "zywrole_vel", "zywrler_levels", "zywrly00value", "zywrle2vel", "zywrle_lvl", "zywrple_limit", "zywrle33low", "zywrle_field", "zywrlemmmessage", "zywrole_low", "zywrse_info", "zywrLE_levels", "zywrle_low", "zywrle_error", "zywrne_levels", "zywrle_stream", "zywrle_depth", "zywrle_val", "zywrse_Level", "zywrle33level", "zywrple_type", "zywrlemylevels", "zywrlemmlevel", "zywrle2limit", "zywrly00level", "zywrle_Level", "zywrse_level", "zywrse_levels", "zywrle_quality", "zywrole_level", "zywrle55error", "zywrole_label", "zywrple_mode", "zywrole_levels", "zywrne_error", "zywrlemmlvl", "zywrle_vel", "zywrle_limit", "zywrle2Level", "zywrle_info", "zywrLE_level", "zywrle_layer", "zywrlemmlevels", "zywrle33levels", "zywrle55stream", "zywrse_field", "zywrLE_val", "zywrle_mode", "zywrly_depth", "zywrLE_quality", "zywrle55level"], "fits_in_ls3bytes": ["fits_in_ls30bytes", "fits_in_ls4tes", "fits_in_ls2tes", "fits_in_LS2bits", "fits_in_ls6bytes", "fits_in_ls2byte", "fits_in_LS3byte", "fits_in_ls3Bytes", "fits_in_LS2Bytes", "fits_in_ls3byte", "fits_in_ls3bits", "fits_in_LS3bits", "fits_in_ls6bits", "fits_in_ls2bits", "fits_in_ls4bytes", "fits_in_ls2bytes", "fits_in_ls4byte", "fits_in_ls30bits", "fits_in_ls30byte", "fits_in_LS2tes", "fits_in_ls30Bytes", "fits_in_LS3bytes", "fits_in_ls4Bytes", "fits_in_LS2bytes", "fits_in_LS3Bytes", "fits_in_ls3tes", "fits_in_ls6Bytes", "fits_in_ls6byte", "fits_in_LS2byte", "fits_in_LS3tes", "fits_in_ls2Bytes"], "fits_in_ms3bytes": ["fits_in_ls2tes", "fits_in_ms1tes", "fits_in_ls2byte", "fits_in_ls3Bytes", "fits_in_ls3byte", "fits_in_ms3tes", "fits_in_ms2Bytes", "fits_in_ls2bytes", "fits_in_msdbytes", "fits_in_ms1Bytes", "fits_in_msdbyte", "fits_in_ms3Bytes", "fits_in_ms1bytes", "fits_in_ls3tes", "fits_in_ms1byte", "fits_in_msdBytes", "fits_in_ms2tes", "fits_in_msdtes", "fits_in_ms3byte", "fits_in_ls2Bytes", "fits_in_ms2byte", "fits_in_ms2bytes"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n", "idx": 18159, "substitutes": {"opaque": [" opplex", " open", "open", "cataques", "paque", " opatile", "opatile", "Open", "opsaque", "opsatile", "catatile", " opaques", "patile", "Opatile", "pplex", "Opaques", "Opaque", "paques", "cataque", "caten", "opsplex", "opplex", "opaques", "opsaques"], "addr": ["coord", "attr", "br", "ref", "map", "info", "eth", "ad", "ha", "kt", "src", "handle", "address", "dh", "id", "ctx", "var", "alloc", "db", "ix", "dr", "adr", "start", "ptr", "mt", "hash", "add", "name"], "size": ["length", "sum", "type", "offset", "h", "fee", "args", "params", "SIZE", "len", "ize", "load", "address", "message", "id", "n", "Size", "send", " length", "data", "count", "mem", "number", "serial", "command", "name"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "fs", "a", "c", "sq", "h", "sm", "i", "os", "ss", "ess", "ns", "spec", "r", "ts", "m", "es", "b", "n", "o", "se", "sb", "sol", "stats", "ds", "less", "S", "gs", "ps", "t", "bs", "als", "sis", "hs", "j", "p"]}}
{"project": "qemu", "commit_id": "e37e6ee6e100ebc355b4a48ae9a7802b38b8dac0", "target": 0, "func": "void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n", "idx": 18161, "substitutes": {"env": ["org", "cv", "er", "kernel", "forge", "gear", "vs", "event", "e", "v", "ctx", "var", "stack", "req", "Environment", "node", "ten", "equ", "hw", "sw", "ef", "eh", "net", "obj", "export", "spec", "expr", "ev", "code", "esp", "console", "context", "cmd", "environment", "nv", "w", "inv", "msg", "her", "dev", "esc", "vp", "window", " environment", "ext", "end", "en", "conn", "vv", "pkg", "viron", "manager", "te", "enter", "ee", "engine", "ah", "buf", "cycle", "here", "ve", "eve", "desc", "vt", "view", "esm", "config", "shell", "sv", "info", "ov", "worker", "server", "nc", "network", "vm", "ew", "ec", "erd", "eng", "outer", "queue"], "addr": ["block", "hop", "a", "ash", "eth", "ad", "asm", "store", "ip", "np", "rr", " dst", "address", "work", "ctx", "link", "mem", "mac", "oa", "hash", "add", "arp", "pad", "act", "offset", "hw", "tx", "iter", "len", "pos", "src", "expr", "Address", "now", "index", "off", "hl", "inter", "alloc", "cmd", "msg", "inv", "mt", "adj", "p", "rs", "host", "pkg", "lat", "point", "err", "size", "elt", "go", "loc", "ack", "ar", "x", "dr", "adr", "at", "ptr", "lr", "coord", "attr", "ref", "rc", "nl", " address", "pas", "res", "gc", "ha", "handle", "r", "ord", "gate", "alt", "ace"], "i": ["is", "bi", "gi", "ind", "ri", "xi", "ki", "err", "cli", "ai", "info", "iy", "ini", " v", "li", "ui", "ic", "y", "ip", "ami", "res", " ii", "io", "pi", "iu", "qi", "zi", "ci", "l", "m", "imm", "index", "id", "ori", "v", "k", "I", "b", "ii", "ti", "ei", "fi", "phi", "ix", " l", "x", " m", "di", " ni", "uri", "mi", " j", "hi", "it", "ij", "t", "multi", "j", "si", "p"]}}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "void ff_slice_thread_free(AVCodecContext *avctx)\n\n{\n\n    ThreadContext *c = avctx->thread_opaque;\n\n    int i;\n\n\n\n    pthread_mutex_lock(&c->current_job_lock);\n\n    c->done = 1;\n\n    pthread_cond_broadcast(&c->current_job_cond);\n\n    pthread_mutex_unlock(&c->current_job_lock);\n\n\n\n    for (i=0; i<avctx->thread_count; i++)\n\n         pthread_join(c->workers[i], NULL);\n\n\n\n    pthread_mutex_destroy(&c->current_job_lock);\n\n    pthread_cond_destroy(&c->current_job_cond);\n\n    pthread_cond_destroy(&c->last_job_cond);\n\n    av_free(c->workers);\n\n    av_freep(&avctx->thread_opaque);\n\n}\n", "idx": 18171, "substitutes": {"avctx": ["avegc", "avgc", "avpkg", "iverctx", "AVkit", "avectx", "avtx", " avkit", "avecf", "avejp", "ayctx", "averjp", "avejac", "aykit", " avcontext", "AVctx", "averctx", "avecontext", " avtx", "avjac", "wavgc", "avercontext", "aytx", "AVcontext", "avjp", "aycontext", "AVtx", "ivercontext", "avehistory", "wavcontext", " avpkg", "avcontext", "wavctx", "avcf", "wavjac", "wavhistory", "iverhistory", " avcf", "avercf", "avkit", "iverjac", "wavpkg", "avepkg", " avgc", " avjp", "avhistory"], "c": ["f", "cf", "lc", "cv", "cr", "config", "g", "cache", "chain", "cam", "a", "C", "h", "ca", "err", "cm", "content", "abc", "com", "fc", "rc", "anc", "mc", "cp", "sc", "etc", "gc", "cb", "u", "tc", "enc", "cu", "ci", "ac", "pc", "l", "con", "call", "m", "cc", "cl", "ctx", "b", "ct", "v", "xc", "bc", "oc", "ce", "vc", "coll", "col", "ec", "container", "cs", "comm", "co", "conf", "dc", "cor", "p"], "i": ["us", "is", "g", "bi", "gi", "ind", "ri", "xi", "point", "ki", "ai", "ini", "batch", "oi", "li", "ic", "ui", "y", "ip", "in", "\u0438", " ii", "ims", "pi", "iu", "qi", "im", "zi", "ci", "ms", "sim", "m", "asi", "index", "me", "gu", "ji", "v", "I", "n", "ii", "ti", "ei", "key", "print", "phi", "fi", "ix", "x", " ti", "span", "di", "uri", "it", "mi", "ij", "t", "ski", "multi", "j", "si", "p"]}}
{"project": "FFmpeg", "commit_id": "e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0", "target": 1, "func": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 18175, "substitutes": {"avctx": ["avtx", "AVcfg", " avcontext", "AVctx", "ajcfg", "avcfg", " avtx", "wavcmp", "ajcontext", "AVcontext", "AVcmp", "AVtx", " avcmp", "wavcontext", "avcmp", "avcontext", "wavctx", "ajctx", "ajtx", "wavtx", " avcfg"], "data": ["to", "text", "window", "pad", "done", "extra", "block", "offset", "action", "end", "trans", "win", "stream", "pointer", " DATA", "ad", "buffer", "fr", "ata", "padding", "bytes", "device", "res", "pos", "dat", "src", "r", "address", "table", "buf", "message", "d", "m", "id", "value", "rew", "DATA", "row", "area", "Data", "key", "str", "empty", "prefix", "next", "file", "raw", "image", "start", "t", "name", "p"], "got_sub_ptr": ["got_sub2pos", "got_ubvalpt", "got_ubvalreq", "got_subvalreq", "got_sub2ptr", "got_sub2addr", "got_sel_addr", "got_sub__tr", "got_sub2pt", "got_subvalpt", "got_sub2tr", "got_sub2req", "got_sub_pos", "got_subvalptr", "got_ubvalptr", "got_sub__pos", "got_sel_pos", "got_sub_tr", "got_sub_addr", "got_ub_ptr", "got_ub_addr", "got_sel_ptr", "got_sub__ptr", "got_ub_req", "got_sub_req", "got_sub_pt", "got_subvaladdr", "got_ub_pt", "got_sub__addr", "got_ubvaladdr", "got_sel_tr"], "avpkt": ["avPkg", "avPkt", "avppmsg", "avppconn", "avpmsg", "evpkt", "avewpct", "avjpdu", " avpbuf", "aveppmsg", "avepkt", "aveppkat", "avpackkg", "avjpmsg", " avcpkt", "avpct", "avpackacket", "avnpcmd", "evppqt", "avwpkt", "avppkt", "avpkat", "avpcmd", "avckt", "avnpacket", "aveppkt", "avcqt", "avcacket", "avpconn", "avwpacket", " avpcmd", "avppdu", " avPkt", "avjpct", "avepvc", "avcpbuf", "avcpconn", "avpodkat", " avpkg", " avPkg", "avppbuf", "avpackkt", "avpbuf", "avppacket", "avpacket", "avpodkt", "avppqt", "avcpkt", " avpmsg", "avckg", " avcpbuf", "avppcmd", "avpvc", "evpacket", " avpacket", "avPcmd", "avnpkt", "avpdu", "avjpbuf", " avpdu", "avjpkt", " avcpdu", "avepct", "avwpct", " avPacket", "avcpdu", "avepkat", "avewpkt", "avppkat", "avPacket", "avepacket", "evppacket", "avjpacket", "avpkg", "avPct", "avjpvc", "avwpvc", "avcpmsg", "avppkg", "avewpacket", "evppkg", "avewpvc", "avpodconn", " avPcmd", "avPvc", "avpodmsg", "avepmsg", "avpqt", "avnpkg", "avepconn", "aveppconn", "evppkt", "avpackqt", "evpkg", " avcpmsg", "avcpkat", "evpqt"], "ptr": ["proc", "pad", "tmp", "coord", "offset", "br", "end", "ref", "ctr", "ind", "fp", "pointers", "iter", "td", "pipe", "pointer", "pr", "eth", "buffer", "fr", "tr", "pos", "loc", "dat", "pl", "rel", "address", "r", "lp", "buf", "arr", "pc", "pt", "index", "sp", "inters", "ctx", "inter", "Ptr", "slice", "alloc", "seek", "dr", "adr", "addr", "ps", "rep", "tp", "p"], "len": ["ls", "sl", "lc", "length", "lan", "cmp", "all", "end", "en", "Len", "ref", "Length", "vec", "iter", "kl", "err", "lf", "js", "le", "size", "nl", "li", "ml", "fin", "duration", "pos", "bytes", "elt", "ll", "gl", "pl", "ell", "lp", "resp", "l", "list", "num", "el", "sp", "n", "code", "val", "str", "lim", "lon", "full", "count", "compl", "mem", "seq", "ln", "fun", "ler", "nt", "wid", "loss", "il", "L", "t", "fn", "ld", "z"], "dialog": ["challogue", "tdogue", "choogue", "colag", "slig", "dialogl", "ialog", "directag", "tdig", "cologue", "ialogue", "dialig", "slogue", "choig", "dialag", "colig", "dialogue", "choog", "dialect", "slog", "colog", "directog", "directig", "challig", "tdag", "tdog", "slogl", "choogl", "ialig", "ialect", "challog", "directect", "directogue", " dialig", " dialogue", "challogl", " dialect"]}}
{"project": "qemu", "commit_id": "5e003f17ec518cd96f5d2ac23ce9e14144426235", "target": 1, "func": "static int init_blk_migration(QEMUFile *f)\n\n{\n\n    BlockDriverState *bs;\n\n    BlkMigDevState *bmds;\n\n    int64_t sectors;\n\n    BdrvNextIterator it;\n\n    int i, num_bs = 0;\n\n    struct {\n\n        BlkMigDevState *bmds;\n\n        BlockDriverState *bs;\n\n    } *bmds_bs;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n    block_mig_state.bulk_completed = 0;\n\n    block_mig_state.zero_blocks = migrate_zero_blocks();\n\n\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n        num_bs++;\n\n    }\n\n    bmds_bs = g_malloc0(num_bs * sizeof(*bmds_bs));\n\n\n\n    for (i = 0, bs = bdrv_first(&it); bs; bs = bdrv_next(&it), i++) {\n\n        if (bdrv_is_read_only(bs)) {\n\n            continue;\n\n        }\n\n\n\n        sectors = bdrv_nb_sectors(bs);\n\n        if (sectors <= 0) {\n\n            ret = sectors;\n\n\n            goto out;\n\n        }\n\n\n\n        bmds = g_new0(BlkMigDevState, 1);\n\n        bmds->blk = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n\n        bmds->blk_name = g_strdup(bdrv_get_device_name(bs));\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = migrate_use_block_incremental();\n\n\n\n        assert(i < num_bs);\n\n        bmds_bs[i].bmds = bmds;\n\n        bmds_bs[i].bs = bs;\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n\n\n    /* Can only insert new BDSes now because doing so while iterating block\n\n     * devices may end up in a deadlock (iterating the new BDSes, too). */\n\n    for (i = 0; i < num_bs; i++) {\n\n        BlkMigDevState *bmds = bmds_bs[i].bmds;\n\n        BlockDriverState *bs = bmds_bs[i].bs;\n\n\n\n        if (bmds) {\n\n            ret = blk_insert_bs(bmds->blk, bs, &local_err);\n\n            if (ret < 0) {\n\n                error_report_err(local_err);\n\n                goto out;\n\n            }\n\n\n\n            alloc_aio_bitmap(bmds);\n\n            error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n            bdrv_op_block_all(bs, bmds->blocker);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    g_free(bmds_bs);\n\n    return ret;\n\n}", "idx": 18187, "substitutes": {"f": ["fd", "cf", "fal", "rf", "fp", "c", "h", "af", "fc", "lf", "F", "e", "m", "tf", "fa", "d", "fm", "v", "uf", "sf", "fi", "file", "fw", "bf", "fn", "t", "fs", "p"], "bs": ["ls", "bb", "bh", "boot", "bits", "bi", "ubs", "outs", "nos", "iss", "rs", "BS", "js", "lbs", "os", "browser", "bp", "obs", "vs", "bys", "ns", "cb", "pb", "there", "ubis", "ats", "ts", "sys", "its", "bsp", "eb", "b", "vers", "bed", "bing", "bis", "bn", "sb", "bc", "s", "buff", "stats", "bos", "ds", "ses", "bps", "bl", "gs", "bas", "bm", "bles", "cs", "boxes", "bu", "blocks", "aos", "bf", "ps", "fs", "banks", "bo", "bes"], "bmds": ["bdepds", "bmms", "mndS", "bmethodls", "bndns", " bto", "vMDains", "bdefS", " bmnS", " baddits", "badds", "bmdn", "bcto", "cmds", "bcmders", "bcmdds", "Bndns", "bsms", "bmdm", "wmdS", "bmdos", "mndn", "bmdds", "mmdjs", "bkgs", "cmdges", "bdevers", "bmdjs", "bconfigges", "wMDS", "bndjs", "bmnds", "bmmries", "ccmds", "cmdcs", "bbdjs", "bdefjs", " bmnds", "Bmdns", "bbdm", "Bnds", " badds", "bkgits", "bnds", "bmns", "bmnps", "bMDns", "nbto", "baddits", "bsmjs", "nbfree", "bMDjs", "bmnS", "bMDos", "vmdains", "wMDs", "bconfigs", "bdepS", "ccmdges", "bcmdls", "bbds", "ccmdls", "mmds", "mmdn", "bjects", "baddgets", "cmdds", "ccmders", "Bndjs", "bmdS", "cmdits", "bcfree", "bddS", "bMDds", "cmders", "bdepps", "bmdls", "ccmdcs", "cmdries", "Bmds", "btabers", "bmdubs", "bmdains", " bmdps", "bmethods", "mndjs", "bdefm", "bcmdjs", "wmdm", "bmdgets", "bmdits", "bddps", " bmnps", "btabcs", "baddjs", "bndS", " bmdS", "bmders", "bfree", "bmungets", "bsmds", "bmdges", "bdevcs", "bndn", "vMDos", "bmdries", "ccmdries", "bto", " baddgets", "btabds", "bdeps", "bcmdcs", "bmdps", "bbdS", "mnds", "wmdjs", "bcmds", "bmdcs", "bsmns", "wmds", "bmnls", "bkggets", "bconfigits", "bcmdits", "bdevs", "Bmdds", "bMDains", "vmdos", "bMDS", "bndds", "btabries", "bdefs", " bfree", "bmunits", "bcmdges", "bdds", "wMDm", "baddn", "cmdls", "baddubs", "bmunubs", "bcmdn", "bMDs", "Bmdjs", "bmethodds", " bmdgets", "ccmdits", "bjectges", "bkgubs", "wMDjs", "bcmdries", "baddS", " baddubs", "Bndds", " bmdds", "vMDs", "bbinds", "bmuns", " bmdits", "bddds", " bmns", "ccmdds", "bMDm", "bmdns", "bminds", "btabs", "bcmdS", "bbindos", "vmds", "bmindains", " bmdubs", "bjectits", "bmindos", "bbindains", "bmmds", "mmdS"], "sectors": ["spectors", "spellers", "serctors", "seters", " severs", "ectors", "vegments", "negments", "severs", "speors", " secs", "bellers", "spegments", "spevers", "evers", "veors", "necs", "bectors", "seors", "vecs", "specs", "veters", "sevec", " segments", " sections", "neors", " sevec", "spevec", "serors", "secs", "servers", " seors", "sections", "becs", "vections", "vevers", " sellers", "sellers", "bevers", "serters", "spections", "nectors", "vevec", "segments", "eters", "eors", "vectors"], "it": ["is", "bit", "mit", "br", "st", "itted", "ins", "h", "iter", "you", "lit", "sit", "or", "It", "rit", "q", "ic", "ot", "he", "ip", "in", "io", "hit", "al", "ut", "ait", "att", "item", "r", "e", "ci", "ITS", "this", "its", "el", "b", "v", "ct", "alt", "jit", "vt", "op", "at", "IT", "t", "j", "si", "p"], "i": ["bi", "gi", "ind", "c", "iter", "ri", "xi", "ki", "cli", "ai", "info", "ini", "li", "ic", "ui", "y", "ip", "ami", "in", "go", "ims", "pi", "iu", "qi", "im", "zi", "ci", "sim", "m", "index", "id", "b", "v", "I", "n", "out", "ii", "ti", "fi", "phi", "ix", "x", "di", "mi", "hi", "try", "ij", "t", "multi", "j", "si", "p"], "bmds_bs": ["bmdjs_bas", "bmdjs_BS", "bmdns_vs", "bmds_ts", "bmds2vs", "bmds_bas", "bmds2BS", "bmdjs2BS", "bmdns_bs", "bmdns_bed", "bmds_bed", "bmdjs_bs", "bmds__BS", "bmds_vs", "bmds_gs", "bmdjs_vs", "bmdjs2ls", "bmds__bs", "bmds__ls", "bmdns_BS", "bmds_its", "bmds_BS", "bmds2ls", "bmds2bs", "bmds__vs", "bmdjs2vs", "bmdjs2bs", "bmdjs_ls", "bmds_ls"], "local_err": ["local_er", "global_er", "local_rr", "global_err", "local_buf", "localErrr", "localErbuf", "localErer", "global_buf", "localErerr", "global_rr"], "ret": ["ls", "xt", "ne", " res", "ext", "rs", " ans", "final", "result", " RET", "iter", "args", "rem", "len", "res", " resp", "elt", "Return", "re", "arr", "RET", "Ret", "ter", "sys", "ts", "rev", "vers", " Ret", "nz", "val", "rets", "alt", "mem", "vals", "status", "nt", "try", "usr", "ptr", "j"], "num_bs": ["num___BS", "num_BS", "num___bs", "num_ubs", "num_bits", "num__boxes", " num_BS", "nom_bs", " num_boxes", "num_bl", " num_cs", "nom_ubs", "num__bits", "num_bis", " num_bits", "num__bis", "num___boxes", "num_blocks", " num_blocks", " num_vs", " num_bl", "num_cs", "num__blocks", "num__cs", "nom_bits", "nom_bps", "num__bs", " num_bis", "num_vs", "num_bps", "num__vs", "num___bl", "num_boxes"]}}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "substitutes": {"vs": ["ls", "pages", "sts", "ks", "sv", "rs", "blogs", "ins", "eps", "changes", "lists", "vr", "ops", "ov", "js", "values", "lbs", "lines", "names", "ss", "obs", "ns", "ims", "ms", "nc", "ts", "sys", "fps", "v", "ev", "sb", "wcs", "Vs", "s", "pg", "vc", "stats", "views", "ds", "qs", "atts", "vals", "vt", "inv", "gs", "VS", "flags", "cs", "ps", "las", "bs", "fs", "vp"], "y": ["ny", " Y", "ery", "ht", "sy", "yer", "c", "xy", "i", "iy", "ym", "ay", "ye", "oy", "ies", "vy", "ya", "yo", "ady", "my", "height", "any", "ey", "m", "sys", "yy", "idy", "yr", "b", "ty", "ky", "axy", "yt", "col", "icy", "cy", "ly", "py", "uy", "ys", "gy", "sky", "Y", "ch", "iny", "yi", "hy", "z", "yl", "ry"], "last_x": ["last____z", " last_y", "last_z", "tmp_y", "tmp_xy", "last____xp", "last_xy", "last_X", " last_X", "last_xx", "last____x", "last_y", "last____X", "tmp_xx", "last_xp", " last_z", " last_left", " last_xp", "last_left"], "x": ["yx", "px", "act", "ax", "ox", "dx", "tx", "xi", "rx", "xs", "ex", "xy", "i", "xp", "max", "xxx", "l", "checked", "m", "index", "xxxx", "v", "xc", "ix", "xa", "w", "xf", "only", "xx", "t", "X", "step", "p"], "h": ["high", "ih", "hr", "f", "ht", "bh", "th", "ach", "ho", "g", "hd", "hh", "H", "c", "rh", "depth", "hs", "hal", "i", "q", "he", "ish", "go", "head", "ha", "hz", "orth", "handle", "pers", "hm", "oh", "ah", "height", "l", "dh", "d", "m", "index", "ph", "b", "kh", "hold", "k", "his", "v", "hl", "history", "His", "him", "hang", "wh", "html", "count", "uth", "it", "hi", "zh", "ch", "t", "hash", "sh", "z", "gh", "each", "p"], "tmp_x": ["tmp_X", "tmp_y", "tp_xml", "tmp__X", " tmp_ix", " tmp_tx", "tmp_xml", "tmp_tx", "tpMemxes", "tmp_ix", "tmpMemxes", "tmp_ux", " tmp_wx", "mp_x", "tmp__x", "tmp_ex", "tmp_wx", " tmp_ex", "tmp_length", "tmp__ex", " tmp_X", "tmp_xt", "tmpMemx", "tmp_xes", "tp_x", "tmp__tx", "tmp__ch", "mp_ux", "tmp_ch", "mp_y", "tmpMemxml", "tpMemxml", "tpMemx", "tp_length", "tp_xes", "tpMemlength", "mp_xt", "tmpMemlength", " tmp_ch"]}}
{"project": "qemu", "commit_id": "a0067da1577e3eb0c60758384282568f4b2328fe", "target": 1, "func": "static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}", "idx": 18195, "substitutes": {"req": ["hr", "init", "args", "js", "def", "fr", "rr", "qq", "query", "ctx", "var", "quest", "needed", "decl", "proc", "reg", "tx", "tek", "rx", "pr", "dq", "rb", "obj", "dist", "expr", "fy", "esp", "cmd", "compl", "required", "inv", "usr", "iq", "tmp", "qa", "ext", "require", "pkg", "ind", "sq", "err", "fresh", "q", "comp", "wx", "arg", "pt", "desc", "cur", "seq", "aux", "quick", "crit", "rt", "attr", "awk", "ref", "jp", "ck", "urg", "requ", "res", "qt", "rel", "form", "r", "gr", "request", "sys", "call", "eg", "reset", "ps", "j"], "resp": ["proc", "reg", "rend", "ne", " res", "response", "ref", "rs", "gt", "conn", "result", "that", "jp", "decl", "args", "err", "Resp", "dl", "js", "ret", "RES", "def", "fr", "serv", "comp", "ess", "res", "pos", "acc", "obj", "ll", "respons", "wx", "arg", "arr", "rel", "eval", "vol", "rev", "rex", "sys", "rec", "sp", "txt", "gz", "ctx", "ev", "out", "respond", "esp", "str", "sol", "gov", "cmd", "compl", "seq", "msg", "rpm", "inv", "results", "buff", "rep", "nt", "snap", "reply", "ps", "comm", "cmp", "repl", "rest", "j"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void add_index_entry(AVStream *st,\n\n                            int64_t pos, int64_t timestamp, int flags)\n\n{\n\n    AVIndexEntry *entries, *ie;\n\n    \n\n    entries = av_fast_realloc(st->index_entries,\n\n                              &st->index_entries_allocated_size,\n\n                              (st->nb_index_entries + 1) * \n\n                              sizeof(AVIndexEntry));\n\n    if (entries) {\n\n        st->index_entries = entries;\n\n        ie = &entries[st->nb_index_entries++];\n\n        ie->pos = pos;\n\n        ie->timestamp = timestamp;\n\n        ie->flags = flags;\n\n    }\n\n}\n", "idx": 18200, "substitutes": {"st": ["rt", "sl", "ost", "th", "sts", "tt", "sv", "sn", "so", "sw", "spect", "h", "ste", "nd", "std", "ism", "sm", "td", "stage", "sta", "store", "fr", "ss", "sc", "sth", "net", "ut", "inst", "set", "form", "St", "est", "pt", "d", "sp", "ST", "ct", "se", "ft", "s", "str", "db", "ast", "art", "ust", "sam", "nt", "stat", "mt", "stable", "t", "ld", "sh", "rest", "step", "ist"], "pos": ["offset", "Pos", "slot", "ref", "ind", "neg", "trans", "pose", "point", "origin", "size", "pr", "port", "ports", "position", "def", "os", "len", "doc", "top", "loc", "pi", "spec", "pl", "form", "resp", "pc", "pid", "pt", "path", "index", "local", "mon", "Position", "pres", "po", "oc", "rot", "POS", "points", "cod", "pro", "op", "nt", "snap", "ps", "cond", "p"], "timestamp": ["Timeness", "timeness", "Timeline", "Timestamp", "temeline", "imprint", "mominal", "meteness", "timdule", "metestamp", "Timprint", "metetime", "timedule", "Timest", " timintage", "imest", "timeeness", "timest", "timeinal", "meteline", "temeness", "scheeness", "temetime", "schedule", " timest", "imestamp", "momdule", "timprint", "momeness", "momestamp", "timintage", "Timetime", "timetime", "timinal", "scheinal", "temestamp", "scheestamp", " timprint", "imintage", "timeestamp", "timeline", "Timintage"], "flags": ["levels", "bugs", "acts", "bits", "ints", "places", "ops", "args", "aps", "limits", "reports", "ports", "mask", "ants", "links", "heads", "grades", "pins", "ags", "flag", "types", "ms", "Flags", "ats", "ts", "locks", "fps", "options", "weights", "members", "issues", "alf", "parts", "mods", "lag", "wcs", "faces", "orts", "fields", "frames", "times", "atts", "stats", "bps", "files", "comments", "posts", "tags", "ps", "rates", "features", "details", "amps"], "entries": ["sentrys", "indents", "sentents", "entsities", "gentrys", "Entried", " entried", "indries", "gentry", "rentries", "entry", "Entrys", "entities", "contrys", "ntries", "gentires", "entsry", "entsries", "ntrys", "gateies", "entried", "entents", "conties", " entrance", "rentrys", "rentrance", "enties", "entsies", "Entires", "ntrance", "gateents", "gateries", "contries", "Entities", "entrance", "entsrys", "entsires", "indrys", "indities", "entires", "entrys", "Entries", "Enties", "senties", "Entents", "contried", "gaterys", "nties", "gentries", "entsents", "sentries", "Entry", "renties", " entrys", " enties"], "ie": ["ele", "ere", "edge", "ief", "ne", "tie", "ice", "er", "entry", "entity", "oe", "ike", "ge", "i", "le", "te", "ade", "ink", "ibe", "ip", "io", "ue", "ig", "ime", "ee", "quote", "ib", "je", "e", "ni", "bie", "pie", "tip", "ige", "ipe", "eur", "ife", "eb", "zip", "sie", "ince", "eg", "see", "ei", "ide", "ce", "rice", "nie", "mie", "pe", "die", "IE", "ite", "iq", "ace", "ine", "pse", "iere"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    MpegEncContext *s = avctx->priv_data;\n\n    AVFrame *pict = data;\n\n    int i, ret;\n\n    int slice_count;\n\n    const uint8_t *slices_hdr = NULL;\n\n\n\n    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (!avctx->slice_count) {\n\n        slice_count = (*buf++) + 1;\n\n        buf_size--;\n\n\n\n        if (!slice_count || buf_size <= 8 * slice_count) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice count: %d.\\n\",\n\n                   slice_count);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        slices_hdr = buf + 4;\n\n        buf       += 8 * slice_count;\n\n        buf_size  -= 8 * slice_count;\n\n    } else\n\n        slice_count = avctx->slice_count;\n\n\n\n    for (i = 0; i < slice_count; i++) {\n\n        unsigned offset = get_slice_offset(avctx, slices_hdr, i);\n\n        int size, size2;\n\n\n\n        if (offset >= buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (i + 1 == slice_count)\n\n            size = buf_size - offset;\n\n        else\n\n            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;\n\n\n\n        if (i + 2 >= slice_count)\n\n            size2 = buf_size - offset;\n\n        else\n\n            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;\n\n\n\n        if (size <= 0 || size2 <= 0 ||\n\n            offset + FFMAX(size, size2) > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)\n\n            return ret;\n\n\n\n        if (ret > 8 * size)\n\n            i++;\n\n    }\n\n\n\n    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {\n\n        ff_er_frame_end(&s->er);\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->last_picture_ptr);\n\n        }\n\n\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *got_frame = 1;\n\n        }\n\n\n\n        // so we can detect if frame_end was not called (find some nicer solution...)\n\n        s->current_picture_ptr = NULL;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 18202, "substitutes": {"avctx": ["avctl", "wavconf", "avewcs", "avejp", "abcmp", "averjp", "vrjp", "abcontext", " avcu", "averctx", "avcfg", "ajcontext", "navcmp", "navpkg", "AVtx", "navctx", "avconfig", "ajcu", "avcontext", "AVctl", " avctl", "ajjac", "avsc", " avconn", "savsys", " avjac", "afconfig", "savnp", "avernp", "wavconn", "avectx", " avcontext", "averconfig", "AVctx", "avconn", "averconn", "avjac", "aversc", "AVjac", "wavcmp", "AVcontext", "avecmd", "avesys", "afjac", "savconfig", "avenp", "aversys", " avpkg", "vercontext", "abtx", "wavjac", "avercu", "verctx", "vrtx", "averpkg", "avcmd", "avwcs", "savtx", "aveconn", "ajwcs", "abctx", "avsys", "ajcfg", "avetx", "avecontext", " avtx", "vertx", "avercontext", "averjac", "avcu", "avcmp", "wavctx", "avconf", "verctl", "abcmd", "afcfg", "ajpkg", "savjp", "vrsc", "wavpkg", "avecfg", " avcfg", "afctx", "abconf", "avpkg", "avercfg", "avtx", "avejac", "navconf", "avnp", " avcmd", "savjac", "avjp", "avertx", "abconn", "avesc", " avwcs", "ajconn", "aveconfig", "abpkg", "vrctx", "ajctx", "AVjp", "savctx", "avepkg"], "data": ["f", "text", "window", "pad", "length", "to", "received", "block", "offset", "action", "a", "content", "feed", "json", "batch", "buffer", "def", "ata", "padding", "bytes", "obj", "read", "mu", "dat", "rel", "r", "form", "sequence", "message", "table", "value", "d", "m", "rew", "DATA", "Data", "family", "package", "str", "empty", "one", "media", "next", "frame", "raw", "image", "input", "t", "response", "name", "p"], "got_frame": ["got___state", "got1length", "received_state", "got_length", "got1data", "got___length", "got1frame", "got___frame", "received_data", "got1state", "received_length", "received_frame", "got_data", "got_state", "got___data"], "avpkt": ["avcppt", "afpct", "avpkg", "avPkt", "avcpwt", "avspkt", "avcpkt", "avPct", "avpwt", "avpj", "afpj", "afcpj", "afcppt", "avnkg", "avbpacket", "avspct", "avnkt", "avcpunct", "avcpkg", " avpwt", "afcpct", " avpacket", "avapacket", "avcpj", "avapkt", "avpackj", "afpunct", "avpackunct", "avapkg", " avcpacket", "avspacket", "avcpct", "avbpunct", "afppt", "avPpt", "afcpacket", "avnacket", " avcpkg", " avpkg", "avcpacket", " avcpkt", "avpct", "avppt", "avapwt", "avpackacket", "avpackkt", "avpunct", "afcpkt", "afcpunct", "avsppt", "afpkt", " avcpwt", "avbpj", "avnwt", "avPacket", "avbpkt", "avpacket", "afpacket"], "buf": ["tmp", "pad", "window", "cv", "coord", "box", "br", "offset", "end", "cache", "ref", "ctr", "pkg", "init", "map", "vec", "iter", "fac", "wb", "bar", "xff", "port", "buffer", "Buffer", "len", "rb", "bytes", "pos", "img", "doc", "read", "cb", "loc", "mu", "orig", "um", "off", "b", "v", "txt", "ctx", "uf", "bc", "late", "alloc", "cmd", "db", "lim", "mem", "begin", "msg", "bl", "raw", "buff", "av", "pool", "limit", "ptr", "queue", "half", "far", "batch"], "s": ["ls", "sl", "sts", "sv", "rs", "a", "c", "sq", "js", "ss", "sc", "ess", "sg", "ns", "soc", "spec", "session", "set", "sys", "ts", "m", "sp", "b", "v", "sb", "stats", "ds", "S", "gs", "ssl", "sam", "cs", "sa", "t", "fs", "p"], "pict": ["fd", "f", "ff", " req", "fl", " f", "FR", "rf", "original", "ref", "P", "Frame", " fin", "fc", "rc", " frames", "F", "ra", "fm", " frame", "ft", " fr", " fn", "fi", "req", "fw", " p", " F", "raw", " e"], "i": ["is", "init", "a", "c", "h", "ip", "y", "ami", " ii", "ims", "qi", "e", "upper", "v", "I", "o", "ii", "key", "phi", "status", "hi", "limit", "t", "f", "offset", "ir", "iter", "ui", "\u0438", "pi", "u", "im", "index", "mi", "name", "multi", "g", "gi", "ind", "chain", "xi", "ki", "err", "cli", "ai", "origin", "q", "li", "go", "iu", "ci", "l", "sim", "m", "me", "level", "ti", "instance", "x", "try", "ij", "si", "batch", "bi", "info", "ias", "ic", "in", "item", "list", "id", "n", "ei", "ix", "di", "it", "ini", "j"], "ret": ["f", "rt", "done", "get", "xt", "offset", "ext", "gt", "ref", "result", "vector", "iter", "args", "err", "rem", "def", "cont", "len", "tr", "res", "elt", "re", "rel", "got", "r", "resp", "RET", "Ret", "rev", "ter", "value", "tf", " Ret", "ft", "total", "reset", "val", "rets", "alt", "success", "mem", "status", "format", "dr", "fun", "it", "nt", "aux", "try", "mt", "t"], "slice_count": ["slice_cond", "slice_child", "slice_cmd", "slaveitynum", "plot_Count", " slice_c", "slice67cond", "slice2con", "plane_count", "plane_amount", "slice67weight", "slice12depth", " slice_limit", "slice67con", "zeroletcd", "slice1count", "slice_found", "slice_code", "sliceityamount", "slice67count", "zero_child", "slice2count", "slice_mode", "slice_sum", "slice1cmd", "zero_count", "slice____info", "slice00Count", "slice_counter", "shift_counter", "sliceletcount", "slice67found", "sloternumber", "slicePcon", "slice_amount", "sliceletcd", "plot_found", "slot____count", "sliceletchild", "planeletamount", "slice00found", "slot____info", "slice_num", "sliceletamount", "scale_count", "slice12sum", "slicePcounter", "sliceletCount", "slot_mode", "plot00Count", "sliceermode", "sliceitycount", "slice_info", "slicePfound", "slice_depth", "shiftPfound", "slot_Count", "slice12count", "slave_amount", "slicePcount", "slice67cd", "slice2found", "plot12Count", "scale_code", "slicetweight", "sample_weight", "slaveityamount", "plane_con", "scale_Count", "slice67Count", "planeletcon", "slice2c", "slice12Count", "slice_number", "slot_flags", "slice2Count", "shift_con", "zero_Count", "plot00found", "slice2code", "sliceletcon", " slice_cond", "slicetcount", "slice67child", "sliceitynum", "slot____flags", " slice_amount", "plot_cmd", "shift_count", "plot00cmd", "slice_flags", "shiftPcounter", "slotermode", "plot12sum", "slice1number", "planeletcount", "sliceernumber", "zero_cd", "scale_c", "shiftPcount", "slice_c", "plot00count", "plot_sum", "zeroletchild", "slice1mode", "slice00cmd", "sample_Count", "slaveityfound", "sample_count", "slave_found", "slicetCount", "slot_info", "slot____Count", "slice____flags", " slice_Count", "plot_count", "zeroletCount", "sliceityfound", "slotercount", "zeroletcount", "slice_limit", "slice____count", "slice2counter", "slice____Count", "shiftPcon", "slot_count", "slice_con", "plot12count", "slave_num", " slice_weight", "sliceercount", "slice_Count", "slice1Count", "plot_depth", "slice_weight", "slice_cd", "slice1found", "plot12depth", "slave_count", "slot_number", "shift_found", "slice00count", "slaveitycount", "slice67counter"], "slices_hdr": ["slices_hrDR", "slices_hrec", "slices_hhook", "slices_hhDR", "slices_trdr", "slices_thdr", "slices_qook", "slices_Hr", "slices_phr", "slices_hmm", "slices_hfr", "slices_hrd", "slices_trDR", "slices_hhrec", "slices_hrmm", "slices_hhdr", "slices_lrd", "slices_ihDR", "slices_iholder", "slices2Hr", "slices_ihfr", "slices_hbr", "slices_ldr", "slices_pradr", "slices2Hbr", "slices_prdr", "slices_Holder", "slices_chdr", "slices_Hfr", "slices_lrid", "slices_Hbr", "slices_lDR", "slices_chbr", "slices_phDR", "slices_phbr", "slices_hadr", "slices2hDR", "slices_hDR", "slices_holder", "slices_hook", "slices_thDR", "slices2hbr", "slices_ihdr", "slices_chDR", "slices_prmm", "slices_qDR", "slices_HDR", "slices_prDR", "slices_phdr", "slices_Hdr", "slices_chr", "slices_tholder", "slices_hrid", "slices2hdr", "slices_hradr", "slices2hr", "slices_trrid", "slices_trrd", "slices_thfr", "slices_qrec", "slices2HDR", "slices_hr", "slices_Hrec", "slices2Hdr", "slices_qdr", "slices_hrdr", "slices_Hook"], "buf_size": ["bufmllength", "buf_status", "buff64site", "buflenSIZE", "Buffer_size", " buf_storage", "buff8cache", "buff_cache", "buflenstatus", "buf_group", "buf_total", "bytemlset", " buf_len", "buf64group", "buf_offset", "bufptgroup", " buf_SIZE", "bytemlsize", "byte_energy", "byte_length", "buf_space", "buflensize", "uf_count", "buf8cache", "Bufferlenstatus", "bytemllength", " buf_Size", "byte_size", "buff8SIZE", "buff_site", "cap_scale", "buf67len", "bufptsite", "bytemlenergy", "buf_storage", "buff_offset", "uf_Size", "uf_name", "buf_length", "buftsize", "buff_len", "buf_energy", "buf2scale", "buf2storage", "buflentotal", "cap_count", "buf2SIZE", "buf_count", "Buffer_status", "buff8size", "buf67size", " buf_count", "buf_set", "Buffer_SIZE", "buff64size", "buf_Size", "buff_group", "buff64group", "bufptlen", "uf_size", "byte_set", "bufmlsize", "uf_SIZE", "buf67site", "bufttotal", "Buffer_total", "buf8offset", "buff8offset", "buf2len", "buf64site", "cap_size", "bufmlenergy", "buf2size", "uf_len", "buf67group", "buf_scale", "uf_scale", "Bufferlensize", "buff64len", "buf64size", "buf64len", "BufferlenSIZE", "buf_name", "buff_SIZE", "buf2count", "buf_SIZE", "buf2Size", "bufmlset", "bufptsize", "cap_space", "buf_site", "buftSIZE", "buftstatus", "buf8SIZE", "buf8size", "buf_cache", "buff_size", "Bufferlentotal", "buf_len"], "size": ["ose", "shift", "content", "shape", "read", "max", "address", "message", "small", "time", "send", "weight", "storage", "mem", "limit", "needed", "offset", "sw", "style", "len", " sizes", "body", "ms", "zero", "space", "total", "empty", "notice", "general", "ie", "izes", "iz", "name", "unit", "to", "window", "length", "sum", "ne", "g", "scroll", "south", "sent", "dim", "error", "set", "l", "options", "sp", "count", "number", "no", "ify", "range", "si", "type", "get", "zone", "fee", "speed", "city", "SIZE", "scale", "ize", "bytes", "height", "any", "n", "Size", "equal", "format", "magic", "news", "start", "sh", "z", "timeout"], "size2": ["score3", " size162", " size02", "name02", "time1", "SIZE2", "ize2", "score2", "SizeTwo", " size52", "style2", "size02", " size4", "size4", " sizeTwo", "size162", "size1", "dimension162", "dimension02", "ize02", "ize4", "Size1", "dimension2", "time2", "Size4", "size52", "name1", "name162", "timeTwo", "SIZE1", " size3", "score52", "size3", "Size2", " size1", "name2", "ize1", "style52", "time4", "style3", "sizeTwo", "dimension1", "SIZE4"]}}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,\n\n                           AVStream *st, RMStream *rst, int codec_data_size)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(st->codec, AV_LOG_ERROR, \"Unsupported video codec\\n\");\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n//        av_log(s, AV_LOG_DEBUG, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,\n\n                  0x10000, fps, (1 << 30) - 1);\n\n        st->avg_frame_rate = st->r_frame_rate;\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 18203, "substitutes": {"v": ["f", "cv", "type", "sv", "g", "vv", "vr", "h", "c", "qu", "i", "conv", "len", "version", "y", "vs", "V", "iv", " V", "ver", "u", "lv", "vol", "rev", "l", "m", "qv", "vi", "value", "vm", "b", "k", "ev", "vp", "ve", "s", "val", "va", "vc", "uv", "nv", "format", "tv", "w", "vt", "inv", "av", "vert", "t", "j", "p"], "size": ["length", "sum", "offset", "g", "sv", "sn", "c", "i", "SIZE", "scale", "len", "ize", "sd", "set", "l", "sp", "n", "Size", "count", "seek", "mem", "format", "t", "z", "name", "si"], "codec_pos": ["codoc_info", "codec_loc", "codec__position", "codec__Pos", "codec__loc", "codec0offset", "codpeg_loc", "codec0Pos", "codec0info", "codpeg_Pos", "codec_offset", "codec__pos", "codoc_pos", "codec_position", "codpeg_pos", "codec_info", "codec0pos", "codoc_Pos", "codec_Pos", "codoc_offset", "codpeg_position"], "ret": ["f", "rt", "ber", "gt", "ref", "final", "result", " RET", "err", "not", "after", "rem", "nl", "cont", "len", "tr", "res", "elt", "ll", "re", "resp", "det", "RET", "Ret", "ter", "tf", "value", "zero", "back", "out", "ft", "ez", " Ret", "inter", "reset", "val", "rets", "alt", "mem", "ail", "status", "it", "fun", "nt", "try", "pret", "mt", "il", "t"], "fps": ["ffff", " fin", "err", " frames", "res", " resp", "resp", "failed", "frames", "first", "next", "vals", "ps", "fs"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 18211, "substitutes": {"f": ["fd", "cf", "g", "fe", "fp", "a", "h", "c", "df", "fac", "fb", "fc", "af", "lf", "i", "ile", "q", "fr", "fx", "F", "r", "form", "e", "l", "d", "m", "tf", "elf", "b", "fm", "uf", "fi", "file", "w", "fo", "inf", "t", "conf", "fs", "p"], "pv": ["Pv", "cpv", "pvi", "mpV", "Pvs", " pj", "pvt", "mpv", "PV", "Pj", "pvs", "parV", "cpj", "cpvs", "Pvt", "Pvi", "parv", "parvi", "mpvt", " pvs", "parvt", "cpvi", "mpvi", " pvi", "pV", "pj"], "size": [" offset", " Size", "length", " len", "_", " unused", " sized", "SIZE", "len", "ize", " notice", " sizes", " st", "e", " resize", "n", "space", "Size", " enc", "s", " scale", " count", " sh", " shr", " sum"], "v": ["cv", "sv", "g", "a", "c", "ov", "i", "q", "y", "vs", "p", "V", "iv", "pi", "u", "lv", "r", "vol", "l", "m", "vi", "vm", "b", "var", "n", "ev", "s", "va", "uv", "nv", "tv", "w", "vt", "inv", "av", "t", "j", "vp"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n", "idx": 18220, "substitutes": {"json": ["new", "java", "xml", "bind", "all", "javascript", "jobs", "ja", "final", "result", "widget", "root", "js", "kj", "params", "needs", "jj", "np", "obj", "journal", "spec", "query", "value", "row", "join", "jack", "database", "state", "print", "latest", "mson", "full", "data", "JSON", "stats", "son", "it", "raw", "alert", "ij", "response", "j", "job"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_record_dump(void)\n\n{\n\n    PCRecord **pr, *r;\n\n    int i, h;\n\n    FILE *f;\n\n    int64_t total, sum;\n\n\n\n    pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n\n    i = 0;\n\n    total = 0;\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {\n\n            pr[i++] = r;\n\n            total += r->count;\n\n        }\n\n    }\n\n    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n\n\n\n    f = fopen(\"/tmp/kqemu.stats\", \"w\");\n\n    if (!f) {\n\n        perror(\"/tmp/kqemu.stats\");\n\n        exit(1);\n\n    }\n\n    fprintf(f, \"total: %\" PRId64 \"\\n\", total);\n\n    sum = 0;\n\n    for(i = 0; i < nb_pc_records; i++) {\n\n        r = pr[i];\n\n        sum += r->count;\n\n        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",\n\n                r->pc,\n\n                r->count,\n\n                (double)r->count / (double)total * 100.0,\n\n                (double)sum / (double)total * 100.0);\n\n    }\n\n    fclose(f);\n\n    free(pr);\n\n\n\n    kqemu_record_flush();\n\n}\n", "idx": 18231, "substitutes": {"pr": ["kr", "hr", "lr", "cr", "br", "rs", "mr", "ins", "pre", "iter", "pir", "err", "rl", "mp", "per", "fr", "ro", "tr", "res", "pp", "pi", "pb", "pit", "rr", "Pr", "pl", "ver", "arr", "gr", "expr", "ra", "pol", "pc", "list", "pt", "rec", "pa", "vp", "ocr", "po", "por", "spr", "print", "PR", "cur", "par", "pro", "dr", "py", "pri", "ptr", "ch", "ps", "rep", "repl", "pse", "wr", "p"], "r": ["rt", "lr", "kr", "hr", "reg", "attr", "cr", "br", "g", "rf", "rs", "er", "mr", "entry", "result", "vr", "c", "nr", "ren", "rh", "err", "rc", "rl", "rar", "rem", "or", "q", "fr", "ro", "rb", "tr", "res", "rg", "obj", "rr", "re", "ur", "rel", "sr", "e", "gr", "rect", "l", "d", "rec", "b", "R", "v", "ar", "pair", "w", "dr", "rm", "adr", "usr", "t", "rer", "rd", "range", "rn", "repl", "p"], "i": ["is", "bi", "gi", "ind", "init", "iter", "xi", "ri", "ki", "cli", "ai", "ia", "or", "batch", "li", "ic", "ui", "y", "ip", "iat", "ish", " ii", "ami", "\u0438", "pi", "iu", "qi", "u", "im", "zi", "ci", "l", "sim", "m", "me", "index", "id", "ji", "b", "v", "I", "o", "n", "ii", "ti", "ei", "phi", "ix", "x", "count", "di", "uri", "it", "mi", "ie", "hi", "ij", "ini", "multi", "j", "si", "p"], "h": ["hr", "ih", "high", "ht", "th", "bh", "ho", "hd", "hh", "H", "rh", "hal", "he", "hu", "y", "go", "ha", "sh", "hz", "pl", "hm", "oh", "ah", "m", "index", "ph", "kh", "k", "n", "his", "hl", "history", "phi", "count", "w", "hp", "hi", "zh", "ch", "t", "hash", "hs", "gh", "p"], "f": ["fd", "fab", "cf", "ff", "fl", "ok", "open", "rf", "g", "fp", "a", "c", "df", "fb", "ef", "fc", "lf", "q", "fr", "y", "fx", "F", "u", "e", "ac", "l", "tf", "m", "d", "fa", "b", "v", "fm", "uf", "o", "s", "sf", "fi", "file", "w", "it", "bf", "fo", "xf", "fn", "t", "conf", "fs", "z", "j", "p"], "total": ["ta", "tar", " summed", "mu", "max", "table", "database", "where", "trace", "eta", "oot", "normal", "done", " unused", "title", "shared", "ot", " TOTAL", "null", "human", "net", "pi", "ms", "pty", "zero", "ma", "summary", "now", " totals", "global", "full", "general", "required", "meta", "unit", "tm", "length", "all", "ne", "result", "OTAL", " final", "otal", "valid", "size", "unknown", "none", "mean", "count", "no", "number", "last", "Total", "created", "ota", "si", "final", " Total", "info", "scale", "doc", "public", "note", "list", " summary", "num", "equal", " tot", "current", "base", "tree", "t", "details", "pretty"], "sum": ["us", "tm", "volume", "all", "ne", "st", "result", "so", "a", "mm", "otal", "cum", "average", "info", "size", "tail", "ss", "su", "diff", "amount", "acc", "Sum", "mu", "miss", "um", "ms", "vol", "sim", "m", "num", "summary", "index", "ma", "sp", "zero", "v", "se", "out", "tu", "mean", "missing", "alpha", " SUM", "count", "stats", "mem", "sam", "nt", "hash", "sa", "unique", "add", "multi", "si"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 18254, "substitutes": {"opaque": ["operity", "oposter", "operoster", "Opque", "operaque", " opque", "opity", "ipac", "opient", "opque", "Opient", "Opity", "ipity", "opoid", "Opaque", " Opient", " Opque", " opoid", "Oposter", "ipaque", "Opac", "opac", " opient", "operac", " Opaque", "Opoid", "iposter", " Opoid"], "buf": ["tmp", "ff", "text", "cv", "block", "box", " buffer", "br", "cache", "ref", "pkg", "map", "vec", "iter", "wb", "good", "Buff", "buffer", "cap", "Buffer", "rb", "tr", "doc", "img", "cb", "pb", "orig", "aka", "BU", "broad", "b", "v", "txt", "ctx", "uf", "code", "bc", "alloc", "cmd", "db", "data", "mem", "seq", "msg", "w", "raw", "buff", "bin", "bl", "pool", "queue", "batch"], "size": ["sn", "shape", "max", "e", "address", "message", "small", "grow", "v", "time", "send", "capacity", "storage", "mem", "status", "limit", "needed", "offset", "sw", "style", "len", "body", "zero", "now", "negative", "global", "area", "code", "space", "total", "empty", "notice", "name", "window", "length", "sum", "g", "sent", "buffer", "dim", "set", "l", "sp", "member", "count", "number", "no", "type", "fee", "draw", "params", "SIZE", "scale", "padding", "ize", "too", "large", "height", "num", "id", "gz", "see", "Size", "data", "equal", "format", "news", "start", "eng", "sh", "z", "timeout"], "s": ["is", "er", "as", "sn", "a", "c", "h", "args", "sm", "js", "or", "ies", "vs", "ims", "o", "stats", "qs", "ses", "als", "bits", "sw", "xs", "ss", "serv", "ns", "obj", "spec", "ms", "sie", "space", "sports", "an", "w", "S", "sis", "hs", "sl", "sts", "g", "rs", "sq", "ex", "self", "os", "set", "m", "socket", "sb", "ar", "x", "ssl", "gs", "sa", "comm", "bs", "ls", "fts", "sv", "ins", "changes", "r", "ats", "ts", "sys", "its", "d", "n", "se", "ds", "sam", "ps", "t", "fs", "z", "j", "es"], "buf1": [" buf3", "buff2", "buffer1", "uf1", "buf0", "buff1", " buf2", "buffer2", "uf2", "uf3", "buffer0", "buffer3", "buff0", "buf3", "buff3", "buf2", "uf0"], "remaining": ["remain", "restaining", "Remained", "remmore", " remmore", "restained", "Remaining", "remained", "Remmore", " remain", "restmore", "Remain", " remained", "restain"], "rmd": ["rnd", "pmd", "crcmd", "ercmd", "pcmd", " rnd", "mmd", " rmt", " rds", "rds", "crmd", "pnd", "rcmd", "ermn", "mds", " rMD", "rmt", "crmt", "rrmd", "crmn", "ermd", "mmt", "mcmd", "mMD", "rmn", "rrMD", " rmn", "mnd", "rrds", "rMD", " rcmd", "rrcmd", "ermt", "pmt"], "i": ["bi", "gi", "ind", "c", "xi", "cli", "ai", "MI", "oi", "li", "ui", "ic", "in", "iat", "\u0438", "ims", "pi", "iu", "qi", "u", "im", "e", "zi", "ci", "l", "me", "m", "index", "v", "n", "I", "ii", "ti", "phi", "ix", "x", "di", "it", "mi", "hi", "ini", "multi", "j", "si"], "nrda": ["nndda", " Nrcna", "nldata", "nddo", "nrandA", "nrownan", "nrdo", " Nrcata", "nrandba", "nrida", "nrdna", "nrowna", "nnrda", "nranda", " nrdba", "nrcna", " nrdao", "nlda", "nddata", "nldo", "nrdA", "nrandao", " Nrda", " nrownA", " nrowna", " nrownao", "nridao", "nrownao", "nrdan", "nldan", " Nrdna", " Nrdan", "nrcan", "nrowno", "nddA", "nnddo", "nnrdo", "nnrdA", " Nrcan", "nrownata", "nldA", "nrdao", "nnddata", "nrownba", "nrcata", "nnrdata", "nnddA", "nrownA", "nridA", "ndda", " nrownba", "nrca", "nldna", " Nrca", " nrdA", "nrownna", " Nrdata", "nrdba", "nridba", "nrdata"], "rcvrc": ["rcrevrl", "RCvrrc", "rcvright", "rlverc", "rcvertarc", " rcsvarc", "rcvinrr", "rcvrarc", "rcuvrc", "rcsvrs", "rcvtright", " rcsvrs", "rccvRC", "rcvcRC", "RCvrroc", "rcvrrc", "rcuverc", "RCsvront", "RCvrr", "RCvrrr", "RCvcmp", "RCvrRC", "rcsvRC", "rcver", "rcverc", " rcver", "rcnvarc", "rcvinr", " rcvrs", "rcvrrl", "rcvert", "rcvrt", " rcvert", "rcvinrt", "rlreverc", "rlvrc", "rcvrrs", " rcverc", "RCsvRC", "RCvrirc", "rcvroc", "rcsvrc", "rcsvfc", "rcvcmp", "rcvarc", "RCvrcmp", "rcvertrc", "rcvront", "rcvrrr", " rcveright", "rlvrl", "rcvrr", "RCvroc", "rcVRC", " rcVrl", "RCvrc", " rcVrc", "rlrevarc", " rcvrl", "rcuvRC", "rcvcfc", "rcuvarc", "rccvirc", "rcvfc", "RCsvfc", "rcvRC", "rcvinRC", "rcvrl", "RCvfc", "rcsvrl", "rlrevrl", "rcvcront", "rcvrRC", "rcnvrl", "rcvertRC", "rcreverc", " rcvrt", "rcvertrr", "rcvr", " rcVRC", " rcvright", " rcvRC", " rcsvrl", "rcvertrl", "rcsvarc", " rcvr", "rcvrirc", "rcuvrl", "RCsvrc", "rcvinroc", "rcverterc", "rccvrc", "rcvirc", "rcuvcmp", "rccvcmp", "rcvcrc", "rcvtrc", "rlrevrc", "rcvtr", "rcVrc", "rcvrroc", "rcsvront", " rcvarc", "rcrevrc", "rlvarc", "rcvrcmp", "rcvinrc", "rcvinright", "rcVrl", "rcvertroc", "RCvRC", "RCvirc", "rcvtrt", "RCvront", "rcnvrc", "rcvrs", "rcnvrs", "rcrevarc", "rcuvirc", " rcsvrc", "rcveright"], "CSR_RCVRC": ["CSR_RMVRC", "CSR_RCvRS", "CSR_RCFRS", "CSR_RCFLL", "CSR_RMvRL", "CSR_RMVRL", "CSR_UCVREF", "CSR_RCFLC", "CSR_RCFINC", "CSR_UCvRC", "CSR_RMvLL", "CSR_RCNLL", "CSR_RCVERRS", "CSR_RCNLC", "CSR_RCNRC", "CSR_RMvRS", "CSR_RMVRS", "CSR_RCVSRC", "CSR_RCCVRC", "CSR_RCVLL", "CSR_RCVINC", "CSR_UCVRFC", "CSR_RMVLL", "CSR_RCFRC", "CSR_RCvINC", "CSR_RCVRFC", "CSR_RCVSRFC", "CSR_RCVRL", "CSR_RCVREF", "CSR_RMvLC", "CSR_RCvLC", "CSR_RCvLL", "CSR_RCvRFC", "CSR_RMvINC", "CSR_RCVSRL", "CSR_RCVSREF", "CSR_RCFRL", "CSR_RCVLC", "CSR_UCvRFC", "CSR_RCvRC", "CSR_UCvRL", "CSR_UCVRL", "CSR_RCVRS", "CSR_RCVERINC", "CSR_RCvREF", "CSR_UCvREF", "CSR_RCCVRFC", "CSR_RMVLC", "CSR_UCVRC", "CSR_RCVERRL", "CSR_RCvRL", "CSR_RCVERRC", "CSR_RMvRC", "CSR_RCCVRL", "CSR_RMVINC", "CSR_RCCVREF", "CSR_RCNRL"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        /* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         */\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  */\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n", "idx": 18267, "substitutes": {"opaque": ["copaques", "opsacement", "copaque", "popaque", "popus", "paque", " opus", "opsaque", "opga", " opica", "oppga", "oppica", "copacement", "psolete", "opacement", "popica", "oppaque", "popga", "opsolete", "paques", " opga", "opssolete", "oppus", "opica", "opus", "pacement", "opaques", "opsaques", "copsolete"], "s": ["is", "as", "states", "a", "h", "c", "js", "ies", "y", "details", "ims", "has", "stats", "qs", "ses", "less", "als", "aws", "sw", "ss", "https", "ns", "events", "spec", "session", "ms", "actions", "parts", "bis", "sports", "services", "w", "S", "cs", "conf", "sis", "hs", "p", "sl", "sts", "g", "rs", "south", "ops", "mos", "sq", "aunts", "service", "self", "os", "ess", "sp", "socket", "sb", "ssl", "gs", "comm", "bs", "ls", "Ws", "sv", "changes", "settings", "params", "r", "ats", "sync", "ts", "sys", "its", "b", "ties", "n", "ds", "ps", "t", "fs", "j", "es"], "i": ["f", "is", "g", "bi", "iri", "gi", "jp", "c", "ri", "xi", "ki", "cli", "ai", "iy", "ity", "oi", "li", "dim", "ui", "y", "in", "iat", "\u0438", " ii", "pi", "iu", "qi", "zi", "ci", "l", "ati", "m", "index", "ori", "v", "I", "n", "j", "bis", "ii", "ti", "fi", "phi", "ix", "di", "uri", "it", "mi", "ij", "ini", "multi", "si", "p"], "ret": ["f", "rt", "ext", "gt", "ref", "result", " RET", "ri", "iter", "cat", "err", "lt", "def", "cont", "dt", "len", "del", "res", "tr", "net", "elt", "re", "att", "r", "flag", "RET", "Ret", "ter", "sys", "v", " Ret", "back", "ft", "inter", "reset", "val", "fi", "rets", "cmd", "desc", "alt", "deg", "status", "it", "mi", "nt", "fun", "try", "rm", "pret", "mt", "t", "j", "red", "ry"]}}
{"project": "FFmpeg", "commit_id": "5e5f75cf8abd76ada3011790a9b4f0762a72e41a", "target": 0, "func": "static void ffm_write_data(AVFormatContext *s,\n\n                           const uint8_t *buf, int size,\n\n                           int64_t pts, int header)\n\n{\n\n    FFMContext *ffm = s->priv_data;\n\n    int len;\n\n\n\n    if (header && ffm->frame_offset == 0) {\n\n        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;\n\n        ffm->pts = pts;\n\n    }\n\n\n\n    /* write as many packets as needed */\n\n    while (size > 0) {\n\n        len = ffm->packet_end - ffm->packet_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(ffm->packet_ptr, buf, len);\n\n\n\n        ffm->packet_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        if (ffm->packet_ptr >= ffm->packet_end) {\n\n            /* special case : no pts in packet : we leave the current one */\n\n            if (ffm->pts == 0)\n\n                ffm->pts = pts;\n\n\n\n            flush_packet(s);\n\n        }\n\n    }\n\n}\n", "idx": 18268, "substitutes": {"s": ["f", "is", "sts", "sv", "rs", "as", "aws", "a", "c", "h", "sq", "js", "i", "self", "os", "ss", "sc", "serv", "ns", "u", "r", "e", "ats", "ts", "m", "d", "sys", "acs", "b", "v", "n", "o", "ds", "qs", "w", "S", "gs", "cs", "ps", "t", "comm", "conf", "fs", "p"], "buf": ["text", "window", "ff", "cv", "length", "block", "box", " buffer", "br", "offset", "end", "ref", "vec", "bar", "Buff", "xff", "buffer", "Buffer", "rb", "tr", "bytes", "pos", "img", "read", "cb", "pb", "orig", "src", "arr", "off", "b", "v", "uf", "bc", "cmd", "data", "cur", "mem", "seq", "msg", "bl", "raw", "buff", "addr", "ptr", "queue", "batch"], "size": ["window", "length", "sum", "zone", "all", "offset", "ose", "g", "scroll", "en", "type", "cache", "south", "sent", "shape", "buffer", "SIZE", "scale", "padding", "ize", "bytes", "too", "pos", "body", "spec", "set", "max", "im", "message", "small", "l", "any", "m", "num", "zero", "now", "sp", "gz", "v", "n", "time", "area", "space", "total", "Size", "send", "since", "empty", "notice", "count", "capacity", "storage", "number", "msg", "needed", "range", "z", "name", "si"], "pts": ["psns", "ctds", "ptts", "colxs", "ptds", " ptst", "ffts", "pkgts", "montds", "pointss", "pkggs", "ptns", " ptxs", "fontss", "pss", "ctts", "ports", "pkgs", "portts", "oints", "iptxs", "pkgt", "pointts", "ffs", "pointns", "ctt", "ointxs", "iptds", "montts", "ffgs", "colts", "cols", "fonts", "iptt", " ptss", " ptt", "psrs", "portrs", "cts", "ointt", " ptials", "prss", "fontxs", "monts", " ptsials", "ptrs", "ptss", "ptials", "fontts", "iptts", "fft", "prs", "ctgs", "ointials", "points", "colss", "ipts", "pointrs", "prts", "psts", "prrs", "psss", "ptgs", "portns", "ptt", "iptss", " ptsxs", "montt", "ptxs"], "header": ["extra", "type", "block", "offset", "filter", "shift", "h", "virtual", "title", "Header", "heading", "ck", "buffer", "dt", "padding", "version", "error", "body", "head", "debug", "event", "flag", "border", "cover", "check", "table", "headers", "index", "gz", "layer", "comment", "empty", "first", "forced", "frame", "required", "dr", "magic", "half", "hidden", "only", "name"], "ffm": ["flmd", "ffmac", "uffmm", "xffdm", "effd", "efftm", "effmo", "ffmm", "uffsm", "xffvm", "aftmd", "ufftm", "effmc", "xffmi", "uffmo", "ffieldman", "fferwm", "uffgm", "ffdm", "buffmo", "uffmac", "uffm", "aftnm", "aftd", "ffmc", "ffieldmat", "aftcm", "fftm", "buffdm", " ffg", "effvm", "effm", "uffdm", "effmm", "ffieldem", " ffms", "ffarm", "uffmc", "ffieldcm", "ffms", "xffarm", "xffgm", "uffg", "buffarm", "uffcm", "uffmt", "uffem", "ffermm", "xffmanager", "ffieldnm", "uffnm", " ffmanager", "effmat", "xffm", "uffmd", "flcm", "ffmo", "ffcm", " ffdm", "ffg", "effem", "ffgm", " ffmm", "effgm", "effM", "aftm", "ffmt", "effrm", "buffem", "ffmat", "effnm", "effmi", "effcm", "buffv", "uffmat", "xffrm", "xffM", "effmt", " ffwm", "xffg", "uffd", "fxm", " ffmac", "effsm", "buffM", "fxrm", "ushmm", "aftmc", "flm", "uffms", "ffnm", "ffieldm", "xffem", "buffvm", "ffman", "uffv", "ffvm", "ffd", " ffsm", "ffmi", "buffm", "uffmi", "ffmanager", "afttm", "fferm", "ushnm", "aftM", "xffman", "flM", "ffrm", "ffersm", "ffem", "uffwm", "ushtm", "buffms", "ushm", "effdm", "xffsm", "buffmi", "fxsm", "ffmd", "ffM", "fxgm", "ffv", " ffarm", "xffmac", " ffv", "ffsm", "ffieldgm", "uffM", "ffwm", "xffnm", "aftmt", " ffmi", "uffman", "buffmanager"], "len": ["ls", "sl", "fl", "length", "lan", "all", "end", "en", "Len", "vec", "lt", "iter", "kl", "lit", "dl", "lf", "le", "nl", "li", "split", "comp", "fin", "del", "syn", "bytes", "pos", "elt", "loc", "ll", "pl", "fil", "enc", "lp", "vol", "rev", "l", "el", "sp", "gz", "n", "hl", "val", "str", "lim", "lon", " l", "full", "coll", "alt", "compl", "mem", "deg", "seq", "lib", "els", "ln", "fun", "ler", "gen", "lic", "limit", "wid", "il", "L", "cmp", "ld", "z"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n\n                struct vmsvga_cursor_definition_s *c)\n\n{\n\n    QEMUCursor *qc;\n\n    int i, pixels;\n\n\n\n    qc = cursor_alloc(c->width, c->height);\n\n    qc->hot_x = c->hot_x;\n\n    qc->hot_y = c->hot_y;\n\n    switch (c->bpp) {\n\n    case 1:\n\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,\n\n                        1, (void*)c->mask);\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n\n#endif\n\n        break;\n\n    case 32:\n\n        /* fill alpha channel from mask, set color to zero */\n\n        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,\n\n                        1, (void*)c->mask);\n\n        /* add in rgb values */\n\n        pixels = c->width * c->height;\n\n        for (i = 0; i < pixels; i++) {\n\n            qc->data[i] |= c->image[i] & 0xffffff;\n\n        }\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n\n#endif\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n\n                __FUNCTION__, c->bpp);\n\n        cursor_put(qc);\n\n        qc = cursor_builtin_left_ptr();\n\n    }\n\n\n\n    dpy_cursor_define(s->vga.ds, qc);\n\n    cursor_put(qc);\n\n}\n", "idx": 18272, "substitutes": {"s": ["f", "ls", "is", "sl", "sts", "g", "rs", "ins", "sn", "states", "south", "h", "js", "os", "ss", "sc", "ns", "sd", "r", "l", "d", "ts", "its", "sys", "sp", "es", "v", "n", "sports", "sb", "stats", "ds", "ses", "S", "gs", "cs", "ps", "t", "bs", "hs", "p"], "c": ["f", "cf", "lc", "cv", "config", "g", "cache", "chain", "sec", "C", "content", "err", "cm", "abc", "rc", "fc", "anc", "com", "mc", "cont", "sc", "cp", "etc", "gc", "unc", "tc", "enc", "cu", "ac", "pc", "l", "nc", "d", "m", "con", "call", "cc", "cl", "v", "b", "ct", "ctx", "bc", "xc", "ce", "desc", "toc", "coll", "col", "cur", "ec", "cod", " C", "w", "cs", "t", "cmp", "co", "conf", "arc", "dc", "cd", "p"], "qc": ["eqdc", "qac", "questt", " qt", "questcs", " qgc", "qlcor", "sqf", "requcr", "requc", "qdc", "checkcon", "aqp", "qup", "dqgc", "qupc", "qcon", "querypc", "qcu", "eqcu", "qf", "qqcr", "iqac", "sqcache", "checkcache", "qqac", "iqc", "dqcon", " qp", "qqfc", "eqfc", "sqpc", " qcu", "querygc", "qgc", " qpc", "qucor", "sqcs", "qlcache", "eqc", "checkc", "questlc", "qr", "qlc", "requcache", "iqgc", "sqfc", "iqcache", "qcache", "qqpc", "qqcache", "eqpc", "querycu", " qcr", "dqcu", "dqc", "qpc", "eqcache", "qut", "iqpc", "qqcu", "qucache", " qdc", "qcor", "qur", "qp", "qcs", "questcache", "questfc", " qcache", "sqc", "dqlc", "qfc", "sqcon", "questc", "sqt", "qugc", "sqlc", " qfc", "checkpc", "qucon", "iqcu", " qr", "iqdc", "questcon", "qlpc", "qt", "aqt", "iqf", "requcu", "aqc", " qcs", "dqpc", "queryc", "aqr", "qqc", " qcor", "qulc", " qcon", "dqcache", "quc", "quf", "sqgc", "dqac", "qcr"], "i": [" ki", "is", "ik", "g", "bi", "gi", "ind", " mi", "iter", "ri", "xi", "ki", "ai", "ity", "oi", "batch", "li", "ui", "ic", "y", "ip", "io", "in", " ii", "ami", "ims", "pi", "\u0438", "qi", "u", "iu", "remote", " bi", "zi", "ci", "ms", "my", "sim", "m", "asi", "me", "id", "index", " pi", "ji", "v", "I", "o", "j", "PI", "ii", "ti", "ei", "phi", "ix", "x", " ti", "span", "di", " ni", " si", "mi", "it", "uri", "ij", "ini", "multi", "si", "p"], "pixels": ["molls", " polls", "paorts", "polls", "prows", "ppixels", "mixels", "pips", "piles", "ports", "pairs", "Polls", "Pixels", "ppix", "pix", "ppips", "paix", " prows", " piles", "apixels", "paips", "pports", " pix", "paixels", "spix", "sprows", "aprows", "sports", "aports", "Pairs", "apix", " ports", "spixels", "Piles", " pips", "miles", "mairs", " pairs"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,\n\n                                          ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    for(i=0; i<4; i++){\n\n        pixel v = pix[-1];\n\n        pix[0]= v += block[0];\n\n        pix[1]= v += block[1];\n\n        pix[2]= v += block[2];\n\n        pix[3]= v +  block[3];\n\n        pix+= stride;\n\n        block+= 4;\n\n    }\n\n}\n", "idx": 18279, "substitutes": {"_pix": ["_pip", "_jpile", "_spixels", "_jpix", " _pixels", "_spix", "_cpip", "_cpix", "_mpix", " _spile", "_cpixels", " _pip", "_pile", "_npile", "_cpile", "_cpich", " _spip", "_spip", "_pixels", "_mpip", "_jpich", "_spile", "_mpixels", "_npix", " _spix", " _spixels", "_pich", "_mpile", " _pile", "_jpixels", "_npich", "_npixels"], "_block": ["___block", "_link", "objblock", "_chain", "_group", "objlist", " _Block", "_Block", "objgroup", "___group", " _type", " _link", "___chain", "_list", "___list", "objchain", "_type"], "stride": ["strimate", "shrride", "STRide", "Stride", " strimate", "strope", " strope", "shrice", "strice", "shride", "sride", "simate", " strride", "trope", "divride", "sope", "trides", "side", "divope", "divide", "Strride", "trride", "Strope", "shrope", "divides", "STRides", "STRride", "strride", "shrimate", "strides", "tride", "divice", "Strice", "STRope"], "i": [" n", " I", "is", "g", "bi", " my", "gi", "ind", "init", " mi", "c", "iter", "xi", "ki", "ai", "ini", "batch", "q", "li", "ui", "ic", "ip", "in", " ii", "pi", "iu", "qi", "im", " bi", "ci", "zi", "e", "sim", "m", "asi", "me", "index", "id", " pi", "v", "I", "n", "out", " iter", "ii", "ti", "print", "phi", "x", " ti", " x", " m", "di", "it", "mi", " j", " multi", "try", "t", "multi", "j", "si", "p"], "pix": ["pcfix", "cpip", " pixels", "opfix", "px", "opip", "pip", " px", "cachefix", "pcix", "spIX", "ipix", "pfix", "cpig", "ipil", " pIX", "publicip", " pip", "Pixels", "pixels", "npfix", "pixel", "Pip", "cacheich", "Pix", "cacheix", "cpfix", "pich", "spip", "opix", "opich", "spix", "pond", "opixels", "cpIX", "cpix", " pixel", "opIX", " pil", "cacheIX", " pich", "npip", "cpx", "Px", "ipx", "pig", "ipixel", "pil", "publicIX", " pond", "cpixel", "npixels", "cpixels", "publicond", "pIX", "pcig", " pfix", "spond", "publicix", "pcx", " pig", "cpil", "npix"], "block": ["proc", "unit", "window", "type", "bit", "box", "label", "offset", "ref", "filter", "chain", "map", "part", "c", "channel", "point", "lock", "use", "def", "buffer", "pen", "pixel", "version", "byte", "wall", "line", "event", "band", "Block", "set", "group", "r", "check", "commit", "none", "sync", "list", "zero", "row", "cl", "k", "record", "join", "rule", "b", "out", "axis", "link", "bin", "bl", "inv", "word", "pack", "tag", "snap", "co", "hash", "field", "name"]}}
{"project": "qemu", "commit_id": "6ca8d0fd51154c37b571ea74dd0b3e7a60ab847a", "target": 0, "func": "static void set_proc_name(const char *s)\n\n{\n\n#ifdef __linux__\n\n    char name[16];\n\n    if (!s)\n\n        return;\n\n    name[sizeof(name) - 1] = 0;\n\n    strncpy(name, s, sizeof(name));\n\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n\n       This simple way is enough for `top'. */\n\n    prctl(PR_SET_NAME, name);\n\n#endif    \t\n\n}\n", "idx": 18282, "substitutes": {"s": ["f", "ls", "text", "is", "sts", "g", "rs", "sv", "a", "c", "sq", "h", "js", "names", "ss", "strings", "y", "in", "bytes", "ns", "r", "ts", "m", "d", "b", "v", "txt", "n", "parts", "space", "sb", "str", "w", "S", "gs", "ps", "t", "p"], "name": ["new", "window", "type", "all", "cache", "nm", "array", "init", "map", "part", "c", "info", "size", "mask", "self", "def", "names", "cap", "null", "ns", "al", "class", "spec", "set", "group", "none", "l", "list", "num", "id", "path", "local", "sp", "v", "n", "se", "out", "code", "key", "str", "prefix", "Name", "data", "NAME", "file", "normal", "mem", "no", "w", "word", "base", "start", "t", "ame", "p"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 18285, "substitutes": {"client": ["to", "close", "window", "component", "cell", "collection", "config", "open", "cache", "conn", "connection", "complete", "c", "lock", "plugin", "cli", "connect", "use", "parent", "application", "service", "manager", "store", "ic", "server", "null", "net", "util", "pattern", "master", "public", "api", "session", "remote", "list", "call", "network", "con", "qualified", "local", "cl", "n", "ct", "core", "template", "force", "Client", "web", "prefix", "cmd", "on", "google", "http", "cod", "common", "controller", "current", "node", "nt", "t", "co", "response", "p"], "request": ["component", "execute", "forward", "shift", "document", " argument", "setup", "attribute", "address", "query", "message", "project", "print", "quest", "req", "pair", "frame", "begin", "art", "transform", "command", "new", "complete", "report", "application", "order", "consider", "reference", "index", "accept", "template", "change", "package", "cmd", "input", "police", "header", "ire", "create", "require", "push", "update", "condition", "claim", "post", "child", "q", "buffer", "enter", "error", "load", " requesting", "set", "match", "record", " command", "instance", "seek", "task", " attempt", "QUEST", "batch", "have", "type", "parse", "initial", "open", "copy", "connect", "search", "requ", "select", "public", "call", "question", "import", "local", " query", "param", "rule", "reset", "Request", "common", "current", "start", "transfer", "response", " requested"], "reply": ["shell", "response", " answer", "result", "route", "part", " replied", "err", "bill", "post", "report", "service", "onse", "nl", "callback", " response", "error", "ish", "related", "Reply", "rr", "flag", "match", "r", "resp", "query", "sett", "table", "sync", "apply", "message", " replies", "force", "back", "bis", "respond", "comment", "echo", "proxy", "prefix", "replace", "notice", "write", "next", "link", "output", "lib", "ply", "relation", "mi", "msg", "command", "try", "queue", "answer", "transfer", "dict", "repl", "ror", "reverse", "job"], "ret": ["rt", "f", "tmp", "pat", "ext", "gt", "ref", "result", "round", "jp", " RET", "lt", "err", "def", "cont", "len", "res", "net", "gc", "elt", "re", "lv", "arr", "r", "resp", "flag", "det", "RET", "Ret", "ter", "sys", "num", "tf", "txt", "back", "out", "ft", "nz", "inter", "backed", "val", "rets", "print", "db", "gb", "cmd", "data", "desc", "et", "alt", "mem", "deg", "status", "arg", "fun", "nt", "rm", "pret", "ptr", "mt", "t", "j", "ry"]}}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n\n                                      CL_TRUE,CL_MAP_READ, 0, buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(dst_buf, mapped, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18304, "substitutes": {"dst_buf": ["ddest_buf", "dst_map", "dst_buff", "ddest_uf", "dest_buff", "dst_uf", "dst_buffer", "dest_buffer", "dest_buf", "ddest_buff", "dest_map", "ddest_buffer"], "src_cl_buf": ["src_scl_buff", "src_cl_buff", "src_cl___buf", "src_scl_uf", "src_cl__queue", "src_cl_queue", "src_scl_buffer", "src_scl_queue", "src_cl___cv", "src_cl__uf", "src_cl_cv", "src_scl_buf", "src_cl__buf", "src_cl_buffer", "src_cl_uf", "src_cl___buff", "src_scl_cv", "src_cl___buffer", "src_cl__buff"], "buf_size": ["buf2SIZE", "buf2size", "uf_len", " buf_Size", "uf2len", "uf2SIZE", "buf_fee", "buf_Size", " buf_fee", "buftstart", "buftSize", "buf_SIZE", "uf_size", "uf_SIZE", "uf2size", "buf1length", "uf2length", "buf_length", "buftsize", "buf_start", "buf2len", "buf1size", " buf_start", "uf_length", "buf1len", "buf1SIZE", "buf_len", "buf2length"], "status": ["Status", "uses", " Status", " state", "check", "scan", "complex", " STAT", "active", "wait", " count", "stats", " j", "comments", " s", "usage", "xml", "cgi", "activation", "sw", "warning", "complete", "report", "json", " spec", "spec", "expr", " active", "progress", "login", "index", "summary", " stat", "vis", "code", "esp", " success", "binding", "state", "s", "console", "html", "success", " score", "msg", "source", " scr", "p", "ser", "atus", " wait", " sw", "result", "confirmed", "user", "err", "valid", "service", "size", "error", "version", "flag", " progress", " error", "sim", "sp", "record", "git", " usage", "prefix", "count", "ssl", "type", "speed", "res", " resp", "doc", "gc", " speed", "arity", "note", "r", "score", "any", "sync", "list", "id", "ping", "n", " exists", "sql", "wa", "str", "format", "current", "magic", "stat", "t", "details"], "mapped": ["mached", "map", "Mapping", "mapping", "smapped", "mmapping", "maped", " mached", "smaped", "mmached", "Maped", " maped", " map", "smapping", "lapping", "Mapped", "mmapped", "lapped", "laped", "Map", "mmaped", "smap", "Mached", " mapping", "lap"]}}
{"project": "FFmpeg", "commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "target": 1, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id > sc->stsd_count)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 18311, "substitutes": {"c": ["f", "cf", "lc", "cv", "cr", "config", "g", "cache", "cn", "C", "ca", "cm", "fc", "rc", "abc", "anc", "com", "mc", "cont", "etc", "tc", "enc", "e", "cu", "ci", "ac", "pc", "l", "nc", "m", "con", "call", "cc", "cl", "ctx", "v", "ct", "n", "bc", "ce", "coll", "ec", "cs", "ch", "t", "co", "conf", "dc", "cd", "p"], "pb": ["proc", "px", "bb", "amp", "ub", "PB", "pkg", "bj", "fp", "jp", "wb", "fb", "pause", "mp", "tab", "asm", "cp", "conv", "rb", "bp", "pp", "p", "pan", "np", "cb", "pl", "phy", "tc", "stab", "patch", "lp", "pm", "buf", "tap", "pc", "resp", "wp", "pt", "erb", "conf", "tf", "arb", "sp", "eb", "b", "ctx", "pa", "uf", "sb", "bc", "db", "pg", "lb", "pel", "req", "tk", "pro", "py", "buff", "typ", "ob", "pack", "emb", "mb", "bs", "dp", "tp", "vp"], "atom": ["nm", " app", " om", " symb", " ob", " Atom", " atoms", " nm", "obj", "orm", " exc", "um", "m", "b", " err", "o", "om", " sp", "x", " cmd", " p", " m", " orb", " buf", " ab", "p"], "st": ["ost", "sts", "th", "cr", "sv", "sn", "sw", "so", "sec", "ste", "std", "nd", "sta", "ss", "tr", "p", "ut", "inst", "set", "src", "St", "est", "sp", "ST", "ct", "ft", "ocr", "s", "str", "ust", "stra", "stat", "start", "stable", "mt", "ch", "ace", "t", "sh", "rest", "ist"], "sc": ["lc", "cv", "osc", "cgi", "config", "scl", "cam", "sec", "craft", "cer", "cm", "fc", "rc", "usc", "anc", "psc", "mc", "ss", "SC", "scale", "comp", "gc", "loc", "sh", "soc", "sd", "spec", "tc", "enc", "cu", "set", "ci", "sci", "ac", "pc", "sync", "nc", "can", "sys", "scan", "cc", "Sc", "sp", "cl", "ctx", "ctl", "scrib", "bc", "uc", "desc", "asc", "ec", "capt", "scope", "cs", "isc", "ch", "sch", "sche", "cmp", "esc", "dc"], "i": ["is", "iri", "init", "h", "y", "ip", "ami", " ii", "ims", "qi", "e", "series", "v", "I", "ii", "phi", "span", "hi", "f", "cgi", "iter", "ui", "\u0438", "pi", "im", "ms", "index", "s", "mi", "iq", "multi", "p", "ice", "gi", "ind", "ri", "xi", "ki", "cli", "ai", "q", "li", "iu", " bi", "ci", "l", "sim", "m", "me", "ti", "instance", "x", "uri", "try", "ij", "ski", "si", "batch", "bi", "info", "ini", "ic", "in", "zi", "id", "n", "ei", "fi", "ix", "di", " ni", "it", "t", "j", "oi"], "entries": ["entlements", "gentrys", "gentlements", "gentry", "Entresses", "entry", "Entrys", "Entlements", "entsrants", " entrs", " entriers", "Entry", "entsry", "Entrates", "gentrates", "entsries", "entsriers", "entriers", "entents", "entresses", "entsresses", "gentresses", "gentounters", " entents", "questries", " entires", "enties", "entrs", "entsies", "Entires", "entounters", "entsrys", "centries", "entsires", "entrates", "gentents", "enrys", "entires", "entrys", "Entrants", "Entries", "Entrs", "Entents", "Entounters", "Entriers", "centies", "centrys", " entrants", "centents", "gentries", "enries", "entrants", "questrs", "questents", "enrates", "entslements", "Enties", "questrys", " entrys", "entsents", " enties", "enounters"]}}
{"project": "FFmpeg", "commit_id": "8c013a9e55d9065793ef7ca6459d1178927a2b35", "target": 0, "func": "static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,\n\n                        uint32_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    char key[5]     = { 0 };\n\n    char *value;\n\n\n\n    size += (size & 1);\n\n\n\n    if (size == UINT_MAX)\n\n        return AVERROR(EINVAL);\n\n    value = av_malloc(size + 1);\n\n    if (!value)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, value, size);\n\n    value[size] = 0;\n\n\n\n    AV_WL32(key, tag);\n\n\n\n    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,\n\n                       AV_DICT_DONT_STRDUP_VAL);\n\n}\n", "idx": 18323, "substitutes": {"s": ["ls", "sts", "g", "rs", "sv", "as", "sn", "so", "a", "c", "sq", "h", "os", "ss", "ns", "sd", "e", "ats", "ts", "d", "sys", "m", "sp", "b", "v", "n", "se", "sb", "stats", "ds", "S", "gs", "cs", "sa", "ps", "t", "bs", "hs", "p"], "st": ["rt", "ost", "sts", "th", "xt", "sv", "rs", "sn", "sw", "so", "ste", "std", "nd", "sm", "sta", "stream", "ss", "sc", "sth", "ut", "inst", "src", "St", "pt", "ts", "sp", "ST", "ct", "se", "stack", "sb", "str", "ast", "bt", "storage", "ust", "art", "bl", "stop", "nt", "start", "mt", "stable", "t", "sh", "rest", "ist"], "tag": ["prop", "type", "reg", "Tag", "attr", "length", "map", "cat", "ag", "style", "TAG", "error", "attribute", "len", "kind", "flag", "feat", "match", "date", "id", "index", "v", "code", "state", "count", "format", "msg", "op", "stat", "token", "at", "t", "tags", "field", "name"], "size": ["length", "sum", "type", "zone", "offset", "ose", "g", "sv", "scroll", "year", "sn", "c", "fee", "timeout", "sent", "shape", "position", "style", "SIZE", "scale", "buffer", "len", "ize", "pos", "too", "set", "max", "e", "height", "message", "small", "grow", "score", "num", "index", "sp", "v", "n", "mode", "time", "code", "area", "space", "total", "Size", "send", "slice", "axis", "empty", "count", "capacity", "mem", "storage", "status", "number", "scope", "dimension", "t", "z", "name", "p"], "pb": ["cv", "bb", "bh", "ub", "PB", "pkg", "tp", "bj", "fp", "jp", "tx", "gp", "td", "cm", "mp", "ab", "cp", "rb", "bp", "np", "pp", "p", "cb", "pl", "tc", "lp", "pm", "cpp", "pc", "pt", "ph", "eb", "b", "ctx", "pa", "uf", "xb", "sb", "pg", "lb", "tk", "aus", "typ", "bs", "dp", "pd", "vp"], "key": ["prop", "type", "label", "sum", "attr", "chain", "map", " Key", "KEY", "title", "mask", "y", "ip", "attribute", " KEY", "set", "item", "ac", "list", "path", "id", "index", "row", "k", "param", "ame", "Key", "code", "val", "option", "str", "prefix", "data", "x", "ek", "link", "pair", "keys", "hash", "name"], "value": ["new", "text", "window", "tmp", "type", "get", "length", "ready", "all", "sv", "cache", "end", "array", "result", "entry", "VALUE", "test", "content", "valid", "memory", "values", "port", "json", "buffer", "position", "password", "version", "attribute", "null", "byte", "ue", "padding", "iv", "set", "buf", "message", "zero", "Value", "index", "available", "row", "v", "var", "record", "code", "vp", "total", "ve", "state", "val", "instance", "description", "data", "mem", "output", "tv", "w", "word", "current", "image", "node", "t", "variable", "established", "name", "allowed", "p"]}}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)\n\n{\n\n    int i, j;\n\n    for (i = 0; i < 5; i++) {\n\n        for (j = 0; j < 38; j++) {\n\n            in[i][j+6][0] = L[0][j][i];\n\n            in[i][j+6][1] = L[1][j][i];\n\n        }\n\n    }\n\n    if (is34) {\n\n        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);\n\n        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);\n\n        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);\n\n        for (i = 0; i < 59; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+32][j][0] = L[0][j][i+5];\n\n                out[i+32][j][1] = L[1][j][i+5];\n\n            }\n\n        }\n\n    } else {\n\n        hybrid6_cx(in[0], out, f20_0_8, len);\n\n        hybrid2_re(in[1], out+6, g1_Q2, len, 1);\n\n        hybrid2_re(in[2], out+8, g1_Q2, len, 0);\n\n        for (i = 0; i < 61; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+10][j][0] = L[0][j][i+3];\n\n                out[i+10][j][1] = L[1][j][i+3];\n\n            }\n\n        }\n\n    }\n\n    //update in_buf\n\n    for (i = 0; i < 5; i++) {\n\n        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));\n\n    }\n\n}\n", "idx": 18324, "substitutes": {"out": ["block", "box", "cache", "init", "h", "check", "table", "cut", "v", "o", "gen", "co", "new", "f", "bit", "gt", "outs", "OUT", "ret", "ot", "net", "our", "target", "client", "off", "over", "comment", "cmd", "one", "full", "w", "clean", "p", "to", "sum", "all", "ne", "conn", "en", "result", "chain", "user", "point", "err", "ex", "soft", "os", "conv", "ou", "io", "go", "set", "l", "m", "up", "file", "on", "no", "pool", "raw", "at", "range", "batch", "type", "copy", "Out", "server", "hit", "line", "public", "r", "this", "list", "d", "con", "sys", "b", "n", "data", "write", "output", "it", "op", "base", "bin", "t", "response"], "in": ["inn", "is", "cache", "init", "h", "c", "use", "ad", "al", "query", "scan", "IN", "v", "o", "mem", "old", "rin", "new", "act", "bit", "from", "inc", "iter", "inner", "serv", "im", "ma", "el", " IN", "and", "source", "input", "p", "sum", "all", "en", "ind", "ex", "isin", "um", "l", "m", "up", "on", "raw", "at", "config", "ins", "mm", "copy", "info", "din", "ic", "line", "att", "r", "form", "ac", "list", "con", "call", "id", "b", "n", "pin", "str", "it", "bin", "vin", "t", "In", "nin"], "L": ["LIN", "DL", "LM", "J", "BL", "LT", "B", "P", "M", "H", "LU", "C", "Q", "Out", "T", "LE", "Long", "TL", "F", "Li", "V", "VL", "LC", "mL", "l", "LP", "List", "Layout", "LG", "LS", "R", "I", "Line", "LB", "XL", "LI", "LD", "EL", "LR", "LV", "G", "ln", "S", "W", "FL", "N", "NL", "In", "LL", "dL"], "is34": ["sis349", "is357", " is32", "IS32", "sis34", "IS357", "is37", "sis32", " is37", "sis37", "Is34", "IS349", "IS34", "is32", " is357", "Is37", "Is357", "is349", " is349", "Is32", "IS37"], "len": ["init", "le", "al", "vol", "val", "mem", "gen", "limit", "cmp", "fl", "mil", "lan", "iter", "lit", "ret", "pos", "spec", "el", "hl", "lig", "lim", "lon", "full", "compl", "ln", "lif", "fun", "lis", "nt", "length", "all", "ne", "en", "Len", "fail", "err", "size", "conv", "fin", "del", "nn", "ll", "l", "level", "ls", "coord", "ref", "mm", "kl", "dl", "nl", "lin", "line", "ell", "rel", "den", "n", "rot", "alt", "coll", "ail", "lib", "bin", "il"], "i": ["us", "is", "ik", "iri", "er", "init", "iti", "y", "ip", "ami", "ims", "qi", "e", "v", "I", "o", "ii", "phi", "status", "hi", "ite", "api", "f", "ir", "iter", "ui", "ish", "\u0438", "pi", "u", "ib", "im", "ma", "index", "s", "mi", "ie", "iso", "iq", "multi", "p", "gi", "ind", "ri", "xi", "ki", "ai", "li", "io", "ql", "iu", "by", "um", "ci", "my", "l", "sim", "m", "me", "\u00ed", "ti", "x", "uri", "dr", "at", "ij", "si", "batch", "aci", "bi", "info", "ia", "ic", "zi", "this", "ji", "id", "ei", "ix", "di", "it", "ini", "z", "oi"], "j": ["er", "xy", "js", "fr", "y", "ip", "v", "dj", "other", "key", "oj", "art", "jl", "reg", "br", "ju", "pr", "json", "dt", "obj", "em", "im", "el", "yy", "s", "uj", "ie", "bl", "adj", "job", "to", "g", "ind", "user", "jc", "err", "ge", "q", "jas", "io", "jj", "by", "je", "arg", "my", "ah", "l", "sim", "m", "pt", "k", "next", "jit", "on", "jo", "dr", "py", "try", "at", "ij", "bo", "si", "jump", "J", "bi", "ja", "bj", "jp", "ijk", "kj", "res", "qt", "aj", "att", "note", "rel", "r", "item", "ng", "this", "ji", "yes", "b", "n", "let", "str", "ix", "di", "it", "z"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 18326, "substitutes": {"f": ["fd", "ff", "cf", "fe", "rf", "fp", "a", "c", "df", "h", "ef", "fb", "fc", "lf", "af", "i", "def", "q", "fr", "F", "e", "r", "l", "tf", "m", "b", "v", "o", "uf", "fi", "file", "fw", "bf", "fo", "t", "fs", "j", "p"], "limit": ["length", "bit", "block", "entry", "condition", "lock", "use", "lit", " policy", "limits", "allow", "size", "tail", "port", "buffer", "scale", "len", "mission", "Limit", "util", "line", "pi", "target", "rate", "max", "limited", "value", "cut", "local", "Lim", "force", "join", "policy", "control", "lim", "capacity", "format", "it", "pool", "base", "timeout"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 18329, "substitutes": {"v": ["f", "cv", "sv", "g", "vr", "h", "c", "i", "q", "conv", "vy", "vs", "iv", "V", "u", "vu", "r", "l", "d", "m", "vi", "vm", "b", "ev", "vim", "vp", "gov", "vc", "uv", "tv", "w", "vt", "inv", "av", "view", "j", "p"], "name": ["new", "type", "length", "g", "nm", "nam", "a", "c", "lat", "err", "valid", "san", "unknown", "def", "q", "names", "known", "error", "in", "null", "spec", "false", "named", "none", "path", "id", "ma", "num", "local", "broad", "var", "n", "j", "code", "missing", "key", "val", "wa", "str", "Name", "NAME", "data", "prefix", "nan", "old", "common", "no", "required", "w", "word", "t", "ame", "p"], "obj": ["tmp", "act", "ok", "object", "attr", "ox", "ref", "pkg", "err", "js", "pr", "self", "res", "pos", "obs", "img", "elt", "cb", "ool", "enc", "expr", "arr", "resp", "objects", "vol", "pt", "ack", "off", "ctx", "o", "out", "val", "str", "inv", "nt", "ob", "addr", "Obj", "bo"], "errp": ["rrp", "errpen", " errP", "errorp", " errpa", "ererp", " ErrP", "Erpa", "ererpb", "errpa", "iterp", " errpb", "errorpa", "errpb", " errpen", "errjp", "iterP", "Erp", "ererP", " Errpen", "rrpre", "ererpen", "errorjp", " errpre", " errjp", "errorP", "errP", "errpre", "ErP", " Errp", "rrP", " Errpb", "Erjp", "iterpre"], "qiv": [" qiter", "dqliv", "sqiter", "qiter", "qiver", "dqiv", "quiver", "dqiov", "quir", "qir", "quiov", "sqliv", "sqiov", "sqir", "quiv", "qiov", " qiver", "sqiver", "sqiv", "qliv", "quiter", " qir", "quliv", "dqiver"], "qobj": ["qqnt", "qobo", "eqobj", "qqbis", "quobo", "qObj", " qobo", "qobject", " qObj", "qnt", " qobject", "iqtmp", "quickobo", "iqobj", "quobject", "dqnt", "quertmp", "eqbis", "dqobj", "quObj", "iqso", "questobj", "qqobj", "quickobject", "quickobj", "dqbis", "qso", "dqbool", "quobj", "questrect", "qrect", "qbis", "quickObj", "querobj", "qqbool", "querso", "questtmp", "questso", "eqbool", "iqrect", "eqnt", "querrect", "qtmp"], "qbool": ["dqbinary", "aqbool", "aqbit", " qint", "qubit", "sqint", "qufloat", " qbo", "qnull", "qubo", "sqobj", "sqbool", " qfloat", "qbo", "sqbinary", " qbit", " qbis", "qubis", "qbit", "dqfloat", "qunull", "qfloat", "quint", "quool", "qubinary", "aqbo", "qconv", "sqool", "qbinary", "dqool", "qubool", "quconv", " qnull", "sqbis", "dqbool", "quobj", " qconv", "aqbis", "sqfloat", "aqconv", "qbis", "aqfloat", "qool", "aqnull", "qint"]}}
{"project": "qemu", "commit_id": "860643bc5aa902f9b736c57b66e301ef08a2b68e", "target": 0, "func": "int kvm_arch_get_registers(CPUState *cs)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_one_reg reg;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    int i, r;\n\n\n\n    /* get the PSW */\n\n    env->psw.addr = cs->kvm_run->psw_addr;\n\n    env->psw.mask = cs->kvm_run->psw_mask;\n\n\n\n    /* the GPRS */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->regs[i] = cs->kvm_run->s.regs.gprs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->regs[i] = regs.gprs[i];\n\n        }\n\n    }\n\n\n\n    /* The ACRS and CRS */\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];\n\n            env->cregs[i] = cs->kvm_run->s.regs.crs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = sregs.acrs[i];\n\n            env->cregs[i] = sregs.crs[i];\n\n        }\n\n    }\n\n\n\n    /* The prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        env->psa = cs->kvm_run->s.regs.prefix;\n\n    }\n\n\n\n    /* One Regs */\n\n    reg.id = KVM_REG_S390_CPU_TIMER;\n\n    reg.addr = (__u64)&(env->cputm);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_CLOCK_COMP;\n\n    reg.addr = (__u64)&(env->ckc);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_TODPR;\n\n    reg.addr = (__u64)&(env->todpr);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    if (cap_async_pf) {\n\n        reg.id = KVM_REG_S390_PFTOKEN;\n\n        reg.addr = (__u64)&(env->pfault_token);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFCOMPARE;\n\n        reg.addr = (__u64)&(env->pfault_compare);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFSELECT;\n\n        reg.addr = (__u64)&(env->pfault_select);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18344, "substitutes": {"cs": ["checks", "ls", "cf", "act", "sts", "ks", "acts", "rs", "bits", "ins", "ics", "c", "cus", "cells", "fc", "rc", "js", "ares", "ips", "ports", "css", "ants", "asks", "cons", "ras", "ck", "cp", "sc", "cases", "vs", "ns", "ims", "ances", "ces", "tc", "ands", "ms", "CS", "pc", "Cs", "ts", "ats", "actions", "cc", "yes", "acs", "caps", "ctx", "rics", "cms", "parts", "wcs", "icks", "s", "ce", "cas", "cks", "cing", "times", "ds", "qs", "icas", "ars", "ys", "ows", "ps", "comm", "otes", "bs", "fs", "hs"], "cpu": ["proc", "CPU", "arch", "bench", "boot", "processor", "hw", "mx", "clock", "c", "nic", "upt", "linux", "ck", "os", "setup", "cp", "ork", "nn", "util", "gc", "ka", "pc", "sys", "cc", "vm", "ctx", "core", "instance", "x", "task", "gpu", "mem", "CP", "node", "base", "process", "pu", "tp", "p"], "env": ["cv", "estate", "er", "stage", "editor", "gear", "vs", "event", "e", "ende", "query", "message", "ctx", "v", "uv", "Environment", "equ", "entry", "eps", "email", "oe", "ef", "eh", "dt", "obj", "export", "eni", "em", "ens", "el", "ev", "console", "context", "db", "environment", "nv", "dev", "esc", "window", "ext", "end", "en", "conn", "dn", "viron", "manager", "buffer", "enter", "ee", "engine", "nel", "enc", "ah", "eu", "here", "txt", "era", "ve", "eve", "desc", "ent", "esm", "shell", "runner", "builder", "ov", "worker", "server", "player", "actor", "den", "operator", "ei", "ew", "app", "web", "ner", "et", "door", "ec", "erd", "outer", "queue", "response"], "reg": ["proc", "g", "ref", "istry", "leg", "win", "disc", "ret", "or", "res", "net", "ig", "re", "group", "set", "gr", "num", "rec", "row", "var", "s", "link", "Reg", "col", "mem", "tag", "rep"], "sregs": ["sremcs", " sstatjs", "sregisterj", "srendjs", "sgraphls", "sremjs", "sstatrs", "sgraphrs", "sregj", " sregj", " sregches", "sregls", "sregd", "sreamid", " sstatls", " srends", " sregid", "sregjs", "sstatjs", "srendcs", " sregjs", "sgraphches", " srendjs", "srendts", "sstatts", "sregts", " sstats", " srenda", "smems", " sregls", "srega", "sremts", "sremls", "sreamd", "srems", "smema", "sstatches", "srendls", " sstatrs", " sstatts", "srends", "sstats", "srema", "smemls", "sreamj", "sregches", " sregcs", " sregts", " sstatcs", " sregd", "sregcs", " sregrs", " srendls", "sregrs", "sregisterid", "sreams", "sregisters", "sremrs", "srenda", "sremches", "smemjs", "sstatls", " sstatches", "sregisterd", " srega", "sregid", "sgraphs", "sstatcs"], "regs": ["mgs", "Regrs", "prns", "regies", "registers", "registerains", "resns", " regers", "rounds", "regservices", "Regs", "patternservices", "privs", "roundjs", "refrs", "defservices", "defs", "privers", "gregs", "regss", "logd", "locs", "rels", "regns", "redss", "refs", "prives", "Regjs", "remins", "REGs", "roundservices", "regS", "roundains", " regts", "logs", " regservices", "replns", "Regss", "regers", "gregservices", "replrs", "patterns", " reges", "reljs", "logss", "prrs", "ress", "regts", "regains", "reds", "patternies", "rems", "gregins", "mgjs", "RegS", "regjs", "regins", "REGers", "logts", "roundies", "refS", "mgains", "remts", "remservices", " regd", "prers", "prs", "REGes", "locrs", "regd", " regss", "defies", "locS", "recjs", "regrs", "redts", "replers", "registerjs", "resers", "redd", "repls", "recss", "gregts", "reges", "recs", " regins", "resrs", "relss"], "i": ["is", "iri", "er", "init", "a", "c", "ip", "y", "ami", " ii", "qi", "e", "menu", "v", "I", "ii", "key", "phi", "span", " j", "hi", "t", "inner", "json", "ui", "\u0438", "pi", "im", "index", "client", "mi", "ie", "source", "iso", "iq", "multi", "p", "gi", "ind", "chain", "ri", "xi", "point", "ki", "ex", "cli", "ai", "parent", "q", "li", "io", "iu", "ni", "ci", "me", "m", "sim", "history", "ti", "prefix", "x", "uri", "dr", "try", "at", "ij", "ski", "si", "batch", "bi", "info", "ic", "in", "remote", "zi", "this", "list", "ji", "sql", "ei", "fi", "ix", "di", "it", "ini", "j", "oi"], "r": ["hr", "lr", "rt", "kr", "f", "resource", "cr", "br", "attr", "g", "rs", "er", "run", "mr", "entry", "result", "ir", "vr", "c", "nr", "ri", "h", "err", "rc", "rar", "rem", "term", "or", "ret", "q", "fr", "rb", "error", "res", "rg", "debug", "rr", "re", "ur", "sr", "e", "rel", "rate", "arr", "l", "m", "d", "b", "R", "v", "record", "n", "ry", "reset", "ar", "str", "w", "dr", "rm", "adr", "it", "try", "usr", "rd", "repl", "j", "p"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 18345, "substitutes": {"p": ["f", "pat", "g", "pkg", "P", "jp", "fp", "a", "c", "h", "point", "pr", "q", "cp", "bp", "pp", "pattern", "pb", "r", "e", "lp", "pc", "l", "m", "d", "ap", "path", "ping", "sp", "b", "v", "k", "n", "pa", "o", "vp", "s", "x", "pair", "w", "it", "op", "pe", "ps", "t", "rep", "tp", "j"], "model": ["er", "sm", "store", "man", "pattern", "master", "dm", "lv", "table", "message", "project", "dem", "activity", "Model", "database", "where", "link", "save", "transform", "relation", "mb", "xml", "entry", "email", "virtual", "report", "device", "em", "spec", "re", "handler", "el", "client", "mode", "db", "controller", "mi", "mod", "job", "cell", "sample", "map", "self", "port", "manager", "ll", "sim", "m", "record", "core", "mail", "ve", "morph", "member", "view", "machine", "image", "module", "bm", "comm", "lc", "config", "method", "mm", "lock", "info", "ml", "server", "form", "vm", "local", "rule", "app", "data", "domain", "tree", "models", "details"], "opts": ["ropps", " optts", "OPtions", "iopps", "opns", "ioptions", "attts", "OPs", "opte", "optts", "ops", " optorts", "ropts", "roptions", "OPns", "opps", "options", "attorts", "attns", "optns", "iops", "optte", "optps", "attte", "oports", "iopns", "rops", " optns", "optorts", "OPps", "iopts", " optte", "OPts"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n", "idx": 18351, "substitutes": {"vdev": ["mdevice", "evdb", "evdevice", "vdevice", "vpad", "svhw", "vhw", " vDev", "mdev", "mhw", "mev", "tdev", "vdb", "wdev", "svpad", "tdb", "vcdev", "wDev", "vobj", "vccam", " vev", "vev", "vmdev", "evdev", "vcam", "svDev", "vmobj", "evobj", " vdevice", "vmdevice", "tobj", "svev", "vmdb", "wev", "tcam", " vhw", "vchw", "wpad", "vcdevice", "tdevice", "svdevice", "vDev", "thw", " vpad", "svdev", " vcam"], "vq": [" vch", "nvque", "fue", "invqueue", "vriq", "svque", "vqq", "vrue", "mqueue", "vrqueue", "svqueue", "vch", "invq", "svdq", "hqs", "fque", "evqq", "inviq", " vqueue", " vque", "invue", "hdq", "mch", "hue", "vdq", "fq", "viq", "nvqq", "mdq", "vqs", "vsqq", "hq", "miq", "vque", " vqs", "svue", "fqueue", "nvq", "evque", "svqs", "mq", "mue", "svq", "vue", "evq", "vrq", "evqs", " vdq", "vqueue", "nvqs", " vue", "vsque", "svch", "vsqs", "vsq"], "s": ["ls", "is", "sts", "sv", "g", "rs", "sn", "sw", "c", "sq", "h", "sm", "service", "js", "self", "ss", "sbm", "ns", "spec", "r", "e", "m", "sys", "d", "ts", "sp", "b", "n", "o", "sb", "state", "stats", "ds", "qs", "w", "S", "gs", "ps", "t", "bs", "fs", "hs"], "elem": [" element", "elelements", "eelements", "sem", "lelem", "elems", "oelement", "elev", "melement", " elev", " eleg", "elelement", "selement", "elelem", "lelement", "elelev", "lem", "elementlev", "ielements", "melete", "elete", "gelement", "selems", "lelements", "Element", "melements", "em", "oelev", "elelems", "eleleg", " elems", "gelete", "oelems", "oelem", "velev", "elementlem", "lelems", "ielete", "ielem", "Elem", "eleg", "eelem", "eelems", "elementlems", "element", "ielement", "velement", "selem", "Elems", "Elev", "melem", "elements", "eelement", "velem", "veleg", "gelements", "gelem", "elementlement", " em"], "section": ["library", "block", "page", "tower", "Section", "tab", "definition", "man", "table", "sector", "key", "pair", "mem", "character", "relation", "entry", "sec", "test", "day", "side", "spec", "group", "function", "index", "row", "mode", "area", "layer", "state", "comment", "context", "option", "element", "container", "tag", "account", "mod", "step", "name", "p", "profile", "length", "header", "mr", "point", "parent", "service", "size", "port", "region", "journal", "set", "m", "ment", "instance", "member", "prefix", "pool", "module", "connection", "second", "part", "sect", "position", "setting", "line", "r", "lp", "se", "sections", "description", "sam", "division", "portion", "j"], "pfn": ["npsn", "pnfl", "pnfc", "Pfc", "Pfn", "ppfn", "pnfunc", "npdn", " pfunc", "jpdn", " pfl", "npn", "jpfn", " pdn", "pnfn", "pfc", " pfm", "jpn", "ffn", "npfn", " pn", "ffm", "jpsn", "ppfm", "Pfl", "pn", "pfm", " pfc", "pfunc", "ppfc", "pdn", "ppdn", "pfl", "psn", "ffc", "Pfunc", " psn", "fdn"], "pa": ["ppo", "offset", "na", "fp", "jp", "ta", "ada", "ca", "mp", "ia", "pr", "pas", "pan", "ha", "pi", "pb", "address", "lp", "pm", "pet", "pc", "pai", "pn", "ap", "ma", "fa", "apa", "po", "sb", "wa", "ppa", "Pa", "ape", "pair", "pha", "par", "eta", "pe", "adr", "arp", "ptr", "PA", "sa", "ps", "rep", "ota", "pse", "p"], "addr": ["url", "pad", "act", "alias", "amp", "attr", "offset", "ref", "pkg", "hop", "map", "a", "tx", "wd", "point", "ai", "ia", "port", " address", "ad", "asm", "ip", "pos", "aff", "np", "ha", "loc", "p", "align", "address", "r", "Address", "m", "ap", "index", "ord", "ctx", "inter", "sha", "ix", "au", "prefix", "x", "mem", "am", "art", "dr", "oa", "adr", "at", "ptr", "mt", "ress", "ace", "add", "arp"]}}
{"project": "FFmpeg", "commit_id": "5602a464c9f9e3c0922f5cfeccaf2fa1c40b2401", "target": 0, "func": "static av_cold int vorbis_decode_init(AVCodecContext *avccontext)\n\n{\n\n    vorbis_context *vc = avccontext->priv_data;\n\n    uint8_t *headers   = avccontext->extradata;\n\n    int headers_len    = avccontext->extradata_size;\n\n    uint8_t *header_start[3];\n\n    int header_len[3];\n\n    GetBitContext *gb = &vc->gb;\n\n    int hdr_type, ret;\n\n\n\n    vc->avccontext = avccontext;\n\n    ff_dsputil_init(&vc->dsp, avccontext);\n\n    ff_fmt_convert_init(&vc->fmt_conv, avccontext);\n\n\n\n    if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;\n\n        vc->scale_bias = 1.0f;\n\n    } else {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_S16;\n\n        vc->scale_bias = 32768.0f;\n\n    }\n\n\n\n    if (!headers_len) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata missing.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = avpriv_split_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata corrupt.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[0], header_len[0]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 1) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"First header is not the id header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_id_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Id header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[2], header_len[2]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 5) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Third header is not the setup header.\\n\");\n\n        vorbis_free(vc);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_setup_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Setup header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    if (vc->audio_channels > 8)\n\n        avccontext->channel_layout = 0;\n\n    else\n\n        avccontext->channel_layout = ff_vorbis_channel_layouts[vc->audio_channels - 1];\n\n\n\n    avccontext->channels    = vc->audio_channels;\n\n    avccontext->sample_rate = vc->audio_samplerate;\n\n    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;\n\n\n\n    avcodec_get_frame_defaults(&vc->frame);\n\n    avccontext->coded_frame = &vc->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18371, "substitutes": {"avccontext": ["avccondposition", "avccoretxt", "avccencurrent", "avaccontext", "avccaconject", "avcconsnect", "avccoconcontext", "avccnoncert", "avccONcurrent", "avcconject", "avccONfig", "avccoconject", "avckonytext", "avcusanontxt", "avcconencontext", "avccanonect", "avcusontxt", "avCConstext", "avsconstant", "avccocontxt", "avccaxonsole", "avcconsect", "avscontex", "avccONtext", "avccanload", "avccronfig", "avccoreject", "avccanontext", "avcconect", "avCContext", "avccystruct", "avckonject", "avCConsnect", "avcfonstruct", "avpcoonkey", "avccxonvert", "avccanoncontext", "avfconstruct", "avccONcontext", "avfconfig", "avfcronect", "avcconposition", "avccxoncert", "avccxonposition", "avckonport", "avcconsport", "avccryload", "avcconkey", "avccyncurrent", "avccONnect", "avinconst", "avacconstant", "avccyncontext", "avccONconnection", "avacconcert", "avccoontext", "avccONct", "avccyfig", "avccronkey", "avpconkey", "avckantext", "avccynstant", "avCConsect", "avcconct", "avCConcontext", "avccxontext", "avscocontext", "avscocontex", "avpcoonfig", "avfcentext", "avcusanontext", "avccxonstruct", "avccaconect", "avcfacontxt", "avcfenstruct", "avccynject", "avccytext", "avcconstant", "avccacontxt", "avccanposition", "avcfonstant", "avpconstant", "avcconest", "avccaonposition", "avccontxt", "avacconect", "avckonystruct", "avccaconstant", "avccnontext", "avcconnect", "avccxoncontext", "avcfonject", "avcfonnect", "avccondload", "avckancurrent", "avcfenTEXT", "avcusoncert", "avccocontex", "avccanonnect", "avccontcurrent", "avccaconfig", "avcconfig", "avccrytext", "avcconenconnection", "avccONtxt", "avcfontext", "avccenct", "avccconnect", "avctontext", "avcconst", "avccondtext", "avfconect", "avcconport", "avcconentext", "avfcronstruct", "avccONvert", "avccONcert", "avckanject", "avccancurrent", "avccontex", "avccoconst", "avcconsole", "avcconttext", "avccoconstant", "avacconenconnection", "avcfentext", "avccxonconnection", "avcconsstruct", "avcconstex", "avctonect", "avccenect", "avcconestant", "avckonload", "avccxonsole", "avccronstant", "avccansole", "avccenTEXT", "avccenfig", "avccacontext", "avcconcert", "avincontxt", "avacconencert", "avcconstext", "avccronconstruct", "avacconentext", "avcconTEXT", "avccyject", "avcfacontext", "avccrystruct", "avcusontext", "avccaxontext", "avccronstruct", "avcfenstant", "avccyntext", "avcconyport", "avccaontext", "avccaconkey", "avcccontxt", "avckonyport", "avctontct", "avacconencontext", "avcconconnection", "avcfonTEXT", "avctontect", "avccONect", "avcusanoncert", "avccanject", "avccenstant", "avcconstruct", "avcconyload", "avccONstruct", "avccoonkey", "avcconsstant", "avckonstruct", "avinconject", "avctontcurrent", "avfcenfig", "avcconencert", "avfcontext", "avcccontext", "avfcronvert", "avccyntex", "avccanontxt", "avCConnect", "avaccacontext", "avcconsload", "avaccaconconstruct", "avfcenject", "avccanoncert", "avccryport", "avcconeconstruct", "avcfaconnect", "avincocontext", "avccontcontext", "avacconconstruct", "avcfaconject", "avccontct", "avccronTEXT", "avincocontxt", "avcusonstant", "avccorest", "avccaconnect", "avccentext", "avacconconnection", "avccconject", "avccenstruct", "avfconvert", "avaccaconstant", "avccencert", "avccxonect", "avccyntxt", "avfconject", "avpcoontext", "avpconfig", "avacconcontext", "avpcontext", "avCConect", "avccONstant", "avccronect", "avckantxt", "avctonct", "avcconeject", "avCConscontext", "avccantxt", "avfcenstruct", "avcconcontext", "avaccaconect", "avccronvert", "avccondsole", "avckoncurrent", "avccONTEXT", "avsconcontext", "avccaxonposition", "avccontect", "avccnonstant", "avckontext", "avccaxonload", "avccONject", "avccaonsole", "avcconload", "avccoretext", "avccaonload", "avctonttext", "avccrontext", "avcfontxt", "avpcoonstant", "avccantext", "avccenject", "avccxonload", "avcconconstruct", "avcusanonstant", "avccocontext", "avscontext", "avcconetxt", "avcconystruct", "avscoconcontext", "avcconytext", "avincoconst", "avccentxt", "avccoonfig", "avcconvert", "avctoncurrent", "avccanonstant", "avincontext", "avckontxt", "avccontnect", "avcconetext", "avfcrontext", "avccaconconstruct", "avcconeect", "avincoconject", "avccoonstant", "avcconcurrent", "avcconscontext", "avccnontxt", "avckonyload", "avscoconstant"], "vc": ["irm", "cv", "bb", "vec", "c", "vd", "vine", "etc", "vs", "lv", "vol", "pc", "v", "ctx", "von", "var", "bt", "uv", "verb", "dc", "cf", "act", "serv", "cp", "obj", "ib", "cu", "vi", "ev", "wl", "voice", "cmd", "ce", "nv", "ow", "inv", "nt", "cs", "ch", "vg", "vp", "ht", "vv", "conv", "ee", "ll", "vet", "ct", "ve", "bc", "ctrl", "vt", "fax", "rt", "lc", "sv", "vr", "fc", "rc", "bank", "ic", "WC", "VC", "voc", "vy", "gc", "att", "ell", "form", "lp", "vl", "cc", "vm", "xc", "cow", "coll", "ec", "av", "csv"], "headers": ["drivers", "codes", "header", "builders", "rs", "bits", "ints", "h", "cells", "users", "ppers", "lines", "names", "aches", "heads", "workers", "bytes", "bys", "types", "ids", "vers", "parts", "pres", "images", "tops", "frames", "html", "ilers", "ds", "qs", "files", "dr", "writers", "ers", "keys", "boxes", "ters", "items", "blocks", "hands"], "header_start": ["query_start", " header_pos", "header_pos", "header5step", " header_open", "header08error", "question_error", "header_open", "question08pos", "header0step", "header0try", "question_pos", "header_step", "question08no", "query_try", "question_no", "header67pos", "question_start", "header08no", "header08pos", "header0init", "header67no", "header_init", "header0start", " header_end", "question08start", "header_end", "header5try", "header_try", "header67error", "header5init", "header_error", "header5start", "question08error", "query_init", "query_step", "header67start", "header_no", "header08start"], "header_len": ["head_lim", "headerLenlast", "head2elt", "header_left", "history_le", "sector_seq", "header33alt", "header67nos", "header67alt", "header67val", "codeLenlast", "sector_val", "sector_alt", "header67seq", "head_len", "header___left", "header33len", "headerJnos", "header_mult", "headerLlen", "sector67seq", "sector67val", "headerLleft", "head_elt", "sector67alt", "headerLenlen", "header_nos", "header33seq", "code_left", "history___nos", "headerLenleft", "codeLenlen", "history_left", "header___le", "headerJleft", "code_mult", "header2elt", "code_last", "head2len", "header_val", "header_alt", "headerJle", "headerLenmult", "headerLlast", "history___len", "headerJlon", "header2lim", "header_last", "header67len", "history_len", "history_nos", "header_le", "code_len", "header2len", "sector67len", "header_elt", "header2lon", "header___len", "headerJlen", "header___mult", "header67le", "header33val", "head2lon", "header___nos", "codeLenmult", "header___last", "header_lim", "header_lon", "headerJelt", "head2lim", "sector_len", "codeLenleft", "headerJlim", "headerLmult", "head_lon", "history___le", "header_seq", "header67left", "history___left"], "gb": ["nb", "bb", "cv", "g", "gt", "gd", "GB", "tg", "gio", "vd", "vg", "wb", "gp", "rb", "rg", "sg", "img", "gc", "cb", "ib", "yg", "gif", "rect", "pc", "sys", "gu", "eb", "vm", "ctx", "eg", "bg", "uf", "hub", "bn", "gnu", "Gb", "sb", "gm", "git", "kb", "db", "pg", "bt", "ds", "gpu", "gg", "storage", "py", "gs", "gy", "bm", "bf", "mb", "bs", "cfg"], "hdr_type": ["hDR_Type", "hdr_length", "hr_len", "hdr8type", "hdr8len", "hdr_Type", "hr_Type", "hdr__TYPE", "hdr8Type", "hdr_ty", "hr_name", "hdr8name", "hdr_len", "hdr__Type", "hDR_length", "hr_type", "hdr__type", "hDR_ty", "hdr__length", "hDR_TYPE", "hDR_type", "hdr_name", "hdr_TYPE"], "ret": ["url", "rt", "ber", "reg", "end", "gt", "ref", "result", " RET", "err", "rem", "def", "len", "tr", "res", "gc", "elt", "ll", "re", "flag", "att", "resp", "det", "RET", "Ret", "rev", "progress", "tf", "ter", "value", "sys", "ern", "txt", "back", "out", "ft", " Ret", "cert", "mail", "reset", "val", "rets", "print", "alt", "success", "mel", "mem", "deg", "status", "it", "fun", "rm", "nt", "try", "usr", "mt", "ry"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n", "idx": 18384, "substitutes": {"f": ["fd", "ff", "cf", "fl", "g", "rf", "fp", "c", "h", "fac", "fb", "fc", "lf", "af", "i", "stream", "buffer", "q", "fr", "y", "fx", "F", "um", "e", "r", "ac", "l", "m", "tf", "d", "fa", "b", "v", "fm", "uf", "o", "out", "sf", "fi", "file", "fw", "w", "bf", "fo", "xf", "fn", "t", "fs", "z", "j", "p"], "blk": [" blck", "Blkt", " blke", "bhkg", "Blk", "blockak", " blkt", "blkt", "blkid", "Blj", "blekid", "llak", "blunk", "bhunk", "grunk", "blockck", "rolck", " blkg", "blj", "blke", "Blkid", "grkg", "blockk", "llk", "brk", " blak", "relk", "rolk", "relck", " blunk", "BLak", "rolkg", "blockkg", "blej", "llck", "grk", "bleunk", "llke", "brck", "brj", "blek", "blkg", "rolak", "BLck", "blck", "Blck", " blkid", "brkt", "bleck", "bhk", "BLunk", "relke", "relak", "BLk", "bleak", "blak", "grck", "bhck", " blj"], "len": ["ls", "sl", "fl", "length", "lan", "offset", "end", "en", "Len", "Length", "vec", " bl", "lf", "size", "nl", "ret", "bytes", "pos", "elt", " el", "ll", "loc", "pl", "lp", " Len", "l", "num", "el", "sp", "off", "n", "val", " length", "str", " clen", "lim", "lon", " l", "coll", " le", "mem", "els", "ln", "flags", "nt", "limit", "lic", "il", "fn", "t", "L", "ld", "z"]}}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 18409, "substitutes": {"err": ["kr", "org", "Error", "cr", "ext", "attr", "rs", "er", "mr", "result", "test", "fee", "iter", "Er", "eth", "or", "fr", "eor", "order", "error", "res", "doc", "der", "obj", "elt", "norm", "rr", "ait", "r", "arr", "resp", "buf", "ah", "gr", "e", "eas", "txt", "aaa", "ev", "gz", "yr", "ocr", "str", "trace", "desc", "req", "cur", "msg", "addr", "usr", "die", "ch", "mt", "cmp", "exc", "cfg"], "mounts": ["mountnames", "mountgs", "mountedments", "materialers", "ountxs", "bindments", "ountl", "ountlist", "ountions", "mountts", "mders", "ounts", "urls", "ountests", "bindxs", "materialnames", "ountments", "Mountrs", "mountds", "urll", "Mountests", "materials", "mountls", "mountrs", "mds", "ounters", "mountands", "materialerences", "dirds", "mounteds", "direrences", "ountnames", "mountedands", "dirs", "montls", "urlrs", "mountments", "materialds", "materialrs", "mounterences", "ountands", "materiall", "mountedls", "ountrs", "monts", "materiallist", "mountions", "urlnames", "mountedxs", "mdlist", "mountests", "ounterences", "montions", "Mounts", "montands", "mdrs", "mountxs", "binds", "ountts", "ountls", "materialgs", "mountl", "ountgs", "mounters", "mountedions", "Mountts", "dirgs", "materialests", "ountds", "materialts", "mountlist"], "mount": ["proc", "component", "block", "bind", "config", "entry", "fail", "complete", "mm", "ount", "lock", "td", "allow", "claim", "mp", "mask", "draw", "display", "buffer", "store", "tr", "device", "mont", "util", "load", "loc", "att", "match", "handle", "um", "dir", "stab", "vol", "sync", "m", "pt", "imm", "pod", "local", "row", "dd", "send", "md", "cmd", "pair", "mem", "material", "Mount", "perm", "nt", "mounted", "find", "touch", "mt", "process", "dev", "ptr", "cmp", "mod", "field", "add", "metadata"], "local_err": ["local_er", "final_err", "activelykr", "local_usr", "remote_err", "local_exp", "local____my", "local_exc", "final_rs", "locallymem", " local_conn", "internal_res", "internal_error", "locallyerr", "old____my", "active_exc", "local_stat", " local_exp", "remote_usr", "localErres", "localererror", "local___error", "locallygz", "local_rs", "localmyexc", "local_res", "local_my", "active_res", "old____fee", "localErstat", "local67fee", "active_err", "localmyrs", "internal_stat", " local_der", "localErerror", "locallyres", "local___err", "final_exc", "final_gz", "localityrs", "finallyerr", "local___exp", "localityexc", "active_kr", "remote_mem", "finallygz", "old_err", "old_my", "local67err", "local_gz", "locallykr", "finallyrs", "localererr", " local_er", "localermem", "localmygz", "locallyrs", " local_error", "locallyconn", "locallyerror", "locallyexp", "activelyres", "old____err", "local_der", "localitygz", "local67my", "old_fee", "localmyerr", "internal_err", "local___conn", "local_kr", "remote_error", "activelyexc", "activelyerr", "localityerr", "finallyexc", "local_conn", "localerusr", "local_mem", "local____fee", "local_error", "local_fee", "locallyexc", "local____err", "localErerr", "locallyusr"], "fd": [" f", " len", "bd", " fin", "stream", "fr", " ft", "dat", " dst", " ed", "pid", "FD", "ctx", "md", "wind", " fi", " ff", "dig", "proc", "f", "ff", "fl", "cf", "gd", "nd", "ret", "dt", " fut", " ret", "sd", "ft", " fs", "db", "ln", "dev", "ld", " td", "window", "disk", "hd", "port", "fin", " fid", "dir", "socket", " tid", "dr", " ptr", "ptr", "cond", "cd", "ond", " dur", " df", "fp", "df", "td", "fc", "dl", "lf", "func", " resp", "gc", "handle", "d", "gz", "dd", "fi", "ds", "bf", "addr", "fs", " fa", "pd"], "i": ["f", "is", "g", "bi", "ind", "iter", "xi", "ai", "ret", "li", "ip", "pi", "im", "r", "ci", "l", "m", "num", "index", "id", "b", "v", "I", "n", "out", "ii", "inter", "ti", "val", "fi", "phi", "ix", "x", "count", "status", "di", "it", "mi", "try", "ij", "t", "ini", "multi", "z", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n", "idx": 18412, "substitutes": {"fdt": ["FDl", "dfte", "sdt", "dfl", "fredt", "fredw", "dfd", "dfT", "fdd", "sdl", "fdl", "dlT", "fdn", "flte", "fdT", "FDt", "fld", "FDn", "FDout", "dlw", "flT", "dfout", "fredte", "dfn", "sdout", "sdn", "flw", "flx", "dfw", "flt", "fredx", "fdx", "fdout", "fdw", "dft", "dlt", "dfx", "dld", "fdte"], "node_path": ["nodegformat", " node_name", "node_name", "nodealname", "node_format", "nodegpath", "device_name", "nodegdepth", "device_pointer", "node_depth", "nodealdepth", " node_depth", "nodegname", "device_prop", "node_prop", "nodealpath", "node_pointer", " node_format", "device_path", "nodealformat"], "property": [" preference", "text", "prop", "alias", "Property", "claim", "pointer", "properties", " attribute", "term", "position", "displayText", "attribute", "address", "expression", "value", "path", "rue", "primary", "key", " field", "description", "option", "policy", " prefix", "prefix", " prop", "package", "private", "node", "tag", "ident", "field", "partial", "name", "p"], "offset": ["component", "shift", "pointer", "Offset", "attribute", "OFF", "address", "message", "o", "out", "trace", "oid", "layout", "field", "url", "f", "alias", "from", "offs", "onet", "order", "len", "pos", "path", "index", "off", "row", "total", "lag", "package", "uint", "meta", "metadata", "to", "window", "length", "end", "slot", "location", "peer", "point", "err", "origin", "parent", "size", "port", "buffer", "error", "set", "seek", "count", "next", "bound", "ptr", "range", "notation", "ref", "fp", "info", "position", "padding", "value", "id", "owner", "onto", "data", "et", "output", "operation", "start", "outer"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n", "idx": 18426, "substitutes": {"rc": ["hr", "rt", "cr", "rs", "rf", "runner", "c", "rx", "anc", "rl", "abc", "ck", "sc", "ro", "rb", "auc", "rr", "loc", "cb", "src", "r", "ra", "pc", "sync", "nc", "ac", "cc", "ack", "rec", "ctx", "ocr", "bc", "oc", "coll", "cur", "ec", "RC", "auth", "rm", "irc", "cs", "cmp", "arc", "rn", "roc", "ry"], "porder": ["raddress", "permgrade", "pcode", "Ppriority", "Pder", "rattr", "ppriority", " pcode", "pingpriority", "permordered", "ccode", " pordered", "ppOrder", " pOrder", "Porder", "Pover", " porders", "torder", "pover", "pingorders", "paddr", "Pdepth", " paddress", "pingOrder", "paddress", "ppprogress", "pcaddress", "pcder", "ppaddress", " ppriority", "cover", " pder", "pgrade", "pordered", "ppattr", "tgrade", "Paddr", " pprogress", "ppdepth", "cOrder", "POrder", "Pcode", " pgrade", "Pprogress", "pattr", "rorder", "pder", "pingorder", "pcaddr", " pdepth", "pcattr", "permaddress", "rdepth", "tordered", "pcorder", "Porders", "pdepth", "porders", "pOrder", " pover", "pporder", "pcdepth", "pprogress", "corder", "pcOrder", " paddr", "taddress", "permorder"], "sums": ["sum", "sights", "caves", "sinum", "isums", "cum", "cums", "saves", "sods", "hizes", "sinizes", " sizes", "Sum", "hames", "Sods", "Sights", "isum", " saves", "sames", "sizes", "sumes", "hums", "Sums", " sames", "isights", " sods", "cods", "sinames", "sinums", "hum", " sum", "isumes", "Sumes", "Saves"], "n": ["nb", "ne", "g", "nm", "na", "sn", "cn", "c", "nr", "dn", "nl", "size", "len", "nn", "np", "ns", "net", "pi", "ni", "r", "l", "nc", "m", "num", "pn", "b", "v", "mn", " N", "nat", "nu", "s", "nan", "count", "gn", "nt", "N", "fn", "t", "j", "p"], "pred_order": ["ind_number", "ind_count", "predictionorders", "preditycount", "pred_offer", " pred_orders", "pred_Order", " pred_offer", " pred_Order", "preditynumber", "pred_count", "pred_orders", "predityposition", "predityorder", "predictionOrder", "pred_number", "pred_position", "ind_position", "predictionorder", "predictionoffer", "ind_order"], "i": ["to", "us", "is", " I", "bi", "iri", "gi", "ind", "c", "ri", "xi", "ki", "ai", "info", "batch", "li", "ic", "ui", "y", "ip", "ish", "\u0438", "in", "io", "iat", "pi", "iu", "qi", "e", "zi", "ci", "ms", "this", "l", "sim", "m", "asi", "id", "index", "me", "ji", "v", "I", "j", "o", "ii", "inter", "ti", "ei", "phi", "ix", "x", "status", "di", "uri", "it", "mi", "ie", "try", "ij", "ini", "ski", "multi", "si", "p"], "k": ["ikk", "kr", "ku", "ok", "ks", "kan", "ik", "ak", "ijk", "uk", "kl", "ki", "ck", "kj", "wk", "K", "sk", "unk", "kind", "ka", "ke", "m", "kw", "ack", "km", "kh", "v", "kid", "key", "mk", "kar", "kn", "ek", "kk", "tk", "kat", "ko", "p"], "cnt": ["actr", "acnc", "acnt", "cust", " cnc", "scnt", "ctr", "cct", "Cpt", "cNT", "ucNT", "Cnt", " cNT", "Cust", "Cct", "ucnt", "rcct", "cnc", "rcnd", " ctr", "uncnc", "acNT", "sccount", "Count", " ccount", "ccount", "acount", " cct", "Ctr", "ucnc", " cpt", "rcount", "scust", " cnd", "cpt", "acpt", "Cnd", "cnd", "count", " count", "uncnt", "uncount", " cust", "ucount", "Ccount", "rcnt", "scount"], "part": ["component", "pad", "piece", "type", "block", "step", "offset", "PART", "mult", "pre", "parent", "inner", "per", "position", "ition", "order", "Part", "version", "split", "diff", "pos", "padding", "pp", "top", "pi", "power", "patch", "kind", "group", "m", "pt", "sp", "parts", "state", "instance", "axis", "pair", "span", "par", "art", "no", "pro", "perm", "magic", "base", "start", "half", "only", "partial", "chapter", "p"], "all_bits": [" all_pins", "all___bits", " all_pots", " all_flags", "all00pots", " all_tops", "all_tops", "all2bits", " all_bytes", "all_flags", "all___its", "all00bytes", "all_pins", "all_bytes", "all_its", "all_bs", "all2its", "all___bit", " all_bs", "all00bits", " all_its", "all_pots", "all_bit", " all_bit", "all2bs", "all2tops", "all___flags"]}}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n", "idx": 18437, "substitutes": {"common": ["new", "component", "to", "present", "from", "initial", "final", "document", "com", "parent", "inner", "shared", "some", "low", "Common", "bur", "public", "head", "body", "set", "session", "message", "standard", "m", "un", "local", "core", "other", "basic", "primary", "instance", "bare", "on", "old", "general", "bolt", "raw", "base", "stable", "tree", "conf", "admin", "metadata", "normal"], "state": ["close", "is", "type", "length", "all", "config", "run", "estate", "runner", "states", "result", "that", "part", "test", "ate", "State", "copy", "post", "STATE", "info", " states", "size", "port", "draw", "fresh", "store", "version", "al", "master", "power", "event", "spec", "form", "check", "list", "monitor", "call", "local", "client", "the", "rule", "area", "see", "code", "core", "operator", "print", "comment", "trace", "data", "count", "task", "stats", "status", "stat", "command", "start", "tag", "we", "scope", "ace", "range", "admin", "rest", "cor", "job"]}}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n", "idx": 18438, "substitutes": {"pointers": ["checks", "pages", "fts", "bits", "offs", "hw", "ints", "lists", "versions", "args", "pieces", "cells", "aps", "steps", "ports", "values", "pointer", "links", "books", "heads", "vs", "bytes", "pos", "pins", "types", "ids", "actions", "ts", "headers", "locks", "weights", "inters", "ctx", "parts", "ices", "eds", "ashes", "shots", "atts", "points", "qs", "feet", "flags", "posts", "results", "gs", "keys", "ptr", "ps", "bs", "stones", "fs", "tips", "amps", "sets"], "linesizes": ["linespaces", "linesists", "lesides", "linites", "lineseps", "linesizations", " linesists", "linizes", "elineseps", "linedizations", "valseps", "linesized", "elinesitions", "elinesizers", "linedized", "linesides", "linedpaces", "lineize", "linedists", "linsizes", "lesizations", "lsized", "linesitions", "linsizers", " linesides", "lines", "lineses", "linsists", "linides", "elinesizes", "lsizations", "linsides", " linesitions", "lineizes", "linedizes", " lineses", "linses", "lesizes", " linesizers", " lineseps", "leseps", "linsizing", "valsizers", "lesites", "linspaces", "linedizing", " linesizations", "linesize", "lsizes", "linesizers", "linesizing", "valsizes", "linsitions", "linedize", "linizations", "linesites", " linesized", "valsizations", "lesizers", "linepaces", "lsists", "linseps", "linsizations", "linists", "linsites", "lineizing", "linsize"], "w": ["f", "window", "hw", "sw", "iw", "wd", "c", "wb", "win", "res", "wn", " W", "wx", "r", "wal", "wi", "rw", "l", "wp", "m", "nw", "b", "v", "n", "wl", "aw", "wcs", "ew", "s", "wa", "wh", "x", "fw", "W", "wr", "t", "wt", "p"], "h": ["high", "hr", "ih", "f", "length", "ht", "bh", " H", "hei", "en", "g", "hw", "hd", "hh", "H", "c", "uh", "hal", "size", "shape", "q", "he", "y", "ha", "hz", "handle", "r", "height", "oh", "ah", "l", "m", "b", "v", "kh", "n", "o", "k", "hl", "x", "it", "hi", "ch", "t", "hash", "z", "p"], "pix_fmt": ["pix_Fmt", "pix_ffformat", "pix_Ftx", "pix_lmt", "pix_fldr", "pix_ltx", "pix_fmdr", "pix_hlt", "pix_cmt", "pix_virm", "pix_flmt", "pix_vmt", "pix_Ftm", "pix_fdr", "pix_mlt", "pix_flirm", "pix_htm", "pix_fformat", "pix_fnt", "pix_vformat", "pix_vtm", "pix_ffmt", "pix_clt", "pix_firm", "pix_flformat", "pix_mdr", "pix_ctm", "pix_ltm", "pix_fftx", "pix_fmtx", "pix_mtx", "pix_lformat", "pix_hmt", "pix_flt", "pix_ftm", "pix_cmk", "pix_cformat", "pix_cirm", "pix_ctx", "pix_vdr", "pix_fmk", "pix_mmt", "pix_vtx", "pix_fmnt", "pix_cdr", "pix_Flt", "pix_ffmk", "pix_mtm", "pix_ftx", "pix_mnt", "pix_fmmt", "pix_htx"], "align": ["pad", "act", "alias", "coord", "length", "offset", "attr", "end", "ext", "wrap", "IGN", "shift", "aug", "adjust", "ag", "size", "scale", "order", "padding", "len", "aff", "al", "cal", "height", "ac", "grow", "l", "num", "index", "imm", "margin", "aligned", "angle", "hang", "alpha", "rot", "col", "ignment", "mem", "format", "ign", "addr", "xf", "add", " alignment"], "i": ["us", "is", "c", "ip", "ami", " ii", "qi", " err", "I", "ii", "key", "print", "phi", " ti", "span", "status", " j", "t", "iter", "inner", "ui", "pi", "im", " pi", "s", "mi", "multi", "p", " I", "g", "gi", "ind", "chain", "ri", "xi", "ai", "li", "iu", " bi", "ci", "sim", "m", "me", "ti", " is", "x", " x", " m", "uri", " si", "ij", "ski", "si", "batch", "bi", " mi", "info", " v", "ic", "in", "zi", "asi", "id", "ji", "fi", "slice", "di", " ni", " p", " e", "it", "ini", "j", "oi"], "ret": ["cat", "def", "fr", "read", "det", "RET", "out", "val", "print", "mem", "deg", "status", "reg", "br", "offset", "gt", "iter", "virtual", "lit", "report", "rem", "cont", "len", "net", "obj", "re", "round", "progress", "off", "back", "ft", "cmd", "full", "success", "fun", "nt", "mt", "ry", "all", "end", "result", "fail", "buffer", "del", "ll", "flag", "resp", "txt", "uf", "cert", "rets", "last", "aux", "try", "ptr", "rt", "get", "ref", "jp", "tr", "res", "gc", "att", "rel", "rev", "Ret", "rect", "value", "backed", "reset", "alt", "it", "addr", "t"], "buf": ["tmp", "window", "ff", "cv", "pad", "box", "block", "br", "end", "cache", "ref", "result", "vec", "bd", "iter", "wb", "bar", "Buff", "BA", "func", "buffer", "Buffer", "conv", "rb", "tr", "bytes", "img", "np", "obj", "cb", "pb", "max", "r", "arr", "rw", "BU", "b", "v", "txt", "uf", "out", "bn", "bc", "alloc", "cmd", "db", "used", "data", "uv", "mem", "msg", "bl", "bin", "buff", "raw", "fun", "bf", "mb", "queue", "ptr", "boxes", "bs"]}}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n", "idx": 18439, "substitutes": {"s": ["ls", "sl", "is", "sts", "sv", "rs", "st", "states", "aws", "fs", "h", "sq", "args", "sm", "settings", "js", "os", "store", "ss", "details", "ns", "ims", "spec", "r", "ms", "bs", "ts", "sys", "sp", "has", "sb", "services", "stats", "ds", "qs", "ses", "less", "status", "w", "S", "gs", "ps", "t", "comm", "sis", "hs", "p"], "index": ["is", "block", "document", "i", "pointer", "IND", "exclusive", "address", "insert", "message", "key", "axis", "capacity", "status", "find", "from", "offset", "mount", "connected", "iter", "interface", "null", "pos", "zero", "subject", "row", "code", "state", "context", "empty", "success", "loop", "scope", "process", "window", "length", "location", "ind", "Index", "update", "point", "ex", "valid", "size", "dim", "error", "version", "loc", "set", "available", "level", "instance", "x", "count", "seek", "number", "no", "image", "batch", "connection", "ion", "lock", "info", "connect", "draw", "position", "thread", "in", "select", "item", "height", "call", "num", "id", "value", "local", "slice", "j"], "frame": ["f", "profile", "window", "component", "zone", "type", "block", "length", "offset", "cf", "label", "Frame", "iframe", "rame", "channel", "point", "fb", "pointer", "position", "fram", "buffer", "fr", " Frame", "event", "face", "flag", "target", "remote", "sequence", "height", "tf", "zero", "id", "owner", "AME", "time", "code", "state", "reset", "context", "sf", "send", "trace", "frames", "feature", "forced", "image", "hide", "base", "xf", "process", "ace", "range", "allowed"]}}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n", "idx": 18447, "substitutes": {"vdev": ["vpad", "vdevice", "camdev", "wdiv", "wdev", "svpad", "dserv", "vcdev", "vcdiv", " vev", "vev", "vserv", "vdiv", "vcpad", "ddevice", "svev", "ddiv", "camserv", "camdevice", "ddev", " vdiv", "vcev", " vpad", "svdev", "camdiv", "svdiv", "wserv", "wdevice"], "vq": ["sveq", "svque", "hw", "vw", "vQ", "verqu", "vereq", " vQ", "vcue", "hque", "vcq", "svqu", " vque", "hQ", "svQ", "hq", "svw", "vque", "svue", " vw", "verue", "svq", "vue", "vqu", "vceq", "veq", "vcqu", "verq"], "s": ["ls", "sl", "is", "us", "sts", "g", "rs", "sv", "iss", "fs", "a", "h", "sq", "c", "sm", "js", "i", "self", "ss", "su", "ns", "sh", "set", "ms", "ats", "bs", "ts", "sys", "m", "es", "b", "v", "se", "n", "sb", "sol", "stats", "ds", "S", "sam", "gs", "source", "cs", "ps", "t", "comm", "sis", "hs", "j", "p"]}}
{"project": "qemu", "commit_id": "1a20a032ccbb5800bfdfc75accfcff2ac67f5bcb", "target": 1, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct usb_device_info bus_info, dev_info;\n\n    USBDevice *d = NULL;\n\n    USBHostDevice *dev;\n\n    char ctlpath[PATH_MAX + 1];\n\n    char buspath[PATH_MAX + 1];\n\n    int bfd, dfd, bus, address, i;\n\n    int ugendebug = UGEN_DEBUG_LEVEL;\n\n\n\n    if (usb_host_find_device(&bus, &address, devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buspath, PATH_MAX, \"/dev/usb%d\", bus);\n\n\n\n    bfd = open(buspath, O_RDWR);\n\n    if (bfd < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to open usb bus - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n    bus_info.udi_addr = address;\n\n    if (ioctl(bfd, USB_DEVICEINFO, &bus_info) < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to grab bus information - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s\", bus_info.udi_devnames[0]);\n\n#else\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s.00\", bus_info.udi_devnames[0]);\n\n#endif\n\n\n\n    dfd  = open(ctlpath, O_RDWR);\n\n    if (dfd < 0) {\n\n        dfd = open(ctlpath, O_RDONLY);\n\n        if (dfd < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to open usb device %s - %s\\n\",\n\n                   ctlpath, strerror(errno));\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (dfd >= 0) {\n\n        if (ioctl(dfd, USB_GET_DEVICEINFO, &dev_info) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to grab device info - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            goto fail;\n\n        }\n\n\n\n        d = usb_create(NULL /* FIXME */, \"usb-host\");\n\n        dev = DO_UPCAST(USBHostDevice, dev, d);\n\n\n\n        if (dev_info.udi_speed == 1)\n\n            dev->dev.speed = USB_SPEED_LOW - 1;\n\n        else\n\n            dev->dev.speed = USB_SPEED_FULL - 1;\n\n\n\n        if (strncmp(dev_info.udi_product, \"product\", 7) != 0)\n\n            pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                    dev_info.udi_product);\n\n        else\n\n            snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                     \"host:%s\", devname);\n\n\n\n        pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\");\n\n        pstrcat(dev->devpath, sizeof(dev->devpath), dev_info.udi_devnames[0]);\n\n\n\n        /* Mark the endpoints as not yet open */\n\n        for (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\n           dev->ep_fd[i] = -1;\n\n\n\n        ioctl(dfd, USB_SETDEBUG, &ugendebug);\n\n\n\n        return (USBDevice *)dev;\n\n    }\n\n\n\nfail:\n\n    return NULL;\n\n}\n", "idx": 18457, "substitutes": {"devname": [" devNAME", "evname", " Devname", " DevName", "evNAME", " devno", " devName", "devName", "deviceno", "devno", "devNAME", " Devno", "evName", "deviceName", "evno", "devicename", " DevNAME"], "bus_info": ["BUS_conf", "bus2Info", "bus_inf", "boot_dict", "BUS_update", "bus_dict", "bus___info", "bus_no", "BUS_Info", "bus___Info", "bus_INFO", "bus2inf", "boot_Info", "BUS_no", "bus___dict", "boot_info", "BUS_status", "bus_status", " bus_id", "bus_Info", " bus_fo", "bus_update", "boot_inf", "bus2dict", "BUS_inf", "bus_id", "BUS_info", "BUS_INFO", "bus___inf", "bus2info", " bus_inf", "bus_conf", "bus_fo"], "dev_info": ["dev2info", "device_fo", "dev_type", "ev_settings", "Dev_inf", "dev_settings", "devJinfo", "devJtry", "dev_try", "ev_try", "device_info", "Dev_info", "dev2inf", "dev_fo", "dev_inf", "dev2fo", "ev_info", "dev_query", "Dev_query", "device_type", "devJsettings", "dev2type", "device_inf"], "d": ["fd", "f", "did", "g", "dx", "bd", "du", "dn", "h", "c", "ad", "dt", "D", "device", "sd", "dat", "dm", "e", "r", "da", "dh", "b", "v", "n", "o", "dd", "dom", "db", "data", "ds", "di", "dr", "w", "od", "t", "dc", "pd", "p"], "dev": ["block", "bd", "h", "wd", "ad", "def", "pp", "debug", "home", "max", "det", "dem", "v", "o", "md", "dis", "mem", "vo", "new", "f", "pad", "Dev", "hw", "_", "test", "develop", "des", "serv", "device", "obj", "sd", "spec", "ev", "endif", "db", "cmd", "usb", "w", "ow", "stop", "nt", "stable", "conn", " device", "dn", "util", "go", "iv", "set", "buf", "ve", "desc", "pro", "serial", "of", "tech", "config", "boot", "final", "cam", "DE", "td", "info", "pub", "func", "tr", "ver", "att", "da", "gu", "n", "priv", "dd", "fi", "DEV", "data", "de", "ds", "di", "adv", "av", "fo", "od"], "ctlpath": ["ctlth", "ctrlfile", "dlpath", "ctllog", "ctlcert", "switchtrace", "dpath", "connPath", "ctxPATH", "connth", "ctrlpath", "switchPath", "dPATH", "driverpath", "conntrace", "ctrlPath", "cmdth", "ctxpath", "connpath", "dlPath", "ctltemplate", "ctPath", "soccert", "socprop", "dllcert", "ctltrace", "ctlpointer", "dlcert", "dlog", "switchopath", "driverprop", "ctxlog", "ctpath", "dllprop", "cbpath", "cmdtemplate", "dlprop", "dllPath", "cbpointer", "ctrlprop", "ctlPATH", "ctrltrace", "conntemplate", "ctfile", "ctlPath", "ctlopath", "ctpointer", "ctxPath", "driveropath", "ctrlth", "socopath", "ctrlpointer", "ctrlcert", "socpath", "ctlprop", "cmdpath", "cbPath", "dllpath", "cmdPath", "switchpath", "drivercert", "ctlfile", "ctrlPATH", "connopath", "ctrlopath", "ctrllog", "ctrltemplate", "dPath", "cbfile"], "buspath": ["ctlth", "bcurl", "sticktemplate", "BUScase", "BUSurl", "bustime", " busPath", "stickurl", "ctltime", "boxpath", " busroot", "boxPath", "boxth", "ctlroot", "stickcase", "busth", "boxtime", "cbpath", "cbroot", "bcPath", "busroot", "bctime", "ctlPath", "bctemplate", " busfile", "busfile", "stickpath", "BUSpath", "buscase", "busPath", "bustemplate", "bcth", "cbPath", "ctlfile", "busurl", "BUStemplate", "bccase", "bcpath", "cbfile"], "bfd": ["nbdl", "nbfunc", "wbgd", " bsd", "abdf", " bdat", "bgd", "abdd", "bbsd", "obdl", "wbfd", " bbd", "Bfd", "abgd", "obgd", "nbfd", "Bdat", "obfd", "bbd", "objsd", "objfd", "abfunc", "nbgd", "bbbd", "bsd", "bdf", "bdd", "abfd", "bdat", "bfunc", "nbdd", "bdl", "bbfd", " bdf", "nbdf", "objbd", "wbfunc", " bdd", "bbdd", "Bdf", "obdf", " bgd", " bdl", "wbdd", "Bdd", "objdd", "abdat"], "dfd": ["dpD", "fdd", "dpc", "fdfd", "fdr", "dpd", "fddd", "dpdd", "dbd", "dfsd", "dfn", "tffd", "dlds", "ddt", "dft", "dds", "fdcd", "fdsd", "dpl", "dfdd", "idddid", "ddfd", " dfp", "dfD", " dfD", "ufcd", "fdp", "olfdd", "iddfd", "dfdi", "tfd", "dffd", "dbD", "pdfcd", "dfp", "pdfd", "DFs", "fdc", "fdds", "DFsd", "dpr", "tfdid", "DFd", "fdD", "dfc", "dfs", "ufn", "dfr", " dft", "ddp", "ufd", "fdl", "idddd", "ddl", "ufdi", "dlfd", "ddc", " dfdd", "iddd", "dfcd", " dffd", "olfD", "ddsd", "dld", "ddD", "dbt", "dfl", "pdfdi", "DFp", "fds", "dfdid", "pdfn", "ddds", "dpn", " dfdid", "dfds", "ddd", "fddi", "ddn", "olfr", "tfdd", "olfd", "dbp", "dlp", "fdn"], "bus": ["bridge", "us", "bit", "type", "box", "block", "alias", "boot", "uses", "host", "connection", "chain", "mount", "user", "card", "interface", "service", "product", "board", "brand", "port", "os", "ip", "home", "class", "bug", "handle", "id", "bid", "b", "back", "family", "binding", "Bus", "prefix", "proxy", "BUS", "controller", "loop", "lib", "usb", "base", "ch", "bs"], "address": ["resource", "alias", "type", "location", "host", "connection", "route", "a", "ash", "interface", "ca", "point", "ai", "service", "port", "position", "order", "attribute", "ip", "device", "pi", "Address", "message", "reference", "network", "path", "index", "id", "angle", "description", "context", "active", "controller", "number", "domain", "command", "directory", "addr", "ress", "ace", "api", "name", "p"], "i": ["f", "a", "c", "interface", "ai", "ip", "in", "io", "pi", "e", "r", "l", "m", "index", "id", "b", "v", "k", "I", "n", "ii", "di", "mi", "t", "z", "j", "p"]}}
{"project": "FFmpeg", "commit_id": "98b377004d9c6fa1c1756c814efe9882b65f96b9", "target": 0, "func": "static av_cold int twin_decode_init(AVCodecContext *avctx)\n\n{\n\n    int ret;\n\n    TwinContext *tctx = avctx->priv_data;\n\n    int isampf, ibps;\n\n\n\n    tctx->avctx       = avctx;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    if (!avctx->extradata || avctx->extradata_size < 12) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = AV_RB32(avctx->extradata    ) + 1;\n\n    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;\n\n    isampf          = AV_RB32(avctx->extradata + 8);\n\n\n\n    if (isampf < 8 || isampf > 44) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (isampf) {\n\n    case 44: avctx->sample_rate = 44100;         break;\n\n    case 22: avctx->sample_rate = 22050;         break;\n\n    case 11: avctx->sample_rate = 11025;         break;\n\n    default: avctx->sample_rate = isampf * 1000; break;\n\n    }\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",\n\n               avctx->channels);\n\n        return -1;\n\n    }\n\n    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO :\n\n                                                   AV_CH_LAYOUT_STEREO;\n\n\n\n    ibps = avctx->bit_rate / (1000 * avctx->channels);\n\n\n\n    if (ibps > 255) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((isampf << 8) +  ibps) {\n\n    case (8 <<8) +  8: tctx->mtab = &mode_08_08; break;\n\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n\n        return -1;\n\n    }\n\n\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if ((ret = init_mdct_win(tctx))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        twin_decode_close(avctx);\n\n        return ret;\n\n    }\n\n    init_bitstream_params(tctx);\n\n\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n\n\n    avcodec_get_frame_defaults(&tctx->frame);\n\n    avctx->coded_frame = &tctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18462, "substitutes": {"avctx": ["avaddr", "wavdl", "avgc", "avctl", "aucontext", "wavconf", "awcv", "cvcmp", "avparams", "avejp", " avcp", "avecontent", "averjp", "afctl", " avcu", "avkt", "avresp", "averctx", "wavct", "navpid", "varcrit", "wavaddr", "navctx", "afcontext", " avcmp", "awtx", "avcontext", "avct", " avctl", "wavcmd", "avercmd", "ajtx", "avcp", " avconn", "averpid", " avloc", "aveloc", " avgc", "wavconn", "varcontext", "afkl", "avercv", " avkt", "avectx", "avect", "awctx", "averparams", "wavcv", "aucp", "afreq", " avcontext", "avconn", "verkt", "wavcmp", "auctx", "navcrit", "avecmd", "afcrit", "afcmd", "avcookie", "avcv", "afpkg", "avkl", "wavcontext", " avpkg", "vercontext", "navctl", "abtx", " avcontent", "afresp", "avecookie", " avcv", "awcontext", "verctx", "avercu", "vercrit", "averresp", "avcmd", "avedl", "ahcontext", "avecp", "afcv", "avcontent", "wavcp", "wavreq", "averkt", "cvctx", "aftx", "avercontent", "avecrit", "navkt", "vercu", "abctx", "avetx", "avecontext", " avtx", " avca", "vertx", "afkt", "averca", "avercontext", "navtx", " avpid", "avecu", " avcrit", "afloc", "wavcu", "avpid", "awcu", "avcu", "avcmp", "wavctx", "avloc", "avconf", "wavkt", "wavcrit", "ajpkg", "aveparams", "ajresp", "vargc", "wavpkg", "afconf", "afparams", "vartx", "afctx", "averct", "avegc", "afobj", " avobj", "wavparams", "avpkg", "averdl", "ajconf", "avtx", "cvcontext", "autx", "ahctx", "avecmp", "avdl", " avcookie", "avercmp", "avca", "ajparams", " avcmd", "avecv", "avjp", "avertx", "afcu", "abaddr", "abconn", "varcookie", "avercp", "afcp", "wavctl", "ahcrit", "avekl", "varcu", "avcrit", "avobj", "afjp", "ajctx", "afpid", " avkl", "ajkt", "verpkg", " avreq", "aveca", " avaddr", "wavtx", "cvtx", "ahobj", "varctx", "avepkg", "avreq", "afcmp"], "ret": [" res", "gt", " reply", "result", " RET", "urn", "ral", " resp", "Return", "resp", "RET", "Ret", "rev", "pol", "value", "val", "alt", "mem", "vals"], "tctx": ["rcmp", "ttx", "atctx", "tmtx", "tscmd", "attx", "tcmp", "tenctx", " ttx", "mtx", "rtx", "tmcu", "ptx", "wtxt", "tencontext", "rcu", "tencmd", "tmctx", "tresp", "pcontext", " tcontext", "pctx", "tenresp", "tentxt", "tcp", "wctx", "tentx", "mctx", "mcmp", "wcp", "atcontext", "tstx", "pcp", "tmcmp", "wtx", "wresp", "rctx", "tcmd", "tscontext", "atcp", "tcontext", "tcu", "tsctx", " tcmd", " ttxt", " tresp", "ttxt", "mcu", "wcontext"], "isampf": ["isampedxf", "isarml", "endsampff", "ispptf", "isarmfr", "Isppf", "isipptf", "endsampxf", " isamph", "isampleh", "Ispptf", "isarmfc", "isampif", "bsarmF", "isamff", "isamplec", "isarmfac", "endsampedfr", "isampsF", "isippf", "endsarmfr", "isarmfs", "isaramif", "isampbf", "isippfort", "isampfl", "isamF", "istsampfac", "istsampf", "endsarmfc", "isammlf", "isapbf", "endsampedff", "isamxf", "bsarmfs", "endsampedf", "endsampif", "isampsf", "isarmf", " isampc", " isampleh", "IsppF", "isaramf", "isammfac", "ismpf", "isamf", " isamplefl", "bsampF", "isreamF", "Isppfort", "isampF", " Isampbf", "istsarmf", "bsampf", " isampfl", "isaramfr", "isamh", "endsarmif", "isarmif", "ismpfac", "isampedff", "bsampl", "isarmlf", "endsarmf", "isufffr", " isamplef", "isippF", "isrpmf", "isamfl", " Isapbf", "isufffc", "bsarmf", "isamplef", "isppf", " IsapF", "isapfl", "isampfort", "isaramfc", "isampedfr", "isrpmxf", "isrpmff", "ismpfc", "isamplf", "isampedf", " IsampF", "isuffif", "endsampfr", "isampsl", "isampfc", "isamptf", "istsarmfc", "bsampfs", "isammfc", "isppfs", "bsarml", "isampff", "Isamptf", "isampfr", "endsampf", "istsarmlf", "isrpmfr", "isreamfort", "isampsbf", "isampc", "isampfac", "IsampF", "isarmF", "isamfr", "isppF", " isamplec", "Isampfort", "isampfs", "isppfort", "isreamf", " Isapf", "isampsfs", "isapF", " Isampf", "isammf", "isapc", "isamc", "isamplefl", "Isampf", "istsamplf", "istsarmfac", "istsampfc", "isreamtf", "endsampfc", "isppl", "isampxf", "ismplf", "isambf", "isufff", "isamph", "isaph", "isampl", "isapf", "endsampedxf"], "ibps": ["abms", "ibcs", "abresses", "IBps", " ibrs", "robps", " ibp", "abports", "imrs", "IBpps", "abples", "imms", "ibports", "imps", "ibip", "rebports", " ibms", "IBresses", "ilibpps", "IBples", "robp", "ilibPS", "abaps", "impps", " ibaps", "ibms", "ibiples", "IBaps", "ibPS", "abPS", "IBPS", "rebps", "robcs", "ibresses", " ibPS", " ibcs", "ibples", "ibics", "IBports", "rebples", "ilibresses", "ibrs", "abps", " ibples", "abrs", "ibpps", "abpps", "ibaps", "IBms", "ibp", "ilibps", "robples", "rebms", " ibpps", "ibips"]}}
{"project": "FFmpeg", "commit_id": "18ff4d20201ae69fdeb2da2c90bdcbd33f7ac025", "target": 1, "func": "static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)\n\n{\n\n    AVFormatContext *is = ifile->ctx;\n\n    AVFormatContext *os = ofile->ctx;\n\n    int i;\n\n\n\n    for (i = 0; i < is->nb_chapters; i++) {\n\n        AVChapter *in_ch = is->chapters[i], *out_ch;\n\n        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,\n\n                                       AV_TIME_BASE_Q, in_ch->time_base);\n\n        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :\n\n                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);\n\n\n\n\n\n        if (in_ch->end < ts_off)\n\n            continue;\n\n        if (rt != INT64_MAX && in_ch->start > rt + ts_off)\n\n            break;\n\n\n\n        out_ch = av_mallocz(sizeof(AVChapter));\n\n        if (!out_ch)\n\n            return AVERROR(ENOMEM);\n\n\n\n        out_ch->id        = in_ch->id;\n\n        out_ch->time_base = in_ch->time_base;\n\n        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);\n\n        out_ch->end       = FFMIN(rt, in_ch->end   - ts_off);\n\n\n\n        if (copy_metadata)\n\n            av_dict_copy(&out_ch->metadata, in_ch->metadata, 0);\n\n\n\n        os->nb_chapters++;\n\n        os->chapters = av_realloc(os->chapters, sizeof(AVChapter) * os->nb_chapters);\n\n        if (!os->chapters)\n\n            return AVERROR(ENOMEM);\n\n        os->chapters[os->nb_chapters - 1] = out_ch;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18474, "substitutes": {"ifile": [" ifute", "ofil", " ifil", "isfute", "IFfile", "IFail", " iffile", "ifail", "inffile", "ifute", "infil", "ofiles", "infile", "ifiles", "isfil", "isfile", "Ifil", "tifile", "ofail", "Ifile", "Ifail", "IFiles", "Iffile", "ifil", "tifil", "iffile", "offile", "IFil", "isffile", "tifiles", "infute", "tiffile", "IFile"], "ofile": ["offime", "ofil", "offole", "Ofiles", "offate", "oile", "oail", "ofole", "ofime", "offil", "orfile", "orfILE", "OFate", " ofil", "ofiles", "OFile", "offiles", "OFail", "offactory", "orfiler", "OFil", "ofactory", "OFiles", "sffile", "ofiler", "oil", "Ofate", "ofail", "ofate", "OFfile", " ofole", " ofiler", "oole", "Ofil", " ofail", "sfiler", " ofILE", "sfile", "Ofile", " ofime", "oime", "offile", "ofILE", "offail", " offile", "OFactory", "oactory", "orffile", "offfile", "sfILE"], "copy_metadata": ["copymaybemeta", "copy_meta", "copy_m", " copy_m", "copy__xml", "copy__metadata", " copy_xml", "copymaybemetadata", " copy_meta", " copy_maybe", "copy__meta", "copy_xml", "copy__maybe", "copy_maybe", "copymaybexml", "copy_mint", "copymaybemaybe", " copy_mint"], "is": ["us", "bits", "ins", "as", "iss", "ir", "ics", "mos", "ri", "ais", "sis", "tis", "js", "ic", "isi", "isf", "obs", "in", "ris", "ms", "IS", "its", "has", "bis", "ii", "iris", "s", "are", "oss", "isal", "atis", "isa", "aus", "ois", "lis", "ists", "isc", "iso", "bs", "fs", "Is", "si", "ist"], "os": ["us", "ost", "ose", "boot", "ox", "er", "as", "los", "ols", "ops", "mos", "oe", "oz", "oses", "js", "or", "ants", "osi", "ot", "oS", "obs", "pos", "io", "dos", "ns", "ms", "sys", "ts", "Os", "acs", "oos", "o", "out", "oes", "OS", "s", "et", "oss", "bos", "oids", "ds", "oa", "ows", "ys", "oid", "at", "otes", "aos", "bs", "fs", "ros", "es"], "i": ["us", " I", "g", "bi", " li", "gi", "ind", " mi", "ri", "xi", "ki", "ex", "ai", "info", "oi", "batch", "name", "li", "ui", "ic", "y", "in", "ip", " ii", "ims", "pi", "iu", "qi", "im", "r", " bi", "ci", "zi", "sim", "m", "me", "index", "ji", "v", "I", "o", "out", " iter", "ii", "ti", "ix", "x", " ti", " x", "di", " ni", " si", " j", "mi", " multi", "it", "hi", "ie", "ij", "ini", "multi", "j", "si", "p"], "in_ch": ["in_cht", " in_hand", "in_chan", " in_cp", "in__ich", "inc_ch", "in___ich", "in___ch", "in2chan", "in1ch", "din_ch", "out_cho", "intcomp", "inwchan", "in__ch", "inMatchu", "vin__ich", "din_chan", "in_ich", "in_arch", "vin_ch", "in_cho", "in_chi", "in2ich", " in_cht", " in_Ch", "din___ch", "in_ech", "inc_comp", "in__chi", "vin_ich", "vin_chi", " in_ech", "in_cp", "din_ich", "in_tch", "inMatch", "inc_arch", "din___chan", "in_sch", "intch", "in_Ch", "in_chu", "inxarch", "in_cha", "intcol", "din_cht", "intarch", " in_che", "in1col", "vin__ch", "inpech", "in1ech", "inpch", "in___cht", "in_hand", "in_col", "din___cht", "inwcho", " in_sch", "inxchan", " in_cho", "vin_chan", "inwch", "out_tch", "in2ch", "inpche", "din___ich", " in_chu", "inMatcp", "inMatCh", "inc_col", "in___chan", "inpCh", "in2chi", "in_che", " in_arch", "in2arch", "in1arch", "in1chan", "inxche", "in__chan", " in_cha", "in_comp", "inxch", "in2che", "vin__chi", "in1cht", "in1comp", "inwtch", " in_chan", "vin__chan", "out_chan"], "out_ch": [" out_chan", "in_chan", "outmych", "out___ch", "outletuch", "cache_chn", "out___vc", "exp_cl", "cacheptchn", "out_ech", " out_ech", "out_cho", "exp_chan", "outmychan", "in_ich", "outmycha", " out_chn", " out_cho", "Out_cho", "outletich", "out_vc", "out_Ch", "Out_ech", "out___ich", "Out_uch", "outptchn", "out_uch", "outmyich", "out_cha", "outptch", " out_Ch", "outptcho", "cache_cor", "out___uch", "in_cha", "check_ch", "exp_ch", "cache_ch", "exp_chn", "Out_chan", "outptcor", "Out_Ch", "Out_ch", "out_cor", "cacheptcho", "outletvc", "cacheptcor", "check_vc", "check_ich", "cacheptch", "outletch", "out_chn", "out_ich", "check_uch", "out_cl", "cache_cho", "out_chan"], "nb_chapters": ["nb_Chars", "nb_champions", "nb_achapters", "nb_weunks", "nb_charts", "nb_ichannels", "nb__chars", "nb_vapters", "nb_Channels", "nb_acharts", "nb_cars", "nb_cannels", "nb__chorders", "nb__contapters", "nb__chunks", "nb__contorders", "nb_chorders", "nb_heapters", "nb_Champions", "nb__chants", "nb_weants", "nb_contannels", "nb_channels", "nb_echars", "nb_chars", "nb_capters", "nb__achants", "nb_hears", "nb__achars", "nb_contorders", "nb_ichapters", "nb_achars", "nb_chunks", "nb_vampions", "nb_vmakers", "nb__contannels", "nb_echampions", "nb_vars", "nb_hearts", "nb_contapters", "nb__channels", "nb_cunks", "nb_carts", "nb__contars", "nb__achapters", "nb__achunks", "nb_ichars", "nb_heannels", "nb__chapters", "nb_ichorders", "nb_contars", "nb_Chapters", "nb_wears", "nb_chmakers", "nb_chants", "nb_Chorders", "nb_Chmakers", "nb_echmakers", "nb_echapters", "nb_achants", "nb_weapters", "nb_achunks", "nb_cants", "nb_achannels"]}}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 18477, "substitutes": {"rec": ["rt", "reg", "ok", "th", "ref", "sec", "Rec", "iter", "REC", "disc", "rc", "rem", "ck", "fr", "ro", "fin", "res", "in", "doc", "obj", "rr", "roll", "re", "rel", "r", "form", "resp", "commit", "con", "ack", "row", "record", "skip", "cmd", "desc", "coll", "req", "col", "mem", "par", "ent", "w", "dr", "nt", "rest", "decl"], "event": ["new", "vent", "component", "type", " EVENT", "ext", "offset", "entity", "update", "err", "info", "error", "attribute", "events", " exc", "ee", "re", "item", "argument", "address", "e", "handler", "message", "id", "index", "ack", "record", "Event", "ev", "context", "change", "cmd", "data", "feature", "task", "frame", "msg", "ent", "image", "command", "ception", "exc", "field", "name"], "datasize": ["datarsiz", "datalsizer", "Datasiz", "Datalsource", "datarsizer", "datarsize", "Datasized", "datASize", "datASiz", "datnosize", "datasizer", "datalsized", "datnosizer", "datatsized", "datnosource", "datASource", "datasized", "Datalsiz", "datatsize", "Datasizer", "Datarsiz", "datalsize", "datnosiz", "Datalsize", "datarsized", "Datarsize", "datasiz", "datalsource", "datasource", "Datasource", "datatsizer", "Datalsizer", "datASizer", "Datasize", "Datarsized", "datatsiz", "datalsiz", "Datarsizer"], "idx": ["idex", "idw", "Idw", "idxc", "idz", "ideix", "vidxa", "Idix", "uidix", " idy", "ipxy", "vidx", "midxc", "idxf", "midxa", "idez", "Idy", "uidx", " idw", "indx", "idexy", "uidy", "Idxc", " idxf", "midx", "uidex", "Idx", "idy", "indxf", " idz", "Idxy", "idexf", "Idex", " idix", "ipx", "indz", " idxa", "ipex", "Idz", "idexc", " idex", "vidxc", "idxa", "ideex", "ipxc", "midix", "idxy", "idew", "idey", " idxc", "idix", "vidix", "indix"], "rec_off": ["rec_opp", "discJoffer", "rec8offer", "rec2off", "decl8off", "rec_op", "rec__on", "rec_ovi", " rec_offer", "rec2offset", "rec__OFF", "recPend", "recpyalong", "rec8off", " rec2offset", "scan_o", "rec_offer", " rec_of", "scan_offer", " rec2offer", "recjoff", "scan_off", "rec_of", "rec8along", "rule_set", "record_offs", "rec2Off", "record2OFF", "recdOff", "decl_along", "rec_set", "recpyoffer", "rec_o", "rec2offs", "disc_offs", "record_off", "recpyoff", "recjovi", "rec__offset", "decl_offer", "err__OFF", " rec2off", "decl_off", " Rec_offer", "rec_fun", "recjoffer", "record_Off", "record_OFF", "decl8along", "record2Off", "discJoff", "rec_offset", " rec_on", "rec__of", "record2offs", "recJoffset", "rec__off", "recPoff", "rec2OFF", "scan_Off", "recPoffset", " rec_offset", "record2off", "err__off", "rec2end", "recjop", "rule_opp", "err_off", "rec_end", "rec_Off", "record_offset", "recJoff", "rule_fun", "discJoffs", " Rec_off", "decl8offer", "err_offset", "rec_on", "err_OFF", "err__offset", "recJoffs", "record_end", "disc_off", "rec_offs", "recdoff", "rule_off", "rec_OFF", " Rec_ovi", "rec2offer", "disc_offer", "recJoffer", "rec_along", " Rec_op"], "old_idx": ["old_midx", "old___idsy", "old___idsxc", "old_idsx", "old_idb", "old_intn", "old_idsp", "old____intn", "old_idz", "old_ridy", "old____intb", "old_idsn", "old_idfx", "old___idn", "old_ridn", "old___idsn", "old_indy", "old_idsxs", "old___idy", "old_intb", "old_ideex", "old_midfx", "old_ridx", "old_kidx", "old_kidxf", "old_idexf", "old_indp", "old____idfx", "old_idp", "old___idxc", "old_kidy", "old___idsx", "old_Idb", "old_intfx", "old_idex", "old_idxc", "old_idey", "old_indxs", "old_idn", "old_idy", "old_idxf", "old_Idex", "old_ridxc", "old_Idz", "old____intx", "old_intx", "old____idb", "old___idx", "old____idn", "old_idsxc", "old____intfx", "old____idx", "old_indx", "old_Idfx", "old_midn", "old_Idn", "old_Idy", "old_midb", "old_idez", "old_idxs", "old_Idx", "old_idsy"], "new_idx": ["new_kidxs", "new_pidx", "new_indc", "new_kidn", "new_inc", "new_Idex", "new_pidn", "new_pidex", "new_inz", "new_indz", "new_Idxs", "new_inx", "new_Idz", "new_idz", "new_idex", "new_idv", "new_Idy", "new_indx", "new_pidxs", "new_kidy", "new_inv", "new_Idn", "new_idy", "new_idn", "new_pidz", "new_idxs", "new_indv", "new_Idx", "new_idc", "new_Idv", "new_kidex", "new_pidy", "new_pidv", "new_kidx"]}}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 18493, "substitutes": {"zSign": ["zChange", "ziChange", "zPos", "ezPos", " zDig", "ziAct", "ziSet", "zAct", "ziExp", "ezSet", "zDig", "izAct", "ezAct", "ziDig", "ZSign", "ezSign", " zAct", "ZDig", "ezDig", "izExp", "ziSign", " zPos", "ziForm", "zSet", "zForm", "izChange", "ezForm", " zSet", " zChange", "ezExp", "izSign", " zForm", "ZExp", "ziPos"], "zExp": ["zenEnc", "ezExt", "ZReg", "czPress", "zEl", "ezPress", " zEx", "zipPos", " zEXP", "ZSup", "zenEXP", " zEnc", "ezExp", "ZExp", "zEx", "czEnc", " zSup", " zComp", "czResp", "zipExp", "ezEx", "zExpress", " zExt", "czInc", "zenReg", "zipExpress", "czEl", "zExt", "ZEx", "zOp", "ziInc", "zhExp", "zoneExp", "zhEx", "zipEXP", "nzResp", "zeExp", " zExpress", "ziEl", "zhInc", "zPos", "nzExec", " zPress", "zeEXP", " zReg", "ezExec", " zResp", "zePos", "czExec", "czExt", "zEXP", "zResp", "ziEx", " zPos", "zComp", "ezEnc", "czEx", "zhEl", "nzExp", "zenExec", "zSup", " zExec", "czComp", "zInc", "zenOp", "zEnc", "ziReg", "czExp", "ziExp", "zoneEnc", "zPress", "zenExp", "zoneExec", "zoneComp", " zOp", "zExec", "nzExt", "zReg", "ezReg", "zenPress", "zeExpress", "czEXP", "ziSup", "czOp"], "STATUS_PARAM": ["STATUSPPARParam", "STATUS_PARParam", "STATUSPARams", "STATUSPARAMS", "STATUSPPARAM", "STATUS_ARAMS", "STATUSPARAM", "STATUS_Vams", "STATUS_PARams", "STATUS_Params", "STATUS_ARAM", "STATUSPARParam", "STATUSPPARAMS", "STATUS_PARAMS", "STATUS_ARParam", "STATUS_VAMS", "STATUS_ARams", "STATUSPPARams", "STATUS_ParParam", "STATUS_ParAM", "STATUS_VAM", "STATUS_ParAMS", "STATUS_VParam"], "roundingMode": ["turningMODE", "roundingingMethod", "roundningMODE", "roundizationMODE", "roundbingMODE", "roundchingModule", "runingmode", "roundingModel", "roundingModule", "roundbingmode", "turningMode", "calllingMODE", "turningManager", "calllingMethod", "rounderingMODE", "runbingMode", "roundtingModule", "turningM", "roundchingManager", "rounderMODE", "roundINGM", "roundlingMode", "groupingModel", "roundeningModule", "roundingingMODE", "turntingM", "roundingmode", "rounderingMode", "roundlingMethod", "turningMethod", "groupingMode", "roundingMethod", "turntingMODE", "roundningMethod", "roundendingTheme", "roundtingManager", "grouptingMODE", "runbingmode", "runbingMethod", "turnlingMODE", "roundingingModule", "roundizationMode", "roundINGMODE", "roundeningModel", "turningTheme", "turnlingMode", "roundtingM", "groupingMODE", "roundendingManager", "turnlingMethod", "roundingM", "groupingModule", "roundtingMode", "roundeningMODE", "roundchingTheme", "roundtingTheme", "rounderMode", "roundbingMode", "roundendingModule", "roundbingMethod", "runingMODE", "turnlingForce", "roundINGMethod", "grouptingModule", "roundingForce", "roundlingForce", "grouptingModel", "roundchingMode", "rounderingForce", "runingMode", "callingMethod", "roundINGmode", "roundingMODE", "grouptingMode", "runbingMODE", "rounderMethod", "roundingingMode", "turntingManager", "roundINGForce", "roundingManager", "runingMethod", "roundtingModel", "roundermode", "roundlingMODE", "turntingModule", "roundeningMode", "turntingTheme", "rounderingMethod", "roundizationM", "roundtingMODE", "roundingingModel", "turningForce", "turntingMode", "callingMODE", "callingMode", "roundINGMode", "roundingTheme", "roundendingMode", "turningModule", "roundningMode", "calllingMode"], "roundNearestEven": ["roundNearesteven", "roundNaresteven", "roundnearestEven", "roundNeearLong", "roundNearEven", "roundNeeareven", "roundNarestEven", "roundNeekeven", "roundNeipalZero", "roundNeearZero", "roundNeutralEven", "roundnearestLong", "roundneearEven", "roundNarestZero", "roundneeareven", "roundNeekLong", "roundnearesteven", "roundNeipalEven", "roundNeipaleven", "roundneearLong", "roundNeareven", "roundNeearEven", "roundNeathereven", "roundNearestZero", "roundNeatherEven", "roundNeutralZero", "roundNearestLong", "roundNeekEven", "roundNearZero", "roundNeutraleven"], "roundIncrement": ["roundInterments", "RoundAdjustmented", "roundIncreement", "rollDecreli", "roundImprovementation", "roundIncreMENT", "roundDecreMENT", "quickSegstant", "roundImprovement", "roundincreMENT", "roundIncrece", "RoundSegension", "rollDecremented", "rollfloat", "roundSegension", "roundIncrema", "roundincrementation", "roundBeginment", "quickIncrestant", "roundBeginmentation", "turnIncrema", "roundMeasurembol", "roll_", "roundAdjustmented", "roundincrements", "roundAdjustment", "rollDecrembol", "roundSegavior", "rollIncrements", "roundReli", "roundMeasuremented", "rollDecreMENT", "roundincrelement", "turnfloat", "roundImprovestant", "roundIncrementation", "roundAdjustement", "roundMeasurements", "RoundAdjustement", "roundSegmbol", "addincremented", "roundSegstant", "roundMeasureension", "roundAdjustument", "addIncrelement", "roundImprovembol", "roundBeginstant", "rollIncreMENT", "roundAdjustments", "roundSegmentation", "roundIncrestant", "sort_", "roundBeginmbol", "roundDecreli", "roundDecrembol", "roundMerma", "roundSetlement", "RoundAdjustments", "RoundIncreement", "quickIncrementation", "roundDecreument", "turnIncrementation", "roundInterment", "rollIncrementation", "roundfloat", "rollDecreument", "roundincrece", "roundDecremented", "RoundSegment", "turnIncreavior", "roundMeasurece", "turnMerment", "addIncrement", "RoundIncreension", "roundIncreension", "roundMerment", "rollDecrementation", "turnIncrement", "roundSegement", "roundIncrements", "roundDecreement", "quickIncrement", "addincrelement", "roundincreension", "quickSegment", "roundSegments", "roundIncreavior", "quickSegmbol", "addincrece", "turnMermentation", "roundSegma", "roundIncremented", "RoundSegement", "rollIncrement", "roundSegMENT", "roundIncrembol", "roundRement", "RoundIncrement", "roundSetce", "roundincrement", "roundSetmented", "rollIncrembol", "roundMeasureement", "roundMeravior", "roundincrembol", "roundDecrements", "roundIncreument", "RoundIncrements", "rollDecrements", "quickSegmentation", "RoundIncremented", "round_", "turnMerma", "roundincreement", "rollDecrement", "rollIncremented", "roundRemented", "rollIncreument", "turnMeravior", "rollIncreli", "turn_", "addIncrece", "RoundAdjustment", "roundIncreli", "quickIncrembol", "roundRements", "roundSegment", "roundDecrement", "addincrement", "addIncremented", "roundMermentation", "roundSetment", "roundInterument", "roundMeasurelement", "sortfloat", "roundIncrelement", "roundMeasurement", "roundincremented", "roundDecrementation", "roundincreli", "RoundSegments"], "roundBits": ["roundAliits", "sortBounds", " roundBbits", " roundMitions", "roundSooks", "roundbins", "roundTbits", "buildBits", " roundMits", "callTooks", "roundBITS", "roundBsitions", "buildbit", "roundBins", "roundTits", "roundBuffITS", "roundBuffins", "rollSacks", "roundBsbits", "roundBacks", "roundSounds", "roundEigs", "roundBots", "roundMits", "roundBbits", "sortBots", "roundSits", " roundBigs", "roundTots", "rollBITS", "roundEitions", "roundBitions", " roundBitions", "roundPugs", "sortBits", "roundBalooks", "callBits", "roundBit", "roundbit", "callBbits", "roundSbits", "buildBugs", "roundPits", "rollBits", "roundOits", "callBats", "rollSits", "roundbugs", "buildBins", "roundSots", "roundMigs", "roundBsigs", "roundOITS", "roundBalits", "roundSacks", "roundBigs", "roundAliugs", "callBooks", "rollSins", "roundBuffits", "roundPins", "roundOins", "roundBats", " roundMigs", "rollSITS", "roundPit", "roundEits", " roundMbits", "roundBuffacks", "roundMitions", "roundEbits", "roundBounds", "rollBacks", "callTats", "roundAliit", "roundTounds", "roundTats", "buildbits", "roundSins", "roundTooks", "rollBins", "roundBugs", "callTits", "roundAliins", "sortBbits", "buildbins", "roundBalats", "roundMbits", "roundBsits", "buildBit", "buildbugs", "roundSITS", "roundbits", "roundOacks", "roundSats", "roundBooks", "roundBalbits", "callTbits"], "isTiny": ["istiny", "istiet", "isDestiet", " isNotale", " istiny", "isThoo", "isNotail", "isSandy", "isTrip", "isNtiny", "isSandiet", " isTrip", " istyp", "isUntale", "isPortiny", "isNotiny", "isTyp", " isTyp", " isToo", "isTail", "isToo", "isUnttiny", "isPortale", "isSandyp", "isSandiny", "isTale", "isUntiny", " isTail", " isNotiny", "isThiny", "isNale", "istyp", " isNottiny", " isTiet", "isTiet", "isNottiny", " isTy", "isDestiny", " isTale", " isNotrip", "isDesty", "isPortrip", "isPortoo", "isNiny", "isTtiny", "isNotoo", "isNotale", " isNotail", "isty", " isTtiny", " isty", " istiet", "isTy", " isNotoo", "isNotrip", "isDestyp", "isUntail", "isThrip", "isNail", "isThale"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "substitutes": {"entry": ["component", "archive", "document", "or", "def", "attribute", "event", "e", "check", "query", "insert", "out", "key", "link", "pair", "word", "command", "answer", "add", "xml", "rance", "complete", "existent", "delete", "application", "inner", "index", "client", "row", "comment", "option", "ce", "element", "empty", "office", "ie", "ry", "cell", "header", "result", "enter", "error", "engine", "match", "record", "instance", "ment", "member", "cue", "escape", "up", "no", "ent", "view", "image", "try", "connection", "search", "ck", "server", "line", "ary", "form", "section", "request", "RY", "import", "writer", "owner", "se", "see", "primary", "common", "ace", "Entry", "response"], "size": ["type", "length", "sum", "zone", "offset", "cache", "location", "g", "south", "fee", "win", "settings", "parent", "password", "memory", "position", "shape", "range", "SIZE", "scale", "len", "padding", "ize", "bytes", "body", "ns", "pi", "max", "address", "e", "table", "height", "message", "small", "network", "now", "index", "id", "owner", "mode", "area", "code", "si", "space", "total", "Size", "state", "s", "empty", "full", "data", "count", "capacity", "storage", "mem", "number", "izes", "limit", "scope", "dimension", "share", "details", "name"], "address_index": ["address_slice", "address__key", " address_ind", "address__slice", " address_Index", "addressipIndex", "addressptIndex", " address_value", "addressablevalue", "addressptaddress", "Address_Index", "address_Index", " address_base", "Address_key", "address_value", "addressableIndex", "addressptbase", "addressipbase", "addressipind", "addressableindex", "address__Index", "address_address", " address_address", "addressableaddress", "addressipindex", "address_key", "Address_slice", "address_ind", "addressptindex", "address__index", "Address_index", "address_base"], "vaddr_base": ["vobj_base", "vaddr__base", "vaddr_bas", "vaddress_bas", "vaddr_map", "vname7no", "vaddress__map", "vaddr_index", "vobj_bas", "vaddr2base", "vaddress_init", "vaddress_buffer", "vname_base", "vaddr__cache", "vaddr2buffer", "vname_no", "vaddr_cache", "vptr_buffer", "vaddrablebind", "vaddr__server", "vptr_id", "vptr_base", "vaddr_bin", "vaddrambas", "vaddress_Base", "vaddrxcache", "vaddress2Base", "vaddr8bin", "vaddress2init", "vaddress2base", "vaddr__map", "vaddr___server", "vaddramBase", "vaddr_buffer", "vaddr7no", "vaddrxmap", "vaddr__buffer", "vaddr_no", "vaddr___base", "vname7index", "vaddr__bas", "vname7base", "vaddr_b", "vobj_id", "vptr_bind", "vname_index", "vname7bin", "vaddress_base", "vaddr7index", "vaddr8no", "vaddress_server", "vaddrxbase", "vptr_balance", "vaddr_init", "vname_bin", "vaddr___map", "vaddress_cache", "vaddr8index", "vptr_b", "vobj_buffer", "vaddress_index", "vaddrxserver", "vaddrambase", "vaddr2id", "vaddr_server", "vaddr___cache", "vaddress__base", "vaddr_id", "vaddr8base", "vaddr7bin", "vaddr_bind", "vaddr2init", "vaddrablebase", "vaddr2bas", "vaddr__index", "vaddr2Base", "vaddress2bas", "vaddr_balance", "vaddr7base", "vaddraminit", "vaddr_Base", "vaddress_map", "vaddress__cache", "vaddrablebalance", "vaddress__server"], "pfns": ["pcfons", "pfcns", "pfiNs", " pcfains", "fpfrens", "pfsds", "pfbfs", "pfds", "pfmns", "mfns", "pvns", "pffs", " pcfns", "pfbns", " pfcds", " pfxs", "pfNs", "fpfNs", "pfxs", "pfens", "pfmuns", "pfrNs", "pfins", " pfcons", "pfxfs", "pfiens", "pfecs", "pfefs", "psfns", " pcfgs", "pfons", "mfmics", "pfbxs", "fpfns", " pfbnis", "pfpds", "pfsons", "pfrns", "mfuns", "psffs", " pfcs", " pfons", "pcfxs", "pfcs", "pbfains", " pfains", " pfbcs", "pfbgs", "pfmics", "pfxens", "pfrens", "pfcnames", "pvuns", "mfics", "pbfgs", " pfnis", "pfnis", "pfmds", "pfxNs", "fpffs", "pcfains", "mfmds", " pfnames", "pcfds", "pfsns", "pfpns", "pfuns", "pfcds", "pfgs", "pfics", "pbfns", "pfnames", "pfains", "mfmuns", "pvics", "mfds", " pfgs", "psfcs", "fpfrNs", "fpfrfs", "pfpuns", "fpfens", "fpfrns", " pfbns", " pfds", "pvds", "pfbcs", "pbfxs", "psfnis", "pfenis", " pfcns", "pcfns", "pfxns", " pffs", "pfrfs", "pfbains", "pfifs", "pfpics", "pcfnames", "pfsnames", "pfcons", "mfmns", " pfbfs", "pcfgs", "pfbnis", " pcfxs", " pfcnames"], "err": ["kr", "extra", "Error", "attr", "cr", "br", "rs", "er", "mr", "ctr", "ind", "result", "eps", "test", "oe", "iter", "fee", "args", "rez", "ef", "cli", "rc", "inner", "Er", "or", "fr", "eor", "orders", "error", "len", "res", "rb", "der", "ns", "cb", "rr", "rel", "r", "e", "errors", "buf", "arr", "resp", "rev", "rss", "conf", "gr", "index", "env", "txt", "gz", "eas", "ev", " Err", "ei", "sol", "notice", "ner", "count", "it", "erd", "rm", "gs", "dr", "try", "usr", "ptr", "exc", "rn"], "i": ["us", "er", "init", "c", "ip", "y", "ami", " ii", "ims", "qi", "v", "I", "o", "ii", "key", "print", "phi", " ti", "span", " j", "hi", "f", " di", "ui", "\u0438", "pi", "u", "im", "index", "mi", "multi", "p", " I", "gi", "ind", "chain", "ri", "xi", "point", "ki", "cli", "ai", "parent", "port", "q", "li", "iu", " bi", "ci", "l", "sim", "m", "me", "k", "ti", "instance", "x", " si", "dr", "ij", "si", "bi", "ini", "ic", "in", "zi", "this", "ji", "id", "b", "n", "ei", "fi", "ix", "di", " ni", "it", "t", "j", "oi"]}}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n", "idx": 18513, "substitutes": {"dev": ["pad", " Dev", "Dev", "window", "th", "conn", "hw", "cam", "wd", "develop", "ad", "def", "os", "serv", "device", "doc", "iv", "debug", "go", "api", "sd", "ver", "by", "cast", "d", "sys", "den", "van", "gu", "env", "v", "var", "ev", "priv", "dd", "ve", "development", "devices", "md", "db", "cmd", "DEV", "Device", "nv", "mem", "usb", "w", "adv", "pro", "nt", "av", "t", "tech"], "p": ["cache", "P", "a", "c", "h", "i", "ip", "bp", "y", "pp", "np", "pb", "patch", "e", "pm", "pc", "wp", "pid", "ap", "v", "out", "dp", "tp", "f", "pre", "pr", "cp", "pi", "u", "php", "progress", "s", "pg", "w", "pe", "rep", "vp", "g", "pkg", "point", "post", "port", "q", "pl", "pers", "l", "pt", "m", "sp", "pro", "at", "comm", "pat", "parse", "fp", "jp", "part", "press", "lp", "r", "d", "ping", "local", "b", "pa", "n", "app", "it", "op", "ps", "t", "j"], "ep": ["ele", "er", "eps", "yp", "oe", "peak", "point", "gp", "ef", "EP", "mp", "except", "Ep", "eh", "cp", "ebin", "ip", "bp", "xp", "pp", "pb", "ee", "em", "tip", "e", "resp", "esc", "est", "wp", "pt", "ap", "el", "eur", "elf", " pe", "eb", "eq", "env", "eu", "eg", "ev", "esp", "vp", "eve", "dep", "ew", "eff", "ei", "et", "ek", "ape", "peg", "ec", "ent", " e", "pe", "lip", "rep", "eng", "ps", "exc", "ea", "dp", "tp"], "ret": ["rt", "prop", "reg", "gt", "ref", "result", " RET", "cat", "lt", "not", "lit", "rem", "des", "def", "cont", " alt", "bool", "tr", "res", "ben", "elt", " fut", "re", "att", "flag", "got", "resp", "det", "RET", "Ret", "ter", "rev", "tf", "vet", "txt", "v", "back", "out", "ft", "git", "reset", "val", "rets", "print", "alt", "deg", "vt", "nt", "aux", "pret", "mt", "reply", "sat", "t", "repl"]}}
{"project": "FFmpeg", "commit_id": "64e105e051ca3e5088b0db64551244482b2836b4", "target": 0, "func": "static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)\n\n{\n\n    DynBuffer *d = opaque;\n\n    int new_size, new_allocated_size;\n\n    UINT8 *new_buffer;\n\n    \n\n    /* reallocate buffer if needed */\n\n    new_size = d->pos + buf_size;\n\n    new_allocated_size = d->allocated_size;\n\n    while (new_size > new_allocated_size) {\n\n        if (!new_allocated_size)\n\n            new_allocated_size = new_size;\n\n        else\n\n            new_allocated_size = (new_allocated_size * 3) / 2;\n\n    }\n\n    \n\n    if (new_allocated_size > d->allocated_size) {\n\n        new_buffer = av_malloc(new_allocated_size);\n\n        if (!new_buffer)\n\n            return;\n\n        memcpy(new_buffer, d->buffer, d->size);\n\n        av_free(d->buffer);\n\n        d->buffer = new_buffer;\n\n        d->allocated_size = new_allocated_size;\n\n    }\n\n    memcpy(d->buffer + d->pos, buf, buf_size);\n\n    d->pos = new_size;\n\n    if (d->pos > d->size)\n\n        d->size = d->pos;\n\n}\n", "idx": 18518, "substitutes": {"opaque": ["obus", "opent", "oposter", "iopacity", "poster", "paque", "oplent", "Opacity", "opatile", "oplus", "opacity", "oplaque", "obaque", "obent", "patile", "Opatile", "pacity", "Opaques", "iopatile", "Opaque", "ioposter", "Opus", "Oposter", "Opent", "oplaques", "opus", "obaques", "iopaque", "opaques"], "buf": ["proc", "cv", "bb", "block", " buffer", "br", "vec", "wb", "fb", "bar", "Buff", "func", "buffer", "cap", "Buffer", "prev", "rb", "bytes", "doc", "img", "cb", "pb", "enc", "arr", "BU", "b", "v", "uf", "bg", "bc", "cmd", "data", "mem", "msg", "raw", "buff", "bf", "queue", "batch"], "buf_size": ["bufLengthindex", "vec_num", "buf64weight", "bufptweight", " buf_length", " buf_index", "buf64size", "vecptsize", "buf64num", "bufLengthSIZE", "buf_SIZE", " buf_SIZE", "buf_num", "vecptspace", "vec_size", "bufptsize", "buf_space", "buf64space", "vec_weight", "vecptnum", "buf_weight", "vec_space", "buf_length", "vecptweight", "bufptnum", "bufLengthsize", "buf_index", "bufptspace"], "d": ["new", "fd", "done", "did", "g", "gd", "dx", "add", "ind", "bd", "du", "dn", "c", "nd", "wd", "td", "dl", "ed", "dot", "draw", "ud", "ad", "ade", "dq", "q", "dt", "diff", "del", "y", "D", "dos", "rest", "more", "al", "debug", "sd", "dat", "dm", "da", "dh", "l", "m", "and", "ord", "n", "dd", "md", "db", "dump", "de", "ds", "di", "dr", "z", "at", "dict", "die", "dev", "od", "rd", "mod", "dp", "ld", "dc", "pd", "j", "p"], "new_size": ["new_speed", "newrowsize", "job_export", "old_size", "job67code", "new_offset", "newvalstatus", "new_send", " new_offset", "job67export", "new7export", "new_len", "new7code", " new_speed", "new_Size", "new67size", "old_status", "recent_size", "new00export", "new_sym", "recent_name", "new64sym", "newvalname", "new_item", "new67code", "new_start", "normal_len", "new64status", "new_status", "newrowscore", "new64size", "new_code", "old_name", "job_start", "new7size", "recent_item", "new64Size", "new64speed", "new67offset", "new_score", "new00size", "newrowsend", "new67start", "new00code", "normal_size", "new67export", "new___len", "job_code", "new___send", "newrowlen", "job67start", "newvalsize", "new___size", "new___score", "new64name", "job_size", " new_Size", "new_export", "normal_send", "new64offset", "new67speed", "job67size", "new_name", "normal_score", "new00start", "newvalsym", "old_sym", "new7start", "new67Size"], "new_allocated_size": ["new_allocation_size", "new_allocation_name", "new_allocatederstring", "new_allocatedamoffset", "new_allisedamsize", "new_allocation_sum", "new_allocated_string", "new_allisedamspace", "new_allocatedlysequence", "new_allocated_sequence", "new_allocation_space", "new_allowed_too", "new_allocating_client", "new_allocatedssize", "new_allocated_storage", "new_allocatedsSIZE", "new_allocated_too", "new_allowed_SIZE", "new_allocatededSIZE", "new_allocatedersize", "new_allocated_scope", "new_allocatingersize", "new_allocated_scale", "new_allocatededstorage", "new_allocated\u05bcsum", "new_allocatedermessage", "new_allocated_name", "new_allocated_score", "new_allocated\u05bcsize", "new_allocatedamspace", "new_allocatingerstring", "new_allised_offset", "new_allocated_space", "new_allocation_SIZE", "new_allocatededname", "new_allocating_string", "new_allocatedlysize", "new_allocatedityoffset", "new_allisedamoffset", "new_allocated_count", "new_allocatededsize", "new_allocated_sum", "new_allocated_SIZE", "new_allocated\u05bcscore", "new_allocated_client", "new_allowed_size", "new_allocatedstoo", "new_allocated_Size", "new_allocation_Size", "new_allocation_count", "new_allocating_message", "new_allocatingermessage", "new_allocated_offset", "new_allocatededscope", "new_allocatedityspace", "new_allocation_scope", "new_allocating_size", "new_allocating_sequence", "new_allised_space", "new_allocateditysize", "new_allised_size", "new_allocatedamsize", "new_allocation_scale", "new_allocatedlyclient", "new_allocated_message", "new_allocation_storage"], "new_buffer": ["free_channel", "new_channel", "newptbuffer", "newJbuffer", "news_size", "current___buff", "new__iter", "new___term", "current_buff", "new___buffer", "current_iter", "newptbuff", "current___iter", "newJblank", " new_memory", "new___window", "new__buffer", "newsJbuffer", "newjbuffer", "current_term", "new1buff", "newptterm", "new_variable", "new_memory", "new___button", "new___binary", "newjsize", "newjblank", "newptiter", "new__buff", "free_buffer", "new_term", " new_iter", "newsJsize", "new_button", "current___buffer", "new1iter", "free_variable", "new___buff", "new1memory", "new_blank", "newJsize", "newsJblank", "current_buffer", "news_blank", "new_buff", " new_binary", "current___term", "news_buffer", " new_button", "new1buffer", "new_window", "free_window", "new__memory", "new___iter", "new_iter", "new_binary", " new_window", " new_buff"]}}
{"project": "FFmpeg", "commit_id": "20da77449d4427a7152b80e4f9acce6a8c93ee7d", "target": 0, "func": "static inline int RENAME(yuv420_rgb24)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*3 > dstStride[0]) h_size-=8;\n\n    \n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\nYUV2RGB\n\n\t/* mm0=B, %%mm2=G, %%mm1=R */\n\n#ifdef HAVE_MMX2\n\n\t\t\t\"movq \"MANGLE(M24A)\", %%mm4\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(M24C)\", %%mm7\t\\n\\t\"\n\n\t\t\t\"pshufw $0x50, %%mm0, %%mm5\t\\n\\t\" /* B3 B2 B3 B2  B1 B0 B1 B0 */\n\n\t\t\t\"pshufw $0x50, %%mm2, %%mm3\t\\n\\t\" /* G3 G2 G3 G2  G1 G0 G1 G0 */\n\n\t\t\t\"pshufw $0x00, %%mm1, %%mm6\t\\n\\t\" /* R1 R0 R1 R0  R1 R0 R1 R0 */\n\n\n\n\t\t\t\"pand %%mm4, %%mm5\t\t\\n\\t\" /*    B2        B1       B0 */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G2        G1       G0 */\n\n\t\t\t\"pand %%mm7, %%mm6\t\t\\n\\t\" /*       R1        R0       */\n\n\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* G2        G1       G0    */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"psrlq $8, %%mm2\t\t\\n\\t\" /* 00 G7 G6 G5  G4 G3 G2 G1 */\n\n\t\t\t\"pshufw $0xA5, %%mm0, %%mm5\t\\n\\t\" /* B5 B4 B5 B4  B3 B2 B3 B2 */\n\n\t\t\t\"pshufw $0x55, %%mm2, %%mm3\t\\n\\t\" /* G4 G3 G4 G3  G4 G3 G4 G3 */\n\n\t\t\t\"pshufw $0xA5, %%mm1, %%mm6\t\\n\\t\" /* R5 R4 R5 R4  R3 R2 R3 R2 */\n\n\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm5\t\\n\\t\" /* B5       B4        B3    */\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" /*       G4        G3       */\n\n\t\t\t\"pand %%mm4, %%mm6\t\t\\n\\t\" /*    R4        R3       R2 */\n\n\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" /* B5    G4 B4     G3 B3    */\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"pshufw $0xFF, %%mm0, %%mm5\t\\n\\t\" /* B7 B6 B7 B6  B7 B6 B6 B7 */\n\n\t\t\t\"pshufw $0xFA, %%mm2, %%mm3\t\\n\\t\" /* 00 G7 00 G7  G6 G5 G6 G5 */\n\n\t\t\t\"pshufw $0xFA, %%mm1, %%mm6\t\\n\\t\" /* R7 R6 R7 R6  R5 R4 R5 R4 */\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"pand %%mm7, %%mm5\t\t\\n\\t\" /*       B7        B6       */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G7        G6       G5 */\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm6\t\\n\\t\" /* R7       R6        R5    */\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\\\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 16(%1)\t\t\\n\\t\"\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\n\n#else\n\n\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm0, %%mm5\t\t\\n\\t\" /* B */\n\n\t\t\t\"movq %%mm1, %%mm6\t\t\\n\\t\" /* R */\n\n\t\t\t\"punpcklbw %%mm2, %%mm0\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"punpcklbw %%mm4, %%mm1\t\t\\n\\t\" /* 0R0R0R0R 0 */\n\n\t\t\t\"punpckhbw %%mm2, %%mm5\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpckhbw %%mm4, %%mm6\t\t\\n\\t\" /* 0R0R0R0R 2 */\n\n\t\t\t\"movq %%mm0, %%mm7\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"movq %%mm5, %%mm3\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpcklwd %%mm1, %%mm7\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"punpckhwd %%mm1, %%mm0\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"punpcklwd %%mm6, %%mm5\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"punpckhwd %%mm6, %%mm3\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"movq %%mm7, %%mm2\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"psllq $40, %%mm7\t\t\\n\\t\" /* RGB00000 0 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* RGB00000 1 */\n\n\t\t\t\"psllq $40, %%mm5\t\t\\n\\t\" /* RGB00000 2 */\n\n\t\t\t\"psllq $40, %%mm3\t\t\\n\\t\" /* RGB00000 3 */\n\n\n\n\t\t\t\"punpckhdq %%mm2, %%mm7\t\t\\n\\t\" /* 0RGBRGB0 0 */\n\n\t\t\t\"punpckhdq %%mm6, %%mm0\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"punpckhdq %%mm1, %%mm5\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"punpckhdq %%mm4, %%mm3\t\t\\n\\t\" /* 0RGBRGB0 3 */\n\n\n\n\t\t\t\"psrlq $8, %%mm7\t\t\\n\\t\" /* 00RGBRGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* GB000000 1 */\n\n\t\t\t\"por %%mm0, %%mm7\t\t\\n\\t\" /* GBRGBRGB 0 */\n\n\t\t\tMOVNTQ\" %%mm7, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\n\n\t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */\n\n\t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */\n\n\t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n#endif\n\n\t\t     \n\n\t\t     \"add $24, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\t\t     \n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n    return srcSliceH;\n\n}\n", "idx": 18523, "substitutes": {"c": ["f", "cf", "lc", "cv", "cr", "g", "C", "h", "ca", "cm", "fc", "rc", "cont", "cp", "etc", "cb", "tc", "enc", "e", "cu", "ci", "ac", "l", "m", "d", "con", "cc", "b", "ctx", "v", "n", "ct", "bc", "s", "ce", "coll", "ec", "cs", "ch", "t", "co", "conf", "dc", "cd", "p"], "src": ["proc", "rt", "sl", "ser", "bh", "attr", "rs", "st", "ins", "sn", "ctr", "sw", "pkg", "sq", "iter", "std", "fc", "rc", "stream", "usc", "rl", "func", "sur", "sc", "conv", "rb", "in", "img", "sub", "iv", "loc", "inst", "sr", "stab", "sort", "sys", "dest", "hl", "sb", "s", "grad", "req", "cur", "lib", "supp", "source", "usr", "input", "ptr", "via", "bs", "sh"], "srcStride": ["srcConstride", "srcstride", "srcRestride", "srcSlrip", "rcStrride", "srcSTse", "srcstr", "srcConstide", "rcStse", "rcStrope", "rcStrr", "srcStrate", "rcStrides", "rcStides", "rcStope", "srcSlide", "srcStrri", "rcStri", "srcStide", "srcSTride", "srcSlr", "srcStrrip", "srcRestrate", "rcStr", "srcSlro", "srcStrse", "srcStr", "rcStride", "srcStides", "srcRestide", "srcSTr", "srcStro", "srcStrides", "srcConstope", "srcStrride", "srcStri", "rcStrri", "srcSTrip", "srcstide", "srcRestro", "srcSTide", "srcStrro", "rcStrro", "srcStrrate", "rcStide", "srcStrope", "rcStrrate", "rcStrip", "srcStse", "srcstides", "srcConstrate", "rcStro", "rcStrrip", "srcStrr", "rcStrse", "srcSTides", "srcStope", "srcSlri", "rcStrate", "srcStrip", "srcSlse", "srcSlride", "srcRestope"], "srcSliceY": ["srcSlideH", "srcSLiceH", "srcSlideY", "srcSlICET", "srcSlsliceY", "srcSlICEy", "srcSLICEH", "srcSliceX", "srcSlsliceT", "srcSLICEY", "srcSlideT", "srcSLicey", "srcSLICEy", "srcSlideX", "srcSLICEX", "srcSlsliceX", "srcSLideY", "srcSLiceT", "srcSLiceX", "srcSlidey", "srcSlICEY", "srcSlICEH", "srcSlicey", "srcSLideX", "srcSliceT", "srcSLideT", "srcSLideH", "srcSlsliceH", "srcSlICEX", "srcSLiceY"], "srcSliceH": ["srcSlideH", "srcSluceW", "srcsliceY", "srcSlicedSH", "srcSliceSH", "srcSlICEHT", "srcSlicedHT", "srcSliceW", "srcSlideY", "srcSliceHH", "srcSluceHH", "srcslICEY", "srcSlideHT", "srcslICEH", "srcslICESH", "srcSlieW", "srcSlideSH", "srcSlICESH", "srcSluceY", "srcSlICEY", "srcSlicedH", "srcslICEHT", "srcSlICEH", "srcSliceHT", "srcsliceHT", "srcsliceSH", "srcSlieHH", "srcSluceH", "srcSlieH", "srcSlicedY", "srcsliceH", "srcSlieY", "srcSlideHH", "srcSlideW"], "dst": ["Dest", "rdest", "dast", "bdnd", "dadest", "dsp", "Ddest", "bdst", "rst", "dasts", "bdest", "dasp", "bdsts", "Dnd", " dnd", "rsp", "dest", " dest", "ddest", "rsts", "Dsts", "Dst", "dsts", "Dsp", " dsts", "dnd"], "dstStride": ["dstrStr", "dsrcStrr", "dsrcStrause", "dstrRestride", "dstSlrip", "dstRestro", "dstStope", "dstrRestrip", "dsrcStrride", "dstStrr", "dstrStrip", "dstStack", "dstRestide", "dstSlope", "dstRestr", "dsrcStide", "dstDro", "dstrRestack", "dstEstride", "dstStr", "dstRestride", "dstDride", "dstStide", "dstEstr", "dsrcStrro", "dstStrause", "dstStrrip", "dstStrack", "dstStrride", "dstStrope", "dstSlr", "dstSlide", "dstrStride", "dstEstope", "dstRestrip", "dsrcStr", "dstEstide", "dstrStack", "dstStro", "dstSlride", "dstrRestr", "dstRestack", "dstStrip", "dsrcStro", "dsrcStause", "dsrcStope", "dstStrro", "dsrcStride", "dstSlack", "dstDide", "dstRestause", "dstDause", "dsrcStrope", "dstStause"], "y": ["ny", " i", "aily", "ery", " ye", "sy", "scroll", " busy", "dy", " ty", "yer", "wy", "h", "xy", "i", "ym", "iy", "ay", "size", "ye", "ot", "oy", "ies", "vy", "ya", " ly", " ay", "by", "ady", "my", "height", "kit", "ey", "m", "yy", "hey", "b", "say", "yr", "iley", "n", "j", "ley", "key", "ky", "axy", "x", "yt", "icy", "cy", "ly", "py", " j", "uy", "gy", "sky", "ys", "Y", "t", "ch", "try", " ya", "yd", "yi", " py", "z", "yl"], "h_size": ["h2SIZE", "h_len", "h2ize", "d_storage", "hr_size", "h2capacity", "h___sized", "bh_Size", "h_group", "h_storage", " h_len", " h2len", " h2size", "H_size", " h_score", "bh_ize", "h2score", " h_Size", "bh_sized", "h_ize", " h2score", "h_sized", "h_capacity", "bh_size", "bh___size", "h_SIZE", "huffyscore", "h___size", "huffysize", "d_group", "H_SIZE", "h___Size", "huffylen", "huffySize", "h2len", "hr_scroll", "hr_Size", "h_score", "d_size", "h2size", "bh___ize", "d_ize", " h2Size", "h___ize", "bh___Size", "hr_capacity", "h_scroll", "h2Size", "h_Size", "H_ize", "h2sized", "h2scroll", "bh___sized", "H_Size"], "_image": ["_code", " _code", "_png", " _png", "_img", " _img"], "_py": ["_xy", "_ps", "txy", "tps", " _xy", "tpy", " _p", "_p", "tp", " _ps"], "_pu": [" _pse", "tmp", "_pse", "tpse", "tpu", " _p", " _mp", "_p", "tp", "_mp"], "_pv": ["_cpv", "_Pv", "____cpv", "_px", "_cpx", "_cpvp", "____ppt", "____cpx", "_cppt", "_Pvp", "_spvp", "_Px", "_Ppt", "____cpvp", "_pvp", "____pvp", "_ppt", "_sppt", "_spv", "_spx", "____px", "____cppt", "____pv"]}}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int hex_to_data(uint8_t *data, const char *p)\n\n{\n\n    int c, len, v;\n\n\n\n    len = 0;\n\n    v = 1;\n\n    for(;;) {\n\n        skip_spaces(&p);\n\n        if (*p == '\\0')\n\n            break;\n\n        c = toupper((unsigned char)*p++);\n\n        if (c >= '0' && c <= '9')\n\n            c = c - '0';\n\n        else if (c >= 'A' && c <= 'F')\n\n            c = c - 'A' + 10;\n\n        else\n\n            break;\n\n        v = (v << 4) | c;\n\n        if (v & 0x100) {\n\n            if (data)\n\n                data[len] = v;\n\n            len++;\n\n            v = 1;\n\n        }\n\n    }\n\n    return len;\n\n}\n", "idx": 18529, "substitutes": {"data": ["to", "text", "window", "done", "length", "pad", "block", "extra", "br", "cache", "map", "h", "valid", "parent", "size", "ad", "buffer", "def", "bool", "ata", "bytes", "np", "dat", "rel", "e", "table", "buf", "this", "message", "list", "d", "options", "rec", "rew", "DATA", "b", "o", "Data", "str", "empty", "db", "full", "next", "format", "w", "bin", "image", "raw", "t", "partial", "batch"], "p": ["f", "pat", "g", "P", "fp", "jp", "part", "h", "point", "i", "pointer", "q", "cp", "padding", "bp", "ip", "pos", "pp", "np", "pb", "r", "pers", "lp", "pc", "l", "pid", "m", "d", "ap", "wp", "ping", "sp", "pt", "b", "k", "n", "pa", "vp", "par", "pard", "w", "pe", "at", "ps", "t", "tp"], "c": ["f", " cur", "cf", "lc", "cv", "cmp", "ach", "g", "cache", "C", "cat", "h", "ca", "err", "cm", "fc", "rc", "mc", "ic", "cont", " mc", " cr", "sc", "cp", "comp", "conv", "gc", "cb", "unc", " ch", "tc", "enc", "cu", "r", "ci", "ac", "pc", "l", "nc", "con", "cc", "cl", "b", "ct", " tc", "bc", "s", "uc", "ce", "vc", "col", "cur", "ec", "cod", "cy", "mac", "cs", "ch", "t", "co", " cc", "dc", "z", "cd"], "len": ["f", "ls", "sl", "fl", "length", "lan", "cmp", " n", "offset", "end", "en", "Len", "ind", "fp", "vec", "h", "lt", "iter", "kl", "dl", "lf", "i", "size", "nl", "ret", "li", "fr", "pos", "lin", "elt", "loc", "ll", " el", "gl", "lv", "ell", "ul", "lp", "rel", "vol", "e", "l", "m", "den", "el", "d", "vel", "n", "mid", "hl", "val", " length", "lim", " l", "x", "alt", "ln", "bl", "mi", "nt", "limit", "gen", " j", "ptr", "il", "L", "fn", "ld"], "v": ["f", "cv", "length", "sv", "g", "vv", "vd", "i", "size", "q", "conv", "version", "vs", "V", "iv", "ver", "u", "lv", "vol", "l", "m", "qv", "value", "vi", "d", "b", "var", "n", "ev", "vp", "ve", "wire", "va", "val", "x", "vc", "uv", "nv", "tv", "w", "vt", "vo", "mint", "av", "limit", "ch", "t", "j"]}}
{"project": "FFmpeg", "commit_id": "fa30a0a54854cd291008c065dfaf45d610e3cd04", "target": 0, "func": "static int RENAME(dct_quantize)(MpegEncContext *s,\n\n                            int16_t *block, int n,\n\n                            int qscale, int *overflow)\n\n{\n\n    x86_reg last_non_zero_p1;\n\n    int level=0, q; //=0 is because gcc says uninitialized ...\n\n    const uint16_t *qmat, *bias;\n\n    LOCAL_ALIGNED_16(int16_t, temp_block, [64]);\n\n\n\n    av_assert2((7&(int)(&temp_block[0])) == 0); //did gcc align it correctly?\n\n\n\n    //s->fdct (block);\n\n    RENAME_FDCT(ff_fdct)(block); // cannot be anything else ...\n\n\n\n    if(s->dct_error_sum)\n\n        s->denoise_dct(s, block);\n\n\n\n    if (s->mb_intra) {\n\n        int dummy;\n\n        if (n < 4){\n\n            q = s->y_dc_scale;\n\n            bias = s->q_intra_matrix16[qscale][1];\n\n            qmat = s->q_intra_matrix16[qscale][0];\n\n        }else{\n\n            q = s->c_dc_scale;\n\n            bias = s->q_chroma_intra_matrix16[qscale][1];\n\n            qmat = s->q_chroma_intra_matrix16[qscale][0];\n\n        }\n\n        /* note: block[0] is assumed to be positive */\n\n        if (!s->h263_aic) {\n\n        __asm__ volatile (\n\n                \"mul %%ecx                \\n\\t\"\n\n                : \"=d\" (level), \"=a\"(dummy)\n\n                : \"a\" ((block[0]>>2) + q), \"c\" (ff_inverse[q<<1])\n\n        );\n\n        } else\n\n            /* For AIC we skip quant/dequant of INTRADC */\n\n            level = (block[0] + 4)>>3;\n\n\n\n        block[0]=0; //avoid fake overflow\n\n//        temp_block[0] = (block[0] + (q >> 1)) / q;\n\n        last_non_zero_p1 = 1;\n\n    } else {\n\n        last_non_zero_p1 = 0;\n\n        bias = s->q_inter_matrix16[qscale][1];\n\n        qmat = s->q_inter_matrix16[qscale][0];\n\n    }\n\n\n\n    if((s->out_format == FMT_H263 || s->out_format == FMT_H261) && s->mpeg_quant==0){\n\n\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            MOVQ\" (%2), \"MM\"5                   \\n\\t\" // qmat[0]\n\n            \"pxor \"MM\"6, \"MM\"6                  \\n\\t\"\n\n            \"psubw (%3), \"MM\"6                  \\n\\t\" // -bias[0]\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            \"psubusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat), \"r\" (bias),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }else{ // FMT_H263\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            MOVQ\" (%3, %%\"FF_REG_a\"), \"MM\"6     \\n\\t\" // bias[0]\n\n            \"paddusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            MOVQ\" (%2, %%\"FF_REG_a\"), \"MM\"5     \\n\\t\" // qmat[i]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] + bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat+64), \"r\" (bias+64),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }\n\n    __asm__ volatile(\n\n        \"movd %1, \"MM\"1                     \\n\\t\" // max_qcoeff\n\n        SPREADW(MM\"1\")\n\n        \"psubusw \"MM\"1, \"MM\"4               \\n\\t\"\n\n        \"packuswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#if COMPILE_TEMPLATE_SSE2\n\n        \"packsswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#endif\n\n        \"movd \"MM\"4, %0                     \\n\\t\" // *overflow\n\n        : \"=g\" (*overflow)\n\n        : \"g\" (s->max_qcoeff)\n\n    );\n\n\n\n    if(s->mb_intra) block[0]= level;\n\n    else            block[0]= temp_block[0];\n\n\n\n    if (s->idsp.perm_type == FF_IDCT_PERM_SIMPLE) {\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x08] = temp_block[0x01]; block[0x10] = temp_block[0x08];\n\n        block[0x20] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x18] = temp_block[0x09]; block[0x04] = temp_block[0x02];\n\n        block[0x09] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x14] = temp_block[0x0A]; block[0x28] = temp_block[0x11];\n\n        block[0x12] = temp_block[0x18]; block[0x02] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1A] = temp_block[0x19]; block[0x24] = temp_block[0x12];\n\n        block[0x19] = temp_block[0x0B]; block[0x01] = temp_block[0x04];\n\n        block[0x0C] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x11] = temp_block[0x0C]; block[0x29] = temp_block[0x13];\n\n        block[0x16] = temp_block[0x1A]; block[0x0A] = temp_block[0x21];\n\n        block[0x30] = temp_block[0x28]; block[0x22] = temp_block[0x30];\n\n        block[0x38] = temp_block[0x29]; block[0x06] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x21] = temp_block[0x14];\n\n        block[0x1C] = temp_block[0x0D]; block[0x05] = temp_block[0x06];\n\n        block[0x0D] = temp_block[0x07]; block[0x15] = temp_block[0x0E];\n\n        block[0x2C] = temp_block[0x15]; block[0x13] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x0B] = temp_block[0x23]; block[0x34] = temp_block[0x2A];\n\n        block[0x2A] = temp_block[0x31]; block[0x32] = temp_block[0x38];\n\n        block[0x3A] = temp_block[0x39]; block[0x26] = temp_block[0x32];\n\n        block[0x39] = temp_block[0x2B]; block[0x03] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x25] = temp_block[0x16];\n\n        block[0x1D] = temp_block[0x0F]; block[0x2D] = temp_block[0x17];\n\n        block[0x17] = temp_block[0x1E]; block[0x0E] = temp_block[0x25];\n\n        block[0x31] = temp_block[0x2C]; block[0x2B] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x36] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x23] = temp_block[0x34]; block[0x3C] = temp_block[0x2D];\n\n        block[0x07] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x0F] = temp_block[0x27]; block[0x35] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x2E] = temp_block[0x35]; block[0x33] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x27] = temp_block[0x36];\n\n        block[0x3D] = temp_block[0x2F]; block[0x2F] = temp_block[0x37];\n\n        block[0x37] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else if(s->idsp.perm_type == FF_IDCT_PERM_LIBMPEG2){\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x04] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x0C] = temp_block[0x09]; block[0x01] = temp_block[0x02];\n\n        block[0x05] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x09] = temp_block[0x0A]; block[0x14] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1C] = temp_block[0x19];\n\n        block[0x11] = temp_block[0x12]; block[0x0D] = temp_block[0x0B];\n\n        block[0x02] = temp_block[0x04]; block[0x06] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0A] = temp_block[0x0C]; block[0x15] = temp_block[0x13];\n\n        block[0x19] = temp_block[0x1A]; block[0x24] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x2C] = temp_block[0x29]; block[0x21] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1D] = temp_block[0x1B]; block[0x12] = temp_block[0x14];\n\n        block[0x0E] = temp_block[0x0D]; block[0x03] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0B] = temp_block[0x0E];\n\n        block[0x16] = temp_block[0x15]; block[0x1A] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x25] = temp_block[0x23]; block[0x29] = temp_block[0x2A];\n\n        block[0x34] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x3C] = temp_block[0x39]; block[0x31] = temp_block[0x32];\n\n        block[0x2D] = temp_block[0x2B]; block[0x22] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x13] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1B] = temp_block[0x1E]; block[0x26] = temp_block[0x25];\n\n        block[0x2A] = temp_block[0x2C]; block[0x35] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x39] = temp_block[0x3A]; block[0x3D] = temp_block[0x3B];\n\n        block[0x32] = temp_block[0x34]; block[0x2E] = temp_block[0x2D];\n\n            block[0x23] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2B] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x36] = temp_block[0x35]; block[0x3A] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x33] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3B] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else{\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x01] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x09] = temp_block[0x09]; block[0x02] = temp_block[0x02];\n\n        block[0x03] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x0A] = temp_block[0x0A]; block[0x11] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x19] = temp_block[0x19];\n\n        block[0x12] = temp_block[0x12]; block[0x0B] = temp_block[0x0B];\n\n        block[0x04] = temp_block[0x04]; block[0x05] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0C] = temp_block[0x0C]; block[0x13] = temp_block[0x13];\n\n        block[0x1A] = temp_block[0x1A]; block[0x21] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x29] = temp_block[0x29]; block[0x22] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x14] = temp_block[0x14];\n\n        block[0x0D] = temp_block[0x0D]; block[0x06] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0E] = temp_block[0x0E];\n\n        block[0x15] = temp_block[0x15]; block[0x1C] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x23] = temp_block[0x23]; block[0x2A] = temp_block[0x2A];\n\n        block[0x31] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x39] = temp_block[0x39]; block[0x32] = temp_block[0x32];\n\n        block[0x2B] = temp_block[0x2B]; block[0x24] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1D] = temp_block[0x1D]; block[0x16] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1E] = temp_block[0x1E]; block[0x25] = temp_block[0x25];\n\n        block[0x2C] = temp_block[0x2C]; block[0x33] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x3A] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x34] = temp_block[0x34]; block[0x2D] = temp_block[0x2D];\n\n        block[0x26] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2E] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x35] = temp_block[0x35]; block[0x3C] = temp_block[0x3C];\n\n        block[0x3D] = temp_block[0x3D]; block[0x36] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3E] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }\n\n    end:\n\n    return last_non_zero_p1 - 1;\n\n}\n", "idx": 18545, "substitutes": {"s": ["is", "er", "fs", "a", "c", "h", "args", "js", "i", "vs", "ims", "e", "series", "v", "ctx", "stats", "ses", "less", "comments", "als", "bits", "eps", "aws", "sw", "steps", "ants", "ss", "sg", "grades", "ns", "spec", "ms", "space", "times", "w", "S", "cs", "rates", "hs", "p", "sts", "g", "rs", "ops", "self", "os", "set", "l", "m", "sb", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "params", "sc", "ats", "ts", "sys", "its", "b", "se", "ds", "stat", "ps", "t", "details", "z", "es"], "block": ["proc", "pad", "blocking", "window", "type", "bit", "box", "disk", "length", "ref", "chain", "init", "map", "tx", "channel", "point", "lock", "ck", "panel", "buffer", "shape", "range", "ml", "ip", "in", "byte", "wall", "line", "load", "Block", "set", "group", "check", "buf", "none", "sync", "list", "network", "off", "row", "b", "k", "cl", "record", "out", "join", "other", "bc", "context", "empty", "prefix", "pop", "x", "link", "mem", "frame", "loop", "number", "w", "bin", "bl", "raw", "base", "pack", "image", "inv", "word", "blocks", "limit", "hash"], "n": ["nb", "g", "nm", "na", "sn", "c", "h", "i", "nl", "size", "name", "len", "nn", "np", "ns", "r", "nor", "l", "nc", "m", "d", "num", "b", "v", "k", " N", "nan", "count", "x", "w", "nt", "N", "t", "z", "j", "p"], "qscale": ["quantscale", "sqsche", "qcale", "quanttest", "iqserver", "qScale", "quserver", "qumode", "qqsystem", "eqdelay", "querysync", "eqtest", "qstore", "sqstore", " qScale", "sqseries", "iqspec", "Qscale", "qsystem", "qdelay", "dqspec", "quscale", "qtest", "sqrate", "qmap", "qtscale", "qqdelay", "sqsystem", "querymode", "quantdelay", "qumap", "sqradius", "querysystem", "eqscale", "sqmask", "dqscale", "sqscan", "sqserver", "qscan", "queryscale", "quanttype", "eqmap", "qudelay", "qtsync", "qutype", "eqradius", "qmode", "Qcale", "qtype", "qrate", "sqsync", "iqsche", "qradius", "qurate", "qumask", "sqmap", "eqmask", "iqscale", "queryrate", "QScale", "qspec", " qcale", "Qspec", "qserver", "eqtype", "qtseries", "qtsystem", "quspec", "qsche", "querydelay", "qmask", "sqscale", "qsync", "qusche", "qustore", "qqscale", "quradius", "querystore", "queryscan", "sqdelay", "queryseries", "sqmode", "qqscan", "qseries", " qspec", "dqScale", "sqspec", "dqcale", "qutest"], "overflow": ["Overload", "Overflows", "underflows", "underflow", "Overwrite", " overwrite", "underwrite", "underload", " overflows", "overflows", " overload", "overwrite", "overload", "Overflow"], "last_non_zero_p1": ["last_non_zero_fp2", "last_non_zero_P3", "last_non_zero_t1", "last_non_zero_P2", "last_non_zero_d2", "last_non_zero_d1", "last_non_zero_Pons", "last_non_zero_t5", "last_non_zero_d0", "last_non_zero_P0", "last_non_zero_p2", "last_non_zero_p0", "last_non_zero_pc2", "last_non_zero_P5", "last_non_zero_dons", "last_non_zero_fp1", "last_non_zero_P1", "last_non_zero_fpons", "last_non_zero_t2", "last_non_zero_pc3", "last_non_zero_p5", "last_non_zero_pc1", "last_non_zero_t3", "last_non_zero_pc5", "last_non_zero_pons", "last_non_zero_d3", "last_non_zero_p3", "last_non_zero_fp3"], "q": ["f", "bit", "qa", "g", "pkg", "h", "sq", "qu", "lock", "depth", "Q", "ck", "dq", "ip", "y", "ue", "pp", "qt", "load", "aq", "qq", "qi", "quality", "u", "ll", "quant", "query", "d", "qv", "question", "eq", "level", "k", "v", "ix", "charge", "qs", "quad", "quit", "w", "ch", "queue", "iq", "quick", "t", "qual", "z", "j", "p"], "qmat": ["quercmd", "eqMat", "sqhat", " qhat", " qman", "lockcmd", "eqmat", "qqcmd", "questmap", " qrix", " qcol", " qformat", "qrix", "qqformat", "dqcol", "querscale", "qmap", " qMat", "qqrix", "questtar", "qman", "dqman", "eqcol", "qumap", "dqmat", "qhat", "qqscale", " qmem", "questmem", "sqrix", "qumat", "qMat", "qqhat", "qformat", "qtar", " qmap", "querhat", "lockmat", "qcmd", "qutar", "eqman", "dqMat", "lockscale", "quermat", "sqmat", "qqmat", "qumem", "lockhat", "sqformat", "qcol", "qmem", " qtar", "questmat"], "bias": ["bbaz", "ebia", "ebali", "babel", "brased", "rbias", "bbau", " balias", "based", " bia", "baz", "erbau", "bbali", "rbased", "bia", "pia", "erbaz", "brias", "balias", "baid", "bali", "biabel", "biaid", "erbia", "erbui", " based", "ebui", "rbalias", "erbias", "rbali", "ebias", "pabel", "erbali", "bui", "brali", " baz", "biia", " bau", "pias", "biias", "bau", "ebabel", "bralias", " bui", "paid", " bali", "ebaid", "bbias"], "dummy": [" datum", "Dummy", "adump", "Datum", " dummies", "adummy", " delta", " dessert", "Delta", "sdessert", "dessert", "indummy", "indessert", "adatum", "sdummies", " dump", "delta", "sdummy", "dummies", "adelta", "indummies", "dump", "Dump", "datum"]}}
{"project": "FFmpeg", "commit_id": "491eaf35ae1f9b619441314bec33766e31580184", "target": 1, "func": "static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)\n\n{\n\n    int channel, stereo, phase, exp;\n\n    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;\n\n    int local_int_14, stereo_exp, local_int_20, local_int_28;\n\n    int n, offset;\n\n\n\n    local_int_4 = 0;\n\n    local_int_28 = 0;\n\n    local_int_20 = 2;\n\n    local_int_8 = (4 - duration);\n\n    local_int_10 = 1 << (q->group_order - duration - 1);\n\n    offset = 1;\n\n\n\n    while (1) {\n\n        if (q->superblocktype_2_3) {\n\n            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {\n\n                offset = 1;\n\n                if (n == 0) {\n\n                    local_int_4 += local_int_10;\n\n                    local_int_28 += (1 << local_int_8);\n\n                } else {\n\n                    local_int_4 += 8*local_int_10;\n\n                    local_int_28 += (8 << local_int_8);\n\n                }\n\n            }\n\n            offset += (n - 2);\n\n        } else {\n\n            offset += qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2);\n\n            while (offset >= (local_int_10 - 1)) {\n\n                offset += (1 - (local_int_10 - 1));\n\n                local_int_4  += local_int_10;\n\n                local_int_28 += (1 << local_int_8);\n\n            }\n\n        }\n\n\n\n        if (local_int_4 >= q->group_size)\n\n\n\n\n        local_int_14 = (offset >> local_int_8);\n\n\n\n\n\n        if (q->nb_channels > 1) {\n\n            channel = get_bits1(gb);\n\n            stereo = get_bits1(gb);\n\n        } else {\n\n            channel = 0;\n\n            stereo = 0;\n\n        }\n\n\n\n        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);\n\n        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];\n\n        exp = (exp < 0) ? 0 : exp;\n\n\n\n        phase = get_bits(gb, 3);\n\n        stereo_exp = 0;\n\n        stereo_phase = 0;\n\n\n\n        if (stereo) {\n\n            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));\n\n            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));\n\n            if (stereo_phase < 0)\n\n                stereo_phase += 8;\n\n        }\n\n\n\n        if (q->frequency_range > (local_int_14 + 1)) {\n\n            int sub_packet = (local_int_20 + local_int_28);\n\n\n\n            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);\n\n            if (stereo)\n\n                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);\n\n        }\n\n\n\n        offset++;\n\n    }\n\n}", "idx": 18556, "substitutes": {"q": ["f", "qa", "g", "pkg", "c", "sq", "h", "qu", "Q", "ck", "dq", "requ", "ue", "qt", "aq", "qi", "qq", "e", "r", "query", "question", "eq", "local", "v", "k", "ve", "quest", "req", "quit", "qs", "w", " qu", "ch", "queue", "iq", "comm", "t", "conf", "z", "p"], "duration": ["gain", "nb", "component", "window", "length", "bb", "type", "h", "nr", "c", "distance", "delay", "depth", "i", "size", "uration", "position", "name", "dt", "dim", "version", "padding", "y", "repeat", "frequency", "sequence", "m", "date", "id", "d", "bid", "record", "v", "time", "days", "total", "db", "count", "span", "direction", "number", "resolution", "format", "base", "Duration", "start", "seconds", "gap", "t", "timeout", "p"], "gb": ["nb", "bridge", "bb", "cv", "cgi", "g", "gt", "gd", "gram", "tg", "GB", "gio", "vg", "wb", "fb", "ogg", "gin", "rb", "rg", "chn", "gc", "phy", "cb", "pb", "ib", "ubis", "yg", "gif", "pc", "arb", "eb", "gz", "bg", "gnu", "Gb", "bn", "hub", "sb", "gm", "bc", "kb", "db", "pg", "vc", "gg", "usb", "gs", "gy", "bm", "bf", "emb", "mb", "ch", "ug", "bs", "cfg"], "b": ["nb", "f", "bb", "bh", "g", "bi", "B", "a", "c", "i", "bank", "buffer", "bp", "y", "cb", "e", "r", "l", "m", "d", "eb", "v", "bg", "be", "sb", "bc", "db", "ba", "bt", "w", "base", "bm", "bf", "t", "bs", "p"], "channel": ["component", "unit", "label", "cho", "connection", "chain", "cam", "camera", "c", "depth", "chip", "chart", "pixel", "version", "byte", "chn", "frequency", "button", "message", "annels", "client", "broad", "mode", "color", "voice", "console", "course", "context", "axis", "member", "chron", "focus", "frame", "direction", "ann", "chan", "scope", "ch", "Channel", "field", "category", "batch"], "stereo": ["Stereo", "stuster", "spectereo", "structuster", "steuster", "stochemistry", "structochemistry", "ustere", "steereo", "stere", "Structure", "ustipple", "STipple", " structure", "steopic", "STortion", "Stipple", "stipple", "stopic", "spectipple", "stortion", " stortion", "structereo", "steochemistry", " stere", " stochemistry", "STructure", "STereo", " stopic", "spectortion", "Stere", " stuster", " stipple", "ustereo", "spectructure", "structopic", "structure", "ustructure"], "phase": ["unit", "amp", "ep", "ref", "phrase", "sample", "shape", "scale", "dim", "version", "xp", "phy", "frequency", "pid", "path", "id", "ph", "mode", "mid", "axis", "ase", "ape", "pha", "pro", "ome", "scope", "Phase"], "local_int_4": ["local_int___428", "local_inc_504", "local_ip_four", "local_iter_10", "local_inc_428", "local_int_Four", "local_int_410", "local_int_four", "local_int00504", "local_str_8", "local_int10410", "local_int64r", "local_inc4504", "local_int4428", "local_int_428", "local_int0045", "local_int1040", "local_int___4", "local_int_04", "local_int_40", "local_int445", "local_iter_r", "local_inc_4", "local_int004", "local_int644", "local_iter_04", "local_int1016", "local_int44", "local_int_504", "local_float_16", "local_int6404", "local_iter_44", "local_int3216", "local_intcFour", "local_ip_4", "local_int1004", "local_inc445", "local_int106", "local_intc04", "local_intc10", "local_int___504", "local_inc_45", "local_int6444", "local_float_40", "local_int3204", "local_float_4", "local_int00428", "local_int104", "local_int108", "local_inc4428", "local_ip_44", "local_int___45", "local_int_r", "local_float_04", "local_int_6", "local_iter_4", "local_intc4", "local_int3240", "local_str_4", "local_int_45", "local_inc44", "local_str_6", "local_int_16", "local_int4504", "local_iter_Four", "local_ip_8", "local_str_410", "local_int_44", "local_int324"], "local_int_8": ["local_int648", "local_int4808", "local_int0810", "local_intx8", "local_short088", "local_int_11", "local_int_32", "local_str_8", "local_int_rin", "local_i_18", "local_i_10", "local_int_9", "local_int6411", "local_inter_8", "local_int088", "local_float_08", "local_int0832", "local_int48810", "local_short0810", "local_uint_8", "local_int1008", "local_int10i", "local_short_10", "local_intx14", "local_str_0", "local_int_0", "local_intx08", "local_inter_11", "local_short_28", "local_i_08", "local_int_810", "local_i_4", "local_int_18", "local_int488", "local_int0828", "local_float_8", "local_inter_08", "local_short0828", "local_int6414", "local_int6408", "local_int489", "local_float_4", "local_str_810", "local_int_08", "local_int104", "local_int108", "local_str_9", "local_i_8", "local_intx18", "local_inter_14", "local_str_4", "local_str_10", "local_str_08", "local_uint_14", "local_int_i", "local_uint_08", "local_short_8", "local_short_32", "local_float_i", "local_uint_18", "local_short0832", "local_i_rin", "local_i_14"], "stereo_phase": ["stadium_phase", "stadium_exp", "stereo_amp", "stadium_amp", "stereo_mid", "stadium_mid"], "local_int_10": ["local_int648", "local_point_8", "local_int_iter", "local_int6711", "local_out_10", "local_int_11", "local_out9110", "local_point_1000", "local_point_14", "local_int_1000", "local_point_9", "local_out_5", "local_int_9", "local_int3610", "local_int98", "local_int_40", "local_point_iter", "local_int3608", "local_int6420", "local_int_ten", "local_out_8", "local_out98", "local_int_12", "local_out910", "local_int_110", "local_point_10", "local_int678", "local_int95", "local_int9110", "local_point_ten", "local_point_20", "local_int910", "local_out_110", "local_int_08", "local_int6440", "local_int6710", "local_int368", "local_int67iter", "local_out95", "local_point_12", "local_point_11", "local_int_5", "local_int6410", "local_int3612", "local_point_40"], "local_int_14": ["local_INT_28", "local_long_14", "local_int414", "local_int428", "local_int_ml", "local_long_ml", "local_long428", "local_int415", "local_long4ml", "local_long_28", "local_int67ml", "local_long414", "local_long415", "local_int_12", "local_int6728", "local_long_15", "local_int_15", "local_int4ml", "local_int6715", "local_int6714", "local_INT_8", "local_INT_14", "local_INT_12"], "stereo_exp": ["stereo_scale", "stere_exp", "stere_comp", "stereo_comp", "stereo_xp", "stere_xp", "stere_scale"], "local_int_20": ["local_inst_8", "local_inst178", "local_uint_60", "local_uint_20", "local_int1760", "local_inst_60", "local_uint_28", "local_int17len", "local_inst17len", "local_int1720", "local_inst_20", "local_uint_40", "local_int178", "local_inst1760", "local_int_len", "local_int_60", "local_inst_len", "local_int_40", "local_inst1720"], "local_int_28": ["local_INT_28", "local_point_8", "local_int_32", "local_point_14", "local_int_148", "local_bit_23", "local_bit_14", "local_bit_8", "local_INT_58", "local_int_21", "local_inter_8", "local_inter678", "local_inter6728", "local_int25148", "local_int_58", "local_point_28", "local_int2558", "local_INT_8", "local_int258", "local_INT_148", "local_int_29", "local_int678", "local_bit_32", "local_bit_27", "local_inter6721", "local_bit_28", "local_int6721", "local_int_23", "local_int_27", "local_int2528", "local_point_29", "local_inter_28", "local_int6728", "local_inter_21"], "n": ["new", "nb", "ne", "g", "nm", "na", "sn", "cn", "a", "c", "h", "dn", "i", "nl", "name", "len", "y", "net", "nn", "ns", "np", "norm", "u", "ni", "e", "nor", "l", "nc", "m", "num", "d", "v", "k", "o", "out", " N", "nu", "nan", "count", "number", "no", "nt", "N", "fn", "t", "z", "j", "p"], "offset": ["block", "shift", "a", "i", "pointer", "seed", "Offset", "attribute", "amount", "OFF", "address", "e", "message", "upper", "o", "time", "skip", "trace", "lower", "limit", "f", "pad", "url", "alias", "usage", "entry", "onet", "len", "pos", "reference", "now", "index", "off", "area", "lag", "stop", "step", "p", "window", "length", "scroll", "end", "location", "slot", "point", "delay", "origin", "size", "buffer", "error", "frequency", "set", "balance", "angle", "instance", "range", "notation", "type", "ref", "fp", "position", "padding", "align", "value", "id", "onto", "reset", "data", "translation", "output", "it", "base", "start", "addr", "timeout"]}}
{"project": "qemu", "commit_id": "ff472a5badf8e6d964455de39ca67ea3a7758dea", "target": 1, "func": "static void cuda_receive_packet(CUDAState *s,\n\n                                const uint8_t *data, int len)\n\n{\n\n    uint8_t obuf[16] = { CUDA_PACKET, 0, data[0] };\n\n    int autopoll;\n\n    uint32_t ti;\n\n\n\n    switch(data[0]) {\n\n    case CUDA_AUTOPOLL:\n\n        autopoll = (data[1] != 0);\n\n        if (autopoll != s->autopoll) {\n\n            s->autopoll = autopoll;\n\n            if (autopoll) {\n\n                timer_mod(s->adb_poll_timer,\n\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n\n                               (get_ticks_per_sec() / CUDA_ADB_POLL_FREQ));\n\n            } else {\n\n                timer_del(s->adb_poll_timer);\n\n            }\n\n        }\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_6805_ADDR:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_SET_TIME:\n\n        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];\n\n        s->tick_offset = ti - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_TIME:\n\n        ti = s->tick_offset + (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        obuf[3] = ti >> 24;\n\n        obuf[4] = ti >> 16;\n\n        obuf[5] = ti >> 8;\n\n        obuf[6] = ti;\n\n        cuda_send_packet_to_host(s, obuf, 7);\n\n        break;\n\n    case CUDA_FILE_SERVER_FLAG:\n\n    case CUDA_SET_DEVICE_LIST:\n\n    case CUDA_SET_AUTO_RATE:\n\n    case CUDA_SET_POWER_MESSAGES:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_POWERDOWN:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case CUDA_RESET_SYSTEM:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_reset_request();\n\n        break;\n\n    case CUDA_COMBINED_FORMAT_IIC:\n\n\n        obuf[1] = 0x5;\n\n\n\n\n        break;\n\n    case CUDA_GET_SET_IIC:\n\n        if (len == 4) {\n\n            cuda_send_packet_to_host(s, obuf, 3);\n\n        } else {\n\n\n\n\n\n\n        }\n\n        break;\n\n    default:\n\n\n\n\n\n\n        break;\n\n    }\n\n}", "idx": 18559, "substitutes": {"s": ["ls", "is", "us", "sts", "conf", "sv", "rs", "st", "er", "g", "sn", "as", "so", "sw", "south", "h", "c", "sq", "js", "service", "os", "store", "ss", "y", "vs", "ns", "spec", "set", "r", "sync", "l", "ts", "d", "sys", "its", "sp", "es", "b", "v", "m", "n", "space", "sports", "sb", "services", "stats", "ds", "qs", "ses", "less", "S", "sam", "ssl", "gs", "cs", "ps", "t", "bs", "comm", "fs", "hs", "z", "p"], "data": ["box", "block", "cache", "a", "shift", "args", "ad", "def", "ata", "dat", "table", "message", "v", "o", "aw", "key", "kat", "hash", "normal", "done", "extra", "offset", "bits", "entry", "bus", "values", " DATA", "pos", "ns", "session", "zero", "DATA", "mat", "windows", "empty", "vals", "results", "keys", "blocks", "partial", "p", "window", "chain", "ops", "valid", "size", "buffer", "byte", "pins", "match", "buf", "none", "options", "next", "no", "raw", "apps", "batch", "text", "type", "final", "info", "params", "res", "bytes", "att", "da", "d", "value", "n", "join", "Data", "str", "ds", "t", "share"], "len": [" n", "length", "lan", "type", "all", "en", "Len", "Length", "h", "size", "nl", "pos", "bytes", "l", "num", "id", "el", "un", "sp", "n", " length", " l", "count", " count", "ln", "t", "z"], "obuf": ["obf", "OBbuff", " ibull", "obbuff", "OBbuf", " obfac", "ofg", " ibbuf", " obuff", "objbuf", "obsbuff", "robbuf", " obert", "obsoster", "oboster", "objoster", "objf", "objbuff", "obbbuf", "oyalf", "robfac", " obbuff", "robert", "obsert", "objuf", "webuf", "obsuf", "oyuf", "oinfac", "obsf", " ibbuff", " dbbuff", " dbuf", "webalf", " obfg", "oinuf", " obuffer", "obbuf", " obf", "obalf", "OBuff", " obull", "obert", "robuff", "obbalf", "obfac", "objuff", "obbfg", "obuff", "ouff", "obsuffer", " obbuf", " dbbuf", "obsather", " oboster", "obsfac", "oyfg", "robbuff", "obsuff", "objert", "objuffer", "obsbuf", "ouf", " ibuf", "robuf", " dbull", "webuff", "webfg", " obather", "oinather", "obuffer", "oinf", "obfg", "oyuff", "OBuf", "obull", "obather"], "autopoll": ["autipoll", "acosppoll", " autopoller", "autipool", "autpol", "authropool", "autoprot", "autorpull", "autospol", "autosppoll", "autoopull", "autoorpull", " autoppoll", "autropoly", "acospoll", "autmoppoll", "autpll", "authopoly", " autoproc", "autooll", "autopoller", "acopool", "autmopoll", " autosproc", " autooll", "autompoller", "autoproc", "autoorpell", "autool", " autoprot", "autompell", "acopoll", "autoplull", "autospool", " autompool", "autosproc", " autospll", "authropull", " autopll", "autorot", "autopsull", "authopool", "autopell", "acospll", "autopool", "autoploly", " autosppoll", " autopool", "autmopll", "autoroc", "autompoll", "autipll", "autompol", "autompull", "autopol", "authropoll", "acoppoll", "automprot", "autospoller", " autipool", "autpool", "autorpoll", "authopoll", "autropull", "autorpol", "autospull", "autospoll", "autopoly", "autopsoll", "autoopell", "autoool", "autropoll", "autoplrot", "autpoll", " autoool", "acopll", "autoll", " autorot", " autipol", "autoopoll", "autoorpoll", " autospoll", " autipll", "autmopool", " autool", " autompoller", "autopll", "autopsell", "autmoproc", "authopull", "autropool", " autipoll", "autompool", "autoplool", "authropoly", "autoploll", "autipoller", "autopull", "autorpell", "autospoly", " autopol", " autompoll", "autoorpol", "autippoll", "autoopol", " autompol", "autospll", "autoppoll", "autipol", "autoplol", "acospool", "autopsol"], "ti": [" ki", "tm", "tri", "mit", "tt", "tie", "bi", "TA", " li", "tile", "gi", " di", "ta", "ste", "ri", "tis", "xi", "ki", " psi", "Ti", "ai", "i", "TI", "Xi", "MI", "uti", "te", "iti", "li", "ui", "isi", "tw", "tone", "ami", "ita", "iat", "qt", "pi", "qi", "alli", "ni", "tip", "aki", "zi", "ci", "wi", "ati", "fa", "VI", "tu", "ii", "fi", "phi", "Tai", "trace", "wit", "wei", "di", " ni", "tv", "mi", "it", "tif", "hi", "ite", "hea", "tree", "t", "ski", "wt", "yi", "si"]}}
{"project": "qemu", "commit_id": "b6b75a99dab760c902c3d355519e0dc2616872e1", "target": 1, "func": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);", "idx": 18562, "substitutes": {"bm": ["irm", "nb", "tm", "bb", "bh", "br", "bi", "mr", "mx", "mm", "BM", "cm", "wm", "ay", "mc", "bp", "sbm", "mu", "em", "umi", "dm", "hm", "pm", "m", "b", "amm", "mn", "bn", "gm", "gb", "lb", "bt", "mi", "sam", "rm", "bol", "bf", "bl", "mt", "bs", "bo"]}}
{"project": "FFmpeg", "commit_id": "513a3494396d0a20233273b3cadcb5ee86485d5c", "target": 1, "func": "static int vp6_parse_coeff(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = s->ccp;\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->idct_scantable;\n\n    uint8_t *model1, *model2, *model3;\n\n    int coeff, sign, coeff_idx;\n\n    int b, i, cg, idx, ctx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    if (c->end >= c->buffer && c->bits >= 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"End of AC stream reached in vp6_parse_coeff\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 1;    /* code type */\n\n        int run = 1;\n\n\n\n        if (b > 3) pt = 1;\n\n\n\n        ctx = s->left_block[ff_vp56_b6to4[b]].not_null_dc\n\n              + s->above_blocks[s->above_block_idx[b]].not_null_dc;\n\n        model1 = model->coeff_dccv[pt];\n\n        model2 = model->coeff_dcct[pt][ctx];\n\n\n\n        coeff_idx = 0;\n\n        for (;;) {\n\n            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {\n\n                /* parse a coeff */\n\n                if (vp56_rac_get_prob_branchy(c, model2[2])) {\n\n                    if (vp56_rac_get_prob_branchy(c, model2[3])) {\n\n                        idx = vp56_rac_get_tree(c, ff_vp56_pc_tree, model1);\n\n                        coeff = ff_vp56_coeff_bias[idx+5];\n\n                        for (i=ff_vp56_coeff_bit_length[idx]; i>=0; i--)\n\n                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;\n\n                    } else {\n\n                        if (vp56_rac_get_prob_branchy(c, model2[4]))\n\n                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);\n\n                        else\n\n                            coeff = 2;\n\n                    }\n\n                    ct = 2;\n\n                } else {\n\n                    ct = 1;\n\n                    coeff = 1;\n\n                }\n\n                sign = vp56_rac_get(c);\n\n                coeff = (coeff ^ -sign) + sign;\n\n                if (coeff_idx)\n\n                    coeff *= s->dequant_ac;\n\n                idx = model->coeff_index_to_pos[coeff_idx];\n\n                s->block_coeff[b][permute[idx]] = coeff;\n\n                run = 1;\n\n            } else {\n\n                /* parse a run */\n\n                ct = 0;\n\n                if (coeff_idx > 0) {\n\n                    if (!vp56_rac_get_prob_branchy(c, model2[1]))\n\n                        break;\n\n\n\n                    model3 = model->coeff_runv[coeff_idx >= 6];\n\n                    run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);\n\n                    if (!run)\n\n                        for (run=9, i=0; i<6; i++)\n\n                            run += vp56_rac_get_prob(c, model3[i+8]) << i;\n\n                }\n\n            }\n\n            coeff_idx += run;\n\n            if (coeff_idx >= 64)\n\n                break;\n\n            cg = vp6_coeff_groups[coeff_idx];\n\n            model1 = model2 = model->coeff_ract[pt][ct][cg];\n\n        }\n\n\n\n        s->left_block[ff_vp56_b6to4[b]].not_null_dc =\n\n        s->above_blocks[s->above_block_idx[b]].not_null_dc = !!s->block_coeff[b][0];\n\n    }\n\n    return 0;\n\n}\n", "idx": 18578, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "ins", "as", "aws", "sw", "a", "sq", "h", "args", "settings", "ares", "js", "self", "os", "ss", "sc", "ns", "ims", "spec", "e", "r", "erences", "ats", "ts", "m", "its", "sys", "sets", "v", "es", "n", "se", "sports", "sb", "services", "times", "stats", "ds", "qs", "ses", "S", "gs", "source", "cs", "sa", "ps", "t", "bs", "fs", "hs", "p"], "c": ["f", "cf", "lc", "cv", "cmp", "cr", "g", "cache", "chain", "cn", "a", "h", "C", "ca", "cm", "cus", "com", "rc", "fc", "anc", "mc", "cont", "ic", "cp", "conv", "etc", "gc", "cb", "unc", "tc", "enc", "r", "cu", "ac", "this", "nc", "m", "con", "cc", "v", "n", "ct", "cl", "bc", "xc", "uc", "ce", "vc", "cur", "ec", "container", "cs", "ch", "t", "co", "conf", "dc", "cd", "p"], "model": ["f", "library", "lc", "cell", "config", "vector", "map", "condition", "mm", "sm", "le", "bank", "man", "server", "device", "go", "ver", "spec", "re", "form", "address", "table", "dem", "sim", "m", "Model", "el", "network", "vm", "zero", "v", "param", "mode", "ve", "policy", "link", "feature", "controller", "mem", "transform", "module", "bm", "command", "tree", "mod", "dev", "models", "variable", "p"], "permute": ["mulate", "permutable", "modute", "permutation", "modutation", "mutable", "modutable", "mute", "mutation", "permulate", "modulate", "mutulate", "mututation", "mututable", "mutute"], "model1": ["template4", "table0", "cell3", "Model2", "modelb", "cell0", "cell1", "link2", "server4", "link0", "table3", "template1", "server1", " model0", "link1", "server0", "serverb", "table1", "templateb", "model4", " model4", "Model0", "Model3", "link3", "Model1", "template0", " modelb", "model0"], "model2": ["image2", "Model2", "modelb", "dem3", "model6", "example2", "feature02", " modelTwo", "model15", "server22", "feature22", " model12", "dem12", "server2", "team6", "modeltwo", "image12", "server02", "example15", "demTwo", "example22", "template2", " model02", "module52", "layer2", "modelTwo", "project3", "templateb", "project6", " model6", "template52", "team2", "model02", "moduleb", "projecttwo", "server15", "model22", "example02", "team3", "Model3", "layer3", "module2", "Model02", "feature2", " model52", "Model1", "teamtwo", "feature15", "layer02", "dem2", " modeltwo", "model12", "imageTwo", "layer1", " modelb", "project2", "image3", "model52"], "model3": [" model6", "module03", "model6", "gem6", "gem03", "model03", " model03", "module6", "gem3", "gem1", "module3", "module1"], "coeff": ["COefficient", " coff", "Coff", "coff", "conffee", "coffee", "coef", "Coeff", "Coefficient", "COef", "conef", "COff", " coffee", "Coef", " coefficient", "noef", "noff", "COffee", " coef", "coneff", "COeff", "conefficient", "coefficient", "noefficient", "noeff"], "sign": ["act", "sum", "br", "ind", "ca", "err", "ai", "shape", "big", "cap", "scale", "sc", "comp", "pos", "ig", "go", "round", "cc", "sp", "sb", "gn", "ign", "sa", "ch", "mod", "cmp", "name"], "coeff_idx": ["coeff_indix", "coeff_idew", "coeff_indw", "coeff_ideindex", "coeff_midx", "coeff_ridx", "coeff_idy", "coeff_Idw", "coeff_Idix", "coeff_Idy", "coeff_idw", "coeff_ridz", "coeff_ideex", "coeff_midn", "coeff_idn", "coeff_idey", "coeff_idz", "coeff_ideix", "coeff_idix", "coeff_Idindex", "coeff_ridn", "coeff_midix", "coeff_idex", "coeff_indx", "coeff_idindex", "coeff_ridex", "coeff_ridix", "coeff_Idex", "coeff_Idx", "coeff_ridindex", "coeff_ridy", "coeff_midz"], "b": ["nb", "f", "bb", "bh", "br", "ach", "g", "bi", "ub", "B", "a", "h", "bd", "fb", "batch", "ab", "rb", "y", "bp", "byte", "go", "cb", "pb", "ib", "by", "r", "e", "l", "m", "d", "eb", "v", "bg", "be", "back", "bis", "sb", "bc", "db", "gb", "ba", "x", "bt", "bl", "bin", "z", "ob", "base", "bf", "bound", "mb", "bu", "ch", "t", "bs", "bo", "j", "p"], "i": ["f", "is", "length", "g", "bi", "gi", "h", "ri", "xi", "ki", "cli", "ai", "ini", "size", "oi", "li", "ui", "ic", "y", "ip", "io", "\u0438", "pi", "iu", "qi", "u", "ib", "ni", "zi", "ci", "l", "m", "d", "index", "id", "v", "I", "o", "n", "ii", "ti", "phi", "ix", "x", "di", "it", "mi", "hi", "ij", "t", "multi", "j", "si", "p"], "cg": [" cgp", " cgs", "cge", "fcg", "lcgp", "fcgs", "lcge", "fcgp", "lcgs", "cgp", "fcge", "cgs", "lcg", " cge"], "idx": ["idex", "tryindex", "tryy", "IDy", "mainy", "idon", "idxes", "odix", "IdX", " idX", "Idix", "odxs", " idy", "idxs", " idon", "mainx", "ody", "IDon", "odx", "IDix", "idindex", "indx", " idindex", "ridX", " idxs", "tryix", "ridex", "Idx", "IDx", "idy", "tryx", "Idex", " idix", "idX", "edy", "mainxes", "edix", "mainix", "indy", "indindex", " idex", "odon", " idxes", "edxes", "edx", "ridix", "ridx", "idix", "indxs", "indix"], "ctx": ["tmp", "cf", "act", "rt", "ht", "conn", "Context", "pkg", "jp", "tx", "nd", "ca", "point", "gp", "td", "cp", "iat", "pos", "np", "gc", "jac", "cb", "loc", "unc", "kt", "qt", "tc", "cu", "height", "ac", "pc", "pt", "index", "cc", "kw", "sp", "txt", "ct", "pa", "bc", "context", "cmd", "cas", "nt", "ptr", "tz", "cmp", "co", "dc", "tp", "timeout", "pat"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n", "idx": 18583, "substitutes": {"s": ["f", "ls", "is", "esm", "sts", "g", "rs", "sv", "st", "as", "sn", "aws", "sw", "scl", "south", "a", "c", "h", "sq", "js", "self", "store", "os", "ss", "sc", "sg", "ns", "spec", "set", "r", "als", "ats", "ts", "m", "sys", "es", "b", "v", "ctx", "n", "o", "se", "acs", "sb", "stats", "ds", "an", "ses", "qs", "less", "w", "S", "ssl", "gs", "cs", "ps", "t", "bs", "conf", "fs", "hs", "z", "j", "p"], "res": ["init", "RES", "def", "resources", "out", "val", "req", "mem", "rest", "reg", "bits", "tx", "rx", "Res", "rem", "ret", "des", "re", "expr", "ms", "progress", "cmd", "success", "vals", "msg", "results", "ress", "cs", "ch", "rep", "red", "p", "prime", "resource", "ser", "rs", "conn", "result", "ri", "err", "fresh", "os", "cons", "resp", "prefix", "x", "resolution", "raw", "ires", "range", "rt", "ins", "trans", "reason", "rc", "pas", "ris", "rel", "r", "arr", "gr", "got", "rev", "pres", "reset", "str", "ix", "data", "addr", "ps", "details", "response", "j"], "start": ["init", "shift", "use", "top", "check", "started", "time", "before", "be", "skip", "key", "first", "wind", "req", "begin", "art", "add", "rest", "need", "pad", "from", "offset", "st", "entry", "pre", "iter", "root", "len", "pos", "ish", "path", "index", "date", "Start", "row", "space", "state", "stop", "ie", "step", "name", "p", "ind", "lat", "point", "arts", "star", "set", "middle", "sp", "ST", "seek", "next", "no", "last", "try", "range", "get", "trans", "part", "starting", "prev", "r", "d", "id", "reset", "str", "it", "t", "j"], "end": ["ending", "close", "length", "rend", "offset", "ext", "all", "en", "st", "final", "add", "ended", "fail", "End", "until", "nd", "point", "win", "pend", "then", "tail", "port", "except", "ad", "ender", "fin", "len", "ue", "append", "ell", "e", "eval", "max", "est", "ort", "id", "dest", "off", "and", "v", "END", "out", "be", "send", "eff", "reset", "val", "wind", "next", "alt", "last", "begin", "it", "stop", "ent", "east", "bound", "hend", "eng", "termin", "range", "rest"], "i": ["is", "g", "bi", "iri", "gi", "ind", "iter", "ri", "xi", "ai", "info", "ini", "json", "q", "li", "ui", "ic", "y", "ip", "iat", "io", "pi", "iu", "qi", "u", "im", "zi", "ci", "l", "sim", "m", "me", "index", "ji", "list", "b", "v", "k", "I", "o", "ori", "ii", "ti", "ei", "fi", "phi", "ix", "slice", "x", "di", "uri", "dr", "mi", " j", "it", "hi", "ij", "t", "multi", "z", "j", "si", "p"], "command": ["text", "program", " Command", "action", "sword", "execute", "phrase", "method", "reason", "password", "definition", "attribute", "pattern", "power", "argument", "form", "function", "sequence", "query", "message", "request", "menu", "call", "force", "mode", "code", "template", "Command", "comment", "send", "description", "cmd", "prefix", "direction", "frame", "status", "word", "process", "response"], "epsv_codes": ["epsv_code", "epsv2cod", "epsv_cod", "epv2code", "epv_cod", "epv_code", "epv2codes", "epv_lines", "epsv2code", "epv2cod", "epsv2codes", "epv2lines", "epv_codes", "epsv_lines", "epsv2lines"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_enqueue_packet(VLANClientState *sender,\n\n                                const uint8_t *buf, int size,\n\n                                NetPacketSent *sent_cb)\n\n{\n\n    VLANPacket *packet;\n\n\n\n    packet = qemu_malloc(sizeof(VLANPacket) + size);\n\n    packet->sender = sender;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n\n}\n", "idx": 18596, "substitutes": {"sender": ["dsend", "bend", "Sorter", "insnd", "dsending", "cend", "cink", "insriber", "Sender", "Snd", "dsender", "insender", "csnd", "csender", "dsorter", "insink", "csorter", "sorter", "Sending", "insend", " sorter", "borter", "snd", " sink", "sending", "cender", "bendor", "criber", "csend", "sendor", "send", "Send", " sending", "sink", "Sendor", "bender", "sriber", " send", " sriber", " sendor", "insorter"], "buf": ["tmp", "cv", "block", " buffer", "br", "pkg", "map", "vec", "wb", "bar", "fb", "Buff", "func", "buffer", "cap", "Buffer", "rb", "bp", "bytes", "doc", "bag", "img", "cb", "pb", "orig", "b", "ctx", "txt", "uf", "bc", "db", "data", "cur", "mem", "msg", "raw", "buff", "bin", "ob", "bf", "bound", "queue"], "size": ["length", "sum", "type", "zone", "offset", "g", "sn", "fee", "sent", "password", "shape", "name", "city", "SIZE", "scale", "len", "amount", "ize", "pos", "body", "set", "max", "address", "height", "message", "small", "num", "index", "sp", "time", "area", "space", "total", "Size", "send", "state", "package", "since", "empty", "notice", "data", "capacity", "count", "x", "storage", "number", "format", "limit", "start", "needed", "scope", "cmp", "timeout"], "sent_cb": ["sent___cf", "sent___fn", "sent____callback", "sentpfn", "sent__fn", "sentswcb", " sent_callback", "sent_cf", "sent___callback", "sent____fn", "send_fn", "sent___cb", "sent____cb", "sent_rb", "send__dt", "sent_queue", " sent_cf", "sent_fee", "send_rb", "sent_fn", "sent_callback", "send__fn", "sent__dt", "sentpcb", "send__cb", "send_callback", "sent____cf", "send_queue", "send_dt", "sentswcallback", " sent_fn", "send_fee", "sentpdt", "sentpfee", "send_cb", "sentswqueue", "sent__cb", "send__fee", "sent__fee", "sentswrb", "sent_dt"], "packet": ["payet", "plest", "presentpet", "packkt", "paket", "packageacket", " packata", "taget", "payacket", "creatant", "ppkt", "tagset", "packeter", "lookset", "tagacket", "ppeter", "bucketer", "packedets", "makeet", "packest", "Packet", "pakant", "packedacket", "octant", "codect", "pppet", "Packacket", "tagpet", "placket", "payant", "presentacket", "pakpet", "looket", "packedest", "codata", "packageets", "packagekt", "makepet", "tageter", "packect", "plet", "lookpet", "packant", "createt", "ppet", "buckpet", "Packect", "packset", "octeter", "codacket", "packacket", "octkt", "octet", " packect", "presentant", "presentet", "codet", "pakacket", "ppacket", "octacket", "lookacket", "payeter", "creatacket", "bucket", "packata", " packacket", "packageest", "packpet", "packedet", "creatpet", "makeset", "packageeter", "paypet", "Packata", "ppant", "buckacket", "makeacket", "packageet", "plets", "octpet", "packets"]}}
{"project": "qemu", "commit_id": "7d6b1daedd00b35e50ce87ea835f662b36a23160", "target": 0, "func": "static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n", "idx": 18597, "substitutes": {"env": ["proc", " environment", "config", "end", "sv", "en", "vs", "obj", "cb", " st", "e", "buf", "txt", "v", "param", "ev", "stack", "code", "context", "db", "environment", "uv", "w", " e", "pe", "scope", "dev", "Ev"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n", "idx": 18598, "substitutes": {"length": ["url", "pad", "type", "block", "th", "offset", "Len", "Length", "bus", "h", "ength", "size", "term", "position", "buffer", "len", "duration", "padding", "pp", "phy", "head", "loc", "kind", "load", "address", "ENGTH", "lp", "message", "height", "l", "path", "sp", "time", "total", "history", "family", "other", "full", "data", "count", "lib", "command", "ptr", "range", "name", "p"], "proto": ["protpro", " proTo", "Propro", "ProTo", " prob", "protTo", "propro", "portTo", "protto", "protb", "portpro", "Proto", "portto", "proTo", "Prob", "prob"], "addrs": ["Addr", "ads", " addr", "adrs", "adds", " adds", "adls", "adresses", "addls", "Addresses", "attls", "Addrs", "Adds", "atts", " addls", " addresses", "adr", "addresses", "addr", "attresses", "attrs"], "buf": ["window", "cv", "block", "box", "br", "pkg", "vec", "Buff", "xff", "port", "batch", "buffer", "cap", "Buffer", "cp", "rb", "bytes", "np", "cb", "pb", "arr", "b", "uf", "alloc", "data", "cur", "mem", "seq", "msg", "raw", "buff", "bin", "pack", "ptr", "queue", "addr", "p"]}}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n", "idx": 18614, "substitutes": {"env1": ["environment2", "door2", "engine2", "dooronce", "env0", " env2", "env2", "en001", "door1", "engine1", "v1", "door001", "environment0", "engineOne", "en1", "v0", " env8", "envOne", "envonce", "environment8", " env0", "vOne", "environment1", "env001", " env001", "v2", "enonce", "v8", " envonce", "engine0", " envOne", "en2", "env8"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void ppc_hw_interrupt (CPUPPCState *env)\n\n{\n\n    int raised = 0;\n\n\n\n#if 1\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                __func__, env, env->pending_interrupts,\n\n                env->interrupt_request, msr_me, msr_ee);\n\n    }\n\n#endif\n\n    /* Raise it */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        /* External reset / critical input */\n\n        /* XXX: critical input should be handled another way.\n\n         *      This code is not correct !\n\n         */\n\n        env->exception_index = EXCP_RESET;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        raised = 1;\n\n    }\n\n    if (raised == 0 && msr_me != 0) {\n\n        /* Machine check exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n            env->exception_index = EXCP_MACHINE_CHECK;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n            raised = 1;\n\n        }\n\n    }\n\n    if (raised == 0 && msr_ee != 0) {\n\n#if defined(TARGET_PPC64H) /* PowerPC 64 with hypervisor mode support */\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            env->exception_index = EXCP_HDECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);\n\n            raised = 1;\n\n        } else\n\n#endif\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            env->exception_index = EXCP_DECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            raised = 1;\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->exception_index = EXCP_40x_PIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            raised = 1;\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->exception_index = EXCP_40x_FIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            raised = 1;\n\n        /* Watchdog timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->exception_index = EXCP_40x_WATCHDOG;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            raised = 1;\n\n        /* External interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            env->exception_index = EXCP_EXTERNAL;\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            raised = 1;\n\n#if 0 // TODO\n\n        /* Thermal interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->exception_index = EXCP_970_THRM;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            raised = 1;\n\n#endif\n\n        }\n\n#if 0 // TODO\n\n    /* External debug exception */\n\n    } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->exception_index = EXCP_xxx;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        raised = 1;\n\n#endif\n\n    }\n\n    if (raised != 0) {\n\n        env->error_code = 0;\n\n        do_interrupt(env);\n\n    }\n\n}\n", "idx": 18619, "substitutes": {"env": ["org", "cv", "cache", "er", "init", "stage", "gear", "etc", "vs", "event", "e", "query", "message", "dh", "v", "ctx", "req", "uv", "timer", "Environment", "answer", "ten", "proc", "equ", "entry", "eh", "dt", "rb", "net", "obj", "cb", "em", "el", "subject", "ev", "state", "context", "db", "environment", "cmd", "nv", "w", "inv", "msg", "die", "dev", "conf", "window", " environment", "ext", "end", "en", "conn", "vv", "dn", "nav", "err", "viron", "ener", "self", "manager", "buffer", "ee", "engine", "enc", "cause", "buf", "ah", "agent", "here", "txt", "era", "loader", "ve", "policy", "desc", "up", "cur", "next", "vt", "config", "shell", "ref", "info", "ov", "worker", "server", "doc", "this", "ter", "eas", "operator", "ew", "ner", "door", "ec", "exec", "erd", "addr", "start", "eng", "queue", "t", "response"]}}
{"project": "qemu", "commit_id": "23979dc5411befabe9049e37075b2b6320debc4e", "target": 0, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    struct DisasContext ctx;\n\n    struct DisasContext *dc = &ctx;\n\n    uint32_t next_page_start, org_flags;\n\n    target_ulong npc;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    qemu_log_try_set_file(stderr);\n\n\n\n    pc_start = tb->pc;\n\n    dc->env = env;\n\n    dc->tb = tb;\n\n    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;\n\n\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->jmp = 0;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->cpustate_changed = 0;\n\n    dc->abort_at_next_insn = 0;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3)\n\n        cpu_abort(env, \"Microblaze: unaligned PC=%x\\n\", pc_start);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n#if !SIM_COMPAT\n\n        qemu_log(\"--------------\\n\");\n\n        log_cpu_state(env, 0);\n\n#endif\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    do\n\n    {\n\n#if SIM_COMPAT\n\n        if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);\n\n            gen_helper_debug();\n\n        }\n\n#endif\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n                        gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        dc->clear_imm = 1;\n\n\tdecode(dc);\n\n        if (dc->clear_imm)\n\n            dc->tb_flags &= ~IMM_FLAG;\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                if (dc->tb_flags & DRTI_FLAG)\n\n                    do_rti(dc);\n\n                 if (dc->tb_flags & DRTB_FLAG)\n\n                    do_rtb(dc);\n\n                if (dc->tb_flags & DRTE_FLAG)\n\n                    do_rte(dc);\n\n                /* Clear the delay slot flag.  */\n\n                dc->tb_flags &= ~D_FLAG;\n\n                /* If it is a direct jump, try direct chaining.  */\n\n                if (dc->jmp != JMP_DIRECT) {\n\n                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (env->singlestep_enabled)\n\n            break;\n\n    } while (!dc->is_jmp && !dc->cpustate_changed\n\n         && gen_opc_ptr < gen_opc_end\n\n                 && !singlestep\n\n         && (dc->pc < next_page_start)\n\n                 && num_insns < max_insns);\n\n\n\n    npc = dc->pc;\n\n    if (dc->jmp == JMP_DIRECT) {\n\n        if (dc->tb_flags & D_FLAG) {\n\n            dc->is_jmp = DISAS_UPDATE;\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n            sync_jmpstate(dc);\n\n        } else\n\n            npc = dc->jmp_pc;\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Force an update if the per-tb cpu state has changed.  */\n\n    if (dc->is_jmp == DISAS_NEXT\n\n        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n        if (dc->is_jmp == DISAS_NEXT)\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, gen_opc_ptr - gen_opc_buf);\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n", "idx": 18620, "substitutes": {"gen_opc_end": ["gen_opC_start", "gen_opC__start", "gen_opf_end", "gen_opc_buf", "gen_opf_ends", "gen_opc__ends", "gen_opc__END", "gen_opc__end", "gen_opf_buf", "gen_opC__end", "gen_opC__END", "gen_opf_start", "gen_opC_end", "gen_opC_ends", "gen_opc_END", "gen_opc__start", "gen_opC__ends", "gen_opC_END", "gen_opc_start", "gen_opc_ends"], "pc_start": ["pc_end", "pc__begin", "proc_size", "pcitynext", "proc_start", "pc2start", "PC_step", "tc_send", "pcitystart", "pc2part", "pc_part", "PC_end", "pc_init", "pc2int", "pc7start", "PC_int", "pc_source", "tc_start", "pc__start", "pc___start", "proc_begin", "pc_int", "pc_next", "tc_source", "pc_size", "PC_start", "pc7offset", "pc2end", "pc__end", "proc_init", "pc___source", "pcitybegin", "pc7step", "PC_next", "pc__init", "pc_send", "pc_step", "pc_offset", "PC_begin", "pc7end", "PC_part", "proc_end", "PC_offset", "pc_begin", "pcityend", "pc___send"], "j": ["jump", "J", "step", "jp", "shift", "jc", "js", "i", "kj", "jj", " ii", "l", "ort", "ji", "v", "k", "n", "uj", "count", "next", "jit", "it", "ij", " jump", "ch", "z", "job"], "lj": [" lJ", "slJ", "sln", "mJ", "sljs", "lg", "lijs", "njs", "mjs", "mj", "liJ", "ljs", "ng", " ljs", " ln", "lij", "mn", "nJ", "lig", "nj", " lg", "ln", "lJ", "slj"], "ctx": ["tmp", "cf", "lc", "cv", "pkg", "ctr", "tx", "c", "ca", "cm", "xy", "abc", "fc", "parent", "cp", "jac", "np", "obj", "cb", "kt", "loc", "tc", "cu", "pc", "nc", "kw", "cc", "txt", " cp", "ct", " err", " tc", " cx", "xc", " waiter", "context", "bc", "cmd", "nt", " sc", "co", " cc", " context"], "dc": ["c", "cat", "document", "currency", "def", "drm", "dat", "pc", "wp", "cca", "mac", "api", "cmp", "dp", "central", "DC", "cr", "_", "tx", "ca", "mc", "cont", "dt", "cp", "obj", "rec", "comment", "cmd", "controller", "cs", "cfg", "admin", "tm", "condition", "disc", "cm", "css", "dim", "tc", "driver", "ci", "kw", "txt", "bc", "oc", "ctrl", "desc", "dr", "cd", "ga", "lc", "coord", "df", "fee", "fc", "rc", "dl", "draw", "func", "city", "doc", "gc", "da", "remote", "ac", "nc", "d", "cc", "ctl", "nz", "dd", "direct", "ds", "ec", "di", "exec", "design"], "next_page_start": ["next_page_size", "next_page_begin", "next_page2offset", "next_pagexlength", "next_page_end", "next_page2length", "next_pages_start", "next_pages_offset", "next_pages_begin", "next_pagexstart", "next_pagexoffset", "next_page2end", "next_page2start", "next_pages_size", "next_pages_end", "next_pages_length", "next_page_length", "next_pagexend", "next_page_offset"], "org_flags": ["org_mask", "org_flag", "org__Flags", "org_Flags", "org__mask", "pg_flags", "org__flags", " org_Flags", " org_mask", "pg_Flags", "pg_flag", " org_flag", "org__flag"], "npc": ["nnpc", "nlp", "nncc", "nnrc", "ncc", "numpc", "numcc", "nrrc", "nrpc", "nrcc", "numrc", "nrlp", "numlp", "nrc", "nnlp"], "num_insns": ["num_vsn", "num_insvs", "num_vsms", "num_invs", "num_risn", "num_asns", "num_insn", "num_insne", "num_vsns", "num_asn", "num_risns", "num_asne", "num_csns", "num_asvs", "num_inons", "num_insms", "num_inn", "num_csons", "num_inne", "num_csn", "num_risne", "num_risvs", "num_inms", "num_csms", "num_inns", "num_insons", "num_vsons"], "max_insns": ["max_inns", "max_itsns", "max_ainsxs", "max_kinsains", "max_incms", "max_presns", "max_itsn", "max_insn", "max_cinuns", "max_insons", "max_insms", "max_inuns", "max_incn", "max_kinsns", "max_ainsns", "max_presxs", "max_csns", "max_cinn", "max_presuns", "max_csn", "max_inxs", "max_cinns", "max_insxs", "max_cinons", "max_itspires", "max_csxs", "max_kinsn", "max_incns", "max_ainsn", "max_inains", "max_insuns", "max_itsains", "max_inspires", "max_insains", "max_csms", "max_ainsons", "max_presn", "max_inpires", "max_ainsuns", "max_inms", "max_inons", "max_inn", "max_kinspires", "max_incxs"], "delayed_branch": ["delayed_brranch", "delayed_trranch", "delayed_brag", "delayed_tranch", "delayed_trag", "delayed_blanch", "delayed_blranch", "delayed_blag", "delayed_frag", "delayed_blanches", "delayed_frranch", "delayed_franch", "delayed_branches", "delayed_tranches", "delayed_franches"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n", "idx": 18624, "substitutes": {"dst": ["Dest", "dmt", "gmt", "bst", "dlct", "dstr", "gstr", "bstr", " dbr", "gst", "Dbl", "Ddest", "dsest", "lbr", "lbl", " dct", "bmt", " ddest", "dlst", "Dnd", " dnd", "lst", "dlest", "best", "dest", "dlnd", "dsmt", "Dct", "dbr", " dest", "ddest", "dsstr", "ldest", " dbl", "Dst", "dct", "dnd", "Dbr", "gest", "dbl", "dsst"], "src1": [" src0", "rc1", "source2", "srcOne", "rc3", "selOne", "sel1", "rc7", "source1", "rc2", "source0", "source3", "src3", " src7", " srcOne", "rc0", "src0", " src3", "src7", "sel2", "sel7", "rcOne"], "src2": ["source7", "rc1", "source2", "ser1", "rc3", "rc7", "source1", "rc2", " src02", "source0", "source3", "src3", "rcb", "ser2", "src02", "source02", " src7", "rc0", "src0", "sourceb", " src3", "src7", "srcb", "serb", "ser0", "rc02"], "w": ["window", "hw", "sw", "h", "c", "iw", "wb", "win", "y", "p", "wx", "r", "wi", "rw", "l", "wp", "d", "m", "nw", "kw", "v", "k", "n", "wcs", "ew", "wa", "wh", "weight", "x", "W", "word", "we", "wt", "z", "wr", " W"], "i": ["is", "ik", "iri", "init", "a", "h", "y", "ip", "ami", " ii", "ims", "qi", "wi", "v", " err", "I", "o", "ii", "phi", " ti", "span", " j", "hi", "f", "iter", "iy", "ui", "\u0438", "pi", "im", "tim", "uli", "index", "vi", " pi", " wi", "mi", "multi", "p", " I", "g", " li", "gi", "ind", "chain", "ri", "xi", "ki", "cli", "ai", "li", "go", "iu", "um", " bi", "ci", "l", "sim", "m", "me", "ti", "x", "uri", "try", "at", "ij", "ski", "yi", "si", "batch", "bi", "jp", "ic", "in", "remote", "zi", "asi", "id", "ji", "gu", "b", "ei", "fi", "ix", "di", " ni", "it", "ini", "j"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 18629, "substitutes": {"bs": ["ls", "bh", "bits", "rs", "ubs", "outs", "BS", "js", "lbs", "os", "bp", "obs", "vs", "bytes", "ns", "ims", "ris", "hz", "blog", "ubis", "ts", "its", "fps", "b", "bis", "sb", "bc", "cks", "irms", "oss", "ds", "bos", "ses", "bps", "aus", "bl", "gs", "bas", "bm", "bles", "cs", "boxes", "ps", "aos", "banks", "fs", "hs", "bo", "bes"], "res": ["resource", "ber", "reg", "mer", "rs", "response", "result", "changes", "vec", "ri", "ren", "rez", "err", "Res", "rc", "report", "rem", "RES", "pr", "js", "css", "def", "os", "cons", "vre", "ro", "pas", "der", "re", "rel", "r", "pers", "resp", "ms", "gr", "rev", "rect", "expr", "rec", "pres", "ry", "reset", "sol", "stats", "req", "resy", "vals", "resolution", "pro", "results", "aux", "ress", "cs", "resh", "ps", " Res", "conf", "details", "cond", "rest", "red", "es"], "fix": ["new", "f", " apply", " call", " patch", "fail", "init", " mut", "fixes", "update", " Fix", " fixes", "err", " msg", " repair", " add", "FIX", "def", "fx", " rem", "patch", "set", "check", "call", " fixing", " edit", "force", " cond", " change", "dirty", " diff", " prefix", "prefix", " commit", " pack", "ix", "Fix", " FIX", "clean", " doc", "repair", "conf", "add"], "rebuild": ["crebuilt", "reebuilt", "reluild", "relbuilt", "rebuilder", "reuild", " rebuilt", " reuild", "rbuilt", "rbuild", "crebuild", "ryuse", "reluse", "reeconstruct", "creconstruct", "rebuilt", "rconstruct", "reconstruct", "rybuild", " reuse", "rbuilder", "reebuilder", "relbuild", "rybuilt", "reuse", "crebuilder", "reebuild", "ryuild"], "refcount_table": ["refcountredtrace", "refsize_option", "refcountabletable", "refcountsTABLE", "refcounttlist", "refsizepleoption", "refcountpletask", "refcountingdb", "refcountpletmp", "refcountingtmp", "refbalancepletrace", "refcountttotal", "refsizepletable", "refstring_table", "refcountptserver", "refbalancepletable", "refcountpleuser", "refcountabletotal", "refbalance_table", "refcountpleserver", "refcountpletrace", "refcount_type", "refstring_type", "refcountstable", "refcountpletable", "refstatingtrace", "refcountingtotal", "refount_table", "refcount1db", "refcount1trace", "refstatingdb", "refcountablelist", "refcountptoption", "refCount_array", "refCount_list", "refcount_stable", "refbalance_trace", "refcount_tab", "refcountplestable", "refcount_tmp", "refcountingtable", "refCount_TABLE", "refcountabledb", "refstatingtotal", "refcount1table", "refcount_server", "refsizeplestable", "refcount64table", "refstring64table", "refcountstab", "refstring_user", "refcount_task", "refcount_TABLE", "refsize_table", "refCount_Table", "refount_list", "refstat_db", "refcountredtmp", "refcountredtable", "refcountablearray", "refcountpletype", "refstatingtable", "refstat_table", "refcount64user", "refcount_db", "refcount_total", "refcountpleoption", "refstring64type", "refstring_task", "refCount_table", "refcountpttable", "refstat_trace", "refcount1total", "refcount_Table", "refcountptstable", "refcountabletrace", "refcountttable", "refcountsTable", "refcount_option", "refsizepleserver", "refcount_trace", "refcount64task", "refstring64task", "refsize_stable", "refount_total", "refcount_list", "refCount_tab", "refcount64type", "refcount_user", "refcount_array", "refcountingtrace", "refstat_total", "refbalancepletmp", "refcountableTABLE", "refbalance_tmp", "refstring64user", "refsize_server"], "nb_clusters": ["nb_clitors", "nb_helusters", "nb_loconents", "nb_cloci", "nb_decloci", "nb_collusters", "nb_kluster", "nb_collaves", "nb_locusters", "nb_custers", "nb_heliffs", "nb_highaves", "nb_clicas", "nb_gluster", "nb_oclicas", "nb_CLuster", "nb_highows", "nb_collocations", "nb_clannels", "nb_oclayers", "nb_clanches", "nb_klusters", "nb_ucicators", "nb_clusiffs", "nb_oclusters", "nb_klicas", "nb_blicals", "nblyclususters", "nb_commanches", "nb_commusters", "nb_commoci", "nb_Clroups", "nb_occusters", "nb_claves", "nb_clusitors", "nblyclusuers", "nblyclitors", "nblyclusters", "nb_clusanches", "nb_blusters", "nb_declusters", "nb_clamps", "nblycliffs", "nb_spliders", "nb_chicators", "nb_occiffs", "nb_oclamps", "nb_helitors", "nblycluers", "nb_declannels", "nb_heluers", "nb_oclicators", "nb_ocluster", "nb_collonents", "nb_clayers", "nb_klayers", "nb_aclocations", "nb_glicas", "nb_clocations", "nb_locows", "nb_ucanches", "nb_Clanches", "nb_ucusters", "nb_clroups", "nb_clusannels", "nb_clususters", "nb_splusters", "nb_custer", "nb_cliffs", "nb_acliders", "nb_declanches", "nb_clicals", "nb_chanches", "nb_colluster", "nb_locaves", "nblyclusiffs", "nb_combanches", "nb_Clocations", "nb_clonents", "nb_glayers", "nb_croups", "nb_Cliders", "nb_clusuers", "nb_aclicals", "nb_combuster", "nb_glusters", "nb_ucamps", "nb_combusters", "nb_occuers", "nb_cluers", "nb_clows", "nb_blocations", "nb_cluster", "nb_ciders", "nb_aclusters", "nb_chusters", "nb_Cluster", "nb_occitors", "nb_splicals", "nb_collows", "nb_CLroups", "nb_Clusters", "nb_clusoci", "nb_oclanches", "nb_CLiders", "nb_highusters", "nb_highonents", "nblyclusitors", "nb_CLusters", "nb_commannels", "nb_clicators", "nb_combocations", "nb_cliders", "nb_champs", "nb_splocations", "nb_bliders", "nb_collanches"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "bits", "g", "as", "ins", "aws", "eps", "changes", "states", "h", "sq", "xs", "js", "os", "ss", "serv", "y", "vs", "details", "ns", "obj", "ims", "spec", "ms", "ats", "l", "ts", "sys", "its", "m", "conf", "es", "b", "v", "bis", "sb", "state", "stats", "ds", "qs", "less", "ses", "sym", "S", "sam", "gs", "ssl", "results", "ys", "cs", "ps", "comm", "als", "fs", "hs", "p"], "i": ["us", "is", "bi", "gi", "ind", " di", "init", "iter", "ri", "xi", "ki", "cli", "ai", "ia", "ini", "li", "ic", "ui", "ip", "y", " ii", "pi", "iu", "qi", "u", "im", "e", " bi", "ci", "zi", "l", "sim", "m", "me", "index", "uli", "gu", "b", "v", "I", "n", "ii", "ti", "ei", "fi", "phi", "ix", "x", " ti", "di", " si", "mi", " j", "it", "hi", "ij", "t", "multi", "j", "si", "p"], "sn": ["ny", "ls", "sl", "inn", "sv", "nm", "tn", "scl", "sw", "cn", "sq", "dn", "nr", "sm", "nl", "ss", "sc", "SN", "Sn", "sbm", "nn", "syn", "ns", "sk", "wn", "sh", "sd", "sr", "sys", "pn", "sp", "txt", "n", "mn", "pres", "bn", "sb", "sf", "sol", "kn", "gn", "span", "ln", "sam", "news", "cs", "sa", "snap", "fn", "nex", "rn", "si"], "ret": ["irm", "prop", " RET", "cat", "def", "det", "RET", "out", "print", "val", "deg", "status", "rm", "plain", "url", "reg", "gt", "test", "lt", "lit", "report", "rem", "cont", "dt", "len", "net", "obj", "Return", "re", "expr", "eval", "mat", " Ret", "back", "ft", "over", "cmd", "compl", "vals", "fun", "nt", "usr", "mt", "rep", "ject", "red", "ry", "detail", "ber", "ext", "result", "err", "term", "del", "elt", "ll", "arg", "resp", "vet", "virt", "txt", "cert", "git", "rets", "alg", "last", "try", "pret", "repl", "rt", "nil", "get", "ref", "final", "fer", "jp", "not", "tr", "att", "r", "rev", "Ret", "rect", "ter", "value", "reset", "web", "alt", "format", "it"], "check_errors": ["read_stats", "read_errors", "check_stats", "checkporesults", "checkpoerrors", "read_failed", "read_results", "checkerrerrors", "check_failed", "checkerrstats", "check_results", "checkerrfailed", "checkpostats", "checkpofailed", "checkerrresults"]}}
{"project": "qemu", "commit_id": "40545f84cfcbe4b73cca040b3043a1c2de935762", "target": 1, "func": "static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    NE2000State *s = opaque;\n\n    int offset, page;\n\n\n\n    addr &= 0xf;\n\n#ifdef DEBUG_NE2000\n\n    printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val);\n\n#endif\n\n    if (addr == E8390_CMD) {\n\n        /* control register */\n\n        s->cmd = val;\n\n        if (val & E8390_START) {\n\n            s->isr &= ~ENISR_RESET;\n\n            /* test specific case: zero length transfert */\n\n            if ((val & (E8390_RREAD | E8390_RWRITE)) &&\n\n                s->rcnt == 0) {\n\n                s->isr |= ENISR_RDC;\n\n                ne2000_update_irq(s);\n\n            }\n\n            if (val & E8390_TRANS) {\n\n                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);\n\n                /* signal end of transfert */\n\n                s->tsr = ENTSR_PTX;\n\n                s->isr |= ENISR_TX;\n\n                ne2000_update_irq(s);\n\n            }\n\n        }\n\n    } else {\n\n        page = s->cmd >> 6;\n\n        offset = addr | (page << 4);\n\n        switch(offset) {\n\n        case EN0_STARTPG:\n\n            s->start = val << 8;\n\n            break;\n\n        case EN0_STOPPG:\n\n            s->stop = val << 8;\n\n            break;\n\n        case EN0_BOUNDARY:\n\n            s->boundary = val;\n\n            break;\n\n        case EN0_IMR:\n\n            s->imr = val;\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN0_TPSR:\n\n            s->tpsr = val;\n\n            break;\n\n        case EN0_TCNTLO:\n\n            s->tcnt = (s->tcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_TCNTHI:\n\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RSARLO:\n\n            s->rsar = (s->rsar & 0xff00) | val;\n\n            break;\n\n        case EN0_RSARHI:\n\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RCNTLO:\n\n            s->rcnt = (s->rcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_RCNTHI:\n\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_DCFG:\n\n            s->dcfg = val;\n\n            break;\n\n        case EN0_ISR:\n\n            s->isr &= ~(val & 0x7f);\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN1_PHYS ... EN1_PHYS + 5:\n\n            s->phys[offset - EN1_PHYS] = val;\n\n            break;\n\n        case EN1_CURPAG:\n\n            s->curpag = val;\n\n            break;\n\n        case EN1_MULT ... EN1_MULT + 7:\n\n            s->mult[offset - EN1_MULT] = val;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 18640, "substitutes": {"opaque": [" Opsole", "iopacity", " opsole", "paque", " opane", " opatile", "opatile", "OPane", "opacity", "iopane", "OPaque", " opque", "opane", "iopque", "pque", "opque", " opacity", "pane", "pacity", "opsole", " Opane", "OPsole", " Opatile", " Opaque", "OPatile", "iopaque"], "addr": ["url", "pad", "alias", "coord", "amp", "attr", "ref", "host", "pkg", "map", "clock", "tx", "point", "err", "eth", " address", "ad", "order", "pos", "aff", "loc", "align", "set", "address", "arr", "buf", "Address", "rev", "id", "index", "ack", "sp", "off", "v", "var", "ord", "ctx", "gate", "env", "inter", "alloc", "cmd", "db", "md", "ix", "phys", "link", "alt", "req", "prefix", "mem", "x", "seek", "dr", "adr", "start", "ptr", "at", "ace", "mt", "tag", "hash", "add", "name"], "val": ["block", "xy", "def", "al", "lv", "ul", "vol", "pol", "v", "var", "ctx", "print", "req", "mem", "status", "find", "sel", "cmp", "hash", "url", "extra", "bit", "reg", "tx", "test", "Val", "VAL", "ret", "values", "style", "serv", "len", "obj", "hz", "eval", "index", "el", "comment", "empty", "vals", "msg", "bl", "ival", "tag", "dev", "mod", "conf", "p", "slot", "pal", "fail", "point", "valid", "buffer", "byte", "cal", "elt", "util", "orig", "arg", "resp", "buf", "pt", "txt", "x", "vt", "bo", "crit", "cho", "always", "ref", "bool", "res", " value", "item", "value", "call", "Value", "volt", "str", "data", "alt", "exec", "aval", "it", "bin", "stat"], "s": ["is", "as", "states", "h", "c", "sm", "js", "i", "store", "ies", "y", "vs", "details", "tes", "stats", "qs", "ses", "status", "less", "flags", "comments", "als", "terms", "bits", "aws", "sw", "xs", "des", "ss", "serv", "grades", "ns", "obj", "spec", "session", "ms", "actions", "parts", "bis", "services", "an", "S", "results", "cs", "conf", "sis", "hs", "p", "sl", "sts", "rs", "ops", "sq", "service", "ads", "os", "ess", "set", "pers", "l", "m", "mods", "sb", "sol", "x", "gs", "ssl", "ows", "comm", "tags", "bs", "ys", "ls", "sv", "ins", "changes", "settings", "search", "params", "r", "ats", "sync", "ts", "sys", "its", "d", "b", "se", "ds", "sam", "stat", "ps", "items", "t", "fs", "j", "es"], "offset": ["window", "pad", "alias", "type", "end", "location", "slot", "update", "shift", "part", "oe", "onet", "point", "tab", "pointer", "size", "oint", "Offset", "position", "style", "mask", "ot", "order", "error", "pos", "line", "set", "address", "index", "sp", "off", "row", "o", "out", "area", "key", "option", "slice", "trace", "prefix", "seek", "count", "next", "et", "op", "bound", "command", "start", "tz", "oid", "range", "timeout"], "page": ["pad", "window", "block", "ref", "slot", "result", "hop", "point", "tab", "pointer", "port", "position", "buffer", "phase", "order", "ip", "pos", "net", "pp", "line", "address", "message", "cycle", "index", "row", "Page", "code", "total", "cmd", "pg", "seek", "count", "next", "frame", "mark", "loop", "number", "age", "node", "base", "limit", "ptr", "range", "step", "p"]}}
{"project": "FFmpeg", "commit_id": "0a359cf157957f3eb37760f731fa75dd320fd659", "target": 0, "func": "static int vc1_filter_line(uint8_t* src, int stride, int pq){\n\n    int a0, a1, a2, a3, d, clip, filt3 = 0;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n\n    if(FFABS(a0) < pq){\n\n        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;\n\n        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;\n\n        a3 = FFMIN(FFABS(a1), FFABS(a2));\n\n        if(a3 < FFABS(a0)){\n\n            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;\n\n            clip = (src[-1*stride] - src[ 0*stride])/2;\n\n            if(clip){\n\n                filt3 = 1;\n\n                if(clip > 0)\n\n                    d = av_clip(d, 0, clip);\n\n                else\n\n                    d = av_clip(d, clip, 0);\n\n                src[-1*stride] = cm[src[-1*stride] - d];\n\n                src[ 0*stride] = cm[src[ 0*stride] + d];\n\n            }\n\n        }\n\n    }\n\n    return filt3;\n\n}\n", "idx": 18646, "substitutes": {"src": ["bb", "bh", "sn", "usc", "stream", "syn", "np", "inst", "scan", "req", "http", "supp", "cmp", "tp", "proc", "url", "act", "st", "sw", "sec", "iter", "sur", "cont", "rb", "obj", "impl", "spec", "ur", "sr", "sort", "stock", "secure", "hl", "source", "usr", "input", "sl", "ser", "rs", "pkg", "sq", "ipl", "rl", "conv", "iv", "load", "loc", "stab", "txt", "sb", "cur", "seq", "raw", "aux", "ssl", "via", "rt", "config", "ins", "ctr", "scene", "rc", "ck", "sc", "img", "r", "sync", "sys", "dest", "str", "vc", "lib", "it", "bin", "stat"], "stride": ["scopeuse", "Stride", "slpace", "STRiden", "struster", " stripe", "drider", "provider", "voluster", "intider", "STRice", " strade", "stringipe", "STRipe", "stine", "stension", "stripe", "STRade", "brride", "instipe", "Strride", "stickider", "grine", "volider", "privipe", "volide", "stickide", "sline", "slision", "grride", "STRride", "gride", "intride", "stope", "frride", "intine", "slride", "STRope", "frade", " strice", "provide", "drilege", "instride", "intice", " strride", "stringride", "scopeuit", "specice", "strension", "striide", "drride", "statusope", "arrider", "privride", "volope", "strade", "volice", "stision", "slension", "provension", "arride", "striope", "formide", "privension", "stice", "drension", "struse", "strilege", "specider", " strine", "scopeide", "drine", "drision", "stide", "strice", " struse", "provice", "divipe", "divider", "stringiden", "slipe", "slilege", "stider", "divride", "instide", "dride", "stickope", "divide", "specride", "divine", "intipe", "arrride", "specipe", "striuster", "Strade", "STRension", "bripe", "specide", "stilege", "stade", "intpace", "strider", "gripe", "bride", "struit", "striider", "strine", "provipe", "statuside", "drice", "specade", " struit", "STRider", "STRide", "formride", "specpace", "slide", "strope", "instiden", "STRuse", "strision", "formope", "fride", "scopeine", "STRine", "formider", "intide", "statusider", "provride", "STRuit", "arrice", "slice", "stringide", "strride", "statususter", " strider", "brice", "Strider", "privide", "frider", "slider", "strpace", "divice", "stickride", "volride", "striden"], "pq": ["pqu", "pQ", "vpq", " pQ", " pue", "tpq", "pqt", "cpqt", "pqi", "cpQ", "PQ", "tpqi", "tpue", "cpue", " pqi", "pue", " pqt", "Pq", "vpqi", "Pue", "vpue", "tpqu", "Pqt", "vpqu", "cpq", " pqu"], "a0": ["e03", "ba7", "ga1", "e2", "a4", " a4", "ga0", "ga2", "aa00", "aa7", "sha00", "e0", "a7", "A8", "ao3", "A0", "e1", "A2", "ba000", "ga000", "A7", "aa000", "aa2", "ao1", "ba2", "ga00", "e3", " a8", " a7", "A1", "a03", "ga3", "a000", "aa1", "ga03", "sha0", "ao0", "aa0", "A4", "ba0", "ga7", "ao03", "aa4", "a00", "a8", "aa8"], "a1": ["a001", " a01", "aa01", "element2", "as7", "a81", "a01", "a7", "A11", "aa001", "A0", " a001", "element81", "A2", "a11", "aa2", "A81", " a81", "as001", "as01", " a7", "A1", "element1", "element0", "aa1", "as1", "A01", " a11", "aa11", "aa7"], "a2": ["a4", "a82", "ga2", "ga0", " a4", "auTwo", "A8", "A0", " a5", "pa4", "A2", "pa2", "au02", "ao02", "ga4", "ga8", "ao2", "ga02", "A02", "aTwo", " a8", "pa82", "ATwo", " a82", "ga82", "a5", " a02", "pa5", "au2", "ga5", "a8", "aoTwo", "a02"], "a3": ["e2", "aa883", " a03", " a53", "u3", "aa03", "a4", " a4", "u1", "aa003", "a6", " a23", " a883", "aa23", "ao53", "A53", "au3", "a003", "au0", "ao3", "au15", " a5", "e1", "A2", "ao15", "u53", "ga23", "au53", " a6", "u6", "ga003", "ao1", "e3", "a23", "a883", "A1", "A3", "a03", "ga3", "aa1", "a15", "ao0", "A6", "aa3", "a5", "a53", " a15", "ao03", "A4", " a003", "e4", "ga5", "ao883", "aa5"], "d": ["fd", "f", "done", "pad", "length", "g", "dra", "gd", "dx", "result", "ind", "a", "bd", "h", "nd", "c", "std", "delay", "dl", "ed", "draw", "ad", "q", "dt", "dim", "diff", "del", "D", "dist", "debug", "sd", "dat", "da", "dir", "r", "dh", "l", "m", "id", "b", "ord", "n", "dd", "dom", "db", "data", "de", "ds", "di", "dr", "z", "dev", "dig", "t", "mod", "dc", "add", "p"], "clip": ["close", "pad", "high", "offset", "scroll", "tile", "filter", " Clip", "crop", "peak", "copy", "lock", "mp", "mask", "clone", "cap", "grab", "scale", "cp", "comp", "split", "ip", "diff", "sc", "low", "keep", "pl", "deep", "tip", "max", "check", "grow", "l", "progress", "zero", "cut", "id", "sp", "drop", "cl", "zip", "client", "b", "clips", "skip", "near", "sound", "slice", "lim", "pop", "seek", "strip", "ape", "loop", "just", "pro", "pe", "lip", "op", "limit", "tif", "stop", "snap", "supp", "ps", "cmp", " clipped", "dc", "z", "sup"], "cm": ["irm", "tm", "fine", "cv", "lc", "px", "nm", "mr", "cam", "crop", "c", "mm", "ca", "fc", "com", "mp", "wm", "asm", "fr", "cont", "cp", "sc", "cb", "tc", "um", "dm", "ram", "pm", "ci", "stab", "m", "cut", "vm", "cl", "fm", "cms", "mn", "gm", "tk", "bm", "CM", "mb", "ch", "co", "conf", "dc"]}}
{"project": "FFmpeg", "commit_id": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb", "target": 0, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n                      int src_count, int src_size, int dest_len)\n\n{\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            return 0;\n\n        *pd++ = bytestream2_get_byteu(&gb);\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            break;\n\n        l = bytestream2_get_byteu(&gb);\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)\n\n                return bytestream2_tell(&gb);\n\n            bytestream2_get_bufferu(&gb, pd, l);\n\n            pd += l;\n\n        } else {\n\n            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)\n\n                return bytestream2_tell(&gb);\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n            }\n\n            bytestream2_skip(&gb, 2);\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return bytestream2_tell(&gb);\n\n}\n", "idx": 18648, "substitutes": {"src": ["tmp", "from", "attr", "rs", "st", "ins", "ctr", "ind", "sn", "sq", "rc", "sur", "cont", "sc", "sub", "img", "iv", "loc", "inst", "sr", "buf", "scan", "sys", "txt", "bg", "sb", "str", "bin", "source", "addr", "usr", "input", "ptr", "sel", "sh", "rest", "name", "sup"], "dest": ["Dest", "to", "tmp", "sum", "attr", "end", "gt", "st", "sv", "result", "init", "trans", "test", "temp", "lit", "origin", "size", "port", "self", "cont", "cp", "gc", "master", "way", "home", "dist", "orig", "target", "max", "loc", "rw", "est", "id", "sp", "txt", "v", "priv", "out", "gate", "through", "desc", "bin", "gen", "source", "start", "usr", "ptr", "dev", "dc", "rest", "decl"], "src_count": ["rc_length", "source_size", "srcitycoll", "src_sum", "rc_sum", "src2size", "src_only", "src00size", "srcitylength", "src00count", "rc_count", "src_Count", "src2length", "src_coll", "rc_size", "source_only", "src2count", "src_length", " src_coll", "src2coll", "src00length", "source_count", " src_Count", "srcitysize", "src00only", "srcitycount", "source_length", " src_length"], "src_size": ["src_len", "dest_count", "src_scale", "dest_scale", " src_len", "src_length", " src_length", "dest_size"], "dest_len": ["dest___length", "source_size", "source_len", "dest_num", "dest_length", "Dest_size", "Dest_len", "dest___end", "dest___len", "source_num", "dest___size", "Dest_length", "source_length", "Dest_end", "dest_size"], "pd": ["fd", "tmp", "px", "pat", "ht", "xd", "hd", "ind", "bd", "wd", "edd", "ld", "td", "cli", "dl", "ed", "pr", "ud", "li", "dt", "cp", "pp", "np", "pread", "pi", "pb", "PD", "pl", "sd", "php", "lp", "pm", "ci", "pc", "pdf", "wp", "pt", "d", "pid", "pn", "pod", "vp", "dd", "po", "md", "phi", "db", "ds", "pard", "ln", "py", "pe", "ssl", "isd", "ptr", "ps", "ped", "dp", "por", "tp", "cd", "p"], "i": ["is", "bi", "gi", "in", "ind", "a", "c", "ri", "xi", "ki", "cli", "ai", "dl", "iy", "li", "ui", "ic", "ip", "y", "io", "ish", " ii", "\u0438", "ims", "pi", "iu", "qi", "u", "pl", "im", "e", "zi", "ci", "lp", "me", "d", "m", "index", "id", "b", "v", "I", "o", "n", "ii", "ti", "s", "ei", "phi", "ix", "x", "status", "di", "it", "mi", "hi", "ij", "lo", "ini", "multi", "j", "si", "p"], "l": ["f", "ls", "sl", "lc", "length", "fl", "tl", "g", "c", "lt", "kl", "h", "lit", "dl", "lf", "rl", "nl", "le", "li", "ml", "len", "lin", "al", "loc", "ll", "isl", "pl", "u", "dL", "lv", " L", "lp", "ul", "list", "m", "d", "el", "b", "v", "n", "lu", "o", "hl", "s", "lb", "lang", "ol", "ly", "ln", "lis", "limit", "lo", "la", "il", "L", "t", "ld", "z", "j", "p"], "dest_end": ["src_loc", "dest2end", "dest2last", "dest__end", "dest__max", "target_begin", "target_stop", "target_size", "dest_max", "destvalmax", "result_max", "resultvalended", "destvalended", "dest2start", "destzstart", "resultvalend", "dest_edge", "dest_stop", "resultvaledge", "dest_ended", "dest_loc", "destzend", "destvalend", "dest_begin", "resultvalmax", "result_end", "destzloc", "dest_start", "target_end", "src_last", "src_end", "dest__edge", "dest_last", "result_ended", "result_edge", "destvaledge", "destzlast", "src_start", "dest_size", "dest2loc", "dest__ended"], "gb": ["nb", "tmp", "bridge", "bb", "cv", " rg", "g", "sv", "gd", "gt", "gram", "GB", "tg", "bd", " db", "vd", "wb", "gp", " pg", "gin", "json", "gom", "rb", "bp", "sg", "rg", "img", "gc", "cb", " rgb", "pb", "ubis", "gif", "lp", "sys", "gu", "vm", "gz", "eg", "bg", "hub", "Gb", "uf", "sb", "gm", "git", "kb", "db", "gov", "pg", "gn", "gpu", "storage", "gg", " GB", "lib", "ds", "py", "gs", "sky", "ssl", "bf", "csv", "mb", "ruby", "cfg"]}}
{"project": "FFmpeg", "commit_id": "1dff9adcb934175fe1beb14ee139ad0636daa29d", "target": 0, "func": "static int recheck_discard_flags(AVFormatContext *s, int first)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i, changed = 0;\n\n\n\n    /* Check if any new streams are needed */\n\n    for (i = 0; i < c->n_playlists; i++)\n\n        c->playlists[i]->cur_needed = 0;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n\n        if (st->discard < AVDISCARD_ALL)\n\n            pls->cur_needed = 1;\n\n    }\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->cur_needed && !pls->needed) {\n\n            pls->needed = 1;\n\n            changed = 1;\n\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n            pls->pb.eof_reached = 0;\n\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n\n                /* catch up */\n\n                pls->seek_timestamp = c->cur_timestamp;\n\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n\n                pls->seek_stream_index = -1;\n\n            }\n\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n\n        } else if (first && !pls->cur_needed && pls->needed) {\n\n            if (pls->input)\n\n                ff_format_io_close(pls->parent, &pls->input);\n\n            pls->needed = 0;\n\n            changed = 1;\n\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n\n        }\n\n    }\n\n    return changed;\n\n}\n", "idx": 18649, "substitutes": {"s": ["f", "ls", "is", "sts", "ks", "sv", "rs", "g", "as", "ins", "aws", "changes", "simple", "south", "a", "sq", "h", "ares", "js", "self", "os", "ss", "sc", "sg", "p", "ns", "ims", "r", "ms", "ats", "sync", "ts", "sys", "its", "acs", "b", "n", "o", "parts", "sb", "eds", "ar", "cmd", "stats", "ds", "qs", "ses", "less", "S", "gs", "cs", "csv", "ps", "t", "bs", "conf", "fs", "hs", "es"], "first": ["present", "new", "f", "irst", "actual", "all", "initial", "second", "use", "self", "same", "bool", "prev", "fr", "must", "top", "master", "commit", "now", "accept", "third", "force", "before", "fast", "primary", "empty", "full", "count", "next", "success", "forced", "last", "required", "format", "current", "start", "First", "only", "isc", "FIR", " FIRST", "cond", "each"], "c": ["f", "cf", "lc", "cv", "cr", "g", "cache", "cn", "C", "ca", "cm", "fc", "rc", "abc", "com", "mc", "cont", "sc", "cp", "comp", "conv", "etc", "gc", "cb", "u", "tc", "enc", "cu", "r", "ci", "ac", "this", "l", "nc", "con", "m", "cc", "b", "v", "ctx", "ct", "n", "wcs", "bc", "xc", "ar", "ce", "vc", "coll", "cur", "ec", "comments", "cs", "comm", "t", "co", "conf", "dc", "cd", "p"], "i": ["is", "iri", "init", "h", "y", "ip", "iat", "ami", " ii", "ims", "qi", "v", " err", "I", "ii", "print", "phi", " j", "hi", "t", "iter", "json", "ui", "\u0438", "pi", "u", "im", "index", "client", "mi", "ie", "iq", "multi", "p", "to", " I", "g", " li", "gi", "ind", "chain", "ri", "xi", "point", "ki", "cli", "ai", "li", "go", "iu", "ci", "my", "l", "sim", "m", "me", "ti", "x", "uri", "try", "at", "ij", "ski", "si", "batch", "get", "bi", "info", "ic", "in", "remote", "zi", "any", "list", "id", "ji", "gu", "n", "ei", "fi", "ix", "di", "it", "ini", "j", "oi"], "st": ["sl", "irst", "ost", "th", "sts", "cr", "tt", "sn", "sw", "ste", "std", "sm", "stage", "sta", "store", "ss", "sc", "tr", "sth", "inst", "set", "St", "est", "sp", "ST", "se", "ct", "be", "ft", "sty", "str", "ast", "et", "storage", "ust", "sam", "start", "mt", "stable", "t", "sh", "rest", "step", "ist"], "pls": ["ptts", "llits", "pll", "patgs", "plys", "patxs", "palgs", "plugongs", "Pls", "pats", "clds", "lls", "sples", "plds", "complgs", " pll", "spljs", "plits", " plns", "pljs", "plls", "PLts", "palges", " plds", "splongs", "plm", "ptes", " plls", "plges", " plits", "splgs", "splm", "paljs", "splts", " ples", "plysys", "PLs", "replxs", "splxs", " plts", "pps", "clgs", "palts", "pts", " plis", "plss", "ples", "plts", "plyjs", "plugs", "palds", "replds", "splds", "spls", "plgs", "ppjs", "patges", "ppl", "palongs", " plgs", "compls", "pals", "flds", "plis", "Pljs", "plves", "ptls", "splis", "ppts", "plxs", " plss", "palns", "splns", "patongs", "clves", "PLis", "patss", " pljs", "splsys", "prds", " plm", "plns", "spll", "prs", "plongs", "plsys", "splls", "clls", "ptm", "patts", "fls", "flts", "repls", "prgs", "cls", "compljs", "cljs", "prls", "Plts", "patis", "plugis", "plugges", "patds", "llgs", "plyves", "palis", "clsys", "PLgs", "Plgs", "ptgs", "patits", "splves", "flss", "PLds"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_transfer(int tpm_fd,\n\n                                         const TPMLocality *locty_data)\n\n{\n\n    return tpm_passthrough_unix_tx_bufs(tpm_fd,\n\n                                        locty_data->w_buffer.buffer,\n\n                                        locty_data->w_offset,\n\n                                        locty_data->r_buffer.buffer,\n\n                                        locty_data->r_buffer.size);\n\n}\n", "idx": 18673, "substitutes": {"tpm_fd": ["tmm_stream", "tpm__id", "tmm_fd", "tpm_pid", "tpm_fin", "tpm__fp", "tmm_pid", "tpm__stream", "tmm_fin", "tmm_id", "tpm_stream", "tpm__pid", "tpm_fp", "tmm_fp", "tpm_id", "tpm__fin", "tpm__fd"], "locty_data": ["locty0extra", "loctY_data", "locty0dat", "loctY_dat", "loctyy_vals", "loctY_rel", "locty__rel", "loctory_buffer", "locty0data", "locty_Data", "locto_Data", "loctory_dat", "loctory_data", "loctyy_data", "locto_results", "locty__data", "locty_extra", "loctyy_extra", "loctiy_result", "locty_default", "locty_buffer", "loctiy_Data", "loctiy_data", "loctyy_dat", "loctory_extra", "locty_dat", "locty__dat", "locty_result", "locty_rel", "loctiy_default", "locto_data", "locty0vals", "locty_results", "locty_vals"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n", "idx": 18675, "substitutes": {"flags": ["levels", " Flags", "bugs", "bits", " bits", "ints", "products", "planes", "ages", "settings", "limits", "reports", "aps", "ports", "mask", "func", "links", "lines", "properties", "workers", "grades", "pins", "lands", "pants", "ags", "flag", "types", "forces", "ms", "ents", "Flags", "xxx", "allows", "ts", "locks", "fps", "options", "weights", "members", "issues", "oos", "parts", "days", "lag", "FLAG", "faces", "frames", "atts", "packages", "stats", "vals", "files", " fps", "posts", "comments", "features", "fs", "cond", "terms"]}}
{"project": "qemu", "commit_id": "f85da3081d001909929a19e530e69cea0487f00e", "target": 1, "func": "void sh4_translate_init(void)\n\n{\n\n    int i;\n\n    static const char * const gregnames[24] = {\n\n        \"R0_BANK0\", \"R1_BANK0\", \"R2_BANK0\", \"R3_BANK0\",\n\n        \"R4_BANK0\", \"R5_BANK0\", \"R6_BANK0\", \"R7_BANK0\",\n\n        \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\n\n        \"R0_BANK1\", \"R1_BANK1\", \"R2_BANK1\", \"R3_BANK1\",\n\n        \"R4_BANK1\", \"R5_BANK1\", \"R6_BANK1\", \"R7_BANK1\"\n\n    };\n\n    static const char * const fregnames[32] = {\n\n         \"FPR0_BANK0\",  \"FPR1_BANK0\",  \"FPR2_BANK0\",  \"FPR3_BANK0\",\n\n         \"FPR4_BANK0\",  \"FPR5_BANK0\",  \"FPR6_BANK0\",  \"FPR7_BANK0\",\n\n         \"FPR8_BANK0\",  \"FPR9_BANK0\", \"FPR10_BANK0\", \"FPR11_BANK0\",\n\n        \"FPR12_BANK0\", \"FPR13_BANK0\", \"FPR14_BANK0\", \"FPR15_BANK0\",\n\n         \"FPR0_BANK1\",  \"FPR1_BANK1\",  \"FPR2_BANK1\",  \"FPR3_BANK1\",\n\n         \"FPR4_BANK1\",  \"FPR5_BANK1\",  \"FPR6_BANK1\",  \"FPR7_BANK1\",\n\n         \"FPR8_BANK1\",  \"FPR9_BANK1\", \"FPR10_BANK1\", \"FPR11_BANK1\",\n\n        \"FPR12_BANK1\", \"FPR13_BANK1\", \"FPR14_BANK1\", \"FPR15_BANK1\",\n\n    };\n\n\n\n    for (i = 0; i < 24; i++) {\n\n        cpu_gregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, gregs[i]),\n\n                                              gregnames[i]);\n\n    }\n\n    memcpy(cpu_gregs + 24, cpu_gregs + 8, 8 * sizeof(TCGv));\n\n\n\n    cpu_pc = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pc), \"PC\");\n\n    cpu_sr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, sr), \"SR\");\n\n    cpu_sr_m = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_m), \"SR_M\");\n\n    cpu_sr_q = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_q), \"SR_Q\");\n\n    cpu_sr_t = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_t), \"SR_T\");\n\n    cpu_ssr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, ssr), \"SSR\");\n\n    cpu_spc = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, spc), \"SPC\");\n\n    cpu_gbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, gbr), \"GBR\");\n\n    cpu_vbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, vbr), \"VBR\");\n\n    cpu_sgr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, sgr), \"SGR\");\n\n    cpu_dbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, dbr), \"DBR\");\n\n    cpu_mach = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, mach), \"MACH\");\n\n    cpu_macl = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, macl), \"MACL\");\n\n    cpu_pr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pr), \"PR\");\n\n    cpu_fpscr = tcg_global_mem_new_i32(cpu_env,\n\n                                       offsetof(CPUSH4State, fpscr), \"FPSCR\");\n\n    cpu_fpul = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, fpul), \"FPUL\");\n\n\n\n    cpu_flags = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t       offsetof(CPUSH4State, flags), \"_flags_\");\n\n    cpu_delayed_pc = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t\t    offsetof(CPUSH4State, delayed_pc),\n\n\t\t\t\t\t    \"_delayed_pc_\");\n\n    cpu_delayed_cond = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State,\n\n                                                       delayed_cond),\n\n                                              \"_delayed_cond_\");\n\n    cpu_ldst = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t      offsetof(CPUSH4State, ldst), \"_ldst_\");\n\n\n\n    for (i = 0; i < 32; i++)\n\n        cpu_fregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, fregs[i]),\n\n                                              fregnames[i]);\n\n}\n", "idx": 18696, "substitutes": {"i": [" n", " I", "bi", " my", "gi", "ind", " pos", " mi", "c", "ri", "xi", "ki", "ex", "cli", "ai", "ini", "oi", " v", "li", "ui", "y", "ip", "in", "\u0438", " ii", "p", "io", "pi", "iu", " t", "qi", " bi", "ci", "zi", "sim", "m", "asi", "me", "ji", "gu", " pi", "index", "v", " err", "I", " c", "n", "o", "ii", "ti", "phi", "ix", " l", "x", " ti", " x", " m", "di", " p", "it", "mi", " j", " multi", "status", "ij", "iq", "t", "ski", "multi", "z", "j", "si", "batch"], "gregnames": ["ggs", "ggname", "regNames", "gallname", "gallnames", "gcNames", "gregfiles", "regfiles", "ggnames", "gcs", "gregs", "regs", "gcnames", "ggfiles", "gallcodes", "gregNames", "regnames", "gregcodes", "ggNames", "ggcodes", "gallNames", "gcfiles", "gregname", "regname", "regcodes"], "fregnames": ["ggregcodes", "freccodes", "ggregtypes", "fregistercodes", "fregtypes", "gregtypes", "fgregNames", "fgregcodes", "fregisterNames", "fgregtypes", "fgregnames", "ggregnames", "ggregNames", "gregNames", "gregcodes", "fregNames", "fregcodes", "fregistertypes", "frecNames", "frectypes", "fregisternames", "frecnames"]}}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    st = av_new_stream(oc, 1);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not alloc stream\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* find the MP2 encoder */\n\n    codec = avcodec_find_encoder(codec_id);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n    c = &st->codec;\n\n    c->codec_type = CODEC_TYPE_AUDIO;\n\n\n\n    /* put sample parameters */\n\n    c->bit_rate = 64000;\n\n    c->sample_rate = 44100;\n\n    c->channels = 2;\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* init signal generator */\n\n    t = 0;\n\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n\n\n\n    audio_outbuf_size = 10000;\n\n    audio_outbuf = malloc(audio_outbuf_size);\n\n\n\n    /* ugly hack for PCM codecs (will be removed ASAP with new PCM\n\n       support to compute the input frame size in samples */\n\n    if (c->frame_size <= 1) {\n\n        audio_input_frame_size = audio_outbuf_size / c->channels;\n\n        switch(st->codec.codec_id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            audio_input_frame_size >>= 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    } else {\n\n        audio_input_frame_size = c->frame_size;\n\n    }\n\n    samples = malloc(audio_input_frame_size * 2 * c->channels);\n\n\n\n    return st;\n\n}\n", "idx": 18700, "substitutes": {"oc": ["ost", "ok", "osc", "ax", "OC", "anc", "fc", "rc", "os", "ot", "wo", "WC", "voc", "ic", "etc", "loc", "soc", "unc", "ac", "pc", "nc", "oco", "cc", "o", "ocol", "ocr", "mic", "bc", "oci", "ive", "toc", "vc", "ec", "vo", "op", "ob", "irc", "og", "co", "roc"], "codec_id": ["codpeg_ident", "codecNameid", "codpeg_type", "codpeg_no", "codec_oid", "codecNameinfo", "codec_class", "codpeg_info", "codec_no", "codecNameno", "codecOno", "codec_name", "codoc_oid", "codoc_class", "codecOid", "codpeg_name", "codoc_type", "codec_type", "codecOident", "codec_ident", "codecNameident", "codpeg_id", "codec_info", "codoc_id", "codecOinfo"], "codec": ["choc", " codenc", "dpeg", "odEC", "codeca", " codoc", "codet", " cododer", "odica", "odek", "codpeg", "codek", "ctoder", "odeca", "codica", "octec", " codEC", "chet", "chek", "codoc", "ctoc", "ctec", "staeca", "codecon", "Cododer", "Codec", "CodEC", "ctef", "codesc", "oddec", "codeec", " codesc", " codpeg", "Coddec", "coddec", "odet", "Codek", "Codoc", "odec", "octenc", "staec", "staenc", " coddec", "octeca", "odoc", "codeesc", "odenc", "codepeg", "octica", "condoder", "condec", "codef", "Codenc", "staica", "codenc", "desc", "dcon", "ododer", "chec", "codcon", "condoc", "codEC", "Codet", "cododer", " codef", " codcon", "odef", "condEC"], "c": ["f", "cf", "lc", "cv", "cmp", "config", "g", "cache", "chain", "C", "ca", "content", "cm", "fc", "rc", "abc", "com", "anc", "icc", "mc", "cont", "ic", "cp", "comp", "conv", "etc", "gc", "cb", "loc", "tc", "enc", "cu", "form", "ci", "can", "ac", "pc", "l", "m", "con", "cc", "b", "ctx", "v", "ct", "o", "bc", "xc", "ce", "vc", "coll", "col", "ec", "cod", "lib", "cs", "ch", "comm", "t", "co", "conf", "dc", "z", "p"], "st": ["new", "f", "rt", "sl", "irst", "tmp", "ost", "th", "sts", "tt", "sv", "sn", "sw", "so", "a", "h", "ste", "std", "nd", "stage", "stream", "sta", "store", "fr", "sc", "sth", "p", "ut", "inst", "set", "src", "r", "St", "est", "l", "ts", "d", "sp", "v", "ST", "se", "ct", "stack", "ctx", "s", "str", "ast", "storage", "ust", "art", "w", "it", "stop", "stan", "start", "stable", "mt", "t", "sh", "rest", "step", "ist"]}}
{"project": "FFmpeg", "commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "target": 1, "func": "static av_cold int libopenjpeg_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibOpenJPEGContext *ctx = avctx->priv_data;\n\n    int err = AVERROR(ENOMEM);\n\n\n\n    opj_set_default_encoder_parameters(&ctx->enc_params);\n\n\n\n    ctx->enc_params.cp_rsiz = ctx->profile;\n\n    ctx->enc_params.mode = !!avctx->global_quality;\n\n    ctx->enc_params.cp_cinema = ctx->cinema_mode;\n\n    ctx->enc_params.prog_order = ctx->prog_order;\n\n    ctx->enc_params.numresolution = ctx->numresolution;\n\n    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;\n\n    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;\n\n    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;\n\n    ctx->enc_params.tcp_numlayers = ctx->numlayers;\n\n    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;\n\n\n\n    if (ctx->cinema_mode > 0) {\n\n        cinema_parameters(&ctx->enc_params);\n\n    }\n\n\n\n    ctx->compress = opj_create_compress(ctx->format);\n\n    if (!ctx->compress) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the compressor\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    ctx->image = mj2_create_image(avctx, &ctx->enc_params);\n\n    if (!ctx->image) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the mj2 image\\n\");\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating coded frame\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    memset(&ctx->event_mgr, 0, sizeof(opj_event_mgr_t));\n\n    ctx->event_mgr.info_handler    = info_callback;\n\n    ctx->event_mgr.error_handler = error_callback;\n\n    ctx->event_mgr.warning_handler = warning_callback;\n\n    opj_set_event_mgr((opj_common_ptr) ctx->compress, &ctx->event_mgr, avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opj_destroy_compress(ctx->compress);\n\n    ctx->compress = NULL;\n\n    opj_image_destroy(ctx->image);\n\n    ctx->image = NULL;\n\n    av_freep(&avctx->coded_frame);\n\n    return err;\n\n}\n", "idx": 18719, "substitutes": {"avctx": ["avctl", "avectl", " avcp", "abcontext", "avekw", "averctx", "avcfg", "averkb", "AVtx", "navctx", " avcmp", "navkb", "awtx", "avcontext", " avctl", "wavcmd", "avercmd", "avecb", "avcp", "wavkl", " avconn", " avkb", "ajkw", "afkl", "avectx", "awctx", " avcontext", "navcontext", "AVctx", "avcb", "avconn", "averconn", "AVcontext", "avecmd", "navcrit", "afpkg", "avkl", "wavcontext", "avercrit", "abtx", "avkw", "wavcfg", "camcp", "awcontext", "avcmd", "avedl", "aveconn", "camcontext", "cvctx", "aftx", "averkl", "abctx", "avetx", " avtx", "avercontext", "AVcmp", "averkw", " avcrit", "averctl", "avcmp", "wavctx", "avconf", " avconf", "ajcb", "avkb", "wavpkg", "avecfg", " avcfg", "afctx", "abconf", "camctx", "cvcp", "avpkg", "camtx", "averdl", "avercfg", "ajdl", "avtx", "cvcontext", " avcb", "averconf", "wavcb", "avdl", "avercb", " avcmd", "avertx", "avekl", "avcrit", "awcmp", "ajctx", " avkl", " avkw", "wavtx", "cvtx", "avepkg"], "ctx": ["px", "cv", "c", "wd", "setup", "etc", "iat", "jac", "np", "kt", "qq", "inst", "check", "work", "wp", "utils", "val", "today", "req", "command", "cmp", "co", "proc", "cf", "act", "hw", "tx", "ca", "xs", "cp", "obj", "cb", "cu", "expr", "cpp", "index", "wcs", "context", "cmd", "msg", "nt", "conf", "cfg", "tmp", "tm", "conn", "pkg", "cm", "conv", "loc", "wx", "tc", "ka", "resp", "kw", "txt", "cl", "ct", "acl", " cx", "ctrl", "prefix", "desc", "col", "tk", "fn", "comm", "crit", "rt", "lc", "ppo", "config", "that", "jp", "kl", "td", "fc", "dl", "abc", "ck", "func", "xp", "doc", "gc", "qt", "unc", "nc", "cc", "yes", "ctl", "pa", "xc", "exec", "addr", "timeout"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n", "idx": 18724, "substitutes": {"flags": ["levels", " Flags", "qa", "acts", "bits", "ints", "states", "aints", "args", "aps", "settings", "values", "properties", "lbs", "mask", "names", "heads", "details", "flag", "ags", "ents", "Flags", "ids", "fps", "options", "weights", "members", "parts", "lag", "FLAG", "orts", "fields", "atts", "count", "vals", "files", "comments", "gs", "posts", "tags", "features", "fs"]}}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n", "idx": 18727, "substitutes": {"machine": ["zone", "alias", "hard", "parse", "shell", "computer", "connection", "chain", "linux", "memory", "mc", "manager", "device", "power", "engine", "handler", "check", "smart", "sim", "model", "network", "monitor", "m", "vm", "series", "money", "me", "local", "mode", "achine", "template", "space", "history", "state", "instance", "green", "link", "managed", "frame", "node", "module", "image", "command", "process", "Machine", "iso", "hello", "keeper"], "cpu_model": ["cpu2mode", "pu_type", "cpu_mode", " cpu_mode", "gpu_owner", "pu_models", "cpu_meta", "cpu_command", "cpu_owner", " cpu_label", "cpu_label", "cpuetylabel", "cpu_module", "pu_module", "gpu_model", "cpu_library", "cpumymeta", "cpumycommand", "pu_meta", "cpu_device", "gpu_type", "cpu____model", "cpu2type", "cpu2label", "pu_device", "cpumytype", "cpu_type", "cpu____command", "cpu____type", "pu_command", "pu_library", " cpu_type", "cpu____meta", "gpu_label", "cpuetymodel", "pu_model", "cpuetyowner", "cpu_models", "cpu2model", "pu_label", "cpumymodel", "cpuetytype"], "kernel_filename": ["kernel_fn", "moduleityfn", "moduleityfilename", "vmablepath", "kernelpyfilename", "vmablemodel", "module_dir", "kernel___file", "kernelpyfn", "kernelityfn", "kernel_file", "vm_filename", "kernel_skin", "kernelityfilename", "vm_location", "kernel_path", "moduleityskin", "kernelitydir", "moduleitydir", "vm_path", "vmablefilename", "kernel_location", "module_filename", " kernel_fn", "module_fn", "kernelablepath", "kernel_model", "kernel_dir", "kernelablemodel", "vm_model", "kernel___fn", " kernel_nm", "kernelityskin", "kernel___nm", "kernelablefilename", "kernelpydir", "kernelablelocation", "vmablelocation", "kernelpyskin", "module_skin", " kernel_file", "kernel___filename", "kernel_nm"], "cpu": ["proc", "CPU", "bench", "library", "profile", "component", "disk", "parse", "boot", "cache", "conn", "processor", "computer", "hw", "cam", "cn", "mx", "runner", "clock", "c", "prof", "jp", "bean", "nic", "execute", "cum", "nice", "linux", "memory", "flow", "chip", "thread", "cp", "pixel", "ro", "comp", "coin", "util", "gc", "pause", "home", "mu", "cu", "check", "pc", "pai", "call", "vm", "ctx", "core", "nu", "reset", "alloc", "ilo", "aco", "phys", "gpu", "mem", "loop", "mac", "pool", "current", "aux", "module", "ruby", "process", " CPU", "pu", "bo", "p"], "ram": ["tm", "rain", "reg", "sum", "cr", "rank", "na", "Ram", "ray", "cam", "RAM", "gram", "hw", "rum", "mm", "tar", "win", "cum", "root", "memory", "rem", "mass", "buffer", "bank", "ras", "region", "ro", "gra", "res", "gc", "sd", "tem", "iam", "scan", "rad", "ra", "sim", "rss", "ma", "row", "lam", "core", "space", "lay", "alloc", "gb", "ru", "ran", "mem", "am", "rom", "ow", "sam", "raw", "sky", " Ram", "mb", "process", "dev", "mar", "gem"], "n": ["nb", " i", "inn", "ne", " len", "na", "en", " ns", "nos", "sn", "c", "nr", "non", "ren", "yn", "ex", " missing", "i", "nl", "names", "name", "acc", "wn", "nn", "in", "ns", "note", "nor", "ng", "nc", "m", "d", "un", "num", "nw", "con", "pn", " c", "o", " N", "mn", "s", "nan", " num", "x", " l", " count", "gn", "an", "span", " m", "number", " p", "ln", " j", "nt", "N", "nia", "t", "z", "j"]}}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "static void ohci_reset(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci_bus_stop(ohci);\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev) {\n\n            usb_attach(&port->port, port->port.dev);\n\n        }\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n", "idx": 18741, "substitutes": {"opaque": ["iopacity", "iopaques", "paque", "oque", "oplacity", "operaque", "opacity", "oplaque", "pque", "operaques", "obaque", "opiera", "operiera", "obacity", "obiera", "opque", "oplque", "pacity", "oaque", "operacity", "iopiera", "iopaque", "obaques", "oacity", "opaques"], "ohci": ["ehuci", "ohcgi", "ehcu", "hlcci", "hhce", "omeci", "ighcit", "ouchuci", "ihpi", "ouchcci", "hhcci", "hcin", "ovuci", "ohdi", "ohcu", "ohce", "ahnic", "orthcu", "ihcu", "ehli", "hlci", "ighmit", "Ohli", "hlcu", "hdi", "ohuci", "ouchdi", "ehce", " ohuci", "ohcont", "ighli", "ehcit", "hldi", "ihuci", "okco", "oshcit", "ohcci", "okcit", "oshcin", " ehcin", "okcin", "ahcit", "oshli", "ovcu", "omecu", " ehuci", "ohcirc", "ihcci", "ahli", "ohpi", "ovcci", "bhcci", "ighcirc", "bhci", "hcci", "ehcgi", "ehdi", "ihco", "ehcin", "ohco", "ovci", "hluci", "okuci", "oshcci", " ohcci", "ehmit", "ehcci", "omecin", "ahpi", "oshdi", "orthcci", "ihcgi", "okoci", "ohcit", "bhce", "ahlc", " ohlc", "Ohcci", "okcci", "ahci", " ohcin", " ohcont", "ihlc", "ihcit", " ohdi", "ahuci", "okci", "ahcin", "ehci", " ehcci", "ohoci", "hcu", "ahdi", " ohcu", "ahmit", "okcu", "omecci", "ihcin", "bhnic", "ehpi", "ehco", "orthcin", "ouchci", "ihci", "ohlc", "Ohuci", "okli", "ehoci", "oshci", "ihli", " ehci", "orthci", "hhcin", "hci", "ehnic", "ihdi", "omecont", "ohmit", "ighcu", "ihoci", "omecgi", "hli", "Ohci", "okdi", "okcgi", "ohcin", "hhci", "Ohdi", "ehlc", "ahcirc", "ighci", " ohce", "ohli", "huci", "ehcirc", " ohcgi", "okcont", "ohnic", "ighcci", "ahcci", "ahcu", "ahce"], "port": [" sport", "page", "seat", "pport", "porter", "priority", "attribute", "pp", "address", "table", "project", "pc", "pid", "var", "tty", "key", "print", "trace", "link", "pair", "find", "bridge", "entry", "test", "interface", "report", "ports", "cp", "device", "export", "spec", "target", "tip", "path", "index", "client", "option", "direction", "pe", "tag", "dev", "vp", "p", "profile", "window", "bind", "host", "peer", "point", "post", "pipe", "service", "buffer", "phy", "nel", "pt", "pod", "boat", "mobile", "ve", "socket", "fire", "proxy", "file", "eport", "module", "ptr", "type", "mit", "connection", "cam", "mate", "gp", "plugin", "position", "slave", "server", "line", "select", "player", "public", "note", "handle", "ort", "import", "value", "let", "feature", "Port", "queue", "PORT", "t"], "i": [" I", "is", "g", "bi", "gi", "ind", " di", " pos", " mi", "c", "ri", "xi", " index", "cli", "ai", "info", "ini", "mc", "batch", " v", "li", "ui", "ic", "ip", "y", "in", "\u0438", " ii", "ami", "pi", "iu", " t", "qi", "tim", "zi", " bi", "ci", "sim", "asi", "m", "me", "index", "gu", " pi", "ji", "b", "v", "I", " c", "j", "ii", "ti", "ix", "x", " ti", " m", "di", " ni", " si", "mi", " j", " multi", "uri", "it", "hi", "ij", " vi", "t", "z", "multi", "si", "p"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 18744, "substitutes": {"env": ["proc", "window", " environment", "block", "equ", "open", "shell", "eco", "en", "er", "hw", "end", "entry", "conn", "viron", "walker", "ov", "worker", "te", "manager", "enter", "server", "forge", "vs", "event", "engine", "e", "ah", "nc", "EN", "conf", "den", "here", "vm", "v", "ctx", "ev", "code", "qa", "ew", "context", "app", "environment", "desc", "ner", "req", "cur", "ec", "msg", "erd", "Environment", "pe", "her", "eng", "queue", "dev", "esc", "exc"], "arg1": ["arg0", " arg0", "argOne", " argOne", "group2", "Arg2", "param1", "call1", "group91", " arg3", " arg01", "ArgOne", "param3", "call3", "group1", "arg3", "arg01", "call01", "Arg91", "Arg1", "arg91", "groupOne", " arg91", "param0", "param01", "call0"], "arg2": ["docTwo", "Arg2", "args2", "Arg4", "argumentTwo", "argument2", "argument1", "arg4", "Arg1", "doc1", "doc2", "args4", " argTwo", " arg4", "args1", "argTwo"], "farg1": [" fArgFirst", "farcFirst", "fvar7", "fumentz", "ftag61", "fvalid21", "varg81", "fblockOne", "fmvar91", "fmvar001", "umarg1", "fask1", "fmarg001", "fflag91", "umument3", "Fagg81", "fblockOnce", "fvar001", "FargOne", "fask7", "fuelarg91", " fargFirst", "Farg81", "farg3", "fmarg91", " fargOnce", "fbar1", " farg001", "fargs3", "faskon", "fflago", "ftag81", "fvalidOne", "figOnce", "fflag81", "fgrad91", "umarg3", "fgrado", "fvaron", "fbar81", "fargumentone", "fvalid1", "farg61", "vtag61", "fuelarg81", "fgrad1", "fargsz", "fargFirst", "fument81", "umargz", " fargsOne", "fumentone", "forgOne", "vargone", "varg1", "farg21", "forg1", "fagg91", "fbarOne", "fvar51", "fuelargo", "fmark7", "xfarg51", "fargsone", " fargs1", "fargsOne", "fuelloc1", "forg81", "fargo", "vtagone", "Farg001", "umument1", "fargument81", "fig21", "fmargOne", "vtag1", "floc81", "fagg1", "fvar1", "farg51", "FaggOne", "fargOne", "fargone", "fArgone", "farg91", "Farg1", "farc1", "fargz", "fument91", "fvalidOnce", "fask51", "fvarOne", " fArg1", "ftag001", " figOne", "fargs1", "umument91", "fargon", "fuelloc91", "fbar001", "umarg91", "fument61", "fuelarg1", "fument3", "vtag81", "fargs91", "fargument61", "figOne", "ftag1", "fargument1", "farc001", "floc1", "farp91", "xfvar1", "fargumentFirst", "Fagg001", "fArgFirst", "fmarg1", " figOnce", "ftagone", "ftagOne", "fgrad81", "umumentz", "floc91", "fArg001", "fagg81", "fblock1", "xfvar51", "fuelloc81", "farg7", "fumentOne", "forg001", "farcone", "fument1", " farg21", "fflag1", "fig1", "xfarg7", "fmark51", "xfargon", "farpz", "xfvaron", " fargsone", "floco", "fblock21", "fargOnce", " fargs001", "fargs001", " fig1", "fmark1", "fument001", "varg61", "faggOne", "xfarg1", "fvar91", "farg001", "farp1", "fmarkon", "fmvarOne", "fargument001", " fig21", " fargone", " fArg001", "fuelloco", "fmvar1", "Fagg1", " fargOne", " fArgone", "fArg1", "xfvar7", "farp3", "farg81", "fagg001"], "farg2": ["farg64", " ftag0", "fvalid21", "floatang2", "farg4", "farg102", "fument64", "fblock2", "fagg2", "ftag02", "floatang102", "fagg102", "fang2", "fflag02", "fflag2", "fiter2", "fpg0", "farg3", " farg02", "fArg4", "fagg02", "fagg21", "fparam2", "fang21", "fument102", "fflag3", "fument2", "fblock02", "fvalid102", " ftag02", "fArg2", "ftag9", "fgrouplet", "farg21", "fpg2", " farg4", "fparam02", " fArg2", "vagg102", " ftaglet", "fparam4", " farg9", " ftag2", "ftagtwo", "fflagtwo", "fparamtwo", "vagg21", "floatarg21", " fArg4", "farg02", "fvalid64", "varg21", "fiter9", "fadmin102", "fument21", "fgroup2", "floatarg102", "vagg2", "fparam3", " fargtwo", "fadmin02", "ftag3", "floatarg2", "fpglet", "fadmin2", "varg2", "farglet", "farg9", "floatarg64", "fadmin21", "fang102", " ftagtwo", " ftag3", " ftag9", " farglet", "floatang21", "fument02", "floatang64", "varg102", "fblock9", "ftag0", " farg3", "farg0", "varg02", " farg0", "ftaglet", "fargtwo", "fiter02", "ftag2", "fang64", "vagg02", "fvalid2", "fgroup0"]}}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_connect_init(NetClientState *peer,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            if (errno == EINTR || errno == EWOULDBLOCK) {\n\n                /* continue */\n\n            } else if (errno == EINPROGRESS ||\n\n                       errno == EALREADY ||\n\n                       errno == EINVAL) {\n\n                break;\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(peer, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 18759, "substitutes": {"peer": ["proc", "component", " Peer", "er", "pkg", "chain", "vr", "channel", "cer", "ca", "ker", "parent", "server", "device", "target", "actor", "remote", "rel", "handler", "message", "pc", "me", "el", "client", "sp", "owner", "socket", "state", "context", "package", "instance", "member", "pro", "pe", "node", "ptr", "p"], "model": ["resource", "type", "label", "object", "entity", "method", "channel", "brand", "style", "man", "server", "version", "attribute", "device", "pattern", "kind", "dm", "address", "message", "network", "Model", "m", "param", "mode", "package", "policy", "member", "link", "controller", "serial", "image", "module", "command", "scope", "process", "base", "mod", "models"], "name": ["ename", "type", "alias", "label", "create", "host", "nam", "part", "title", "term", "names", "man", "order", "version", "error", "net", "address", "named", "me", "path", "id", "local", "n", "family", "key", "comment", "description", "ment", "package", "Name", "NAME", "prefix", "file", "common", "no", "base", "ame", "admin", "normal"], "host_str": ["host2string", "port_str", "port_id", "host2str", "port2string", " host_s", "host2s", "port2br", "port_string", "host_id", "host_br", "port2id", "port2str", "port_br", "host_s", "host2br", "host_Str", "host2id", " host_Str", " host_string", "host2Str", "host_string"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "g", "ins", "sn", "aws", "c", "sq", "h", "js", "des", "ss", "ies", "res", "ns", "ms", "ats", "ts", "m", "sys", "sp", "b", "n", "socket", "sb", "sports", "sol", "stats", "ds", "qs", "less", "w", "S", "sam", "ssl", "gs", "comments", "results", "cs", "ps", "t", "bs", "comm", "fs", "hs", "p"], "fd": ["f", "ff", "cf", "ffff", "fl", "window", " df", "conn", "fp", "hd", "bd", " fin", "df", "fee", "ld", "td", "fb", "fc", "dl", "stream", "lf", "func", "pipe", "ed", "port", "fr", "dt", "fin", "fx", " fid", "cb", "sd", "dat", "handle", "dir", "buf", "pid", "d", "id", "FD", "uf", "dd", "socket", "tty", "fi", "db", "wind", "file", "ds", "ln", "fun", "bf", "addr", "ptr", "fn", "fs", "pd", "fed"], "connected": ["linked", "done", "ready", "enabled", "played", "conn", " disconnected", "ported", "connection", "closed", "ended", "confirmed", "loaded", "led", "connect", "ed", "built", "locked", "added", "powered", "approved", "opened", "finished", "reported", "selected", "checked", "started", "qualified", "released", "changed", "active", "registered", "used", "tested", "rolled", "success", "encrypted", "initialized", "joined", "printed", "mounted", "hidden", "created", "updated", "established", "fed"], "ret": ["rt", "f", "reg", "ext", "gt", "ref", "tn", "result", "err", "rem", "nl", "cont", "dt", "len", "tr", "res", "elt", "ll", "re", "flag", "got", "resp", "det", "RET", "Ret", "rect", "gz", "back", "ft", "inter", "backed", "reset", "val", "fi", "rets", "db", "alt", "success", "mem", "deg", "encrypted", "fun", "rm", "nt", "ptr", "mt", "t", "red"], "saddr": ["sysaj", " saddress", "padd", "sobj", "ssattr", "esaddress", "Saj", "Saddr", "pptr", " sadd", "waddress", "padr", "esaddr", " sptr", "saj", "wadd", "saddress", " sattr", "jsattr", " spkg", "southinfo", "paddr", " sadr", "Saddress", "sysaddress", "ssaddr", "esadd", "spkg", "jsaddress", "southadd", " sobj", "wattr", "jsaddr", "ssobj", "ssaddress", "sadd", "sysaddr", " saj", "sadr", "sptr", "sinfo", "waddr", "sattr", "esattr", " sinfo", "southaddr", "southpkg", "wobj", "jsadd"]}}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 18773, "substitutes": {"kernel_entry": ["kernel8option", "kernel_option", "kernelityflag", "energyityexistent", "module_high", "kernel_search", "kernelxhigh", "kernel8high", "kerneltentry", "module_zero", "module_search", "kernelityexclusive", "kernelxentry", "kernel_name", "kernelxcheck", "energyityexclusive", "kernelityentry", "kernel_exclusive", "kernel_flag", "kernel__entry", "energyityentry", "module_check", "kerneltsearch", "energy_exclusive", "kerneltzero", "kernel_only", "kernel__only", "energy_existent", "energy_entry", "kernel__name", "kernel8entry", "module_option", "kernelxoption", "energy_flag", "module_entry", "kernel__look", "energyityflag", "kernelthigh", "kernelityexistent", "kernel8check", "kernel_existent", " kernel_name", "kernel_check", "kernel_zero", " kernel_only", " kernel_look", "kernel_look"], "kernel_high": ["kernelaxylow", "kernel_index", " kernel_low", "kernel_specific", "ernel_specific", "kernelaxyspecific", "kernel_higher", "ernel_high", " kernel_higher", "ernel_hi", "kernel_low", "kernel_hi", "ernel_low", "kernelaxyhi", " kernel_index", "kernelaxyhigh", " kernel_hi"], "initrd_size": ["initrh_ize", "initrd67offset", "initrh_start", "initrd_max", "initnd_size", "initrer_max", "initnd67size", "initrd_style", "initnd67Size", "initrd_SIZE", "initrdLsize", "initrer_SIZE", "initrd__offset", "initnd_offset", "initrdLSIZE", "initrb_offset", "initra_ize", "initrd_start", "initrd_index", "initra_sum", "initrdLstate", "initra_size", "initrb_size", "initrd_name", "initrb_space", "initrd__ize", "initrd_sum", "initrdLmax", "initrh_size", "initrs_size", "initrd__style", "initrd67state", "initnd_state", "initrd__space", "initrd__size", "initnd_Size", "initrd67Size", "initra_fee", "initrd67size", "initrd__SIZE", "initrh_style", "initrb_SIZE", "initrd_fee", "initrd_space", "initrd_state", "initrd__start", "initrd_ize", "initrer_state", "initrer_size", "initnd67offset", "initrd_Size", "initrs_index", "initnd67state", "initrs_name"], "initrd_offset": ["inithr_offset", "initrod__off", "initrd_Offset", "initrd__Offset", "inithr_Offset", "initrd___offset", "initrb_index", "initrd__index", "inithringaddress", "initrd_position", "inithringleft", "initrod__index", "inithringOffset", "initrd__offset", "inithr_address", "initrb_offset", "initrd_start", "initrd_index", "initrb_size", "cont", "initrd__off", "initrdingleft", "initrb_Offset", "initrd___out", "initrod_off", "initrd__out", "initrd__size", "initrod__offset", "initrdingOffset", "inithr_left", "initrod_Offset", "initrdingaddress", "initrod_index", "initrb_start", "initrd_left", "initrb_out", "initrd__start", "initrb_op", "initrd_out", "func", "initrd___index", "initrdingoffset", "initrd_off", "initrd_address", "initrd__position", "initrb_position", "initrd___Offset", "initrod__Offset", "initrd_op", "initrod_offset", "inithringoffset"], "big_endian": ["big_medians", "big_meder", "big_beginIAN", "big_endical", "big_endsIAN", "big_medical", "big_ender", "big_endric", "big_crossian", "big_ndIAN", "big_medig", "big_endsful", "big_endsien", "big_ndians", "big_medien", "big_endien", "big_endser", "big_beginian", "big_endful", "big_endIAN", "big_ndian", "big_endians", "big_crossians", "big_ndien", "big_ndful", "big_endig", "big_ndric", "big_medric", "big_crossIAN", "big_beginians", "big_beginical", "big_median", "big_endsian", "big_endsical", "big_endsric", "big_endsians", "big_medIAN", "big_crossful", "big_endsig"], "prom_buf": ["mem_msg", "mem_index", "promxbuffer", "promxindex", "mem_buffer", "prom_msg", "prom_buffer", "promxmsg", "promxbuf", "mem_buf"], "prom_size": ["prom__length", "prom2length", "prom2set", "rim_length", "rim_size", "rim__size", "rim_set", "rim_num", "prom2size", "prom_set", "rim__set", "rim__num", "prom__num", "prom_length", "prom__size", "prom_num", "prom__set", "prom2num", "rim__length"], "xlate_to_kseg0": ["xlate_to_ksem0", "xlate_to_kseag_", "xlate_to_kseig3", "xlate_to_ksegs0", "xlate_to_ksep1", "xlate_to_ksep0", "xlate_to_kscheg0", "xlate_to_ksegs1", "xlate_to_kseag1", "xlate_to_kseeg3", "xlate_to_ksegm1", "xlate_to_kseig0", "xlate_to_kseeg2", "xlate_to_ksegm_", "xlate_to_kscheeg2", "xlate_to_kseig2", "xlate_to_ksem3", "xlate_to_kseeg1", "xlate_to_kseeg0", "xlate_to_kseg2", "xlate_to_kseg_", "xlate_to_ksem2", "xlate_to_ksegs2", "xlate_to_kseg3", "xlate_to_kseg1", "xlate_to_kseag0", "xlate_to_ksegm0", "xlate_to_kseeg_", "xlate_to_ksep2", "xlate_to_kscheg3", "xlate_to_kscheeg3", "xlate_to_kscheg2", "xlate_to_kscheeg0"], "opaque": ["popaque", "oplay", "poplay", "openaque", "popque", " openg", " oplay", "openg", "openeng", "openque", "opque", " opque", "popeng", "openlay"], "addr": ["pad", "type", "attr", "offset", "ref", "map", "err", "info", "pointer", "asm", "order", "obj", "address", "arr", "progress", "id", "var", "state", "alloc", "mem", "dr", "adr", "ptr", "hash", "add", "name", "arp"], "prom_index": ["prom_slot", "prom_loc", "promgindex", "rem_offset", "promgloc", "rem2index", "prom_offset", "prom2offset", "promjindex", "rem_slot", "promgoffset", "promjloc", "promjslot", "prom2index", "rem2offset", "rem2loc", "prom2loc", "rem2slot", "prom2slot", "rem_loc", "promgslot", "rem_index", "promjoffset"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_anon(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n", "idx": 18781, "substitutes": {"data": ["to", "text", "window", "block", "initial", "result", "bus", "map", "iter", "info", "json", "def", "ata", "error", "device", "res", "mu", "dat", "reader", "spec", "da", "form", "rel", "query", "table", "group", "d", "accept", "rew", "DATA", "join", "Data", "missing", "context", "empty", "next", "format", "raw", "input", "t", "step", "batch"], "unused": ["sunUsed", "unuse", "unalinitialized", "unalUsed", "unalused", "sunuse", "sunused", "suninitialized", " unuse", "unaluse", "unUsed", "uninitialized", " unUsed", " uninitialized"], "tmp": ["nb", "cv", "cmp", "attr", "tt", "mut", "emp", "pkg", "temp", "err", "xy", "mp", "tab", "Temp", "params", "rb", "etc", "np", "img", "obj", "src", "buf", "m", "imm", "sp", "txt", "var", "ctx", "vp", "mk", "uv", "nv", "mem", "mint", "vt", "sam", "buff", "nt", "perm", "aux", "mb", "ptr", "snap", "t", "MP", "p"], "v": ["f", "cv", "g", "sv", "vv", "vr", "c", "ov", "i", "q", "conv", "y", "vy", "vs", "p", "V", "u", "ver", "l", "m", "vi", "vm", "b", "var", "ev", "vis", "x", "vc", "uv", "nv", "tv", "it", "vt", "vo", "av", "w", "t", "j", "vp"], "errp": ["errpl", "lerpa", "errpid", "rrp", "arrp", "rrpad", "ererpa", "attrpen", "diep", "errpen", "ererp", "attrpl", "attrpa", "errpa", "lerp", "rrpl", "diepa", "errps", "arrpa", "attrpid", "ererpers", "arrps", "errpad", "ererpl", "rrpid", "attrpad", "attrps", "ererpad", "attrp", "ererpen", "erercp", "rrpen", "lercp", "diecp", "arrpid", "diepers", "lerpers", "errcp", "errpers", "rrps", "rrpa"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n", "idx": 18799, "substitutes": {"dev": ["proc", "pad", "window", "Dev", "disk", "block", "g", "conn", "host", "hw", "hd", "h", "test", "info", "ad", "def", "os", "server", "device", "obj", "debug", "sd", "ver", "att", "spec", "handle", "buf", "dem", "d", "pt", "env", "v", "var", "ctx", "ev", "dd", "ve", "app", "md", "db", "cmd", "data", "DEV", "link", "Device", "on", "de", "mem", "exec", "w", "serial", "nt", "av", "conf", "p"], "vq": ["vth", "svqq", "vgr", "Vq", "vck", "vqq", " vv", "vQ", "vw", "vv", "vpl", "sviq", "svgr", "svmsg", "vcgr", "hck", " vQ", "Vv", "vcdq", "vcq", "evqq", " vgr", "vh", "vtqq", "evh", "eviq", "vtq", "svv", " vmsg", "vcck", "hdq", " vqq", "vdq", "viq", "hQ", "svh", "hq", "svw", " vw", "svpl", "Vqq", "svq", "vcpl", " vck", "evq", " vdq", " vpl", "vcQ", "Vmsg", "vcw", "vmsg", "vtiq"], "n": [" ng", "nb", "ne", "nm", "na", " ns", "sn", "tn", "cn", "ind", "c", "nr", "i", "nl", "ity", "name", "nn", "ns", "ng", "nor", "l", "nc", "d", "num", "index", "m", "o", " N", "nu", "x", "number", "ln", "nt", "N", "t", "z", "j", "p"]}}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)\n\n{\n\n    AVFilterContext  *ctx = inlink->dst;\n\n    ATempoContext *atempo = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n\n\n    int ret = 0;\n\n    int n_in = src_buffer->nb_samples;\n\n    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);\n\n\n\n    const uint8_t *src = src_buffer->data[0];\n\n    const uint8_t *src_end = src + n_in * atempo->stride;\n\n\n\n    while (src < src_end) {\n\n        if (!atempo->dst_buffer) {\n\n            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);\n\n            if (!atempo->dst_buffer)\n\n                return AVERROR(ENOMEM);\n\n            av_frame_copy_props(atempo->dst_buffer, src_buffer);\n\n\n\n            atempo->dst = atempo->dst_buffer->data[0];\n\n            atempo->dst_end = atempo->dst + n_out * atempo->stride;\n\n        }\n\n\n\n        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);\n\n\n\n        if (atempo->dst == atempo->dst_end) {\n\n            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /\n\n                             atempo->stride);\n\n            ret = push_samples(atempo, outlink, n_samples);\n\n            if (ret < 0)\n\n                goto end;\n\n        }\n\n    }\n\n\n\n    atempo->nsamples_in += n_in;\n\nend:\n\n    av_frame_free(&src_buffer);\n\n    return ret;\n\n}\n", "idx": 18812, "substitutes": {"inlink": ["cinline", "inLink", "inmatch", "dinline", "cinlink", "innmap", " inLink", "inmap", "dinmap", "INmatch", "dinscan", "cinmatch", "outscan", "INline", "cinLink", "innline", "inscan", "INLink", " inmatch", "outmap", "outline", "INlink", "innlink", "dinlink", "innscan"], "src_buffer": ["src___Buffer", "src_channel", " src_Buffer", "rc_buff", "src___buff", "sel___reference", "src2reference", "sel_Buffer", " src_buff", "sel___buff", " src_buf", "src_reference", "src_buff", "src_Buffer", "src___buffer", "sel_buff", "sel___Buffer", "sel_reference", "rc_buf", "sel_buffer", "src_uffer", " src_channel", "sel___buffer", "src2Buffer", "src_buf", "rc_uffer", "src2buff", "src2buffer", "src___reference", "rc_buffer"], "ctx": ["tmp", "cf", "act", "cv", "lc", "config", "conn", "Context", "pkg", "hw", "jp", "tx", "wd", "ca", "cm", "abc", "func", "mc", "setup", "cp", "jac", "np", "obj", "gc", "loc", "cb", "tc", "nc", "kw", "cc", "txt", "ct", "ctl", "xc", "bc", "context", "cmd", "ctrl", "kk", "pool", "tz", "cmp", "co", "conf", "cfg", "timeout"], "atempo": ["atonporal", "httota", "empping", "aumho", "tempi", "ematepo", "paipot", "atenpi", "paiota", "iasmota", "atenpro", "adempo", "paifo", "atemo", "atenpa", "aumpo", "atenota", "atemmo", "atengo", "iasmcho", "atemporter", "tempty", "atemppo", "addypa", "atonpot", "mateote", "atempor", "atonlo", "atonpo", "matepa", "atemota", "temote", "paio", "ademmo", "ematefo", "atenpp", "atenpor", "ademote", "animatebo", "paiote", "aramota", "amo", "atonpa", "mateota", "montote", "atonpro", "ematepa", "mmmmpo", "atenho", "temota", "atenaco", "aumporter", "iempo", "adempi", "atempot", "atepo", "atembo", "paipos", "aramppo", "adempot", "atempi", "aumo", "tempro", "tempo", "mmmmota", "atonaco", "aumhea", "atomlo", "tmota", "atemgo", "tmpos", "paipo", "httpo", "addypo", "atonpos", "eddypo", "ampo", "atomlia", "atemlia", "addypos", "aramote", "emapa", "atemaco", "emacho", "emplia", "atemporal", "aramgo", "adempa", "iemo", "iasmpot", "montpty", "amorphpos", "aramporal", "atenlia", "atonhea", "montpa", "paimo", "atonote", "atempos", "matego", "emateota", "atenpr", "atenping", "tmpot", "atepi", "atenote", "tempp", "monto", "ampos", "empho", "mateporter", "atemcho", "tempa", "emppo", "tmpr", "addyaco", "emapos", "aumaco", "tembo", "animatepos", "httpot", "eddyote", "atonota", "addypor", "amorphpr", "emapot", "amorphota", "emapo", "animatepi", "ademppo", "atemping", "eddypa", "atebo", "tempos", "atompot", "atepos", "aumpa", "montpi", "tmmo", "paipi", "aumote", "atenporal", "atomaco", "atemhea", "atempa", "atompor", "atempty", "atemho", "atenpos", "addypp", "iemmo", "paipa", "atomho", "atonpty", "aumgo", "atompo", "matepi", "iempos", "atomping", "atenppo", "emaota", "iasmpo", "atoncho", "atempp", "atemlo", "montpo", "atenporter", "mmmmpa", "httlo", "atonpi", "atemfo", "emaote", "mmmmgo", "atompa", "tmo", "atenhea", "ammo", "atonho", "temfo", "tmpo", "atenpot", "eddypi", "ematepos", "atenpo", "atomota", "emaho", "tmpa", "arampo", "arampot", "montpos", "matepo", "amorphpo", "atemote", "animatepo", "emago", "atempr", "aumpi", "adempos", "atempro", "atongo"], "outlink": ["inthread", "inLink", "fromroute", "outloop", "outputline", "outLink", "outthread", " outroute", " outloop", " outthread", "outputloop", "outputLink", "fromline", "outroute", "outputthread", "outputlink", " outline", "outline", " outLink", "fromlink", "outputroute", "fromloop"], "src": ["url", "tmp", "rt", "length", "ser", "rs", "st", "ctr", "sn", "ind", "ins", "trans", "iter", "origin", "rc", "rl", "i", "inner", "sur", "cont", "sc", "conv", "comp", "obs", "ebin", "syn", "sub", "img", "loc", "inst", "sr", "r", "rel", "scan", "sys", "now", "index", "imp", "dest", "txt", "bg", "sb", "s", "str", "ctrl", "seek", "cur", "filename", "RC", "raw", "source", "addr", "usr", "input", "ptr", "sel", "tp"], "src_end": ["rc_offset", "src_ends", "src_est", "rc_ends", "rc_end", "src_offset", "sec_end", "sec_start", "sec_est", "rc_start", "src_END", "rc_END", "src_start", "sec_END"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "struct vhost_net *vhost_net_init(VhostNetOptions *options)\n\n{\n\n    int r;\n\n    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 18819, "substitutes": {"options": ["checks", "alias", "config", "ptions", "offs", "outs", "eps", "plates", "changes", "ops", "args", "onet", "pieces", "cells", "steps", "settings", "limits", "info", "ports", "values", "properties", "rules", "lines", "comes", "params", "names", "os", "pins", "ims", "public", "false", "OP", "example", "objects", "errors", "table", "sequence", "actions", "ts", "zero", "maker", "caps", "weights", "global", "parts", "Options", "ices", "meta", "tops", "other", "orts", "faces", "option", "tools", "times", "stats", "points", "vals", "abilities", "flags", "aux", "keys", "features", "als", "details", "terms", "lets"], "r": ["kr", "rt", "hr", "lr", "resource", "f", "cr", "attr", "br", "g", "rs", "er", "run", "mr", "entry", "result", "ir", "c", "h", "nr", "ren", "err", "rc", "i", "rar", "q", "fr", "ro", "rb", "like", "res", "rg", "p", "rr", "re", "rate", "ur", "sr", "air", "e", "rw", "arr", "l", "m", "d", "client", "b", "v", " err", "n", "R", "record", "ar", "dr", "ptr", "t", "rd", "repl", "rn", "ror", "j", "ry"], "net": ["org", "page", "init", "man", "ip", "np", "nut", "kt", "dat", "nat", "out", "mem", "art", "cart", "plain", "test", "virtual", "serv", "dt", "nets", "null", "ns", "obj", "inet", "ms", "mot", "prot", "client", "mat", "total", "db", "msg", "nt", "vert", "resource", "tmp", "all", "ne", "conn", "chain", "result", "channel", "Net", "term", "port", "physical", "io", "pot", "set", "m", "ether", "next", "on", "no", "number", "ent", "pool", "module", "NET", "rt", "config", "connection", " Net", "mult", "non", "nic", "not", "city", "server", "res", "ut", "remote", "ng", "list", "network", "sys", "num", "n", "gate", "web", "et", "write", "grid", "domain", "fat", "eng", "hidden", "tree", "t"]}}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n", "idx": 18820, "substitutes": {"usb_msd_init": ["usb_msb_info", "usb_msd__info", "usb_msd__init", "usb_msd__Init", "usb_msb_init", "usb_msd_Init", "usb_msd_new", "usb_msb_new", "usb_msd_info", "usb_msb_Init", "usb_msd__new"], "filename": ["sn", "ames", "np", "which", "fle", "pdf", "status", "files", "needed", "ame", "f", "url", "mpeg", "nm", "existent", "title", "json", "len", "jing", "spec", "black", "src", "path", "brace", "subject", "lua", "png", "wcs", "Filename", "directory", "source", "til", "rn", "name", "jpg", "p", "finals", "length", "ext", "location", "ren", "println", "username", "fil", "txt", "prefix", "JSON", "file", "fn", "fd", "text", "nil", "ename", "config", "fp", "nl", "kj", "position", "names", "unc", "sequence", "xxx", "n", "sql", "description", "NAME", "format", "bol", "fs"], "id": ["rid", "f", "pad", "fd", "window", "type", "ID", "end", "ref", "init", "h", "nd", "info", "root", "size", "error", "in", " fid", "kind", "Id", "dir", "r", "ids", "pid", "d", "num", "uid", "n", "mid", "vid", "kid", "key", "ide", " tid", "str", " ID", "sid", "status", "no", "number", "it", "base", "start", "oid", "wid", "addr", "ident", "t", "hash", "name"], "opts": ["oprs", "optters", " opTS", " oppers", "opct", "opt", "iopets", " oprs", " opets", " opct", " opjs", "opspers", "opns", "OPs", "opjs", "opters", "optt", " ops", "optts", "optct", "ops", "opsjs", "opls", " opls", "opshs", " opt", "operts", "oppers", "copls", "OPets", "optls", "opths", "operct", "ophs", "opouts", "opsts", "OPns", "opsTS", "opps", "opsls", "optrs", "copTS", "prot", "opTS", " opouts", "cophs", "opsct", " opns", "opets", "optTS", "optjs", "iops", "optpers", "opsps", "optps", "operTS", "copts", " opps", "coprs", "iopns", "OPps", "proters", "iopts", "OPouts", "optouts", " opters", "proct", "OPts", "prots"], "dinfo": ["dInfo", "DInfo", "Dinf", "udinfo", " dfo", "linfo", "rfo", "Dattr", " dattr", "lINFO", " dINFO", "udinformation", "ddattr", "ffo", " dInfo", "dinformation", "Dinfo", "ddno", "dattr", "finfo", "rInfo", "rinfo", "dINFO", "dno", "finf", "rinf", "lInfo", "DINFO", "ddInfo", "Dno", "dinf", "ddinfo", "Dinformation", " dinf", " dinformation", "dfo", " dno", "fInfo", "udinf"], "dev": ["new", "roller", "pad", " Dev", "Dev", "disk", "end", "conn", "hw", "cam", " device", "DE", "wd", "develop", "info", "ov", "des", "ad", "def", "serv", "server", "tr", "device", "iv", "obj", "go", "sd", "ver", "driver", "buf", "van", "gu", "env", "v", "var", "hid", "ev", "priv", "out", "dd", "ve", "devices", "cmd", "DEV", "data", "door", "de", "Device", "mem", "gpu", "usb", "w", "ow", "vo", "nt", "adv", "pro", "serial", "fo", "die", "ptr", "od", "tech"], "fatal_error": ["familiar_error", "fatal_ERROR", "fatal_no", "fatal__ror", "fatalityerror", "familiar_ERROR", "fatal_ror", "familiar_no", "fatal__ERROR", "fatal___err", "fatal__no", "fatalityERROR", "fatal__error", "fatal___ror", "fatal_err", "fatalityno", "fatal___error", "familiar_ror", "fatalityror"], "p1": [" pOne", "t2", "t0", "t3", "p7", "jp0", "jpOne", "sp2", " p3", "jp2", "p5", "P3", "P2", " p0", "pOne", " p5", "t1", "jp5", "P0", "sp3", "p0", " p7", "P7", "p3", "P5", "jp7", "P1", "jp1", "sp1", "POne", "sp0"], "fmt": ["fmats", "ftm", "fMT", "tftm", "tfmt", "fats", "sfprintf", " fMT", "sfMT", "forformat", "sflt", " flt", "Fmt", "Ftm", "tflt", "fformat", "formt", "Fformat", "FMT", "forlt", "Fats", " fformat", "Flt", "tfformat", "flt", "fmformat", "fortm", "Fprintf", "fmmt", "fmprintf", " fats", " ftm", "sfmt"], "nr": ["rid", "nb", " n", "kr", "attr", "br", "er", "ctr", "sn", "mr", "chain", "iter", "NR", "err", "Ni", "nl", " NR", "radius", "nn", "np", "arity", "ni", "r", "gr", "ng", "nc", "sys", "num", "nw", "n", "nz", "inter", "ar", "next", "nv", " ni", "nt", "adr", "oid", " resid", "ptr", "rn"], "p2": ["Ptwo", " p4", "f3", " p3", "jp2", "tp2", "P3", "P2", "op1", "tp3", "f2", "P4", "f1", "p3", " ptwo", "P1", "jp1", "p4", "jp4", "op2", "ptwo", "tp1", "f4", "jp3", "op4", "tptwo", "optwo"]}}
{"project": "FFmpeg", "commit_id": "aacf6b3a2fd8bc8603e3deaa6e612ea03cf08707", "target": 1, "func": "static inline void rv34_mc(RV34DecContext *r, const int block_type,\n\n                          const int xoff, const int yoff, int mv_off,\n\n                          const int width, const int height, int dir,\n\n                          const int thirdpel, int weighted,\n\n                          qpel_mc_func (*qpel_mc)[16],\n\n                          h264_chroma_mc_func (*chroma_mc))\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    uint8_t *Y, *U, *V, *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride + mv_off;\n\n    int is16x16 = 1;\n\n\n\n    if(thirdpel){\n\n        int chroma_mx, chroma_my;\n\n        mx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) / 3 - (1 << 24);\n\n        my = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) / 3 - (1 << 24);\n\n        lx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) % 3;\n\n        ly = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) % 3;\n\n        chroma_mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        chroma_my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = (chroma_mx + (3 << 24)) / 3 - (1 << 24);\n\n        umy = (chroma_my + (3 << 24)) / 3 - (1 << 24);\n\n        uvmx = chroma_coeffs[(chroma_mx + (3 << 24)) % 3];\n\n        uvmy = chroma_coeffs[(chroma_my + (3 << 24)) % 3];\n\n    }else{\n\n        int cx, cy;\n\n        mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] >> 2;\n\n        my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] >> 2;\n\n        lx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] & 3;\n\n        ly = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] & 3;\n\n        cx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        cy = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = cx >> 2;\n\n        umy = cy >> 2;\n\n        uvmx = (cx & 3) << 1;\n\n        uvmy = (cy & 3) << 1;\n\n        //due to some flaw RV40 uses the same MC compensation routine for H2V2 and H3V3\n\n        if(uvmx == 6 && uvmy == 6)\n\n            uvmx = uvmy = 4;\n\n    }\n\n    dxy = ly*4 + lx;\n\n    srcY = dir ? s->next_picture_ptr->f.data[0] : s->last_picture_ptr->f.data[0];\n\n    srcU = dir ? s->next_picture_ptr->f.data[1] : s->last_picture_ptr->f.data[1];\n\n    srcV = dir ? s->next_picture_ptr->f.data[2] : s->last_picture_ptr->f.data[2];\n\n    src_x = s->mb_x * 16 + xoff + mx;\n\n    src_y = s->mb_y * 16 + yoff + my;\n\n    uvsrc_x = s->mb_x * 8 + (xoff >> 1) + umx;\n\n    uvsrc_y = s->mb_y * 8 + (yoff >> 1) + umy;\n\n    srcY += src_y * s->linesize + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    if(   (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4\n\n       || (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4){\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 22 * s->linesize;\n\n\n\n        srcY -= 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, (width<<3)+6, (height<<3)+6,\n\n                            src_x - 2, src_y - 2, s->h_edge_pos, s->v_edge_pos);\n\n        srcY = s->edge_emu_buffer + 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(uvbuf     , srcU, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        s->dsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n    }\n\n    if(!weighted){\n\n        Y = s->dest[0] + xoff      + yoff     *s->linesize;\n\n        U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }else{\n\n        Y = r->tmp_b_block_y [dir]     +  xoff     +  yoff    *s->linesize;\n\n        U = r->tmp_b_block_uv[dir*2]   + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = r->tmp_b_block_uv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }\n\n\n\n    if(block_type == RV34_MB_P_16x8){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8;\n\n        srcY += 8;\n\n    }else if(block_type == RV34_MB_P_8x16){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8 * s->linesize;\n\n        srcY += 8 * s->linesize;\n\n    }\n\n    is16x16 = (block_type != RV34_MB_P_8x8) && (block_type != RV34_MB_P_16x8) && (block_type != RV34_MB_P_8x16);\n\n    qpel_mc[!is16x16][dxy](Y, srcY, s->linesize);\n\n    chroma_mc[2-width]   (U, srcU, s->uvlinesize, height*4, uvmx, uvmy);\n\n    chroma_mc[2-width]   (V, srcV, s->uvlinesize, height*4, uvmx, uvmy);\n\n}\n", "idx": 18830, "substitutes": {"r": ["f", "cr", "g", "rs", "er", "rf", "mr", "vr", "c", "h", "rc", "i", "q", "rb", "rg", "u", "re", "sr", "e", "l", "m", "d", "b", "R", "v", "n", "k", "ar", "x", "w", "dr", "t", "j", "p"], "block_type": ["frame_types", "frame_id", "block_types", "blockblocktypes", "block_kind", "block_id", "frame_type", "blockblockid", "blockblocktype", "blockblockkind", "frame_kind"], "xoff": ["Xoff", "Xoffs", " xoffs", "fxOff", "xOff", "xoffs", " xOff", "fxoff", "fxoffs", "XOff"], "yoff": ["Yoffs", "yyoffset", "Yoffset", "yyoffs", "Yoff", "xoffset", "yOff", "YOff", "yyOff", "yyoff", "yoffs", "xOff", "xoffs", "yoffset"], "mv_off": ["mvjoff", "mV_offs", "mvjno", "mx_off", "mx_Off", "mx_on", "mx_offset", "mv_offset", "mvjoffset", "mv_offs", "mvxOff", "mv2on", "mv2offset", "mv_Off", "mvxoffset", "mv_on", "mv_no", "mv2Off", "mV_offset", "mvxon", "mvjoffs", "mV_no", "mvxoff", "mV_off", "mv2off"], "height": ["length", "h", "depth", "flow", "inches", "size", "gravity", "radius", "style", "bottom", "dim", "y", "history", "angle", "ty", "hang", "wh", "yt", "resolution", "sky", "density", "Height", "ch", "gh"], "dir": ["fd", "url", "window", "ht", "attr", "ext", "dy", "ind", "ir", "draft", "method", "channel", "wd", "dn", "DIR", "lock", "iter", "tab", "manager", "def", "dim", "diff", "tr", "pos", "dist", "kind", "driver", "dm", "orient", "rad", "rect", "det", "d", "path", "vol", "rec", "row", "folder", "dial", "dirty", "dep", "rot", "db", "direct", "grad", "desc", "str", "file", "direction", "di", "uri", "dr", "lib", "bound", "directory", "ptr", "Dir", "dict", "dev", "range"], "thirdpel": ["thirdpan", "dpol", "qpol", "thirdpol", "threepel", "threecel", "threepan", "dpan", "qcel", "thirdcel", "threepol", "rightcel", "rightpan", "qpel", "dcel", "qpan", "rightpol", "dpel", "rightpel"], "weighted": ["lighted", "Weighted", "processed", "Weightable", "Weightedd", "lightable", "processeds", "lightedd", "processedd", "processable", "Weighteds", "weighteds", "lighteds", "weightable", "weightedd"], "qpel_mc": ["qpol_mac", "qpol_mem", "qpol_pc", "qpel_pc", "qpel_mem", "qpel_mac", "qpol_mc"], "chroma_mc": ["chromera_fc", "chromera_mic", "chromera_mc", "chromera_gc", "chroma_mic", "chroma_gc", "chroma_fc"], "s": ["is", "er", "as", "states", "fs", "a", "c", "h", "js", "i", "y", "ims", "v", "stats", "storage", "qs", "ses", "status", "less", "http", "als", "f", "sw", "ss", "https", "ns", "spec", "session", "src", "ms", "space", "sports", "state", "times", "w", "S", "source", "cs", "conf", "hs", "p", "sl", "sts", "g", "rs", "south", "ops", "sq", "ex", "os", "conv", "m", "sb", "ssl", "gs", "comm", "ls", "sv", "ins", "settings", "sc", "scripts", "ats", "sys", "ts", "its", "fps", "b", "n", "se", "sql", "views", "ds", "ps", "t", "details", "z", "es"], "Y": ["Py", "XY", "J", "Ty", "B", "M", "UK", "H", "My", "HT", "Q", "T", "TY", "YP", "y", "YY", "MY", "Sky", "Z", "UV", "I", "G", "W", "S", "YE", "YC", "X"], "U": ["UU", "US", "M", "P", "UK", "C", "MU", "UC", "T", "OU", "D", "F", "UX", "u", "UV", "UE", "R", "I", "A", "UM", "Unity", "S", "W", "UT", "E", "X", "UI"], "V": ["VO", "VOL", "B", "M", "P", "TV", "H", "C", "Q", "T", "VC", "F", "CV", "Z", "UV", "v", "R", "I", "VA", "VM", "G", "W", "S", "VS", "L", "E", "X"], "srcY": [" srcTY", "sourceY", "sourceV", "srcX", "srcTY", "rcX", "sourceX", "sourceTY", "rcV", "rcTY", " srcX", "rcY"], "srcU": ["sourceU", "sourceA", "viaU", "srcX", "viaX", "rcA", "sourceX", "rcX", "rcU", "viaA", "srcA"], "srcV": ["sourceU", "srcT", "sourceV", "srcX", "rcX", "sourceX", "rcT", "rcV", "rcU", " srcX", "sourceT", " srcT"], "dxy": ["txy", "zxy", "sdpx", "dpx", "zpx", "dwy", "tpx", "txf", "zwy", "twy", "sdxf", "sdxy", "dxf", "sdwy", "zxf"], "mx": ["yx", "tm", "px", "zx", "ox", "mr", "tx", "mos", "mm", "xi", "mis", "rx", "xs", "mas", "xy", "mp", "ym", "mc", "ml", "mmmm", "y", "xes", "hz", "wx", "ms", "ey", "me", "m", "ma", "ux", "mn", "nz", "mic", "mite", "mes", "lex", "x", "colm", "mus", "mi", "mie", "mb"], "my": ["ny", "yer", "mm", "mis", "xy", "mp", "ym", "iy", "ity", "zy", "li", "y", "ies", "vy", "mmm", "by", "iam", "MY", "ms", "me", "m", "ma", "yy", "fy", "mon", "ury", "mn", "mic", "ty", "ky", "mes", "mem", "mys", "sym", "mi", "mie", "py", "gy", "ry"], "umx": ["uminumx", "uminumex", "umpx", "umex", "ulx", "ulix", "ulpx", "ubx", "ufex", "ump", "ufp", "umix", "ulex", "ulp", "ubix", "uly", "ufy", "ubpx", "imix", "imx", "ubex", "imex", "ufx", "uminumy", "impx", "uminump"], "umy": ["uminumx", "umby", "cummy", "mpyy", "uminumyy", "umsy", "aumsy", "mlsy", "ummy", "mpx", "uminumsy", "cumry", "aumy", "cumy", "umbry", "aummy", "mlx", "aumry", "umry", "cumsy", "umbmy", "mpsy", "uminumy", "umbsy", "mlyy", "umyy", "mly", "mpy"], "lx": ["klw", "llmx", " lw", "klex", "klmx", "lw", "slx", "lly", "slmx", "kly", "llx", "slpx", "lmx", "lex", "llex", " lpx", "klx", "slw", " lex", "klpx", "lpx", " lmx"], "ly": ["ny", "shell", "mm", "xy", "le", "iy", "ity", "zy", "li", "ml", "y", "vy", "lly", "by", "gly", "sys", "yy", "fy", "ury", "ley", "ty", "ky", "sty", "lay", "dis", "sol", "iem", "ply", "mi", "py", "lib", "gy", "sym", "lo", "las", "hy", "ry"], "uvmx": ["luvmex", "uvlex", "lupmw", "uvlw", "umlw", "lupmy", "umly", "lupmx", "umlex", "umlx", "uvmw", "upmx", "lupmex", "luvmy", "uvlx", "uvmex", "luvmx", "upmex", "upmw", "upmy", "uvly", "luvmw"], "uvmy": ["uumx", "uummy", "uumcy", "uummx", "ufmy", "uvgy", "uvcy", "uumgy", "uugy", "uumy", "uucy", "ufgy", "ufmx", "ufcy"], "src_x": ["src_X", " src_ex", "src_ex", " src_X"], "src_y": ["source_y", "src_Y", "source_x", "source_Y", "source_ny", "src_ny"], "uvsrc_x": ["uvsrc__rx", "uvsrc__y", "uvsrc_rx", "uvrc_z", "uvsrc__z", "uvsrc_z", "uvrc_y", "uvrc_rx", "uvrc_x", "uvsrc__x"], "uvsrc_y": ["uvsrc__b", "uvsrc__y", "uvsrc__py", "uvrc_py", "uvsrc_b", "uvrc_y", "uvrc_b", "uvsrc_py", "uvrc_x", "uvsrc__x"], "chroma_mx": ["chromea___mr", "chromca___py", "chroma___x", "chroma_py", "chroma___mn", "chroma__mx", "chromaogmus", "chromca_x", "chromea___mk", "chromA_yx", "chromea_mx", "chromaogyx", "chroma_mr", "chromca_mx", "chroma___mr", "chroma____mx", "chroma_mk", "chroma____mk", "chroma_mus", "chroma___mk", "chromaogmx", "chromea_mn", "chromA__wm", "chroma_yx", "chromea_mr", "chroma_mn", "chromea_mk", "chroma___py", "chromca___mk", "chroma____x", "chroma____py", "chromca___mx", "chroma__wm", "chroma___mx", "chroma_wm", "chroma__mus", "chromA__mus", "chromA__yx", "chromA_wm", "chromA_mx", "chroma__yx", "chromea___mx", "chromca_mk", "chromaogwm", "chromA__mx", "chromA_mus", "chromca___x", "chromea___mn", "chroma_x", "chromca_py"], "chroma_my": ["chromapa_my", "chroma_____yy", "chroma_____ni", "chroma___mie", "chroma_____mie", "chroma_ny", "chroma_mid", "chroma__ny", "chromapa_ny", "chromapa_mys", "chroma_mie", "chromera__my", "chroma__mid", "chroma___yy", "chroma_mi", "chromana_yy", "chromana___ni", "chroma_ni", "chroma_gy", "chroma___my", "chromera__mi", "chromera_my", "chromera__ny", "chromera_mid", "chromera_ny", "chroma_yy", "chroma___ni", "chromana___mie", "chroma_____my", "chromera__mid", "chromana___yy", "chromana_my", "chromapa_gy", "chroma__mi", "chroma__my", "chromera_mi", "chromana_ni", "chromana___my", "chroma_mys", "chromana_mie"]}}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 18833, "substitutes": {"s": ["ls", "sl", "is", "sts", "sv", "rs", "g", "ins", "states", "aws", "changes", "south", "a", "h", "sq", "c", "js", "i", "ports", "os", "ss", "y", "vs", "details", "p", "ns", "events", "ims", "spec", "set", "pers", "r", "e", "ms", "ats", "sync", "l", "ts", "m", "its", "sys", "d", "b", "v", "se", "parts", "sb", "state", "services", "stats", "ds", "ses", "less", "w", "S", "gs", "cs", "sa", "ps", "t", "bs", "comm", "fs", "hs", "z", "es"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)\n\n{\n\n    uint64_t VCO_out, PLL_out;\n\n    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;\n\n    int M, D0, D1, D2;\n\n\n\n    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */\n\n    if (cpc->pllmr & 0x80000000) {\n\n        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */\n\n        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */\n\n        M = D0 * D1 * D2;\n\n        VCO_out = cpc->sysclk * M;\n\n        if (VCO_out < 400000000 || VCO_out > 800000000) {\n\n            /* PLL cannot lock */\n\n            cpc->pllmr &= ~0x80000000;\n\n            goto bypass_pll;\n\n        }\n\n        PLL_out = VCO_out / D2;\n\n    } else {\n\n        /* Bypass PLL */\n\n    bypass_pll:\n\n        M = D0;\n\n        PLL_out = cpc->sysclk * M;\n\n    }\n\n    CPU_clk = PLL_out;\n\n    if (cpc->cr1 & 0x00800000)\n\n        TMR_clk = cpc->sysclk; /* Should have a separate clock */\n\n    else\n\n        TMR_clk = CPU_clk;\n\n    PLB_clk = CPU_clk / D0;\n\n    SDRAM_clk = PLB_clk;\n\n    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;\n\n    OPB_clk = PLB_clk / D0;\n\n    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;\n\n    EXT_clk = PLB_clk / D0;\n\n    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;\n\n    UART_clk = CPU_clk / D0;\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);\n\n    /* Setup time-base clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);\n\n    /* Setup SDRAM clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);\n\n    /* Setup UART clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);\n\n}\n", "idx": 18838, "substitutes": {"cpc": ["compcs", "plcall", "pcci", "ppb", "pctc", "podC", "skyc", "pircin", "cpucu", "captc", "pircat", "compcin", "cpcat", "pb", "cmpg", " cpb", "pc", "ippc", "compac", "copC", "pirc", "pccache", "cpn", " cpt", "privsec", "podpc", "comppc", "cpcu", "cryptc", "capv", "cpgc", "pxcs", "podv", "compcache", " cpv", "arpgc", "cpuunc", "cppc", " cpca", "compp", "plc", "cpv", "capn", "copci", "pccs", "ippu", "cmpcin", "cpk", "pcu", " cpcache", "pcfc", "cmpcache", "pxc", "cpuc", "copc", " pprc", "copct", " ppcs", "capp", "cpp", "cryptcache", "copca", "arpc", "pccall", "ippC", "cpci", "cprc", "copgc", "cpac", "copcu", "skyca", "arpsec", "plcache", "podc", "plci", "podci", "cryptcin", "podcin", "cmppc", " cpcs", "copx", "compn", "compfc", "capc", "privc", "pcct", " cpac", "cpC", "cpucache", "cpb", "copu", "arpcache", "pcc", "ipppc", "compu", "cmpcat", "cpcs", " cprc", "pt", "cpu", "pxrc", " cpcu", "compc", "podu", "capac", "cpcin", "skyunc", "cpx", " cpk", "compcat", "cpt", "cpuca", "arpca", "cmpx", "cpg", "pxk", "cpcall", "copsec", "copcache", "cpsec", "cmpfc", "cplc", "skycache", "ppt", "pplc", "cmpu", "cpct", "cpunc", "pcg", "cpcache", " ppc", "cmpci", "cpfc", "cmpv", "podcat", "compv", " ppk", "cpca", " cpn", "arppc", "podcache", "pcp", "privpc", "coppc", "cmpct", "copg", " cplc", "cmpc", "capcs", "copcin", "pircache", "comptc", "arpunc", "cptc", "cryptcat", "pcx", "podcall", "privgc", "ppc"], "VCO_out": ["VOK_ne", "VCO_ne", "VCo_OUT", "VCOPpos", "VCOzout", "VCO_set", "VCo_in", "Vco_pos", "VCo_no", "VCO_pos", "VCO_data", "VCO_obj", "VCOzdata", "VCOPset", "VOK_in", "VCO_in", "Vco_set", "VCo_obj", "VCOzsum", "VCo_out", "VCOzin", "VCOPsum", "Vco_sum", "VOK_err", "VCO_OUT", "Vco_out", "VCO____pos", "VCo_sum", "VCO____set", "VCO____sum", "VCOPout", "VCO____out", "VCO_sum", "VCO_no", "VOK_out", "VCo_data", "VCO_err"], "PLL_out": ["PCL_in", "Pll__OUT", "Pll__loss", "PLL_OUT", "PLL__in", "PLL_int", "PLL_ex", "PCL_int", "PCL_out", "PLL_loss", "PLL__loss", "Pll_ex", "PLL__OUT", "Pll__in", "PLL__out", "Pll_out", "Pll_loss", "PLL__int", "PLC_out", "Pll__out", "PLC_int", "PLL_Out", "PCL_obj", "Pll_in", "PLL_obj", "PLL_in", "PLC_Out", "PLC_in", "PLL__Out", "Pll_OUT"], "CPU_clk": ["CPU_plq", "CPU_chikk", "CPU_CLk", "CPU_clz", "CPU_slikk", "CPU_slik", "CPU_Clek", "CPU_____clak", "CPU_sltk", "CPU_slek", "CPU_synek", "CPU_CLK", "CPU_cleak", "CPU_plak", "CPU_____cleik", "CPU_CLka", "CPU_flck", "CPU_flks", "CPU_chik", "CPU_plck", "CPU_cletk", "CPU_synK", "CPU_____clek", "CPU_Clz", "CPU_clak", "CPU_declk", "CPU_clik", "CPU_plks", "CPU_clks", "CPU_Clk", "CPU_plz", "CPU_declks", "CPU_flk", "CPU_CLck", "CPU_____cleak", "CPU_____cletk", "CPU_slk", "CPU_plek", "CPU_declck", "CPU_synk", "CPU_blq", "CPU_plk", "CPU_chek", "CPU_clka", "CPU_clK", "CPU_glck", "CPU_blk", "CPU_____clk", "CPU_declka", "CPU_glq", "CPU_flak", "CPU_clq", "CPU_plK", "CPU_synikk", "CPU_____cltk", "CPU_plka", "CPU_____clik", "CPU_chtk", "CPU_clikk", "CPU_slK", "CPU_glk", "CPU_chK", "CPU_clek", "CPU_cleik", "CPU_slak", "CPU_declak", "CPU_CLz", "CPU_cltk", "CPU_chak", "CPU_blck", "CPU_CLek", "CPU_clck", "CPU_chk", "CPU_ClK", "CPU_declz"], "TMR_clk": ["TMR_lek", "TMR_aclik", "TMR_fullk", "TMR_shk", "TMR_clz", "TMR_Clek", "TMR_clik", "TMR_fullz", "TMR_gliker", "TMR_fullak", "TMR_blek", "TMR_Clk", "TMR_clq", "TMR_blck", "TMR_aclq", "TMR_shik", "TMR_aclk", "TMR_glk", "TMR_glz", "TMR_shq", "TMR_lck", "TMR_cln", "TMR_colk", "TMR_lk", "TMR_shck", "TMR_ln", "TMR_bln", "TMR_plck", "TMR_blk", "TMR_aclck", "TMR_coliker", "TMR_colz", "TMR_glak", "TMR_cliker", "TMR_clck", "TMR_plik", "TMR_Clck", "TMR_clek", "TMR_plq", "TMR_fulliker", "TMR_colak", "TMR_plk", "TMR_Cln", "TMR_clak"], "SDRAM_clk": ["SDRAM_lck", "SDRAM_clek", "SDRAM_Clek", "SDRAM_plck", "SDRAM_clK", "SDRAM_lk", "SDRAM_plz", "SDRAM_glk", "SDRAM_Clz", "SDRAM_clke", "SDRAM_plk", "SDRAM_slke", "SDRAM_flk", "SDRAM_Clk", "SDRAM_slek", "SDRAM_glke", "SDRAM_clck", "SDRAM_glK", "SDRAM_plek", "SDRAM_Clck", "SDRAM_glek", "SDRAM_clz", "SDRAM_flek", "SDRAM_lek", "SDRAM_flke", "SDRAM_slK", "SDRAM_slk", "SDRAM_lz", "SDRAM_flK"], "PLB_clk": ["PLB_flk", "PLB_colk", "PLB_nlck", "PLB_plkid", "PLB_coltk", "PLB_flK", "PLB_plK", "PLB_plkt", "PLB_deck", "PLB_clke", "PLB_lickk", "PLB_mlk", "PLB______colk", "PLB_mlock", "PLB_licck", "PLB_mlke", "PLB_sclck", "PLB_plkk", "PLB_hlk", "PLB______clark", "PLB_cltk", "PLB_decck", "PLB_dectk", "PLB_plck", "PLB_clark", "PLB_clK", "PLB_nlk", "PLB_clck", "PLB_plk", "PLB_classke", "PLB______cltk", "PLB_flck", "PLB_sclark", "PLB_flkk", "PLB_pltk", "PLB_lickid", "PLB_nlK", "PLB_colck", "PLB_lick", "PLB______colck", "PLB_mlkt", "PLB_nlkk", "PLB_plock", "PLB_sclk", "PLB_colark", "PLB_plke", "PLB_classck", "PLB_clock", "PLB______colark", "PLB_hlkid", "PLB_plark", "PLB_deckt", "PLB_clkid", "PLB_mltk", "PLB_mlck", "PLB_hlck", "PLB______coltk", "PLB_hlkk", "PLB_classk", "PLB_clkk", "PLB______clck", "PLB_scltk", "PLB_classock", "PLB______clk", "PLB_clkt"], "OPB_clk": ["OPB_lickk", "OPB_cktk", "OPB_ckkh", "OPB_ckk", "OPB_blek", "OPB_blark", "OPB_splk", "OPB_lictk", "OPB_splck", "OPB_ckkk", "OPB_deckk", "OPB_dectk", "OPB_splek", "OPB_rlark", "OPB_deck", "OPB_clkk", "OPB_splark", "OPB_rlk", "OPB_deckh", "OPB_rlck", "OPB_lickh", "OPB_cltk", "OPB_clck", "OPB_clark", "OPB_clkh", "OPB_blk", "OPB_lick", "OPB_clek", "OPB_rlek", "OPB_blck"], "EXT_clk": ["EXT_clak", "EXT_slk", "EXT_mlk", "EXT_slke", "EXT_toolak", "EXT_plck", "EXT_blke", "EXT_slck", "EXT_clg", "EXT_clck", "EXT_slak", "EXT_clke", "EXT_mlkl", "EXT_toolck", "EXT_CLkl", "EXT_mlg", "EXT_blk", "EXT_plg", "EXT_CLk", "EXT_CLg", "EXT_CLck", "EXT_plkl", "EXT_toolke", "EXT_mlck", "EXT_blck", "EXT_blak", "EXT_plk", "EXT_clkl", "EXT_toolk"], "UART_clk": ["UART_clp", "UART_____sclk", "UART_____clk", "UART_Clk", "UART_blk", "UART_____clj", "UART_clj", "UART_bln", "UART_klp", "UART_clak", "UART_klck", "UART_____scln", "UART_plak", "UART_____sclj", "UART_scln", "UART_Clak", "UART_blp", "UART_____clak", "UART_____cln", "UART_plp", "UART_klk", "UART_blck", "UART_plk", "UART_kln", "UART_sclak", "UART_clck", "UART_sclj", "UART_plj", "UART_sclk", "UART_pln", "UART_Cln", "UART_plck", "UART_Clj", "UART_____sclak", "UART_cln"], "M": ["DM", "MD", "LM", "J", "MR", "MAN", "MH", "B", "MT", "P", "MM", "H", "C", "BM", "MU", " CM", "MI", " mM", "T", "AM", "K", "MC", "D", "F", "V", "MIT", "MX", "MA", "NM", "MP", "m", "R", "I", "MO", "VM", "MN", "TM", "G", " m", "S", "N", "CM", "L", "PM", "MS", "U", "RM"], "D0": ["DInfo", "DValue", " DValue", "d1", " D255", "M3", "DIt", "d2", "DZero", " D6", " D780", "D15", "d4", "P25", "DI15", "M9", "D25", "Size780", "M50", "DO15", "d6", "DONo", "Sizeee", "DINo", "DI0", "U780", " D50", "U0", "DO10", "P0", "DO0", "DO255", "D6", " D25", "Do2", "Date0", " DNo", "Dee", "D50", "Do1", " DIt", "DD2", " D10", "D4", " D8", " D9", "D8", "Date780", "D3", " Dee", "D255", "P3", "P2", "d0", "dValue", "D10", "DoZero", "U8", "DD25", "DD6", "DD1", "PNo", "Do0", "DDee", " D4", "DOZero", "Do255", " D3", "DDInfo", " DInfo", "DateIt", " D15", "Size3", "DNo", "DIValue", "Do3", "P50", " DZero", "DDNo", "PInfo", "Size0", "M1", "DD9", "D780", "P6", "DI10", "P1", "DI6", "DD0", "M0", "Mee", "Date8", "D9", "Doee", "M2", "Do780", "UIt", "Do4"], "D1": [" D9", "V001", " D001", "D01", "DOne", "V7", "d1", "d01", "P2", "d2", "d7", "P4", "M1", "D4", "Q9", "DD4", "D001", "Q001", "P1", " D7", "DD1", "Q7", " D01", "M7", "DDOne", "D9", "M01", "POne", "M2", "D7", " DOne", "Q1", "DD2", "V1", " D4", "V9"], "D2": ["M02", "D3", "Do3", "d22", "D02", "S1", "d0", " D22", "P2", "S0", "d2", "d10", "DD256", "D10", "M1", " D6", "P0", "D256", "Do10", "S02", "D6", "D22", "DD6", " D256", "P1", "Do6", "M0", "S2", "Do2", "DD3", "d20", " D20", "d3", "Do0", "M2", "P02", "d6", "D20", "Do20", "DD2", "d256", " D10", "Do22", " D3"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n", "idx": 18853, "substitutes": {"opaque": ["withaque", " opatile", "opatile", "opacity", "Opasus", "opsaque", "ooch", "opesh", "oatile", " Opaques", " opoch", " opacity", "Opaques", "oaque", "opsasus", "Opaque", "withatile", "withacity", " Opaque", "opoch", "Opesh", "oacity", " Opasus", "opaques", "withoch", "opsaques", "opsesh", "opasus", " Opesh"], "addr": ["pad", "act", "alias", "coord", "attr", "offset", "oad", "ref", "tx", "ash", "err", "ay", " address", "ad", "pos", "np", "obj", " arg", "loc", "align", "aj", "arity", "src", "arg", "address", "arr", "handle", "Address", "work", "dh", "now", "id", "here", "ack", "off", "ord", "ock", "var", "ctx", "gate", "inter", "sha", "state", "ar", "alloc", "cmd", "ix", "seek", "alt", "msg", "dr", "adr", "at", "ptr", "add"], "size": ["length", "type", "sum", "offset", "sy", "shell", "st", "year", "sn", "sec", "shift", "fee", "args", "style", "shape", "SIZE", "scale", "len", "ize", "body", "align", "max", "address", "e", "message", "small", "l", "num", "sp", "n", "se", "code", "space", "Size", "send", "notice", "weight", "count", "storage", "number", "msg", "command", "news", "scope", "iz", "sh", "z", "name", "si"], "cmd646bar": ["cmd736car", " cmd646be", "cmd866bar", "cmd646car", " cmd736bar", "cmd736bar", "cmd645dec", " cmd645bar", "cmd646be", " cmd645be", "cmd645bar", "cmd616dec", " cmd646dec", " cmd645deb", " cmd736serv", "cmd646serv", "cmd645deb", "cmd736serv", "cmd616bar", "cmd736be", " cmd646car", " cmd646deb", "cmd866car", "cmd645be", "cmd616be", "cmd649car", "cmd616deb", "cmd646dec", "cmd866serv", " cmd736car", "cmd649bar", "cmd649serv", "cmd646deb", "cmd736deb", " cmd645dec", " cmd646serv", "cmd736dec"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t hpet_ram_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    HPETState *s = opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            return timer->config;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            return timer->config >> 32;\n\n        case HPET_TN_CMP: // comparator register\n\n            return timer->cmp;\n\n        case HPET_TN_CMP + 4:\n\n            return timer->cmp >> 32;\n\n        case HPET_TN_ROUTE:\n\n            return timer->fsb;\n\n        case HPET_TN_ROUTE + 4:\n\n            return timer->fsb >> 32;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return s->capability;\n\n        case HPET_PERIOD:\n\n            return s->capability >> 32;\n\n        case HPET_CFG:\n\n            return s->config;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl\\n\");\n\n            return 0;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick >> 32;\n\n        case HPET_STATUS:\n\n            return s->isr;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 18892, "substitutes": {"opaque": [" opass", "oposter", "Opque", "Opacity", "oplacity", "compque", "opacity", " opque", "opass", "oplaque", "Opface", "compaque", "oploster", "compaques", " opaques", "opque", "compass", "Opaques", "Opass", "Opaque", "ipface", "opface", "Oposter", "ipaque", "oplface", "iposter", "opaques", "ipacity"], "addr": ["pad", "arch", "act", "alias", "coord", "block", "attr", "offset", "oad", "host", "ref", "pkg", "hw", "init", "map", "tx", "args", "i", "ad", "asm", "len", "pos", "bytes", "obj", "kt", "loc", "align", "src", "max", "address", "arr", "r", "handle", "Address", "dh", "now", "ack", "gz", "ctx", "var", "n", "ord", "gate", "inter", "state", "alloc", "cmd", "ix", "prefix", "data", "x", "alt", "mem", "dr", "oa", "msg", "adr", "node", "z", "ptr", "mt", "start", "hash", "add", "name", "arp"], "size": ["length", "type", "ffff", "offset", "args", "SIZE", "len", "ize", "bytes", "align", "address", "m", "num", "id", "sp", "ctx", "n", "area", "Size", "data", "count", "mem", "start", "cmp", "z", "name"], "s": ["is", "er", "as", "a", "h", "c", "sm", "ed", "js", "or", "store", "ies", "vs", "ims", "v", "ches", "o", "stats", "qs", "ses", "less", "ers", "als", "ments", "terms", "bits", "aws", "sw", "aps", "ports", "ants", "ss", "serv", "ns", "obj", "spec", "ms", "actions", "parts", "sports", "ations", "state", "services", "an", "vals", "S", "hs", "p", "sl", "sts", "g", "rs", "ops", "sq", "service", "os", "ess", "itions", "ands", "l", "sim", "sp", "sb", "ing", "gs", "ists", "comm", "bs", "ls", "sv", "ins", "changes", "erences", "ats", "ts", "d", "its", "sys", "sets", "b", "ties", "se", "n", "eds", "ds", "sym", "sam", "ps", "t", "fs", "es"], "cur_tick": [" cur_time", "curJtick", "cur_ick", "cur__poll", "curmlpot", " cur_cycle", "cur_icker", "cur____token", "curmlick", " cur_stick", "curmmevent", "curpttick", "curmmick", "curjtick", "ctr_token", "cur_pot", " cur_event", "cur__tick", "curtcycle", " cur_window", "curmmtoken", "curtevent", "cur_time", "cur___tick", "ctr_tick", "curJstick", "cur_stick", "cur__icker", "curmltoken", "cur____time", " cur_pick", "cur__ick", "curJtime", "curptick", "curjick", " cur_lock", " cur_token", "curmmtick", "cur_check", " cur_ick", "cur___stick", "curptpot", "cur_window", "cur___ick", "curJtoken", "cur_cycle", "cur_poll", "cur_lock", "cur_event", "cur____tick", "cur__cycle", "curpttoken", "cur_pick", "curjpoll", " cur_check", "curjcycle", " cur_poll", "curJick", " cur_icker", "curJwindow", "curmmpoll", "cur___window", "curtick", "curmltick", "curttoken", " cur_pot", "ctr_cycle", "ctr_ick", "curttick", "cur____ick", "curmmcheck", "cur_token"], "index": ["act", "length", "label", "block", "type", "offset", "open", "ref", "location", "ind", "init", "Index", "vector", "test", "iter", "point", "lock", "ex", "info", "i", "seed", "position", "shape", "range", "order", "error", "pos", "loc", "address", "height", "insert", "scan", "can", "check", "zero", "num", "id", "here", "row", "ctx", "gate", "code", "dd", "key", "context", "slice", "val", "db", "ix", "axis", "x", "count", "link", "seek", "loop", "status", "no", "node", "find", "command", "hash", "timeout"], "timer": ["tm", "taker", "type", "program", "header", "later", "Timer", "cell", "runner", "er", "processor", "mr", "counter", "tool", "peer", "clock", "test", "iter", "cer", "temp", "icker", "parser", "tar", "recorded", "walker", "worker", "term", "buffer", "thread", "browser", "dt", "server", "duration", "iler", "player", "event", "reader", "tc", "actor", "tem", "tim", "handler", "driver", "function", "menu", "ter", "tom", "monitor", "sim", "byter", "writer", "meter", "txt", "time", "cker", "loader", "state", "wrapper", "finder", "latest", "atom", "task", "imer", "tick", "ger", "trigger", "transfer", "t", "ramer", "variable", "timeout"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,\n\n                            uint16_t vendor, uint16_t device,\n\n                            uint16_t class_code, uint8_t pif)\n\n{\n\n    uint8_t *config;\n\n    uint32_t size;\n\n\n\n    proxy->vdev = vdev;\n\n\n\n    config = proxy->pci_dev.config;\n\n    pci_config_set_vendor_id(config, vendor);\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n", "idx": 18893, "substitutes": {"proxy": ["prime", "profile", "alias", "cache", "connection", "push", "map", "native", "mos", "copy", "lock", "gp", "roxy", "connect", "report", "service", "linux", "port", "clone", "manager", "slave", "browser", "server", "version", "shadow", "ip", "phy", "pi", "master", "engine", "flag", "php", "Proxy", "remote", "embed", "friend", "query", "project", "request", "sync", "reference", "play", "ping", "client", "secure", "force", "gate", "mail", "super", "socket", "primary", "pin", "wrapper", "target", "web", "cas", "x", "link", "pse", "http", "pro", "py", "pool", "mi", "module", "view", "reply", "show", "reverse", "p"], "vdev": [" vdata", "wdev", "vcdev", "avdist", "svmem", "hDev", "uvcomment", "avserv", "tdef", "vdist", " vdd", "vmDev", "pdata", "hdev", " vgo", "wdef", "vval", "vdata", "vDEV", "vtdev", "vdes", "uvgo", "vtx", "pdev", " vcomment", " vdoc", "vdoc", "vmdev", "vcam", "hdef", "vcmd", "vmcam", "vctx", "vcdevice", "hconn", "vtdoc", "nvdev", " vval", "tconn", " vdist", "vardata", " vdes", "vdb", "vgo", " vDEV", "wconn", "vmem", "vardev", "vserv", "avdev", "hcam", "vtcomment", "wev", " vcmd", "pdd", " vdef", "vDev", "uvdoc", " vtx", "svdev", "vconn", "vcDEV", " vcam", "vartx", "vdef", "wdevice", "vdevice", " vdb", "wval", " vDev", "wdes", "tdev", "nvval", "vcomment", "hDEV", "pev", "svdef", "hcmd", "nvev", "vdd", "hmem", " vev", "uvdev", "vev", "vcdist", "vccmd", "vmdevice", " vdevice", "pdist", "nvdes", "vardevice", "hdevice", " vmem", "avdb", "pserv", "varev", "vardd", "tdevice", "svdevice", " vserv", "vtgo", "pdb", "vardist"], "vendor": ["vmirt", "bost", "avoid", "ivost", " virus", "evoid", "wendor", "evistor", "birus", "avistor", "avoice", "avirus", "virus", "ivendor", "wirus", "svirus", "vistor", "svirt", "avender", "woid", " virt", "evirus", "avirt", "chendor", "vmoice", "vmender", "svendor", "chirus", "virt", "bendor", "lirt", "voice", " vost", "chirt", "wistor", "birt", "lender", "vmendor", "ivirt", "vender", "svistor", "loice", "ivirus", "ivistor", "lendor", "chistor", "evendor", "vost", "avendor"], "device": ["component", "disk", "location", "channel", "interface", "pipe", "product", "deck", "port", "slave", "drive", "version", "phy", "power", "class", "event", "remote", "address", "project", "model", "date", "network", "pod", "hid", "family", "ve", "devices", "package", "instance", "DEV", "feature", "Device", "controller", "di", "serial", "image", "directory", "module", "scope", "dev", "volume"], "class_code": [" class_Code", "classalcode", "classNameCode", "classityid", "classNameid", "classalcodes", "classitycod", "class_codes", "classabilitycode", "class_rule", "classabilitymode", "class_id", " class_mode", "class_Code", "class_mode", " class_codes", "class_cod", "classNamecode", "classitycode", "classalmode", " class_rule", "classNamecod", " class_cod", " class_id", "classabilitycodes", "classityCode", "classalrule", "classabilityrule"], "pif": ["phpif", "cpif", " pifi", "ciff", "phpifer", " pIF", "cpIF", "cpifi", "cIF", "piff", "ppifer", "ppIF", "phpIF", "npitch", "pifi", "npif", "pIF", "cpiff", "ppitch", "npifer", "cifi", "cif", "npIF", " piff", "pifer", "pitch", "phpitch", "ppif"], "config": ["cache", "init", "c", "args", "content", "attribute", "etc", "debug", "address", "table", "other", "FIG", "capacity", "storage", "command", "dc", "add", "mount", "complete", "interface", "temp", "json", "cont", "diff", "spec", "code", "lag", "comment", "change", "cmd", "empty", "bitcoin", "input", "adj", "conf", "cfg", "admin", "length", "all", "ext", "conn", "chain", "map", "condition", "port", "cap", "access", "load", "loc", "set", "options", "ct", "bc", "control", "desc", "cond", "text", "Config", "reason", "fig", "settings", "info", "rc", "connect", "search", "mask", "sc", "att", "form", "ac", "list", "con", "ctl", "app", "data", "capt", "output", "common", "exec", "t"], "size": ["window", "length", "type", "sum", "zone", "g", "cache", "scroll", "south", "shift", "c", "fee", "settings", "city", "shape", "SIZE", "scale", "sc", "len", "ize", "large", "power", "set", "max", "height", "grow", "small", "l", "zero", "index", "sp", "global", "n", "mode", "code", "space", "total", "Size", "s", "state", "send", "empty", "count", "capacity", "storage", "number", "limit", "scope", "iz", "sh", "z", "name", "p"]}}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static int usb_device_add(const char *devname, int is_hotplug)\n\n{\n\n    const char *p;\n\n    USBDevice *dev;\n\n\n\n    if (!free_usb_ports)\n\n        return -1;\n\n\n\n    if (strstart(devname, \"host:\", &p)) {\n\n        dev = usb_host_device_open(p);\n\n    } else if (!strcmp(devname, \"mouse\")) {\n\n        dev = usb_mouse_init();\n\n    } else if (!strcmp(devname, \"tablet\")) {\n\n        dev = usb_tablet_init();\n\n    } else if (!strcmp(devname, \"keyboard\")) {\n\n        dev = usb_keyboard_init();\n\n    } else if (strstart(devname, \"disk:\", &p)) {\n\n        BlockDriverState *bs;\n\n\n\n        dev = usb_msd_init(p, &bs);\n\n        if (!dev)\n\n            return -1;\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {\n\n                dev->handle_destroy(dev);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (!strcmp(devname, \"wacom-tablet\")) {\n\n        dev = usb_wacom_init();\n\n    } else if (strstart(devname, \"serial:\", &p)) {\n\n        dev = usb_serial_init(p);\n\n#ifdef CONFIG_BRLAPI\n\n    } else if (!strcmp(devname, \"braille\")) {\n\n        dev = usb_baum_init();\n\n#endif\n\n    } else if (strstart(devname, \"net:\", &p)) {\n\n        int nic = nb_nics;\n\n\n\n        if (net_client_init(\"nic\", p) < 0)\n\n            return -1;\n\n        nd_table[nic].model = \"usb\";\n\n        dev = usb_net_init(&nd_table[nic]);\n\n    } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) {\n\n        dev = usb_bt_init(devname[2] ? hci_init(p) :\n\n                        bt_new_hci(qemu_find_bt_vlan(0)));\n\n    } else {\n\n        return -1;\n\n    }\n\n    if (!dev)\n\n        return -1;\n\n\n\n    return usb_device_add_dev(dev);\n\n}\n", "idx": 18915, "substitutes": {"devname": ["debugcall", "developstart", "privname", "developword", "devline", "evcall", " devno", "devrun", " devrun", "testcase", "procName", "avcase", "padnames", "devword", "defnames", "procline", "devsize", "evName", "devstart", "divword", "testname", " devword", "devma", "devicename", "evma", "devicenames", "developrun", "defword", " devdefault", "attrma", "developnames", "attrname", " devsize", "evcase", " devName", "defdefault", "devno", "divstart", " devstart", "debugName", "evnames", "procstart", "attrName", "evword", "developcall", "procname", "developno", "padname", "padNAME", " devcall", "testno", "varname", "evline", "debugword", "deviceword", "privName", "avstart", "formsize", "evname", "formword", "debugsize", "evNAME", "avname", "attrcall", "devName", "privstart", "devNAME", "varno", "formstart", "deviceName", "defstart", "formname", " devnames", "divname", "devdefault", "defname", "developdefault", "debugma", "devnames", " devNAME", "privline", "padName", "divrun", "teststart", "devcase", "deviceno", "divnames", "evrun", "debugstart", "avno", "evstart", "devcall", "debugname", "evno", "varName", "developname", "devicerun", "varrun"], "is_hotplug": ["is_hotPlug", "is_smartplug", "is_hotlink", "is_smartpack", "is_hardplug", "is_hotpack", "is_hotsplug", "is_hotslink", "is_hardpack", "is_hardPlug", "is_hotpl", "is_hotspl", "is_hardpl", "is_hardlink", "is_smartlink", "is_hotspack", "is_hotsPlug"], "p": ["f", "prop", "pat", "g", "pkg", "P", "fp", "jp", "part", "c", "h", "pre", "a", "post", "i", "port", "q", "cp", "bp", "y", "ip", "pp", "pi", "pb", "pl", "php", "pers", "lp", "pm", "r", "pc", "l", "pid", "d", "m", "pn", "pt", "ap", "sp", "wp", "b", "v", "ping", "n", "pa", "k", "ctx", "vp", "e", "app", "path", "par", "w", "it", "pe", "ps", "t", "tp", "j"], "dev": ["prop", "block", "bd", "h", "ad", "def", "debug", "dat", "cast", "query", "det", "scan", "dem", "v", "var", "out", "development", "val", "devices", "dis", "link", "mem", "vo", "normal", "proc", "pad", "Dev", "br", "hw", "sw", "bus", "test", "develop", "des", "device", "pi", "sd", "off", "ev", "comment", "alloc", "cmd", "db", "usb", "w", "nt", "stable", "ch", "th", "disk", "conn", "hd", "push", "dn", "nav", "err", "port", "fin", "util", "go", "enc", "buf", "ve", "pro", "ent", "raw", "serial", "cho", "jump", "ach", "cam", "draw", "tr", "res", "ver", "att", "form", "d", "gu", "dd", "dep", "app", "DEV", "data", "vc", "de", "di", "adv", "av", "eng", "od", "sh"], "bs": ["ls", "us", "is", "bh", "ks", "bi", "bits", "ubs", "rs", "iss", "bus", "bd", "BS", "js", "lbs", "ss", "bp", "obs", "vs", "ns", "cb", "pb", "ms", "ts", "its", "b", "bed", "bis", "sb", "bc", "gb", "cks", "bos", "ds", "ses", "qs", "gs", "bm", "cs", "ps", "aos", "fs", "bes"]}}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {\n\n        return;\n\n    }\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_schib_valid(&schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, &schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 18931, "substitutes": {"cpu": ["proc", "CPU", "bench", "arch", "boot", "runner", "conn", "processor", "hw", "prof", "cam", "jp", "clock", "c", "onet", "nic", "cli", "linux", "ck", "thread", "cp", "ork", "net", "np", "gc", "obj", "target", "hog", "cu", "pc", "nc", "sys", "vm", "ctx", "core", "nu", "apache", "alloc", "phys", "gpu", "mem", "exec", "pool", "node", "stat", "process", "uu", "t", "pu", "tp", "p"], "reg1": [" reg0", " reg2", "Reg2", "Reg1", "Reg0", "REG1", "register1", "REG4", "reg0", "reg2", "register0", "REG0", "REG2", "reg4", "register4", "register2", "Reg4"], "ipb": ["IPfb", "ipfb", " ipa", "ipbp", " ipB", " IPbp", " sipB", " ipfb", "IPa", " ipbp", "ipa", "IPb", " sipa", " IPa", " sipb", " IPb", "ipB", " clipb", " clipfb", " IPB", " sipbp", " clipa"], "cssid": ["ssolid", "jsid", "ssd", "catsid", "icsify", "jsuid", "apsid", "csuid", "cside", "jside", "cssify", "cmsID", "csify", "rssid", "csd", "cssd", "apsolid", "ssname", "apsuid", "ssify", "rssname", "rssd", "cssID", "csolid", "jsolid", "cmsd", "icsd", "sside", "apside", "icsid", "catside", "csid", "catsolid", "cmsname", "csside", "cssuid", "cssname", "rssID", "cmsid", "ssID", "cssolid"], "ssid": ["ossId", "ssuid", " ssuid", " sside", "ssit", "ssin", " ssin", "cside", "rssin", "ksId", "rssid", "ssida", "wside", "wspid", "ossit", "esside", "cssida", "wsid", "ksit", "sspid", "ssId", "ossid", "ksida", "sside", "osside", "rssit", "essid", "cssin", "csid", "rssuid", "csside", "cssuid", "essId", "csit", "kside", "rssId", "rsside", "essit", "ksid", "csspid", "csId", "wsida", "kspid"], "schid": ["scpid", "skib", "ssip", "choid", "chit", "cssit", "cssib", " schpid", "schip", "chib", "ssit", " schident", " schoid", "hashoid", "khoid", "cssip", "orcib", "hashid", "scheide", "schident", "orcit", "ssib", "scheib", "scident", "khpid", "khident", "schpid", "orcid", "schit", "schide", "scoid", "khid", "skoid", "scheip", "skid", "chid", "scheit", "schoid", "scid", "hashib", "orcide", "chide", "scheid"], "m": ["f", "tm", "mut", "g", "nm", "mr", "M", "c", "h", "mm", "sm", "cm", "i", "mc", "man", "dm", "r", "middle", "ms", "l", "imm", "id", "d", "vm", "b", "v", "n", "mid", "mn", "mat", "gm", "s", "md", "mem", "mi", "rm", "perm", "module", "bm", "mt", "t", "p"], "sch": ["kr", "sl", "chu", "cr", "ach", "sy", "sw", "orsche", "cht", "hess", "sm", "hed", "hs", "css", "mc", "Sch", "ss", "sc", "https", "sg", "sk", "hz", "sd", "soc", "shop", "hou", "sp", "ich", "kh", "squ", "mk", "sol", "ksh", "sym", "chan", "ssl", "her", "sky", "cs", "sche", "ch", "isch", "isc", "ssh", "cfg", "sh"], "schib": ["skibl", "skib", "chig", "khtab", "khim", "chib", "chlib", "sslIB", "schim", "skIB", "sslibl", "schibl", "scibl", "scib", "schIB", "sslib", "schig", " schIB", "schtab", "sklib", "khig", "scheib", " schlib", "skim", "skig", "scheIB", "sslig", "scig", "schetab", "scIB", "schlib", "schelib", "chIB", "skid", "khib", "scid", "sclib", "sktab", "scheig", "scheim", "scheid"], "addr": ["url", "rt", "aer", "attr", "offset", "rs", "oad", "ref", "host", "trans", "a", "iter", "err", " arch", "ag", "rc", "ret", "nl", "eth", "asm", "ad", " address", "order", "tr", "ip", "res", "rr", "align", "arity", " ref", "arr", "r", "address", "gr", "Address", " ip", "ac", "ap", "id", "sp", "ack", "ord", "gate", "cmd", "ix", "arm", "mem", "art", "dr", "adr", "ptr", "mt", "ace", "cmp", "hash", "rn", "add", "arp"], "cc": ["cf", "lc", "cv", "bb", "cell", "ctr", "inc", "c", "fee", "ld", "CC", "rc", "fc", "ck", "func", "mc", "ret", "sc", "acc", "gc", "soc", "tc", "dc", "ci", "cast", "ac", "pc", "cycle", "nc", "call", "cca", "con", "cl", "ctx", "k", "ct", "ctl", "contact", "bc", "uc", "cmd", "count", "vc", "ec", "erc", "cs", "isc", "xx", "cmp", "co", "cci", "cond", "cd", "PC"], "env": ["proc", "org", "window", "cv", "config", "ext", "end", "en", "conn", "er", "hw", "entry", "bean", "ef", "viron", "info", "term", "port", "te", "style", "eh", "order", "sc", "server", "enter", "dt", "net", "obj", "eni", "engine", "target", "enc", "e", "buf", "ter", "nc", "network", "den", "vm", "ctx", "v", "ev", "priv", "era", "esp", "code", "ve", "ei", "ew", "context", "console", "environment", "ner", "et", "desc", "next", "ec", "vt", "pe", "Environment", "scope", "eng", "ptr", "ped", "dev", "esc", "conf", "ten"], "ar": ["aer", "attr", "ear", "er", "ref", "as", "ir", "tar", "bar", "ag", "rar", "ro", "dar", "al", "r", "arr", "ra", "har", "aro", "ap", "var", "car", "area", "inter", "AR", "au", "are", "arm", "par", "am", "art", "ars", "adr", "at", "ptr", "ara", "mar", "war", "arc", "ard", "arp"]}}
{"project": "qemu", "commit_id": "7e5f90fa3ff32ea31548666d57a78005555ecf34", "target": 1, "func": "int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n\n                int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 18942, "substitutes": {"filename": ["url", "f", "nil", "ename", "binary", "FN", "nm", "location", "fp", "kl", "SourceFile", "username", "loc", "fil", "src", "dir", "buf", "path", "nw", "subject", "txt", "n", "png", "family", "Filename", "prefix", "file", "utf", "ln", "files", "directory", "source", "fn", "ame", "rn", "name", "jpg"], "ep": ["ele", "ere", "isp", "en", "eps", "dp", "fp", "yp", "peak", "gp", "ef", "EP", "pipe", "mp", "eth", "cp", "ip", "pp", "np", "e", "wp", "ap", "imp", "eb", "env", "sp", "eg", "ev", "esp", "dep", "ew", "ream", "et", "ek", "ape", "ec", "pe", "lip", "ps", "ea", "Ep", "tp", "p"], "loadaddr": ["lpad", "laddr", "laddress", "addaddress", "addaddr", "callarg", "loadaddress", "callpad", "loadpad", "calladdress", "addarg", "addpad", "calladdr", "larg", "loadarg"], "is_linux": ["is_cpu", "is_system", "Is_ubuntu", "is_os", "Is_linux", " is_Linux", " is_os", " is_windows", "issuccessLinux", "Is_system", "issuccesslinux", "Is_nice", "is_microsoft", "is_Linux", " is_cpu", "is_iso", "issuccesssystem", "is_nice", "Is_microsoft", "Is_Linux", "issuccessnice", "is_ubuntu", "is_windows", " is_iso"], "fd": ["proc", "f", "window", "fl", "ff", "disk", "open", "dra", "ind", "fp", " fin", "df", "dn", "std", "td", "fc", "dl", "stream", "lf", "pointer", "func", "draw", "fr", "dt", "fin", "len", "pos", "io", " fid", "cb", "sd", "dat", "handle", "da", "dir", "form", "pid", "d", "path", "fa", "FD", "ctx", "out", "dd", "socket", "raf", "fi", "db", "wind", "file", "ds", "ln", "fun", "fat", "bf", "ptr", "fn", "ini", "fs", "cond", "cd", "fed"], "size": ["length", "sum", "g", "sy", "sn", "sw", "c", "fee", "shape", "os", "name", "SIZE", "dim", "scale", "len", "ize", "too", " sizes", "set", "max", "grow", "small", "l", "now", "sp", "gz", "n", "area", "space", "sha", "Size", "send", "empty", "notice", "count", "mem", "status", "no", "izes", "news", "sized", "iz", "sh", "z", "step", "si"], "h": ["hr", "ih", "f", "ht", "bh", "header", "host", "hw", "hd", "hh", "H", "c", "hal", "eh", "he", "head", "sh", "hm", "oh", "ah", "dh", "l", "d", "m", "headers", "ph", "b", "v", "o", "hl", "dr", "hp", "hi", "t", "hs", "p"], "hdr": ["hr", "shvr", " htr", "phdr", "ohheader", "htr", "chdr", "chadr", "shr", "khdr", "shder", "expdr", " hpart", "hiarp", "ehdr", "ehDR", " hbr", "hivr", "ohdr", "HDR", "Hdel", "ohatt", "expbr", "shpr", "khDR", "ahtar", "herpart", "ihheader", "ihdr", "heDR", "herDR", "Hadr", "hepr", " hadr", "shDR", "ihstr", "khr", "achdr", "ehpart", "Hvr", "hstr", "chDR", "hatt", "ohstr", "hodr", "ohtar", "khder", "ahbr", "hpart", " hDR", "hbr", "Hr", "phstr", "helpdr", "helptr", "headr", "hebr", "ihder", "her", "hiDR", "Hder", "achmt", "Hatt", "harp", "oholder", "hdel", "herdr", " hstr", "ohadr", "ohtr", "hertr", "hodel", "hestr", "ihr", "achpr", "hadr", "shmt", "ahstr", "phder", "Holder", "hearp", "phheader", "hmDR", "shdr", "holder", "hevr", "hmdr", "expstr", " hr", "chvr", "hmadr", "hedr", "hmt", "hemt", "hopart", "ehvr", "ohbr", "hidr", "ahdr", "hDR", "Htr", "ohpart", "hepart", "ehdel", " hder", "achDR", "exptar", "htar", "helpDR", " harp", "Hdr", "hpr", "ohDR", "Hpart", "hmatt", "shadr", "hvr", "hoDR", "hder", "hheader", "helpolder", "ohder", "ihtr", " hvr"], "data": ["block", "cache", "memory", "pointer", "def", "ata", "ip", "read", "mu", "dat", "address", "table", "message", "out", "aw", "f", "extra", "done", "entry", "bus", "readable", " DATA", "len", "pos", "obj", "zero", "index", "DATA", "mode", "area", "empty", "w", "results", "dev", "name", "p", "to", "window", "length", "all", "end", "result", "map", "channel", "good", "valid", "buffer", "os", "error", "record", "file", "next", "raw", "image", "text", "type", "final", "padding", "d", "id", "rew", "n", "Data", "str", "format", "di", "bin", "base", "start", "t"], "compressed_data": ["compressed___data", "compressed___info", "comprypted_bytes", "compressededDATA", "compress_data", "compressed_image", "compressededwindow", "compressed_info", "compressed_window", "compressededdata", "compress_DATA", "compressed___mem", "compressed_mem", "compressed_DATA", "comprypted_data", "comprypted_mem", "compress_image", "comprypted_info", "compressed_bytes", "compress_window", "compressed___bytes", "compress_bytes"], "max_bytes": ["tmpingwindows", "max_bps", " MAX_errors", " MAX_bps", "maxingwindows", "max_lines", " MAXlexbits", "max_caps", " max_bits", "max____sections", "maxlexerrors", "maxlyseconds", "tmp_bytes", "max2bits", "max_sections", "max_Bytes", " MAX_bits", "MAX_bytes", "tmp_windows", "maxlypoints", "maxingbytes", "tmpingsections", " max_lines", "MAX_points", "maxlexbps", "max_windows", "MAX_seconds", "maxlexbits", "max____bytes", "tmp_caps", "max2lines", "maxlybytes", " MAXlexerrors", "max_points", "max2Bytes", "maxingsections", "tmpingcaps", "max____caps", "MAX_bits", "tmp_sections", "maxvalbytes", "tmpingbytes", "maxvalsections", "maxingcaps", " MAXlexbytes", " max_Bytes", "max2bytes", "maxvalwindows", "max_errors", "max____windows", " MAXlexbps", "maxlexbytes", "max_seconds", "maxvalcaps", " MAX_bytes", "maxlybits", "max_bits"], "bytes": ["tmp", "pages", "offset", "bits", "aws", "pointers", "trans", "loads", "xy", "ips", "values", "lines", "len", "byte", "ies", "ata", "body", "ims", "ns", "Bytes", "address", "errors", "rows", "parts", "total", "images", "tes", "fields", "frames", "features", "ds", "mem", "bps", "files", "flags", "raw", "gs", "seconds", "blocks", "items", "bs", "meta", "es"]}}
{"project": "FFmpeg", "commit_id": "2e5195646dc5578e1751004b0ac6e787d18637e4", "target": 1, "func": "static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MPCContext *c = s->priv_data;\n\n    int ret, size, size2, curbits, cur = c->curframe;\n\n    int64_t tmp, pos;\n\n\n\n    if (c->curframe >= c->fcount)\n\n        return -1;\n\n\n\n    if(c->curframe != c->lastframe + 1){\n\n        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);\n\n        c->curbits = c->frames[c->curframe].skip;\n\n    }\n\n    c->lastframe = c->curframe;\n\n    c->curframe++;\n\n    curbits = c->curbits;\n\n    pos = url_ftell(s->pb);\n\n    tmp = get_le32(s->pb);\n\n    if(curbits <= 12){\n\n        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;\n\n    }else{\n\n        tmp = (tmp << 32) | get_le32(s->pb);\n\n        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;\n\n    }\n\n    curbits += 20;\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n\n\n    size = ((size2 + curbits + 31) & ~31) >> 3;\n\n    if(cur == c->frames_noted){\n\n        c->frames[cur].pos = pos;\n\n        c->frames[cur].size = size;\n\n        c->frames[cur].skip = curbits - 20;\n\n        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);\n\n        c->frames_noted++;\n\n    }\n\n    c->curbits = (curbits + size2) & 0x1F;\n\n\n\n    if (av_new_packet(pkt, size) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->data[0] = curbits;\n\n    pkt->data[1] = (c->curframe > c->fcount);\n\n\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pts = cur;\n\n    ret = get_buffer(s->pb, pkt->data + 4, size);\n\n    if(c->curbits)\n\n        url_fseek(s->pb, -4, SEEK_CUR);\n\n    if(ret < size){\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n    pkt->size = ret + 4;\n\n\n\n    return 0;\n\n}", "idx": 18963, "substitutes": {"s": ["ls", "is", "us", "sts", "fts", "sv", "rs", "ins", "aws", "sw", "changes", "sq", "ops", "h", "xs", "ares", "js", "i", "opens", "ants", "os", "ss", "sc", "serv", "https", "ies", "vs", "ns", "ims", "set", "r", "e", "ms", "ats", "ts", "m", "sys", "conf", "its", "es", "b", "v", "ches", "se", "ties", "has", "bis", "sports", "sb", "stats", "oss", "ds", "qs", "ses", "S", "ers", "gs", "gets", "cs", "ps", "t", "bs", "als", "fs", "hs", "p"], "pkt": ["Pmt", "pwk", "opct", "cpet", "mwk", " pdu", "pingkg", "pkg", "packdu", "paacket", "mkg", "Pet", "Pkt", " pck", "cpct", "Pkg", "opacket", "packkt", " pmt", "Packet", "spnt", "mkt", "pck", "spacket", " pet", "packnt", "pingkt", "rkg", "pet", "lpkg", "opkt", "lpwk", "macket", "cpnt", "spkt", "pakt", "paet", "Pnt", " pwk", " packet", "prokt", "met", "pingnt", "spdu", "cpmt", "cpacket", "packet", "packacket", "proet", "pct", "rkt", "prokg", " pkg", "racket", "pinget", "proacket", "pack", "opnt", "pmt", "lpkt", " pct", "cpkt", " pnt", "lpacket", "mck", "pnt", "pdu"], "c": ["f", "cf", "lc", "cv", "cmp", "cr", "config", "g", "cache", "chain", "cn", "cam", "C", "ca", "cm", "abc", "rc", "fc", "com", "anc", "mc", "i", "cont", "ic", "cp", "sc", "conv", "comp", "etc", "cal", "gc", "unc", "tc", "enc", "cu", "r", "ci", "can", "ac", "pc", "nc", "con", "m", "cc", "v", "ctx", "ct", "xc", "bc", "uc", "ce", "count", "vc", "coll", "cur", "col", "ec", "comments", "cs", "t", "co", "conf", "arc", "dc", "cd", "p"], "ret": ["rt", "opt", "xt", "ext", "gt", "tn", "err", "conv", "len", "res", "elt", "ll", "re", "resp", "buf", "rev", "Ret", "ter", "RET", "txt", "v", "back", "out", " Ret", "total", "val", "rets", "et", "x", "alt", "mem", "status", "it", "nt", "mt", "t"], "size": ["sn", "shift", "pieces", "shape", "max", "message", "small", "skip", "send", "storage", "mem", "limit", "cmp", "new", "offset", "_", "sw", "cont", "len", "body", "obj", "zero", "area", "total", "space", "package", "empty", "notice", "uint", "msg", "name", "length", "sum", "sent", "dim", "set", "sp", "txt", "count", "number", "no", "type", "fp", "fee", "speed", "SIZE", "scale", "ize", "bytes", "height", "score", "num", "gz", "n", "Size", "data", "format", "fat", "news", "loss", "sh", "z", "timeout"], "size2": [" size02", "length02", "SIZE02", "timeout2", "ize2", "SIZE2", "sizetwo", "speed102", "score2", "size102", " sizetwo", "timeouttwo", "ize102", " size52", "size02", " size4", "size4", "size1", " size102", "ize02", "speed2", "score1", "sizedtwo", "size52", "SIZE52", "size5", "ize5", "SIZE3", "SIZE1", " size3", "score52", "length3", "size3", " size5", "sized2", " size1", "speed5", "ize1", "length2", "score4", "SIZE4"], "curbits": ["crubitis", "corbit", "curbitis", "curbios", "uncubinates", "curbitals", "cubbs", "custerites", "curgiting", "contibitions", "truffits", "custerits", "scurgats", "curbins", "crubbits", "cribited", "curbats", "bcurbats", "murbits", " curbbs", "curit", "uncurbits", "cobbbits", "acrobits", "curgites", "curtbits", "cribats", "crobins", "coblits", "cubiting", "cobbits", "cambites", "crubits", "caudugs", "uncurbios", "coblitals", "contibites", "curgbits", "crubitable", "cambats", "scurbiting", "caudats", " cretchits", "caudinates", "curgates", "uncurbites", "curbitable", "curgbs", "curbates", "murbited", "truffbits", "cribugs", "decrubits", "cibits", "curgitions", "dcurtits", "curditions", "curtitions", "uncurdits", "scurgiting", "uncribugs", "curbitors", "acrobitors", "acurbins", "cibitions", "coblital", "cribabilities", "uncurdbits", "caudabilities", "cubits", "curtited", "crubitions", "crubugs", " cretchouts", "turbit", "curtats", "acurbats", "scurbites", "cobbates", "truffit", "curbit", "cribitable", "cibates", "curbites", "cambiting", "cubinates", "truffites", "uncribits", "curgats", "cubouts", "cruffites", "bcruffits", "curbbits", "crubited", "curtits", "cribins", "conturbits", "custerios", "cruffital", "uncribites", "cruffit", "mribited", "curbabilities", "scurbits", "bcrubits", "dcurbats", "cuscitors", "turbites", "acurbits", "uncubits", "turbits", " cretchbits", " curbouts", "bcurbital", "curdbits", "curtites", "curbugs", "curdites", "cretchbs", "cambits", "uncribats", "crobited", "cretchats", "decrubited", "curbital", "curbited", "bcruffital", "cuscins", "scurgits", "caudits", "cruffitals", "dcurtabilities", "cibitis", "decurbitions", "uncubites", "cruffits", "cuscits", "murbites", "cubins", "scurbats", "corbites", "cubios", "cretchouts", "uncurdites", "conturbites", "cuberitals", "decrubitis", "contibates", "uncurbbits", "bcrubats", "uncurbats", "decurbited", "cobbites", "uncurbitions", "scurgites", "decurbitis", "curtabilities", "uncurbugs", "uncurbinates", "mribites", "dcurbits", "bcurbit", "dcurbabilities", "corbits", "acrobins", "cerbinates", "crubats", "curgits", "cibited", "cubbits", "bcurbitable", "cerbits", "decrubitions", "cuberits", "cribinates", "coblit", " curbbits", "cubitors", "murbins", "cretchits", "cubited", "contibits", "corbbits", "conturbitions", "crobitors", "acrobats", "curbiting", "curbbs", " cretchbs", "cuscats", "acurbitors", "cubites", "cruffbits", "mribits", "cobbitions", "cribbits", "crubites", "bcurbbits", "turbbits", "conturbates", "crobats", "cretchitable", "dcurtats", "custerinates", "bcurbitals", "curbinates", "bcrubbits", "cribites", "cubats", "cerbios", "caudites", "bcurbits", "cuberit", "curtitis", "curbitions", "crobits", "crobites", "curdits", "dcurbinates", "bcruffitals", "bcrubitable", "curits", "uncubios", "curgouts", "cretchbits", "cuberital", "cribits", "bcruffit", "cerbites", "curbouts", "decurbits", "mribins", "dcurtinates", "uncurditions", "curtinates", "curites", "cibites"], "tmp": ["nb", "tm", "prop", "rt", "cmp", "attr", "offset", "tt", "emp", "cache", "gt", "pkg", "test", "mm", "temp", "tar", "xy", "js", "mp", "cp", "etc", " resp", "np", "obj", "img", "cb", "util", " t", "stuff", "pot", "elt", "src", "loc", "resp", "buf", " mp", "m", "tf", "sp", " pts", "txt", "uff", "v", "ctx", "out", "mk", "cmd", "uv", "mem", "appy", "msg", "vt", "perm", "buff", "nt", "addr", "mb", "t", "tz", "ptr", " np", "bytes", "snap", "tp", "timeout", "p"], "pos": ["proc", "pad", "prop", "offset", "Pos", "open", "ref", "mut", "pkg", "neg", "trans", "part", "pose", "point", "pr", "port", "position", "os", "len", "res", "obj", "top", "loc", "pi", "spec", "pl", "rel", "resp", "pc", "pid", "pt", "index", "id", "ping", "sp", "off", "tell", "ctx", "local", "pres", "po", "reset", "val", "rot", "POS", "oss", "seq", "no", "pro", "op", "base", "limit", "start", "addr", "snap", "ps", "cmp", "conf", "cond", "rest", "p"], "curframe": ["corframe", "currentframe", "serfram", "corsequence", "Curfram", " curfram", "curfeature", "rctrace", "curthread", "catchline", "cFrame", "corfram", "lastthread", "curfram", "cortrace", "catchsequence", "ctrframe", " curwindow", "lastframe", "ctrwindow", "curtrace", "cframe", "forefram", "curline", "lastFrame", "curwindow", "rcline", "crthread", "lastsequence", "catchpanel", "currentFrame", "crfram", "Curline", " curtrace", "ctrfram", "serframe", "colsequence", " cursequence", "priFrame", "lastfram", " curFrame", "ctrsequence", "cfeature", "foreFrame", "rcframe", "rcpanel", "foreframe", "catchframe", "sersequence", "curpanel", "prifram", "colFrame", "lastfeature", "priframe", "crFrame", "crframe", "serwindow", "curFrame", "currentfeature", "rcsequence", "prithread", "Curpanel", "rcfram", "Curframe", "cursequence", "colfram", "Cursequence", "colframe"], "frames_noted": ["frames_note", "frames_ntefined", "framesoxtuned", "frames_NOTed", "frames_nten", "frames_naended", "frames_Notefined", "frames_naeed", "frames_noteed", "frames_NOTe", "frames_notefined", "framesoxtuneed", "frames_tune", "framesoxtunended", "frames_notended", "frames_tunended", "frames_NOTeed", "frames_tuned", "frames_Notied", "frames_tunefined", "frames_ntied", "frames_naed", "frames_Noten", "frames_noten", "framesoxnotended", "frames_Noted", "frames_tuneed", "framesoxnoted", "frames_nae", "frames_tunied", "frames_NOTended", "framesoxnoteed", "frames_nted", "framesoxtune", "frames_notied", "frames_tunen", "framesoxnote"]}}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,\n\n                            uint32_t value)\n\n{\n\n    int i;\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_readl(opaque, addr);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x \\n\", timer_id);\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n                timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n                if (new_val & HPET_TN_32BIT) {\n\n                    timer->cmp = (uint32_t)timer->cmp;\n\n                    timer->period = (uint32_t)timer->period;\n\n                }\n\n                if (new_val & HPET_TIMER_TYPE_LEVEL) {\n\n                    printf(\"qemu: level-triggered hpet not supported\\n\");\n\n                    exit (-1);\n\n                }\n\n\n\n                break;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n                break;\n\n            case HPET_TN_CMP: // comparator register\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP \\n\");\n\n                if (timer->config & HPET_TN_32BIT)\n\n                    new_val = (uint32_t)new_val;\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffff00000000ULL)\n\n                                  | new_val;\n\n                if (timer_is_periodic(timer)) {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffff00000000ULL)\n\n                                     | new_val;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_CMP + 4: // comparator register high order\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffffULL)\n\n                                  | new_val << 32;\n\n                else {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config\n\n                                & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffffULL)\n\n                                     | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_ROUTE + 4:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_ROUTE + 4\\n\");\n\n                break;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n                break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return;\n\n            case HPET_CFG:\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n                s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n                if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Enable main counter and interrupt generation. */\n\n                    s->hpet_offset = ticks_to_ns(s->hpet_counter)\n\n                                     - qemu_get_clock(vm_clock);\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        if ((&s->timer[i])->cmp != ~0ULL)\n\n                            hpet_set_timer(&s->timer[i]);\n\n                }\n\n                else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Halt main counter and disable interrupt generation. */\n\n                    s->hpet_counter = hpet_get_ticks();\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        hpet_del_timer(&s->timer[i]);\n\n                }\n\n                /* i8254 and RTC are disabled when HPET is in legacy mode */\n\n                if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_disable();\n\n                } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_enable();\n\n                }\n\n                break;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG+4 write \\n\");\n\n                break;\n\n            case HPET_STATUS:\n\n                /* FIXME: need to handle level-triggered interrupts */\n\n                break;\n\n            case HPET_COUNTER:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)\n\n                                  | value;\n\n               DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            case HPET_COUNTER + 4:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)\n\n                                  | (((uint64_t)value) << 32);\n\n               DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            default:\n\n               DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n               break;\n\n        }\n\n    }\n\n}\n", "idx": 18969, "substitutes": {"opaque": ["OPque", "operque", "iopaques", "Opque", "ipoch", "paque", "operatile", " opane", " opatile", "opatile", "ipque", "OPane", "compque", "operaque", "iopane", "OPaque", " opque", "opane", "Opane", "iopque", "pque", "compaque", "OPac", "operoch", "ipatile", " opac", "opque", " opoch", "pane", "Opaques", "compac", "Opaque", "paques", "ipaque", "opac", "compane", "opoch", "iopaque", "opaques"], "addr": ["pad", "act", "alias", "coord", "attr", "offset", "rank", "ref", "host", "hw", "conn", "ind", "init", "pkg", "tx", "ash", "iter", "point", " address", "ad", "ip", "pos", "obj", "loc", "align", "aj", "set", "src", "handle", "address", "r", "arr", "Address", "dh", "sys", "id", "ack", "ord", "ctx", "gate", "inter", "state", "alloc", "cmd", "ix", "prefix", "data", "x", "seek", "alt", "mem", "adr", "arp", "at", "ptr", "start", "ace", "adj", "cmp", "hash", "add"], "value": ["new", "unit", "type", "length", "initial", "VALUE", "test", "VAL", "size", "memory", "values", "port", "buffer", "json", "padding", "byte", "ue", "address", "commit", "Value", "local", "v", "time", "total", "state", "key", "weight", "data", "mem", "number", "format", "w", "python", "bin", "current", "field", "name"], "i": [" iii", " offset", " pos", " out", " mid", " resp", " ii", " arg", " ref", " bi", " ip", " err", " iter", " ind", " tid", " conn", "x", " l", " x", " m", " p", " j", " e", " ptr", " inv", "j"], "s": ["is", "sts", "sv", "rs", "iss", "aws", "sw", "sq", "sis", "js", "os", "ss", "serv", "ns", "spec", "session", "ts", "sys", "sp", "v", "socket", "sb", "services", "ds", "qs", "ses", "an", "S", "sam", "ssl", "gs", "ps", "t", "fs", "hs", "p"], "old_val": ["OLD_VAL", "OLD_value", "old_loc", "oldJserv", "old___loc", " old_value", "oldJval", "old_value", "old___bit", "old_bit", " old_bit", "old___serv", "old___val", "oldJvalue", " old_loc", "oldJloc", " old_serv", "old_VAL", "old_serv", "old___value", "OLD_val"], "new_val": ["new_col", "new___Val", "new_len", "new67val", "newJvalue", "new___bal", "new_vals", "new___vals", " new_bal", "old_vals", "new67Val", "new67col", "NEW_mem", " new_Val", "newJval", "NEW_vals", "new_value", "NEW_len", "newJlen", "new___len", "NEW_value", "NEW_val", "old_len", "NEW_Val", "new___serv", " new_col", "old_value", "new___value", "old_Val", "new_Val", "newJvals", "new___mem", "new___val", "new_mem", "new_bal", " new_value", "new_serv", " new_serv"], "val": ["new", "reg", "cho", "attr", "ref", "slot", "ind", "tx", "sel", "Val", "test", "err", "valid", "VAL", "ret", "pr", "func", "buffer", "serv", "res", "rol", "cal", "iv", "util", "loc", "elt", "pl", "item", "arr", "eval", "resp", "buf", "vol", "pol", "v", "ctx", "var", "lev", "data", "col", "mem", "bal", "vals", "aval", "msg", "mint", "dev", "cmp", "p"], "index": ["coord", "offset", "open", "ref", "ind", "init", "Index", "ion", "iter", "point", "info", "timeout", "pointer", "position", "order", "error", "pos", "loc", "set", "address", "sort", "scan", "list", "zero", "num", "id", "row", "ctx", "ord", "gate", "code", "inter", "key", "slice", "context", "axis", "ix", "x", "seek", "ptr", "dev", "hash", "add", "j"], "timer": ["program", "Timer", "cache", "er", "counter", "cer", "definition", "drm", "duration", "event", "menu", "tom", "monitor", "time", "acher", "req", "span", "imer", "tz", "rer", "tp", "roller", "taker", "clock", "test", "iter", "nr", "temp", "walker", "dt", "tim", "handler", "byter", "finder", "wrapper", "her", "trigger", "tm", "header", "mr", "peer", "tg", "older", "aster", "err", "term", "manager", "buffer", "tc", "driver", "sim", "meter", "txt", "loader", "task", "tick", "module", "attr", "later", "runner", "processor", "ctr", "icker", "worker", "thread", "browser", "player", "tem", "actor", "ter", "writer", "ger", "outer", "transfer", "t", "timeout"]}}
{"project": "qemu", "commit_id": "2af3da91839c04a5d73643b4eacce4cd93b9d428", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n", "idx": 18988, "substitutes": {"env": ["org", "window", "esm", "config", "sv", "estate", "en", "st", "shell", "er", "entry", "hess", "viron", "bar", "walker", "ef", "te", "def", "manager", "gear", "vs", "obj", "ee", "e", "buf", "ah", "me", "EN", "neck", "ctx", "v", "ev", "code", "ve", "operator", "ew", "context", "cmd", "environment", "db", "desc", "ner", "cur", "ec", "erd", "pe", "Environment", "dev", "esc", "sh"], "f": ["fd", "ff", "cf", "rf", "fp", "c", "h", "fac", "df", "fb", "fc", "lf", "buffer", "fr", "fx", "F", "e", "form", "tf", "d", "fm", "v", "b", "uf", "out", "sf", "fi", "full", "file", "fw", "w", "mac", "bf", "fo", "xf", "fn", "t", "fs", "p"], "cpu_fprintf": ["cpu_dwrite", "cpu_hprint", "cpu_fformat", "cpu_hprintf", "cpu_rprintln", "cpu_vprint", "cpu_rprintf", "cpu_hprintln", "cpu_rformat", "cpu_lformat", "cpu_lwrite", "cpu_rprint", "cpu_cprint", "cpu_dprintf", "cpu_cprintln", "cpu_dprint", "cpu_lprintf", "cpu_vprintf", "cpu_lprintln", "cpu_cprintf", "cpu_hformat", "cpu_vprintln", "cpu_hwrite", "cpu_rwrite", "cpu_dformat", "cpu_vformat", "cpu_cwrite", "cpu_dprintln", "cpu_fwrite", "cpu_fprint", "cpu_fprintln"], "flags": ["length", "ffff", "bits", "args", "settings", "size", "mask", "func", "ensions", "xp", "ags", "flag", " flag", "ents", "Flags", "d", "options", "code", "lag", "fields", "count", "vals", "cs", "ptr", "features", "fs", "cond", "name"], "i": ["us", "is", "bi", "gi", "ind", "chain", "c", "ri", "xi", "ki", "cli", "ai", "ini", "batch", "oi", "li", "ui", "ic", "ip", "in", "io", "y", "\u0438", "ami", "pi", "iu", "u", "im", "zi", "ci", "sim", "m", "me", "index", "id", "v", "I", "o", "j", "n", "ii", "ti", "key", "ei", "s", "phi", "fi", "ix", "x", "di", "number", "it", "mi", "ie", "uri", "ij", "iq", "t", "multi", "si", "p"]}}
{"project": "qemu", "commit_id": "8d0bcba8370a4e8606dee602393a14d0c48e8bfc", "target": 0, "func": "int net_init_socket(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    Error *err = NULL;\n\n    const NetdevSocketOptions *sock;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);\n\n    sock = opts->socket;\n\n\n\n    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 19003, "substitutes": {"opts": ["opt", " dopts", " dopt", " doptions", "OPs", "opte", "optt", " ops", "optts", "ops", "opls", "protions", "operts", "opfs", "optpt", "optls", "OPfs", " opte", "OPts", "optfs", "operos", "operls", "prot", "options", "opers", " opfs", "oppt", "optte", "OPte", "optos", "OPls", "propt", "opos", "OPos", " doppt", "opttions", "prots"], "name": ["new", "type", "alias", "nm", "er", "create", "chain", "nam", "part", "title", "root", "parent", "size", "names", "cap", "order", "version", "len", "event", "class", "spec", "group", "named", "cast", "none", "me", "path", "id", "ma", "num", "n", "time", "code", "family", "nom", "key", "comment", "package", "str", "prefix", "Name", "NAME", "file", "mem", "old", "common", "no", "format", "word", "domain", "base", "addr", "ident", "mod", "ame", "admin", "add", "normal"], "peer": ["proc", "component", "resource", "window", "er", "host", "pkg", "connection", "chain", "entity", "part", "vr", "channel", "older", "cer", "point", "ker", "peak", "parent", "worker", "inner", "pipe", "per", "manager", "buffer", "params", "enter", "server", "side", "device", "master", "target", "remote", "rel", "finger", "pc", "ter", "pod", "client", "ctx", "owner", "socket", "state", "context", "instance", "package", "holder", "member", "pro", "pool", "pe", "node", "ssl", "scope", "ger", "outer"], "errp": ["erP", "rrp", "errP", "rrps", " errps", "errps", "rrP", " errpp", "errpp", "erps", "erpp", "erp", "rrpp", " errP"], "err": ["proc", "kr", "Error", "attr", "cr", "br", "rs", "er", "conn", "mr", "c", "iter", "test", "fee", "cer", "rx", "ex", "rc", "Er", "or", "fr", "eor", "error", "res", "der", "obj", "cb", "rr", "r", "arr", "e", "buf", "resp", "sys", "txt", "eas", "aaa", "ev", "out", "gz", "cmd", "ner", "cur", "msg", "usr", "ch", "exc", "conf", "cfg"], "sock": ["symocked", "ysocked", "insoy", "osox", "dsock", " sck", "bsocked", "ysocker", "salong", "persockey", "gesck", "dsocker", "insocked", "geslock", "wocker", " soc", " socks", "inslock", "ysox", "jsockey", "sess", "nsoy", "alsock", "statsOCK", "tsock", "jsox", "msOCK", "isOCK", "isoy", "sockey", " sockey", "slock", "portsockey", "insick", "persox", "socks", "isocked", "dsack", "dsck", "ysock", "resocked", " socked", "socker", "salOCK", "insocket", "desox", "desocked", "six", "commocker", "svck", "desocker", "msocked", "osck", "msock", "slox", "yslock", "psoin", "alslock", "portsoco", "alsOCK", "portsod", "wock", " soy", "desconn", "nox", " sess", "ssOCK", "resoin", "gesox", "psocked", "persconn", "islock", "soc", "song", "stsack", "commlock", "persock", "synock", "soin", "commock", "bsocker", "tsOCK", "ssock", "psOCK", "essockey", "osod", "psock", "osocked", "dsog", "statsoin", "tsck", "essocked", "sack", "synck", "stsock", " sod", "salock", " sox", "synOCK", "desoco", "msocker", "wox", "sod", "tsocked", "bslock", "desocket", "soco", "desod", "isock", "psix", "desockey", "jsock", "nsock", "svock", "ysconn", "portsock", "stsocked", "isox", "symock", "wck", " soco", " slock", "symOCK", "symck", " sack", "sallock", "osock", "sOCK", "commocket", "socket", " socker", "insock", "salack", "jsocker", "salocked", "nsick", " six", "essoc", "insocker", " sOCK", "ssck", "ysockey", "sless", "desock", "dsocked", "nsocked", "bsock", "synocked", "statsocked", " sog", " sick", "sconn", "psocks", "alsocked", "sck", "slck", "ssocked", "nock", "sox", "sick", "gesock", "sog", "socked", "statsock", "jsocked", "tsoc", "jsoc", "alsocker", "svocked", "gesocker", "gesocked", "tsocker", "soy", "essock", " song", "noy", "svOCK", "jsck", "isocker", "dsocket", "resock", "resOCK", "nlock", "stsocker", "alsocket"], "fd": ["done", "cf", "fl", "ffff", "ff", "f", "fine", "fe", "conn", "ind", "fs", "fp", "bd", "fee", "df", "nd", "std", "td", "fb", "dl", "fc", "lf", "pipe", "size", "ini", "port", "fr", "dt", "dim", "fin", "pos", " fid", "cb", "sd", "dat", "da", "handle", "dir", "handler", "pid", "d", "fa", "id", "FD", "fm", "gz", "uf", "dd", "raf", "tty", "fi", "db", "file", "ds", "ln", "fun", "ptr", "fn", "rd", "ld", "cond", "fed"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 19005, "substitutes": {"v": ["f", "cv", "g", "sv", "vv", "vr", "c", "h", "i", "pr", "q", "conv", "y", "vs", "V", "ver", "r", "e", "l", "d", "m", "vi", "vm", "b", "k", "n", "o", "ev", "vis", "om", "vp", "s", "x", "vc", "uv", "nv", "mint", "w", "vt", "view", "av", "tv", "inv", "it", "t", "j", "p"], "obj": ["tmp", "org", "act", "ht", "object", "bh", "attr", "ref", "bj", "so", " ob", "xy", "js", "ck", "self", "ot", "obs", "elt", "impl", "inst", "acting", "expr", "objects", "resp", "Object", "txt", "ctx", "o", "po", "oj", " Obj", "et", "phys", " ok", "ent", "inv", "nt", "ob", "oid", "og", "adj", "Obj", "ist"], "name": ["text", "type", "alias", "attr", "na", "nm", "init", "part", " names", "def", "names", "cap", "order", "ns", "spec", "named", "ma", "id", "path", "local", "var", "n", "missing", "key", "s", "comment", "str", "cmd", "prefix", "NAME", "Name", "data", "an", "par", "common", "no", "ann", "w", "word", "ident", "t", "ame", "p"], "errp": [" errm", "crps", "rrp", "rrr", "rcjp", "rrd", "errm", "rcps", "err", "errpc", "crpa", "rrpa", " errpa", "erpc", "errpa", "erps", "errps", " errps", "crm", "errjp", "rrpc", "erjp", "erP", " errpc", "errP", "rrm", "erd", "rrP", "rcp", "rrjp", "erp", "rcP", " errd", "rrps", "errd", "crp", "errr", " errr"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)\n\n{\n\n    int d;\n\n    for( d = 0; d < 8; d++ ) {\n\n        const int p0 = pix[-1*xstride];\n\n        const int p1 = pix[-2*xstride];\n\n        const int q0 = pix[0];\n\n        const int q1 = pix[1*xstride];\n\n\n\n        if( FFABS( p0 - q0 ) < alpha &&\n\n            FFABS( p1 - p0 ) < beta &&\n\n            FFABS( q1 - q0 ) < beta ) {\n\n\n\n            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */\n\n            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */\n\n        }\n\n        pix += ystride;\n\n    }\n\n}\n", "idx": 19011, "substitutes": {"av_flatten": ["av___Flatten", "av_fratt", "av_fratten", "av___Flen", "av___Flatt", "av_fren", "av___flatt", "av_flen", "av___flatten", "av_fense", "av_Flense", "av___flen", "av_flatt", "av_fatt", "av_fatten", "av_fen", "av_Flatten", "av_Flatt", "av_frense", "av___flense", "av_flense", "av___Flense", "av_Flen"], "pix": ["pfx", "PIX", "px", " px", "Pfx", "psixels", "ppixels", "pfix", "tpx", " pIX", "psond", "prix", "spix", "ppip", "cpile", " pile", "pact", "cpact", "piip", "psile", "Pct", "repixels", "ppx", "pixels", "Pip", "Pix", " pact", "tpixels", "ppfix", "pressed", "cpix", "cpac", "repix", "spixels", "pct", "tpip", "repfx", "pitch", "apac", " pixels", "pile", "spIX", "prond", " pitch", " pfx", "psix", "Pixels", "ppIX", "ppix", "prressed", "apx", "pond", " pac", "pw", "cpx", "Px", " pond", "apix", "pIX", "psressed", " pfix", "spfix", " pct", "pip", "pac", "cpct", "piix", " pip", "prw", "tpix", "cpitch", "apitch", "piIX", "psact", "cpixels", "psw", " pw", "repIX", " pressed"], "xstride": [" xstrride", "ystrimate", "ySTRride", "xStride", "xstringide", "ySTRend", "xctrider", "xstrimate", "xstringend", " xdivid", "ystrace", "xStrider", " xdivide", "xstrade", "xdivause", "xSTRace", "ySTRice", "Xctrider", "ySTRide", "xstide", "Xctride", "xstringause", "xstause", "ySTRimate", "ystrride", "xgrice", "xSTRimate", "xSTRide", "Xctrides", "xstrend", "xstringimate", "Xctrade", "xdivid", "Xstrider", "Xstrides", "xSTRider", "Xstride", "xdivride", "ystrider", "xStrides", "xSTRade", " xdivause", "xstringace", "xSTRride", "xstid", "xctrade", "xvolride", "ySTRace", "xgride", "xctrice", "ystrice", " xstrause", "xSTRides", "xstrride", "xStrade", "xdivide", "xstrace", "xstringride", " xstrid", "xSTRend", "ystrend", "xvolide", "xvolimate", "xctride", "xstrider", "ySTRider", "xctrides", "xstrice", "xstrid", "xstringid", "xStrend", "xgrride", "xSTRice", "xgrider", " xdivride", "Xstrade", "xstrides", "xStrice", "xstringice", "xStrace", "xctrride", "xvolace", "xstrause"], "ystride": ["ytride", "ypride", "ycharide", "ystriden", "yslension", "ycharension", "xdividen", "yprine", "yprate", "xstrride", "ystrride", "ystrate", "ytrate", " ystrate", "ysliden", " yconstate", "xstrension", "xdivide", "ydivension", "ychariden", " yconstide", "xdivension", "yconstide", "ydivride", "yconstate", " ystrine", "xstriden", "ystrine", "ycharride", "xdivride", "ytrine", "ystrension", "yconstine", " yconstine", "yslide", "ydividen", "yslride", "ydivide"], "alpha": ["appa", "alias", "qa", "ax", "lambda", "inc", "a", "ta", "h", "ca", "HA", "ia", "i", "ity", "scale", "al", "pi", "star", "da", "height", "ac", "ra", " gamma", "fa", "ma", "Alpha", "phas", "upper", "A", "acl", "angle", "ar", "val", "phi", "au", "asc", "pha", "xa", "alph", "la", "p"], "beta": ["prime", "igma", "elta", "alias", "binary", "qa", "bi", "lambda", "filter", "a", "ta", "ca", "fty", "xff", "term", "te", "scale", "bp", "\u03b2", "aa", "p", "mu", "frequency", "u", "fa", "Alpha", "zero", "gam", "broad", "b", "v", "bis", "ii", "phi", "ba", "pha", "Beta", "base", "alph", "dev", "z", "normal"], "d": ["fd", "done", " de", "did", "g", "dra", "dx", "dy", "ind", "c", "du", "bd", "nd", "i", " delta", "draw", "dal", "ad", "def", "dim", "dt", "diff", "del", "D", "debug", "dat", "da", "e", " dim", "dir", "l", "m", "den", "b", "cd", "ord", "n", "days", "out", "back", "dd", "md", "db", "x", "de", "ds", "di", "w", "dr", " D", "mod", "t", "dev", "dig", "ld", "dc", "pd", "j", "p"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n\n{\n\n    char local[13];\n\n\n\n    memcpy(local, version, 12);\n\n    local[12] = 0;\n\n\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n\n    if (vs->major != 3 ||\n\n        (vs->minor != 3 &&\n\n         vs->minor != 4 &&\n\n         vs->minor != 5 &&\n\n         vs->minor != 7 &&\n\n         vs->minor != 8)) {\n\n        VNC_DEBUG(\"Unsupported client version\\n\");\n\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n\n     * as equivalent to v3.3 by servers\n\n     */\n\n    if (vs->minor == 4 || vs->minor == 5)\n\n        vs->minor = 3;\n\n\n\n    if (vs->minor == 3) {\n\n        if (vs->auth == VNC_AUTH_NONE) {\n\n            VNC_DEBUG(\"Tell client auth none\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_client_init(vs);\n\n       } else if (vs->auth == VNC_AUTH_VNC) {\n\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_auth_vnc(vs);\n\n       } else {\n\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n            vnc_flush(vs);\n\n            vnc_client_error(vs);\n\n       }\n\n    } else {\n\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n\n        vnc_write_u8(vs, 1); /* num auth */\n\n        vnc_write_u8(vs, vs->auth);\n\n        vnc_read_when(vs, protocol_client_auth, 1);\n\n        vnc_flush(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19023, "substitutes": {"vs": ["is", "ks", "vd", "args", "js", "ims", "docs", "lv", "v", "stats", "qs", "posts", "co", "terms", "bits", "outs", "eps", "sw", "xs", "aps", "ports", "values", "ants", "lbs", "ss", "pps", "heads", "ns", "ms", "parts", "wcs", "times", "points", "vals", "inv", "VS", "keys", "cs", "ils", "hs", "vp", "uds", "sts", "rs", "blogs", "vv", "ops", "ads", "lines", "caps", "vers", "tops", "Vs", "atts", "words", "vt", "gs", "gets", "ows", "bs", "checks", "ls", "pages", "sv", "ins", "changes", "lists", "vr", "names", "obs", "ver", "ts", "its", "vm", "vc", "views", "ds", "ps", "otes", "fs", "es"], "version": ["text", "VER", "length", "type", "bits", "vector", "ion", "channel", "versions", "info", "size", "scale", "byte", "ver", "spec", "message", "value", "vers", "v", "VERSION", "binding", "wire", "Version", "package", "feature", "number", "uint", "node", "command", "tag", "pack", "iso", "hash", "release", "name"], "len": [" n", "length", "lan", "type", "en", "Len", " bl", " common", "rc", "size", "bytes", "al", "lp", "l", "el", "v", "n", " c", " length", " clen", " l", "vc", "common", "lib", "lic"], "local": ["new", "close", "tmp", "window", "length", "all", "initial", "cache", "final", "pal", "as", " locals", "a", "lock", "valid", "le", "inner", "self", "shared", "server", "null", "util", "al", "loc", "master", "public", "remote", "ac", "Local", "l", "localhost", "m", "list", "el", "client", "v", "global", "n", "var", "out", "mail", "state", "val", "where", "empty", "full", "data", "file", "on", "mem", "old", "common", "external", "save", "serial", "pack", "foreign", "sel", "name", " Local", "p"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 19027, "substitutes": {"base": ["f", "type", "from", "bi", "create", "end", "ref", "based", "en", "as", "init", "a", "h", "ada", "c", "use", "bar", "origin", "ASE", "root", "i", "size", "port", "Base", "buffer", "store", "scale", "server", "bp", "ip", " Base", "pi", "set", "re", "address", "e", "check", "m", "sys", "id", "cpu", "b", "v", "balance", "pa", "back", "area", "out", "se", " bases", "key", "reset", "kb", "ase", "prefix", "db", "bare", "file", "site", "eta", "bound", "bas", "source", "start", "bu", "mb", "range", "name", "p"], "env": ["org", "window", "cv", "end", "sv", "en", "conn", "er", "hw", "jp", "vr", "h", "viron", "stage", "bar", "pen", "server", "sc", "vs", "np", "obj", "home", "cb", "set", "enc", "e", "max", "buf", "nc", "network", "con", "eu", "v", "ctx", "ev", "code", "sb", "ei", "context", "environment", "req", "site", "nv", "ec", "vt", "pe", "scope", "eng", "ptr", "dev", "conf", "vp"], "s": ["is", "er", "as", "states", "fs", "a", "h", "c", "args", "js", "i", "store", "y", "vs", "ims", "e", "v", "o", "has", "stats", "storage", "qs", "ses", "less", "ers", "aws", "ports", "ss", "ns", "spec", "actions", "parts", "space", "services", "S", "conf", "p", "sl", "sts", "g", "rs", "ops", "sq", "q", "os", "set", "pers", "l", "m", "sp", "acs", "socket", "sb", "gs", "sa", "comm", "bs", "ls", "sv", "ins", "changes", "properties", "params", "sc", "r", "ats", "ts", "its", "b", "se", "n", "ds", "sam", "ps", "t", "details", "j", "es"], "iomemtype": ["iomimerplate", "iememty", "iomemotype", "iomimerType", "iblemplate", "iologyemvalue", "iomidemtype", "iologyimertype", "iomimvalue", "iomimplate", "iemimtype", "iologyemType", "iologyimervalue", "iomimervalue", "iomemstatus", "iomemerplate", "iomemvalue", "iemimType", "iomemplate", "iomemstype", "iomidemType", "iomemerotype", "iologyimerplate", "iomademtype", "iomeminotype", "iomimType", "iomemType", "iomimTYPE", "iomemTYPE", "iomemsType", "iemimTYPE", "iememtype", "iomotortype", "ibleminplate", "iblemtype", "iomemertype", "iblemintype", "iomemerstatus", "iememTYPE", "iomidemplate", "iologyimerType", "iologyemplate", "iblemstatus", "iologyemtype", "iomotorplate", "iomeminstatus", "iomemsTYPE", "iomemintype", "iememType", "iomeminplate", "iomotorotype", "iomotorstatus", "iomimtype", "iemimty", "ibleminstatus", "iomemsty", "iomademTYPE", "iomimty", "iomidemvalue", "iblemotype", "iomademType", "ibleminotype", "iomemty", "iomimertype", "iomademty"], "qi": [" ki", "cgi", "qa", "quire", "sq", "ike", "ki", "afi", "Q", "Ni", "\u043e", " sq", "i", "ia", "ifa", " Qt", "dq", " q", "q", "ui", "li", "oka", "ql", "eni", "qt", "aq", "qq", "ni", "cu", "query", "gui", " cu", "qv", " pi", "igi", "eas", " cis", "squ", "ii", "ei", "iza", "fi", "IQ", " IQ", "agi", " ti", "qs", " ni", " si", " Ni", " MI", "iq", "ique", "ini", "cci", "si"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static int mp_decode_frame(MPADecodeContext *s, OUT_INT **samples,\n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    int i, nb_frames, ch, ret;\n\n    OUT_INT *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);\n\n\n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        skip_bits(&s->gb, 16);\n\n\n\n    switch(s->layer) {\n\n    case 1:\n\n        s->avctx->frame_size = 384;\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        s->avctx->frame_size = 1152;\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n        s->avctx->frame_size = s->lsf ? 576 : 1152;\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n\n\n        if (nb_frames < 0)\n\n            return nb_frames;\n\n\n\n        s->last_buf_size=0;\n\n        if (s->in_gb.buffer) {\n\n            align_get_bits(&s->gb);\n\n            i = get_bits_left(&s->gb)>>3;\n\n            if (i >= 0 && i <= BACKSTEP_SIZE) {\n\n                memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);\n\n                s->last_buf_size=i;\n\n            } else\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid old backstep %d\\n\", i);\n\n            s->gb           = s->in_gb;\n\n            s->in_gb.buffer = NULL;\n\n        }\n\n\n\n        align_get_bits(&s->gb);\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        i = get_bits_left(&s->gb) >> 3;\n\n\n\n        if (i < 0 || i > BACKSTEP_SIZE || nb_frames < 0) {\n\n            if (i < 0)\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid new backstep %d\\n\", i);\n\n            i = FFMIN(BACKSTEP_SIZE, buf_size - HEADER_SIZE);\n\n        }\n\n        assert(i <= buf_size - HEADER_SIZE && i >= 0);\n\n        memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n\n        s->last_buf_size += i;\n\n    }\n\n\n\n    /* get output buffer */\n\n    if (!samples) {\n\n        av_assert0(s->frame != NULL);\n\n        s->frame->nb_samples = s->avctx->frame_size;\n\n        if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n        samples = (OUT_INT **)s->frame->extended_data;\n\n    }\n\n\n\n    /* apply the synthesis filter */\n\n    for (ch = 0; ch < s->nb_channels; ch++) {\n\n        int sample_stride;\n\n        if (s->avctx->sample_fmt == OUT_FMT_P) {\n\n            samples_ptr   = samples[ch];\n\n            sample_stride = 1;\n\n        } else {\n\n            samples_ptr   = samples[0] + ch;\n\n            sample_stride = s->nb_channels;\n\n        }\n\n        for (i = 0; i < nb_frames; i++) {\n\n            RENAME(ff_mpa_synth_filter)(&s->mpadsp, s->synth_buf[ch],\n\n                                        &(s->synth_buf_offset[ch]),\n\n                                        RENAME(ff_mpa_synth_window),\n\n                                        &s->dither_state, samples_ptr,\n\n                                        sample_stride, s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * sample_stride;\n\n        }\n\n    }\n\n\n\n    return nb_frames * 32 * sizeof(OUT_INT) * s->nb_channels;\n\n}\n", "idx": 19041, "substitutes": {"s": ["us", "is", "er", "as", "a", "c", "h", "args", "js", "ies", "vs", "details", "ims", "series", "v", "utils", "has", "stats", "qs", "ses", "less", "comments", "als", "aws", "sw", "ports", "ants", "ss", "serv", "sg", "ns", "spec", "ms", "parts", "bis", "sports", "state", "services", "an", "w", "S", "source", "cs", "conf", "hs", "p", "sts", "ains", "rs", "ops", "sq", "still", "service", "os", "set", "pers", "m", "sb", "ar", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "settings", "ats", "ts", "sys", "its", "ties", "n", "se", "ds", "sam", "ps", "t", "fs", "z", "j", "es"], "samples": ["Samps", " sample", "specample", "sents", "samps", "sample", "Sents", "specamples", "Sample", "specamps", "specents", " sents", "Samples", " samps"], "buf": ["tmp", "ff", "cv", "length", "block", "br", "cache", "ref", "vec", "wb", "err", "fb", "bar", "rc", "Buff", "xff", "buffer", "Buffer", "rb", "len", "bytes", "img", "np", "cb", "pb", "max", "BU", "b", "uf", "out", "db", "cmd", "data", "cur", "mem", "msg", "raw", "buff", "bin", "bf", "queue", "p"], "buf_size": [" buf_SIZE", "buf64pos", "buf_pos", "buf__", "buff2count", "buff2length", " buf_limit", "buf64Size", " buf_Size", "cb_f", "buf64SIZE", "buff2SIZE", "buff_length", "buff2size", "buf_length", "buf2length", "buf2SIZE", "buf_count", "buf_f", "buf_Size", " buf_pos", "bufptf", "buf2size", "bufpt_", "buff_count", "buf64size", "buf_limit", "buff_SIZE", "buf_SIZE", "buf2count", "cb__", "buff_size"], "i": ["f", "is", "length", "g", "bi", "gi", "ir", "c", "h", "xi", "cli", "ai", "info", "ia", "oi", "q", "li", "ui", "conv", "ic", "ip", "y", "ish", "ami", " ii", "io", "ims", "pi", "iu", "qi", "u", " bi", "ci", "zi", "l", "me", "m", "sim", "index", "id", "b", "v", "k", "I", "n", "j", "o", "ori", "ii", "ti", "ei", "fi", "phi", "ix", "x", " ti", "di", " ni", "it", "mi", "hi", "limit", "ij", "ini", "yi", "multi", "si", "p"], "nb_frames": ["nb67points", "obb_points", "nbJframe", "obbptruns", "obb_runs", "obb67points", "nbJbits", "nb_points", "nbJobs", "obb_events", "NB_states", "nb___states", "num_bits", "nbuffyvalues", "nb_obs", "nb67runs", "nb23hops", "nb_runs", "NB_frames", "NB_flows", "unique_flows", "numxobs", "obb67frames", "lenuffyframes", "nboyflows", "nb___flows", "numxbits", "NB_hops", "lenuffyimages", "lenuffyvalues", "nbuffyframes", "obbptflows", "nb_frame", "nbxframes", "num_obs", "unique_blocks", "abb_points", "nbJframes", "nb23states", "nb67items", "nb23flows", "nbptframes", "nbptflows", "nb_images", "obb_items", "abb_frames", "nb_flows", "nb_hops", "uniqueoywords", "nbptruns", "nb23frames", "unique_words", "nbxframe", "nboyframes", "nb_words", "obbptevents", "nb67events", "uniqueoyflows", "nb67flows", "obb_frames", "nbJwords", "nbPframes", "uniqueoyframes", "nb_items", "num_frames", "uniqueoyblocks", "nbPpoints", "len_frames", "nb_blocks", "nb____frames", "nb67frames", "nb____images", "nbptevents", "nbxbits", "abb_blocks", "num_frame", "nbJflows", "nb_states", "len_images", "unique_frames", "nb___hops", "nbPitems", "nb____points", "obbptframes", "obb_flows", "abb_images", "nb___frames", "nb____blocks", "numxframe", "obb67flows", "obb67items", "len_values", "nboyblocks", "nbxobs", "nb_values", "nbJblocks", "nb_bits", "nbPflows", "numxframes", "nbuffyimages", "nb_events", "nboywords"], "ch": ["ih", "cho", "th", "ach", "jp", "channel", "och", "chip", "q", "cp", "sc", "res", "qt", "cb", "pc", "chi", "ich", "ctx", "ct", "tch", "col", "cur", "chan", "cs", "sch", "cmp", "CH"], "ret": ["new", "rt", "gt", "ref", "jp", "rem", "conv", "len", "res", "pert", "elt", "re", "rel", "RET", "Ret", "txt", "out", "ft", "reset", "val", "et", "alt", "status", "nt", "tif", "mt", "hash"], "samples_ptr": ["samples__Ptr", "samples_size", "samples__size", "samples__pointer", "samples_Ptr", "samples__ptr", "samples_pointer"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}", "idx": 19075, "substitutes": {"options": ["opt", "config", "ptions", "ops", "args", "oops", "settings", "aps", "info", "ans", "properties", "os", "styles", "params", "some", "spec", "classes", "ms", "ts", "caps", "kw", "parts", "Options", "tops", "uploads", "roots", "option", "times", "atts", "stats", "flags", "op", "keys", "mt", "ps", "tags", "meta", "details"], "errp": ["erpg", "lerpa", "errping", "rrp", "errorr", " erper", "rrping", " erpg", "errpg", "errorpg", "rrpp", "err", " errP", " erp", "errorp", "lerper", "errpa", " erpa", "lerp", "erps", "errorps", "errps", " errps", "errorpa", "errorper", "errper", "lerpg", "rrpg", "errpp", "erpp", "errorping", "erping", "erP", "errorP", "errP", " errpp", "erp", "rrps", "errr", " errr"], "inet": [" eth", "binary", "offset", "het", " IP", "conn", "connection", "iss", "init", "iw", "onet", "interface", "virtual", "afi", " NI", "anc", "i", "eth", " ut", " anew", " mac", "dt", "pton", "ip", "iat", "net", " socket", "elt", "kt", " Ethernet", "target", " dst", "address", " eq", "det", "localhost", " ip", " net", "network", " VIP", "ect", "local", "client", " xp", " target", "socket", " dest", "fi", "ix", "prefix", "inel", "et", "ant", "oss", "ds", " local", "initialized", " ni", "nt", "tif", "tz", "sat", "iq", "ifi"], "addr": ["rid", "url", "pad", "rt", "act", "opt", "amp", "attr", "bind", "rs", "ref", "host", "conn", "pkg", "map", "ash", "args", "err", "aps", "ad", "os", "params", "ip", "pos", "obj", "ns", "elt", "align", "rel", "r", "arr", "address", "dir", "Address", "expr", "rect", "ack", "ord", "ctx", "parts", "cmd", "ix", "db", "prefix", "alt", "points", "mem", "encrypted", "art", "dr", "adr", "news", "ress", "ptr", "mt", "ace", "conf", "add", "arp"], "crumpled_addr": ["crumpled2addr", "crumbled_cmd", "crumpled___cmd", "crumpled_add", "crumbled_loc", "crumbled_ord", "crumpled_obj", "crumpled__add", "crumpling_mem", "crumbled_address", "crumpling_address", "crumpled_address", "crumbled_addr", "crumpled_ord", "crumpled2obj", "crumpling_arr", "crumpled__ptr", "crumpled_arr", "crumpled___address", "crumpling_obj", "crumpled_cmd", "crumpling_addr", "crumbled_obj", "crumpled_loc", "crumbled_add", "crumpled_ptr", "crumpled__addr", "crumpled___arr", "crumpled___addr", "crumpled2address", "crumpled_mem", "crumpled2cmd", "crumbled_ptr", "crumpled___obj"], "iv": ["ih", "ior", "iver", "vir", "ik", "iva", "vv", "ir", "vr", "nov", "iter", "iw", "ov", "i", "Iv", "liv", "voc", "ip", "iat", "ib", "rir", "iov", "qv", "vi", "v", "var", "VI", "ev", "oc", "fi", "ive", "riv", "vc", "uv", "ec", "iro", "nv", "ivo", "tv", "ient", "vt", "it", "av", "ival", "ij", "ptr", "iq", "iph", "IV", "vp"], "local_error": ["global_Error", "local_Error", "local_event", "localityError", "localpydetail", "local____danger", " local_problem", "localityevent", "localpydanger", " local_Error", "localpyerror", "local_ror", "localityror", "localityerror", "local_detail", "local_problem", "local_danger", "global_ror", " local_detail", "local____error", " local_danger", " local_ror", "global_error", " local_warning", "global_event", "local____detail", "local_warning"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 19082, "substitutes": {}}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n", "idx": 19090, "substitutes": {"ioc": ["piOC", "diroc", "lioc", "iico", "uioc", "iocate", "liOC", "liroc", "dioco", "oocate", " ioci", "uiroc", " iosc", " iocate", "uiocate", "ooc", "dioc", "piroc", "diico", "uiosc", " ioco", "iocal", "uioco", "iosc", "iOC", "uioci", " iocal", "ioco", " iroc", " iico", "pioc", " iOC", "piocal", "ioci", "ooci", "uiico", "oosc", "iroc", "liocal"], "buffer": ["window", "bb", "length", "block", "binary", "cache", "phrase", "page", "map", "channel", "document", "stream", "Buffer", "byte", "read", "face", "table", "buf", "message", "sequence", "b", "paste", "uf", "empty", "data", "raw", "buff", "base", "source", "command", "queue", "variable", "batch"], "size": [" Size", "type", "length", "sum", "offset", "sn", "fee", "args", "use", "timeout", "sent", "shape", "SIZE", "dim", "scale", "len", "ize", "read", "set", "message", "time", "out", "code", "space", "send", "Size", "empty", "count", "seek", "mem", "format", "addr", "scope", "ptr", "t", "iz", "__", "name", "si"], "ret": ["rt", "run", "g", "gt", "st", "result", " RET", "cat", "std", "lit", "tail", "cont", "len", "tr", "res", "elt", "gc", "match", "arg", "re", "arr", "r", "flag", "RET", "Ret", "sys", "sp", "uf", "out", "total", "print", "val", "alt", "mem", "it", "raw", "nt", "limit", "try", "ptr", "mb", "mt", "t", "__"], "watch": ["cv", "rain", "parse", "ach", "g", "cache", "er", "cam", "push", "channel", "cat", "WATCH", "lock", "track", "warn", "store", "serv", "thread", "ignore", "read", "ait", "patch", "match", "wat", "check", "scan", "query", "sync", "call", "sp", "row", "v", "var", "out", "see", "priv", "aw", "key", "change", "atcher", "seek", "write", "wait", "feature", "mem", "status", "w", "chan", "raw", "atch", "ch", "t", "share", "Watch", "timeout", "batch"]}}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n", "idx": 19102, "substitutes": {"opaque": ["opent", "popaque", "iopaques", "oppacity", "Opque", "oplacity", "popais", "opacity", "oplaque", "iopque", "oppais", "obaque", "obent", "obque", "popacity", "popaques", "opque", "Opaques", "oppaque", "Opaque", "oplais", "oppaques", "iopent", "Opent", "oplaques", "iopaque", "obaques", "opais", "opaques"], "ret": ["rt", "pat", "ext", "gt", "ref", "sec", "jp", " RET", "err", "xy", "def", "len", "tr", "res", "elt", "re", "arg", "resp", "det", "RET", "Ret", "ter", "tf", "ct", " Ret", "back", "code", "ft", "nz", "inter", "val", "rets", "cmd", "count", "x", "alt", "et", "mem", "deg", "status", "nt", "aux", "rm", "try", "magic", "mt", "reply", "t", "hash", "ry"], "ctx": ["org", "cv", "dad", "init", "def", "etc", "jac", "np", "kt", "inst", "mom", "check", "work", "req", "cmp", "co", "dc", "proc", "cf", "act", "hw", "tx", "std", "ca", "cp", "obj", "ns", "cb", "cu", "expr", "context", "alloc", "cmd", "pg", "nt", "conf", "cfg", "tm", "window", "conn", "pkg", "ind", "cm", "jj", "wx", "tc", "resp", "pt", "kw", "txt", "cl", "ct", " cx", "ctrl", "prefix", "desc", "tk", "aux", "batch", " context", "crit", "rt", "config", "kick", "bj", "jp", "kl", "td", "dl", "abc", "fc", "worker", "ck", "func", "kj", "urg", "xp", "gc", "qt", "unc", "nc", "sys", "cc", "ctl", "xc", "exec", "addr", "timeout"], "t2": ["ot4", "T0", "t0", "T5", "t3", "f3", " t_", "T3", " t3", "time1", " T3", " t1", "p5", "t5", "T2", " ttwo", " T4", " t5", "f2", "ot1", "p1", "t1", "t_", "ot2", "f1", "p0", "ttwo", "time2", " t4", " T1", "timetwo", "f_", " T2", "time3", " t0", "kttwo", "ot3", "t4", "T4", "kt2", "p2", "time4", "T1", "kt4", "T_"], "cmp_buf": ["comp_buffer", "cmp_bu", "comp_bytes", "cmp___buf", "cmp_fac", "cmp___buffer", "cmp1vec", "mp_buf", "comp_fac", "cmp_buffer", "comp_buff", "comp_buf", "cmp_bytes", "cmp__vec", "cmp__buffer", "cmp___bytes", "cmp1buf", "cmp_vec", "cmp__buf", "cmp_buff", "mp_buffer", "cmp1buffer", "comp_vec", "cmp1fac", "cmp___bu", "mp_vec", "comp_bu"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 19108, "substitutes": {"ctx": ["tmp", "cf", "act", "px", "ok", "conn", "Context", "pkg", "hw", "jp", "tx", "c", "ca", "cm", "ck", "mc", "CT", "cp", "obj", "qt", "cb", "gc", "wx", "tc", "cu", "ci", "nc", "sys", "kw", "cc", "ct", " cx", "xc", "bc", "context", "cas", "req", "cmp", "co", "cfg"], "gprn": ["gpolid", " gprr", " gprnb", "gsprn", "GsprN", "gsprna", "gwrnum", "gprid", "gpolnum", " gsprn", "gsprnb", "Gsprn", "gptrr", "gptrnb", "gfrr", "gsprN", "Gprnum", "gwrn", "gsprnum", "gpoln", "GprN", " gsprnb", "gprna", " gprna", " gsprr", "Gprid", "gsprr", "gprr", "gfrna", "gsprid", "gfrnb", "Gsprid", "gptrn", "gprnb", "Gprn", "gpolN", "gprN", "gprnum", "gwrN", "Gsprnum", "gwrid", " gsprna", "gfrn", "gptrna"], "sprn": ["prN", "sprnb", "svN", "krn", "prnb", "svnb", "sprN", "sprnr", "krnr", "krnb", "svn", "svnr", "prn", "prnr", "krN"]}}
{"project": "qemu", "commit_id": "732b530c1bd064bdcc29975c0b78fc6de8c47e7f", "target": 0, "func": "static void nvdimm_build_common_dsm(Aml *dev)\n\n{\n\n    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;\n\n    uint8_t byte_list[1];\n\n\n\n    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);\n\n    function = aml_arg(2);\n\n    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);\n\n\n\n    /*\n\n     * do not support any method if DSM memory address has not been\n\n     * patched.\n\n     */\n\n    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));\n\n\n\n    /*\n\n     * function 0 is called to inquire what functions are supported by\n\n     * OSPM\n\n     */\n\n    ifctx = aml_if(aml_equal(function, aml_int(0)));\n\n    byte_list[0] = 0 /* No function Supported */;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    /* No function is supported yet. */\n\n    byte_list[0] = 1 /* Not Supported */;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    /*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     */\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    /*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     */\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n", "idx": 19115, "substitutes": {"dev": ["proc", "disk", "block", "test", "eth", "ay", "def", "definition", "error", "device", "event", "reader", "driver", "example", "handler", "env", "v", "param", "var", "ev", "development", "app", "member", "cmd", "DEV", "module", "eng"], "method": ["sm", "memory", "eth", "def", "man", "attribute", "top", "event", "message", "met", "arm", "mem", "private", "command", "med", "field", "gem", "proc", "mount", "test", "interface", "rem", "inner", "hod", "power", "spec", "session", "im", "handler", "smart", "path", "and", "wrapper", "context", "package", "cmd", "process", "mod", "ident", "variable", "name", "job", "cell", "map", "user", "service", "self", "manager", "util", "class", "sim", "m", "model", "history", "instance", "member", "view", "module", "attr", "mm", "property", "METHOD", "mp", "func", "Method", "tr", "public", "form", "month", "this", "call", "param", "direct", "magic"], "ifctx": ["ifcfg", "iffcfg", "iwtc", "iwcontext", "ifContext", "IFtx", "ifcontext", "iftc", "iftx", "Ifcontext", "ifcmd", "iffcontext", "iwcmd", "Ifpkg", "iffctx", "ifftc", "Ifctx", "Iftc", " ifpkg", " ifcontext", "IFcontext", " iftx", " ifcmd", " ifContext", "iwpkg", "ifpkg", "IfContext", "Ifcfg", "iwcfg", "IFContext", "iwctx", "iwtx", "Ifcmd", "Iftx", "IFctx"], "function": ["f", "length", "type", "production", "object", "action", "lambda", "connection", "condition", "interface", "role", "service", "func", "callback", "attribute", "event", "address", "handler", "section", "Function", "table", "value", "index", "functional", "before", "family", "context", "package", "feature", "format", "number", "relation", "fun", "operation", "module", "command", "word", "fn", "variable", "normal"], "dsm_mem": ["dsm2memory", "dsm_mb", "dmm2ram", "dmm_ram", "dSM_mb", "dmm2mem", "dmm_mem", "dmm2memory", "dmm_memory", "dsm_em", "dspace_memory", "dsm2ram", "dSM_memory", "dsm_ram", "dsm_memory", "dspace_em", "dsm2mem", "dspace_mem", "dSM_mem"], "unpatched": ["unpatchhed", "unathed", "unminached", "unpayized", "unPatched", "unpayached", " unpatushed", "unPatching", "unpayched", "unmatched", "unatched", " unpched", "unlicced", "Unpatching", "unpched", " unpached", "unatching", "unbatchhed", "Unpatched", " unpatching", "unpushed", "unliched", " unpathed", "Unpatchatched", "Unpatatched", "Unpatchching", "unpatchized", "unmatced", "Unpatchched", " unmathed", "unPatatched", "unbatchched", "Unpatized", " unmatatched", " unmatced", "unminching", " unpching", "unpatchching", "Unpatced", " unpatatched", "unbatchching", "unpatchatched", "unmatatched", "unlicched", " unmatched", "unmathed", "Unpatchced", "unpatced", "unminched", " unpushed", "unpching", "unpayushed", "Unpathed", "unlicching", "unpatatched", "unpatchched", "unpayatched", " unatatched", "unfetched", "unPathed", " unatching", "unpathed", "unpayching", " unatched", "unpayhed", "unpached", "unatatched", " unpatached", "Unpatchized", "unpatized", "unbatchatched", "unfethed", " unpatced", "unpatushed", "unfetced", "unfetching", "unpatached", "unminushed", "unpatchced", "Unpatchhed", " unathed", "unmatized", "unpatching"], "result_size": ["resultptsign", " result_type", "result32size", " result_offset", "response_size", "response_offset", "result_sum", "response_sign", "result_offset", "result_Size", "result_sign", "result32name", "result_length", "Result_sized", "Result_name", "resultpttimeout", "result32sum", "Result_sent", "result_loc", "result_timeout", "response_timeout", "resultptoffset", " result_loc", "result_type", "result_store", "result32loc", " result_name", "result_name", " result_store", " result_sum", "resultLoffset", "Result_size", "Result_type", "resultitytimeout", "resultitysize", "resultLstore", "Result_Size", " result_length", "result_sent", "resultityoffset", "resultitysign", "resultptsize", "resultLsize", "result_sized"], "byte_list": ["attributeedlisted", "byte2list", "byte2LIST", "byte64string", "byte67len", "display_listed", " byte_LIST", "byte_listed", "byte5print", "attribute_list", "display_LIST", "bytes_LIST", "byte5listed", "byte8LIST", "byte32list", "byte64list", "Byte_string", "Byte2LIST", "byteedlist", "byteedpre", "Byte_List", "Byte2list", "bytes_print", "byte_len", "byte64LIST", " byte_listed", "attributeedpre", "attributeedlist", "attribute_listed", "byte67listed", "byte5LIST", "byte9list", "byte32listed", "byte_print", "byte_string", "display_list", "byte2List", "Byte2List", "byte9len", "byte67list", "Byte_LIST", "byte8print", "display_len", "byte5list", "byte_pre", "bytes_list", "byteedlisted", "attribute_pre", "attributeedList", "byte32pre", "byte8listed", "attribute_List", "byte64List", "byte_List", "byte32List", "byte67LIST", "byte_LIST", "byte9LIST", "Byte2string", "byte9listed", "Byte_list", "byte2string", "bytes_listed", "byteedList", "byte8list"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n", "idx": 19116, "substitutes": {"anon_cred": ["anon_scord", "anon_acld", "anon_tged", "anon_csred", "anon__cret", "anon_cid", "anon_decred", "anon_ctx", "anon_cshed", "anon_Cid", "anon__cord", "anon_cld", "anon_tred", "anon_acged", "anon_acred", "anon_Cret", "anon_tid", "anon_cord", "anon_csld", "anon_ttx", "anon_aced", "anon__Cid", "anon_scld", "anon_decid", "anon_Cord", "anon__Cret", "anon_thed", "anon_decret", "anon__Cord", "anon__acld", "anon_ced", "anon_acord", "anon_Cred", "anon_sced", "anon__Cred", "anon_tld", "anon__acred", "anon_cret", "anon_dectx", "anon__aced", "anon__ced", "anon__cred", "anon_csged", "anon_ached", "anon__cid", "anon_ched", "anon_scred", "anon_cged", "anon__acord", "anon_scret", "anon_Ctx", "anon_decord", "anon__cld", "anon_scid"], "ret": ["rt", "tmp", "reg", "gt", "ref", "ctr", "result", "fail", "lt", "cat", "err", "rem", "def", "store", "cont", "len", "tr", "res", "elt", "ll", "re", "r", "resp", "det", "RET", "Ret", "vet", "v", "ct", "back", "out", "code", "ft", "inter", "git", "val", "print", "rets", "x", "alt", "mel", "mem", "deg", "status", "nt", "aux", "mt", "t", "red"]}}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 19119, "substitutes": {"bs": ["ls", "us", "sts", "bh", "bits", "ubs", "outs", "iss", "asis", "BS", "js", "lbs", "os", "ss", "bp", "obs", "vs", "bytes", "blog", "ns", "hz", "ubis", "ms", "ts", "sys", "its", "fps", "acs", "b", "bis", "sb", "bc", "ashes", "uts", "cks", "bos", "ds", "bps", "aus", "bl", "gs", "cs", "boxes", "ps", "aos", "banks", "fs", "hs", "bes"], "offset": ["url", "scroll", "end", "slot", "location", "ref", "shift", "origin", "seed", "pointer", "Offset", "os", "error", "attribute", "pos", "top", "set", "address", "zero", "index", "id", "off", "row", "o", "reset", "key", "prefix", " offsets", "seek", "op", "base", "start", "oid", "addr"], "nb_clusters": ["nb_recocations", "nb_cllicts", "nb_callicts", "nb_custers", "nb_recicas", "nb_CLodes", "nb_exploses", "nb_caluster", "nb5chusters", "nbolyexplusters", "nb_clicas", "nb_ciques", "nb_chocations", "nb_groupsosures", "nb_CLores", "nb_clients", "nb__plients", "nb_aclores", "nbolycloses", "nb_plients", "nb_allusters", "nb5clions", "nb_splosures", "nb_clust", "nbolycllicts", "nb5chocations", "nb5chions", "nb_explusters", "nbolyexploses", "nb_clodes", "nb_plusters", "nb_chicas", "nb_cliques", "nb5chicas", "nb_closures", "nb_flicas", "nbolycluster", "nb_groupsusters", "nb_codes", "nb__pliques", "nb_cients", "nb_flions", "nb_clocations", "nb_chions", "nb_allores", "nbolyclusters", "nb_splusters", "nb_flocations", "nb_caloses", "nb_aclibraries", "nb_plodes", "nb_spliques", "nb_groupsust", "nbolyexpllicts", "nb__plodes", "nb_Closures", "nb_splients", "nb_Clust", "nb__clusters", "nb_expllicts", "nb_pliques", "nb_clores", "nb__cliques", "nb_closes", "nb_splust", "nb__clodes", "nb_allodes", "nb_recions", "nb_cluster", "nb_CLibraries", "nb_aclusters", "nb_allibraries", "nb__plusters", "nb_clions", "nb_aclodes", "nb_chusters", "nb_Closes", "nb_groupsuster", "nb_Cluster", "nb_flusters", "nb5clusters", "nb5clicas", "nb_Clusters", "nb__clients", "nb5clocations", "nb_clibraries", "nbolyexpluster", "nb_expluster", "nb_splodes", "nb_CLusters", "nb_recusters", "nb_spluster", "nb_calusters", "nb_Cllicts"], "s": ["ls", "is", "sts", "sv", "rs", "bits", "ins", "aws", "h", "ares", "js", "os", "ss", "serv", "ies", "vs", "ns", "ims", "spec", "ats", "ts", "sys", "its", "sp", "acs", "b", "parts", "bis", "sb", " ss", "stats", "ds", "qs", "ses", "http", "S", "sam", "gs", "ssl", "cs", "sa", "ps", "fs", "hs", "p"], "l2_table": ["l2__key", "l3_table", "l2phpaddress", "l2phptable", "l3_database", "l3_tab", "l3_master", "l2____tab", "l4_address", "l3_page", "l2_array", "l2__size", "l2iptable", "l2_cache", "l2ipblock", "l2_page", "l4_table", "l2protable", "l1_cache", "l2__table", "l2___block", "l3_size", "l2phptab", "l2_TABLE", "l1_table", "l2Ttable", "l2____TABLE", "l3_header", "l2__array", "l2Tsize", "l2_address", "l2____table", "l3_TABLE", "l2phpresult", "l3_key", "l2_header", "l3_block", "l2__tab", "l2____header", "l2___master", "l2Ttab", "l4_result", "l2___cache", "l2ipcache", "l2_column", "l2propage", "l2_size", "l2_tab", "l2_block", "l2_master", "l2__TABLE", "l2__cache", "l2_key", "l3_array", "l2prodatabase", "l2TTABLE", "l1_column", "l2procache", "l2_database", "l2___table", "l4_tab", "l3_cache", "l1_TABLE", "l2ipmaster", "l2_result", "l2__column"], "l2_index": ["l2_initial", "l2istprefix", "l2eindex", "l2ecount", "l2tavailable", "l2tindex", "l1_id", "l2istindex", "l2_int", "ltwo_path", "l2__path", "l120_prefix", "l2_rank", "l3_open", "l2_seed", "ltwo_index", "ltwo_int", "l2_count", "l22status", "l2___i", "l120istseed", "l3_index", "l2_icon", "l2_ind", "l2_open", "l2_status", "l2_i", "l2__int", "l2__ind", "l2_id", "l2___index", "l22initial", "l2_prefix", "l2tinitial", "l120_seed", "l1_Index", "l1_rank", "l120istindex", "l120isti", "l2tstatus", "l3_icon", "l2_available", "l22_status", "l120_i", "l22_initial", "l2istseed", "l2isti", "l3_Index", "l2_Index", "l2eicon", "l22_available", "l120_index", "l120istprefix", "l2___seed", "l2_path", "l2eIndex", "l2__index", "l22index", "l2___prefix", "l22available", "l22_index", "l3_count", "ltwo_ind", "l1_index"], "ret": ["er", " RET", "cat", "after", "def", "det", "RET", "utils", "out", "val", "print", "deg", "rm", "reply", "reg", "gt", "iter", "lt", "lit", "report", "rem", "cont", "dt", "net", "re", "expr", " Ret", "ft", "lag", "over", "cmd", "mber", "nt", "usr", "mt", "red", "ry", "ber", "ext", "result", "err", "ert", "elt", "flag", "resp", "txt", "uf", "cert", "git", "rets", "try", "pret", "pat", "rt", "tr", "res", "att", "arr", "rect", "Ret", "ter", "ort", "sys", "rev", "nz", "reset", "et", "alt", "ail", "it", "details"], "i": ["f", "us", " I", "is", "bi", "gi", "ind", "complete", " mi", "ri", "xi", "ki", " index", "cli", "ai", "info", "json", "oi", "li", "ui", "ic", "dim", "ip", "y", "io", "\u0438", " ii", "in", "pi", "iu", "qi", "by", "im", " bi", "ci", "zi", "sim", "m", "asi", "index", "me", "uli", " pi", "ji", "series", "id", " err", "I", "ii", "ti", "ei", "phi", "ix", "x", " ti", "span", " m", "uri", " ni", " si", " j", "mi", " multi", "di", "it", "hi", "ij", "ini", "multi", "j", "si", "batch"], "old_offset": ["old_off", "new_attribute", "Old_off", "old___offset", "oldTheattribute", "new_offset", "old_rot", "new_block", "oldxOffset", "old7pointer", "oldTheblock", "old_point", "oldxpoint", "old_pointer", " old_point", "old_attribute", "Old_rot", "old7rot", "Old_offset", "old_loc", "oldamoffset", "oldTheoffset", "oldxoffset", "old___pointer", "old_Offset", "old___Offset", " old_key", "old_key", "old_block", " old_Offset", "old___off", "old7offset", " old_loc", "old7off", "old___loc", "old___key", "old___rot", "oldamblock", "oldamattribute", "Old_pointer"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    S390pciState *s = opaque;\n\n\n\n    return &s->pbdev[PCI_SLOT(devfn)].as;\n\n}\n", "idx": 19126, "substitutes": {"bus": ["proc", "us", "bridge", "clus", "bit", "box", "block", "boot", "uses", "chain", "mount", " Bus", "cus", "board", " buses", "device", "bur", "back", "book", "bc", "Bus", "used", "BUS", "loop", "usb", "dev", "bs", " BUS"], "opaque": ["opse", "oopque", "OPque", "oppque", "optque", "OPaco", "ipse", "optaque", "ipque", "oppsolete", " opque", "OPaque", "oopossus", "opossus", " opse", "opque", "oppaco", "optaco", "oppaque", "opsolete", " opossus", "ipaque", "OPsolete", "optsolete", "ipossus", "oopse", "oopaque", "opaco"], "devfn": ["devpath", " devpath", "DevFN", " devname", "devname", " devnm", " devnon", "devicepath", "Devname", " devFN", " devicenon", "ndFN", "devnm", "devnon", "devicefn", "ndfn", " devicepath", "Devfn", "devicenon", "devFN", "devicenm", "ndname", " devicenm", " devicefn"], "s": ["f", "ls", "sl", "is", "sts", "sv", "rs", "a", "c", "sq", "sac", "h", "sm", "i", "ss", "ess", "y", "ns", "r", "e", "l", "ts", "m", "d", "b", "v", "n", "o", "sb", "state", "sol", "ds", "ses", "S", "ssl", "gs", "ps", "t", "als", "sis", "z", "j", "p"]}}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_info_commands(void)\n\n{\n\n    char *resp, *info, *info_buf, *endp;\n\n\n\n    info_buf = info = hmp(\"help info\");\n\n\n\n    while (*info) {\n\n        /* Extract the info command, ignore parameters and description */\n\n        g_assert(strncmp(info, \"info \", 5) == 0);\n\n        endp = strchr(&info[5], ' ');\n\n        g_assert(endp != NULL);\n\n        *endp = '\\0';\n\n        /* Now run the info command */\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", info);\n\n        }\n\n        resp = hmp(info);\n\n        g_free(resp);\n\n        /* And move forward to the next line */\n\n        info = strchr(endp + 1, '\\n');\n\n        if (!info) {\n\n            break;\n\n        }\n\n        info += 1;\n\n    }\n\n\n\n    g_free(info_buf);\n\n}\n", "idx": 19128, "substitutes": {"resp": ["response", "ref", "conn", "result", "init", "jp", "tx", "err", "Resp", "Response", "cli", "ret", "fr", "serv", "comp", "res", "pos", "body", "obj", "re", "rel", "r", "rev", "rec", "sp", "txt", "ctx", "esp", "vp", "respond", "cmd", "req", "next", "par", "status", "msg", "nt", "ps", "comm", "cmp", "rep", "repl", "p"], "info": ["ready", "cache", "init", "shift", "recent", "i", "def", "safe", "ip", "debug", "kind", "check", "query", " Info", "time", "skip", "key", "where", "trace", "req", "status", "hi", "show", "information", "nice", "f", "entry", "iter", "nr", "interesting", "inner", "ret", "json", "diff", "Info", "tip", "now", "zero", "index", "off", "row", "total", "comment", "state", "empty", "notice", "full", "success", "par", "msg", "source", "stable", "iso", "conf", "name", "p", "all", "end", "update", "important", "good", "valid", "unknown", "comp", "error", "ignore", "loc", "by", "help", "none", "txt", "about", "history", "used", "count", "try", "inf", "rt", "type", "ok", "parse", "more", "doc", "list", "num", "id", "INFO", " INFO", "fi", "str", "data", "it", "op", "start", "fo", "addr", "only", "details"], "info_buf": ["inf_box", " info_buff", "info_buff", "inf_uf", "info___limit", "info2buff", "info___buf", "info___buff", "info_uf", "info2limit", "info_cb", " info2buff", "inf_cb", "info___uf", " info_uf", "inf_buf", " info_limit", " info2uf", "info2uf", " info2buf", "info_limit", " info_map", " info2limit", "info_map", "info2buf", "info_box"], "endp": ["restp", "gatep", "pendp", "Endv", " endpoint", " endpos", "rendp", "endcp", "pendcp", "Endpat", "endv", "enderp", "Endcp", "endercp", " endP", "endedv", "endedp", "rendpt", "EndP", "appendP", "gateP", " endpt", "endpoint", "rendpoint", "appendp", "appendpoint", "pendpat", "enderpat", "Endp", "endedpos", "pendP", "gatept", "Endpt", "endP", "restpos", "restP", "rendP", "appendpt", "gatev", "restpt", "endpat", "endedP", "enderP", "endedpt", "endpt", "endpos"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "substitutes": {"s": ["ls", "is", "sl", "us", "sts", "g", "rs", "sv", "as", "ins", "sn", "sw", "south", "c", "h", "sq", "sm", "ex", "js", "i", "self", "os", "ss", "sc", "sg", "in", "p", "ns", "ims", "set", "ts", "d", "its", "sys", "b", "ties", "ctx", "se", "sports", "sb", "x", "stats", "ds", "an", "ses", "less", "qs", "w", "S", "gs", "cs", "comm", "t", "bs", "ps", "fs", "hs", "es"], "type": ["ype", "ref", " ty", "test", " typ", "y", "event", "class", "kind", "re", "target", "e", "id", " Type", "ct", "o", "ty", "TYPE", "state", "cmd", "et", "pe", "typ", "tag", "Type", "name", "p"], "ret": ["rt", "tmp", "f", "reg", "prop", "gt", "ref", "result", "err", "lit", "rc", "def", "buffer", "null", "res", "obj", "Return", "re", "r", "target", "arr", "resp", "flag", "RET", "Ret", "rev", "out", "val", "rets", "cmd", "alt", "mem", "fun", "op", "aux", "nt", "usr", "mt", "reply", "t", "repl", "ry"], "arg": ["new", "reg", "ext", "g", "gt", "ref", "ax", "args", "Arg", "err", "ag", " args", "or", "def", "in", "res", "ig", "obj", "gc", "orig", "flag", "target", "arr", "argument", "pl", "r", "m", "ack", "b", "v", "param", "agg", "out", "key", "ar", "val", "cmd", "pg", "mem", "it", "op", "ob", "tag", "mb", "t", "name", "p"], "old_code_ptr": ["old_code_store", "old_cache_ptr", "old_cache_ps", "old_code_ps", "old_codeprops", "old_codes_pointer", "old_code_pt", "old_cache_store", "old_code_addr", "old_cache_Ptr", "old_code_pointer", "old_Code_addr", "old_Code_tip", "old_codes_ptr", "old_code_tip", "old_code_Ptr", "old_codeproPtr", "old_Code_pointer", "old_codeprostore", "old_codes_pt", "old_codeproptr", "old_Code_ptr", "old_codes_addr"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 19133, "substitutes": {"s": ["is", "er", "as", "fs", "a", "c", "h", "js", "i", "ies", "y", "vs", "ims", "v", "out", "stats", "http", "qs", "ses", "less", "status", "als", "bes", "bits", "aws", "sw", "ports", "ss", "https", "ns", "obj", "spec", "ms", "parts", "bis", "sports", "full", "S", "cs", "conf", "hs", "sl", "sts", "g", "rs", "ops", "err", "ads", "self", "os", "conv", "set", "l", "sp", "sb", "gs", "gets", "ssl", "comm", "bs", "ls", "sv", "ins", "changes", "ats", "ts", "sys", "its", "b", "n", "tests", "ds", "sam", "ps", "t", "details", "es"], "p": ["f", "g", "pkg", "P", "jp", "fp", "pre", "c", "h", "gp", "post", "i", "mp", "press", "q", "cp", "bp", "ip", "pp", "np", "phy", "pb", "php", "tip", "lp", "r", "pc", "wp", "d", "ap", "m", "ping", "sp", "b", "v", "pa", "o", "vp", "data", "x", "up", "it", "pro", "op", "w", "ps", "t", "rep", "dp", "tp", "j"], "request": ["get", "push", "method", "reason", "point", "claim", "position", "buffer", "q", "access", "order", "requ", "version", "read", "event", "set", "re", "address", "r", "query", "message", "reference", "call", "question", "reset", "change", "quest", "cmd", "prefix", "seek", "task", "req", "Request", "frame", "QUEST", "command", "input", "hello", "response"], "value": ["unit", "length", "get", "action", "multiple", "ceive", "sample", "result", "vector", "VALUE", "content", "property", "values", "json", "position", "buffer", "version", "attribute", "ue", "set", "example", "function", "address", "message", "Value", "v", "see", "ve", "operator", "key", "val", "change", "description", "data", "output", "number", "save", "command", "hello", "variable", "response", "volume"], "index": ["length", "offset", "open", "end", "ref", "ind", "update", "condition", "Index", "ion", "iter", "point", "document", "connect", "i", "size", "position", "order", "len", "pos", "address", "query", "reference", "num", "id", "row", "code", "key", "val", "context", "axis", "prefix", "data", "seek", "x", "link", "success", "status", "number", "image", "find", "input", "timeout"]}}
{"project": "qemu", "commit_id": "a193b0f0a8d7735f4eb2ff863fd0902a5fa5eec6", "target": 0, "func": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,\n\n                                      int64_t offset, uint64_t bytes,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BlockBackend *blk = job->common.blk;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t start, end; /* bytes */\n\n    int n; /* bytes */\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);\n\n    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);\n\n\n\n    trace_backup_do_cow_enter(job, start, offset, bytes);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start += job->cluster_size) {\n\n        if (test_bit(start / job->cluster_size, job->done_bitmap)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(job->cluster_size, job->common.len - start);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = blk_blockalign(blk, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,\n\n                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = blk_co_pwrite_zeroes(job->target, start,\n\n                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = blk_co_pwritev(job->target, start,\n\n                                 bounce_qiov.size, &bounce_qiov,\n\n                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        set_bit(start / job->cluster_size, job->done_bitmap);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->bytes_read += n;\n\n        job->common.offset += n;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, offset, bytes, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 19160, "substitutes": {"job": ["org", "block", "program", "com", "tab", "store", "low", "build", "event", "project", "work", "scan", "pair", "status", "node", "command", "mb", "cor", "entry", "jam", "report", "Job", "day", "order", "cp", "rb", "sub", "cb", "bug", "row", "state", "comment", "package", "cmd", "db", "tag", "process", "conf", "problem", "cell", " Job", "jobs", "user", "manager", "error", "jj", "journal", "match", "sim", "record", "sb", "member", "task", "up", "pro", "image", "ob", "module", "emb", "jar", "batch", "jump", "config", "connection", "jp", "info", "server", "pixel", "obs", "pause", "line", "band", "item", "this", "sync", "mor", "vm", "param", "app", "web", "common", "exec", "j"], "offset": ["length", "bit", "block", "location", "slot", "ref", "hop", "init", "shift", "delay", "origin", "info", "root", "size", "mask", "Offset", "position", "buffer", "order", "error", "byte", "padding", "pos", "len", "unk", "align", "address", "index", "id", "off", "row", "reset", "alloc", "rot", " offsets", "data", "seek", "count", "et", "output", "stop", "op", "base", "bound", "image", "addr", "transfer", "oot", "timeout"], "bytes": ["done", "pages", "length", "bits", "jobs", "offs", "ops", "loads", "steps", "users", "ips", "memory", "les", "values", "size", "xff", "lines", "os", "heads", "len", "byte", "ies", "abytes", "units", "Bytes", "address", "classes", "errors", "eks", "rows", "odes", "reads", "options", "parts", "total", "tes", " offsets", "points", "maps", "bps", "files", "gs", "limit", "keys", "seconds", "blocks", "items", "bs", "es"], "error_is_read": ["error_Is_read", "error_is__write", "error_type_reader", "error_is__read", "error_Is_readable", "error_is_write", "error_type_readable", "error_is_error", "error_is_readable", "error_type_read", "error_type_write", "error_is__readable", "error_is_reader", "error_Is_write"], "is_write_notifier": ["is_write_noteiger", "is_write_noteifier", "is_write_noify", "is_write_notifer", "is_write_critiger", "is_write_critifier", "is_write_notiger", "is_write_vertifer", "is_write_noteicator", "is_write_notified", "is_write_notify", "is_write_vertified", "is_write_noicator", "is_write_noifer", "is_write_verticator", "is_write_noteified", "is_write_noifier", "is_write_vertifier", "is_write_noteifer", "is_write_critifer", "is_write_noified", "is_write_noiger", "is_write_critify", "is_write_noticator", "is_write_noteify"], "blk": [" blck", "brock", "glke", "lbg", "clck", "bltk", "lbck", "blg", "plk", "blke", "brk", " bltk", " blak", "plg", "clk", "bleg", "BLak", "clak", "lbak", "blek", "brck", "glak", "lbk", "plak", " blg", "BLck", "brotk", "blck", "broak", "brok", "BLtk", "bleck", "plck", "glck", "BLke", "BLk", "glk", "clke", "brg", "brak", "bleak", "blak"], "cow_request": ["cowpycommand", "cow_command", "cowpyrequest", "cow_req", "cowpyreq", "cowtheparam", "cow_param", "cowthereq", "cow_query", "Cow_command", "cowthequery", "Cow_query", "cowtherequest", "Cow_request", "Cow_req", "Cow_param"], "iov": [" morale", "cv", "iol", "minecraft", "isco", " volley", "yon", "iva", " vibe", "vector", "vr", "nov", "iw", " mor", "vec", "hero", "veh", " bio", "river", "icon", "Iv", "iour", " mus", "drm", "serv", "liv", "voc", "conv", "dq", " multimedia", " supporters", "iv", "iological", "intelligence", " trou", "rio", " fav", "meyer", " terr", "imp", "ivic", "rov", "virt", "chrom", "voice", " civ", "ilo", " vib", "uj", "ovi", "iev", "ichael", "ieu", "iop", "tv", "inv", "vo", "ij", " unim", "iq", "establishment", "hovah", " rav", "vp"], "bounce_qiov": ["bounce_quiop", "bounce_sqiv", "bounce_qqvoice", "bounce_qqiour", "bounce2qqiour", "bounce_qqiov", "bounce_qqiev", "bounce_qiev", "bounce_quiov", "bounce_dqiov", "bounce_dqiv", "bounce2qqiop", "bounce_dqvoice", "bounce_sqiev", "bounce_qqiol", "bounce_veiop", "bounce_veibr", "bounce2qqiol", "bounce_piop", "bounce_dqiop", "bounce_quiour", "bounce_qqibr", "bounce_qiv", "bounce_sqiov", "bounce_piov", "bounce2qiol", "bounce_qiour", "bounce2qiov", "bounce2qiop", "bounce_dqiol", "bounce_qibr", "bounce_qqiv", "bounce2qqiov", "bounce_qqiop", "bounce_sqiop", "bounce_veiov", "bounce_qiop", "bounce_dqiour", "bounce_quibr", "bounce2qiour", "bounce_qiol", "bounce_veiour", "bounce_pvoice", "bounce_piour", "bounce_dqiev", "bounce_qvoice"], "bounce_buffer": ["bounceblebuffer", "bounce_map", "bouncebleBuffer", "bounce_base", "bounce_address", "bouncematbuff", "bounce2buf", "bounce2Buffer", "bounce_Buffer", "bounce_available", "bouncemataddress", "bounce_buf", "bounced_document", "bounce___address", "bounce2base", "bounce2buffer", "bounceblebuff", "bouncematbuffer", "bouncing_map", "bounced_Buffer", "bouncing_buf", "bouncing_Buffer", "bouncing_buff", "bounced_buffer", "bounced_available", "bounce___buff", "bounced_buff", "bouncematmap", "bounce___map", "bounced_base", "bounce2document", "bounce_buff", "bouncebleavailable", "bouncing_buffer", "bounce2buff", "bouncing_address", "bounce_document", "bounce___buffer"], "start": [" Start", "init", "shift", "c", "a", "use", "store", "top", "head", "kind", "address", "e", "check", "started", "before", "time", "skip", "key", "first", "wind", "begin", "art", "rest", "add", "new", "pad", "from", "st", "entry", "pre", "iter", "root", "pos", "ish", "power", "now", "index", "Start", "row", "space", "stop", "step", "p", "create", "prep", "origin", "size", "set", "match", "sp", "seek", "x", "next", "try", "at", "we", "get", "rank", "boot", "part", "starting", "position", "in", "pause", "id", "reset", "ix", "it", "current", "base", "addr", "t", "j"], "end": ["ending", "close", "ff", "edge", "get", "all", "ext", "en", "wrap", "ended", "End", "until", "entity", "nd", "after", "size", " End", "except", "order", "fin", "ue", "export", "append", "set", "max", "ell", "e", "est", "index", "id", "enable", "off", "and", "ord", "END", "endif", "eff", "ew", "send", "ek", "up", "begin", "ent", "stop", "bound", "limit", "eng", "add"], "n": ["nb", "ne", "g", "nm", "en", "na", "sn", "cn", "c", "nd", "min", "i", "nl", "size", "len", "y", "nn", "np", "ns", "ni", "r", "l", "nc", "m", "num", "d", "b", "v", "o", "out", " N", "mn", "nu", "nan", "count", "it", "w", "nt", "N", "t", "z", "j", "p"]}}
{"project": "qemu", "commit_id": "d157ed5f7235f3d2d5596a514ad7507b18e24b88", "target": 0, "func": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n", "idx": 19184, "substitutes": {"bs": ["ls", "bb", "sts", "rs", "bi", "ubs", "outs", "bits", "BS", "lbs", "os", "ss", "bp", "obs", "vs", "ns", "ubis", "ts", "its", "acs", "b", "bn", "bis", "sb", "bc", "bos", "qs", "ds", "aus", "bl", "gs", "bm", "cs", "aos", "fs", "hs"], "rule": ["tle", "block", "parse", "run", "require", "filter", "that", "test", "document", "rl", "role", "service", "style", "rules", "definition", "fr", "order", "ule", "ro", "error", "priority", "law", "rol", "line", "event", "rr", "spec", "re", "match", "item", "r", "function", "e", "group", "request", "call", "rec", "row", "record", "Rule", "se", "ULE", "fire", "state", "comment", "operator", "policy", "key", "feature", "task", "link", "http", "word", "pe", "node", "command", "statement", "module", "tag", "sche", "token", "trigger", "ace", "scope", "range", "decl", "p"], "s": ["ls", "sts", "sv", "rs", "fs", "h", "sq", "c", "sm", "js", "i", "os", "ss", "ns", "ims", "ts", "sp", "b", "v", "sb", "state", "ds", "ses", "S", "gs", "cs", "sa", "ps", "t", "sis", "hs", "j", "p"]}}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        /* Set the device in I/O access mode */\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        /* read mode */\n\n        switch (cmd) {\n\n        case 0x00: /* ??? */\n\n            goto reset_flash;\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: /* Block erase */\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; /* Block erase error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0x50: /* Clear status bits */\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: /* Block (un)lock */\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: /* Status Register */\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: /* Read Device ID */\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: /* CFI query */\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: /* Write to buffer */\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0xf0: /* Probe for AMD flash */\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: /* Read array mode */\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: /* Block erase */\n\n        case 0x28:\n\n            if (cmd == 0xd0) { /* confirm */\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { /* read array mode */\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n", "idx": 19198, "substitutes": {"pfl": ["pfi", "ippl", "lpject", "lpFl", "pflush", "privatefr", "cpFl", " pflat", "pafil", "lplf", "apflight", "lpsw", "cpfol", "plf", "pplane", "paifil", "paifl", " pilot", "formflight", "ipfil", "pform", "dpfl", " pfr", "phpform", "apfr", "phpilot", "phpsw", "npvl", " pfc", "dpFl", "lpgl", " pwl", "powerflo", "phpject", "pcompl", "pject", "pflo", "patbm", "pingFl", "pgl", "pbfl", "patfl", " pbm", "pbfil", "paform", "patchfr", "jpfi", "patchoft", "formfp", "pFl", "patplane", "dpplane", "Pfr", "cpfl", " pform", "lpplane", "ipfr", "pkgcompl", "phpfl", " pprot", "lpcompl", "paiflush", "dpflo", " pflight", "pfc", "jppol", "pcl", " ppol", "pkgfol", " pject", "phpflight", "dplf", "paflush", "pfil", " plf", " pflow", " pjet", "patchfl", "pbm", "perfr", "pflat", "lpfr", "ipfl", "powerfd", "pflow", " pfd", "ppl", "cpfil", "npprot", "patkl", "pafl", "cpfd", "npsw", " pfp", "cpflo", "phpflat", "pbpl", "lpcl", "jpfc", "dpfil", "jpfl", "pkgFl", "pkl", "pingfl", "lpilot", "percl", " pplane", " psw", " pflo", "phpfc", "jpFl", "paiform", "apoft", "phpjet", "Pfl", "lpflo", "Pgl", "pprot", "jpflight", "lpfl", "pwl", "pfin", " pvl", "ppol", "lpfp", "pkgfl", "cpwl", "cpfr", " pfol", " ppl", "phpvl", "pflight", "pingfr", "cpcompl", "privateflo", "powerfl", "pingfi", "Pflo", "apfl", "pfr", "cpflow", "perflight", "privatefin", "pajet", " pcl", "pvl", "pingfol", " pflush", "phpplane", " pfi", "perfl", "privatefl", "formflo", "pingpol", "pilot", "Psw", " pkl", "Pfin", "pjet", " poft", " pFl", " pfil", "npfl", "phpbm", "powerwl", " pcompl", " pfin", "phpcompl", "phpprot", "lpflight", "jpflat", "formfl", "pingflow", "patchflight", "pfp", "phpwl", "phpkl", "pawl", "psw", "poft", "pfol", "pbfr", " pgl", "pfd"], "offset": ["f", "pad", "ff", "length", "from", "end", "scroll", "location", "offs", "ref", "slot", "hop", "fp", "shift", "h", "point", "origin", "af", "i", "pointer", "size", "mask", "Offset", "position", "buffer", "xff", "error", "ip", "padding", "pos", "attribute", "loc", "align", "set", "address", "height", "pt", "path", "index", "sp", "off", "row", "b", "o", "slice", "rot", "et", "seek", "ow", "w", "op", "command", "start", "at", "addr", "ptr", "mt", "oid", "z"], "value": ["text", "type", "length", "block", "wrap", "create", "hw", "vector", "VALUE", "update", "shift", "memory", "size", "values", "position", "buffer", "byte", "attribute", "ue", "set", "address", "function", "buf", "Value", "index", "b", "v", "vp", "val", "weight", "data", "mem", "format", "w", "current", "op", "raw", "start", "input", "t", "field", "name"], "be": ["ode", "bit", "enabled", "block", "end", " enable", " depth", " index", "ength", " align", "Offset", " address", "byte", "ize", " bytes", " capacity", " height", " begin", " hop", " error", " b", " stride", "off", " mode", " start", " count", " off", "op"], "p": ["f", "g", "P", "fp", "jp", "h", "c", "point", "i", "q", "cp", "bp", "pos", "pp", "pb", "r", "lp", "pc", "l", "wp", "pt", "m", "ap", "ph", "sp", "b", "v", "pa", "o", "n", "vp", "s", "x", "w", "pro", "op", "ps", "t", "tp", "j"], "cmd": ["prop", "init", "xy", "def", "ip", "np", "kind", "cut", "ctx", "key", "md", "req", "mem", "status", "command", "cmp", "dc", "act", "bit", "MD", "nd", "cp", "obj", "cb", "target", "index", "mode", "code", "state", "cod", "msg", "fun", "nt", "cfg", "vp", "opt", "bind", "conn", "pkg", "ind", "err", "cli", "term", "flag", "help", "buf", "resp", "kw", "txt", " command", "ct", "force", "control", "desc", "count", "quit", "comm", "cd", "batch", "crit", "text", "config", "ctr", "reason", "Cmd", "mask", "func", "canon", "urg", "xp", "handle", "id", "hold", "op", "addr"], "wcycle": ["hwcle", " wcount", "hcle", "hwcycle", "Wcc", "hcycles", "swcode", "hwsync", "wcycles", "wdcode", "hwcc", "wcount", "Wcle", "wcc", "wdcycle", "hwcycles", "Wcode", "Wcycles", "wcle", "wcode", "Wcount", "hcode", "swcycle", "swcle", "hcycle", "wdcle", "swcycles", "Wcycle", " wsync", "hwcount", "wsync", " wcc", "Wsync", "hwcode", "wdcycles"]}}
{"project": "qemu", "commit_id": "4c055ab54fae39b6329c57bcb5334d59b920463e", "target": 0, "func": "int kvm_init_vcpu(CPUState *cpu)\n\n{\n\n    KVMState *s = kvm_state;\n\n    long mmap_size;\n\n    int ret;\n\n\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\n    if (ret < 0) {\n\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_fd = ret;\n\n    cpu->kvm_state = s;\n\n    cpu->kvm_vcpu_dirty = true;\n\n\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (mmap_size < 0) {\n\n        ret = mmap_size;\n\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\n                        cpu->kvm_fd, 0);\n\n    if (cpu->kvm_run == MAP_FAILED) {\n\n        ret = -errno;\n\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n\n        s->coalesced_mmio_ring =\n\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n\n    }\n\n\n\n    ret = kvm_arch_init_vcpu(cpu);\n\nerr:\n\n    return ret;\n\n}\n", "idx": 19204, "substitutes": {"cpu": ["CPU", "component", "us", "library", "cv", "program", "cache", "c", "upt", "linux", "i", "kernel", "setup", "np", "pc", "pid", "ctx", "utils", "mem", "mac", "node", "tp", "proc", "hw", "docker", "clock", "du", "cp", "device", "net", "aq", "u", "php", "cu", "total", "phys", "cs", "process", "uu", "pu", "p", "conn", "pkg", "cli", "uart", "util", "phy", "ka", "core", "socket", "pool", "aux", "ruby", "bench", "parse", "boot", "runner", "processor", "prof", "jp", "copy", "nic", "cum", "anc", "ck", "gc", "remote", "this", "sys", "vm", "nz", "reset", "gpu", "lib", "ace", "foo"], "s": ["proc", "ls", "is", "sl", "sts", "g", "rs", "sv", "sw", "states", "iss", "so", "changes", "south", "a", "c", "h", "sq", "aws", "sis", "sm", "args", "ex", "js", "i", "ports", "os", "q", "ss", "sc", "conv", "store", "y", "ns", "ims", "spec", "ts", "sys", "sp", "es", "b", "v", "sets", "se", "n", "acs", "space", "sb", "state", "services", "ds", "qs", "ses", "less", "w", "S", "ssl", "gs", "cs", "sa", "ps", "t", "bs", "comm", "fs", "hs", "ssh", "si", "p"], "mmap_size": ["mmmap_count", "mmmap_Size", "mmap_area", "mmap1error", "mmap1storage", "mmat67value", "mmap_error", "mmat_size", "mmmap_storage", "mmmap_size", "mmap1SIZE", "mmap1set", "mmmap_set", "mmap67number", "mmap67value", "mmmap_SIZE", "mmat67area", "mmap2SIZE", "mmap2error", "mmap_value", "mmapper_Size", "mmap2size", "mmap_Size", "mmapper_SIZE", "mmap67size", "mmap_SIZE", "mmat_number", "mmap1count", "mmap_sum", "mmapper_size", "mmat67size", "mmapper_len", "mmap_storage", "mmmap_error", "mmap_set", "mmap1size", "mmat67number", "mmap_number", "mmap_count", "mmap_len", "mmat_value", "mmat_area", "mmap2storage", "mmmap_sum", "mmap67area"], "ret": [" res", " RET", "def", "det", "RET", "out", "val", "print", "mem", "deg", "rm", "f", "gt", "lt", "rem", "cont", "dt", "len", "net", "Return", " fut", "re", "back", " Ret", "ft", "inter", "fun", "nt", "usr", "mt", "red", "ry", "tmp", "ext", "g", "result", "err", "elt", "ll", "set", "flag", "arg", "resp", "uf", "cert", "git", "rets", "dr", "try", "ptr", "rt", "fd", "get", "ref", "fp", "jp", "nl", " alt", "tr", "res", "gc", "att", "rev", "Ret", "ter", "nz", "reset", "fi", "alt", "it", "addr", " ar", "t", "j"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}", "idx": 19216, "substitutes": {"cs": ["ls", "sts", "ks", "cell", "acts", "rs", "ins", "cn", "ics", "c", "cus", "cm", "ares", "js", "ck", "css", "cons", "cp", "sc", "cases", "vs", "ns", "gc", "ims", "ces", "tc", "CS", "pc", "Cs", "ts", "ats", "caps", "cc", "acs", "ctx", "cms", "ices", "wcs", "icks", "s", "cmd", "ce", "cas", "cks", "ix", "ds", "ec", "qs", "ses", "ys", "gs", "ps", "otes", "bs", "fs", "hs"], "cpu": ["proc", "CPU", "bench", "cv", "cell", "conn", "processor", "hw", "mx", "cam", "cn", "jp", "clock", "c", "onet", "nic", "cli", "linux", "ck", "kernel", "os", "thread", "cp", "ork", "sc", "server", "device", "net", "np", "gc", "tc", "cu", "ka", "pc", "sync", "nc", "pt", "sys", "cc", "vm", "sp", "ctx", "exe", "utils", "core", "cmd", "gpu", "frame", "mem", "rom", "mac", "pool", "stat", "process", "pu", "tp"], "env": ["cv", "estate", "er", "kernel", "vs", "e", "ctx", "v", "proc", "extra", "hw", "entry", "eps", " ens", "eh", "serv", "dt", "net", "eni", "obj", "cb", "em", "ens", "el", "ev", "esp", "console", "context", "cmd", "environment", "nv", "inv", "process", "dev", "esc", "conf", "vp", "window", " environment", "ext", "end", "en", "conn", "viron", "origin", "enc", "buf", "ah", "eur", "here", "era", "ve", "eve", "desc", "next", "ptr", "esm", "attr", "config", "shell", "sv", "worker", "sc", "server", "doc", "der", "nc", "sys", "vm", "eas", "eg", "ei", "ew", "data", "et", "ds", "ec", "addr", "eng"], "depend": ["independent", "disable", "require", "based", "ind", "fail", " depending", "dependent", " dependence", " depends", "epend", "ependent", "improve", "specific", "deb", " rely", " based", " dependent", "project", "work", "depending", "und", "dep", "reflect", "req", "wait", "Based", "osit"], "the": ["new", "minimum", "them", "ethe", "length", "to", "th", "type", "from", "het", "get", "what", "_", "that", "largest", "test", "non", "expected", "you", "athe", "document", "were", "then", "application", "eth", "unknown", "te", "he", "some", "their", "there", "your", "by", "match", "max", "my", "they", "any", "this", "tf", "and", "where", "ing", "trace", "The", "on", "an", "general", "number", "current", "we", "t", " The", "each"], "of": ["new", "oft", "to", "component", "from", "en", "that", "des", "or", "OF", "in", "your", "by", "Of", "e", "and", "s", "on", "an", "number", "current", "with", "name"], "caused": ["provurred", "occus", "occused", "provumed", "caus", "Caus", "Caused", "Caumed", "provused", "caumed", "provus", "caurred", "occumed", "Caurred", "occurred"], "exception": ["exceptceptor", "repection", "execception", "EXception", "eaction", "exeactly", "exceptor", "eException", "interceptions", "eceptions", "Exception", "transception", "eyption", "reception", "EXaction", "exceptception", "eactly", "Expection", "excception", "Exceptions", "except", "execption", "exceptpection", "exption", "excceptions", "xception", "EXpection", "excpection", "recept", "execpection", "exceptions", "exException", "exeception", "EXption", "xpection", "eyactly", "eceptor", "xceptor", "interception", "EXException", "EXceptions", "eption", "reption", "transption", "transpection", "interaction", "interException", "expection", "eyception", "xceptions", "eception", "exceptceptions", "exaction", "exepection", "eypection", "excption", "transcept", "Exption", "exeption", "execcept", "exactly", "epection"], "not": ["is", "all", "ont", "never", "always", "unless", "non", "than", "or", "ot", "probably", "note", "nor", "also", "now", "un", "n", "before", "should", "let", "currently", "no", "at", "only", "t"], "target": ["new", "minimum", "matched", "original", "execute", "major", "expected", "arget", "necessary", "Target", "recorded", "root", "physical", "specific", "real", "master", "specified", "match", "max", "table", "inter", "latest", "proxy", "next", "supported", "current", "generated", "actual"], "level": ["levels", "length", "type", "label", "offset", "location", "depth", "scale", "priority", "line", "class", "group", "sequence", "value", "path", "local", "stack", "print", "count", "file", "module", "limit", "scope", "variable", "lvl", "Level", "name"], "so": ["resource", "such", "might", "is", "th", "always", "condition", "still", "were", "being", "sc", "probably", "they", "this", "any", "also", "xxx", "because", "se", "him", "since", "s", "thus", "sf", "Should", "ie", "could", "need"], "be": ["obe", "been", "always", "never", "en", "a", "you", "were", "ge", "le", "being", "or", "te", "ignore", "Be", "re", "by", "note", "also", "BE", "se", "fore", "stay", "ve", "are", "equal", "bes"]}}
{"project": "qemu", "commit_id": "e3f30488e5f802547b3a60e40cebaef3b4ec16a3", "target": 1, "func": "static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))\n\n        return;\n\n\n\n    if (n->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(n->tx_vq, 0);\n\n        return;\n\n    }\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        ssize_t ret, len = 0;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        unsigned hdr_len;\n\n\n\n        /* hdr_len refers to the header received from the guest */\n\n        hdr_len = n->mergeable_rx_bufs ?\n\n            sizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\n            sizeof(struct virtio_net_hdr);\n\n\n\n        if (out_num < 1 || out_sg->iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* ignore the header if GSO is not supported */\n\n        if (!n->has_vnet_hdr) {\n\n            out_num--;\n\n            out_sg++;\n\n            len += hdr_len;\n\n        } else if (n->mergeable_rx_bufs) {\n\n            /* tapfd expects a struct virtio_net_hdr */\n\n            hdr_len -= sizeof(struct virtio_net_hdr);\n\n            out_sg->iov_len -= hdr_len;\n\n            len += hdr_len;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,\n\n                                      virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(n->tx_vq, 0);\n\n            n->async_tx.elem = elem;\n\n            n->async_tx.len  = len;\n\n            return;\n\n        }\n\n\n\n        len += ret;\n\n\n\n        virtqueue_push(vq, &elem, len);\n\n        virtio_notify(&n->vdev, vq);\n\n    }\n\n}\n", "idx": 19223, "substitutes": {"n": ["new", "nb", "ny", "ne", "g", "na", "en", "nm", "conn", "sn", "tn", "cn", "c", "non", "dn", "ren", "h", "yn", "cdn", "nr", "nd", "nl", "name", "names", "y", "nn", "np", "ns", "net", "note", "remote", "form", "ng", "nor", "nc", "d", "network", "num", "m", "nw", "local", "b", "v", "hn", "o", "mn", "out", "nu", "gn", "an", "nv", "on", "ann", "number", "w", "ln", "nt", "node", "N", "fn", "comm", "conf", "rn", "j", "p"], "vq": ["xqs", "svqq", " vch", "svz", "vck", "svque", "vqq", "veiq", "sviq", "sq", "xq", "vch", "hiq", " vque", "lq", "hue", "vdq", "viq", "vqs", "sz", "xdq", " vz", "hq", "veue", " vqs", "vque", "svue", "lque", "svqs", "svq", "ldq", " vck", "vue", "veqq", "xck", "vz", " vdq", "veq", "hqq", "sue", " vue", "sch", "svch", "svck", "xque"], "elem": ["uelda", " ele", "lelem", "pept", " elev", "elelement", "elelem", "veem", "pele", "adelda", " edem", "eele", " eagle", "edlement", "lelems", "telems", "edem", "euagle", "eelement", "uelems", "nelev", "pelem", "enle", " element", "peem", "elems", "lelev", "eem", "vept", "neagle", "eld", "telement", "ego", "elete", "eulem", "adelems", "adelem", " elems", "nelement", "eulement", "velev", "element", "velems", "bele", "telem", "enlem", "velem", "edlems", "uelem", "eeld", "elev", " ego", "adelement", "elelev", "lelement", "enll", "veelement", "ept", "elelems", "edlem", "elelda", "bept", "eelem", "eagle", "nelems", "beem", "ele", "eego", "eleelement", "euld", "eelete", "eulev", "tedem", "eell", "elda", " ell", "ell", "edlev", "leld", "vele", "belem", "nelem", "lelete", "engo", "eulete", "neelement", "eledem", "uelement"], "ret": ["rt", "f", "url", "sum", "lan", "ext", "gt", "en", "result", "leg", "lt", "lit", "after", "nl", "def", "cont", "fin", "len", "tr", "res", "del", "ben", "elt", "read", "ll", "flag", "lv", "re", "arr", "resp", "r", "arg", "RET", "rev", "Ret", "l", "num", "el", "back", "out", "ft", "reset", "val", "rets", "str", "count", "alt", "mem", "deg", "status", "fun", "nt", "mt", "ptr", "il", "t", "hash", "ld", "red"], "out_num": ["outputzsnap", "output_nu", " out_n", "out_um", "out_snap", "out_mon", "outputznu", "out_non", "output_num", "in_pos", "outputznum", "out_name", "outLEman", " out_ref", "out_pos", "outLEno", "out_n", "outjno", "outjpos", "outvalnu", "in_mun", "out_no", "out_Num", "in_man", " out_net", " out_non", "outvalum", "outznu", "outzum", " out_name", "outznum", "outjmsg", "outputzum", "in_Num", "output_snap", " out_mon", "outvalnum", "outzsnap", "outvalsnap", "output_um", "outLEnum", "out_msg", "out_man", "in_no", "in_num", "in_msg", "out_net", "in_mon", "out_nu", "outLEmon", "outjnum", "out_ref", "out_mun"], "out_sg": ["in_rg", "in_sb", " out_ng", "in_sk", "out__gs", "out2sk", "out_sc", "out_sol", "out2sg", "ch_gs", "out_rg", "ch_sg", "out__rg", "in_sd", " out_sol", "out_ng", "ch_rg", "out_sb", "outstreamng", "out__si", "in_sg", "out__sg", " out_sb", "out_sd", " out_sc", "out_gs", " out_si", "out2rg", "outstreamsc", "in_bg", "outstreamsg", "out_sk", "ch_si", "outstreamsb", "out2sb", "in_num", "out_bg", "out_si"], "hdr_len": ["hdr_fun", "hdr_length", "hdr2len", "hpar_ln", "hvr_len", "hdr7Len", "hvr_gen", "hDR_gen", "hdr_la", "hdr_Len", "hdr_gen", "hDR_den", "hDR_mem", "hDR_en", "hvr_el", "hvr_Len", "hpar_Len", "hdr_el", "hDR_la", "hDR_Len", "hdr_en", "hdr_mem", "hDR_syn", "hdr_long", "hdr_buf", "hdr2mem", "hDR_len", "hDR_fun", "hdr_den", "hpar_len", "hDR_buf", "hdr2den", "hdr_ln", "hdr2Len", "hdr_syn", "hDR_length", "hdr7buf", "hdr7la", "hDR_long", "hdr7len"]}}
{"project": "qemu", "commit_id": "a1c5975270f2335e1d7129c084a6e562d7b99bdd", "target": 1, "func": "static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n", "idx": 19237, "substitutes": {"port": ["component", "bridge", "window", "type", "bind", "mit", "page", "entry", "peer", "connection", "test", "channel", "point", "interface", "post", "plugin", "connect", "report", "pipe", "valid", "ports", "pport", "porter", "store", "priority", "cp", "server", "phy", "export", "public", "select", "journal", "cast", "table", "project", "pc", "ort", "pid", "pt", "import", "pod", "ping", "bid", "client", "boat", "meter", "row", "rule", "gate", "let", "tty", "comment", "policy", "trace", "proxy", "count", "task", "wait", "required", "pool", "Port", "eport", "bound", "termin", "queue", "PORT", "only", "p"], "discard": ["Discarded", "Discause", " discarded", " disccast", "Discard", "iscarded", "DiscARD", " DiscARD", "dccast", "resARD", "discarding", "resard", "resause", "discards", "discause", " discarding", "Discards", " Discarding", "discarded", "discARD", "dcards", " discards", " Discause", " Discards", " Discard", "Disccast", "resarded", "iscarding", "iscards", "dcard", "iscard", " Discarded", "dcarded", "disccast"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static int hdev_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n\n\n\n\n\n\n    const char *filename = qdict_get_str(options, \"filename\");\n\n    char bsd_path[MAXPATHLEN] = \"\";\n\n    bool error_occurred = false;\n\n\n\n    /* If using a real cdrom */\n\n    if (strcmp(filename, \"/dev/cdrom\") == 0) {\n\n        char *mediaType = NULL;\n\n        kern_return_t ret_val;\n\n        io_iterator_t mediaIterator = 0;\n\n\n\n        mediaType = FindEjectableOpticalMedia(&mediaIterator);\n\n        if (mediaType == NULL) {\n\n            error_setg(errp, \"Please make sure your CD/DVD is in the optical\"\n\n                       \" drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        ret_val = GetBSDPath(mediaIterator, bsd_path, sizeof(bsd_path), flags);\n\n        if (ret_val != KERN_SUCCESS) {\n\n            error_setg(errp, \"Could not get BSD path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If a real optical drive was not found */\n\n        if (bsd_path[0] == '\\0') {\n\n            error_setg(errp, \"Failed to obtain bsd path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If using a cdrom disc and finding a partition on the disc failed */\n\n        if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 &&\n\n            setup_cdrom(bsd_path, errp) == false) {\n\n            print_unmounting_directions(bsd_path);\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        qdict_put(options, \"filename\", qstring_from_str(bsd_path));\n\n\n\nhdev_open_Mac_error:\n\n        g_free(mediaType);\n\n        if (mediaIterator) {\n\n            IOObjectRelease(mediaIterator);\n\n        }\n\n        if (error_occurred) {\n\n            return -ENOENT;\n\n        }\n\n    }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n        if (*bsd_path) {\n\n            filename = bsd_path;\n\n        }\n\n        /* if a physical device experienced an error while being opened */\n\n        if (strncmp(filename, \"/dev/\", 5) == 0) {\n\n            print_unmounting_directions(filename);\n\n        }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 19238, "substitutes": {"bs": ["ls", "bb", "sts", "bh", "bits", "rs", "ubs", "BS", "js", "lbs", "os", "ss", "bp", "obs", "vs", "ns", "pb", "ubis", "ms", "ts", "its", "b", "bg", "bis", "sb", "bc", "bos", "ds", "qs", "bps", "bl", "gs", "bm", "cs", "ps", "fs", "bes"], "options": ["checks", "config", "ptions", "bits", "eps", "ption", "plates", "fs", "lets", "ops", "fp", "args", "settings", "aps", "linux", "properties", "opens", "values", "json", "comes", "styles", "params", "os", "null", "pins", "ims", "spec", "false", "objects", "errors", "ms", "ts", "caps", "weights", "es", "Options", "tops", "uploads", "roots", "option", "times", "data", "atts", "stats", "IONS", "bos", "games", "files", "results", "dict", "ps", "features", "meta", "details", "metadata", "finals"], "flags": ["fd", "length", " Flags", "acts", "bits", "ints", "ops", "args", "settings", "nl", "properties", "mask", "ants", "lines", "ensions", "params", "kind", "flag", "types", "ags", "ms", "Flags", "ts", "locks", "fps", "weights", "members", "lag", "FLAG", "faces", "fields", "windows", "cmd", "frames", "times", "atts", "stats", "vals", "status", "files", "comments", "cs", "tags", "features", "details"], "errp": ["rerp", " errm", " errping", " errpar", "lerpa", "errping", "rrp", "errpid", "lerr", "rrr", "errorr", "errorpar", "rrping", "erm", "errm", "lerping", "err", " errP", "errpar", "rerping", "errorp", " errpost", "erpid", "ererp", "errorm", "rrpost", "errpa", "errorps", "lerp", "errps", " errps", "rrpid", "erpa", "ererping", "rerpost", "errpost", "errorping", "ererps", "ererpar", "erping", "errorpid", "erP", "errorP", "errP", "erp", "rrpa", "errr"], "s": ["f", "ls", "sl", "sts", "sv", "rs", "as", "sn", "states", "c", "sq", "args", "sm", "settings", "js", "os", "ss", "ns", "obj", "ts", "sys", "b", "sb", "state", "stats", "ds", "ses", "status", "S", "gs", "ys", "ssl", "cs", "sa", "ps", "t", "fs"], "local_err": ["local____er", "local_er", "local__kr", "Local_r", "local____ptr", "local___ptr", "local____kr", " local_sys", "local____sys", "local_ptr", "Local_ptr", "local___er", " local_kr", "local____r", "local___err", "local_r", "local___r", "local_kr", "Local_err", "Local_er", "local__err", "local____err", "local__sys", "local_sys"], "ret": ["rt", "opt", "get", "gt", "result", " RET", "rem", "nl", "len", "tr", "res", "elt", "Return", "ll", "re", "att", "r", "arg", "resp", "RET", "Ret", "ter", " Ret", "out", "ft", "val", "rets", "et", "alt", "mem", "nt", "mt", "il", "t", "j"], "filename": ["url", "nil", "ename", "length", "binary", "fp", "title", "river", "ames", "SourceFile", "json", "buffer", "browser", "names", "username", "journal", "which", "fil", "src", "fle", "path", "txt", "amer", "wine", "family", "Filename", "prefix", "file", "files", "bas", "directory", "source", "til", "fn", "ame", "fs", "name", "jpg"], "bsd_path": ["bssd_value", "bsd_data", "bsd_stream", "bssd_stream", "bsdxroot", "bsd7path", "bssd_name", "bsd_p", "bsd2path", "bssd_component", "bsd_value", "bsd___Path", "bsd___path", "bsd_component", "bsd__ath", "bssd_root", "bssd_p", "bsd_ring", "bsd_Path", "bsd_ath", "bssd_ath", "bssd_path", "bsd2Path", "bsd___route", "bsd_port", "bssd_port", "bsd7Path", "bssd_route", "bsd2root", "bsd_name", "bsd7p", "bsd_root", "bsdxPath", "bsdxpath", "bsd7name", "bsd___ring", "bsd__data", "bsdxstream", "bssd_Path", "bssd_data", "bsd_route", "bsd__path", "bsd___component", "bssd_ring", "bsd2stream", "bsd2data", "bsd__Path", "bsd___value"], "mediaType": ["areaType", " mediaTyp", "mediAdapter", "commandTyp", "mediaTypes", "mediaName", "proxyAdapter", "memorySource", "memoryAdapter", "proxyType", " mediaName", "resourceTYPE", "mediaHandler", "mediaTYPE", "dataTYPE", "commandTypes", "mediaAdapter", "memoryTYPE", "memoryTypes", "documentIterator", "resourceType", "dataType", "mediName", "areaTypes", "mediaSource", " mediaTypes", " mediaTYPE", "commandTYPE", "documentType", "areaTyp", "memoryType", "memoryName", "resourceHandler", "documentTYPE", "dataName", "imageTypes", " mediaHandler", "commandType", "mediaTyp", " mediaIterator", "imageType", "proxyTYPE", "mediaIterator", "proxyName", "dataAdapter", "imageSource", "mediType", "imageTYPE", "areaTYPE", "documentHandler", " mediaAdapter", "mediTYPE", "resourceIterator", " mediaSource"], "ret_val": ["ret2VAL", "retTvalue", "retTval", "return_val", "ret_vals", "retTel", "ret2val", "ret_VAL", "ret_value", " ret_VAL", "ret2vals", "ret3vals", " ret_vals", "ret3VAL", "ret_type", "ret_Val", "Ret_VAL", " ret_type", "ret32value", "ret3val", "Ret_el", "Ret_val", "Ret_value", "return_Val", "ret_el", "ret32el", "ret2type", "ret32val", "ret32VAL", "return_vals", "ret3type", "retTVAL", "return_value"]}}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n", "idx": 19243, "substitutes": {"bus": ["us", "bridge", "bb", "piece", "block", "bh", "box", "boot", "conn", "route", "mount", "chain", "ass", "cat", "onet", "lock", "cus", "hand", "ck", "stick", "board", "os", " buses", "bur", "kt", "bug", "driver", "handler", "buf", "vol", "sync", "sys", "ack", "b", "book", "bc", "volt", "Bus", "full", "BUS", "phys", "vc", "controller", "BO", "http", "loop", "bolt", "usb", " brick", "bu", "dev", "bs", " BUS"], "loc": ["lr", " location", "LOC", "label", "Loc", "reg", "box", "location", "ref", "tx", "iter", "lit", "info", "fc", "rc", "pub", "ro", "res", "pos", "doc", "util", "home", "pl", "rel", "lp", "dir", "buf", "ac", "l", "path", "local", "ack", "cl", "ctx", "zip", "oc", "alloc", "lim", "data", "col", "lang", "ol", "lib", "ch", "co", "p"], "dinfo": ["dInfo", "DInfo", "Dinf", "Dfo", " dfo", "fti", "fINFO", "linfo", "dsInfo", "dsinf", "dnInfo", "dsfo", " dinit", "ffo", "ddinf", "tinfo", "tinf", " dInfo", "dinformation", "Dinfo", "ddinit", "dninf", "finfo", "finit", "dINFO", "dninfo", "finf", "DINFO", "lfo", "ddinfo", "dinf", "dnINFO", " dti", " dinf", "tfo", " dinformation", "dti", "dsinfo", "dfo", "linformation", "dinit", "ddfo", "Dti", "fInfo", "tinformation", "linf"], "unit": ["component", "block", "init", "cat", "currency", "Unit", "kt", "quant", "vol", "un", "nu", "future", "key", "axis", "weight", "uni", "span", "relation", "command", "normal", "bit", "du", "title", "ju", "device", "pos", "onent", "u", "target", "group", "zero", "index", "Unity", "nit", "uint", "scope", "stable", "category", "sum", "unt", "chain", "user", "point", "term", "port", "unknown", "dim", "ou", "units", "um", "dir", "force", "task", "file", "number", "uri", "cond", "type", "label", "reason", "slave", "ut", "value", "num", "n", "family", " Unit", "alt", "mun", "it", "under", "volume"]}}
{"project": "FFmpeg", "commit_id": "fbd97184f8b68b2074b79a1698e4d9404292f7ca", "target": 1, "func": "static int link_filter_inouts(AVFilterContext *filt_ctx,\n\n                              AVFilterInOut **curr_inputs,\n\n                              AVFilterInOut **open_inputs, AVClass *log_ctx)\n\n{\n\n    int pad = filt_ctx->input_count, ret;\n\n\n\n    while (pad--) {\n\n        AVFilterInOut *p = *curr_inputs;\n\n        if (!p) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Not enough inputs specified for the \\\"%s\\\" filter.\\n\",\n\n                   filt_ctx->filter->name);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        *curr_inputs = (*curr_inputs)->next;\n\n\n\n        if (p->filter) {\n\n            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)\n\n                return ret;\n\n            av_free(p->name);\n\n            av_free(p);\n\n        } else {\n\n            p->filter = filt_ctx;\n\n            p->pad_idx = pad;\n\n            insert_inout(open_inputs, p);\n\n        }\n\n    }\n\n\n\n    if (*curr_inputs) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Too many inputs specified for the \\\"%s\\\" filter.\\n\",\n\n               filt_ctx->filter->name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    pad = filt_ctx->output_count;\n\n    while (pad--) {\n\n        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));\n\n\n\n        currlinkn->filter  = filt_ctx;\n\n        currlinkn->pad_idx = pad;\n\n        insert_inout(curr_inputs, currlinkn);\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 19245, "substitutes": {"filt_ctx": ["filt_tx", "fift_ctx", "filt67context", "fil_std", "fil_ctx", "filturectx", "fil_tc", "filt_std", "filtationctx", "filt___context", "filturestd", "filt___tc", "fld_context", "fift_rx", "filt_pool", "filt67std", "filturetx", "filt___tx", "filtration_func", "filt_pkg", "fil_rc", "fil_cf", "fift_tx", "filturecpp", "fld_tx", "filt_cfg", "fld_ctx", "filtationstd", "fift_cfg", "filtration_std", "filt_cf", "filt_func", "fil_context", "filtration_pool", "fld_cfg", "filtationtx", "filtationcpp", "filtration_ctx", "filtration_pkg", "filtration_tx", "filt_context", "filt_rx", "filtration_context", "fil_tx", "filt_tc", "filt___ctx", "filt67tx", "fil_cpp", "filt67ctx", "filt_cpp", "filt_rc"], "curr_inputs": ["curr_inputS", "curr_exceptes", "curr_currentets", "curr_context_", "curr_excepts", "curr_buts", "curr_Inputs", "curr__outputs", "curr_execs", "curr_currentes", "curr_outputos", "curr__output_", "curr_input_", "curr_exceptS", "curr_InputS", "curr_Inputes", "curr_contexts", "curr_inputes", "curr_outputers", "curr__input_", "curr_except_", "curr_output_", "curr_contextes", "curr_errors_", "curr_contextS", "curr_outputts", "curr_inputers", "curr_rawS", "curr__outputS", "curr_outputs", "curr_Input_", "curr_buters", "curr_but_", "curr_contextts", "curr_errorsS", "curr_inputts", "curr_execos", "curr_raw_", "curr__inputS", "curr__inputs", "curr_errorses", "curr_currentts", "curr_outputets", "curr_currents", "curr_outputes", "curr_rawes", "curr_butes", "curr__inputos", "curr_contexters", "curr_contextets", "curr_outputS", "curr_errorss", "curr_contextos", "curr__outputos", "curr_exec_", "curr_execS", "curr_inputos", "curr_raws", "curr_inputets"], "open_inputs": ["open_interestcs", "open_contexts", "open_connectes", "open_outputcs", "open_outputles", "open_inputts", "open_outputs", "open__outputs", "open_contextes", "open_contextts", "open_inputeds", "open_outputes", "open_connects", "open_Inputs", "open_Inputts", "open_outputeds", "open_interests", "open__inputs", "open_interestles", "open__inputts", "open_outputts", "open_connectcs", "open__outputes", "open_inputles", "open_contexteds", "open_Inputes", "open_interestes", "open_inputcs", "open_inputes", "open__inputeds", "open_connectles", "open__inputes", "open_Inputeds", "open__outputts", "open__outputeds"], "log_ctx": ["loggingctx", "blog_jac", "webptcas", "blog_ctx", " log2ctx", " log_obj", "loggerctx", "logpttx", "webpttx", "webptrec", "log__kb", "log__ctx", " log_conn", " log2kb", "log_tx", "log_context", "loggerdesc", "log_conn", "log2context", "log2obj", "log_cas", "log__obj", " log2obj", "web_rec", "web_cas", "loggerconst", "web_ctx", "log_rec", "log_obj", " log_kb", "log_jac", "log_kb", "log2ctx", " log_context", "blog_const", "loggingdesc", "webptctx", "blog_desc", " log_desc", "log_desc", "log__context", "loggingtx", "logptcas", "loggerjac", "logptrec", "logptctx", "web_tx", " log_tx", "log2kb", "loggingconn", "log_const", " log2context"], "ret": ["rt", "gt", "ref", "result", "err", "not", "rem", "nl", "port", "def", "fin", "pas", "tr", "res", "elt", "ll", "re", "flag", "rel", "att", "resp", "det", "RET", "Ret", "r", "txt", "back", "out", "ft", " Ret", "nz", "reset", "val", "rets", "print", "alt", "success", "mel", "status", "no", "pro", "it", "nt", "aux", "try", "pret", "fun", "mt", "reply", "t", "j", "red"], "pad": ["crop", "shift", "ad", "store", "pen", "np", " padd", "patch", "address", "max", "ady", "grow", "pc", "ctx", "wait", "pair", "adder", "add", "pay", "offset", "pre", "pend", " padding", "cp", "len", "device", "pos", "append", "tip", "embed", "off", "cmd", "dev", "length", "bind", "end", "pkg", "prep", "ind", "push", "map", "delay", "port", "buffer", "added", "pod", "ack", "prefix", "count", "x", "seek", "quad", "Pad", "blank", "ptr", "pat", "batch", "rank", "depth", "pick", "scale", "padding", "pause", "d", "id", "ping", "paste", "pa", "n", "gate", "ix", "addr", "pack", "start"], "p": ["proc", "f", "pat", "parse", "g", "pkg", "fp", "jp", "P", "pre", "c", "peer", "h", "point", "post", "i", "per", "port", "q", "cp", "comp", "bp", "ip", "y", "pp", "np", "power", "pb", "patch", "pl", "pi", "att", "tip", "pers", "lp", "pm", "resp", "pc", "l", "wp", "pt", "ap", "d", "pod", "ping", "sp", "m", "local", "k", "pa", "n", "param", "vp", "primary", "app", "policy", "pair", "span", "par", "pro", "perm", "op", "at", "ps", "comm", "t", "rep", "dp", "tp", "j"], "currlinkn": ["currplugn", "currplayn", "currlinkmn", "currerlinkne", "currplugnel", "currstreammn", "currLinkn", "currstreamn", "currerlinkconn", "currnetworkmn", "currboltne", "currerlinkna", "currerlinknel", "currplaynel", "currlockconn", "currLinkna", "currlinkout", "currerLinkm", "currstreamconn", "currlinkcn", "currrlinkmn", "currrlinkcn", "currnetn", "currstreamcn", "currnodena", "currlocknm", "currplugns", "currerLinkn", "currerLinkna", "currerlinkns", "currboltconn", "currboltn", "currrstreamconn", "currlinkna", "currrstreamcn", "currerlinkn", "currerlinkout", "currerlinknm", "currplugout", "currrlinkconn", "currlinkns", "currlinknel", "currplayout", "currboltnm", "currrstreammn", "currrstreamn", "currplayns", "currlinkconn", "currnoden", "currlockne", "currlinkm", "currLinkm", "currnetworkconn", "currerlinkm", "currlinkne", "currnetna", "currlockn", "currnodem", "currnetworkcn", "currnetm", "currlinknm", "currnetworkn", "currrlinkn"]}}
{"project": "qemu", "commit_id": "46232aaacb66733d3e16dcbd0d26c32ec388801d", "target": 0, "func": "static void x86_cpu_common_class_init(ObjectClass *oc, void *data)\n\n{\n\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    xcc->parent_realize = dc->realize;\n\n    dc->realize = x86_cpu_realizefn;\n\n    dc->bus_type = TYPE_ICC_BUS;\n\n    dc->props = x86_cpu_properties;\n\n\n\n    xcc->parent_reset = cc->reset;\n\n    cc->reset = x86_cpu_reset;\n\n    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;\n\n\n\n    cc->class_by_name = x86_cpu_class_by_name;\n\n    cc->parse_features = x86_cpu_parse_featurestr;\n\n    cc->has_work = x86_cpu_has_work;\n\n    cc->do_interrupt = x86_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;\n\n    cc->dump_state = x86_cpu_dump_state;\n\n    cc->set_pc = x86_cpu_set_pc;\n\n    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = x86_cpu_gdb_read_register;\n\n    cc->gdb_write_register = x86_cpu_gdb_write_register;\n\n    cc->get_arch_id = x86_cpu_get_arch_id;\n\n    cc->get_paging_enabled = x86_cpu_get_paging_enabled;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_memory_mapping = x86_cpu_get_memory_mapping;\n\n    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;\n\n    cc->write_elf64_note = x86_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;\n\n    cc->write_elf32_note = x86_cpu_write_elf32_note;\n\n    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;\n\n    cc->vmsd = &vmstate_x86_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->debug_excp_handler = breakpoint_handler;\n\n#endif\n\n    cc->cpu_exec_enter = x86_cpu_exec_enter;\n\n    cc->cpu_exec_exit = x86_cpu_exec_exit;\n\n}\n", "idx": 19253, "substitutes": {"oc": ["org", "osc", "oca", "ok", "oad", "OC", "rc", "mc", "ot", "ic", "cp", "voc", "ocon", "loc", "unc", "soc", "ac", "pc", "nc", "oco", "o", "ocr", "bc", "uc", "alloc", "oci", "roc", "aco", "toc", "vc", "ec", "erc", "ob", "oid", "og", "od", "co", "arc", "ocation", "orp"], "data": ["config", "cache", "dll", "info", "func", "def", " sd", "ata", "res", "doc", "dat", "d", "rec", "DATA", "ctx", " d", "Data", "dd", "cmd", "ds", "output", "di", "bin", "dev", "name"], "xcc": [" xck", "xfacc", " xcar", "ixcar", "xxacc", "xffc", "xfcell", "oxcc", "ixCC", "xxcc", "ncc", "nac", " xCC", "oxcar", "xac", "xfc", "xpacc", "xack", "xcell", "xacc", "xaac", "oxCC", "ncell", "ixcc", "nck", "ixck", "oxck", " xac", "xck", "xcar", "xpfc", "xCC", "xfcc", "xxcell", "xacell", "xpcc", " xcell", "xpcell", "xxfc"], "cc": ["cf", "lc", "cv", "cell", "ucc", "cache", "conn", "inc", "craft", "c", "ca", "ld", "cm", "disc", "td", "fc", "rc", "CC", "lf", "ck", "icc", "mc", "func", "cont", "cp", "comp", "sc", "acc", "pp", "gc", "go", "BC", "ll", "unc", "tc", "cu", "ci", "ac", "pc", "nc", "con", "cca", "cl", "ctx", "ctl", "ct", "bec", "code", "bc", "uc", "xc", "control", "ctrl", "cmd", "ce", "cong", "vc", "coll", "ec", "cod", "cy", "lib", "cs", "isc", "xx", "cmp", "co", "cci", "cd"], "dc": ["cf", "lc", "DC", "c", "df", "bd", "cat", "ca", "disc", "cm", "fc", "rc", "ck", "mc", "dt", "cp", "gc", "iac", "unc", "tc", "da", "ac", "pc", "nc", "d", "cca", "rec", "ctx", "ctl", "dd", "bc", "db", "vc", "de", "ds", "ec", "di", "cci", "cs", "cmp", "co", "dp", "cd"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    audsettings_t obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 19256, "substitutes": {"hw": ["ht", "ews", "pkg", "hd", "sw", "hh", "aws", "iw", "h", "wd", "wy", "rh", "hs", "wm", "ay", "wk", "mg", "wo", "rack", "wn", "xp", "ha", "phy", "hz", "mph", "wx", "hog", "cu", "hm", "wi", "rw", "wp", "sys", "nw", "kw", "rew", "ich", "kh", "ctx", "ether", "how", "wan", "hub", "hop", "him", "ww", "aw", "wcs", "htt", "ew", "wa", "mx", "igh", "phys", "fw", "ow", "rpm", "w", "whe", "haw", "shake", "zh", "hp", "war", "sh", "vp"], "as": ["is", "asa", "rs", "aws", "sw", "a", "ass", "ais", "mas", "ias", "ay", "asm", "As", "ras", "jas", "asms", "kas", "ns", "asha", "ms", "ac", "asp", "ats", "ts", "asi", "nas", "asia", "eas", "ctx", "AS", "aw", "s", "ams", "ar", "ase", "au", "ast", "an", "am", "ars", "aus", "sa", "aos", "las", "bs", "conf", "sh"], "error": ["close", "Error", "type", "alias", "offset", "rank", "er", "result", "warning", "channel", "std", "err", "info", "rc", "order", "server", "p", "event", "ERROR", "r", "e", "address", " Error", "message", "query", "row", " err", "owner", "time", "se", "state", "comment", "description", "instance", "ar", "empty", "data", "pair", "success", "frame", "status", "no", "command", "start", "stable", "ace", " ERROR", "exc", "ror", "name", "detail"], "ss": [" os", "ls", "ks", "sv", "rs", " ssh", "iss", "sw", " rs", "aws", "ass", "tx", "sq", "hess", " ts", "settings", "js", "css", " sa", "pps", " sd", "ess", "pas", "serv", "ns", "ests", "sd", "ness", "spec", "ms", " ls", "rss", "ts", "\u00df", "sys", "SS", "si", " fs", " ps", "s", "ams", "pse", "stats", " iss", "oss", "ds", "ssl", "news", " sc", "ress", "cs", "ssh", " s", "ps", "sa", "bs", "aos", "ys", " us", " sys", "es"], "pa": ["ppo", "pol", "ja", "pkg", "jp", "ta", "ada", "oe", "ca", "mp", "ia", "pr", "pas", "ea", "pan", "pp", "ha", "pi", "pb", "pause", "ka", "pm", "aka", "pc", "pai", "sea", "pt", "ap", "pee", "ma", "ph", "ava", "ping", "asia", "ctx", "qua", "wan", "paste", "apa", "po", "val", "wa", "au", "ppa", "Pa", "fa", "pha", "ga", "no", "pro", "py", "pe", "whe", "opa", "oa", "sa", "PA", "ps", "la", "ara", "rep", "pu", "ota", "pse", "p"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)\n\n{\n\n    CPU_DoubleU farg;\n\n    int isneg;\n\n    int ret;\n\n    farg.ll = arg;\n\n    isneg = float64_is_neg(farg.d);\n\n    if (unlikely(float64_is_nan(farg.d))) {\n\n        if (float64_is_signaling_nan(farg.d)) {\n\n            /* Signaling NaN: flags are undefined */\n\n            ret = 0x00;\n\n        } else {\n\n            /* Quiet NaN */\n\n            ret = 0x11;\n\n        }\n\n    } else if (unlikely(float64_is_infinity(farg.d))) {\n\n        /* +/- infinity */\n\n        if (isneg)\n\n            ret = 0x09;\n\n        else\n\n            ret = 0x05;\n\n    } else {\n\n        if (float64_is_zero(farg.d)) {\n\n            /* +/- zero */\n\n            if (isneg)\n\n                ret = 0x12;\n\n            else\n\n                ret = 0x02;\n\n        } else {\n\n            if (isden(farg.d)) {\n\n                /* Denormalized numbers */\n\n                ret = 0x10;\n\n            } else {\n\n                /* Normalized numbers */\n\n                ret = 0x00;\n\n            }\n\n            if (isneg) {\n\n                ret |= 0x08;\n\n            } else {\n\n                ret |= 0x04;\n\n            }\n\n        }\n\n    }\n\n    if (set_fprf) {\n\n        /* We update FPSCR_FPRF */\n\n        env->fpscr &= ~(0x1F << FPSCR_FPRF);\n\n        env->fpscr |= ret << FPSCR_FPRF;\n\n    }\n\n    /* We just need fpcc to update Rc1 */\n\n    return ret & 0xF;\n\n}\n", "idx": 19274, "substitutes": {"arg": ["f", "bit", "reg", "ok", "g", "ax", "ref", "inc", "args", "fac", "Arg", "ag", "ad", "def", "in", "doc", "ig", "deb", "p", "obj", "cal", "rap", "re", "target", "flag", "arr", "argument", "local", "param", " larg", "var", "inter", "oc", "val", "ar", "au", "ang", "aux", "conf", "field", "add", "arp"], "set_fprf": ["set_fporfx", "set_fsprfx", "set_vPRF", "set_nporfx", "set_fporc", "set_nporb", "set_fbrf", "set_vPRx", "set_fcrb", "set_vPRf", "set_fsprc", "set_fporf", "set_nporf", "set_vprf", "set_fsprF", "set_nprf", "set_fPRx", "set_fbrb", "set_fporb", "set_fprfx", "set_fprb", "set_nprb", "set_fPRb", "set_vprF", "set_fbrfx", "set_fprc", "set_fPRF", "set_fcrx", "set_nporc", "set_fPRf", "set_fprx", "set_vprx", "set_fsprx", "set_fprF", "set_vPRb", "set_fcrF", "set_fsprb", "set_fcrf", "set_fsprf", "set_vprb", "set_nprc", "set_fbrc", "set_nprfx"], "farg": [" fagg", "floatapp", " fop", "lfrav", " fric", "lfitem", "fedagg", "fpack", "fbtag", "freg", " dfvar", "fullarg", " fpack", "fullref", "frav", " dfargs", " farp", "fullreg", "fcargument", "flargument", "fwarg", "fwref", "fullagg", "fargs", "fmargs", "ffield", " fargument", "fullfield", "flarg", "flop", "fitem", "dpack", "fcarp", " fvar", "fabarg", " fref", "fladmin", "fref", "farc", "floatric", " faut", "fagg", "fabfield", "fmvar", "fop", "floatfield", "fedric", "lfargument", "darg", "lfarg", "fmarg", "fmaut", "farp", "flrav", "floattag", "fvar", "floatarc", "dargument", "flitem", "flapp", "fapp", "fric", "ftag", "fullric", " freg", "floatarp", "flreg", "fedarg", "fabref", "fbarg", "fcarg", "fabarc", "fcpack", "fbapp", "floatitem", "floatref", "fedreg", " fargs", "fwarp", " dfarg", "floatrav", "fbadmin", " dfaut", "fullarc", "floatargument", "floatop", "faut", "darp", "fwric", "floatreg", "fltag", "floatadmin", "floatarg", "fadmin", "fargument"], "isneg": ["ISpos", "risdec", "ispriv", "ipos", "ispos", "lisui", " isrel", "Isneg", "ISneg", "isaneg", "isorigin", "osmobile", "osneg", "rismobile", "aisneg", "espos", "ismobile", "aismobile", " ispos", "esneg", "lisorigin", "esnegative", "isrel", " isnegative", "isapriv", "lisneg", "ineg", "ISnegative", "risserver", "isne", "ipriv", "Isnegative", "irel", "isui", "aisrel", "imobile", " isne", "isdec", "isaui", "esne", "iui", "aisserver", "risneg", "isnegative", "iorigin", "isaorigin", "Ispos", "aispos", " ismobile", "isserver", "ISne", "aisdec", "lispriv", "Isne", "osserver", "osdec"], "ret": [" RET", "cat", "eth", "def", "det", "RET", "utils", "alf", "out", "print", "val", "replace", "req", "mem", "status", "art", "rm", "reply", "mb", "hash", "rest", "url", "bit", "reg", "gt", "test", "iter", "virtual", "rem", "cont", "dt", "len", "net", "obj", "Return", "re", "expr", "back", "ft", "cmd", "fun", "nt", "tag", "usr", "mt", "opt", "ext", "terror", "result", "ert", "pert", "elt", "flag", "match", "set", "resp", "txt", "cert", "rets", "desc", "quad", "last", "dr", "try", "pret", "ptr", "tech", "rt", "nil", "tt", "ref", "final", "pub", "tr", "res", "der", "att", "aj", "rel", "rev", "Ret", "ter", "sys", "ort", "value", "nz", "reset", "str", "rot", "alt", "addr", "t"]}}
{"project": "qemu", "commit_id": "df8002103c3e262dc40d7b5e0eb2171ba28b1d63", "target": 0, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {\n\n            if (s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n                /* can always write bit 4 of CR7 */\n\n                if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 19290, "substitutes": {"opaque": ["popaque", "opent", "oposter", "iopaques", "poster", "paque", "opacity", "opsaque", " opque", "iopque", "pque", "opsent", "popacity", "popaques", " opaques", "opque", " opacity", "opsacity", "paques", "popent", "ioposter", " opent", " oposter", "iopaque", "opaques", "opsaques"], "addr": ["url", "pad", "act", "alias", "coord", "attr", "offset", "ref", "host", "location", "ind", "init", "tx", "iter", "ret", "func", "ad", "store", "order", "tr", "loc", "rr", "align", "src", "handle", "address", "arr", "r", "id", "ack", "v", "var", "ord", "ctx", "inter", "alloc", "db", "ix", "cmd", "grad", "str", "x", "link", "prefix", "dr", "mac", "adr", "at", "ptr", "mt", "ace", "hash", "add"], "val": ["prop", "xy", "def", "al", "check", "vol", "pol", "v", "var", "ctx", "key", "gold", "mem", "sel", "als", "new", "bit", "reg", "tx", "test", "Val", "fb", "VAL", "ret", "values", "pr", "serv", "len", "pos", "obj", " aval", "eval", "el", "vals", "msg", "bl", "ival", "dev", "conf", "p", "unit", "ind", "fail", "err", "valid", "buffer", "byte", "rol", "cal", "elt", " arg", "arg", "buf", "pt", "txt", "sol", "x", "vt", "try", "cho", "ref", "func", " v", "bool", "res", "fx", "doc", " value", "item", "rel", "arr", "list", "value", "num", "Value", "rot", "str", "data", "alt", "lib", "aval", "it", "bin", "stat"], "s": ["is", "er", "as", "states", "sn", "a", "c", "h", "sm", "js", "store", "ies", "y", "vs", "details", "ims", "e", "ids", "v", "utils", "tes", "stats", "qs", "ses", "less", "comments", "als", "terms", "bits", "aws", "sw", "xs", "des", "ss", "ns", "events", "obj", "sd", "spec", "sort", "ms", "parts", "bis", "state", "services", "an", "w", "S", "cs", "conf", "sis", "hs", "p", "sl", "sts", "ains", "g", "rs", "sq", "aunts", "service", "self", "os", "ess", "set", "m", "sp", "sb", "ssl", "gs", "bs", "ls", "esm", "sv", "changes", "settings", "params", "r", "ats", "ts", "sys", "its", "b", "se", "n", "tests", "ds", "sam", "ps", "t", "fs", "j", "es"], "index": ["block", "column", "route", "init", "vector", "i", "seed", "shape", "exclusive", "address", "query", "insert", "scan", "ctx", "key", " ind", "send", "axis", "active", "link", "capacity", "status", "node", "find", "new", "offset", "test", "iter", "pos", "zero", "row", "total", "state", "change", "success", "loop", "length", "all", "scroll", "location", "ind", "Index", "update", "condition", "point", "ex", "valid", "size", "error", "version", "loc", "set", "match", "commit", "cycle", "ticket", "level", "x", "seek", "count", "number", "module", "ptr", "cond", "si", " offset", "config", "connect", "search", "draw", " address", "position", "thread", "scale", "server", "select", "height", "request", "list", "value", "num", "id", "local", "gate", " sidx", "dd", "slice", "ix", "timeout"]}}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 19291, "substitutes": {"nc": ["ne", "nm", "cn", "ics", "c", "nr", "nic", "yn", "cus", "anc", "usc", "nl", "sc", "nn", "np", "ns", "gc", "unc", "NC", "tc", "pc", "nw", "cc", "n", "ct", "nz", "bc", "oc", "Ns", "nt", "nih", "cs", "nec", "isc", "rn"], "s": ["ls", "sl", "is", "us", "sts", "sv", "rs", "states", "aws", "changes", "fs", "a", "h", "sq", "sm", "xs", "js", "ss", "ess", "y", "p", "ns", "sd", "ats", "l", "ts", "sys", "b", "n", "has", "bis", "sports", "sb", "stats", "ds", "qs", "ses", "less", "S", "sam", "gs", "cs", "ps", "t", "bs", "als", "sis", "hs", "z", "j", "es"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n", "idx": 19301, "substitutes": {"buf": ["pad", "window", "tmp", "cv", "ff", "block", "ref", "page", "fp", "map", "c", "h", "xff", "port", "batch", "buffer", "q", "cap", "Buffer", "cp", "rb", "bp", "pos", "img", "read", "cb", "pb", "loc", "max", "r", "b", "v", "paste", "ctx", "uf", "out", "paren", "alloc", "cmd", "pg", "data", "cur", "mem", "w", "msg", "bl", "buff", "raw", "bin", "limit", "ptr", "queue"], "size": ["length", "sum", "type", "offset", "g", "en", "sn", "c", "h", "fee", "sent", "nl", "shape", "buffer", "SIZE", "scale", "padding", "ize", "pos", "in", "body", "bytes", "max", "message", "small", "l", "m", "sp", "v", "n", "space", "Size", "send", "since", "s", "empty", "count", "mem", "number", "w", "start", "sh", "z", "name"], "pmsg_type": ["pmsg___Type", "pmessage_type", "pmsg__num", "pmessage_Type", "pmessage_name", "pmsg___name", "pessage_type", "pmessage_id", "pmsg__name", "pmessage_size", "pessage_data", "pmsg_size", "pmessage_num", "pmsg__type", "pmsg__Type", "pmsg_num", "pmsg_Type", "pmsg_id", "pmsg_data", "pessage_Type", "pmsg___type", "pmsg_error", "pmsg_name", "pmsg___num", "pessage_error"], "p": ["proc", "f", "pad", "pay", "pat", "g", "en", "pkg", "page", "fp", "P", "jp", "pre", "c", "h", "a", "point", "post", "i", "pr", "port", "pointer", "buffer", "q", "cp", "bp", "y", "pos", "xp", "pp", "np", "ip", "pi", "pb", "pl", "php", "r", "lp", "pers", "pc", "l", "wp", "pt", "d", "ap", "m", "ping", "sp", "pid", "b", "v", "progress", "n", "pa", "vp", "prefix", "pg", "up", "span", "par", "pro", "pe", "pn", "at", "pack", "ps", "t", "rep", "dp", "tp", "j"], "p_end": ["tp_start", "p__size", "tp_end", "p2end", "p_END", "p_stop", "p_len", "p_size", "p_max", "lp_stop", " p_max", " p_size", "tp_len", "tp_END", "p2END", "lp_END", "lp_end", " p_END", "p_ending", "p_start", "p__end", "p2stop", " p_ending", "p__ending"], "len": ["ls", "sl", "fl", "length", "lan", "cmp", "label", "offset", "all", "en", "Len", "vec", "lt", "err", "lit", "lf", "nl", "li", "conv", "fin", "pos", "elt", "line", " el", "ll", "pl", "lp", "l", "el", "un", "sp", "v", "n", "mat", "mn", "val", " clen", "str", "lim", "lon", " l", "count", "coll", "mem", "cod", "seq", "ann", "ln", "lib", "fun", "nt", "lic", "il", "L", "t", "fn", "ld", "repl"], "tag": ["prop", "cat", "tar", "debug", "var", "key", "old", "word", "cmp", "hash", "field", "pad", "bit", "reg", "offset", "ag", "style", "ot", "pos", "net", "bug", "rat", "date", "row", "mat", "back", "code", "comment", "cmd", "html", "par", "mt", "meta", "Tag", "end", "tg", "card", "parent", "term", "brand", "te", "TAG", "comp", "go", "match", "feat", "flag", "set", "pod", "prefix", "count", "task", "col", "no", "dr", "token", "at", "tags", "qual", "type", "attr", "role", "tail", "tr", "ver", "note", "call", "local", "feature", "format", "op", "stat", "pack", "t"]}}
{"project": "qemu", "commit_id": "ddb603ab6c981c1d67cb42266fc700c33e5b2d8f", "target": 0, "func": "static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n\n{\n\n    XHCITRB *trb_setup, *trb_status;\n\n    uint8_t bmRequestType;\n\n\n\n    trb_setup = &xfer->trbs[0];\n\n    trb_status = &xfer->trbs[xfer->trb_count-1];\n\n\n\n    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,\n\n                              xfer->epctx->epid, xfer->streamid);\n\n\n\n    /* at most one Event Data TRB allowed after STATUS */\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n\n        trb_status--;\n\n    }\n\n\n\n    /* do some sanity checks */\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n\n                TRB_TYPE(*trb_setup));\n\n        return -1;\n\n    }\n\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n\n                TRB_TYPE(*trb_status));\n\n        return -1;\n\n    }\n\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n\n        return -1;\n\n    }\n\n    if ((trb_setup->status & 0x1ffff) != 8) {\n\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n\n                (trb_setup->status & 0x1ffff));\n\n        return -1;\n\n    }\n\n\n\n    bmRequestType = trb_setup->parameter;\n\n\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n\n    xfer->iso_xfer = false;\n\n    xfer->timed_xfer = false;\n\n\n\n    if (xhci_setup_packet(xfer) < 0) {\n\n        return -1;\n\n    }\n\n    xfer->packet.parameter = trb_setup->parameter;\n\n\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n\n\n    xhci_try_complete_packet(xfer);\n\n    if (!xfer->running_async && !xfer->running_retry) {\n\n        xhci_kick_epctx(xfer->epctx, 0);\n\n    }\n\n    return 0;\n\n}\n", "idx": 19307, "substitutes": {"xhci": ["xhlci", "xhhpi", " xxhlii", "xhhci", "xhvc", "xhlpi", "xhtvc", " xxhlpi", "xhlvc", " xxhii", "xhlii", "xhtci", "xhii", "xhhvc", "xhtpi", "xhhii", "xhpi", " xxhlci", "xhtii", " xxhci", " xxhlvc", " xxhpi", " xxhvc"], "xfer": ["crossfer", "xferred", "wxfr", "xporter", "crosstransfer", "inxlate", "vfer", "ixporter", "exiter", "xcer", "refer", "ctxlate", "oxpire", "axiter", "wxporter", "zxreq", "ctxference", "txiter", "txfer", "xxporter", " xFER", "ixFER", " xve", "ixference", "zxfer", "ixreq", "oxiter", "xsend", "xxcer", "txport", "ctxfe", "xterm", " xiter", "xtransfer", "axporter", "ixfe", "oxference", "ixffer", "_", "xreq", "xfr", "workpire", "axfer", "exterm", " xpire", "ixfer", "xxport", " xporter", "oxcer", "xception", "xpporter", "txffer", "inxfer", "workfer", "txFER", "crosspire", "reference", "xxference", "ixterm", "crossve", "xfporter", "extransfer", "axsend", "ixuse", "txcert", "ixve", "tception", " xferred", "cmd", "ixfr", "txception", "zxferred", "xject", " xreq", "uxffer", "exporter", "uxterm", "xxfr", "xxiter", "xpject", "txporter", "ixferred", " xtransfer", "tfer", "xlate", "xxfer", "xpire", "zference", " xfr", "tporter", "yiter", "xffer", "xxcert", "ixiter", "txpire", "xport", "xxffer", "txference", "ixtransfer", "oxFER", "xference", "xuse", "wxject", "ixlate", "workference", "wxception", "vference", "workporter", "uxFER", "ixject", "xpfer", "zfer", "oxsend", "yfer", "wxpire", "xxFER", "xxtransfer", "axference", "uxference", "zFER", " xuse", "wxfer", "txcer", "xfject", " xference", "wxference", "yporter", "zxference", "ixpire", "oxcert", "uxporter", "xiter", "xfe", "inxfe", "oxception", "exffer", " xsend", "func", "axffer", "wxFER", "xffr", "xpfr", "reiter", "uxferred", "xcert", " xception", "xxpire", "tference", "exfer", "zuse", "retransfer", "txferred", "vffer", "uxiter", "xFER", "xe", " xject", "inxference", "uxfr", "oxfer", "ytransfer", "vporter", "exec", "xve", "uxfer", "ctxfer", "oxport"], "trb_setup": ["trB_status", "trfb_init", "trb_init", "trb_sequence", "trb_result", "trB_settings", "trb_____setup", "trB_call", "trB_rise", "trfb11update", "trb_update", "trb11init", "trB_help", "trb_____call", "trbb_init", "trb___setup", "trb_sync", "trb_info", "trbdefsetup", "trb_config", "trb_____new", "trbb_update", "trbbdefinit", "trbaircall", "trb_set", "trba_setup", "trb_new", "trba_reset", "trb_Setup", "trfb11get", "trB_new", "trB_Setup", "trb11update", "trb_help", "trbdefinit", "trbTheset", "trB_init", "trB_sequence", "trfb11init", "trb___init", "trbdefcheck", "trbbdefsetup", "trb_check", "trba_Setup", "trb11get", "trb_settings", "trbb_setup", "trb_____set", "trB_set", "trb_call", "trB_config", "trB_connect", "trB_setup", "trba_result", "trfb_setup", "trbbdefupdate", "trB_control", "trb_connect", "trfb11setup", "trbbdefcheck", "trbairsetup", "trbairset", "trbThesetup", "trbdefupdate", "trbTheconnect", "trbb_check", "trb_reset", "trB_sync", "trb_control", "trb_get", "trb11setup", "trfb_update", "trb___status", "trbThehelp", "trB_info", "trb_rise", "trb___control", "trfb_get", "trbairnew"], "trb_status": ["trB_status", "trb0stat", "trB_version", "trb_result", "trB_settings", "trB_res", "trB_description", "trB_handle", "trB_check", "trp_status", "trb___stat", "trb0status", "trb_free", "trb0check", "trb_type", "trb_version", "trb_Status", "trb___reason", "trp_spec", "trb0type", "trB_stat", "trb_handle", "trb_check", "trb_description", "trB_reason", "trb_settings", "trb__description", "trB_type", "trp_result", "trb___handle", "trb__stat", "trb_res", "trb_spec", "trB_Status", "trB_free", "trb__type", "trb_stat", "trb___status", "trb__check", "trb_reason", "trp_stat", "trb__status"], "bmRequestType": ["bmEventStyle", "bnrequestTyp", "BMResponseTypes", "bmReturnType", "bmrequestType", "bmrequestInfo", "bmReturnTYPE", "bmRequTYPE", "bmRequestTyp", "bdRequestTYPE", "bmRequTypes", "bnRequestTyp", "bnRequestInfo", "bmrequestTyp", "bnRequestTypes", "bmRequType", "bmEventName", "bnrequestInfo", "bnrequestTypes", "bmCommandType", "BMResponseType", "bmCommandTypes", "bmRequestName", "bdRequType", "bdRequStyle", "bdRequestType", "bmRequestInfo", "BMRequestType", "bmRequestStyle", "BMRequestTypes", "bmResponseInfo", "bmResponseTypes", "bmCommandName", "bmReturnStyle", "bmRequestTYPE", "bdRequestStyle", "bmEventType", "bnrequestType", "BMRequestStyle", "bmRequInfo", "bmRequStyle", "bmRequestTypes", "bnRequestType", "bmResponseName", "BMResponseName", "bdRequTYPE", "bmResponseStyle", "bmResponseTyp", "BMResponseStyle", "bmResponseType", "bmCommandStyle", "bmRequTyp", "bmrequestTypes", "bmEventTypes", "BMRequestName"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n", "idx": 19322, "substitutes": {"ts": ["ls", "sts", "ks", "tt", "rs", "tn", "ics", "tis", "estamp", "Ts", "ss", "ns", "ims", "kt", "ms", "ents", "ats", "pc", "pt", "its", "tes", "uts", "TS", "ds", "qs", "gs", "cs", "mt", "tz", "ps", "t", "bs", "als", "fs", "hs", "tp"]}}
{"project": "FFmpeg", "commit_id": "816577716bc6170bccfea3b9e865618b69a4b426", "target": 1, "func": "static av_cold int dvdsub_close(AVCodecContext *avctx)\n\n{\n\n    DVDSubContext *ctx = avctx->priv_data;\n\n    av_freep(&ctx->buf);\n\n    ctx->buf_size = 0;\n\n    return 0;\n\n}\n", "idx": 19353, "substitutes": {"avctx": ["avctrl", "savctrl", "avtx", "awctx", " avctrl", "aftx", " avcontext", " avtx", "awctrl", "avcv", "afcontext", "awtx", "savcv", "avcontext", "savcontext", " avcv", "awcontext", "savctx", "afcv", "savtx", "afctx"], "ctx": ["crit", "cf", "px", "cv", "act", "config", "ref", "pkg", "hw", "ind", "cam", "ctr", "tx", "c", "anc", "ck", "mc", "cp", "np", "obj", "ns", "kt", "loc", "cb", "gc", "inst", "tc", "unc", "buf", "ac", "nc", "cc", "kw", "txt", "cl", "ct", "wcs", " cx", "bc", "xc", "context", "cmd", "ctrl", "desc", "req", "lib", "auth", "nt", "tz", "ptr", "cmp", "cfg", "cor", " context"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return toclen;\n\n}\n", "idx": 19373, "substitutes": {"req": ["crit", "org", "reg", "attr", "ref", "conn", "pkg", "Requ", "ind", "jp", "tx", "sq", "err", "rx", "dq", "urg", "q", "fr", "requ", "rb", "res", "qt", "rr", "qq", "spec", "wx", "r", "resp", "query", "request", "buf", "gr", "gz", "ctx", "history", "ocr", "md", "cmd", "quest", "prefix", "desc", "uj", "compl", "http", "mem", "required", "msg", "inv", "rpm", "aux", "usr", "queue", "comm", "cmp", "j", "each"], "outbuf": ["outputbuff", "invvec", "outbound", "Outbuffer", "OUTbytes", "outbag", "outbuff", " outbytes", "inbuff", " outbuff", "OUTbuf", " outqueue", "outputbuffer", "checkbag", " outbuffer", "invbuf", "inbuf", "outbuffer", " outbag", "checkbuf", "outbu", "callbu", " outbu", "outvec", "callbuf", "callbuff", "OUTbuff", "invbuffer", "outputqueue", "Outvec", "inbuffer", " outbound", "Outqueue", "inqueue", "outputbuf", "checkbuff", "invbu", "outputbound", "callbound", "OUTvec", "outputbytes", "outqueue", "Outbag", "Outbu", "outputbu", "Outbuff", "checkbytes", "outbytes", " outvec", "Outbytes", "Outbuf"], "s": ["ls", "sl", "is", "sts", "rs", "iss", "sw", "c", "sq", "h", "sis", "js", "i", "ss", "ess", "y", "syn", "ns", "r", "ts", "sys", "m", "sp", "es", "b", "v", "n", "se", "sb", "sol", "ds", "http", "ses", "less", "S", "sam", "gs", "sa", "ps", "t", "comm", "fs", "hs", "p"], "start_track": ["start_tracks", "startTimetrack", "start_tr", " start_tracking", "startTimeroute", " start_seek", " start_route", "start_tracking", "end_trace", " start_tr", "start_Track", "startPosttrack", " start_tracks", "start_rack", "start_ack", "start_seek", "startPosttrace", "end_track", "startTimerack", "end_ack", "start_trace", "startPostack", " start_Track", " start_rack", "start_route"], "format": ["unit", "f", "ff", "act", "type", "cf", "filter", "fp", "method", "fc", "size", "style", "dim", "scale", "version", "len", "iat", "pattern", "spec", "feat", "set", "form", "function", "sort", "fit", "ats", "fm", "mat", "force", "mode", "ft", "time", "Format", "prefix", "feature", "file", "atter", "frame", "status", "transform", "MAT", "command", "tag", "mt", "t", "fn", "api", "name", "pretty"], "msf": [" msm", "csm", "armsfr", "entsf", " msF", "entsfr", "msfi", "entsfe", "csf", "msm", " msfs", "tesz", "omsv", "csF", "msfe", "lsm", "tesfg", " msfer", "csfi", "msz", "armsfe", "tesf", " mscf", "ampsF", "armsz", "armsf", "tsp", "msF", "msfr", "emsf", " msfr", "emsfer", "armscf", " msfg", "lsp", "lsv", "omsf", "tsv", "lsf", "msv", "tsf", "lsfi", "ampsf", "msp", "msfs", " msz", "ampsfer", "omsfi", "emsF", "mscf", "entscf", "lsF", "emsfs", "armsfg", "armsfs", "tsfi", "tesfs", "omsp", " msfi", " msfe", "msfg", "ampsfs", "msfer"], "toclen": ["topicfin", "doclength", "soclength", "toclim", " tcLen", "soclan", "socrel", "topiclength", "tocrel", "allocstr", "alloclength", "tocstr", "tclan", "oclen", "oclength", "doclan", "soclim", "toclength", "ocdir", "doclen", "socLen", "tclim", "socstr", "tclen", " tclength", "tcrel", "htmllength", "tocfin", "tocLen", " tcdir", "socdir", "htmlfin", "tocdir", "ocLen", "topiclen", "ocstr", "docLen", "soclen", "alloclen", "tnLen", "socfin", "tcLen", "toclan", "htmlLen", " tclen", "tnrel", "tclength", "tnlim", "tnlen", "htmllen", "topicLen", "allocLen"], "nb_sectors": ["nb_usellers", "nb_velements", "nb_nellers", "nb_sesicides", "nb_negments", "nb_sellers", "nb_seonents", "nb_pegments", "nb_useonents", "nb_useors", "nb_seors", "nb_perseors", "nb_pellers", "nb_peonents", "nb_nectors", "nb_bectors", "nb_beors", "nb_becs", "nb_perseonents", "nb_sesctors", "nb_perseicides", "nb_usectors", "nb_veicides", "nb_veors", "nb_nelements", "nb_sesors", "nb_persectors", "nb_pectors", "nb_peors", "nb_seicides", "nb_vectors", "nb_neors", "nb_pecs", "nb_sesonents", "nb_vegments", "nb_begments", "nb_secs", "nb_veonents", "nb_selements", "nb_belements", "nb_segments", "nb_vecs", "nb_vellers"]}}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 19380, "substitutes": {"bs": ["bb", "bh", "ubs", "BS", "js", "bp", "vs", "ims", "pb", "eb", "bed", "bec", "qs", "ses", "abilities", "als", "bes", "bits", "outs", "aws", "aps", "lbs", "ns", "hz", "ubis", "ms", "bis", "cks", "vals", "aus", "bl", "cs", "aos", "sts", "rs", "css", "lines", "blog", "stones", "acs", "vers", "bing", "bn", "sb", "bc", "uts", "lb", "bps", "gs", "bm", "boxes", "ls", "bi", "names", "obs", "bytes", "ears", "ats", "ts", "its", "fps", "b", "ba", "bos", "ds", "els", "bas", "base", "news", "bles", "bf", "ps", "otes", "lets", "fs", "banks"], "errp": ["arrper", "arrp", " errpkg", "aerp", "diep", "arrpe", "dieP", " errper", " errP", " errpa", "ererp", "aerP", "aerpkg", "errpa", "dieps", "diepa", " errpad", "errps", "errpe", "aerpa", " errps", "arrpa", "arrps", "errpad", "errper", "ererpad", "ererps", "diepe", "errP", "ererper", "arrpad", "errpkg", " errpe", "diepkg"], "local_err": ["localererrors", "local_er", "locallyerr", " local_arr", "local_r", "internal_r", "locallyreq", "local_arr", "local_rr", "partialererr", "partial_err", "internal_er", "localererr", " local_eas", " local_er", " local_msg", " local_error", "local_msg", " local_rr", "partialererrors", "internal_err", "local_req", "localereas", "localerrel", "partial_rel", "local_eas", "local_errors", "partial_eas", "local_error", "internal_eas", "locallyer", "locallyeas", "partialerrel", " local_req", "local_rel", "partialereas", "partial_errors"], "ret": ["rt", "ext", " res", "gt", "ref", "ctr", "result", "sec", "lt", "rem", "def", " alt", "del", "tr", "res", "len", "elt", "ll", "re", "arg", "arr", "resp", "det", "RET", "Ret", "ter", "rev", "back", "out", "ft", "cert", "nz", "inter", "reset", "print", "val", "rets", "cmd", "desc", "kb", "alt", "mem", "deg", "mber", "status", "fun", "nt", "rm", "usr", "mt", "reply", "ptr", "t", "hash"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 19389, "substitutes": {"dev": ["proc", "Dev", "block", "conn", "hw", "cam", "h", "test", "develop", "info", "des", "ad", "def", "serv", "device", "doc", "obj", "debug", "home", "go", "sd", "ver", "spec", "att", "buf", "dem", "d", "env", "off", "v", "ev", "out", "priv", "dd", "ve", "devices", "db", "cmd", "DEV", "data", "desc", "Device", "de", "mem", "w", "pro", "vo", "nt", "raw", "serial", "adv", "av", "ch", "conf"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "aws", "fs", "south", "a", "c", "sq", "h", "js", "i", "ss", "su", "syn", "ns", "spec", "ts", "sys", "m", "es", "b", "v", "n", "sb", "state", "sol", "ds", "ses", "w", "S", "gs", "cs", "sa", "ps", "t", "bs", "conf", "sis", "p"], "pci_conf": ["puci_fac", "pci_con", "pdat_con", "pci00cand", "pdi_def", "puci_cand", "puci_config", "pci_fac", "pdi_config", "pdat_conv", "pcu_config", "pcixcon", "pdat_conf", "pdi_priv", "pci_cons", "pci_priv", "pcixconf", "pcixnav", "puci_conf", "pco_conf", "pci_cand", "pcu_prop", "pcu_conn", "pci_config", "pdat_nav", "pci00conf", "pcixconv", "pci00config", "pci_nav", "pco_con", "pdi_conf", "pcu_conf", "pci_prop", "pdi_com", "pci_com", "pci_conv", "pci_def", "pco_cons", "pdi_conn", "pci_conn", "pco_config", "pci00fac"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n", "idx": 19403, "substitutes": {"insn": ["insnm", "resn", "insnz", "linsn", "linssn", "insz", "intsnz", "valsne", " insz", "resnan", "intsn", "pssn", "ressn", "insne", "pinssn", "intsnan", "valssn", "linsdn", "linsne", "insdn", "resnz", "linsnan", "pinsne", "pinsn", "linsz", "linsnz", "linsnm", " insdn", "valsnm", "pinsnm", "insnan", "valsn", "psz", "inssn", "intssn", "psdn", "psn", " inssn"], "mask": ["window", "sum", "config", "filter", "white", "crop", "map", "shift", "lock", "ask", "shape", "bool", "sign", "master", "loc", "patch", "flag", "match", "black", "set", "address", "check", "target", "list", "kw", "mode", "key", "mk", "Mask", "weight", "flags", "perm", "pack", "tag", "addr", "cmp", "conf"], "dest": ["Dest", "proc", "window", "opt", "sum", "end", "st", "result", "trans", "test", "temp", "origin", "cont", "tr", "img", "obj", "master", "loc", "dist", "orig", "target", "src", "table", "buf", "sys", "txt", "v", "global", "out", "cur", "mem", "transform", "msg", "source", "addr", "usr", "ptr", "nom", "rest"], "tmp": ["cv", "box", "mut", "cache", "tar", "tab", "trap", "etc", "np", "qq", "dat", "table", "ctx", "v", "out", "mk", "uv", "old", "buff", "node", "snap", "mb", "cmp", "tp", "new", "proc", "test", "temp", "ret", "cp", " src", "obj", "dist", "target", "src", "global", "db", "msg", "nt", "p", "window", "result", "ind", "tg", "loc", "orig", "resp", "buf", "sp", "txt", "cur", "vt", "pool", "ptr", "repl", "rt", "attr", "tt", "emp", "tn", "trans", "jp", "mm", "copy", "td", "mp", "img", "local", "utm", "output", "mint", "tv", "perm", "start", "t"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIONvidia3d0Quirk *data;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vdev->bars[1].region.size) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->data = data = g_malloc0(sizeof(*data));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    data->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,\n\n                          data, \"vfio-nvidia-3d4-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,\n\n                          data, \"vfio-nvidia-3d0-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 19408, "substitutes": {"vdev": ["evstore", "svver", "svstore", "avve", "evDEV", "vcdev", "envga", "svend", "hDev", " vapp", "avscan", "vve", "svev", "avDev", "hdev", "vstable", "vcev", " vDevice", "evdef", "hsys", "gev", "envdev", "vDEV", "gDev", "gstable", "vscan", "pstable", "vver", "lenv", " vstore", "vstore", "pdev", "vend", "evenv", "evver", "evapp", "pdevice", "vrdev", "vcam", "tev", "gdev", "vtech", " vver", "tend", "avDEV", " vsys", "gve", "venv", "vctech", "vcenv", "envdevice", "gend", " vDEV", " venv", "avsys", "vrpro", "gcam", "avDevice", "avdev", " vtech", "hcam", "vrcam", "nsys", "avdevice", "vrDev", " vdef", "avga", "ncam", "vDev", "svdev", "avenv", " vstable", "evDevice", " vcam", "gdevice", "vdef", " vscan", "avdef", "vdevice", " vDev", "tdev", "pev", "vapp", "vpro", " vpro", "ndev", " vev", "vga", "vev", "vDevice", "evdev", "evscan", " vdevice", "hga", "lev", "svapp", "svenv", "hdevice", " vve", "tdevice", "svdevice", "vsys", "svDEV", "envDev", "ldev", "avcam", "svsys", "gpro", "ndevice", "ltech"], "quirk": ["qlict", "qirk", "qarantine", "invirus", "acquirrel", "acquiat", "quault", "inqulict", "qirrel", "invirrel", "blasi", "gallinn", "requirt", "QUirrel", "requiat", "aquirrel", "requlict", " quirus", "gallirk", "qulict", "squirt", "galllict", " inquitton", "qasi", "squiat", "equirk", "invirk", "QUinnie", "querirrel", "chirk", "requitton", "guirk", "QUirk", "quitton", "inquirrel", "blault", "quiry", " inqulict", "inquasi", "guirt", "aquirk", "aquiat", "acquirus", "equarantine", "quiat", " quinn", "queriat", "quirus", "inquirk", "squirk", "invasi", "acquasi", "queriry", "blirt", "acqulict", "glirrel", "requirus", "requinnie", "acquitton", "invault", "guasi", "aquiry", "requirrel", "quirt", "aqulict", "virk", "qirus", " qulict", "gliat", "requirk", "quasi", "quirrel", "vlict", "blirk", "quinn", "vasi", "aquirus", "invirt", "quarantine", " quinnie", "requiry", "glirk", " inquirk", "equirus", "QUirus", "virus", "requarantine", "equirrel", "glirus", "chinn", " quirrel", "chiat", "invlict", "chirus", "gallirus", "quinnie", "querirk", "chirt", "aquasi", "squlict", " inquiat", "acquirk", "chlict", "guault"], "data": ["block", "action", "cache", "content", "memory", "def", "ata", "debug", "mu", "dat", "table", "query", "message", "advert", "cheat", "out", "key", "mem", "relation", "snap", "new", "extra", "done", "reg", "bus", "json", " DATA", "dq", "device", "obj", "group", "zero", "rec", "DATA", "empty", "db", "results", "dev", "name", "p", "to", "window", "all", "result", "map", "size", "buffer", "error", "feat", "buf", "next", "image", "batch", "type", "config", "ref", "video", "fee", "info", "res", "bytes", "rel", "r", "list", "value", "d", "rew", "n", "Data", "missing", "output", "di", "format", "bin", "news"]}}
{"project": "FFmpeg", "commit_id": "919d13d2383bd7318b80ed0c5b723323a79a8996", "target": 0, "func": "static int cookie_string(AVDictionary *dict, char **cookies)\n\n{\n\n    AVDictionaryEntry *e = NULL;\n\n    int len = 1;\n\n\n\n    // determine how much memory is needed for the cookies string\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n\n\n    // reallocate the cookies\n\n    e = NULL;\n\n    if (*cookies) av_free(*cookies);\n\n    *cookies = av_malloc(len);\n\n    if (!cookies) return AVERROR(ENOMEM);\n\n    *cookies[0] = '\\0';\n\n\n\n    // write out the cookies\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n\n\n    return 0;\n\n}\n", "idx": 19411, "substitutes": {"dict": ["get", "pkg", "hd", "update", "map", "h", "nd", "wd", "ad", "def", "fr", "del", "doc", "obj", "dat", "session", "da", "arr", "dir", "vol", "rect", "list", "d", "conf", "upper", "und", "dd", "state", "md", "cmd", "db", "str", "data", "compl", "ds", "ict", "adv", "dr", "base", "inf", "hash", "ld", "cond", "red"], "cookies": [" cooks", "cooks", "celliers", "innbooks", "cmds", "warnys", "cookials", "payied", "innys", "cooky", "Cookries", "Cookies", "goodies", "curys", "Cooky", "goodied", "coinssters", "CookIES", "replied", "goodys", "replys", "cookries", "replIES", "copys", "readys", "Cookells", "cookbooks", "cellries", "cookied", "warnies", "bufiers", "innials", "Cookys", "capys", "innies", "copbooks", "readsters", "Cookiers", "cookIES", "Cookials", "cookiers", "cellys", "capy", "cmdys", "copials", "bufys", "cooksters", "cmdies", "Cookied", " cookells", "cellies", "payies", "bufies", "curied", "warnied", "capIES", "coinsied", "cmdells", "cookells", "cookys", "copy", "readies", "curs", "readied", "Cooks", "payys", "replies", "capies", "Cookbooks", "goodsters", "bufries", "curies", "warnIES", "copIES", "coinsies", "coinsys", " cookys", "copies", "pays"], "e": ["ele", "ere", "ep", "ne", "g", "end", "er", "en", "fe", "eps", "entity", "peer", "c", "oe", "err", "ef", "ge", "ed", "le", "i", "or", "self", "te", "eh", "he", "ze", "ue", "eeee", "elt", "event", "ee", "re", "je", "ffe", "note", "me", "eur", "eu", "el", "d", "EEE", "eb", "se", "eg", "xe", "o", "ev", "be", "see", "n", "ei", "element", "one", "ce", "et", "ek", "de", "ec", "ent", "ie", "pe", "ger", "we", "E", "ea", "ae", "ine", "es"]}}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "static int get_physical_address (CPUMIPSState *env, hwaddr *physical,\n\n                                int *prot, target_ulong real_address,\n\n                                int rw, int access_type)\n\n{\n\n    /* User mode can only access useg/xuseg */\n\n    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;\n\n    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;\n\n    int kernel_mode = !user_mode && !supervisor_mode;\n\n#if defined(TARGET_MIPS64)\n\n    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n#endif\n\n    int ret = TLBRET_MATCH;\n\n    /* effective address (modified for KVM T&E kernel segments) */\n\n    target_ulong address = real_address;\n\n\n\n#define USEG_LIMIT      0x7FFFFFFFUL\n\n#define KSEG0_BASE      0x80000000UL\n\n#define KSEG1_BASE      0xA0000000UL\n\n#define KSEG2_BASE      0xC0000000UL\n\n#define KSEG3_BASE      0xE0000000UL\n\n\n\n#define KVM_KSEG0_BASE  0x40000000UL\n\n#define KVM_KSEG2_BASE  0x60000000UL\n\n\n\n    if (kvm_enabled()) {\n\n        /* KVM T&E adds guest kernel segments in useg */\n\n        if (real_address >= KVM_KSEG0_BASE) {\n\n            if (real_address < KVM_KSEG2_BASE) {\n\n                /* kseg0 */\n\n                address += KSEG0_BASE - KVM_KSEG0_BASE;\n\n            } else if (real_address <= USEG_LIMIT) {\n\n                /* kseg2/3 */\n\n                address += KSEG2_BASE - KVM_KSEG2_BASE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (address <= USEG_LIMIT) {\n\n        /* useg */\n\n        if (env->CP0_Status & (1 << CP0St_ERL)) {\n\n            *physical = address & 0xFFFFFFFF;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        }\n\n#if defined(TARGET_MIPS64)\n\n    } else if (address < 0x4000000000000000ULL) {\n\n        /* xuseg */\n\n        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0x8000000000000000ULL) {\n\n        /* xsseg */\n\n        if ((supervisor_mode || kernel_mode) &&\n\n            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xC000000000000000ULL) {\n\n        /* xkphys */\n\n        if (kernel_mode && KX &&\n\n            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 19431, "substitutes": {"env": ["org", "cv", "estate", "er", "init", "h", "setup", "forge", "gear", "vs", "e", "v", "ctx", "req", "uv", "Environment", "equ", "entry", "sw", "ef", "eh", "rb", "net", "obj", "ev", "code", "state", "context", "cmd", "environment", "nv", "msg", "inv", "dev", "esc", "conf", "vp", "window", " environment", "disk", "ext", "end", "en", "conn", "nav", "err", "te", "manager", "enter", "engine", "ah", "buf", "here", "era", "desc", "vt", "ptr", "esm", "attr", "config", "shell", "sv", "worker", "network", "vm", "param", "ew", "et", "ec", "erd", "eng", "outer", "t", "response"], "physical": ["resource", "hard", "binary", "location", "absolute", "route", "native", "virtual", "protected", "memory", "pointer", "relative", "pixel", "attribute", "ip", "exclusive", "target", "address", "localhost", "checked", "reference", "network", "local", "basic", "primary", "maximum", "prefix", "phys", "external", "operation", "base", "image", "Physical", "variable", "vp"], "prot": ["prop", "type", "opt", "what", "virtual", "protected", "ret", "eth", "port", "def", "version", "pos", "net", "Prot", "pc", "tf", "ping", "ocol", "lag", "reset", "rot", "policy", "prefix", "protect", "chron", "phys", "status", "format", "pro", "flags", "tif", "typ", "stat", "at", "addr", "ptr", "platform", "pat"], "real_address": ["absolutetextmemory", "regular_memory", "real_length", "realtextaddress", "real_Address", "realmlelement", "absolutetextaddress", "signed_relative", "absolute_address", "signedmmelement", "real1address", "realityaddress", "real_memory", "realpreroute", "absolute_memory", "real_element", "absolute_route", "realationpointer", "realmmport", "realationaddress", "realpreaddress", "realetaddress", "signed_address", "regular_length", "real_addr", "realmlport", "realetport", "regular_address", "absolutetextroute", "realmmrelative", "realetrelative", "realitymemory", "signedmmport", "absolutetextelement", "real_route", "signedmmrelative", "regular1address", "realityroute", "real1memory", "realmmelement", "signed_element", "absolute_element", "realityelement", "realmmaddress", "real__address", "regular1memory", "signed_port", "physical_Address", "realtextmemory", "realprememory", "realetelement", "physical_address", "real__Address", "real_port", "physical_addr", "real_relative", "real_pointer", "regular1pointer", " real_attribute", "realtextelement", "real__addr", "realmlrelative", "realtextroute", "realationmemory", " real_location", "signedmmaddress", "realpreelement", "real_attribute", "real_location", "regular_pointer", "real1pointer", "realationlength", "realmladdress", "regular1length", "real1length"], "rw": ["rt", "rib", "rf", "ref", "route", "channel", "rar", "wm", "term", "eth", "pointer", "asm", "password", "res", "net", "exclusive", "r", "rew", "writer", "aw", "weight", "write", "req", "w", "word", "pack", "ptr", "dc", "wr"], "access_type": [" access_types", "access_key", " access_key", "accessoryinfo", "accessorykey", "access_info", "accessorytypes", "accessorytype", "access_types", " access_info"]}}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434, "substitutes": {"spapr": ["sparpl", "shampR", "spraprus", "espampcr", "spaptrt", "spapl", "spumprt", "spaml", "spppar", "sptapcr", "spapres", "spappw", " spiprr", "spapw", "spappz", "spapbr", "spaprr", "shopappr", "spcapr", "sptapres", "ispapw", "spampm", "capaptpr", "ispapbr", "spappbr", "spampfr", "ispappw", "spaprus", " spipr", "sparmrt", "spumppr", "espapm", "ispapr", "spaptpr", "spapppr", "sparpfr", "spipar", "shophapr", "spampR", "shapR", "sparpr", "sparmrer", "spiprr", "spraprr", "spappu", "spapper", "capapr", "sprapu", "spapz", "capappr", "shophapz", "capaprt", "shopapz", "shampfr", "ispaper", "spaper", "spaprer", "spipw", "sppprus", "sptapm", "espapcr", "shapfr", "spcapres", "shapl", "shapr", "capaptrer", "shopapr", "spapter", "ispappr", "espampr", "espampm", " spiprus", "sparmpr", "spapar", "capaprer", "spaptw", "spampcr", "spampl", "spappr", "sprappr", " spipar", "sphappr", "spapcr", "espampres", "spapm", "shophapu", "spumpr", "capaptrt", "sphapr", "capaptr", "shampl", "spiper", "ispapper", "spampr", "spiprus", "spamr", "sprapr", "espapr", "spapR", " spaprus", "spaptrer", "sphapu", "spcapm", "sprapz", "spampres", "spaprt", "spipr", "sppprr", "sphapz", "spppr", "sprapar", "spaptbr", "spcapcr", "spapfr", "spamR", "spumprer", " spaprr", "ispappbr", "espapres", "spaptr", " spapar", "sptapr", "sparpR", "spamfr", "shampr", "spapu", "sparmr", "shopapu", "shophappr", "spipbr"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n", "idx": 19441, "substitutes": {"v": ["f", "cv", "g", "sv", "vr", "c", "h", "i", "q", "conv", "vy", "vs", "V", "u", "vu", "r", "e", "l", "m", "qv", "vi", "vm", "b", "k", "ev", "vim", "vp", "gov", "vc", "uv", "w", "vt", "verb", "av", "j", "p"], "name": ["text", "type", "alias", "nm", "create", "nam", "a", "c", "lat", "err", "title", "search", "valid", "san", "term", "unknown", "def", "names", "cap", "error", "null", "false", "item", "r", "named", "none", "path", "id", "ma", "local", "n", "code", "missing", "key", "str", "NAME", "Name", "prefix", "data", "nan", "filename", "common", "no", "format", "w", "word", "start", "t", "ame", "p"], "list": ["block", "cache", "use", "LIST", "ul", "table", "drop", "out", "print", "old", "status", "word", "limit", "dict", "layout", "show", "st", "cont", "null", "isl", "index", "comment", "empty", "source", "all", "array", "chain", "result", "map", "parent", "li", "load", "set", "match", "none", "l", "level", "record", "member", "count", "file", "seq", "listed", "view", "batch", "type", "lists", "copy", "lock", "not", "info", "bool", "form", "sequence", "any", "List", "id", "local", "str", "format", "only", "queue", "tree", "t", "collection", "ist"], "size": ["length", "type", "sum", "g", "sn", "add", "args", "use", "shape", "ui", "SIZE", "scale", "len", "ize", " sizes", "set", "max", "ci", "small", "m", "zero", "index", "id", "sp", "num", "n", "code", "space", "Size", " length", "empty", "data", "count", "capacity", "equal", "number", "izes", "dimension", "iz", "z", "si"], "errp": [" errm", " errping", "errping", "rrp", "errorr", "rrping", "ferpa", "erm", "errm", " errP", "err", " errpa", "errorm", "errorp", "errpa", "cerp", "ferping", "cerpre", "rrpre", "ferp", " errpre", "erP", "ferP", "cerP", "errorP", "errP", "errpre", "rrP", "erp", "rrpa", "errr", " errr"], "qiv": ["qij", "qqiev", "qivable", "qiver", "acquive", "quiver", "acquivable", "qqij", "qive", "acquiv", "requiver", "quiov", " qiov", " qiev", "quivable", "qiev", "acquiver", " qij", "requiv", "qqiv", "qqiver", " qivable", "quiv", "qiov", " qiver", "requivable", "quiev", "quive", "quij", " qive", "requiov"], "qobj": ["dqjs", "quso", "dqso", "qjs", "qob", "qObj", "qobject", "queryObj", " qObj", "iqObj", "qujs", " qobject", " qob", "iqobj", "quobject", "queryob", "dqobj", "quObj", "dqrect", "iqso", " qjs", " qrect", "dqobject", "qso", "quobj", "quob", "queryjs", "qrect", "qurect", "dqObj", "queryobj"], "entry": ["cell", "result", "channel", "expected", "existent", "info", "search", "or", "q", "server", "obj", "line", "way", "ary", "exclusive", "set", "match", "ist", "r", "form", "e", "check", "insert", "RY", "found", "import", "index", "sp", "row", "record", "se", "see", "comment", "key", "print", "instance", "element", "member", "data", "link", "equal", "ent", "it", "nt", "try", "needed", "ace", "created", "Entry", "add", "ry"]}}
{"project": "qemu", "commit_id": "0a982b1bf3953dc8640c4d6e619fb1132ebbebc3", "target": 0, "func": "static void test_qga_file_write_read(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    const unsigned char helloworld[] = \"Hello World!\\n\";\n\n    const char *b64;\n\n    gchar *cmd, *enc;\n\n    QDict *ret, *val;\n\n    int64_t id, eof;\n\n    gsize count;\n\n\n\n    /* open */\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-file-open',\"\n\n                 \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    id = qdict_get_int(ret, \"return\");\n\n    QDECREF(ret);\n\n\n\n    enc = g_base64_encode(helloworld, sizeof(helloworld));\n\n    /* write */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-write',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \",\"\n\n                          \" 'buf-b64': '%s' } }\", id, enc);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert_cmpint(eof, ==, 0);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read (check implicit flush) */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n", "idx": 19469, "substitutes": {"fix": ["fd", "f", "bridge", "to", "cell", " patch", "ifix", "init", "fixes", "pre", "test", " Fix", "fc", "valid", "FIX", "def", "diff", "fx", "patch", "feat", "set", "check", "call", "force", " prefix", "prefix", "ix", "Fix", "feature", "file", "cod", "format", "mix", "fab", "conf", "field", "edit"], "fixture": ["tlict", "pixture", "fiber", "ciddler", "confancy", "Familiar", " familiar", "miber", " fiber", "piber", "futation", "pixtures", "bactory", "pactory", "mixtures", "fancy", "tixture", "flict", " factory", "liddler", "mixture", "cutation", "lutation", "flamiliar", "factory", " fixtures", "cluent", "flutation", "mactory", "cixture", "flixtures", "confixture", "lixture", "fluent", "bixture", "fixtures", "Fixture", "confactory", "fiddler", "tactory", "flluent", "bancy", "lluent", "blict", "flixture", "fliddler", "conflict", "Fixtures", "tancy", "familiar"], "helloworld": ["hellowild", "helleworld", "hellOWild", "hellowww", "helloyww", "hellaworld", "llowww", "hallaworld", "lloyww", "hellowshield", "lloyworld", "llowsworld", "hellawily", "helloweorld", "helloywell", "hellawww", "helloweily", "helloyshield", "llowhell", "hellowsww", "hellowsworld", "millowild", "helloweww", "hellewild", "hallowesome", "hellaphorld", "hellowworld", "hallawww", "helloyorld", "hellowewell", "hellowsild", "llowild", "hellOWhell", "llowsild", "hellaphworld", "millowsily", "hellaphshield", "hellowshell", "millowily", "hellOWworld", "llowworld", "hellowsorld", "lloworld", "hellewworld", "milloworld", "lloyorld", "hellowswell", "hallowww", "millowswell", "hallawesome", "hallowily", "helloyild", "helloyily", "hellowesome", "helloyworld", "hellaphww", "hellOWorld", "helloweesome", "helloweshield", "hellawesome", "llowshell", "llowsorld", "helloweild", "hellowsesome", "millowsorld", "hellowhell", "lloyshield", "hellowily", "hellowwell", "millowsild", "helloweworld", "halloworld", "millowwell", "hellewhell", "hallawily", "hellowsily", "llowshield"], "b64": ["sb16", "base32", "b256", "bg16", "base128", "b8", "bguffy", "b128", "bg64", " b128", "base16", "base64", " b32", "sbuffy", "b32", "bg8", "sb64", "sb8", "base256", "baseuffy", " b256", "base8", "B128", "B32", "b16", "B256", "B64", "buffy"], "cmd": ["prop", "init", "args", "cat", "wd", "tab", "def", "kt", "kind", "grow", "ctx", "send", "mk", "md", "req", "mem", "auth", "command", "dc", "act", "MD", "std", "dt", "cp", "cb", "norm", "path", "code", "cod", "msg", "fun", "nt", "mt", "cfg", "job", "opt", "bind", "ext", "conn", "pkg", "ind", "err", "pipe", "term", "del", "phy", "dir", "help", "resp", "buf", "pt", "ct", "col", "quit", "try", "cond", "cd", "batch", "crit", "rt", "awk", "ref", "ctr", "method", "rc", "Cmd", "urg", "rev", "call", "om", "data", "exec", "op", "addr"], "enc": ["ENC", "attr", "ext", "conn", "en", "pkg", "inc", "c", "err", "fc", "rc", "Enc", "ot", "ic", "conv", "len", "iv", "cb", "buf", "ac", "nc", "con", "sys", "el", "cc", "kw", "ct", "code", "bn", "ew", "str", "et", "vc", "col", "ec", "lang", "cod", "encrypted", "auth", "msg", "ent", "format", "buff", "nt", "ch", "dc"], "ret": ["cat", "def", "kt", "dat", "det", "RET", "ctx", "bed", "out", "grad", "req", "mem", "deg", "rm", "dict", "reg", "gt", "gd", "iter", "lt", "std", "lit", "cont", "dt", "net", "re", "eval", "el", "prot", "back", "ft", "db", "nt", "mt", "ld", "ry", "result", "ert", "fresh", "del", "elt", "ll", "resp", "buf", "pt", "vet", "uf", "cert", "git", "rets", "dr", "vt", "aux", "try", "pret", "repl", "rt", "ref", "jp", "tr", "res", "att", "rel", "got", "rev", "Ret", "rect", "ts", "sys", "gz", "backed", "reset", "et", "alt", "it", "addr", "t"], "val": ["fol", "vec", "def", "al", "dat", "vol", "pol", "v", "var", "grad", "mem", "old", "vo", "sel", "als", "act", "reg", "tx", "test", "Val", "lit", "VAL", "pr", "serv", "pos", "obj", "eval", "el", "gb", "vals", "nt", "dev", "sil", "p", "all", "pal", "valid", "rol", "cal", "elt", "loc", "pl", "arg", "resp", "buf", "pt", "ve", "x", "col", "cur", "vt", "pret", "cond", "ele", "cho", "res", "bil", "att", "item", "rel", "arr", "value", "b", "data", "alt", "bal", "lib", "aval", "it", "base", "stat", "il", "t"], "id": ["rid", "f", " offset", "fd", "type", "ID", "end", "ref", "en", "ind", "h", "iter", "err", " rid", "ad", "q", "aid", "len", " fid", "Id", "ids", "pid", "d", "index", "uid", "bid", "hid", "ctx", "mid", "vid", "code", "kid", "key", " tid", "md", "ix", "sid", "et", "str", "ent", "it", " pid", "base", "oid", "addr", "wid", "tag", "iq", "ident", "start", "hash", "name"], "eof": ["seof", "ceown", "seow", "Eof", "weOf", "weown", "peow", "EOf", "eov", "peoh", "eok", "peOf", "ueof", "eoff", "ceov", "ueov", "eeov", "teow", "ueok", "eeoh", " eOf", "Eov", " eoff", "eeof", "teov", "eOf", " eok", "ceOf", "eeOf", "seoh", "Eow", "weov", "seOf", "eown", "weof", "eeown", "ueOf", "eoh", "eeow", "teof", " eow", "peof", "eeoff", "eow", "ceof", "teoff", " eov", "Eok"], "count": [" cur", "nb", "act", "length", "sum", " total", "all", "cache", "counter", "ctr", "add", "ind", "part", "c", "test", "ount", "err", "depth", " counts", "size", "cloud", " name", "child", "cont", "len", "amount", "flag", "found", "Count", " key", "list", "pt", "num", "index", "call", "cd", " err", "ct", "n", " c", "code", "total", "missing", "key", "first", "full", "data", " num", "coll", "col", "no", "nt", "find", " code", "stat", "t", "conf", "cond", "z", "name"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n", "idx": 19473, "substitutes": {"data": ["done", "text", "window", "block", "array", "map", "iter", "size", "values", "buffer", "ata", "device", "bytes", "read", "mu", "dat", "reader", "session", "da", "table", "list", "zero", "d", "accept", "DATA", "out", "Data", "state", "next", "mem", "output", "di", "bin", "image", "input", "batch"], "unused": ["unus", " unusing", " unspecified", "unusable", "unaused", "unause", "nused", "uspecified", "unausable", "unspecified", "nuse", " unusable", "uusable", " unuse", "uused", "unusing", "unaspecified", "unuse", "nonus", "uuse", "nusing", "nonuse", "nus", "nonusing", "nonused", " unus"]}}
{"project": "qemu", "commit_id": "01cd90b641e1aed40cf13a577e6a737af94d55e7", "target": 0, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n", "idx": 19490, "substitutes": {"xendev": ["yendeddev", "xtendoc", "xenterv", "xestev", "xendsec", "xendeddev", "yendedev", "xendedev", "xtentata", "xendedec", " xendee", "xndame", "xENDov", "xendoc", " xndee", "xendedDEV", "exendec", "xendeg", "xnddev", "xtentoc", "xENDev", "xenteg", "xtenteg", "exendedev", "xendsoc", "xendsev", "xendeiv", "xendingoc", "xendingev", "wxendfo", "xENDoc", "xenderoc", "xendeec", "xtentdev", "xengower", "yenddev", " xendiv", "xestDEV", " xndev", "xendower", "xtendev", "xendedov", "xendame", " xndame", "xenderiv", "xentata", "xENData", "xENDeg", "lexendoc", "xENDDEV", "wxendDev", "lexendedev", "xENDfo", "xenderee", "xengee", "xtenddev", "xendedoc", "xendDev", "xenderec", "xendeov", "xtendeg", "lexendec", "xendedDev", "xbeginev", "exendedov", "xendeower", "xendingriver", "xendeown", "xendedfo", "xtentev", "lexendev", "xendata", "wxendDEV", "xendec", "xndev", "xENDdev", " xnddev", "xentown", "xentriver", "yendedeg", "xendedown", "xentoc", "yendederv", "wxendedDEV", "exendev", "xenddev", " xendeev", "xendDEV", "wxendedDev", "xentev", "exendown", "xentdev", "xendfo", " xendeower", "exendov", "xtendown", " xendeee", "wxendev", " xendower", "xenderev", "xtentriver", "xendown", "xenderv", "xenderower", "xendeee", "xENDriver", "xengev", "xendov", "xtendata", "lexendedec", "xendiv", "exendedown", "xendriver", "xestfo", " xenddev", "xndee", "xENDown", "xENDerv", "xentee", "xENDDev", "xtentown", "wxendedfo", "xestDev", "xendeev", "xendee", "yendev", "xendingata", " xendeiv", "yendeg", "xendedame", "xendedeg", "xengiv", "xbegineg", "lexendedoc", " xendame", "xendedee", "xendederv", "exendedec", "xtendriver", "xbeginown", "xbegindev", "xENDec", "xentame", "wxendedev", "yenderv"], "i": ["is", "iri", "init", "c", "h", "ip", "y", "ami", " ii", "ims", "qi", "series", "v", "I", "ii", "phi", " ti", " j", " multi", "hi", "t", "f", "ui", "\u0438", "pi", "im", "index", " pi", " l", "mi", "multi", "p", "to", " I", " li", "gi", "ind", "ri", "xi", "err", "cli", "ai", "li", "conv", "io", "go", "iu", " bi", "ci", "l", "sim", "m", "me", "ti", "x", " m", "uri", " si", "ij", "si", "batch", " n", "bi", " mi", "info", " v", "ic", "in", "r", "zi", " k", "list", "asi", "ji", "id", "n", "ei", "fi", "ix", "di", " ni", "it", "ini", "j", "oi"], "xen_9pdev": ["xen_970ipserv", "xen_99ipdevelop", "xen_21phpdevice", "xen_9edev", "xen_13pdadv", "xen_09pdef", "xen_8pcdevice", "xen_93pth", "xen_9preds", "xen_96psver", "xen_9rdev", "xen_9Pserv", "xen_999piddev", "xen_9phppro", "xen_9pscast", "xen_21phppro", "xen_09tpdev", "xen_12pserv", "xen_9ppsd", "xen_99pdev", "xen_99pDEV", "xen_1tdev", "xen_9wpde", "xen_9lpdebug", "xen_12pdev", "xen_99pdevelop", "xen_9tdev", "xen_ninenver", "xen_9gver", "xen_9lpDev", "xen_9pbdem", "xen_9pcache", "xen_96pfam", "xen_9dev", "xen_9ipdem", "xen_9apdev", "xen_9cdev", "xen_9pve", "xen_9rde", "xen_996pdevices", "xen_9tpver", "xen_970wDev", "xen_09pver", "xen_21pdevice", "xen_21pev", "xen_8tdd", "xen_ninendev", "xen_9powerdev", "xen_9ddevelop", "xen_9ipDEV", "xen_ninetreq", "xen_ninengo", "xen_09tpdef", "xen_9pserv", "xen_96pdev", "xen_ninepreq", "xen_9perdef", "xen_970pDev", "xen_09pschool", "xen_9Pev", "xen_9wpcast", "xen_9pcdevelop", "xen_9erreq", "xen_9rDev", "xen_99ipserv", "xen_9pdDev", "xen_9pDev", "xen_9pcserv", "xen_ninepdev", "xen_9gdebug", "xen_9tver", "xen_ninenserv", "xen_93pval", "xen_9pde", "xen_96psfam", "xen_999piddeal", "xen_09tpver", "xen_96pcast", "xen_970wver", "xen_9ipdes", "xen_9ipfam", "xen_13pDev", "xen_9ppdef", "xen_8tserver", "xen_9pver", "xen_9pbserver", "xen_9pcDEV", "xen_9fdev", "xen_12pden", "xen_9pdes", "xen_96psdev", "xen_9tpdev", "xen_9lpdev", "xen_9pcev", "xen_8pdem", "xen_tenerdev", "xen_9tsd", "xen_9tpth", "xen_9wdev", "xen_8pserver", "xen_8pve", "xen_9perdev", "xen_9pgu", "xen_9fver", "xen_9pith", "xen_9phpdd", "xen_9ipev", "xen_ninepgo", "xen_970pver", "xen_9nserv", "xen_9Pfam", "xen_9wpver", "xen_9fsd", "xen_9ppev", "xen_9wdes", "xen_8pdd", "xen_9ppcast", "xen_9cserv", "xen_13pdconn", "xen_09tpschool", "xen_999pdev", "xen_9erdebug", "xen_970pdev", "xen_9pival", "xen_8pcev", "xen_9Pdevice", "xen_9preq", "xen_9piddevelop", "xen_9psfam", "xen_12preden", "xen_9pcast", "xen_ninepgu", "xen_8pev", "xen_9cev", "xen_9nev", "xen_9tpdef", "xen_1pev", "xen_99ipDEV", "xen_9piddd", "xen_9tev", "xen_9picache", "xen_ninepev", "xen_9gDEV", "xen_9pbev", "xen_9ipve", "xen_tenerver", "xen_9wpserv", "xen_99ipdev", "xen_9pdconn", "xen_9tve", "xen_9pev", "xen_9rver", "xen_9pdevice", "xen_9tdd", "xen_9padv", "xen_9ppro", "xen_9preserv", "xen_9tserver", "xen_ninepdef", "xen_9pcdev", "xen_8pDev", "xen_13pdDev", "xen_9ipdev", "xen_9ppreq", "xen_13pddev", "xen_9piddevice", "xen_93pival", "xen_9nver", "xen_9ppschool", "xen_9psdev", "xen_9pbdd", "xen_9ndef", "xen_1tver", "xen_8pdevice", "xen_9lpdd", "xen_9ergu", "xen_9powerserv", "xen_13padv", "xen_9ppdev", "xen_12preds", "xen_21ppro", "xen_999pdd", "xen_96pscast", "xen_9ppdevice", "xen_9pdadv", "xen_99pserv", "xen_9piddev", "xen_tenerdebug", "xen_tenerDEV", "xen_9ppver", "xen_9pserver", "xen_9ddes", "xen_9wDev", "xen_9pval", "xen_9apdevices", "xen_9treq", "xen_9pbve", "xen_9tdevice", "xen_8pcdevelop", "xen_9pdeal", "xen_9ppdevices", "xen_9lpdeal", "xen_9lpDEV", "xen_21pdev", "xen_9pergo", "xen_ninepver", "xen_9Pdev", "xen_9powerds", "xen_9edeal", "xen_9tpro", "xen_9wpdef", "xen_8tdev", "xen_93pdev", "xen_9psd", "xen_9preden", "xen_970pfam", "xen_tenpdebug", "xen_9pcver", "xen_9tpschool", "xen_8tdem", "xen_9ipDev", "xen_9pth", "xen_9pschool", "xen_9pdd", "xen_8tev", "xen_9pdebug", "xen_13pdev", "xen_9ppfam", "xen_9perver", "xen_12preserv", "xen_9pconn", "xen_970ipfam", "xen_tenpver", "xen_9powerden", "xen_9lpserv", "xen_9tpcache", "xen_9pfam", "xen_ninendef", "xen_9ppgu", "xen_9dver", "xen_9ipdevelop", "xen_996apdevices", "xen_9ipver", "xen_9erDEV", "xen_970wdev", "xen_1pdev", "xen_8pver", "xen_9ndev", "xen_9piddeal", "xen_9ddevice", "xen_9fev", "xen_ninepserv", "xen_8pdev", "xen_9lpver", "xen_9wpfam", "xen_9pdem", "xen_9dconn", "xen_9tpval", "xen_ninetdev", "xen_9wpgo", "xen_9cver", "xen_1pver", "xen_8pde", "xen_9wver", "xen_9lpadv", "xen_9lpdevelop", "xen_9pddev", "xen_9ngo", "xen_9nschool", "xen_9dDev", "xen_12predev", "xen_9pcds", "xen_13pconn", "xen_9pden", "xen_970pserv", "xen_9predev", "xen_9apver", "xen_9cdevices", "xen_9persth", "xen_9erver", "xen_9ipserv", "xen_9persval", "xen_ninetdevice", "xen_12pds", "xen_9phpserver", "xen_96pver", "xen_9erdev", "xen_tenpDEV", "xen_9pgo", "xen_1tsd", "xen_93pidev", "xen_21phpev", "xen_9pbdev", "xen_996pdev", "xen_9pidev", "xen_9edd", "xen_9Ppro", "xen_9pcden", "xen_9psver", "xen_21phpdev", "xen_ninenev", "xen_9phpev", "xen_9ddev", "xen_999piddd", "xen_1tev", "xen_9lpconn", "xen_ninepdevice", "xen_tenpdev", "xen_9tgu", "xen_9erdevice", "xen_93picache", "xen_9dadv", "xen_09pdev", "xen_9wpDev", "xen_9phpdevice", "xen_9pcdevice", "xen_970ipdev", "xen_9persdev", "xen_8tve", "xen_9pdevelop", "xen_9gdev", "xen_8pcdev", "xen_996apdev", "xen_996apver", "xen_1psd", "xen_996pver", "xen_970pdes", "xen_9pdevices", "xen_9pds", "xen_8pdevelop", "xen_999pdeal", "xen_9wpdev", "xen_9pDEV", "xen_ninetgu", "xen_9perscache", "xen_970wdes", "xen_93pith", "xen_93pcache", "xen_9phpdev", "xen_9tdem", "xen_9pdef"], "s": ["g", "rs", "sv", "c", "h", "ss", "e", "r", "d", "m", "b", "v", "n", "o", "sb", "stats", "ds", "w", "S", "gs", "ps", "t", "fs", "j", "p"], "fsdev": [" fsDEV", "FSDEV", "FSdevice", "fsDEV", " fsdevice", "fsDev", "FSDev", "csDev", "fsdevice", "csDEV", "csdev", "csdevice", " fsDev", "FSdev"], "str": ["er", "init", "c", "def", "fr", "shr", "inst", "vol", "v", "out", "key", "print", "new", "f", "cr", "br", "st", "sw", "iter", "inner", "pr", "cont", "expr", "w", "msg", "cs", "usr", "name", "p", "sl", "sts", "g", "rs", "chain", "err", "buffer", "comp", "enc", "buf", "sp", "txt", "STR", "ocr", "prefix", "x", "cur", "seq", "dr", "raw", "ctr", "sc", "tr", "res", "doc", "r", "arr", "b", "Str", "data", "exec", "it", "t", "j"], "ring_order": ["ray_order", "ray_ord", "ring_ord", "ring_index", "ray_record", "ring_record", "ray_index"]}}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n", "idx": 19492, "substitutes": {"s": ["is", "sts", "g", "rs", "a", "c", "h", "ops", "sq", "js", "i", "self", "q", "os", "ss", "sc", "y", "ns", "obj", "spec", "set", "r", "m", "d", "ts", "sys", "its", "es", "b", "v", "ctx", "n", "o", "sb", "state", "context", "x", "stats", "ds", "ses", "w", "S", "gs", "source", "cs", "ps", "t", "conf", "hs", "p"], "op": ["opt", "ost", "ok", "attr", "ext", "bit", "ox", "cop", "hop", "jp", "update", "ops", "oe", "copy", "oper", "mp", "or", "ot", "cp", "comp", "ip", "pp", "obj", "loc", "pl", "OP", "arg", "ist", "set", "expr", "ac", "opp", "wp", "ack", "sp", "o", "Op", "operator", "oc", "oop", "cmd", "pop", "up", "oss", "omp", "it", "operation", "ob", "og", "ps", "cmp", "co", "p"], "args": ["us", "rs", "ins", "eps", "aws", "as", "ics", "ops", " arguments", "aps", "js", "ads", "values", "params", "orders", "vs", "ns", "ims", "Args", "related", "arms", "ags", "arg", "arr", "ms", "ents", "ids", "actions", "ts", "options", "issues", "members", "parts", "pres", "ams", "atts", "ds", "qs", "mus", "vals", "uns", "ars", "aus", "flags", "posts", "gs", "aux", "results", "cs", "ps", "items", "bs", "fs", "terms", "p"], "dst": ["Dest", "jpt", "dust", "delst", "kz", "dsv", "disest", "dusts", "dot", "pnd", "dadest", "Ddest", "dsest", "dv", " dv", "Dnd", " dnd", " dendest", "dsbr", "dssts", "adST", " dpt", "adst", " dpr", "jdest", "hdest", "fmt", "Dmt", "dsend", "kpr", "didst", " denst", "jend", "pdest", "pst", "kbr", "jmt", "jlt", "Dot", "snd", "disst", "adot", " dport", "hbr", "Dend", "hpt", "Dct", "DST", "sdest", "delport", "dpr", "Dst", "dST", "dsnd", "dend", "jz", " dr", " dno", "dport", "jbr", "dz", "dast", " dend", "sdst", "sest", " ddest", " dmt", " dz", " denST", "fport", "dbr", " dest", "fdest", "sdmt", " dot", "dsts", " dsts", "dr", "deldest", "adr", "dnd", "pno", "duend", "dlt", "sdST", "dalt", "dspt", "dsst", "didno", "dsct", "dmt", "dudest", " dST", "sst", "jpr", "Dv", "dsdest", "kst", " dbr", "hst", "Dr", "fst", "disST", "daend", "dest", "dsmt", " dlt", "dno", "jst", "disend", "ddest", "dpt", " dennd", "didnd", "sct", "dct", "delmt", "dsST", "diddest"], "src": ["sn", "init", "syn", "inst", "scan", "ctx", "other", "stats", "RC", "supp", "snap", "proc", "from", "st", "sec", "std", "rob", "rb", "null", "sub", "spec", "target", "sr", "hl", "cmd", "phys", "source", "usr", "tmp", "ser", "th", "rs", "sq", "origin", "rl", "self", "comp", "conv", "iv", "loc", "set", "sp", "txt", "sb", "bc", "desc", "cur", "ptr", "via", "bs", "rt", "nil", "attr", "sv", "ctr", "ins", "vr", "rc", "sc", "obs", "r", "sync", "sys", "sing", "dest", "cc", "str", "vc", "addr", "isc"], "mask": ["block", "box", "cache", " mark", "shift", "allow", "ask", "shape", " stamp", " masks", "sk", "cover", "scan", "key", " scale", "weight", "status", "mac", "flags", "mb", "cmp", "hash", "bit", "offset", "bits", "mount", "mas", "temp", "clear", " Mask", "target", "ms", " masked", "zero", "ma", "index", "code", "comment", "fix", "tag", "mt", "mod", " flags", "window", "qa", "result", "map", "cm", "sign", "set", "match", "flag", " error", "m", "Mask", "count", "batch", " offset", "type", "config", "filter", "lock", "scale", " mu", "gc", "miss", " flag", "id", "hold", "write", "mark", "perm", "hide", "pack", "share", "z"]}}
{"project": "FFmpeg", "commit_id": "3594554a064d76e3514fab9781c0e63ea9e08ea9", "target": 0, "func": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n  /* VIS-specific optimizations */\n\n  int accel = vis_level ();\n\n  const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n  if (accel & ACCEL_SPARC_VIS) {\n\n      if (avctx->bits_per_raw_sample <= 8 &&\n\n          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {\n\n          c->idct_put = ff_simple_idct_put_vis;\n\n          c->idct_add = ff_simple_idct_add_vis;\n\n          c->idct     = ff_simple_idct_vis;\n\n          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n      }\n\n\n\n      if (!high_bit_depth) {\n\n      c->put_pixels_tab[0][0] = MC_put_o_16_vis;\n\n      c->put_pixels_tab[0][1] = MC_put_x_16_vis;\n\n      c->put_pixels_tab[0][2] = MC_put_y_16_vis;\n\n      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;\n\n\n\n      c->put_pixels_tab[1][0] = MC_put_o_8_vis;\n\n      c->put_pixels_tab[1][1] = MC_put_x_8_vis;\n\n      c->put_pixels_tab[1][2] = MC_put_y_8_vis;\n\n      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;\n\n\n\n      c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;\n\n      c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;\n\n      c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;\n\n      c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;\n\n\n\n      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;\n\n      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;\n\n      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;\n\n      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;\n\n\n\n      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;\n\n      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;\n\n      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;\n\n      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;\n\n      }\n\n  }\n\n}\n", "idx": 19494, "substitutes": {"c": ["cf", "lc", "cv", "cr", "config", "all", "g", "cache", "chain", "cam", "C", "ca", "err", "cm", "content", "fc", "com", "anc", "rc", "abc", "mc", "cont", "ic", "cp", "sc", "etc", "gc", "pi", "unc", "spec", "set", "tc", "enc", "e", "cu", "ci", "can", "ac", "pc", "l", "nc", "m", "con", "call", "check", "cc", "scan", "ctx", "v", "ct", "n", "bc", "xc", "ce", "vc", "coll", "ec", "cs", "t", "co", "conf", "arc", "dc", "z", "p"], "avctx": ["wavkb", "avpkg", "navtmp", "aveconn", "avtmp", "avcas", "avectx", "avparams", "averparams", "avejp", "avercas", " avcontext", "avercmp", " avtc", "navcontext", "AVctx", "averctx", "avconn", "avecontext", "savtc", "auctx", " avjp", "AVcmp", "avjp", "navcf", "navpkg", "AVcas", "navctx", "wavcf", " avtmp", "navkb", "avcmp", "avetmp", "avcontext", "wavctx", "avcf", "savconn", "aupkg", "varcas", "savcontext", "aucf", "AVparams", " avconn", "avkb", "aukb", "savctx", "wavpkg", "avtc", "varctx", "varcmp", "navjp", "varparams", "avetc"]}}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc(VP8Context *s, int luma,\n\n            uint8_t *dst, uint8_t *src, const VP56mv *mv,\n\n            int x_off, int y_off, int block_w, int block_h,\n\n            int width, int height, int linesize,\n\n            vp8_mc_func mc_func[3][3])\n\n{\n\n    if (AV_RN32A(mv)) {\n\n        static const uint8_t idx[3][8] = {\n\n            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,\n\n                                        // also function pointer index\n\n            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required\n\n            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels\n\n        };\n\n        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];\n\n        int my = (mv->y << luma)&7, my_idx = idx[0][my];\n\n\n\n        x_off += mv->x >> (3 - luma);\n\n        y_off += mv->y >> (3 - luma);\n\n\n\n        // edge emulation\n\n        src += y_off * linesize + x_off;\n\n        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {\n\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n\n                                block_w + idx[1][mx], block_h + idx[1][my],\n\n                                x_off - mx_idx, y_off - my_idx, width, height);\n\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n        }\n\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n\n    } else\n\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n}\n", "idx": 19538, "substitutes": {"s": ["ls", "is", "sts", "g", "rs", "st", "sv", "ins", "aws", "sw", "south", "a", "c", "h", "sq", "ex", "settings", "js", "i", "service", "ss", "https", "sg", "ns", "spec", "set", "e", "r", "ats", "d", "ts", "m", "sys", "sp", "b", "v", "n", "sports", "sb", "stats", "ds", "qs", "ses", "less", "w", "S", "gs", "cs", "csv", "ps", "t", "fs", "p"], "luma": ["nlasma", "nlora", "loco", "lora", "nluma", "mfu", "lasma", "leuc", " luten", "muna", "leuma", "linasma", "leanca", "Luten", "Lfu", " luc", "oluma", "Lum", " lanca", "Luc", "luten", " lfu", "lanca", "linanca", "linora", "Loco", "oloco", " lum", "mum", "nlanca", "leora", "leuna", "oluna", "luna", " luna", "Lanca", "linuma", "Luna", "Luma", "olanca", "leasma", "lfu", "leuten", "muma", "leoco", "lum", "luc"], "dst": ["Dest", "Dost", "rdest", "bst", "adrc", " dost", "dot", "brc", "Ddest", "sdst", "rost", " dsrc", "idest", "sdpt", "rst", " ddest", "adpt", "sdrc", "adot", "dest", "dost", "bot", "idst", "ddest", "dpt", " dest", "adst", "idsrc", "drc", "iddest", "Dst", "bpt", "Dsrc", "rest", "dsrc", "sdot"], "src": ["proc", "url", "rt", "lr", "tmp", "ser", "th", "offset", "rs", "st", "ins", "sn", "init", "sec", "sq", "iter", "ri", "copy", "rx", "rc", "rl", "stream", "inner", "sur", "fr", "sc", "sub", "iv", "dist", "loc", "cb", "inst", "target", "sr", "r", "ur", "sort", "ul", "scan", "insert", "sync", "sys", "dest", "b", "sb", "str", "filename", "lib", "source", "addr", "start", "ptr", "input", "fn", "usr", "via", "sh", "sup"], "mv": ["mV", "px", "gmvm", "dmvc", "vtv", "dvc", "pva", "mvP", "dmvm", "amvP", "dx", "mx", "vv", "mcv", " mva", "lx", "gmvi", "vmtv", "vmj", "pv", "vmV", "vmvi", " mvc", "dvp", "vx", "vmvm", "gmvin", "amvm", "mcV", "mj", "manv", "vmvin", "dv", "amceive", "dmv", "mva", "amV", "lvp", "mvp", "mceive", "lv", " mj", "manvin", "amv", " mV", "vV", "mvm", "vmv", "mvi", " mceive", "mvc", "lvc", " mtv", "vj", " mvp", "gmv", " mx", "mcceive", "amvc", " mvP", "vvt", "vva", "manvi", " mvt", "mvin", "dmvP", "mcvP", " mvm", "mvt", "mtv", "manvm", "pvt"], "x_off": ["x___err", "x_offer", "xxoffer", "yx_hand", " x_offer", "xacthand", "ex_along", "x_OFF", "ex_off", "ex_on", "yx_out", " x_offset", "yx_free", "xxhand", "x__offset", "xxfree", "x_hand", "xxoffset", "x67off", "xxon", "yxacthand", "xxoff", "xactout", "yxactout", "x67hand", "yxactfree", "x__off", "x_offset", "yxactoff", "xactoff", "x___on", "x_along", "xxOFF", "x67free", " x_err", " x_on", "x_on", "xxout", "xactfree", "x_free", "ex_offset", "x67out", "x__on", "yx_off", "x_err", "x_out", " x_OFF", "x___off"], "y_off": ["y_before", "yo___off", "y___zero", "x_OFF", "y_offer", "y___raw", "vy_offs", " y_offs", "y_OFF", "vy_off", "y_end", "vy_before", "y__OFF", "cy_off", "ry_on", "yo___raw", "yo___zero", "y___off", " y_OFF", "y___OFF", "yo_off", "yo_raw", "ry_off", "yo_zero", "cy_offer", "y_att", "y_zero", "x_on", "ry_end", "y_offs", "y_on", "yo___OFF", "yo_OFF", "y__off", "y_raw", "cy_att"], "block_w": ["blocklogW", "block__m", "block_wh", "window__w", "Block_w", "Block_h", "blockJh", "window_wh", "blockJW", "block__wh", "window__m", "block_wx", "blocklogm", "block_wid", "block__w", "blockJwx", "block2h", "window_m", "window_w", "window_W", "blocklogwh", "block_m", "block2wx", "block2W", "Block_wid", "window__W", "blockJw", "block_W", "blocklogw", "Block_wx", "block2w", "window__wh", "block__W", "Block_W"], "block_h": ["blockPh", "block2hh", "Block_w", "Block_h", "block_hw", "block_hi", "block2v", " block_v", "blockgrhi", "block2h", "blockPw", "block_hh", "Block_hh", "blockgrh", "block_v", " block_hi", " block_hw", "blockPhh", " block_hh", "blockgrw", "block2w", "blockPv"], "height": ["window", "length", "volume", "block", "rank", "h", "depth", "size", "gravity", "radius", "shape", "bottom", "padding", "y", "build", " heights", "rows", "grow", "row", "history", "acity", "total", "ty", "angle", "hang", "alpha", "count", "html", "capacity", "resolution", "w", "sky", "ows", "density", "Height", "ch", "t", "hash", " Height"], "linesize": ["inespace", "linssize", "lineize", "stylesIZE", "pagesization", "lesize", "inesize", "linsIZE", "codesize", "odesized", "linsization", "linsizing", "blocksization", "lins8", "inesization", "inspace", " linesIZE", "ines8", "insize", "lesized", "pointsize", "linsize", "codesIZE", "linksization", "codesizer", "codesization", "linesized", "inesIZE", "blocksized", "lineizer", "linksized", "insIZE", "linespace", " linesizer", "linesizing", "linepace", "pointsizer", "linsizer", "pointsized", "odesize", "elinesize", "linsized", "elinespace", "elinesIZE", "linksizing", "pinsIZE", "lesization", "odesizing", "elinesizer", "lineization", "blocksizer", "linksizer", "inesizer", "linksIZE", "linesIZE", "stylesizer", "lesizer", "stylespace", "pagesIZE", "insizer", "pinssize", "lines8", "pointsization", "linesizer", "inessize", " lines8", "linesization", "pagesize", "pagesizer", "lineIZE", "blocksize", "linksize", "linessize", "stylesize", "pinsization", "odesizer", "pinsize", " linespace"], "mc_func": ["mc2unc", " mc_fun", "mc_function", "mc_unc", "mc2fc", "MC2fc", "mc2func", " mc_function", "MC_func", "mc_fc", "mc_fun", " mc_kw", "MC_unc", "MC2unc", "MC2func", " mc_fc", "mc_kw", " mc_unc", "MC_fc", "mc2kw"], "idx": ["idw", "Idxs", "pidx", "IdX", " idp", "IDc", "idsox", "idsex", "ady", "idsy", "IDx", " idix", "idX", "Idc", "indct", "andct", "andv", " idy", "ridci", "pidy", "idex", "Idw", "infow", "pidxs", "IDw", "idxs", "midxs", "ridv", "Idx", "pidst", "infoc", "idy", " idst", "idsx", "infoxb", "idst", "idv", "identv", "ridix", "midci", "idci", "idsv", "idc", "IDex", "andw", " idX", "idct", "idox", "identx", "indx", "ridox", " idxs", "idsxs", "andx", "Idex", "identw", "ridy", "midix", "idp", "indv", " idci", "idxb", "Idp", "Idy", "adox", "infox", "midx", "Idst", "indw", "adx", "ridxs", " idex", "Idxb", "adv", "idsp", "IDX", "IDxb", "ridx", "IDxs", "idix", "identct"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554, "substitutes": {"dev": ["proc", "pad", "Dev", "act", "ach", "conn", "hw", "cam", " device", "wd", "or", "ad", "os", "serv", "device", "ver", "att", "ac", "d", "v", "ev", "priv", "dep", "md", "dis", "DEV", "data", "Device", "de", "mem", "w", "pro", "ow", "nt", "av", "od"], "prop": ["proc", "attr", "pkg", "sec", "test", "property", "pr", "term", "or", "def", " props", "prev", "cp", "comp", "pos", "doc", "fx", "bug", "spec", "feat", " Prop", "pt", "priv", "sty", "cmd", "Prop", "rop", "col", "pro", "op", "pri", "ps", "conf", "cfg", "pred", "p"], "str": ["f", "text", "br", "st", "ctr", "chain", "c", "err", "fr", "cont", "tr", "res", "doc", "spec", "enc", "r", "arr", "buf", "vol", "list", "sp", "txt", "b", "STR", "out", "s", "Str", "ar", "desc", "data", "seq", "msg", "raw", "w", "name", "p"], "ptr": ["proc", "prime", "pad", "th", "ref", "ctr", "ind", "jp", "pointer", "pr", "eth", "tr", "pert", "pos", "np", "iv", "dist", "obj", "inst", "src", "rel", "arr", "handle", "tip", "buf", "pt", "ts", "index", "sp", "ctx", "inter", "Ptr", "dep", "deg", "dr", "addr", "resh", "t", "rep", "ps", "sh", "tp", "p"], "fmt": ["hformat", "hmt", "fcmid", "ftm", "fMT", "tfmt", "fct", " fMT", "hMT", " fct", " fmid", "vmt", "Fmt", "Ftm", "Fmid", "htm", "fformat", "Fformat", "FMT", "fmid", " fformat", "vstr", "tfformat", "tfstr", "fcMT", "fcmt", "fstr", "tfct", "fcformat", " fstr", "vformat", " ftm", "vct"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "DECLARE_LOOP_FILTER(mmxext)\n\nDECLARE_LOOP_FILTER(sse2)\n\nDECLARE_LOOP_FILTER(ssse3)\n\nDECLARE_LOOP_FILTER(sse4)\n\n\n\n#endif /* HAVE_YASM */\n\n\n\n#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT\n\n\n\n#define VP8_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \\\n\n    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)\n\n\n\n#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][1] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][2] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT\n\n\n\n\n\nav_cold void ff_vp8dsp_init_x86(VP8DSPContext* c)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        c->vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;\n\n        c->vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;\n\n#if ARCH_X86_32\n\n        c->vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;\n\n        c->vp8_idct_add       = ff_vp8_idct_add_mmx;\n\n        c->vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;\n\n#endif\n\n        c->put_vp8_epel_pixels_tab[1][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;\n\n\n\n#if ARCH_X86_32\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;\n\n#endif\n\n    }\n\n\n\n    /* note that 4-tap width=16 functions are missing because w=16\n\n     * is only used for luma, and luma is always a copy or sixtap. */\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        VP8_MC_FUNC(2, 4, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, mmxext);\n\n#if ARCH_X86_32\n\n        VP8_LUMA_MC_FUNC(0, 16, mmxext);\n\n        VP8_MC_FUNC(1, 8, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(1,  8, mmxext);\n\n\n\n        c->vp8_v_loop_filter_simple   = ff_vp8_v_loop_filter_simple_mmxext;\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;\n\n#endif\n\n    }\n\n\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        c->vp8_idct_add                         = ff_vp8_idct_add_sse;\n\n        c->vp8_luma_dc_wht                      = ff_vp8_luma_dc_wht_sse;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags) && (cpu_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, sse2);\n\n        VP8_MC_FUNC(1, 8, sse2);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, sse2);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, sse2);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_sse2;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        c->vp8_idct_dc_add4y          = ff_vp8_idct_dc_add4y_sse2;\n\n\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_sse2;\n\n\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_sse2;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse2;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, ssse3);\n\n        VP8_MC_FUNC(1, 8, ssse3);\n\n        VP8_MC_FUNC(2, 4, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, ssse3);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_ssse3;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;\n\n    }\n\n\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        c->vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;\n\n\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_sse4;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 19557, "substitutes": {}}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int get_bat (CPUState *env, mmu_ctx_t *ctx,\n\n                    target_ulong virtual, int rw, int type)\n\n{\n\n    target_ulong *BATlt, *BATut, *BATu, *BATl;\n\n    target_ulong base, BEPIl, BEPIu, bl;\n\n    int i;\n\n    int ret = -1;\n\n\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    switch (type) {\n\n    case ACCESS_CODE:\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n        break;\n\n    default:\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n        break;\n\n    }\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    base = virtual & 0xFFFC0000;\n\n    for (i = 0; i < 4; i++) {\n\n        BATu = &BATut[i];\n\n        BATl = &BATlt[i];\n\n        BEPIu = *BATu & 0xF0000000;\n\n        BEPIl = *BATu & 0x0FFE0000;\n\n        bl = (*BATu & 0x00001FFC) << 15;\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                    \" BATl 0x\" ADDRX \"\\n\",\n\n                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                    *BATu, *BATl);\n\n        }\n\n#endif\n\n        if ((virtual & 0xF0000000) == BEPIu &&\n\n            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||\n\n                (msr_pr == 1 && (*BATu & 0x00000001))) {\n\n                /* Get physical address */\n\n                ctx->raddr = (*BATl & 0xF0000000) |\n\n                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 19567, "substitutes": {"env": ["proc", "org", "window", "extra", "disk", "attr", "config", "ext", "end", "en", "conn", "er", "sw", "init", "err", "worker", "te", "manager", "def", "cap", "server", "rb", "vs", "net", "obj", "inst", "e", "ah", "here", "sp", "v", "param", "ev", "era", "code", "gate", "ve", "state", "operator", "context", "instance", "cmd", "environment", "db", "desc", "et", "req", "nv", "ec", "vt", "pe", "inv", "eng", "ptr", "dev", "t", "esc", "conf"], "ctx": ["cf", "act", "cv", "conn", "Context", "pkg", "hw", "tx", "c", "anc", "rc", "mc", "cp", "sc", "conv", "jac", "np", "obj", "cb", "loc", "tc", "cu", "ci", "con", "cc", "ct", "bc", "xc", "context", "cmd", "ctrl", "cas", "x", "req", "exec", "nt", "aux", "cmp", "co", "p"], "virtual": ["resource", "text", "angular", "bit", "binary", "initial", "bi", "ref", "final", "absolute", "vector", "rendered", "vr", "native", "interface", "reverse", "valid", "protected", "ret", " v", "buffer", "physical", "ui", "server", "version", "ip", "real", "net", "specific", "al", "target", "sim", "m", "index", "vm", "virt", "local", "v", "vp", "total", "binding", "console", "context", "web", "full", "intel", "external", "bal", "required", "initialized", "vt", "domain", "view", "inv", "current", "t", "ptr", "hidden", "vert", "Virtual", "bitcoin", "unique", "variable", "actual", "name", "normal"], "rw": ["lr", "rt", "resource", "ref", "self", " r", "physical", "ip", "res", "xp", "net", "iv", "ib", "rew", "wire", "ei", " wr", "weight", "write", "req", "ran", "w", "inv", "bound", "rin", "ruby", "ptr", " w", "wr"], "type": ["unit", "all", "action", "ype", "what", "test", " typ", "role", "size", "port", "style", "error", "class", "kind", "ver", "set", "types", "function", "value", "index", "id", "ping", "time", "rule", "o", "family", "TYPE", "state", "ty", "change", "where", "weight", "count", "feature", "file", "format", "no", "view", "pe", "relation", "typ", "start", "pack", "ptr", "word", "try", "scope", "t", "range", "Type", "tp", "name"], "BATlt": ["BATlet", "PORTlt", "Batlin", "BTLT", "Batelt", "Batlet", "BATlin", "Batteryelt", " BATelt", "Batterylt", "SPEClet", "ATlin", "Batl", "BTtl", "Batteryl", "ATelt", "ATlt", "GBTl", "BTelt", "PORTtl", "SPECelt", "BATtl", "BATelt", " BATtl", "GBTlin", "Batut", "BTlt", " BATlet", "Batlt", " BATLT", "Batteryut", "BATLT", "PORTelt", "ATl", "PORTLT", "SPEClt", "SPECl", "GBTelt", "GBTlt"], "BATut": ["Batuti", "Batu", "Benuts", "LETut", "LETutil", "BenUT", "GBTut", "BatUT", "BTuti", " BATutil", "LETul", "BATus", "Benuti", "BATUT", "Batutil", "BTul", "BATuts", "BATuti", "GBTus", "BTu", " BATul", "BTut", "Batuts", "LETlt", " BATus", "BTUT", "Benut", "BTutil", "Batut", "BTuts", "BTlt", "BATul", "Batlt", "Batus", "BATutil", "LETu", "GBTu", "Batul", "GBTlt"], "BATu": ["SAMl", "Batnu", "BTou", "CHATl", "CHATtu", "BatU", "TAGui", "BATus", " BATnu", "BATul", "SPECou", "Batou", "BATiu", "CHATut", "NETus", "SPECl", "BATnu", "LOGou", "Batu", "SAMu", "GBTut", "NETui", "SPECut", " BATul", "BTut", "Benl", "SPECu", "BTU", "Batut", " BATU", "NETu", "SAMcu", "BATou", "BATU", "BTtu", "Batul", "Benu", "TAGou", "BTnu", "BTcu", "LOGuu", "GBTui", "Batl", " BATiu", "TAGu", "VISl", "BTu", "GBTus", "GBTl", "BTl", "BATcu", "GBTU", "GBTuu", "BATui", "NETou", "Bencu", "SAMiu", "VISu", "BATtu", "CHATu", "VISou", " BATcu", "BATuu", "LOGU", "GBTou", "VISut", "Battu", "LOGu", "BTul", "BTuu", "Batcu", "GBTcu", "TAGus", "Benut", "GBTnu", "Batiu", "GBTu"], "BATl": ["new", "bit", "Batlin", "PINlt", "BATli", "BL", "BATle", "_", "PINn", "BATlin", " BATle", "ATli", "SET", "SPECli", "ATlin", "Batl", "func", "SPEClin", "Batteryl", "def", "GBTt", "BATt", "BATn", "V", "GBTln", "GBTl", " BATt", "Batteryln", "BATln", "PINl", "Batteryle", "BTl", "PINli", "SPEClp", "Batteryt", "Batlp", "BTlt", "Batlt", "BATlp", "BTli", "GBTle", "Batn", "Batli", "ATl", "uint", "ATlp", "BTn", " BATln", "SPECl"], "base": ["bit", "block", "binary", "bi", "ref", "interface", "ex", "pointer", "Base", "buffer", "physical", "server", "bp", "ip", "real", "net", "res", "re", "set", "r", "e", "m", "index", "id", "bid", "b", "v", "back", "out", "basic", "binding", "db", "prefix", "used", "et", "file", "external", "bal", "bound", "bas", "name", "p"], "BEPIl": ["BEEPFail", "TEPIns", "PEPIl", "BDPEl", "BEPFail", "BETNL", "TEPil", " BEPIns", "BDPil", " BEPLu", "PEEPFail", "TEMil", "BEMIns", "BEMil", "BENDUs", "BEPEl", "BEMEl", "BEPNL", "BDPFail", " BEPUs", "BDPUs", "PEPNL", "BETEl", "BENDIns", "TEMIl", "TEPEl", " BENDLu", " BENDIl", "TEPIl", "BENDLu", " BENDIns", "BETFail", "BDPNL", "BEPUs", "PEEPIl", "BEMIl", "PEPEl", "BEEPUs", "BETIl", "BDPIns", "BEEPIns", "BEEPLu", "PEPFail", " BENDUs", "BEEPNL", "BENDIl", "BEPLu", "BEPil", "BEEPEl", "BEEPil", "TEMIns", "PEEPNL", "BDPLu", "BEPIns", "BEEPIl", "BDPIl", "PEEPEl", "TEMEl"], "BEPIu": ["BEPIPus", "BEPIou", "BEPIIu", "BELIu", "BEMPIntelu", "BEMPIntelus", "BEPIuid", "BEPIui", "BEPEu", "BEPIEui", "BEPIIou", "BELIui", "BepIcu", "BEPIPou", "BELEcu", "BEPicu", "BEMPIuid", "BEPIAuid", "BepIIou", "BepIu", "BepIIcu", "BEPUIou", "BELIcu", "BEPEui", "BEPIPcu", "BepIIu", "BEPIuf", "BEPIAus", "BEPEcu", "BEPIcu", "BEMPIu", "BEPIus", "BEPUIus", "BEPib", "BELEb", "BEPIEb", "BEPIb", "BEPiui", "BEPInteluf", "BEPIntelus", "BepIou", "BEPEb", "BEPIEuf", "BEPIIus", "BepIIus", "BELEu", "BEMPInteluid", "BepIus", "BEPIPu", "BEPIEu", "BEPIAu", "BEPInteluid", "BEPiu", "BELIb", "BELEui", "BEMPIuf", "BEPIntelu", "BEMPIus", "BEPUIu", "BEPIEcu", "BEPUIcu", "BEPIEuid", "BEPIAuf", "BEPIEus", "BEMPInteluf", "BEPIIcu"], "bl": ["ble", "sl", "jl", "bridge", "br", "BL", "bi", "bd", "kl", "nl", "fr", "li", "ml", "obl", "len", "bp", "loc", "ll", "pl", "lp", "l", " BL", "b", "cl", "ibl", "bg", "lu", "mn", "bn", "abl", "lig", "Bl", "sb", "bc", "lb", "ba", "ln", "bm", "bf", "ptr", "il", "bs", "BR"], "i": ["f", "is", "bi", "gi", "ind", "ir", "c", "ri", "xi", "point", "ki", "ai", "ini", "batch", "li", "ui", "ic", "y", "ip", "in", "\u0438", " ii", "pi", "iu", "qi", "u", "im", "tim", " bi", "ci", "zi", "e", "r", "l", "sim", "m", "me", "index", "ji", "gu", "id", "b", "v", "I", "n", "ii", "ti", "ei", "fi", "ix", "x", "status", "di", "it", " j", "mi", "hi", "ij", "t", "multi", "z", "j", "si", "p"]}}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "func": "static void *migration_thread(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    /* Used by the bandwidth calcs, updated later */\n\n    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    int64_t initial_bytes = 0;\n\n    int64_t max_size = 0;\n\n    int64_t start_time = initial_time;\n\n    int64_t end_time;\n\n    bool old_vm_running = false;\n\n    bool entered_postcopy = false;\n\n    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */\n\n    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_savevm_state_header(s->to_dst_file);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        /* Now tell the dest that it should open its end so it can reply */\n\n        qemu_savevm_send_open_return_path(s->to_dst_file);\n\n\n\n        /* And do a ping that will make stuff easier to debug */\n\n        qemu_savevm_send_ping(s->to_dst_file, 1);\n\n\n\n        /*\n\n         * Tell the destination that we *might* want to do postcopy later;\n\n         * if the other end can't do postcopy it should fail now, nice and\n\n         * early.\n\n         */\n\n        qemu_savevm_send_postcopy_advise(s->to_dst_file);\n\n    }\n\n\n\n    qemu_savevm_state_begin(s->to_dst_file, &s->params);\n\n\n\n    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;\n\n    current_active_state = MIGRATION_STATUS_ACTIVE;\n\n    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n\n\n    trace_migration_thread_setup_complete();\n\n\n\n    while (s->state == MIGRATION_STATUS_ACTIVE ||\n\n           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        int64_t current_time;\n\n        uint64_t pending_size;\n\n\n\n        if (!qemu_file_rate_limit(s->to_dst_file)) {\n\n            uint64_t pend_post, pend_nonpost;\n\n\n\n            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,\n\n                                      &pend_post);\n\n            pending_size = pend_nonpost + pend_post;\n\n            trace_migrate_pending(pending_size, max_size,\n\n                                  pend_post, pend_nonpost);\n\n            if (pending_size && pending_size >= max_size) {\n\n                /* Still a significant amount to transfer */\n\n\n\n                if (migrate_postcopy_ram() &&\n\n                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&\n\n                    pend_nonpost <= max_size &&\n\n                    atomic_read(&s->start_postcopy)) {\n\n\n\n                    if (!postcopy_start(s, &old_vm_running)) {\n\n                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;\n\n                        entered_postcopy = true;\n\n                    }\n\n\n\n                    continue;\n\n                }\n\n                /* Just another iteration step */\n\n                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);\n\n            } else {\n\n                trace_migration_thread_low_pending(pending_size);\n\n                migration_completion(s, current_active_state,\n\n                                     &old_vm_running, &start_time);\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (qemu_file_get_error(s->to_dst_file)) {\n\n            migrate_set_state(&s->state, current_active_state,\n\n                              MIGRATION_STATUS_FAILED);\n\n            trace_migration_thread_file_err();\n\n            break;\n\n        }\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        if (current_time >= initial_time + BUFFER_DELAY) {\n\n            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -\n\n                                         initial_bytes;\n\n            uint64_t time_spent = current_time - initial_time;\n\n            double bandwidth = (double)transferred_bytes / time_spent;\n\n            max_size = bandwidth * migrate_max_downtime() / 1000000;\n\n\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;\n\n\n\n            trace_migrate_transferred(transferred_bytes, time_spent,\n\n                                      bandwidth, max_size);\n\n            /* if we haven't sent anything, we don't want to recalculate\n\n               10000 is a small enough number for our purposes */\n\n            if (s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 19574, "substitutes": {"opaque": ["OPque", "iopacity", "oesc", "OPesc", "oque", "Opacity", "opesc", "oiera", " opque", "OPaque", "opacity", "catacity", " opiera", "Opiera", "opiera", "opque", " opesc", "catiera", "OPiera", "Oposit", "oaque", "oposit", "ioposit", "Opaque", "iopiera", "cataque", "catosit", "iopaque"], "s": ["is", "as", "h", "args", "sm", "js", "i", "store", "ies", "y", "vs", "details", "ims", "v", "has", "stats", "qs", "ses", "less", "als", "aws", "sw", "ports", "ss", "serv", "ns", "spec", "sports", "cmd", "times", "an", "w", "S", "conf", "sis", "hs", "p", "sl", "sts", "rs", "south", "sq", "still", "service", "os", "ess", "set", "l", "m", "sb", "ssl", "gs", "gets", "comm", "bs", "ls", "sv", "ins", "changes", "ats", "ts", "sys", "its", "d", "b", "ties", "sql", "ds", "sam", "csv", "ps", "t", "fs", "j", "es"], "end_time": ["endabletime", "endabletimeout", "stop_start", "endableruntime", "endmodtimeout", "endablestart", "stop_runtime", "endmodruntime", "end_runtime", "stop_time", "stop_timeout", "end_timeout", "endmodstart", "endmodtime", "end_start"], "current_time": ["initial_price", "current_price", "initial_time", "currentTimesize", "currentutionsize", "currentutionprice", "currentutiontime", "currentTimeprice", "initial_size", "currentutiontable", "initial_table", "currentTimetime", "current_size", "current_table", "currentTimetable"], "pending_size": ["pending_SIZE", "pending_Size", "pended_size", "pended_SIZE", "pended_Size"], "pend_post": ["append_post", "pend___new", "pend_posts", "pend___post", "pend_new", "pend___pre", "pend2post", "pend2new", "pend2posts", "append_new", "pend2pre", "pend___posts", "append_posts", "append_pre", "pend_pre"], "pend_nonpost": ["pend_nposts", "pend_npost", "pend_noposts", "pend_notpre", "pend_npre", "pend_notpost", "pend_notposts", "pend_nopre", "pend_nonposts", "pend_nonPOST", "pend_nonpre", "pend_nopost", "pend_nPOST", "pend_noPOST", "pend_notPOST"]}}
{"project": "qemu", "commit_id": "b6954712abea03afd686b724060f9873e2c61f2b", "target": 0, "func": "void replay_input_event(QemuConsole *src, InputEvent *evt)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        /* Nothing */\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_add_input_event(qapi_clone_InputEvent(evt));\n\n    } else {\n\n        qemu_input_event_send_impl(src, evt);\n\n    }\n\n}\n", "idx": 19576, "substitutes": {"src": ["rt", "ser", "th", "bh", "rs", "st", "tn", "sn", "ctr", "hw", "sec", "vr", "sq", "screen", "rc", "gin", "sur", "sc", "wn", "rol", "obj", "iv", "loc", "pl", "sr", "rel", "sys", "dest", "ctx", "hl", "sb", "cur", "source", "usr", "pri", "via", "sel", "bs", "sh"], "evt": ["Evle", "evv", " evle", "evl", "egn", "ekr", "Evt", "iverle", "EVr", "Evr", " evl", "Evn", "Evv", "EVent", "egv", "iverr", "evn", " event", "event", "evle", "ekt", " evv", "EVt", "EVn", " evr", "egl", "ekent", " evn", "ivert", "ivern", "evr", "ekn", "Evl", "egt"]}}
{"project": "FFmpeg", "commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "target": 1, "func": "static inline unsigned int get_uint(ShortenContext *s, int k)\n\n{\n\n    if (s->version != 0)\n\n        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);\n\n    return get_ur_golomb_shorten(&s->gb, k);\n\n}\n", "idx": 19593, "substitutes": {"s": ["ls", "sts", "sv", "rs", "sn", "aws", "c", "sq", "sac", "ops", "js", "os", "q", "ss", "serv", "ess", "sg", "ns", "ims", "ms", "ats", "ts", "sys", "se", "sb", "sf", "ast", "ds", "qs", "ses", "less", "S", "sam", "gs", "cs", "sa", "ps", "comm", "bs", "conf", "fs", "hs", "p"], "k": ["ikk", "kr", "ku", "ok", "ks", "kan", "ik", "g", "ak", "ijk", "c", "uk", "kl", "ck", "kj", "q", "K", "sk", "dk", "unk", "kind", "u", "max", "ka", "work", "ke", "m", "kw", "kh", "km", "kid", "key", "mk", "isk", "ek", "kk", "tk", "it", "t", "z", "j"]}}
{"project": "FFmpeg", "commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "target": 1, "func": "static void scale_coefs (\n\n    int32_t *dst,\n\n    const int32_t *src,\n\n    int dynrng,\n\n    int len)\n\n{\n\n    int i, shift, round;\n\n    int16_t mul;\n\n    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;\n\n\n\n    mul = (dynrng & 0x1f) + 0x20;\n\n    shift = 4 - ((dynrng << 23) >> 28);\n\n    if (shift > 0 ) {\n\n      round = 1 << (shift-1);\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp = temp + round;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n", "idx": 19595, "substitutes": {"dst": ["dlbsp", "dtstore", "Dest", "mdcheck", "ssts", "sdcr", "mdend", "sdset", "delst", " dld", "dadest", "dput", " dwp", "delstop", "ddbsp", "sput", "mdsn", "ddbr", "bddest", "lddest", "edst", "dsset", "dsl", "mdstop", "dsstore", "ddend", "dstop", "bdlt", "edbsp", "drstop", "ddnd", "dset", "darwp", "dstore", "ddst", " dcheck", "bdcr", "drst", "dost", "dlnd", " dstore", "ddsn", "mdest", "sdest", " dput", "Dst", "dend", "drsn", "drset", "dwp", "sddest", " dbsp", "ldld", "ddsl", "dast", "dtst", "darst", "sdst", "sdstop", "ddost", " ddest", "bdsts", "ldst", "darcheck", "bdstop", "Dset", "dtdest", "drbr", "dbr", " dest", "dlsl", "delstore", "ldest", "sdstore", "dsn", " dset", "dsts", " dsts", "deldest", "mdst", "edsl", "dnd", "dlt", "dalt", "mdwp", "bdput", "darest", "drend", "dld", "dsst", "dbsp", " drest", "drost", "sst", "ldrest", "dastop", " dost", " dbr", "ednd", "drest", "dcr", "bdst", "dlst", "ddstop", "dellt", "ldstore", "dest", "dscr", "dtest", "dtrest", "ddest", "dtld", "dcheck", "drbsp", "Dbsp", "bdset", "bdstore"], "src": ["bh", "sn", "syn", "np", "inst", "scan", "req", "rpm", "supp", "sel", "proc", "st", "sw", "sec", "inc", "rob", "sur", "serv", "rb", "sub", "impl", "spec", "sr", "sort", "stock", "rec", "secure", "hl", "s", "source", "usr", "input", "resource", "sl", "ser", "rs", "pkg", "sq", "ipl", "rl", "conv", "comp", "iv", "loc", "stab", "sp", "txt", "sb", "bc", "desc", "cur", "seq", "aux", "ssl", "via", "bs", "rt", "ins", "ctr", "info", "rc", "func", "sc", "in", "rg", "img", "rel", "r", "sync", "sys", "ji", "dest", "cc", "b", "str", "lib", "ipp", "irc"], "dynrng": ["dynramp", "dynlng", "dynclanger", "dyncsprgn", "dyncRnd", "dyncranger", "dynprng", "dynclNG", "dynRng", "dyncRamp", "dyncsprng", "dynrmb", "dynnranger", "dynspramp", "dynsprmb", "dyncrng", "dynlNG", "dynlmd", "dyncrmd", "dyncRng", "dynsprnd", "dynprnd", "dynrrNG", "dynrNG", "dynrranger", "dynpramp", "dynlanger", "dynRgn", "dyncrnd", "dynnrmd", "dynrrng", "dynclng", "dyncrmb", "dynranger", "dynnrng", "dynrrmd", "dyncramp", "dynrgn", "dynsprgn", "dynRnd", "dynRmb", "dynRamp", "dyncRmb", "dyncrNG", "dynprgn", "dynrmd", "dynprmb", "dyncrgn", "dynrnd", "dyncsprnd", "dynclmd", "dynsprng", "dynnrNG"], "len": ["f", "fl", "length", "lan", "lc", "en", "Len", "Length", "h", "kl", "lock", "lit", "dl", "lf", "le", "size", "nl", "li", "fin", "del", "pos", "elt", "ll", "isl", "ul", "l", "vl", "m", "num", "el", "list", "b", "cl", "n", " length", "lim", "lon", " l", "mem", "lib", "ln", "lis", "il", "L", "t", "fn"], "i": ["is", "ik", "iri", "init", "or", "ip", "y", "ami", " ii", "qi", "iii", "e", "v", "I", "o", "ii", "key", "phi", " ti", "status", " j", "hi", "rest", " ki", "f", " di", "ir", "iy", "ret", "ui", "ish", "\u0438", "pi", "im", "index", " pi", "s", "mi", "iq", "name", "multi", "to", " I", "g", " li", "gi", "ind", "chain", "ri", "xi", "err", "cli", "ai", "q", "li", "io", "iu", " bi", "ci", "l", "sim", "m", "me", "ori", "ti", " is", "x", "on", "uri", " si", "try", "at", "ij", "si", "batch", "bi", " mi", "depth", " index", "info", "ia", "ic", "in", "res", "item", "r", "zi", "list", "id", "ji", "n", " iter", "ei", "fi", "ix", "di", "it", "base", "ini", "j", "oi"], "shift": ["trade", "pull", "init", "seed", "shape", "track", "shr", "move", "address", "ul", "message", "time", "skip", "send", "weight", "focus", "frame", "transform", "shake", "command", "snap", "show", "hash", "sup", "pad", "offset", "clock", "distance", "dq", "style", "order", "split", "diff", "shock", "sub", "dist", "power", "hift", "tip", "Shift", "sort", "index", "off", "mode", "change", "iq", "resh", "step", "length", "sample", "ind", "push", "delay", "size", "q", "version", "error", "sign", "set", "m", "sleep", "tick", "seq", "mix", "raw", "ssh", "ptr", "reverse", "filter", "depth", "mask", "scale", "tr", "align", "handle", "hold", "reset", "ix", "it", "hide", "effect", "start", "pack", "transfer", "hello", "share", "sh", "j"], "round": ["trade", "block", "box", "build", "drop", "print", "reflect", "snap", " Round", "field", "Round", "close", "ff", "reg", "offset", "pre", "min", "ound", "diff", "null", "re", "group", "deep", "sort", "play", "row", "secure", "gro", "inter", "full", "mi", "clean", "mod", "hard", "bind", "cell", "turn", "sign", "set", "apply", "m", "rounded", "level", "force", "bc", "col", "quick", "cond", "reverse", "open", "shell", "ref", "method", "town", "lock", "adjust", "connect", "scale", "sc", "server", "align", "roll", "r", "form", "around", "rect", "ort", "call", "hold", "bot", "rule", "reset", "sound", "rot", "format", "j"], "mul": [" mula", "emul", "Mule", "minulative", "immolar", "mutolar", "c", "manulative", "ril", "mtUL", "modol", "muli", "rUL", " cmule", "mur", " cmUL", "ruler", "permul", "mutula", "molar", "mutules", "MUL", "mutulse", "mtula", "emip", "mmula", "tul", "pil", "moul", "mula", "modular", "magur", "mtolar", "mmul", "mular", " muli", " cmul", "smil", "duler", "manull", "mutuler", "new", "mil", "permip", "mutul", "mmol", "mol", "_", "magoul", "tUL", "immula", "mutip", "mtil", "mule", "mutil", "cont", " mule", "dul", "minul", "magul", "modil", "Muli", "mutual", "smulative", "immil", "smuler", "remulative", "mtulse", " mular", "remula", "mmolar", "Mul", "emull", " mull", "emular", "moduleur", "remul", "mip", "rula", " cmuli", "moduleolar", "emules", "mutular", "mules", "moduleoul", " mUL", "manular", "smular", "magolar", "remull", "smol", "Mular", "rular", "emual", "mUL", "rulator", "dil", " mulative", " moul", "load", "mulse", "set", "permules", "mmil", "dular", "rul", "mtual", "minull", "mtular", "tuler", "mulative", "emulative", "poul", "get", "emulse", "mual", "Muler", "mtul", "smull", "mulator", "mtulator", "copy", "roul", "mtoul", "modul", "pul", "manul", "mutulator", "minular", "emula", "permular", "mutur", "call", "Moul", "immul", "smul", "mmular", "mull", "muler", "mutoul", "pula", "tular", "moduleul", "mtuli"], "temp": ["cache", "ta", "memory", "ip", "master", "dat", "v", "time", "able", "capacity", "mem", "timer", "deg", "status", "typ", "perature", "pre", "test", "iter", "min", "json", "Temp", "null", "pi", "power", "tim", "cu", "abl", "total", "empty", "full", "mi", "input", "mod", "variable", "p", "fake", "unit", "tmp", "all", "unt", "result", "ate", "point", "port", " temperature", "buffer", "util", "set", "tc", "pt", "pressure", "Temperature", "txt", "level", "prefix", "at", "ptr", "emp", "method", "fac", "mm", "copy", "mp", "position", "tr", "texture", "tem", "sequence", "ac", "adjusted", "strength", " Temp", "alt", "output", "format", "mint", "current", "base", "t", "timeout"], "temp1": ["tem0", "tmpOne", "tim4", "emp1", "emp11", "temp0", "tempone", "temA", "template1", "tim5", "Temp5", "timone", "tmpA", " tempB", "tmp1", "templateTo", "tim01", "Temp1", "term01", "temp01", "stem1", "timOne", "stem0", "tmpTo", "stem9", "template01", "temB", "tmp11", "tempB", "tmp4", "tim3", "term1", "tempTo", "tmp3", " temp9", "tim0", "tempA", "TempOne", "tem1", "tmpB", "tem3", "term5", "tem11", "stem3", "tmp01", "temp9", "temp11", "stem01", "emp01", "temOne", "template11", " tempone", "tim1", "Temp01", " temp01", "stem4", "tempOne", "termOne", "tem4", "empTo", "stemone", "tim11", "tem9", "timA"], "temp2": [" tempDouble", "template3", "bufferL", "tmp5", "base2", "level2", "temGe", "template2", "bufferTwo", "base5", "buffer2", "templateL", "base4", "stemL", "stemTwo", "buffer5", "tmp4", "tem5", "tmp2", "tem3", "temDouble", "temTwo", "tempGe", " tempGe", "tempL", "buffer3", "level4", "base3", "buffer4", "tmpGe", "tempTwo", "tem2", "level3", "stem3", "tempDouble", "tem4", "levelDouble", "stem2", "stem4"], "temp3": ["cache03", "tempDecl", "template5", "tempthree", "emp3", "stem003", "tmpthree", "template3", "temThree", "cacheThree", "temp03", "status5", "tmp003", "current5", "stemthree", "stem6", "tmp03", "tmpThree", "stem03", "stem5", "tem6", "tem43", "current6", "status3", "cachethree", "stemDecl", "templateThree", "temp21", "temDecl", "template6", "tmp4", "tempThree", "mod6", "tem5", "mod5", "tmp3", "tmpDecl", "emp03", "status6", "mod43", "stem43", "stemThree", "cache4", "tem3", "mod3", "temp003", "statusThree", "temp43", "stem21", "tmp21", "tem03", "emp21", "currentThree", "stem3", "cache3", "tem4", "stem4", "current3", "emp003"], "temp4": ["permfour", "temp04", "tempBy", " temp45", "sequence5", "tmpFour", "tmp44", "sequence6", "perm6", "emp45", "stem42", "temfour", "cache44", "sat4", " temp44", "stem6", "sequenceLine", "stem5", "tem6", "tem04", "sat6", "satBy", "temp42", "tem44", "empfour", "temp44", "stemFour", "sequence4", "cacheFour", "emp422", "tmp4", "tmp45", "tempLine", "sequenceBy", "tem5", "empFour", "stem04", "tmpLine", "tempFour", "cache4", "tmpBy", "tem3", "temp422", "sequence2", "tmp422", "temFour", "perm4", "tempfour", "emp42", "tem2", "emp44", " temp422", "tmp6", "satLine", "stem3", "temp45", "sequence3", "tmp42", "tem4", "stem4", "stem2", "emp6", "permFour", "cache04", "stem44", "emp4"], "temp5": ["template5", "emp3", "template3", "temLet", "tmp5", "tim5", "status5", "emp5", "time5", "temp50", "emp2", "level6", "tem6", "tmp512", "levelLet", "template2", "status3", "tim6", "emp4", "tmp50", "template6", "empLet", "tempLet", "tem5", "level5", "status6", "time6", "time3", "tmp2", "tem3", "emp512", "emp50", "tim512", "level4", "tem2", "tmp6", "tem50", "temp512", "status2", "tem4", "time4", "emp6"], "temp6": ["template8", "template4", "cache06", "test6", "tempSix", "temp68", "tim4", "TempSix", "empSix", "test7", " temp06", "level9", "temp8", "stem6", "tmp7", "result6", "level6", "stem5", "stem7", "tem6", "test68", "tim6", "stem9", " temp68", "tmpSix", "result7", "stem68", "template6", "tem7", "Temp8", "resultSix", "tem5", "cache6", "level5", "testSix", "templateSix", "tmp68", "cache4", "tim8", "result68", "temp06", "cacheSix", "temp9", "stemSix", "temSix", "emp68", "Temp6", "tmp6", "level7", "tem06", "tem9", "stem4", " tempSix", "emp6", "timSix", "tem4", "Temp4", "emp4"], "temp7": ["temseven", "cache87", "prime87", "tim07", "temp07", "tim7", "primeseven", "tmp07", "testSeven", "testJul", "cacheSeven", "test7", "ptr87", "tmp7", "stem6", "stem07", "ptr4", "statusseven", "prime4", "temp87", "cache7", "status07", "stem1", "tem6", "status4", "prime7", "cacheseven", "status87", "cacheJul", "test87", "cache07", "tim6", "tem87", "tmp87", "tem7", "tempSeven", "tmp4", "ptr7", "status6", "tempJul", "tem1", "tempseven", "tim87", "tmpseven", "status7", "tmp6", "timJul", "tem07", "ptrseven", "timSeven", "tim1", "stem4", "tem4", "stemseven", "stem7"]}}
{"project": "qemu", "commit_id": "db3b3c7281ca82e2647e072a1f97db111313dd73", "target": 1, "func": "static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}", "idx": 19612, "substitutes": {"opts": ["iopps", " opjs", "opjs", "OPs", "iopms", " ops", "ops", "optts", "OPms", "opls", " opls", "optls", "pros", "props", "promt", "OPjs", "opmt", "opps", "OPmt", "iops", " opmt", "optps", " opps", "OPls", "optms", "OPps", "iopts", "opms", "optjs", "OPts", "prots"], "fse": [" fge", "fcser", "Fae", "fcae", "fsem", " fser", " fsem", " fae", "fser", "vae", "fcsem", "vse", " fte", "Fse", "Fsem", "fae", "Fser", "fge", "vte", "vge", "Fge", "Fte", "fcse", "fte"], "errp": ["erP", "errP", "Erp", "ErP", " errpp", "errpp", " errP", "errr", "erp", "erpp", "Erpp", "err", "Err", " errr"], "sec_model": ["sec_models", " sec_mode", "sec_mode", " sec_Model", " sec_models", "sec_Model"], "path": ["url", "text", "prop", "component", "length", "alias", "th", "type", "ref", "location", "host", "entry", "chain", "pkg", "route", "partial", "method", "test", "pred", "user", "point", "anc", "root", "stream", "port", "pattern", "PATH", "spec", "target", "form", "dir", "Path", "value", "id", "pt", "out", "template", "ath", "near", "key", "context", "where", "str", "prefix", "full", "data", "desc", "file", "filename", "output", "format", "transform", "status", "serial", "raw", "with", "stat", "source", "arc", "name", "p"]}}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633, "substitutes": {"vs": ["ks", "fs", "vd", "args", "js", "bp", "ims", "docs", "v", "ii", "qs", "terms", "bits", "outs", "eps", "xs", "ports", "values", "lbs", "links", "ss", "heads", "ns", "ms", "parts", "wcs", "services", "s", "times", "vals", "inv", "VS", "cs", "ils", "hs", "vp", "uds", "sts", "rs", "blogs", "vv", "ops", "ads", "lines", "rys", "ables", "caps", "ups", "vers", "history", "Vs", "atts", "words", "vt", "gs", "ows", "ists", "ires", "bs", "ls", "pages", "sv", "ins", "changes", "lists", "vr", "ov", "names", "ues", "params", "obs", "ts", "its", "vc", "views", "ds", "otes", "details"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int integratorcm_init(SysBusDevice *dev)\n\n{\n\n    IntegratorCMState *s = INTEGRATOR_CM(dev);\n\n\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n", "idx": 19643, "substitutes": {"dev": ["pad", "Dev", "disk", "conn", "hw", "cam", "DE", "des", "ad", "def", "os", "serv", "device", "phy", "pi", "sd", "ver", "spec", "dm", "buf", "scan", "dem", "d", "sys", "v", "ctx", "ev", "gate", "o", "dd", "ve", "devices", "db", "dis", "DEV", "Device", "de", "ds", "usb", "w", "adv", "serial", "nt", "ch", "p"], "s": ["is", "er", "as", "states", "fs", "a", "h", "c", "args", "sm", "js", "i", "ies", "y", "vs", "ims", "e", "ids", "v", "o", "tes", "stats", "qs", "ses", "less", "ers", "als", "terms", "f", "bits", "eps", "aws", "sw", "ports", "des", "ss", "serv", "ns", "sd", "spec", "ms", "parts", "bis", "sports", "services", "cmd", "w", "S", "cs", "conf", "hs", "p", "sl", "sts", "g", "rs", "sq", "self", "os", "set", "l", "m", "sb", "gs", "gets", "comm", "tags", "bs", "ls", "sv", "ins", "changes", "settings", "params", "ears", "r", "erences", "ats", "sync", "ts", "sys", "its", "d", "b", "se", "n", "uploads", "tests", "ds", "sam", "ps", "t", "details", "j", "es"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650, "substitutes": {"obj": ["tmp", "act", "opt", "bb", "bh", "object", "obo", "bj", "pkg", "onet", "kl", "xy", "js", "ck", "pr", "ot", "obs", "np", "elt", "impl", "inst", "arr", "resp", "rect", "ack", "txt", "o", "ev", "nu", "po", "oc", "oj", "cmd", "cod", "tk", "nt", "ob", "buff", "ij", "og", "Obj", "bo", "j"]}}
{"project": "FFmpeg", "commit_id": "8f4020d8a4b2e6264f54accbcb881577316c3ca6", "target": 0, "func": "static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)\n\n{\n\n    int frame_size_code;\n\n\n\n    skip_bits(bitbuf, 8); /* temporal_reference */\n\n\n\n    /* frame type */\n\n    s->pict_type = get_bits(bitbuf, 2) + 1;\n\n    if (s->pict_type == 4)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        /* unknown fields */\n\n        if (s->f_code == 0x50 || s->f_code == 0x60) {\n\n            int csum = get_bits(bitbuf, 16);\n\n\n\n            csum = ff_svq1_packet_checksum(bitbuf->buffer,\n\n                                           bitbuf->size_in_bits >> 3,\n\n                                           csum);\n\n\n\n            av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",\n\n                    (csum == 0) ? \"correct\" : \"incorrect\", csum);\n\n        }\n\n\n\n        if ((s->f_code ^ 0x10) >= 0x50) {\n\n            uint8_t msg[256];\n\n\n\n            svq1_parse_string(bitbuf, msg);\n\n\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"embedded message: \\\"%s\\\"\\n\", (char *)msg);\n\n        }\n\n\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits1(bitbuf);\n\n\n\n        /* load frame size */\n\n        frame_size_code = get_bits(bitbuf, 3);\n\n\n\n        if (frame_size_code == 7) {\n\n            /* load width, height (12 bits each) */\n\n            s->width  = get_bits(bitbuf, 12);\n\n            s->height = get_bits(bitbuf, 12);\n\n\n\n            if (!s->width || !s->height)\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            /* get width, height from table */\n\n            s->width  = ff_svq1_frame_size_table[frame_size_code].width;\n\n            s->height = ff_svq1_frame_size_table[frame_size_code].height;\n\n        }\n\n    }\n\n\n\n    /* unknown fields */\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);    /* use packet checksum if (1) */\n\n        skip_bits1(bitbuf);    /* component checksums after image data if (1) */\n\n\n\n        if (get_bits(bitbuf, 2) != 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 4);\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 2);\n\n\n\n        while (get_bits1(bitbuf) == 1)\n\n            skip_bits(bitbuf, 8);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19654, "substitutes": {"bitbuf": ["bugcmd", "itbuffer", "bituf", "shotbuf", " bitbatch", " bitbuffer", " bitcap", "taskbuf", "BITobj", "wordbuff", "bootdb", "bytebatch", "lockbag", " bitbuff", "bitobj", "Bitbuffer", "batchdb", "bitbag", "bitbatch", "byteuf", "bandbuf", "bitcat", " bitbox", " bitdesc", "blockbag", "bootbuf", "boardbuf", "backuf", "jobbag", "bitsbuff", "bootuf", "bitfac", "bitsbuf", "gitfac", "basevec", " bitcmd", "gitbuf", "bitqueue", "bytebuff", "blockbuffer", "Bitbuf", " bitvec", "boardbn", "bootbuff", "baseuf", "bitbox", "bitscat", "blockbuf", "backbuf", "itbuf", " bitobj", "taskcat", "gitnext", "bitdb", "lockbuffer", "bytebox", "lockbuff", "bytebuffer", "catbuf", "bitbuffer", "bitscmd", "blockuf", "bytedesc", "bitcmd", "catcmd", "bytecap", "lockbuf", "bitbn", "bootbr", "boardbuffer", "backbuffer", "bitcap", "byteobj", "bugbuf", "bugbuffer", "worduf", "bitvec", "lockuf", "Bitbuff", "bandbuff", "bitsuf", " bituf", "formbatch", "bugbox", "shotbatch", "bandbuffer", "formbr", "formbuffer", "jobuf", "bitsbox", "itqueue", "bitbr", "bytebuf", "backcmd", " bitbn", "bitsqueue", "bitscap", "buguf", "wordbuf", "batchbuf", "bytequeue", "gitbuff", "BITdesc", "bitsbuffer", "batchbuff", "bugbuff", "bootbuffer", "shotbox", "bugdb", "jobbuff", "basebuff", "bitdesc", "bitsnext", "bytebr", "bandbn", "jobbuf", "bootbatch", "bitsbag", "lockfac", "bytecmd", "bytebag", " bitqueue", "basebuf", "bitsvec", "bitnext", "batchuf", "boardbuff", "catbag", "locknext", "bitsfac", "taskcmd", "catcat", "taskbag", "wordbag", "bitbuff", "formbuf", "BITbuffer", "itbuff", "BITbuf"], "s": ["is", "er", "as", "fs", "c", "h", "js", "store", "y", "ies", "vs", "ims", "has", "stats", "qs", "ses", "less", "als", "st", "eps", "aws", "sw", "ports", "des", "ants", "ss", "sg", "ns", "spec", "ms", "bis", "sports", "w", "S", "results", "cs", "rates", "conf", "hs", "p", "sts", "ains", "rs", "ops", "aunts", "ex", "service", "os", "conv", "set", "pers", "l", "m", "sb", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "ats", "ts", "d", "sys", "its", "b", "n", "se", "uploads", "ds", "ps", "details", "j", "es"], "frame_size_code": ["frame_size12Code", "frame_size5result", "frame_sizeityCode", "frame_sizeityresult", "frame_sizeitycode", "frame_size_rate", "frame_size32rate", "frame_width_code", "frame_name_count", "frame_size_table", "frame_size5code", "frame_size_key", "frame_name_Code", "frame_width32code", "frame_width32create", "frame_width32table", "frame_size_cycle", "frame_size_coe", "frame_size32create", "frame_size_result", "frame_size12cycle", "frame_name_code", "frame_size12coe", "frame_size5table", "frame_width_rate", "frame_size32table", "frame_size12code", "frame_size32code", "frame_name_type", "frame_width_create", "frame_width_table", "frame_sizeitytable", "frame_size_Code", "frame_width32rate", "frame_size_type", "frame_size5Code", "frame_size_create", "frame_size_count"], "msg": ["new", "tmp", "text", "ext", "g", "pkg", "result", "reason", "Message", "args", "err", "title", "sent", "error", "res", "sg", "doc", "obj", "body", "Msg", "event", "bug", "arg", "arr", "buf", "message", "ms", "vol", "m", "txt", "gz", "var", "mat", "out", "mail", "mess", "gm", "mo", "str", "cmd", "empty", "data", "desc", "mem", "goo", "gs", "news", "mt", "og", "tree"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n", "idx": 19665, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n", "idx": 19667, "substitutes": {"a": ["act", "from", "ach", "as", "c", "ada", "ed", "or", "ade", "ab", "ad", "ata", "aa", "aj", "att", "e", "ac", "d", "eas", "aaa", "A", "area", "apa", "au", "ast", "ba", "ant", "an", "am", "oa", "aux", "at", "sa", "ea", "ae", "admin", "both", "ga"], "b": ["nb", "bridge", "to", "bb", "br", "g", "bi", "blue", "another", "B", "c", "fb", "ed", "ab", "rb", "abb", "y", "bp", "cb", "ib", "by", "e", "r", "d", "eb", "v", "n", "hub", "be", "bis", "other", "bc", "ba", "bound", "t", "bs", "facebook"], "da": ["DA", "dra", "lambda", "hd", "bd", "du", "ta", "dl", "dal", "ata", "ao", "dar", "aa", "deb", "dat", "ra", "oda", "d", "ma", "fa", "lda", "ena", "anda", "pa", "Da", "sha", "ar", "va", "wa", "md", "ba", "ds", "di", "dr", "oa", "sa", "la", "ara", "ea", "ld", "pd", "ga"], "db": ["nb", "bridge", "bb", "ub", "bi", "gd", "Db", "bd", "df", "vd", "fb", "dl", "ud", "ad", "ade", "rb", "dk", "deb", "bur", "cb", "pb", "sd", "dat", "ib", "rel", "dir", "d", "eb", "back", "dd", "sb", "sql", "bc", "kb", "gb", "ds", "di", "lib", "bl", "py", "ob", "try", "bf", "og", "DB", "dev", "bs", "dp", "dc"]}}
{"project": "qemu", "commit_id": "c3fecea50dc0f27198b8658a0c9c4fbfdd0f95db", "target": 1, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, int create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, NULL, s);\n\n    set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = do_write(s->fd, &hdr, sizeof(hdr));\n\n    if (ret) {\n\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -EIO;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = do_writev(s->fd, iov, wlen, aio_req->iov_offset);\n\n        if (ret) {\n\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -EIO;\n\n        }\n\n    }\n\n\n\n    set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, NULL, s);\n\n\n\n\n    return 0;\n\n}", "idx": 19684, "substitutes": {"s": ["f", "ls", "is", "sl", "sts", "sv", "rs", "st", "g", "as", "so", "sw", "a", "h", "c", "sq", "ex", "js", "i", "self", "os", "store", "ss", "serv", "y", "sub", "ns", "ims", "sd", "spec", "e", "r", "sync", "l", "ts", "sys", "m", "conf", "sp", "es", "b", "v", "se", "n", "socket", "sb", "stats", "ds", "qs", "ses", "http", "status", "less", "w", "S", "an", "gs", "ssl", "source", "cs", "ps", "t", "bs", "comm", "fs", "hs", "j", "p"], "aio_req": ["aio_expr", "aio___requ", "aio_inv", "aoy_seq", "aio___res", "aie_req", "aio_cmd", "aio_desc", "aive_requ", "aio_seq", "aive_cmd", "aive_req", "aio_quest", "aio_request", "aioptexpr", "aio_query", "aio___err", "aie_requ", "aive_expr", "aio2md", "aie_require", "aio___seq", "aio2requ", "aie_md", "aie_inv", "aioptreq", "aio___require", "aio___quest", "aie_request", "aio_err", "aio_res", "aIO_requ", "aio_obj", "aoy_requ", "aie_err", "aioptrequ", "aio2request", "aoy_res", "aio2req", "aio_requ", "aio_require", "aioptcmd", "aio___request", "aoy_req", "aio_md", "aio___inv", "aIO_query", "aio___req", "aIO_req", "aIO_request"], "iov": ["ih", "cv", "isco", "ucc", "IO", "vr", "vec", "oo", "ef", "river", "uart", "wo", "conv", "ou", "version", "io", "iv", "OV", "actor", "rio", "nc", "ux", "uf", "ilo", "ovi", "uv", "ival", "iq"], "niov": ["niOV", "diOV", "tiOV", "tiocr", "tiuv", "niocr", "nuuv", "nuov", "diocr", "nuocr", "nuOV", "tiov", "niuv", "diov", "diuv"], "create": ["new", "close", "open", "ulate", "execute", "update", "copy", "use", "delete", "clear", "draw", "creat", "ure", "creator", "ize", "activate", "build", "load", "set", "check", "insert", "destroy", "enable", "drop", "force", "raise", "define", "code", "see", "send", "cre", "actory", "ce", "count", "write", "equal", "make", "find", "only", "created", "creation", "add", "Create"], "aiocb_type": ["aiocB_name", "aiocB_color", "aiocbetytypes", "aiocbetycolor", "aiocbetyType", "aiocb_Type", "aiocB_Type", "aiocb___type", "aiocb_types", "aiocB_time", "aiocB_type", "aiocbetytype", "aiocb___name", "aiocB_types", "aiocb___time", "aiocb_time", "aiocb_color", "aiocb_name", "aiocb___types"], "hdr": ["hr", "ghDR", "Hstr", "Hrr", "thedro", "phdr", " htr", "husr", "ohheader", "ohrr", "thecmd", "htr", " hld", "Hgt", "hgt", "thstr", "heder", "shder", "thedr", "phbr", "ahDR", " hbr", "ohdr", "hmsg", "theusr", "HDR", "heheader", "hdro", "hhstr", "hld", "heDR", "thheader", "hhmsg", "Hadr", "thfr", "shDR", "ohr", "ohld", " hheader", "hstr", "ohstr", "phDR", "hrdr", "ghdro", " hmsg", "hrnz", "ghdr", " hDR", "hbr", "Hr", "hrstr", "ohint", "thetr", "phrr", "hser", "Hder", "hrr", "Hheader", "ahder", "thdr", "hrDR", "thbr", "hmtr", " hstr", "hnz", "theDR", "ohadr", " husr", "ahser", "hadr", "Hbr", "hhdr", "Hser", "Hmsg", "hhder", "shdr", "thDR", "hint", "hmcmd", "hmdr", "hhDR", " hcmd", " hr", " hint", "hedr", "ohnz", "thegt", "ahheader", "ohbr", "Hint", "ahadr", " hfr", "hcmd", "ahdr", "shser", "hDR", "Htr", "hhnz", " hder", "thld", " hrr", "Hdr", "Hdro", "ohfr", "ohDR", "hmusr", "ahtr", "ghgt", "hder", "hheader", "hfr", "ohder"], "wlen": ["wxlength", "wbl", "rlen", "hlan", "willer", " wbl", "wordlen", "welt", "whelt", "wval", " wval", "worddl", "wxval", "rval", "swiller", "wdl", "wLen", "whlan", "swlan", " wlan", "winlen", "winln", " wlength", "helt", " wen", "hbl", "worden", "hen", " willer", "wln", "wlength", "wlan", "wxLen", "rlength", "wxlen", "swlen", "winiller", " wdl", " wLen", "swln", "winlan", "whlen", "hlen", "rLen", "hdl", " wln", "wen", "whdl", " welt", "wordbl"], "ret": ["rt", "gt", "result", "err", "rem", "cont", "len", "tr", "res", "elt", "Return", "ll", "att", "rel", "r", "re", "flag", "rev", "Ret", "RET", "any", "back", "out", "ft", " Ret", "val", "rets", "x", "count", "alt", "success", "et", "rm", "nt", "mt", "il", "t"]}}
{"project": "qemu", "commit_id": "2b3de6ada5d180130ba083d5b45ed51ce8e4def2", "target": 1, "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);", "idx": 19685, "substitutes": {"p": ["pat", "g", "pkg", "P", "jp", "part", "c", "h", "pre", "post", "i", "pr", "press", "cp", "y", "ip", "pp", "np", "pb", "att", "e", "r", "lp", "pc", "wp", "d", "m", "ap", "ping", "v", "k", "n", "pa", "vp", "pro", "w", "op", "at", "ps", "t", "tp"], "q": ["f", "window", "qa", "g", "cache", "pkg", "h", "sq", "qu", "lock", "Q", "flow", "i", "ck", "dq", "requ", "y", "ue", "pp", "qt", "aq", "qi", "qq", "pl", "quote", "r", "quant", "query", "gr", "l", "pt", "d", "m", "cl", "v", "k", "ct", "ry", "gm", "cmd", "pg", "req", "quit", "qs", "w", "z", "it", "mt", "queue", "iq", "comm", "t", "ch", "conf", "que", "j"], "state": ["close", "to", "is", "type", "length", "ose", "ne", "st", "states", "result", "init", "come", " State", "ta", "State", "h", "test", "lock", "STATE", "info", "oto", " states", "size", "port", "style", "ot", "powered", "al", "power", " t", "spec", "set", " error", "l", "list", "m", "value", "id", "un", "local", "out", "code", "s", "print", " length", "where", "change", "trace", " l", " score", "status", "no", "it", "stat", "start", "tag", "ch", "cs", " s", "t", "name", "ist"]}}
{"project": "qemu", "commit_id": "36c6711bbe79642b0102416a9dd4243505e874a6", "target": 1, "func": "static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,\n\n                           int base, int16_t offset)\n\n{\n\n    const char *opn = \"ldst_pair\";\n\n    TCGv t0, t1;\n\n\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    t1 = tcg_temp_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n    case LWP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"lwp\";\n\n        break;\n\n    case SWP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sw(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sw(t1, t0, ctx);\n\n        opn = \"swp\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case LDP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"ldp\";\n\n        break;\n\n    case SDP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sd(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sd(t1, t0, ctx);\n\n        opn = \"sdp\";\n\n        break;\n\n#endif\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 19709, "substitutes": {"ctx": ["cv", "bh", "c", "xy", "com", "setup", "etc", "iat", "jac", "np", "kt", "grad", "cas", "req", "tz", "cmp", "co", "dc", "cf", "act", "hw", "tx", "ca", "xs", "mc", "json", "cp", "obj", "cb", "cu", "wcs", "context", "cmd", "pg", "nt", "scope", "conf", "cfg", "tmp", "conn", "pkg", "cn", "cm", "parent", "conv", "loc", "wx", "tc", "resp", "kw", "sp", "txt", "cl", "ct", "history", " cx", "bc", "kb", "pool", "via", "bo", "cd", "batch", "rt", "lc", "config", "ref", "Context", "ctr", "jp", "kl", "gp", "fc", "ck", "func", "sc", "fx", "pause", "gc", "qt", "unc", "handle", "nc", "sys", "cc", "gz", "ctl", "xc", "timeout"], "opc": ["ioppc", "iopnc", "opct", "OPc", " opct", "ropn", "iopcin", "OPnc", "copc", " opcs", "copcs", "ropnc", "copct", "opnc", "roppc", "iopcs", "OPn", " opcin", "iopc", "oppc", "OPpc", "copcin", "iopn", "opcin", "opcs", "ropc", "iopct"], "rd": ["rid", "hr", "rt", "lr", "fd", "rod", "th", "rend", "rank", "attr", "rs", "dra", "rf", "end", "ind", "du", "aug", "nd", "ri", "rh", "std", "rx", "rc", "ring", "dq", "fr", "rax", "rb", "rg", "rr", "orth", "round", "rate", "ird", "r", "src", "sr", "rw", "ra", "rss", "d", "index", "rown", "RD", "ord", "back", "dd", "ru", "db", "ds", "dr", "rin", "usr", "ptr", "mb", "range", "ld", "rn", "rest", "red", "ry"], "base": ["f", "rt", "type", "length", "bit", "end", "ref", "bi", "st", "based", "h", "origin", "root", "size", "Base", "buffer", "store", "fr", "server", "len", "bp", "null", "orig", "set", "max", "r", "handler", "work", "zero", "id", "index", "b", "balance", "se", "back", "reset", "db", "ase", "et", "x", "file", "bal", "old", "no", "bound", "bas", "start", "bf", "mb", "range", "p"], "offset": ["extra", "pad", "length", "bit", "block", "attr", "type", "coord", "end", "ref", "slot", "location", "shift", "rc", "pointer", "Offset", "fr", "error", "attribute", "pos", "unk", "set", "address", "r", "index", "id", "off", "row", "time", "reset", "rot", "et", "alt", "bound", "addr", "bf", "mt", "start", "ptr", "range"], "opn": ["Opr", "opr", "OPc", " opcn", "opns", "opnu", "optnp", "optnt", "cmdc", "cmdnu", "cmdn", " opN", "hopcn", "optv", "OPcn", "hopnp", "opcn", "opnp", "hopn", "OPns", "cmdv", "hopnt", "opN", "OPn", "OPN", " opns", "Opns", " opnt", "OpN", " opr", "optcn", "optn", "OPr", "Opcn", " opnu", " opnp", "opnt", "opv", "Opc", "optc", " opv", "optnu", "Opn"], "t0": ["at0", "t180", "m1", "T50", "tie", "det0", " t00", "T6", "att0", "tmp1", "it0", " tor", "dt1", "t83", "tree9", "detZero", "rt000", " t180", "TMac", "tree1", "tmp000", "m8", "ot50", " t6", "tree0", " t047", "it4", "itNo", " T0", "ttZero", "ntOK", " tMac", "gt180", "treeie", "test83", "t50", "t047", "tnOK", "tOK", "t9", "T83", " t50", " T8", "Tie", "m0", "ot1", "t00", "rt1", " t4", "ut1", "TZero", "at4", "att047", "dt0", "t4", " tie", "Tor", "tor", "nt7", "ot047", "tt0", "t000", "test0", "tt7", "att8", "det047", "tt9", " tOK", " tNo", "tn7", "it1", "T9", "t7", "gt0", " tZero", "T000", "t8", " t9", "T180", " T00", "T4", "gt83", "it6", " t83", "it83", "ut6", "at83", "ttor", "T0", "m00", "t6", " t000", " t7", " t8", "tt1", "ot0", "at1", "at000", "det8", "atNo", "utMac", " T1", "ut0", "dt83", "rt4", "rt0", "tMac", "tNo", "nt0", "test1", "gt1", "tZero", "dt6", "T7", "T047", "tn0", "tmp0", "T1", "attZero"], "t1": ["toone", "e12", "e2", "T5", "tN", "T001", "eONE", "T120", "atN", "timeAP", " t119", "time1", "template1", "p01", "time512", "template91", "t5", "ot120", "tAP", " t5", "t110", "it0", "t31", "atOne", "e1", "ot2", "atone", "dt1", "tree1", "otOne", "v0", "templateons", "t61", "t512", "at512", " t41", "terone", "taone", "T14", "dt61", "time119", " t61", "tree0", " t6", "tsOne", "it61", "tsone", "tree120", " tOne", "tt384", "template0", "otONE", "wt512", "ter41", "t2", " tONE", "tree01", " tAP", "ntOne", "e01", "T91", "t9", "pt14", "otons", "pt110", "treeOne", "e0", "pt512", "it91", "tone", " t256", "v31", "ot1", "Tone", "t120", "testOne", "pt6", " t01", "p0", "ptone", "tt01", "it9", "at6", " t31", "wtAP", "itone", "otone", "ot12", "t14", "test8", "eone", "pt01", "taOne", "to41", "ter5", "itOne", "T01", "ta1", "nt512", "t256", "te01", "T12", " t2", "ts120", "it1", "te2", "ts1", "to384", " t110", "t001", "pt1", "t384", "t8", " t9", "v01", "it256", " t512", "te1", "p2", "dt9", "tree512", "nt110", "it8", "to0", "ptN", "to61", "T0", "itons", "tree31", "T61", "t6", "pt41", "v384", "tree001", "t91", "tons", "T2", "to1", " t8", "to14", "dtone", "te0", "ptOne", "wt119", "p1", "ot61", "treeons", "v1", "t12", "v6", "tt1", "tOne", "ot0", "at1", " tN", " t120", "pt384", "tt41", "pt0", "wt1", "ter1", "test1", "ter0", "ta120", "t119", "t41", "test256", "ter61", "Tons", "to01", " tone", "terOne", "T41", "to6", "t01", "tONE", "ot001", "nt1", "ot512", "T1", "atons"]}}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716, "substitutes": {"klass": [" klasses", "ikclass", "kclass", "ikls", "tklasses", "klasses", "kls", "klf", " kclass", "tklass", "Klass", "iklasses", " kls", "iklass", " klf", "tklf", "Klasses", "Kls", "tkls", "Kclass", "Klf"], "data": ["attr", "cache", "result", "dll", "rc", "ret", "json", " DATA", "buffer", "def", "ata", "res", "mu", "dat", "kind", "d", "value", " Data", "rew", "DATA", "Data", "di", "w", "bin", "module", "name"], "dc": ["proc", "lc", "DC", "cr", " DC", "disk", "cache", "cam", "c", "df", "cat", "ca", "cm", "disc", "fc", "root", "rc", "currency", "draw", "mc", "dt", "comp", "cp", "sc", "doc", "gc", "iac", "unc", "tc", "dm", "cu", "da", "ac", "pc", "nc", "d", "cca", "cc", "ct", "dd", "bc", "oc", "uc", "desc", "vc", "ec", "di", "dr", "mac", "erc", "cs", "design", "dp", "cd", "ga"], "diag288": [" diag248", " diag280", "diag263", "diag248", " diag256", "diig256", "diig280", "diag280", "diog288", " diag263", " diig280", " diog288", "diagg28", " diog28", " diog263", " diag28", "diagg263", "diig248", "diog28", "diagger288", "diagg280", "diang248", "diang288", "diang280", "diagg256", "diag28", "diog280", "diagger280", "diagg288", "diagger263", "diig288", "diog263", " diig288", "diang256", " diog280", "diagg248", " diig256", "diag256", " diig248", "diagger28"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "int ff_estimate_motion_b(MpegEncContext * s,\n\n                       int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code)\n\n{\n\n    int mx, my, range, dmin;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    const int mot_stride = s->mb_width + 2;\n\n    const int mot_xy = (mb_y + 1)*mot_stride + mb_x + 1;\n\n    \n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = mv_table[mot_xy    ][0];\n\n            P[0][1] = mv_table[mot_xy    ][1];\n\n            P[1][0] = mv_table[mot_xy - 1][0];\n\n            P[1][1] = mv_table[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = mv_table[mot_xy - mot_stride             ][0];\n\n                P[2][1] = mv_table[mot_xy - mot_stride             ][1];\n\n                P[3][0] = mv_table[mot_xy - mot_stride + 1         ][0];\n\n                P[3][1] = mv_table[mot_xy - mot_stride + 1         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            pred_x= P[1][0];\n\n            pred_y= P[1][1];\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    /* intra / predictive decision */\n\n//    xx = mb_x * 16;\n\n//    yy = mb_y * 16;\n\n\n\n//    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n//    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    dmin= halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n\n\n//    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    mv_table[mot_xy][0]= mx;\n\n    mv_table[mot_xy][1]= my;\n\n    return dmin;\n\n}\n", "idx": 19721, "substitutes": {"s": ["ls", "is", "us", "sts", "g", "rs", "sv", "ins", "as", "scl", "sw", "aws", "a", "c", "h", "sq", "ops", "args", "sm", "ex", "js", "i", "q", "os", "ss", "sc", "y", "sg", "vs", "p", "ns", "ims", "spec", "set", "e", "r", "ms", "ats", "bs", "m", "d", "its", "sys", "ts", "b", "v", "ctx", "n", "se", "ties", "sb", "stats", "ds", "an", "ses", "qs", "w", "S", "gs", "cs", "ps", "t", "comm", "fs", "hs", "z", "es"], "mb_x": [" MB_content", "mb_width", " MB_X", "mb_dx", "mb_content", "mp_ex", "mb__width", "kb_x", "mb__y", "mb08content", "mb1x", "mp_x", "mp1width", "mp1ex", "mb_ex", "emb_dx", "mb__x", "mb08X", "emb_y", "mb__z", "mb1dx", "mb08x", " MB_x", "mb1z", "kb_ex", "mb_ix", "mb08ix", "mb__ex", "mb_X", "kb_y", "mp1z", "emb_ex", "mp_width", "mp_z", "kb_ix", "mb_z", "emb_x", "mb1ex", "mp1x", " MB_ix", "mb1width", "mb1y", "mb__dx"], "mb_y": ["mb_gy", "mb___yo", "mor08yl", "mor_y", "mor_yl", "mb_yl", "rav_yo", "mor08y", "mb67yl", "mor_ny", "ghost_ye", "mb___y", "mb______gy", "mb08yl", "mb___yt", "mb______y", "mor_yy", "mb______ym", "ghost_y", "rav_x", "mb_ny", "mb___x", "mb_ye", "mb___yy", "mb67ny", "mb___xy", "ref_yl", "mb______ye", "ghost_gy", "mb67yy", "mb08ny", "mb67y", "ref_yt", "mb08yy", "mor08ny", "mb08y", "mor08yy", "ghost_ym", "mb_yo", "mb_xy", "ref_y", "rav_xy", "mb_ym", "mb___yl", "mb_yy", "mb_yt", "rav_y", "ref_yy"], "mv_table": ["mv5list", "mv_map", "mvi_map", "mv_source", "mv1map", "mvi_info", "mV_table", "mv5tab", "mv_database", "mv1table", "mV_source", "mv5source", "mv1info", "mv2info", "mvi_tab", "mvi2map", "mV_database", "mov_table", "mv2map", "mV_tab", "mvi2table", "mv_tab", "mv5table", "mV_list", "mv_info", "mv5database", "mov_tab", "mvi2tab", "mvi2info", "mv2tab", "mv1tab", "mvi_table", "mv_array", "mv_list", "mov_list", "mov_array", "mv2table"], "ref_picture": ["ref_code", "ref__picture", "reference_image", " ref_friendly", "ref2picture", "refogperson", " ref_proof", "reference2picture", "refogproof", " ref_person", "refgproof", "ref2pict", "reference_profile", "reference2profile", "ref_pict", "ref_proof", "ref_image", "refgpicture", "reference2image", "ref2profile", "ref2image", "ref_profile", "reference_picture", " ref_communication", "reference2pict", "ref__friendly", "ref_person", "ref__person", " ref_profile", "ref_communication", "ref__proof", "refogpicture", "refogfriendly", "refgcode", " ref_code", "ref_friendly", "reference_pict"], "f_code": ["f___code", "ref_code", "ref_language", "f___name", "fdefcode", "f_codes", "fjcode", "ref_description", "ref_codes", "fdefcodes", "f___codes", "f___description", "fjcodes", "fjpicture", "f_picture", "flicpicture", "f_description", "fdefdescription", "f_name", "fdefname", "ref_name", "f_language", "fliccode", "fliclanguage", "fliccodes", "fjlanguage"], "mx": ["yx", "px", "xml", "ox", "ax", "mr", "tx", "mm", "mouse", "rx", "xs", "xy", "mp", "wm", "mc", "ml", "cp", "y", "xes", "mort", "MX", "wx", "dm", "max", "pm", "ms", "m", "vm", "ctx", "mn", "nz", "mic", "mk", "md", "ix", "mop", "yz", "x", "mem", "mac", "mi", "rm", "mie", "mb", "mt", "xx", "fax", "mind"], "my": ["ny", "mos", "mm", "My", "mis", "xy", "mp", "ym", "memory", "self", "les", "mc", "mg", "y", " MY", "mph", "their", "your", "gray", "by", "iam", "pm", "MY", "ms", "wi", "me", "m", "sys", "yy", "vm", "his", "mon", "mn", "ty", "ti", "mk", "md", "maybe", "colm", "mem", "mys", "mi", "py", "mie", "sam", "try", "dds", "thing", "ys", " My", "multi"], "range": ["resource", "window", "usage", "offset", "ref", "sample", "chain", "channel", "args", "use", "ge", "size", "term", "radius", "shape", "q", "fr", "scale", "store", "diff", "ANGE", "res", "exclusive", "rage", "Range", "loc", "max", "r", "move", "spread", "ange", "rang", "remote", "ram", "list", "m", "path", "conf", "call", "row", "force", "race", "area", "history", "space", "angle", "change", "slice", "axis", "share", "feature", "frame", "format", "handle", "view", "bound", "base", "domain", "command", "scope", "ch", "gap", "release", "rest", "batch"], "dmin": ["nonly", "dMin", "n0", "idminus", " damin", "donemin", "dtstat", "dlminus", "dMIN", " dMin", "r0", "d0", "ldmon", "drapart", "idamin", "dllt", "dsmin", "dslt", "draminus", "dramin", "drain", "rmins", "dminus", "ronly", "dstat", "ldrain", "draamin", " dmon", " dstat", " dlower", "damin", "drMIN", "dlower", " dlt", "dlMin", "drrain", "drmin", " dMIN", "dpart", " d0", "ldMIN", "dtmon", "donelower", "donly", "ldmin", " dmins", " dminus", "dmon", "idmin", "donemon", "rmin", "nmin", "dmins", "idpart", "dtmin", "dtlower", " drain", "drmon", "nmins", "donestat", " donly", "dlt", "dsMin", "dsminus", " dpart", "dlmin"], "xmin": ["yMin", "exstart", "xpmax", "exmin", "xpmin", "xminimum", " xinit", "fxmin", "wmax", "wmins", "xMin", "Xminimum", "xpstart", "exmins", " xbegin", "exmax", "xstart", "xmlmin", "xxmax", "xxMin", "yinit", "ixmin", "ixmins", "Xmin", "lexmin", " xminimum", "exbegin", "xmlinit", "ixbegin", "fxbegin", "xbegin", "lexmax", "ymins", "Xmax", "xxmin", "lexbegin", "xxmins", "xinit", "wxminimum", "wxmins", "wmin", "fxmax", "xpmins", "ybegin", "ixmax", "wxmax", "xmlmins", " xmins", "wstart", "wxmin", " xMin", "xmins", "lexinit", "fxinit", "Xmins"], "ymin": ["iymid", "yymin", "erymind", " ymer", " ystore", "yserv", "Ymid", "verymins", "verymer", "axymin", "xpart", "xminimum", "cymin", "verymedi", "cypart", "fymin", "rymax", "iymin", "axyserv", "Ymax", "ymain", "Yserv", "verymin", "xMIN", "Ymin", "cyMIN", " ypart", "yystore", "iymins", "ilymain", "verypart", "lyMIN", "iypart", "yymind", "erystore", "ilyserv", " ymind", "axymedi", "fypart", "fymins", "ystore", "verymain", "ymins", "veryserv", "lyminimum", "ymer", "rymid", "fymer", "lymin", "erymin", "ymid", "ymind", "erymins", "axymain", "ilymin", "ilymedi", "ymedi", "cyminimum", " ymins", "yymins", "ypart", "lymax", "iyserv", "iymax", "xmins", "rymin", "cymins", "cymax", "yminimum", "ryserv", "yMIN"], "xmax": ["xhr", "ixax", "rxmin", "exmin", "xend", "exhr", "Xend", "xtmod", " xmod", "exmax", "xmlmin", "ixmin", "exax", "txmax", "txmin", "ixhr", "xmlMAX", "mxend", "xtmin", "xmllast", "yMAX", "xax", "ypr", "txMAX", "xMAX", "mxmax", "rxlast", "ymod", "expr", "ylast", "xmlmax", "xpr", "yend", "Xmax", "yax", " xax", "Xax", "xlast", "rxMAX", "xtax", "mxax", "ixpr", "ixmax", " xhr", "rxmax", "xmod", "xtmax", "exMAX"], "ymax": ["symagic", "pmap", "ymav", "ymask", "ypagic", "ymat", "ymaz", "ynax", "iemAX", "ypass", "ermav", "symAX", "ymAX", "symap", "ymass", "ymmake", "iemake", "ypav", "ymac", "ynac", "ypask", "yake", "ammax", "symake", "symgr", "yngr", "symac", "ynass", "ymmaz", "symax", "ynagic", "pmake", "ymaxy", "iemaz", "ypazon", "ermat", "symass", "ypgr", "ymmat", "ymgr", "ammask", "ermap", "yax", "ermaz", "ymake", "ymmax", "symav", "ermAX", "iemat", "iemax", "ymmap", "ammazon", "ypac", "pmaxy", "ermax", "pmax", "ypake", "ymmaxy", "iemaxy", "ynake", "ymagic", "yazon", "ymazon", "ypax", "iemap", "ammake", "yask", "ynav", "ymap", "iemav"], "rel_xmin": ["rel_dxmax", "rel_remin", "rel_dxmin", "rel_dxstat", "rel_xpath", "rel_remax", "rel_ypath", "rel_exman", "rel_ystat", "rel_exmin", "rel_dxmins", "rel_exmins", "rel_ymins", "rel_repath", "rel_exmax", "rel_xstat", "rel_xman", "rel_xmins", "rel_expath", "rel_reman", "rel_yman", "rel_exstat"], "rel_ymin": ["rel_mmin", "rel_ysminimum", "rel_mmins", "rel_xonly", "rel_Yminimum", "rel_Ymin", "rel_ysmax", "rel_ymins", "rel_xminimum", "rel_ysmin", "rel_Yonly", "rel_xmins", "rel_Ymax", "rel_yminimum", "rel_mmax", "rel_ysonly", "rel_Ymins", "rel_monly", "rel_yonly"], "rel_xmax": ["rel_oxmin", "rel_latstart", "rel_oxstart", "rel_xmlmax", "rel_ystart", "rel_xax", "rel_yres", "rel_exmin", "rel_yax", "rel_exmax", "rel_exax", "rel_xmlax", "rel_oxshow", "rel_latmax", "rel_oxmax", "rel_xshow", "rel_xmlmin", "rel_xmlres", "rel_yshow", "rel_xres", "rel_latshow", "rel_xstart", "rel_exres", "rel_latmin"], "rel_ymax": ["rel_ymaj", "rel_wyAX", "rel_iemaj", "rel_yyax", "rel_yyAX", "rel_ymask", "rel_iemax", "rel_yax", "rel_yAX", "rel_wyax", "rel_yask", "rel_yaz", "rel_iemaz", "rel_ymmaj", "rel_iemask", "rel_ymaz", "rel_ymmax", "rel_yaj", "rel_yyaj", "rel_ymmask", "rel_ymAX", "rel_yymax", "rel_wyaj", "rel_wymax", "rel_ymmaz"], "P": ["Progress", "J", "B", "M", "SCP", "H", "C", "PS", "Q", "T", "PT", "K", "D", "F", "V", "PF", "IP", "PRE", "Z", "PUT", "TP", "R", "I", "A", "Ps", "PI", "PP", "PO", "PR", "PIN", "Array", "DP", "O", "G", "S", "W", "CP", "Port", "N", "Y", "PU", "L", "E", "U", "X", "p"]}}
{"project": "FFmpeg", "commit_id": "ecb14b8af73b92e5a1be47c119d2f528ff402ebd", "target": 0, "func": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n\n    MpegEncContext * const s = &h->s;\n\n    AVCodecContext * const avctx= s->avctx;\n\n    H264Context *hx; ///< thread context\n\n    int buf_index;\n\n    int context_count;\n\n    int next_avc;\n\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n\n    int nal_index;\n\n\n\n    h->nal_unit_type= 0;\n\n\n\n    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;\n\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n\n        h->current_slice = 0;\n\n        if (!s->first_field)\n\n            s->current_picture_ptr= NULL;\n\n        ff_h264_reset_sei(h);\n\n    }\n\n\n\n    for(;pass <= 1;pass++){\n\n        buf_index = 0;\n\n        context_count = 0;\n\n        next_avc = h->is_avc ? 0 : buf_size;\n\n        nal_index = 0;\n\n    for(;;){\n\n        int consumed;\n\n        int dst_length;\n\n        int bit_length;\n\n        uint8_t *ptr;\n\n        int i, nalsize = 0;\n\n        int err;\n\n\n\n        if(buf_index >= next_avc) {\n\n            if (buf_index >= buf_size - h->nal_length_size) break;\n\n            nalsize = 0;\n\n            for(i = 0; i < h->nal_length_size; i++)\n\n                nalsize = (nalsize << 8) | buf[buf_index++];\n\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n\n                break;\n\n            }\n\n            next_avc= buf_index + nalsize;\n\n        } else {\n\n            // start code prefix search\n\n            for(; buf_index + 3 < next_avc; buf_index++){\n\n                // This should always succeed in the first iteration.\n\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n\n                    break;\n\n            }\n\n\n\n            if(buf_index+3 >= buf_size) break;\n\n\n\n            buf_index+=3;\n\n            if(buf_index >= next_avc) continue;\n\n        }\n\n\n\n        hx = h->thread_context[context_count];\n\n\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n\n        if (ptr==NULL || dst_length < 0){\n\n            return -1;\n\n        }\n\n        i= buf_index + consumed;\n\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n\n        while(dst_length > 0 && ptr[dst_length - 1] == 0)\n\n            dst_length--;\n\n        }\n\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n        }\n\n\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n\n        }\n\n\n\n        buf_index += consumed;\n\n        nal_index++;\n\n\n\n        if(pass == 0) {\n\n            // packets can sometimes contain multiple PPS/SPS\n\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n\n            // if so, when frame threading we can't start the next thread until we've read all of them\n\n            switch (hx->nal_unit_type) {\n\n                case NAL_SPS:\n\n                case NAL_PPS:\n\n                    nals_needed = nal_index;\n\n                    break;\n\n                case NAL_IDR_SLICE:\n\n                case NAL_SLICE:\n\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n\n                    if (!get_ue_golomb(&hx->s.gb))\n\n                        nals_needed = nal_index;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        //FIXME do not discard SEI id\n\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n\n            continue;\n\n\n\n      again:\n\n        err = 0;\n\n        switch(hx->nal_unit_type){\n\n        case NAL_IDR_SLICE:\n\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n\n                return -1;\n\n            }\n\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n\n        case NAL_SLICE:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= &hx->s.gb;\n\n            hx->s.data_partitioning = 0;\n\n\n\n            if((err = decode_slice_header(hx, h)))\n\n               break;\n\n\n\n            if (   h->sei_recovery_frame_cnt >= 0\n\n                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {\n\n                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n\n                                    (1 << h->sps.log2_max_frame_num);\n\n            }\n\n\n\n            s->current_picture_ptr->f.key_frame |=\n\n                    (hx->nal_unit_type == NAL_IDR_SLICE);\n\n\n\n            if (h->recovery_frame == h->frame_num) {\n\n                h->sync |= 1;\n\n                h->recovery_frame = -1;\n\n            }\n\n\n\n            h->sync |= !!s->current_picture_ptr->f.key_frame;\n\n            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);\n\n            s->current_picture_ptr->sync = h->sync;\n\n\n\n            if (h->current_slice == 1) {\n\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n\n                    decode_postinit(h, nal_index >= nals_needed);\n\n                }\n\n\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n\n                    return -1;\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    ff_vdpau_h264_picture_start(s);\n\n            }\n\n\n\n            if(hx->redundant_pic_count==0\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL){\n\n                if(avctx->hwaccel) {\n\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n\n                        return -1;\n\n                }else\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n\n                }else\n\n                    context_count++;\n\n            }\n\n            break;\n\n        case NAL_DPA:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= NULL;\n\n\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n\n                break;\n\n\n\n            hx->s.data_partitioning = 1;\n\n\n\n            break;\n\n        case NAL_DPB:\n\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n\n            hx->intra_gb_ptr= &hx->intra_gb;\n\n            break;\n\n        case NAL_DPC:\n\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n\n               && s->context_initialized\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL)\n\n                context_count++;\n\n            break;\n\n        case NAL_SEI:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_sei(h);\n\n            break;\n\n        case NAL_SPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){\n\n                av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, trying alternative mode\\n\");\n\n                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);\n\n                init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));\n\n                ff_h264_decode_seq_parameter_set(h);\n\n            }\n\n\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n\n                s->low_delay=1;\n\n\n\n            if(avctx->has_b_frames < 2)\n\n                avctx->has_b_frames= !s->low_delay;\n\n            break;\n\n        case NAL_PPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n\n\n            break;\n\n        case NAL_AUD:\n\n        case NAL_END_SEQUENCE:\n\n        case NAL_END_STREAM:\n\n        case NAL_FILLER_DATA:\n\n        case NAL_SPS_EXT:\n\n        case NAL_AUXILIARY_SLICE:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n\n        }\n\n\n\n        if(context_count == h->max_contexts) {\n\n            execute_decode_slices(h, context_count);\n\n            context_count = 0;\n\n        }\n\n\n\n        if (err < 0)\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n\n        else if(err == 1) {\n\n            /* Slice could not be decoded in parallel mode, copy down\n\n             * NAL unit stuff to context 0 and restart. Note that\n\n             * rbsp_buffer is not transferred, but since we no longer\n\n             * run in parallel mode this should not be an issue. */\n\n            h->nal_unit_type = hx->nal_unit_type;\n\n            h->nal_ref_idc   = hx->nal_ref_idc;\n\n            hx = h;\n\n            goto again;\n\n        }\n\n    }\n\n    }\n\n    if(context_count)\n\n        execute_decode_slices(h, context_count);\n\n    return buf_index;\n\n}\n", "idx": 19724, "substitutes": {"h": ["hr", "ih", "f", "ht", "header", "bh", "th", "g", "cache", "host", "hw", "hd", "hh", "H", "c", "rh", "hs", "hal", "q", "eh", "he", "head", "hz", "handle", "r", "hm", "oh", "ah", "dh", "m", "ph", "b", "v", "kh", "k", "ctx", "o", "hl", "history", "x", "html", "http", "w", "hp", "ch", "dev", "comm", "hash", "sh", "j", "p"], "buf": ["proc", "tmp", "window", "cv", "block", "bh", "br", "pkg", "map", "vec", "wb", "fb", "Buff", "func", "mates", "buffer", "cap", "Buffer", "conv", "rb", "bp", "doc", "bag", "np", "img", "cb", "pb", "arr", "cast", "rw", "b", "v", "ctx", "uf", "bn", "bc", "str", "db", "cmd", "ba", "cur", "mem", "seq", "bin", "buff", "bf", "bu", "queue", "batch"], "buf_size": ["buf_content", "bufPSize", " buf2start", " buf_SIZE", "buf_space", "buf_start", "bufixsize", "uf_content", "bufowSIZE", "buf2start", "buf2amount", "uf_Size", "buff_space", "bufixSize", "bufPcache", "buf_amount", " buf_amount", "buf__amount", "buf2SIZE", "bufowsize", "bufPcontent", "bufowamount", "bufixcontent", " buf2size", "buf_Size", "buf__SIZE", "buf__size", "uf_size", "uf_cache", "uf_SIZE", "buf__start", "buf2size", " buf2SIZE", "bufowstart", "buf_SIZE", "uf_index", "buff_SIZE", "bufixcache", " buf_start", "buf_cache", " buf2amount", "buff_size", "bufPsize"], "s": ["ls", "is", "sl", "sts", "th", "sv", "rs", "g", "bits", "as", "ins", "aws", "a", "c", "sq", "settings", "js", "os", "ss", "sc", "conv", "ess", "syn", "vs", "ns", "ims", "sh", "spec", "session", "set", "ms", "ats", "ts", "m", "sys", "its", "d", "sp", "es", "b", "v", "ctx", "n", "his", "utils", "has", "sports", "wcs", "sb", "services", "socket", "stats", "ds", "http", "ses", "S", "gs", "cs", "ps", "t", "fs", "hs", "j", "p"], "avctx": ["avctl", "wavconn", "avercv", "avercfg", " avkt", "avectx", "avtx", "avectl", "avercc", "averkt", "wavcv", " avcp", " avsys", "avejac", "vtx", " avcontext", " avtc", "avkt", " avcu", "averctx", "apcp", "avsys", "apcc", "avcc", "avconn", "averconn", "avecontext", "avcfg", "avjac", " avtx", "avetx", "wavcmp", "avercontext", "avesys", "avecv", "wavcu", "avertx", "avcv", "averjac", "avercp", "aversys", "averctl", "wavctl", " avcmp", "wavcontext", "avcu", "avcmp", "avcontext", "wavctx", "avertc", "wavjac", "wavcfg", "vcmp", "vcontext", "avcp", " avconn", "vctx", "avercu", " avcc", "wavtx", "avtc", "avecfg", "apkt", "avecp", " avjac", "apctx", "avetc"], "hx": ["ihtx", "hxx", "ihx", "thxx", " hxx", "htx", "thx", "ihxx", "thtx", " htx"], "buf_index": ["buff2index", "buf_status", "bufgind", "cache_iterator", "bufxstart", "buf___strength", "uf_open", "uf_no", " buf_ind", "broad_slice", "buf_point", "broad_index", " buf_point", " buf_location", "cache_ind", "uf_count", "buf_start", "uf_start", "buf_Index", "buf___open", "buf_number", "buf_strength", "buf_search", "buf_slice", "buff_iter", "buff2iter", "buf_level", "buff2size", "buf_lock", "broad_address", " buf_level", "cachegind", "buf_iterator", "uf_number", "buf___index", "buf_count", "bufgindex", "buf_no", " buf_status", "uf_size", "buf_num", "uf_strength", "buf___size", "bufgiterator", "broad_search", "cachegindex", "buf2size", "uf_len", "buf_open", "buf_location", " buf_Index", "bufgnum", " buf_iter", "cachegnum", "buf_address", "cache_index", "buf_ind", " buf_lock", "cache_num", "buf2index", "uf_iter", "buf2iter", "buf2count", "uf_index", "buff_index", "cachegiterator", "uf_ind", "buf2ind", "buf_iter", "bufxindex", "bufxnumber", "buff_size", "buf_len"], "context_count": ["context8comment", "context_max", "contextingcount", "context_table", "context64table", "component_count", "context64count", "contextinglength", "context8table", "component_length", "context8child", "component_max", " context64child", "context64comment", "context_child", "contextingCount", "component_Count", "contextingmax", "context8count", " context_table", "context_length", "context_comment", "context64child", " context_comment", "context_Count", " context64count", " context64table", " context64comment", " context_child"], "next_avc": ["next_avecache", "next_avect", "next_wavca", "next_avepc", "next___afca", "next_svf", "next_ovf", "next_afca", "next___afc", "next_aveci", "next_svcu", "next_ovac", "next_wavcache", "next_avef", "next_averca", "next_wavf", "next_cvcs", "next_awcache", "next_svc", "next_avecs", "next_avalbc", "next_avct", "next_avpc", "next_cvpc", "next_avcu", "next_aveca", "next_averf", "next_awct", "next___avc", "next_avcc", "next_wavc", "next_wavcu", "next_avalc", "next_avci", "next_avercc", "next_ovca", "next_ovcs", "next___avac", "next_avcache", "next___afac", "next___avcs", "next_awc", "next_avecc", "next_ovc", "next_afc", "next_avercs", "next_cvc", "next_avec", "next_cvbc", "next_wavac", "next_afcs", "next_averc", "next_wavcs", "next_avf", "next_avebc", "next___afcs", "next_avalcs", "next_wavci", "next___avca", "next_avbc", "next_avca", "next_wavct", "next_afac", "next_avcs", "next_avercu", "next_awci", "next_avalpc", "next_ovcc", "next_svcs", "next_avac"], "nal_index": ["nal__count", "nal_label", "nal_ind", "nal__index", "nalacind", "nal__link", "nal__position", "nale_ind", "nal__key", "nalaclabel", "nalaclink", "nals_count", "nal__label", "nals_key", "nal_count", "nals_index", "nal_link", "nale_label", "nal_position", "nale_index", "nal__ind", "nal_key", "nals_position", "nalacindex", "nale_link"], "pass": ["proc", "gain", "prop", "act", "fl", "run", "push", "fail", "ass", "card", "fall", "allow", "stage", "password", "ret", "mask", "func", "ask", "def", "phase", "access", "pas", "acc", "pos", "pp", "read", "session", "handle", "arg", "PASS", "check", "commit", "scan", "can", "call", "row", "level", "pillar", "pa", "mode", "j", "skip", "through", "strip", "col", "par", "loop", "status", "auth", "process", "conf", "Pass", "step", "p"], "consumed": [" unconsaved", " unconsume", "consaved", " unconsumption", "Consaved", "presumption", "consume", " unconsumed", "Consumed", "presumed", "Consumption", "consumption", "presaved", "Consume", "presume"], "dst_length": ["dst__count", "dst2length", "dst_len", "dest_count", "dst2len", "dest_len", "dst_count", "dest_length", "dst2count", "dst__length", "dst__len"], "bit_length": ["bits_length", "bit64length", "bit2length", "bits_size", "bit2size", "bits_len", "bit_count", "bit_size", "bit64size", "bit2len", "bit64len", "bit2count", "bits_count", "bit64count", "bit_len"], "ptr": ["pad", "length", "attr", "br", "offset", "ref", "ctr", "ind", "vec", "rc", "pointer", "pr", "buffer", "heads", "tr", "src", "enc", "arr", "address", "rev", "ctx", "Ptr", "str", "desc", "cur", "dr", "addr"], "i": ["f", "bi", "gi", "ind", "c", "xi", "ki", "cli", "ai", "MI", "li", "ui", "ic", "ip", "y", "io", "\u0438", "in", "pi", "iu", "qi", "e", "zi", "ci", "wi", "l", "sim", "m", "me", "index", "id", "gu", "b", "v", "I", "ii", "ti", "ei", "phi", "ix", "x", "di", "it", "mi", "hi", "ini", "multi", "j", "si"], "err": ["proc", "extra", "Error", "coord", "cr", "er", "result", "complete", "valid", "func", "or", "diff", "error", "res", "rr", "r", "arr", "errors", "e", "score", "call", "level", "race", "ei", "str", "count", "raw", "rn"]}}
{"project": "FFmpeg", "commit_id": "611b35627488a8d0763e75c25ee0875c5b7987dd", "target": 1, "func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n\n                                const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext *pc = &dctx->pc;\n\n    uint64_t state = pc->state64;\n\n    int pic_found = pc->frame_start_found;\n\n    int i = 0;\n\n\n\n    if (!pic_found) {\n\n        for (i = 0; i < buf_size; i++) {\n\n            state = (state << 8) | buf[i];\n\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n\n                i++;\n\n                pic_found = 1;\n\n                dctx->cur_byte = 0;\n\n                dctx->remaining = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (pic_found && !dctx->remaining) {\n\n        if (!buf_size) /* EOF considered as end of frame */\n\n            return 0;\n\n        for (; i < buf_size; i++) {\n\n            dctx->cur_byte++;\n\n            state = (state << 8) | buf[i];\n\n\n\n            if (dctx->cur_byte == 24) {\n\n                dctx->h = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 26) {\n\n                dctx->w = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 42) {\n\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n\n\n                if (cid <= 0)\n\n                    continue;\n\n\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n\n                if (dctx->remaining <= 0) {\n\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n\n                    if (dctx->remaining <= 0)\n\n                        return dctx->remaining;\n\n                }\n\n                if (buf_size - i + 47 >= dctx->remaining) {\n\n                    int remaining = dctx->remaining;\n\n\n\n                    pc->frame_start_found = 0;\n\n                    pc->state64 = -1;\n\n                    dctx->cur_byte = 0;\n\n                    dctx->remaining = 0;\n\n                    return remaining;\n\n                } else {\n\n                    dctx->remaining -= buf_size;\n\n                }\n\n            }\n\n        }\n\n    } else if (pic_found) {\n\n        if (dctx->remaining > buf_size) {\n\n            dctx->remaining -= buf_size;\n\n        } else {\n\n            int remaining = dctx->remaining;\n\n\n\n            pc->frame_start_found = 0;\n\n            pc->state64 = -1;\n\n            dctx->cur_byte = 0;\n\n            dctx->remaining = 0;\n\n            return remaining;\n\n        }\n\n    }\n\n    pc->frame_start_found = pic_found;\n\n    pc->state64 = state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 19728, "substitutes": {"dctx": ["pdobj", "sdwp", " dtx", "djcontext", "djcp", " dcp", "dresp", "didcmp", "docm", " dcv", "ddork", "dcas", "djcas", "djctx", "xff", " dcmp", "calpkg", " dobj", "def", " dwp", "daork", "dlcomp", " dinst", "dreq", " dbatch", "odcrit", "dloc", "doinst", "dbproc", " dcas", "dcrit", "sdpkg", "donectx", "donecp", "dlcm", " dcpu", "Dcp", "dbtimeout", "delcm", "Djac", "docmp", "dcp", "dcv", "djca", "datimeout", "dowp", "docp", "new", "pdfunc", "ddreq", "ffff", " dloc", "dlctx", "dctr", "_", "dtimeout", "dcontext", "delcontext", "daloc", "ddctx", "Dtx", "ddtx", "delctx", "dacp", "djcss", "modcm", "didctx", "dacontext", "didcp", "doreq", " dcontext", "dlwp", " dork", "dbtx", " dfunc", "dactl", "Dobj", "dcmp", " dgc", "ddcmd", "dlobj", "dcm", "dawp", "didtx", "dinst", "dagc", "didcontext", "datx", "dlloc", "didcomp", "dactx", " dcfg", "dlcontext", "docv", "didpkg", "dbatch", "modcss", "sdctx", "dwp", "dmom", "donecas", "dproc", "didcas", "dlserv", "Dctx", "daobj", "sdcontext", "docontext", " dserv", " dca", " dcm", "calbatch", "odbatch", "donecfg", "doctr", "daca", "dobj", "docss", "didobj", "ddresp", "dserv", "dgc", "daresp", "doctx", "didinst", " dreq", " dcmd", "dpkg", "odpkg", "dofunc", "dbjac", "didwp", "Dcas", "dotx", "dcfg", "calctx", "ddctr", " dctr", "Dcontext", "ddpkg", "didmom", "calcrit", "modctx", "modpkg", "doobj", "djac", "dctl", "Dmom", "dcss", " dcrit", "pdctx", "dacv", " dalloc", "dalloc", " djac", "dbobj", "ddcontext", "dcmd", "donewp", " dctl", "dacss", " dpkg", "dcomp", "dlctl", "delserv", "docpu", "func", "dork", "doalloc", "dopkg", "odctx", "Dpkg", "dacmd", "call", "didcfg", "donetimeout", " dresp", "dbwp", "ddalloc", "pdpkg", "dcpu", "dca", "dbctx", " dcomp", "doneproc", "dfunc", "dactr", " dcss", " dmom", "daproc", "dlgc", "dtx"], "buf": ["proc", "cv", "bb", "block", "br", "bits", "vec", "fb", "bar", "Buff", "batch", "buffer", "cap", "Buffer", "rb", "bp", "obs", "bytes", "doc", "img", "bag", "cb", "pb", "arr", "aka", "cast", "brace", "b", "ctx", "v", "uf", "bc", "late", "cmd", "mem", "msg", "bl", "bin", "buff", "ob", "bf", "pack", "queue", "bs", "que", "p"], "buf_size": ["buf_ize", "cb_SIZE", "buf67Size", "bn_gz", "cb_ize", "buf_range", "bufvalgz", " buf_length", "bn_source", "buf2range", "uf_found", "cb_range", "uf_empty", "bn_loc", "box_Size", " buf_Size", "cb_len", "buf67fee", "buf_length", "bnvalgz", "buf0size", "buf_too", "cb_size", "cb_name", "buf67size", "buf_fee", "buf_Size", "buf_gz", "buf0ize", "uf_size", "bn_size", "bnvalloc", "buf67style", "box_size", "buf_source", " buf_ize", "bufvalsize", "buf2len", "bufswgz", "bufswsource", "box_fee", "bufvalsource", "bnvalsize", "buf2size", "buf_empty", "buf0Size", "uf_too", "buf0length", "bufswloc", "box_style", "buf_name", "buf_SIZE", "buf2Size", "cb_Size", "bufswsize", "buf_style", "buf_found", "bufvalloc", "buf_loc", "bnvalsource", "buf_len"], "pc": ["proc", "px", "lc", "amp", "conn", "pkg", "tp", "cam", "c", "cm", "pac", "fc", "rc", "psc", "mp", "anc", "pr", "mc", "icc", "func", "pointer", "cp", "pan", "gc", "iac", "pi", "pb", "tc", "cu", "lp", "pm", "ac", "nc", "pn", "pt", "wp", "sys", "cc", "ping", "ctx", "pa", "pic", "acl", "bc", "alloc", "vc", "ec", "tk", "lib", "cs", "cmp", "arc", "dc", "pd", "amps", "PC", "p"], "i": ["is", "init", "c", "ip", "ami", "y", " ii", "ims", "qi", "e", "v", "I", "o", "ii", "print", "phi", " ti", "span", "status", " j", "t", "f", " pos", "iter", "ui", "\u0438", "pi", "u", "im", "index", "client", "mi", "multi", "p", "to", " I", "g", "gi", "ind", "ri", "xi", "point", "ki", "ex", "cli", "ai", "li", "io", "go", "load", "iu", " bi", "ci", "my", "l", "sim", "m", "me", "record", "ti", "x", "uri", "try", "ij", "yi", "si", "batch", "bi", "copy", "ia", "ic", "in", "zi", "any", "list", "ji", "b", "ei", "fi", "slice", "ix", "di", "it", "ini", "j", "oi"], "cur_byte": ["cur___bytes", "cur_second", "now_note", "curJbyte", "Cur_Byte", "curJbytes", "Cur_bit", "cur_line", "curjpage", "Cur_page", "curjbyte", "cur5bytes", "curjnote", "cur___page", " cur_Byte", "cur_note", "cur___bit", "now_byte", "Cur_bytes", " cur_element", "cur___Byte", "cur5Byte", "Cur_second", "curJline", "curjbytes", "cur_Byte", "cur5element", "curjByte", "cur_element", "now_page", "Cur_byte", "cur___second", "cur_page", "cur_bit", "Cur_note", "cur_bytes", "cur5byte", "cur___byte", " cur_line", " cur_bytes"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext      *ctx = avctx->priv_data;\n\n    VAAPIEncodeH264Context *priv = ctx->priv_data;\n\n    int hrd_buffer_size;\n\n    int hrd_initial_buffer_fullness;\n\n\n\n    if (avctx->bit_rate > INT32_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Target bitrate of 2^31 bps or \"\n\n               \"higher is not supported.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size)\n\n        hrd_buffer_size = avctx->rc_buffer_size;\n\n    else\n\n        hrd_buffer_size = avctx->bit_rate;\n\n    if (avctx->rc_initial_buffer_occupancy)\n\n        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;\n\n    else\n\n        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;\n\n\n\n    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;\n\n    priv->rc_params.rc = (VAEncMiscParameterRateControl) {\n\n        .bits_per_second   = avctx->bit_rate,\n\n        .target_percentage = 66,\n\n        .window_size       = 1000,\n\n        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),\n\n        .min_qp            = (avctx->qmin >= 0 ? avctx->qmin : 18),\n\n        .basic_unit_size   = 0,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->rc_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->rc_params);\n\n\n\n    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;\n\n    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {\n\n        .initial_buffer_fullness = hrd_initial_buffer_fullness,\n\n        .buffer_size             = hrd_buffer_size,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->hrd_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->hrd_params);\n\n\n\n    // These still need to be  set for pic_init_qp/slice_qp_delta.\n\n    priv->fixed_qp_idr = 26;\n\n    priv->fixed_qp_p   = 26;\n\n    priv->fixed_qp_b   = 26;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\"PRId64\" bps.\\n\",\n\n           avctx->bit_rate);\n\n    return 0;\n\n}\n", "idx": 19759, "substitutes": {"avctx": ["tvctx", "vcfg", "avertxt", "avercall", "wavconf", "aucmp", "vtmp", "abcmp", "avejp", "wavca", " avcp", "averjp", "avset", "abcontext", "wavcpu", "avekw", "averctx", "wavct", "avcfg", "navcmp", "navpkg", "AVtx", " avcall", "navctx", " avcmp", "avconfig", "avcontext", "avct", "vcontext", "avcp", "wavkl", " avcf", "wavconfig", "averpid", "vrtmp", "ajct", " avjac", "avefc", "averobj", "tvjac", "wavconn", "avectx", "wavjp", "abcfg", " avcontext", "navcontext", "navkl", "averfc", "vrcfg", "AVctx", "evtx", "avconn", "averconn", "avjac", "wavcmp", "auctx", "avkl", "wavcontext", " avpkg", "avercomp", "ajcpu", "avcf", "avkw", "savset", "wavcfg", "tvset", "aveconf", "vctx", "vrtx", "avecp", "evcontext", "auct", "savcf", "aveconn", "avtmp", "navfc", "averkl", "vconfig", "navkw", "abctx", "avetx", "avecontext", " avtx", "navtxt", "avtxt", "averca", "navtx", "wavobj", "avpid", "navcomp", "navcall", "evctx", "avfc", "avcpu", "avcmp", "evreq", "wavctx", "avcomp", "avconf", "aucpu", "wavpid", "vpid", "avecfg", " avcfg", "navcfg", "avcall", "navjp", " avobj", "vrreq", "avpkg", " avconfig", "avercfg", "avtx", "AVcfg", "savpkg", "averconf", "avecmp", "avercmp", "avca", "avepid", "vobj", "savjac", "avjp", "navcf", "avertmp", "avekl", "vrctx", "avobj", "vrpid", " avset", " avcomp", "ajctx", "navcp", "ajcmp", "savcomp", " avkw", "tvpkg", "aveobj", "AVjp", "aveca", "avetxt", "savctx", "avreq", " avreq", "vrcontext"], "ctx": ["org", "cv", "init", "wd", "def", "etc", "iat", "jac", "np", "kt", "wp", "mk", "mem", "tz", "cmp", "co", "dc", "cf", "act", "hw", "tx", "xs", "mc", "dt", "cp", "obj", "ns", "cb", "cu", "expr", "context", "alloc", "cmd", "nt", "conf", "tmp", "conn", "pkg", "ind", "iac", "loc", "wx", "tc", "resp", "pt", "kw", "txt", "ct", "acl", "bc", "ctrl", "desc", "pool", "ptr", "fn", "rt", "config", "kl", "td", "fc", "ck", "func", "voc", "xp", "doc", "fx", "gc", "public", "unc", "ac", "rect", "nc", "sys", "call", "cc", "ctl", "xc", "exec", "mint", "pri", "addr"], "priv": ["proc", "Priv", "prop", "rib", "attr", "conn", "pkg", "sec", "tx", "cer", "rc", "good", "pub", "pr", "Pri", "def", "access", "serv", "cp", "etc", "doc", "pi", "pb", "soc", "public", "rel", "expr", "rev", "rw", "sys", "env", "ocr", "alloc", "policy", "riv", "mem", "lib", "exec", "pro", "perm", "private", "nt", "py", "auth", "pri", "ptr", "prov", "dev", "cmp", "conf", "cfg", "admin", "rest"], "hrd_buffer_size": ["hrd_buffer_strength", "hrd_enum_source", "hrd_buffer_name", "hrd_enum_body", "hrd_bufferlenbody", "hrd_Buffer_data", "hrd_window_Size", "hrd_buffer_source", "hrd_block_len", "hrd_Buffer_strength", "hrd_window_max", "hrd_enumlenbody", "hrd_window_size", "hrd_buffer_max", "hrd_Buffer_SIZE", "hrd_block_size", "hrd_Buffer_size", "hrd_buffer_data", "hrd_bufferlensource", "hrd_bufferlenSize", "hrd_buffer_SIZE", "hrd_buffer_body", "hrd_block_Size", "hrd_buffer_len", "hrd_enumlensize", "hrd_buffer_Size", "hrd_window_length", "hrd_window_SIZE", "hrd_enum_size", "hrd_window_name", "hrd_enum_Size", "hrd_enumlensource", "hrd_enumlenSize", "hrd_bufferlensize", "hrd_buffer_length", "hrd_block_name"], "hrd_initial_buffer_fullness": ["hrd_initial_buffer_offness", "hrd_initial_buffer_cleanness", "hrd_initial_buffer_fullivity", "hrd_initial_buffer_fullyly", "hrd_initial_buffer_fullfulness", "hrd_initial_buffer_fullyfulness", "hrd_initial_buffer_fullyliness", "hrd_initial_buffer_fullyness", "hrd_initial_buffer_offity", "hrd_initial_buffer_fulliness", "hrd_initial_buffer_cleanity", "hrd_initial_buffer_fullly", "hrd_initial_buffer_fuliveness", "hrd_initial_buffer_fullyivity", "hrd_initial_buffer_offiveness", "hrd_initial_buffer_fulliveness", "hrd_initial_buffer_broadfulness", "hrd_initial_buffer_fully", "hrd_initial_buffer_fullyiveness", "hrd_initial_buffer_offlength", "hrd_initial_buffer_fullity", "hrd_initial_buffer_fulivity", "hrd_initial_buffer_fullength", "hrd_initial_buffer_broadivity", "hrd_initial_buffer_broadness", "hrd_initial_buffer_fulllength", "hrd_initial_buffer_cleanfulness", "hrd_initial_buffer_fullyity", "hrd_initial_buffer_cleanliness", "hrd_initial_buffer_fullliness", "hrd_initial_buffer_fulfulness", "hrd_initial_buffer_broadly", "hrd_initial_buffer_fulness", "hrd_initial_buffer_fulity", "hrd_initial_buffer_fullylength", "hrd_initial_buffer_broadity"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)\n\n{\n\n\tlong x,y;\n\n\n\n\tdst[0]= src[0];\n\n\n\n\t// first line\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n\n\n        dst+= dstStride;\n\n\n\n\tfor(y=1; y<srcHeight; y++){\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\t\tconst long mmxSize= srcWidth&~15;\n\n\t\tasm volatile(\n\n\t\t\t\"mov %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_a\"), %%mm1\t\\n\\t\"\n\n\t\t\t\"movq 1(%0, %%\"REG_a\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"movq 1(%1, %%\"REG_a\"), %%mm3\t\\n\\t\"\n\n\t\t\t\"movq -1(%0, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movq -1(%1, %%\"REG_a\"), %%mm5\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm5, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm4, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm3, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm2, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\"\n\n#if 1\n\n\t\t\tMOVNTQ\" %%mm5, (%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm4, (%3, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#else\n\n\t\t\t\"movq %%mm5, (%2, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\t\"movq %%mm4, (%3, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#endif\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\t:: \"r\" (src + mmxSize  ), \"r\" (src + srcStride + mmxSize  ),\n\n\t\t\t   \"r\" (dst + mmxSize*2), \"r\" (dst + dstStride + mmxSize*2),\n\n\t\t\t   \"g\" (-mmxSize)\n\n\t\t\t: \"%\"REG_a\n\n\n\n\t\t);\n\n#else\n\n\t\tconst long mmxSize=1;\n\n#endif\n\n\t\tdst[0        ]= (3*src[0] +   src[srcStride])>>2;\n\n\t\tdst[dstStride]= (  src[0] + 3*src[srcStride])>>2;\n\n\n\n\t\tfor(x=mmxSize-1; x<srcWidth-1; x++){\n\n\t\t\tdst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;\n\n\t\t\tdst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;\n\n\t\t}\n\n\t\tdst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;\n\n\t\tdst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;\n\n\n\n\t\tdst+=dstStride*2;\n\n\t\tsrc+=srcStride;\n\n\t}\n\n\n\n\t// last line\n\n#if 1\n\n\tdst[0]= src[0];\n\n\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n#else\n\n\tfor(x=0; x<srcWidth; x++){\n\n\t\tdst[2*x+0]=\n\n\t\tdst[2*x+1]= src[x];\n\n\t}\n\n#endif\n\n\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 19782, "substitutes": {"src": ["sn", "usc", "syn", "np", "inst", "ctx", "http", "RC", "supp", "sel", "sup", "proc", "st", "sw", "sec", "inc", "std", "rx", "sur", "cont", "rb", "dist", "sr", "imp", "secure", "hl", "s", "source", "usr", "input", "tmp", "sl", "length", "ser", "rs", "sq", "ipl", "rl", "size", "comp", "iv", "loc", "txt", "sb", "ctrl", "lb", "desc", "cur", "seq", "ssl", "aux", "ptr", "via", "bs", "rt", "ins", "ctr", "rc", "scale", "sc", "obs", "in", "img", "sync", "sys", "dest", "cc", "str", "sh"], "dst": ["Dest", "nest", "dsc", " dcr", "deput", "sbl", "dput", " dx", " dwp", "dsest", "dv", " dv", "donsts", "dssts", "dsrest", "deport", " dreat", "donst", "Dcr", "dddest", "ddx", "nst", "dsp", "idsts", "sdput", "ddst", " dport", "nsp", "idwp", "idv", "idst", "nsts", "Dsts", "sdest", " dput", "Dst", "dST", "Dsp", "dwp", "dport", "ddbl", " dsp", "sdsts", "deest", "sdst", " ddest", "donv", "Drest", "ddreat", " dest", "ddsc", "Dport", "dsts", " dsts", "sreat", "sdST", "dbl", "dsput", "dsst", "dx", " drest", " dST", "sst", " dsc", "dreat", "drest", "dcr", "Dput", "dest", "Dsc", "dscr", "ddest", "donwp", " dbl", "Dx", "dsST"], "srcWidth": ["hlAmount", " srcSize", "auxH", "stLength", "auxSize", "rcPath", " srcNetwork", "hlWidth", "hlGraph", "srcNetwork", "rcAmount", "srcPath", "stPath", "sourceWidth", "srcLength", " srcLeft", "hlHeight", "auxHeight", "rcSize", "rcGraph", "rcWidth", " srcPath", "rcLength", "rcNetwork", "srcGraph", " srcH", "rsSize", "srcH", "rcLeft", "stHeight", " srcLength", "rsHeight", "srcSize", "srHeight", "srcAmount", "stWidth", "sourceLeft", "srcLeft", "rcH", "rcHeight", "rsNetwork", "srGraph", "sourceHeight", "srWidth", "rsWidth", "auxWidth", "sourceSize", "srAmount"], "srcHeight": ["srcCount", " srcSize", "secureWidth", "secureHeight", "rcTheme", "sourceWidth", "secureTheme", "srcheight", "rcSize", "rcWidth", "secureheight", "rcCount", "srcTheme", "sourceCount", "srcSize", "rcheight", " srcCount", " srcTheme", " srcheight", "rcHeight", "sourceHeight", "sourceSize"], "srcStride": ["srcDestrict", "srcSprat", "srcRestride", "rcStrride", "srcStrrat", "srcSpride", "srcRestrat", "srcSlrict", "rcStrat", "srcRestrip", "srcStrrict", "rcStrrat", "srcSlide", "srcStide", "srcStrrip", "srcDestide", "rcStrrict", "rcStride", "srcRestide", "rcStrict", "srcStrat", "srcStrride", "srcSpide", "rcStide", "srcDestride", "srcSprip", "rcStrip", "rcStrrip", "srcSlrat", "srcStrict", "srcStrip", "srcSlride", "srcDestrat"], "dstStride": ["dndStd", "dndStr", "dndStide", "dndStride", "dstFlrid", "dndStrd", "dsrcStrride", "dstStrr", "dstRestide", "dstRestr", "dstFlide", "dsrcStide", "dstStrd", "dstStr", "dstRestride", "dstStide", "dsrcStrid", "dndStrride", "dstStrride", "dstSlrid", "dstSlide", "dstFlride", "dststide", "dstSlride", "dndStrr", "dsrcStrrid", "dstStd", "dststd", "dsrcStride", "dststride", "dstStrid", "dstRestd", "dststr", "dstStrrid"], "x": ["px", "ax", "column", "xd", "page", "content", "xy", "i", "e", "key", "print", "axis", "inx", "cy", "edit", "yx", "tx", "rx", "path", "el", "index", "full", "w", "X", "step", "ry", "p", "name", "ext", "g", "scroll", "ind", "chain", "xi", "lat", "ex", "wx", "l", "ct", "ux", "on", "dr", "at", "xf", "xx", "batch", "get", "xt", "ox", "dx", "mx", "draw", "xp", "fx", "att", "item", "d", "n", "xe", "xc", "ix", "lex", "t", "z", "j"], "y": ["ny", "ery", "sy", "dy", "yer", "wy", "h", "lat", "yn", "xy", "i", "iy", "ym", "ay", "yl", "ye", "ot", "oy", "ies", "vy", "ya", "yo", "by", "my", "kit", "ey", "m", "pt", "yy", "sys", "b", "yr", "o", "out", "ty", "very", "axy", "yt", "cy", "ly", "py", "uy", "sky", "gy", "try", "Y", "ch", "t", "yi", "j"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 19808, "substitutes": {"ctx": ["cv", "wd", "def", "etc", "iat", "jac", "np", "kt", "work", "mk", "today", "cas", "req", "cmp", "co", "proc", "cf", "act", "gt", "hw", "tx", "std", "ca", "xs", "warn", "cp", "obj", "cb", "cu", "handler", "wcs", "context", "cmd", "nt", "cfg", "p", "tmp", "conn", "pkg", "ind", "push", "cm", "conv", "loc", "wx", "tc", "ka", "resp", "cpu", "kw", "txt", "cl", "ct", "history", "bc", "kb", "prefix", "desc", "x", "cur", "crit", "rt", "ctr", "jp", "kl", "anc", "fc", "abc", "ck", "sc", "xp", "gc", "qt", "nc", "sys", "cc", "gz", "ctl", "xc", "ann"]}}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "substitutes": {"view": ["window", "get", "cell", "block", "virtual", "document", "widget", "View", "service", "VIEW", "display", "manager", "blade", "version", "iew", "eye", "form", "check", "query", "watch", "model", "index", "client", "row", "v", "see", "print", "package", "web", "link", "html", "file", "task", "controller", "views", "tv", "image", "layout", "show", "field"]}}
{"project": "FFmpeg", "commit_id": "2162b862eba5aadb59c0cf7cc304c67f4a5fb946", "target": 1, "func": "static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}", "idx": 19827, "substitutes": {"vlc": ["vrl", "tllc", "vplc", "vlcs", "vrc", "vpl", "volc", "vrp", "vrcs", "vlca", "wllc", "vlsc", "wlcs", "wlp", "vpp", "vpc", "tlc", "volsc", "vll", "tlcs", "wlsc", "tll", "vllc", "VLca", "VLsc", "wlc", "vrlc", "volcs", "vlp", "wlca", "VLc", "tlp", "VLcs", "volca"], "len": ["ls", "sl", "length", "lan", "tl", "en", "Len", "ref", "ind", "vec", "lvl", "kl", "lit", "dl", "le", "nl", "size", "li", "ml", "pen", "del", "syn", "pos", "nn", "fin", "elt", "low", "ll", "spec", "pl", "ell", "enc", "lp", "resp", "rel", "l", "list", "den", "el", "num", "id", "von", "wl", "priv", "hl", "val", "lim", "lon", "link", "mem", "cod", "seq", "ln", "els", "bl", "sym", "lis", "nt", "hi", "lo", "wid", "il", "fn", "cmp", "ld"], "he": [" ge", "het", "cache", "en", "ja", "na", "hene", "hem", "h", "she", "rh", "gre", "hs", "hal", "le", "ile", "te", "ye", "vre", " ke", "hu", "ue", "cal", " ha", "ha", "HE", "e", "cu", "hen", "fle", "phe", "me", "ke", "ma", "che", "He", " pe", "hes", "se", "ithe", "xe", "see", " fe", "ve", " h", "wa", "ale", "ce", "ape", " we", "mem", "pe", "hi", "her", "wen", "we", "sche", "spe", "ense", "co", "ae", "yi", "hy", "aste", "pse"], "codes": ["checks", "rooms", "modules", "cache", "ones", "ints", "rices", "outs", "xs", "pieces", "cells", "cats", "coins", "values", "lines", "cons", "coded", "names", "cases", "icons", "obs", "bytes", "cards", "scripts", "types", "classes", "errors", "ms", "zi", "odes", "boards", "headers", "its", "chains", "fits", "ices", "images", "frames", "tests", "cod", "maps", "files", "flags", "keys", "cs", "phones", "blocks", "items", "rates", "bs", "terms", "cd"], "bits": ["checks", "is", "bit", "bi", "ubs", "outs", "ints", "ins", "jobs", "rs", "ops", "xs", "pieces", "ports", "values", "size", "ads", "lines", "cats", "bool", "heads", "cases", "obs", "bytes", "vs", "units", "pins", "ns", "ris", "rots", "classes", "ms", "rows", "ats", "locks", "its", "issues", "b", "utils", "fits", "parts", "bis", "bars", "s", "orts", "uts", "frames", "cod", "maps", "vals", "bps", "flags", "gs", "keys", "bles", "cs", "phones", "items", "ps", "blocks", "bs"], "syms": ["symns", "tyms", "thecs", "schefs", "tyls", "symn", "tymes", "tyvs", "Syms", "synvs", "sysms", "syvs", "syps", "sycs", "syma", "asyps", "asymes", " syvs", " syps", "thems", "syfs", "synmb", "chemn", "asyma", " symes", " syfs", "Symes", "typs", "tymb", "tyfs", "symcs", "chemb", "chems", "asyms", "synmn", "symms", "sysmes", "synps", "syns", "Syps", "Syfs", " syls", "schecs", "Syvs", "synms", "symb", "sysps", "symes", "chevs", "schems", "thefs", "Syls", "tymn", "synma", "symfs", "syls", "thens", "sysma", "synmes", "schens"], "code": ["close", "component", "ode", "type", "length", "bit", "action", "offset", "cache", "create", "ice", "entry", "result", "reason", "c", "test", "use", "lock", "err", "rc", "le", "size", "buffer", "Code", "error", "byte", "coe", "ue", "go", "u", "e", "check", "ci", "message", "pc", "cycle", "xxx", "value", "zero", "index", "ack", "b", "force", "mode", "be", "out", "key", "xc", "comment", "change", "ce", "data", "count", "x", "next", "rice", "cod", "ie", "command", "try", "ch", "co", "name"], "i": ["us", "is", "init", "you", "isi", "y", "ip", "ami", " ii", "ims", "qi", "v", "I", "o", "PI", "ii", "esi", "print", "phi", " ti", "status", " j", "hi", "t", "ir", "iy", "ui", "\u0438", "pi", "im", "index", "client", "mi", "iso", "iq", "multi", "p", "to", " I", "all", "g", "gi", "ind", "chain", "ri", "xi", "point", "ex", "cli", "ai", "parent", "li", "io", "iu", " bi", "ci", "sim", "m", "me", "ori", "ti", "x", " m", "uri", "ij", "si", "bi", "info", "ity", "ic", "in", " Xi", "zi", "list", "asi", "id", "ji", "ei", "fi", "ix", "di", "it", "ini", "z", "j", "oi"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n", "idx": 19834, "substitutes": {"task": ["new", "proc", "piece", "object", "run", "unt", "result", "that", "trans", "rake", "map", "test", "tx", "tg", "game", "worker", "func", "ask", "asks", "thread", "def", "setup", "net", "util", "master", "target", "associated", "session", "form", "table", "work", "ack", "total", "Task", "course", "cmd", "data", "link", "next", "ran", "think", "bolt", "msg", "it", "node", "command", "nt", "process", "dev", "t", "job"], "obj": ["proc", "org", "tmp", "act", "rt", "ok", "object", "bh", "attr", "ext", "rs", "ref", "bj", "ind", "onet", "err", "ex", "xy", "js", "self", "os", "ot", "rb", "obs", "pos", "inst", "orig", "arr", "sys", "id", "Object", "txt", "ctx", "ct", "o", "out", "obb", "oc", "str", "cmd", "db", "data", "oss", "cod", "tk", "it", "op", "nt", "ob", "typ", "oid", "addr", "og", "od", "t", "Obj", "j", "Ob"], "src": ["url", "rt", "sl", "tmp", "ser", "th", "rs", "st", "ref", "sn", "bj", "SOURCE", "sec", "vr", "sq", "err", "rc", "rl", "sur", "sc", "syn", "rol", "iv", "loc", "inst", "target", "sr", "rel", "scan", "sync", "sys", "dest", "txt", "ctx", "sb", "bc", "s", "str", "data", "ds", "gs", "source", "addr", "usr", "ptr", "fn", "via", "bs", "sup"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int64_t pos;\n\n    int inited_stream_count;\n\n\n\n    nut->avf= s;\n\n    \n\n    av_set_pts_info(s, 60, 1, AV_TIME_BASE);\n\n\n\n    /* main header */\n\n    pos=0;\n\n    for(;;){\n\n        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"no main startcode found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_main_header(nut) >= 0)\n\n            break;\n\n    }\n\n    \n\n    \n\n    s->bit_rate = 0;\n\n\n\n    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);\n\n\n\n    /* stream headers */\n\n    pos=0;\n\n    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){\n\n        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"not all stream headers found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_stream_header(nut) >= 0)\n\n            inited_stream_count++;\n\n    }\n\n\n\n    /* info headers */\n\n    pos=0;\n\n    for(;;){\n\n        uint64_t startcode= find_any_startcode(bc, pos);\n\n        pos= url_ftell(bc);\n\n\n\n        if(startcode==0){\n\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n\n            return -1;\n\n        }else if(startcode == KEYFRAME_STARTCODE){\n\n            url_fseek(bc, -8, SEEK_CUR); //FIXME\n\n            break;\n\n        }else if(startcode != INFO_STARTCODE){\n\n            continue;\n\n        }\n\n\n\n        decode_info_header(nut);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19886, "substitutes": {"s": ["ls", "is", "sts", "g", "rs", "sv", "ins", "sn", "aws", "sw", "south", "a", "c", "h", "sq", "sm", "js", "i", "san", "ants", "os", "ss", "sc", "y", "vs", "ns", "ims", "set", "r", "ms", "als", "ats", "ts", "sys", "its", "sp", "acs", "b", "v", "es", "n", "o", "sports", "sb", "state", "ar", "tools", "stats", "ds", "an", "ses", "qs", "uns", "aus", "S", "gs", "cs", "csv", "ps", "t", "bs", "comm", "fs", "hs", "sa", "j", "p"], "ap": ["amp", "ep", " pars", "AP", " pp", " af", "aps", "mp", "cap", "Ap", "bp", "ip", "pp", "att", " op", " map", "tap", " ip", " mp", "sp", " cp", " sp", " sap", " p", "op", "ps", "tp", " par"], "nut": ["na", "ore", "ano", "or", "np", "cot", "Nut", "mom", "maker", "cut", "nat", "apy", "art", "node", "snap", "six", "sat", "kat", "hog", "knife", "nm", "nr", "ot", "net", "ns", "obj", "our", "ens", "nw", "nir", "cmd", "aunt", "nv", "cens", "nt", "aos", "san", "tmp", "sts", "cooked", "conn", "native", "util", "iv", "orb", "rots", "stab", "feat", "pot", "utt", "nuts", "nor", "gob", "core", "nova", "ocr", "uts", "fn", "demon", "piece", "ox", "hawk", "umb", "critical", "ut", "grain", "ng", "num", "orn", "nas", "tub", "n", "torn", "rot", "capt", "sam"], "bc": ["proc", "clus", "lc", "bb", "bus", "cond", "sec", "c", "kl", "cm", "fc", "rc", "mc", "ic", "sc", "conv", "ml", "bp", "jac", "gc", "BC", "cb", "pb", "unc", "soc", "tc", "ib", "um", "pc", "nc", "sys", "arb", "con", "cc", "broad", "b", "ctx", "cl", "bg", "bec", "sb", "console", "uc", "oc", "db", "gru", "ba", "vc", "asc", "ec", "ob", "bitcoin", "bf", "cs", "snap", "lic", "comm", "cmp", "bs", "exc", "arc", "dc", "bo"], "pos": ["proc", "tmp", "prop", "to", "length", "pat", "offset", "Pos", "slot", "ref", "nos", "neg", "push", "pose", "point", "origin", "pointer", "pr", "port", "position", "def", "os", "size", "comp", "len", "doc", "go", "top", "loc", "pi", "body", "spec", "pl", "resp", "pc", "l", "pid", "pt", "index", "prot", "sp", "off", "client", "Position", "pres", "po", "rot", "POS", "x", "oss", "ds", "on", "no", "pro", "apo", "op", "base", "limit", "at", "snap", "ps", "bs", "conf", "cond", "add", "j", "p"], "inited_stream_count": ["inited_window_Count", "inited_form_Count", "inited_window_count", "inited_stack_count", "inited_streaminglength", "inited_form_count", "inited_streamingCount", "inited_stream_Count", "inited_stream_counter", "inited_form_counter", "inited_stream_length", "inited_stack_call", "inited_window_length", "inited_form_cache", "inited_stream_ct", "inited_field_length", "inited_streamingcount", "inited_window_ct", "inited_field_Count", "inited_stack_Count", "inited_streamingct", "inited_field_count", "inited_stream_cache", "inited_stream_call"]}}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)\n\n{\n\n    int ret;\n\n\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"reinit context\\n\");\n\n\n\n    /* 1. streamoff */\n\n    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);\n\n    if (ret)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"capture VIDIOC_STREAMOFF\\n\");\n\n\n\n    /* 2. unmap the capture buffers (v4l2 and ffmpeg):\n\n     *    we must wait for all references to be released before being allowed\n\n     *    to queue new buffers.\n\n     */\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"waiting for user to release AVBufferRefs\\n\");\n\n    if (atomic_load(&s->refcount))\n\n        while(sem_wait(&s->refsync) == -1 && errno == EINTR);\n\n\n\n    ff_v4l2_context_release(&s->capture);\n\n\n\n    /* 3. get the new capture format */\n\n    ret = ff_v4l2_context_get_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"query the new capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 4. set the capture format */\n\n    ret = ff_v4l2_context_set_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"setting capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 5. complete reinit */\n\n    sem_destroy(&s->refsync);\n\n    sem_init(&s->refsync, 0, 0);\n\n    s->draining = 0;\n\n    s->reinit = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 19889, "substitutes": {"s": ["ls", "is", "sts", "ains", "sv", "rs", "g", "ins", "states", "aws", "changes", "fs", "south", "sw", "ops", "sq", "args", "h", "js", "i", "self", "ants", "os", "params", "ss", "serv", "store", "ies", "vs", "ns", "ims", "events", "obj", "spec", "ags", "ms", "ats", "ts", "sys", "its", "conf", "m", "acs", "b", "v", "ties", "utils", "n", "has", "sb", "tes", "services", "stats", "ds", "qs", "ses", "aus", "S", "ers", "gs", "cs", "ps", "comm", "bs", "als", "details", "hs", "j", "es"], "ret": ["cat", "def", "ben", "det", "RET", "v", "out", "print", "val", "deg", "rm", "sat", "hash", "f", "reg", "gt", "complete", "iter", "lt", "rem", "cont", "dt", "len", "net", "re", "back", " Ret", "ft", "cmd", "fun", "nt", "usr", "mt", "red", "ry", "ber", "ext", "result", "ert", "fin", "del", "elt", "ll", "flag", "resp", "vet", "txt", "cert", "rets", "pret", "rt", "get", "jp", "not", " alt", "tr", "res", "att", "got", "grain", "rev", "Ret", "ter", "value", "backed", "reset", "str", "alt", "it", "il", "t", "details", "j"]}}
{"project": "FFmpeg", "commit_id": "e3123856c79c36507772ada1bcda6cfe36a1e297", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892, "substitutes": {"s": ["ls", "sl", "is", "sts", "g", "rs", "as", "sn", "ins", "scl", "a", "c", "sq", "js", "os", "ss", "sc", "sg", "ns", "spec", "src", "e", "r", "ats", "pc", "ts", "m", "sys", "its", "sp", "es", "b", "v", "ctx", "n", "sb", "ds", "ses", "w", "S", "aus", "gs", "cs", "ps", "t", "bs", "fs", "hs", "p"], "ap": ["ep", "AP", " af", "aps", "mp", "cap", "bp", "pp", "al", "att", "pl", " map", "tap", "ac", " mp", "sp", " cp", "pa", " sp", "ar", " sap", "am", "pro", "op", "ps", " pr", "tp", " par"], "wsvqa": ["hwvaja", "wsvgqua", "wsvvaja", "wsvpaja", "vsviza", "hwvvqa", "vssviza", "wssviza", "wsgovqa", "vsvqua", "wsgovala", "wsvtqua", "wsvpqa", "vsvaja", "wssvaja", "wsvpiza", "wsvaja", "wssvqa", "wsgovaja", "vsvqa", "wsvgqa", "hwvala", "wsvgiza", "hwvqua", "wsgovqua", "wsvvala", "vssvaja", "hwvvqua", "wsvtqa", "hwvqa", "wssvqua", "wsvtaja", "wsvpqua", "wsvqua", "vssvqa", "wsvala", "wsvgaja", "vssvqua", "wsvvqua", "wsvvqa", "wsviza", "hwvvala", "hwvvaja", "wsvtala"], "pb": ["proc", "cv", "bh", "ub", "PB", "pkg", "fp", "jp", "gp", "fb", "td", "mp", "cp", "sc", "rb", "bp", "iat", "np", "pp", "pan", "cb", "pl", "tc", "ib", "lp", "pm", "buf", "iov", "pc", "wp", "pt", "pid", "erb", "sp", "eb", "b", "ctx", "pa", "uf", "vp", "sb", "pg", "lb", "tk", "pro", "typ", "ob", "mb", "snap", "bs", "dp", "tp", "p"], "st": ["rt", "sl", "irst", "put", "ost", "th", "sts", "sum", "tt", "end", "sn", "add", "sw", "so", "chest", "ste", "nd", "std", "td", "stage", "stri", "sta", "store", "cont", "sc", "sth", "mont", "must", "ut", "inst", "bo", "src", "set", "form", "resp", "St", "est", "ts", "pt", "sp", "cl", "ST", "ct", "stack", "ft", "sty", "str", "ast", "et", "bt", "storage", "rd", "status", "art", "ust", "ent", "stan", "stop", "nt", "stat", "stra", "start", "usr", "mt", "stable", "t", "stru", "wt", "rest", "step", "ist"], "header": ["text", "window", "type", "sum", "block", "offset", "cache", "er", "column", "filter", "sample", "init", "peer", "part", "h", "channel", "iter", "content", "tar", "title", "Header", "heading", "tail", "term", "buffer", "drm", "server", "version", "tr", "padding", "len", "byte", "body", "head", "event", "master", "player", "ver", "flag", "cover", "border", "spec", "table", "check", "query", "headers", "writer", "rule", "history", "meta", "layer", "comment", "key", "cmd", "data", "feature", "file", "frame", "dr", "magic", "command", "source", "tag", "HEAD", "tree", "hash", "field", "metadata"], "scratch": ["Scratch", "Scatter", "Scattered", "SCatter", "Screenshot", " Scatter", "scatter", "scattered", "SCattered", " Screenshot", "screenshot", " Scratch", " Scattered", "SCratch", "SCreenshot"], "chunk_tag": ["chunkssize", "chunkscount", "chunkstag", "chunk_count", "chunksnumber", "chunks_number", "chunk_number", "chunks_count", "chunks_tag", "chunks_size"], "chunk_size": ["chump_size", "chunk2name", "chunk_length", "chunk_name", "chunk2size", "chump_name", "chump_length", "chunk2length"]}}
{"project": "FFmpeg", "commit_id": "984add64a41c3296a8a82051cc90bff2eb449609", "target": 1, "func": "int ff_wma_init(AVCodecContext *avctx, int flags2)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n    float bps1, high_freq;\n\n    volatile float bps;\n\n    int sample_rate1;\n\n    int coef_vlc_table;\n\n\n\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n\n        || avctx->channels    <= 0 || avctx->channels    > 2\n\n        || avctx->bit_rate    <= 0)\n\n        return -1;\n\n\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n\n        s->version = 1;\n\n    } else {\n\n        s->version = 2;\n\n\n\n\n    /* compute MDCT block size */\n\n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n\n                                                  s->version, 0);\n\n    s->next_block_len_bits = s->frame_len_bits;\n\n    s->prev_block_len_bits = s->frame_len_bits;\n\n    s->block_len_bits      = s->frame_len_bits;\n\n\n\n    s->frame_len = 1 << s->frame_len_bits;\n\n    if (s->use_variable_block_len) {\n\n        int nb_max, nb;\n\n        nb = ((flags2 >> 3) & 3) + 1;\n\n        if ((avctx->bit_rate / avctx->channels) >= 32000)\n\n            nb += 2;\n\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n\n        if (nb > nb_max)\n\n            nb = nb_max;\n\n        s->nb_block_sizes = nb + 1;\n\n    } else {\n\n        s->nb_block_sizes = 1;\n\n\n\n\n    /* init rate dependent parameters */\n\n    s->use_noise_coding = 1;\n\n    high_freq = avctx->sample_rate * 0.5;\n\n\n\n    /* if version 2, then the rates are normalized */\n\n    sample_rate1 = avctx->sample_rate;\n\n    if (s->version == 2) {\n\n        if (sample_rate1 >= 44100) {\n\n            sample_rate1 = 44100;\n\n        } else if (sample_rate1 >= 22050) {\n\n            sample_rate1 = 22050;\n\n        } else if (sample_rate1 >= 16000) {\n\n            sample_rate1 = 16000;\n\n        } else if (sample_rate1 >= 11025) {\n\n            sample_rate1 = 11025;\n\n        } else if (sample_rate1 >= 8000) {\n\n            sample_rate1 = 8000;\n\n\n\n\n\n    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);\n\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;\n\n\n\n\n\n\n\n    /* compute high frequency value and choose if noise coding should\n\n       be activated */\n\n    bps1 = bps;\n\n    if (avctx->channels == 2)\n\n        bps1 = bps * 1.6;\n\n    if (sample_rate1 == 44100) {\n\n        if (bps1 >= 0.61) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.4;\n\n\n    } else if (sample_rate1 == 22050) {\n\n        if (bps1 >= 1.16) {\n\n            s->use_noise_coding = 0;\n\n        } else if (bps1 >= 0.72) {\n\n            high_freq = high_freq * 0.7;\n\n        } else {\n\n            high_freq = high_freq * 0.6;\n\n\n    } else if (sample_rate1 == 16000) {\n\n        if (bps > 0.5) {\n\n            high_freq = high_freq * 0.5;\n\n        } else {\n\n            high_freq = high_freq * 0.3;\n\n\n    } else if (sample_rate1 == 11025) {\n\n        high_freq = high_freq * 0.7;\n\n    } else if (sample_rate1 == 8000) {\n\n        if (bps <= 0.625) {\n\n            high_freq = high_freq * 0.5;\n\n        } else if (bps > 0.75) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.65;\n\n\n    } else {\n\n        if (bps >= 0.8) {\n\n            high_freq = high_freq * 0.75;\n\n        } else if (bps >= 0.6) {\n\n            high_freq = high_freq * 0.6;\n\n        } else {\n\n            high_freq = high_freq * 0.5;\n\n\n\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n\n            avctx->block_align);\n\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n\n            bps, bps1, high_freq, s->byte_offset_bits);\n\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n\n\n\n    /* compute the scale factor band sizes for each MDCT block size */\n\n    {\n\n        int a, b, pos, lpos, k, block_len, i, j, n;\n\n        const uint8_t *table;\n\n\n\n        if (s->version == 1) {\n\n            s->coefs_start = 3;\n\n        } else {\n\n            s->coefs_start = 0;\n\n\n        for (k = 0; k < s->nb_block_sizes; k++) {\n\n            block_len = s->frame_len >> k;\n\n\n\n            if (s->version == 1) {\n\n                lpos = 0;\n\n                for (i = 0; i < 25; i++) {\n\n                    a = ff_wma_critical_freqs[i];\n\n                    b = avctx->sample_rate;\n\n                    pos = ((block_len * 2 * a) + (b >> 1)) / b;\n\n                    if (pos > block_len)\n\n                        pos = block_len;\n\n                    s->exponent_bands[0][i] = pos - lpos;\n\n                    if (pos >= block_len) {\n\n                        i++;\n\n                        break;\n\n\n                    lpos = pos;\n\n\n                s->exponent_sizes[0] = i;\n\n            } else {\n\n                /* hardcoded tables */\n\n                table = NULL;\n\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n\n                if (a < 3) {\n\n                    if (avctx->sample_rate >= 44100) {\n\n                        table = exponent_band_44100[a];\n\n                    } else if (avctx->sample_rate >= 32000) {\n\n                        table = exponent_band_32000[a];\n\n                    } else if (avctx->sample_rate >= 22050) {\n\n                        table = exponent_band_22050[a];\n\n\n\n                if (table) {\n\n                    n = *table++;\n\n                    for (i = 0; i < n; i++)\n\n                        s->exponent_bands[k][i] = table[i];\n\n                    s->exponent_sizes[k] = n;\n\n                } else {\n\n                    j = 0;\n\n                    lpos = 0;\n\n                    for (i = 0; i < 25; i++) {\n\n                        a = ff_wma_critical_freqs[i];\n\n                        b = avctx->sample_rate;\n\n                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);\n\n                        pos <<= 2;\n\n                        if (pos > block_len)\n\n                            pos = block_len;\n\n                        if (pos > lpos)\n\n                            s->exponent_bands[k][j++] = pos - lpos;\n\n                        if (pos >= block_len)\n\n                            break;\n\n                        lpos = pos;\n\n\n                    s->exponent_sizes[k] = j;\n\n\n\n\n\n            /* max number of coefs */\n\n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;\n\n            /* high freq computation */\n\n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /\n\n                                          avctx->sample_rate + 0.5);\n\n            n = s->exponent_sizes[k];\n\n            j = 0;\n\n            pos = 0;\n\n            for (i = 0; i < n; i++) {\n\n                int start, end;\n\n                start = pos;\n\n                pos += s->exponent_bands[k][i];\n\n                end = pos;\n\n                if (start < s->high_band_start[k])\n\n                    start = s->high_band_start[k];\n\n                if (end > s->coefs_end[k])\n\n                    end = s->coefs_end[k];\n\n                if (end > start)\n\n                    s->exponent_high_bands[k][j++] = end - start;\n\n\n            s->exponent_high_sizes[k] = j;\n\n#if 0\n\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n\n                    s->frame_len >> k,\n\n                    s->coefs_end[k],\n\n                    s->high_band_start[k],\n\n                    s->exponent_high_sizes[k]);\n\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n#endif\n\n\n\n\n\n#ifdef TRACE\n\n    {\n\n        int i, j;\n\n        for (i = 0; i < s->nb_block_sizes; i++) {\n\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n\n                    s->frame_len >> i,\n\n                    s->exponent_sizes[i]);\n\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n\n\n#endif\n\n\n\n    /* init MDCT windows : simple sinus window */\n\n    for (i = 0; i < s->nb_block_sizes; i++) {\n\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n", "idx": 19908, "substitutes": {"avctx": ["avaddr", "avgc", "avctl", "wavconf", "avectl", "navjac", "abcontext", " avcu", "avkt", "averctx", "aveaddr", "afcmp", "avcfg", "ajconfig", "ajcontext", "wavaddr", "navctx", "afcontext", " avcmp", "avhandle", "avconfig", "ajcu", "avcontext", " avctl", "navgc", "avercmd", "avecb", "averhandle", "avcp", "wavkl", " avconn", " avgc", " avjac", "averobj", "wavconn", "avercv", " avkt", "avectx", " avcontext", "averconfig", "avcb", "avconn", "averconn", "avjac", "wavgc", "avcv", "avkl", "wavcontext", " avpkg", "vercontext", "abtx", "vrcb", "wavcfg", "avereq", "averreq", " avcv", "avercu", "verctx", "vrtx", "avehandle", "avcmd", "avecp", "afcv", "wavcp", "avergc", "averaddr", "aveconn", "aftx", "averkl", "abctx", "avetx", "avecontext", " avtx", "afkt", "vertx", "avercontext", "avecu", "navconn", " avhandle", "avcu", "avcmp", "wavctx", "avconf", " avconf", "vercfg", "wavpkg", "avecfg", " avcfg", "ajcmd", "afctx", "avegc", " avobj", "avpkg", " avconfig", "avercfg", "avtx", " avcb", "averconf", "avejac", "avercmp", " avcmd", "avertx", "avercp", "ajconn", "aveconfig", "avekl", "vrctx", "avobj", "abctl", "ajctx", "ajcmp", "avekt", "ajgc", "aveobj", "wavtx", "avepkg", "avreq", " avreq", "vrcontext"], "flags2": ["Flags4", "flag1", "ags3", "flags02", "Flags02", "flags0", "options1", "flags1", "options02", "Flags2", "flag4", " flags3", " flags0", "Flags1", "options4", "flags3", "Flags0", " flags1", "Flags3", "ags1", "flag2", "flag02", "ags0", "flags4", "options2", "ags2"], "s": ["is", "sn", "states", "fs", "h", "sm", "js", "y", "vs", "ims", "ags", "utils", "stats", "qs", "ses", "less", "comments", "als", "terms", "eps", "aws", "sw", "ports", "ss", "https", "ns", "sd", "spec", "ms", "bis", "sports", "services", "S", "results", "cs", "hs", "sts", "g", "rs", "ops", "sq", "ex", "self", "os", "set", "pers", "l", "m", "sb", "ar", "ssl", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "so", "scripts", "ats", "sync", "ts", "sys", "its", "se", "ds", "ps", "details", "z", "es"], "i": ["bi", "c", "ki", "li", "ip", "io", "iat", "pi", "iu", "e", " bi", "ci", "l", "m", "ati", "v", "I", "ii", "ti", "fi", "phi", "mi", "t", "multi", "si", "p"], "bps1": [" rates2", "bps2", "bits0", "bits1", "rates0", "rates2", " rates0", "rates1", "bits2", "bps0", " rates1"], "high_freq": ["high_freQ", "high_freeqs", "high_preQ", "high_freeq", "high_freck", "high_preq", "high_preqs", "high_Frereq", "high_Freq", "high_frereq", "high_Freqs", "high_Freck", "high_freqs", "high_preck", "high_FreQ", "high_freereq"], "bps": ["ls", "bits", "eps", "ops", "steps", "aps", "ips", "params", "pps", "bp", "bytes", "abytes", "ns", "pb", "fps", "bis", "gb", "stats", "points", "maps", "vals", "ps", "rates", "bs", "amps", "p"], "sample_rate1": ["sample_rat2", "sample_iterator100", "sample_rate3", "sample_rates1", "sample_range0", "sample_time3", "sample_range1", "sample_index100", "sample_rates100", "sample_rate101", "sample_rates01", "sample_rate0", "sample_delayU", "sample_ratesU", "sample_rangeU", "sample_index1", "sample_delay0", "sample_rate01", "sample_rate100", "sample_iterator101", "sample_time01", "sample_rates3", "sample_rateU", "sample_rat101", "sample67rate100", "sample67rat100", "sample67rate1", "sample_index2", "sample67rate101", "sample_time1", "sample_rates0", "sample67rat2", "sample_delay2", "sample67rate2", "sample_rate2", "sample_time2", "sample_rat100", "sample67rat1", "sample_range100", "sample_index0", "sample_rates101", "sample67rat101", "sample_iterator1", "sample_rates2", "sample_delay1", "sample_range2", "sample_rat1", "sample_iterator2"], "coef_vlc_table": ["coef_vlac_table", "coef_vlc2table", "coef_vlc_size", "coef_vlac_db", "coef_vlac_data", "coef_vlc_data", "coef_vlc_db", "coef_vlac_size", "coef_vlc2data", "coef_vlc2db", "coef_vlc2size"], "nb_max": ["nb_top", "NB_major", "nbPmod", "nbmymod", "binarymyfinal", "binary_max", "nb2top", "nbPfinal", "NB_min", "nb_box", "nblmaximum", "nb_range", "NB2top", "binarymyexp", "nb_med", "nb2max", "nbmyexp", "nb67min", "binary_mod", "NB_top", "binarymymod", "nb7min", "nb7MAX", "nb_major", "nbmyfinal", "ni_max", "binary_exp", "NB2max", "cb_MAX", "NB_max", "cb_min", "cb_med", "nb_final", "nbmymax", "binarymymax", "nb_MAX", "nbPexp", "nb67major", "nb7max", "nb67top", "nblmax", "nb2major", "nb7med", "ni_maximum", "nb_exp", "nb_maximum", "NB2min", "nb_mod", "ni_range", "nbPmax", "nblbox", "ni_box", "cb_max", "NB2major", "nblrange", "nb67max", "binary_final", "nb_min", "nb2min"], "nb": [" neb", "fine", "bb", "ne", "bits", "bi", "nm", "tn", "bj", "conn", "cn", "nr", "NB", "nd", "wb", "NR", "cli", " nu", "obj", "rb", "nn", "np", "body", "nob", "cb", "pb", "zb", "oat", "ns", "ni", "ib", "note", "aff", "qq", "nc", "num", "eb", "bn", "nz", "nu", "sb", "obb", "mk", "kb", " numb", "db", "gb", "gov", "uj", "count", "cmd", "phys", "nv", "number", "usb", "nt", "ob", "buff", "try", "iq", "bs", "nom", "batch"]}}
{"project": "FFmpeg", "commit_id": "12dea8a5a15343e9c404376c40ca8a1cc9d1479e", "target": 1, "func": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}", "idx": 19912, "substitutes": {"avctx": ["Avctx", "Avcmd", "avtx", "awctx", "Avtx", "vtx", " avcontext", "AVctx", " avtx", " avcmd", "AVcontext", "AVcmp", "AVtx", "vcmd", " avcmp", "awtx", "avcmp", "avcontext", "awcmp", "vcontext", "vctx", "awcontext", "avcmd", "Avcontext"], "ctx": ["crit", "cf", "act", "cv", "lc", "window", "conn", "ctr", "pkg", "hw", "jp", "tx", "ca", "cm", "td", "ia", "ck", "def", "cp", "ork", "iat", "jac", "np", "xp", "qt", "kt", "loc", "gc", "cb", "obj", "tc", "ka", "check", "resp", "nc", "index", "kw", "cc", "txt", "cl", "ct", "ctl", "history", "wcs", "xc", "context", "kb", "cmd", "ctrl", "prefix", "desc", "req", "ann", "nt", "aux", "tz", "cmp", "conf", "cfg"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n", "idx": 19916, "substitutes": {"nd": ["nb", "fd", "bb", "rend", "ne", "gd", "xd", "ind", "hd", "decl", "bd", "vd", "dn", "std", "td", "lf", "ck", "rest", "wn", "nn", "np", "dk", "ns", "ND", "sd", "inst", "ng", "det", "nc", "d", "ined", "nda", "ord", "und", "n", "hn", "dd", "md", "cmd", "wind", "nv", "odd", "ds", "pard", "ln", "ent", "nt", "buff", "news", "isd", "od", "rd", "ld", "rn", "pd", "cd"], "models": ["ls", "codes", "pages", "modules", "relations", "guards", "jobs", "states", "los", "lists", "fixes", "ages", "mas", "versions", "xs", "users", "limits", "reports", "settings", "videos", "values", "links", "lines", "names", "params", "suits", "ies", "obs", " Models", "pins", "ims", "mails", "types", "classes", "ms", "fit", "ids", "forms", "model", "headers", "mins", "chains", "members", "eas", "hips", "mods", "fits", "sql", "images", "projects", "ians", "devices", "lim", "mes", "views", "bots", "groups", "maps", "qs", "mem", "els", "files", "mys", "gs", "apps", "gets", "boxes", "seconds", "items", "flows", "es"], "default_model": ["Default_Model", "default___data", "default___models", "default_name", "default_data", "default___label", "default_Model", "Default_label", "default_models", "default___model", "default___name", "Default_data", "Default_name", "default___Model", "Default_model", "default_label", "Default_models"], "i": ["is", "c", "ip", "y", "ami", " ii", "ims", "qi", "I", "ii", "key", "phi", " ti", "uni", "status", " j", "hi", " ki", "f", "cgi", "iter", "ui", "\u0438", "pi", "im", "ms", "index", " pi", "client", " wi", "mi", "iso", "iq", "multi", "p", "to", "g", "gi", "ind", "chain", "xi", "point", "ki", "ri", "cli", "ai", "li", "io", "go", "iu", " bi", "ci", "my", "sim", "m", "me", "ti", "x", " m", "uri", " si", "ij", "ski", "si", "bi", "jp", " mi", "ic", "in", "remote", "zi", "list", "ji", "id", "gu", "n", " c", "ei", "fi", "ix", "di", " ni", "it", "ini", "j", "oi"]}}
{"project": "qemu", "commit_id": "8103b4d161d7c00ea3ff89ffe66bb2bc2c67de5d", "target": 0, "func": "static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n", "idx": 19927, "substitutes": {"opaque": ["ropaques", "oposter", "oplay", "opllay", "paque", "opacle", "opposter", "ropacle", " opacle", "oplaque", "oppca", "oploster", " opaques", "opplay", "ropula", "pacle", " opula", "oppaque", "ropaque", "paques", "oplca", " oposter", " opca", "opula", "opca", " oplay", "pula", "opaques"], "vector": [" sensor", " vec", " keyword", "ser", "random", "gradient", "counter", "phrase", "NV", "vec", "clock", "document", "password", "product", "term", "seed", "buffer", " v", " matrix", "version", "padding", " Vector", "spec", "sequence", "message", "ctors", "value", "series", "zero", "v", "template", "inventory", "Vector", "description", "translation", "material", "number", "transform", " vectors", "serial", "command", "token", "hello", "response", "normal"], "dev": ["proc", "pad", "Dev", "end", "conn", "cam", "ind", " device", "develop", "des", "ad", "def", "serv", "tr", "device", "ver", "spec", "det", "dem", "sys", "van", "d", "local", "v", "var", "ev", "app", "val", "md", " vo", "cmd", "DEV", "cand", "de", "mem", "w", "vo", "av", "nt", "ptr", " devs"]}}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 19962, "substitutes": {"cfg": ["org", "cf", "cgi", "config", "qa", "ext", "gt", "ctr", "init", "fig", "nav", "gp", "cli", "def", "urg", "mg", "forge", "etc", "ns", "qt", "cb", "orig", "fg", "gz", "eas", "eg", "bg", "priv", "alg", "cmd", "gov", "gb", "desc", "cand", "oga", "compl", "gran", "gg", "deg", "exec", "gs", "og", "adj", "comm", "conf", "nom"], "errp": ["erpress", "rrp", "erpkg", " erP", "erpb", " errpkg", "err", "rrpb", " errP", " erpkg", "errpress", "verP", " erp", "verp", "errpb", "ferpb", " err", "errpp", "erpp", "ferp", "verr", "erP", "ferP", "errP", "rrP", " errpp", "verpp", "rrpress", "erp", "errpkg", "ferpress", "errr", " errr"]}}
{"project": "FFmpeg", "commit_id": "101ef19ef4dc9f5c3d536aee8fcc10fff2af4d9e", "target": 1, "func": "static void decode_block(BinkAudioContext *s, short *out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = s->coeffs_ptr[ch];\n\n        if (s->version_b) {\n\n            coeffs[0] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n        } else {\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            /* constant is result of 0.066399999/log10(M_E) */\n\n            int value = get_bits(gb, 8);\n\n            quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root;\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else if (get_bits1(gb)) {\n\n                j = i + rle_length_tab[get_bits(gb, 4)] * 8;\n\n            } else {\n\n                j = i + 8;\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            width = get_bits(gb, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    coeff = get_bits(gb, width);\n\n                    if (coeff) {\n\n                        if (get_bits1(gb))\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n            s->dsp.vector_fmul_scalar(coeffs, coeffs, s->frame_len / 2, s->frame_len);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n\n                                          s->frame_len, s->channels);\n\n\n\n    if (!s->first) {\n\n        int count = s->overlap_len * s->channels;\n\n        int shift = av_log2(count);\n\n        for (i = 0; i < count; i++) {\n\n            out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n\n        }\n\n    }\n\n\n\n    memcpy(s->previous, out + s->block_size,\n\n           s->overlap_len * s->channels * sizeof(*out));\n\n\n\n    s->first = 0;\n\n}\n", "idx": 19965, "substitutes": {"s": ["f", "ls", "is", "sts", "ains", "g", "rs", "sv", "er", "ins", "as", "aws", "sw", "fs", "a", "c", "sq", "ops", "h", "ex", "settings", "js", "ants", "os", "ss", "sg", "vs", "details", "ns", "ims", "spec", "e", "r", "ms", "ats", "series", "ts", "m", "its", "sys", "conf", "es", "b", "sim", "n", "o", "parts", "se", "space", "sports", "sb", "stats", "ds", "qs", "ses", "less", "span", "S", "gs", "results", "cs", "ps", "t", "bs", "als", "comm", "hs", "p"], "out": ["new", "to", "tmp", "outs", "result", "c", "Out", "buffer", "os", "ot", "conv", "ou", "y", "in", "io", "res", "img", "arr", "buf", "m", "v", "n", "o", "output", "w", "t", "p"], "use_dct": ["use_Dpt", "use_fot", "use_dCT", "use_duct", "use2duct", "use2Duct", "use_sdCT", "use_dpt", "use2dpt", "use_fuct", "use_fpt", "use2dCT", "use_dot", "use2dct", "use_fCT", "use2Dpt", "use_sduct", "use2DCT", "use_Dct", "use_sdct", "use_Duct", "use_sdot", "use_fct", "use_Dot", "use2Dct", "use_DCT"], "ch": ["ble", "ih", "th", "ht", "cho", "ach", "br", "ind", "h", "channel", "c", "cht", "ca", "qu", "och", " Ch", "chart", "chip", "ot", "cp", "sc", "y", "chn", "sk", "p", "cb", "att", "ech", "height", "l", "Ch", "ich", "b", "v", "kh", "chrom", "code", "hl", "mk", "chron", "x", "count", "tch", "col", "cha", "ek", "chan", "zh", "cs", "sch", "CH", "sh", "z", "cd", "batch"], "i": ["is", "ik", "c", "h", "y", "ami", "ip", "qi", "iii", "e", "v", "I", "o", "ii", "phi", "status", "hi", "api", "f", "ui", "\u0438", "pi", "u", "im", "index", "w", "mi", "ie", "multi", "p", "length", "g", "gi", "ind", "ri", "xi", "ki", "ai", "li", "io", "iu", "um", "ci", "my", "l", "m", "ti", "x", "uri", "try", "ij", "si", "bi", "info", "ia", "ic", "in", "zi", "height", "id", "ji", "b", "n", "ei", "ix", "di", "it", "ini", "z"], "j": ["f", "jl", "jump", "J", "br", "g", "bi", "ja", "jp", "h", "jc", "js", "json", "kj", "fr", "y", "jj", "jac", "obj", "aj", "r", "height", "l", "m", "ji", "index", "b", "v", "dj", "n", "o", "row", "uj", "jit", "it", "w", "ij", "adj", "z", "si", "p"], "k": ["ikk", "kr", "ku", "ok", "ks", "ik", "kick", "ak", "g", "ind", "ijk", "c", "kl", "uk", "ki", "ck", "kj", "ask", "K", "y", "sk", "unk", "kind", "u", "ark", "ka", "kit", "ke", "m", "id", "index", "kw", "b", "kh", "km", "n", "v", "o", "kid", "key", "mk", "isk", "ek", "kk", "tk", "w", "ko", "z", "p"], "q": ["f", " req", "qa", "g", " z", "c", "sq", "h", "qu", "Q", " sq", " qual", "dq", "requ", "y", "ue", "pp", "qt", "aq", "qq", "qi", "u", "ll", "quality", "query", "m", "qv", " query", "v", "weight", "x", "req", "charge", "qs", "w", " qu", "it", "iq", " crit", "t", "qual", "z", "p"], "quant": ["final", "percent", "important", "mult", "recent", "qu", "temp", "good", "pick", "valid", "liquid", "press", "tight", "requ", "frac", "shock", "mont", "specific", "critical", "util", "debug", "qq", "patch", "deep", "quiet", "integer", "different", "vol", "pdf", "mot", "complex", "stock", "neutral", "local", " Quant", "var", "secure", "finals", "total", "windows", "count", "stats", "quad", "material", "uint", "ent", "private", "nt", "buff", "quick", "details", "qual", "nice", "Quant", "quart"], "coeff": ["COefficient", "foff", "coeffic", " coff", "Coff", "foeff", "loeffic", " coact", "coff", "coef", "Coeff", "Coefficient", "COef", "foef", "coact", "loefficient", "COff", "Coef", " coefficient", " coeffic", "loef", "Coeffic", "foact", " coef", "COeff", "COact", "coefficient", "loeff"], "gb": ["nb", "bb", "cv", "binary", "attr", "g", "gt", "gd", "GB", "tg", "vg", "wb", "fb", "xy", "td", "rb", "rg", "sg", "io", "img", "gc", "large", "cb", "pb", "phy", "ib", "fg", "gif", "yg", "rect", "erb", "sys", "eb", "b", "gz", "eg", "bg", "uf", "Gb", "gnu", "hub", "sb", "gm", "kb", "db", "pg", "html", "bt", "storage", "goo", "gg", "deg", "py", "gs", "bm", "bf", "csv", "mb", "og", "ruby", "bs", "cfg", "hog", "gh", "jpg"], "coeffs": ["coefficients_", "coaffis", "coefficientjs", " coeffsys", "coefficientts", " coff_", "coeff_", "coneffs", "coffts", "coffsys", "coefids", "conefficientjs", " coffjs", "coffjs", "coeffsys", "coefes", "coefficientids", "coactts", "coefficientis", "coefficids", "coefficientses", "conefficientss", "coffcs", "conefficientids", "coaffts", "coefficients", "coeffrates", "coffis", "coactsys", "coffls", "coff_", "coneffjs", "coefrates", "coefficientsjs", "coefficls", " coefficientis", "coefficientss", "coefficientrates", "conefficientes", " coeffcs", "coeffices", " coeffts", " coefficientjs", "coaffs", "coaffcs", "coffs", " coffs", " coefficientls", "coneffss", "coeffss", " coeffjs", " coeff_", "coeffls", "coefjs", "coefficss", " coefficientrates", "coneffids", "coeffics", "coefls", "coaffsys", "coeffcs", "coeffts", "coefs", "coef_", "coefficrates", "coacts", "coefficientls", " coffcs", " coeffrates", "coeffes", "coneffes", "coefficientes", "conefficients", "coefts", "coaffjs", "coeffids", " coefficients", "coeffis", " coffts", "coefficjs", " coeffls", "coeffjs", "coefficientsss", " coffsys", " coeffis", "coactcs"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n\n                                 const uint8_t *buf, int size, int64_t pts)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    AVStream *st = ctx->streams[stream_index];\n\n    StreamInfo *stream = st->priv_data;\n\n    int64_t dts;\n\n    int len;\n\n\n\n    /* XXX: system clock should be computed precisely, especially for\n\n       CBR case. The current mode gives at least something coherent */\n\n    if (stream_index == s->scr_stream_index)\n\n        s->last_scr = pts;\n\n    \n\n#if 0\n\n    printf(\"%d: pts=%0.3f scr=%0.3f\\n\", \n\n           stream_index, pts / 90000.0, s->last_scr / 90000.0);\n\n#endif\n\n    \n\n    /* XXX: currently no way to pass dts, will change soon */\n\n    dts = AV_NOPTS_VALUE;\n\n\n\n    /* we assume here that pts != AV_NOPTS_VALUE */\n\n    if (stream->start_pts == AV_NOPTS_VALUE) {\n\n        stream->start_pts = pts;\n\n        stream->start_dts = dts;\n\n    }\n\n    while (size > 0) {\n\n        len = s->packet_data_max_size - stream->buffer_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n\n        stream->buffer_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        while (stream->buffer_ptr >= s->packet_data_max_size) {\n\n            /* output the packet */\n\n            flush_packet(ctx, stream_index,\n\n                         stream->start_pts, stream->start_dts, s->last_scr);\n\n            /* Make sure only the FIRST pes packet for this frame has\n\n               a timestamp */\n\n            stream->start_pts = AV_NOPTS_VALUE;\n\n            stream->start_dts = AV_NOPTS_VALUE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 19976, "substitutes": {"ctx": ["tmp", "cf", "act", "cv", "bh", "conn", "Context", "hw", "pkg", "ind", "cn", "jp", "cam", "tx", "c", "ca", "xs", "cm", "anc", "hs", "js", "ck", "mc", "cont", "params", "cp", "sc", "conv", "setup", "etc", "iat", "np", "ns", "gc", "kt", "cb", "wx", "tc", "cu", "nc", "cc", "kw", "kh", "ct", "ctl", " cx", "bc", "xc", "context", "mk", "cmd", "x", "req", "aus", "addr", "comm", "cmp", "cfg", "dc", "p"], "stream_index": ["stream_num", "server_handle", "stream_alias", "server_ind", " stream_num", " stream_alias", " stream_number", "stream_location", "server_number", " stream_slice", "stream_handle", " stream_ticket", "stream_ticket", " stream_Index", " stream_ind", "stream_Index", "stream_number", "stream_no", "server_index", " stream_location", "stream_ind", "stream_slice", " stream_no"], "buf": ["tmp", "text", "ff", "cv", "length", "block", " buffer", "br", "offset", "ref", "result", "vec", "wb", "fb", "bar", "Buff", "xff", "buffer", "cap", "Buffer", "rb", "bytes", "pos", "img", "cb", "pb", "orig", "src", "arr", "ered", "b", "v", "uf", "code", "bc", "str", "cmd", "data", "cur", "mem", "seq", "msg", "buff", "ob", "addr", "ptr", "queue", "batch"], "size": ["length", "sum", "zone", "type", "offset", "ose", "g", "year", "cache", "sample", "south", "fee", "args", "settings", "sent", "buffer", "shape", "SIZE", "dim", "scale", "padding", "ize", "bytes", "too", "body", "pos", "max", "height", "message", "small", "l", "any", "m", "num", "now", "zero", "ms", "sp", "gz", "n", "time", "space", "total", "Size", "send", "since", "empty", "full", "count", "capacity", "equal", "storage", "number", "msg", "izes", "needed", "range", "name"], "pts": ["ctis", "ptts", "porttes", "txtes", "pkgts", "tellsd", "cmdtes", "txs", "ptsets", "reqts", "portsets", "cmdsets", "cmds", "PTis", "ctts", "ports", "pkgs", "portts", "pkgt", "txts", "txsets", "Ptrs", "cmdts", "reqs", "ctt", "colts", "cols", "ptS", "pttes", " ptl", "ctss", "ptsd", "cts", "PTts", "telll", "tellS", "Ptrl", "reqxs", "ptis", "PtrS", "ptss", "pkgxs", " ptsd", "ctxs", "tells", "colss", "PTs", "reqt", "Ptrsd", " ptS", "ptt", "ptl", "ptxs", "colis", "PTss"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "sn", "scl", "sw", "so", "tx", "c", "sq", "sm", "xs", "js", "service", "ss", "sc", "ess", "vs", "ns", "ims", "sh", "sd", "spec", "set", "src", "scripts", "ms", "ats", "ts", "sys", "sp", "se", "sb", "str", "sid", "stats", "ds", "qs", "less", "ses", "S", "sam", "ssl", "gs", "cs", "sa", "ps", "t", "bs", "comm", "fs", "hs", "p"], "st": ["sl", "irst", "ost", "th", "sts", "tt", "sv", "sn", "sw", "so", "ste", "nd", "std", "sm", "sta", "ss", "sc", "ess", "tr", "sk", "ut", "inst", "src", "St", "est", "ts", "sp", "ST", "se", "stack", "str", "ust", "start", "mt", "t", "sh", "z", "ist"], "stream": ["present", "component", "cache", "stage", "iterator", "track", "store", "event", "table", "query", "message", "check", "v", "stack", "o", "time", "send", "REAM", "stats", "http", "status", "transform", "download", "ost", "mount", "sw", "test", "ste", "then", "inner", "style", "our", "spec", "row", "console", "wrapper", "context", "loop", "source", "dev", "metadata", "sl", "window", "hook", "length", "th", "header", "host", "chain", "peer", "channel", "post", "pipe", "port", "buffer", "iv", "engine", "driver", "enc", "poll", "pod", "ack", "pool", "view", "ssl", "image", "filter", "video", "Stream", "info", "draw", "thread", "server", "tr", "unk", "public", "ver", "reader", "rel", "form", "sync", "list", "writer", "dd", "str", "ream", "data", "upload", "sam", "response"], "dts": ["ddts", "fdTS", "gduts", "Dts", "pdps", "fduts", "gdTS", "pdts", "duts", "ddTS", "dcs", "Dt", "dt", "dduts", "pdtt", " dcs", "gdps", " dtt", " dps", "fdtt", "Dps", "dTS", "pdcs", "ddps", "fdts", " dt", "ddt", "dtt", " duts", "gdts", "Duts", "fdps", "fdcs", "dps"], "len": ["ls", "sl", "fl", "length", "lan", "cmp", "en", "Len", "vec", "h", "lt", "iter", "kl", "err", "lit", "dl", "lf", "le", "nl", "ret", "li", "fin", "del", "pos", "elt", "line", "loc", "ll", "pl", "rel", "lp", "vol", "rev", "l", "den", "el", "un", "num", "sp", "gz", "v", "n", "hl", "val", "lim", "lon", " l", "coll", "alt", "compl", "mem", "cod", "seq", "lib", "els", "ln", "fun", "bin", "gen", "lic", "limit", "half", "wid", "ptr", "il", "L", "t", "ld", "repl", "p"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n", "idx": 19987, "substitutes": {"cpu_model": ["cpu_Model", " cpu_Model", " cpu_type", "gpu_Model", "gpu_label", " cpu_models", "cpu_label", "cpu_models", "cpu_type", "gpu_model"], "id": ["rid", "f", "is", "type", "ID", "rank", "ref", "part", "h", "i", "def", "ip", "res", " fid", "head", "Id", "r", "ids", "pid", "d", "m", "index", "uid", "num", "bid", "sp", "hid", "k", "mid", "vid", "kid", "key", "ide", " tid", "md", " ID", "data", "sid", "count", "it", " pid", "tag", "oid", "start", "addr", "wid", "ident", "name", "p"], "prom_addr": ["promocdata", "prom2ptr", " prom_ptr", "promptaddr", "prom8addr", "promockaddr", "Prom_address", "promockarr", "prom8address", "promptptr", "promocaddr", "promocptr", "romptaddr", "romptdata", "rom_ptr", "romptptr", "prom_ptr", "rom_data", "rom_arr", "Prom_addr", " prom_src", "prom_arr", "promockptr", "prom_data", "prom8ptr", "promocarr", "prom2addr", "rom_addr", "prom2address", "promptdata", " prom_address", "prom_src", "promockdata", "prom_address", "Prom_ptr", "romptarr", "promptarr", "prom8src"], "cpu_irqs": ["cpu_iriffs", "cpu_prqu", "cpu_prques", "cpu_riniffs", "cpu_inqu", "cpu_rings", "cpu_inq", "cpu_rinqs", "cpu_pirqs", "cpu_pirqu", "cpu_prqs", "cpu_miriffs", "cpu_mirqs", "cpu_mirq", "cpu_pirq", "cpu_inques", "cpu_irgs", "cpu_irq", "cpu_iorqs", "cpu_prq", "cpu_ioriffs", "cpu_inqs", "cpu_rinq", "cpu_mirgs", "cpu_iorq", "cpu_pirques", "cpu_irques", "cpu_iorgs", "cpu_irqu"], "cs": ["proc", "ls", "cf", "act", "cv", "sts", "rs", "cn", "c", "cus", "js", "ck", "css", "cons", "cp", "sc", "vs", "ns", "tc", "ac", "CS", "Cs", "nc", "ts", "sys", "caps", "cc", "acs", "ctx", "wcs", "s", "cas", "cks", "stats", "ds", "ec", "qs", "gs", "ps", "comm", "fs"], "cpu": ["CPU", "us", "cv", "cache", "init", "c", "linux", "memory", "np", "pc", "ctx", "nu", "mem", "mac", "node", "tp", "proc", "cf", "hw", "clock", "bean", "uda", "cp", "null", "aq", "hz", "cu", "client", "alloc", "cmd", "ce", "aco", "phys", "process", "uu", "pu", "p", "clus", "disk", "conn", "pkg", "cn", "cli", "comp", "cal", "util", "phy", "ka", "eu", "core", "socket", "pool", "aux", "bench", "boot", "processor", "prof", "cam", "jp", "copy", "nic", "cum", "ck", "thread", "sc", "gc", "score", "nc", "sys", "vm", "reset", "gpu", "stat"], "env": ["proc", "window", "esm", "cv", "config", "ext", "shell", "sv", "en", "er", "conn", "hw", "end", "entry", "oe", "screen", "ef", "viron", "js", "enter", "server", "forge", "vs", "np", "obj", "export", "cb", "engine", "target", "enc", "e", "buf", "eu", "el", "ctx", "v", "eg", "ev", "mn", "priv", "eve", "ve", "sb", "console", "ew", "context", "app", "cmd", "environment", "ce", "db", "et", "desc", "ape", "next", "nv", "ec", "mem", "common", "ent", "vt", "pe", "scope", "ptr", "dev", "esc", "conf", "cfg", "vp"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "av_cold void avcodec_register(AVCodec *codec)\n\n{\n\n    AVCodec **p;\n\n    avcodec_init();\n\n    p = &first_avcodec;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p          = codec;\n\n    codec->next = NULL;\n\n\n\n    if (codec->init_static_data)\n\n        codec->init_static_data(codec);\n\n}\n", "idx": 19998, "substitutes": {"codec": ["cdEC", "odEC", "codbec", "codeca", " codoc", "prederer", " coderer", "codeisc", "Codentity", "cdec", "codeEC", "codisc", " codEC", "odisc", "coderer", "odbec", "codoc", "Codisc", "Codec", "CodEC", "codesc", "podeco", "oddec", "predbec", "cmderer", "oderer", "czbec", "cdeca", "codeec", "codedisc", "Codeco", "czec", " codisc", "Coddec", "coddec", "codeiac", "Codoc", "odec", "codedEC", " coddec", "odoc", "cmdec", "cmdeco", "podesc", "codeeca", "czerer", "cdiac", "Codiac", "Codeca", "podec", "cmdesc", "poderer", "codedec", "Coderer", "codiac", "codEC", "czdec", "predec", "odentity", "preddec", "codentity", "codeoc", "codedentity", "codeco", "Codesc"], "p": ["proc", "f", "pad", "prop", "ep", "g", "pkg", "peer", "jp", "P", "part", "a", "c", "h", "fp", "point", "gp", "post", "i", "mp", "pr", "per", "q", "cp", "bp", "pp", "np", "pi", "pb", "pl", "php", "pers", "lp", "pc", "wp", "m", "ap", "pid", "pod", "ping", "sp", "b", "v", "pa", "n", "vp", "up", "pair", "par", "pro", "pe", "process", "ps", "t", "rep", "tp", "j"]}}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 19999, "substitutes": {"p": ["f", "pad", "g", "cache", "pkg", "P", "fp", "jp", "a", "pre", "c", "h", "post", "info", "mp", "q", "cp", "bp", "ip", "xp", "pp", "np", "pi", "pb", "ist", "r", "lp", "pm", "resp", "pc", "l", "wp", "d", "m", "ap", "progress", "ping", "sp", "pt", "b", "v", "pa", "n", "out", "o", "vp", "app", "ar", "pg", "x", "up", "w", "op", "pe", "at", "ps", "t", "rep", "dp", "tp", "j"], "p_wwn": ["p_whegn", "p_nwizen", "p_wawr", "p_rwn", "p_nwrd", "p_wgn", "p_Wll", "p_wnn", "p___rwrd", "p_wrisen", "p_wkn", "p_watrown", "p_nden", "p_wawn", "p_wdn", "p_waden", "p_rwisen", "p_rwwn", "p_nkn", "p_dwn", "p___wrd", "p_wden", "p___rwwn", "p_rwrd", "p_Wkn", "p_nrown", "p_wisen", "p_rwll", "p_wrrd", "p_wrd", "p_wrwn", "p_nwwn", "p_wwr", "p_dnn", "p_watden", "p_nwreen", "p_whewm", "p_dwm", "p_rwdn", "p_walkn", "p_walll", "p_watkn", "p_Wwn", "p___wwn", "p_wrown", "p_wakn", "p_nwisen", "p_rwwr", "p___rwisen", "p___wizen", "p_rwreen", "p_wareen", "p_rwm", "p_watwn", "p_nwwr", "p___rwizen", "p_rgn", "p_wrizen", "p_warown", "p_wll", "p_ward", "p_waldn", "p_rwizen", "p_wwm", "p_Wdn", "p_wreen", "p_whewn", "p_rnn", "p_rwkn", "p___wisen", "p_wizen", "p_nwn", "p_whenn", "p_walwn", "p_dgn"], "i": ["is", "init", "h", "y", " ii", "ims", "e", "v", " err", "I", "o", "ii", "key", "phi", " ti", " count", "status", " j", " multi", "hi", " di", " pos", " hi", "iter", "ui", "\u0438", "pi", "u", "index", " pi", "mi", "multi", " I", " li", "gi", "ind", "ri", "xi", "ki", "ex", "cli", "ai", "li", "go", " bi", "ci", "me", "m", "k", "ti", "x", " x", " m", "uri", " si", "at", "ij", "si", "batch", "bi", " mi", " index", " v", "ic", "zi", "asi", "n", " iter", "ei", "ix", "di", " ni", "it", "ini", "z", "j"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_i_picture_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex, status = 0;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n#if HAS_ADVANCED_PROFILE\n\n    if (v->profile <= PROFILE_MAIN)\n\n#endif\n\n    {\n\n        if (v->extended_mv) v->mvrange = get_prefix(gb, 0, 3);\n\n        if (v->multires) v->respic = get_bits(gb, 2);\n\n    }\n\n#if HAS_ADVANCED_PROFILE\n\n    else\n\n    {\n\n        v->s.ac_pred = get_bits(gb, 1);\n\n        if (v->postprocflag) v->postproc = get_bits(gb, 1);\n\n        /* 7.1.1.34 + 8.5.2 */\n\n        if (v->overlap && v->pq<9)\n\n        {\n\n            v->condover = get_bits(gb, 1);\n\n            if (v->condover)\n\n            {\n\n                v->condover = 2+get_bits(gb, 1);\n\n                if (v->condover == 3)\n\n                {\n\n                    status = bitplane_decoding(&v->over_flags_plane, v);\n\n                    if (status < 0) return -1;\n\n#if TRACE\n\n                    av_log(v->s.avctx, AV_LOG_DEBUG, \"Overflags plane encoding: \"\n\n                           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n                }\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return status;\n\n}\n", "idx": 20000, "substitutes": {"v": ["f", "window", "cv", "all", "sv", "cache", "er", "g", "vv", "response", "sw", "video", "vr", "c", "h", "vd", "qu", "ov", "i", "q", "conv", "version", "y", "vs", "p", "V", "iv", "detail", "em", "ver", "u", "lv", "query", "message", "rev", "l", "m", "qv", "vi", "value", "vm", "env", "b", "k", "ev", "vim", "ve", "wire", "s", "val", "x", "vc", "uv", "nv", "tv", "w", "vt", "inv", "av", "view", "current", "ch", "dev", "t", "z", "j", "vp"], "gb": ["nb", "bb", "cv", "attr", "g", "gt", "gd", "hw", "GB", "tg", "vg", "wb", "fb", "xy", "rb", "rg", "bytes", "gc", "large", "cb", "pb", "ib", "gif", "pc", "sys", "eb", "gam", "b", "ctx", "vm", "eg", "bg", "hub", "Gb", "gnu", "sb", "gm", "kb", "db", "pg", "html", "bt", "gpu", "storage", "gg", " GB", "deg", "goo", "py", "gs", "gy", "bm", "bf", "csv", "mb", "ruby", "bs", "cfg", "gh"], "pqindex": ["pqIndex", " pqind", "proqladdress", "cqindex", "cqqind", "pqseed", "pqnum", "proqaxis", "piqvalue", "pquind", "pqqIndex", "pqqind", "paqdata", "paqIndex", "paqnum", "pquantIndex", "pqqindex", "pdqseed", "paquseed", "pquantindex", "pQnum", "cqnum", "pqvalue", "pqqvalue", "pqqaddress", "pqind", "pqlaxis", "pcapno", "piqindex", "cqqnum", "proqlno", "proqaddress", " pqqvalue", "proqindex", "paqudata", "paqqIndex", "pdqdata", "pquseed", "pqudata", "pdqindex", "cqind", "proqlaxis", "pqqaxis", "paqind", " pqvalue", "pquantvalue", "pqdata", "paqqnum", " pqqind", "pquindex", "paquind", "pcapaxis", " pqqindex", "pcapindex", "paqqindex", "pqlindex", "pdqind", "paqqind", "cqqindex", "pqladdress", "pqaxis", "piqind", "proqlindex", "paqseed", "pqqno", "paqindex", "pcapaddress", "pqno", "pquantind", "pquantnum", "pqaddress", "pqlno", "pQind", "proqno", "pqqnum", "pQindex", "paquindex"]}}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    AVCodec *dec;\n\n    char val_str[128];\n\n    AVDictionaryEntry *tag = NULL;\n\n    AVRational display_aspect_ratio;\n\n\n\n    printf(\"[STREAM]\\n\");\n\n\n\n    printf(\"index=%d\\n\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        if ((dec = dec_ctx->codec)) {\n\n            printf(\"codec_name=%s\\n\", dec->name);\n\n            printf(\"codec_long_name=%s\\n\", dec->long_name);\n\n        } else {\n\n            printf(\"codec_name=unknown\\n\");\n\n        }\n\n\n\n        printf(\"codec_type=%s\\n\", media_type_string(dec_ctx->codec_type));\n\n        printf(\"codec_time_base=%d/%d\\n\",\n\n               dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        printf(\"codec_tag_string=%s\\n\", val_str);\n\n        printf(\"codec_tag=0x%04x\\n\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            printf(\"width=%d\\n\", dec_ctx->width);\n\n            printf(\"height=%d\\n\", dec_ctx->height);\n\n            printf(\"has_b_frames=%d\\n\", dec_ctx->has_b_frames);\n\n            if (dec_ctx->sample_aspect_ratio.num) {\n\n                printf(\"sample_aspect_ratio=%d:%d\\n\",\n\n                       dec_ctx->sample_aspect_ratio.num,\n\n                       dec_ctx->sample_aspect_ratio.den);\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n\n                          1024*1024);\n\n                printf(\"display_aspect_ratio=%d:%d\\n\",\n\n                       display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            printf(\"pix_fmt=%s\\n\",\n\n                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name\n\n                                                    : \"unknown\");\n\n            printf(\"level=%d\\n\", dec_ctx->level);\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            printf(\"sample_rate=%s\\n\", value_string(val_str, sizeof(val_str),\n\n                                                    dec_ctx->sample_rate,\n\n                                                    unit_hertz_str));\n\n            printf(\"channels=%d\\n\", dec_ctx->channels);\n\n            printf(\"bits_per_sample=%d\\n\",\n\n                   av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n        }\n\n    } else {\n\n        printf(\"codec_type=unknown\\n\");\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n\n        printf(\"id=0x%x\\n\", stream->id);\n\n    printf(\"r_frame_rate=%d/%d\\n\",\n\n           stream->r_frame_rate.num, stream->r_frame_rate.den);\n\n    printf(\"avg_frame_rate=%d/%d\\n\",\n\n           stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n\n    printf(\"time_base=%d/%d\\n\",\n\n           stream->time_base.num, stream->time_base.den);\n\n    printf(\"start_time=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->start_time, &stream->time_base));\n\n    printf(\"duration=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->duration, &stream->time_base));\n\n    if (stream->nb_frames)\n\n        printf(\"nb_frames=%\"PRId64\"\\n\", stream->nb_frames);\n\n\n\n    while ((tag = av_dict_get(stream->metadata, \"\", tag,\n\n                              AV_DICT_IGNORE_SUFFIX)))\n\n        printf(\"TAG:%s=%s\\n\", tag->key, tag->value);\n\n\n\n    printf(\"[/STREAM]\\n\");\n\n}\n", "idx": 20005, "substitutes": {"fmt_ctx": ["fmtCcontext", "fmt_context", "flt_ctx", "ftx_context", "fmt2tx", "ftx_ctx", "fmt_txt", "fmt_req", "fmtCtxt", "fmt2context", "ftx_tx", "fmtCctx", "fmt2ctx", "ftx_req", "fmtCtx", "flt_txt", "fmt2txt", "flt_tx", "fmt_tx", "flt_context"], "stream_idx": ["stream_inx", "stream_inxs", "stream_iny", "stream_idz", "stream_midxd", "stream_midy", "stream_didx", "stream_midxs", "stream_Idx", "stream_didxs", "stream_didy", "stream_inz", "stream_idy", "stream_Idxd", "stream_ridxs", "stream_ridz", "stream_Idy", "stream_ridy", "stream_ridx", "stream_Idxs", "stream_idxd", "stream_midx", "stream_didxd", "stream_idxs"], "stream": ["present", "window", "sl", "length", "hook", "open", "steam", "sw", "spect", "Stream", "channel", "trans", "video", "iterator", "feed", "pipe", "draw", "port", "shape", "cont", "version", "tr", "util", "read", "reader", "src", "form", "path", "pod", "ack", "row", "secure", "time", "ocr", "console", "context", "ream", "REAM", "data", "seek", "desc", "ec", "transform", "pro", "view", "upload", " upstream", "dev", "metadata", "each"], "dec_ctx": ["dec_pool", "dec_cu", "decptcontext", "dec00pkg", "dec_conn", "dec00tz", "dec_context", "dec___ck", "ec_cfg", "dec67obj", "evalogcontext", "dectxpkg", "dec__obj", "decettx", "decogcv", "Dec_ctl", "eval_ctx", "dec_ck", "dec2context", "eval_cv", "ec_cp", "decptsys", "ec_ctl", "dec_cmp", "ec_gc", "ec_obj", "eval_context", "ec_lvl", "decptobj", "DEC_cmd", "decogcontext", "decetcas", " dec_tz", "dec_sys", "evalogctx", "dec_pkg", "Dec_grad", "dec2tx", "decogcu", "Dec_pool", "dec_tz", "eval_cu", "dec__ctx", "dec_lvl", "dectxctx", "dec_ca", "dec_cp", "ec_context", "evalogcu", "decogpkg", "DEC_obj", "ec_ca", "dec2ctx", "decockcu", "decptctx", "decptpkg", "dec_ctl", "decoggc", "Dec_cas", "dec_grad", "Dec_conn", "dec8ctx", "dec__ctl", "Dec_obj", "dec00obj", "dec8pool", "decogcrit", "dec___tx", "decockcv", "decptcmd", "Dec_ctx", "DECptcmd", "dec67cmd", "ec_cmp", "dectxgc", "evalogcv", "DECptctx", "decockctx", "DEC_check", "DECptcheck", "DEC_ctx", "ec_sys", "dec_cas", "decogctx", " dec_ci", "dec_check", "dec_crit", " dec_obj", "dec67ctx", "dec_cfg", "decetpkg", "dec__tx", "dec_obj", "DECptobj", "dec67check", " dec_tx", "ec_ctx", "decockcontext", "dec_ci", "dec8tx", "dec8pkg", "dec_gc", "Dec_tx", "dec2obj", "dec_cmd", "ec_pkg", " dec_pkg", "Dec_pkg", "Dec_ck", "dec_tx", "dec00ctx", "Dec_cmp", "dec___pkg", "ec_tx", "dec___ctx", "decetctx", "dec_cv", "ec_crit", "dectxcrit", "decptcheck"], "val_str": ["val2fr", "Val_arr", "val2arr", "val2str", "Val_Str", " val_r", " val_string", " val_arr", "value_arr", "Val_buf", " val_br", "val_arr", "val_string", "val2string", "Val_str", "val_fr", "val_br", "value_fr", "val2br", " val_Str", "val_r", "val_buf", "val_Str", "value_str"], "tag": ["type", "label", "Tag", "attr", "reg", "cat", "ag", "style", "TAG", "error", "pos", "debug", "event", "match", "id", "key", "comment", "desc", "count", "peg", "word", "stat", "token", "meta", "field", "name"], "display_aspect_ratio": ["display_aspect_statistor", "display_aspect_rao", "display_aspect_Ratirection", "display_aspect_ratience", "display_aspect_statios", "display_aspect_rati", "display_aspect_dirience", "display_aspect_rotio", "display_aspect_requial", "display_aspect_tIO", "display_aspect_dirirection", "display_aspect_ari", "display_aspectistratio", "display_aspect_Ratror", "display_aspect_arios", "display_aspect_tao", "display_aspect_ratao", "display_aspect_digios", "display_aspect_tior", "display_aspect_Ratio", "display_aspect_requios", "display_aspect_rotios", "display_aspect_Ratirement", "display_aspect_dirios", "display_aspect_digirection", "display_aspectistratirection", "display_aspect_Ratior", "display_aspect_tios", "display_aspect_rio", "display_aspect_digience", "display_aspect_Ratial", "display_aspect_statior", "display_aspect_Ratios", "display_aspect_ratial", "display_aspect_Ratao", "display_aspect_ratror", "display_aspect_rtio", "display_aspect_statio", "display_aspect_Rati", "display_aspect_ratIO", "display_aspect_ratior", "display_aspect_arror", "display_aspect_ario", "display_aspectistdigience", "display_aspect_rtios", "display_aspect_tio", "display_aspect_Ratience", "display_aspect_tistor", "display_aspectistdigio", "display_aspectistdigirection", "display_aspectistratios", "display_aspect_rtial", "display_aspect_requirement", "display_aspect_ratios", "display_aspect_rIO", "display_aspect_roti", "display_aspect_digio", "display_aspect_rotror", "display_aspect_rios", "display_aspect_Ratistor", "display_aspect_dirio", "display_aspect_ratirection", "display_aspectistdigios", "display_aspectistratience", "display_aspect_ratistor", "display_aspect_requio", "display_aspect_RatIO", "display_aspect_rtirement", "display_aspect_ratirement"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "static void encode_block(MpegEncContext *s, int16_t *block, int n)\n\n{\n\n    int i, j, table_id;\n\n    int component, dc, last_index, val, run;\n\n    MJpegContext *m = s->mjpeg_ctx;\n\n\n\n    /* DC coef */\n\n    component = (n <= 3 ? 0 : (n&1) + 1);\n\n    table_id = (n <= 3 ? 0 : 1);\n\n    dc = block[0]; /* overflow is impossible */\n\n    val = dc - s->last_dc[component];\n\n\n\n    ff_mjpeg_encode_coef(m, table_id, val, 0);\n\n\n\n    s->last_dc[component] = dc;\n\n\n\n    /* AC coefs */\n\n\n\n    run = 0;\n\n    last_index = s->block_last_index[n];\n\n    table_id |= 2;\n\n\n\n    for(i=1;i<=last_index;i++) {\n\n        j = s->intra_scantable.permutated[i];\n\n        val = block[j];\n\n\n\n        if (val == 0) {\n\n            run++;\n\n        } else {\n\n            while (run >= 16) {\n\n                ff_mjpeg_encode_code(m, table_id, 0xf0);\n\n                run -= 16;\n\n            }\n\n            ff_mjpeg_encode_coef(m, table_id, val, run);\n\n            run = 0;\n\n        }\n\n    }\n\n\n\n    /* output EOB only if not already 64 values */\n\n    if (last_index < 63 || run != 0)\n\n        ff_mjpeg_encode_code(m, table_id, 0);\n\n}\n", "idx": 20019, "substitutes": {"s": ["ls", "is", "esm", "sts", "sv", "rs", "sw", "a", "c", "sq", "sm", "settings", "js", "service", "self", "os", "ss", "y", "sg", "ns", "ims", "spec", "set", "r", "ms", "ats", "l", "series", "ts", "sys", "es", "b", "v", "ctx", "o", "se", "sb", "eds", "gm", "services", "times", "stats", "ds", "qs", "ses", "less", "S", "sam", "gs", "cs", "ps", "t", "bs", "fs", "hs", "p"], "block": ["new", "f", "proc", "bit", "type", "box", "object", "chain", "map", "point", "lock", "board", "buffer", "q", "def", "byte", "in", "line", "load", "Block", "set", "group", "check", "buf", "list", "row", "b", "record", "v", "out", "x", "frame", "mem", "bin", "bl", "raw", "word", "pack", "bf", "ch", "view", "blocks", "snap", "image", "range", "field", "p"], "n": ["nb", "ne", "g", "na", "nm", "sn", "cn", "c", "h", "nr", "size", "q", "len", "y", "nn", "np", "ns", "note", "r", "nor", "ng", "l", "nc", "num", "d", "network", "b", "v", "k", "o", " N", "nu", "nan", "x", "span", "no", "number", "nt", "N", "fn", "t", "z", "p"], "i": ["is", "bi", "gi", "ind", "c", "ri", "xi", "ki", "ai", "ia", "li", "ui", "ic", "y", "in", "ip", "jj", "\u0438", "io", "pi", "iu", "qi", "ni", "im", "zi", "ci", "l", "sim", "me", "id", "index", "ji", "v", "I", "o", "ii", "ti", "ei", "print", "ix", "x", "di", "it", "mi", "ie", "hi", "ij", "iq", "ini", "multi", "si", "p"], "j": ["f", "job", "jl", "jump", "J", "g", "bi", "ja", "jp", "c", "jc", "h", "js", "pr", "kj", "q", "fr", "y", "jj", "jac", "aj", "u", "r", "l", "d", "ji", "index", "b", "v", "k", "o", "dj", "uj", "x", "jit", "it", "ij", "t", "z", "si", "p"], "table_id": ["table2type", "tab_id", "tabOnum", "tableNameindex", "tab_num", "table_ide", "tableOid", "tablelwith", "tablelid", "entity_info", "entity_def", "entity_id", " table_link", " table2id", "table_with", "tableNameid", "tableptid", "tableptip", "tab_ids", "table2index", "tableNamelen", "table_link", "tabOlen", "table_ip", "table_index", "table_ref", "table_tag", "entity_oid", " table_index", "table_len", " table_type", "tabOid", "tabOids", " table_ip", "chain_id", "chain_pid", "table_log", "tableptids", "tablelpid", "table_ids", "tableOnum", " table_ids", "tablelinfo", "table_info", " table2type", " table_len", "chain_with", "table_oid", " table2index", "tableptlog", " table_tag", "tableNametype", "table_num", "table_pid", " table_log", " table2len", "table_type", "tab_len", "table2len", " table_ref", "tableOlen", " table_ide", "chain_info", "table_def", "tableOids", "table2id"], "component": ["unit", "type", "zone", "Component", "column", "slot", "format", "chain", "entity", "method", "reason", "c", "channel", "common", "part", "uni", "fc", "com", "service", "application", "draw", "ity", "port", "position", "brand", "scale", "comp", "attribute", "device", "kind", "ness", "form", "function", "sequence", "project", "pc", "nc", "index", "code", "family", "comment", "state", "context", "instance", "ce", "member", "col", "controller", "frame", "quarter", "direction", "number", "omp", "character", "relation", "node", "division", "command", "module", "impact", "scope", "dimension", "stable", "field"], "dc": ["lc", "DC", "c", "ca", "disc", "td", "fc", "rc", "mc", "cloud", "dt", "sc", "dim", "comp", "cp", "loc", "dat", "tc", "da", "dir", "ac", "pc", "nc", "d", "cc", "ctx", "bc", "db", "coll", "ds", "ec", "di", "dr", "mac", "cs", "cmp", "co", "dp", "cd"], "last_index": ["first_length", "last_key", "Last_Index", " last_size", "Last_index", "Last_block", "first_date", "last_ind", " last_member", "last_member", " last_position", " last_Index", "lastxIndex", "lastxindex", "lastWlength", "lastxlength", "first_Index", "lastxdate", "last_size", "lastWIndex", "lastOvermember", "last_length", "last_Index", "lastOversize", "last_date", "lastOverindex", " last_key", "lastWindex", "first_index", "lastOverposition", "last_block", "last_position", "lastWdate", " last_ind"], "val": ["prop", "length", "cho", "sv", "fe", "ref", "vec", "tx", "test", "Val", "sel", "fc", "valid", "VAL", "ret", "pr", "values", "des", "def", "buffer", "li", "comp", "len", "res", "pos", "rol", "cal", "al", "elt", "loc", "pl", "ver", "rel", "eval", "r", "buf", "vol", "pol", "l", "value", "index", "Value", "el", "eq", "b", "v", "var", "se", "ve", "sol", "data", "x", "col", "mem", "bal", "vals", "seq", "aval", "lib", "vt", "dev", "cmp", "p"], "run": ["head", "check", "scan", "work", "un", "be", "pass", "rm", "rd", "co", "add", "reg", "order", "render", "ro", "len", "round", "spec", "play", "index", "row", "code", "ru", "cmd", "loop", "fun", "process", "running", "name", "step", "rid", "length", "all", "end", "result", "update", "Run", "go", "load", "rate", "commit", "cycle", "ack", "record", "une", "ran", "seq", "no", "mix", "try", "runs", "range", "rank", "runner", "ref", "cum", "rc", "draw", "roll", "r", "form", "sync", "call", "num", "con", "coll", "exec"], "m": ["f", "tm", "esm", "g", "nm", "mr", "M", "c", "h", "mm", "cm", "mp", "wm", "man", "y", "em", "dm", "r", "um", "hm", "ms", "pm", "l", "d", "vm", "b", "v", "fm", "o", "om", "gm", "mo", "mk", "md", "x", "arm", "am", "mac", "mi", "rm", "module", "bm", "mt", "mb", "mod", "t", "p"]}}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dstParam[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint16_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint16_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\tint srcStride[3];\n\n\tuint8_t *src[3];\n\n\tuint8_t *dst[3];\n\n\t\n\n\tif((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[2];\n\n\t\tsrc[2]= srcParam[1];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[2];\n\n\t\tsrcStride[2]= srcStrideParam[1];\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_YV12){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[1];\n\n\t\tsrc[2]= srcParam[2];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[1];\n\n\t\tsrcStride[2]= srcStrideParam[2];\n\n\t}\n\n\telse if(isPacked(c->srcFormat)){\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= srcParam[0];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStrideParam[0]<<1;\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_Y8){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= NULL;\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= 0;\n\n\t}\n\n\n\n\tif((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[2];\n\n\t\tdst[2]= dstParam[1];\n\n\t\t\n\n\t}else{\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[1];\n\n\t\tdst[2]= dstParam[2];\n\n\t}\n\n\t\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);\n\n\t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);\n\n*/\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we cant output a dstY line so lets try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\t\t\tRENAME(yuv2yuvX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2rgbX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstFormat,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n", "idx": 20022, "substitutes": {"c": ["f", "lc", "cv", "cmp", "cr", "config", "cache", "cam", "cn", "chain", "C", "ca", "err", "cm", "fc", "rc", "abc", "com", "mc", "cont", "ic", "cp", "sc", "conv", "comp", "etc", "gc", "cb", "unc", "tc", "enc", "e", "cu", "ci", "ac", "pc", "l", "nc", "con", "cc", "cation", "rec", "cl", "v", "ctx", "ct", "b", "n", "wcs", "xc", "bc", "ce", "vc", "coll", "col", "ec", "cs", "ch", "comm", "t", "co", "conf", "dc", "p"], "srcParam": ["srcNum", "sourceDim", "sourceNum", "sourceParam", "rcNum", "rcDim", "rcPar", " srcPar", "sourcePar", "srcPar", " srcDim", "srcDim", " srcNum", "rcParam"], "srcStrideParam": ["srcSlripMem", "srcStrateParam", "srcStridePar", "srcStrateMem", "srcStripMem", "srcStrMem", "srcSlripPar", "srcStrMat", "srcStripMat", "srcStripPar", "srcSlrideParam", "srcStratePar", "srcStripParam", "srcStrideMem", "srcSlripParam", "srcSlrideMat", "srcStrideMat", "srcSlrideMem", "srcSlridePar", "srcStrParam", "srcSlripMat", "srcStrPar", "srcStrateMat"], "srcSliceY": ["srcSliceW", "srcSlideY", "srcLiceY", "srcSlsliceY", "srcLiceX", "srcSliceX", "srcLsliceXY", "srcLsliceW", "srcSlideX", "srcSliceXY", "srcLiceW", "srcSlsliceX", "srcSlizeW", "srcLiceXY", "srcSlizeX", "srcLsliceY", "srcLsliceX", "srcSlideXY", "srcSlsliceXY", "srcSlizeY", "srcSlizeXY", "srcSlsliceW", "srcSlideW"], "srcSliceH": ["srcPliceHT", "srcSlieX", "srcSlieHT", "srcSlideH", "srcSlatchHT", "srcPliceH", "srcSlideY", "srcSliceX", "srcSlatchY", "srcSlideHT", "srcSlideX", "srcPlatchHT", "srcPlatchH", "srcPlatchX", "srcSliceHT", "srcPliceX", "srcSlatchH", "srcSlatchX", "srcSlieH", "srcSlieY", "srcPliceY", "srcPlatchY"], "dstParam": ["destPar", "ddestParam", " ddestMem", "dstAM", "dstrPar", " ddestPar", "destParam", "ddestMem", " dstPar", " dstMem", "dstrMem", "destMem", "dstrAM", " ddestAM", "dstPar", "ddestAM", "dstMem", " dstAM", "ddestPar", "destAM", " ddestParam", "dstrParam"], "dstStride": ["dstStrain", "dstRestrat", "dstDestr", "dstRestrain", "dstRestr", "ddestStrat", "dstDestrat", "dstStr", "dstRestride", "dstAttride", "dstDestrain", "ddestRestrain", "ddestRestride", "dstAttrain", "ddestStr", "ddestStride", "dstAttrat", "ddestStrain", "dstAttr", "dstDestride", "dstStrat", "ddestRestrat", "ddestRestr"], "vLumFilterPos": ["vLumRuleCond", "vLumbFilterCond", "vLumRulePos", "vLangFilterPos", "vLumbFilterPos", "vLumFilOff", "vLumBufferPos", "vLumListenerPos", "vLumFilterOff", "vLangListenerTrans", "vLumBufferTrans", "vLumListenerOff", "vLangFilterPort", "vLumListenerPort", "vLumFilPort", "vLumFilterCond", "vLumBufferCond", "vLangListenerPort", "vLumFilTrans", "vLumListenerTrans", "vLumBufferOff", "vLangFilterOff", "vLangListenerPos", "vLumbFilterDef", "vLumFilterTrans", "vLumBufferPort", "vLumFilPos", "vLangFilterTrans", "vLangListenerOff", "vLumRuleDef", "vLumFilterDef", "vLumFilterPort", "vLumBufferDef"], "vChrFilterPos": ["vChrCounterPos", "vChrFFPos", "vChdrFilterRes", "vChdrHandlerPos", "vChrHandlerPos", "vChdrHandlerLoc", "vChrtCounterPos", "vChrCounterPart", "vChrManagerPos", "vChdrHandlerPoints", "vChrManagerLoc", "vChdrFilterLoc", "vChdrFilterPos", "vChrManagerPoints", "vChrHandlerPoints", "vChrtFilterPart", "vChrtCounterPart", "vChdrHandlerRes", "vChrHandlerLoc", "vChdrFilterPoints", "vChrFilterPoints", "vChrHandlerRes", "vChrTransformPos", "vChrFilCol", "vChrTransformRes", "vChrFilterPosition", "vChrFilterLoc", "vChrtCounterCol", "vChrtFilterCol", "vChrFilterPart", "vChrFFPart", "vChrtFilterPosition", "vChrFilterRes", "vChrFFPosition", "vChrCounterCol", "vChrTransformLoc", "vChrManagerRes", "vChrtFilterPos", "vChrFFCol", "vChrFilterCol", "vChrFilPos", "vChrFilPart", "vChrFilPosition", "vChrCounterPosition", "vChrtCounterPosition", "vChrTransformPoints"], "hLumFilterPos": ["hLumaFilterObj", "hLoomFilterCond", "hLumFilDir", "hLoomFilDir", "hLumTERComp", "hLoomFilComp", "hLoomFilterPos", "hLumBlockPos", "hLumaFilterPos", "hLoomFilPos", "hLumSortDir", "hLumSortPos", "hLumTERCond", "hLumFilterDir", "hLumaControlPos", "hLumFormatObj", "hLumBlockObj", "hLoomFilterDir", "hLumFilterCond", "hLumControlRes", "hLumControlObj", "hLumaFilterRes", "hLumFormatPos", "hLoomFilterComp", "hLumControlPos", "hLumFilterComp", "hLumBlockRes", "hLumSortCond", "hLumTERPos", "hLumTERDir", "hLumFilCond", "hLumaControlRes", "hLoomFilCond", "hLumSortComp", "hLumFilComp", "hLumFormatRes", "hLumFilPos", "hLumFilterObj", "hLumaControlObj", "hLumFilterRes"], "hChrFilterPos": ["hChrfilterLen", "hChdrFilterPos", "hChroFileRes", "hChrFileDir", "hChdrfilterRot", "hChdrFilterRot", "hChrFilterDir", "hChroFilterPosition", "hChrChannelPosition", "hChdrfilterLen", "hChrTestPos", "hChrTestRot", "hChdrFilterLen", "hChrfilterPosition", "hChrFormatRot", "hChrChannelDir", "hChrChannelRes", "hChdrfilterPos", "hChroFileDir", "hChrfilterDir", "hChrFormatRes", "hChrFilterRes", "hChrTestLen", "hChrfilterRes", "hChrFormatLen", "hChrTestRes", "hChrFileRes", "hChroFilePos", "hChrFilePosition", "hChdrFilterRes", "hChroFilePosition", "hChrFilePos", "hChdrfilterRes", "hChrFilterPosition", "hChrFormatPos", "hChrfilterPos", "hChroFilterRes", "hChrfilterRot", "hChroFilterPos", "hChrChannelPos", "hChrFilterRot", "hChrFilterLen", "hChroFilterDir"], "vLumFilter": ["vElulFilter", "vLulHandler", "vElumFilter", "vLnumFilter", "vLulLimit", "vElulLimit", "vLumChannel", "vLnumChannel", "vLumiFilter", "vLumbLimit", "vBlumFilter", "vElumHandler", "vElulRule", "vBlumiHandler", "vLulFilter", "vLumbRule", "vLnumFil", "vBlumChannel", "vLomFilter", "vElumLimit", "vBlumiFilter", "vLumFil", "vElulHandler", "vBlumHandler", "vLomHandler", "vLumHandler", "vLumiLimit", "vLumiRule", "vBlumFil", "vLumbHandler", "vLumiHandler", "vLumRule", "vLomFil", "vBlumiFil", "vLumbFilter", "vElumRule", "vLomChannel", "vLumiChannel", "vLumiFil", "vLulRule", "vLnumHandler", "vLumLimit", "vBlumiChannel"], "vChrFilter": ["vClrFil", "vColrbFilter", "vChruChannel", "vChnfilter", "vChruFil", "vChmChannel", "vChdrfilter", "vChrHandler", "vChdrHandler", "vChbFil", "vChruFormat", "vChbFormat", "vClmFil", "vChbChannel", "vColrFilter", "vChruFilter", "vClmFormat", "vColrbfilter", "vChrbfilter", "vChmFil", "vClmFilter", "vClrFormat", "vChrFil", "vChbFilter", "vChrFormat", "vColrfilter", "vChnHandler", "vChrbHandler", "vChnFilter", "vChdrFilter", "vClrFilter", "vChmFilter", "vChmFormat", "vColrbHandler", "vClmChannel", "vClrChannel", "vChrfilter", "vChrChannel", "vColrHandler", "vChrbFilter"], "hLumFilter": ["hLeumFF", "hLoxRule", "hLamFF", "hLumpFilter", "hLumpFF", "hLumiSpec", "hLeumFilter", "hLumFil", "hLumaFilter", "hLeoxFF", "hLeumSpec", "hMumpFil", "hLoxSpec", "hLamFilter", "hLamFil", "hLumaFil", "hLumFF", "hLeumRule", "hMumFil", "hLumaFF", "hLuminFF", "hLuminRule", "hLeoxFilter", "hLumiRule", "hLumpFil", "hLumRule", "hLoxFilter", "hMumpFF", "hLoxFF", "hLuminFilter", "hLumiFilter", "hLuminSpec", "hLumSpec", "hLeoxRule", "hMumpFilter", "hMumFilter", "hMumFF", "hLeoxSpec", "hLumiFF"], "hChrFilter": ["hShrcFilter", "hChrbTransform", "hColrFil", "hChrTransform", "hChrVersion", "hChrgTarget", "hColuTarget", "hChrgFilter", "hChrTarget", "hShrFilter", "hChuFilter", "hShrChain", "hShrcVersion", "hChrcVersion", "hChrbVersion", "hColuFil", "hColrFilter", "hChriVersion", "hShrcChain", "hColrTransform", "hChrChain", "hShrFil", "hChriChain", "hShrVersion", "hChrbTarget", "hChriFil", "hChuFil", "hChrbFilter", "hChrFil", "hChrbFil", "hChrgFil", "hChrbChain", "hChrcChain", "hChuTarget", "hColuFilter", "hChrgTransform", "hChriFilter", "hChrcFilter", "hChuTransform", "hColrTarget", "hChrcFil", "hColuTransform", "hShrcFil"], "lumMmxFilter": ["lumMpxFormat", "lumMmmOnly", "lumBpxFormat", "lumRmxOnly", "lumRmmFilter", "lumRmxFilter", "lumMmInfo", "lumRmxInfo", "lumMmProfile", "lumRmmOnly", "lumMmnOnly", "lumMixFilter", "lumMmxFormat", "lumBmxFormat", "lumMmOnly", "lumMmxHandler", "lumMmxInfo", "lumRmmInfo", "lumMmmFilter", "lumMmmHandler", "lumBpxFilter", "lumMmnInfo", "lumBmxFilter", "lumMmxSort", "lumBpxSort", "lumMmmFormat", "lumMmnProfile", "lumBmxHandler", "lumMpxFilter", "lumBmxSort", "lumMpxSort", "lumMixHandler", "lumMmxProfile", "lumMmFilter", "lumMmmProfile", "lumMixSort", "lumMmmInfo", "lumBpxHandler", "lumMmxOnly", "lumRmxProfile", "lumMpxHandler", "lumMmnFilter", "lumMixFormat", "lumMmmSort", "lumRmmProfile"], "chrMmxFilter": ["chrMxFile", "chrMmxBlock", "chrMmnFile", "chrMmxfilter", "chrMnaFile", "chrMixfilter", "chrMmnfilter", "chrLmnBlock", "chrMxFilter", "chrLmxFilter", "chrMtmFilter", "chrMtmFile", "chrMmnBlock", "chrMixFile", "chrMpxfilter", "chrMmxFile", "chrMxRule", "chrMpxBlock", "chrMnaFilter", "chrMnaRule", "chrLmxFile", "chrLmnfilter", "chrLmnFile", "chrLmxfilter", "chrMtmRule", "chrLmnFilter", "chrMixBlock", "chrLmxBlock", "chrMpxFilter", "chrMixFilter", "chrMmxRule", "chrMmnFilter", "chrMpxFile"], "lumPixBuf": ["lumPfxBuf", "lumPixRuf", "lumPfxRuf", "lumPixPbuf", "lumPfxRatch", "lumPixBatch", "lumPixBuffrc", "lumPxPbuf", "lumPixBuffuffer", "lumPfxRuff", "lumPxPrc", "lumPxBuf", "lumPixPatch", "lumPixBuff", "lumPixPuff", "lumPxPuffer", "lumPixBuffer", "lumPfxRbuf", "lumPixRbuf", "lumPixBbuf", "lumPxPuf", "lumPixRuff", "lumPfxBatch", "lumPixPrc", "lumPixBuffbuf", "lumPxBrc", "lumPxBuffer", "lumPixRatch", "lumPixPuf", "lumPixBrc", "lumPixBuffuf", "lumPixPuffer", "lumPxBbuf", "lumPfxBuff", "lumPfxBbuf"], "chrPixBuf": ["chrPxPff", "chrPixRbuf", "chrPixGus", "chrPxPuf", "chrPfxBbuf", "chrPixRus", "chrPixGbuf", "chrPixCbuf", "chrPixBuff", "chrPixPbuf", "chrPfxBus", "chrPixBbuf", "chrPixTuf", "chrPixBff", "chrPixCuc", "chrPxPbuf", "chrPixGuf", "chrPixTbuf", "chrPxBuf", "chrPxPuc", "chrPixRuf", "chrPixPus", "chrPixPuf", "chrPxBff", "chrPfxBuf", "chrPixGuff", "chrPfxBuff", "chrPixBuc", "chrPixCuf", "chrPixPuff", "chrPixTff", "chrPfxPbuf", "chrPfxPus", "chrPfxPuf", "chrPixPuc", "chrPixBus", "chrPixPff", "chrPixTuc", "chrPxBuc", "chrPfxPuff", "chrPixRuff", "chrPixCff", "chrPxBbuf"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union srp_iu *srp = &req->iu.srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n", "idx": 20026, "substitutes": {"s": ["ls", "is", "sts", "g", "rs", "sv", "sw", "h", "sq", "ops", "js", "i", "os", "ss", "sc", "serv", "vs", "ns", "ims", "session", "r", "ms", "ats", "l", "ts", "d", "sys", "sp", "es", "b", "v", "sb", "stats", "ds", "http", "ses", "less", "S", "ssl", "gs", "cs", "ps", "t", "bs", "fs", "hs", "z", "j", "p"], "req": ["rh", "rez", "js", "tab", "fr", "rr", "qq", "query", "ctx", "md", "quest", "rpm", "supp", "needed", "rd", "cmp", "decl", "need", "reg", "tx", "test", "tek", "rx", "rem", "dq", "dist", "spec", "expr", "progress", "rec", "cmd", "uj", "compl", "required", "msg", "inv", "usr", "iq", "adj", "dev", "rep", "conf", "p", "ext", "pkg", "require", "ind", "sq", "err", "good", "term", "q", "comp", "wx", "resp", "desc", "seq", "pro", "aux", "ij", "quick", "comm", "range", "crit", "rt", "attr", "ref", "ctr", "Requ", "jp", "worker", "urg", "requ", "res", "xp", "qt", "rel", "r", "gr", "request", "rw", "rss", "eq", "gz", "dep", "Request", "exec", "j"], "srp": ["ctrP", "sprcp", "srpc", "sprpc", "lrf", "srf", "svpa", "selp", "vrpt", "ctrp", "serps", " srpa", "sprpy", "vrp", " srf", "lrpid", "lrpa", "servp", "irpt", "vrpar", "ctrpt", "servpro", "srpar", "srps", " srps", "ircp", "srpa", "srpt", "srpro", " srpy", "srP", "lrp", "srpid", "surpar", "selpa", "ibrpar", "srvp", "svpp", "serpar", "svpro", "surp", " srpc", "selpp", "srcp", "svp", " srP", "srpp", "sprp", "ctrpy", " srpt", "surpc", "ibrpc", "servpp", "sprP", "irpc", "vrcp", "sprpt", "irp", "svf", "servpa", " srpar", "serp", "srpy", "selpro", "serpc", "svpid", " srvp", "vrpc", "vrps", "ibrvp", "survp", "ibrp", " srpid"], "sdev": ["sdevice", "tsev", "esev", "srdevice", "esconn", "slev", "msdev", "jsev", "svar", "Sdevice", "tsconn", "sddevice", " sDev", "senv", "tesdev", "slDEV", "jsconn", "jsDev", "jsdev", "tesDEV", "sdnode", "sysDev", "ssgo", "Sender", "ssdevice", "srfat", "tsdev", "esdev", "sDev", "tesdiv", "svvar", "tsenv", "msdevice", "jsdiv", " sdevice", "sldevice", " snode", "sysdevice", "scam", "sgu", "statscam", " sfat", "Sev", "jsdevice", "sfat", "jsDEV", "msenv", "statsdev", "sdiv", "tsDev", "sender", " sdevelop", "SDev", " sgo", " scam", "jscam", " sev", "isdevice", " sender", "SDEV", " sDEV", "sdfat", "tesdevice", "ssdev", " sgu", "sysdev", "snode", "msvar", "svdev", "isDev", "tsdevice", "sddev", "ssgu", "sev", "sdevelop", "sconn", "isdiv", "ssdevelop", "sgo", "srnode", "srdev", "sysender", "tsvar", "sDEV", "Sdev", "sldev", " sdiv", "isdev", "esdevice", "svenv", "statsdevice", "svdevice", "tsdevelop"], "n": [" ng", "nb", "f", "ne", " len", "g", "na", "en", "nm", " ns", "sn", "cn", "a", "h", "c", "dn", "yn", " nm", "i", "nl", "name", "len", "y", "ize", "nn", "np", "ns", "net", "norm", "ll", "ni", "note", "r", "e", "ng", "nor", "l", "nc", "d", "num", "m", "pn", "b", "v", "o", "out", " N", "nu", " fn", "nan", " l", "x", "gn", "an", "no", "ln", "w", "number", "nt", "N", "fn", "t", "z", "j", "p"], "id": ["rid", "fd", "pad", "is", "type", "ID", "offset", "end", "ref", "ind", "init", "h", "tx", "info", "i", "size", "ad", "q", "aid", "len", "ip", "in", "res", "debug", "Id", "request", "l", "pid", "d", "num", "ids", "uid", "bid", "and", "sp", "mid", "vid", "kid", "ide", "md", "cmd", " tid", "sid", "data", "status", "no", "it", "oid", "tag", "wid", "start", "dev", "ident", "t", "addr", "hash", "name", "p"], "lun": ["lrang", "leunt", "leund", "lUN", "lunn", "llut", "Len", "mlun", "lrun", "lrour", "leour", " lUn", "llen", "mlUN", "lund", " lut", "Lum", "mlunn", " lunt", "Lun", "lUn", "len", "leun", "slut", "lunt", "llunt", "plun", " lunn", " lum", "slon", "lour", "slUN", "leang", "slmun", "plund", "Lunn", "lrUN", "llun", "slunt", " lund", "Lunt", "leUN", "plunt", "Lour", "llUN", "slun", "lon", "lut", "Lon", "leum", "plUn", "lmun", "lang", " lmun", "Lut", "slen", "mlUn", "Lang", "LUN", "LUn", " lUN", "llon", "leUn", "lum", "llmun"]}}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "static int do_sendv_recvv(int sockfd, struct iovec *iov, int len, int offset,\n\n                          int do_sendv)\n\n{\n\n    int ret, diff, iovlen;\n\n    struct iovec *last_iov;\n\n\n\n    /* last_iov is inclusive, so count from one.  */\n\n    iovlen = 1;\n\n    last_iov = iov;\n\n    len += offset;\n\n\n\n    while (last_iov->iov_len < len) {\n\n        len -= last_iov->iov_len;\n\n\n\n        last_iov++;\n\n        iovlen++;\n\n    }\n\n\n\n    diff = last_iov->iov_len - len;\n\n    last_iov->iov_len -= diff;\n\n\n\n    while (iov->iov_len <= offset) {\n\n        offset -= iov->iov_len;\n\n\n\n        iov++;\n\n        iovlen--;\n\n    }\n\n\n\n    iov->iov_base = (char *) iov->iov_base + offset;\n\n    iov->iov_len -= offset;\n\n\n\n    {\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n        struct msghdr msg;\n\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_iov = iov;\n\n        msg.msg_iovlen = iovlen;\n\n\n\n        do {\n\n            if (do_sendv) {\n\n                ret = sendmsg(sockfd, &msg, 0);\n\n            } else {\n\n                ret = recvmsg(sockfd, &msg, 0);\n\n            }\n\n        } while (ret == -1 && errno == EINTR);\n\n#else\n\n        struct iovec *p = iov;\n\n        ret = 0;\n\n        while (iovlen > 0) {\n\n            int rc;\n\n            if (do_sendv) {\n\n                rc = send(sockfd, p->iov_base, p->iov_len, 0);\n\n            } else {\n\n                rc = qemu_recv(sockfd, p->iov_base, p->iov_len, 0);\n\n            }\n\n            if (rc == -1) {\n\n                if (errno == EINTR) {\n\n                    continue;\n\n                }\n\n                if (ret == 0) {\n\n                    ret = -1;\n\n                }\n\n                break;\n\n            }\n\n            if (rc == 0) {\n\n                break;\n\n            }\n\n            ret += rc;\n\n            iovlen--, p++;\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Undo the changes above */\n\n    iov->iov_base = (char *) iov->iov_base - offset;\n\n    iov->iov_len += offset;\n\n    last_iov->iov_len += diff;\n\n    return ret;\n\n}\n", "idx": 20032, "substitutes": {"sockfd": ["sockFD", "sipptr", "sOCKdir", "sackfd", "sOCKfd", " sockedfc", "sinkfd", "sackfile", "sackstream", "ssockfile", "ssackd", "sockfc", "sckstream", "sackdir", " sockedfs", "sigfile", "ssackfd", "sckd", "soyfd", "ssockd", " sockedFD", "sockeddir", "sckfd", " sockfile", "ssockdir", "ssackdir", "sinkFD", "socksfile", "ssackFD", " sockptr", "socksfc", "sackd", " sockedfd", "sigfd", "sinkstream", "sckfile", "sockedfc", "sockstream", "ssackfile", "sockd", "sOCKfs", " sipptr", " sockFD", "sOCKFD", "sigfc", " sockedfile", "sockedfd", "ssockstream", "ssackstream", "soyfs", " sockdir", " sockeddir", "sckdir", "soydir", "sockfile", " sipfile", "sockedfile", "sipfile", "socksfd", "sockdir", "sckFD", "sinkfile", "sipFD", "ssockFD", "sinkptr", "ssockfd", " sipFD", "socksptr", " sipfd", " sockfs", "sockedfs", "sackFD", "socksFD", "sockfs", "sockptr", "sinkdir", "soyFD", "sinkd", " sockfc", "sipfd", "sockedFD", "socksdir", "sigdir"], "iov": ["vector", "vec", "iper", "veh", "icon", "drm", "iat", "np", "mu", "mom", "v", "von", "brother", "ilo", "uv", "vo", "mpeg", "minecraft", "yon", "ir", "nov", "river", "serv", "gra", "obj", "norm", "soc", "src", "vision", "imp", "rov", "wikipedia", "voice", "cmd", "uj", "iev", "inv", "ever", "iq", "vg", "vp", "riot", "iol", "lov", "isco", "iva", "pkg", "uart", "liv", "conv", "version", "username", "iv", "phy", "iu", "ech", "buf", "ux", "kov", "mus", "seq", "iop", "ij", "prov", "iph", "comm", "sov", "established", "nil", "fp", "jp", "vr", "dl", "iour", "browser", "voc", "server", "img", "igroup", "chrom", "ei", "ovi", "tv", "dyl", "av"], "len": ["unit", "ls", "length", "lan", "end", "en", "Len", "neg", "vec", "mult", "lt", "iter", "dl", "lf", "le", "nl", "size", "split", "fin", "del", "syn", "pos", "net", "elt", "loc", "ll", "align", "pl", "ell", "lp", "l", "list", "num", "el", "local", "off", "n", "hl", "val", "rot", "lim", "lon", "alt", "compl", "lang", "seq", "ln", "nt", "limit", "half", "il", "L", "cmp", "ld"], "offset": ["shift", "pointer", "seed", "Offset", "attribute", "iat", "OFF", "address", "o", "lower", "eta", "limit", "cmp", "extra", "pad", "ff", "onet", "pos", "index", "off", "area", "inter", "alpha", "lon", "ow", "unit", "tmp", "length", "ext", "end", "slot", "location", "update", "point", "delay", "origin", "size", "buffer", "error", "aff", "elt", "loc", "set", "l", "prefix", "half", "range", "attr", "ref", "fp", "position", "padding", "align", "adjusted", "reset", "rot", "et", "alt", "equal", "op", "base", "addr", "start", "t", "timeout"], "do_sendv": ["do_createvt", "do_sendup", "do_failup", "do_switchvt", "do_parseev", "do_transfervr", "do_transferv", "do_poseev", "do_poseconv", "doPsenduv", "do_sendvv", "do_sendvr", "do_createv", "do_sendev", "do_createvc", "do_sendvc", "do_exportvv", "do_posev", "do_failv", "do_poseo", "do_transferup", "doPfailup", "doedexportvv", "do_useconv", "do_parseo", "doedexportvt", "do_failuv", "doPfailv", "do_seuv", "doPsendup", "do_exportvt", "do_createvv", "doPfailuv", "do_switchvv", "do_failvr", "do_seup", "doedsendvt", "do_switchv", "doedsendv", "do_exportv", "do_useo", "do_senduv", "do_transferuv", "do_exportvc", "do_sendo", "doPsendvr", "doPsendv", "do_useev", "do_sendconv", "doedexportvc", "doedsendvc", "do_sendvt", "doedsendvv", "do_parsev", "do_parseconv", "do_switchvc", "do_usev", "doedexportv", "doPfailvr", "do_sevr", "do_sev"], "ret": ["cat", "def", "det", "RET", "out", "val", "print", "mem", "rm", "url", "reg", "gt", "lt", "rem", "cont", "dt", "re", "round", "progress", "el", "off", "ft", "cmd", "success", "fun", "nt", "mt", "ext", "rs", "en", "result", "err", "fin", "elt", "ll", "flag", "arg", "resp", "uf", "ar", "rets", "desc", "count", "x", "try", "pret", "at", "ptr", "repl", "rt", "nil", "get", "xt", "ref", "jp", "not", "tr", "res", "gc", "att", "rel", "r", "got", "arr", "rev", "Ret", "num", "nz", "reset", "rot", "alt", "t", "j"], "diff": ["extra", " difference", "pad", "length", "label", "Diff", "attr", "ext", "ind", "trans", "shift", "part", "df", "delay", "dl", "iff", "def", "dt", "split", "del", "dim", "comp", "deb", "dist", "elt", "loc", "note", "rel", "dir", "different", "progress", "d", "eff", "dep", "change", "changed", "desc", "alt", "deg", "fun", "mix", "mod", "cmp", "range", "cond", "step"], "iovlen": ["livld", "iovlan", "livlong", "livelt", "iovLen", "convlen", "ivli", "iovld", "livcompl", "livdepth", "ivlength", "novlif", "chromli", "ioven", "chromLen", "ibrln", "iovli", "chromlong", "iovcompl", "iovlib", "voiceelt", "chromen", "chromlan", "ievelt", "ivLen", "iovln", "kovnum", "livellen", "voicedepth", "chromcompl", "ievlen", "livLen", "novlen", "ivlen", "novLen", "iovsl", "iumlen", "voicelen", "voicenum", "iovlif", "noven", "ibrsl", "ievsl", "ivlan", "convnum", "iumlength", "iovnum", "ivlif", "convlan", "ievdepth", "iovlength", "ieven", "kovlen", "voiceld", "voicelib", "kovlan", "iovdepth", "chromlen", "novli", "ievld", "livlen", "iumlif", "novln", "iven", "liven", "iovelt", "livlan", "novlan", "novlength", "ibren", "iovellen", "kovlib", "kovellen", "ievln", "kovlong", "voicelan", "iovlong", "ivcompl", "novsl", "iumLen", "ibrlen", "chromellen", "convlib"], "last_iov": [" last_iv", "last_mus", "last_iour", "last___voice", "lastMiv", "last_____ij", "lastOneconv", "used_vr", "used_iev", "used____iev", "lastremiov", "last_nov", "last_____iev", "last_vr", " last_ij", "last___vr", " last__vg", "lastMiov", "last___mus", "used_iov", "lastOnevg", "last____iov", "last___liv", " last_vr", "last__vg", "last___conv", "last_voice", "lastobjibr", " last_iour", " last_vg", "last___iov", "last___iour", " last_conv", "lastobjiov", "last___iev", "last____iev", "lastremnov", "lastOneiov", "lastMij", "last__mus", "used_iour", "lastremibr", " last_mus", "last_ovi", "lastremliv", "last_____iour", "last_____iov", "last_vg", "last__iov", "lastOnemus", " last_ibr", " last_nov", "used____iov", "last___ij", " last__conv", "lastMovi", "lastobjliv", "last_conv", "last_iv", "used____vr", "last____iour", " last_liv", " last_voice", " last__mus", "last____vr", "last___vg", "last_liv", "used____iour", " last_iev", " last__iov", "last__conv", "last_ij", "last_iev", "last_ibr", "lastobjnov", " last_ovi"], "msg": ["args", "man", "message", "vol", "v", "out", "send", "md", "req", "mem", "status", "gen", "nm", "tx", "ag", "sg", "body", "obj", "ms", "summary", "mat", "gm", "cmd", "tag", "og", "mt", "say", "cfg", "sum", "all", "header", "g", "pkg", "game", "cm", "error", "Msg", "arg", "resp", "buf", "l", "m", "txt", "gent", "mail", "mess", "desc", "seq", "dr", "gs", "module", "comm", "get", "config", "mg", "res", "doc", "arr", "gr", "list", "call", "gz", "mn", "str", "data", "op", "news", "stat", "addr", "j"], "p": ["proc", "f", "pat", "ep", "pkg", "fp", "jp", "P", "pre", "c", "h", "part", "mp", "i", "per", "port", "q", "prev", "cp", "conv", "bp", "ip", "xp", "pos", "pp", "np", "iat", "pb", "u", "e", "lp", "pm", "r", "pc", "pai", "wp", "m", "ap", "d", "pt", "l", "v", "ctx", "pa", "n", "param", "o", "vp", "up", "par", "pard", "pro", "perm", "op", "ps", "t", "rep", "dp", "tp", "j"], "rc": ["proc", "rt", "clus", "cv", "cr", "rs", "ctr", "result", "nr", "err", "rx", "fc", "rl", "rob", "ck", "sc", "ro", "res", "gc", "cb", "rr", "round", "src", "enc", "r", "tc", "resp", "sr", "pc", "rev", "nc", "con", "cc", "rec", "ack", "row", "cd", "bc", "uc", "ce", "cmd", "desc", "cur", "ec", "RC", "cs", "cmp", "arc", "dc", "roc", "red", "ry"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp9_decode_frame(AVCodecContext *ctx, void *frame,\n\n                            int *got_frame, AVPacket *pkt)\n\n{\n\n    const uint8_t *data = pkt->data;\n\n    int size = pkt->size;\n\n    VP9Context *s = ctx->priv_data;\n\n    int res, tile_row, tile_col, i, ref, row, col;\n\n    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&\n\n                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);\n\n    ptrdiff_t yoff, uvoff, ls_y, ls_uv;\n\n    AVFrame *f;\n\n    int bytesperpixel;\n\n\n\n    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {\n\n        return res;\n\n    } else if (res == 0) {\n\n        if (!s->s.refs[ref].f->buf[0]) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Requested reference %d not available\\n\", ref);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)\n\n            return res;\n\n        ((AVFrame *)frame)->pts = pkt->pts;\n\n#if FF_API_PKT_PTS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        ((AVFrame *)frame)->pkt_pts = pkt->pts;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n        ((AVFrame *)frame)->pkt_dts = pkt->dts;\n\n        for (i = 0; i < 8; i++) {\n\n            if (s->next_refs[i].f->buf[0])\n\n                ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n            if (s->s.refs[i].f->buf[0] &&\n\n                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)\n\n                return res;\n\n        }\n\n        *got_frame = 1;\n\n        return pkt->size;\n\n    }\n\n    data += res;\n\n    size -= res;\n\n\n\n    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {\n\n        if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0])\n\n            vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n            (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)\n\n            return res;\n\n    }\n\n    if (s->s.frames[REF_FRAME_MVPAIR].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR]);\n\n    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n        (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    if (s->s.frames[CUR_FRAME].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[CUR_FRAME]);\n\n    if ((res = vp9_alloc_frame(ctx, &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    f = s->s.frames[CUR_FRAME].tf.f;\n\n    f->key_frame = s->s.h.keyframe;\n\n    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    ls_y = f->linesize[0];\n\n    ls_uv =f->linesize[1];\n\n\n\n    if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0] &&\n\n        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||\n\n         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n    }\n\n\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->next_refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n        if (s->s.h.refreshrefmask & (1 << i)) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);\n\n        } else if (s->s.refs[i].f->buf[0]) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);\n\n        }\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (ctx->hwaccel) {\n\n        res = ctx->hwaccel->start_frame(ctx, NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->decode_slice(ctx, pkt->data, pkt->size);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->end_frame(ctx);\n\n        if (res < 0)\n\n            return res;\n\n        goto finish;\n\n    }\n\n\n\n    // main tile decode loop\n\n    bytesperpixel = s->bytesperpixel;\n\n    memset(s->above_partition_ctx, 0, s->cols);\n\n    memset(s->above_skip_ctx, 0, s->cols);\n\n    if (s->s.h.keyframe || s->s.h.intraonly) {\n\n        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n\n    } else {\n\n        memset(s->above_mode_ctx, NEARESTMV, s->cols);\n\n    }\n\n    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n\n    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_segpred_ctx, 0, s->cols);\n\n    s->pass = s->s.frames[CUR_FRAME].uses_2pass =\n\n        ctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;\n\n    if ((res = update_block_buffers(ctx)) < 0) {\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Failed to allocate block buffers\\n\");\n\n        return res;\n\n    }\n\n    if (s->s.h.refreshctx && s->s.h.parallelmode) {\n\n        int j, k, l, m;\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            for (j = 0; j < 2; j++)\n\n                for (k = 0; k < 2; k++)\n\n                    for (l = 0; l < 6; l++)\n\n                        for (m = 0; m < 6; m++)\n\n                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n\n                                   s->prob.coef[i][j][k][l][m], 3);\n\n            if (s->s.h.txfmmode == i)\n\n                break;\n\n        }\n\n        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;\n\n        ff_thread_finish_setup(ctx);\n\n    } else if (!s->s.h.refreshctx) {\n\n        ff_thread_finish_setup(ctx);\n\n    }\n\n\n\n    do {\n\n        yoff = uvoff = 0;\n\n        s->b = s->b_base;\n\n        s->block = s->block_base;\n\n        s->uvblock[0] = s->uvblock_base[0];\n\n        s->uvblock[1] = s->uvblock_base[1];\n\n        s->eob = s->eob_base;\n\n        s->uveob[0] = s->uveob_base[0];\n\n        s->uveob[1] = s->uveob_base[1];\n\n\n\n        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {\n\n            set_tile_offset(&s->tile_row_start, &s->tile_row_end,\n\n                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);\n\n            if (s->pass != 2) {\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    int64_t tile_size;\n\n\n\n                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&\n\n                        tile_row == s->s.h.tiling.tile_rows - 1) {\n\n                        tile_size = size;\n\n                    } else {\n\n                        tile_size = AV_RB32(data);\n\n                        data += 4;\n\n                        size -= 4;\n\n                    }\n\n                    if (tile_size > size) {\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n\n                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    data += tile_size;\n\n                    size -= tile_size;\n\n                }\n\n            }\n\n\n\n            for (row = s->tile_row_start; row < s->tile_row_end;\n\n                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {\n\n                struct VP9Filter *lflvl_ptr = s->lflvl;\n\n                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;\n\n\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,\n\n                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);\n\n\n\n                    if (s->pass != 2) {\n\n                        memset(s->left_partition_ctx, 0, 8);\n\n                        memset(s->left_skip_ctx, 0, 8);\n\n                        if (s->s.h.keyframe || s->s.h.intraonly) {\n\n                            memset(s->left_mode_ctx, DC_PRED, 16);\n\n                        } else {\n\n                            memset(s->left_mode_ctx, NEARESTMV, 8);\n\n                        }\n\n                        memset(s->left_y_nnz_ctx, 0, 16);\n\n                        memset(s->left_uv_nnz_ctx, 0, 32);\n\n                        memset(s->left_segpred_ctx, 0, 8);\n\n\n\n                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n\n                    }\n\n\n\n                    for (col = s->tile_col_start;\n\n                         col < s->tile_col_end;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        // FIXME integrate with lf code (i.e. zero after each\n\n                        // use, similar to invtxfm coefficients, or similar)\n\n                        if (s->pass != 1) {\n\n                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));\n\n                        }\n\n\n\n                        if (s->pass == 2) {\n\n                            decode_sb_mem(ctx, row, col, lflvl_ptr,\n\n                                          yoff2, uvoff2, BL_64X64);\n\n                        } else {\n\n                            decode_sb(ctx, row, col, lflvl_ptr,\n\n                                      yoff2, uvoff2, BL_64X64);\n\n                        }\n\n                    }\n\n                    if (s->pass != 2) {\n\n                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n\n                    }\n\n                }\n\n\n\n                if (s->pass == 1) {\n\n                    continue;\n\n                }\n\n\n\n                // backup pre-loopfilter reconstruction data for intra\n\n                // prediction of next row of sb64s\n\n                if (row + 8 < s->rows) {\n\n                    memcpy(s->intra_pred_data[0],\n\n                           f->data[0] + yoff + 63 * ls_y,\n\n                           8 * s->cols * bytesperpixel);\n\n                    memcpy(s->intra_pred_data[1],\n\n                           f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                    memcpy(s->intra_pred_data[2],\n\n                           f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                }\n\n\n\n                // loopfilter one row\n\n                if (s->s.h.filter.level) {\n\n                    yoff2 = yoff;\n\n                    uvoff2 = uvoff;\n\n                    lflvl_ptr = s->lflvl;\n\n                    for (col = 0; col < s->cols;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n\n                    }\n\n                }\n\n\n\n                // FIXME maybe we can make this more finegrained by running the\n\n                // loopfilter per-block instead of after each sbrow\n\n                // In fact that would also make intra pred left preparation easier?\n\n                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);\n\n            }\n\n        }\n\n\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n\n            adapt_probs(s);\n\n            ff_thread_finish_setup(ctx);\n\n        }\n\n    } while (s->pass++ == 1);\n\n    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n\n\nfinish:\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->s.refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->s.refs[i]);\n\n        if (s->next_refs[i].f->buf[0] &&\n\n            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)\n\n            return res;\n\n    }\n\n\n\n    if (!s->s.h.invisible) {\n\n        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n\n            return res;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    return pkt->size;\n\n}\n", "idx": 20035, "substitutes": {"ctx": ["tmp", "cf", "act", "cv", "rt", "config", "conn", "pkg", "ctr", "hw", "cn", "jp", "tx", "c", "ca", "cm", "anc", "rc", "js", "ck", "mc", "self", "setup", "cp", "sc", "conv", "iat", "jac", "np", "obj", "gc", "kt", "cb", "qt", "wx", "tc", "cu", "ac", "nc", "sys", "cpu", "cc", "kw", "ct", "ctl", "history", " cx", "xc", "bc", "context", "kb", "cmd", "cas", "req", "tz", "cmp", "conf", "cfg", "p"], "frame": ["component", "window", "cf", "type", "profile", "block", "object", "movie", "offset", "header", "chain", "scene", "Frame", "iframe", "rame", "video", "channel", "point", "fb", "info", "fc", "flow", "pointer", "draw", "fram", "def", "fr", "setup", "error", "zo", "event", "face", "feat", "session", "embed", "e", "form", "sequence", "cast", "none", "request", "zero", "id", "index", "reset", "instance", "ce", "frames", "feature", "next", "ence", "image", "base", "process", "show", "response", "name", "p"], "got_frame": [" got_frames", "got_", "received_", "get_", "got_frames", " got_response", " got_state", "got_response", "got_state", " got_"], "pkt": ["pwk", "mnt", "mwk", "Pmsg", "spqt", "cpwk", "ppacket", "Pkt", "cnt", " pck", "ppwk", "Pct", "spwk", "Packet", "cck", "mkt", "pqt", "spnt", "pck", "ckt", "spacket", "cacket", "pmsg", "spux", "macket", "ppkt", "spkt", " pqt", "Pnt", " pwk", " packet", "prokt", "mqt", " pux", "mmsg", "cpacket", "packet", "pct", "cpck", "pux", " pmsg", "ppux", "pront", "proacket", "mct", " pct", "proct", "cpkt", " pnt", "mck", "pnt"], "data": ["done", "window", "text", "length", "pad", "box", "sample", "trans", "map", "video", "content", "info", "size", "json", " DATA", "buffer", "name", "ata", "error", "bytes", "len", "p", "read", "mu", "dat", "table", "buf", "message", "d", "now", "value", "DATA", "area", "Data", "out", "str", "next", "mem", "raw", "image", "input", "t", "step", "batch"], "s": ["is", "a", "c", "h", "args", "sm", "js", "y", "vs", "details", "ims", "v", "utils", "o", "has", "stats", "qs", "less", "ses", "st", "aws", "sw", "tx", "xs", "ports", "ss", "ns", "u", "spec", "ms", "parts", "space", "sports", "state", "times", "w", "S", "cs", "conf", "hs", "p", "sl", "sts", "th", "g", "rs", "sq", "ex", "self", "os", "ess", "go", "set", "sp", "sb", "sf", "sers", "gs", "ssl", "gets", "comm", "bs", "ls", "sv", "ins", "changes", "settings", "r", "ats", "ts", "sys", "its", "b", "ties", "n", "tests", "ds", "sam", "stat", "ps", "t", "fs", "sh", "z", "es"], "res": ["proc", "resource", "ber", "reg", "ries", "rs", "bits", "response", "result", "chain", "fs", "err", "rez", "Res", "js", "rem", "ret", "RES", "css", "values", "def", "os", "conv", "len", "pas", "pos", "re", "rel", "pers", "r", "resp", "gr", "ms", "rev", "expr", "rss", "conf", "zero", "progress", "off", "out", "pres", "reset", "val", "sol", "req", "success", "vals", "status", "resolution", "results", "plain", "ress", "resh", "ps", "rep", "hash", "details", "rest", "red"], "tile_row": ["window_rect", "tile_rc", "window_row", "tile_rect", "window_cell", "window_rc", "tile_cell"], "tile_col": ["tilexcol", "col_column", "tile_column", "tilexct", "tile_ct", "col_col", "col_ct", "tilexrow", "col_row", "tilexcolumn"], "i": ["is", "g", "bi", "gi", "ind", "chain", "ir", "init", "c", "ri", "xi", "ki", "cli", "ai", "info", "ini", "oi", "batch", "q", "li", "ui", "ic", "ip", "ami", "y", "\u0438", "ims", "pi", "iu", "qi", "remote", "r", "zi", "ci", "sim", "me", "index", "id", "gu", "ji", "list", "I", "n", "history", "ii", "ti", "ei", "slice", "ix", "x", "status", "di", "uri", "it", "mi", "hi", "start", "ij", "t", "ski", "multi", "si", "p"], "ref": ["url", "prop", "resource", "type", "alias", "cell", "block", "offset", "ext", "rf", "map", "ef", "Ref", "rem", "ret", "tab", "def", "grab", "fr", "ro", "diff", "pos", "bad", "obj", "img", "cb", "round", "re", "orig", "rel", "remote", "resp", "bug", "buf", "rev", "arg", "reference", "num", "id", "index", "rec", "inter", "reset", "key", "val", "prefix", "link", "REF", "req", "mem", "deg", "pro", "raw", "buff", "ob", "tag", "addr", "rep", "range", "ror"], "row": ["rid", "th", "cell", "ox", "tile", "rs", "vr", "rc", "ro", "tr", "pos", "roll", "group", "r", "rows", "height", "rect", "num", "index", "key", "ow", "w", "ptr", "co", "range", "ror"], "col": ["coord", "cell", "column", "tile", "c", "COL", "cat", "win", "fc", "cp", "pos", "cal", "line", "loc", "pc", "pt", "con", "num", "ct", "color", "val", "rot", "coll", "ch", "il", "fn", "co"], "yoff": ["zoff", "yOFF", "zov", "syov", "syOFF", "yOff", "syoff", " yOFF", "yov", " yOff", "zOff", " yov", "zOFF", "syOff"], "uvoff": ["uuOFF", "uvOFF", "ueoff", "uuoff", "uioffset", "ueOFF", "ueOff", "uioff", "uuoffset", "uvOff", "uiOff", "uvoffset", "ueoffset", "uiOFF", "uuOff"], "ls_y": ["vs_xy", "vs_my", "vs_yy", "vs_y", "ls_yy", "ls_my", "ls2yy", "ls2y", "ls2my", "ls2xy", "ls_xy"], "ls_uv": ["ls_u", "tl_x", "tl_uv", "ls2uv", "tl_cv", "tl_u", "ls2u", "ls_x", "ls2cv", "ls2x", "ls_cv"], "f": ["ff", "cf", "fl", "fab", "g", "fe", "fp", "c", "h", "fac", "fb", "ef", "fc", "info", "lf", "q", "fr", "fx", "F", "fg", "e", "form", "d", "elf", "fu", "b", "v", "fm", "alf", "uf", "o", "ft", "sf", "fi", "full", "file", "fw", "of", "bf", "fo", "xf", "t", "fs", "p"], "bytesperpixel": ["bytesPERpixel", "bytesperframe", "bitsPERpixel", "bytesPerframe", "byteslastpixel", "bytesPERcell", "bytesPERframe", "bitsPERframe", "bitsperpixel", "bitsperframe", "bitsPERcell", "bytespercell", "bytesPerpixel", "byteslastcell", "byteslastframe", "bytesPercell", "bitspercell"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t gt64120_readl (void *opaque,\n\n                               target_phys_addr_t addr, unsigned size)\n\n{\n\n    GT64120State *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    uint32_t val;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfff) >> 2;\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_MULTI:\n\n        /* Only one GT64xxx is present on the CPU bus, return\n\n           the initial value */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n        /* Reading those register should empty all FIFO on the PCI\n\n           bus, which are not emulated. The return value should be\n\n           a random value that should be ignored. */\n\n        val = 0xc000ffee;\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    case GT_CPU:\n\n    case GT_SCS10LD:\n\n    case GT_SCS10HD:\n\n    case GT_SCS32LD:\n\n    case GT_SCS32HD:\n\n    case GT_CS20LD:\n\n    case GT_CS20HD:\n\n    case GT_CS3BOOTLD:\n\n    case GT_CS3BOOTHD:\n\n    case GT_SCS10AR:\n\n    case GT_SCS32AR:\n\n    case GT_CS20R:\n\n    case GT_CS3BOOTR:\n\n    case GT_PCI0IOLD:\n\n    case GT_PCI0M0LD:\n\n    case GT_PCI0M1LD:\n\n    case GT_PCI1IOLD:\n\n    case GT_PCI1M0LD:\n\n    case GT_PCI1M1LD:\n\n    case GT_PCI0IOHD:\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n    case GT_ISD:\n\n        val = s->regs[saddr];\n\n        break;\n\n    case GT_PCI0_IACK:\n\n        /* Read the IRQ number */\n\n        val = pic_read_irq(isa_pic);\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Just return the last written value. */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CFGADDR:\n\n        val = phb->config_reg;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (!(phb->config_reg & (1 << 31))) {\n\n            val = 0xffffffff;\n\n        } else {\n\n            val = pci_data_read(phb->bus, phb->config_reg, 4);\n\n        }\n\n        if (!(s->regs[GT_PCI0_CMD] & 1) && (phb->config_reg & 0x00fff800)) {\n\n            val = bswap32(val);\n\n        }\n\n        break;\n\n\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_CMD:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    if (!(s->regs[GT_CPU] & 0x00001000))\n\n        val = bswap32(val);\n\n\n\n    return val;\n\n}\n", "idx": 20054, "substitutes": {"opaque": ["popaque", "Opque", " opatile", "opatile", "ipque", " opque", "oplaque", "popatile", " opaques", "popaques", "ipatile", "opque", "Opatile", "Oposit", "Opaques", "oposit", "Opaque", "ipaque", "ipaques", "oplatile", "poposit", "oplaques", "oplosit", "opaques"], "addr": ["pad", "arch", "coord", "block", "offset", "ref", "host", "map", "tx", "rc", "port", "ad", "len", "res", "pos", "loc", "kt", "align", "src", "max", "address", "arr", "Address", "work", "aro", "id", "ord", "var", "state", "alloc", "cmd", "prefix", "ix", "mem", "adr", "node", "tag", "ptr", "mt", "hash", "sh", "add"], "size": ["length", "type", "ser", "offset", "sn", "h", "args", "cap", "SIZE", "len", "ize", "set", "address", "d", "m", "id", "num", "sp", "n", "Size", "count", "mem", "w", "start", "hash", "sh", "z", "name"], "s": ["ls", "is", "sts", "sv", "rs", "g", "ins", "sn", "states", "aws", "h", "sq", "c", "ex", "js", "asm", "os", "store", "ss", "y", "vs", "ns", "ims", "r", "e", "ms", "ats", "bs", "ts", "sys", "single", "es", "b", "n", "space", "sports", "sb", "socket", "tes", "stats", "ds", "http", "an", "S", "ssl", "gs", "csv", "ps", "t", "comm", "conf", "fs", "hs", "z", "p"], "phb": ["phr", "phbg", "grr", "grd", "grbg", "phd", "ahb", "ahd", "ahbg", " phr", " phbg", " phd", "ahr", "grb"], "val": ["crit", "prop", "label", "ref", "slot", "fail", "vec", "tx", "Val", "err", "lit", "valid", "VAL", "ret", "def", "urg", "serv", "len", "res", "pos", "rol", "util", "elt", "al", "cal", "loc", "arg", "arr", "eval", "resp", "buf", "vol", "pol", "rel", "value", "v", "var", "ctx", "sol", "au", "data", "alt", "compl", "bal", "vals", "aval", "msg", "bl", "vt", "base", "stat", "ival", "find", "dev", "sel"], "saddr": [" saddress", "daddress", "wsvar", " sadmin", "wsstate", "stsalign", "stsaddr", "stsadmin", "Saddr", "tsaddress", "waddress", " salign", "shost", "shash", " sptr", "tsbound", "dsaddress", " sstate", "saddress", "galign", "ssrc", "wshost", "wsaddr", "walign", "Shash", "wsusr", "sstate", "Saddress", "sadmin", "Shost", " ssrc", "gaddress", "svar", " surg", "sbound", "ssaddr", "tsalign", "ssadmin", "sshash", "dsusr", "dshost", "wbound", " svar", "wsaddress", "ssurg", "gbound", "ssalign", "Susr", "ssaddress", "ssstate", "ssptr", "stsurg", "dsaddr", "Sptr", "tsaddr", "salign", "sptr", "waddr", "daddr", "gaddr", "ssvar", "dptr", "surg", "susr", " shash", "dsrc"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    opt = qemu_opt_find(opts, name);\n\n    if (!opt) {\n\n        QemuOptDesc *desc = opts->list->desc;\n\n        int i;\n\n\n\n        for (i = 0; desc[i].name != NULL; i++) {\n\n            if (strcmp(desc[i].name, name) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc[i].name == NULL) {\n\n            if (i == 0) {\n\n                /* empty list -> allow any */;\n\n            } else {\n\n                fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\",\n\n                        name, opts->list->name);\n\n                return -1;\n\n            }\n\n        }\n\n        opt = qemu_mallocz(sizeof(*opt));\n\n        opt->name = qemu_strdup(name);\n\n        opt->opts = opts;\n\n        TAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n        if (desc[i].name != NULL) {\n\n            opt->desc = desc+i;\n\n        }\n\n    }\n\n    qemu_free((/* !const */ char*)opt->str);\n\n    opt->str = NULL;\n\n    if (value) {\n\n        opt->str = qemu_strdup(value);\n\n    }\n\n    if (qemu_opt_parse(opt) < 0) {\n\n        fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str,\n\n                opts->list->name, opt->name);\n\n        qemu_opt_del(opt);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20070, "substitutes": {"opts": [" oprs", "OPs", "opters", " ops", "optts", "optypes", "protions", "upt", "optns", "operrs", "optps", "OPTS", "iopths", "opms", "opths", "otts", "oprs", "optters", "ioptions", "opns", "iopt", "operts", "opfs", " opcs", "optrs", "upts", "opTS", "proTS", "opcs", "operms", " opters", "OPts", "opttions", "iopms", " opTS", "iopps", " opms", "optt", "ops", "operns", "OPfs", "optfs", "otps", "operters", "options", " opns", "otTS", "opertions", "optcs", "optms", " copcs", "iopts", "prots", "operps", "iopbs", " coptypes", "optths", "props", " copts", " opths", "iopcs", "opps", " optypes", "optTS", " opfs", "upbs", "upcs", "ottions", "opbs", " opps", "optbs", " options", "opttypes", " cops"], "name": ["na", "init", "nam", "def", "store", "syn", "named", "table", "var", "out", "key", "val", "filename", "mem", "word", "node", "ame", "normal", "new", "alias", "nm", " NAME", "title", "root", "order", "len", "ns", "spec", "group", "path", "ma", "code", "comment", "option", "tag", "dev", "admin", "length", "all", "parent", "size", "term", "cap", "version", "error", "class", "dir", "none", "prefix", "member", "no", "number", "module", "type", "label", "attr", "ref", "info", "search", "names", "in", "doc", "ver", "note", "list", "num", "id", "local", "n", "family", "missing", "description", "str", "NAME", "Name", "data", "common", "format", "base", "tree"], "value": ["unit", "text", "type", "label", "get", "initial", "result", "vector", "VALUE", "update", "test", "content", "property", "widget", "password", "values", "json", "term", "variable", "server", "version", "attribute", "event", "expression", "function", "message", "ter", "Value", "summary", "v", "template", "other", "state", "comment", "change", "description", "val", "key", "option", "instance", "data", "str", "format", "tv", "word", "raw", "serial", "hello", "range", "field", "vp"], "opt": ["org", "prop", "init", "cat", "xy", "plot", "def", "ip", "al", "inst", "OP", "max", "optim", "var", "out", "val", "req", "mem", "art", "typ", "proc", "ost", "test", "iter", "lt", "temp", "lit", "ret", "pr", "json", "cp", "null", "obj", "tip", "expr", "eval", "zero", "off", "j", "option", "Opt", "cmd", "anon", "alloc", "oss", "nt", "tag", "usr", "adj", "p", "tmp", "all", "ext", "slot", "ind", "update", "err", "adapt", "parent", "term", "port", "error", "go", "feat", "arg", "buf", "pt", "options", "txt", "alg", "x", "aux", "crit", "rt", "coord", "ok", "attr", "cho", "open", "ref", "jp", "copy", "info", "tr", "img", "select", "ver", "ts", "num", "id", "dest", "n", "alt", "it", "op", "stat", "addr", "t", "opted", "nom", "timeout"], "desc": ["reg", "config", "ext", "ind", "sec", "sel", "recent", "disc", "info", "des", "def", "dim", "sc", "diff", "order", "etc", "doc", "der", "sub", "dist", "loc", "obj", "described", "rel", "dir", "sort", "buf", "path", "eq", "dest", "rec", "txt", "cd", "ctx", "pres", "dep", "comment", "description", "str", "cmd", "md", "asc", "req", "next", "ds", "mem", "deg", "seq", "ec", "msg", "Desc", "pri", "dict", "ptr", "dev", "cmp", "esc", "meta", "details", "decl"], "i": ["is", "init", "y", "ip", "ims", "qi", "v", "I", "ii", "phi", "wait", "status", "hi", "t", "f", "iter", "ui", "pi", "u", "im", "index", "inter", "mi", "ie", "iso", "multi", "p", "g", "gi", "ind", "ri", "xi", "err", "ki", "cli", "ai", "size", "li", "io", "iu", "ci", "l", "sim", "m", "me", "eu", "k", "ti", "x", "next", "uri", "try", "ij", "si", "batch", "bi", "info", "ic", "in", "zi", "list", "id", "ji", "n", "ei", "fi", "ix", "di", "it", "ini", "j", "oi"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n", "idx": 20086, "substitutes": {"dev": [" Dev", "Dev", "window", "conn", "hw", "cam", "sw", "vr", "test", "info", "des", "def", "os", "serv", "device", "obj", "sd", "ver", "spec", "driver", "remote", "att", "query", "scan", "dem", "conf", "d", "gu", "env", "v", "var", "ev", "dd", "ve", "app", "val", "devices", "md", "dis", "cmd", "DEV", "data", "Device", "de", "ds", "mem", "w", "adv", "raw", "nt", "serial", "av", "ch", "tech"], "s": ["is", "as", "states", "fs", "a", "h", "args", "js", "i", "store", "ies", "y", "vs", "ims", "v", "utils", "stats", "qs", "ses", "less", "als", "bes", "eps", "aws", "sw", "steps", "ports", "ss", "serv", "ns", "obj", "sd", "spec", "ms", "sports", "services", "w", "S", "source", "cs", "hs", "p", "sl", "sts", "g", "rs", "south", "sq", "ex", "self", "set", "l", "sp", "mods", "sb", "ar", "gs", "comm", "bs", "ys", "ls", "sv", "changes", "settings", "params", "r", "this", "ats", "ts", "sys", "its", "b", "n", "se", "tests", "ds", "sam", "ps", "t", "details", "sh", "j", "es"], "err": ["kr", "Error", "cr", "attr", "later", "br", "rs", "er", "conn", "mr", "eps", "result", "test", "iter", "fee", "cer", "tar", "h", "ex", "cli", "c", "Er", "or", "warn", "fr", "eor", "error", "res", "der", "elt", "obj", "rr", "r", "arr", "resp", "buf", "gr", "errors", "e", "conf", "sys", "erb", "here", "eas", "txt", "aaa", "ev", "out", "gz", "esp", "ez", "ctx", "ar", "str", "cmd", "notice", "req", "msg", "erd", "inv", "it", "usr", "ch", "die", "ptr", "exc", "cfg", "rn"]}}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20095, "substitutes": {"ehci": ["ehcu", "hessci", " ehcgi", "graphcci", "ethercin", "ekdc", "althcos", "Ehcos", "echcgi", "ahco", "althcci", "hdi", "iahdi", "iahcit", "vehcci", "derci", "khdc", "graphcu", "graphci", "rahcit", "ehcit", " ehc", "dercci", "htmcit", "khcin", "htmci", "vehdi", "htmc", " ehcin", "hesscci", "ethercci", "echdc", "rahini", "ethci", "ehdc", "khcell", "hcci", "ehcgi", "iahcci", "khcos", "ehdi", "archdi", "ehcin", "dercgi", "althcgi", "ehcci", "Ehci", "archcci", "Ohcit", "hcit", "vehci", "Ohcci", "graphcit", "ahci", "khc", "ahc", "khcgi", "khcit", "hesscit", "archci", "echcci", "ahcin", " ehcci", "althci", "Ohcell", "echcin", "Ohcu", "ethercgi", " ehwife", "ethwife", "khdi", "ethercit", "khcu", "etherci", "khci", "hzcit", "ehco", "ehcell", " ehco", "ekcci", "Ehcgi", "htmcell", "ekci", "echci", "khcci", "hci", " ehcu", "ehcos", "hzini", " ehcit", "archcit", "etherini", "rahcu", "rahci", "Ohci", "khco", "hzcu", "ethercu", "iahci", "hzci", "ethcit", "hesswife", "echcit", "Ehcci", "ehc", "ehini", "echcu", "ekcit", "Ohc", "ehwife", "dercu", " ehdi", "vehcu", "ethcci"], "frames": ["levels", "pages", "bits", "ins", "states", "ints", "planes", "cells", "plays", "reports", "inches", "videos", "values", "months", "links", "lines", "fram", "bytes", " Frames", "events", "ours", "ences", " processes", "fps", "weights", "parts", " frame", "ations", "images", "faces", "times", "views", "frame", "files", " fps", "hops", "flags", "dates", "requisites", "Frames", "seconds", "blocks", "features", "fs", "flows"], "i": [" I", "is", " f", "g", "bi", " my", " li", "gi", "ind", " di", "init", " mi", "xi", "ki", " index", "ai", " missing", "li", "ui", "ic", "ip", "y", "in", "\u0438", " ii", "ims", "pi", "iu", "qi", "im", " bi", "ci", "zi", "sim", "m", "index", "gu", " pi", "I", " c", "j", " wi", " iter", "ii", "ti", "print", "fi", "phi", "ix", " parts", "x", " ti", " x", "span", " m", "di", " ni", " si", " j", "mi", " multi", "it", " info", "ini", " me", "multi", "si"]}}
{"project": "FFmpeg", "commit_id": "c9c55a56996836e7783fb27018834f230c553c98", "target": 0, "func": "static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n\n{\n\n    while (uls->id != CODEC_ID_NONE) {\n\n        if(mxf_match_uid(uls->uid, *uid, 16))\n\n            break;\n\n        uls++;\n\n    }\n\n    return uls;\n\n}\n", "idx": 20102, "substitutes": {"uls": ["us", " puls", " pulses", "args", "cus", "rus", "regon", "ames", "ims", "ul", " sus", " vill", "lass", "umers", "ucl", "qs", "uns", "flags", "uci", " MLS", "ossus", "ull", "ucc", "ports", "des", "ilot", "spec", "u", "cu", "uli", "imp", "ishers", "uckles", "cks", "irms", "aus", "results", "cs", " Ips", "ulse", "las", "clus", "uds", "rs", "UL", "ols", "imil", "helps", "urus", "sels", "inces", "ult", "ults", "ups", "tops", "umes", "lus", "icas", "LCS", "ists", " UCS", "pes", "amps", "ulates", "GS", "ls", "fts", "acts", " populations", "US", "ins", " sentiments", " currents", "ud", "kj", "ails", "Us", " los", "ces", "illus", " sidx", "orts", "ix", "aults", "missions", "eus", "phones", "ps", " us"], "uid": ["gain", "unit", "us", "rid", "ua", "did", "UID", "user", "du", "cat", "uk", "std", "uh", "cum", "gin", "mask", "ud", "username", "util", "gc", "kt", "mu", "u", "cu", "ul", "pet", "pid", "id", "cpu", "bid", "hn", "vid", "kid", "tu", "nu", "dd", "who", "comment", "aw", "sid", "uni", "gpu", "uv", "uri", "uint", "upload", "eus", "upid", "oid", "tag", "usr", "uu", "iq", "addr", "unique", "pu"]}}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n", "idx": 20105, "substitutes": {"chr": [" chrb", "chnr", "CHor", "cyr", "ichres", "chres", "chnri", "CHrt", "Chri", "ichrt", "cyre", "cyrs", " chor", "chrs", "Chr", " chrt", "Char", "CHr", "Chrb", "ichor", "chrt", "charrb", "chrc", "chnrb", "Chre", "charrs", " chrs", "chre", " chre", "chor", "chnrc", "Chrc", "chrb", "charr", "ichr", "cyar", "Chrs", "chri", "ichri", " chres", "charar", "ichrc", "ichrb", "CHres"], "connected": ["present", "ready", "disabled", "closed", "fitted", "ed", "locked", "equipped", "opened", "selected", "started", "owned", "licensed", "active", "colored", "encrypted", "status", "mounted", "updated", "fed", "visible", "enabled", "productive", "provided", "ended", "loaded", "powered", "pressed", "client", "authorized", "tested", "success", "joined", "running", "generated", " attached", "conn", "valid", "documented", "reported", "checked", "available", "wired", "functional", "socket", "supported", "shown", "initialized", "online", "bound", "created", "cond", "established", "linked", "induced", "developed", "played", "open", " disconnected", "controlled", "connection", "accessible", "connect", "built", "called", "nc", "successful", "modified", "charged", "registered", "rolled", "responsive", "current", "ached", "hidden"], "s": ["is", "as", "fs", "a", "h", "js", "asm", "store", "y", "ies", "vs", "ims", "utils", "stats", "qs", "ses", "less", "als", " cs", "eps", "aws", "ports", " self", "ss", "serv", "ns", "spec", "ms", "client", "sports", "services", " ss", "S", "cs", "hs", "p", "sts", "g", "rs", "sq", "self", "conv", "set", "pers", "l", "m", "acs", " ps", "sb", "gs", "ssl", "ssh", "comm", "bs", "ys", "ls", "sv", "ins", "so", "search", "server", "ears", "ats", "sync", "ts", "sys", "b", "se", "ds", "sam", "ps", "details", "j", "es"]}}
{"project": "FFmpeg", "commit_id": "544286b3d39365b30298ae07e66a755200b0895c", "target": 1, "func": "int h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format, width, height;\n\n\n\n    /* picture header */\n\n    if (get_bits(&s->gb, 22) != 0x20)\n\n        return -1;\n\n    skip_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1)\n\n        return -1;\t/* marker */\n\n    if (get_bits1(&s->gb) != 0)\n\n        return -1;\t/* h263 id */\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n\n\n    if (format != 7) {\n\n        s->h263_plus = 0;\n\n        /* H.263v1 */\n\n        width = h263_format[format][0];\n\n        height = h263_format[format][1];\n\n        if (!width)\n\n            return -1;\n\n\n\n        s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n\n\n        s->unrestricted_mv = get_bits1(&s->gb); \n\n        s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* SAC: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* advanced prediction mode: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* not PB frame */\n\n\n\n        s->qscale = get_bits(&s->gb, 5);\n\n        skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n    } else {\n\n        s->h263_plus = 1;\n\n        /* H.263v2 */\n\n        /* OPPTYPE */\n\n     \n\n        if (get_bits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */\n\n            return -1;\n\n        format = get_bits(&s->gb, 3);\n\n                \n\n        skip_bits(&s->gb,1); /* Custom PCF */\n\n        umvplus_dec = get_bits(&s->gb, 1); /* Unrestricted Motion Vector */\n\n        skip_bits(&s->gb, 10);\n\n        skip_bits(&s->gb, 3); /* Reserved */\n\n        \n\n        /* MPPTYPE */\n\n        s->pict_type = get_bits(&s->gb, 3) + 1;\n\n        if (s->pict_type != I_TYPE &&\n\n            s->pict_type != P_TYPE)\n\n            return -1;\n\n        skip_bits(&s->gb, 7);\n\n        \n\n        /* Get the picture dimensions */\n\n        if (format == 6) {\n\n            /* Custom Picture Format (CPFMT) */\n\n            skip_bits(&s->gb, 4); /* aspect ratio */\n\n            width = (get_bits(&s->gb, 9) + 1) * 4;\n\n            skip_bits1(&s->gb);\n\n            height = get_bits(&s->gb, 9) * 4;\n\n#ifdef DEBUG \n\n            fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n\n#endif            \n\n        }\n\n        else {\n\n            width = h263_format[format][0];\n\n            height = h263_format[format][1];\n\n        }\n\n        \n\n        if ((width == 0) || (height == 0))\n\n            return -1;\n\n            \n\n        if (umvplus_dec) {\n\n            skip_bits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n\n        }\n\n            \n\n        s->qscale = get_bits(&s->gb, 5);\n\n    }\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n    s->width = width;\n\n    s->height = height;\n\n    return 0;\n\n}\n", "idx": 20109, "substitutes": {"s": ["us", "is", "er", "as", "states", "c", "js", "y", "ies", "vs", "details", "ims", "tes", "stats", "qs", "ses", "less", "status", "comments", "ers", "als", "eps", "aws", "ports", "des", "ants", "ss", "sg", "ns", "spec", "session", "ms", "parts", "bis", "services", "S", "results", "cs", "rates", "conf", "hs", "p", "sts", "ains", "rs", "ops", "sq", "err", "css", "os", "set", "pers", "acs", "sb", "ar", "gs", "comm", "bs", "ls", "sv", "ins", "changes", "copy", "search", "params", "ears", "ats", "ts", "sys", "its", "sets", "b", "n", "eds", "tests", "ds", "ps", "fs", "es"], "format": ["unit", "f", "act", "type", "length", "layout", "label", "action", "filter", "fp", "init", "method", "cat", "lat", "flat", "use", "settings", "title", "size", "port", "style", "digit", "position", "scale", "dim", "version", "padding", "pattern", "api", "feat", "set", "form", "function", "sort", "commit", "none", "fit", "ats", "list", "date", "index", "mat", "mode", "color", "missing", "Format", "print", "option", "AT", "prefix", "feature", "html", "file", "frame", "status", "transform", "it", "MAT", "stat", "at", " Format", "tag", "fn", "t", "range", "edit"], "height": ["window", "length", "volume", "chain", "crop", "h", "depth", "size", "gravity", "radius", "shape", "dim", "scale", "bottom", "padding", "y", "build", "quality", "pi", "above", "grow", "rows", "history", "total", "hang", "alpha", "capacity", "html", "count", "frame", "resolution", "density", "huge", "Height", "loss", "hash"]}}
{"project": "qemu", "commit_id": "f3d8b1eb105199a1d6bf063a8a574e782689909a", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           DisplayState *ds, stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    qemu_irq *gpio_in[5];\n\n    qemu_irq *gpio_out[5];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    i2c_bus *i2c;\n\n    int i;\n\n\n\n    flash_size = ((board->dc0 & 0xffff) + 1) << 1;\n\n    sram_size = (board->dc0 >> 18) + 1;\n\n    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        adc = stellaris_adc_init(0x40038000, pic[14]);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            stellaris_gptm_init(0x40030000 + i * 0x1000,\n\n                                pic[timer_irq[i]], adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],\n\n                                    &gpio_out[i]);\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        i2c = i2c_init_bus();\n\n        stellaris_i2c_init(0x40020000, pic[8], i2c);\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            ssd0303_init(ds, i2c, 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            pl011_init(0x4000c000 + i * 0x1000, pic[uart_irq[i]],\n\n                       serial_hds[i], PL011_LUMINARY);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void * oled;\n\n            void * sd;\n\n            void *ssi_bus;\n\n            int index;\n\n\n\n            oled = ssd0323_init(ds, &gpio_out[GPIO_C][7]);\n\n            index = drive_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n", "idx": 20110, "substitutes": {"kernel_filename": ["kernelingfamily", "ernel_name", "ernel_family", "kernel_file", "kernel_name", " kernel_Filename", "ernel_file", " kernel_profile", "kernelingfilename", "kernel_Filename", "kernelleFilename", "kernel_profile", "kernelleprofile", "kernel_family", "kernelingname", "kernelingfile", "kernellefilename", "kernellefile", "ernel_filename", " kernel_file"], "cpu_model": ["cpu_Model", "cpuvalflag", "puetymodels", "cpuetymodels", "cpuvalmodel", "CPU_location", "pu_type", "puetytype", "cpu_location", "cpuetymodel", "pu_models", "CPU_Model", "cpu_flag", "cpuetyModel", "puetyModel", "pu_model", "cpuvallocation", "pu_Model", "cpu_models", "puetymodel", "cpuvalModel", "CPU_model", "cpu_type", "CPU_flag", "cpuetytype"], "ds": ["ks", "rs", "du", "df", "vd", "bd", "dl", "des", "def", "os", "dt", "ss", "dos", "Ds", "da", "dm", "dh", "DS", "dd", "db", "de", "ses", "cs", "ps", "dds", "bs", "pd", "ros"], "board": ["bit", "box", "block", "config", "boot", "runner", "builder", "bus", "video", "bd", "du", "card", "ward", "lock", "bar", "fc", "ck", "deck", "ud", "bank", "def", "buffer", "boarding", "setup", "ro", "sc", "bro", "body", "kt", "way", "bug", "player", "reader", "form", "check", "sync", "list", "boards", "d", "cpu", "ack", "row", "record", "ctl", "back", "hub", "bot", "core", "dd", "bc", "rot", "control", "member", "Board", "bang", "controller", "frame", "loop", "mac", "view", "word", "base", "ob", "lo", "design", "layout", "oard", "bo"], "uart_irq": ["uart_iraql", "uart_vrq", "uart__pirve", "uart_pirqs", "uart_vrve", "uart__irql", "uart__irqs", "uart_pirve", "uart__pirql", "uart_irve", "uart_iraqs", "uart_irql", "uart_iraq", "uart__pirq", "uart_vrql", "uart_pirql", "uart_vrqs", "uart__pirqs", "uart__irve", "uart_irqs", "uart__irq", "uart_pirq", "uart_irave"], "timer_irq": ["timer_irqs", "timer_irech", "timer_ireqs", "timer_rinqs", "timer_rinch", "timer__pirqs", "timer_rinq", "timer__pirq", "timer__irch", "timer_pirqu", "timer_irequ", "timer_irch", "timer__irqs", "timer_irich", "timer_ireq", "timer_rinqu", "timer__irq", "timer_iriq", "timer_pirq", "timer_pirqs", "timer_pirch", "timer__pirch", "timer_iriqs", "timer_irreq", "timer__irqu", "timer_pirreq", "timer_irireq", "timer__pirqu", "timer_irqu", "timer_rinreq"], "gpio_addr": ["gpio____inter", "gpio__add", "gpio_inter", "gpio____in", "gpio____addr", "gpio_align", "gpios_addr", "gpio2addr", "gpios_address", "gpios_inter", "gpio2align", "gpio_address", "gpio__inter", "gpio2add", "gpios_align", "gpio2address", "gpios_add", "gpio__addr", "gpio__in", "gpio_add", "gpio____add", "gpios_in"], "gpio_irq": ["gpio_errqs", "gpio_pirz", "gpio_irue", "gpio_ireue", "gpio_iriq", "gpio_irz", "gpio_pirue", "gpio_mirqs", "gpio_errz", "gpio_irqs", "gpio_ireqs", "gpio_rinq", "gpio_errq", "gpio_riniq", "gpio_rinqs", "gpio_rinz", "gpio_erriq", "gpio_pirq", "gpio_piriq", "gpio_mirq", "gpio_pirqs", "gpio_mirue", "gpio_ireq"], "pic": ["proc", "Picture", "px", "cam", "jp", "ics", "sac", "nic", "pac", "fc", "pict", "pipe", "pr", "mc", "icc", "trap", "ic", "shot", "ip", "doc", "ig", "pins", "iac", "pi", "pp", "pb", "pl", "gc", "jac", "arg", "arr", "picture", "lp", "ac", "pc", "pol", "sp", "txt", "pa", "script", "png", "pin", "photo", "photos", "par", "capt", "lib", "py", "magic", "lic", "Pic", "ps", "wic", "eric", "arc", "p"], "gpio_in": ["gpios_ind", "gpio___rin", "gpios_ic", "gpio___out", "gpios_ins", "gpios_out", "gpio___in", "gpios_rin", "gpio_ins", "gpio_ind", "gpio___ind", "gpio_rin", "gpio_ic", "gpios_in"], "gpio_out": ["gpio2outs", "gpio1outs", "gpio_output", "gpio2in", "gpio1out", "gpios_gen", "gpio1gen", "gpios_output", "gpio_gen", "gpio1in", "gpio_outs", "gpios_out", "gpios_outs", "gpio2out", "gpio2gen", "gpios_in"], "adc": ["adcc", "edt", "adgc", "agc", " adgc", "Adb", " adf", "aycon", " adl", "adf", "odcc", " adb", " adcc", "agcc", "Adl", "dt", "adp", "acc", "agpc", "ayc", " adp", "edf", "Adf", "adt", "Adc", "odgc", "odc", "adcon", "accon", "Adp", "db", "adpc", "edc", "accc", "aypc", "aycc", "adb", "acpc", "edl", " adt", "Adt", "agcon", "acgc", " adpc", "dp", "dc", "odpc", "adl"], "sram_size": ["sdam_size", "sram1name", "sram2length", "sram2count", "sram_SIZE", "srum1name", "srum1size", "sream_count", "sream_size", "srum1SIZE", "sdam2SIZE", "sram1SIZE", "sram_name", "srum_name", "sream_Size", "srum_size", "sream_name", "sdam2size", "sdam_SIZE", "sram2size", "sdam_Size", "sram_count", "sdam2length", "sram_Size", "sdam_length", "sram1count", "srum_count", "srum_SIZE", "sram2name", "sram2Size", "srum1count", "sram2SIZE", "sram1size", "sdam2Size", "sram_length"], "flash_size": ["usbvalwidth", "usbvalspeed", "flash_SIZE", " flash_SIZE", "flashvalSIZE", "flashlexspeed", "flashLogspeed", "cell_Size", "usbvalsize", "cell_start", "flash_width", "flashLogSize", "flash_Size", "usb_size", "flash_speed", "flashvalspeed", "cell_size", "flashlexwidth", "flashLogstart", "flash_loc", " flash_loc", "flash_start", "flashlexsize", "cell_speed", "usbvalSIZE", "usb_speed", "flashlexSIZE", " flash_Size", "usb_SIZE", "flashvalwidth", "flashvalsize", "usb_width", "flashLogsize"], "i2c": ["i1n", "i2n", " i1f", " i2n", "i7e", "i3c", " i2f", "i2f", " i1e", " i1c", " i2e", "i7n", " i1n", "i3f", "i1f", "i1e", "i3e", "i2e", "i7c", "i1c", "i7f", "i3n"], "i": ["is", "init", "c", "h", "ip", "y", "ami", " ii", "qi", "iii", "e", "wi", "v", "I", "o", "ii", "phi", " ti", "span", "status", " j", "hi", "ui", "\u0438", "pi", "u", "im", "s", "mi", "multi", "p", "g", "gi", "ind", "chain", "ri", "xi", "ki", "ex", "cli", "ai", "q", "li", "io", "iu", "ci", "l", "me", "m", "sim", "eu", "sp", "k", "ti", "x", "dr", "ij", "si", "bi", "ini", "ic", "in", "zi", "r", "this", "ji", "id", "gu", "n", "ei", "ix", "di", "it", "t", "j", "oi"]}}
{"project": "FFmpeg", "commit_id": "47219e1c0c2f8a159e70b58e6293c169c7dd62cc", "target": 1, "func": "static void do_video_out(AVFormatContext *s,\n\n                         OutputStream *ost,\n\n                         InputStream *ist,\n\n                         AVFrame *in_picture,\n\n                         int *frame_size, float quality)\n\n{\n\n    int nb_frames, i, ret, av_unused resample_changed;\n\n    AVFrame *final_picture, *formatted_picture;\n\n    AVCodecContext *enc, *dec;\n\n    double sync_ipts;\n\n\n\n    enc = ost->st->codec;\n\n    dec = ist->st->codec;\n\n\n\n    sync_ipts = get_sync_ipts(ost) / av_q2d(enc->time_base);\n\n\n\n    /* by default, we output a single frame */\n\n    nb_frames = 1;\n\n\n\n    *frame_size = 0;\n\n\n\n    if(video_sync_method){\n\n        double vdelta = sync_ipts - ost->sync_opts;\n\n        //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c\n\n        if (vdelta < -1.1)\n\n            nb_frames = 0;\n\n        else if (video_sync_method == 2 || (video_sync_method<0 && (s->oformat->flags & AVFMT_VARIABLE_FPS))){\n\n            if(vdelta<=-0.6){\n\n                nb_frames=0;\n\n            }else if(vdelta>0.6)\n\n                ost->sync_opts= lrintf(sync_ipts);\n\n        }else if (vdelta > 1.1)\n\n            nb_frames = lrintf(vdelta);\n\n//fprintf(stderr, \"vdelta:%f, ost->sync_opts:%\"PRId64\", ost->sync_ipts:%f nb_frames:%d\\n\", vdelta, ost->sync_opts, get_sync_ipts(ost), nb_frames);\n\n        if (nb_frames == 0){\n\n            ++nb_frames_drop;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** drop!\\n\");\n\n        }else if (nb_frames > 1) {\n\n            nb_frames_dup += nb_frames - 1;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** %d dup!\\n\", nb_frames-1);\n\n        }\n\n    }else\n\n        ost->sync_opts= lrintf(sync_ipts);\n\n\n\n    nb_frames= FFMIN(nb_frames, max_frames[AVMEDIA_TYPE_VIDEO] - ost->frame_number);\n\n    if (nb_frames <= 0)\n\n        return;\n\n\n\n    formatted_picture = in_picture;\n\n    final_picture = formatted_picture;\n\n\n\n#if !CONFIG_AVFILTER\n\n    resample_changed = ost->resample_width   != dec->width  ||\n\n                       ost->resample_height  != dec->height ||\n\n                       ost->resample_pix_fmt != dec->pix_fmt;\n\n\n\n    if (resample_changed) {\n\n        av_log(NULL, AV_LOG_INFO,\n\n               \"Input stream #%d.%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               ist->file_index, ist->st->index,\n\n               ost->resample_width, ost->resample_height, av_get_pix_fmt_name(ost->resample_pix_fmt),\n\n               dec->width         , dec->height         , av_get_pix_fmt_name(dec->pix_fmt));\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    ost->video_resample = dec->width   != enc->width  ||\n\n                          dec->height  != enc->height ||\n\n                          dec->pix_fmt != enc->pix_fmt;\n\n\n\n    if (ost->video_resample) {\n\n        final_picture = &ost->resample_frame;\n\n        if (!ost->img_resample_ctx || resample_changed) {\n\n            /* initialize the destination picture */\n\n            if (!ost->resample_frame.data[0]) {\n\n                avcodec_get_frame_defaults(&ost->resample_frame);\n\n                if (avpicture_alloc((AVPicture *)&ost->resample_frame, enc->pix_fmt,\n\n                                    enc->width, enc->height)) {\n\n                    fprintf(stderr, \"Cannot allocate temp picture, check pix fmt\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n            /* initialize a new scaler context */\n\n            sws_freeContext(ost->img_resample_ctx);\n\n            ost->img_resample_ctx = sws_getContext(dec->width, dec->height, dec->pix_fmt,\n\n                                                   enc->width, enc->height, enc->pix_fmt,\n\n                                                   ost->sws_flags, NULL, NULL, NULL);\n\n            if (ost->img_resample_ctx == NULL) {\n\n                fprintf(stderr, \"Cannot get resampling context\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n        sws_scale(ost->img_resample_ctx, formatted_picture->data, formatted_picture->linesize,\n\n              0, ost->resample_height, final_picture->data, final_picture->linesize);\n\n    }\n\n#else\n\n    if (resample_changed) {\n\n        avfilter_graph_free(&ost->graph);\n\n        if (configure_video_filters(ist, ost)) {\n\n            fprintf(stderr, \"Error reinitialising filters!\\n\");\n\n            exit_program(1);\n\n        }\n\n    }\n\n#endif\n\n    if (resample_changed) {\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    /* duplicates frame if needed */\n\n    for(i=0;i<nb_frames;i++) {\n\n        AVPacket pkt;\n\n        av_init_packet(&pkt);\n\n        pkt.stream_index= ost->index;\n\n\n\n        if (s->oformat->flags & AVFMT_RAWPICTURE) {\n\n            /* raw pictures are written as AVPicture structure to\n\n               avoid any copies. We support temorarily the older\n\n               method. */\n\n            AVFrame* old_frame = enc->coded_frame;\n\n            enc->coded_frame = dec->coded_frame; //FIXME/XXX remove this hack\n\n            pkt.data= (uint8_t *)final_picture;\n\n            pkt.size=  sizeof(AVPicture);\n\n            pkt.pts= av_rescale_q(ost->sync_opts, enc->time_base, ost->st->time_base);\n\n            pkt.flags |= AV_PKT_FLAG_KEY;\n\n\n\n            write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n            enc->coded_frame = old_frame;\n\n        } else {\n\n            AVFrame big_picture;\n\n\n\n            big_picture= *final_picture;\n\n            /* better than nothing: use input picture interlaced\n\n               settings */\n\n            big_picture.interlaced_frame = in_picture->interlaced_frame;\n\n            if (ost->st->codec->flags & (CODEC_FLAG_INTERLACED_DCT|CODEC_FLAG_INTERLACED_ME)) {\n\n                if(top_field_first == -1)\n\n                    big_picture.top_field_first = in_picture->top_field_first;\n\n                else\n\n                    big_picture.top_field_first = top_field_first;\n\n            }\n\n\n\n            /* handles sameq here. This is not correct because it may\n\n               not be a global option */\n\n            big_picture.quality = quality;\n\n            if(!me_threshold)\n\n                big_picture.pict_type = 0;\n\n//            big_picture.pts = AV_NOPTS_VALUE;\n\n            big_picture.pts= ost->sync_opts;\n\n//            big_picture.pts= av_rescale(ost->sync_opts, AV_TIME_BASE*(int64_t)enc->time_base.num, enc->time_base.den);\n\n//av_log(NULL, AV_LOG_DEBUG, \"%\"PRId64\" -> encoder\\n\", ost->sync_opts);\n\n            if (ost->forced_kf_index < ost->forced_kf_count &&\n\n                big_picture.pts >= ost->forced_kf_pts[ost->forced_kf_index]) {\n\n                big_picture.pict_type = AV_PICTURE_TYPE_I;\n\n                ost->forced_kf_index++;\n\n            }\n\n            ret = avcodec_encode_video(enc,\n\n                                       bit_buffer, bit_buffer_size,\n\n                                       &big_picture);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Video encoding failed\\n\");\n\n                exit_program(1);\n\n            }\n\n\n\n            if(ret>0){\n\n                pkt.data= bit_buffer;\n\n                pkt.size= ret;\n\n                if(enc->coded_frame->pts != AV_NOPTS_VALUE)\n\n                    pkt.pts= av_rescale_q(enc->coded_frame->pts, enc->time_base, ost->st->time_base);\n\n/*av_log(NULL, AV_LOG_DEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\",\n\n   pkt.pts != AV_NOPTS_VALUE ? av_rescale(pkt.pts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1,\n\n   pkt.dts != AV_NOPTS_VALUE ? av_rescale(pkt.dts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1);*/\n\n\n\n                if(enc->coded_frame->key_frame)\n\n                    pkt.flags |= AV_PKT_FLAG_KEY;\n\n                write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n                *frame_size = ret;\n\n                video_size += ret;\n\n                //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\",\n\n                //        enc->frame_number-1, ret, enc->pict_type);\n\n                /* if two pass, output log */\n\n                if (ost->logfile && enc->stats_out) {\n\n                    fprintf(ost->logfile, \"%s\", enc->stats_out);\n\n                }\n\n            }\n\n        }\n\n        ost->sync_opts++;\n\n        ost->frame_number++;\n\n    }\n\n}\n", "idx": 20129, "substitutes": {"s": ["ls", "is", "sts", "rs", "st", "as", "a", "c", "sq", "ops", "h", "js", "os", "ss", "serv", "ns", "sd", "spec", "src", "ats", "ts", "sys", "its", "o", "stats", "ds", "S", "gs", "cs", "ps", "t", "bs", "fs", "hs", "p"], "ost": ["org", "hop", "oo", " nost", "sta", "oster", "or", "store", "etc", "oh", "o", "ast", "old", "art", "osta", "oid", "rest", "st", "sw", "onet", "ogg", "rob", "lost", "omm", "ot", "obj", "embed", "zero", "tto", "ora", "console", "oss", "nt", "irst", "sts", "lov", "oad", "host", "rog", "ops", "otype", "post", "os", "rost", "rol", "utt", "olog", "ether", "arent", "ocr", "oc", "yt", "ust", "iop", "ob", "ys", "ond", "rt", "OST", "tt", "ox", "ott", "so", "hess", "obs", "must", "iot", "istor", "oman", "est", "ort", "sys", "rss", "ord", "oth", "ocol", "om", "ream", "et", "op", "news", "irc", "od"], "ist": ["ih", "irst", "is", "sts", "xt", "ont", "aci", "ik", "st", "isting", "ins", "oad", "pect", "fp", "ism", "ush", "icol", "ic", "ess", "ilst", "ip", "ird", "istor", "wp", "its", "alist", "ith", "oth", "vp", "IST", "ast", "et", "dit", "ust", "iop", "ict", "ista", "ists", "irc", "isc", "il", "iste"], "in_picture": ["inockpicture", "in_comment", "inzpict", "inockphoto", "inockdocument", "inLpicture", "in_document", "in___photo", "inzcomment", " in_document", "inzprofile", "inLprofile", " in_pict", " in_profile", "in_pict", " in_photo", "in___profile", "inLpict", "in___document", "inLcomment", "in_photo", "inockprofile", "in___picture", " in_comment", "inzpicture", "in_profile"], "frame_size": ["window_size", "frame_scale", "window_SIZE", "frame_Size", "frame_len", "window_len", "window_loss", "frame_SIZE", "frame_bytes", "window_scale", "window_Size", "window_bytes", "frame_loss"], "quality": [" rating", " qualifier", " frequency", " level", " divergence", " qualities", " aspect", "Quality", " confidence", " qual", "q", "scale", " significance", " Quality", " quiet", " compression", "frequency", " accuracy", " priority", " gamma", " resolution", " zoom", " clip", " equality", " performance", "qual", " fidelity"], "nb_frames": ["nb5thumbnails", "nb_videos", "nb____features", "nb5cells", "nb___items", "nbYimages", "nb\u0648features", "sb_rows", "nb___videos", "nb8frames", "cdn_lines", "nb___planes", "obb_events", "ni_versions", "batch_frames", "nb5images", "cdnJphones", "nz\u0648jobs", "nb_ims", "nb__planes", "nr_frames", "batch_flows", "NB_frames", "nb_jobs", "nr_images", "n_objects", "nb67bits", "NB_shots", "nb__videos", "NB_images", "nbWframes", "nb_lines", "sbJrows", "sbJseconds", "NB_planes", "nb__images", "nb\u0648jobs", "nb8ims", "nb____shots", "cdn5frames", "nz_jobs", "nb_shots", "nb____jobs", "nb_rows", "nb67rows", "nbJphones", "nb5frames", "nb____faces", "nb\u0648frames", "nbJframes", "nbJfaces", "sbJfaces", "nb67items", "cdn_phones", "nbptframes", "nb8users", "nb_objects", "ni_planes", "nbYframes", "nb_images", "nb_flows", "nb_fps", "nb___phones", "nbWobjects", "sb_seconds", "nb___images", "nb67faces", "n_faces", "nb_links", "cdn_frames", "nb8events", "nb_seconds", "obb_frames", "cdnJims", "nr_items", "cdn5images", "cdn5thumbnails", "NB_values", "nb_modules", "nr_bits", "nbJims", "nb67seconds", "nb_items", "nb8phones", "nz_faces", "nb_cells", "nb_users", "nz\u0648faces", "NB_videos", "nb___bits", "NB_objects", "sbJframes", "cdn_cells", "nbWvalues", "nb____links", "nb____frames", "cdnJlines", "nb67frames", "nbYvalues", "cdn5cells", "ni_images", "nz_features", "nb8fps", "nb8lines", "batch_modules", "ni_frames", "nb_versions", "n_videos", "cdn_images", "nbptimages", "nb_planes", "cdn_thumbnails", "nb_phones", "nb67images", "nb_thumbnails", "cdnJframes", "nbptversions", "nz_frames", "n_frames", "nb___ims", "nbptplanes", "nb\u0648faces", "NB_links", "sb_frames", "nz\u0648features", "obb_fps", "nbYobjects", "cdn_ims", "nb___frames", "nz\u0648frames", "obb_users", "nbJseconds", "nb_values", "nb__frames", "nb_bits", "nb___lines", "sb_faces", "nbJlines", "nb_features", "nb____planes", "nb_events", "nbJrows", "nb_faces", "nbWimages"], "i": ["f", "is", "g", "bi", "ir", "c", "ai", "ip", "iat", "pi", "iu", "r", "ci", "m", "index", "b", "I", "n", "ii", "ti", "fi", "it", "mi", "ij", "t", "j", "si", "p"], "ret": ["new", "rt", "ref", "result", "jp", "rem", "bool", "len", "res", "img", "elt", "ll", "flag", "re", "rel", "RET", "fu", "out", "ft", "reset", "val", "fi", "alt", "mem", "status", "rm", "aux"], "resample_changed": ["ressample_failed", "resample_change", "resample2changed", "resample_diff", "resample_loaded", "ressample_changed", "ressample_created", "resamp_loaded", "resample_failed", "resample2failed", "resample2created", "resamp_diff", "resample_created", "resamp_change", "resamp_changed", "ressample_change", "resample2change"], "final_picture": ["final_summary", " final___img", " final___picture", "Final_picture", " final_video", "Final___profile", "final___video", "Final_pic", " final___summary", "final___proof", "final_profile", "final___profile", "final_pic", "Final___proof", "final_proof", " final_summary", "finalisedimg", "Final_proof", "final___img", "finalisedvideo", "Final___picture", "finalisedsummary", "final___summary", " final___video", " final_img", "final___picture", "finalisedpicture", "final___pic", "Final___pic", "final_video", "Final_profile", "final_img"], "formatted_picture": ["formated___picture", "formatted___photo", "formated_memory", "formated___profile", "formated_photo", "formated_audio", "formattedlyaudio", "formated_profile", "formated_conference", "formatted_image", "formatted___profile", "formated___audio", "formattedlypicture", "formatted_profile", "formatted___pic", "formatted_pic", "formated___status", "formatted___status", "formattedlystatus", "formatted_photo", "formated_pic", "formatted_memory", "formatted___image", "formattedlyprofile", "formatted___audio", "formatted_audio", "formatted_conference", "formated_picture", "formatted___picture", "formated_image", "formated___image", "formatted_status", "formated___photo", "formated___pic", "formated_status"], "enc": ["act", "cv", "lc", "ENC", "en", "conn", "inc", "c", "fc", "rc", "anc", "Enc", "ic", "conv", "acc", "iv", "unc", "ens", "ac", "pc", "nc", "cc", "rec", "ack", "env", "ctx", "code", "xc", "oc", "ew", "desc", "et", "oder", "cur", "Dec", "ec", "cod", "lang", "ent", "cs", "eng", "eric"], "sync_ipts": ["sync_ptts", "sync_pts", "sync_ptb", "sync___iptts", "sync_iprs", "sync___iptps", "sync_ipps", "sync_ptls", "sync_rolrs", "sync_iptls", "sync_iptz", "sync_seqs", "sync_opes", "sync_rectts", "sync_seqls", "sync_opps", "sync_ptrs", "sync_iptes", "sync___iptrs", "sync___ipps", "sync_rols", "sync_ocols", "sync_rectps", "sync___ips", "sync_ocolps", "sync_rolts", "sync_cmdls", "sync_opb", "sync_rolps", "sync_ptz", "sync_cmdts", "sync_ocolrs", "sync_ptps", "sync___ipts", "sync_cmdps", "sync_iptb", "sync_oprs", "sync___iprs", "sync_rectz", "sync_iptts", "sync_seqps", "sync_ptes", "sync_ocolts", "sync_ointes", "sync_seqts", "sync_ointb", "sync_ips", "sync_rolz", "sync_rects", "sync_iptrs", "sync_ointts", "sync_oints", "sync_cmds", "sync_ops", "sync_iptps"], "nb_frames_drop": ["nb_links_single", "nb_links_drop", "nb_links_dl", "nb_links_drops", "nb_frames_dl", "nb_frames_drops", "nb_frames_single"], "sync_opts": ["sync_oppls", "sync_opct", "sync_OPs", "sync_optts", "sync_OPts", "sync_oppct", "sync_oppts", "sync_atts", "sync_opcs", "sync_opsct", "sync_ipt", "sync_OPters", "sync_opps", "sync_optps", "sync_ipcs", "sync_opt", "sync_optcs", "sync_optt", "sync_atps", "sync_OPcs", "sync_optters", "sync_ips", "sync_opls", "sync_OPls", "sync_OPct", "sync_opsts", "sync_opss", "sync_atters", "sync_OPt", "sync_opsls", "sync_ops", "sync_OPps", "sync_ats", "sync_opters"], "frame_number": ["frameNameNumber", "frame_no", "frameNameno", "image_span", "image_no", "image_Number", "frame_Number", "image_number", "frame_span", "frameNamenumber", "frameNamespan"]}}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n", "idx": 20131, "substitutes": {"opaque": [" Opacity", "obossibly", "obosit", "Opacity", "oplacity", "opatile", "opacity", "OPaque", "oplaque", " Opossibly", "OPacity", "obaque", "OPaques", "obacity", "Opossibly", "Oposit", "oposit", "Opaque", "obatile", " Opaque", "oplatile", " Oposit", "OPatile", "oplaques", "obaques", "opaques", "opossibly"], "dbs": ["ldbs", "dans", "dsbs", "dbbas", "dbos", "smes", "dvals", "dbas", "dbbs", " dbes", "dsbes", "ldBS", "dscs", "sbs", "ldbas", "davals", "dcs", "sdbs", "sdvals", "dabs", "dos", "sbas", "sos", "dsmes", " dns", "dsbas", " dbas", " dcs", "ldos", "dbBS", "dsos", "dbcs", "dmes", "dns", "sdbes", " dvals", " dos", "dabes", "sdns", "dbbes", "dBS", " dmes", "dbes", " dBS"]}}
{"project": "qemu", "commit_id": "3a21532626bb5c3ecb0f916843f75ccce6501a9d", "target": 0, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n\n\n\n    /* Only aligned reads are allowed on OHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n        return;\n\n    }\n\n\n\n    if (addr < OPREGBASE) {\n\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n\n\n    /* Do any register specific pre-write processing here.  */\n\n    switch(addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n", "idx": 20148, "substitutes": {"ptr": ["proc", "pad", "rt", "tmp", "th", "ref", "ctr", "ind", "pointers", "h", "err", "js", "pointer", "pr", "ret", "store", "cont", "tr", "obj", "handle", "r", "address", "arr", "rev", "dh", "rect", "pt", "ts", "sp", "v", "ctx", "ry", "inter", "Ptr", "str", "alloc", "req", "dr", "z", "ps", "t", "add", "p"], "addr": ["init", "ash", "eth", "ad", "asm", "ip", "np", "kt", "rr", "address", "work", "dh", "v", "var", "ctx", "md", "grad", "mem", "old", "mac", "oa", "cmp", "hash", "tp", "add", "arp", "pad", "act", "alias", "offset", "gt", "hw", "tx", "iter", "ret", "len", "pos", "obj", "src", "Address", "index", "row", "hl", "inter", "state", "cmd", "phys", "w", "msg", "mt", "ld", "name", "ser", "rs", "slot", "host", "pkg", "ind", "map", "lat", "err", "size", "elt", "loc", "set", "arg", "pt", "sp", "ack", "ar", "x", "on", "cur", "dr", "adr", "at", "rt", "coord", "attr", "ref", "ctr", "trans", "rc", "ck", "res", "ha", "handle", "arr", "rel", "r", "ac", "rev", "sys", "id", "dest", "gz", "ord", "gate", "dd", "str", "ix", "alt", "ace", "t"], "val": ["prop", "xy", "def", "al", "max", "vol", "pol", "v", "var", "ctx", "grad", "mem", "old", "status", "cmp", "sel", "hash", "reg", " Val", "test", "tx", "Val", "VAL", "ret", "len", "pos", "hz", " ret", "eval", " update", " eval", " old", "el", "index", "cmd", "vals", "msg", "ival", "dev", "p", "fail", "err", "valid", "rol", "cal", "elt", " arg", "loc", "set", "arg", "resp", "buf", "l", "pt", "sol", "x", "vt", "cho", "ref", " v", "res", " value", "rel", "value", "num", "data", "alt", "bal", "aval", "stat"], "s": ["ls", "sl", "is", "sts", "sv", "rs", "aws", "sw", "changes", "h", "c", "sq", "sm", "js", "self", "os", "store", "ss", "serv", "vs", "ns", "ims", "sd", "r", "e", "ms", "ts", "m", "d", "sys", "its", "sp", "es", "b", "v", "n", "se", "sb", "state", "times", "stats", "ds", "an", "ses", "qs", "w", "S", "sam", "gs", "cs", "ps", "t", "bs", "comm", "fs", "hs", "j", "p"], "mmio": ["nightio", "mpio", "mpIO", "mtIO", "mmmi", "mmIO", "mpia", "mmi", "mpiol", "memio", "wmico", "nightiol", "wmie", "mmmios", "mxios", "mtia", "mmnet", "mmios", "memiol", "mmia", "nightios", " mmia", "mbios", "mmico", "mxio", "memios", "mtios", "mtio", "mxnet", "mbico", "mmiol", "mmie", "mbie", "mmmio", "mpi", "mxiol", "mbio", " mmie", " mmico", "memnet", "wmio", "nighti", "mmmiol", "mpnet", "mpios", " mmIO", " mmios", "wmios"], "i": [" offset", " len", " res", " out", "or", " init", " ref", "set", "r", " ip", " set", "l", " var", "v", " err", " start", " sp", " tmp", " l", "x", " rel", " dist", "t", " stored", "p"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n", "idx": 20151, "substitutes": {"index": ["length", "type", "config", "open", "offset", "ind", "Index", "ion", "lock", "info", "connect", "i", "size", "position", "IND", "error", "address", "height", "request", "zero", "num", "id", "row", "level", "n", "j", "key", "state", "ix", "data", "count", "x", "frame", "number", "no", "si"], "obj": ["tmp", "org", "act", "ready", "opt", "cmp", "object", "attr", "ref", "conn", "entry", "ind", "jp", "onet", "js", "stick", "pr", "ck", "ot", "cont", "obs", "res", "pos", "go", "impl", "elt", "inst", "node", "handle", "arr", "resp", "rect", "checked", "con", "txt", "v", "ctx", "n", "o", "out", "po", "oc", "oj", "val", "alloc", "instance", "str", "x", "cod", "ent", "ie", "vo", "nt", "ob", "typ", "addr", "joined", "og", "ptr", "adj", "buff", "t", "Obj", "bo", "j", "p"], "name": ["text", "tmp", "type", "label", "attr", "nm", " NAME", "ref", "nam", "part", "c", "title", "info", "search", "parent", "size", "def", "names", "order", "len", "null", "item", "address", "named", "dir", "list", "path", "id", "local", "v", "n", "o", "key", "package", "str", "NAME", "Name", "data", "prefix", "file", "filename", "mem", "common", "w", "word", "base", " Name", "only", "tree", "ame", "normal"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20158, "substitutes": {"arg1": ["arged", " arg0", "arg0", "tagone", "Arg2", "Arg3", "tag01", "agg0", " arg01", "agg3", "agg2", "tag1", "arg01", "agged", "Arg1", "argone", "agg01", " argone", " arged", "Arged", "aggone", "agg1", "tag0"], "arg2": ["ig02", "prop3", "ig2", "argument3", "arg02", "argumentTwo", "ag02", "ag1", "argument2", "ig1", "ag2", "agTwo", "propTwo", "prop2", " argTwo", " arg02", "igTwo", "argTwo"], "arg3": ["group3", "paramthree", " arg23", "group2", "param2", " argThree", "agThree", "target2", "arg23", "argThree", "targetThree", "groupthree", "target3", "param3", " arg5", " argthree", "ag2", "arg5", "argthree", "target23", "ag23", "group5", "ag3", "param5"], "farg1": ["farge9", "farp8", "floc3", "fok41", "fargs15", "falleOnce", "fokOne", " fcall1", "farg4", "fuser4", "fvary", "fargument3", "fgroup001", "forarg4", "farg8", "fagg9", "fassons", "flarg81", "flblock81", "fargn", "forarg37", "falle41", "fconfig101", "fargasso", "fvar001", "fagg3", "floatargons", "fconfig15", "floatvarons", "fass1", "fvalidn", " fcall001", " fargOnce", " farg001", "fargs3", " fagg101", " fok41", "fgroup1", "fvalid1", "fargs101", "fvalid8", "floatconfig101", " farg01", "fcall1", "floatarg001", " fargsOne", "flarg3", "fass81", "farg41", "forumentasso", "farg101", "fargument01", " fargs1", "farg01", "fargsOne", " fcall3", " fagg9", "farge1", "flblockons", "floatargy", "flag2", "farge101", " farg9", "fuser37", " fargs2", "fagg1", "floatconfig3", "fuser1", "fvar1", "fagg4", " farg15", "flargons", "fokOnce", "fargOne", "farpn", "fblock81", "flagOne", "floatarg1", "fok1", "fargumentOnce", "flvalid3", "forargasso", "flag1", "fcall3", "forarg1", "fargs1", "faggasso", "forument4", "forument1", "falleOne", "fumenty", "fument37", "fagg15", "fconfig3", "floatvary", "fargument1", " fcall01", "fagg37", "flargn", "farge15", "floc1", "fagg101", " fok1", " fokOne", "floc101", "flblock3", "floatarg101", "fargs2", "flblock1", "falle1", " farg41", "fargumentOne", "fargy", "farg9", "fumentons", "fblockons", "fblock1", "farp81", "fgroupy", "fargons", "fagg8", " fagg1", "fument1", " farg101", "floc15", "fcall001", "fvar15", "fcall01", "flarg1", "flvalid1", "fvar101", "fconfig1", "floatarg3", "fuserasso", "fumentasso", "farg15", "floatvar1", "fgroupons", "fargOnce", " fargs001", "flag001", "fargs001", "farpons", "fass3", "floatconfig15", "fument001", "fument4", "farg81", " fagg15", "flarg8", "farg001", "farp1", "floatarg15", "fargument001", "forument37", "floatconfig1", "flvalid8", "fblock3", "fvarons", "floatvar001", "fvalid3", "farg37", "fagg01", " fargOne", "flvalidn", "fvar9", "fargument41", " fokOnce", "farp3", "faggn", "fagg001"], "farg2": ["fparpTwo", "formargument2", "fark3", "fllink2", "fargument2", "farg4", "farg102", "cfargtwo", "fagg48", "fargument3", "fagg2", "farg8", "fpar21", "flink22", "fllink22", "cfig102", "flinkTwo", "fabframe002", "fagg3", "formarg2", "cfarg2", "fok3", "formarg8", "ftag22", "fabframe3", "fvalid4", "flarg2", "ftagTwo", "fpartwo", "flink2", "fparam2", "fparg2", "fargTwo", "fument102", "fument2", "fok21", " fark3", "fvalidSecond", "fArg2", "fframe002", "fparptwo", "fparp4", "farg21", " fark2", " farg4", "cfig2", "formarg48", "fig102", "fargument48", "fargSecond", "fcallTwo", "cfarg21", "fparam4", "fArg3", "formargument8", "fllinkSecond", "fig21", "farp4", "fparamtwo", "fabarg21", "fpargtwo", "fig2", "faj002", "faj21", "faj3", "fvalidlet", "fumenttwo", "fcall4", "fabframe21", "fument21", "formargument3", "cfigtwo", "farpTwo", "fark2", "fabframe2", "ftagSecond", "fabarg3", "farglet", "flinkSecond", "fpar102", "flargTwo", "fagg8", "fcall2", " farglet", " fark4", "farg22", "formarg3", "farg48", "cfig21", "fpargTwo", "farptwo", "fvalidTwo", "cfarg102", "fark4", "faj2", "farklet", "fvalid22", "figtwo", "fparp2", "fabarg2", "fframe2", "fargtwo", "fcalltwo", "fframe3", "ftag2", "fllinkTwo", "flargSecond", "farg002", "fpar2", "fArg48", "fvalid3", "flarg22", "fvalid2", "fargument8", "fok2", "formargument48", "fparg4", "fArg8", "fok002", "farp2", "fabarg002", "fparamTwo", " farklet", "fframe21"], "farg3": ["fparam34", "fvar3", " fcall4", "foarg41", "farg343", "fang5", "dfdateant", "fcall343", "farg4", "fcagg3", "fascant", "fargthree", "fcarg03", "foument5", "fargument3", "fagg2", "fagthree", "fargumentment", "fcall03", "ftarget343", "fdatethree", "fagg3", "varg3", "wtarget03", "fascThree", "fcallment", "fag3", "fargs3", "foument41", " fargment", "varg03", "ftag03", "fargant", "dfargThree", "fasc3", "farg6", "fargThree", "fitem33", "fig03", "fcall33", "ftarget33", "dfdatethree", "farg13", "wtarget3", "wtarget33", "farg41", "fvar2", " farg4", "fcagg6", "fagg5", " fcall3", "fcarg6", "vagg3", "fdate3", " fcallment", "varg5", "fdate4", "foarg5", "dfargthree", "fagThree", "fument34", "foarg3", " fcall13", "fvar5", "ftarget3", "figThree", "fcarg3", "fcall13", "fcall3", "foument3", " farg13", "farg33", "fcall4", "fargment", "fument3", "wtarget343", "fargument13", "fdatement", "fcargThree", "vagg2", "fparam3", "fang3", "fargs2", "fig6", "fdate13", "ftag3", "varg2", "fig3", "warg343", "fang41", "ftagThree", "faggThree", "fascthree", "foarg34", "dfdateThree", "fument41", "fdateThree", "dfarg3", "fargs03", "fang34", "warg03", "warg3", "fument5", "ftag6", "warg33", "fagg6", "ftarget03", "fitem03", "foument34", "fagg03", "fparam41", "fitem343", "farg5", "fdateant", "fparam5", "fagant", "dfargant", "fitem3", "fcagg03", "fargs5", "farg34", "fcaggThree", "fvar03", "vagg5", "fargument4", "farg03", "dfdate3", "vagg03"], "ft0_128": ["ft100_1024", "ft0_48", "ft0P512", "ft06463", "ft064128", "ft0_180", "ft0_512", "ft2_32", "ft0_1024", "ft000_ul", "ft000_128", "ft0_3", "ft0_256", "ft0Pdq", "ft0M128", "ft0_16", "ft0_dq", "ft1_256", "ft2_63", "ft0_simple", "ft2_128", "ft0P256", "ft0_32", "ft1_180", "ft0_\t", "ft06465", "ft100_128", "ft0P128", "ft1_dq", "ft1_16", "ft06416", "ft100_3", "ft1_\t", "ft000_48", "ft064256", "ft1_65", "ft2_256", "ft0M512", "ft0Mdq", "ft0_65", "ft06432", "ft0_63", "ft0M256", "ft0_ul", "ft100_simple", "ft1_512"], "ft1_128": ["ft51_384", "ft1116", "ft11257", "ft7_16", "ft1_211", "ftone_128", "ft1_97", "ft0_256", "ft7_257", "ft7_128", "ft1_256", "ft51_128", "ft51_211", "ft0_32", "ft7_32", "ft1132", "ftone_256", "ft1_16", "ftone_32", "ftone_97", "ft0_384", "ft1_32", "ft1_257", "ft1_384", "ft51_256", "ft11128"]}}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n", "idx": 20189, "substitutes": {"buf": ["proc", "window", "block", "bh", "br", "header", "ref", "vec", "h", "fb", "Buff", "buffer", "Buffer", "rb", "bytes", "p", "img", "cb", "pb", "rw", "b", "v", "uffer", "uf", "alloc", "cmd", "data", "uv", "mem", "w", "msg", "raw", "buff", "ob", "bf", "pack", "queue", "que", "batch"], "buf_size": ["buf2size", "uf_len", "buf_ize", "buf2start", "buf2ize", "buf_Size", " buf_len", "uf_size", "uf_Size", " buf_ize", "buf_start", "buf2len", " buf_start", "buf_len"], "filename": [" wo", "tmp", "f", "attr", "nm", "fp", "fil", "src", "path", "kw", "txt", "png", "family", "wcs", " fn", "fi", "prefix", "seek", "write", "file", "files", "image", "fn", "ame", "name"], "cow_header": ["cowmytree", "gae_header", "cow_member", "cow_config", "cow_____status", "cow_size", "cow_tree", "craft_tree", "cowmysize", "craft___adder", "cow_head", "cow_status", "cowmyadder", "cow_definition", "cow___size", "cow_adder", "cow___adder", "gow_header", "craft___size", "cow_____header", "gae_member", "gae_definition", "craft_adder", "gow_manager", "cow___header", "gae_head", "gow_config", "cowptmember", "cow___tree", "cow_manager", "cow_____config", "cow_____manager", "cowptdefinition", "cowpthead", "craft___tree", "craft___header", "cowptheader", "cowmyheader", "craft_size", "craft_header", "gow_status"]}}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "uint64_t ram_bytes_remaining(void)\n\n{\n\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n\n}\n", "idx": 20197, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {\n\n    Pulse pulse;\n\n    TemporalNoiseShaping * tns = &sce->tns;\n\n    IndividualChannelStream * ics = &sce->ics;\n\n    float * out = sce->coeffs;\n\n    int global_gain, pulse_present = 0;\n\n\n\n    /* This assignment is to silence a GCC warning about the variable being used\n\n     * uninitialized when in fact it always is.\n\n     */\n\n    pulse.num_pulse = 0;\n\n\n\n    global_gain = get_bits(gb, 8);\n\n\n\n    if (!common_window && !scale_flag) {\n\n        if (decode_ics_info(ac, ics, gb, 0) < 0)\n\n            return -1;\n\n    }\n\n\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n\n        return -1;\n\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n\n        return -1;\n\n\n\n    pulse_present = 0;\n\n    if (!scale_flag) {\n\n        if ((pulse_present = get_bits1(gb))) {\n\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n\n                return -1;\n\n            }\n\n            decode_pulses(&pulse, gb, ics->swb_offset);\n\n        }\n\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n\n            return -1;\n\n        if (get_bits1(gb)) {\n\n            av_log_missing_feature(ac->avccontext, \"SSR\", 1);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 20199, "substitutes": {"ac": ["AC", "act", "aci", "ach", "ak", "cam", "c", "sac", "ica", "fac", "rac", "pac", "fc", "anc", "abc", "ag", "mc", "ad", "ab", "ic", "ican", "acer", "acc", "jac", "iac", "auc", "aq", "unc", "att", "tc", "enc", "cu", "pc", "ain", "ap", "cc", "ack", "acs", "ctx", "ct", "acl", "bc", "uc", "Ac", "aco", "vc", "ec", "am", "mac", "at", "cs", "ace"], "sce": ["csse", "iscer", "slee", "imsce", "opensces", "scle", " slee", "islee", "jsce", "gescle", " scel", "isce", "iscle", "sescle", "sesce", "jsse", "Scle", "rske", "gesces", "gsces", "jsCE", "insces", "Sces", "rsce", "alscle", "rsces", "isCE", "gesce", " ske", "rsse", "imsse", "inske", "stsced", "ske", "csCE", "gscle", "sesces", "stsces", "imsces", " scle", " sced", "scel", "openscle", "opensce", "gesCE", "sced", "alsced", "stsce", "alsce", "Sce", "insCE", "mscle", "gsce", "sces", "Ske", "scer", "insce", " scer", "jsced", "gsced", "msced", "csce", "imscle", " sCE", "sse", "seslee", " sces", "gescel", "alsces", "openske", "sCE", "stscle", " sse", "msces", "SCE", "isces", "csced", "rscle", "msce"], "gb": ["nb", "bridge", "px", "bb", "box", "cfg", "g", "gt", "gd", "bits", "tg", "GB", "gio", "args", "wb", "gp", "fb", "xy", "ogg", "gin", "buffer", "rb", "rg", "bytes", "io", "img", "gc", "ig", "cb", "pb", "by", "handle", "gif", "yg", "ib", "buf", "pc", "um", "its", "eb", "b", "gz", "row", "eg", "bg", "uf", "bn", "hub", "Gb", "sb", "gm", "bc", "kb", "db", "pg", "storage", "goo", "gg", " GB", "gpu", "msg", "py", "gs", "gy", "ows", "bf", "ruby", "mb", "bs", "vg", "gh"], "common_window": ["commontenancestream", "commonishwin", "common_device", "commontenancewin", "commonlywin", "Common_stream", "Common_client", "Common_windows", "Common_device", "common_stream", "commonlyclient", "commontenancewindow", "common_win", "commonlystream", "commonlywindow", "commonishwindows", "Common_win", "commonishwindow", "common_windows", "commontenanceclient", "Common_window", "commonishdevice", "common_client"], "scale_flag": [" scale_leaf", "scaleetricflag", "scale_mode", "scale_only", "scalealflag", "scale_status", "scale2only", "scale2flags", " scale_mode", "scaleerflag", "scalefulflag", "scaleermode", "scale_leaf", " scale_status", "scalefulflags", "scaleerflags", "scalefulonly", " scale_flags", " scale_only", " scale_lag", "scalealmode", "scaleerevent", "scale_event", "scalealflags", "scaleetricleaf", "scale2lag", "scale_lag", "scaleetricflags", " scale_event", "scaleetricstatus", "scale_flags", "scale2flag", "scalefullag", "scalealevent"], "pulse": ["Pulse", "cpolar", "prulsion", "pauls", "duls", "cpulsion", "psulse", "expolar", "impulse", "spulse", "paolar", "ppulsion", "Pulsion", "polar", "psitch", "psulsion", "ppulse", "spitch", "rulsion", "impolar", "cpulse", "dulse", "ruls", "pritch", "spuls", "Puls", "pulsion", "impitch", "puls", "ppuls", "impuls", "prulse", "expuls", "pruls", "paulsion", "expulse", "cpitch", "cpuls", "Pitch", "paulse", "ppolar", "rulse", "ritch", "dolar", "spulsion", "expitch", "ditch", "pitch", "psuls"], "tns": ["pcs", "ternis", "rnes", "dtns", "tn", "ttns", "vcs", " tn", "terns", " tcs", "ttnos", "ynes", "terls", "tls", "rcs", "pns", " tnis", "ynos", "dtks", "vns", "ttnis", "yns", "Tnes", "terks", " trs", "pn", "ynis", "Tcs", "dtls", "dtnis", "ymn", " tls", "tnes", "tcs", "rmn", "tnis", "tmn", "rns", "ttcs", "ycs", " tnos", "prs", "tks", " tks", "tnos", "vn", "Tmn", "Tns", "trs", "vrs"], "ics": ["ls", "is", "onics", "ks", "aic", "icking", "ik", "rs", "ICS", "bits", "ins", "ints", "aws", "tis", "nic", "xs", "cus", "aps", "fc", "ips", "oms", "icc", "css", "iers", "ic", "icons", "IC", "xes", "vs", "ris", "ns", "ico", "ims", "ats", "ts", "sys", "its", "caps", "acs", "rics", "fits", "ices", "mic", "iris", "irs", "icks", "pic", "wcs", "icates", "stats", "qs", "ires", "cs", "isc", "irc", "ps", "eric", "wic", "bs", "ils", "fs", "amps", "icing", "es"], "out": ["gain", "to", "px", "all", "g", "gt", "ref", "outs", "result", "OUT", "ex", "Out", "mask", "os", "ot", "conv", "sc", "in", "io", "net", "res", "obj", "gc", "cb", "band", "unc", "scan", "sys", "its", "off", "v", "ctx", "o", "ix", "output", "bin", "raw", "aux", "at", "ch", "loss", "aos", "t", "co", "conf"], "global_gain": ["total_gain", "global_speed", " global_grain", "global_gen", " global_wave", " global_gen", "total_speed", "global_wave", "total_wm", " global_speed", "global_grain", "global_wm"]}}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n", "idx": 20200, "substitutes": {"s": ["ls", "is", "sts", "sv", "rs", "bits", "ins", "as", "aws", "changes", "sw", "south", "h", "sq", "xs", "js", "i", "ports", "tains", "os", "ss", "serv", "https", "y", "ies", "vs", "details", "ns", "ims", "events", "ags", "ms", "ats", "sync", "ts", "sys", "its", "b", "v", "se", "parts", "bis", "sql", "sb", " ss", "stats", "ds", "qs", "ses", "less", "http", "S", "ers", "gs", "gets", "ows", "sam", "cs", "comments", "comm", "ps", "bs", "als", "fs", "hs", "es"]}}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void pci_qdev_register(PCIDeviceInfo *info)\n\n{\n\n    info->qdev.init = pci_qdev_init;\n\n    info->qdev.bus_type = BUS_TYPE_PCI;\n\n    qdev_register(&info->qdev);\n\n}\n", "idx": 20213, "substitutes": {"info": ["f", "ready", "ok", "config", "Inf", "always", "cache", "entry", "init", "update", "iter", "fee", "report", "good", "i", "error", "Info", "doc", "details", "debug", "loc", "kind", "address", "check", "query", "request", "now", "index", "id", "txt", "about", "time", "INFO", "history", "fire", "comment", "description", "fi", "where", "policy", "notice", "trace", "desc", "count", "next", "success", "http", "auth", "it", "py", "try", "fo", "start", "inf", "iso", "conf", "information", "metadata"]}}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n", "idx": 20233, "substitutes": {"net": ["org", "page", "def", "man", "ip", "vs", "np", "nut", "kt", "dat", "nat", "out", "nu", "art", "sky", "plain", "act", "nm", "sec", "test", "virtual", "onet", "serv", "nets", "obj", "inet", "mot", "client", "mat", "phys", "nt", "vert", "unit", "ne", "conn", "en", "nis", "chain", "nav", "Net", "port", "physical", "io", "pot", "virt", "ether", "task", "no", "ent", "comm", "fax", "NET", "rt", "config", "boot", "nic", "not", "server", "ut", "iot", "ver", "ng", "nc", "network", "sys", "vm", "n", "gate", "volt", "web", "et", "ann", "grid", "fat", "eng"], "dev": [" Dev", "Dev", "block", "cho", "conn", "host", "hw", "cam", "dn", "develop", "disc", "info", "eth", "des", "pub", "ad", "def", "serv", "server", "device", "doc", "obj", "debug", "go", "iv", "ver", "dat", "att", "enc", "cast", "buf", "det", "dem", "nc", "d", "van", "watch", "den", "nw", "gu", "env", "v", "var", "ev", "priv", "dd", "ve", "val", "devices", "md", "dis", "cmd", "DEV", "desc", "data", "de", "mem", "adv", "w", "raw", "nt", "av", "aux", "ptr", "tech"], "file": ["block", " f", "run", "fe", "page", "h", " fin", " msg", "use", "le", "ile", "attribute", "al", " pool", "e", "table", "time", "out", " data", "key", "link", "files", "lo", " world", "field", "proc", "f", "issue", "iter", "spec", "ib", "handler", "progress", "path", " fo", "row", " fe", "db", " File", "name", "p", " filename", "File", "disk", "array", "user", " db", "channel", "port", "buffer", "byte", "io", "util", " fid", "dir", " error", "task", "image", "range", "open", "ref", "connection", "entity", "fp", "info", "lf", " files", " chain", "in", "line", "reader", "handle", "form", " io", "local", "rule", "data", "et", "base", "il", "tree", "t", " path"], "index": ["length", "offset", "rank", "ref", "ind", "chain", "Index", "connected", "test", "iter", "point", "lock", "depth", "ex", "connect", "i", "brand", "position", "dim", "pos", "head", "loc", "address", "sequence", "list", "d", "num", "id", "level", "n", "key", "val", "slice", "str", "ix", "prefix", "weight", "seek", "count", "x", "span", "seq", "no", "number", "node", "find", "start", "range"], "vhost_ops": ["vhost__Ops", "vhost2op", "vHost_oops", "vhost__tops", "vhost__oops", "vHost_tops", "vhost2Ops", "vost_Ops", "vost_caps", "vHost_ops", "vost_ops", "vhost2ops", "vHost_Ops", "vhost_Ops", "vhost_tops", "vhost2tops", "vhost__ops", "vHost_op", "vhost_oops", "vhost_caps", "vhost_op"]}}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int rtsp_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char host[1024], path[1024], tcpname[1024], cmd[2048];\n\n    URLContext *rtsp_hd;\n\n    int port, i, ret, err;\n\n    RTSPHeader reply1, *reply = &reply1;\n\n    unsigned char *content = NULL;\n\n    AVStream *st;\n\n    RTSPStream *rtsp_st;\n\n    int protocol_mask;\n\n\n\n    rtsp_abort_req = 0;\n\n    \n\n    /* extract hostname and port */\n\n    url_split(NULL, 0,\n\n              host, sizeof(host), &port, path, sizeof(path), s->filename);\n\n    if (port < 0)\n\n        port = RTSP_DEFAULT_PORT;\n\n\n\n    /* open the tcp connexion */\n\n    snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port);\n\n    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)\n\n        return AVERROR_IO;\n\n    rt->rtsp_hd = rtsp_hd;\n\n    rt->seq = 0;\n\n    \n\n    /* describe the stream */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"DESCRIBE %s RTSP/1.0\\r\\n\"\n\n             \"Accept: application/sdp\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, &content);\n\n    if (!content) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n        \n\n    /* now we got the SDP description, we parse it */\n\n    ret = sdp_parse(s, (const char *)content);\n\n    av_freep(&content);\n\n    if (ret < 0) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    \n\n    protocol_mask = rtsp_default_protocols;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n       RTSP stream */\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        char transport[2048];\n\n        AVInputFormat *fmt;\n\n\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n\n\n        /* compute available transports */\n\n        transport[0] = '\\0';\n\n\n\n        /* RTP/UDP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) {\n\n            char buf[256];\n\n            int j;\n\n\n\n            /* first try in specified port range */\n\n            if (rtsp_rtp_port_min != 0) {\n\n                for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) {\n\n                    snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j);\n\n                    if (!av_open_input_file(&rtsp_st->ic, buf, \n\n                                            &rtp_demux, 0, NULL))\n\n                        goto rtp_opened;\n\n                }\n\n            }\n\n\n\n            /* then try on any port */\n\n            if (av_open_input_file(&rtsp_st->ic, \"rtp://\", \n\n                                       &rtp_demux, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n            }\n\n\n\n        rtp_opened:\n\n            port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;unicast;client_port=%d-%d\",\n\n                     port, port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/TCP\");\n\n        }\n\n\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), \n\n                     sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;multicast\");\n\n        }\n\n        snprintf(cmd, sizeof(cmd), \n\n                 \"SETUP %s RTSP/1.0\\r\\n\"\n\n                 \"Transport: %s\\r\\n\",\n\n                 rtsp_st->control_url, transport);\n\n        rtsp_send_cmd(s, cmd, reply, NULL);\n\n        if (reply->status_code != RTSP_STATUS_OK ||\n\n            reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].protocol != rt->protocol) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->protocol = reply->transports[0].protocol;\n\n        }\n\n\n\n        /* close RTP connection if not choosen */\n\n        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&\n\n            (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) {\n\n            av_close_input_file(rtsp_st->ic);\n\n            rtsp_st->ic = NULL;\n\n        }\n\n\n\n        switch(reply->transports[0].protocol) {\n\n        case RTSP_PROTOCOL_RTP_TCP:\n\n            fmt = &rtp_demux;\n\n            if (av_open_input_file(&rtsp_st->ic, \"null\", fmt, 0, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n            \n\n        case RTSP_PROTOCOL_RTP_UDP:\n\n            {\n\n                char url[1024];\n\n                \n\n                /* XXX: also use address if specified */\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d\", \n\n                         host, reply->transports[0].server_port_min);\n\n                if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n\n            {\n\n                char url[1024];\n\n                int ttl;\n\n\n\n                fmt = &rtp_demux;\n\n                ttl = reply->transports[0].ttl;\n\n                if (!ttl)\n\n                    ttl = 16;\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", \n\n                         host, \n\n                         reply->transports[0].server_port_min,\n\n                         ttl);\n\n                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* use callback if available to extend setup */\n\n    if (ff_rtsp_callback) {\n\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n\n                             NULL, 0, rt->last_reply) < 0) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n                         \n\n    /* start playing */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"PLAY %s RTSP/1.0\\r\\n\"\n\n             \"Range: npt=0-\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, NULL);\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n#if 0\n\n    /* open TCP with bufferized input */\n\n    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {\n\n        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {\n\n            err = AVERROR_NOMEM;\n\n            goto fail;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n fail:\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n        if (rtsp_st) {\n\n            if (rtsp_st->ic)\n\n                av_close_input_file(rtsp_st->ic);\n\n        }\n\n        av_free(rtsp_st);\n\n    }\n\n    av_freep(&content);\n\n    url_close(rt->rtsp_hd);\n\n    return err;\n\n}\n", "idx": 20237, "substitutes": {"s": ["ls", "is", "sts", "g", "rs", "ins", "as", "aws", "so", "sw", "a", "c", "sq", "h", "xs", "js", "service", "self", "os", "store", "ss", "serv", "server", "in", "ns", "spec", "set", "src", "r", "ms", "ats", "ts", "sys", "its", "m", "sp", "es", "b", "n", "sb", "stats", "ds", "qs", "ses", "w", "S", "gs", "ssl", "source", "cs", "ps", "t", "bs", "conf", "fs", "hs", "z", "p"], "ap": ["ep", "apt", "map", "aps", "mp", "cap", "bp", "pp", "al", "att", " op", " map", "tap", "ac", " mp", " ip", "sp", " cp", " pac", "pa", " sp", "ar", " sap", "ape", " p", "op", "ps", "tp"], "rt": ["tmp", "tt", "rf", "rs", "gt", "vr", "tx", "rx", "rl", "rc", "ot", "dt", "ro", "rb", "tr", "res", "RT", "rr", "sr", "r", "resp", "rw", "rev", "sys", "pt", "rec", "txt", "ctx", "req", "bt", "art", "dr", "vt", "rm", "nt", "it", "addr", "usr", "ptr", "mt", "t", "rd", "rn"], "host": ["author", "hook", "ost", "bind", "conn", "pkg", "hop", "connection", "user", "h", "root", "serv", "Host", "server", "https", "ip", "pattern", "loc", "home", "target", "driver", "handle", "address", "dir", "src", "localhost", " Host", "client", "subject", "local", "owner", "cert", "context", "str", "prefix", "http", "uri", "mac", "domain", "container", "node", "addr", "name"], "path": ["text", "prop", "length", "th", "ext", "conn", "pkg", "route", "chain", "method", "part", "root", "cp", "ip", "pattern", "PATH", "dir", "Path", "query", "pid", "pt", "id", "pod", "con", "local", "template", "ath", "history", "cert", "key", "context", "prefix", "data", "file", "col", "format", "transform", "msg", "stat", "name", "p"], "tcpname": ["tpno", "tctxName", "tchname", "tppname", "Tcpname", "tspno", "tplen", "tcpadmin", " tcpno", "Tmplen", "tpkgname", "tcpName", "tcplen", "tpkgnames", "tspname", "tpName", " tmpno", " tmpName", "tmpNAME", "tpname", "tcpNAME", " tcpaddress", " tmpname", " tmptype", "tpkgNAME", "Tcpnames", " tcpName", "tptype", "tctxNAME", "tchaddress", "TmpName", "Tcpno", "tspName", " tmpadmin", "Tmpnames", "tmplen", "tcpaddress", "Tcplen", "tmpaddress", "tchadmin", "tsplen", "Tmpname", "tcpnames", "tmpno", "tmptype", "tpkgName", "tchno", "Tmpno", "tpptype", "TcpName", "tpnaddress", "tmpadmin", "tpnadmin", " tcptype", "tmpName", "tctxnames", "tpnname", "tppName", " tmpaddress", "tcptype", " tcpadmin", "TmpNAME", "tctxname", "tcpno", "TcpNAME", "tmpname", "tpnno", "tmpnames"], "cmd": ["text", "prop", "act", "MD", "config", "ext", "ctr", "pkg", "method", "c", "tx", "cli", "rc", "Cmd", "tab", "def", "cont", "cp", "cb", "patch", "dir", "id", "txt", "ctx", "ct", "code", "comment", "send", "mk", "md", "control", "desc", "data", "req", "cod", "auth", "msg", "fun", "rm", "nt", "command", "magic", "comm", "cmp", "cfg", "cd", "pat"], "rtsp_hd": ["rtsp_hard", "rtsp_conn", "rtspt_hard", "rtsv_hd", "rtsl_hd", "rtsp___hd", "rtsp____hd", "rtsp___dt", "rtsp2hard", "rtsv_md", "rtsp____md", "rtsp2hd", "rtsp_tx", "rtsport_ctx", "rtspt_hd", "rtsport_hd", "rtsp_ld", "rtsl_ld", "rtsp_dt", "rtsp_md", "rtsp____rh", "rtsport_rh", "rtspt_ds", "rtsport_conn", "rtsp2ht", "rtsl_rh", "rtsp____tx", "rtsp2ds", "rtsv_tx", "rtsp_ctx", "rtsp___rh", "rtspt_ht", "rtsp___ld", "rtsp_rh", "rtsp_ds", "rtsp_ht", "rtsv_rh", "rtsl_dt"], "port": ["to", "window", "length", "type", " sport", "ported", "page", "connection", "slot", "peer", "pkg", "P", "interface", "pport", "ports", "size", "position", "priority", "server", "version", "ip", "len", "pos", "cp", " Port", "line", "export", "pi", "address", "project", "pc", "localhost", "ort", "pt", "pid", "index", "ORT", "client", "import", "row", "prot", "n", "state", "print", "policy", "media", "proxy", "count", "file", "format", "number", "pro", "it", "Port", "eport", "limit", "age", "ptr", "PORT", "t", "timeout", "p"], "i": ["f", "is", "bi", "er", "gi", "ind", "chain", "ir", "c", "iter", "xi", "ki", "ai", "info", "ini", "batch", "li", "ui", "ip", "y", "in", "pi", "iu", "qi", "u", "im", "e", "zi", "ci", "sim", "m", "me", "index", "id", "gu", "b", "v", "I", "n", "o", "ii", "ei", "ti", "key", "phi", "ix", "x", "di", "it", "mi", "hi", "ij", "t", "multi", "si", "p"], "ret": ["tmp", "gt", "ctr", "result", "lit", "rem", "nl", "sent", "fr", "dt", "fin", "del", "tr", "res", "len", "net", "elt", "rr", "ll", "re", "flag", "r", "arr", "resp", "rev", "Ret", "RET", "progress", "num", "sys", "txt", " Ret", "back", "ft", "nz", "reset", "val", "fi", "rets", "alt", "success", "deg", "dr", "nt", "try", "usr", "mt", "ptr", "t", "repl"], "err": ["lr", "kr", "Error", "attr", "cr", "br", "er", "ind", "ir", "fee", "iter", "rc", "Er", "pr", "fr", "order", "error", "res", "doc", "der", "elt", "obj", "cb", "rr", "fg", "r", "arr", "expr", "rev", "txt", "gz", "aaa", "notice", "ner", "req", "status", "msg", "dr", "try", "addr", "usr", "ch", "ptr", "die", "rer", "conf", "cfg", "rn"], "reply1": ["reply2", "answer1", "partOne", "reply3", "answer3", "Reply1", "responseOne", "ReplyOne", "response2", "Reply2", "answer2", "response1", "Reply3", "part1", "part2", "replyOne", "response3"], "reply": ["response", "result", "repl", "info", "report", "nl", "fr", "ro", "error", "server", "res", "body", "Reply", "rr", "r", "resp", "sync", "sp", "txt", "se", "out", "esp", "comment", "reset", "spr", "echo", "proxy", "notice", "write", "req", "frame", "status", "ply", "msg", "rm", "nt", "command", "answer", "transfer", "rep", "ror", "p"], "content": ["text", "act", "header", "xml", "config", "ext", "conn", "result", "fp", "c", "cm", "title", "readable", "sent", "mask", "css", "buffer", "name", "cont", "cp", "version", "res", "Content", "body", "ontent", "load", "tc", "match", "address", "resp", "message", "value", "accept", "cc", "txt", "ct", "code", "out", "comment", "description", "context", "str", "quest", "empty", "data", "lex", "output", "format", "CONT", "status", "raw", "magic", "command", "clean", "transfer", "response", "cor"], "st": ["tmp", "irst", "ost", "th", "tt", "sv", "sn", "sw", "ste", "std", "nd", "stage", "stream", "serv", "sc", "tr", "p", "ut", "inst", "src", "r", "St", "est", "ts", "pt", "sp", "ST", "se", "ct", "str", "status", "art", "it", "z", "nt", "start", "at", "mt", "stable", "t", "sh", "rest", "ist"], "rtsp_st": ["rtsp_ct", "rtsps_ist", "rtsd_nd", "rtsps_st", "rtsp_data", "rtsp_ist", "rtsd_st", "rtsps_se", "rtsps_tt", "rtsp_tt", "rtsd_data", "rtsd_ct", "rtsp_se", "rtsp_nd"], "protocol_mask": ["protocolnetask", "protport_map", "protocolitymask", "protocolnetmask", "protocol_ask", "protocol_filter", "protport_mask", "protocolnetflag", "protocolityflags", "protocol_map", "protocol__mask", "protocol_flags", "protocolityflag", "protocol_flag", "protocol_bit", "protocolnetflags", "protport_bit", "protocol__flag", "protocolityfilter", "protport_flag", "protocol__ask", "protocol__flags"], "transport": ["transband", "transferporter", "transferports", "Transporter", "ransports", "Transband", "Transname", "ransband", "transname", " transband", "transporter", "ransporter", "ransport", "transports", "Transport", " transname", "ransname", " transports", "Transports", "transferport"], "fmt": ["cfformat", "flt", "cfmt", "cflt", "fformat", "Fmt", "Fformat", " flt", " fformat", "ftx", " ftx", "Flt", "cftx", "Ftx"], "buf": ["pad", "length", "box", "block", "br", "ref", "conn", "map", "stream", "buffer", "cap", "Buffer", "conv", "len", "table", "var", "code", "str", "data", "count", "seq", "pool", "raw", "buff", "pack"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                                int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong phys;\n\n    int prot;\n\n\n\n    /* XXX: implement mmu */\n\n\n\n    phys = address;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n\n\n    return tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                        phys & TARGET_PAGE_MASK, prot,\n\n                        mmu_idx, is_softmmu);\n\n}\n", "idx": 20238, "substitutes": {"env": ["proc", "window", "cv", "equ", "config", "end", "sv", "en", "ef", "viron", "te", "store", "server", "vs", "cb", "e", "ten", "ah", "v", "ctx", "param", "ev", "code", "ve", "sb", "context", "web", "environment", "ce", "desc", "nv", "uv", "scope", "ptr", "dev", "esc", "conf", "vp"], "address": ["resource", "url", "type", "alias", "offset", "location", "host", "page", "route", "array", "interface", "memory", "pointer", "eth", "port", "position", "shape", "buffer", "order", "server", "attribute", "device", "handle", "r", "Address", "message", "reference", "network", "path", "index", "ase", "direction", "uri", "number", "command", "addr", "process", "ptr", "range", "add", "name"], "rw": ["rib", "RW", "rf", "hw", "route", "rh", "wb", "rar", "rb", "net", "ram", "dir", "work", "wp", "nc", "nw", "network", "row", "wire", "writ", "aw", "wa", "wh", "wind", "write", "req", "w", "wr"], "mmu_idx": ["mmu_idz", "mmu_pidz", "mmu__idxs", "mmu_Idxf", "mmu_Idxc", "mmu__Idxs", "mmu__Idx", "mmu_Idy", "mmu_idy", "mmu_pidg", "mmu_Idx", "mmu_pidx", "mmu_idxf", "mmu__Idxc", "mmu__idxc", "mmu_midy", "mmu_idxs", "mmu__idx", "mmu_midxs", "mmu_idxc", "mmu_Idxs", "mmu_Idz", "mmu__Idy", "mmu_midx", "mmu_pidxf", "mmu_Idg", "mmu_idg", "mmu__idy", "mmu_midxc"], "is_softmmu": ["is_softmmus", "is_SoftmemU", "is_Softmmu", "is_softmemue", "is_Softmmus", "is_softMMU", "is_softMMux", "is_softmmmue", "is_softmmcu", "is_softMMu", "is_softmemu", "is_softMMue", "is_softMMcu", "is_Softmmux", "is_softmemcu", "is_softmemux", "is_Softmmcu", "is_SoftmmU", "is_Softmmue", "is_softmmmus", "is_Softmemus", "is_softmemU", "is_softmmux", "is_Softmemux", "is_Softmemue", "is_Softmemcu", "is_softmemus", "is_softMMus", "is_softmmue", "is_softmmU", "is_softmmmu", "is_Softmemu", "is_softmmmux"], "phys": ["proc", "arch", "prop", "Phys", "type", "ref", "host", "hw", "page", "memory", "eth", "pr", "port", "mp", "password", "physical", "pas", "ip", "np", "ris", "phy", "pi", "home", "handle", "rel", "pc", "sys", "path", "cpu", "ph", "priv", "socket", "phi", "ther", "gpu", "mem", "pro", "mac", "stat", "addr", "ptr", "snap", "ps", "tp", "p"], "prot": ["fd", "prop", "fl", "type", "pat", "bits", "ref", "method", "mult", "channel", "tel", "eth", "port", " PROT", "def", "physical", "version", "tr", "pos", "net", "pattern", "phy", "Prot", "tf", "path", "ph", "ocol", " proto", "rot", "policy", "conduct", "cmd", "col", "format", "pro", "fat", "typ", "tif", "at", "addr", "ptr", "stat", "sche", "platform", "tp", "p"]}}
