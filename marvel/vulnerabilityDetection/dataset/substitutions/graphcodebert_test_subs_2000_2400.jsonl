{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         void **refcount_table,\n\n                         int64_t *refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k, refcount;\n\n    int ret;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= *refcount_table_size) {\n\n            ret = realloc_refcount_array(s, refcount_table,\n\n                                         refcount_table_size, k + 1);\n\n            if (ret < 0) {\n\n                res->check_errors++;\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        refcount = s->get_refcount(*refcount_table, k);\n\n        if (refcount == s->refcount_max) {\n\n            fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n            fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \"\n\n                    \"width or qemu-img convert to create a clean copy if the \"\n\n                    \"image cannot be opened for writing\\n\");\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n        s->set_refcount(*refcount_table, k, refcount + 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20248, "substitutes": {"bs": ["ubis", "lbs", "bits", "ubs", "ss", "BS", "ns", "aos", "iss", "ps", "cs", "bc", "fs", "rs", "gs", "ds", "bis", "ls", "bm", "bh", "ms", "vs", "hs", "bes", "js", "its", "ts", "als", "obs", "sb", "bos", "b", "bas", "cks", "bb"], "res": ["expr", "cons", "resp", "rez", "re", "response", "rc", "rev", "r", "red", "os", "ack", "rem", "err", "rel", "inv", "rss", "ps", "RES", "def", "resolution", "results", "rs", "reset", "des", "pers", "pres", "ress", "result", "details", "resh", "pr", "ms", "cond", "Res", "vals", "reg", "rest", "wcs", "gr", "req", "crit", "rec", "rek", "pas"], "refcount_table": ["refcountsTABLE", "refcount2table", "refcountstab", "refcountisttable", "refcountistset", "refname_tab", "refchildistsource", "refountstable", "refcount_TABLE", "refcount2database", "refval_table", "refcount2TABLE", "refchild_source", "refcount_db", "refvaledlist", "refcount2list", "refcount_source", "refcount_array", "refount_tab", "refcounteddatabase", "refcountedtable", "refchildistset", "refname_table", "refval_database", "refcountsTable", "refname_Table", "refountstab", "refcountistdb", "refvaledTABLE", "refount_table", "refchild_set", "refval_list", "refcount_database", "refcount_set", "refchild_table", "refount_Table", "refcountstable", "refname_array", "refountsTABLE", "refountsTable", "refchildistdb", "refchild_db", "refchildisttable", "refcount_list", "refcount_Table", "refvaledtable", "refount_TABLE", "refcount_tab", "refval_TABLE", "refcountedTABLE", "refcountsarray", "refvaleddatabase", "refcountedlist", "refcountistsource"], "refcount_table_size": ["refcount_TABLE_size", "refcount_table_SIZE", "refcount_table2length", "refcount_TABLE_ize", "refcount_table_Size", "refcount_list_size", "refcount_list_length", "refcount_table2SIZE", "refcount_TABLE_length", "refcount_TABLE_SIZE", "refcount_list_SIZE", "refcount_table_length", "refcount_table2size", "refcount_table_ize", "refcount_table2ize"], "offset": ["end", "first", "oid", "begin", "et", "index", "set", "Offset", "ref", "off", "length", "seed", "attribute", "count", "top", "key", "style", "id", "trace", "empty", "timeout", "row", "slot", "reset", "initial", "peer", "tile", "base", "fp", "shift", "align", "seek", "position", "location", "addr", "scroll", "error", "prefix", "sector", "block", "address", "pos", "slice", "pointer", "origin", "point", "padding", "alias"], "size": ["name", "scope", "capacity", "message", "number", "si", "amount", "sum", "SIZE", "length", "scale", "large", "fee", "count", "total", "style", "resolution", "space", "empty", "timeout", "max", "bytes", "no", "body", "shift", "height", "sn", "sized", "ize", "gravity", "full", "send", "position", "storage", "shape", "area", "Size", "range", "zero", "address", "len", "small", "padding", "type"], "s": ["comm", "p", "t", "is", "sys", "ubs", "h", "ss", "ns", "ims", "y", "ses", "stats", "ps", "eps", "cs", "sts", "rs", "gs", "fs", "aws", "c", "ds", "bis", "pers", "locks", "south", "sn", "abilities", "sm", "ls", "sam", "sv", "ssl", "sw", "ats", "hs", "ms", "S", "js", "ess", "g", "its", "sq", "ts", "sp", "http", "als", "ins", "qs", "less", "sb", "b", "l", "sl", "series", "serv"], "start": ["t", "p", "use", "end", "first", "it", "begin", "set", "arts", "starting", "index", "started", "root", "init", "top", "before", "id", "space", "row", "st", "get", "step", "wind", "base", "shift", "Start", "seek", "part", "open", "iter", " starting", "rest", "sp", "ist", "from", "range", " tid", "pre", "store", "next", " Start", "pointer", "ish", "origin", "art"], "last": ["old", "scope", "end", "any", "first", "final", "worst", "latest", "tail", "most", "total", "largest", "las", "best", "max", "close", "st", "good", "reverse", "since", "show", "ast", "base", "nd", "full", "est", "Last", "stable", "rest", "based", "after", "bottom", "next"], "cluster_offset": ["cluster___offset", "clocation___id", "clusterptoffset", "cluster_item", "cluster_length", "clocation___length", "clusters_index", "clusterptitem", "clust_pos", "cluster___id", "clusterptkey", "cluster_point", "clusters_offset", "clust_Offset", "cluster_key", "clust_position", "clusters_Offset", "cluster_pos", "clocation_id", "clust_offset", "cluster_id", "cluster____item", "clocation_length", "clust_item", "cluster_position", "cluster_index", "clocation_url", "clocation___url", "cluster____offset", "cluster_url", "clocation_offset", "cluster___url", "clusters_point", "clocation___offset", "cluster___length", "cluster____key", "clust_point", "clust_key", "cluster_Offset", "clust_id"], "k": ["kw", "n", "mk", "ck", "kt", "ks", "km", "kind", "ack", "ek", "kan", "m", "unk", "wk", "sk", "ac", "key", "i", "ko", "c", "ku", "kl", "ki", "j", "alpha", "z", "kn", "K", "ke", "q", "ask", "kr", "kh", "ka", "kk", "ik", "kick", "g", "kb", "ijk", "ak", "u", "kid", "kj", "uk"], "refcount": [" refcomment", "Refc", "refc", "alfcount", "recount", " refcall", "refconst", "alfcounter", "efcount", "calcell", "alfcloud", " refount", "refcache", "reconst", "recomment", " refcounter", "refcounter", "refcall", "referencec", "respcount", "respcache", "refcloud", "replconst", "calcounter", "refcomment", "Refcount", "replcomment", "reount", "alfcell", "calcount", "Refount", "Refcall", "replcount", "efcache", "refount", "refcell", "efcounter", " refcell", "referenceount", " refcloud", "referencecount", "referencecall", " refc", " refconst", "calcloud", " refcache", "respcounter", "replount"], "ret": ["gt", " Ret", "resp", "t", "re", "out", "final", "rev", "it", "print", "cat", "r", "ref", "back", "rets", "rem", "value", "err", "Ret", " alt", "count", "val", "nz", "dt", "ter", "ext", "reset", "jp", "tr", "j", "no", "status", "result", "mt", "sr", "deg", "ft", "rt", "jump", "alt", "true", "num", "reg", "try", "nt", "RET", "after", "len", "ll", "elt", "att", "ry", "flag", "net"], "check_errors": ["checkdchecks", "checkdresults", "check_checks", "check_rows", "read_results", "check_results", "checkderrors", "read_checks", "read_errors", "read_rows", "checkdrows"], "corruptions": ["corritations", "chriture", "chritured", "chritations", "chruptured", "corrupture", "corritions", "corstructure", "corstructions", "corritured", "corrotured", "chrupture", "corroture", "corstructured", "corruptured", "corrotations", "corrotions", "chruptations", "chruptions", "corruptations", "corstructations", "chritions", "corriture"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n", "idx": 20257, "substitutes": {"opaque": ["oppaque", " oposter", "oplaque", "OPaque", "opent", "OPoster", "OPly", "Opaque", "opane", "oppca", "opca", " opca", "oppane", "Oposter", "oposter", " opane", "opllay", "opplay", " oplay", "oplane", "Oply", "oply", " opent", "OPent", "Opent", " oply", "oplay", "oplca"], "addr": ["fx", " address", "dh", "state", "alloc", "r", "arp", "ref", "off", "err", "add", "offset", "src", "inter", "loc", "x", "eth", "rs", "tx", "host", "handle", "ip", "hw", "ord", "ptr", "now", "rt", "Address", "adr", "dr", "ad", "at", "wd", "address", "cmd", "ace", "pos", "work", "store", "obj", "pad", "attr", "alias"], "value": ["name", "volume", "property", "VALUE", "vector", " sum", "state", "message", " amount", "func", "number", "memory", "index", "set", "length", "ay", " sequence", "fee", "val", " cost", " parameter", "code", "Value", "data", "byte", "content", "function", " weight", "values", "buffer", "mem", " v", "block", "address", " values", " quantity", " val", "ue", "v", " pair", "type"], "size": ["n", "name", " length", "bits", "length", "SIZE", "offset", "count", "val", "weight", "info", "args", "data", "ity", "bytes", "z", "buf", "ize", "num", "mem", "Size", "address", "len", "l", "v", "type"], "backref": ["Backpointer", "frontreference", "Backref", "backreference", "frontRef", "backRef", "frontpointer", "BACKref", "BackRef", "BACKreference", "Backptr", "frontref", " backreference", " backpointer", "BACKRef", "sideref", "Backreference", " backRef", "sideRef", "sidereference", "backpointer", "sideptr", "backptr", " backptr"], "s": ["n", "t", "p", "state", "is", "a", "r", "source", "o", "set", "os", "f", "h", "m", "ss", "ns", "sd", "stats", "d", "bs", "ps", "i", "sts", "e", "cs", "rs", "gs", "c", "ds", "sis", "se", "z", "ls", "sv", "hs", "S", "js", "g", "ins", "sq", "ts", "als", "less", "sb", "b", "l", "v", "sl"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "substitutes": {"addr": ["dh", "alloc", "et", "r", "arp", "ack", "ref", "gate", "off", "ix", "err", "add", "offset", "ay", "act", "d", "src", "pkg", "arr", "inter", "id", "eth", "tx", "hw", "coord", "ctx", "ptr", "align", "ag", "alt", "hl", "help", "at", "adr", "ad", "dr", "address", "cmd", "store", "pad", "att", "v", "attr", "oc"], "val": ["valid", "p", "all", "sel", "ival", "it", "ret", "vc", "index", "vol", "ref", "f", "aval", "bal", "value", " value", "err", "al", "ac", "fee", "eval", "serv", "pl", "pt", "x", "arg", "loc", "arr", "tx", "data", "test", "bit", "var", "Val", "pol", "z", "buf", "ctx", "q", "pr", "num", "res", "VAL", "vals", "buffer", "reg", "mem", "util", "cal", "len", "sol", "port", "v", "lib", "sl", "vt"]}}
{"project": "qemu", "commit_id": "9f2130f58d5dd4e1fcb435cca08bf77e7c32e6c6", "target": 0, "func": "static int fb_initialise(struct XenDevice *xendev)\n\n{\n\n    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);\n\n    struct xenfb_page *fb_page;\n\n    int videoram;\n\n    int rc;\n\n\n\n    if (xenstore_read_fe_int(xendev, \"videoram\", &videoram) == -1)\n\n\tvideoram = 0;\n\n\n\n    rc = common_bind(&fb->c);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    fb_page = fb->c.page;\n\n    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,\n\n\t\t\t    fb_page->width, fb_page->height, fb_page->depth,\n\n\t\t\t    fb_page->mem_length, 0, fb_page->line_length);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    rc = xenfb_map_fb(fb);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n#if 0  /* handled in xen_init_display() for now */\n\n    if (!fb->have_console) {\n\n        fb->c.ds = graphic_console_init(xenfb_update,\n\n                                        xenfb_invalidate,\n\n                                        NULL,\n\n                                        NULL,\n\n                                        fb);\n\n        fb->have_console = 1;\n\n    }\n\n#endif\n\n\n\n    if (xenstore_read_fe_int(xendev, \"feature-update\", &fb->feature_update) == -1)\n\n\tfb->feature_update = 0;\n\n    if (fb->feature_update)\n\n\txenstore_write_be_int(xendev, \"request-update\", 1);\n\n\n\n    xen_pv_printf(xendev, 1, \"feature-update=%d, videoram=%d\\n\",\n\n\t\t  fb->feature_update, videoram);\n\n    return 0;\n\n}\n", "idx": 20283, "substitutes": {"xendev": ["wxendeddev", "xendsapter", "xiendedew", "xindDev", " xenderv", "vendew", "xengec", "xendsDev", "vndew", "xenele", "xengdev", " xendsep", "xaddv", "xendserv", "xenect", "ixendec", "zenddev", "xendeddev", "xendapter", "xendeddevice", "xindev", "xiendedele", "zendep", "xendep", "xideev", "xiderv", "xendew", "xidapter", "xendsele", "xndect", "xendsee", " xendsapter", "wxendev", " xendsdev", "ixendedect", "xendsev", "wxendeddevice", "xendec", "xendedew", "xaddev", "xadddev", "xiendee", " xendapter", "xsenddev", "xendv", "xenec", "zendedep", "xenddev", "wxendedev", "zendv", "xenew", "venddev", "xengdevice", "xindapter", "ixenddev", " xendDev", "xenderv", "vndDev", "vendDev", "xendedect", "xndv", "wxendec", " xindDev", "xendele", "xendect", "xiendev", "ixendedec", " xindev", "wxenddev", "zendev", " xendep", "xendedele", "xendedev", "xiendele", "xengev", "xiendedee", "ixendect", "ixendedev", "xenev", "ixendev", "xenee", "xendedDev", "xendedec", "vndev", "xideapter", "xendedv", "xendee", "xndec", "xnddevice", "xaddep", "vendev", "xideep", "xendDev", "zendedev", "wxenddevice", "xndDev", "xsendDev", "wxendedec", "xndev", "ixendeddev", "xndew", " xendsev", "xendedee", "zendeddev", "xidedev", "xenddevice", "xiendedev", "xiendew", "xidev", "zendedv", "xndapter", " xinderv", "xendedep", "xendsep", "xsendew", "xnddev", "xndep", "xendsdev", " xindapter", "xsendev", "xidDev", "xendsew", "xinderv", "vnddev", " xenddev"], "fb": ["blog", "gif", "fee", "fuel", "eval", "fe", "uf", "wp", "deb", "vy", "hd", "fr", "ff", "wb", "bt", "be", "sb", "fab", "fl", "tf", "bb", "abb", "eb", "beck", "gb", "bs", "pp", "fm", "fs", "FB", "nb", "gold", "xff", "fi", "rh", "db", "fen", "face", "facebook", "fam", "b", "fc", "ffff", "bf", "ref", "f", "zy", "abc", "lb", "fg", "hab", "ab", "buf", "fax", "ctx", "icc", "fa", "buffer", "xf", "buff", "vt", "fx", "rb", "btn", "cb", "raf", "ob", "bridge", "ctrl", "fw", "fp", "abl", "bm", "grab", "rf", "fd", "pb", "bp"], "fb_page": ["ebmypoint", "bufgetpage", "abb_phrase", "abb_page", "fb_phrase", "bufgetchain", "fbmatpage", "fb_map", "fb1chain", "fw_page", "fb_port", "fb_pages", "fb1client", "facebook_pool", "fw_point", "abb_disk", "eb_record", "fb_c", "eb_line", "fb_load", "fb_memory", "fbmlpage", "fbprodisk", "fbmypoint", "fbpromemory", "facebook_p", "fb_message", "buf_record", "facebook_pages", "ebmypage", "fbmyline", "buf_chain", "fb_pool", "buf_page", "fb_p", "abb_memory", "fbmlclient", "fbgetchain", "fb_disk", "fb_point", "fbpropage", "fb_record", "fbmypage", "fb1record", "ffff_client", "ffff_message", "fw_port", "fb_pointer", "bufgetrecord", "fbgetclient", "facebook_page", "facebook_load", "fb_line", "fb_space", "ffff_space", "fw_c", "ffff_page", "ebmyrecord", "fb_client", "fbgetrecord", "fbmyclient", "fbmlspace", "ebmyline", "fbmyrecord", "facebook_map", "bufgetclient", "fb_chain", "fbmlmessage", "eb_page", "fb1page", "facebook_pointer", "buf_client", "fbmatload", "eb_point", "fbmychain", "fbmatpointer", "fbprophrase", "fbgetpage", "fbmatpages"], "videoram": ["videorAM", "videratorom", "videorableam", "videORAm", "videorsiam", "videorsam", "videoAM", "videoramm", "videORiam", "videorsamin", "vendoam", "videroram", "vidoriam", "videoriams", "videoramin", "vendoray", "videoams", "videatoramer", "videoredim", "videoredam", "videratoramer", "vendorom", "videorom", "videatorot", "vieoredim", "videoriay", "vendorAm", "vendoams", "vidoramin", "vendORiam", "videoriAM", "videoramer", "videorationAm", "videorsams", "videorams", "videonom", "vieoramm", "videorsAM", "vendoriam", "videORamm", "vieoram", "videratorot", "vidoriams", "vendoAM", "vendORAm", "vendORam", "videorationam", "videORim", "videatorom", "videoriot", "vieorim", "vidoriamin", "videoay", "vendorams", "videORom", "videoam", "videoriamin", "videorsAm", "videonam", "videorsom", "vidoram", "videORam", "videraram", "videatoram", "vieoredam", "vendORom", "videorableams", "vendorAM", "videoray", "videorableiam", "videorAm", "vieoracion", "vieoredamm", "viderorom", "videorsay", "viderorot", "videoriom", "videorableamin", "videratoram", "vidorams", "videorationom", "videonot", "videonamer", "videoredacion", "videorim", "videoredamm", "videraracion", "videorot", "vidoriiam", "videORacion", "videoriam", "videoracion", "vieoredacion", "videoriiam", "viderarim", "videraramm", "vendoram", "videroramer", "videorationiam", "videoriamer", "vendoay"], "rc": ["ras", "ck", "userc", "cont", "ce", "ack", "desc", "auc", "con", "cd", "uc", "cur", "res", "lc", "cr", "tc", "ry", "success", "re", "isc", " ro", "sync", "rr", "cs", "ko", "cmp", "clus", " cr", "xff", "arc", "rh", "sc", "dr", "rac", "pc", "cc", "core", "sys", "r", "dc", "co", "gc", "rin", "irc", "RC", "c", "rys", "ec", "cod", "raw", "roc", "nc", "comp", "ok", "yes", "usr", "func", "ac", "src", " RC", "ro", "code", "bc", "rs", "row", "rx", "rt", "cor", "priv", "rl", " proc", "rec", "ctr"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_exts(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8s_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16s_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32s_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20299, "substitutes": {"ot": ["t", "pot", "isc", "tt", "quote", "mot", "ort", "it", "oid", "et", "os", "OT", "oted", " tot", "oting", "y", "lot", "ox", "ct", "cot", "pt", " dot", "or", "hot", "ote", "ott", "ant", "yt", "ent", "rt", " pt", "Mot", "at", "ots", "rot", "nt", "typ", "oot", "iat", "oc", "ota", " mot", "iot"], "reg": [" registry", "p", "re", "rect", "leg", "msg", "sys", "tag", "org", "ret", "r", "ru", "gro", "go", "rom", "rem", "err", " region", "Reg", "disc", "domain", "gb", "gc", "act", "val", "rg", "eg", "rar", "or", "asm", "lang", "greg", "istry", "ring", "urg", "br", "dat", "res", "db", "rule", "addr", "region", "mem", "rm", "g", " rg", "gr", "REG", "req", "pool", "cmd", "cache", "form", "gen", "rec", "grid", "eng", "gov", "net", "serv"]}}
{"project": "qemu", "commit_id": "c0462f6d75fa481f7660c15a5ca3a60205aa4eca", "target": 0, "func": "bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n", "idx": 20301, "substitutes": {"param": ["perm", "dm", "tag", "prom", "comment", "me", "mm", "index", "ref", "pm", "m", "rem", "member", "attribute", "Param", "program", "im", "package", "vim", "arg", "target", "attr", "jp", "prop", "argument", "min", "num", "Parameter", "part", "cm", "buffer", "dem", "par", "config", "prefix", "command", "params", "aram", "mark", "cal", "address", "form", "v", "cp", "padding", "ram", "type"], "buf": ["bag", "msg", "cap", "txt", "rb", "func", "cat", "cb", "ref", "h", "window", "err", "bl", "conv", "Buff", "pkg", "arr", "uf", "bc", "Buffer", "bar", "cv", "str", "data", "paren", "vec", "cur", "batch", "que", "proc", "result", "img", "ctx", "br", "bh", "brace", "queue", "tmp", "wb", "seq", "buffer", "iter", "mem", "pend", "buff", "np", "cmd", "block", "bu", "bin", "cam", "pg", "ah", "pb", "emb", "pool", "port", "b", "pad", "v", "cast", "bp", "cp"], "p": ["n", "perm", "t", "pot", "r", "ping", "f", "m", "tp", "h", "pkg", "d", "ps", "pt", "pp", "pro", "lp", "x", "i", "wp", "c", "pa", "pers", "jp", "j", "pid", "fp", "result", "prop", "ctx", "P", "ptr", "q", "pr", "pe", "part", "buffer", "par", "g", "sp", "rep", "pb", "np", "pc", "pos", "pre", "pointer", "b", "bp", "v", "l", "cp", "point"]}}
{"project": "FFmpeg", "commit_id": "099d6813c27faf95257a529aa2c65dfde816a487", "target": 1, "func": "int ff_h264_alloc_tables(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int big_mb_num= s->mb_stride * (s->mb_height+1);\n\n    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;\n\n    int x,y;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)\n\n\n\n    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n\n    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);\n\n    for(y=0; y<s->mb_height; y++){\n\n        for(x=0; x<s->mb_width; x++){\n\n            const int mb_xy= x + y*s->mb_stride;\n\n            const int b_xy = 4*x + 4*y*h->b_stride;\n\n\n\n            h->mb2b_xy [mb_xy]= b_xy;\n\n            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));\n\n        }\n\n    }\n\n\n\n    s->obmc_scratchpad = NULL;\n\n\n\n    if(!h->dequant4_coeff[0])\n\n        init_dequant_tables(h);\n\n\n\n    return 0;\n\nfail:\n\n    free_tables(h, 1);\n\n    return -1;\n\n}\n", "idx": 20305, "substitutes": {"h": ["he", "eh", "m", "th", "host", "hd", "fr", "br", "bh", "hs", "_", "v", "zh", "hh", "o", "hal", "jpg", "H", "ha", "pp", "info", "ih", "op", "hz", "ph", "rh", "hm", "hp", "dr", "has", "b", "hi", "comm", "ht", "ssh", "ho", "f", "hash", "exec", "def", "c", "hw", "ctx", "sh", "kh", "her", "hhh", "cache", "gh", "history", "p", "dh", "func", "oh", "here", "q", "hl", "ch", "http", "ah", "each", "w"], "s": ["ties", "is", "m", "ims", "ops", "sts", "ds", "sv", "sw", "tools", "hs", "es", "ins", "ants", "als", "sb", "v", "sl", "n", "a", "o", "os", "ns", "conv", "bs", "cs", "e", "i", "fs", "aws", "se", "his", "ers", "ats", "vs", "g", "wcs", "has", "ts", "gets", "qs", "b", "tes", "les", "comm", "t", "sys", "css", "session", "stats", "ps", "c", "ctx", "spec", "ls", "sh", "S", "its", "sp", "conf", "serv", "history", "p", "parts", "ys", "ss", "ses", "sports", "rs", "gs", "j", "ms", "js", "sq", "ges", "w"], "x": ["n", "p", "t", " X", "dx", "o", "index", " xx", "f", "m", "ix", "ox", " i", "i", "e", "tx", "xy", "rx", "X", "z", "ex", "px", "xs", "l", "v", "w"], "y": ["n", "t", "yy", "p", "py", "o", "m", "key", "cy", "iy", "ey", "yl", "i", "e", "ly", "ny", "my", "vy", "xy", "j", "dy", "sy", "Y", "ch", "ym", "ry", "b", "v"]}}
{"project": "FFmpeg", "commit_id": "3583eb93410a73cac8ddf291baa405005ff4c405", "target": 0, "func": "static inline CopyRet copy_frame(AVCodecContext *avctx,\n\n                                 BC_DTS_PROC_OUT *output,\n\n                                 void *data, int *data_size,\n\n                                 uint8_t second_field)\n\n{\n\n    BC_STATUS ret;\n\n    BC_DTS_STATUS decoder_status;\n\n    uint8_t is_paff;\n\n    uint8_t next_frame_same;\n\n    uint8_t interlaced;\n\n\n\n    CHDContext *priv = avctx->priv_data;\n\n\n\n    uint8_t bottom_field = (output->PicInfo.flags & VDEC_FLAG_BOTTOMFIELD) ==\n\n                           VDEC_FLAG_BOTTOMFIELD;\n\n    uint8_t bottom_first = !!(output->PicInfo.flags & VDEC_FLAG_BOTTOM_FIRST);\n\n\n\n    int width    = output->PicInfo.width;\n\n    int height   = output->PicInfo.height;\n\n    int bwidth;\n\n    uint8_t *src = output->Ybuff;\n\n    int sStride;\n\n    uint8_t *dst;\n\n    int dStride;\n\n\n\n    ret = DtsGetDriverStatus(priv->dev, &decoder_status);\n\n    if (ret != BC_STS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"CrystalHD: GetDriverStatus failed: %u\\n\", ret);\n\n       return RET_ERROR;\n\n    }\n\n\n\n    is_paff           = ASSUME_PAFF_OVER_MBAFF ||\n\n                        !(output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC);\n\n    next_frame_same   = output->PicInfo.picture_number ==\n\n                        (decoder_status.picNumFlags & ~0x40000000);\n\n    interlaced        = ((output->PicInfo.flags &\n\n                          VDEC_FLAG_INTERLACED_SRC) && is_paff) ||\n\n                         next_frame_same || bottom_field || second_field;\n\n\n\n    av_log(avctx, AV_LOG_VERBOSE, \"CrystalHD: next_frame_same: %u | %u | %u\\n\",\n\n           next_frame_same, output->PicInfo.picture_number,\n\n           decoder_status.picNumFlags & ~0x40000000);\n\n\n\n    if (priv->pic.data[0] && !priv->need_second_field)\n\n        avctx->release_buffer(avctx, &priv->pic);\n\n\n\n    priv->need_second_field = interlaced && !priv->need_second_field;\n\n\n\n    priv->pic.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE |\n\n                             FF_BUFFER_HINTS_REUSABLE;\n\n    if (!priv->pic.data[0]) {\n\n        if (avctx->get_buffer(avctx, &priv->pic) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return RET_ERROR;\n\n        }\n\n    }\n\n\n\n    bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n\n    if (priv->is_70012) {\n\n        int pStride;\n\n\n\n        if (width <= 720)\n\n            pStride = 720;\n\n        else if (width <= 1280)\n\n            pStride = 1280;\n\n        else if (width <= 1080)\n\n            pStride = 1080;\n\n        sStride = av_image_get_linesize(avctx->pix_fmt, pStride, 0);\n\n    } else {\n\n        sStride = bwidth;\n\n    }\n\n\n\n    dStride = priv->pic.linesize[0];\n\n    dst     = priv->pic.data[0];\n\n\n\n    av_log(priv->avctx, AV_LOG_VERBOSE, \"CrystalHD: Copying out frame\\n\");\n\n\n\n    if (interlaced) {\n\n        int dY = 0;\n\n        int sY = 0;\n\n\n\n        height /= 2;\n\n        if (bottom_field) {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: bottom field\\n\");\n\n            dY = 1;\n\n        } else {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: top field\\n\");\n\n            dY = 0;\n\n        }\n\n\n\n        for (sY = 0; sY < height; dY++, sY++) {\n\n            memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);\n\n            if (interlaced)\n\n                dY++;\n\n        }\n\n    } else {\n\n        av_image_copy_plane(dst, dStride, src, sStride, bwidth, height);\n\n    }\n\n\n\n    priv->pic.interlaced_frame = interlaced;\n\n    if (interlaced)\n\n        priv->pic.top_field_first = !bottom_first;\n\n\n\n    if (output->PicInfo.timeStamp != 0) {\n\n        priv->pic.pkt_pts = opaque_list_pop(priv, output->PicInfo.timeStamp);\n\n        av_log(avctx, AV_LOG_VERBOSE, \"output \\\"pts\\\": %\"PRIu64\"\\n\",\n\n               priv->pic.pkt_pts);\n\n    }\n\n\n\n    if (!priv->need_second_field) {\n\n        *data_size       = sizeof(AVFrame);\n\n        *(AVFrame *)data = priv->pic;\n\n    }\n\n\n\n    if (ASSUME_TWO_INPUTS_ONE_OUTPUT &&\n\n        output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) {\n\n        av_log(priv->avctx, AV_LOG_VERBOSE, \"Fieldpair from two packets.\\n\");\n\n        return RET_SKIP_NEXT_COPY;\n\n    }\n\n\n\n    return RET_OK;\n\n}\n", "idx": 20320, "substitutes": {"avctx": ["savctx", " avcmd", "avercu", "awcontext", " avconn", "avcf", "avercf", "avcontext", "vrpkg", "AVcfg", "avertxt", " avcfg", "awpkg", "avertx", "avercontext", "vrcontext", " avpkg", "avtx", "avtxt", "averjac", "awcmd", "aversc", "AVconn", "averctx", "savjac", "awconn", "avejac", "vrconn", "avjac", "savcf", "savcu", "avsc", "avfc", "avecontext", " avsc", "avesc", "vrtx", "avpkg", "AVcontext", "avcmd", "awctx", "awtx", "AVtx", " avtxt", "averfc", " avfc", "avecu", "avecf", "avefc", "avectx", "avcu", "avcfg", "avercfg", "AVctx", " avcontext", "vrcmd", " avtx", "vrtxt", "avconn", "vrctx"], "output": ["response", "out", "final", "PUT", "ilo", "entity", "print", "o", "write", "policy", "filter", "progress", "format", "answer", "image", "secure", "display", "document", "online", "info", "outer", "no", "export", "connection", "detail", "see", "version", "op", "option", "net", "four", "web", "generated", "position", "module", "video", "operation", "console", "open", "buffer", "product", "Output", "new", "sort", "put", "common", "config", "update", "global", "error", "command", "block", "prev", "protected", "remote", "cache", "production", "input", "hidden", "success", "file", "network", "public", "text"], "data": ["name", "p", "t", "out", "start", "bits", "message", "window", "offset", "table", "d", "ata", "image", "ops", "received", "id", "empty", "mu", "tx", "bytes", "batch", "no", "buf", "pipe", "extra", "DATA", "dat", "map", "buffer", "doc", "Data", "block", "bin", "w", "pos", "input", "sample", "next", "pointer", "actions", "pad", "da", "text"], "data_size": ["image_len", "image_length", "data_length", "data_len", "image_size", "data_type", "image_type"], "second_field": ["third_fields", "second___field", "Second___field", "secondFieldfield", "Second_buffer", "second_buffer", "Second_fields", "third_buffer", "Second_field", "secondFieldmargin", "second___fields", "Second___buffer", "secondFieldfields", "secondFilemargin", "secondFilefields", "secondFilebuffer", "second___buffer", "third_margin", "second_margin", "second_fields", "third_field", "secondFieldbuffer", "secondFilefield", "Second___fields"], "ret": [" Ret", "gt", "resp", "fun", "t", "re", " RET", "out", "state", "lit", "final", "rev", "txt", "prot", "cat", " res", "r", "cont", "stat", "ref", "desc", "rets", "Return", "summary", "err", "hash", "Ret", "val", " returned", "def", "ter", "code", "reset", "sat", "jp", "imp", "tr", "status", "detail", "result", "mt", "deg", "ft", "rt", "reply", " resp", "res", "alt", "report", "nt", "RET", "std", "obj", "len", "elt", "terror"], "decoder_status": ["decode_stats", "decode_report", "decoderpyreport", "decoder_msg", "decode_state", "decoderCstate", "decoderationstatus", "decoder_stat", "decoder_report", "decoder__status", "decoderCstatus", "decoder_state", "decoder_stats", "decode_status", "decoder_Status", "decoder__Status", "decoded_Status", "decoder2state", "decoding_status", "decoderpystatus", "decoderpystats", "decoder2status", "decode_stat", "decoder2stat", "decoder__stats", "decoder2Status", "decoder__score", "decoding_msg", "decoderationmsg", "decoded_stat", "decode_Status", "decoder_score", "decoderCstat", "decoderationscore", "decoder__msg", "decoding_score", "decoderpyStatus", "decoderCStatus", "decoded_status", "decoder__report"], "is_paff": ["is_bpaf", "is2maffe", "is2puff", "is_pcap", "is2paffe", "is_maff", "is_spaf", "is_cuff", "is2muff", "is_cpaf", "is2maff", "is_cpuff", "is_piffe", "is_cpaff", "is2maf", "is_spaff", "is_paf", "is_Paff", "is_mcap", "is_spiffe", "is_caff", "is_vaff", "is_Pff", "is_puff", "is2paff", "is_maf", "is_pff", "is_Paf", "is_bpiffe", "is_Pcap", "is_maffe", "is_ciffe", "is_vcap", "is_bpuff", "is_vff", "is_Puff", "is_caf", "is2paf", "is_vaffe", "is_muff", "is_mff", "is_bpaff", "is_spuff", "is_paffe", "is_cpaffe", "is_Paffe"], "next_frame_same": ["next_frame_safe", "next_framelysame", "next_frames_equal", "next_Frame_same", "next_frames_good", "next_frame_good", "next_Frame_safe", "next_frames_present", "next_frames_same", "next_framelyident", "next_frame_ident", "next_frames_match", "next_frame_equal", "next_frame_present", "next_frame_match", "next_frame_num", "next_framelynum", "next_framelyequal", "next_Frame_good", "next_Frame_equal"], "interlaced": ["interlitacer", "interflocated", "interlace", "interflisted", "interristed", " interlacer", "interlcaded", "INTERlocated", "interplisted", "interfladed", " interplaced", "interplaed", "interraded", "interplaced", "interlitocated", "interplace", "interladed", "intervlaed", "interlitaced", " interlisted", "interrocated", "interlayacer", "interlcaced", "intercomplocated", "interlocated", "intervlace", "INTERplace", " interpladed", " interplisted", " interlocated", "interlitaded", "intercomplaced", "interlayocated", "INTERplaed", "interflaced", " interladed", "intervlaced", "INTERlaed", "interlacer", "intervlocated", "INTERplaced", "interlcacer", "INTERlaced", " interlayaded", " interlayaced", " interlayacer", "intercomplace", "interraced", "INTERlace", "interpladed", " interplocated", " interlayocated", "interlisted", "interlaed", "interlcocated", "interlayaced", "INTERplocated", "interlayaded", "intercomplaed", "interplocated"], "priv": ["perm", "expr", "sys", "pas", "rc", "usr", "ssh", "alloc", "org", "access", "private", "prov", "sec", "policy", "notice", "por", "stats", "pkg", "pro", "loc", "conn", "Priv", "pri", "deb", "cp", "good", "cmp", "tr", "proc", "pub", "pol", "rw", "prop", "urg", "ctx", "ptr", "pr", "lib", "env", "trust", "auth", "sky", "dev", "mem", "ch", "ocr", "Pri", "sp", "rep", "req", "conf", "soc", "pre", "rib", "not", "pi", "gov", "encrypted", "riv", "cfg", "ev", "attr", "pic", "serv"], "bwidth": ["bWidth", " bstr", "bstr", "Bstr", " bsize", "dwidth", "Bsize", "dstr", "Bwidth", "bsize", " bWidth", "dsize", "dWidth", "BWidth"], "src": ["sys", "rc", "txt", "usr", "source", "rel", "dir", "iv", "dest", "loc", "rs", "img", "buf", "sn", "ptr", "bh", "tmp", "bg", "sc", "sub", "rl", "inst", "input", "sb", "ser", "comp", "origin", "attr"], "sStride": ["tsStr", "sstide", "sRestr", "sRestride", "sSprat", "sstrat", "tsRestide", "sStrat", "tsStride", "sSpride", "tsRestride", "sRestrat", "tsStide", "tsStrat", "sstr", "sstride", "sStr", "sRestide", "sSpide", "tsRestr", "tsRestrat", "sSpr", "sStide"], "dst": ["dbl", "dsc", "mth", "idbl", "dth", "msc", "idst", "jsc", "jbl", "mst", "idsc", "jst", "mbl", "jth", "idth"], "dStride": ["dSlride", "dSTride", "dstride", "dStrip", "dSlide", "dstide", "dSTide", "dSlrd", "dstrip", "bStrip", "bStide", "bStrd", "bSlide", "dstrd", "dStide", "bSlrip", "dStrd", "dSTrd", "bSlrd", "dSlrip", "bSlride", "dSTrip", "bStride"]}}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n", "idx": 20327, "substitutes": {"nc": ["n", "rn", "ck", "cb", "cn", "nr", "tn", "dc", "ns", "gc", "nw", "ct", "unc", "nz", "cs", "bc", "nn", "conn", "cv", "c", "nb", "nd", "sn", "ctx", "nm", "NC", "nic", "sc", "NT", "nt", "anc", "mc", "pc", "np", "tc", "nl", "nec", "ne", "cc", "nv", "mn", "fc", "net"], "s": ["n", "comm", "t", "sys", "is", "a", "sa", "os", "stat", "h", "changes", "ns", "ss", "y", "ses", "sync", "stats", "iss", "bs", "ps", "ops", "cs", "sts", "sports", "rs", "gs", "fs", "aws", "ds", "sis", "j", "se", "sm", "sn", "spec", "ls", "sam", "sv", "sw", "ssl", "ats", "hs", "S", "js", "new", "es", "its", "sq", "ts", "sp", "ins", "conf", "obj", "qs", "sb", "sol", "an", "b", "as", "sl", "w"]}}
{"project": "qemu", "commit_id": "79d5ca5617cfc9be13a4f314ed800fca1267d903", "target": 1, "func": "static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 20328, "substitutes": {"fd": ["fn", "ed", "td", "flags", "bf", "cb", "dd", "io", "f", "dc", "du", "fed", "sd", "dn", "dir", "d", "fff", "id", "fm", "ld", "dt", "ind", "eth", "cd", "fs", "bd", "ds", "dl", "hd", "pid", "ord", "fp", "nd", "ff", "df", "fi", "cond", " fid", "db", "fa", "fin", "ud", "ln", "len", "lf", "pd", "fc", "FD"], "node": ["n", "fn", "name", "parent", "t", "msg", "normal", "slave", "this", "source", "index", "list", "desc", "field", "f", "m", "root", "seed", "Node", "item", "nw", "d", "post", "key", "note", "id", "e", "document", "nn", "attr", "cd", "row", "data", "c", "leaf", "good", "local", "hd", "content", "nd", "result", "link", "k", "manager", "child", "server", "event", "tmp", "entry", "db", "self", "component", "edge", "adj", "new", "inner", "wife", "nt", "path", "tree", "np", "obj", "len", "handler", "holder", "nil", "instance"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,\n\n                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    int i;\n\n#if COMPILE_TEMPLATE_MMX\n\n    if(!(c->flags & SWS_BITEXACT)) {\n\n        long p= 4;\n\n        const int16_t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW};\n\n        uint8_t *dst[4]= {aDest, dest, uDest, vDest};\n\n        x86_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};\n\n\n\n        if (c->flags & SWS_ACCURATE_RND) {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121_ACCURATE\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        }\n\n        return;\n\n    }\n\n#endif\n\n    for (i=0; i<dstW; i++) {\n\n        int val= (lumSrc[i]+64)>>7;\n\n\n\n        if (val&256) {\n\n            if (val<0) val=0;\n\n            else       val=255;\n\n        }\n\n\n\n        dest[i]= val;\n\n    }\n\n\n\n    if (uDest)\n\n        for (i=0; i<chrDstW; i++) {\n\n            int u=(chrSrc[i       ]+64)>>7;\n\n            int v=(chrSrc[i + VOFW]+64)>>7;\n\n\n\n            if ((u|v)&256) {\n\n                if (u<0)        u=0;\n\n                else if (u>255) u=255;\n\n                if (v<0)        v=0;\n\n                else if (v>255) v=255;\n\n            }\n\n\n\n            uDest[i]= u;\n\n            vDest[i]= v;\n\n        }\n\n\n\n    if (CONFIG_SWSCALE_ALPHA && aDest)\n\n        for (i=0; i<dstW; i++) {\n\n            int val= (alpSrc[i]+64)>>7;\n\n            aDest[i]= av_clip_uint8(val);\n\n        }\n\n}\n", "idx": 20338, "substitutes": {"c": ["n", "kw", "t", "com", "rc", "cont", "ce", "cn", "f", "dc", "m", "h", "ac", "co", "ct", "d", "enc", "con", "cs", "e", "cu", "bc", "cv", "s", "ec", "cmp", "C", "ctx", "lc", "cm", "cf", "ci", "g", "config", "mc", "conf", "tc", "cc", "b", "v", "fc", "ca", "cp", "l", "w"], "lumSrc": ["lumAsr", "luvSrs", "lumbAsrc", "lumbAssrc", "lumbSrc", "lumSourcers", "luvSrc", "luvSuf", "lumSourcerc", "lumIdnc", "lumInsRC", "lumIduf", "luvIdrc", "lumbAsRC", "lumPrt", "lumRsuf", "lumCrt", "lumSsrc", "lamSrc", "lumSourceuf", "luvIdrs", "lumbSr", "lumbSsrc", "lumAsRC", "lumRsrs", "lumSvc", "lumCrc", "lumbAsr", "lumSrt", "lumInsrc", "lamSvc", "lumInsr", "lumAssrc", "lumSRC", "luvIdnc", "lumPvc", "lumSnc", "lumSr", "lamSrt", "luvSnc", "lumAsrc", "lamSRC", "lumCvc", "lumRsrc", "lumSourcenc", "lumSrs", "lumCRC", "lumIdrc", "luvIduf", "lumInssrc", "lumbSRC", "lumSuf", "lumRsnc", "lumPrc", "lumPRC", "lumIdrs"], "chrSrc": ["charSRC", "chdrSourcerc", "chrAsRC", "chrInsrc", "chrInsrt", "chrsRC", "chrAsrc", "chrcInsrl", "chrsla", "chrDRC", "chdrSsrc", "chrSecRC", "charRic", "chrssrc", "chrDsrc", "chrDrc", "charRrc", "chrPrc", "chrSecrc", "chrSourcesrc", "chrSourcerc", "chrPla", "chrSRC", "chrInssrc", "chrcSrc", "chrgSrt", "chrPrl", "chrsrl", "charRsrc", "chrgInssrc", "chdrSrs", "chdrSrc", "chrSecsrc", "chrcInssrc", "chrAsource", "chrRic", "chrRsource", "chrgInsrt", "chrSlrt", "chrSsrc", "chrSlrc", "chrcSsrc", "chrRsvc", "chrInsla", "chrgSsrc", "chrSluf", "charSource", "charRRC", "chrsrc", "chrsrs", "chrSic", "chrRRC", "chdrSourcesrc", "chrRsrc", "chdrSourcers", "chdrSourceRC", "chrRsRC", "chrSvc", "chrPsrc", "chrcInsla", "chrcInsrc", "chrSourceRC", "chrDic", "charSic", "chrSourcers", "charSrc", "chdrSRC", "chrSecic", "chrSla", "chrgSrc", "charSvc", "chrInsrl", "chrgInsuf", "chrSrt", "chrSuf", "chrgInsrc", "charSsrc", "chrSlsrc", "chrSrs", "chrSrl", "chrcSla", "chrgSuf", "chrSource", "chrRrc", "chrInsuf", "chrcSrl", "chrAsvc"], "alpSrc": ["alpSuRC", "alpSyrc", "alpSack", "alpCg", "alpSyst", "alpSyRC", "alpInsrs", "aluSg", "aluSrc", "alpiSust", "alpSRC", "alpSg", "alpAsrc", "alpInsg", "aluAsrc", "alpiSst", "alpiSurc", "alpiSrc", "alpSst", "alpInsrc", "aluAsix", "alpSrs", "aluAsrs", "alpSurc", "alpCrs", "alpAsrs", "alpCix", "alpAsg", "aluSrs", "alpInsix", "aluSix", "aluAsg", "alpSuack", "alpSust", "alpiSuack", "alpiSack", "alpAsix", "alpiSRC", "alpSyack", "alpSix", "alpiSuRC", "alpCrc"], "dest": ["master", "orig", "neg", "out", "usr", "stop", "source", "Dest", "gate", "desc", "list", "dc", "win", "table", "loc", "target", "decl", "data", "st", "temp", "tr", "comb", "result", "pipe", "foreign", "spec", "ptr", "tmp", "est", "buffer", "sc", "priv", "iter", "mem", "rest", "sort", "trans", "sp", "port", "dist", "v", "origin", "chain"], "uDest": ["hTarget", "oDesc", " udest", "oDecl", " uDesc", "hDest", "uDesc", "vDecl", "hEast", "unDest", "ouQueue", "cuTarget", "vEast", "cuDest", "unQueue", "vTarget", "oDest", "cuEast", "ouDesc", "ouDest", "uQueue", "adest", "aDesc", "uTarget", "vdest", "uDecl", "unDecl", "unDesc", "uEast", "hDesc", "vDesc", "udest", "aDecl", "cuDesc", "ouDecl", " uDecl", "oQueue"], "vDest": ["uvDest", "bEnd", "vcDest", "uvBuff", "uvPriv", "vEast", "vTarget", " vEast", "bdest", "wDest", "vEnd", "bEast", "wPriv", " vEnd", "wBuff", "vdest", "vPriv", "vcdest", "wTarget", "uvTarget", " vdest", " vPriv", " vBuff", " vTarget", "vBuff", "vcEast", "bDest", "vcEnd"], "aDest": ["oDesc", "oDecl", "bDecl", "aPriv", "saDesc", "bDesc", "auDest", "aPos", "ADest", " aPos", "bdest", "auPos", "adest", "aDesc", "odest", " aDesc", "saDest", "saPos", "Adest", "auPriv", "auDesc", "bDest", "aDecl", " aPriv", "saPriv", "ADesc", "ADecl", "oDest"], "dstW": ["dirstW", "dSTM", "dsrcR", "ddestM", "DSTM", "drestR", "dsrcW", "dntW", "DestWH", "dsrcS", "dstM", "dSTR", "drestS", "DstWriter", "DstN", "DSTS", "dstR", "dstS", "dsrcWH", "DstU", "dstreamW", "DestH", "DSTWriter", "destH", "dirstM", "DstL", "dstartM", "dsnL", "DstWH", "dSTU", "dstH", "dstWe", "DestW", "dstU", "destM", "DestU", "dSTWe", "dirstWH", "ddestN", "DstH", "dSTW", "destW", "destR", "dSTS", "dntH", "dstartR", "dsnW", "ddestW", "dstartW", "dstreamR", "dsnWriter", "dstN", "dntM", "dostWriter", "DSTW", "dstL", "ddestWH", "dsnH", "drestM", "DSTWe", "DestR", "dstreamM", "drestWe", "dntU", "dstartWe", "destWH", "DstR", "dostW", "DSTH", "DestN", "dSTL", "DstS", "drestW", "dstreamWH", "dostL", "dostH", "dSTWriter", "destN", "dstWH", "dstWriter", "dirstN", "DstW", "dsrcM", "DSTL", "dSTH", "DstWe", "DstM", "DSTR", "destU", "DestM"], "chrDstW": ["chrDrcV", "chrRstH", "chrdrcL", "chrDntT", "chrSndV", "chrRSTL", "chrPrcV", "chrDSTH", "chrDvL", "chrDistH", "chrDrW", "chrdstW", "chrDintW", "chrDstR", "chrDvW", "chrDstL", "chrDistW", "chrDistZ", "chrSblM", "chrDntL", "chrDrcR", "chrRSTZ", "chrDSTZ", "chrPstN", "chrdrcW", "chrDStH", "chrPrcM", "chrDestW", "chrDvT", "chrDsetR", "chrDblR", "chrDintM", "chrDvV", "chrDblW", "chrSndN", "chrDStZ", "chrDblM", "chrDestU", "chrDSTV", "chrPstW", "chrDSTW", "chrDistM", "chrSstV", "chrDndV", "chrRstL", "chrDStV", "chrDndU", "chrDstT", "chrDrcN", "chrRSTH", "chrDsetW", "chrRstZ", "chrDstU", "chrSstR", "chrSstU", "chrRSTN", "chrDstV", "chrDstN", "chrDintN", "chrRstN", "chrPstM", "chrDintH", "chrPstV", "chrDrN", "chrdstL", "chrDSTL", "chrRSTW", "chrDsetM", "chrDrH", "chrSstM", "chrSblR", "chrdrcV", "chrSndU", "chrdstT", "chrDrcW", "chrDndN", "chrDrcM", "chrDistN", "chrDestN", "chrSndW", "chrDrcL", "chrDstH", "chrDStW", "chrSstW", "chrDstZ", "chrDndW", "chrDstM", "chrRstW", "chrPrcW", "chrDrcU", "chrDintV", "chrRstV", "chrDntV", "chrDrL", "chrSblW", "chrdstV", "chrdrcT", "chrDistV", "chrDestV", "chrPrcN", "chrRSTV", "chrDSTN", "chrDrcT", "chrSstN", "chrDintL", "chrDntW"], "i": ["this", "ski", "m", "err", " I", " index", "I", "pa", "ti", "cli", "ui", " bi", "v", "point", "uri", "\u0438", "si", "me", "o", "ai", "ix", "ji", "x", " ii", "ind", "e", "gi", "info", " ti", "sim", "ami", "status", "fi", "oi", "at", "g", " j", " pi", "hi", "bi", "parent", "phi", "it", "ri", "xi", "f", "y", "multi", "zi", "ei", "qi", "ini", "ip", "li", "ia", "in", "ci", "mi", "ii", "ma", "slice", "pi", "l", "ij", " li", "print", "di", "index", "iu", " pos", "go", "init", "key", "id", " iter", "php", "ki", "j", "q"], "src": ["sys", "rc", "usr", "source", "sec", "desc", "rel", "loc", "st", "cur", "img", "sn", "ptr", "tmp", "iter", "sort", "trans", "sub", "sur", "inst", "sb", "ser", "comp", "dist", "ctr", "sl"], "dst": ["pst", "pddest", "dadest", "lest", "Dest", "daST", "hdest", "lend", "hport", "lST", "ddest", "pdST", "pdest", "pest", "pdst", "delST", "lst", "dend", "ldest", "hST", "psts", "pdend", "dST", "Dst", "dast", "daend", "delport", "dport", "lsts", "DST", "hst", "delst", "Dsts", "Dport", "Ddest", "deldest", "dsts"], "counter": ["time", "state", "pack", "list", "desc", "record", "table", "count", "loader", "code", "tr", "no", "names", "num", "ounter", "entry", "buffer", "cycle", "obj", "cache", "ctr", "codes", "pointer", "class", "syn"], "p": ["n", "perm", "t", "o", "ping", "f", "h", "m", "tp", "d", "pkg", "post", "ps", "pt", "pp", "pl", "lp", "wp", "cp", " P", "peer", "pa", "pers", "php", "jp", "imp", "j", "ap", "ip", "pid", "fp", "op", "P", "q", "dp", "pe", "at", "g", "sp", "pc", "np", "pos", "pi", "b", "bp", "l", "port", "pat", "point"]}}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n            env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        } else if (n < CPU_NB_REGS32) {\n\n            n = gpr_map32[n];\n\n            env->regs[n] &= ~0xffffffffUL;\n\n            env->regs[n] |= (uint32_t)ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        if (n < CPU_NB_REGS32 ||\n\n            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {\n\n            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n            return 16;\n\n        }\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n                env->eip = ldq_p(mem_buf);\n\n                return 8;\n\n            } else {\n\n                env->eip &= ~0xffffffffUL;\n\n                env->eip |= (uint32_t)ldl_p(mem_buf);\n\n                return 4;\n\n            }\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 20345, "substitutes": {"cs": ["is", "rc", "ck", "ks", "aps", "css", "ys", "cus", "ns", "ss", "ps", "bs", "sts", "Cs", "rs", "fs", "c", "ds", "s", "ec", "ctx", "ls", "CS", "caps", "vs", "hs", "sc", "js", "wcs", "ins", "ts", "tc", "acs", "cc", "cks", "cp"], "mem_buf": ["memmatbuffer", " mem_box", "memedfb", "mem_bar", " mem_buffer", " mem_uf", "memedbuf", "memmatfb", " mem_gen", " mem_buff", " mem_bed", "memorybuf", " mem_bar", " mem_db", " mem_fb", "mem2buffer", "mem_buffer", "mem2vec", " mem_cb", "mem_gen", "mem_box", "Mem_buf", "memfbuff", " mem_bu", "mem_cb", "mem_fb", "memorybuffer", "memorybed", "mem2cb", "memMembuf", "mem2bu", "Mem_buffer", "mem2uf", "mem_buff", "memfbuf", "memmatbuf", "memMemdb", "mem2buf", "memedbox", "memfbuffer", "mem_bu", "mem_vec", "memorygen", "mem_bed", "memfbu", "Mem_vec", "memmatbox", "memedbuffer", "memMembar", "mem_db", "mem2buff", "mem_uf"], "n": ["name", "fn", "p", "t", "en", "all", "gn", "rn", "number", "o", "cn", "index", "nr", "tn", "m", "ns", "root", "y", "dn", "nw", "nor", "d", "na", "none", "x", "note", "i", "conn", "nn", "on", "c", "ni", "size", "s", "N", "j", "no", "nb", "nu", "z", "ng", "sn", "nm", "names", "num", "un", "new", "g", "ren", "ln", "nt", "norm", "np", "after", "nl", "len", "ne", "next", "nc", "an", "mn", "port", "l", "v", "local", "nan", "net", "nil", "w"], "cpu": ["core", "ck", "kt", "cn", "process", "processor", "stat", "boot", "ack", "gc", "ct", "pkg", "bench", "pt", "conn", "cv", "node", "c", "ec", "arch", "proc", "hw", "setup", "ork", "pu", "aux", "ctx", "ex", "clock", "CP", "nic", "aco", "bean", "ka", "cf", "mem", "util", "pc", "tc", "CPU", "comp", "ca", "cp", "net"], "env": ["chart", "door", "eh", "et", "desc", "equ", "eni", "policy", "err", "neck", "gear", "vert", "eco", "worker", "uv", "event", "server", "oe", "email", "ew", "next", "client", "v", "ev", "engine", "der", "eb", "context", "te", "enc", "e", "esc", "exc", "environment", "vs", "entry", "dev", "runner", "era", "cmd", "Environment", "eng", "scope", "ef", "ner", "ei", "outer", "operator", "den", "ec", "hw", "buf", "ctx", "extra", "ve", "her", "config", " environment", "obj", "esi", "nc", "el", "hess", "attr", "er", "en", "end", "org", "window", "ext", "conn", "enter", "estate", "ent", "here", "manager", "console", "viron", "eu", "doc", "eq", "ah", "cfg", "eve"], "tmp": [" ptr", " ref", " dst", " ignored", " sp", " addr", " remainder", " np", " delta", " net", " ov", " leftover", " noise", " done", " ind", " stored", " junk", " resp", " lost", " input", " remaining", " missing", " misc", " allocated", " matched", " tcp", " err", " quot"]}}
{"project": "FFmpeg", "commit_id": "70b1dcef2d859ae6b3e21d61de928c3dd0cf1aa4", "target": 0, "func": "int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n\n                                     H264ParamSets *ps)\n\n{\n\n    AVBufferRef *sps_buf;\n\n    int profile_idc, level_idc, constraint_set_flags = 0;\n\n    unsigned int sps_id;\n\n    int i, log2_max_frame_num_minus4;\n\n    SPS *sps;\n\n\n\n    profile_idc           = get_bits(gb, 8);\n\n    constraint_set_flags |= get_bits1(gb) << 0;   // constraint_set0_flag\n\n    constraint_set_flags |= get_bits1(gb) << 1;   // constraint_set1_flag\n\n    constraint_set_flags |= get_bits1(gb) << 2;   // constraint_set2_flag\n\n    constraint_set_flags |= get_bits1(gb) << 3;   // constraint_set3_flag\n\n    constraint_set_flags |= get_bits1(gb) << 4;   // constraint_set4_flag\n\n    constraint_set_flags |= get_bits1(gb) << 5;   // constraint_set5_flag\n\n    skip_bits(gb, 2);                             // reserved_zero_2bits\n\n    level_idc = get_bits(gb, 8);\n\n    sps_id    = get_ue_golomb_31(gb);\n\n\n\n    if (sps_id >= MAX_SPS_COUNT) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sps_buf = av_buffer_allocz(sizeof(*sps));\n\n    if (!sps_buf)\n\n        return AVERROR(ENOMEM);\n\n    sps = (SPS*)sps_buf->data;\n\n\n\n    sps->sps_id               = sps_id;\n\n    sps->time_offset_length   = 24;\n\n    sps->profile_idc          = profile_idc;\n\n    sps->constraint_set_flags = constraint_set_flags;\n\n    sps->level_idc            = level_idc;\n\n\n\n    memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n\n    memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n\n    sps->scaling_matrix_present = 0;\n\n\n\n    if (sps->profile_idc == 100 ||  // High profile\n\n        sps->profile_idc == 110 ||  // High10 profile\n\n        sps->profile_idc == 122 ||  // High422 profile\n\n        sps->profile_idc == 244 ||  // High444 Predictive profile\n\n        sps->profile_idc ==  44 ||  // Cavlc444 profile\n\n        sps->profile_idc ==  83 ||  // Scalable Constrained High profile (SVC)\n\n        sps->profile_idc ==  86 ||  // Scalable High Intra profile (SVC)\n\n        sps->profile_idc == 118 ||  // Stereo High profile (MVC)\n\n        sps->profile_idc == 128 ||  // Multiview High profile (MVC)\n\n        sps->profile_idc == 138 ||  // Multiview Depth High profile (MVCD)\n\n        sps->profile_idc == 144) {  // old High444 profile\n\n        sps->chroma_format_idc = get_ue_golomb_31(gb);\n\n        if (sps->chroma_format_idc > 3) {\n\n            avpriv_request_sample(avctx, \"chroma_format_idc %u\",\n\n                                  sps->chroma_format_idc);\n\n            goto fail;\n\n        } else if (sps->chroma_format_idc == 3) {\n\n            sps->residual_color_transform_flag = get_bits1(gb);\n\n        }\n\n        sps->bit_depth_luma   = get_ue_golomb(gb) + 8;\n\n        sps->bit_depth_chroma = get_ue_golomb(gb) + 8;\n\n        if (sps->bit_depth_chroma != sps->bit_depth_luma) {\n\n            avpriv_request_sample(avctx,\n\n                                  \"Different chroma and luma bit depth\");\n\n            goto fail;\n\n        }\n\n        sps->transform_bypass = get_bits1(gb);\n\n        decode_scaling_matrices(gb, sps, NULL, 1,\n\n                                sps->scaling_matrix4, sps->scaling_matrix8);\n\n    } else {\n\n        sps->chroma_format_idc = 1;\n\n        sps->bit_depth_luma    = 8;\n\n        sps->bit_depth_chroma  = 8;\n\n    }\n\n\n\n    log2_max_frame_num_minus4 = get_ue_golomb(gb);\n\n    if (log2_max_frame_num_minus4 < MIN_LOG2_MAX_FRAME_NUM - 4 ||\n\n        log2_max_frame_num_minus4 > MAX_LOG2_MAX_FRAME_NUM - 4) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"log2_max_frame_num_minus4 out of range (0-12): %d\\n\",\n\n               log2_max_frame_num_minus4);\n\n        goto fail;\n\n    }\n\n    sps->log2_max_frame_num = log2_max_frame_num_minus4 + 4;\n\n\n\n    sps->poc_type = get_ue_golomb_31(gb);\n\n\n\n    if (sps->poc_type == 0) { // FIXME #define\n\n        sps->log2_max_poc_lsb = get_ue_golomb(gb) + 4;\n\n    } else if (sps->poc_type == 1) { // FIXME #define\n\n        sps->delta_pic_order_always_zero_flag = get_bits1(gb);\n\n        sps->offset_for_non_ref_pic           = get_se_golomb(gb);\n\n        sps->offset_for_top_to_bottom_field   = get_se_golomb(gb);\n\n        sps->poc_cycle_length                 = get_ue_golomb(gb);\n\n\n\n        if ((unsigned)sps->poc_cycle_length >=\n\n            FF_ARRAY_ELEMS(sps->offset_for_ref_frame)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"poc_cycle_length overflow %d\\n\", sps->poc_cycle_length);\n\n            goto fail;\n\n        }\n\n\n\n        for (i = 0; i < sps->poc_cycle_length; i++)\n\n            sps->offset_for_ref_frame[i] = get_se_golomb(gb);\n\n    } else if (sps->poc_type != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"illegal POC type %d\\n\", sps->poc_type);\n\n        goto fail;\n\n    }\n\n\n\n    sps->ref_frame_count = get_ue_golomb_31(gb);\n\n    if (sps->ref_frame_count > H264_MAX_PICTURE_COUNT - 2 ||\n\n        sps->ref_frame_count >= 32U) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"too many reference frames %d\\n\", sps->ref_frame_count);\n\n        goto fail;\n\n    }\n\n    sps->gaps_in_frame_num_allowed_flag = get_bits1(gb);\n\n    sps->mb_width                       = get_ue_golomb(gb) + 1;\n\n    sps->mb_height                      = get_ue_golomb(gb) + 1;\n\n    if ((unsigned)sps->mb_width  >= INT_MAX / 16 ||\n\n        (unsigned)sps->mb_height >= INT_MAX / 16 ||\n\n        av_image_check_size(16 * sps->mb_width,\n\n                            16 * sps->mb_height, 0, avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"mb_width/height overflow\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    sps->frame_mbs_only_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag)\n\n        sps->mb_aff = get_bits1(gb);\n\n    else\n\n        sps->mb_aff = 0;\n\n\n\n    sps->direct_8x8_inference_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag && !sps->direct_8x8_inference_flag) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n\n        goto fail;\n\n    }\n\n\n\n#ifndef ALLOW_INTERLACE\n\n    if (sps->mb_aff)\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MBAFF support not included; enable it at compile-time.\\n\");\n\n#endif\n\n    sps->crop = get_bits1(gb);\n\n    if (sps->crop) {\n\n        unsigned int crop_left   = get_ue_golomb(gb);\n\n        unsigned int crop_right  = get_ue_golomb(gb);\n\n        unsigned int crop_top    = get_ue_golomb(gb);\n\n        unsigned int crop_bottom = get_ue_golomb(gb);\n\n\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP) {\n\n            av_log(avctx, AV_LOG_DEBUG, \"discarding sps cropping, original \"\n\n                                           \"values are l:%d r:%d t:%d b:%d\\n\",\n\n                   crop_left, crop_right, crop_top, crop_bottom);\n\n\n\n            sps->crop_left   =\n\n            sps->crop_right  =\n\n            sps->crop_top    =\n\n            sps->crop_bottom = 0;\n\n        } else {\n\n            int vsub   = (sps->chroma_format_idc == 1) ? 1 : 0;\n\n            int hsub   = (sps->chroma_format_idc == 1 ||\n\n                          sps->chroma_format_idc == 2) ? 1 : 0;\n\n            int step_x = 1 << hsub;\n\n            int step_y = (2 - sps->frame_mbs_only_flag) << vsub;\n\n\n\n            if (crop_left & (0x1F >> (sps->bit_depth_luma > 8)) &&\n\n                !(avctx->flags & AV_CODEC_FLAG_UNALIGNED)) {\n\n                crop_left &= ~(0x1F >> (sps->bit_depth_luma > 8));\n\n                av_log(avctx, AV_LOG_WARNING,\n\n                       \"Reducing left cropping to %d \"\n\n                       \"chroma samples to preserve alignment.\\n\",\n\n                       crop_left);\n\n            }\n\n\n\n            if (INT_MAX / step_x             <= crop_left               ||\n\n                INT_MAX / step_x - crop_left <= crop_right              ||\n\n                16 * sps->mb_width <= step_x * (crop_left + crop_right) ||\n\n                INT_MAX / step_y             <= crop_top                ||\n\n                INT_MAX / step_y - crop_top  <= crop_bottom             ||\n\n                16 * sps->mb_height <= step_y * (crop_top + crop_bottom)) {\n\n                av_log(avctx, AV_LOG_WARNING, \"Invalid crop parameters\\n\");\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    goto fail;\n\n                crop_left = crop_right = crop_top = crop_bottom = 0;\n\n            }\n\n\n\n            sps->crop_left   = crop_left   * step_x;\n\n            sps->crop_right  = crop_right  * step_x;\n\n            sps->crop_top    = crop_top    * step_y;\n\n            sps->crop_bottom = crop_bottom * step_y;\n\n        }\n\n    } else {\n\n        sps->crop_left   =\n\n        sps->crop_right  =\n\n        sps->crop_top    =\n\n        sps->crop_bottom =\n\n        sps->crop        = 0;\n\n    }\n\n\n\n    sps->vui_parameters_present_flag = get_bits1(gb);\n\n    if (sps->vui_parameters_present_flag) {\n\n        int ret = decode_vui_parameters(gb, avctx, sps);\n\n        if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE)\n\n            goto fail;\n\n    }\n\n\n\n    /* if the maximum delay is not stored in the SPS, derive it based on the\n\n     * level */\n\n    if (!sps->bitstream_restriction_flag &&\n\n        (sps->ref_frame_count || avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT)) {\n\n        sps->num_reorder_frames = MAX_DELAYED_PIC_COUNT - 1;\n\n        for (i = 0; i < FF_ARRAY_ELEMS(level_max_dpb_mbs); i++) {\n\n            if (level_max_dpb_mbs[i][0] == sps->level_idc) {\n\n                sps->num_reorder_frames = FFMIN(level_max_dpb_mbs[i][1] / (sps->mb_width * sps->mb_height),\n\n                                                sps->num_reorder_frames);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!sps->sar.den)\n\n        sps->sar.den = 1;\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n\n        static const char csp[4][5] = { \"Gray\", \"420\", \"422\", \"444\" };\n\n        av_log(avctx, AV_LOG_DEBUG,\n\n               \"sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %\"PRId32\"/%\"PRId32\"\\n\",\n\n               sps_id, sps->profile_idc, sps->level_idc,\n\n               sps->poc_type,\n\n               sps->ref_frame_count,\n\n               sps->mb_width, sps->mb_height,\n\n               sps->frame_mbs_only_flag ? \"FRM\" : (sps->mb_aff ? \"MB-AFF\" : \"PIC-AFF\"),\n\n               sps->direct_8x8_inference_flag ? \"8B8\" : \"\",\n\n               sps->crop_left, sps->crop_right,\n\n               sps->crop_top, sps->crop_bottom,\n\n               sps->vui_parameters_present_flag ? \"VUI\" : \"\",\n\n               csp[sps->chroma_format_idc],\n\n               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,\n\n               sps->timing_info_present_flag ? sps->time_scale : 0);\n\n    }\n\n\n\n    /* check if this is a repeat of an already parsed SPS, then keep the\n\n     * original one.\n\n     * otherwise drop all PPSes that depend on it */\n\n    if (ps->sps_list[sps_id] &&\n\n        !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n\n        av_buffer_unref(&sps_buf);\n\n    } else {\n\n        remove_sps(ps, sps_id);\n\n        ps->sps_list[sps_id] = sps_buf;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&sps_buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 20352, "substitutes": {"gb": ["gt", "csv", "gif", "rb", "bits", "py", "bf", "tg", "cb", "bsp", "hub", "gm", "aaa", "gam", "gc", "gz", "gd", "mb", "bs", "rg", "uf", "bridge", "um", "eg", "vg", "cd", "gs", "bn", "vm", "gnu", "args", "xy", "bytes", "fb", "asm", "nb", "buf", "img", "ctx", "deg", "mg", "bg", "wb", "db", "storage", "gg", "g", "kb", "phy", "buff", "bt", "Gb", "pg", "pb", "GB", "sb", "gh", "cfg"], "avctx": ["verconn", " avcv", "cloudctx", "vrcv", " avconn", "aircv", "aircontext", "avcontext", "avcv", " avcfg", "cloudcontext", "vrcontext", "avtx", "cloudconn", "airtx", "airctx", "vrtx", "vercfg", "cloudcfg", "verctx", "avcfg", " avcontext", "vercontext", " avtx", "avconn", "vrctx"], "ps": ["Ps", "p", "pse", "aps", "PS", "pes", "ams", "amps", "ops", "pp", "eps", "bs", "mp", "cs", "fs", "gs", "rs", "ds", "pers", "pres", "ms", "ats", "ets", "ips", "pps", "ts", "params", "ups"], "sps_buf": ["sPS_uf", "spsckcb", "sPS_buff", "sps__data", "sPS_alloc", "spsckalloc", "sps_uf", "sps__buff", "sps2buf", "sps2uf", "smp_buf", "sps_cb", "sps__buf", "smp_uf", "sps2data", "sPS_buf", "sps2buff", "sps_alloc", "smp_buff", "sps__uf", "spsckbuf", "smp_cb", "sPS_cb", "sps_data", "sps_buff", "spsckuf", "smp_data"], "profile_idc": ["profile_idsx", "profile_indf", "profile_trypc", "profile_idsf", "profile_idl", "profile_idect", "profile_Idcut", "profile_idx", "profile_itpc", "profile_iconcor", "profileOactcut", "profile_idsl", "profile_indc", "profile_tryc", "profile_Idca", "profile_idsc", "profile_tryct", "profile_iconc", "profile_idct", "profile_indx", "profileOidl", "profile_idf", "profileOactcor", "profileOidc", "profile_itct", "profile_indl", "profile_Idx", "profile_idcor", "profileOidcut", "profile_Idcor", "profile_idpc", "profileOactl", "profile_Idl", "profileOidcor", "profileOactc", "profile_IDc", "profile_IDca", "profile_idca", "profile_Idc", "profile_actc", "profile_iconl", "profile_iconcut", "profile_itc", "profile_idC", "profile_itC", "profile_actcut", "profile_ideC", "profile_idepc", "profile_actcor", "profile_actl", "profile_tryC", "profile_idcut", "profile_idec", "profile_IDx"], "level_idc": ["level_uidC", "level_ridlc", "level_iconl", "level_vidco", "level_Idl", "level_vidc", "level_ridi", "level_Idlc", "level_mitci", "level_idco", "level_Idf", "level_vidci", "level_ridl", "level__oidci", "level_oidc", "level_idsc", "level_idsxc", "level_ridc", "level_oidce", "level_mitc", "level_idsC", "level__idce", "level_idi", "level_ridf", "level_idenC", "level_idenco", "level_idsl", "level_idl", "level_oidco", "level_idC", "level_uidc", "level_uidxc", "level_mitce", "level_iconc", "level_idce", "level_idf", "level_Idco", "level_uidco", "level_idci", "level_iconi", "level_idxc", "level_idsf", "level__oidco", "level_idlc", "level_idsco", "level_Idc", "level__idci", "level_oidci", "level__idc", "level_idenxc", "level_Idi", "level_mitco", "level_ridco", "level__idco", "level_iconlc", "level_idenc", "level__oidce", "level__oidc", "level_vidce"], "sps_id": ["sPS_ids", "samplesootlen", "sps_num", "sps_len", "sps_ref", "sps2id", "sps__id", "sps2info", "sps__ids", "samples_len", "sps_name", "sps2len", "samples_ident", "sps2no", "spsootname", "spse_id", "spsootident", "spsootid", "sps_rid", "sPS_rid", "sPS_num", "spse_it", "spse_ids", "samplesootname", "sps_info", "samples_name", "spsootlen", "sps_ident", "samples_id", "sps_ids", "sPS_name", "sPS_info", "samplesootident", "sPS_ID", "sPS_no", "samplesootid", "sPS_len", "sPS_id", "smp_ids", "sps_ID", "smp_id", "sps_it", "sps__it", "smp_ref", "sPS_vid", "sps_no", "sps_vid"], "i": ["bi", "n", "t", "phi", "p", "it", "si", "m", " l", " m", "x", " ii", " ti", "I", "ti", "j", "ip", "li", " bi", "ci", " j", " v", "mi", "ii", "pi", "l", "v", "b"], "log2_max_frame_num_minus4": ["log2_max_frame_num_minus2", "log2_max_frame_num_version4", "log2_max_frame_num_version8", "log2_max_frame_num_times2", "log2_max_frame_num_mod4", "log2_max_frame_num_mod8", "log2_max_frame_num_mod32", "log2_max_frame_num_times4", "log2_max_frame_num_minus8", "log2_max_frame_num_times32", "log2_max_frame_num_minus32", "log2_max_frame_num_version2", "log2_max_frame_num_mod2", "log2_max_frame_num_times8", "log2_max_frame_num_version32"], "sps": ["desps", "despers", "imsbs", "esPS", " sPS", "descs", "sepers", "lspt", "sts", "Sts", "sops", "expers", "jsaps", "isPS", " sts", " spers", "lsls", "iscs", "sebs", "gsts", "exeps", "espl", "nspp", "desits", "spt", "ascs", " sbs", "esports", "issts", "rsps", "gspers", " splays", "jsts", "Sports", "seps", "isaps", "rsaps", "desplaces", "ispl", "Spps", "desrs", " spl", "srs", "spp", "sPS", "seaps", "lseps", "aspps", "nsps", " scs", "ssts", "exls", "Sps", "SPS", "sls", " saps", "splaces", "ispers", "espps", "gsps", "gsPS", "spoints", "lsps", " saves", "lsPS", "sits", "desPS", "aspoints", "splays", "iseps", "seops", " sops", "despl", "spers", "exps", " spt", "asPS", "rseps", "dessts", "spps", "dests", " spp", "asps", "ists", "espt", "jsps", "sept", "esps", "rspps", "saps", "isrs", "sbs", "spl", "lspl", "asaves", "sports", "nsplays", "Spers", "seeps", " sports", " spoints", "imsops", "isits", " splaces", "imsps", "rscs", "imspt", " spps", "rspers", "Spt", "jspers", "scs", "rsPS", "lspers", "saves", "isps", "isplaces", "nspt"]}}
{"project": "qemu", "commit_id": "424ad8388f89f4202a7836d003273f23ebe04b09", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t oldval, newval;\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 20365, "substitutes": {"opaque": ["OPatile", " opaques", "popatile", "iopaque", " opque", "iopatile", "OPaque", "OPacity", "iopaques", "OPaques", " opacity", "Opaque", "OPque", "iopque", "Opacity", "opacity", "popque", "opaques", "Opaques", "popaque", "Opque", "opque", "popaques", "opatile"], "addr": ["name", " address", "rc", "tag", "rev", "et", "r", "index", "arp", "ack", "ref", "arity", "ix", "hash", "add", "offset", "rol", "order", "act", "err", "inv", "ash", "src", "url", "loc", "hop", "id", "eth", "rs", "tx", "host", "cmp", "ip", "hw", "ord", "ctx", "ptr", "align", "res", "Address", "adr", "dr", "ad", "at", "address", "cmd", "pos", "work", "len", "pad", "v"], "val": ["all", "ret", "vol", "value", " value", "err", "rel", "eval", "pt", "loc", "xy", "res", "alt", "rot", " v", "util", "zero", "pos", "elt", "v", "local", "sl", "sel", "stat", " eval", "aval", "bl", "x", "info", "data", "fail", "Val", "pol", "base", "pal", "pr", "values", "num", "dev", "cal", "bin", "update", " arg", "it", "ref", "imm", "arg", "def", "tx", "bit", "var", "buf", "ctx", "conf", "obj", "len", "sol", "l", "el", "attr", "vt", "serv", "valid", "ival", "index", "al", "item", "key", "arr", "test", "grad", "VAL", "vals", "unit", "reg", "block", "lib"], "size": ["n", "name", "cap", "sum", "length", "SIZE", "scale", "offset", "count", "id", "args", "dim", "c", "z", "ize", "num", "unit", "mem", "Size", "sp", "len", "l", "v", "ffff", "type"], "s": ["n", "comm", "p", "ports", "is", "sys", "os", "set", "parts", "ows", "changes", "ss", "ns", "ims", "ses", "stats", "ps", "bs", "sts", "rs", "fs", "gs", "aws", "c", "ds", "sis", "bis", "ls", "details", "ms", "ssl", "sv", "sw", "ats", "vs", "hs", "views", "ies", "S", "js", "es", "ins", "sq", "ts", "its", "als", "ads", "ants", "qs", "less", "acs", "sb", "ains", "as", "sl", "series"], "oldval": ["olderVAL", "Oldeval", "holdervol", "Oldval", "oldvol", "OldVAL", "newVal", " newVAL", "oldeval", " oldVal", "olderval", " oldvol", "olderVal", "holderval", " neweval", "OldVal", "oldvalue", " oldvalue", "holdervalue", "holderVAL", "newvalue", " oldeval", "oldervalue", "oldVAL", "oldervol", " oldVAL", "oldVal", " newVal"], "newval": ["ewvalue", " newcho", "ewel", "nexteval", "newVal", "enval", "oldeval", "ewpol", " newitem", "newel", "NEWlev", "newseval", "newsfail", "newspol", "createvalue", "NEWval", "newsvalue", "newvalue", "ewfail", "normalval", "createlev", " newbal", "oldVal", "newsarr", "newfail", "ewarr", "genvals", "nextitem", "NEWeval", "newlev", "ewval", "NEWVAL", "NEWvalue", "nextpol", " newvalid", "mainVAL", "newsvol", "createbal", "mainval", "newVAL", " newvol", "normaleval", "ewvol", "nextVal", "NEWel", "nextvol", "newvals", "nextvals", "nextlev", "newsvals", "NEWvalid", "createvalid", "nextvalue", "oldvalid", " newVAL", "newsval", "mainVal", "nextarr", "createVal", "normalVal", "NEWVal", " neweval", "envalue", "newslev", "neweval", "newsVal", "nextfail", "oldvalue", "nextvalid", "nextVAL", "maineval", "newcho", "newscho", "oldfail", "oldVAL", " newVal", "ewitem", "newbal", "createVAL", " newvalue", " newel", "oldbal", "eneval", "createval", "genvol", "ewVal", "genval", "newitem", "newpol", "newarr", "enVAL", "newvol", "normalcho", "nextval", "newvalid", " newfail", "genlev"], "i": ["bi", "name", "ij", "n", "phi", "p", "is", "ic", "it", "a", "ri", "si", "me", "index", "di", "iu", "ai", "io", "xi", "ix", "m", "y", "ims", "ji", "multi", "im", "zi", "key", "ei", "ie", "iy", "x", "sim", "ind", "e", "gi", "info", "I", "c", "ami", "qi", "ini", "j", "cli", "ti", "asi", "li", "ia", "ui", "ex", "gu", "oi", "in", "ci", "mi", "u", "ii", "pi", "hi", "l", "uri"], "cpu": ["core", "sys", "proxy", "gpu", "ck", "ilo", "cat", "processor", "process", "css", "stat", "pixel", "boot", "device", "us", "thread", "gc", "prof", "bus", "current", "physical", "cu", "cum", "dt", "vm", "c", "php", "node", "cmp", "disk", "proc", "nu", "mac", "hw", "ip", "pu", "ctx", "hz", "hard", "clock", "chip", "nic", "aco", "nice", "bean", "sc", "mem", "mx", "pc", "np", "cam", "uu", "cache", "CPU", "linux", "comp", "phys", "cp", "ram"], "cs": ["sys", "ics", "ks", "icks", "css", "ys", "ix", "cus", "ns", "ss", "acts", "stats", "ps", "ars", "sts", "cu", "fs", "rs", "c", "ds", "ctx", "ls", "checks", "CS", "vs", "ats", "ces", "hs", "sc", "cf", "js", "wcs", "ins", "ts", "pc", "acs", "qs", "cc", "cks", "cp", "cas", "cons"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset,\n\n        uint64_t val, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (reg_n > 1) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n        hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                TARGET_FMT_plx \"offset\\n\", offset);\n\n    }\n\n    s->reg_set[offset >> 2] = val;\n\n\n\n    switch (reg_n) {\n\n    /* IIESR */\n\n    case 0:\n\n        /* FIXME: what if irq is pending, allowed by mask, and we allow it\n\n         * again. Interrupt will rise again! */\n\n\n\n        DPRINTF(\"%s enable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Enable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask |= val & 0xFF;\n\n        s->group[grp_quad_base_n + 1].src_mask |= (val & 0xFF00) >> 8;\n\n        s->group[grp_quad_base_n + 2].src_mask |= (val & 0xFF0000) >> 16;\n\n        s->group[grp_quad_base_n + 3].src_mask |= (val & 0xFF000000) >> 24;\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n        /* IIECR */\n\n    case 1:\n\n        DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Disable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask &= ~(val & 0xFF);\n\n        s->group[grp_quad_base_n + 1].src_mask &= ~((val & 0xFF00) >> 8);\n\n        s->group[grp_quad_base_n + 2].src_mask &= ~((val & 0xFF0000) >> 16);\n\n        s->group[grp_quad_base_n + 3].src_mask &= ~((val & 0xFF000000) >> 24);\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n    default:\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n", "idx": 20368, "substitutes": {"opaque": [" opaques", "Opoid", "parentlay", "opoid", "parentacity", " opoid", "compoid", "Opca", "compaques", " opacity", "Opaque", "opca", " opca", "Opacity", "opacity", "compute", "compaque", "opaques", "parentaque", " opute", "Opaques", " oplay", "parentca", "Opute", "Oplay", "oplay", "opute"], "offset": ["parent", "t", "reference", "start", "o", "amount", "Offset", "index", "set", "ref", "output", "off", "length", "value", "onto", "attribute", "window", "sync", "table", "key", "tz", "inter", "loc", "style", "trace", "timeout", "row", "slot", "data", "peer", "reset", "handle", "batch", "base", "mt", "shift", "op", "height", "ptr", "align", "kernel", "position", "kh", "seek", "frequency", "entry", "buffer", "location", "addr", "ta", "scroll", "usage", "error", "prefix", "range", "sector", "block", "address", "offer", "pos", "slice", "pointer", "pad", "origin", "point", "padding", "alias"], "val": ["valid", "p", "all", "msg", "sel", "ival", "it", "ret", "ver", "func", "vol", "ref", "f", "aval", "sum", "value", " value", "err", "hash", "al", "bl", "rol", "ay", "eval", "fee", "item", "ul", "inter", "pt", "x", "empty", "tx", "Value", "data", "var", "xy", "bit", "vec", "Val", "test", "slot", "pol", "base", "buf", "ctx", "res", "alt", "VAL", "vals", "reg", "unit", "dev", "rot", "util", "zero", "block", "conf", "bin", "pos", "cal", "elt", "b", "sol", "v", "local", "lib", "vt"], "size": ["n", "name", " length", "start", "message", "set", "index", "off", "h", "length", "SIZE", "fee", "count", "e", "weight", "bytes", "z", "shift", "ize", "num", "mem", "Size", "sp", "len", "l", "type"], "s": ["n", "comm", "t", "p", "sys", "is", "ports", "bits", "settings", "o", "os", "r", "h", "m", "ns", "ss", "y", "ims", "changes", "ses", "stats", "ands", "bs", "ps", "ops", "cs", "sts", "socket", "rs", "gs", "fs", "space", "c", "i", "ds", "sis", "bis", "se", "south", "spec", "ls", "details", "ers", "ms", "ssl", "sv", "ats", "vs", "hs", "ies", "S", "js", "g", "es", "its", "sq", "ts", "sp", "als", "ins", "gets", "conf", "qs", "less", "sb", "b", "sl", "w"], "req_quad_base_n": ["req_quad_based_cn", "req_quad_basejn", "req_quad_based_n", "req_quad_base_b", "req_quad_basexN", "req_quad_basexnumber", "req_quad_based_N", "req_quad_basexn", "req_quad_basejp", "req_quad_base32n", "req_quad_base_p", "req_quad_base_ns", "req_quad_Base_n", "req_quad_base2n", "req_quad_base2b", "req_quad_bas_N", "req_quad_base_N", "req_quad_base_v", "req_quad_base32v", "req_quad_bas2l", "req_quad_Base2b", "req_quad_basejcn", "req_quad_base32b", "req_quad_Base2v", "req_quad_base_cn", "req_quad_basejN", "req_quad_Base_number", "req_quad_bas2N", "req_quad_bas_l", "req_quad_base_number", "req_quad_base2v", "req_quad_Base_v", "req_quad_Base_b", "req_quad_Base_ns", "req_quad_Base2n", "req_quad_Base_N", "req_quad_bas2n", "req_quad_base2l", "req_quad_basexns", "req_quad_base2N", "req_quad_bas_n", "req_quad_based_p", "req_quad_base_l"], "grp_quad_base_n": ["grp_quad_base_c", "grp_quad_basepton", "grp_quad_base_on", "grp_quad_baseptn", "grp_quad_Base_N", "grp_quad_Base_x", "grp_quad_base2l", "grp_quad_base1n", "grp_quad_base2name", "grp_quad_basetN", "grp_quad_base2r", "grp_quad_base_p", "grp_quad_basetnt", "grp_quad_base_nt", "grp_quad_base_name", "grp_quad_base2nt", "grp_quad_base_ns", "grp_quad_baseptN", "grp_quad_base2N", "grp_quad_basetn", "grp_quad_base_x", "grp_quad_Base_c", "grp_quad_base_N", "grp_quad_base2n", "grp_quad_baseptx", "grp_quad_Base_l", "grp_quad_base1N", "grp_quad_base1l", "grp_quad_Base_n", "grp_quad_base_r", "grp_quad_Base_name", "grp_quad_Base_r", "grp_quad_base_l"], "reg_n": ["arg_n", "regMn", "arg_ne", "reg_p", "eng_c", "arg_nb", "regxnb", " reg_p", "reg_c", "reg_ne", "regxn", "eng_1", "reg_N", "REG_dn", "reg_k", " reg_name", "regMnb", "REG_c", "reg_dn", "regxne", "regMne", "REG_n", "reg_nb", "reg_name", "reg_l", "eng_n", "eng_N", "regMl", "arg_l", "reg_1", "regxl", "REG_k"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_submit_acl(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t handle;\n\n    int datalen, flags;\n\n    struct bt_link_s *link;\n\n\n\n    if (length < HCI_ACL_HDR_SIZE) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        return;\n\n    }\n\n\n\n    handle = acl_handle((data[1] << 8) | data[0]);\n\n    flags = acl_flags((data[1] << 8) | data[0]);\n\n    datalen = (data[3] << 8) | data[2];\n\n    data += HCI_ACL_HDR_SIZE;\n\n    length -= HCI_ACL_HDR_SIZE;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid ACL handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        /* TODO: signal an error */\n\n        return;\n\n    }\n\n    handle &= ~HCI_HANDLE_OFFSET;\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    link = hci->lm.handle[handle].link;\n\n\n\n    if ((flags & ~3) == ACL_ACTIVE_BCAST) {\n\n        if (!hci->asb_handle)\n\n            hci->asb_handle = handle;\n\n        else if (handle != hci->asb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    if ((flags & ~3) == ACL_PICO_BCAST) {\n\n        if (!hci->psb_handle)\n\n            hci->psb_handle = handle;\n\n        else if (handle != hci->psb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS */\n\n    bt_hci_event_num_comp_pkts(hci, handle | HCI_HANDLE_OFFSET, 1);\n\n\n\n    /* Do this last as it can trigger further events even in this HCI */\n\n    hci->lm.handle[handle].lmp_acl_data(link, data,\n\n                    (flags & 3) == ACL_START, length);\n\n}\n", "idx": 20370, "substitutes": {"info": ["isu", "history", "Info", "is", "basic", "frame", "o", "kind", "os", "index", "force", "stat", "INFO", "f", "check", "nr", "fo", "init", "by", "id", "def", "i", "bit", "meta", "good", " inf", "status", "base", "now", "fi", "inf", "auth", "report", "http", "error", "from", "conf", "information", "json", "about", "type"], "data": ["duration", "first", "message", "value", "multiple", "format", "ops", "none", "timeout", "batch", "no", "map", "Data", "command", "params", "zero", "next", "padding", "chain", "name", "done", "response", "a", "o", "list", "device", "ns", "bus", "empty", "join", "partial", "size", "bytes", "dat", "entry", "new", "load", "missing", "hash", "aw", "table", "d", "image", "def", "weight", "mu", "str", "tx", "buf", "height", "extra", "raw", "buffer", "ad", "cache", "len", "to", "actions", "sha", "share", "valid", "p", "out", "window", "offset", "read", "ata", "id", "test", "content", "DATA", "error", "block", "address", " DATA", "text"], "length": ["duration", "n", "valid", "loop", "t", "load", "end", "p", "available", "time", "message", "capacity", "missing", "L", "number", "H", "minimum", "h", "value", "offset", "present", "phi", "th", "tail", "count", "ength", "total", "empty", "size", "limit", "idth", "expected", "family", "height", "ptr", "full", "position", "padding", "maximum", "buffer", "shape", "sequence", "error", "path", "zero", "address", "be", "len", "ENGTH", "pad", "l", "Length", "ish", "angle", "type"], "hci": ["hsee", "hlci", "lmi", "ohcli", "hmi", "httpcci", "ehCI", "hli", " hcos", "Hcci", "hooksee", " hcin", "ohdi", "ehoci", "thcci", "lci", "wli", "thci", "httpco", "httpli", "hCI", "ehcci", " hii", "hlcli", "hri", " hco", "hercos", "rmi", "hcos", "hecirc", "httpdi", "hecm", "lco", "heci", "ehii", "hoci", "cco", "hlic", " hcirc", "ohci", "shci", "cci", "shcci", "hecci", "ihri", "shCI", " hlic", "rci", "ehci", " hcci", "thoci", "hloci", "hcm", "ihdi", "hcin", "httplic", "ohoci", "rco", "cdi", "hcirc", "shoci", "hco", "heri", "ccin", "hookcos", " hCI", "hookcci", "wcci", "hercci", "wci", "ihcm", "ehdi", "hcci", "ehcin", "Hci", "hedi", "httpcirc", "thco", "hlcci", "lcci", "loci", "heco", "rcci", "httpci", "hecu", " hmi", "herci", "hcu", "Hcu", " hsee", "hii", " hli", "ehco", "ohcci", "ohri", " hdi", "Hoci", "hcli", "Hco", " hoci", "wlic", " hcu", "ohcm", "lcli", "Hii", "hersee", "hookci", "hdi", "ihci"], "handle": ["oid", "process", "transfer", "tool", "then", "delay", "policy", "release", "value", "driver", "count", "filename", "mask", "target", "forward", "close", "node", "hide", "host", "folder", "hand", "bh", "server", "ssl", "map", "path", "command", "port", "anch", "trigger", "angle", "chain", "type", "loop", "state", "context", "device", "ha", "note", "size", "connection", "status", "wrap", "bind", "dev", "has", "cmd", "handler", "header", "scope", "handled", "memory", "wrapper", "hash", "label", "mount", "ctx", "ptr", "buffer", "shape", "try", "match", "range", "cache", "store", "metadata", "line", "route", "alias", "share", "old", "index", "set", "check", "h", "offset", "domain", "key", "id", "bridge", "code", "le", "lock", "queue", "draw", "addr", "help", "ignore", "tree", "address", "hold", "Handle", "flag"], "datalen": [" dallis", " dallen", "datotalener", "damelength", "dotalength", "damelener", "datatalen", "datalener", " dipalen", "Dalens", "damelen", "datalength", "Datalength", "Dalength", "datallen", "datalens", " dipalength", " datalize", " dipalens", "datotalength", "dallength", "damelens", " dallens", " datalis", "dipalens", "Datallen", "datatalength", "dallis", " dallength", "Datalen", "dblens", "dalllen", "datotalens", "dalen", "dblength", "dblen", "datalize", "dipalize", "datatalener", "datotalen", "dotalener", "datalis", " datalens", "dallize", "dotalen", " dipalize", "Dallen", "dipalength", "dalener", "dalength", "Datalens", "dalis", "dalize", "dalens", "dallen", "datatalens", "dallens", "dipalen", " datalength", "dotalens", "dbllen", "Dalen", "damelis"], "flags": ["hands", " Flags", "ports", "helps", "links", "bits", "heads", "settings", "aps", "kind", "weights", "hips", "packages", "tags", "bugs", "acts", "stats", "allows", "mask", "weight", "times", "fs", "args", "locks", "faces", "relations", "points", "details", "checks", "atts", "utils", "lines", "tools", "vals", "types", "levels", "reports", "properties", "pins", "facts", "posts", "Flags", "cmd", "features", "ags", "options", "actions", "flag", "magic", "lag", "friendly", "fields"], "link": ["share", "loop", "parent", "load", "way", "links", "pack", "slave", "hip", "Link", "delay", "index", "tool", "ping", "alias", "check", "device", "member", "offset", "head", "relation", "tail", "url", "loc", "label", "lp", "lan", "ld", "id", "target", "le", "local", "lo", "connection", "pid", "linked", "base", "lock", "like", "li", "bind", "handler", "ble", "sh", "addr", "ln", "match", "sp", "path", "address", "nl", "store", "light", "port", "line", "l", "route", "ink", "chain", "type"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_flush(&s->client);\n\n}\n", "idx": 20398, "substitutes": {"bs": ["lbs", "bits", "ubs", "ns", "bps", "ss", "BS", "aos", "ims", "abus", "iss", "cs", "bc", "fs", "aws", "gs", "ds", "bis", "bh", "ats", "bing", "hs", "vs", "asis", "bes", "js", "its", "ts", "als", "obs", "pb", "acs", "fps", "sb", "bos", "cks"], "s": ["sys", "is", "a", "os", " ss", "ns", "ss", "ims", "ses", "ps", "cs", "sts", "aws", "rs", "gs", "ds", "sis", "j", "ls", "sam", "ats", "hs", "self", "S", "js", "its", "sq", "ts", "ares", "als", "less", "sb", "b", "as", "v"]}}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 20410, "substitutes": {"qiov": ["qrolet", "qqiev", "aydrm", "queryconv", "dqnov", "dqliv", "qqiour", "querynov", "qnov", "Qiov", "Qovi", "quiov", "qconv", "dqconv", "Qdrm", " qrolet", " qiev", " qdrm", "qurolet", " qliv", " qnov", "qdrm", " qiour", "queryiov", "ayrolet", "qiour", "quiour", "quiev", "ayiov", "ayovi", "qiev", " qovi", "queryliv", "qqrolet", "dqiov", "qovi", "Qrolet", " qconv", "qqiov", "qliv"], "i": ["m", "ims", " I", "im", " index", "span", "I", "ti", "ui", " err", "point", "uri", "uli", "n", "\u0438", " si", "si", "me", "ai", "ix", " m", "x", " ii", "ind", "sim", " ti", "ami", "fi", " ni", "oi", "g", " missing", " pi", "u", "bi", "t", "phi", "it", "ri", "xi", "f", "y", "multi", " my", "zi", "mu", "s", "qi", "ini", "ip", "li", "in", "ci", " key", "mi", "ii", " mi", "pi", "yi", "ij", "p", " li", "print", "di", "index", "iu", "go", " all", "init", "key", "id", " iter", "ki", "j", "q", "gu", " wi", " multi"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20422, "substitutes": {"avctx": [" avjp", "aptx", "wavctx", "vrctx", " avgc", "averiac", "wavcv", "camctx", " avconn", "aftx", "afgc", "avcontext", "vrpkg", "avcv", "avjp", "camsc", "avecv", "vrcontext", "afpkg", " avpkg", "avtx", "aversc", "apctx", "aviac", "averjac", "avgc", "avctl", "apcontext", "averctx", "aveconn", "avetx", "avecontext", "avejac", "avjac", "avsc", "afcontext", "afcv", "apctl", "wavctl", "avesc", "avpkg", "afctx", "wavcontext", "aveiac", "wavjp", "avectx", "camjac", "wavconn", " avctl", " avcontext", "avconn", "avejp", " avtx", "wavtx", "vrgc", "camiac"], "data": ["name", "done", "resp", "t", "p", "load", "final", "message", "frame", "ref", "f", "type", "m", "window", "length", "value", "read", "d", "ata", "val", "image", "package", "id", "def", "empty", "mu", "str", "meta", "size", "bytes", "batch", "content", "family", "result", "extra", "DATA", "video", "dat", "buffer", "area", "error", "Data", "block", "bin", "cache", " DATA", "pos", "input", "next", "to", "pad", "feed", "text"], "data_size": [" data_len", " data_SIZE", " data_Size", " data_length", "data_length", " data_shape", "data_len", "data_Size", "data_shape", "data_SIZE"], "avpkt": ["avpkat", "avpmt", "avwpqt", " avpmt", "avpdu", " avPkt", "avenpgt", "avnpacket", " avpacket", "avepdu", "avppkt", "avepkg", "avpqt", "avpbmt", "avwpkt", "avewpdu", "avpacket", "avenpkt", "avppqt", "avepacket", "avppct", "avpbacket", "avnpkg", "avepgt", "avewpqt", " avPacket", "avpodacket", "avcpacket", "avwpkat", "avewpkt", "avppdu", "avepct", "avpkg", "avpodgt", "avcpkt", "avPct", "avpodkg", "avpct", "avenpacket", "avPacket", "avwpacket", "avwpct", "avwpdu", "avPqt", "avpbkt", " avPkat", "avenpkg", "avepkt", "avpbkat", " avpkat", "avpodkt", "avewpct", "avPkat", "avwpmt", "avPmt", "avnpgt", "avPdu", "avpgt", "avcpgt", "avPkt", " avPmt", "avepqt", "avnpkt", "avcpkg"], "buf": ["orig", "p", "cap", "rb", "cb", "ref", "read", "pkg", "Buff", "bs", "capt", "loc", "uf", "bc", "Buffer", "cv", "bytes", "vec", "batch", "lim", "img", "ctx", "raw", "br", "bh", "dat", "queue", "tmp", "map", "db", "buffer", "box", "iter", "mem", "buff", "np", "cmd", "bin", "len", "b"], "seq": ["pse", "msg", "prot", "sel", "iq", "frame", "sec", "list", "desc", "ref", "session", "exec", "sync", "eval", "pkg", "val", "mp", "sim", "ez", "ctrl", "cv", "tx", "test", "tab", "cl", "ec", "vec", "batch", "jp", "proc", "clus", "cur", "qa", "ng", "ctx", "spec", "q", "queue", "num", "feat", "sc", "ess", "iter", "sequ", "sequence", "mem", "sq", "nt", "sub", "job", "eq", "pause", "req", "cmd", "prev", "obj", "crit", "gen", "next", "comp", "flow", "ctr", "chain", "serv"]}}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static ssize_t imx_fec_receive(NetClientState *nc, const uint8_t *buf,\n\n                               size_t len)\n\n{\n\n    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));\n\n    IMXFECBufDesc bd;\n\n    uint32_t flags = 0;\n\n    uint32_t addr;\n\n    uint32_t crc;\n\n    uint32_t buf_addr;\n\n    uint8_t *crc_ptr;\n\n    unsigned int buf_len;\n\n    size_t size = len;\n\n\n\n    FEC_PRINTF(\"len %d\\n\", (int)size);\n\n\n\n    if (!s->regs[ENET_RDAR]) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Unexpected packet\\n\",\n\n                      TYPE_IMX_FEC, __func__);\n\n        return 0;\n\n    }\n\n\n\n    /* 4 bytes for the CRC.  */\n\n    size += 4;\n\n    crc = cpu_to_be32(crc32(~0, buf, size));\n\n    crc_ptr = (uint8_t *) &crc;\n\n\n\n    /* Huge frames are truncated.  */\n\n    if (size > ENET_MAX_FRAME_SIZE) {\n\n        size = ENET_MAX_FRAME_SIZE;\n\n        flags |= ENET_BD_TR | ENET_BD_LG;\n\n    }\n\n\n\n    /* Frames larger than the user limit just set error flags.  */\n\n    if (size > (s->regs[ENET_RCR] >> 16)) {\n\n        flags |= ENET_BD_LG;\n\n    }\n\n\n\n    addr = s->rx_descriptor;\n\n    while (size > 0) {\n\n        imx_fec_read_bd(&bd, addr);\n\n        if ((bd.flags & ENET_BD_E) == 0) {\n\n            /* No descriptors available.  Bail out.  */\n\n            /*\n\n             * FIXME: This is wrong. We should probably either\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n        } else {\n\n            s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n        }\n\n        imx_fec_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n", "idx": 20425, "substitutes": {"nc": ["n", "ics", "rn", "cn", "nr", "dc", "ns", "gc", "ct", "nw", "nz", "cs", "bc", "nn", "conn", "cv", "c", "ec", "nd", "sn", "NC", "nic", "sc", "nt", "anc", "mc", "pc", "np", "tc", "nl", "nec", "ne", "nv", "cc", "net", "xc"], "buf": ["p", "rb", "cap", "msg", "rc", "txt", "bf", "cb", "ref", "read", "bl", "Buff", "uf", "bc", "Buffer", "cv", "data", "fb", "bytes", "vec", "batch", "img", "raw", "br", "queue", "tmp", "seq", "wb", "buffer", "box", "mem", "buff", "block", "pb", "BU", "cmd", "bin", "b", "v", "text"], "len": ["n", "fun", "en", "t", "all", "start", "Len", "h", "length", "SIZE", "count", "ld", "code", "str", "data", "size", "bytes", "cmp", "body", "z", "ptr", "ize", "num", "mem", "Size", "ln", "sp", "pos", "nl", "l", "type"], "s": ["n", "comm", "t", "p", "sys", "is", "sa", "set", "sec", "ns", "ss", "ses", "stats", "iss", "bs", "ps", "cs", "sts", "sports", "fs", "rs", "gs", "aws", "c", "i", "ds", "sis", "se", "sn", "spec", "ls", "sam", "ssl", "sv", "sw", "ats", "hs", "S", "js", "g", "sq", "ts", "sp", "sg", "conf", "qs", "less", "store", "sb", "an", "so"], "bd": ["ed", "vd", "rb", "bf", "cb", "dd", "led", "dis", "bl", "disc", "gb", "ob", "sd", "d", "bs", "mb", "lay", "ld", "bc", "bar", "dt", "cd", "ds", "md", "hd", " BD", "nb", " bl", "bo", "br", "bh", "bind", "edd", "bg", " b", "db", "box", "od", "ocked", "ad", "kb", "js", "ded", "fd", "BT", "pb", "bt", "buff", "BD", "sb", "pd", "b", "pad", "da", "ba", "bb"], "addr": ["n", "name", "er", "msg", "rc", "a", "r", "arp", "ref", "ix", "offset", "hash", "debug", "add", "act", "dir", "src", "url", "loc", "x", "id", "arr", "i", "rs", "args", "data", "tx", "size", "host", "handle", "ip", "coord", "ord", "ctx", "ptr", "align", "ag", "rt", "alt", "adr", "Address", "mem", "dr", "at", "ad", "np", "address", "cmd", "obj", "pos", "store", "nl", "port", "pad", "v", "attr", "alias"], "crc": ["acce", "acron", "acrc", "rcred", "Cred", " cce", "cred", "acrs", "gcRC", "pcrc", "lcrc", "pcrs", " cRC", "accr", "ccr", "rcrc", "pcRC", "rcron", "acRC", "lcred", "cron", "cRC", "gccr", "Crs", "CRC", "Cron", "lcron", "gcce", "cce", "Cck", "pcron", "rcck", " ccr", "gcrc", "lcck", "crs", "cck", "Crc"], "buf_addr": ["bufxoffset", " buf_address", "buf__ref", "buf_address", "br_dir", "uf_len", "bufxlen", "uf_ref", " buf_ref", "br_offset", "uf_ptr", "buf_offset", "buf__addr", "buf_ptr", "bufxdir", "buf_ref", " buf_ptr", "bufxaddr", "buf_dir", "buf__ptr", "buf__len", "br_len", "uf_addr", "br_addr"], "crc_ptr": ["cron2obj", "cRC_val", "cron_obj", "crc2ref", "cron_ptr", "cron2ptr", "crc_val", "crc_obj", "crc_inter", "crc2ptr", "cron2inter", "cRC_rel", "crc_ref", "crc_rel", "crc2inter", "cron2ref", "crc2obj", "cRC_ptr", "cron_ref", "cron_inter", "cRC_addr", "crc_addr"], "buf_len": ["buf6len", "buf_lang", "buf_pos", "buf6pos", "buffer_len", "ctxityelt", "bufjaddr", "buf_ptr", " buf2ref", "ctxitylen", "buf_elt", " buf2length", "queue_len", "bufjl", " buf_fin", "buf_lan", " buf_el", " buf_length", "ctx_lang", "buffer_ptr", "bufitylength", "ctx_elt", "buf_l", "ctx_len", "buffer_length", "queue_l", "buf6ptr", "buff5len", "ctx_length", "buf_el", "buff_len", "buf_length", "buf6length", "buf_fin", "buf2fin", " buf_offset", "buff_en", "ctxitylang", "buf_offset", "buf2len", "buf5elt", "buff_elt", "buf2pos", " buf2len", "buff5elt", "bufitylang", "buff5lan", "buf2ref", "buf5en", "buf2ptr", "ctxitylength", "queue_addr", "buffer_pos", "buf_en", "buf2length", "buff_lan", " buf_ref", "buff5en", "buf2addr", "buf_ref", "bufityelt", "buf5lan", "buf2l", " buf2fin", "bufjlen", "buf5len", "bufitylen"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n", "idx": 20433, "substitutes": {"env": ["ee", "esm", "eh", "app", "desc", "dn", "gear", "eg", "vm", "peer", "cur", "worker", "uv", "ov", "server", "sv", "ew", "v", "ev", "eas", "engine", "context", "enc", "e", "esc", "export", "exc", "environment", "vs", "entry", "self", "dev", "erd", "esp", "era", "cmd", "Environment", "external", "eng", "timer", "network", "net", "exec", "act", "nw", "cv", "outer", "ec", "proc", "buf", "ctx", "ve", "buffer", "em", "np", "obj", "shell", "vp", "serv", "vt", "er", "en", "end", "txt", "org", "usr", "window", "init", "editor", "etc", "inv", "code", "conn", "ext", "enter", "ent", "here", "manager", "queue", "console", "viron", "doc", "ah", "nv", "gov"], "bp": ["bi", "mk", "p", "lbs", "vp", "btn", "eb", "vc", "bf", "cb", "bsp", "BP", "tp", "bps", "gb", "pkg", "bs", "mb", "lb", "lp", "yk", "prof", "wp", "bc", "ipp", "bn", "bd", "fb", "jp", "wr", "snap", "nb", "fp", "bm", "br", "bh", "bg", "BIP", "hp", "kb", "usb", "esp", "sp", "pb", "bt", "np", "sb", "isp", "gp", "cp", "bb", " lb"]}}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "substitutes": {"widget": ["focus", "view", "window", "root", "win", "editor", "wid", "board", "wp", "document", "layout", "fw", "Widget", "wx", "ctx", "web", "html", "idget", "console", "gui", "component", " widgets", "screen", "game", "wt", "obj", "grid", "w"], "button": ["message", "process", "pixel", "but", "driver", "span", "no", "application", "butt", "function", "ui", "video", "operation", "feature", "job", "command", "action", "next", "trigger", "again", "point", "type", "channel", "Button", "BUT", "ilo", "comment", "back", "menu", "title", "note", "power", "atom", "connection", "link", "entry", "cart", "mark", "b", "timer", "normal", "tag", "number", "color", "display", "label", "foreign", "module", "pressed", "position", "buffer", "box", "match", "delete", "communication", "element", "utton", "index", "field", "window", "attribute", "notice", "editor", "change", "key", "submit", "bridge", "code", "document", "section", "tab", "bot", "band", "version", "shift", "result", "click", "page", "error", "pb", "block", "form", "bug", "flag", "option"], "opaque": ["OPatile", "ioplucent", "OPlucent", "opac", "OPac", "iopaque", " Opaque", "iopatile", "OPaque", "OPacity", "OPiphany", " Opiphany", "OPulent", "compac", " opacity", "opacity", "opulent", "compaque", "compulent", "compacity", "opiphany", " Opatile", " opulent", " opac", "iopiphany", "oplucent", " Oplucent", "opatile"], "vc": ["vd", "ht", "ic", "vi", "vl", "dc", "conv", "gc", "etc", "vr", "iv", "VC", "cs", "bc", "cu", "tk", "cv", "vm", "ctrl", "c", "voc", "vg", "ec", "wr", "tv", "wx", "sn", "ctx", "uv", "sv", "vs", "vt", "lc", "cf", "vo", "vv", "soc", "oc", "nv", "v", "vp", "lv", "ev", "xc", "serv"], "s": ["n", "t", "p", "is", "sys", "a", "sa", "r", "os", "o", "h", "ss", "ns", "session", "ses", "d", "serv", "ps", "cs", "i", "sts", "rs", "gs", "fs", "aws", "c", "ds", "sis", "st", "sm", "sn", "spec", "ls", "sam", "sv", "sw", "vs", "ats", "hs", "sc", "S", "js", "g", "sq", "ts", "sp", "gets", "sg", "soc", "u", "qs", "sb", "b", "v", "sl", "w"], "btn": ["fn", "prot", "msg", "ck", "bolt", "foo", "bott", "tk", "cli", " bout", "butt", "wx", "addon", "bh", "feat", "bt", " todd", "pai", "sb", "stick", "fl", "again", "bb", " slack", "focus", " champ", "bs", " quit", "bn", "ko", "bd", " tit", "dat", " bud", "cmd", "skin", " ko", "oulder", "b", "fc", "bj", "comm", "quit", "bf", "toggle", "tn", " tip", "pkg", " dock", "mu", "fb", "bo", " tet", "bg", " kick", "attr", "plot", "txt", "org", "kt", "cb", "aug", "window", "lu", " slog", "nom", " notch", "ctrl", "og", "fw", "bot", "fp", "nm", "utt", "heading", "rl", "typ", "bol", "bp", "ctr"]}}
{"project": "FFmpeg", "commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "target": 1, "func": "static void * attribute_align_arg worker(void *v){\n\n    AVCodecContext *avctx = v;\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    AVPacket *pkt = NULL;\n\n\n\n    while(!c->exit){\n\n        int got_packet, ret;\n\n        AVFrame *frame;\n\n        Task task;\n\n\n\n        if(!pkt) pkt= av_mallocz(sizeof(*pkt));\n\n        if(!pkt) continue;\n\n        av_init_packet(pkt);\n\n\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {\n\n            if(c->exit){\n\n                pthread_mutex_unlock(&c->task_fifo_mutex);\n\n                goto end;\n\n            }\n\n            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);\n\n        }\n\n        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n        frame = task.indata;\n\n\n\n        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);\n\n        pthread_mutex_lock(&c->buffer_mutex);\n\n        av_frame_unref(frame);\n\n        pthread_mutex_unlock(&c->buffer_mutex);\n\n        av_frame_free(&frame);\n\n        if(got_packet) {\n\n            int ret2 = av_dup_packet(pkt);\n\n            if (ret >= 0 && ret2 < 0)\n\n                ret = ret2;\n\n        } else {\n\n            pkt->data = NULL;\n\n            pkt->size = 0;\n\n        }\n\n        pthread_mutex_lock(&c->finished_task_mutex);\n\n        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;\n\n        c->finished_tasks[task.index].return_code = ret;\n\n        pthread_cond_signal(&c->finished_task_cond);\n\n        pthread_mutex_unlock(&c->finished_task_mutex);\n\n    }\n\nend:\n\n    av_free(pkt);\n\n    pthread_mutex_lock(&c->buffer_mutex);\n\n    avcodec_close(avctx);\n\n    pthread_mutex_unlock(&c->buffer_mutex);\n\n    av_freep(&avctx);\n\n    return NULL;\n\n}\n", "idx": 20457, "substitutes": {"v": ["n", "p", "t", "vc", "r", "vi", "f", "m", "h", "vr", "iv", "va", "i", "cv", "vm", "av", "j", "k", "ve", "sv", "vs", "g", "vo", "w", "nv", "b", "l", "V", "vp", "vv", "vt"], "avctx": ["avehandle", " avcv", " avnp", " avconn", "svctx", "avcontext", "avcv", "avenp", " avcfg", " avcam", "avecv", "avecfg", "avercontext", " avhandle", "averctx", "aveconn", "avercam", "avecontext", "avcam", "svconn", "avecam", "avectx", "svcontext", "avcfg", "avercfg", " avcontext", "svnp", "avconn", "avhandle", "avercv", "avnp", "averhandle"], "c": ["n", "comm", "coll", "t", "p", "com", "vc", "rc", "ic", "this", "r", "cb", "ce", "f", "dc", "m", "abc", "co", "ac", "gc", "ct", "etc", "count", "unc", "con", "call", "cs", "bc", "cu", "e", "cd", "cv", "cl", "ec", "cmp", "C", "ctx", "chain", "lc", "cm", "sc", "cf", "ci", "g", "config", "mc", "pc", "cam", "tc", "conf", "cr", "cache", "can", "nc", "cc", "b", "fc", "l", "cp", "ca", "xc"], "pkt": ["xpkg", "paelt", "pack", "fpkg", " pkg", "spck", "pet", "xpkt", "ipet", "pelt", "pbkt", "pcmd", "payacket", "cpwk", "npmsg", "parsekt", "pacmd", "ipacket", "packet", "payqt", "Pqt", "pckg", "pett", "pck", "pcacket", "packck", "paft", "pavc", "pashot", "pqt", " pft", "pcet", "Pet", " pct", "pvc", " pck", "wpet", "pwk", "pct", "spvc", " pnt", "wpkt", " pwk", "nkt", "fpet", "npelt", "ppacket", "pmsg", "nnt", "pbkg", "ipwk", " pshot", "pft", "vpacket", "Pwk", " pett", " pix", "xpett", "paacket", "pkat", " pkat", "vpft", "spett", "pkg", "nacket", "payct", "ppet", " pmsg", "pix", " pvc", "npkt", "nct", "ipkt", "ppnt", "parsekg", "wpwk", " pcmd", "xpacket", "spkg", "Pkat", "payix", "Pct", "spacket", "pshot", "cpacket", " pqt", "pbelt", "pnt", "payshot", "ppkt", "Packet", "paykt", "pakt", "Pkt", "vpelt", "npkg", " pelt", "pckt", "cpet", "fpkt", "spkt", "paix", "parseacket", "wpkat", "pbmsg", "packacket", " pet", "packkt", "ppct", "pcct", "paycmd", "vpkt", "parseet", "packkg", "cpkt", "fpacket", "pcck", " packet"], "got_packet": ["got___ped", "got_packedet", "got_packed", "got_packkt", "got_packskt", "got_packET", "got_linkacket", "got___po", "got_packageacket", "got_maskel", "got_bucked", "got_signed", "got_packedacket", "got_packacket", "got_po", "got_packsET", "got_packedkt", "got_packageed", "got_packo", "got_packagekt", "got___pel", "got_packsed", "got_linker", "got_ped", "got_packageo", "got_linket", "got_packer", "got_signet", "got___packel", "got_packel", "got_packeder", "got_masket", "got___pet", "got_signET", "got_signkt", "got_pet", "got___packet", "got_buckkt", "got___packed", "got_packset", "got_packageel", "got_bucket", "got___packo", "got_buckET", "got_linkkt", "got_pel", "got_packageer", "got_masko", "got_packageet", "got_masked"], "ret": ["fun", "gt", "resp", " Ret", "re", "magic", "txt", "it", "rev", "kt", "usr", "cont", "xt", "ref", "back", "desc", "rets", "f", "rem", "err", "Ret", "val", "url", "ert", "arg", "def", "code", "bit", "lt", "jp", "tr", "RT", "flag", "status", "mt", "result", "repl", "deg", "ft", "rt", "reply", "res", "alt", "fin", "mem", "rm", "dr", "rot", "nt", "try", "RET", "cmd", "after", "virt", "len", "elt", "att", "success", "got"], "frame": ["rame", "orig", "t", "kt", "iframe", "bf", "process", "force", "ref", "f", "window", "movie", "zone", "session", "qt", "FR", "image", "shot", "none", "def", "code", "info", "row", "data", "bit", "tx", "fb", "step", "frames", "profile", "base", "Frame", "fr", "version", "word", "event", "scene", " framed", "video", "draw", "part", "feat", "component", "cf", " timeframe", "face", "sequence", "doc", "feature", "fin", "error", " Frame", "ence", "zero", "block", "req", "remote", "sample", "framework", "comp", "fram", "file", "point", "text"], "task": ["master", "t", "question", "time", "tt", "msg", "tag", "kt", "message", "func", "role", "index", "process", "commit", "list", "window", "tar", "session", "thread", "piece", "item", "table", "key", "total", "image", "unknown", "package", "target", "tx", "bit", "test", "node", "Task", "worker", "result", "function", "word", "rake", "request", "event", "ask", "part", "feat", "self", "dev", "new", "service", "nt", "job", "config", "command", "action", "block", "req", "tc", "remote", "term", "work", "form", "next", "course", "token", "net"]}}
{"project": "qemu", "commit_id": "86865c5ff16bd1a2ef2b9ce217a7bb8f39e2126c", "target": 1, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n    /* This code tries to make movcal emulation sufficiently\n\n       accurate for Linux purposes.  This instruction writes\n\n       memory, and prior to that, always allocates a cache line.\n\n       It is used in two contexts:\n\n       - in memcpy, where data is copied in blocks, the first write\n\n       of to a block uses movca.l for performance.\n\n       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used\n\n       to flush the cache. Here, the data written by movcal.l is never\n\n       written to memory, and the data written is just bogus.\n\n\n\n       To simulate this, we simulate movcal.l, we store the value to memory,\n\n       but we also remember the previous content. If we see ocbi, we check\n\n       if movcal.l for that address was done previously. If so, the write should\n\n       not have hit the memory, so we restore the previous content.\n\n       When we see an instruction that is neither movca.l\n\n       nor ocbi, the previous content is discarded.\n\n\n\n       To optimize, we only try to flush stores when we're at the start of\n\n       TB, or if we already saw movca.l in this TB and did not flush stores\n\n       yet.  */\n\n    if (ctx->has_movcal)\n\n\t{\n\n\t  int opcode = ctx->opcode & 0xf0ff;\n\n\t  if (opcode != 0x0093 /* ocbi */\n\n\t      && opcode != 0x00c3 /* movca.l */)\n\n\t      {\n\n\t\t  gen_helper_discard_movcal_backup ();\n\n\t\t  ctx->has_movcal = 0;\n\n\t      }\n\n\t}\n\n\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\t\t\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(low, REG(B7_4));\n\n\t    tcg_gen_bswap16_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, addr, 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n#define LD(reg,ldnum,ldpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\n\n#define ST(reg,stnum,stpnum,prechk)\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_gen_mov_i32(REG(B11_8), addr);\t\t\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n\tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\\n\n\tST(reg,stnum,stpnum,prechk)\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)\n\n\tLD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n        {\n\n            TCGv val = tcg_temp_new();\n\n            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);\n\n            gen_helper_movcal (REG(B11_8), val);            \n\n            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n        }\n\n        ctx->has_movcal = 1;\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    gen_helper_ocbi (REG(B11_8));\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 20467, "substitutes": {"ctx": ["ck", "ce", "loc", "unc", "timeout", "ticket", "jp", "aux", "wx", "event", "tmp", "lc", "xs", "kb", "std", "command", "tc", "ctl", "xc", "kw", "resp", "context", "unk", "x", "ind", "dl", "cmp", "xp", " cx", "cf", "wcs", "anc", "prefix", "cmd", "iat", "crit", "acl", "tm", "cc", "cp", "cas", "dc", "abc", "exec", "act", "gc", "reason", "pkg", "tz", "cu", "cv", "tx", "c", "hw", "config", "nt", "req", "np", "ca", "yes", "history", "mk", "kt", "cb", "etc", "ct", "ctrl", "conn", "bc", "document", "cm", "mc", "cfg", "today", "ctr"], "CHECK_NOT_DELAY_SLOT": ["CHECK_NOT_DELAY_LOTS", "CHECK_NOT_DELAYEDSLOT", "CHECK_NOT_DELAY_SLOTS", "CHECK_NOT_DELAY_PLOTS", "CHECK_NOT_DELAY_SlOT", "CHECK_NOT_DELAYEDSLot", "CHECK_NOT_DELAY_SlOST", "CHECK_NOT_DELAY_Slot", "CHECK_NOT_DELAY_SlOP", "CHECK_NOT_DELAY_LOP", "CHECK_NOT_DELAY_PLOT", "CHECK_NOT_DELAY_LOT", "CHECK_NOT_DELAY_PLOP", "CHECK_NOT_DELAY_Lot", "CHECK_NOT_DELAYEDSLOST", "CHECK_NOT_DELAYEDSLOTS", "CHECK_NOT_DELAY_SLOP", "CHECK_NOT_DELAYEDSLOP", "CHECK_NOT_DELAY_SLOST", "CHECK_NOT_DELAY_PLOST", "CHECK_NOT_DELAY_PLot", "CHECK_NOT_DELAY_SLot"], "delayed_pc": ["delayed_mc", "delaying_pb", "delaying_PC", "delayed___PC", "delocated5mc", "delaying___pc", "delayed___sc", "delocated_sc", "delaying___sc", "delayed___pb", "delaying___PC", "delayed5pc", "delayed5sc", "delayed_pb", "delaying_pc", "delocated5pc", "delocated_PC", "delocated5PC", "delayed___pc", "delayed5mc", "delayed5PC", "delayed_PC", "delocated_pc", "delocated5sc", "delocated_mc", "delaying___pb", "delayed_sc", "delaying_sc"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471, "substitutes": {"opaque": ["oplque", " opaques", "ipatile", "iply", "oque", "ipaques", "oplaque", "ogacity", "ogaque", " opatile", "oplacity", "Opatile", "ipaque", "ogque", "Opaque", "oacity", "opacity", "opaques", "oplient", "Opaques", "oient", "Oply", "oply", "ogient", " oply", "opque", "oaque", "opatile", "opient"], "hz": [" fps", "density", " her", "zh", " bandwidth", "hh", "zz", "stones", " height", "h", "zone", "elong", "hash", "rss", "val", "tz", " cz", "weight", " sch", "fs", "hurst", "hd", "hhhh", "z", "hm", "height", " Hz", "clock", "frequency", " frequency", "kh", "hs", "Hz", " MHz", "maxwell", " h", "GHz", "zon", "mostly", "MHz", "phy", "vals", "wcs", "conf", "fps", " hue", "phil", "cz"], "s": ["t", "p", "is", "sys", "a", "r", "source", "set", "f", "h", "m", "ns", "ss", "stats", "bs", "ps", "space", "sts", "socket", "e", "rs", "gs", "c", "ds", "bis", "j", "se", "status", "spec", "ls", "q", "ms", "sv", "ats", "self", "S", "js", "service", "g", "its", "sq", "ts", "ins", "sb", "sol", "b", "as", "v", "an", "sl"]}}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_dma_write(BlockBackend *blk,\n\n                         int64_t sector_num, int nb_sectors,\n\n                         void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    dma_addr_t dma_addr, dma_len;\n\n    void *mem;\n\n    int nsector, remainder;\n\n    int extra = 0;\n\n\n\n    qemu_iovec_destroy(&io->iov);\n\n    qemu_iovec_init(&io->iov, io->len / MACIO_PAGE_SIZE + 1);\n\n\n\n    if (io->remainder_len > 0) {\n\n        /* Return remainder of request */\n\n        int transfer = MIN(io->remainder_len, io->len);\n\n\n\n        MACIO_DPRINTF(\"--- processing write remainder %x\\n\", transfer);\n\n        cpu_physical_memory_read(io->addr,\n\n                                 &io->remainder + (0x200 - transfer),\n\n                                 transfer);\n\n\n\n        io->remainder_len -= transfer;\n\n        io->len -= transfer;\n\n        io->addr += transfer;\n\n\n\n        s->io_buffer_index += transfer;\n\n        s->io_buffer_size -= transfer;\n\n\n\n        if (io->remainder_len != 0) {\n\n            /* Still waiting for remainder */\n\n            return;\n\n        }\n\n\n\n        MACIO_DPRINTF(\"--> prepending bounce buffer with size 0x200\\n\");\n\n\n\n        /* Sector transfer complete - prepend to request */\n\n        qemu_iovec_add(&io->iov, &io->remainder, 0x200);\n\n        extra = 1;\n\n    }\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        sector_num = (int64_t)(s->lba << 2) + (s->io_buffer_index >> 9);\n\n    } else {\n\n        sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    }\n\n\n\n    nsector = (io->len >> 9);\n\n    remainder = io->len - (nsector << 9);\n\n\n\n    MACIO_DPRINTF(\"--- DMA write transfer - addr: %\" HWADDR_PRIx \" len: %x\\n\",\n\n                  io->addr, io->len);\n\n    MACIO_DPRINTF(\"xxx remainder: %x\\n\", remainder);\n\n    MACIO_DPRINTF(\"xxx sector_num: %\"PRIx64\"   nsector: %x\\n\",\n\n                  sector_num, nsector);\n\n\n\n    dma_addr = io->addr;\n\n    dma_len = io->len;\n\n    mem = dma_memory_map(&address_space_memory, dma_addr, &dma_len,\n\n                         DMA_DIRECTION_TO_DEVICE);\n\n\n\n    if (!remainder) {\n\n        MACIO_DPRINTF(\"--- DMA write aligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, io->len);\n\n        qemu_iovec_add(&io->iov, mem, io->len);\n\n    } else {\n\n        /* Write up to last complete sector */\n\n        MACIO_DPRINTF(\"--- DMA write unaligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, (nsector << 9));\n\n        qemu_iovec_add(&io->iov, mem, (nsector << 9));\n\n\n\n        MACIO_DPRINTF(\"--- DMA write read    - bounce addr: %p \"\n\n                      \"remainder_len: %x\\n\", &io->remainder, remainder);\n\n        cpu_physical_memory_read(io->addr + (nsector << 9), &io->remainder,\n\n                                 remainder);\n\n\n\n        io->remainder_len = 0x200 - remainder;\n\n\n\n        MACIO_DPRINTF(\"xxx remainder_len: %x\\n\", io->remainder_len);\n\n    }\n\n\n\n    s->io_buffer_size -= ((nsector + extra) << 9);\n\n    s->io_buffer_index += ((nsector + extra) << 9);\n\n\n\n    io->len = 0;\n\n\n\n    MACIO_DPRINTF(\"--- Block write transfer   - sector_num: %\"PRIx64\"  \"\n\n                  \"nsector: %x\\n\", sector_num, nsector + extra);\n\n\n\n    m->aiocb = blk_aio_writev(blk, sector_num, &io->iov, nsector + extra, cb,\n\n                              io);\n\n}\n", "idx": 20480, "substitutes": {"blk": [" blak", "BLb", " blb", "blak", "blK", "slK", "blb", "BLK", " blK", "BLk", "slak", "BLak", "slb", "slk"], "sector_num": ["sectoritydim", " sector_number", " sector_name", " sector_no", "sector2no", "section_num", "sector_id", "sector_number", "sectorityno", "sector_dim", "section_number", "sector2num", "sectoritynumber", "sector_Num", "sector_no", "sectoritynum", " sector_dim", "sector2name", "section_id", "sector2number", "sector_name", "section_Num"], "nb_sectors": ["nb_neors", "nb_seors", "nb_pselements", "nb_segments", "nb_nelements", "nb_vegments", "nb_nectors", "nb_psegments", "nb_vectors", "nb_selements", "nb_veors", "nb_velements", "nb_negments", "nb_pseors", "nb_psectors"], "cb": ["fn", "rb", "bf", "func", "callback", "dc", "err", "gb", "CB", "ctrl", "bc", "cd", "cv", "cmp", "proc", "fp", "buf", "ctx", "bg", "db", "cm", "cf", "obj", "sb", "cc", "b", "bp", "cp", "bb"], "opaque": ["composit", "oplque", "operaques", "operus", "opoid", "oque", "iopaque", "oplaque", "ipacity", " opque", "Opaco", "oboid", "operque", "operoid", "oplaco", "iopatile", " opatile", "iopaques", "iposit", "ompque", "oplacity", "ipaque", "obatile", " opus", "compque", "obaque", "Opaque", "oacity", "Opacity", "oaco", "opacity", "omposit", "ompacity", "compaque", "opaques", "iopoid", "paque", "pque", "ompaque", "opaco", "patile", "compacity", "pus", "oposit", "Opque", "opque", "operatile", "ipque", "oaque", "operaque", "opatile", "obaques", "opus"], "io": ["ee", "cho", "ory", "orm", "transfer", "foo", "ox", "fo", "driver", "im", "timeout", "ore", "no", "lo", "ary", "event", "ex", "server", "video", "command", "example", "client", "ry", "feed", "iot", "response", "ilo", "ion", "o", "os", "list", "ai", "cgi", "note", "i", "my", "disk", "ahi", "connection", "op", "iol", "link", "entry", "IO", "ae", " IO", "ace", "remote", "network", "net", "core", "zip", "proxy", "writer", "it", "ri", "task", "exec", "co", " ie", "image", "pro", "def", "poll", "iop", "bit", "ao", "ip", "ia", " gateway", "storage", "obj", "so", "serv", "yes", "history", "ror", "org", "hero", "go", "isco", "window", "ie", "ro", "row", "or", "test", "byte", "ki", "tif", "rio", "page", "ico", "error", "http", "ive", "interface", "form", "option", "iterator"], "m": ["n", "M", "p", "t", "dm", "o", "me", "mm", "r", "f", "h", "gm", "d", "mp", "i", "vm", "meta", "c", "j", "mt", "sm", "mode", "bm", "manager", "ms", "cm", "hm", "em", "g", "mc", "mis", "tm", "b", "l", "v", "w"], "s": ["n", "comm", "er", "p", "t", "is", "sys", "ports", "settings", "a", "sym", "o", "os", "r", "set", "h", "ns", "ss", "y", "ims", "changes", "us", "stats", "d", "serv", "ps", "bs", "i", "e", "cs", "sts", "rs", "services", "gs", "fs", "c", "sim", "ds", "sm", "spec", "ls", "ms", "sv", "sets", "sw", "vs", "ats", "hs", "sam", "self", "ies", "sc", "S", "js", "g", "es", "its", "ins", "sp", "ts", "als", "qs", "less", "sb", "b", "w"], "dma_addr": ["dma2addr", "dma__addr", "dma_address", "dme_address", "dma2ptr", "dma2address", "dme_addr", "dma__address", "dma__ptr", "dme_ptr", "dma_ptr"], "dma_len": ["dme_val", "dma___len", "dma_size", "dma_val", "dma__size", "dme_size", "dma___size", "dma__val", "dma_length", "dma__length", "dme_length", "dma__len", "dme_len", "dma___length", "dma___val"], "mem": ["msg", "alloc", "memory", "mm", "ref", "rem", "progress", "ata", "mb", "um", "md", "temp", "asm", "buf", "nm", "link", "jump", "res", "Mem", "buffer", "addr", "reg", "buff", "mi", "cmd", "mop", "phys", "ram"], "nsector": ["nframe", "ntsection", "ansection", "dector", " nbrowser", "ansector", "dsection", "dframe", "Nsector", "mbrowser", "cnbrowser", "cnser", "Nector", "Nsection", "nector", "cnsector", "dsector", "ntriver", "mser", "msector", "anector", "nsection", " nriver", "anframe", "msection", " nector", "ntsector", "nser", " nsection", "cnsection", "ntector", "Nriver", "Nframe", " nser", "nriver", "nbrowser"], "remainder": ["remainedder", "remplaindr", "remainingter", "remainingner", " remainger", " remainsner", "remainingdr", "remainsner", "promainedter", " remainsdr", " remainner", "REMainder", "resprainder", "remaindr", "remainster", "remplainter", "remainner", "remrainner", "remrainter", "promainedger", "promainedner", "promainedder", "REMainingger", "remainedter", "remainDER", "respainner", " remainedDER", "remainingder", "promainter", "remainsdr", "respainder", "remrainDER", "remainingDER", "remainsger", "remplainder", "remraindr", "resprainter", " remainDER", "promainder", "remainter", "REMainingder", " remainedger", "REMainDER", "remainedDER", "REMainger", "remplainger", "remainger", " remainedder", "remrainder", "REMainingDER", "promainner", "respraindr", "respainter", " remainsger", " remainedner", "remainsDER", "remrainger", "resprainner", "remainingger", "remplainner", "remainedner", "REMainter", "respaindr", " remainsder", "remainsder", "remainedger", "promainger", " remaindr", "REMainingter"]}}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n", "idx": 20485, "substitutes": {"bs": ["ubis", "boxes", "sys", "lbs", "ics", "bits", "ks", "aps", "ubs", "cus", "ns", "BS", "ss", "bps", "outs", "aos", "ims", "stats", "iss", "ps", "cs", "bc", "sts", "fs", "gs", "aws", "ds", "bis", "bytes", "ls", "hz", "ms", "bles", "vs", "bing", "hs", "ats", "bes", "js", "xs", "es", "its", "ts", "als", "obs", "pb", "aus", "qs", "acs", "sb", "bos", "cks", "bp", "bas"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 20495, "substitutes": {"iommu_mr": ["iommo_hr", "iommo_mr", "iommu_rs", "iommo_rr", "iommo_rs", "iommu2vr", "iommu2rs", "iommu_rr", "iommu_hr", "iommu2rr", "iommu_vr", "iommo_vr", "iommu2mr", "iommu_tr", "iommo_tr"], "n": ["fn", "p", "t", "out", "rn", "r", "o", "cn", "nr", "tn", "m", "h", "ns", "nw", "nor", "na", "x", "i", "nn", "on", "node", "c", "N", "j", "nb", "nu", "sn", "nm", "num", "nah", "g", "nt", "np", "nl", "ne", "mn", "nc", "nv", "l", "v", "an", "b"], "vtd_as": ["vdt_am", "vdoolyas", "vtd_ars", "vtd2as", "vtd2ass", "vtd_ws", "vtd_am", "vtd_has", "vpd_jas", "vtd_asha", "vtddba", "vtd8am", "vdt_ws", "vdd_as", "vtd_mas", "vtd_ats", "vtadbras", "vdoolyras", "vtd_ass", "vtd_ras", "vtd_jas", "vtadbas", "vnt_has", "vta_a", "vtd_asin", "vpd_ass", "vdt_las", "vtdolyras", "vtd8as", "vtdappasin", "vta_ras", "vtdolyase", "vdo_asha", "vsd_as", "vtdappase", "vdt_as", "vtddbasha", "vtdolyav", "vdd_ats", "vdo_ras", "vtdolyasha", "vtd___ats", "vtdolyhas", "vdoolyasy", "vtd_ar", "vtd_asy", "vdtpyas", "vtd___asin", "vtd_ase", "vta_asha", "vtd___ase", "vtd2ras", "vtddbas", "vtd2ar", "vdo_as", "vtd0ar", "vnt_av", "vsd_ras", "vtd8las", "vtd_a", "vdt_rs", "vtadbasha", "vtd2asha", "vtdpyas", "vtdpyars", "vdoolyasha", "vtdappas", "vnt_as", "vtd_av", "vtdolyasy", "vdtpyrs", "vtd2ase", "vdtpyws", "vtdolyas", "vtd0jas", "vsd_aos", "vpd_as", "vtdolyaos", "vsd_ase", "vtddbras", "vtadba", "vtd2jas", "vdd_asin", "vpd_ar", "vta_as", "vtd0ass", "vtd___as", "vdd_ase", "vtdpyrs", "vdo_asy", "vtdappats", "vtdolymas", "vtd_rs", "vdtpyars", "vnt_ras", "vtd_aos", "vtd0as", "vdt_ars", "vtd_las", "vtd2asy", "vtdpyws", "vtd2aos"], "s": ["p", "t", "sys", "state", "is", "sa", "r", "os", "h", "m", "ss", "ns", "ps", "bs", "cs", "sts", "space", "rs", "fs", "gs", "c", "ds", "sis", "sn", "ls", "ats", "S", "js", "g", "its", "ts", "sb", "b", "as", "v", "w"], "ce": ["ee", " CE", " ace", "lee", "ck", "et", "cont", "cue", "coe", "force", "cele", "te", "du", "card", "ze", "ct", "ie", "e", "c", " ke", "ge", "le", "cur", "cle", "se", "enter", "see", " ice", "cell", "ent", "ke", "cer", "ve", "ine", "cand", "ces", "pe", "entry", "cf", "de", "ci", "ae", "cause", "cel", "ence", "ense", "ace", "CE", "ne", "nc", "cc", "je", "ca", "ue", "cast", "ced"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n", "idx": 20507, "substitutes": {"sd": ["td", "vd", "state", "si", "dd", "dk", "dis", "ss", "sk", "d", "sim", "ind", "aws", "ds", "md", "dl", "st", "hd", " cd", "SD", "se", "south", "sm", "sn", "sam", "sv", "sy", "sh", "sky", "ess", "od", "sg", "eds", "sb", "pd", "sand", "so"], "addr": [" ptr", " address", "dh", "a", " dst", "set", "arp", "ack", "ref", "off", "hash", "offset", "add", "act", "ha", "ar", "ash", "arr", "loc", "id", "eth", "tx", "test", "coord", "ord", "mt", "ptr", "align", "map", "Address", "help", "at", "ad", " pad", "address", "cmd", "obj", "ace", "work", "pad", "sha", "lag", "attr"]}}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_handle_escape(QemuConsole *s)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i<s->nb_esc_params; i++) {\n\n        switch (s->esc_params[i]) {\n\n            case 0: /* reset all console attributes to default */\n\n                s->t_attrib = s->t_attrib_default;\n\n                break;\n\n            case 1:\n\n                s->t_attrib.bold = 1;\n\n                break;\n\n            case 4:\n\n                s->t_attrib.uline = 1;\n\n                break;\n\n            case 5:\n\n                s->t_attrib.blink = 1;\n\n                break;\n\n            case 7:\n\n                s->t_attrib.invers = 1;\n\n                break;\n\n            case 8:\n\n                s->t_attrib.unvisible = 1;\n\n                break;\n\n            case 22:\n\n                s->t_attrib.bold = 0;\n\n                break;\n\n            case 24:\n\n                s->t_attrib.uline = 0;\n\n                break;\n\n            case 25:\n\n                s->t_attrib.blink = 0;\n\n                break;\n\n            case 27:\n\n                s->t_attrib.invers = 0;\n\n                break;\n\n            case 28:\n\n                s->t_attrib.unvisible = 0;\n\n                break;\n\n            /* set foreground color */\n\n            case 30:\n\n                s->t_attrib.fgcol=COLOR_BLACK;\n\n                break;\n\n            case 31:\n\n                s->t_attrib.fgcol=COLOR_RED;\n\n                break;\n\n            case 32:\n\n                s->t_attrib.fgcol=COLOR_GREEN;\n\n                break;\n\n            case 33:\n\n                s->t_attrib.fgcol=COLOR_YELLOW;\n\n                break;\n\n            case 34:\n\n                s->t_attrib.fgcol=COLOR_BLUE;\n\n                break;\n\n            case 35:\n\n                s->t_attrib.fgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 36:\n\n                s->t_attrib.fgcol=COLOR_CYAN;\n\n                break;\n\n            case 37:\n\n                s->t_attrib.fgcol=COLOR_WHITE;\n\n                break;\n\n            /* set background color */\n\n            case 40:\n\n                s->t_attrib.bgcol=COLOR_BLACK;\n\n                break;\n\n            case 41:\n\n                s->t_attrib.bgcol=COLOR_RED;\n\n                break;\n\n            case 42:\n\n                s->t_attrib.bgcol=COLOR_GREEN;\n\n                break;\n\n            case 43:\n\n                s->t_attrib.bgcol=COLOR_YELLOW;\n\n                break;\n\n            case 44:\n\n                s->t_attrib.bgcol=COLOR_BLUE;\n\n                break;\n\n            case 45:\n\n                s->t_attrib.bgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 46:\n\n                s->t_attrib.bgcol=COLOR_CYAN;\n\n                break;\n\n            case 47:\n\n                s->t_attrib.bgcol=COLOR_WHITE;\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 20518, "substitutes": {"s": ["n", "comm", "t", "ports", "is", "sys", "ears", "os", "parts", "ans", "changes", "ns", "ss", "ims", "us", "ses", "stats", "ps", "bs", "cs", "sts", "rs", "gs", "fs", "aws", "sports", "services", "ds", "pers", "states", "se", "spec", "ls", "details", "ches", "ms", "sv", "sw", "sets", "ats", "vs", "hs", "S", "js", "es", "ins", "sq", "ts", "als", "its", "ares", "gets", "ants", "qs", "less", "mys", "sb", "as", "tes", "sl"], "i": ["bi", "ij", "phi", "\u0438", "is", " li", "it", "ic", " si", "si", "me", "index", "di", "iu", "ai", "ski", "xi", "io", "m", "ix", "go", "ims", "y", " I", "us", "init", "multi", " m", "by", "im", " my", "zi", " index", "x", " ii", "e", "sim", "ind", "gi", " ti", "I", "c", " iter", " di", "qi", "ki", "ini", "j", "ip", "batch", "ti", "li", "ui", "ex", " bi", " ni", "oi", "in", "ci", " j", " pi", "mi", "ii", " mi", "pi", " multi"]}}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 20520, "substitutes": {"s": ["n", "p", "t", "os", "h", "ns", "ss", "ses", "d", "ps", "e", "socket", "fs", "gs", "rs", "c", "ds", "sv", "S", "js", "es", "sq", "ts", "sg", "sb", "v", "w"], "tcg_src": ["tcgo_cont", "tcgo___cur", "tcg_impl", "tcg___impl", "tcgo___src", "tcg_cont", "tcg__dest", "tcg_dest", "tcgo___tmp", "tcg_syn", "tcgo_dest", "tcg_source", "tcrg_impl", "tcgo___cont", "tcg__src", "tcgo_cur", "tcgo_impl", "tcg___src", "tcg_desc", "tcgntdesc", "tcg_tmp", "tctg__src", "tcg___dest", "tcgo_src", "tcgntimpl", "tcrg_desc", "tctg__source", "tctg_dest", "tcrg_src", "tcg_rol", "tctg_source", "tcga_target", "tcg___tmp", "tcgo___impl", "tcgo___dest", "tcgntsrc", "tcgo_rou", "tcg___desc", "tcg___cur", "tcga_rol", "tcg___syn", "tcg_target", "tctg__dest", "tcg___cont", "tcg___rou", "tcgntsyn", "tcgo_tmp", "tcga_st", "tctg_src", "tcg__source", "tcg_cur", "tcga_src", "tcg_rou", "tcrg_syn", "tcg_st", "tcgo___rou"], "destidx": ["Destindx", "Destidz", "destidxs", "destIdz", "Destidxs", "destindxs", "destIdxf", "destindxf", " destidxs", " destidy", "destIdy", "destIdxs", "destidy", "Destindz", " destidxf", "destIdx", "destindx", "destindy", "Destidx", "Destindy", "Destindxs", "Destidy", "destidxf", "destidz", "destindz"], "element": ["vector", "ele", "ror", "month", "number", "ce", "index", "field", "lem", " ele", "value", "offset", "repeat", "object", "attribute", "echo", "e", "empty", "section", "le", "E", "ment", "mode", "module", "position", "pe", "lement", "entry", "buffer", "component", "sequence", "feature", "nce", "oe", "append", "interface", "address", "variable", "ace", "elt", "Element", "lements"], "memop": ["emoop", "memoryhop", "Memoper", "memoryok", " memops", "emop", "mOp", "MemOp", "mhop", "emOp", "memoper", "memok", "memops", " memoper", " memhop", " memOp", "memhop", " memok", "Memhop", "memoryoop", " memoop", "memoryop", "memoryOp", "Memop", "mok", "memoryops", "emops", "memOp", "mop", "memoryoper", "memoop"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),\n\n                                    int ra, int rb, int rc,\n\n                                    int islit, uint8_t lit)\n\n{\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    if (ra != 31) {\n\n        if (islit) {\n\n            if (lit != 0)\n\n                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));\n\n            else\n\n                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);\n\n        } else {\n\n            TCGv tmp1, tmp2;\n\n            tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);\n\n            tcg_gen_shli_i64(tmp1, tmp1, 3);\n\n            tmp2 = tcg_const_i64(64);\n\n            tcg_gen_sub_i64(tmp1, tmp2, tmp1);\n\n            tcg_temp_free(tmp2);\n\n            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);\n\n            tcg_temp_free(tmp1);\n\n        }\n\n        if (tcg_gen_ext_i64)\n\n            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);\n\n    } else\n\n        tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n}\n", "idx": 20531, "substitutes": {"tcg_gen_ext_i64": ["tcg_gen_ext_pi32", "tcg_gen_ext_l16", "tcg_gen_ext2I32", "tcg_gen_ext_pi64", "tcg_gen_ext_i32", "tcg_gen_ext_pi256", "tcg_gen_ext2I16", "tcg_gen_ext2I8", "tcg_gen_ext2i16", "tcg_gen_ext_i8", "tcg_gen_ext_l64", "tcg_gen_ext_I8", "tcg_gen_ext_i16", "tcg_gen_ext_I256", "tcg_gen_ext_l32", "tcg_gen_ext_I32", "tcg_gen_ext_I64", "tcg_gen_ext_i256", "tcg_gen_ext2i64", "tcg_gen_ext_pi16", "tcg_gen_ext2i8", "tcg_gen_ext_pi8", "tcg_gen_ext2I64", "tcg_gen_ext_I16", "tcg_gen_ext2i32"], "ra": ["rera", "re", "ras", "mr", "ror", "ri", "a", "ica", "r", "ru", "sa", "ref", "rise", "raf", "co", "cro", "ha", "ar", "loc", "rr", "po", "ro", "rar", "tri", "row", "rs", "RA", "rx", "cur", "lo", "aria", "ran", "la", "rog", "rw", "dra", "Ra", "br", "rt", "pr", "rh", "tra", "ur", "ir", "ta", "area", "rap", "ara", "au", "era", "cr", "ma", "ca", "rd"], "rb": ["re", "lr", "mr", "ri", "r", "ru", "cb", "ref", "raf", "rob", "ob", "reb", "vr", "ruby", "erb", "lb", "loc", "rr", "rg", "ro", "rar", "ab", "nb", "hr", "rw", "br", "rt", "wb", "db", "rf", "rid", "RB", "rm", "rl", "pb", "bt", "b", "bp", "rd"], "rc": ["isc", "rn", "ras", "ck", "ror", "ica", "r", "cb", "ce", "ru", "ri", "ref", "raf", "co", "act", "gc", "ct", "rin", "src", "vr", "irc", "loc", "rr", "ro", "cs", "ctrl", "rar", "rs", "cv", "RC", "uc", "c", "row", "ec", "rx", "cur", "rog", "hr", "rw", "rt", "roc", "arc", "lc", "ur", "sc", "rm", "rac", "rl", "pc", "cr", "tc", "rec", "nc", "cc", "fc", "ctr"], "islit": ["slig", "sllit", "iolig", "slitt", "kelite", "iollit", "islite", "iolitt", "iolit", "slit", "selig", "gelit", "islig", "gelig", "isllit", "kelig", "kelit", "selite", "gellit", "gelitt", "kellit", "sellit", "islitt", "slite", "selit"], "lit": ["lif", "t", "lam", "sel", "it", "stat", "ref", "lu", "length", "late", "init", "pl", "lb", "lp", "loc", "las", "def", "tl", "bit", "lt", "vec", "let", "limit", "lang", "la", "lim", "li", "rt", "fi", "lite", "lic", "alt", "hl", "lc", "mit", "rot", "buff", "typ", "eral", "len", "hi", "l", "lv", "sl", "type"], "tmp1": ["tmp4", "temp1", "tm0", "tmpone", " tmpone", "td2", "buffone", "tem2", "ctx3", "mp0", "perm1", "tmp3", "buffOne", "temp3", "tmone", "temp2", "tp1", "buff2", " tmp0", "tmpFor", "tem4", "tm2", " tmp25", " tmpFor", "tp2", "buff1", "tpOne", "tp25", "td1", "tm1", "temp4", "ctxOne", "tem1", "mpOne", " tmp3", "txt3", "ctx2", "mpone", "txtone", "perm2", "ctx1", "temp0", "temFor", "txt2", "tempFor", "tmpOne", "permOne", "mp25", "txt1", " tmpOne", "mp2", "mp1", " tmp4", "txtOne", "mp3", "tmp25", "permone", "tdOne", "tmp0"], "tmp2": ["mp02", "tmp4", "temp1", "primetwo", "tmp3", "temp3", "obj02", "tmptwo", "temp2", "mp4", "txt02", "prime1", "objtwo", "tmp02", "obj2", "temp4", " tmp3", "txt3", "txt2", "mptwo", "txt1", "mp2", "mp1", "mp3", " tmp4", " tmp02", "prime2", "obj1", "prime02"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_dequant_tables(H264Context *h)\n\n{\n\n    int i, x;\n\n    init_dequant4_coeff_table(h);\n\n    if (h->pps.transform_8x8_mode)\n\n        init_dequant8_coeff_table(h);\n\n    if (h->sps.transform_bypass) {\n\n        for (i = 0; i < 6; i++)\n\n            for (x = 0; x < 16; x++)\n\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n\n        if (h->pps.transform_8x8_mode)\n\n            for (i = 0; i < 6; i++)\n\n                for (x = 0; x < 64; x++)\n\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n\n    }\n\n}\n", "idx": 20534, "substitutes": {"h": ["comm", "history", "p", "t", "dh", "he", "ht", "context", "zh", "eh", "it", "hh", "H", "f", "oh", "m", "window", "hash", "gc", "th", "info", "hist", "c", "host", "handle", "hd", "proc", "hw", "ih", "here", "q", "bh", "hz", "sh", "ph", "kh", "sw", "hl", "hs", "hm", "hp", "rh", "help", "ch", "mem", "dr", "http", "obj", "cache", "ah", "b", "v", "w"], "i": ["bi", "ij", "name", "phi", "p", "is", "\u0438", "ic", "it", "ri", "this", "si", "me", "di", "index", "iu", "io", "ai", "ix", "m", "y", "us", " I", "multi", "im", "zi", "ei", "ie", "key", "iy", "id", " ii", "sim", "ind", "gi", "info", "I", "c", "qi", "ki", "ini", "ti", "ip", "batch", "cli", "asi", "status", "li", "q", "ui", "oi", "at", "in", "ci", "ik", "g", "mi", "u", "ii", "slice", "pi", "l", "hi", "uri", "chain"], "x": ["fx", "expr", "p", "xx", "any", "xes", "dx", "xt", "xe", "cox", "xi", "ix", "check", "y", "ax", "ox", "ac", "yx", "act", "pt", "xa", "pl", "inx", "e", "on", "tx", "c", "xy", "php", "xml", "rx", "X", "batch", "j", "xp", "lex", "z", "mix", "wx", "ctx", "q", "ex", "draw", "ph", "px", "xf", "at", "try", "xs", "ux", "mx", "xxx", "ll", "v", "el", "lat", "xc"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int g722_encode_init(AVCodecContext * avctx)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono tracks are allowed.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    c->band[0].scale_factor = 8;\n\n    c->band[1].scale_factor = 2;\n\n    c->prev_samples_pos = 22;\n\n\n\n    if (avctx->trellis) {\n\n        int frontier = 1 << avctx->trellis;\n\n        int max_paths = frontier * FREEZE_INTERVAL;\n\n        int i;\n\n        for (i = 0; i < 2; i++) {\n\n            c->paths[i] = av_mallocz(max_paths * sizeof(**c->paths));\n\n            c->node_buf[i] = av_mallocz(2 * frontier * sizeof(**c->node_buf));\n\n            c->nodep_buf[i] = av_mallocz(2 * frontier * sizeof(**c->nodep_buf));\n\n            if (!c->paths[i] || !c->node_buf[i] || !c->nodep_buf[i]) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (avctx->frame_size) {\n\n        /* validate frame size */\n\n        if (avctx->frame_size & 1 || avctx->frame_size > MAX_FRAME_SIZE) {\n\n            int new_frame_size;\n\n\n\n            if (avctx->frame_size == 1)\n\n                new_frame_size = 2;\n\n            else if (avctx->frame_size > MAX_FRAME_SIZE)\n\n                new_frame_size = MAX_FRAME_SIZE;\n\n            else\n\n                new_frame_size = avctx->frame_size - 1;\n\n\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested frame size is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_frame_size,\n\n                   avctx->frame_size);\n\n            avctx->frame_size = new_frame_size;\n\n        }\n\n    } else {\n\n        /* This is arbitrary. We use 320 because it's 20ms @ 16kHz, which is\n\n           a common packet size for VoIP applications */\n\n        avctx->frame_size = 320;\n\n    }\n\n    avctx->delay = 22;\n\n\n\n    if (avctx->trellis) {\n\n        /* validate trellis */\n\n        if (avctx->trellis < MIN_TRELLIS || avctx->trellis > MAX_TRELLIS) {\n\n            int new_trellis = av_clip(avctx->trellis, MIN_TRELLIS, MAX_TRELLIS);\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested trellis value is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_trellis,\n\n                   avctx->trellis);\n\n            avctx->trellis = new_trellis;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    g722_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 20541, "substitutes": {"avctx": ["vrcmp", " avjac", " avcmd", "aucontext", "ajmsg", "avcc", "avemsg", "avertx", "avecfg", "vrcontext", "auctx", "avcp", "vrcu", "savcontext", "wavcfg", " avcmp", "afcontext", "wavctl", "navcmp", "avecp", "afctx", "afcp", " avreq", "averbj", "avercfg", " avctl", "wavreq", "wavtx", " avcc", "vrctx", "ajpkg", "avercmd", "avcmp", "avekt", "avekl", "navctx", "avercontext", "averkt", "afpkg", "ajtx", "navcu", "averctx", "wavsys", "avercp", "afcmd", "navcontext", "vrtx", "wavcmd", "averctl", " avtxt", "avecmd", "aujac", "avcu", "avbj", "ajctl", " avcontext", " avtx", " avmsg", "averjac", "afsys", "savctx", " avbj", "ajcp", "savcmd", "aftx", "avepkg", "avtxt", "avtx", "avetx", "avecontext", "avejac", "avjac", "averpkg", "avkt", "wavcontext", "afctl", "wavkl", "avmsg", "ajjac", "autxt", "wavconn", "avreq", "ajsys", "avconn", "vrbj", "wavctx", " avconn", "avcontext", " avcu", " avpkg", "avectl", "avkl", "avctl", "avermsg", "aucc", "wavpkg", "aveconn", " avcp", "avsys", "ajkl", "ajcfg", "avpkg", "averreq", "avcmd", "ajcontext", "ajconn", "ajctx", "ajkt", "avectx", "avetxt", "avcfg", "avecc", "autx", "averconn", "savtx", "afkt"], "c": ["coll", "comm", "t", "p", "com", "rc", "a", "o", "cont", "ce", "cb", "f", "dc", "m", "abc", "co", "ac", "conv", "etc", "ct", "d", "enc", "gc", "call", "con", "cs", "bc", "cu", "cd", "cv", "comments", "cl", "ec", "cmp", "C", "ctx", "chain", "lc", "cm", "sc", "cf", "ch", "g", "ci", "anc", "config", "mc", "pc", "cam", "conf", "tc", "cache", "cr", "cal", "can", "nc", "cc", "b", "v", "l", "ca", "cp", "lib", "fc", "comp", "xc"], "ret": ["gt", "fun", "resp", "t", "re", "out", "pas", "print", "et", "mail", "back", "ref", "rets", "Return", "rem", "Ret", "val", "def", "ext", "eth", "mel", "tr", "result", "mt", "ft", "rt", "res", "alt", "nt", "RET", "ll", "elt", "urn", "att", "flag", "fit"], "i": ["bi", "ij", "p", "phi", "is", "\u0438", "ic", "it", "ri", "si", "me", "index", "di", "o", "ai", "io", "f", "xi", "m", "ix", "go", "y", "ims", "ji", "multi", "im", "zi", "key", "x", "id", " ii", "sim", "ind", "gi", "info", "span", "I", "ami", "qi", "ki", "ini", "j", "ip", "cli", "ti", "status", "batch", "iu", "li", "q", "ui", "ex", "fi", "oi", "in", "gl", "ci", "mi", "ii", "slice", "to", "pi", "l", "v", "list", "uri", "chain"], "new_frame_size": ["new_frame_to", "new_frame2number", "new_window_number", "new_window_to", "new_frame_Size", "new_window_Size", "new_frame_set", "new_frame_scale", "new_frame_name", "new_frame_count", "new_frame2size", "new_Frame_set", "new_frame_SIZE", "new_window_len", "new_window_count", "new_Frame_size", "new_window_size", "new_window_SIZE", "new_window_name", "new_Frame_scale", "new_frame2count", "new_frame_len", "new_frame_number"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n", "idx": 20548, "substitutes": {"opaque": [" opaques", "obosit", "oplaque", "paques", "opesc", " opque", " opatile", " oposit", "Opatile", "obatile", "oplatile", "obaque", "Opaque", "obesc", "opaques", "paque", "Opaques", "pque", " opesc", "patile", "oposit", "Opque", "opque", "oplosit", "opatile", "oplesc"], "addr": ["gt", "name", " address", "dh", "tag", "alloc", "index", "ref", "go", "ix", "offset", "add", "hash", "act", "src", "loc", "arg", "id", "tx", "data", "node", "var", "coord", "ord", "ctx", "ptr", "align", "res", "map", "Address", "adr", "at", "ad", "bound", "dr", "sp", "address", "obj", "pos", "len", "store", "to", "pad", "sha"], "size": ["n", "name", "state", "start", "index", "h", "SIZE", "length", "offset", "d", "count", "id", "args", "data", "ize", "num", " count", " len", "shape", "mem", "Size", "sp", "address", "len", "l", "type"], "s": ["n", "p", "t", "is", "a", "r", "o", "os", "set", "h", "ss", "ns", "iss", "ps", "i", "sts", "fs", "gs", "rs", "c", "ds", "j", "se", "spec", "ls", "q", "sv", "hs", "ess", "S", "js", "g", "es", "sq", "ts", "als", "qs", "less", "sb", "b"]}}
{"project": "qemu", "commit_id": "465f2fedd262cbdcbfc92c181660cf85e5029515", "target": 0, "func": "static int cryptodev_builtin_create_cipher_session(\n\n                    CryptoDevBackendBuiltin *builtin,\n\n                    CryptoDevBackendSymSessionInfo *sess_info,\n\n                    Error **errp)\n\n{\n\n    int algo;\n\n    int mode;\n\n    QCryptoCipher *cipher;\n\n    int index;\n\n    CryptoDevBackendBuiltinSession *sess;\n\n\n\n    if (sess_info->op_type != VIRTIO_CRYPTO_SYM_OP_CIPHER) {\n\n        error_setg(errp, \"Unsupported optype :%u\", sess_info->op_type);\n\n        return -1;\n\n    }\n\n\n\n    index = cryptodev_builtin_get_unused_session_index(builtin);\n\n    if (index < 0) {\n\n        error_setg(errp, \"Total number of sessions created exceeds %u\",\n\n                  MAX_NUM_SESSIONS);\n\n        return -1;\n\n    }\n\n\n\n    switch (sess_info->cipher_alg) {\n\n    case VIRTIO_CRYPTO_CIPHER_AES_ECB:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CBC:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CBC;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CTR:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CTR;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_DES_ECB:\n\n        algo = QCRYPTO_CIPHER_ALG_DES_RFB;\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher alg :%u\",\n\n                   sess_info->cipher_alg);\n\n        return -1;\n\n    }\n\n\n\n    cipher = qcrypto_cipher_new(algo, mode,\n\n                               sess_info->cipher_key,\n\n                               sess_info->key_len,\n\n                               errp);\n\n    if (!cipher) {\n\n        return -1;\n\n    }\n\n\n\n    sess = g_new0(CryptoDevBackendBuiltinSession, 1);\n\n    sess->cipher = cipher;\n\n    sess->direction = sess_info->direction;\n\n    sess->type = sess_info->op_type;\n\n\n\n    builtin->sessions[index] = sess;\n\n\n\n    return index;\n\n}\n", "idx": 20549, "substitutes": {"builtin": ["linkedin", "builtIn", "buildins", "buildIn", "Builtin", "linkedas", "BuiltIn", " builtins", " builtas", "uiltIn", "builtas", "linkedIN", "linkedIn", "uiltin", "builtins", "uiltIN", "buildin", "Builtins", " builtIn", "builtIN", " builtIN", "uiltas"], "sess_info": ["sist_http", "sessetyhttp", "sess_now", "session_no", "sessjsuccess", "scess___try", "ssession_info", "ssession2info", "sessobjinf", "sess___status", "sessjinf", "senge_inf", "sess___info", "sess_inf", "sessetyuser", "sess___inf", "sess_history", "session_INFO", "sess_fo", "semptjinf", "sess_ready", "sess1Info", "semptjinfo", "sessobjinfo", "scess_inf", "sess_init", "sessjinfo", "sengeetynow", "sessjready", "sess___try", "ssession2inf", "session1Info", "senge_info", "sessjreport", "sengeetyuser", "sempt_info", "sess2inf", "senge_now", "sess___fo", "sessjhistory", "sess_no", "ssession_inf", "sessetyinfo", "session1INFO", "sengeetyinf", "ssession2init", "sist_INFO", "sess2init", "sess_http", "sess_Info", "ssession_success", "scess_try", "sessetynow", "scess_status", "ssession_ready", "sess2info", "sess2Info", "scess___info", "sess_status", "session_Info", "sess1INFO", "sess2INFO", "sess_INFO", "semptjreport", "sess_try", "sess2fo", "sess_report", "sempt_report", "session_info", "semptjhistory", "sessobjuser", "sess1info", "scess___inf", "session1no", "sempt_history", "session1info", "sessetyINFO", "sist_info", "sess_user", "sist_inf", "scess_info", "sess2no", "sess_success", "sempt_inf", "ssession_init", "ssession2fo", "sess___init", "scess___status", "senge_user", "sessobjnow", "sessetyinf", "ssession_fo", "sess1no", "sengeetyinfo"], "errp": ["outerpid", "errP", "confping", "excP", "errpa", "ierp", "iterP", "errorps", "errpid", "ererg", "iterp", "errpe", "errpb", "excpe", "ierpb", "eorp", "outerP", "testp", "nerpb", "errping", "derpa", "nerps", "errorping", " errps", "derpid", "diep", "usrpoint", "errps", "errpkg", " errP", "testpp", "errpr", "eorpb", "ererp", " errpp", "timerg", "usrpb", "testping", "errorP", "confP", "ererps", "excpid", "diepoint", "outerp", "confps", "ererpa", "eorpo", "timerp", "eorpoint", "errg", "derpkg", "usrpo", "nerpkg", "errpp", "testP", "timerps", "confp", " errpid", "ierpkg", "errpo", "errpoint", " errpr", "outerpr", "derpb", "nerp", "ierps", "derp", "usrp", " errping", "derpr", "errorpe", "diepo", "iterpp", "diepb", "derps", "errorpid", "derg", " errpe", "errorp", "excp", "timerpa", "derP", "iterping"], "algo": ["calready", "palgo", "albo", "stalca", "qualko", "adalGO", "calvo", "stalgorithm", "alca", "mailvo", "ralko", "alango", "palno", "algor", "calbo", "qualvo", "almo", "Algo", "aladdin", "mailbo", "AlGO", "mailgorithm", " already", "balvo", "halvo", "stalGO", "mailca", "taladdin", "stalgo", "stalgem", "qualga", " alno", "aligo", "adalango", "alionna", "alonna", "ALgorithm", "halgorithm", "talonna", "unalgo", "halGO", "alvo", "calgorithm", "balgorithm", "talcos", " almo", "adalgem", "unalgorithm", " algorithm", "qualgo", " alvo", " alGO", "talgo", "alko", "halgo", "unalready", "Alno", "palgorithm", "algem", "unalcos", "ALgo", "alno", "aliaddin", "palGO", "adalgo", "unalonna", "halango", "alga", "unalvo", " algor", "ralvo", "calgo", "algorithm", "stalvo", "alcos", "ALGO", "alicos", "palmo", "palgor", "ralga", "balko", "halca", "stalango", "unaladdin", "alGO", "balga", "balgo", "already", "ALgor", "mailgo", "halgem", "balbo", "Almo", "ralgo"], "mode": ["name", "loop", "state", "message", "model", "role", "kind", "depth", "me", "mm", "pose", "device", "m", "offset", "scale", "mid", "format", "driver", "mission", "method", "display", "style", "mask", "timeout", "dirty", "dim", "operator", "MODE", "size", "md", "language", "mate", "show", "status", "version", "shift", "purpose", "module", "position", "pe", "component", "location", "mit", "stage", "direction", "sequence", "error", "feature", "config", "oe", "zero", "ode", "Mode", "mod", "metadata", "success", "network", "distance", "type"], "cipher": [" cip", "chipher", " ciph", "coiph", "chiper", "ciph", "cip", "coipher", "chip", "coip", " ciper", "coiper", "chiph", "ciper"], "index": ["name", "Index", "loop", "search", "context", "capacity", "set", "list", "connect", "check", "offset", "init", "order", "fee", "count", "key", "loc", "x", "id", "ind", "i", "empty", "timeout", "level", "info", "row", "max", "axis", "node", "size", "dim", "close", "limit", "j", "lock", "version", "height", "min", "num", "position", "open", "sort", "find", "update", "instance", "zero", "block", "address", "pos", "len", "iso", "slice", "success", "alias"], "sess": ["wvc", "wess", "wsession", "ssession", "wession", "sssession", " session", " svc", "svc", "ssvc", "session", " ssession", "ssess"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n", "idx": 20553, "substitutes": {"entry": ["element", "end", "office", "it", "escape", "entity", "comment", "cue", "r", "index", "list", "set", "record", "field", "check", "window", "member", "attribute", "add", "Entry", "item", "ie", "key", "pair", "inter", "def", "e", "row", "RY", "query", "ary", "se", "ment", "enter", "see", "result", "ent", "cell", "event", "link", "child", "server", "password", "page", "try", "import", "match", "nt", "command", "inner", "ence", "ace", "obj", "insert", "ew", "next", "ry", "ue", "instance"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 20562, "substitutes": {"ahci": ["hacor", "herecci", "hereki", " ahcu", "ahcia", "amci", " ahpi", " ahcci", "hci", "ahli", "haci", "akhce", " ahco", "hpi", "hco", "hereci", " ahlink", "amce", "ehli", "akhcu", "ahlink", "ehco", "ohcor", "achlink", "ohcci", "achci", "ahdi", "hcci", "ehdi", "hali", "ahce", "ehcia", "akhdi", "akhlink", "hadi", "amdi", "ehki", "ohci", "ohdi", "herecia", "akhci", "ahpi", "ahki", "ohki", "achcu", "achcci", "ohli", "ahco", "ehcci", "ehcor", "akhcci", "ehci", "ehpi", "ohcia", "ahcci", "ahcor", "ehce", "ahcu", "amcci"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static int writev_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector qiov;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&writev_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_writev(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}", "idx": 20576, "substitutes": {"argc": ["argsv", "argumentp", "catm", " argm", "argC", "argumentcs", "catct", "arglc", " argC", "catc", "argct", " argp", "Argc", "aglc", "argp", "Argp", "argcs", "argl", "catC", "argsC", "argsl", "argumentl", "argumentcount", "Argcount", "agc", "argcount", " argcs", "agl", "argumentc", " argcount", " argl", "argumentct", "argsm", " argct", "argm", "agcs", " arglc", "Argl", "argsc", "argsct", "argumentlc", "argumentv"], "argv": ["argsv", "argumentp", " argvs", "argargs", "arglv", " argb", "argumentvs", " argp", "argf", "Argc", "agv", "argsvs", "argp", " argh", "Argp", "argsp", "argumentb", "agh", "argsh", "argsf", "Argv", "argvs", "argh", "agb", "agc", "agargs", "argslv", "argumentargs", "tagf", "tagc", " argargs", "argumentc", "Argf", "argumentf", "taglv", " arglv", "tagv", " argf", "argb", "argsc", "agp", "argumentv"], "t1": ["p0", "T1", "m3", "t01", "m2", "p3", "p1", "T01", "l01", "m1", " t01", "t0", " t0", "t3", "l2", "m0", "l3", "p2", "T2", "T3", "T0", " t3", "l1"], "t2": ["time2", "p0", "t02", "T1", "T6", "m2", "c6", "p1", " t4", "c2", "timetwo", "m1", "T02", "c1", "t6", "t0", " t0", " t02", " t6", "t3", "c3", "m0", "time1", "ttwo", "time02", "p2", "T4", "T2", "T3", "Ttwo", "T0", "t4", " t3", "p3", "m4", " ttwo"], "c": ["n", "t", "p", "rc", "vc", "o", "r", "ce", "color", "off", "f", "h", "dc", "m", "y", "abc", "co", "ac", "gc", "ct", "count", "unc", "con", "code", "bc", "cs", "i", "ec", "cur", "cmp", "cut", " C", "z", "C", "ctx", "k", "lc", " count", "sc", "ch", "g", "tc", "u", "cache", "nc", "b", "l", "v", "cc", "fc", "cp"], "cnt": [" ccount", "cct", "ncount", "acnt", "Cnton", "ncnt", "Cnc", "Cnt", "count", "account", "lcount", "lcnt", "ncNT", " cct", "Ccount", "ncnton", "acount", "CNT", "lcnc", "ccount", " count", "Count", " cnton", "cnton", " cNT", " cnc", "cnc", "acct", "Cct", "lcNT", "gnt", "gNT", "cNT", "gount"], "buf": ["out", "rb", "txt", "alloc", "cb", "uffer", "ref", "h", "window", "err", "gz", "Buff", "pkg", "bs", "CB", "uf", "bc", "Buffer", "layout", "cv", "row", "data", "FB", "vec", "batch", "nb", "CV", "result", "ptr", "uffy", "br", "tmp", "queue", "wb", "seq", "buffer", "box", "iter", "mem", "fd", "buff", "block", "cmd", "pb", "bt", "cache", "BU", "np", "b", "v", "cp", "font"], "offset": ["oid", "et", "length", "value", "count", "loc", "timeout", "reset", "xy", "no", "ff", "tmp", "rot", "command", "zero", "pos", "pointer", "client", "point", "padding", "type", "start", "o", "ind", "info", "data", "size", "base", "op", "xff", "frequency", "entry", "location", "prefix", "time", "it", "bf", "number", "Offset", "ref", "f", "total", "tz", "image", "style", "layout", "slot", "position", "buffer", "sp", "len", "iso", "to", "alias", "p", "end", "out", "org", "index", "set", " offsets", "off", "window", "OFF", "attribute", "transform", "id", "online", "eta", "shift", "seek", "addr", "error", "orbit", "address", "pad", "origin"], "nr_iov": ["tnMemliv", "nr_liv", "nb_ovi", "sr_iour", "nrMemliv", "nrxliv", "nrMemiv", "tnMemiov", "nrMemiour", "tnMemiour", "nrxij", "tn_iour", "nb_iov", "nb_ij", "nrxovi", "nr_voice", "nrMemiov", "nb_liv", "tn_iv", "sr_ovi", "nr_iour", "tn_iov", "sr_iov", "nr_ij", "sr_voice", "nr_iv", "nrxiov", "nr_ovi", "tn_liv", "tnMemiv"], "qiov": ["qiv", "chiov", "qqiev", "ziu", "sqiv", "quovi", "quiu", "sqiov", " qij", "eqiour", "quiov", "sqiev", " qiv", " qiev", "chvr", "sqvoice", "eqiov", "qvoice", "qiu", "chiour", "requiov", "qij", "qqvoice", "queryiev", "requovi", "queryiour", " qiour", "queryiov", " qvoice", "quiour", "qiour", "eqiev", "quiev", "qiev", "qvr", "zovi", "qqiv", "requij", "chiev", "qovi", "eqij", "quvr", "ziov", "zij", "qqiov", "requiu", "quij", "queryvr"], "optind": ["opindex", "catIND", "optPtr", "opInd", "optionind", " optstart", "optimPtr", "optInd", " optindex", "optIND", "OptIND", "optioninder", " optPtr", "optionIND", "optimind", "verbind", "optiminder", "optionindex", "optinder", "optimIND", "optindex", "optimstart", "Optind", "verind", "opIND", "Optstart", "optionPtr", "catindex", "optimbind", "Optbind", "verIND", " optinder", "Optindex", " optInd", "optstart", " optIND", "catInd", "verindex", "optbind", "optimindex", "opind", "catind", "optionInd"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++) {\n\n        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n    }\n\n}\n", "idx": 20581, "substitutes": {"dst": ["bst", "dasrc", "jest", "dlt", "dssrc", " dlt", "dbr", "daST", " dsrc", "daist", " dbr", " dsts", " drc", "pdrc", "Dbr", "Dlt", "dest", "Dbl", "pdest", "pdst", "jrc", " dist", "dust", "dsrc", " dnd", "daust", " dST", "dsust", "pdbr", "pdbl", "pdnd", "darc", "dST", "Dnd", " dbl", "bsrc", "jnd", "jst", "Dst", "dnd", "dast", "blt", "dbl", "Dsrc", "Dist", "dsST", "Drc", "DST", "bsts", "drc", "Dsts", " dust", " dest", "dist", "dsst", "dsts"], "i": ["is", "ic", "ski", "m", "ims", " I", "im", "span", "I", "batch", "ti", "cli", "asi", "ui", " bi", "v", " err", "uri", "chain", "uli", "\u0438", "si", "me", "ai", "ix", "ji", "x", " ii", "e", "sim", "ind", "gi", " ti", "info", "ami", "status", "oi", "sequence", " pi", "hi", "bi", "phi", "t", "ogi", "it", "iq", "ri", "xi", "y", "multi", "zi", "iri", "ei", "qi", "ini", "ip", "li", "ci", "mi", "ii", "esi", "pi", "ish", "yi", "ij", "p", "di", "index", "iu", "init", "id", "ki", "j", "ms", "json", " multi"]}}
{"project": "FFmpeg", "commit_id": "6fd00e9dd94ac3aecf4fa14ca6fa23c395215ac9", "target": 1, "func": "static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n\n                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],\n\n                      GetBitContext *gb)\n\n{\n\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;\n\n    int comment_len;\n\n\n\n    skip_bits(gb, 2);  // object_type\n\n\n\n    sampling_index = get_bits(gb, 4);\n\n    if (m4ac->sampling_index != sampling_index)\n\n        av_log(avctx, AV_LOG_WARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n\n\n\n    align_get_bits(gb);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n\n\n\n    skip_bits_long(gb, comment_len);\n\n    return 0;\n", "idx": 20600, "substitutes": {"avctx": [" avjac", "avcmp", "aftx", "avcc", "avcontext", "servjac", "servctx", "avecmp", "AVcmp", "avtx", "servtx", "avecontext", " avcmp", "avjac", "afcontext", "AVcontext", "afctx", "AVcc", "avectx", "avecc", "afjac", "AVctx", " avcontext", " avtx", " avcc", "servcontext"], "m4ac": ["m4aj", "m256sac", "m2ac", "mfouracc", "mfoursac", "m5acc", "m6AC", "m6ac", " m4acc", "m4acc", "m4am", "smfouraj", "m4sac", "m5am", "smfouracc", "m256acc", " m4AC", "m2acc", "m5AC", "sm4ac", "m5ac", "smfoursac", "m6acc", "m2sac", "mfourac", "m2AC", "mfouraj", "m256ac", "sm4aj", " m4am", "m2aj", " m2AC", " m2ac", "m6am", "smfourac", " m2am", "sm4sac", "sm4acc", "m256aj", " m2acc", "m2am", "m4AC"], "new_che_pos": ["new_chelpos", "new_chemmrot", "new_eifmos", "new_ei_neg", "new_chetxaddr", "new_ch_loc", "new_chepttrans", "new_codtxpos", "new_chemmpos", "new_che2loc", "new_chem_pos", "new_culdpo", "new_chetxto", "new_culdto", "new_che2position", "new_che_loc", "new_che2os", "new_che_rot", "new_ch_ds", "new_cheldpo", "new_cu_addr", "new_cuxmot", "new_chellneg", "new_cheekpo", "new_che_po", "new_ch_POS", "new_culdposition", "new_chexpo", "new_cu_to", "new_culdps", "new_cheldloc", "new_cheptpos", "new_chetxpos", "new_chellPOS", "new_ei_mos", "new_che_addr", "new_chefpos", "new_che_pat", "new_che2pos", "new_cheldneg", "new_che2pat", "new_ei_POS", "new_che_mos", "new_che_to", "new_chefneg", "new_cheldmos", "new_chetxrot", "new_codtxpo", "new_chelds", "new_che_ds", "new_chexpos", "new_chemmpr", "new_cheldtrans", "new_cheekto", "new_chemmPOS", "new_che_pr", "new_cheldto", "new_chelmot", "new_che_mot", "new_eifpos", "new_chellmos", "new_cheldps", "new_culdpos", "new_cuxpo", "new_chemldpos", "new_eifneg", "new_chellpos", "new_cheldaddr", "new_chemmloc", "new_codtxpr", "new_eifPOS", "new_che2ds", "new_chetxpr", "new_cod_po", "new_chexrot", "new_cheekaddr", "new_chem_loc", "new_chemmpo", "new_cheldpos", "new_chefrot", "new_cheldposition", "new_cu_po", "new_che_POS", "new_chexpr", "new_che_trans", "new_chefmos", "new_chexmot", "new_culdaddr", "new_chemldloc", "new_ch_Pos", "new_che2ps", "new_cheptloc", "new_cod_pos", "new_ei_pos", "new_cheldPOS", "new_cu_ps", "new_chefloc", "new_che2Pos", "new_chelneg", "new_che_Pos", "new_ch_os", "new_chem_trans", "new_chetxpo", "new_cu_pos", "new_che_os", "new_cod_pr", "new_che_neg", "new_codtxrot", "new_che_ps", "new_cod_rot", "new_chem_po", "new_chelPos", "new_che_position", "new_cuxpos", "new_cheptpo", "new_chemldpo", "new_cheekpos", "new_cu_neg", "new_chemldtrans", "new_chefPOS", "new_chelpo", "new_cuxneg", "new_ch_rot", "new_cu_position", "new_chexneg", "new_cu_mot", "new_ch_pat", "new_ch_pos"], "gb": ["gt", "csv", "gem", "ogg", "rb", "gpu", "gif", "eb", "sys", "py", "bf", "tg", "cb", "bsp", "jpg", "hub", "gm", "gam", "goo", "gc", "gz", "google", "gd", "ruby", "mb", "bs", "rg", "erb", "eg", "vg", "git", "gs", "vm", "args", "gnu", "cv", "xy", "bytes", "fb", "nb", "img", "ctx", "raw", "gin", "bg", "html", "yg", "wb", "db", "hog", "gg", "g", "kb", "pb", "bt", "Gb", "pg", "sg", "json", "GB", "sb", "gh", "cp", "cfg", "bb", "wm"], "num_front": ["number_front", "number_side", "numllface", "num_fd", "orig_fr", "num88side", "num88fore", "num___fd", "origllfd", "numllfront", " num_left", "num___front", "num___aft", "numllfd", "origllfront", "origllface", "num___face", "num___back", "num_left", "orig_face", "num_fore", "orig_front", "num88back", "num_aft", "num___fr", "num___left", "num_fr", "num88front", "origllfr", "orig_fd", "number_back", "number_fore", "numllfr", " num_aft", "num_face"], "num_side": ["num_bottom", "num88side", "num88small", "dev_below", "num_main", "num__side", "Num_below", "dev88small", "num_Side", "dev88side", "num__back", "num__Side", "dev88back", "num88below", "dev_small", "nb_main", "dev_side", "num67side", "Num_side", "num_small", "num88back", "num67back", "num67small", "num67below", "nb_back", "dev_back", "num__below", "num_below", "nb_side", "Num_back", "dev88below", "Num_Side", "nb_bottom"], "num_back": ["NUM___load", "num64place", "num42backer", "num_bottom", "num68back", "num64back", "num42back", "num__bottom", "num_place", "num68front", "num64forward", "multi_back", "NUM___front", "num_Back", " num_bottom", "NUM_front", "multi64back", "num___front", "multi_backer", "num___Back", "num_forward", "NUM_back", "num__back", "multi64backer", "num68bottom", "num_load", "num42forward", "NUM_load", "multi64forward", "multi64place", "num___back", "num64backer", "num42place", "NUM___back", "num__BACK", "num0back", "num0place", "num0forward", "num_backer", "multi_forward", "num0backer", "NUM_Back", "num_BACK", "num__front", "num___load", "num68BACK", "multi_place", "NUM___Back", " num_BACK"], "num_lfe": ["num_lifee", "num_cfa", "num_lva", "num_olfE", "num_ffE", "num_ffes", "num_ffed", "num_lfee", "num_lifes", "num_alfes", "num_lve", "num_alfE", "num_lfa", "num_lfed", "num_olfe", "num_ffa", "num_lifE", "num_life", "num_olfee", "num_lfes", "num_lved", "num_lfE", "num_ffee", "num_alfee", "num_cfe", "num_cfed", "num_alfe", "num_lves", "num_cfes", "num_ffe", "num_olfes"], "num_assoc_data": ["num_assoc2DATA", "num_assoc_DATA", "num_associngdata", "num_associngDATA", "num_assign_size", "num_assoc_key", "num_assoc_count", "num_assocmata", "num_associngkey", "num_assign_data", "num_assoc_size", "num_assoc2len", "num_assoc2count", "num_assOC_size", "num_assoc2data", "num_assoc_ata", "num_assign_DATA", "num_assocmsize", "num_assign_ata", "num_assOC_len", "num_assocmdata", "num_assign_key", "num_assOC_data", "num_assoc2size", "num_assoc_len", "num_assoc2key", "num_assOC_count"], "num_cc": [" num_cf", "num67cca", "num_CC", "num67cc", "num_cca", "num_fc", "num_ca", "num67cf", " num_CC", " num_cca", " num_cs", " num_ca", "num67fc", " num_fc", "num_cf", "num_cs"], "sampling_index": ["sampping_index", "sampling___offset", "sampling2data", "sampling_num", "sampling_ind", "sampler_link", "samplingingoffset", "sampling___ind", "sampling_no", "sampling_link", "samplingetypoint", "samisonetynum", "samison_offset", "sampping_ind", "samison_num", "sampling_offset", "samisonetyindex", "samisonetyoffset", "sampling_id", "sampling_point", "sampler_no", "sampling2link", "samison_index", "samplingingindex", "sampler_ind", "sampling___index", "sampler_data", "samplingingind", "samplingingno", "sampling_valid", "samison_point", "sampping_valid", "sampler_offset", "sampling2index", "samplingetyindex", "sampping_id", "sampling_data", "sampling2ind", "samplingetynum", "sampling___no", "sampler_index", "samisonetypoint", "samplingetyoffset"], "comment_len": ["slot_pos", "commentationpos", "comment6pos", "comment_set", "comment_pos", "comment_seq", "slot_seq", "slotationlen", "slot_len", "slotationpos", "commentationlen", "comment6set", "comment6seq", "commentationset", "slotationseq", "slotationset", "comment6len", "commentationseq", "slot_set"]}}
{"project": "FFmpeg", "commit_id": "5257743aee0c3982f0079e6553aabc6aa39401d2", "target": 1, "func": "static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,\n\n                               int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    WSSndContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n\n\n    int in_size, out_size, ret;\n\n    int sample = 128;\n\n    uint8_t *samples;\n\n    uint8_t *samples_end;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    out_size = AV_RL16(&buf[0]);\n\n    in_size  = AV_RL16(&buf[2]);\n\n    buf += 4;\n\n\n\n    if (in_size > buf_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame data is larger than input buffer\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* get output buffer */\n\n    s->frame.nb_samples = out_size;\n\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples     = s->frame.data[0];\n\n    samples_end = samples + out_size;\n\n\n\n    if (in_size == out_size) {\n\n        memcpy(samples, buf, out_size);\n\n        *got_frame_ptr   = 1;\n\n        *(AVFrame *)data = s->frame;\n\n        return buf_size;\n\n    }\n\n\n\n    while (samples < samples_end && buf - avpkt->data < buf_size) {\n\n        int code, smp, size;\n\n        uint8_t count;\n\n        code  = *buf >> 6;\n\n        count = *buf & 0x3F;\n\n        buf++;\n\n\n\n        /* make sure we don't write past the output buffer */\n\n        switch (code) {\n\n        case 0:  smp = 4;                              break;\n\n        case 1:  smp = 2;                              break;\n\n        case 2:  smp = (count & 0x20) ? 1 : count + 1; break;\n\n        default: smp = count + 1;                      break;\n\n        }\n\n        if (samples_end - samples < smp)\n\n            break;\n\n\n\n        /* make sure we don't read past the input buffer */\n\n        size = ((code == 2 && (count & 0x20)) || code == 3) ? 0 : count + 1;\n\n        if ((buf - avpkt->data) + size > buf_size)\n\n            break;\n\n\n\n        switch (code) {\n\n        case 0: /* ADPCM 2-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ( code       & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 2) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 4) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample +=  (code >> 6)        - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 1: /* ADPCM 4-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ws_adpcm_4bit[code & 0xF];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ws_adpcm_4bit[code >> 4];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 2: /* no compression */\n\n            if (count & 0x20) { /* big delta */\n\n                int8_t t;\n\n                t = count;\n\n                t <<= 3;\n\n                sample += t >> 3;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            } else { /* copy */\n\n                memcpy(samples, buf, smp);\n\n                samples += smp;\n\n                buf     += smp;\n\n                sample = buf[-1];\n\n            }\n\n            break;\n\n        default: /* run */\n\n            memset(samples, sample, smp);\n\n            samples += smp;\n\n        }\n\n    }\n\n\n\n    s->frame.nb_samples = samples - s->frame.data[0];\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = s->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20606, "substitutes": {"avctx": ["avetc", " avjac", "wavctx", " avcv", "aftc", "avtc", "avertc", "avcmp", "awcontext", "aftx", "abcmp", "avcontext", "avepkg", "avcv", "avecv", "avecmp", "abtx", "afpkg", " avpkg", "avtx", "ajtx", "avectl", "avkl", "avctl", "afkl", "averctx", "wavpkg", "avetx", "awcmp", "avecontext", " avcmp", "avejac", "avjac", "afcontext", "afcv", "ajkl", "afcmp", "avpkg", "afctx", " avkl", "abctx", "awctx", "awtx", "averctl", "ajctx", "ajcontext", "wavcontext", "afctl", "avectx", "afjac", " avctl", " avcontext", " avtx", "wavtx", "averjac", "abcontext"], "data": ["message", "this", "m", "length", "value", "rel", "multiple", "format", "text", "meta", "batch", "video", "map", "Data", "action", "next", "v", "file", "padding", "type", "name", "done", "resp", "response", "a", "o", "output", "device", "package", "results", "empty", "bytes", "body", "values", "dat", "self", "area", "sequence", "bin", "flags", "pieces", "frame", "f", "d", "image", "def", "mu", "str", "extra", "raw", "buffer", "cache", "to", "history", "p", "bits", "window", "offset", "read", "ata", "id", "content", "result", "DATA", "doc", "block", " DATA", "options", "input", "pad", "da", "w"], "got_frame_ptr": ["got_frame__pos", "got_frames__ptr", "got_frame2ptr", "got_frames_pos", "got_window_pointer", "got_window_obj", "got_frame2pos", "got_frame__ptr", "got_frameingpos", "got_frames__loc", "got_frame2loc", "got_frame__pointer", "got_window2ptr", "got_frame_pos", "got_frame__loc", "got_frames__pointer", "got_frames_loc", "got_frame_Ptr", "got_frame2pointer", "got_frame2Ptr", "got_frameingloc", "got_window2pointer", "got_frame_pointer", "got_window2Ptr", "got_frameingptr", "got_frame_obj", "got_window2obj", "got_frame_loc", "got_frameingpointer", "got_frames_ptr", "got_frame2obj", "got_frames_pointer", "got_frames__pos", "got_window_Ptr", "got_window_ptr"], "avpkt": ["avpmit", "avcpcht", "avckg", "avjpacket", "wavpcht", "avepacket", "avopkg", "wavpkt", "avjpkt", "avPct", "avPacket", "wavppnt", "wavppacket", "avPkat", "avopkt", " avPkt", "avopck", " avpacket", "avpacket", "avppcht", "avepck", "avdkt", "avcpacket", "avvpkt", "avppnt", "avpck", "avppmit", " avPct", " avPkat", "avrespnt", "avvpacket", "wavppcht", "avckt", "avcacket", "avevpck", "avvpkg", "avjpmit", "wavpacket", "avepkg", "avppct", "avcck", "avevpkt", "avPmit", "avevpkg", "wavppkt", "avevpacket", "avcpkt", " avpct", "avdmit", " avPmit", "avepkt", "avtkt", " avpkat", "avpcht", "avvpck", "avrespkt", "avjpkat", "avpkat", "avdacket", "avtmit", " avpmit", "avdkat", "avppkt", "avtct", "wavpnt", "avcpnt", "avrespacket", "avopacket", " avPacket", "avrespcht", "avppacket", "avpkg", "avpct", "avtacket", "avPkt", "avpnt"], "s": ["n", "p", "is", "sys", "a", "r", "os", "f", "h", "m", "ss", "ns", "ims", "conv", "stats", "d", "bs", "ps", "ops", "i", "cs", "sts", "rs", "gs", "fs", "c", "ds", "j", "ctx", "spec", "ls", "full", "ms", "sv", "ats", "hs", "S", "js", "ess", "g", "es", "its", "sq", "ts", "ins", "als", "qs", "less", "b", "l", "v", "w"], "buf": ["msg", "cont", "desc", "foo", "err", "progress", "late", "uf", "cur", "batch", "lim", "rw", "ff", "br", "tmp", "wb", "map", "BU", "emb", "pos", "gen", "next", "port", "v", "bl", "order", "bs", "Buffer", "bytes", "vec", "xff", "num", "seq", "db", "mem", "cmd", "b", "font", "ref", "aw", "pkg", "cv", "mu", "tx", "good", "fb", "limit", "proc", "ctx", "ptr", "buffer", "box", "buff", "pg", "cache", "len", "rb", "cap", "txt", "alloc", "cb", "off", "window", "offset", "Buff", "arr", "bar", "bc", "keep", "img", "prop", "shift", "nm", "queue", "iter", "doc", "pb", "block", "bp", "ctr", "text"], "in_size": ["in_score", "out_status", "in5Size", "out_Size", "out_global", "out_scale", "in_status", "in67Size", " out_Size", "inlaysize", "in_count", "in5status", "out_score", "in_SIZE", "in___device", "in_scale", "in67size", "out_SIZE", "in5scale", "in___Size", "in_Size", "in5size", "inlaySize", " out___count", "inlayglobal", "in___size", "in67scale", "inlayscore", "in_global", "in_device", " out_count", "in___count", " out___Size", " out___size", " out_device", " out___device", "in67status"], "out_size": ["outMemSize", " out_name", "in_SIZE", "outablenum", "out_SIZE", "oablesize", "outptdepth", "o_score", "o_length", "outMemstore", "outjwidth", "out_num", "out_name", "outptstore", "oablescore", " out_Size", "outJformat", "out_depth", " out_SIZE", "outJsize", "outptSize", "in_store", "oablenum", "out_score", "oablelength", "outjsize", "outjlength", "in_depth", "outMemsize", " out_width", " out_format", "out_Size", "out_store", "out_width", "o_num", "outMemdepth", "o_size", "in_Size", "out_format", " out_length", "outJSIZE", "out_length", "outablesize", "outablelength", "outptsize", "outablescore"], "ret": ["gt", "fun", "resp", "re", "out", "bad", "txt", "it", "rev", "det", "red", "cont", "ref", "back", "f", "rets", "rem", "err", "Ret", "tail", "val", "arr", "empty", "reset", "tr", "j", "status", "result", "repl", "mt", "deg", "rt", "tmp", "res", "alt", "buffer", "reg", "mem", "nt", "RET", "zero", "len", "elt", "flag", "got", "vt"], "samples": ["timesounds", "jsamples", "samps", "ssamples", " sources", "slides", "slamples", "nsonents", "tsamps", "Samps", "ssample", "nsamples", " sores", " samps", " samp", " sides", "slamp", "tsample", "tsources", "timesonents", "jsample", "Sources", "nsamps", "sides", "slamps", "ssamps", "Samp", "timesamps", "Samples", "Sides", "jsamp", "tsamples", "sores", "jsamps", "samp", "nsounds", "Sounds", "timesamples", " sample", "Sores", "sonents", "Sonents", "sample", "ssores", "sources", "sounds", "Sample"], "samples_end": ["samples_ended", "samp_ends", "samples_len", "samp_ended", "samples_ends", "samps_end", "samp_last", "samples_start", "sairs_len", "samps_to", "samples_to", "samps_start", "samples_ending", "samp_end", "samples_last", "samp_start", "sairs_ending", "sairs_end"], "code": ["name", "time", "magic", "rc", "age", "frame", "cb", "ce", "coe", "ack", "index", "Code", "check", "go", "length", "change", "ct", "ie", "key", "call", "text", "id", "note", "cd", "close", "test", "c", "ose", "ec", "cmp", "status", "cod", "mode", "event", "num", "cond", "component", "ch", "sequence", "error", "action", "command", "ode", "cycle", "cmd", "cache", "nc", "cc", "line", "comp", "second", "counter", "chain", "type"], "smp": ["aresmp", "mysclip", "tspm", "Smp", "atsmp", "insmp", "ccp", "fsmp", "inscmp", "tscmp", " samp", "spm", "Spm", "scp", "sclip", " spm", "Somp", "fscmp", "atspm", "ccmp", "atscmp", "sMP", "fswp", "areswp", "gsamp", "stsmp", "inscp", "tscp", " scmp", "gsomp", "camp", "gsmp", "cmp", "Scmp", "atsamp", "somp", "Scp", " spsc", "arespsc", "mysmp", "gsMP", "Samp", "tsmp", "stspm", " swp", " somp", "spsc", "stscmp", "samp", "stscp", "arescmp", "insclip", "SMP", " sclip", "fspsc", "scmp", " scp", "swp", "myscp", " sMP", "myscmp"], "size": ["n", "name", "use", "end", "time", "start", "message", "index", "sum", "SIZE", "length", "offset", "read", "window", "zone", "fee", "total", "space", "empty", "c", "max", "bytes", "get", "ose", "dim", "body", "cmp", "z", "south", "sn", "ize", "send", "speed", "buffer", "unit", "mem", "Size", "error", "sp", "range", "cache", "len", "pos", "sample", "port", "small", "sent", "type"], "count": ["n", "core", "all", "time", "rc", "first", "comment", "cont", "amount", "index", "list", "force", "number", "second", "check", " cc", "sum", "err", "length", "add", "hash", "key", "total", "call", "current", "id", "info", "max", "c", "test", "cmp", "base", "z", "result", "found", "ount", "now", "more", "num", "cond", "try", "scroll", "Count", "doc", "ch", "match", "nt", "cmd", "conf", "cache", "len", "codes", "nc", "cc", "last", "flag", " counts", "counter", "type"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n\n                                     const int16_t *hLumFilter,\n\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n\n                                     uint8_t *formatConvBuffer,\n\n                                     uint32_t *pal, int isAlpha)\n\n{\n\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n\n\n\n    if (toYV12) {\n\n        toYV12(formatConvBuffer, src, srcW, pal);\n\n        src= formatConvBuffer;\n\n    } else if (c->readLumPlanar && !isAlpha) {\n\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n\n        src = formatConvBuffer;\n\n    }\n\n\n\n    if (!c->hyscale_fast) {\n\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n\n    }\n\n\n\n    if (convertRange)\n\n        convertRange(dst, dstWidth);\n\n}\n", "idx": 20613, "substitutes": {"c": ["coll", "t", "p", "com", "rc", "cont", "cn", "ce", "f", "dc", "h", "abc", "co", "ac", "gc", "ct", "d", "enc", "etc", "unc", "con", "call", "cs", "bc", "cu", "e", "cd", "cv", "ec", "cmp", "cur", "C", "ctx", "k", "lc", "cm", "sc", "cf", "ci", "config", "mc", "pc", "cr", "tc", "conf", "cam", "cal", "cache", "can", "nc", "cc", "l", "v", "fc", "b", "cp", "ca", "comp", "chain", "w"], "dst": ["dedst", "dstd", " dct", "dint", "Dest", " drend", "dent", "daint", " dsts", "dedest", "dest", "dnt", "dasts", "debugst", "Dct", "bdest", " dnd", " dint", "Dstd", "tdsc", "deest", "drend", "debugsts", "debugrend", "Dnd", "dedsc", "debugint", "darend", "dect", "Dst", "tdst", "dnd", "dast", "dct", " dnt", "bdnd", "Dnt", "dsc", "bdct", "tdest", "Dsc", " dest", "bdst", "tdstd", "dedstd", "dsts"], "dstWidth": ["DestWrite", " dstW", "dmtW", "dstrHeight", "dvWidth", "dblEnd", " dmtW", "ddestWidth", "dstrW", " destW", "dostWidth", "dSTWrite", " destWidth", " destX", "dSTHeight", " dmtRender", "dstrX", "ddestRender", "dvW", "dstW", "dvRender", "DstWrite", " dstRender", "dstX", "dblWidth", "dvEnd", "dostWrite", "dblHeight", "DestW", "dmtHeight", "dSTWidth", "dmtWidth", " dstHeight", "ddestHeight", "dvX", "DstHeight", "destEnd", "DestHeight", " dmtHeight", "destWrite", "destHeight", "DstW", "dostHeight", "dstEnd", " destEnd", "dstHeight", "DestWidth", "dSTW", "dblW", " dstEnd", " dstX", "dstWrite", "destW", "DstWidth", "dostW", "dvHeight", "dmtRender", "destWidth", "dstRender", " dmtWidth", "ddestW", "destX", "dstrWidth", " destHeight"], "src_in": ["rc_IN", "rc_out", "src_inn", "src_out", "rc_inn", " src_ind", "src_ind", " src_int", "srcPout", "srcPin", "srcPins", "src_ins", " src_out", "src_IN", "rc_in", "rc_ins", "srcPinn", "src_int"], "srcW": ["rcNW", "rcM", "sortV", "rcV", "rcWidth", "srW", "srcWidth", " srcL", " srcWR", "sortL", " srcw", "sortWR", "srV", "addrWidth", "addrL", "addrV", "rcw", "stW", "srcL", "stM", "srcWR", "srcM", "sortW", " srcNW", " srcV", "srNW", "srcV", " srcWidth", "srcNW", "rcWR", "srcw", " srcR", " srcM", "srWidth", "addrW", "rcR", "stR", "srcR", "rcL", "stw", "rcW"], "xInc": ["exInc", " xINC", "xIncre", "exIncre", "rxinc", "checkinc", " xIncre", "xinc", "exIns", "exINC", "rxINC", "rxIncre", "checkInc", "xIns", " xinc", "rxIns", " xIns", "rxInc", "checkIncre", "xINC", "checkINC"], "hLumFilter": ["hLamSort", "hLamApply", "hHumStream", "hLamProfile", "hLamFilter", "hLumProfile", "hLumpStream", "hLulDef", "hHumpFilter", "hHumFilter", "hHumpProfile", "hLUMSort", "hLumiDef", "hLulFilter", "hLamStream", "hLumpFilter", "hHumpStream", "hLulApply", "hLumiFilter", "hLumApply", "hLUMFilter", "hHumSort", "hLumpProfile", "hHumProfile", "hLamDef", "hLumiSort", "hLulSort", "hLumDef", "hLumSort", "hLumpSort", "hLUMStream", "hLumiApply", "hHumpSort", "hLUMProfile", "hLumStream"], "hLumFilterPos": ["hLamFilterPos", "hLumHandlerSize", "hLumSourceSize", "hLumFormatPos", "hLueFormatPos", "hLamFilterOff", "hLueFilterPOS", "hLumBufferPos", "hLumHandlerPOS", "hLamHandlerPos", "hLamFilterPOS", "hLumBufferPOS", "hLumFormatSize", "hLumFilterOff", "hLumSortPos", "hLamHandlerPOS", "hLumBufferSize", "hLumHandlerPos", "hLamHandlerOff", "hLumSourcePOS", "hLumSourcePos", "hLumSourceOff", "hLumSortPOS", "hLamHandlerSize", "hLueFilterSize", "hLumSortOff", "hLamFilterSize", "hLueFilterPos", "hLumFilterPOS", "hLumSortSize", "hLueFormatPOS", "hLueFormatSize", "hLumFormatPOS", "hLumHandlerOff"], "hLumFilterSize": ["hLumMaskSIZE", "hLumMaskLen", "hLumMaskPos", "hLangFilterLen", "hLumMaskSpec", "hLumBufferPos", "hLumTextureLen", "hLumFilterLen", "hLangBufferSize", "hLumpFilterLen", "hLumpFilterPos", "hLumpFilterSIZE", "hLumFilterSpec", "hLumFilterSIZE", "hLumBufferStyle", "hLumpFilterSize", "hLumTextureSize", "hLumMaskSize", "hLumTexturePos", "hLangBufferLen", "hLumOutputStyle", "hLumOutputSize", "hLangFilterSize", "hLumBufferSize", "hLumOutputLen", "hLangBufferStyle", "hLumpTextureLen", "hLumBufferLen", "hLangFilterSpec", "hLumBufferSIZE", "hLumpTexturePos", "hLumMaskStyle", "hLangBufferSpec", "hLumOutputSpec", "hLangFilterStyle", "hLumFilterStyle", "hLumpTextureSize", "hLumBufferSpec", "hLumpTextureSIZE", "hLumTextureSIZE"], "formatConvBuffer": ["formatConvtBuffer", "formatEnnvBuffer", "formatConvertCache", "formatConconvCache", "formatConconvTable", "formatconvLength", "formatConVBuff", "formatconvBlock", "formatCovBuffer", "formatConvecLength", "formatConvtArray", "formatconvBytes", "formatconvtBuff", "formatConvecBuffer", "formatConnvBuilder", "formatEnvBuffer", "formatConvtLength", "formatEnvBuilder", "formatConvLength", "formatConvtBuff", "formatCovBuff", "formatConvtTable", "formatConnvBuffer", "formatConconvBuffer", "formatCovertBuff", "formatConconvBuff", "formatConvBytes", "formatconVBuffer", "formatconvtCache", "formatEnvBuff", "formatConconvLength", "formatConconvArray", "formatconvtBuffer", "formatCovArray", "formatConvtBuilder", "formatConvtBlock", "formatConvBuilder", "formatconvCache", "formatConvCache", "formatConnvBuff", "formatConvecBlock", "formatConVBuffer", "formatConvBuff", "formatconvBuffer", "formatEnnvBuff", "formatConvertArray", "formatConvertTable", "formatConvBlock", "formatConvertBuff", "formatConvtCache", "formatconvtLength", "formatconvBuff", "formatConvArray", "formatConconvBlock", "formatCovertBuffer", "formatconvtBlock", "formatconvtTable", "formatConvertBuffer", "formatconvTable", "formatConvecTable", "formatConvtBytes", "formatEnnvBuilder", "formatConvertBytes", "formatConVBytes", "formatConvTable", "formatCovertArray", "formatconVBuff", "formatCovertTable", "formatCovTable", "formatconVBytes", "formatConconvBuilder"], "pal": ["alph", "mat", "p", "pas", "cil", "pack", "color", "bal", "qq", "al", "bat", "pac", "qt", "ul", "val", "pl", "style", "fac", "phal", "ass", "isal", "local", "pres", "sal", "pid", "pol", "Pal", "alpha", "what", "ph", "olor", "pill", "qual", "sav", "cal", "conf", "phil", "pat", " PAL", "el", "font", "pha", "attr"], "isAlpha": ["isalMeta", "bisAlias", "isalHA", "bisAlpha", "isaalpha", "isPhase", "needsalpha", " isMass", "hasAlpha", "isaAlpha", "ishMass", " isMeta", "isMeta", "IsPhase", "ISAlpha", "needsAlpha", "isalpha", "setalpha", "ISHA", "hasMeta", "isaPhase", "isMass", " isalpha", "isalAlpha", "Isalpha", "setAlpha", "setHA", "ISalpha", "IsHA", "bisalpha", " isAlias", "ishalpha", "needsHA", "needsAlias", " isPhase", "isHA", "ISMass", " isHA", "hasHA", "ishHA", "IsAlpha", "ishAlpha", "bisHA", "isAlias"], "toYV12": ["toXP8", "toYVS32", "toYUV32", "toYAVS32", "toXV24", "toYVM8", "toYVM2", "toYUV12", "toYP8", "toYv32", "toYVS2", "toIEUV12", "toIEV8", "toYV32", "toIEUV8", "toYVSail", "toYP24", "toIEUV32", "toXV8", "toYAVSail", "toYVS12", "toXV2", "toYAV32", "toYV24", "toYv2", "toYAVail", "toYPail", "toYV8", "toIEV2", "toXP2", "toXV12", "toYAVS12", "toYAV2", "toXP24", "toXP12", "toIEUV2", "toYP12", "toIEV12", "toYVM24", "toYAVS2", "toYAV12", "toYv8", "toYVM12", "toYVail", "toYUV8", "toYUV2", "toYP2", "toYv12", "toYv24", "toYP32", "toYUVail", "toYV2", "toIEV32"], "convertRange": ["converrange", "convertRule", "convertingRange", "conforceRange", "conversionrange", "conlateRow", "conforceRow", "coforceRule", "conforceRegion", "convertingRegion", "convertRow", "conforceRule", "conversionRate", "convertingRow", "convertrange", "covertRule", "convertsRate", "converRate", "convertedrange", "covertRegion", "convertRegion", "convertedRange", "coversionRange", "covertRate", "convertsRange", "convertRate", "coforceRegion", "conversionRange", "convertingRule", "converRange", "coforceRange", "coversionList", "conlateRegion", "conlateRule", "conlateRange", "conforceList", "convertsrange", "covertrange", "convertedList", "coforceRow", "conforcerange", "covertRow", "coversionRate", "coversionrange", "covertList", "covertRange", "convertList", "conversionList"], "src": ["sys", "lr", "rc", "usr", "r", "source", "spr", "conv", "iv", "vr", "pkg", "dest", "loc", "impl", "rs", "st", "s", "syn", "cur", "proc", "fp", "sr", "img", "sn", "urg", "raw", "ptr", "tmp", "ssl", "sl", "via", "hl", "buffer", "sc", "addr", "inner", "sq", "config", "sub", "ins", "rl", "buff", "obj", "sur", "input", "inst", "sb", "ser", "supp", "ctr", "attr"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */\n\n                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n", "idx": 20617, "substitutes": {"av_flatten": ["av__fenn", "av_multen", "av_flac", "av_clenn", "av_clatten", "av__flac", "av_flen", "av_flenn", "av_clac", "av__fac", "av__fatten", "av__flenn", "av_fatten", "av_fac", "av_multenn", "av_multac", "av_multatten", "av__flatten", "av_fen", "av_fenn", "av_clen", "av__fen", "av__flen"], "pix": [" pct", "ipfx", "ppixels", "Padd", "Pitch", "paiv", " padd", "pct", " pfx", "cpIX", "Pixels", "padd", "pIX", "Px", "vpixels", "npixels", "pfx", " pox", " pond", "paix", "pox", "pond", "Pox", "npfix", "PIX", "vpix", "npct", " pip", "pixels", "ppond", "ppfx", "ipix", " px", "paixels", "vpIX", "npadd", "pfix", "cpip", "vpip", "paitch", "Pix", " piv", "cpx", "px", " pIX", "npox", "ppIX", "pip", "Pct", "ipIX", " pfix", "cpixels", "pitch", "piv", "Piv", "Pond", "npix", " pitch", "ppix", "Pfix", " pixels", "ppx", "cpix"], "xstride": ["xdivide", "xSTRride", "xstrend", "xslride", "xslides", "xSTRide", "xdride", "xcollides", "ystide", "xstrange", "xcollid", "xscoperide", "ystrest", "ySTRides", "ystides", "ySTRride", "ystrime", "ySTRange", "xstrided", "ySTRided", "ystrride", "xstrides", "xSTRides", "xStrride", "xstides", "xstringest", "xdrend", "xSTRimate", "xstrimate", "xstringange", "xSTRided", "xStrided", "ySTRime", "ystrange", "xStride", "xstide", "xslided", "xstriride", "ySTRimate", "xstringride", "xSTRest", "xdivest", "xstrid", "xstrest", "ystrides", "ystid", "xstriide", "xstringimate", "xstringide", "xstrime", "xscopeimate", "xcollride", "ystrend", "xcollide", "xstriime", "xSTRange", "xslide", "xdivride", "xdivides", "ySTRend", "ystrided", "xstriend", "ySTRide", "ystrid", "xdrride", "xslid", "xdrime", "xscopeange", "ystrimate", "xSTRime", "xSTRend", "xscopeide", "xStrides", "xstrride", "xstringides", "ySTRest", "xstid"], "ystride": ["ystatusale", "xSTRride", "ystrale", "ySTRine", "ystatusIDE", "xyStrider", "xstrIDE", "xSTRide", "yStrider", "ySTRider", "ylenide", "yStrride", "ystrider", "xystrine", "xyStride", "ystrine", "ystrride", "ystatusride", "yglride", "xstrides", "xSTRides", "ystatuside", "ydivine", "ySTRide", "ybride", "ystrides", "ybrride", "ylenides", "yglale", "ylenider", "yStride", "xystrider", "xSTRIDE", "ySTRale", "xyStrine", "xstrale", "xystride", "ySTRides", "ydivride", "xstrride", "xstrider", "xystrride", "xSTRider", "yglide", "ybrides", "xyStrride", "ystrIDE", "ySTRride", "yglIDE", "ydivider", "ySTRIDE", "ylenride", "xSTRale", "ybrider", "yStrine", "ydivide"], "alpha": ["asc", "alph", "phi", "p", "upper", "rc", "it", "a", "si", "lambda", "h", "scale", " gamma", "ac", "title", "ati", "al", "ar", "appa", "xa", "la", "A", "ia", "fa", "ta", "area", "inc", "au", "acl", "ma", "HA", "phas", "ca", "hi", "pi", "ra", "Alpha", "sha", "pha", "angle", "alias"], "beta": ["bi", "phi", "t", "BA", "p", "binary", "normal", "a", "lambda", "coe", "te", "scale", "gam", "late", "fee", "\u03b2", "e", "bc", "mu", "blue", "bis", "igma", "base", "Beta", "boost", "frequency", "lie", "fine", "ta", "prime", "dev", "term", "bet", "tc", "u", "b", "ca", "v", "Alpha", "ba", "pha", "alias"], "tc0": ["qt0", "pcands", "TC0", " tcands", " tc6", "qt6", "tcands", " tc00", "TCands", "pc0", "tc6", "TC00", "tc00", "TC1", "TC6", "qt1", " tc1", "pc1", "tc1", "pc00"], "i": ["bi", "name", "ij", "t", "p", "is", "\u0438", "it", "ri", "this", "print", "o", "si", "index", "r", "di", "io", "ai", "xi", "me", "ix", "m", "iu", "us", "init", "multi", "im", "zi", "ie", "x", "id", "sim", "ind", "gi", "I", "c", "ki", "ti", "ini", "ip", "j", "status", "li", "ui", "ms", "ex", "try", "in", "ci", "g", "ico", "mi", "ii", "pi", "l", "v", "hi", "chain"], "d": ["n", "done", "t", "p", "out", "der", "dm", "dx", "D", "r", "dd", "di", "did", "du", "dc", "m", "del", "f", "debug", "add", "dir", "dt", "ind", "cd", "dim", "c", "bd", "ds", "dl", "den", "md", "dig", "j", "ord", "nd", "dra", "dy", "dat", "draw", "de", "dr", "g", "ad", "fd", "diff", "mod", "pd", "l", "v", "days", "dj", "da"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "int ff_mpeg4_decode_picture_header(MpegEncContext * s, GetBitContext *gb)\n\n{\n\n    int startcode, v;\n\n\n\n    /* search next start code */\n\n    align_get_bits(gb);\n\n    startcode = 0xff;\n\n    for(;;) {\n\n        v = get_bits(gb, 8);\n\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        \n\n        if(get_bits_count(gb) >= gb->size*8){\n\n            if(gb->size==1 && s->divx_version){\n\n                printf(\"frame skip %d\\n\", gb->size);\n\n                return FRAME_SKIPED; //divx bug\n\n            }else\n\n                return -1; //end of stream\n\n        }\n\n\n\n        if((startcode&0xFFFFFF00) != 0x100)\n\n            continue; //no startcode\n\n        \n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            printf(\"startcode: %3X \", startcode);\n\n            if     (startcode<=0x11F) printf(\"Video Object Start\");\n\n            else if(startcode<=0x12F) printf(\"Video Object Layer Start\");\n\n            else if(startcode<=0x13F) printf(\"Reserved\");\n\n            else if(startcode<=0x15F) printf(\"FGS bp start\");\n\n            else if(startcode<=0x1AF) printf(\"Reserved\");\n\n            else if(startcode==0x1B0) printf(\"Visual Object Seq Start\");\n\n            else if(startcode==0x1B1) printf(\"Visual Object Seq End\");\n\n            else if(startcode==0x1B2) printf(\"User Data\");\n\n            else if(startcode==0x1B3) printf(\"Group of VOP start\");\n\n            else if(startcode==0x1B4) printf(\"Video Session Error\");\n\n            else if(startcode==0x1B5) printf(\"Visual Object Start\");\n\n            else if(startcode==0x1B6) printf(\"Video Object Plane start\");\n\n            else if(startcode==0x1B7) printf(\"slice start\");\n\n            else if(startcode==0x1B8) printf(\"extension start\");\n\n            else if(startcode==0x1B9) printf(\"fgs start\");\n\n            else if(startcode==0x1BA) printf(\"FBA Object start\");\n\n            else if(startcode==0x1BB) printf(\"FBA Object Plane start\");\n\n            else if(startcode==0x1BC) printf(\"Mesh Object start\");\n\n            else if(startcode==0x1BD) printf(\"Mesh Object Plane start\");\n\n            else if(startcode==0x1BE) printf(\"Still Textutre Object start\");\n\n            else if(startcode==0x1BF) printf(\"Textutre Spatial Layer start\");\n\n            else if(startcode==0x1C0) printf(\"Textutre SNR Layer start\");\n\n            else if(startcode==0x1C1) printf(\"Textutre Tile start\");\n\n            else if(startcode==0x1C2) printf(\"Textutre Shape Layer start\");\n\n            else if(startcode==0x1C3) printf(\"stuffing start\");\n\n            else if(startcode<=0x1C5) printf(\"reserved\");\n\n            else if(startcode<=0x1FF) printf(\"System start\");\n\n            printf(\" at %d\\n\", get_bits_count(gb));\n\n        }\n\n\n\n        switch(startcode){\n\n        case 0x120:\n\n            decode_vol_header(s, gb);\n\n            break;\n\n        case USER_DATA_STARTCODE:\n\n            decode_user_data(s, gb);\n\n            break;\n\n        case GOP_STARTCODE:\n\n            mpeg4_decode_gop_header(s, gb);\n\n            break;\n\n        case VOP_STARTCODE:\n\n            return decode_vop_header(s, gb);\n\n        default:\n\n            break;\n\n        }\n\n\n\n        align_get_bits(gb);\n\n        startcode = 0xff;\n\n    }\n\n}\n", "idx": 20618, "substitutes": {"s": ["p", "t", "sys", "is", "a", "sa", "si", "os", "set", "f", "m", "h", "ss", "ns", "sf", "ses", "stats", "ps", "cs", "e", "sts", "aws", "gs", "rs", "fs", "c", "sim", "ds", "st", "se", "sm", "ls", "ms", "ssl", "sv", "sam", "ats", "hs", "sc", "S", "js", "g", "sq", "ts", "sp", "sg", "sb", "b"], "gb": ["gt", "gif", "rb", "eb", "py", "bf", "tg", "cb", "io", "hub", "large", "gm", "goo", "ob", "gc", "gd", "mb", "erb", "rg", "ib", "uf", "bs", "bc", "eg", "vg", "gs", "gio", "vm", "fb", "asm", "nb", "buf", "tif", "bg", "yg", "gu", "wb", "db", "gg", "g", "kb", "pb", "Gb", "pg", "emb", "sg", "GB", "sb", "b", "cfg", "bb"], "startcode": ["pickcycle", "rankcode", "startingcod", "Startcase", "spacec", "artx", "birthcoded", "baseline", "startcore", "stickco", "stickcase", "lookco", "basecoded", "stickcode", "rankentry", "stickgo", "birthCode", " startcod", "lookpage", "checksequence", "birthcode", "initlink", "spacecode", "firstcoded", "initcode", " starttime", "rankcase", "statusco", "drawcod", "drawcase", "startinfo", "launchcode", "Startcode", "birthdate", "pickcode", "Startcount", "sendcommand", "startcod", "initcycle", "startingcode", "statuscore", "partquery", "precod", "initquery", " startsequence", "stopcase", "firstcode", "casecod", "launchquery", "stopcache", "basetry", "sticklink", "startdate", " startcommand", "needcode", "starttry", "padcode", "initevent", "keycode", "sharecase", "statuscase", "initcore", "shortmodule", "artc", "launchtry", "checkcache", "basecod", "stickcondition", "initco", " startvalue", "lookcode", "initmap", "initcondition", "stopmodule", " startc", "padvalue", "stopquery", "startvalue", "needcod", "initcard", "precase", "startgo", "initentry", "drawpost", "stickcycle", "startingsequence", "partentry", "sharetime", "caseco", "spacex", "firstcache", "startno", "launchco", "headvalue", "needsequence", "partcache", "artcod", "lookcommand", "padcod", "initinfo", "stopcode", "firstlink", "launchcache", "launchmap", " startdate", "Startcod", "startentry", "partcode", "launchcod", " startno", "stopentry", " startcase", "sharecod", " startcard", "startpage", "casecode", " startcount", "birthcache", "startevent", "firstcase", "sharecode", "startmodule", "needline", "startcount", "shortevent", "startcase", "initmodule", "lookcache", "basecode", " startcycle", "sendpage", "needco", "stopevent", "firstevent", "startcoded", "initno", "firstno", "shortcode", " startcache", "rankinfo", " startpage", "headcoded", "casetime", "latcache", "startsequence", "initcase", "latcode", "initcache", "launchline", "launchcase", "startcommand", "pickcase", "sendcode", "startco", "latcase", "spacecod", "basecache", "padcoded", "starttime", "launchtime", " starttry", " startx", "artcode", "shortcase", "drawcode", "keycod", "needcase", "startcycle", " startline", "checkline", "inittime", "startpost", "startline", "startcondition", "initpost", "artdate", " startCode", "checkcode", "firstco", "startx", "startc", " startcoded", "precount", "startcache", "startquery", "birthcod", "startCode", "sendcod", " startquery", "startmap", "headcode", "latevent", " startco", "startlink", "firstinfo", "rankmap", "launchentry", "rankquery", "lookcod", "precode", "sharepost", "rankcache", "needcache", " startlink", "needcore", "initcod", "keysequence", "stickcard", " startgo", "keycycle", "artCode", "startingcycle", "firstcod", "statuscode", "pickcondition", "shareco", "firstgo", "startcard", "headcod"], "v": ["n", "qv", "p", "t", "vc", "r", "f", "m", "h", "value", "y", "conv", "inv", "iv", "vu", "val", "d", "vr", "va", "x", "i", "vert", "cv", "vm", "c", "tv", "j", "uv", "k", "q", "sv", "vs", "g", "vo", "vv", "u", "nv", "b", "l", "V", "vp", "lv", "ev", "vt"]}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n    const uint8_t *buf_start= buf;\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1) * 2;\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        s->repeat_pict = 1;\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 5;\n\n                                else\n\n                                    s->repeat_pict = 3;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 2;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}\n", "idx": 20620, "substitutes": {"s": ["n", "p", "t", "sys", "settings", "a", "sac", "os", "set", "r", "f", "h", "ss", "ns", "ses", "conv", "stats", "ps", "bs", "cs", "sts", "e", "rs", "gs", "aws", "fs", "c", "ds", "sn", "ctx", "spec", "ls", "q", "ms", "ssl", "sets", "sv", "ats", "vs", "hs", "sw", "self", "sc", "S", "js", "service", "es", "g", "ins", "sq", "ts", "sp", "sg", "less", "sb", "as", "v", "so", "w"], "avctx": ["verconn", " avjac", "devcontext", " avcv", "devserver", "avcmp", " avconn", "aftx", "svctx", "avcontext", "afconn", "avepkg", "avcv", "avertx", "avecmp", "avercontext", " avpkg", "avesys", "avtx", " avcomp", "aversys", "svpkg", "averctx", " avsys", "avetx", "svtx", "avecontext", " avcmp", "avjac", "avsys", "afcontext", "afcv", "avejac", "avcomp", "aveserver", "avpkg", "AVcontext", "devctx", "afctx", "avserver", "AVjac", "AVtx", "svconn", "vercomp", "svcmp", "verctx", "avectx", "svcontext", "svsys", "averconn", "AVctx", "avercomp", "vertx", " avcontext", "averserver", "devsys", " avtx", "avercv", "avconn"], "buf": ["msg", "pack", "desc", "foo", "length", "err", "late", "uf", "batch", "lim", "rw", "ff", "br", "bh", "tmp", "wb", "BU", "emb", "pos", "port", "v", "padding", "done", "loop", "orig", "words", "bl", "conv", "bs", "Buffer", "data", "bytes", "vec", "nb", "deg", "xff", "true", "db", "mem", "cmd", "cam", "bin", "sofar", "b", "eng", "cp", "bf", "begin", "ref", "pkg", "mb", "def", "cv", "args", "fb", "ctx", "raw", "ptr", "bo", "bg", "buffer", "box", "buff", "np", "pool", "pg", "cache", "len", "cast", "wait", "mat", "rb", "end", "txt", "cap", "alloc", "cb", "off", "bed", "go", "window", "read", "aka", "Buff", "src", "code", "bar", "bc", "que", "keep", "img", "prop", "nm", "queue", "grad", "iter", "doc", "pb", "block", "pad", "bp", "ctr", "text"], "buf_size": ["uf_size", "buf__max", "buffer_size", "buf_length", "uf__max", "buf__SIZE", "uf__size", "buf_SIZE", "buffer_from", "uf_max", "uf__end", "buf__end", "buf_max", "buf_from", "uf_SIZE", "buffer_length", "uf__SIZE", "buf__size", "uf_end", "buffer_start"], "pc": ["td", "asc", "p", "isc", "vp", "vc", "rc", "func", "dc", "pm", "tp", "iac", "amps", "PC", "disc", "ac", "sync", "conv", "gc", "ct", "pac", "enc", "pt", "pp", "lp", "cs", "bc", "wp", "cu", "tk", "cv", "c", "pa", "peer", "ec", "cmp", "proc", "psc", "ctx", "pr", "arc", "icc", "lc", "cm", "sc", "px", "pan", "amp", "anc", "mc", "pb", "cam", "xc", "tc", "soc", "acl", "cc", "pd", "pi", "fc", "cp", "pic"], "buf_end": ["buf2end", "uf_max", "buf_ending", " buf_exp", "buf09ending", "buf64end", "bufjend", "uf_End", "buf_est", "buffer_size", "buffer_last", "buf09exp", "bufjlast", "buf09start", "buf_max", "buffer_ends", "buf09end", " buf_ending", "buf_last", "buf64exp", "buffer_est", "bufjstart", "buf64ending", "buf2max", "buf2END", "uf_start", "buf_exp", "buf_End", "bufjest", "uf_END", "buffer_end", "buf_ends", "buf_END", "buf2start", "buf64start", "uf_end", "buffer_start"], "buf_start": ["buf_left", "buf2st", "buf_st", "bufptinit", "uf_left", "buf2end", "bufptstart", "buf_begin", "buffer_end", "buf_init", "buffer_st", "bufptend", "bufptleft", "buf2start", "buf2begin", "buffer_begin", "uf_end", "uf_init", "buffer_start", "uf_start"], "start_code": ["startacCode", "parttenancecode", "startewcode", "startewcomponent", "starttenanceevent", " start_cod", " start_codes", " start_sequence", "start_component", "startewsequence", "startxcase", "start_case", "starttenancetime", "startxcomponent", "start_sequence", "parttenancetype", " start_case", "startxcodes", "start_Code", "start_codes", "part_event", "part_type", "starttenancecode", "parttenancetime", "start_event", " start_number", "starttenancetype", "start_time", "part_time", "startxcode", "parttenanceevent", "startxcod", "part_code", "startacnumber", "startewCode", "start_cod", "startaccode", "start_type", " start_component", " start_Code", "startxCode", "start_number", "startxsequence"], "frame_rate_index": ["frame_rate_Index", "frame_erate_success", "frame_time_Index", "frame_erate_index", "frame_rate_block", "frame_time_link", "frame_time_block", "frame_time_index", "frame_rates_index", "frame_rates_ind", "frame_rates_number", "frame_range_index", "frame_rate_id", "frame_erate_id", "frame_rate_success", "frame_erate_ex", "frame_range_ind", "frame_rate_ex", "frame_rate_ind", "frame_range_info", "frame_rate_link", "frame_range_number", "frame_rate_info", "frame_rate_number", "frame_rates_Index"], "ext_type": ["ext___description", "xt_sequence", "ext___name", "ext_description", "xt_type", "ext___type", "xt_name", "ext_sequence", "ext_name", "ext___sequence", "xt_description"], "bytes_left": ["bytes_loaded", "bytesityleft", "bytesitylt", "bufixlt", "bytes_length", "boxes_limit", "bytes5inner", "boxes5limit", "bufixonly", "boxes_left", "buf_fail", "buf_lt", "boxes5inner", "bytesixfail", "bytes5limit", "bits_len", "bits_left", "bytesityonly", "bytes_right", "buf_left", "boxes5left", "bytesityfail", "bytes5lit", "bytesixleft", "bytes08fail", "bytes_lt", "tes_available", "bytes_only", "bytes64lit", "bufixleft", "tes_loaded", "boxes5lit", "buf_only", "bytesixlt", "bytes_limit", "boxes_lit", "bytesixonly", "bytes_available", "bytes64limit", "boxes_inner", "tes_left", "bytes_len", "bytes_fail", "bytes_lit", "bytes5left", "bits_length", "bufixfail", "bytes64inner", "bytes08only", "bytes_inner", "bytes08left", "bits_right", "bytes08lt", "tes_right", "bytes64left"], "frame_rate_ext_n": ["frame_rate_exp_num", "frame_rate_exp_N", "frame_rate_ext_num", "frame_rate_exp_n", "frame_rate_exp_p", "frame_rate_ext_p", "frame_rate_ext_N"], "frame_rate_ext_d": ["frame_rate_ext_dim", "frame_rate_ex_d", "frame_rate_ex_n", "frame_rate_ex_t", "frame_rate_ex_dim", "frame_rate_ext_t"], "picture_structure": ["picture_instype", "picture_restructure", "picture_restruction", "picture_instruction", "picture_instrict", "picture_stype", "picture_struction", "picture_restype", "picture_constrict", "picture_instructure", "picture_construction", "picture_restrict", "picture_strict", "picture_constructure", "picture_constype"], "top_field_first": ["top_fields_last", "top_fields_first", "top_field_part", "top_fields_part", "top_field_ref", "top_field_last", "top_fields_ref"], "repeat_first_field": ["repeat_last_fields", "repeat_last_frame", "repeat_first_fields", "repeat_last_line", "repeat_last_field", "repeat_first_line", "repeat_first_frame"], "progressive_frame": ["progressiveingframes", "progressive_format", "progressiveableformat", "progression_frames", "progression_feature", "progressive_frames", "progressiveablefeature", "progressiveingfeature", "progression_frame", "progression_format", "progressive_feature", "progressiveingframe", "progressiveingformat", "progressiveableframe", "progressiveableframes"], "horiz_size_ext": ["horiz_size_ex", "horiz_space_external", "horiz_size_external", "horiz_size2external", "horiz_space_ex", "horiz_size_exp", "horiz_size2exp", "horiz_size2ext", "horiz_space_exp", "horiz_size2ex", "horiz_space_ext"], "vert_size_ext": ["vert_size___init", "vert_Size_ex", "vert_Size_init", "vert_Size_opt", "vert_size_ex", "vert_size___ext", "vert_size_opt", "vert_size___opt", "vert_size___ex", "vert_size_init", "vert_Size_ext"], "bit_rate_ext": ["bit_rate2Ext", "bit_rate_external", "bit_rate2ex", "bit_rate_Ext", "bit_rate_ex", "bit_rates_ext", "bit_rates_ex", "bit_rate2external", "bit_rates_external", "bit_rate2ext", "bit_rates_Ext"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int set_chroma_format(AVCodecContext *avctx)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx) {\n\n        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {\n\n            p_schro_params->format->chroma_format =\n\n                            schro_pixel_format_map[idx].schro_pix_fmt;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR,\n\n           \"This codec currently only supports planar YUV 4:2:0, 4:2:2\"\n\n           \" and 4:4:4 formats.\\n\");\n\n\n\n    return -1;\n\n}\n", "idx": 20623, "substitutes": {"avctx": ["wavctx", "averkw", "aftx", "avcontext", "avekj", "avertx", "avercontext", " avpkg", "avtx", "Avcontext", "averctx", "wavkw", "Avpkg", "avetx", "avkw", "avecontext", "wavtx", "afcontext", "avkj", "Avtx", "avpkg", "AVcontext", "afkj", "afctx", "AVtx", "wavcontext", " avkw", "Avctx", "avectx", " avkj", "AVctx", " avcontext", " avtx", "AVpkg"], "idx": ["idy", " idz", "didix", "midex", "didx", "keyx", "aidj", " idxi", "ardxes", "sidx", "aidxes", "sidxi", "indwx", "idlex", "ndj", "ndxi", "idj", "sidxs", "Idex", " idwx", "keylex", "keyxs", "sidlex", "midx", "bidx", "idez", "bidxi", " idex", "keyxi", "indxs", "aidxi", "idxs", "idz", "indix", "indz", "ideix", "didy", "idix", "ardx", " idy", "midxi", "idex", "idxes", "Idxs", "bidz", "aidx", "indy", "ndxes", " idlex", "indx", "Idx", "midxs", "ardj", "bidix", "idxi", " idix", "midz", "ndx", " idxs", "idexs", "midix", "ardxi", "didwx", "idwx"], "p_schro_params": ["p_schro_config", "p_schro2ams", "p_schlo_ams", "p_schro_ams", "p_schros_data", "p_schropyams", "p_schros2ams", "p_schro2data", "p_schros_ams", "p_schro_settings", "p_schro2params", "p_schlo_settings", "p_schlo_data", "p_schro_data", "p_schropyconfig", "p_schropyparams", "p_schros2params", "p_schro2config", "p_schros2config", "p_schros2data", "p_schros_params", "p_schros_config", "p_schropydata", "p_schlo_params"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 20631, "substitutes": {"ctx": ["kw", "Context", "jac", "sys", "ic", "context", "ck", "kt", "cb", "co", "ac", "gc", "ct", "src", "unc", "conn", "cu", "bc", "tk", "cv", "tx", "c", "jp", "cmp", "proc", "hw", "rt", " cx", "cci", "lc", "cm", "sc", "nt", "rl", "pc", "tc", "rec", "nc", "cc", "ctl", "fc", "cp", "cas", "xc"], "rb": ["bf", "r", "cb", "ru", "raf", "rob", "gb", "reb", "vr", "src", "erb", "lb", "ib", "rg", "rr", "ro", "bc", "rs", "fb", "rx", "nb", "buf", "rw", "ptr", "rt", "wb", "db", "rf", "RB", "rm", "rl", "pb", "sb", "b", "ra", "bb", "rd"], "rc": ["isc", "rn", "ic", "r", "cb", "ru", "ref", "dc", "ac", "rin", "src", "irc", "rr", "ro", "cs", "bc", "rs", "cv", "RC", "uc", "c", "ec", "rx", "cur", "rw", "sr", "ptr", "rt", "roc", "arc", "res", "sc", "reg", "rl", "pc", "cr", "tc", "rec", "nc", "cc", "fc", "ra", "cp", "rd"], "fn11": ["kn11", "bn011", "pn14", "anon11", "bn1111", "fn12", " fn1111", "fen2011", "fn1100", "dn12", "ln11", "fn2011", "anon1111", "pn2011", "kn12", "rn1111", "anon1100", "fn118", "fen11", "pn1", "fn111", "FN1", "sn11", "dn1111", "ln1111", "FN1111", "tn118", "FN011", "fen1", "FN11", " fn2011", "FN111", "rn11", "sn1111", "kn011", "tn11", "sn118", "rn011", "fn1", "kn1", "fn1111", " fn011", "tn1111", "FN12", "anon011", " fn1", "fn14", "fn011", " fn12", "ln111", "fen14", " fn118", "rn1100", "ln12", " fn14", "bn1100", "pn11", "dn111", "dn11", "bn11"], "vb": ["vvb", "vbe", "uvf", "vvf", "visb", "uvbc", "vsb", "VB", "uvsb", "svb", "wireb", "uvB", "vrb", " vB", "vf", "cvrb", "cvb", "wiresb", "vB", "svB", "vipb", "svrb", "cvB", "cvp", " vbe", "Vrb", "svbe", "vbc", "Vbe", "uvb", "Vb", " vp", " vobj", "vpb", "vib", "vibc", "wirebc", " vf", "uvbe", "uvpb", "wirepb", "vvobj", "vobj", "cvbe", "uvobj", "Vp", "vp"], "vc": ["qv", "vd", "vp", "ic", "ht", "cil", "cb", "vi", "vl", "dc", "conv", "vr", "VC", "cs", "bc", "cu", "cv", "vm", "c", "voc", "vy", "dl", "vec", "fp", "uv", "wl", "rt", "ve", "pr", "sv", "vet", "lic", "vs", "lc", "ev", "vo", "rl", "pc", "bt", "wt", "ll", "cc", "b", "gp", "v", "fc", "nv", "cp", "lv", "voice", "vv", "xc", "vt"]}}
{"project": "qemu", "commit_id": "0e86c13fe2058adb8c792ebb7c51a6a7ca9d3d55", "target": 1, "func": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 20643, "substitutes": {"dev": ["p", "out", "ver", "Dev", "cont", "dd", "desc", "dis", "go", "device", "scan", "debug", "d", "iv", "serv", "pro", "pt", "def", "conn", "info", "Device", "test", "des", "ds", "md", "data", "hd", "tr", "hw", "proc", "DEV", "spec", "raw", "env", "dem", "ow", "priv", "mem", "ad", "doc", "de", "adv", "nt", "ch", "usb", "cmd", "cam", "obj", "tm", "stick", "pad", "att", "v", "cast", "ev", "w"], "vser": [" vdesc", "verstat", "gder", "vcur", "formser", "vuser", "evsoc", "formther", "evser", "svserver", "vmserver", "verprof", "wber", "verears", "versoc", "hcur", " vstat", "uvser", "vprof", "verber", "svstat", "wireears", "vsys", "formSer", "vther", "vder", "vstat", " vserver", "verder", "evdes", "verdesc", "evsel", "verserv", "verctr", " vuser", "evpro", "vsoc", "formdesc", "svserv", "svprof", " vSER", "svber", "evserv", "vrev", "wSER", "verSer", "gser", "ivpro", "hser", " vsel", "vdes", "uvrev", "evserver", "hserver", "vmcur", " vsys", "evder", "evrev", " vder", "ivber", "gserver", "versys", "vserv", "wprof", "uvserver", "ivserv", "evsys", "verther", "wser", "ivser", "veruser", "svdes", " vrev", "wireserv", "vserver", "vSER", " vctr", "vsel", "svuser", "vber", "wsel", "evSER", "verdes", "verser", "uvserv", "verpro", "vears", " vears", "vmser", "verserver", "vctr", " vSer", " vther", "wserv", "vdesc", "evber", "wirectr", "hder", "wireser", "svsoc", "vSer", "svsys", "vmder", "svser", "gcur", "vpro", " vserv"], "vdev": ["vdes", " vdevice", "Vdef", "verdev", "wdevice", "vdef", "verdef", "wdes", "avvar", " vvar", "Vder", "verserver", " vdef", "wdev", "vdevice", "vder", " vserver", "verder", "vvar", " vder", "Vserver", "wvar", "avdev", "avdes", "avdevice", " vdes", "Vdev", "vserver"]}}
{"project": "qemu", "commit_id": "5666ca4ae06d20497f887241151278e266947087", "target": 1, "func": "int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n", "idx": 20644, "substitutes": {"cenv": ["cexe", "menv", "concontext", "menvironment", "constate", "cen", "cviron", "centry", " ccontext", "men", "ecentry", "conenvironment", "cuwindow", "cuexe", " csb", "dcstate", "ccontext", " centry", "fenvironment", "fenv", " cstate", "kviron", "kenvironment", "fexe", "cuentry", "cwindow", "cenvironment", "dcenv", "ecenvironment", "fwindow", "cuenv", " cenvironment", "cuenvironment", "cusb", " cviron", "kenv", "csb", " cwindow", "dccontext", "ken", "ecsb", " cexe", "mviron", "dcenvironment", " cen", "ecenv", "cstate", "conenv"], "sregs": ["sgrb", "smemS", "sREGjs", "sregisters", "SRegfs", "sRegjs", "sregjs", "sregb", "Sregs", " smems", "sregS", " sregS", "sregisterfs", "SRegb", "smems", " sregn", "sREGS", "sREGs", "sREGfs", " smemjs", "SRegs", "sRegb", "sregfs", "smemn", "sregn", "SReges", "sremn", "Sregfs", "sRegfs", "SRegjs", " sregjs", "sgrjs", "smemjs", "sREGn", "sregisterjs", "Sreges", "sregisteres", "sremS", "Sregb", " smemS", "sREGes", " smemn", "sreges", "srems", "sReges", "sRegs", "sremjs", "sgrs", "Sregjs"]}}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647, "substitutes": {"vq": ["vue", "xrequ", "jq", "invqu", "vdch", "jue", "jque", " vque", "svch", "mq", "xque", "vqq", "invck", "svqs", "viewq", "yq", "viewqu", "wqq", "yue", "hue", "inviq", "veqq", "xqq", "vdgr", " vqs", "svrequ", "hqu", "mue", "veiq", " vch", "jQ", "evq", "vdqq", "yque", "hqq", "wque", "svgr", " vue", "yrequ", "svck", "invdq", "xq", "hq", "vck", "viewue", "vch", "jqq", " vck", "invqq", "invque", " vqq", "evqq", "evck", "viewqq", "vrequ", "mqq", " vqu", "veq", "veue", "veque", "vgr", "yqq", "vQ", "svdq", "invq", "invQ", " vgr", "wiq", "jqu", "mque", "svque", "vqs", "viq", "wq", " vQ", "svq", "evqs", "vque", "svqq", "vdq", " vdq", "vqu"], "vdev": ["svserial", "lval", "ddb", " vdevice", "vmdev", " vval", "visvar", "uvdev", "vdef", " vgu", "ldev", "mdb", "viewdev", "ddevice", "visdev", "mdevice", "vmdat", "ddev", "vgu", " vdef", "svgu", "uvgu", " vpad", " vev", "vdevice", "svev", "visserver", "uvvar", "vvar", "uvdef", "vval", " vdb", "vev", "svgo", "mev", "vgo", "vmgo", "mdev", "svpad", "lev", " vgo", " vserial", "vpad", "svdev", "viewgu", "vdb", "viewserver", "uvserver", "vdat", "svval", "vserial", "svdef", "dev", "visgu", "viewvar", "uvserial", "vmpad", "ldat", "svdat", "vserver", " vdat"]}}
{"project": "FFmpeg", "commit_id": "8728360b5664ef9db31137d8d3104cac33b9a911", "target": 1, "func": "static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}", "idx": 20659, "substitutes": {"avctx": ["vrcmp", "avdl", "averconf", "evtx", "avehistory", "avertx", "avecmp", "vrcontext", "avcp", " avcrit", " avcmp", "afcontext", "avecp", "afctx", "afcp", "wavcmp", " avctl", "wavtx", "vrctx", "ajpkg", "devcontext", "avcmp", "avconf", "evctx", "devcmp", "devcfg", "avercontext", "ajtx", "averctx", "evcontext", "wavcp", "aveca", "afcmp", "vrtx", "avercmp", "devctx", "ajcmp", "ajctl", "vertx", " avcontext", " avtx", "avedl", "avecrit", "wavhistory", "ajhistory", "ajcp", "aftx", "afconn", "avepkg", " avcfg", "wavconf", "aveconf", "avtx", "avetx", "avecontext", "averpkg", "ajca", "avca", "afconf", "averdl", "vercfg", "wavcontext", "afctl", "ajdl", "wavconn", "vercontext", "avconn", "devtx", "wavctx", "avcrit", " avconn", "avhistory", "avcontext", "wavca", " avpkg", "avctl", "devcp", "wavpkg", "aveconn", " avcp", "devcrit", "avpkg", " avconf", "ajctx", "ajcontext", "ajconn", "verctx", "avectx", "avcfg", "evcmp", "averconn", "afdl"], "mp": ["mk", "p", "cap", "ppo", "mph", "MP", "mm", "mmm", "app", "m", "pm", "amps", "gm", "pkg", "mb", "ps", "pp", "mint", "pl", "sim", "aph", "nom", "Mp", "wp", "pa", "omp", "md", "mar", "jp", "cmp", "emp", "ap", "mac", "ip", "proc", "fp", "mt", "imp", "psc", "bm", "ms", "tmp", "sam", "map", "cm", "px", "mit", "em", "mx", "amp", "rep", "mc", "pb", "ym", "rup", "mic", "tm", "mod", "ep", "ma", "mn", "cp"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n", "idx": 20662, "substitutes": {"s": ["n", "p", "t", "sys", "is", "os", "set", "f", "h", "m", "ns", "ss", "ses", "ps", "bs", "cs", "sts", "i", "fs", "gs", "rs", "aws", "c", "ds", "z", "spec", "ls", "sv", "ssl", "utils", "ats", "hs", "sc", "S", "js", "g", "sq", "ts", "sp", "conf", "less", "sb", "b", "as", "v"], "stream": ["loop", "present", "time", "view", "response", "context", "message", "os", "length", "window", "Stream", "transform", "channel", "sync", "read", "socket", "row", "data", "test", "st", "size", "host", "pod", "version", "platform", "video", "sw", "REAM", "seq", "console", "buffer", "stage", "stack", "sequence", "path", "range", "each", "sample", "port", "v", "local", "steam", "ream", "sl", "chain", "iterator"], "presentation_time": ["presentation_timer", "presentation___TIME", "presentation___date", "presentATION_date", "presentationtimeduration", "presentation_TIME", "presentationTimetimer", "presentATION_duration", "presentationTimedate", "presentation_Time", "presentationTimeTime", "presentations_Time", "presentations_date", "presentationtimetime", "presentation___time", "presentations_timer", "presentationtimedate", "presentATION_TIME", "presentation_date", "presentation_duration", "presentATION_time", "presentationTimetime", "presentations_time", "presentation___duration", "presentationtimeTIME"], "m_obj_size": ["m_obj_dim", "m_obj_len", "m_Obj_size", "m_obj_num", "m_Obj_Size", "m_obj_Size", "m_Obj_num"], "m_obj_offset": ["m_objectxoffset", "m_obj_tile", "m_objxoff", "m_Obj_offset", "m_objJOffset", "m_obj_Offset", "m_object_off", "m_objJoffset", "m_obj____prefix", "m_objJoff", "m_objJtile", "m_obj____off", "m_obj____offset", "m_objxprefix", "m_obj_off", "m_Obj_Offset", "m_objectxoff", "m_objxoffset", "m_object_offset", "m_obj_prefix", "m_Obj_off", "m_objectxprefix", "m_object_prefix", "m_Obj_tile"], "payload_len": ["payload2len", "payloads_length", "payloads_Len", "payload00len", "payload00lon", "payloadetyLen", "payl_length", "payl_len", "payloads_len", "payl_Len", "payload_length", "payloadetylen", "payload00length", "payload_buf", "payload00Len", "payloads_buf", "payloadetybuf", "payload_lon", "payloadetylength", "payl_lon", "payload2length", "payload_Len", "payload2lon", "payload2Len"], "asf": ["ASfac", "asp", "iasf", "Asrf", "rasfo", "asg", "asfo", "lasf", "ASg", "iasfo", "ASf", " asfac", "lasrf", "ASv", "rasrf", "rasv", " asfi", " asv", " asg", "rasp", "iasfs", "asfac", "rasfac", "amsfo", "lasp", " asfo", "iasfi", "asfi", "asv", "Asfo", "Asp", "asfs", "amsfs", "lasfo", "amsfi", "asrf", "Asf", " asfs", "amsf", "rasg", "rasf"], "pb": ["p", "rb", "vp", "eb", "cb", "dc", "pm", "tp", "bps", "gb", "ker", "gc", "pkg", "bs", "pt", "pp", "lp", "uf", "mp", "pl", "tk", "lb", "wp", "tap", "cv", "cp", "um", "tab", "pa", "PB", "fb", "jp", "zb", "vm", "peer", "ap", "xb", "ab", "fp", "mb", "ctx", "bh", "ub", "dp", "wb", "db", "px", "pan", "stab", "kb", "amp", "pc", "np", "tc", "pg", "pool", "emb", "tm", "typ", "sb", "orp", "bp", "gp", "bj", "apa", "tf"], "val": [" aval", "valid", "p", "sel", " valid", "ival", " num", "ret", "ver", "high", "index", "vol", "ref", " eval", "aval", " el", "bal", " value", "value", "al", "bl", "rol", "eval", "key", "pl", "pt", "loc", "ind", "tx", "dim", "Val", " Val", "pol", "status", "col", "buf", "lev", "li", "ctx", "pr", "num", " ver", "seq", "res", "VAL", "vt", "vals", " len", "ch", " v", "typ", " VAL", "pos", "len", "elt", "b", "sil", "v", "el", "point", "sl", "serv"]}}
{"project": "FFmpeg", "commit_id": "0eaec10550bd9a0682db9f7920ed0d86f1450f4b", "target": 1, "func": "static int pcm_encode_frame(AVCodecContext *avctx,\n\n\t\t\t    unsigned char *frame, int buf_size, void *data)\n\n{\n\n    int n, sample_size, v;\n\n    short *samples;\n\n    unsigned char *dst;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n    case CODEC_ID_PCM_S16BE:\n\n    case CODEC_ID_PCM_U16LE:\n\n    case CODEC_ID_PCM_U16BE:\n\n        sample_size = 2;\n\n        break;\n\n    default:\n\n        sample_size = 1;\n\n        break;\n\n    }\n\n    n = buf_size / sample_size;\n\n    samples = data;\n\n    dst = frame;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = (v + 128) >> 8;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = ((v + 128) >> 8) + 128;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_alaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_ulaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    avctx->key_frame = 1;\n\n    //avctx->frame_size = (dst - frame) / (sample_size * avctx->channels);\n\n\n\n    return dst - frame;\n\n}\n", "idx": 20697, "substitutes": {"avctx": ["autcmd", "autwp", "wavctx", "avcmp", "cvwp", " avconn", "aftx", "avcontext", "autcv", "evctx", "avcv", "navctx", "navwp", "AVcmp", "avtx", "evconn", "cvcv", "AVconn", "evcontext", "avwp", " avcmp", "afcontext", "cvcmd", "afcmp", "AVcontext", "cvctx", "navcmd", "afctx", "avcmd", "AVtx", "navcv", "wavcontext", "autctx", "wavcmp", "evcmp", "AVctx", " avcontext", "wavtx", "avconn"], "frame": ["rame", "state", "message", "iframe", "context", "force", "f", "window", "image", "code", "space", "info", "fb", "frames", "show", "profile", "base", "Frame", "fr", "raw", "scene", "video", "seq", "feat", "buffer", "cf", "face", "sequence", "block", "sample", "framework", "fram", "origin", "point", "header", "chain", "channel"], "buf_size": ["buf_sum", "buf_length", "buf8length", "buf_Size", "buf_len", " buf_len", "buf2size", "buf2length", " buf_sum", "buf2count", " buf_length", "buf8count", "buf_count", "buf2len", " buf_Size", " buf_count", "buf8len", "buf8size"], "data": ["response", "binary", "message", "context", "m", "window", "value", "length", "channel", "table", "ata", "image", "package", "empty", "mu", "bytes", "step", "batch", "result", "buf", "extra", "raw", "DATA", "values", "video", "buffer", "area", "sequence", "Data", "range", "block", "bin", "next", "sample", "pointer", "feed", "padding", "text"], "n": ["fn", "all", "m", "err", "dn", "count", "none", "con", "on", "N", "no", "sn", "k", "ex", "after", "name", "gn", "non", "o", "cn", "ns", " ns", "x", "note", "i", "size", "nos", "nb", "names", "num", "new", "g", "ren", "ln", "norm", "nl", "b", "t", "rn", "number", "f", "tn", "y", "nor", "d", "nn", "c", "s", "z", "un", " N", "nt", "np", "len", "nc", "l", "el", "nan", "syn", "en", "p", "out", "na", "j", "nm", "pn", "ll", "ne", "an", "mn", "yn"], "sample_size": ["ample_set", "sample_id", "ample_size", " sample_id", "sample_Size", "Sample_size", "Sample_SIZE", "frame_Size", "sample_len", "sample_range", "frame_SIZE", " sample_len", "frame_size", "frame_range", "Sample_Size", " sample_SIZE", "sample_set", "ample_SIZE", "sample_SIZE"], "v": ["qv", "all", "message", "m", "value", "format", "vm", "temp", "uv", "k", "ov", "video", "sv", "qu", "ev", "vector", "rev", "vi", "conv", "x", "um", "i", "e", "wire", "status", "values", "vs", "at", "g", "u", "b", "lv", "t", "vc", "it", "f", "y", "d", "vr", "cv", "max", "c", "var", "av", "tv", "z", "ve", "html", "to", "pi", "l", "V", "vp", "vv", "vt", "p", "en", "ver", "h", "inv", "iv", "val", "get", "j", "version", "q", "ch", "nv", "w"], "samples": ["isents", "Sales", "bocks", "isamples", "isples", "samps", " sources", "ssamples", "saces", "spamples", "bizes", "Samps", "ssents", "damples", "samamples", " samps", " sores", "spores", "sales", "isocks", "dizes", "tamples", " sales", "docks", "Sples", "sples", "dources", "isamps", "Sumps", "isizes", "Sources", "nents", "namples", "sents", "dents", "taces", "ssamps", "daces", " sents", "assonents", "baves", "Samples", "assamps", "Sents", "sores", "isources", "samocks", "donents", "sumps", "spales", "tources", "spamps", "isaves", "sizes", "Sores", "sonents", "Socks", "isumps", "saves", "daves", "isaces", "damps", "assocks", "samamps", "assamples", "Sonents", "namps", "sources", "socks", "tocks", "bamples", "ssources", "numps"], "dst": ["dhrest", "dste", "dadest", "dtstop", "dld", "dhstr", "dodest", " dlt", "docists", "edst", "drdest", "ldstr", "ddstore", "ldst", "dest", "dstore", "Drest", "daut", " dST", "drmt", "ardman", "adST", "drst", "dtdest", "fdsts", "dhsts", "derust", "bdstack", "dset", " dists", "didth", "derste", "derstage", "dolt", "derut", "dsset", "rdust", "dth", "dhst", "dstr", "dlt", "edsts", "distage", "dsbs", "ardstore", "disst", "dhman", "ddstack", "adbs", "disstore", "dbstop", "dbST", "dasts", " dbs", "derrd", "dstack", "dhmt", "dhstore", "ardst", "didst", " drd", "dsl", "ardsts", "dbst", "drlt", "bddest", " drest", " dstr", "disdrop", "dsstore", "dport", "domt", "bdstop", "bdstore", "dman", "adstop", "didsts", "Dsts", "disstage", " dust", "disth", "docst", "bdld", "dstage", "rdst", "ddest", "dmt", " dstage", "bdsl", "Dstore", "bdST", "rdste", "bdut", " dsts", "derst", "ldrest", "edST", " dmt", "Dld", "dtrest", "fdth", " ddest", "adset", "dbstore", "dhport", "dstop", "dtst", "distack", "rdrd", "dissts", "diddrop", "dhists", "Dst", " dset", "dast", "adst", "eddest", "ddsts", "adstore", "dsdest", "disdest", " dstore", " dut", "dddest", "dost", "distore", "dbs", "dist", "Dstop", "Ddest", "dsst", "ddut", "docdest", " dman", "dsts", " dport", "fdst", "dists", "dersts", "dsest", "Dest", "ldmt", "daST", "ddst", "ardld", "fddrop", "dssts", "dissl", "disstack", "dhdest", "drest", "drd", "dust", "dastore", "dasl", "dST", "darest", " dstop", " dstack", "ddrop", "addest", "dastage", "DST", "dut", "arddest", "bdstage", "bdst", "docport", " dste"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {\n\n  register int i;\n\n  int __attribute__ ((aligned (16))) tempo[4];\n\n\n\n  if (filterSize % 4) {\n\n    for(i=0; i<dstW; i++) {\n\n      register int j;\n\n      register int srcPos = filterPos[i];\n\n      register int val = 0;\n\n      for(j=0; j<filterSize; j++) {\n\n\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n      }\n\n      dst[i] = av_clip(val>>7, 0, (1<<15)-1);\n\n    }\n\n  }\n\n  else\n\n  switch (filterSize) {\n\n  case 4:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_vEven, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 12) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\t// now put our elements in the even slots\n\n\tsrc_v = vec_mergeh(src_v, (vector signed short)vzero);\n\n\n\n\tfilter_v = vec_ld(i << 3, filter);\n\n        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)\n\n\n\n        // the neat trick : we only care for half the elements,\n\n        // high or low depending on (i<<3)%16 (it's 0 or 8 here),\n\n        // and we're going to use vec_mule, so we chose\n\n        // carefully how to \"unpack\" the elements into the even slots\n\n\tif ((i << 3) % 16)\n\n\t  filter_v = vec_mergel(filter_v,(vector signed short)vzero);\n\n\telse\n\n\t  filter_v = vec_mergeh(filter_v,(vector signed short)vzero);\n\n\n\n\tval_vEven = vec_mule(src_v, filter_v);\n\n\tval_s = vec_sums(val_vEven, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 8:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_v, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 8) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tfilter_v = vec_ld(i << 4, filter);\n\n        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)\n\n\n\n\tval_v = vec_msums(src_v, filter_v, (vector signed int)vzero);\n\n\tval_s = vec_sums(val_v, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 16:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1 = vec_ld(srcPos + 16, src);\n\n\tvector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tvector signed short src_vA = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tvector signed short src_vB = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n\tvector signed short filter_v0 = vec_ld(i << 5, filter);\n\n       \tvector signed short filter_v1 = vec_ld((i << 5) + 16, filter);\n\n        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)\n\n\n\n\tvector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);\n\n\tvector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n\tvector signed int val_s = vec_sums(val_v, vzero);\n\n\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  default:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int j;\n\n\tregister int srcPos = filterPos[i];\n\n\n\n        vector signed int val_s, val_v = (vector signed int)vzero;\n\n\tvector signed short filter_v0R = vec_ld(i * 2 * filterSize, filter);\n\n        vector unsigned char permF = vec_lvsl((i * 2 * filterSize), filter);\n\n\n\n        vector unsigned char src_v0 = vec_ld(srcPos, src);\n\n        vector unsigned char permS = vec_lvsl(srcPos, src);\n\n\n\n        for (j = 0 ; j < filterSize - 15; j += 16) {\n\n          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);\n\n          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          vector signed short src_vA = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          vector signed short src_vB = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n          vector signed short filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          vector signed short filter_v2R = vec_ld((i * 2 * filterSize) + (j * 2) + 32, filter);\n\n          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);\n\n          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);\n\n\n\n          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);\n\n          val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n          filter_v0R = filter_v2R;\n\n          src_v0 = src_v1;\n\n        }\n\n\n\n        if (j < (filterSize-7)) {\n\n          // loading src_v0 is useless, it's already done above\n\n          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);\n\n          vector unsigned char src_v1, src_vF;\n\n          vector signed short src_v, filter_v1R, filter_v;\n\n          if ((((int)src + srcPos)% 16) > 8) {\n\n            src_v1 = vec_ld(srcPos + j + 16, src);\n\n          }\n\n          src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          src_v = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          // loading filter_v0R is useless, it's already done above\n\n          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);\n\n          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          filter_v = vec_perm(filter_v0R, filter_v1R, permF);\n\n\n\n          val_v = vec_msums(src_v, filter_v, val_v);\n\n        }\n\n\n\n        val_s = vec_sums(val_v, vzero);\n\n\n\n        vec_st(val_s, 0, tempo);\n\n        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n\n\n    }\n\n  }\n\n}\n", "idx": 20698, "substitutes": {"dst": ["dasrc", " dct", "dlt", "dssrc", " dlt", "ddst", "ddwrite", " dsrc", " dstream", "dsct", "dsrc", "dwrite", "ststream", "ddstream", "dast", "stst", "dslt", "dct", " dwrite", "dalt", "dddest", "dact", "dstream", "stdest", "stwrite", " ddest", "dsst", "ddest"], "dstW": ["gotWR", "gotW", "dscW", "destV", "deltaW", "dscWA", "dstN", "distW", "dndEW", "dspEW", "distSize", "DstSize", "dndN", "dndF", "dstV", "dotEW", "gotEW", " dstF", "deltaWR", "DstV", "dsrcW", "dsrcV", " dstN", "dstWR", "deltaWA", "deltaEW", "dbtW", "dotW", "dbtF", "gstWA", "dstM", "DestW", "DestSize", "dbtN", "dspF", " dspEW", "dscWR", "destM", "distV", "dscEW", "DstW", "dbtEW", "gstWR", "dstSize", "dstEW", "dsrcM", " dspN", "dstWA", "dotWA", "dsrcSize", " dstEW", "destW", "dotWR", "gstEW", " dspF", "DstM", "dspN", "destSize", "gotWA", "DestV", "gstW", "dndW", "dstF", " dspW", "distM", "DestM", "dspW"], "src": ["sup", "Source", "SOURCE", "sys", "rc", "txt", "usr", "sel", "cont", "source", "sf", "sync", "conv", "pkg", "iv", "image", "secure", "loc", "stream", "dest", "bc", "target", "attr", "st", "s", "cur", "fp", "sr", "fil", "sn", "img", "ptr", "ssl", "control", "sw", "tmp", "sc", "addr", "in", "inc", "sort", "ins", "sq", "sub", "std", "rl", "ctr", "sur", "input", "inst", "sb", "ser", "supp", "lib", "syn", "sl"], "srcW": ["srcN", "rcN", "srcPos", " srcPos", "stPos", "stW", " srcN", "stSize", "srcSize", "rcSize", "rcPos", "rcW", "stN", " srcSize"], "xInc": ["zInc", "xyInit", "xyinc", "zinc", " xEnc", "zInit", "xInit", "xEnc", "xyEnc", "zEnc", " xinc", "xyInc", "xinc", " xInit"], "filter": ["lr", "out", "usr", "stop", "r", "source", "cont", "ref", "include", "f", "check", "length", "scale", "transform", "ilt", "conv", "val", "stream", "Filter", "mask", "target", "fw", "flat", "test", "select", "vec", "reverse", "profile", "proc", "fp", "flash", "fil", "pipe", "ff", "control", "map", "sc", "supp", "inc", "sort", "only", "match", "config", "term", "block", "bin", "v", "fl", "fc", "tf", "chain", "channel"], "filterPos": ["controlSize", " filterPosition", "controlPos", "FilterPoints", "FilterPOS", "filterPoints", "onlySize", "filterRes", "onlyPOS", "blockPosition", "blockSize", " filterRes", "reportRes", "filterPOS", " filterPoints", "reportPOS", "blockPos", "sortPOS", "FilterPos", "FilterSize", "controlPoints", "sortPos", "blockPOS", "onlyPos", "controlPOS", "sortRes", "reportPos", " filterPOS", "onlyPosition", "filterPosition"], "filterSize": ["FilterSIZE", "filterSense", "batchSize", "blockSIZE", "tableSIZE", "tableType", "filterSIZE", "tablePos", "FilterType", "filterType", "tableCount", "triggerSize", "windowSize", " filterScale", "batchType", "windowStyle", "filterStyle", "filterScale", "windowScale", "tableSize", " filterCount", "triggerSIZE", "blockSize", "testSIZE", " filterStyle", "triggerCount", "blockScale", " filterSIZE", "testCount", "FilterPos", "FilterSize", "FilterStyle", "blockCount", "tableStyle", "filterCount", "testStyle", "hashSense", "triggerSense", "FilterCount", "hashSize", "batchCount", "hashSIZE", "hashCount", "windowSIZE", "blockStyle", " filterSense", "testSize", "batchPos"], "i": ["is", "ic", "source", "io", "m", "ims", "im", "I", "ti", "ui", "ex", " bi", "v", "point", "uri", "name", "\u0438", "a", "si", "me", "o", "ai", "ix", "ji", "um", " ii", "ind", "sim", "gi", "info", " ti", "e", "ami", "status", "dr", "g", "u", "remote", "hi", "b", "bi", "t", "phi", "it", "iq", "ri", "r", "f", "xi", "y", "multi", "zi", "ei", "c", "s", "qi", "ini", "ip", "li", "ia", "ci", "mi", "ii", "to", "pi", "l", "series", "ij", "p", "through", "index", "di", "iu", "init", "ie", "val", "id", "ki", "iii", "iter"], "tempo": ["empo", "tempt", "empt", "temota", "emota", "surota", "timpt", "timpo", "surpt", "empi", "surpi", "tempi", "timpi", "timota", "surpo"], "j": ["n", "ij", "aj", "er", "p", "it", "r", "o", "si", "jl", "off", "y", "err", "ji", "by", "ie", "bs", "pt", "note", " ii", "ind", "on", " J", "jp", "z", "fr", "col", "jc", "bo", "other", "k", "jump", "J", "q", "ia", "oj", "pr", "kh", "jet", "ja", "js", "at", "g", "jo", "obj", "json", "kj", "uj", "next", "je", "jj", "l", "v", "bj", "dj", "b"], "src_v1": ["src_l7", "src_m7", "src_ver1", "src_h0", "src_ver0", "src_m2", "src_mF", "src_h7", "src_t2", "src_tF", "src_lN", "src_v2", "src_mN", "src_ver2", "src_t1", "src_vN", "src_j1", "src_l1", "src_v4", "src_v7", "src_h1", "src_verF", "src_m0", "src_t0", "src_j4", "src_j2", "src_t4", "src_v0", "src_hN", "src_j0", "src_l0", "src_m1", "src_m4"], "src_vF": ["src_b2", "src_w0", "src_mf", "src_mV", "src_h0", "src_p2", "src_bF", "src_m2", "src_mF", "src_avf", "src_pf", "src_pF", "src_vf", "src_wF", "src_VF", "src_VV", "src_v2", "src_hf", "src_avF", "src_vH", "src_hF", "src_mE", "src_V0", "src_hH", "src_wE", "src_bf", "src_m0", "src_wV", "src_VE", "src_v0", "src_vE", "src_av0", "src_avH", "src_p0", "src_vV", "src_b0"], "src_v": ["src_h", "src2t", "source_i", "source_p", "src_i", "src2p", "source_t", "src__m", "ser_s", "ser_vi", "src_rev", "src2i", "src_s", "source_v", "src__i", "source_V", "rc_t", "src__V", "src2V", "src___rev", "src2m", "src_p", "rc_o", "src___v", "src___h", "src_o", "rc_v", "src__v", "src___o", "src_vi", "src_t", "ser_f", "src_V", "src2v", "src_m", "src_f", "rc_p", "rc_h", "ser_v", "source_m", "rc_rev"], "filter_v": [" filter_m", "fil_vs", "filter___f", " filter_status", "filter_m", "filter_x", "filter_vs", " filter_f", "filter_uv", "fil_f", "fil_ve", "filter___vr", "filter_vr", "tail_v", "filter_ve", "filterpym", "filter___v", "filter_r", "filter___vs", "sort_v", " filter_vs", "sort_m", " filter_x", "filter_status", "tail_tv", "fil_uv", "filter_tv", "filterpyv", "sort_uv", "filter___x", "fil_v", "filterpystatus", "tail_r", "tail_vr", "filter___tv", "filter_f", "filter___r"], "val_vEven": ["val_mfree", "val_h0", "val2mzero", "val_mzero", "val_hZero", "val2vzero", "val_uzero", "val_ufree", "val_vzero", "val_sZero", "val_mEven", "val_jEven", "val_mZero", "val2vfree", "val______", "val2v0", "val_vZero", "val_____4", "val_vfree", "val_jzero", "val_j0", "val_4", "val_v0", "val2mfree", "val_m0", "val_jZero", "val_sEven", "val_uZero", "val_hzero", " val__", "val_szero", "val__", " val_4", " val_2", "val_____2", "val2vZero", "val_u0", "val2mZero", "val_s0", "val_2", "val_hfree", "val2m0"], "val_s": ["val_l", "val_m", "val2l", " val_sym", "fail_l", "fail_s", "val2v", "fail_v", "val2n", " val_m", "val2s", " val_n", "fail_n", "val_sym", "val_n"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n", "idx": 20716, "substitutes": {"env": ["qv", "scope", "txt", "context", "func", "param", "set", "code", "node", "var", "cur", " st", "buf", "ctx", "environment", "map", "dev", "mem", "stack", " context", "config", " environment", "conf", "obj", "ev", "attr", "w"], "value": ["property", "VALUE", "python", "vector", "create", "view", "hello", "use", "message", "widget", "comment", "process", "commit", "field", "go", "attribute", "hash", "item", "val", "image", "total", "package", "unknown", "time", "code", "document", " message", "Value", "data", "select", "size", "get", " Value", "see", "function", "word", "now", "request", "raw", "ve", "values", "server", " input", "VAL", "buffer", "self", "feature", " v", "instance", "job", "action", "block", "address", "execute", " values", "json", "input", "ue", "v", "V", "vp", "type"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n", "idx": 20722, "substitutes": {"obj": ["resp", "rect", "txt", "ht", "org", "o", "os", "ref", "object", "ob", "act", "pt", "ot", "og", "onet", "xy", "imp", "hw", "img", "op", "ctx", "bo", "now", "bh", "oj", "pr", "ex", "tmp", "js", "Obj", "nt", "ist", "obs", "objects", "typ", "gov", "bj", "attr"], "v": ["p", "t", "vis", "view", "o", "r", "vi", "f", "h", "m", "conv", "vu", "iv", "vr", "vim", "mint", "x", "vm", "cv", "vy", "c", "av", "tv", "j", "uv", "q", "sv", "vs", "vt", "g", "b", "l", "V", "vp", "ev", "w"], "opaque": ["oplay", " Opaco", " opaques", " Opaque", " opaco", " Opque", " opque", " opatile", "oppatile", "Opatile", "oppque", "oppaques", "Opaque", "opaques", " Oplay", "opplay", "oppaco", "Opaques", " oplay", "opaco", "Opque", "opque", "oppaque", "opatile"], "name": ["NAME", "n", "search", "cap", "missing", "comment", " names", " Name", "alias", "type", "title", "nam", " prefix", "key", " NAME", "label", "def", "ame", " path", "str", "named", "word", "nm", "names", "Name", "part", "error", " key", "prefix", "path", "term", "w", "attr", "text"], "errp": ["erp", "errP", "errm", "arrpa", "errr", "rrpc", "errpa", "erpc", "err", " errP", " errpc", "errpid", "lerpun", "ererp", "errpad", "rrP", "arrp", "rrpa", " errpa", "lerp", "errpc", " erpun", "ererpun", "lerpad", "rrr", " erp", "lerpid", " errr", "ererpad", "rrm", "erP", "ererpid", "errpun", " erpad", "rrp", "arrpc", "arrm", " errm", " erpid"], "prop": ["perm", " poss", "p", "prot", "tag", "desc", " pos", "pred", "rel", "pkg", "val", "pro", "pt", "ps", "fac", "key", "def", "mp", "prof", "pri", "rop", "pa", "jp", "proc", "cfg", "col", "op", "Prop", " prob", "pr", "ph", "feat", "opt", "priv", " Prop", "per", "rep", "pb", " proc", " comp", "cmd", "fam", "mod", " p", "acc", "att", "comp", " props", "attr", " pro"], "value": ["property", "valid", "VALUE", "state", "number", "set", "index", "field", "length", "attribute", "object", "iv", "val", "total", "key", "text", "current", "id", "code", "Value", "data", "max", "test", "size", "byte", "tv", " Value", "result", "checked", "version", "see", "values", "VAL", "entry", "unit", "instance", "expression", "address", "json", "input", "ue", "widget", "vp", "distance", "type"]}}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n", "idx": 20728, "substitutes": {"path": ["name", "mat", "p", "present", "end", "out", "txt", "cont", "alias", "check", "ix", "transform", "ac", "dir", "pkg", "th", "url", "pt", "text", "stream", "dest", "code", "empty", "str", "c", "php", "host", "test", "local", "Path", "PATH", "pattern", "prop", "raw", "spec", "link", "full", "component", "template", "ath", "prefix", "cmd", "remote", "pointer", "port", "pat", "file", "cp", "uri", "dot", "chain", "w"]}}
{"project": "qemu", "commit_id": "1466cef32dd5e7ef3c6477e96d85d92302ad02e3", "target": 0, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 20738, "substitutes": {"d": ["ed", "p", "t", "dm", "dx", "D", "dd", "di", "did", "f", "dc", "h", "m", "du", "y", "sd", "dn", "e", "dt", "bd", "c", "ds", "md", "hd", "j", "dat", "dr", "g", "fd", "dos", "pd", "b", "l", "v", "da", "w"], "i": ["n", "bi", "p", "t", " li", "si", "index", "di", " x", " pos", "xi", "m", "ix", " err", " l", "y", " I", "multi", " m", " my", " index", "x", " ii", " n", " ti", "I", " iter", "c", "s", "j", "li", " k", " bi", " ni", "g", " j", " counter", " v", " pi", "mi", "u", "ii", " c", "pi", "b", " e", "v", " multi", "l", "counter"], "mch": ["emsch", "mailcht", "ychn", "esmcht", "gmche", "Mchid", " mchid", " mkh", "esmkh", "tmchid", "esmCh", "cmach", "amche", "tmach", "mtcht", "pich", "Mich", "mchn", "mech", "cmchn", "mailche", "mtch", "mtchn", "mgt", "cmech", "stanoch", "matkh", "pch", "manch", " mich", " mht", "emcht", "memach", "amech", "emach", "mailch", "tmzh", "stanch", "msch", "remcher", "rmchid", "emzh", "tmech", "pche", "emcher", "mrach", "mht", "mrch", "rmoch", "emtch", "esmch", "rmach", "modcher", "cmform", "cmoch", "parch", "nmcher", "mth", "mCh", "tmth", "cmarch", "remcht", "emth", "nmcht", "pth", "cmch", " mth", "amch", "nmth", "cmcht", "rmcher", "smach", "mrech", "mich", "tmch", "gmkh", "pmich", "remach", "amth", "pmche", " mcht", "emchid", "amchn", "modth", "cmgt", "rmth", "imcht", "pach", "esmach", "memchn", "gmCh", "pmzh", "emch", "nch", "Mch", "ychid", "mchid", "remkh", "ych", " mach", "vmch", "pht", " mcher", "imach", "remche", "cmchan", "esmzh", "matoch", "mailchn", "esmcher", "amoch", " mchn", "gmoch", "vmach", "stanform", "imzh", "pcht", "nmch", "manchn", "psch", "remch", "gmach", "emchn", "memch", "esmche", "gmtch", "smich", " mCh", "gmcht", "remech", "mkh", "cmchid", "mtach", "gmch", "mailchid", "rmche", "cmsch", "nchid", "emoch", "esmarch", "smch", "imcher", "mancht", "match", "tmCh", "mailCh", "cmche", "imich", "matchan", "remzh", "tmcht", "gmchn", "cmich", "mform", "rmchn", "gmich", "mailich", "pmch", "emht", "imch", "march", "pech", "rmch", "emCh", "manche", " mech", "vmcht", "pmcht", " moch", "emich", "rmCh", "nmche", "amcht", "tmcher", "nich", "moch", "mche", "vmche", "nach", "pchn", "mzh", "tmich", "pmcher", "mailcher", "gmchan", "rmkh", " mform", "smchid", "mach", "vmchn", "emche", " mgt", "rmtch", " mche", "tmche", "tmchn", "modch", "memich", "stangt", "mcher", "amkh", "amchan", "nmach", "rmcht", "esmech", "pkh", "mchan", "stanich", "modich", "Mach", "tmchan", "stanchid", "yCh", "mrcht", "mcht", "pchan", "pchid", "rmich"]}}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static int h261_find_frame_end(ParseContext *pc, AVCodecContext* avctx, const uint8_t *buf, int buf_size){\n\n    int vop_found, i, j, bits_left, last_bits;\n\n    uint32_t state;\n\n\n\n    H261Context *h = avctx->priv_data;\n\n\n\n    if(h){\n\n        bits_left = h->bits_left;\n\n        last_bits = h->last_bits;\n\n    }\n\n    else{\n\n        bits_left = 0;\n\n        last_bits = 0;\n\n    }\n\n\n\n    vop_found= pc->frame_start_found;\n\n    state= pc->state;\n\n    if(bits_left!=0 && !vop_found)\n\n        state = state << (8-bits_left) | last_bits;\n\n    i=0;\n\n    if(!vop_found){\n\n        for(i=0; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    i++;\n\n                    vop_found=1;\n\n                    break;\n\n                }\n\n            }\n\n            if(vop_found)\n\n                    break;    \n\n        }\n\n    }\n\n    if(vop_found){\n\n        for(; i<buf_size; i++){\n\n            if(avctx->flags & CODEC_FLAG_TRUNCATED)//XXX ffplay workaround, someone a better solution?\n\n                state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pc->frame_start_found= vop_found;\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 20741, "substitutes": {"pc": ["p", "sys", "isc", "vc", "rc", "py", "func", "process", "dc", "pm", "tp", "iac", "PC", "disc", "pac", "sync", "gc", "ct", "pkg", "pt", "pp", "lp", "po", "mp", "wp", "bc", "cs", "cu", "unc", "c", "pa", "php", "peer", "ec", "cmp", "proc", "pod", "ctx", "cpu", "pr", "arc", "icc", "lc", "px", "amp", "anc", "pb", "cam", "tc", "acl", "cc", "pi", "pd", "pat", "cp", "pas", "pic"], "avctx": ["aptx", "avconfig", "Avconn", "avcmp", "evconfig", " avconn", "abcmp", "avcontext", "evctx", " avconfig", "abtx", "avesys", "avtx", "Avcontext", "apctx", "evconn", "apcontext", " avsys", "evcontext", "avetx", "apcmp", "avecontext", " avcmp", "avsys", "AVsys", "AVcontext", "abctx", "Avconfig", "AVtx", "Avctx", "avectx", "AVctx", " avcontext", " avtx", "avconn", "abcontext"], "buf": ["bag", "p", "rb", "msg", "bits", "bf", "cb", "window", "words", "late", "aka", "ob", "mus", "Buff", "pkg", "bs", "arr", "uf", "bar", "Buffer", "bc", "cv", "bn", "data", "fb", "bytes", "vec", "que", "batch", "proc", "img", "ctx", "nm", "br", "queue", "wb", "seq", "map", "db", "buffer", "mem", "doc", "buff", "pb", "block", "np", "bu", "cmd", "cam", "bin", "b", "bp", "v", "cast"], "buf_size": ["uf_no", "uf_size", "uf_Size", "uf_fee", "buf_length", "buf_Size", "buf_speed", "buf_SIZE", "cb_SIZE", "buf_number", "bufibfee", "bufibspeed", "buf8Size", "buf_no", "buf_ize", "bufibsize", "cb_size", "buf8no", "cb_ize", "cb_length", "uf_number", "buf_fee", "buf8number", "bufibSize", "buf8size", "uf_speed"], "vop_found": ["vop_sold", "vrop_found", "vop___sold", "vop___matched", "vap_needed", "vop5founded", "vop_needed", "vomp_found", "vopCfounded", "vop___given", "vop___packed", "vop___found", "vopCpresent", "voplychanged", "vop_packed", "vap_printed", "vop_matched", "vop67kept", "vok_fd", "vop_for", "voop_packed", "vop___forced", "voop_matched", "vop_tested", "vop67found", "vop_failed", "vopptpacked", "vop_full", "voom_found", "vop_forced", "vop67fd", "vopt_found", "voom_kept", "vop_allowed", "vop_changed", "voom_forced", "vok_found", "vop_fixed", "voom___kept", "vopLfind", "voop_fixed", "vopptfind", "vap_found", "vop_result", "vopLallowed", "vrop_fd", "vopptfixed", "vop67sold", "vopt_full", "vopLfull", "voop_found", "vomp_tested", "vop_Found", "voom___forced", "voop_result", "vopLfound", "vop_present", "vop67for", "vop___result", "vopptmatched", "vop___kept", "vop67forced", "vap_Found", "voplyfailed", "vopptallowed", "voom_sold", "vomp_founded", "voom___found", "vok_changed", "voom___sold", "voptLfull", "vop_fd", "vop_find", "voptLallowed", "vrop_for", "vop_printed", "voplyfound", "voptLfind", "vopptfound", "vopCfound", "voplyfd", "vop67find", "voptLfound", "vop5tested", "vop___fixed", "vok_failed", "vrop_find", "vop_given", "vopt_allowed", "vomp_present", "vopt_find", "vop_kept", "vop5present", "voop_given", "vopptfull", "vop_founded", "vopCtested", "vop5found"], "i": ["is", "ic", "io", "m", "ims", "im", "I", "ti", "cli", "k", "ui", "ex", "ir", "point", "uri", "n", "Index", "start", "si", "me", "o", "ai", "ix", "ji", "x", "ind", "sim", "e", "gi", "info", "ami", "status", "oi", "ik", "at", "g", "iat", "u", "hi", "bi", "parent", "phi", "it", "ri", "f", "xi", "y", "multi", "zi", "iri", "ei", "c", "qi", "ini", "ip", "z", "li", "ia", "in", "ci", "mi", "ii", "to", "pi", "l", "ori", "ij", "p", "out", "print", "index", "di", "iu", "init", "id", "ki", "iter", "eu"], "j": ["m", "err", "th", "pt", "jp", "fr", "k", "br", "res", "v", "dj", "ev", "n", "aj", "ed", "ion", "o", "ix", "ji", "note", "ind", "my", "J", "pr", "adj", "at", "g", "je", "b", "att", "bj", "bi", "t", "it", "jit", "r", "y", "by", "d", "str", "c", "s", "z", "bo", "li", "other", "ja", "try", "jo", "obj", "kj", "l", "el", "ij", "er", "p", "out", "jl", "index", "di", "ie", "ge", "ng", "jc", "jump", "q", "js", "ch", "block", "uj", "json", "ne", "mn", "jj", "gov"], "bits_left": ["bytes_found", "bitsptlast", "bits08length", "ports_found", "ports_last", "ports_low", "bits_l", "bitsityleft", "fits_left", "bits_loc", "files_l", "bit_left", "bytes_right", "bitsitylow", "ports_left", "fitsitylow", "bits_low", "bitsptleft", "bit_enabled", "bs_right", "bits08left", "fitsityneeded", "bits_found", "bits_lt", "bits_enabled", "bits32loc", "bits_last", "bytes_left", "fits_lower", "bit_entry", "bits_needed", "bitsitylower", "files_Left", "bitslentry", "fitsityleft", "bitsptfound", "bits08entry", "bitsllength", "bits_lower", "bits_Left", "bitspfound", "bitslleft", "bits08enabled", "bitslenabled", "bs_left", "bit_length", "fits_needed", "bitsityneeded", "bits32right", "bits32left", "bits_length", "bytes_needed", "bitspneeded", "bits_entry", "bits_right", "fitsitylower", "bitsptlow", "bs_loc", "files_left", "files_lt", "fits_low", "bitspleft", "bitspright"], "last_bits": ["last88stats", "last___bps", " last_bugs", " last_bis", " last_bps", "first_bytes", "first_pins", "last_pins", "last___bugs", "last_bps", "last__bps", "last\u0648bit", "last_bit", "last_bugs", "last88bytes", "first_bits", "last\u0648bits", "last80bytes", "last__bits", "last\u0648bugs", " last_blocks", "last___pins", "last80bits", " last_stats", "last88bis", "last_stats", "first_bit", "last\u0648blocks", "last___bit", " last_bit", "last__bytes", "last___bits", "last_blocks", "last__bugs", "first_parts", "last_bytes", "last_bis", "last88bits", " last_bytes", "last80stats", "last_parts", "last___bytes", "last80bis"], "state": ["all", "is", "msg", " block", "commit", " family", "policy", "zone", "value", "progress", "length", "err", "debug", " choice", "user", "timeout", "close", " score", "temp", "what", "map", "component", "be", " code", "port", "STATE", " err", "local", "type", "name", "loop", "start", "resource", "comment", "list", "State", "stat", "te", "ns", " start", "power", "trace", " size", "info", " error", "data", "size", "handle", "states", "status", "base", "see", "mode", " port", "rule", "location", "sequence", "ace", " name", "powered", "public", "update", "instance", " event", "scope", "tag", "it", "frame", "memory", "ping", "color", "hash", "stats", "reason", " ignore", "ps", "description", "style", "spec", "position", "buffer", "we", "try", "in", " key", "config", " offset", "range", "cache", "store", "to", "l", " action", " body", " timeout", "out", " rule", "print", "where", "index", "set", " policy", "offset", "al", "init", "val", "key", "id", "code", "conn", " speed", "or", "test", "st", "version", "lock", "result", "queue", " status", "error", " step", "block", "ne", "can", " msg"], "h": ["comm", "history", "p", "t", "dh", "he", "ht", "zh", "eh", "hh", "o", "hal", "H", "oh", "m", "hash", "c", "host", "hd", "enh", "hw", "hr", "ih", "ctx", "here", "bh", "hz", "sh", "ph", "kh", "rh", "hs", "hm", "hl", "hp", "ch", "uh", "http", "has", "ah", "b", "l", "v", "hi"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_write(AddressSpace *as, target_phys_addr_t addr,\n\n                         const uint8_t *buf, int len)\n\n{\n\n    address_space_rw(as, addr, (uint8_t *)buf, len, true);\n\n}\n", "idx": 20743, "substitutes": {"as": ["is", "ras", "am", "a", "sa", "sac", "os", "nas", "ach", " us", "ns", "aos", "aw", "ase", "ar", "asa", "bs", "ps", "las", "ias", "ars", "rs", "sis", "ass", "s", "asm", "ast", " es", "ms", "js", "es", "aus", "AS", "ak", "an", "oss", "pas", "As"], "addr": [" address", "dh", "r", "arp", "ack", "ref", "off", "err", "add", " plat", "ac", "act", "wid", "ar", "src", "loc", "x", "on", "tx", "ip", "hw", "coord", "ord", "urg", "ptr", "align", "ag", "alt", "adr", "at", "dr", "ad", "mem", "wd", "address", "cmd", "obj", "pos", "pad", "attr"], "buf": ["bag", "cap", "alloc", "cb", "uffer", "ref", "window", "late", "aka", " buffer", "Buff", "etc", "arr", "uf", "bc", "Buffer", "cv", "bn", "data", "bytes", "vec", "que", "batch", "result", "img", "raw", "queue", "seq", "map", "buffer", "box", "mem", "new", "doc", "buff", "block", "pb", "cmd", "b", "v"], "len": ["n", "en", " length", "lit", " clen", "Len", "h", "length", " l", "wid", "count", "val", "pl", "loc", "lp", "lan", "size", "bytes", "vec", "kl", "lang", "fil", " bl", "num", "seq", "hl", "fin", "mem", "ln", "nt", "pos", "nl", "ll", "lf", "elt", "l", "el", "L"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_run_capture (AudioState *s)\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        int live, rpos, captured;\n\n        HWVoiceOut *hw = &cap->hw;\n\n        SWVoiceOut *sw;\n\n\n\n        captured = live = audio_pcm_hw_get_live_out (hw);\n\n        rpos = hw->rpos;\n\n        while (live) {\n\n            int left = hw->samples - rpos;\n\n            int to_capture = audio_MIN (live, left);\n\n            st_sample_t *src;\n\n            struct capture_callback *cb;\n\n\n\n            src = hw->mix_buf + rpos;\n\n            hw->clip (cap->buf, src, to_capture);\n\n            mixeng_clear (src, to_capture);\n\n\n\n            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n                cb->ops.capture (cb->opaque, cap->buf,\n\n                                 to_capture << hw->info.shift);\n\n            }\n\n            rpos = (rpos + to_capture) % hw->samples;\n\n            live -= to_capture;\n\n        }\n\n        hw->rpos = rpos;\n\n\n\n        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {\n\n            if (!sw->active && sw->empty) {\n\n                continue;\n\n            }\n\n\n\n            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {\n\n                dolog (\"captured=%d sw->total_hw_samples_mixed=%d\\n\",\n\n                       captured, sw->total_hw_samples_mixed);\n\n                captured = sw->total_hw_samples_mixed;\n\n            }\n\n\n\n            sw->total_hw_samples_mixed -= captured;\n\n            sw->empty = sw->total_hw_samples_mixed == 0;\n\n        }\n\n    }\n\n}\n", "idx": 20751, "substitutes": {"s": ["p", "t", "is", "sys", "sa", "r", "os", "set", "sing", "ys", "h", "ss", "ses", "ps", "space", "sts", "sim", "fs", "gs", "rs", "c", "ds", "se", "sm", "sn", "spec", "ls", "ssl", "sv", "spe", "sc", "S", "js", "sq", "ts", "sp", "sg", "sb", "as", "v", "sl"], "cap": ["clip", "hap", "mp", "wp", "ape", "sv", "spe", "map", "qu", "cr", "cn", "pp", "copy", "tap", "cmp", "caps", "cf", "pan", "cam", "cmd", "acl", "wa", "cc", "cp", "comm", "com", "vc", "aps", "co", "act", "gc", "aw", "cu", "cv", "c", "cl", "snap", "av", "ip", "ab", "buf", "cod", "ctx", "Cap", "sh", "shape", "sp", "CAP", "ca", "cast", "vp", "serv", "ach", "window", "ac", "ct", "capt", "pl", "ctrl", "bc", "ipp", "ap", "prop", "sam", "grab", "chip", "addr", "craft", "ch", "amp", "can", "cfg", "wav", "w"], "live": ["fresh", "length", "shot", "loaded", "ld", "mp", "hot", "liv", "lo", "lim", "low", "player", "prime", "visible", "sample", "ctl", "sl", "ed", "life", "Live", "ind", "i", "lt", "watch", "linked", "db", "active", "bound", "only", "nl", "hi", "t", "load", "high", "locked", "ref", "y", "mid", "act", "d", "lived", "max", "enabled", "living", "tight", "ready", "ls", "ife", "sp", "len", "line", "l", "vp", "gt", "valid", "available", "old", "lit", "latest", "val", "pl", "id", "online", "le", "full", "here", "sam", "hl", "addr", "iter", "ive", "fps"], "rpos": ["rarpt", " rpt", "ppo", "pport", "ploc", "Rloc", "lpose", "mrloc", "srpos", "lcon", "erport", "vrpos", "rPos", "lrpos", "lpl", "rp", "rpid", "vrpro", "rpo", "rpro", "rarpor", "rpt", "rpose", "Rpt", "erp", "mrpo", "mrpl", "lpo", "pp", " rport", "lcol", "rloc", "rarposition", "lpro", "vrcon", "mrposition", "rcpt", " rpor", "lpos", "rposition", "erpt", " rpo", "ppt", "lloc", "rarpo", "rPOS", "mrpose", "rport", "mrpt", "vrpl", "lrpro", "ppos", "rcon", "erpos", " rloc", " rPos", "vrpt", "rarpl", "vrposition", "Rpos", " rposition", "vrcol", "Rpid", "lrcol", "lpid", "rcol", "rcpid", "rcloc", "mrPos", " rPOS", "rcpos", " rp", "lpt", "srPOS", "lposition", "Rpo", "ppose", "rarpos", " rpl", "rpl", " rpid", "mrpos", "RPos", "srpo", "lrcon", "rpor", "rarPOS", "srpor"], "captured": ["mittorted", "collectuated", "mittpled", "capturable", "caported", "censured", "collectified", "collecturable", "Captored", " captored", "apture", " captpled", "censired", "captored", " captorted", "captached", "aptored", "Captured", " capturated", "collectorted", "Captached", "configured", "capturred", " capturized", "mittured", "capified", "aptured", "configurred", "quantified", "papled", "paorted", "quantuated", "aptired", "captorted", "censurred", "censurated", " captached", " capturable", "configired", "mitturred", " capture", "quantured", "paured", "capture", "aptached", "capturated", " capturred", "capturized", "apturated", "captified", "apturized", "configurable", "apturable", "captired", "Capture", "captpled", "censurable", "quantorted", "collectured", "captuated", "collecturated", "collecturized", "capured", "capuated", "apturred", "paurred"], "hw": ["hap", "igh", "ww", "wi", "wy", "wp", "hd", "rw", "wx", "wl", "bh", "wb", "hs", "ow", "ew", "kw", "hip", "hh", "ha", "aws", "wr", "watch", "cmp", "iw", "wind", "haw", "ih", "hz", "rh", "hm", "mem", "wcs", "wd", "wo", "cam", "wa", "lv", "ht", "vc", "health", "wk", "aw", "nw", "pkg", "vr", "cu", "cv", "psc", "ctx", "mg", "sh", "wit", "we", "rpm", "wn", "vp", "dh", "ich", "h", "rew", "window", "hop", "conn", "fw", "mph", "chip", "shake", "hl", "addr", "craft", "wm", "w"], "sw": ["kw", "was", "sys", "ssh", "sa", "wh", "rew", "ss", "sf", "sk", "window", "ww", "sd", "aw", "nw", "th", "serv", "SW", "wp", "nn", "fw", "syn", "watch", "iw", "snap", "tr", "se", " SW", "wrap", "warn", "rw", "wx", "sn", "sm", "sr", "sam", "sh", "sv", "ssl", "ow", "we", "sc", "ch", "ess", "amp", "qu", "sp", "Sw", "esp", "squ", "wo", "tw", "wt", "ew", "wn", "sb", "wa", "sql", "oss", "so", "swe", "ev", "sl", "w"], "src": ["sys", "rb", "lr", "rc", "txt", "sel", "usr", "source", "sf", "conv", "vr", "iv", "bs", "url", "loc", "attr", "rs", "str", "ipl", "fp", "sr", "img", "sn", "buf", "ctx", "ptr", "bh", "rt", "tmp", "sh", "hl", "buffer", "sc", "addr", "new", "sq", "sp", "std", "rl", "buff", "sg", "obj", "sur", "inst", "input", "sb", "ser", "supp", "ctr", "sl"], "cb": ["kw", "rb", "rc", "eb", "vc", "bf", "func", "cn", "callback", "CU", "abc", "gb", "conv", "ob", "bs", "erb", "lb", "CB", "ctrl", "bc", "tk", "conn", "cd", "cv", "cu", "c", "fb", "ec", "zb", "cmp", "nb", "buf", "cod", "ctx", "cell", "ub", "tmp", "wb", "db", "cm", "lc", "cf", "ch", "job", "pb", "bt", "cmd", "cr", "obj", "buff", "nc", "cc", "b", "sb", "obb", "bj", "cp", "cfg", "bb", "abb"]}}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "substitutes": {"chr": [" chebr", " chbr", " charar", " chrc", " charr", "Chrc", "chrt", " chro", " charrt", " chero", "chear", " cher", "Chrt", "chro", " chrt", " chear", " charrc", "Chr", "Char", "chero", "chebr", "chrc", "chbr", "cher"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n", "idx": 20766, "substitutes": {"base": ["name", "parent", "p", "create", "Base", "state", "basic", "start", "out", "bf", "index", "set", "ref", "back", "m", "root", "length", "offset", "scale", "init", "ase", "key", "mb", "bs", "top", "x", "id", "i", "max", "balance", "size", "family", "cpu", "server", "buffer", "bound", "prefix", "based", "zero", "address", "store", "bas", "b", "bp", "v", "local", "bid", "type"], "irq": ["ibrql", "irqu", " arql", " virqu", " virq", " irqu", "nirq", "irqq", " arqu", "nirqq", " irqq", "irql", " virqq", " arqq", "ibrq", "ibrqu", " arq", "nirqu", " virql", "ibrqq"], "version": ["ception", "vector", "time", "ver", "ion", "number", "index", "depth", " versions", "length", "release", "hash", "value", "order", "format", "Version", "power", "package", "VER", "level", "generation", "step", "vers", "status", "VERSION", "family", "mode", "spec", "ision", "server", "position", "development", "major", "component", "sequence", "supported", "feature", "date", "direction", "command", "vision", "v", "versions", "class", "type"], "dev": ["ed", "cho", "p", "sys", "out", "ver", "det", "Dev", "die", "DE", "dd", "ach", "di", "dis", "go", "device", "sd", "dn", "th", "d", "serv", "enc", "pro", "pt", "val", "def", "data", "test", "des", "ds", "md", "Device", "tr", "av", "DEV", "ve", "ex", "sh", "res", "gu", "sky", "dem", "de", "mem", "ad", "new", "priv", "ch", "nt", "vo", "adv", "cmd", "obj", "an", "pad", "att", "v", "eng", "ev", "w"], "s": ["n", "comm", "p", "sys", "is", "sa", "os", "m", "h", "ns", "ss", "us", "sd", "stats", "bs", "ps", "cs", "sts", "socket", "rs", "gs", "fs", "ds", "z", "sm", "ls", "sam", "sh", "sv", "ms", "vs", "hs", "self", "S", "js", "g", "es", "its", "sq", "ts", "sp", "als", "ins", "sb", "b", "l", "sl"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 20797, "substitutes": {"cpu": ["core", "t", "p", "sys", "gpu", "rc", "ck", "alloc", "frame", "os", "processor", "process", "stat", "boot", "tp", "exec", "ean", "gc", "pkg", "ruby", "bench", "x", "nz", "conn", "cu", "socket", "cv", "vm", "c", "gnu", "arch", "cli", "proc", "hw", "nu", "worker", "mac", "ork", "pu", "aux", "ctx", "kernel", "nan", "clock", "queue", "aco", "apache", "uart", "bean", "ka", "project", "mem", "eu", "runner", "docker", "rpm", "pc", "uu", "tc", "CPU", "linux", "nc", "client", "exe", "cp", "net", "xc", "aq"], "r1": ["nr2", "nr3", "R1", " r2", "r01", "rc0", "rc2", "ar1", "r8", "nr01", "raj", "p3", "R3", "rc3", "r9", "rOne", "rc5", "p1", "nr5", "nr9", "R0", "nr8", "R2", "Raj", " r9", "rc9", " r8", " r5", "attr3", "attr2", "ar01", "R9", "nr1", "rc1", "ar8", "p2", "attraj", " r0", "r0", "nrOne", " raj", "ROne", "attr1", " r01", "r5", "r2", "rcOne", "ar3"], "r3": [" r2", "p12", "R3", "R4", "pr3", "t6", " r6", "R2", "pr2", "t3", "R6", " r4", "r6", "pr12", "r12", " r12", "p2", "r4", "t2", "t4", "r2", "p3"], "gaddr": ["gaddress", "bgaddress", "gmaddress", "giaddr", "bgarch", "gptr", "giaddress", "bgaddr", "garch", "gmaddr", "bgptr", "gmarch", "giarch", "giptr", "gmptr"], "ar": ["er", "am", "dar", "r", "arp", "ai", "tar", "al", "arr", "rr", "ars", "bar", "rar", "or", "ray", "var", "aster", "AR", "arc", "ir", "ta", "par", "dr", "ara", "ra", "star", "atar", "are", "ear"], "env": ["ee", "esm", "eh", "et", "desc", "eni", "equ", "gear", "eg", "vm", "worker", "uv", "event", "web", "server", "sw", "pe", "stage", "oe", "ew", "v", "ev", "state", "engine", "context", "e", "esc", "environment", "vs", "entry", "db", "home", "ka", "dev", "erd", "esp", "era", "cmd", "Environment", "eng", "network", "net", "t", "exec", "pkg", "ei", "cv", "tx", "outer", "den", "ec", "hw", "buf", "ctx", "spec", "kernel", "extra", "ve", "kh", "stack", "config", "sp", "docker", "req", "conf", "obj", " environment", "nc", "el", "vp", "shell", "serv", "er", "en", "end", "txt", "org", "window", "init", "ie", "ext", "conn", "code", "enter", "here", "queue", "console", "viron", "priv", "eu", "doc", "site", "ah", "nv"], "pbdev": ["cbobj", "cbdevice", "pbDev", "bpby", "fbdiv", "PBdevice", "pbder", "pbdiv", "bpdevice", "bpdef", "ubdevice", "bpdev", "pgdev", "cbdes", "lpdev", "lpserv", "ubdriver", "bpdes", "PBdes", "cpby", "ubserv", "pgdiv", "objdev", "pbdes", "fbdev", "cpder", "pbdef", "PBDev", "bpserv", "pgdevice", "pcder", "cbdiv", "objserv", "cbval", "pcdev", "objobj", "pcdef", "ubobj", "pbdriver", "pgval", "bpder", "pbobj", "pbval", "PBdiv", "objDev", "bpDev", "ubdev", "ubDev", "cbdev", "cbDev", "pbserv", "pbby", "pbdevice", "lpdriver", "bpdriver", "cpdev", "pgDev", "cpdef", "PBdev", "fbval", "pcby", "lpdevice", "cbserv", "fbdevice"], "mr": ["lr", "rb", "mor", "rn", "usr", "dar", "r", "shr", "m", "ml", "vr", "rr", "rg", "tur", "rar", "rs", "tr", "MR", "hr", "sr", "mt", "fr", "bm", "br", "kr", "ur", "adr", "rm", "drm", "dr", "ocr", "gr", "mc", "rpm", "Mr", "mn", "mir", "wm"], "i": ["p", "a", " si", " vi", "si", "r", "di", "f", " pos", " I", "ei", "x", " ti", "I", " di", "j", "li", " bi", " ni", "ci", " j", " v", " pi", "ii", " mi", " p", "l", "v"], "fh": ["fdh", "fx", "fth", "lfH", "tfhd", "fhl", "sfoh", "ufch", "bw", "ufhi", " fH", "sfh", "bch", "bH", "bhi", "dfx", "fehd", "tfh", "cfw", "bth", "fH", "sfhs", "ffhl", "fhd", "bc", "fkh", " fc", "fw", "sfhl", "fhs", "ufw", "tfhandle", " fhandle", "tfc", "cfh", "tfkh", "cfch", "bh", "ffh", "fdhs", "tfH", "ffoh", "ffhs", " fhd", " fkh", "fdoh", "ufh", "fekh", "foh", "cfhi", "lfc", "dfh", "lfh", "tfx", "fch", "fhandle", "feh", "fdhl", "fc", " fth", "dfH", "dfhandle", "lfth", "fec", "fhi", " fx"], "pcias": ["ppias", "ppiAs", "piios", " ppias", "pfiAs", "piia", " ppiasy", "pcuas", "ppios", "pciasa", "ppiAS", " pdias", "Pdia", "ppiac", "pciac", " ppiAs", "pdiuna", "Pdios", "pviuna", "pdios", "pciAs", "ppiasy", " pdiAS", "piiAs", " piiAs", "pfias", "piiAS", "Pcia", "Pcios", "pdiasa", "pfiAS", " pciAS", "pdiAS", "piias", "pvias", "pcuAS", "Pdias", " pciuna", "pdia", "Pcias", "pcuasy", "pviAs", " ppiAS", "pdias", "pfiasa", "ppia", "Pciac", "pdiAs", " pdiasa", "piiuna", " piiuna", "pciasy", " pdiAs", "piiasa", " piias", "pdiac", "pciAS", " pciasa", "pcios", " pciasy", "pcia", "pcuAs", "piiasy", "pviAS", " piiAS", "Pdiac", "piiac", "pciuna", " pciAs"], "len": ["n", "coll", "lig", "name", "en", " length", "ret", "list", "ref", "Len", "length", "err", "late", "ml", "format", "val", "loc", "lp", "lan", "il", "lon", "str", "size", "dl", "bytes", "limit", "kl", "le", "lang", "lt", "lim", "cmp", "abl", "li", "spec", "ls", "wl", "lic", "seq", "hl", "lc", "iter", "mem", "fin", "ln", "nt", "lis", "nl", "pos", "ll", "mn", "elt", "l", "fl", "el", "lib", "sl", "L"], "buffer": ["cap", "message", "ref", "window", "length", "count", "stream", "array", "Buffer", "size", "byte", "batch", "base", "result", "buf", "word", "ptr", "region", "shape", "match", "command", "buff", "block", "address", "cache", "pointer", "header"]}}
{"project": "qemu", "commit_id": "293d2a0014a0e849477413f55aaa05f2743b2e04", "target": 0, "func": "static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n\n                                  void *opaque)\n\n{\n\n    monitor_flush(opaque);\n\n    return FALSE;\n\n}\n", "idx": 20802, "substitutes": {"chan": ["focus", "txt", "chn", "cb", "ach", "err", "act", "con", "conn", "Chan", "tx", "Channel", "c", "proc", "ann", "pipe", "ctx", "anon", "Ch", "ch", "mon", "cmd", "obj", " ch", "bin", "can", "an", "chain", "channel"], "cond": [" pos", "Cond", "condition", "reason", " exc", " condition", "code", "bc", "tx", "c", "proc", "ctx", " thread", " Cond", " whence", " reason", "cmd", " proc", "pos", " code", " why", " conditions", " conditional", "Condition", " interrupt", " flock", " chain", " fut"], "opaque": ["boane", "ipane", "ipaques", "ipacity", " opque", "OPaque", "OPacity", "boaques", "ipaque", "OPaques", "opade", "obaque", " opacity", "opane", "popade", "opacity", "boacity", "popque", "obade", "opaques", "obque", "boaque", "obacity", "popaque", "opque", " opade", "OPane", "popacity"]}}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_store_spr(int reg, TCGv t)\n\n{\n\n    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n", "idx": 20803, "substitutes": {"reg": ["ig", "re", "leg", "tag", "ret", "stat", "sec", "ref", "rem", "Reg", "order", "im", "key", "loc", "ind", "eg", "ld", "row", "tab", "cell", "pr", "res", "db", "rule", "region", "addr", "mem", "REG", "pc", "typ", "req", " REG", "mod", "rec", "grid", "eng", "attr"], "t": ["n", "p", "tt", "out", "txt", "kt", "a", "tg", "o", "r", "task", " x", "f", "tn", "m", "h", "tp", "y", " ts", " tc", "d", "e", " T", "tx", "c", " td", "st", "tr", " g", "j", " ot", "mt", "T", "k", "rt", "ta", "g", "ts", "tree", "tc", "obj", "u", "w", "b", "l", "v", "vt"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n", "idx": 20811, "substitutes": {"bs": ["bi", "is", "lbs", "ks", "ubs", "ss", "BS", "ns", "aos", "ses", "bl", "iss", "ib", "bc", "fs", "bn", "bd", "ds", "bis", "s", " BS", "ls", "bh", "bles", "vs", "bing", "hs", "bes", "its", "ts", "obs", "pb", "sbm", "blocks", "acs", "qs", "bas", "bos", "sb", "bp", "b", "as", "cks", "ba", "bb"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n", "idx": 20812, "substitutes": {"opaque": ["OPacle", "iopaque", "ankaco", "OPaque", "boaco", "opument", "OPaques", "tainaque", "tainaques", "obaque", "OPque", "iopque", "boque", "ankque", "opaques", "tainque", "obque", "opaco", "boaque", "tainacle", "iopument", "ankument", "obacle", "ankaque", "opque", "opacle", "iopaco", "obaques", "boument"], "addr": ["fx", " address", "dh", "r", "ack", "ref", "offset", "add", " plat", "ac", "wid", "src", "inter", "loc", "x", "id", "rs", "tx", "var", "host", "handle", "coord", "hw", "ord", "mt", "ctx", "ptr", "align", "rt", "Address", "help", "adr", "ad", "dr", "address", "cmd", "ace", "pos", "work", "store", "ident", "pad", "attr", "alias"], "val": [" aval", "valid", "resp", "p", "msg", "lit", " arg", "ival", "index", "vol", "ref", " eval", "aval", "bal", "value", " value", "al", "rol", "eval", "serv", "loc", "arg", "tx", "data", "Val", "buf", "ctx", "grad", "res", "VAL", "vals", "mem", " v", "cal", "len", "sol", "v", "vt"], "size": ["n", "name", "message", "index", "sum", "SIZE", "length", "offset", "scale", "sd", "fee", "gz", "count", "space", "weight", "empty", "c", "ity", "body", "height", "sn", "ize", "iz", "send", " Size", "shape", "mem", "Size", "sq", "sp", "len", "small", "sha", "sent", "type"], "b": ["p", "BA", "rb", "eb", "a", "r", " a", "f", "m", "h", "y", "B", "gb", "ob", "d", "bs", "mb", " B", "i", "bar", "bc", "c", "fb", "j", "ab", "base", " ab", "br", "bh", "ub", "db", "ch", "g", "bound", "be", "sb", "bp", "v", "l", "bid", "ba", "bb"]}}
{"project": "qemu", "commit_id": "54ca9095f046dfa03c3d093cc55f6d76b61864e1", "target": 0, "func": "void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    unsigned long pc;\n\n    CPUX86State *saved_env;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);\n\n    if (ret) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc, NULL);\n\n            }\n\n        }\n\n        if (retaddr)\n\n            raise_exception_err(EXCP0E_PAGE, env->error_code);\n\n        else\n\n            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);\n\n    }\n\n    env = saved_env;\n\n}\n", "idx": 20831, "substitutes": {"addr": [" address", "rc", "a", "r", "arp", "ix", "err", "offset", " plat", "add", "act", "ar", "src", "url", "rr", "x", "id", "rs", "host", "handle", "ip", "hw", "ord", "mt", "ctx", "ptr", "align", "rt", "res", "adr", "at", "mem", "ad", "address", "cmd", "obj", "work", "port", "attr", "alias"], "is_write": [" is_written", "is__writing", "is___written", "is_writing", "iso__control", "iso__writer", "is_control", "is__writ", "is_writ", "is___write", "is_written", "is__write", "iso__write", "is__writer", "is___control", "is_writer", "iso_write", "iso__writing", "iso_writing", "is___writing", "iso_control", "iso_writer", " is_writ", "is__written", "is___writ", "is___writer", "is__control"], "is_user": ["is___other", " is_username", "is___username", "is_users", " is_users", " is_client", " is_custom", "is___custom", "is_custom", "is_username", "is_other", " is_other", "is_client", "is___user"], "retaddr": ["altaddress", "Retaddr", "retadr", "Retaddress", "retattr", " retattr", "resetaddr", "altadd", "ftaddr", "ftadr", "retsexpr", "tryaddr", "retsaddress", "tryptr", "tryaddress", "retexpr", "Retadd", "retstr", "resetstr", "Retstr", "altaddr", " retadd", "retptr", "altptr", "resetaddress", "altstr", "retsaddr", "retadd", "Retptr", "ftaddress", "retaddress", " retptr", "retsadr", "tryattr", " retaddress", "ftexpr", "Retexpr", "Retattr", "Retadr"], "tb": ["atbt", "tbr", "ppb", "tbelt", "tbb", " tbb", " Tbl", " tblock", "tbp", "tbi", " Tbb", "pbl", "atb", "pbb", "tbt", "tblock", "mintbr", " Tbp", "notebb", "ttbr", " tbm", "atbp", "ptbr", "ttbelt", " tbt", "mintbi", "ttb", "mintb", "tbl", "noteblock", "mintbelt", " tpb", "ptbi", " tbl", " Tpb", "atbl", "notebm", " tbp", "tbm", "noteb", " Tb", "tpb", " Tbm", "pb", "ptb", " Tbt", "ptbelt", "ttbi", " Tblock"], "ret": [" Ret", "gt", "ben", "re", " RET", "any", "lit", "rc", "rev", "backed", "det", "cont", "xt", "back", "rets", "Return", "rem", "Ret", "gb", "ct", "val", "arr", "ert", "def", "ter", "il", "rs", "pret", "reset", "get", "jp", "tr", "flag", "mt", "result", "ft", "rt", "fi", "res", "alt", "__", "nt", "RET", "not", "ne", "ry", "gov", "success", "got", "pas"], "pc": ["asc", "p", "pic", "isc", " rc", "rc", " dc", " xp", "vc", " cs", " ac", "ping", "dc", " cc", "tp", "PC", " sc", "gc", " cp", "ps", "pt", "lp", "cs", "bc", " PC", "c", "pa", "proc", "mac", "pid", "pod", "psc", "ctx", "ptr", "pn", "pr", "arc", "lc", "px", "pan", "sc", "phy", " pad", " pac", "mc", "pb", " proc", "tc", " pas", "pg", "cam", "pointer", "nc", " p", "cc", "pi", "port", "bp", "fc", "cp", "pad", "point", " lac"], "saved_env": ["saved2env", "saved_state", "saned___env", "saned___environment", "save_conn", "saved___mem", "saned_state", "saved_conn", "saved2conn", "saved_en", "saved_environment", "saned_environment", "save_env", "saved___conn", "saved2mem", "saved___en", "saned___state", "saved___proc", "saved_mem", "saved___env", "save_mem", "saned_env", "saved___state", "saved_proc", "saved___environment"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835, "substitutes": {"d": ["n", "done", "t", "p", "dh", "dm", "dx", "a", "D", "o", "dd", "di", "r", "del", "dq", "dc", "du", "m", "h", "y", "debug", "sd", "dn", "def", "dt", "e", "ld", "ind", "i", "info", "args", "bd", "data", "c", "dl", "ds", "s", "md", "j", "nd", "dict", "df", "q", "dat", "draw", "db", "self", "dev", "ded", "dr", "ad", "de", "od", "fd", "pd", "b", "l", "dj", "da", "rd"], "val": ["valid", "cho", "p", "t", "resp", "ival", "it", "vol", "ref", "ix", "bal", "value", "err", "bl", "al", "eval", "key", "arr", "pt", "x", "arg", "il", "ind", "pret", "tx", "data", "test", "var", "xy", "bit", "vec", "Val", "status", "pol", "buf", "bo", "ctx", "ve", "pr", "num", "res", "VAL", "vals", "addr", "reg", "dev", "ch", "mem", "len", "elt", "b", "v", "el", "vt"], "ret": [" Ret", "cert", "valid", "gt", "t", "re", " RET", "out", "leg", "rc", "it", "rev", "final", " res", "cont", "back", "ref", "rets", "rem", "Ret", "gb", "bool", "inter", "ert", "x", "arg", "def", "resp", "lt", "tr", "comb", "mt", "result", "repl", "ft", "rt", " resp", "res", "alt", "reg", "nt", "ts", "RET", "len", "not", "ry", "elt", "flag", "ctr", " fut"]}}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n", "idx": 20840, "substitutes": {"format": ["fn", "name", "p", "old", "tag", "settings", "source", "set", "color", "f", "Format", "policy", "api", "err", "qt", "title", "act", "method", "reason", "text", "style", "layout", "data", "size", " Format", "pattern", "fp", "mt", "version", "op", "status", "parse", "mode", "family", "spec", "module", "MAT", "ats", "feat", "pretty", "unit", "service", "at", "sort", "template", "config", "prefix", "feature", "command", "error", "form", "options", "l", "v", "fc", "file", "option", "att", "padding", "atter", "type"], "QemuOpts": ["QemuOptS", "QemuLogSpec", "QemusOptS", "QemusLogSpec", "QemusOpts", "QemusOptOptions", "QemuObjectOptions", "QemusLogOptions", "QemuObjectSpec", "QemuOptOptions", "QemuOptSpec", "QemusLogS", "QemuObjects", "QemuLogOptions", "QemusOptSpec", "QemuLogS", "QemusLogs", "QemuLogs", "QemuObjectS"], "ov": ["ever", "ovi", "rov", "sov", "kov", "oid", "oval", "ove", "oh", "erv", "om", "off", "fo", "ob", "oven", "iv", "vr", "va", "OV", "vg", "og", "cv", "oo", "over", "lov", "uo", "iov", "nov", "av", "tv", "mt", "van", "uv", "aven", "sv", "iev", "orf", "ovan", "ow", "oi", "vo", "uj", "uph", "iva", "ova", "nv", "gov", "dj", "vp", "ev", "oc"], "ret": ["gt", "resp", "t", "re", "p", "out", "lit", "txt", "rc", "rev", "it", "det", "OUT", "r", "memory", "print", "ber", "ref", "back", "f", "rets", "tn", "rem", "err", "Ret", "ob", "gc", "val", "pt", "ert", "arg", "def", "dt", "uf", "rs", "usr", "reset", "jp", "temp", "tr", "j", "lt", "result", "mt", "buf", "ft", "rt", "tmp", "vet", "res", "alt", "fi", "buffer", "opt", "report", "reg", "new", "g", "rm", "mem", "nt", "rep", "RET", "cmd", "obj", "ll", "elt", "ry", "att"], "local_err": ["local___priv", "where___err", "localMemeas", "localpyok", "where___bg", "localpyreq", "internal_err", "local_bg", "local_priv", "where___eas", "local____err", "where_eas", "where_rr", "local_mr", "local___rr", "error___err", "local3r", "loc_msg", "errormyobj", "error___er", "where_err", " local_er", "local_req", " local_req", "locpyerr", "local_error", " local_iter", "localmyerr", "localErobj", "localMembg", "localMemresult", "local___bg", "local___eas", "localMemer", "internal_init", "loc_err", "error___priv", "error_err", " local_attr", "local_errors", "where_bg", "local___error", "local_rr", "localpyerrors", "old_req", "local____obj", "error_er", "errormyerr", "localmyobj", "localErmsg", " local_result", "loc_errors", "local___er", "localErerrors", "local___err", "localMemerr", "local_msg", "locpyok", "localErreq", "local_eas", "old_err", "local_ok", "oldpyout", "local_iter", "local____req", "local_obj", "oldpyerr", "localMiter", "oldpyobj", "local3init", "localMemmr", "old_obj", "local_Er", "errormyev", "locpyerrors", "internal_r", "error_obj", "local_init", " local_mr", "localpymsg", "loc_rr", "local3err", "localpyerr", "old_out", "error_priv", " local_error", "local_out", "oldpyreq", "localMemrr", "localErev", "error_ev", "locpymsg", "local___req", "local_attr", "loc_ok", "localErout", "localMerr", "localErok", "localpyout", "where___rr", "local_result", "localMEr", "loc_eas", "localmyev", "local_r", "local____out", "localErerr", "localpyobj", "local___attr", "local_er", "local_ev", " local_Er"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 20856, "substitutes": {"c": ["n", "p", "t", "rc", "this", "cont", "ce", "f", "dc", "m", "h", "co", "init", "ct", "d", "unc", "con", "call", "cs", "e", "s", "ec", "C", "ctx", "lc", "cm", "ch", "g", "config", "util", "tc", "conf", "cache", "cc", "b", "v", "fc", "ca", "cp", "w"], "lumFilter": ["LamChannel", "lumbFilter", "lumbChannel", "lumSort", "lumeSort", "LamFil", "lamChannel", "lumeFilter", "lumeChannel", "LamSort", "lamFil", "LumSort", "lamSort", "LumChannel", "lumChannel", "lumbFil", "lumFil", "lamFilter", "LamFilter", "lumeFil", "LumFil", "LumFilter", "lumbSort"], "lumSrc": ["lumInsRC", "lumVSrs", "luminVSrc", "luminVSrs", "lumVSrc", "lumInsrs", "lumsrc", "lumInsrc", "lumsrs", "luminSRC", "luminVSRC", "luminSrc", "lumSRC", "lumsRC", "lumSrs", "luminSrs", "lumVSRC"], "lumFilterSize": ["lumControlStyle", "lumStreamWeight", "lumStreamLength", "lumFilterLength", "lumFilterStyle", "lamFilterWeight", "lamMaskStyle", "lumMaskStyle", "lumControlWeight", "lamMaskWeight", "lumStreamStyle", "lumMaskSize", "lumStreamSize", "lumMaskWeight", "lamFilterSize", "lamMaskSize", "lamMaskLength", "lumMaskLength", "lamFilterLength", "lamFilterStyle", "lumFilterWeight", "lumControlSize", "lumControlLength"], "chrFilter": ["CharFilter", "chrtOnly", "chrtFil", "chrQuery", "charQuery", "ChrOnly", "chrsFilter", "chrtQuery", "ChrFilter", "ChrQuery", "chrsQuery", "chrsFil", "chrFil", "charFil", "chrtFilter", "chrsOnly", "ChrFil", "CharOnly", "chrOnly", "CharFil", "charOnly", "CharQuery", "charFilter"], "chrUSrc": ["chrbUSfx", "chrbUSur", "chrbSRC", "chrVsrc", "chrSrc", "chrbUSrc", "chrbSfx", "chrVsfx", "chrSfx", "chrFSRC", "chrVsur", "chrbSur", "chrFSfx", "chrUSfx", "chrbUSRC", "chrUSRC", "chrSur", "chrFSur", "chrbSrc", "chrVsRC", "chrSRC", "chrFSrc", "chrUSur"], "chrVSrc": ["chrcVssrc", "chrcVSsrc", "chrVssrc", "chrVsrc", "chrVsr", "chrSrc", "chrcVsRC", "chrFSsrc", "chrSr", "chrcVSrc", "chrFSRC", "chrcVSRC", "chrVSr", "chrcVSr", "chrVSsrc", "chrVSRC", "chrcVsrc", "chrcVsr", "chrVsRC", "chrFSr", "chrSRC", "chrSsrc", "chrFSrc"], "chrFilterSize": ["chrFilterData", "chrBufferType", "chrcFilterType", "chrMaskData", "chrBufferData", "chrFilterType", "chrcFilterData", "chrcBufferSIZE", "chrFilterSIZE", "chrcFilterSize", "chrBufferSize", "chrBufferSIZE", "chrMaskType", "chrChannelData", "chrChannelSize", "chrChannelType", "chrcBufferType", "chrMaskSIZE", "chrcBufferSize", "chrcBufferData", "chrcFilterSIZE", "chrMaskSize", "chrChannelSIZE"], "alpSrc": ["alpSch", "alpSvc", "almSrc", "almDsrc", "alpDsRC", "alpVsrc", "almDsch", "alpVsvc", "alpSRC", "almSRC", "alpVsRC", "almDsvc", "almSvc", "almDsRC", "alpDsch", "almSch", "alpDsrc", "alpDsvc", "alpVsch"], "dest": ["master", "orig", "p", "end", "out", "cas", "usr", "source", "gate", "Dest", "desc", "dc", "window", "us", "transform", "win", "table", "d", "src", "loc", "id", "target", "data", "st", "temp", "tr", "comb", "spec", "est", "wb", "iter", "mem", "rest", "trans", "ident", "port", "v", "dist", "origin", "chain", "w"], "uDest": ["gDest", "uiDesc", "iudest", "ouChan", "uiEast", "ueDest", "uDesc", "iuDest", "ujSource", "uuNet", "uidest", "iuThis", "ueDesc", "uStream", "ujThis", "gdest", "nuDest", "uedest", "nuThis", "ujdest", "uiDest", "nudest", "nuSource", "uuChan", "gDesc", "ucDest", "uuDest", "ujDest", "ucChan", "ouStream", "uEast", "uuStream", "gEast", "ucStream", "uThis", "ucNet", "uNet", "ouNet", "udest", "ouDest", "uChan", "ueEast", "iuSource", "uSource"], "vDest": ["uDesc", "vDecl", "vEast", "VDecl", "Vdest", " vDesc", "bdest", "bEast", "vdest", "vDat", "uDecl", "bDat", "VDesc", " vDecl", "VEast", "dDat", "VDest", "VDat", "dEast", "bDest", "vDesc", "ddest", "dDest"], "aDest": ["vaTrans", " aWorld", " aStream", "naStream", "aSource", "naQueue", "ASource", "aLoc", "aWin", "naWin", "aaDest", "AQueue", "ALoc", "oWorld", "aTarget", "ADest", "vaDest", " aTrans", "AStream", "aWorld", " aTarget", "oSource", " aQueue", "aDesc", " aWin", "aTrans", "aaTrans", "aaTarget", " aLoc", " aDesc", "aStream", "vaDesc", "aQueue", "vaTarget", " aSource", "aaDesc", "AWorld", "naDest", "AWin", "oLoc", "oDest"], "dstW": [" dstB", "destV", "dstreamW", "dndV", "dstreamD", "dblV", "DestH", "dstreamV", "dltW", "drestW", "destH", "dstD", "dstHTML", "dstV", "dstL", "DstV", " dltW", "destB", "dgestV", "dblH", "drestB", " dstV", "dltB", "DestHTML", "DestD", "destD", "dstH", "drestV", "dltV", "dstM", "DestW", "destL", " dltL", "dgestD", "destM", "dblM", "dstB", "DstW", "DstH", "DstD", "dndH", "dblW", " dltB", "DstHTML", "destW", "dstreamHTML", "dgestHTML", " dstL", " dltV", "dndM", "DstM", "dgestW", "DestV", "drestL", "dndW", "destHTML", "dltL", "DestM"], "chrDstW": ["chrDssetSize", "chrLstR", "chrDzSize", "chrDssetP", "chrSstW", "chrDndW", "chrDssetG", "chrDbrB", "chrDndWindows", "chrDndS", "chrDstrW", "chrDsnP", "chrSndB", "chrSndH", "chrSndWindows", "chrLndH", "chrDstrH", "chrLstH", "chrDsetSize", "chrDstoreB", "chrDrcH", "chrDsetP", "chrDndH", "chrDstoreW", "chrDstR", "chrDsnG", "chrSstH", "chrLndR", "chrDstoreH", "chrSstB", "chrSstWindows", "chrDstS", "chrDsnSize", "chrDsstG", "chrDstG", "chrDstoreWindows", "chrLndS", "chrDndR", "chrDstSize", "chrDrcW", "chrDndB", "chrDssetW", "chrLndW", "chrDrcS", "chrLstW", "chrDstrR", "chrDbrWindows", "chrDsnW", "chrDsetW", "chrDzW", "chrDstB", "chrLstS", "chrDzP", "chrDsstW", "chrDzG", "chrDstWindows", "chrDrcR", "chrDstrS", "chrDbrW", "chrDstP", "chrDbrH", "chrDsetG", "chrDstH", "chrDsstSize", "chrDsstP", "chrSndW"]}}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n", "idx": 20902, "substitutes": {"key": ["name", "mk", "param", "index", "ref", "ek", "sum", "value", "y", "hash", "KEY", "item", "x", "keys", "id", "code", "i", "po", "pri", "info", "max", "ray", "query", "pid", "base", "ctx", "link", "k", "password", "Key", "owner", "path", "prefix", "req", "pointer", "need", "port", "ry", "v", "icon", "type"], "opaque": ["oplque", " opaques", "opulence", "Opulence", "oplaque", " opque", "opposter", " opatile", "Opatile", "oppque", "ocque", "Opaque", "ocaques", "ocatile", "Oposter", "opaques", "oposter", "Opaques", "oploster", "oppulence", "ocaque", "Opque", "opque", "oplulence", "oppaque", "opatile"], "cpu": ["core", "p", "ports", "sys", "gpu", "alloc", "print", "processor", "process", "boot", "tp", "unk", "rom", "gc", "program", "pkg", "ruby", " cp", "bench", "prof", "physical", "nz", "ro", "trace", "conn", "cu", "cum", "cv", "vm", "c", " CPU", "php", "jp", "cli", "proc", "hw", "worker", "pu", "aux", "ctx", "kernel", "hz", "chip", "clock", "aco", "nic", "component", "px", "ka", "ocr", "runner", "rpm", "util", "pc", "np", "pool", "cam", "cal", "CPU", "linux", "phys", "cp", "ram"], "regidx": ["reginx", "regnamex", "regoidtx", "regidex", " regpartx", "regidz", "reginz", "regiterx", " regidy", "regfdxb", "regpidy", " regparttx", "regridx", "regIdix", "regtryy", "regpidix", " regfdx", "regidtx", "regminxc", "regtryex", "regminix", "regfdxx", " regIdxc", " regidxc", " regidxx", "regfdex", "regidxx", "regridw", " regfdxx", "regpartw", "regridxx", "regminx", "reginxc", " regidz", " regnameex", "regminz", "regiterxb", "regiterex", " regpartw", " regparty", "regpidex", "regiterxx", "regoidy", " regnamex", " regidix", "regfdx", "regidw", "regtryx", "regpidx", "regnameex", " regfdxb", " regIdix", "regnamey", "regtryix", "regidix", "regIdxc", "regparttx", "regridex", " regIdx", " regfdex", " regidw", "regidxc", "regridtx", "regridy", "regidy", "regoidw", " regidtx", "regnameix", "regIdx", "reginix", "regpartx", "regoidx", " regnameix", "regidxb", " regIdz", " regidxb", "regIdz", " regnamey", " regidex", "regparty", "regridxb"], "ri": ["bi", "RI", "rir", "rc", "r", "si", "vi", "ru", "di", "io", "ai", "xi", "rik", "ati", "rin", "iri", "zi", "adi", "ro", "i", "pri", "rs", "ric", "ni", "ki", "ini", "ti", "uti", "li", "rt", "rio", "ani", "rid", "ir", "ris", "ria", "rm", "ci", "mi", "udi", "ii", "ry", "hi", "pi", "ra", "uri"], "cpreg_array_len": ["cpreg_arr_gen", "cpreg_array_length", "cpreg_arr_len", "cpreg_arr_Len", "cpreg_array2gen", "cpreg_array_pos", "cpreg_array2loc", "cpreg_array_no", "cpreg_array2length", "cpreg_arr_loc", "cpreg_array2Len", "cpreg_array_loc", "cpreg_arr_length", "cpreg_arr_pos", "cpreg_arr_no", "cpreg_array2no", "cpreg_array2len", "cpreg_array_gen", "cpreg_array_Len", "cpreg_array2pos"]}}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_huffman_decode(unsigned char *dest, unsigned char *src)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    int counter = 0;\n\n\n\n    unsigned char bits = *ptr++;\n\n\n\n    while ( val != 0x16 ) {\n\n        if ( (1 << counter) & bits )\n\n            val = src[byte + val - 0x17];\n\n        else\n\n            val = src[val - 0x17];\n\n\n\n        if ( val < 0x16 ) {\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n\n\n        if (counter++ == 7) {\n\n            counter = 0;\n\n            bits = *ptr++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20903, "substitutes": {"dest": ["master", "asc", "orig", "out", "end", "txt", "usr", "cont", "source", "Dest", "desc", "member", "rel", "loc", "target", "str", "decl", "vec", "tr", "result", "buf", "prop", "est", "addr", "iter", "mem", "new", "rest", "trans", "bin", "pos", "ident", "pointer", "port", "ser", "dist", "v", "origin"], "src": ["sys", "rb", "lit", "rc", "usr", "sel", "cont", "source", "sec", "desc", "length", "gb", "iv", "stream", "loc", "impl", "rs", "str", "st", "bytes", "s", "cur", "byte", "proc", "sr", "buf", "sn", "img", "gin", "tmp", "seq", "hl", "sc", "addr", "supp", "in", "ins", "sp", "trans", "rl", "sub", "obj", "sur", "inst", "slice", "sb", "ser", "cc", "ctl", "ripp", "dist", "fc", "ctr", "sl", "serv"], "ptr": ["expr", "rect", "sys", "pert", "usr", "ret", "sec", "Ptr", "offset", "rel", "bl", "ps", "pt", "loc", "arr", "vec", "jp", "cur", "tr", "proc", "coord", "fr", "pen", "ctx", "br", "addr", "adr", "iter", "dr", "inters", "prime", "ts", "rep", "sp", "pc", "req", "address", "pos", "inst", "pointer", "pad", "dist", "pointers", "point", "ctr"], "counter": ["atomic", "loop", "TER", "vector", "upper", "writer", "Counter", "context", "scope", "number", "comment", "processor", "index", "nr", "container", "check", "value", "cover", "offset", "length", "card", "condition", "count", "key", "x", "con", "ter", "mask", "code", "level", "created", "outer", "currency", "controller", "over", "size", "c", "cmp", "cer", "clock", "num", "frequency", "ounter", "console", "creator", "buffer", "factor", "sequence", "per", "inner", "term", "zero", "clear", "ier", "pointer", "nc", "timer", "magic", "ctr", "chain"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)\n\n{\n\n    return t && t->rearm;\n\n}\n", "idx": 20908, "substitutes": {"t": ["td", "n", "p", "time", "tt", "txt", "it", "a", "r", "o", "tin", "task", "te", "f", "m", "tp", "h", "y", "tn", "ct", "d", "mint", "dt", "e", "i", "tap", "c", "st", "ti", "tr", "tim", "T", "k", "q", "ta", "at", "g", "ts", "tc", "w", "tm", "to", "l", "timer", "v", "tf", "vt"]}}
{"project": "FFmpeg", "commit_id": "3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba", "target": 1, "func": "static int iff_read_header(AVFormatContext *s)\n\n{\n\n    IffDemuxContext *iff = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    uint8_t *buf;\n\n    uint32_t chunk_id, data_size;\n\n    uint32_t screenmode = 0, num, den;\n\n    unsigned transparency = 0;\n\n    unsigned masking = 0; // no mask\n\n    uint8_t fmt[16];\n\n    int fmt_size;\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codec->channels = 1;\n\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n    avio_skip(pb, 8);\n\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n\n    st->codec->codec_tag = avio_rl32(pb);\n\n    iff->bitmap_compression = -1;\n\n    iff->svx8_compression = -1;\n\n    iff->maud_bits = -1;\n\n    iff->maud_compression = -1;\n\n\n\n    while(!url_feof(pb)) {\n\n        uint64_t orig_pos;\n\n        int res;\n\n        const char *metadata_tag = NULL;\n\n        chunk_id = avio_rl32(pb);\n\n        data_size = avio_rb32(pb);\n\n        orig_pos = avio_tell(pb);\n\n\n\n        switch(chunk_id) {\n\n        case ID_VHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 14)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 12);\n\n            st->codec->sample_rate = avio_rb16(pb);\n\n            if (data_size >= 16) {\n\n                avio_skip(pb, 1);\n\n                iff->svx8_compression = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_MHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 32)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 4);\n\n            iff->maud_bits = avio_rb16(pb);\n\n            avio_skip(pb, 2);\n\n            num = avio_rb32(pb);\n\n            den = avio_rb16(pb);\n\n            if (!den)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 2);\n\n            st->codec->sample_rate = num / den;\n\n            st->codec->channels = avio_rb16(pb);\n\n            iff->maud_compression = avio_rb16(pb);\n\n            if (st->codec->channels == 1)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            else if (st->codec->channels == 2)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            break;\n\n\n\n        case ID_ABIT:\n\n        case ID_BODY:\n\n        case ID_DBOD:\n\n        case ID_MDAT:\n\n            iff->body_pos = avio_tell(pb);\n\n            iff->body_end = iff->body_pos + data_size;\n\n            iff->body_size = data_size;\n\n            break;\n\n\n\n        case ID_CHAN:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            if (avio_rb32(pb) < 6) {\n\n                st->codec->channels       = 1;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            } else {\n\n                st->codec->channels       = 2;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            }\n\n            break;\n\n\n\n        case ID_CAMG:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            screenmode                = avio_rb32(pb);\n\n            break;\n\n\n\n        case ID_CMAP:\n\n            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case ID_BMHD:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size <= 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            avio_skip(pb, 4); // x, y offset\n\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n\n            if (data_size >= 10)\n\n                masking                      = avio_r8(pb);\n\n            if (data_size >= 11)\n\n                iff->bitmap_compression      = avio_r8(pb);\n\n            if (data_size >= 14) {\n\n                avio_skip(pb, 1); // padding\n\n                transparency                 = avio_rb16(pb);\n\n            }\n\n            if (data_size >= 16) {\n\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_DPEL:\n\n            if (data_size < 4 || (data_size & 3))\n\n                return AVERROR_INVALIDDATA;\n\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n\n                return fmt_size;\n\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n\n            else {\n\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            break;\n\n\n\n        case ID_DGBL:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size < 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            iff->bitmap_compression          = avio_rb16(pb);\n\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n\n            st->codec->bits_per_coded_sample = 24;\n\n            break;\n\n\n\n        case ID_DLOC:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width  = avio_rb16(pb);\n\n            st->codec->height = avio_rb16(pb);\n\n            break;\n\n\n\n        case ID_TVDC:\n\n            if (data_size < sizeof(iff->tvdc))\n\n                return AVERROR_INVALIDDATA;\n\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n\n            if (res < 0)\n\n                return res;\n\n            break;\n\n\n\n        case ID_ANNO:\n\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n\n        case ID_NAME:      metadata_tag = \"title\";     break;\n\n        }\n\n\n\n        if (metadata_tag) {\n\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n\n                return res;\n\n            }\n\n        }\n\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n\n    }\n\n\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n\n\n    switch(st->codec->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n\n\n        if (st->codec->codec_tag == ID_16SV)\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n\n        else if (st->codec->codec_tag == ID_MAUD) {\n\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n\n            } else {\n\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            st->codec->bits_per_coded_sample =\n\n                av_get_bits_per_sample(st->codec->codec_id);\n\n\n\n            st->codec->block_align =\n\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n\n        } else {\n\n        switch (iff->svx8_compression) {\n\n        case COMP_NONE:\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n\n            break;\n\n        case COMP_FIB:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n\n            break;\n\n        case COMP_EXP:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n\n            return -1;\n\n        }\n\n        }\n\n\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        iff->bpp          = st->codec->bits_per_coded_sample;\n\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n\n            st->codec->bits_per_coded_sample = 24;\n\n        }\n\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n\n        iff->masking      = masking;\n\n        iff->transparency = transparency;\n\n\n\n        if (!st->codec->extradata) {\n\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n\n        buf = st->codec->extradata;\n\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n\n        bytestream_put_byte(&buf, iff->bpp);\n\n        bytestream_put_byte(&buf, iff->ham);\n\n        bytestream_put_byte(&buf, iff->flags);\n\n        bytestream_put_be16(&buf, iff->transparency);\n\n        bytestream_put_byte(&buf, iff->masking);\n\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 20917, "substitutes": {"s": ["n", "comm", "p", "t", "is", "sys", "sa", "os", "set", "f", "m", "ns", "ss", "ses", "stats", "bs", "ps", "cs", "sts", "fs", "gs", "aws", "rs", "c", "ds", "scl", "ls", "ats", "hs", "sc", "S", "js", "es", "ins", "sq", "ts", "its", "sp", "sg", "qs", "less", "sb", "b", "as", "v"], "iff": ["fx", "aud", "gif", "ogg", "txt", "eb", "pread", "sel", "bf", "et", "cb", "app", "jpg", "dial", "io", "alf", "iffs", "ef", "conv", "gz", "act", "pkg", "ata", "arf", "image", "ifa", "pp", "x", "uf", "sect", "ipp", "ief", "crop", "tx", "aff", "dl", "fb", "xml", "ell", "iam", "fp", "img", "png", "ff", "tif", "abel", "cell", "fax", "IFF", "ocl", "html", "grab", "lib", "px", "xf", "aft", "patch", "amp", "http", "ist", "conf", "obj", "less", "diff", "af", "lf", "elt", "fc", "supp", "tf", "bb", "eff"], "pb": ["td", "resp", "p", "sys", "rb", "vp", "txt", "msg", "func", "cb", "dc", "pm", "tp", "conv", "ob", "gc", "pkg", "mb", "pt", "pp", "lp", "uf", "mp", "wp", "tk", "erb", "lb", "um", "cv", "tx", "tab", "pa", "PB", "fb", "jp", "meta", "cmp", "snap", "peer", "proc", "nb", "pid", "ab", "fp", "pl", "ctx", "tmp", "dp", "wb", "db", "buffer", "px", "patch", "kb", "stab", "sp", "pc", "typ", "pg", "tc", "np", "emb", "pool", "req", "pro", "sb", "port", "b", "bp", "bj", "cp", "bb", "buff"], "st": ["td", "ste", "t", "ost", "tt", "start", "must", "first", "usr", "stop", "et", "set", "h", "ss", "bl", "sta", "th", "ct", "src", "pt", "stream", "sts", "St", "str", "sat", "step", "stru", "ast", "se", "mt", "fr", "ust", "sn", "nd", "sm", "sth", "rt", "sh", "sw", "est", "sc", "stable", "rest", "stack", "put", "sp", "nt", "ist", "irst", "std", "mont", "stri", "store", "inst", "sb", "ST", "ut", "art", "sl", "sty"], "buf": ["cap", "msg", "txt", "out", "rc", "bf", "cb", "ref", "err", "bl", "uf", "bc", "cv", "batch", "img", "ff", "ctx", "raw", "uv", "tmp", "seq", "map", "buffer", "buff", "b", "bp", "v"], "chunk_id": ["chunk_name", "chian_mode", "chunkNameid", "chian_bid", "chian_name", "chunk_ident", "chunks_id", "chunkNamemode", "chunk___id", "chianNamebid", "chunks_name", "chunks_ident", "chianNamemode", "chunk_mode", "chunks_info", "chunk___mode", "chunkNamename", "chianNamename", "chunk___bid", "chunk_info", "chian_id", "chunkNamebid", "chianNameid", "chunk_bid", "chunk___name", "chunk_data"], "data_size": [" data_SIZE", "data_description", "dataPsize", "ata_size", "data_length", "data_len", "DATA_scale", "dataLscale", "dataLSize", "data_too", "data_Size", "DATA_Size", "data_SIZE", "dataPrate", " data_description", "dataPSize", "DATA_size", " data_Size", "DATA_rate", "DATA_len", "ata_Size", " data_rate", "ata_too", "DATA_length", "DATA_SIZE", "dataLrate", "data_rate", "dataLsize", "data_scale"], "num": ["n", "perm", "orig", "en", "msg", "ver", "number", "index", "sum", "offset", "nam", "nom", "id", "um", "con", "umi", "dim", "max", "tim", "no", "proc", "nu", "nb", "coord", "nm", "mult", "uni", "dev", "mem", "common", "mon", "mark", "typ", "pos", "Num", "gen", "len", "NUM", "mn"], "den": ["perm", "quality", "done", "en", "high", "window", "seed", "mid", "conv", "dir", "none", "lan", "orient", "level", "dim", "limit", "no", "pen", "uni", "alt", "dev", "mem", "mon", "range", "len", "flag", "attr"], "fmt": ["ftype", "fctx", " ftype", "fctype", "fcmt", " fMT", " ftx", "fxmt", "fxMT", "fMT", "ftx", "fcMT", "fxtype", "fxtx"], "fmt_size": ["fmt_len", "fmt_name", "fformat_SIZE", "fformat_len", "fmt_SIZE", "fformat_size", "fformat_name"], "orig_pos": ["origptpt", " orig_seq", "orig1offset", "orig_position", "origptloc", "origin_position", "orig67seq", "orig67POS", "origin_loc", "orig_POS", "origptposition", "orig_seq", "orig1pos", "orig1POS", " orig_POS", "orig1seq", "orig_offset", "orig67pos", "orig_loc", "orig_pt", " orig_offset", "origin_pt", "orig67offset", "origin_pos", "origptpos"], "res": ["resp", " rem", "re", " results", " cs", "os", "rem", "err", "val", "con", "RES", "def", "Conn", "rs", "reset", "ress", "resh", " resp", " ver", "cond", "VAL", "vals", "Res", "reg", "rest", "rep", "req"], "metadata_tag": ["meta_comment", "metadata_comment", "meta_type", "metadata_type", "meta_id", "meta_tag", "metadata_id"]}}
{"project": "FFmpeg", "commit_id": "f3ace37a3b8c93218630a37b7df4dc195f1215a9", "target": 1, "func": "static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n\n{\n\n    int err, i, dash = 0, result = 0, code_found = 0;\n\n    char buf[CONTROL_BUFFER_SIZE];\n\n    AVBPrint line_buffer;\n\n\n\n    if (line)\n\n        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    while (!code_found || dash) {\n\n        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n\n            av_bprint_finalize(&line_buffer, NULL);\n\n            return err;\n\n        }\n\n\n\n        av_log(s, AV_LOG_DEBUG, \"%s\\n\", buf);\n\n\n\n        if (strlen(buf) < 4)\n\n            continue;\n\n\n\n        err = 0;\n\n        for (i = 0; i < 3; ++i) {\n\n            if (buf[i] < '0' || buf[i] > '9')\n\n                continue;\n\n            err *= 10;\n\n            err += buf[i] - '0';\n\n        }\n\n        dash = !!(buf[3] == '-');\n\n\n\n        for (i = 0; response_codes[i]; ++i) {\n\n            if (err == response_codes[i]) {\n\n                if (line)\n\n                    av_bprintf(&line_buffer, \"%s\", buf);\n\n                code_found = 1;\n\n                result = err;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (line)\n\n        av_bprint_finalize(&line_buffer, line);\n\n    return result;\n\n}\n", "idx": 20918, "substitutes": {"s": ["n", "comm", "t", "p", "is", "a", "r", "os", "f", "h", "m", "ns", "ss", "ses", "d", "serv", "ps", "x", "cs", "e", "sts", "rs", "fs", "gs", "socket", "c", "ds", "ap", "se", "scl", "sm", "ctx", "sv", "sw", "ats", "sc", "S", "js", "g", "sq", "ts", "an", "b", "as", "v", "w"], "line": ["name", "out", "frame", "print", "comment", "o", "list", "length", "board", "Line", "code", "user", "online", "row", "node", "le", "eline", "cl", "lo", "ip", "cli", "status", "lock", "pipe", "LINE", "word", "mode", "link", "cell", "ine", "queue", "lin", "el", "lines", "lined", "buffer", "page", "iter", "ln", "error", "range", "stay", "block", "cmd", "nl", "len", "stroke", "lf", "port", "l", "flag", "file", "point", "header", "text"], "response_codes": ["response_seconds", "responseablestates", " response_cs", "response_cs", "response2states", "resp_codes", " response_states", "response2cs", "Response_code", "resp_values", "response_values", " response_code", "response_objects", "response_states", "response_code", "response2code", "response_odes", "resp_seconds", "Response_odes", "responseablecodes", "Response_codes", "response2codes", "responseablecode", "responseablecs", "resp_objects"], "err": ["expr", "msg", "progress", "cli", "fr", "br", "ex", "res", "Error", "oe", "term", "cr", "n", "resp", "orig", "der", "mr", "rev", "order", "rr", "trace", "e", "fail", "coord", "pr", "dr", "inner", "norm", "cmd", "rn", "it", "die", "r", "nr", "score", "rank", "act", "ner", "str", "c", "var", "raw", "ptr", "Er", "try", "req", "conf", "obj", "len", "diff", "errors", "attr", "er", "lr", "out", "rb", "txt", "rc", "usr", "cb", "ach", "off", "notice", "gz", "ie", "val", "arr", "code", "or", "test", "ord", "result", "ine", "cor", "addr", "iter", "ch", "error", "ctr"], "i": ["bi", "ij", "ori", "phi", "p", "\u0438", "t", "ic", "it", "iq", "ri", "si", "me", "index", "di", "iu", "ai", "o", "xi", "io", "ix", "m", "y", "ji", "multi", "ie", "zi", "ei", "inter", "x", "id", "ind", "sim", "gi", "I", "ami", "qi", "ti", "j", "ip", "ini", "cli", "li", "q", "ui", "oi", "ir", "iter", "eu", "ci", "g", "mi", "u", "ii", "pi", "hi", "v", "uri", "chain"], "buf": ["msg", "pack", "desc", "late", " buffer", "uf", "cur", "batch", "br", "tmp", "bt", "emb", "pos", "v", "resp", "cat", "words", "conv", "Buffer", "data", "bd", "bytes", "vec", "seq", " b", "db", "mem", "wd", "cmd", "b", "bf", "r", "pkg", "cv", "str", "max", "tx", "fg", "fb", "proc", "ctx", "raw", "bg", "buffer", "box", "buff", "obj", "cache", "len", "bag", "p", "rb", "cap", "txt", "out", "cb", "off", "window", "aka", "Buff", "val", "arr", "code", "bar", "bc", "que", "tr", "result", "img", "prop", "nm", "queue", "iter", "doc", "block", "pad", "text"], "line_buffer": ["charingentry", "point___buffer", "line_buff", "lineacdatabase", "line_entry", "line2Buffer", "line2buffer", " line_buf", "char_buffer", "lineptbuffer", "line_limit", "charingsize", "Line_buffer", "lineptcallback", "ine_match", "lineingbuffer", "charingBuffer", "line___buffer", "line___thread", "point_limit", "point_Buffer", "char_entry", "Line_queue", "point___thread", "line_thread", "ine_cache", "lineptqueue", "char_Buffer", "lineacbuffer", "Line_callback", "point_buffer", "ine_database", "point___Buffer", "line_cache", "line_database", "line___limit", " line_Buffer", "line_size", "char_size", "lineaccache", "line___Buffer", "line_buf", "line_queue", "Line_buff", "lineptbuff", "line_match", "lineingsize", "charingbuffer", "lineingentry", "line_Buffer", "ine_buffer", "lineacmatch", "point___limit", "point_thread", "line2buf", "lineingBuffer", "line_callback"]}}
{"project": "qemu", "commit_id": "26e92f65525ef4446a500d85e185cf78835922aa", "target": 0, "func": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)\n\n{\n\n    arm_sysctl_state *s = (arm_sysctl_state *)opaque;\n\n\n\n    switch (offset) {\n\n    case 0x00: /* ID */\n\n        return s->sys_id;\n\n    case 0x04: /* SW */\n\n        /* General purpose hardware switches.\n\n           We don't have a useful way of exposing these to the user.  */\n\n        return 0;\n\n    case 0x08: /* LED */\n\n        return s->leds;\n\n    case 0x20: /* LOCK */\n\n        return s->lockval;\n\n    case 0x0c: /* OSC0 */\n\n    case 0x10: /* OSC1 */\n\n    case 0x14: /* OSC2 */\n\n    case 0x18: /* OSC3 */\n\n    case 0x1c: /* OSC4 */\n\n    case 0x24: /* 100HZ */\n\n        /* ??? Implement these.  */\n\n        return 0;\n\n    case 0x28: /* CFGDATA1 */\n\n        return s->cfgdata1;\n\n    case 0x2c: /* CFGDATA2 */\n\n        return s->cfgdata2;\n\n    case 0x30: /* FLAGS */\n\n        return s->flags;\n\n    case 0x38: /* NVFLAGS */\n\n        return s->nvflags;\n\n    case 0x40: /* RESETCTL */\n\n        return s->resetlevel;\n\n    case 0x44: /* PCICTL */\n\n        return 1;\n\n    case 0x48: /* MCI */\n\n        return 0;\n\n    case 0x4c: /* FLASH */\n\n        return 0;\n\n    case 0x50: /* CLCD */\n\n        return 0x1000;\n\n    case 0x54: /* CLCDSER */\n\n        return 0;\n\n    case 0x58: /* BOOTCS */\n\n        return 0;\n\n    case 0x5c: /* 24MHz */\n\n        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());\n\n    case 0x60: /* MISC */\n\n        return 0;\n\n    case 0x84: /* PROCID0 */\n\n        /* ??? Don't know what the proper value for the core tile ID is.  */\n\n        return 0x02000000;\n\n    case 0x88: /* PROCID1 */\n\n        return 0xff000000;\n\n    case 0x64: /* DMAPSR0 */\n\n    case 0x68: /* DMAPSR1 */\n\n    case 0x6c: /* DMAPSR2 */\n\n    case 0x70: /* IOSEL */\n\n    case 0x74: /* PLDCTL */\n\n    case 0x80: /* BUSID */\n\n    case 0x8c: /* OSCRESET0 */\n\n    case 0x90: /* OSCRESET1 */\n\n    case 0x94: /* OSCRESET2 */\n\n    case 0x98: /* OSCRESET3 */\n\n    case 0x9c: /* OSCRESET4 */\n\n    case 0xc0: /* SYS_TEST_OSC0 */\n\n    case 0xc4: /* SYS_TEST_OSC1 */\n\n    case 0xc8: /* SYS_TEST_OSC2 */\n\n    case 0xcc: /* SYS_TEST_OSC3 */\n\n    case 0xd0: /* SYS_TEST_OSC4 */\n\n        return 0;\n\n    default:\n\n        printf (\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 20938, "substitutes": {"opaque": [" opaques", "opoid", "iopaque", " oposter", "oplaque", " opoid", "opent", "opade", "oplade", "obaque", "oploid", "obade", "opaques", "iopoid", "oposter", "oplaques", "oploster", " opent", "obent", "oplent", "ioposter", " opade", "obaques"], "offset": ["offs", "t", "start", "a", "oid", "o", "set", "Offset", "index", "ref", "off", "length", "attribute", "object", "zone", "tz", "style", "id", "mask", "row", "slot", "data", "size", "no", "base", "z", "mt", "shift", "op", "ock", "clock", "ms", "ocation", "operation", "buffer", "location", "addr", "bound", "error", "sp", "command", "from", "zero", "block", "address", "pos", "pointer", "pad", "point", "padding", "type"], "s": ["ports", "izes", "ums", "m", "ims", "sts", "ances", "ds", "ches", "hs", "es", "ins", "ants", "als", "eds", "sb", "ations", "n", "ed", "ails", "a", "o", "os", " outputs", "ores", "rows", "e", "alls", "aws", "fs", "olds", "ions", "ocks", "ers", "ats", " returns", "ests", "g", "ts", "b", " docs", "t", "r", "outs", "stats", "d", "ps", "uns", "ments", "c", "z", "ls", "ies", "S", "its", " values", "ists", "er", "p", "itions", "parts", "dates", "ss", "ands", "rs", "gs", "ries", "locks", "umps", "js", "sq", "erences", "ains", "resses", " holds", "w"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_is_self(cpu)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    wi.free = false;\n\n    if (cpu->queued_work_first == NULL) {\n\n        cpu->queued_work_first = &wi;\n\n    } else {\n\n        cpu->queued_work_last->next = &wi;\n\n    }\n\n    cpu->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(cpu);\n\n    while (!wi.done) {\n\n        CPUState *self_cpu = current_cpu;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        current_cpu = self_cpu;\n\n    }\n\n}\n", "idx": 20945, "substitutes": {"cpu": ["core", "p", "sys", "gpu", "ck", "alloc", "frame", "os", "processor", "process", "stat", "java", "boot", "tp", "device", "us", "gc", "etc", "pkg", "program", "bench", "prof", "copy", "conn", "cu", "socket", "cum", "mu", "vm", "reset", "jp", "cmp", "cli", "proc", "hw", "library", "ork", "pu", "ctx", "kernel", "hz", "server", "clock", "num", "aco", "nic", "component", "px", "mem", "runner", "pc", "np", "remote", "CPU", "linux", "pai", "port", "phys", "cp", "net"], "func": ["fn", "fun", "fx", "kw", "perm", "expr", "orig", "sys", "cb", "sec", "wrapper", "callback", "f", "go", "PF", "exec", "act", "conv", "method", "closure", "pkg", "val", "unc", "fac", "con", "package", "cs", "impl", "cu", "str", "fw", "imp", "proc", "coord", "mac", "fr", "prop", "aux", "function", "ctx", "invoke", "cf", "util", "cmd", "obj", "work", "cc", "b", "comp", "fc", "apply", "attr"], "data": ["n", "fun", "fn", "done", "name", "p", "t", "out", "all", "any", "missing", "r", "memory", "di", "list", "output", "record", "f", "m", "device", "window", "value", "ns", "rel", "rew", "format", "table", "d", "ata", "val", "na", "none", "x", "def", "empty", "mu", "row", "info", "size", "bytes", "step", "no", "batch", "snap", "result", "function", "extra", "DATA", "items", "dat", "what", "res", "map", "buffer", "mem", "new", "error", "only", "Data", "params", "cache", "next", "input", "da"], "wi": [" xp", " hi", " ho", "dit", "eni", "fee", "wy", "wp", "wiki", "ti", "rw", "wx", "wl", "ui", "wen", " wh", "feat", "WI", "wine", "rus", " wo", "lis", "pai", "ushi", " ti", "wr", "igi", "fi", "wcs", " pi", "wo", " wifi", "wt", "mie", "wikipedia", "hi", "bi", " wit", " wip", "xi", "ei", " wid", " yo", "isi", "ni", " wa", "qi", "wik", " pci", " sir", "wic", "wit", "gui", "hog", "wal", "mi", "wat", "esi", "yi", "wei", "xe", "iu", " xx", "shi", "wid", "fw", "wu", "gra", "hei", "innie", "wife", "wig", "udi", "Wi", "ye", "rek", "wm"], "self_cpu": [" self_ctx", "self___cpu", "self_gc", "selfPropu", "selfProcpu", " self_pu", " self_conn", " self_gpu", "self___pu", "selfProconn", "self_gpu", "selfProgpu", "selfJpu", "selfJcpu", "selfJgc", "selfJctx", "self_conn", "self_ctx", "self___gc", "self___ctx", " self_gc", "self_pu"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "double avpriv_strtod(char *restrict nptr, char **restrict endptr)\n\n{\n\n    char *end;\n\n    double res;\n\n\n\n    /* Skip leading spaces */\n\n    while (isspace(*nptr))\n\n        nptr++;\n\n\n\n    if (!av_strncasecmp(nptr, \"infinity\", 8)) {\n\n        end = nptr + 8;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"inf\", 3)) {\n\n        end = nptr + 3;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"nan\", 3)) {\n\n        end = check_nan_suffix(nptr + 3);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"+nan\", 4) ||\n\n               !av_strncasecmp(nptr, \"-nan\", 4)) {\n\n        end = check_nan_suffix(nptr + 4);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"0x\", 2) ||\n\n               !av_strncasecmp(nptr, \"-0x\", 3) ||\n\n               !av_strncasecmp(nptr, \"+0x\", 3)) {\n\n        /* FIXME this doesn't handle exponents, non-integers (float/double)\n\n         * and numbers too large for long long */\n\n        res = strtoll(nptr, &end, 16);\n\n    } else {\n\n        res = strtod(nptr, &end);\n\n    }\n\n\n\n    if (endptr)\n\n        *endptr = end;\n\n\n\n    return res;\n\n}\n", "idx": 20958, "substitutes": {"nptr": ["namedr", "numrod", "ntsp", "noterect", "anpad", "snreq", "sncert", "gnproc", "enpad", "jPtr", "ntaddr", "oncert", "nonpert", "nanPtr", "ntadr", "snfx", "anptr", "nonpointer", "unpointer", "jptr", "noteptr", " nproc", "ansp", "onaddr", "anproc", "anPtr", "ndr", "annptr", "snpr", "mntr", "ntpert", "onsp", "namecert", "snpost", "notepert", "unpt", "dnptr", "namerect", "nanpol", " nrod", "ntcert", "NPtr", "nanptr", "gnpert", "nwpert", "nnptr", "anfx", "sndr", "andr", "ntptr", "annaddr", "nnproc", "jcert", "unadr", "snPtr", "Naddr", "uncert", "dnpert", "enptr", "mnpr", "wntp", "namepert", "ninpt", "wptr", "snadr", "nameptr", "nincert", "Npol", "nepad", "snrod", "snpert", "ninptr", "ntr", "snptr", "ontr", "onpt", "neptr", "npt", " npert", "dnproc", "snaddr", "onpert", "wnpert", "numpad", "ancert", "snproc", "Nptr", "nameadr", "snpt", "unpad", "onfx", "onpad", "notetp", "annadr", "nnpointer", "Npad", "wcert", "nwptr", "nttr", " npad", "Npert", "nrect", "npointer", "onrect", "gnpt", "mnptr", "nadr", "nanpert", "numaddr", "gnptr", "unproc", " npol", "gnpointer", "nreq", "ntp", "npert", "dnpost", "nwproc", "nproc", "npost", "antr", "wnptr", "anaddr", "numfx", "numproc", "unfx", " naddr", "nPtr", " ncert", "ninrect", "nonptr", "unptr", "snpointer", "neaddr", "nameaddr", "annpert", " nadr", "mnpt", "onptr", " npointer", "anreq", "onadr", "enaddr", "jpert", " nreq", "nncert", " npt", "wnrect", "gncert", "nsp", "onpointer", "npad", "nrod", "dnpointer", "numpointer", "snpad", "nwcert", "anpointer", "enfx", "numpt", "nefx", "npol", "onproc", "nonpt", "nametp", "namept", "gnpost", "sntr", "wPtr", "nanaddr", "Npointer", " nPtr", "ncert", "naddr", "numptr", "nfx", "neadr", "nanadr", "onpr", " nfx", "wpert", "npr", "neproc", " ndr", "dnPtr"], "endptr": ["endPtr", "endedpt", "ENDptr", "endbp", " endbp", "Endpointer", "endedptr", " endtr", "Endp", "lastPtr", "Endtr", "endpointer", "lastptr", "endedpointers", "lastpt", " endpointers", "endedpointer", " endpointer", "endtr", "ENDtr", "endedPtr", "endpointers", " endp", "ENDpt", "endpt", "Endptr", "Endbp", "endedtr", "lasttr", "ENDPtr", "endedbp", "Endpointers", "endp", "endedp"], "end": ["all", "End", "then", "err", "ld", "close", "reset", "des", " End", "fr", "ff", "event", "server", "alt", "fin", "term", "rend", "re", "start", "ending", "enc", "e", "END", "info", "fail", "wind", "send", "est", "entry", "dev", "bound", "run", "pend", "append", "last", "eng", "it", "begin", "r", "rem", "post", "url", "str", "max", "good", "hend", "nd", "and", "ad", "rest", "obj", "len", "valid", "en", "old", "out", "final", "stop", "ver", "set", "gate", "check", "add", "ended", "id", "ext", "conn", "row", "st", "ender", "ell", "ment", "ent", "full", "reg", "except", "can"], "res": [" result", "expr", "med", "resp", "rez", "re", "sys", "out", "der", "pas", "rev", "ret", "ver", "stock", "r", "red", "vol", "rem", "err", " Res", "rel", "progress", "inv", "val", "ps", "RES", "resolution", "cs", "results", "conn", "def", "rs", "reset", "des", "pres", "vec", "j", "status", "result", "ress", "fr", " RES", "resh", "details", "pr", "ms", " reg", "cond", "Res", "vals", "reg", "js", "dev", "rest", "ins", "gr", "req", " residual", "conf", "crit", " ret", "rend", " err", "rek", "cons"]}}
{"project": "FFmpeg", "commit_id": "b2a8850969b89151677253be4d99e0ba29212749", "target": 0, "func": "static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {\n\n    double time = av_gettime() / 1000000.0;\n\n    /* update current video pts */\n\n    is->video_current_pts = pts;\n\n    is->video_current_pts_drift = is->video_current_pts - time;\n\n    is->video_current_pos = pos;\n\n    is->frame_last_pts = pts;\n\n    check_external_clock_sync(is, is->video_current_pts);\n\n}\n", "idx": 20961, "substitutes": {"is": ["ism", "isc", "isa", "any", "bits", "it", "ics", "ri", "os", "set", "parts", "ai", "isf", "tis", "ims", "irm", "ns", "act", "im", "iss", "bs", "ib", "ois", "cs", "il", "i", "IS", "fs", "isi", "sim", "info", "bis", "s", "sis", "get", "ais", "isal", "ip", "hw", "iris", "plays", "ls", "ms", "ir", "ris", "js", "in", "es", "ik", "has", "its", "ts", "ins", "ist", "Is", "lis", "isl", "does", "oss", "ish", "isin", "ists", "are", "serv"], "pts": ["pointc", "iptps", "pls", "psp", "apts", " ptts", "plS", "iptS", "pkgps", "plts", "ptls", "aptls", "pss", "ffts", "ctp", "ctc", "pkgs", "aptws", " ptws", "psc", "points", "pointls", "pkgts", "cts", "ptts", "iptts", "ffls", "pointp", "ptps", "aptts", "pkgS", "ptws", "ctls", "ipts", "psls", "ptc", "ffws", "plps", "ptS", "ptp", " ptls", "ffs"], "pos": ["resp", "p", "present", "time", "o", "os", "Pos", "pose", "offset", "win", " Pos", "d", "serv", "val", "ps", "pt", "loc", "pro", " positions", "def", "po", " position", "data", "ds", "xy", "s", "snap", "proc", "pid", "spec", "ms", "position", "POS", "vs", "seq", "seek", "js", "rot", "trans", " POS", "pc", " pose", "len", "gen", "port", "v", "point", "type"], "serial": [" vel", " random", " seed", " start", " total", " speed", " tick", " stream", " ser", " seek", " snap", " velocity", " times", " ver", " pid", " sec", "res", " sid", " step", " tid", " proc", " id", " delay", "ser", " sleep", " scale", " seq"]}}
{"project": "qemu", "commit_id": "a659979328fb6d4d6100d398f5bd9a2310c3e169", "target": 0, "func": "open_f(int argc, char **argv)\n\n{\n\n\tint flags = 0;\n\n\tint readonly = 0;\n\n\tint growable = 0;\n\n\tint c;\n\n\n\n\twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 's':\n\n\t\t\tflags |= BDRV_O_SNAPSHOT;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\n\t\t\tflags |= BDRV_O_NOCACHE;\n\n\t\t\tbreak;\n\n\t\tcase 'r':\n\n\t\t\treadonly = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'g':\n\n\t\t\tgrowable = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&open_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (!readonly) {\n\n            flags |= BDRV_O_RDWR;\n\n        }\n\n\n\n\tif (optind != argc - 1)\n\n\t\treturn command_usage(&open_cmd);\n\n\n\n\treturn openfile(argv[optind], flags, growable);\n\n}\n", "idx": 20970, "substitutes": {"argv": ["argsv", " argvs", " argV", "argw", " argz", "arguments", "argumentvs", "argsw", " argp", " argc", "argsvs", "agv", "argz", "argp", "argsp", "args", "argvs", "agc", "argc", "argsz", " args", "argV", "argumentc", "argumentV", " argw", "argsV", "agz", "argumentw", "argsc", "agp", "argss", "argumentv"], "c": ["n", "t", "p", "com", "rc", "vc", "a", "o", "r", "ce", "f", "dc", "m", "abc", "ac", "co", "gc", "ct", "d", "count", "unc", "x", "cs", "code", "e", "bc", "i", "uc", "ec", "cur", "cmp", "z", "C", "cod", "k", "\u00e7", "lc", "sc", "cf", "ch", "g", "mc", "pc", "conf", "tc", "cache", "u", "nc", "cc", "b", "v", "l", "fc", "cp", "xc", "w"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n", "idx": 20975, "substitutes": {"s": ["comm", "t", "p", "is", "sys", "r", "os", "set", "m", "changes", "ss", "ns", "y", "ims", "ses", "stats", "d", "ps", "bs", "ops", "sim", "sts", "sports", "rs", "fs", "gs", "aws", "services", "ds", "sis", "st", "bis", "se", "status", "spec", "ls", "details", "sv", "sw", "hs", "S", "ess", "js", "es", "has", "sq", "ts", "ins", "its", "qs", "less", "store", "sb", "b", "l", "sl"], "buf": ["kw", "loop", "p", "cap", "pack", "func", "cb", "ref", "desc", "off", "aka", " buffer", "Buff", "pkg", "uf", "font", "bar", "Buffer", "bc", "cv", "bn", "tab", "fb", "vec", "batch", "proc", "ab", "img", "ff", "bo", "ctx", "ptr", "br", "queue", "env", "map", "db", "buffer", "addr", "dev", "iter", "mem", "doc", "buff", "pb", "cmd", "pool", "emb", "cam", "cache", "ah", "b", "cast", "v", "pad", "ev"], "event_code": ["eventsetclose", "versionencontroller", "eventStatuschange", "eventixchoice", "version_currency", "owner_success", "eventitystatus", "event_choice", "event5command", "eventStatuscode", "owner_comment", "eventencecode", "event_controller", "event5code", "ownerixchoice", "eventsetcode", "eventixcode", "event_change", "event_comment", "eventixcomment", " event_case", "event__status", "ownerixcomment", "event_currency", "eventletclose", "event5order", "eventencereason", "eventencecase", "event_order", "event____codes", "eventencurrency", "event____code", " event_reason", "eventitycode", "eventenchoice", "eventStatuscommand", "owner_choice", "eventencomment", "event__codes", "event__case", "version_code", " event_status", "versionenclose", "event_reason", "eventitycase", "version_controller", "event_case", "event__code", "eventopchoice", "eventsetcontroller", "eventencontroller", "eventixsuccess", "versionencode", "eventletcurrency", "eventsetcurrency", "ownerixcode", "eventencode", "version_close", "event_close", "state_code", "ownerixsuccess", "eventopcomment", "event5change", "event_command", "eventletcode", "event____case", "eventencestatus", "eventensuccess", "state_order", "state_command", "event_codes", "eventStatusorder", "versionencurrency", "eventletcontroller", "owner_code", "eventenclose", "event____status", "event_status", "eventopcode", " event_codes", "eventityreason", "eventopsuccess", "state_change", "event_success"], "media_status": ["finalprostart", "final_start", "medium_status", "memory___set", "finalproscore", "mediaStatusdisplay", "mediaStatusaccess", "medium_stats", "media_access", "media_stat", "media67code", " media_info", "memory_display", "media_state", "memory___Status", "mediaitysettings", " media_state", "media_strength", "area____code", "mediaprostatus", "area_code", "memory___status", "area____status", "media_start", "media_set", "mediaStatusStatus", "media____operator", "mediaStatusstatus", "media_code", "mediaStatusdescription", "mediaitystat", "mediapropost", "media___status", "media____status", "mediaitystatus", "media_info", "area_status", "finalpropost", "mediaproscore", "mediaStatusset", "memory_status", " media_stat", "mediaPstats", "final_post", "media67status", "area____operator", "mediaStatusscore", "media67score", "media_stats", "media____code", "media_settings", "mediaStatusstart", "area_strength", "medium_description", "media_display", "media___display", "final_status", "mediaStatuspost", "media67operator", "area_operator", "media_description", "mediaPaccess", "media_score", "media___set", "media67post", "media____strength", "media_post", "media_Status", "final_score", "media67start", "mediaPdescription", "memory___display", "memory_Status", " media_error", " media_settings", "area____strength", "mediaityinfo", "finalprostatus", "media___Status", "medium_access", "media_operator", "media_error", "mediaprostart", "mediaPstatus", "media67strength", "memory_set", "mediaStatusstats"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n", "idx": 20994, "substitutes": {"hotplug_dev": ["hotplugablebuf", "hotPlug_Dev", "hotplug_buf", "hotpl_dev", "hotplug_Dev", "hotplug2dev", "hotplug2Dev", "hotplugeddef", "hotplugableDev", "hotplug__dev", "hotplugedDev", "hotplugabledev", "hotpl_device", "hotpl_Dev", "hotplug_device", "hotPlug_def", "hotplugeddev", "hotplugedbuf", "hotplug_def", "hotplug__buf", "hotplugablediv", "hotplug2buf", "hotplug__Dev", "hotPlug_buf", "hotPlug_dev", "hotplug__div", "hotplug_div", "hotplug2div"], "dev": ["hid", "vd", "der", "ver", "Dev", "dd", "dis", "h", "device", "debug", "d", "tech", "pro", "def", "develop", "test", "data", "des", "ds", "watch", "md", "hd", "hw", "DEV", " device", "raw", "env", "dem", "ow", "priv", "mem", "doc", "ad", "ch", "adv", "de", "wd", "cam", "pad", "att", "v", "local", "ev", "w"], "errp": ["derp", "excpp", "errP", "excP", "errpa", " errP", " errpc", "derpc", "errpp", "errbp", " errpa", " errpp", "errpc", "derpp", " errbp", "diepc", "derpa", "excpa", "diep", "excp", "diebp", "dieP", "derP", "derbp"], "vdev": [" vdevice", "avpro", "Vdef", "gev", "vdef", "vtdev", "uvdev", "gdevice", "vtpro", "uvdevice", " vdef", "vdevice", "uvdiv", "uvdef", "vev", "vdiv", "vtev", "gdev", "avev", "avdev", "svdev", "svdef", " vdiv", "svdevice", "avdevice", "Vdiv", "gpro", "Vdevice", "vtdevice", "gdiv", "Vdev", "svdiv", "gdef", "vpro"], "s": ["n", "p", "is", "a", "sa", "sym", "si", "su", "h", "ss", "ns", "sf", "stats", "iss", "ps", "i", "sts", "cs", "fs", "gs", "rs", "des", "ds", "sis", "st", "j", "se", "south", "sn", "sm", "ls", "ms", "sv", "sh", "sam", "sw", "S", "js", "es", "g", "sq", "sp", "ts", "sg", "sb", "sol", "b", "an", "v", "so", "sl"], "sd": ["td", "vd", "sys", "dh", "sa", "si", "sing", "di", "dd", "dk", "dis", "ss", "sk", "d", "cs", "bd", "ds", "sis", "md", "hd", "dl", "SD", "sm", "sn", "sam", "sv", "sy", "sh", "sw", "sky", "sc", "od", "sq", "sp", "fd", "sg", "sid", "sb", "pd", "ev", "sl"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,\n\n                                    SocketAddress *addr,\n\n                                    Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_connect_sync(ioc, addr);\n\n    fd = socket_connect(addr, NULL, NULL, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_connect_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_connect_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20996, "substitutes": {"ioc": ["atioc", "tioco", "diOC", "ioOC", "ioid", "cioc", "ioos", "iroc", "iooci", " ioco", "piroc", "iosc", "pioci", "tiroc", "iooc", "pioco", "pioc", "ioco", "cioid", "atios", "cioco", "dioc", " iOC", "tiOC", "ioci", "piosc", " ioci", "tioc", "tiosc", "diroc", "piocon", "diocon", "iOC", "ioroc", "atiOC", "ciocon", " iocon", "tioci", "piOC", "ioosc", "pioid", "atioci", " iroc", " ioid", "tiocon", "iocon"], "addr": ["fx", "aj", "mk", "msg", "start", "a", "r", "arp", "ack", "ix", "add", "rel", "ac", "rol", "aw", "act", "inv", "wid", "ha", "src", "ash", "url", "arr", "loc", "rs", "host", "md", "oa", "ip", "coord", "live", "mt", "ptr", "now", "ag", "align", "rt", "bind", "alt", "map", "adr", "Address", "ad", "wd", "address", "cmd", "ace", "nl", "work", "pos", "art", "attr"], "errp": ["errps", " erP", "erp", "derp", "errP", " errpost", "errpost", "errm", " errjp", " erpost", "errpa", "errr", "errorm", "err", " errP", "arrp", "errorjp", " errpa", "errjp", "cerpost", "derr", "cerp", " erpa", "derps", "erps", "cerP", " erp", " errps", "cerpa", " errr", "erP", "errorp", "errorP", "arrP", "arrjp", "arrm", " errm", "derP"], "fd": ["td", "fun", "fn", "fx", "bf", "func", " sd", "dd", " dur", "f", "fed", " ff", "sd", "gz", "d", "gd", "fe", "unc", "fm", "ld", "dt", " f", "fs", "created", " td", "dl", "dig", "fb", "ds", "hd", "handle", "pid", "fp", "nd", "fr", "dra", "ff", "FH", "dy", "ptr", "df", "fi", "dat", "cond", " fid", "db", "cf", "fin", "ud", "ln", " df", " fin", " fs", " fl", "pd", "lf", "elt", "fc", "fl", "FD", "da", "ffff", " fa", " fut"]}}
{"project": "FFmpeg", "commit_id": "e30b068ef79f604ff439418da07f7e2efd01d4ea", "target": 1, "func": "static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    /** when the frame data does not need to be concatenated, the input buffer\n        is resetted and additional bits from the previous frame are copyed\n        and skipped later so that a fast byte copy is possible */\n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);", "idx": 21007, "substitutes": {"s": ["is", "source", "ims", "ops", "sts", "ds", "details", "ssl", "sv", "sw", "hs", "xs", "es", "ins", "als", "less", "sb", "as", "sql", "n", "a", "os", "changes", "ns", "sync", "bs", "x", "cs", "results", "aws", "fs", "bis", "status", "ats", "vs", "views", "self", "ts", "sg", "qs", "tes", "comm", "sys", "settings", "stats", "d", "ps", "services", "args", "ctx", "ls", "utils", "ies", "S", "its", "sp", "conf", "store", "l", "so", "serv", "p", "set", "parts", "h", "ss", "ses", "eps", "rs", "gs", "q", "ms", "js", "tests", "sq", "ains", "w"], "gb": ["gt", "csv", "vd", "gif", "rb", "sys", "eb", "gpu", "py", "tg", "cb", "hub", "tp", "bps", "gm", "goo", "gc", "gz", "gd", "mb", "bs", "rg", "ib", "uf", "bridge", "eg", "vg", "gs", "gio", "vm", "gnu", "cv", "fb", "nb", "gom", "img", "ctx", "gin", "bm", "mg", "ub", "bg", "lib", "yg", "wb", "db", "storage", "buffer", "gg", "g", "kb", "phy", "rl", "buff", "pb", "Gb", "pg", "bt", "sg", "pc", "tm", " GB", "GB", "sb", "gh", "gp", "bp", "bj", "gov", "vp", "cfg", "bb"], "len": ["n", "gt", "valid", "en", "all", "end", "ret", "list", "ref", "del", "Len", "length", "offset", "bl", "conv", "enc", "val", "loc", "lp", "ld", "lan", "il", "lon", "str", "data", "size", "bytes", "lt", "vec", "cmp", "ell", "lang", "local", "compl", "lim", "kl", "repl", "cod", "ls", "align", "full", "num", "un", "alt", "hl", "seq", "split", "iter", "fin", "mem", "gl", "ln", "nt", "sp", "bin", "nl", "pos", "ll", "elt", "lf", "half", "l", "fl", "el"], "append": ["enable", "valid", "grow", "end", "app", "raise", "index", "force", "write", "alias", "seed", "add", "ended", "enc", "note", "ext", "empty", "vert", "END", "join", "close", "leaf", "important", "fail", "batch", "replace", "prop", "shift", "bind", "send", "drop", "equal", "open", "atten", "ignore", "only", "update", "pend", "buff", "after", "attach", "visible", "next", "pad", "bold", "flag", "apply", "push", "attr", "insert"], "buflen": ["bufrog", "bullov", "buflog", "buclade", "buflun", "buplan", "lufrog", "buvlen", " buflan", "buplen", "bullan", "bucilog", "luflah", "buvlength", "lufren", "bufllen", "bufrade", "cuflens", "buvlun", "buflov", "bulllen", "cuvelens", "bufxlen", "bufxov", "cuvellen", "buclog", "cufllen", "cuvelov", "bucilade", "buflength", "buvlan", "buflan", "bufxen", "buclen", "cuflen", " bullength", "buclah", " bullan", "bullength", " bullun", "luflade", "bullens", "buvelens", "cuflov", "bucilah", "buvelen", "bucilen", "buplength", "buplun", "bufren", "lufrah", "lufrade", "bufxens", " buflength", "buflens", " buflun", "bullun", "buvellen", "bufrah", "cuvelen", " bullen", "luflen", "bullen", "buflah", "buflade", "luflog", "buvelov"]}}
{"project": "FFmpeg", "commit_id": "a55692a96099c40aabb25e1443890be99f9c845c", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012, "substitutes": {"w": ["p", "t", "writer", "a", "r", "write", "f", "m", "h", "window", "nw", "d", "e", "fw", "c", "s", "iw", "rw", "sw", "wb", "W", "g", "wt", "ew", "wa", "b", "v"], "fmt_ctx": ["ftm_ctx", "fmt2ctx", "fmt_context", "flt_tx", "fmt_conf", "fmt2tx", "flt_xc", "fmt2pkg", "frt_context", "flt_ctx", "frt_ctx", "fmt_tx", "fmt___xc", "ftx_ctx", "fmt_pkg", "frt_pkg", "fmt_xc", "ftm_pkg", "fmt2context", "fmt2xc", "ftx_cmd", "fmt_cmd", "fmt___ctx", "ftx_tx", "frt_tx", "ftm_conf", "ftx_context", "fmt___context", "ftm_context", "flt_context", "fmt___tx"], "interval": ["innerallel", " interallel", "prechange", "vervol", "schevol", "interpoint", "intsection", "iterv", "airchange", " interv", "terchange", "innerval", "airceptor", "inVAL", "interv", "intergrade", "verval", " interival", "intermediate", "interVAL", "intervol", "terpoint", "inval", "Intervals", "interchange", "itervol", "intival", "intval", " interrange", "INTERVAL", "scheval", "interrange", "airVAL", "INTERallel", "intersection", "iterpoint", "preVAL", "iterVAL", "INTERv", " interVAL", "terVAL", "tersection", "interival", "scheVAL", "Interchange", "Interceptor", "itermediate", " interchange", "INTERvol", "tergrade", "Interv", "iterrange", "tervals", "vermediate", " intervals", "inival", "Interval", "INTERvals", "INTERgrade", "interallel", " intergrade", "preval", "innermediate", " intervol", " Interval", "INTERpoint", "terv", " Interival", "invol", "preceptor", "verrange", "airval", "INTERmediate", "Intersection", "InterVAL", "iterval", "intervals", " Intervol", "INTERval", "innerVAL", " intermediate", "iterival", "schemediate", "interceptor", "intvals", "terval", "intv", " InterVAL"], "cur_ts": [" cur_", "curpyks", "cur__ks", "cur_ks", "curThets", "Cur__time", "ctrl_tz", "tmp_", "cur__TS", "cur__time", "cur_ms", "current_", "Cur__times", "cur__snap", "Cur_uts", "Cur_time", "Cur__tz", "ctrl_ks", "Cur_ts", "Cur__ts", "cur__uts", "cur__cs", "cur_snap", "ctrlThesnap", "ctrlTheks", "cur_cs", "curTheks", "curpyts", "Cur_times", "ctrlThets", "curThesnap", "cur_uts", "curThetz", "cur_time", "Cur_tz", "Cur_ms", "ctrl_snap", "cur__tz", "Cur_cs", "ctrlThetz", "curpytz", "ctrl_ts", "cur_times", "Cur_TS", "cur_TS", "cur_tz", "cur__ts", "cur_", "cur__times", "curpysnap"], "pkt": ["facket", "tpkg", "promsg", " pkg", "pet", "fcmd", "pmt", "pcmd", "fmt", "cpwk", "packet", "pingacket", "fft", "npacket", "proacket", " pwd", "pingkg", " pft", "Pet", "pwd", "tpwk", "prokt", "pwk", " pnt", "punct", "pingkt", " pmt", "tpacket", " pwk", "spcmd", "pact", "ppacket", "perwk", "pmsg", "tet", "perkg", "pft", "cpnt", "spft", "Pkg", "pkg", "fact", "perkt", " pmsg", "tkt", "cmsg", "npkt", "fkt", "cwd", "ppnt", "pingunct", "peracket", "pingmsg", " pcmd", "ppwk", "spacket", "tkg", "tacket", "fmsg", "prounct", "pingact", "cpacket", "pnt", "ppkt", "Packet", "cmt", "npet", "Pkt", "npkg", "ckt", " punct", "spkt", "fwd", " pact", "fkg", "tpkt", "cpkt", " packet"], "pkt1": ["pwk1", "pft1", "pft2", "pct0", "pwk5", " pkt2", "pft5", " pkt0", " pwk5", "pct2", " pwk1", " pwk0", "pct1", " pkt5", "pkt5", "pkt2", "pkt0", "pwk0", " pwk2", "pft0", "pct5", "pwk2"], "frame": ["state", "message", "iframe", "context", "cue", "ce", "process", "force", "f", "movie", "window", "head", "relation", "image", "trace", "fw", "row", "frames", "point", "profile", "base", "Frame", "fr", " frames", "event", "scene", " framed", "fi", "queue", "seq", "part", "feat", "face", "sequence", "feature", "error", "ence", "block", "cmd", "framework", "fram", "flow", "chain", "channel"], "target": ["gt", "valid", "t", "start", "bolt", "begin", "source", "set", "length", "window", "offset", "rel", " targ", "transform", "root", "goal", "format", "table", "top", "total", "inter", "dest", "arg", "trace", "Target", "eth", "until", "data", "peer", "timeout", "reset", " targets", "eta", "limit", "size", "tr", "point", "base", "result", "mt", "height", "ptr", "created", "jump", "tmp", "seek", "alt", "buffer", " Target", "ta", " targeted", "match", "ts", "path", "range", "obj", "iat", "next", "pointer", "to", "arget", "port", "trap", "origin", "ARGET", "padding", "alias"], "frame_count": ["frame2c", "frame_ctr", " frame_c", " frame_ctr", " frame2Count", " frame2c", "frame2count", " frame2ctr", "frame2Count", " frame2count", "frame_Count", "frame_c", "frame2ctr", " frame_Count"], "i": ["n", "ij", "p", "t", "it", "si", "r", "index", "ai", "f", "m", "im", "ind", "I", "c", "limit", "ti", "j", "ip", "q", "fi", "ci", "mi", "ii", "pi", "l", "b"], "stream_index": ["channel_ind", "stream_id", " stream_position", "channel_id", "stream_ind", " stream_id", "channel_index", "stream_hash", "stream_offset", "stream_position", "channel_hash", " stream_offset"]}}
{"project": "FFmpeg", "commit_id": "d32547a24a3fcc8286b318353f43805838b84775", "target": 1, "func": "int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx,\n                                             uint8_t *buf, int buf_size,\n                                             const short *samples)\n{\n    AVPacket pkt;\n    AVFrame *frame;\n    int ret, samples_size, got_packet;\n    av_init_packet(&pkt);\n    pkt.data = buf;\n    pkt.size = buf_size;\n    if (samples) {\n        frame = av_frame_alloc();\n        if (!frame)\n            return AVERROR(ENOMEM);\n        if (avctx->frame_size) {\n            frame->nb_samples = avctx->frame_size;\n        } else {\n            /* if frame_size is not set, the number of samples must be\n             * calculated from the buffer size */\n            int64_t nb_samples;\n            if (!av_get_bits_per_sample(avctx->codec_id)) {\n                av_log(avctx, AV_LOG_ERROR, \"avcodec_encode_audio() does not \"\n                                            \"support this codec\\n\");\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            nb_samples = (int64_t)buf_size * 8 /\n                         (av_get_bits_per_sample(avctx->codec_id) *\n                          avctx->channels);\n            if (nb_samples >= INT_MAX) {\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            frame->nb_samples = nb_samples;\n        }\n        /* it is assumed that the samples buffer is large enough based on the\n         * relevant parameters */\n        samples_size = av_samples_get_buffer_size(NULL, avctx->channels,\n                                                  frame->nb_samples,\n                                                  avctx->sample_fmt, 1);\n        if ((ret = avcodec_fill_audio_frame(frame, avctx->channels,\n                                            avctx->sample_fmt,\n                                            (const uint8_t *)samples,\n                                            samples_size, 1)) < 0) {\n            av_frame_free(&frame);\n            return ret;\n        }\n        /* fabricate frame pts from sample count.\n         * this is needed because the avcodec_encode_audio() API does not have\n         * a way for the user to provide pts */\n        if (avctx->sample_rate && avctx->time_base.num)\n            frame->pts = ff_samples_to_time_base(avctx,\n                                                 avctx->internal->sample_count);\n        else\n            frame->pts = AV_NOPTS_VALUE;\n        avctx->internal->sample_count += frame->nb_samples;\n    } else {\n        frame = NULL;\n    }\n    got_packet = 0;\n    ret = avcodec_encode_audio2(avctx, &pkt, frame, &got_packet);\n    if (!ret && got_packet && avctx->coded_frame) {\n        avctx->coded_frame->pts       = pkt.pts;\n        avctx->coded_frame->key_frame = !!(pkt.flags & AV_PKT_FLAG_KEY);\n    }\n    /* free any side data since we cannot return it */\n    av_packet_free_side_data(&pkt);\n    if (frame && frame->extended_data != frame->data)\n        av_freep(&frame->extended_data);\n    av_frame_free(&frame);\n    return ret ? ret : pkt.size;\n}", "idx": 21030, "substitutes": {"avctx": [" avjac", " avcmd", "avtc", "averkl", "avecmp", "avecfg", "avcp", "wavcfg", " avcmp", "avcomp", "afcontext", "wavctl", "avecp", "afctx", "afcp", " avreq", "avecomp", "verctl", "wavcmp", " avctl", "wavtx", "avetc", "aptx", "avercmd", "avcmp", "actctx", "avekl", "avercontext", "ajtx", "apctx", "averctx", "apcontext", "avercp", "afcmp", "avercmp", "averctl", "avecmd", "actjac", "avercomp", " avcontext", " avtx", "avertc", "avereq", "aftx", " avcfg", "avtx", " avcomp", "avetx", "avecontext", "avejac", "avjac", "wavcontext", "afctl", "ajjac", "avreq", "avconn", "wavctx", "apcp", " avtc", " avconn", "avcontext", "actcontext", "avectl", "avkl", "avctl", "afkl", "aveconn", " avcp", "wavjac", "ajcfg", " avkl", "avcmd", "ajreq", "ajctx", "ajconn", "ajcontext", "verctx", "avectx", "avcfg", "averconn", "vercmp", "acttx", "vercmd"], "buf": ["p", "rb", "msg", "alloc", "bf", "cb", "ref", "window", "Buff", "arr", "uf", "Buffer", "cv", "data", "fb", "bytes", "vec", "batch", "img", "ctx", "raw", "q", "queue", "wb", "seq", "db", "buffer", "box", "mem", "doc", "bound", "buff", "pb", "block", "cmd", "pos", "b", "bp", "v", "pad"], "buf_size": ["uf_size", "uf_Size", "buff_Size", "buf_length", "buf_dim", "buf_Size", "buf_len", "buf2Size", " buf_len", "buf2size", "buff_length", "buf2length", " buf_length", "buff_size", "buf2len", "uf_dim", " buf_Size", "buff_len"], "samples": ["samps", " sources", "ssamples", "nources", "Samps", "ssents", " samps", "ssigs", "Sources", "nents", "sents", "asamples", "ssamps", " sents", "asources", "Samples", "Sents", "asamps", "Sigs", "sigs", " sigs", "namps", "sources", "namples"], "pkt": ["Packet", "prokt", "opkt", "opacket", "Pet", "wwd", "Pkt", "wpt", "apkg", " ppt", "wacket", " pkg", "pet", "cpet", "Pkg", "pkg", " apkt", "packacket", "propt", "opet", "pix", " pet", "packkt", "packet", "packwd", "opix", "apacket", "appt", " apkg", "cpkt", "ppt", " apet", "apkt", "prokg", "proacket", " pwd", "wkt", "cpacket", "packpt", " packet", " apacket", "cpix", " pix", "pwd"], "frame": ["message", "cue", "role", "ce", "process", "zone", "filter", "head", "fake", "shot", "fe", "close", "reset", "host", "fr", "function", "word", "event", "scene", "video", "feat", "component", "feature", "command", "ence", "next", "client", "framework", "file", "local", "flow", "point", "chain", "channel", "rame", "focus", "state", "response", "context", "movie", "package", "trace", "empty", "info", "join", "data", "show", "base", "part", "self", "cf", "face", "sequence", "new", "cmd", "remote", "header", "instance", "time", "load", "iframe", "force", "f", "session", "object", "table", "image", "embed", "call", "style", "def", "fb", "frames", "proc", "request", "module", "buffer", "range", "line", "comp", "field", "window", "init", "code", "row", "step", "profile", "fp", "Frame", "version", "draw", "queue", "page", "error", "block", "form", "fram"], "ret": ["gt", " Ret", "resp", "t", "re", "out", "txt", "it", "det", "print", "xt", "ber", "ref", "back", "f", "rets", "Return", "rem", "err", "Ret", "count", "val", "def", "ter", "pret", "reset", "mel", "tr", "status", "result", "mt", "aux", "ft", "rt", "reply", "res", "alt", "vals", "nt", "RET", "virtual", "after", "len", "ll", "elt", "flag", "tf"], "samples_size": ["sampleszSize", "samps_ize", "samples_no", "samples67Size", "samps_size", "samples_count", "samps_num", "samps_Size", "samples_Size", "samps_count", "samples2name", "samples2count", "samples67num", "samps_no", "samples_num", "sampleszno", "samps_name", "samples_ize", "sampleszsize", "samplesznum", "samples67no", "samples2Size", "samples67size", "samples2size", "samples_name"], "got_packet": ["n", "got_packkt", "all", "got_ppkt", "func", "got_preskt", "got_compet", "got_packacket", "call", "def", "got_presacket", "got_compacket", "got_preset", "got_compets", "got_ppets", "got_compkt", "got_ppet", "got_presets", "new", "got_ppacket", "_", "got_packets"], "nb_samples": ["nb_namples", "nb_Subes", "nb_bamples", "nb_nsounds", "nb_isplays", "nb_Sounds", "nb_sents", "nb_jsources", "nb_nsans", "nb_dounds", "nb_Slements", "nb_lplays", "nb_nents", "nb_sales", "nb_damples", "nb_desamples", "nb_jsances", "nb_lizes", "nb_Sources", "nb_Samples", "nb_Sples", "nb_saves", "nb_sans", "nb_pizes", "nb_nsaves", "nb_esples", "nb_lamples", "nb_psamps", "nb_sples", "nb_psamples", "nb_isizes", "nb_isamples", "nb_Saves", "nb_maves", "nb_Sans", "nb_nubes", "nb_sizes", "nb_mamps", "nb_sances", "nb_desples", "nb_nizes", "nb_mamples", "nb_sources", "nb_esamps", "nb_bonents", "nb_nsamples", "nb_naves", "nb_psources", "nb_sounds", "nb_bizes", "nb_esamples", "nb_samps", "nb_ments", "nb_eslements", "nb_nsamps", "nb_sonents", "nb_Sizes", "nb_nales", "nb_ponents", "nb_csubes", "nb_nsizes", "nb_pamples", "nb_deslements", "nb_Sances", "nb_namps", "nb_subes", "nb_nsonents", "nb_nplays", "nb_damps", "nb_csamps", "nb_desamps", "nb_jsamps", "nb_isales", "nb_dans", "nb_pamps", "nb_Samps", "nb_splays", "nb_csamples", "nb_Sents", "nb_slements", "nb_lales", "nb_psances", "nb_bamps", "nb_jsamples"]}}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n", "idx": 21034, "substitutes": {"function": ["fn", "fun", "name", "vector", "context", "func", "number", "role", "amount", "index", "lambda", "force", "f", "length", "value", "attribute", "object", "method", "program", "closure", "table", "unc", "array", "document", "size", "library", "connection", "family", "word", "kernel", "event", "full", "module", "frequency", "cf", "service", "command", "action", "expression", "address", "form", "Function", "handler", "functional", "type"], "count": ["n", "name", "vector", "start", "context", "number", "amount", "index", "list", "force", "sum", "length", "hash", "table", "th", "total", "call", "id", "array", "code", "cs", "c", "var", "size", "test", "batch", "nb", "base", "result", "found", "ctx", "ount", "num", "seq", "Count", "nt", "range", "cycle", "cache", "len", "v", "ctr", "counter"], "eax": ["eas", "erox", "ecabs", "ebaj", "eras", "edabs", "edag", "eox", "xac", "edac", "ebae", "xabs", "ebab", "erag", "ebag", " eox", "ecae", "ebox", "ecab", "ebax", "eac", "ecac", "eraj", "eaj", "erax", " eaj", " eas", "ebas", "eag", "eab", "ecag", "xax", "eabs", "erae", "ecax", "edax", "xag", "eae", "erab"], "ebx": ["ibax", "egix", "ubox", "ubix", "abbix", "egx", " ebz", "ubx", "dbex", "erbax", " ebax", "dbax", "ibix", "ebox", "ebix", "ebax", "erbex", "egz", "ebz", "erbix", "erbx", "ibx", "ibox", "ibex", "abbx", "abbax", "ubz", "ubax", "abbox", "dbx", "egax", "dbix", " ebix", "ebex"], "ecx": ["egw", "edw", "egix", "edp", "ebj", "cex", "ceax", " ecj", "ecy", " ecv", "egx", "exw", "egxx", "ebv", "edix", "ebax", "edj", "exxx", " ecy", "ebp", "edxx", "cep", "eby", "ecj", "ecix", "exx", "exix", "ecv", "ecw", "ecax", "edax", "ecxx", "edv", "ecp", "cey", "edy"], "edx": ["osedax", "oledctx", "nedix", "mentedxi", "nedxi", "oledix", "oledx", "adax", " edix", "nedax", "eix", "adx", "adux", "atedax", "mentedx", "eux", "edix", "mentedix", "mentedax", "atedux", "edux", "osedxi", "osedix", "edxi", "etix", "ex", "etctx", " edctx", "oledxi", "osedx", "etx", "adix", "atedix", "edctx", "nedx", "edax", "atedx", "etxi", " edxi"], "vec": ["ele", "msg", "pack", "et", "vid", "length", "err", "sum", "pt", "vert", "uv", "sv", "vet", "v", "point", "ev", "vector", "veh", "list", "vre", "data", "values", "vs", "seq", "deep", "dev", "mit", "mem", "cmd", "cam", "bin", "fam", "fc", "vc", "it", "Vector", "act", "vr", "def", "cv", "tx", "str", "var", "ec", "proc", "buf", "ctx", "spec", "ptr", "resh", "ve", "wit", "buffer", "nt", "req", "obj", "len", "vp", "save", "vt", "serv", "mat", "plot", "cap", "kt", "ver", "func", "index", "go", "seed", "inv", "iv", "val", "test", "result", "prop", "dict", "queue", "vals", "js", "doc"]}}
{"project": "FFmpeg", "commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "target": 1, "func": "static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,\n\n                           int flags)\n\n{\n\n    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n", "idx": 21037, "substitutes": {"ctx": ["kw", "fx", "jac", "resp", "sys", "rc", "txt", "context", "kt", "ck", "cb", "cn", "tnc", "gc", "ct", "pkg", "tz", "con", "conn", "cu", "cv", "tx", "jp", "cmp", "hw", "setup", "cpp", "tmp", "cm", "sc", "cf", "wcs", "wd", "config", "prefix", "np", "cmd", "tc", "obj", "nc", "cc", "ca", "ctl", "cp", "cas", "ctr", "xc"], "dst": ["dto", "adbr", " dsp", " dwt", "dedest", "dest", "hot", "adest", "hST", "dwt", " dST", "sdest", "adot", "ddto", "Dth", "adST", "adsts", "dnd", "Dto", "doST", "hst", "Dend", "dth", "Dot", " dtr", "Dbr", " dend", "dbST", " dot", " dnd", "dosts", "dbst", "ddth", "Dsts", "dput", "ddest", "adtr", " dsts", "dtr", "ddbr", "ddsp", "ddnd", "sdnd", "Dwt", "deest", "ddend", "Dnd", "Dst", "sdto", "adst", "deST", "dbest", "dost", "dests", "Ddest", "sdput", "dsts", "ddput", "dbr", "doot", "Dest", "adwt", " dput", "ddST", "ddst", " dbr", "Dsp", "sdsts", "sdst", "hest", "dend", "dsp", "dbtr", "sdth", "dST", "sdST", "DST", " dest", " ddest", "dot"], "src": ["sys", "rc", "txt", "sel", "start", "source", "sec", "desc", "sf", "scan", "sync", "conv", "init", "iv", "vr", "image", "dest", "rs", "RC", "syn", "st", "cur", "cmp", "proc", "sr", "img", "sn", "ptr", "rt", "tmp", "via", "ur", "sc", "in", "face", "ins", "inner", "config", "sq", "sp", "from", "rl", "np", "sub", "obj", "sur", "input", "inst", "sb", "ser", "comp", "ctr", "nil"], "flags": ["boxes", " Flags", "ports", "rates", "bits", "settings", "aps", "kind", "weights", "parts", "tags", "bugs", "acts", "words", "FLAG", "mask", "gs", "args", "comments", "styles", "locks", "planes", "files", "names", "atts", "values", "ms", "cond", "properties", "types", "wcs", "ants", "ts", "Flags", "cmd", "features", "ags", "options", "fps", "actions", "members", "flag", "limits", "lag", "fields"], "surface": ["filename", "rect", "view", "context", "Sur", "func", "source", "sun", "window", "FACE", "image", "inter", " surf", "uf", "bridge", "fac", "sim", "package", "texture", "ra", "managed", "data", "profile", "proc", "tile", "unity", "dra", "png", "ptr", "far", "ve", "ui", "sam", "tmp", "plane", "buffer", "face", "save", "subject", "screen", "prof", "np", "form", "sur", "metadata", "reflect", "origin", " Surface", "uri"], "map": ["master", "man", "M", "mk", "view", "txt", "pack", "maps", "func", "make", "app", "set", "ack", "tool", "m", "policy", "window", "scale", "hash", "transform", "ac", "image", "bridge", "mask", "mp", "bar", "copy", "tap", "row", "texture", "data", "apper", "ape", "size", "ap", "tile", "mt", "lock", "buf", "result", "img", "bind", "mg", "tmp", "buffer", "shape", "addr", "box", "mem", "Map", "MAP", "match", "config", "block", "tree", "clear", "conf", "cache", "metadata", "pad", "cast", " MAP", "cp", "save"], "surfaceDesc": ["faceDec", "surfacedesc", " surfaceName", "surfaceDec", "uriDesc", "faceDes", "surfaceSpec", " surfaceSpec", " surfSpec", " surfaceDec", " surfaceDes", "faceName", " surfDec", "faceSpec", "texturedesc", "surfaceDes", " surfDesc", " surfacedesc", "facedesc", "textureDes", "surfaceName", " surfdesc", "faceDesc", "uridesc", "uriName", "textureDesc"], "LockedRect": [" mLockedRECT", "LiedRat", "latchedRegion", "Lockedrect", "LockedText", "LiedRegion", "LockerText", "Clockedrect", "LashedArea", "LachedRect", "LockedDir", "ClockedDir", "LockingRect", "LockerDir", "lockedLoc", "LatchedRat", "LlockedRect", "Lockrect", "LotedRegion", "Lockerrect", "LiedLoc", "LotedLoc", "LonedArea", " mLashedArea", "LatchedLoc", "LachedArea", "LonedRECT", "LiedRect", " mLashedLoc", " mLockedLoc", "LachedLoc", "LackedDir", "LockedRECT", "LlockedRegion", "LockRegion", "ClockRect", "LackedRect", " mLashedRect", "LockerRect", "LockingRegion", "LatchedRect", "Clockrect", "LonedRect", "latchedRat", "ClockedRect", "LashedRECT", "lockedRegion", " mLashedRECT", "ClockedRegion", "latchedLoc", "LotedRat", "LashedLoc", "LockedRat", "LockRect", "LockerRegion", "LockedArea", "LockedLoc", "LockedRegion", "LatchedRegion", "ClockRegion", " LlockedText", "LonedLoc", "lockedRect", "LockDir", " LockedRegion", "Lackedrect", " LlockedRegion", "LachedRECT", "ClockDir", "latchedRect", " LockedText", "LockingText", "lockedRat", "LotedRect", "LashedRect", "LackedRegion", " LlockedRect", " mLockedArea", " mLockedRect", "LlockedText"], "hr": ["ij", "er", "rect", "lr", "mr", "eh", "r", "nr", "HR", "oh", "h", "hour", " hrs", "ha", "vr", "HK", "Dr", "rr", "arr", "rs", "bd", "JR", "hd", "tr", "proc", "fr", "ih", "ptr", "resh", "br", "here", "hz", "pr", "kr", "html", "rh", "hl", "hm", "her", "js", "dr", "roth", "drm", "gr", " HR", "req", "TR", "yr", "ths", "ah", "Mr", " dr", "timer", "DR", "ctr", "rd"], "i": ["n", "bi", "p", "t", "ic", "it", "si", "r", "di", "me", "index", "ai", " x", "xi", "o", "m", "ix", "y", "ims", " I", "us", "multi", "wi", "im", "zi", "x", " ii", "sim", "ind", "gi", "e", " ti", "I", "span", " di", "qi", "ki", "ti", "j", "ip", "cli", "ini", "asi", "batch", "PI", "li", "ui", " k", "gu", " bi", " ni", "in", "ci", " j", "g", "mi", "u", "ii", "pi", "hi", "l"], "err": ["resp", "er", "eas", "lr", "msg", "der", "txt", "rc", "mr", "sys", "usr", "r", "nr", "ger", "score", "aaa", "notice", "init", "fee", "gz", "ner", "order", "count", "arr", "rr", "ind", "rar", "str", "or", "test", "ec", "asm", "eor", "result", "buf", "fr", "ptr", "br", "cer", "pr", "kr", "Er", "res", "erer", "ir", "dev", "iter", "errors", "error", "Error", "req", "cr", "conf", "len", "elt", "timer", "ctr", "attr"], "nb_planes": ["n_plates", "nn_pages", "nbtplates", "nb_pins", "nxframes", "n_planes", "num_planes", "nbxpins", "nb_pages", "nb_ports", "nbxframes", "nn_planes", "nxports", "nxplates", "nbxplanes", "nn_plates", "nbxplates", "nbtpins", "nbxports", "nb_plates", "num_plates", "nbtpages", "num_pins", "n_ports", "num_pages", "nbxpages", "nbtplanes", "n_frames", "nxplanes", "nb_frames"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n", "idx": 21050, "substitutes": {"prog": [" progn", "Progs", " proj", "Progp", " proge", "procgp", "procj", "procgn", "Prog", " Prog", " Proc", "progn", " progs", " progp", "proG", "ProG", "Progn", "proc", "procg", "proj", " Proge", "procG", "proge", "Proge", " proG", "progp", "Proj", " proc", "Proc", " Progs", "procgs", "progs"], "po": ["cho", "p", "pot", "opa", "ppo", "hea", "mot", "ho", "o", "ato", "policy", "fo", "cro", "flo", "co", "por", "ps", "pt", "ket", "note", "ot", "whe", "cu", "oo", "PO", "ko", "pa", "Po", "ao", "mo", "ote", "elo", "bo", "apo", "pr", "aco", "pe", "odo", "ogo", "ta", "jo", "ico", "oe", "vo", "ppa", "pb", "wo", "mi", "obj", "pos", "O", "pd", "pi", "pty", "so", "ota"], "i": ["n", "bi", "p", "phi", "is", "t", "ic", "it", "iq", "si", "me", "di", "index", "iu", "ai", "xi", "f", "m", "go", "ix", "ims", "y", "us", "h", "init", "multi", "im", "zi", "ei", "ie", "x", " ii", "sim", "ind", "gi", " ti", "I", "c", "e", "qi", "ki", "ti", "j", "ini", "batch", "cli", "asi", "status", "li", "k", "ui", "fi", "gu", " bi", " ni", "oi", "in", "iter", "ci", " j", "g", "mi", "u", "ii", "pi", "hi", "v", "l", "chain", "yi"], "expert": ["despert", "exppert", "Expect", " exclusive", "yesfig", " exactly", "descellent", "inspert", "despect", "texfeat", "repert", "repect", "exvert", "yespert", "recellent", " exfeat", "Exfig", "yesvert", "expvert", "texactly", "excellent", "texpert", "Exvert", "insactly", "expcellent", "exfig", "expfig", "exclusive", "expect", "insfeat", "Existant", "Expert", "Excellent", "exactly", "insclusive", "desistant", "reistant", "yescellent", "exfeat", "existant", "texclusive"], "buf": ["cap", "rb", "txt", "out", "alloc", "cat", "cb", "window", "err", "length", "aka", "conv", " buffer", "Buff", "pkg", "needed", "mb", "uf", "bc", "Buffer", "cv", "str", "data", "row", "cp", "fb", "vec", "tr", "proc", "result", "img", "ctx", "uffy", "br", "bh", "xff", "queue", "tmp", "db", "buffer", "iter", "new", "mem", "buff", "block", "pool", "cmd", "emb", "pb", "np", "pg", "hold", "req", "pos", "vp", "font", "text"]}}
{"project": "FFmpeg", "commit_id": "b8a2331a70b720e83e1be243f7d17941c8952ef2", "target": 1, "func": "av_cold int ffv1_common_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    if (!avctx->width || !avctx->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    s->avctx = avctx;\n\n    s->flags = avctx->flags;\n\n\n\n    s->picture.f = avcodec_alloc_frame();\n\n    s->last_picture.f = av_frame_alloc();\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width  = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    // defaults\n\n    s->num_h_slices = 1;\n\n    s->num_v_slices = 1;\n\n\n\n    return 0;\n\n}", "idx": 21061, "substitutes": {"avctx": ["wavkt", " avcmd", "vancmd", "captx", "vancp", "averkl", "avertx", "avecmp", "avecfg", "abtx", "avcp", "avrt", "wavcfg", " avcmp", "afcontext", "avpy", "averrt", "afctx", "awctx", " avreq", "awctr", " avobj", "avercfg", "vctx", "vcp", "afpy", "avcmp", " avloc", "navctx", "avercontext", "averkt", "awreq", "abcp", "ajtx", "aversys", "navcu", "averctx", " avsys", "avercp", "awcmp", "averpy", "vanctx", "avercmp", "verkl", "capctx", "avcu", "capcmp", "afjac", "vertx", " avcontext", " avtx", "averjac", "afsys", "avercu", "avereq", "aftx", "afcfg", "abrt", " avcfg", " avkt", "avtx", "verobj", "wavcu", "capkl", "avetx", "avjac", "avkt", "avectr", "abctx", "aveloc", "ajjac", "avreq", "avobj", "vercontext", "avloc", "vrt", "wavctx", "navpkg", "navcfg", "avcontext", " avcu", "vcontext", " avpkg", " avctr", "avkl", "ajpy", "wavpkg", "vancontext", " avcp", "avsys", "vtx", "avpkg", "avcmd", "ajctx", "verctx", "avectx", "avcfg", "afloc", "vcmd", "vercmp", "afobj", "avctr"], "s": ["n", "comm", "ports", "p", "is", "sys", "os", "set", "parts", "ss", "ns", "ims", "y", "stats", "bs", "ps", "eps", "cs", "sts", "i", "rs", "fs", "gs", "aws", "c", "ds", "ass", "pers", "st", "se", "z", "spec", "ls", "details", "ms", "sv", "ats", "vs", "hs", "S", "js", "ess", "es", "its", "sq", "ts", "ins", "has", "als", "gets", "conf", "qs", "acs", "sb", "b", "as", "v", "sl"]}}
{"project": "FFmpeg", "commit_id": "c776531aef9b546ca576d4c8e3ec14a513394618", "target": 0, "func": "static int vqa_decode_chunk(VqaContext *s)\n\n{\n\n    unsigned int chunk_type;\n\n    unsigned int chunk_size;\n\n    int byte_skip;\n\n    unsigned int index = 0;\n\n    int i;\n\n    unsigned char r, g, b;\n\n    int index_shift;\n\n    int res;\n\n\n\n    int cbf0_chunk = -1;\n\n    int cbfz_chunk = -1;\n\n    int cbp0_chunk = -1;\n\n    int cbpz_chunk = -1;\n\n    int cpl0_chunk = -1;\n\n    int cplz_chunk = -1;\n\n    int vptz_chunk = -1;\n\n\n\n    int x, y;\n\n    int lines = 0;\n\n    int pixel_ptr;\n\n    int vector_index = 0;\n\n    int lobyte = 0;\n\n    int hibyte = 0;\n\n    int lobytes = 0;\n\n    int hibytes = s->decode_buffer_size / 2;\n\n\n\n    /* first, traverse through the frame and find the subchunks */\n\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n\n        index      = bytestream2_tell(&s->gb);\n\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case CBF0_TAG:\n\n            cbf0_chunk = index;\n\n            break;\n\n\n\n        case CBFZ_TAG:\n\n            cbfz_chunk = index;\n\n            break;\n\n\n\n        case CBP0_TAG:\n\n            cbp0_chunk = index;\n\n            break;\n\n\n\n        case CBPZ_TAG:\n\n            cbpz_chunk = index;\n\n            break;\n\n\n\n        case CPL0_TAG:\n\n            cpl0_chunk = index;\n\n            break;\n\n\n\n        case CPLZ_TAG:\n\n            cplz_chunk = index;\n\n            break;\n\n\n\n        case VPTZ_TAG:\n\n            vptz_chunk = index;\n\n            break;\n\n\n\n        default:\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: Found unknown chunk type: %c%c%c%c (%08X)\\n\",\n\n            (chunk_type >> 24) & 0xFF,\n\n            (chunk_type >> 16) & 0xFF,\n\n            (chunk_type >>  8) & 0xFF,\n\n            (chunk_type >>  0) & 0xFF,\n\n            chunk_type);\n\n            break;\n\n        }\n\n\n\n        byte_skip = chunk_size & 0x01;\n\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n\n    }\n\n\n\n    /* next, deal with the palette */\n\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CPL0 and CPLZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the palette chunk */\n\n    if (cplz_chunk != -1) {\n\n\n\n/* yet to be handled */\n\n\n\n    }\n\n\n\n    /* convert the RGB palette into the machine's endian format */\n\n    if (cpl0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the palette size */\n\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found a palette chunk with %d colors\\n\",\n\n                chunk_size / 3);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        for (i = 0; i < chunk_size / 3; i++) {\n\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n\n            r = bytestream2_get_byteu(&s->gb) * 4;\n\n            g = bytestream2_get_byteu(&s->gb) * 4;\n\n            b = bytestream2_get_byteu(&s->gb) * 4;\n\n            s->palette[i] = (r << 16) | (g << 8) | (b);\n\n        }\n\n    }\n\n\n\n    /* next, look for a full codebook */\n\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBF0 and CBFZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the full codebook chunk */\n\n    if (cbfz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if ((res = decode_format80(&s->gb, chunk_size, s->codebook,\n\n                                   s->codebook_size, 0)) < 0)\n\n            return res;\n\n    }\n\n\n\n    /* copy a full codebook */\n\n    if (cbf0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the full codebook size */\n\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: CBF0 chunk too large (0x%X bytes)\\n\",\n\n                chunk_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n\n    }\n\n\n\n    /* decode the frame */\n\n    if (vptz_chunk == -1) {\n\n\n\n        /* something is wrong if there is no VPTZ chunk */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: no VPTZ chunk found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n\n    chunk_size = bytestream2_get_be32(&s->gb);\n\n    if ((res = decode_format80(&s->gb, chunk_size,\n\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n\n        return res;\n\n\n\n    /* render the final PAL8 frame */\n\n    if (s->vector_height == 4)\n\n        index_shift = 4;\n\n    else\n\n        index_shift = 3;\n\n    for (y = 0; y < s->frame.linesize[0] * s->height;\n\n        y += s->frame.linesize[0] * s->vector_height) {\n\n\n\n        for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) {\n\n            pixel_ptr = x;\n\n\n\n            /* get the vector index, the method for which varies according to\n\n             * VQA file version */\n\n            switch (s->vqa_version) {\n\n\n\n            case 1:\n\n                lobyte = s->decode_buffer[lobytes * 2];\n\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                /* uniform color fill - a quick hack */\n\n                if (hibyte == 0xFF) {\n\n                    while (lines--) {\n\n                        s->frame.data[0][pixel_ptr + 0] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 1] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 2] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 3] = 255 - lobyte;\n\n                        pixel_ptr += s->frame.linesize[0];\n\n                    }\n\n                    lines=0;\n\n                }\n\n                break;\n\n\n\n            case 2:\n\n                lobyte = s->decode_buffer[lobytes];\n\n                hibyte = s->decode_buffer[hibytes];\n\n                vector_index = (hibyte << 8) | lobyte;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                break;\n\n\n\n            case 3:\n\n/* not implemented yet */\n\n                lines = 0;\n\n                break;\n\n            }\n\n\n\n            while (lines--) {\n\n                s->frame.data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n\n                pixel_ptr += s->frame.linesize[0];\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle partial codebook */\n\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBP0 and CBPZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (cbp0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n\n\n            /* time to replace codebook */\n\n            memcpy(s->codebook, s->next_codebook_buffer,\n\n                s->next_codebook_buffer_index);\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    if (cbpz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n            GetByteContext gb;\n\n\n\n            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n\n            /* decompress codebook */\n\n            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,\n\n                                       s->codebook, s->codebook_size, 0)) < 0)\n\n                return res;\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21070, "substitutes": {"s": ["n", "comm", "t", "p", "is", "sys", "state", "settings", "a", "sa", "os", "set", "source", "ss", "ns", "ses", "stats", "serv", "ps", "bs", "ops", "cs", "sts", "e", "aws", "gs", "rs", "fs", "c", "ds", "bis", "se", "status", "south", "spec", "ls", "details", "ex", "sam", "sv", "sw", "ats", "hs", "S", "js", "es", "ins", "sq", "ts", "sg", "conf", "qs", "an", "sb", "as", "v", "ains", "w"], "chunk_type": ["chunkTypestat", "chunk64typ", "chunktypetype", "chunks_Type", "chault_TYPE", "chdownload_size", "chault_Type", "chunkTypetype", "chunkLtype", "chocolTypeType", "chunkTyperole", "chunk_typ", "chunkOype", "chunk_role", "chunkLsize", "chdownloadLype", "chdownloadLsize", "chunktypeTYPE", "chunkOtype", "chunktypeType", "chocolTyperole", "chunktypetyp", "chdownload_ype", "chunks_size", "chunks_type", "chunk_prefix", "chunk_kind", "chacket_tag", "chocol_stat", "chunk_tag", "chocol_type", "chunkPtype", "chunkOtag", "chunk_key", "chault_type", "chunk64type", "chunks_class", "chunk_TYPE", "chunk_status", "chunkLtag", "chacket_prefix", "chdownloadLtype", "chunk_class", "chunkTypeType", "chocolTypetype", "chacket_status", "chom_type", "chunkPtyp", "chacket_type", "chdownload_tag", "chunkOsize", "chunk_stat", "chom_tag", "chunk64option", "chdownload_type", "chault_option", "chunk_Type", "chom_kind", "chunk_option", "chunk_ype", "chunkLype", "chocol_Type", "chom_key", "chocolTypestat", "chunkPoption", "chault_tag", "chunkPtag", "chault_typ", "chdownloadLtag", "chocol_role", "chunk64tag"], "chunk_size": ["chunk_length", "chacket_time", "chob_length", "chunk_offset", "chunk__time", "chob_len", "chunk__speed", "chunk64type", "chunk_time", "chob_Size", "chacket_length", "chunk_speed", "chacket_size", "chacket_speed", "chunk__type", "chacket_offset", "chunk__size", "chunk64size", "chacket_type", "chunk64speed", "chunk64time", "chunk_Size", "chunk_len", "chob_size"], "byte_skip": ["byteplaceoffset", "byte__offset", " byte_shift", "byte_shift", " byte_miss", "byte_offset", " byte_offset", "word_filter", "bytelexoffset", "word_offset", "byte_miss", "byte__shift", "word_skip", "byte_filter", "byteplaceshift", "word_shift", "byte__miss", "byte__skip", "bytelexskip", "bytelexfilter", "byteplaceskip", "bytelexshift", "byteplacefilter"], "i": ["bi", "n", "p", "t", "it", "si", "index", "f", "m", "id", "e", "info", "I", "c", "j", "ip", "z", "ci", "pos", "ii", "pi", "l", "v"], "r": ["name", "er", "p", "t", "re", "rb", "rc", "a", "f", "h", "m", "ar", "vr", "e", "str", "c", "R", "rx", "br", "cr", "l", "v", "w"], "g": ["n", "p", "tg", "f", "m", "h", "G", "gc", "d", "e", "gi", "c", "ge", "j", "ga", "k", "q", "bg", "gg", "u", "l", "v", "gp", "gh"], "b": ["bi", "p", "t", "eb", "a", "bf", "cb", "f", "m", "h", "B", "d", "bc", "c", "fb", "ab", "nb", "bg", "db", "be", "sb", "l", "v", "ba", "bb"], "index_shift": ["indexmodshift", "indexmodstart", "index_align", "row_start", "row_align", "row_size", "index_start", "indexmodsize", "row_shift", "indexmodalign", "index_size"], "res": ["ires", "final", "rev", "bits", "os", "err", "rows", "RES", "resolution", "results", "rs", "ries", "tx", "dim", "xy", "base", "ress", "result", "lock", "version", "raw", "ex", "Res", "vals", "mem", "error", "req"], "x": ["p", "t", "dx", "o", "index", "pixel", "m", "ix", "ox", "tx", "c", "xy", "rx", "X", "ex", "px", "xs", "pos", "l", "v", "point", "lat", "w"], "y": ["p", "yy", "t", "py", "o", "index", "m", "key", "ey", "iy", "ny", "my", "vy", "c", "xy", "j", "col", "z", "sy", "sky", "Y", "ies", "ch", "ym", "v"], "pixel_ptr": ["image_ptr", "image_offset", "pixel_offset", "pixel_set", "pixel_pointer", "image_pointer", "image_set"], "lobytes": ["locyches", "loytes", "lobyches", "ellobyts", "lobyts", "lotches", "elloyches", "ellobytes", "elloyte", "lottes", "loyts", "ellobyches", "loyches", "locytes", "elloyts", "lotte", "locyte", "elloytes", "ellobyte", "locyts", "loyte", "lotts", "lobyte"], "hibytes": ["hibbytes", "hibycks", "hibbyces", "labyces", "hibuytes", "hibobyte", "labobyces", "hibobytes", "hibbycks", "labytes", "hibobyces", "hibuyces", "labyte", "labobyte", "hibyte", "labobytes", "hibyces", "labycks", "hibuyte", "hibuycks", "hibobycks", "hibbyte", "labobycks"], "lines": ["boxes", "links", "heads", "os", "bands", "ns", "pages", "ines", "keys", "cells", "bytes", "faces", "planes", "elines", "points", "ls", "sets", "vals", "levels", "pins", "verts", "ln", "steps", "blocks", "codes", "line", "limits", "errors", "les"], "gb": ["gt", "gif", "rb", "gpu", "bf", "cb", "jpg", "hub", "gm", "gc", "gz", "gd", "mb", "rg", "uf", "eg", "vg", "gs", "args", "fb", "ge", "nb", "gom", "img", "deg", "ground", "bg", "html", "db", "storage", "gg", "kb", "Gb", " GB", "sb", "GB", "gh", "gp", "gov", "got", "cfg", "bb"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_mmio_map(PCIDevice *d, int region_num,\n\n                              pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    int mmio_io_addr;\n\n\n\n    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,\n\n                                                 DEVICE_NATIVE_ENDIAN);\n\n\n\n    cpu_register_physical_memory(addr, size, mmio_io_addr);\n\n}\n", "idx": 21092, "substitutes": {"d": ["p", "t", "dh", "dm", "dx", "D", "r", "dd", "di", "did", "f", "dc", "h", "m", "sd", "e", "dt", "c", "ds", "s", "db", "de", "g", "fd", "pd", "v", "da", "w"], "region_num": ["region_number", " region_number", " region_Num", "region_no", "region_Num", " region_no"], "addr": ["dh", "start", "alloc", "index", "ref", "arity", "offset", "add", "order", "src", "ash", "url", "loc", "arr", "id", "eth", "rs", "data", "var", "oa", "handle", "coord", "hw", "ord", "mt", "ptr", "res", "map", "Address", "adr", "mem", "ad", "location", "dr", "fd", "address", "cmd", "pos", "nl", "store", "mod", "port", "pad", "attr"], "size": ["name", "izes", "start", "amount", "set", "kind", "sum", "SIZE", "length", "offset", "scale", "fee", "format", "count", "description", "id", "code", "empty", "args", "data", "max", "bytes", "body", "mode", "ize", "iz", "storage", "fat", " sizes", "shape", "area", "mem", "Size", "range", "address", "len", "store", "small", " format"], "type": ["name", "ype", "t", "state", "time", "p", "Type", "tag", "kind", "offset", "TYPE", "count", "style", "id", "dt", "weight", "info", "mode", "pe", "speed", "types", "unit", "shape", "error", "typ", "address"], "mmio_io_addr": ["mmio_io_address", "mmio_io_id", "mmio_i_add", "mmio_io__addr", "mmio_io___addr", "mmio_io__address", "mmio_io_add", "mmio_io___address", "mmio_i_address", "mmio_i_ptr", "mmio_io_ad", "mmio_io_ptr", "mmio_io__id", "mmio_io___ad", "mmio_i_addr", "mmio_i_id", "mmio_i_ad"]}}
{"project": "qemu", "commit_id": "ac4b0d0c4feb291643c0e8a07a92e449e13881b5", "target": 0, "func": "static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t/* NOP */\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  */\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        /* TODO: */\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            /* No length check */;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        /* Filters are not implemented */\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            /* TODO: ordering? */\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        /* TODO */\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        /* TODO: check that the remaining bits are all 0 */\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command */\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command */\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n", "idx": 21100, "substitutes": {"info": ["name", "history", "Info", "is", "basic", "it", "frame", "one", "kind", "index", "os", "force", "stat", "INFO", "f", "check", "nr", "fo", "init", "by", "about", "id", "def", "bit", "good", " inf", "status", "now", "fi", "report", "help", "try", "error", "conf", "information", "json", "work", "success", "inf"], "data": ["all", "msg", "message", "value", "rel", "none", "xy", "batch", "no", "res", "Data", "pos", "next", "pointer", "n", "name", "done", "start", "a", "list", "bus", "x", "join", "size", "bytes", "values", "dat", "dev", "new", "bin", "w", "t", "time", "it", "hash", "aw", "table", "d", "def", "mu", "str", "limit", "buf", "extra", "raw", "buffer", "trans", "cache", "len", "to", "l", "p", "out", "end", "bits", "window", "offset", "read", "ata", "val", "DATA", "addr", "block", " DATA", "input", "pad", "text"], "length": ["duration", "loop", "t", "p", "vector", " Length", "available", " clen", "message", "phi", "L", "end", "capacity", "number", "stop", "amount", "H", "f", "h", " l", "value", "count", "ength", "total", "time", "max", "size", "idth", "expected", "height", "ptr", "full", "position", "padding", "maximum", "buffer", "ow", " len", "shape", "component", "sp", "term", "ty", "address", "of", "be", "len", "form", "w", " lengths", "ENGTH", "l", "Length", "angle", "type"], "hci": ["phnic", "lmi", "ohcit", "hmi", "hmci", "httpnic", "ohce", "hli", "hki", "Hcci", "hnic", "ohcu", "ohdi", "thcci", "lci", "hmco", "wli", "mci", "thci", "ahco", "ohco", " hco", "rmi", "thcu", "hcit", "lco", "mcci", "ohci", "phcu", " hcci", "rci", " hki", "thki", "thpi", "mco", "rco", "hmcu", "httpuci", "thuci", "ahcgi", "httpcu", "hco", "phuci", "wcci", "wci", "huci", "hcci", "Hci", "ohcgi", "thco", "hce", "ohki", "hcgi", " hcgi", "phci", "lcci", "Hcgi", "rcci", " hcit", "httpci", "mcu", " hmi", "hcu", "Hcu", "hpi", "Hpi", " hli", "ahci", "ohcci", "thnic", " hdi", "ahce", "Hco", " hpi", "hmcit", " hcu", "wdi", "ohli", "hdi", " hce"], "cmd": ["comm", "name", "gt", "mk", "resp", "msg", "txt", "rn", "quit", "det", "param", "cont", "kind", "cb", "cat", "Cmd", "tp", "qt", "rol", "init", "act", "ct", "pkg", "call", "arg", "id", "ext", "def", " command", "cd", "conn", "ind", "code", "md", "handle", "cmp", "cli", "cur", "batch", "MD", "buf", "op", "cod", "prop", "raw", "ctx", "mode", "bind", "tmp", "grad", "auth", "opt", "addr", "help", "ch", "mem", "nt", "term", "command", "path", "prefix", "req", "rpm", "obj", "Command", "handler", "cp", "cfg", "ctr", "attr", "text"], "paramlen": ["memberlen", "inputLen", "parcount", "aramlan", "paramcount", "parlength", "Paramlen", "inputcount", "paramlength", "memcount", "aramlen", "aramlength", "paramcoll", "keycoll", "aramcoll", "memlen", "parLen", "memberlan", "paramLen", "aramLen", "keylan", "keylen", "ParamLen", "inputlength", "memberlength", "parlen", "paramlan", "memlength", "memLen", "Paramlength", "keylength", "inputlen", "membercoll"], "i": ["n", "p", "t", "it", "a", "di", "index", "ai", "f", "h", "m", "init", "ati", "im", "x", "id", "ind", "I", "dim", "j", "ip", "in", "ci", "mi", "iat", "ii", "pi"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n", "idx": 21102, "substitutes": {"fs": ["sys", "is", "ics", "bf", "f", "ys", "ns", "ims", "ss", "eks", "bs", "ps", "cs", "irs", "aws", "fw", "rs", "ds", "s", "xml", "FS", "files", "ls", "ms", "fi", "vs", "hs", "cf", "js", "xs", "es", "ts", "fd", "linux", "fps", "grid", "fc"], "id": ["name", "hid", "is", "tag", "iq", "oid", "ids", "kind", "ide", "index", "ref", "desc", "f", "h", "vid", "aid", "ID", "mid", "init", "wid", "d", "key", "i", "cd", "info", "md", "ip", "pid", "status", "ih", "ms", "ida", "rid", "addr", "Id", "ad", "ick", "fd", "path", " tid", "sid", "kid", "ident", "uid", "bid", "type"], "isc": ["ISC", "pic", "isa", "is", "ic", "rc", "sys", "alloc", "usc", "ics", "stat", "sec", "ich", "dc", "isf", "isch", "isco", "sk", "disc", "gc", "stats", "iss", "tech", "irc", "bs", "secure", "ib", "isk", "cs", "eth", "ec", "iw", "cycles", "status", "iris", "ih", "icons", "wic", "nic", "sc", "inc", "ico", "pc", "misc", "soc", "mic", "isp", "cc", "fc", "ish", "icon", "oc"], "swap": ["maskap", "ship", " swape", "wash", "swop", "snarp", "wape", "snift", "snrap", "swip", "twift", "maskrap", "twap", "shap", "wap", "wapped", "swash", "snap", "wrap", "swape", "shift", "reshap", "reshape", "twop", "snash", " swapped", "maskash", "swarp", "snip", "maskarp", "swrap", "swift", "twip", "swapped", "reshapped", "shop", "reshrap", "snop", "warp", " swrap"], "is_maskable": ["is_allow_", "is_ask_", "is_cleanable", "is_locked", "is_askworthy", "is_lockable", "is_maskability", "is_masked", "is_Maskable", "is_Masked", "is_cleanworthy", "is_askable", "is_Maskability", "is_masker", "is_mask_", "is_lock_", "is_askability", "is_locker", "is_cleaned", "is_asked", "is_allowable", "is_asker", "is_allower", "is_maskworthy", "is_cleanability", "is_Maskworthy", "is_allowed"], "flic": ["folin", "kLic", "fnic", "klic", "vlig", "klig", " fic", "vnic", "vlic", "vlict", " folin", "llic", "fic", "fLic", "flict", "lic", "vic", " fLic", " fnic", "lolin", "flig", " flict", "volin", " flig", "lnic", "vLic", "klict"], "r": ["n", "er", "t", "p", "re", "out", "ror", "rc", "it", "mr", "rb", "usr", "ru", "nr", "f", "m", "h", "err", "ar", "d", "vr", "rg", "x", "rr", "ter", "e", "i", "rar", "rs", "or", "c", "R", "tr", "sr", "rw", "k", "rt", "q", "g", "cr", "u", "ry", "b", "l", "v", "rd", "w"], "ret": ["gt", " Ret", "t", "re", "out", "rc", "usr", "rev", "xt", "set", "ref", "f", "rets", "rem", "err", "Ret", "rel", "gc", "ar", "val", "mb", "arr", "rr", "nz", "dt", "rs", "reset", "st", "jp", "tr", "j", "result", "sr", "mt", "ft", "rt", "q", "res", "alt", "rm", "dr", "new", "error", "nt", "RET", "att", "flag", "attr", "rd"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                int lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                int lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_ff1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_fl1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 21106, "substitutes": {"dc": ["td", "DC", "dm", "rc", "di", " DC", "dt", "bc", "cd", "dl", "ec", "df", "icc", "dat", "dp", "lc", "cm", "sc", "ci", "mc", "pc", "tc", "nc", "cc", "fc", "da", "xc", "oc"], "insn": ["itssn", "pinspan", "linsn", "kspan", "csn", " inssn", "risnin", "attsnw", "ssgn", "attsnz", "linsl", "ssns", "inl", "ksnr", "insnr", "ksn", "psgn", "ksnw", "pinssn", "imsnr", "csns", "itsns", "insnw", "intssn", "vsn", "risnr", "insl", "kssn", "csgn", "insgn", "vsgn", "INSn", "inssn", "attsn", "tsn", "intsn", "vspan", "linsnw", "insnin", "pssn", "pinsgn", "vssn", "inn", "intsnz", "tsns", "itsn", "pinsn", "insc", "insnz", "tsc", "tsgn", "imsn", "itsl", "risn", " insnw", "INSnr", " insnz", "insname", "INSgn", "imsnin", "linsnr", "pinsnr", "linsgn", "linsns", "ksname", "linssn", "ssn", "psn", "INSname", "rissn", "attssn", "insns", "ksgn", "INSnin", "inns", "pinsnw", "inspan", "intsnw", "psname", "imssn", "ssc", "csc", "INSsn"], "op0": ["ip0", "hop1", "p0", "OP2", "OP1", "opt00", "OP5", "hop2", "OP0", "hop5", "p1", "OP00", "opt0", "op00", "op5", "hop0", "ip2", " op00", "p2", "opt2", "p5", "ip1", "opt1"], "op1": ["oper01", "op3", "op01", "OP2", "Op01", "OP1", " op8", "oper2", "oper3", "OP5", "OP0", "op8", "Op3", "Op4", "op5", " op01", " op4", "oper5", "Op0", "oper1", "OP3", "Op5", "oper8", "OP4", "Op2", "OP8", "op4", "OP01", "Op1"], "op2": ["op3", "ip5", "OP2", " op3", "OP1", "OP5", "op6", " op5", "p1", " op6", "opt6", "op5", "OP6", "ip2", "ip3", "p2", "opt2", "opt5", "p5", "p3", "ip1", "opt1"], "ra": ["ras", "rc", "a", "sa", "ri", "r", "ru", "red", "rise", "raf", "rom", "tar", "cro", "ar", "ata", "loc", "po", "ro", "rar", "rs", "rum", "RA", "rx", "aria", "la", "ran", "ring", "stra", "gra", "sr", "dra", "Ra", "ina", "res", "rain", "tra", "ur", "rf", "ta", "area", "rap", "ara", "au", "from", "era", "ora", "ma", "da", "ba"], "rb": ["rub", "rab", "lr", "rc", "mr", "r", "ru", "cb", "nr", "raf", "rob", "gb", "ob", "reb", "vr", "erb", "rr", "rg", "lb", "ro", "rar", "rs", "fb", "zb", "nb", "ab", "hr", "rw", "sr", "rt", "wb", "db", "rf", "rid", "RB", "rl", "pb", "rib", "sb", "b", "bb"], "rd": ["td", "lr", "rc", "rn", "mr", "ri", "nder", "r", "ru", "red", "ird", "dd", "raf", "rob", "d", "rr", "rg", "ro", "ld", "RD", "rar", "rs", "cd", "bd", "rx", "hr", "fr", "rw", "nd", "dra", "sr", "rt", "pr", "rh", "rf", "rid", "dr", "rm", "rat", "fd", "rl", "cr"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n", "idx": 21110, "substitutes": {"timer_list": ["timermyout", " timer_def", "timer2spec", "imer2list", "timermyarray", " timer_array", " timermatarray", " timermatlist", "timermatlist", "imer_lists", "timer_spec", "imer2lists", "timer2list", "timer_out", "imer2listed", "timer_listed", "timermatarray", "timermatout", "timer_array", "imer_spec", "imer_listed", " timer_out", "timer_def", "timer2listed", "imer_list", " timermatout", "timermatdef", "timermylist", "timer_lists", " timermatdef", "timermydef", "timer2lists", "imer2spec"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n", "idx": 21118, "substitutes": {"src": ["fx", "sys", "view", "rc", "usc", "txt", "usr", "stock", "source", "sec", "look", "gb", "image", "secure", "dest", "filename", "loc", "ind", "rs", "st", "s", "cur", "ipl", "img", "sr", "sh", "ur", "sc", "in", "ins", "screen", "sub", "rl", "our", "input", "inst", "sb", "sur", "ser", "supp", "sl"], "dst": [" dct", "jct", " dsts", "dssts", "dsct", " dnd", "jset", "dsnd", "jnd", "jst", "Dst", "dnd", " dset", "dct", "Dset", "dset", "dsdest", "Dsts", " ddest", "Ddest", "dsst", "ddest", "dsset", "dsts"], "num_pixels": ["num_spixels", "num_pims", "num_nponents", "num_pidairs", "num_picks", "num_ponents", "num_Picks", "num_npairs", "num_Pims", "num_Ponents", "num_sponents", "num_spairs", "num_spicks", "num_Pixels", "num_pidims", "num_npicks", "num_paixels", "num_pairs", "num_pubs", "num_paubs", "num_pidubs", "num_paairs", "num_paims", "num_npixels", "num_Pubs", "num_pidixels", "num_Pairs"], "palette": ["palettes", "Palet", " palet", " pallete", "palet", "Palettes", "Palette", "facue", " palettes", "pallete", "calettes", "palte", "stalettes", "facette", "facet", " palte", "palue", "callete", "calette", "calte", " palue", "Palue", "stallete", "stalte", "stalette", "facettes"], "i": ["is", "ic", "m", "ims", "im", " index", "span", "I", "jp", "ti", "cli", "asi", "ex", "ui", " bi", "v", " err", "uri", "chain", "uli", "\u0438", " si", "si", "me", "o", "ai", "ix", "ji", " m", "x", " ii", "sim", "ind", "gi", " ti", "my", " di", " it", " ni", "oi", "g", " j", " pi", "uu", "bi", "phi", " Xi", "it", "ri", "xi", "f", "multi", "zi", "ei", "qi", "ini", "ip", "z", "li", "in", "ci", " key", "mi", "ii", " mi", "pi", "l", " ki", "ij", " li", "di", "iu", "init", " iter", "ki", "j", "ms", "gu", " wi", " info", " multi"]}}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n", "idx": 21135, "substitutes": {"obj": ["ok", "comm", "resp", "any", "txt", "org", "alloc", "o", "ref", "go", "object", "ob", "act", "pkg", "ot", "conn", "onet", "xy", "cmp", "j", "hw", "cod", "bo", "ctx", "oj", "bh", "tmp", "obo", "Object", "js", "Obj", "nt", "obs", "objects", "typ", "cmd", "bj", "attr", "oc"], "ioc": ["adiocate", "liocation", "biocy", "uiocate", "adioint", "piroc", "iniocate", "piot", "diocate", "ioci", "xioc", " iocation", "gioco", "zioc", "adiroc", "dioko", " iot", "gioc", "biroc", "uiocated", "iot", "tioco", "liroc", "gioci", "adioko", "iroc", "ioca", "adioc", "giocy", "tiroc", "bioc", "gioint", "ioco", "iocation", "piocy", "cioco", "tiOC", "liot", " ioci", "iniocated", "tioci", " iocy", "iocy", "iocon", "ciOC", "giroc", "tiocy", "iocate", "dioint", "pioc", "tioc", "ioko", "diroc", "ciroc", "adioco", "dioco", " iocon", "biocon", "dioca", "uiroc", "zioca", "xiocation", "ioint", "iocated", "xiroc", "lioc", "lioci", "tiocate", "uioc", "cioc", "giocon", "tiocated", "liocon", " ioco", "adioca", "dioc", "inioc", " iOC", "zioko", "piocon", "iOC", "xioci", "dioci", "iniroc", " iroc", "xioco", "tiocon", "ziocate"]}}
{"project": "FFmpeg", "commit_id": "028cc42a1638e6f93a857f11c2568d1c3a51e612", "target": 1, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n\n    if (!strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data+5) == 2) {\n\n        uint8_t desc[256];\n\n        int score = AVPROBE_SCORE_MAX / 2, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 21155, "substitutes": {"st": ["ste", "t", "state", "ost", "start", "kt", "stop", "et", "set", "stat", "sta", "act", "th", "src", " est", "pt", "stream", "sts", "St", "str", "s", "se", "nd", "mt", "ust", "sn", "stan", "ft", "sth", "rt", "sv", "est", "sh", "sw", "storage", "sc", "stable", "at", "stage", "rest", "ad", "sp", "spect", "std", "irst", "ist", "nt", "store", "inst", "sb", "cast", "ST", "ut", "art"], "pkt": ["mdu", "ppkt", "pdu", "Packet", "pront", "prokt", "macket", "paykt", "pwk", "Pkt", "ckt", "prowd", "cacket", " pnt", " pkg", " pdu", "Pkg", "pkg", "wwk", " pwk", "payacket", "payett", "ppacket", "cwd", "wnt", "paynt", "packet", "ppnt", "cpett", "mkt", "wkg", "Pett", "pett", "cpkt", "cnt", "Pnt", "ppwk", "proacket", " pwd", "wkt", "mnt", "cpnt", "cpacket", "Pdu", "Pwk", " packet", "pnt", "pwd"], "desc": ["name", "asc", "data", "Desc", "msg", "out", "txt", "DES", "comment", "cont", "sec", "dc", "summary", "err", "bl", "disc", "dir", "annot", "description", "label", "def", "ext", "id", "cd", "str", "uc", " Desc", "meta", "des", "ds", "esc", "vec", "cmp", "dl", "ript", "md", "buf", "osc", "dict", "ptr", "seq", "sc", "mem", "doc", "sort", "sub", "obj", "ribe", "rec", "metadata", "bd", "attr", "text"], "ret": ["gt", " Ret", "resp", "t", "re", "txt", "it", "rev", "r", "xt", "sec", "ref", "rets", "rem", "err", "progress", "Ret", "gc", "val", "arr", "uf", "test", "des", "get", "lt", "jp", "j", "status", "result", "buf", "deg", "ptr", "ft", "rt", "tmp", "num", "res", "alt", "reg", "mem", "dr", "nt", "RET", "nl", "len", "ll", "elt", "success"], "ast": ["ed", "master", "old", "Ast", "ard", "ost", "AST", "tt", "must", "am", "a", "bart", "any", "list", "walk", "ref", "aid", "add", "mast", "sta", "ac", "aw", "act", "esta", "asted", "embed", "test", "past", "aster", "hd", "asm", "ab", "ait", "ann", "mt", "nd", "ust", "asts", "quest", "est", "asting", "addr", "ess", "at", "aft", "rest", "and", "bound", "ad", "nt", "ist", "std", "irst", "amd", "ace", "wat", "acl", "store", "af", "ah", "each", "pat", "cast", "as", "dist", "att", "art", "instance"], "sub_demuxer": ["sub_demuploader", "sub_democers", "sub_deuxed", "sub_demUXor", "sub_demUXers", "sub_demuxier", "sub_demixer", "sub_promuxe", "sub_Demuxe", "sub_demixor", "sub_promuxer", "sub_demixers", "sub_deluxed", "sub_promxer", "sub_demue", "sub_deuxer", "sub_demuer", "sub_demluxer", "sub_Democers", "sub_demluxor", "sub_Demuxer", "sub_promuxier", "sub_demUXer", "sub_deluxer", "sub_demuxers", "sub_demuxe", "sub_demuxor", "sub_demuploadier", "sub_demuploaders", "sub_democer", "sub_Democer", "sub_promxe", "sub_demUXed", "sub_Democe", "sub_demuier", "sub_demuxed", "sub_Democier", "sub_demixe", "sub_promuxers", "sub_demuploade", "sub_demxe", "sub_Demuxers", "sub_demixier", "sub_demluxers", "sub_deuxor", "sub_deluxor", "sub_promxers", "sub_demxers", "sub_demuers", "sub_promxier", "sub_demixed", "sub_democier", "sub_demluxed", "sub_demxer", "sub_demxier", "sub_deuxers", "sub_democe", "sub_deluxers", "sub_Demuxier"], "time_base": [" time_bas", "time_ase", "duration_based", "durationtimease", " time2bas", "time2base", "Time_base", "durationtimebased", "time2bas", " time_Base", "time2Base", " time_bal", " time2Base", "durationtimebase", "time_based", "Time_Base", "timexBase", "Time_bas", "timetimease", "time_Base", "time_bas", "timetimebased", "Time_only", "duration_base", " time2base", "time_only", "timetimebase", "duration_ase", "time_bal", "timexbal", "timexbase"], "pb": ["td", "p", "rb", "vp", "eb", "py", "tg", "cb", "BP", "pm", "tp", "gb", "ob", "gc", "pkg", "bs", "pt", "pp", "lp", "uf", "mp", "wp", "bc", "ib", "pl", "tap", "cv", "tx", "tk", "tab", "pa", "PB", "fb", "jp", "proc", "nb", "ap", "ab", "fp", "buf", "mb", "ctx", "ub", "tmp", "dp", "buffer", "px", "patch", "stab", "kb", "sp", "erb", "pc", "np", "pg", "tc", "emb", "pool", "lb", "sb", "bp", "bj", "cp", "tf", "bb"], "pd": ["td", "p", "vd", "dh", " ad", "vp", " dc", "PD", " sd", "dd", "pard", "dq", "pm", "tp", "sd", " prod", " db", "d", "ps", "po", " np", "dt", " pdf", "cd", "bd", " td", "ds", "md", "dl", " dw", "hd", " cd", " dd", "dict", " md", "edd", "df", "pr", " std", "dp", " od", "ud", "fd", " PD", " df", "np", "pc", "std", "sb", " ep", "pi", "ctl", "pat", "dj", "cp", "xd"]}}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)\n\n{\n\n    int ret;\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    if (o_out)\n\n        *o_out = o;\n\n    if (!o)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n    if (!val || o->offset<=0)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (o->type == FF_OPT_TYPE_BINARY) {\n\n        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);\n\n        int *lendst = (int *)(dst + 1);\n\n        uint8_t *bin, *ptr;\n\n        int len = strlen(val);\n\n        av_freep(dst);\n\n        *lendst = 0;\n\n        if (len & 1) return AVERROR(EINVAL);\n\n        len /= 2;\n\n        ptr = bin = av_malloc(len);\n\n        while (*val) {\n\n            int a = hexchar2int(*val++);\n\n            int b = hexchar2int(*val++);\n\n            if (a < 0 || b < 0) {\n\n                av_free(bin);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            *ptr++ = (a << 4) | b;\n\n        }\n\n        *dst = bin;\n\n        *lendst = len;\n\n        return 0;\n\n    }\n\n    if (o->type != FF_OPT_TYPE_STRING) {\n\n        int notfirst=0;\n\n        for (;;) {\n\n            int i;\n\n            char buf[256];\n\n            int cmd=0;\n\n            double d;\n\n\n\n            if (*val == '+' || *val == '-')\n\n                cmd= *(val++);\n\n\n\n            for (i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++)\n\n                buf[i]= val[i];\n\n            buf[i]=0;\n\n\n\n            {\n\n                const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n\n                if (o_named && o_named->type == FF_OPT_TYPE_CONST)\n\n                    d= o_named->default_val.dbl;\n\n                else if (!strcmp(buf, \"default\")) d= o->default_val.dbl;\n\n                else if (!strcmp(buf, \"max\"    )) d= o->max;\n\n                else if (!strcmp(buf, \"min\"    )) d= o->min;\n\n                else if (!strcmp(buf, \"none\"   )) d= 0;\n\n                else if (!strcmp(buf, \"all\"    )) d= ~0;\n\n                else {\n\n                    int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n\n                    if (res < 0) {\n\n                        av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val);\n\n                        return res;\n\n                    }\n\n                }\n\n            }\n\n            if (o->type == FF_OPT_TYPE_FLAGS) {\n\n                if      (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;\n\n                else if (cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;\n\n            } else {\n\n                if      (cmd=='+') d= notfirst*av_get_double(obj, name, NULL) + d;\n\n                else if (cmd=='-') d= notfirst*av_get_double(obj, name, NULL) - d;\n\n            }\n\n\n\n            if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n\n                return ret;\n\n            val+= i;\n\n            if (!*val)\n\n                return 0;\n\n            notfirst=1;\n\n        }\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (alloc) {\n\n        av_free(*(void**)(((uint8_t*)obj) + o->offset));\n\n        val= av_strdup(val);\n\n    }\n\n\n\n    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));\n\n    return 0;\n\n}\n", "idx": 21166, "substitutes": {"obj": ["expr", "n", "t", "rect", "sys", "out", "txt", "oid", "et", "os", "this", "vol", "ref", "off", "ns", "window", "object", "ob", "act", "src", "ot", "ind", "onet", "str", "xy", "cur", "j", "hw", "bo", "ctx", "bh", "rt", "tmp", "self", "addr", "js", "Obj", "nt", "ist", "obs", "buff", "np", "objects", "typ", "pos", "inst", "bj", "attr"], "name": ["n", "NAME", "ref", "alias", "nam", "key", "id", "label", "ame", "str", "info", "data", "c", "var", "no", "named", "san", "nm", "word", "spec", "names", "Name", "num", "mem", "path", "prefix", "term", "cmd", "w", "v", "local", "attr", "type"], "val": ["cho", "all", "msg", "vol", "value", "rel", "rol", "eval", "pt", "loc", "pos", "elt", "ser", "v", "sel", "stat", "aval", "bl", "x", "data", "Val", "vec", "pol", "pr", "dev", "gl", "mem", "cmd", "cal", "b", "vc", "tag", "it", "ref", "exec", "call", "arg", "def", "str", "tx", "var", "ctx", "buffer", "buff", "len", "el", "vp", "attr", "serv", "vt", "valid", "p", "txt", "ival", "ver", "index", "al", "key", "arr", "test", "prop", "grad", "cond", "VAL", "vals", "reg", "doc", "rec", "lib"], "alloc": ["ok", "all", "rc", "vol", "ack", "ref", "offset", "ac", "init", "count", "loc", "call", "empty", "var", "coord", "addr", "mem", "buff", "req", "pool", "pos", "attr", "oc"], "o_out": ["oPcheck", "oixfound", "oo_out", "oPfound", " o_no", "o__no", "o__in", " o_opt", " o_msg", "oixcheck", "oo_check", "o_OUT", "o__opt", "o_no", "o_in", "oo_found", "o_msg", "oixout", " o_in", "o__out", " o_OUT", "o_found", "o_opt", "o_check", "oPout"], "ret": ["resp", "re", " RET", "out", "lit", "cat", "set", "ref", "Return", "rem", "Ret", "count", "def", "il", "data", "res", "alt", "mem", "nt", "RET", "len", "ll", "elt", "flag"], "o": ["n", "ok", "er", "t", "p", "out", "yo", "a", "oid", "os", "ion", "one", "et", "io", "f", "off", "m", "om", "go", "y", "h", "object", "co", "fo", "ob", "original", "image", "none", "ot", "po", "e", "onet", "or", "oo", "c", "s", "oa", "lo", "no", "op", "bo", "other", "owner", "oi", "ow", "g", "oe", "O", "u", "oc", "iso", "an", "oin", "l", "v", "so", "w"], "dst": ["dedst", "Dust", "dth", "nint", "dbists", "dists", "lrest", "dbust", "nst", "dint", "dedfr", "nrest", "disst", "Dsp", "dfr", "dpr", "sdst", " dpr", "lST", "dbsp", "disust", "idpr", " dend", "ldth", "idst", "sdfr", "ldst", "nST", "lst", "drest", " dfr", "ldpr", "dend", "dust", "dsp", " dint", " dST", "idth", "dissp", "dST", "dedend", "lint", "dbst", "sdend", "Dst", " dth", " dset", " drest", "Dists", "dset", "sdST", "ldset", "dedST", "disists", "idset"], "lendst": ["lenderst", "lendno", "lendedSt", "lentno", "lenderno", "lendbl", "lENDno", "lrendsw", "lendedst", "lendsno", "glenderno", "lendest", "llendST", " lendSt", "lentst", "lrendst", "glendno", "glenderest", " lendedst", " lendedsw", "llendst", "lendsest", "lENDbl", "lENDst", "glendersw", "lendSt", "lendersw", "lenderest", "lENDST", "llENDST", "llENDno", "lendST", " lendedSt", "laddST", "lenderST", "llENDst", " lendsw", "lentsw", "lrendSt", "lendssw", "laddno", "lendsst", "lentest", "glenderst", "lenderbl", "laddst", "glendest", "laddbl", "llendno", "glendsw", "llENDbl", "glendst", "llendbl", "lendsw", "lendedsw"], "bin": ["bi", "n", "binary", "back", "obin", "bed", "sum", "hash", "bl", "bat", "pac", "win", "init", "src", "bool", "bc", "str", "bn", "bit", "vec", "byte", "batch", "base", "fr", "pipe", "big", "gin", "tmp", "bg", "db", "buffer", "box", "in", "mem", "reg", "pin", "inner", "buff", "cmd", "cache", "pos", "len", "bu", "slice", "b", "lib"], "ptr": ["p", "end", "index", "Ptr", "ref", "ix", "offset", "bl", "src", "pt", "loc", "arr", "dest", "ind", "var", "vec", "tr", "ctx", "br", "pr", "db", "buffer", "addr", "dr", "mem", "sp", "buff", "pc", "address", "cmd", "pos", "len", "next", "pointer", "inst", "port", "pad", "pat", "pi", "pointers", "ctr"], "i": ["bi", "n", "phi", "p", "t", "is", "\u0438", "ic", "it", "a", "si", "index", "di", "iu", "io", "ai", "f", "xi", "m", "ix", "h", "y", "init", "multi", "ji", "im", "zi", "key", "ei", "x", "id", "sim", "gi", "I", "c", "ami", "s", "qi", "ti", "j", "ini", "ip", "cli", "mac", "PI", "li", "me", "ui", "oi", "iter", "ci", "g", "mi", "u", "ii", "pi", "l", "v", "hi", "b"], "buf": ["kw", "rb", "cap", "txt", "cb", "ref", "off", "window", "err", "length", "bl", " buffer", "Buff", "pkg", "bs", "arr", "loc", " cmd", "uf", "def", "filename", "bc", "Buffer", "str", "cv", "data", "var", "bytes", "vec", "md", "proc", "ab", " buff", "img", "ctx", "br", "names", "tmp", "queue", "wb", "seq", "db", "buffer", " vec", "box", "iter", "mem", "buff", "block", "cmd", "pos", "ctr"], "d": ["n", "done", " D", "p", "dh", "it", "D", "del", "f", "x", "def", "e", "ind", "cd", "c", "ds", "md", " dw", "j", "dev", "de", "new", "ad", "g", "wd", "fd", "v", "w"], "o_named": ["o_specified", "o_sn", "onet_sn", "O_name", "O_amed", "onet_name", "oktsn", "O_named", "onet_specified", "o_amed", "o_name", " o_identified", "onet_named", " o_name", " o_amed", "o_nm", "oktnamed", "O_nm", "o_identified", "oktname", "oktspecified"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,\n\n                                    int alpha, int beta, int8_t *tc)\n\n{\n\n    uint8_t bs0 = 1;\n\n    uint8_t bs1 = 1;\n\n    uint8_t bs2 = 1;\n\n    uint8_t bs3 = 1;\n\n\n\n    if (tc[0] < 0)\n\n        bs0 = 0;\n\n    if (tc[1] < 0)\n\n        bs1 = 0;\n\n    if (tc[2] < 0)\n\n        bs2 = 0;\n\n    if (tc[3] < 0)\n\n        bs3 = 0;\n\n\n\n    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,\n\n                                               bs0, bs1, bs2, bs3,\n\n                                               tc[0], tc[1], tc[2], tc[3],\n\n                                               alpha, beta,\n\n                                               img_width);\n\n}\n", "idx": 21168, "substitutes": {"data": ["p", "out", "rc", "a", "r", "f", "m", "device", "window", "rew", "table", "d", "ata", "image", "bus", "def", "c", "bytes", "batch", "img", "buf", "raw", "DATA", "video", "dat", "map", "buffer", "dev", "in", "ad", "Data", "block", "cache", "input", "rec", "v"], "img_width": ["img2rate", "img_rate", "img_length", "img2width", "imglenrate", "img_height", "imglenheight", " img_rate", "img2height", " img_w", "img_w", "img2length", "imglenlength", " img_length", " img_height", "imglenwidth"], "alpha": ["asc", "alph", "final", "a", "ica", "da", "sha", "ac", "title", "al", "ar", "asa", "pro", "xa", "power", "important", "ity", "aria", "la", "height", "extra", "ia", "area", "inc", "ta", "error", "ppa", "ma", "hi", "ca", "ra", "Alpha", "anti", "pha", "attr", "alias"], "beta": ["bi", "phi", "lr", "binary", "normal", "fty", "lambda", "secondary", "late", "latest", "fee", "Delta", "po", "\u03b2", "elta", "vert", "mu", "meta", "fb", "bis", "blue", "bot", "eta", "xy", "igma", "dust", "mega", "extra", "Beta", "aylor", "video", "fa", "fine", "ta", "dev", "oe", "term", "pb", "ii", "ne", "lib", "ba"], "tc": ["td", "asc", "t", "com", "tt", "ic", "rc", "tg", "desc", "tn", "dc", "cus", "tp", "fee", "toc", "ct", "etc", "bs", "unc", "cs", "bc", "tk", "cu", "ctrl", "tl", "uc", "cv", "c", "wp", "ec", "temp", "cur", "tim", "tv", "cmp", "ctx", "spec", " TC", "icc", "aco", "abi", "lc", "cm", "types", "ta", "ci", "webkit", "tic", "ts", "cases", "mc", "config", "pb", "pc", "ty", "tw", " TTC", "cache", "tm", "nc", "cc", "ctl", "tu", "tf", "TC"]}}
{"project": "qemu", "commit_id": "f37343197708d90f119007ce5ecc2503be9c04c1", "target": 0, "func": "void slirp_select_poll(fd_set *readfds, fd_set *writefds, fd_set *xfds,\n\n                       int select_error)\n\n{\n\n    Slirp *slirp;\n\n    struct socket *so, *so_next;\n\n    int ret;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_instances)) {\n\n        return;\n\n    }\n\n\n\n    global_readfds = readfds;\n\n    global_writefds = writefds;\n\n    global_xfds = xfds;\n\n\n\n    curtime = qemu_get_clock_ms(rt_clock);\n\n\n\n    QTAILQ_FOREACH(slirp, &slirp_instances, entry) {\n\n\t/*\n\n\t * See if anything has timed out\n\n\t */\n\n\t\tif (time_fasttimo && ((curtime - time_fasttimo) >= 2)) {\n\n\t\t\ttcp_fasttimo(slirp);\n\n\t\t\ttime_fasttimo = 0;\n\n\t\t}\n\n\t\tif (do_slowtimo && ((curtime - last_slowtimo) >= 499)) {\n\n\t\t\tip_slowtimo(slirp);\n\n\t\t\ttcp_slowtimo(slirp);\n\n\t\t\tlast_slowtimo = curtime;\n\n\t\t}\n\n\n\n\t/*\n\n\t * Check sockets\n\n\t */\n\n\tif (!select_error) {\n\n\t\t/*\n\n\t\t * Check TCP sockets\n\n\t\t */\n\n\t\tfor (so = slirp->tcb.so_next; so != &slirp->tcb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\t/*\n\n\t\t\t * FD_ISSET is meaningless on these sockets\n\n\t\t\t * (and they can crash the program)\n\n\t\t\t */\n\n\t\t\tif (so->so_state & SS_NOFDREF || so->s == -1)\n\n\t\t\t   continue;\n\n\n\n\t\t\t/*\n\n\t\t\t * Check for URG data\n\n\t\t\t * This will soread as well, so no need to\n\n\t\t\t * test for readfds below if this succeeds\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, xfds))\n\n\t\t\t   sorecvoob(so);\n\n\t\t\t/*\n\n\t\t\t * Check sockets for reading\n\n\t\t\t */\n\n\t\t\telse if (FD_ISSET(so->s, readfds)) {\n\n\t\t\t\t/*\n\n\t\t\t\t * Check for incoming connections\n\n\t\t\t\t */\n\n\t\t\t\tif (so->so_state & SS_FACCEPTCONN) {\n\n\t\t\t\t\ttcp_connect(so);\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} /* else */\n\n\t\t\t\tret = soread(so);\n\n\n\n\t\t\t\t/* Output it if we read something */\n\n\t\t\t\tif (ret > 0)\n\n\t\t\t\t   tcp_output(sototcpcb(so));\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Check sockets for writing\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, writefds)) {\n\n\t\t\t  /*\n\n\t\t\t   * Check for non-blocking, still-connecting sockets\n\n\t\t\t   */\n\n\t\t\t  if (so->so_state & SS_ISFCONNECTING) {\n\n\t\t\t    /* Connected */\n\n\t\t\t    so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t    ret = send(so->s, (const void *) &ret, 0, 0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXXXX Must fix, zero bytes is a NOP */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    }\n\n\t\t\t    /* else so->so_state &= ~SS_ISFCONNECTING; */\n\n\n\n\t\t\t    /*\n\n\t\t\t     * Continue tcp_input\n\n\t\t\t     */\n\n\t\t\t    tcp_input((struct mbuf *)NULL, sizeof(struct ip), so);\n\n\t\t\t    /* continue; */\n\n\t\t\t  } else\n\n\t\t\t    ret = sowrite(so);\n\n\t\t\t  /*\n\n\t\t\t   * XXXXX If we wrote something (a lot), there\n\n\t\t\t   * could be a need for a window update.\n\n\t\t\t   * In the worst case, the remote will send\n\n\t\t\t   * a window probe to get things going again\n\n\t\t\t   */\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Probe a still-connecting, non-blocking socket\n\n\t\t\t * to check if it's still alive\n\n\t \t \t */\n\n#ifdef PROBE_CONN\n\n\t\t\tif (so->so_state & SS_ISFCONNECTING) {\n\n                          ret = qemu_recv(so->s, &ret, 0,0);\n\n\n\n\t\t\t  if (ret < 0) {\n\n\t\t\t    /* XXX */\n\n\t\t\t    if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\terrno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t      continue; /* Still connecting, continue */\n\n\n\n\t\t\t    /* else failed */\n\n\t\t\t    so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t    so->so_state |= SS_NOFDREF;\n\n\n\n\t\t\t    /* tcp_input will take care of it */\n\n\t\t\t  } else {\n\n\t\t\t    ret = send(so->s, &ret, 0,0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXX */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    } else\n\n\t\t\t      so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t  }\n\n\t\t\t  tcp_input((struct mbuf *)NULL, sizeof(struct ip),so);\n\n\t\t\t} /* SS_ISFCONNECTING */\n\n#endif\n\n\t\t}\n\n\n\n\t\t/*\n\n\t\t * Now UDP sockets.\n\n\t\t * Incoming packets are sent straight away, they're not buffered.\n\n\t\t * Incoming UDP data isn't buffered either.\n\n\t\t */\n\n\t\tfor (so = slirp->udb.so_next; so != &slirp->udb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\tif (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                            sorecvfrom(so);\n\n                        }\n\n\t\t}\n\n\n\n                /*\n\n                 * Check incoming ICMP relies.\n\n                 */\n\n                for (so = slirp->icmp.so_next; so != &slirp->icmp;\n\n                     so = so_next) {\n\n                     so_next = so->so_next;\n\n\n\n                    if (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                        icmp_receive(so);\n\n                    }\n\n                }\n\n\t}\n\n\n\n\t/*\n\n\t * See if we can start outputting\n\n\t */\n\n\tif (slirp->if_queued) {\n\n\t    if_start(slirp);\n\n\t}\n\n    }\n\n\n\n\t/* clear global file descriptor sets.\n\n\t * these reside on the stack in vl.c\n\n\t * so they're unusable if we're not in\n\n\t * slirp_select_fill or slirp_select_poll.\n\n\t */\n\n\t global_readfds = NULL;\n\n\t global_writefds = NULL;\n\n\t global_xfds = NULL;\n\n}\n", "idx": 21202, "substitutes": {"readfds": ["readablefbms", "readerfsrs", "readerfrs", "readdrs", "readduds", "readfsns", "readfdns", "readfxs", "readfbms", "readxjs", " readlns", "readljs", "readlds", "readdns", "readerfuds", "readfdds", "readerfsds", "readfsrs", "readfms", "readrfms", "readfsuds", "readfuds", " readfcs", "readlns", "readablefbrs", "readerfsns", "readxds", " readfjs", "readfbds", "readfdcs", "readfsds", "readablefbds", "readfjs", "readablefxs", "readfbrs", "readfdjs", "readxns", " readlcs", "readerfns", " readljs", "readrfds", "readrfrs", "readlcs", "readablefds", "readerfds", "readdds", "readerfsuds", "readrfxs", " readfns", "readfbxs", "readxcs", "readablefms", "readablefbxs", "readfrs", "readfcs", "readfns", " readlds", "readablefrs"], "writefds": ["writefpd", "writefsds", "writecds", "writefpuds", "writefsdays", "writefcms", "writerfds", "writeFds", "writerfuncs", "writefuds", "writerfunds", "writefunms", "writerfunords", "writefcs", "writecdt", "readfd", "writefsuds", "readfsd", "writeinfts", "writeofd", "writeofdays", "writefd", "writefpds", "readfsuds", "readfuds", "writeinfdds", "writefms", "writeFcs", "writefccs", "writeinfds", "writefdt", "writeFms", "updatefsdds", "updatefsds", "writefsdt", "updatefts", "writefdays", "writeofds", "writefunds", "writefuncs", "writerfms", "writefsts", "readfsds", "writefords", "writerfords", "writecdds", "updatefsts", "readfsdays", "writefunords", "updatefsdt", "writefsd", "updatefds", "writerfcs", "writefpdays", "writefcds", "writefcords", "readfdays", "writerfunms", "writefts", "writefdds", "writeFords", "writefsdds", "writeinfdt", "writeofuds", "updatefdt", "updatefdds", "writects"], "xfds": ["fwds", "fifns", "fbds", "fxonents", "fxuds", "cfeds", "feers", "fifrs", "feedos", "fwns", "fwcs", "fweds", "fifdos", "fxds", "fbuds", "fwonents", "fwands", "xfands", "feeds", "fxcs", "xfns", "cfds", "feens", "xfdos", "fxns", "fifds", "xfcs", "cfcs", "fxrs", "fxdos", "xfuds", "xfonents", "fbns", "xfeds", "fbonents", "cfands", "xfrs", "fxeds", "fxands", "fwuds"], "select_error": ["select__error", "select_Error", "select__Error", "select__ok", "select_ok", "Select_Error", " select_Error", "select_ror", "select2error", "Select_error", "select_err", "select2ror", " select_ror", "select2Error", "Select_warning", "Select_ok", " select_err", "select_warning", "select__warning", "select2err"], "slirp": ["twirper", "slairpe", "slpirpad", "slyrpad", "scheoidphp", "slIrpp", "sloidphp", "slirpp", "islirpad", "slirer", "sloidping", "slIrphp", "slircphp", "dlirpc", "dlirpa", "scheoidpp", "slrirsp", "slrirper", "slirpc", "sliorpre", "slirr", "glpirp", "slyrP", "dlirpers", "slibrr", "sliterpa", "slibrpr", "sslirp", "slIrp", "slirkp", "slirtping", "scheirping", "sliterpers", "slpirpr", "librping", "twrirpp", "islpirpad", "slrirP", "slibrping", "sliterp", "slairp", "dliterpa", "slirpy", "slirksp", "glirp", "slrirp", "slairr", "sligp", "slyrpr", "sslibrr", "slairpr", "slircping", "sligpa", "sligpers", "twirp", "islpirP", "twirsp", "slrirpa", "twrirp", "slircp", "slpirphp", "slarsp", "dliterp", "slirpe", "sslibrp", "sslirr", "sligpc", "slibrpy", "slIrping", "slrirpy", "slirkpp", "slirpa", "slirtp", "islirP", "scheoidping", "twirpp", "islpirp", "librp", "slibrp", "lirp", "slarper", "twrirper", "slyrp", "slirpers", "glirr", "sliorp", "slpirpe", "scheirp", "slircpp", "glpirpe", "sloidp", "slirepr", "slibrpre", "dlirp", "slyrphp", "islirp", "sliorr", "slirkper", "twrirsp", "slirping", "slarpp", "slirper", "slrirpc", "slirpad", "slpirr", "sliorpy", "slirpr", "slrirpre", "sslibrpre", "glirpe", "slrirr", "sliterpc", "glpirpr", "slirep", "slpirP", "librpr", "scheirphp", "dliterpc", "scheirpp", "sslirpre", "slyrping", "dliterpers", "scheoidp", "slpirp", "slrirphp", "slarp", "slirphp", "slirP", "slrirpers", "glirpr", "glpirr", "lirping", "slirepe", "slirtpr", "sslibrpy", "sslirpy", "slrirpp", "slirpre", "islpirphp", "lirpr", "sloidpp", "slrirpad", "slirsp", "islirphp"], "so": ["sing", "ski", "io", "su", "sum", "fo", "th", "stro", "lo", "no", "sn", "ssl", "sw", "ow", "client", "SO", "sl", "ste", "sel", "o", "os", "si", "esh", "sync", "bs", "sim", "cs", "oo", "ko", "se", "sm", "ka", "dylib", "oto", "hi", "oss", "inho", "stone", "sys", "opa", "ho", "sa", "sie", "osp", "co", "pro", "po", "s", "ao", "mo", "bo", "ve", "sh", "she", "sp", "So", "mi", "obj", "dll", "store", "iso", "ii", "syn", "yes", "usr", "go", "ss", "isco", "sk", "goo", "ro", "st", "since", "j", "\u00f8", "sam", "ico", "soc", "ne"], "so_next": ["go__new", "go_new", " so_start", "so__next", "so_parent", "so__state", "se_link", "lo_parent", "go__next", "so_new", "se_next", "se_self", "go_err", "so_self", "SO_new", "go_next", "so_err", "so__err", "go_state", "so_start", "so_prev", "lo_name", "SO_next", "so__new", "SO_state", "so_future", "SO__new", "lo_next", "SO__state", "se_prev", "go__err", "lo_adj", "so_state", " so_link", " so_future", "so_name", "so_adj", "so_link", "SO__next", "go__state"], "ret": ["gt", "fun", "resp", " Ret", "t", "re", "out", "cert", "txt", "usr", "et", "cont", "r", "back", "desc", "tn", "rets", "rem", "err", "hash", "Ret", "val", "nz", "arg", "def", "ter", "ext", "dt", "rs", "args", "reset", "lt", "tr", "j", "result", "mt", "success", "deg", "ft", "rt", "reply", "res", "alt", "rf", "reg", "mem", "try", "iter", "rm", "nt", "ts", "RET", "cmd", "len", "ll", "elt", "ry", "flag", "magic"]}}
{"project": "qemu", "commit_id": "970d622e8ab1de8fdf5762e23e92a2dea9d7d36c", "target": 0, "func": "uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n", "idx": 21218, "substitutes": {"op1": ["OP11", "op3", "post4", " op3", "OP1", " op8", "bit3", "oop0", "OP0", "op8", "post3", "oop11", "post0", " op4", "op0", " op0", "op11", "oop1", "bit4", "bit1", "post1", " op11", "bit0", "OP8", "op4", "oop8"], "op2": ["op3", " optwo", "opTwo", " op3", "optwo", "hoptwo", "hop2", "exp3", "aptwo", " opTwo", "ap102", "ipb", "hopTwo", "ap2", "apTwo", "ip2", "ip3", "exp02", "op102", "hop102", "exp2", "expb", "op02", "ip02", " op102", " op02"], "opa": ["osa", "ppo", "anza", " xp", "za", " proto", " ro", " zo", "ski", "arp", "zo", "tar", " po", "fo", " fo", "asa", "hop", "po", " pap", "ipp", "pox", "php", "pa", " hop", "oa", "ti", "ip", "ap", "ahi", "op", "elo", "apo", "rio", "ona", "aco", "obo", "oga", " ip", "jo", "ola", "oop", "vo", "appy", "ppa", "pps", " php", "pai", "ma", "apt", " pol", "apa", "opus"], "opb": [" opl", "optba", "iopl", "opba", "opbi", " opba", "hop2", " opnb", "apb", "opl", "optb", "optl", "hopbar", "rop2", "opnb", " opbi", "opera", "operbar", "hopbase", "hopa", "ropbd", " opbar", "iopb", "opbd", "ap2", "hopnb", "opbar", "opernb", "opbase", "optbi", "operb", "apbase", "hopbd", "hopb", "apbd", "iopba", "iopbi", "ropbase", "ropb"], "res": ["expr", "yes", "resp", "p", "re", "out", "pas", "final", "resource", "ret", "r", "red", "vol", "ows", "off", "rem", "err", "hash", "rel", " Res", "init", "rss", "val", "ps", "arr", "RES", "resolution", "def", "results", "rs", "reset", "des", "pers", "pres", "vec", "result", "ress", "respons", "resh", "pr", "ms", "resources", "Res", "vals", "reg", "mem", "rest", "new", "has", "gr", "zero", "req", "block", "conf", "cons"], "i": ["bi", "ij", "name", "phi", "p", "\u0438", "is", " Xi", " li", "it", "ic", "iq", " si", "print", "si", "me", "di", "index", "iu", "ai", "ri", "xi", "o", "ix", "m", "ims", "y", "ji", "multi", "by", "im", "zi", "ei", "x", "id", " ii", "sim", "ind", "gi", "info", " ti", "I", " iter", "my", "ni", "qi", "ki", "ti", "j", "ini", "ip", "status", "li", "ui", "ex", "fi", " bi", " ni", "oi", "in", "ci", " pi", "mi", "ii", "ma", " mi", "pi", "hi", " multi", "point"]}}
{"project": "qemu", "commit_id": "7b527b86eb3560d68f41218cec0cdf3d60a38323", "target": 0, "func": "static int s390_ipl_init(SysBusDevice *dev)\n\n{\n\n    S390IPLState *ipl = S390_IPL(dev);\n\n    uint64_t pentry = KERN_IMAGE_START;\n\n    int kernel_size;\n\n\n\n    int bios_size;\n\n    char *bios_filename;\n\n\n\n    /*\n\n     * Always load the bios if it was enforced,\n\n     * even if an external kernel has been defined.\n\n     */\n\n    if (!ipl->kernel || ipl->enforce_bios) {\n\n        uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;\n\n\n\n        if (bios_name == NULL) {\n\n            bios_name = ipl->firmware;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (bios_filename == NULL) {\n\n            hw_error(\"could not find stage1 bootloader\\n\");\n\n        }\n\n\n\n        bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,\n\n                             &ipl->bios_start_addr, NULL, NULL, 1,\n\n                             ELF_MACHINE, 0);\n\n        if (bios_size > 0) {\n\n            /* Adjust ELF start address to final location */\n\n            ipl->bios_start_addr += fwbase;\n\n        } else {\n\n            /* Try to load non-ELF file (e.g. s390-zipl.rom) */\n\n            bios_size = load_image_targphys(bios_filename, ZIPL_IMAGE_START,\n\n                                            4096);\n\n            ipl->bios_start_addr = ZIPL_IMAGE_START;\n\n            if (bios_size > 4096) {\n\n                hw_error(\"stage1 bootloader is > 4k\\n\");\n\n            }\n\n        }\n\n        g_free(bios_filename);\n\n\n\n        if (bios_size == -1) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        /* default boot target is the bios */\n\n        ipl->start_addr = ipl->bios_start_addr;\n\n    }\n\n\n\n    if (ipl->kernel) {\n\n        kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n\n                               NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n\n         * kernel parameters here as well. Note: For old kernels (up to 3.2)\n\n         * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n\n         * loader) and it won't work. For this case we force it to 0x10000, too.\n\n         */\n\n        if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n\n            ipl->start_addr = KERN_IMAGE_START;\n\n            /* Overwrite parameters in the kernel image, which are \"rom\" */\n\n            strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n\n        } else {\n\n            ipl->start_addr = pentry;\n\n        }\n\n\n\n        if (ipl->initrd) {\n\n            ram_addr_t initrd_offset;\n\n            int initrd_size;\n\n\n\n            initrd_offset = INITRD_START;\n\n            while (kernel_size + 0x100000 > initrd_offset) {\n\n                initrd_offset += 0x100000;\n\n            }\n\n            initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n            if (initrd_size == -1) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        ipl->initrd);\n\n                exit(1);\n\n            }\n\n\n\n            /*\n\n             * we have to overwrite values in the kernel image,\n\n             * which are \"rom\"\n\n             */\n\n            stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n\n            stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 21219, "substitutes": {"dev": ["p", "sys", "dm", "ver", "Dev", "ach", "device", "serial", "sd", "d", "iv", "serv", "pro", "def", "eth", "Device", "data", "handle", "disk", "proc", "hw", "DEV", " device", "ctx", "spec", "ptr", "dem", "de", "mem", "ad", "usb", "wd", "ch", "nt", "conf", "obj", "v", "ev", "w"], "ipl": ["gif", "fol", "ippers", "ipt", "impl", "ief", "tl", "liv", "imp", "inyl", "ssl", "expl", "sil", "fl", " pl", "coll", "sel", "ix", "obl", "pp", "ind", "il", "multipl", "yp", "empl", "dl", "ept", "iov", "pol", "ih", "repl", "iol", "mult", "ik", "isl", "pel", "supp", "phi", "cil", "iq", "vl", "opl", "rob", "iop", "owl", "cl", "ith", "ip", "scl", "ocl", "iph", "inc", "PL", "inf", "vp", "nil", "iper", "prov", "iu", "qq", "spl", "inv", "iv", "pl", "abul", "ipp", "ell", "compl", "elf", "abl", "opp", "impact", "hl", "ips", "upp", "rl", "uph", "each", "includes"], "kernel_size": ["kernel67Size", "channelitysource", "kernel00percent", "kernel2size", "kernel00loss", "kernel0space", "wrapper_ize", "kernel_write", "kernel_SIZE", "worker_size", "kernel67write", "kernel_capacity", "kernel_Size", "kernelitysize", "wrapper00percent", "kernel2Size", " kernel2size", "kernelitysource", "kernel67percent", "kernel0capacity", "kernel2SIZE", "kernel_percent", "kernel64size", "worker_space", " kernel2count", "kernel_source", "kernellogstrength", "kernel_loss", "kernelityweight", " kernel_SIZE", "kernel_ize", " kernel_Size", "kernel67size", "worker_length", "kernellogize", " kernel2ize", "kernel00size", "channelitySize", "kernelitySize", " kernel_write", "kernel2strength", "kernel64Size", "wrapper_percent", "kernel64weight", "kernel00ize", "kernel67loss", "kernel64loss", " kernel_count", "channel_size", "kernel67SIZE", "kernel0size", "kernellogsize", "kernel0length", "wrapper_loss", "kernel_weight", "kernel2ize", "wrapper00size", "wrapper_size", "channelityweight", "kernel_strength", " kernel2strength", " kernel_strength", "kernel64percent", "channel_weight", " kernel_ize", "channelitysize", "channel_source", "kernellogcount", "kernel67ize", "kernel_length", "kernel_count", "kernel64ize", "worker_capacity", "kernel_space", "kernel2write", "kernel64source", "wrapper00ize", "channel_Size", "kernel2count", "wrapper00loss"], "bios_size": ["bio_name", "bios_error", "biosistsize", "bii_filename", "bio_size", "bios7SIZE", "bii_speed", "biosistinfo", "bockets_time", "bios5SIZE", "bios00size", "bios6speed", "bio_address", "bios4error", "bios00speed", "bio_scale", "bios7error", "bii00speed", "biosistspeed", "bios5space", "bios4sized", "bios8size", "bios_SIZE", "bios6info", "bio_space", "bockets_sized", "bios7size", "bios6filename", "bios4SIZE", "bio_ize", "bios7sized", "bio_SIZE", "bios_time", "bii_size", "bios5error", "bios5size", "bockets_size", "bios_address", "bockets_SIZE", "bio_sized", "bios6size", "bios8SIZE", "bios_scale", "bios00info", "bii00info", "bios_name", "bii00size", "bio_error", "bios_info", "bios8space", "bios8error", "bios_ize", "bii_info", "bios_sized", "bios_speed", "bios00filename", "bii00filename", "bios4size", "bios_space", "biosistfilename"], "bios_filename": ["bounces_Filename", "bios_wav", "bio_Filename", "bio_name", "bios_uri", "bio_username", "bios2filename", "bios2name", "bios_folder", "bios_txt", "bios_handle", "bounces_folder", "bios__fil", "bounces_filename", "bio_wav", "bios_file", "bios___Filename", "bios___filename", "bounces___folder", "bios___fp", "bios__filename", "bios2file", "bio_txt", "bios___handle", "bios___txt", "bio_file", "bios_fil", "bios_status", "bios2username", "bio_handle", "bounces___status", "bio_fp", "bios_fp", "bios___folder", "bounces___Filename", "bounces___filename", "bios__username", "bios_name", "bio_fil", "bounces_status", "bios___status", "bios_Filename", "bio_uri", "bios__Filename", "bios_username", "bio_filename"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 21250, "substitutes": {"devname": ["devlen", "DevName", "volnames", "Devname", "devno", "deviceName", " devnm", "evlen", "evnm", "evname", "volnm", " devnames", "Devlen", "devicename", "evnames", "volname", "volName", "Devno", "devnames", "devnm", "deviceno", "evno", " devno", " devlen", " devName", "devName", "evName"], "device": ["volume", "engine", "gpu", "model", "context", "slave", "di", "window", "serial", "database", "driver", "image", "bus", "document", "Device", "node", "peer", "controller", "handle", "disk", "drive", "connection", "DEV", "pod", "pipe", "family", "link", "directory", "module", "product", "ve", "draw", "position", "server", "devices", "buffer", "project", "dev", "interface", "address", "remote", "port", "network"], "label": ["name", "els", "tag", "comment", "Label", " Label", "list", "role", "desc", "alias", "color", "field", "type", "kind", "description", "value", "group", "title", "key", "url", "loc", "style", "lay", "mask", "bus", " L", "call", "layout", "str", "slot", "data", "node", "leaf", "hide", "size", "local", "handle", "LAB", "abel", "cell", "link", "module", "id", "control", "position", "shape", "EL", "prefix", "block", "lab", "nl", "stroke", "line", "l", "route", "el", " labels", "L"], "bus_opts": ["bus_pyents", "bus_hps", "bus_opvs", "bus_cops", "bus_opents", "bus_optters", "bus_attuts", "bus_optps", "bus_pyuts", "bus_opps", "bus_provs", "bus_cots", "bus_pyts", "bus_attents", "bus_prots", "bus_optts", "bus_OPs", "bus_propt", "bus_hts", "bus_OPters", "bus_oppt", "bus_hvs", "bus_hpt", "bus_attps", "bus_pyps", "bus_otts", "bus_OPts", "bus_opters", "bus_OPcs", "bus_opcs", "bus_oputs", "bus_otcs", "bus_OPps", "bus_props", "bus_copt", "bus_otps", "bus_optents", "bus_covs", "bus_ops", "bus_optcs", "bus_otters", "bus_attts", "bus_optuts", "bus_ots"], "dev_opts": ["dev_popts", "dev_OPcs", "dev_orcs", "dev_optts", "dev_catds", "dev_catcs", "dev2optts", "dev_optters", "dev_opt", "dev2opters", "dev_opters", "dev_pros", "dev_OPts", "dev_popters", "dev_opTS", "dev_prots", "dev_orts", "dev2opts", "dev_poprs", "dev_OPs", "dev_ops", "dev_optcs", "dev2ops", "dev_catTS", "dev2oprs", "dev_optds", "dev_oprs", "dev_verters", "dev_ords", "dev2optters", "dev_verrs", "dev2optrs", "dev_opds", "dev_prot", "dev_procs", "dev_catts", "dev_verts", "dev_otts", "dev_pops", "dev_optTS", "dev_vers", "dev_otcs", "dev_optt", "dev_ott", "dev_opcs", "dev_orTS", "dev_optrs"], "index": ["Index", "n", "loop", "available", "state", "engine", "capacity", "context", "number", "ion", "list", "process", "connect", "ix", "IND", "length", "offset", "add", "value", "thread", "order", "fee", "condition", "connected", "count", "total", "x", "id", "ind", "i", "weight", "level", "row", "mount", "max", "axis", "select", "size", "timeout", "created", "no", "batch", "connection", "status", "lock", "version", "height", "link", "directory", "ex", "num", "position", " Index", "open", "active", "location", "iter", "instance", "zero", "address", "pos", "success", "point", "insert"]}}
{"project": "qemu", "commit_id": "6cff3e8594cd974a507d531da09455d1c7aeb30d", "target": 0, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n", "idx": 21256, "substitutes": {"mon": ["man", "master", "monkey", "mat", "dm", "demon", "meter", "ston", "mm", "di", "dom", "ai", "met", "m", "mut", "mint", "mp", "sim", "conn", "mu", "my", "admin", "Mon", " man", "dog", "den", "MON", "mate", "ann", "san", "mt", "manager", "sam", "min", "don", "mit", "mun", "mx", "util", "mont", "mi", "mons", "tem", "wat", "mond", "client", "mn", "monitor", "mir", "mind", " monitor", "serv"], "str": ["name", "t", "is", "print", "r", "list", "exec", "ar", "enc", "arr", "or", "st", "s", "tr", "cut", "status", "fr", "buf", "br", "res", "seq", "STR", "sc", "ch", "dr", "new", "par", "gr", "sp", "stri", "cr", "obj", "Str", "ctr"], "c": ["comm", "t", "p", "com", "rc", "vc", "a", "cat", "r", "cont", "ce", "ach", "f", "dc", "m", "go", "err", "ac", "co", "conv", "gc", "ct", "d", "cy", "unc", "con", "cs", "bc", "cu", "cum", "i", "e", "uc", "cl", "ec", "cur", "cmp", "cut", "z", "C", "cod", " cr", "k", "q", "arc", "\u00e7", "lc", "cm", "sc", "cf", "ch", "mc", "cr", "tc", "u", "cache", "cc", "l", "ca", "fc", "comp", "cp", "v", "b", "chain"]}}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n", "idx": 21261, "substitutes": {"s": ["n", "comm", "ties", "t", "p", "is", "state", "ysis", "settings", "a", "os", "set", "h", "m", "ns", "ss", "ims", "changes", "ses", "stats", "ar", "bs", "ps", "cs", "sts", "e", "rs", "gs", "aws", "i", "c", "services", "ds", "fs", "se", "status", "spec", "ls", "sv", "ssl", "hs", "ies", "S", "js", "service", "es", "g", "its", "sq", "ts", "ins", "has", "ares", "conf", "qs", "mys", "sb", "ains", "b", "as", "sl"], "seg_reg": ["sema_label", "sema_addr", "seg2loc", "segment_reg", "segm_val", "sege2addr", "segment_res", "seg_label", "semapyaddr", "seg_addr", "seg2REG", "sep_reg", "segm_addr", "sep_loc", "semapyrem", "seg2num", "semapyreg", "sema_reg", "segment_REG", "sema_rem", "seg2register", "segm_reg", "seg_num", "segm2addr", "seg_loc", "sege_addr", "sege_rom", "sep2addr", "seg_rem", "segpylabel", "seg_register", "seg_res", "seg2addr", "semapylabel", "segment_addr", "segm2reg", "sep2reg", "sege_reg", "segm2val", "sege2register", "seg_rom", "seg_REG", "seg2val", "sep_addr", "sege2reg", "segm_num", "sege_register", "sege2rom", "segpyreg", "sep_res", "segpyrem", "seg2reg", "sep2num", "segpyaddr", "seg_val", "sep_num", "segm2num", "seg2rom", "seg2res"]}}
{"project": "qemu", "commit_id": "5d98bf8f38c17a348ab6e8af196088cd4953acd0", "target": 0, "func": "void gen_intermediate_code_a64(ARMCPU *cpu, TranslationBlock *tb)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    target_ulong next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n\n\n    dc->aarch64 = 1;\n\n    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then\n\n     * there is no secure EL1, so we route exceptions to EL3.\n\n     */\n\n    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&\n\n                               !arm_el_is_aa64(env, 3);\n\n    dc->thumb = 0;\n\n    dc->bswap_code = 0;\n\n    dc->condexec_mask = 0;\n\n    dc->condexec_cond = 0;\n\n    dc->mmu_idx = ARM_TBFLAG_MMUIDX(tb->flags);\n\n    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (dc->current_el == 0);\n\n#endif\n\n    dc->fp_excp_el = ARM_TBFLAG_FPEXC_EL(tb->flags);\n\n    dc->vec_len = 0;\n\n    dc->vec_stride = 0;\n\n    dc->cp_regs = cpu->cp_regs;\n\n    dc->features = env->features;\n\n\n\n    /* Single step state. The code-generation logic here is:\n\n     *  SS_ACTIVE == 0:\n\n     *   generate code with no special handling for single-stepping (except\n\n     *   that anything that can make us go to SS_ACTIVE == 1 must end the TB;\n\n     *   this happens anyway because those changes are all system register or\n\n     *   PSTATE writes).\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 1: (active-not-pending)\n\n     *   emit code for one insn\n\n     *   emit code to clear PSTATE.SS\n\n     *   emit code to generate software step exception for completed step\n\n     *   end TB (as usual for having generated an exception)\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 0: (active-pending)\n\n     *   emit code to generate a software step exception\n\n     *   end the TB\n\n     */\n\n    dc->ss_active = ARM_TBFLAG_SS_ACTIVE(tb->flags);\n\n    dc->pstate_ss = ARM_TBFLAG_PSTATE_SS(tb->flags);\n\n    dc->is_ldex = false;\n\n    dc->ss_same_el = (arm_debug_target_el(env) == dc->current_el);\n\n\n\n    init_tmp_a64_array(dc);\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    tcg_clear_temp_count();\n\n\n\n    do {\n\n        tcg_gen_insn_start(dc->pc, 0);\n\n        num_insns++;\n\n\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    gen_exception_internal_insn(dc, 0, EXCP_DEBUG);\n\n                    /* Advance PC so that clearing the breakpoint will\n\n                       invalidate this TB.  */\n\n                    dc->pc += 2;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc->ss_active && !dc->pstate_ss) {\n\n            /* Singlestep state is Active-pending.\n\n             * If we're in this state at the start of a TB then either\n\n             *  a) we just took an exception to an EL which is being debugged\n\n             *     and this is the first insn in the exception handler\n\n             *  b) debug exceptions were masked and we just unmasked them\n\n             *     without changing EL (eg by clearing PSTATE.D)\n\n             * In either case we're going to take a swstep exception in the\n\n             * \"did not step an insn\" case, and so the syndrome ISV and EX\n\n             * bits should be zero.\n\n             */\n\n            assert(num_insns == 1);\n\n            gen_exception(EXCP_UDEF, syn_swstep(dc->ss_same_el, 0, 0),\n\n                          default_exception_el(dc));\n\n            dc->is_jmp = DISAS_EXC;\n\n            break;\n\n        }\n\n\n\n        disas_a64_insn(env, dc);\n\n\n\n        if (tcg_check_temp_count()) {\n\n            fprintf(stderr, \"TCG temporary leak before \"TARGET_FMT_lx\"\\n\",\n\n                    dc->pc);\n\n        }\n\n\n\n        /* Translation stops when a conditional branch is encountered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefetch aborts occur at the right place.\n\n         */\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             !dc->ss_active &&\n\n             dc->pc < next_page_start &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(cs->singlestep_enabled || dc->ss_active)\n\n        && dc->is_jmp != DISAS_EXC) {\n\n        /* Note that this means single stepping WFI doesn't halt the CPU.\n\n         * For conditional branch insns this is harmless unreachable code as\n\n         * gen_goto_tb() has already handled emitting the debug exception\n\n         * (and thus a tb-jump is not possible when singlestepping).\n\n         */\n\n        assert(dc->is_jmp != DISAS_TB_JUMP);\n\n        if (dc->is_jmp != DISAS_JUMP) {\n\n            gen_a64_set_pc_im(dc->pc);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            gen_exception_internal(EXCP_DEBUG);\n\n        } else {\n\n            gen_step_complete_exception(dc);\n\n        }\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_UPDATE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            /* fall through */\n\n        case DISAS_JUMP:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n        case DISAS_EXC:\n\n        case DISAS_SWI:\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_WFI:\n\n            /* This is a special case because we don't want to just halt the CPU\n\n             * if trying to debug across a WFI.\n\n             */\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         4 | (dc->bswap_code << 1));\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 21267, "substitutes": {"cpu": ["core", "uci", "sys", "gpu", "rc", "ck", "alloc", "os", "process", "boot", "pixel", "tp", "gc", "conn", "cu", "onet", "vm", "gnu", "jp", "proc", "mac", "hw", "nu", "base", "ork", "pu", "ctx", "environment", "clock", "chip", "nic", "aco", "bean", "sc", "ka", "mem", "mx", "ola", "upt", "rpm", "pc", "np", "pb", "cam", "CPU", "linux", "nc", "phys", "cp", "net"], "tb": ["Tbi", "tbb", "ttba", "tba", "tB", " twb", "ttbl", "ttbd", "tenzb", "tebb", "tbl", "traceba", "ttyba", "notexb", "toolwb", "tob", "ptb", "tracefb", "toolv", "ttx", "tazb", " tB", "Tb", "tracexb", "tov", "itbm", "tsx", "tbt", "pbb", "teb", "noteba", "toolb", "itba", "itb", "ttb", "tsb", "treebd", "togb", "Tbb", "itbi", "twb", "treebt", "tenj", "tbd", "Tbl", "itbl", "itB", "txb", "ptbe", "itv", "tracev", "tbi", "pbt", "tj", "pbi", "treeba", "tozb", "timbb", "tenb", "tzb", "tx", "tsbl", "tfb", "ptbl", "tracebm", "tv", "tbe", "ttybd", "ptx", "tbm", " txb", "timb", "noteb", " tv", "tagb", "tebi", "traceb", "toB", "treeb", "tobt", "tebl", "timbi", "itxb", "ttybt", "toxb", "tsbe", "taj", "tab", "timbt", "tobb", "itbb", "toj", "tgb", "notebm", "tobi", "tengb", "tracewb", "pb", "toolfb", " tfb", "ttbe", "ttyb", "ttbt"], "cs": ["sys", "rc", "ck", "ks", "os", "css", "ys", "cus", "ss", "ns", "ac", "ps", "bs", "sts", "rs", "c", "ds", "ec", "cmp", "ls", "CS", "caps", "vs", "lc", "sc", "cms", "ci", "wcs", "ts", "pc", "tc", "acs", "nc", "cc", "cks", "ca", "cp"], "env": ["eh", "et", "ce", "desc", "equ", "ens", "dt", "eg", "vm", "ds", "server", "sw", "tc", "next", "ew", "v", "erc", "ev", "eas", "context", "enc", "e", "esc", "environment", "vs", "db", "sc", "dev", "era", "cmd", "eng", "net", "core", "ef", "ei", "cv", "den", "ec", "proc", "hw", "buf", "ctx", "kernel", "config", "docker", "np", "conf", "nc", "el", "vp", "serv", "er", "en", "dh", "end", "org", "cb", "window", "inv", "ea", "ext", "conn", "ect", "estate", "ent", "here", "hl", "viron", "priv", "nv", "eve"], "dc1": [" DC2", " DC3", "DC3", "cca1", "cca3", "fc3", "cca2", "fc1", "cca9", " DC9", "dc3", "DC2", "DC1", " dc9", " dc3", "dc2", " DC1", "tc2", "fc2", "tc3", " dc2", "tc1", "dc9"], "dc": ["desc", "dq", "fee", "central", "dt", "wp", "cd", "ds", "no", "lc", "oe", "cr", "tc", "ctl", "oc", "kw", "dm", "cat", "comment", "cca", "api", "condition", "nz", "bd", "dim", "dl", "see", "ga", "arc", "dat", "dp", "db", "sc", "adr", "de", "dr", "drm", "pc", "cam", "acl", "tm", "cc", "fc", "cp", "td", "DC", "vc", "die", "css", "du", "disc", "gc", "d", "def", "currency", "c", "ec", "mac", "ctx", "df", "design", "cms", "nc", "ca", "rc", "di", "dd", "isco", "ac", "document", "bc", "controller", "admin", "enter", "draw", "cm", "doc", "mc", "da"], "pc_start": ["pc8part", "pc_begin", "px_base", "proc_start", "px_part", "proc_stop", "pc8first", "pcWfirst", "pc00stop", "sc_first", "PC_pos", "pc0end", "pc_set", "pc00end", "pxWstart", "proc_end", "pc__end", "sc23start", "px_first", "proc_set", "pcWpart", "PC_begin", "pc0start", "PC_start", "pc23end", "sc_start", "pc0stop", "pc_pos", "pc_base", "pc00set", "pc_part", "pc8base", "pcWbase", "pc_first", "sc23first", "pc__start", "pc00start", "pc8start", "pc23first", "pc__begin", "pcWstart", "sc23end", "pc_stop", "pc__pos", "pc_end", "pxWpart", "pc0set", "pc23start", "pxWbase", "sc_end", "px_start", "PC_end", "pxWfirst"], "next_page_start": ["next_page2pos", "next_pages_start", "next_pc_start", "next_pc_end", "next_page_pos", "next_pages_pos", "next_pages_end", "next_page2size", "next_pc_offset", "next_page_end", "next_page_size", "next_page2offset", "next_page2end", "next_pc_pos", "next_page_offset", "next_pages_size", "next_page2start"], "num_insns": ["num_inn", "num_innfs", "num_isinns", "num_lsns", "num_lsn", "num_incnz", "num_insnis", "num_incns", "num_isincs", "num_innn", "num_innz", "num_incn", "num_isinfs", "num_insn", "num_infs", "num_innis", "num_innns", "num_inns", "num_lsnis", "num_inscs", "num_incs", "num_lsnz", "num_inncs", "num_isinn", "num_insfs", "num_incnis", "num_insnz"], "max_insns": ["max_rsns", "max_insn", "maxL_", "max_incn", "max_incns", "max_minsne", "max_insuns", "total__", "max_insne", "max_incne", "max_rsuns", "total_ex", "max__", "max_ex", "max_rsne", "max_incuns", "maxLex", "max_minsns", "max_minsn", "max_rsn", "max_minsuns"]}}
{"project": "FFmpeg", "commit_id": "2ac00d2d1d51047c6ce69d5fbe1a08392d142658", "target": 0, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {\n\n            sc->stsc_data[i].id = 0;\n\n            if (c->fc->error_recognition & AV_EF_EXPLODE) {\n\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 21281, "substitutes": {"c": ["coll", "n", "p", "t", "com", "rc", "vc", "cont", "ce", "cn", "f", "dc", "m", "abc", "ac", "co", "conv", "etc", "ct", "enc", "call", "con", "cs", "bc", "e", "cu", "cd", "cv", "ec", "cur", "C", "ctx", "cor", "lc", "cm", "cf", "ci", "g", "anc", "config", "mc", "pc", "cam", "tc", "conf", "cache", "cr", "can", "nc", "cc", "ca", "fc", "v", "l", "chain"], "pb": ["resp", "p", "rb", "txt", "eb", "pack", "cb", "pm", "tp", "ob", "conv", "pkg", "pro", "pt", "pp", "lp", "uf", "mp", "pl", "wp", "lb", "erb", "tk", "cp", "tab", "pa", "fb", "PB", "jp", "asm", "proc", "fp", "buf", "mb", "ctx", "ub", "dp", "wb", "db", "px", "pan", "patch", "phy", "stab", "amp", "sp", "pc", "typ", "tc", "pg", "emb", "buff", "conf", "req", "pel", "sb", "bs", "b", "bp", "fc", "bj", "vp", "tf", "bb"], "atom": [" orb", " Atom", "p", "orm", "o", " x", "m", "om", " buf", " exc", " app", "x", " cmd", "um", " nm", "or", " form", " ab", "nm", "bm", " om", "entry", " symb", " p", " atoms", " err", " ob"], "st": ["ste", "t", "p", "ost", "start", "set", "stat", "sec", "ss", "sta", "th", "ct", "src", "sts", "St", "str", "s", "cur", "tr", "stra", "mt", "nd", "ust", "sn", "ft", "sh", "sv", "est", "sw", "stable", "ch", "rest", "ocr", "sp", "std", "ist", "cr", "ace", "inst", "ST", "so", "ut"], "sc": ["ok", "asc", "sch", "scope", "isc", "sys", "com", "rc", "usc", "Sc", "set", "sec", "desc", "dc", "ss", "scale", "scan", "sd", "sync", "ac", "gc", "cgi", "capt", "loc", "cs", "bc", "cu", "sic", "cv", "uc", "cl", "esc", "ec", "sci", "scl", "psc", "osc", "ctx", "spec", "cer", "sh", "sw", "lc", "qu", "craft", "ci", "ch", "anc", "sp", "mc", "config", "pc", " subsc", "cr", "tc", "soc", "cam", "can", "nc", "cc", "scrib", "sche", "fc", "comp", "SC"], "i": ["is", "ic", "m", "ims", "im", "I", "ti", "batch", "cli", "k", "ui", " bi", "v", "uri", "n", "\u0438", "si", "me", "ai", "ix", "cgi", "ji", "x", " ii", "sim", "ind", "gi", "e", " ti", "ami", "fi", " ni", "oi", "g", "hi", "bi", "phi", "t", "it", "iq", "ri", "xi", "f", "y", "multi", "zi", "iri", "ei", "s", "qi", "ini", "ip", "li", "in", "ci", "rest", "mi", "ii", "esi", "slice", "pi", "l", "series", "ij", "p", "di", "index", "iu", "us", "init", "id", "ki", "j", "q", "ms", "iter"], "entries": ["gentlements", "Entrys", "ENTries", "ENTrys", "ntrys", "ENTies", "gentrance", "entrates", "enries", "mentencies", "Enties", "entsents", "entencies", "Entry", "entRY", "entures", "entsries", "ntries", "curents", "ENTlements", "enents", "mentrys", "gentrys", "Entrates", "Entriers", "entrance", "curires", "enions", "nties", "ENTRY", "genties", "gentry", "entsions", "curries", "entsrance", "Entrance", "ntlements", "ntRY", "gentries", "entsures", "EntRY", "mentries", "entry", "ntriers", "entents", "entriers", "entions", "Entures", "ntures", "entsriers", "entlements", "entsrys", "entslements", "entsires", "entires", "Entries", "entsies", "Entencies", "Entlements", "entsrates", "entsry", "enires", "curions", "enties", "entrys", "mentrates", "entsencies"]}}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n", "idx": 21284, "substitutes": {"frame": ["rame", "state", "context", "iframe", "force", "ref", "f", "window", "offset", "image", "style", "id", "code", "trace", "target", "row", "info", "hide", "frames", "show", "base", "Frame", "fr", " frames", "scene", "draw", "feat", "buffer", "self", "face", " Frame", "stack", "error", "block", "pointer", "fram", "local", "point", "channel"], "height": ["density", "volume", "history", "kw", "hang", "ht", "depth", "ows", "h", "window", "length", "y", "count", "rows", "style", "resolution", "row", "Height", "size", "alpha", "yt", "gravity", "html", "padding", "sky", "shape", "ch", "holes", "ty", "stroke", "gy", "above", "ish", "grow", "angle"], "src": ["sys", "load", "rc", "usr", "sel", "source", "sec", "ack", "rob", "init", "iv", "embed", "dest", "stream", "loc", "ind", "target", "rs", "str", "RC", "attr", "st", "s", "cur", "fr", "sr", "img", "buf", "raw", "ptr", "now", "rt", "tmp", "seq", "sc", "addr", "inner", "sq", "ins", "std", "rl", "req", "obj", "input", "inst", "sb", "ser", "comp", "slice", "dist", "supp", "ctr", "sl", "text"], "src_end": ["src_fin", "src_ends", "src_End", "rc_end", "rc_ends", "rc_End", "rc_fin"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n", "idx": 21296, "substitutes": {"n": ["fn", "t", "p", "en", "out", "gn", "rn", "r", "o", "cn", "nr", "f", "m", "y", "co", "dn", "nw", "nor", "d", "na", "note", "i", "conn", "nn", "on", "or", "c", "node", "N", "j", "nu", "nb", "ng", "sn", "nm", "num", "adj", "cdn", "g", "nt", "norm", "np", "nl", "ne", "nc", "nv", "mn", "l", "v", "b", "an", "w"], "cmd": ["comm", "kw", "resp", "build", "msg", "it", "quit", "ck", "iq", "cont", "cb", "desc", "m", "Cmd", "exec", "act", "ct", "pkg", "pt", "call", "def", "ind", "conn", "ctrl", "ext", "news", "tx", "c", "tab", "good", "md", "cmp", "cli", "batch", "cur", "op", "urg", "ctx", "nm", "q", "bind", "send", "control", "help", "and", "ch", "mem", "wd", "nt", "job", "command", "term", "crit", "form", "quick", "nc", "comp", "cp", "cfg", "ctr"], "req": ["resp", "msg", "usr", "fresh", "iq", "r", "requ", "ack", "ref", "desc", "dq", "qq", "rel", "qt", "fee", "gz", "pkg", "pro", "required", "ind", "rd", " requ", "tx", "tab", "good", "md", "jp", "rx", "cur", "j", "fr", "buf", "aux", "urg", "ctx", "request", "q", "quest", "res", "seq", "cond", "dem", "js", "mem", "eq", "sq", "crit", "quick", "rec", "comp", "need"], "ns": ["NS", "ks", "Ns", "os", "ans", " names", "nas", "aps", "ys", "acts", "ons", "ss", "aos", "outs", "ims", "na", "bs", "eps", "uns", "cs", "sts", "nn", "fs", "conn", "gs", "ds", "s", "locks", "nos", "sn", "ls", "names", "ms", "ats", "vs", "ites", "js", "xs", "its", "ins", "nt", "sp", "als", "qs", "ne", "mn", "ains", "irms", "ents"]}}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n", "idx": 21302, "substitutes": {"link": ["ck", "pack", "process", "tool", "scan", "loc", "ld", "close", "node", "let", "lo", "word", "map", "ick", "action", "local", "ink", "flow", "type", "loop", "list", "thread", "sync", "ay", "relation", "join", "disk", "linked", "flex", "cell", "entry", "ln", "mark", "zip", "load", "way", "tag", "task", "ping", "image", "url", "call", "label", "def", "style", "ip", "parse", "li", "html", "match", "sp", "store", "line", "l", "route", "share", "build", "Link", "set", "connect", "check", "id", "lay", "test", "query", "le", "ment", "lock", "error", "play", "block", "address", "light", "flag"], "i": ["is", "ic", "ski", "io", "m", "ims", "im", "span", "I", "ti", "ui", " bi", "v", " err", "chain", "uli", "name", "\u0438", " si", "si", "ai", "ix", " m", "x", " ii", "sim", "ind", "gi", "e", " ti", "ami", " di", " ni", "oi", "g", " j", " pi", "u", "bi", "t", "phi", "it", "iq", "xi", "y", "multi", "ei", "c", "s", "qi", "ini", "li", "ci", "mi", "ii", " mi", "pi", "yi", "ori", "ij", "p", " li", "print", "di", "index", "iu", "init", "key", "id", "ki", "j", "gu", "json", " multi"], "picref": ["picrel", "Picreg", " picrel", " piclink", "picnum", "pcob", "pclink", "ericentry", "niccell", "ericreg", "icref", "picconf", "ericreference", "txtlink", "icRef", "picentry", " picnum", "picreference", "Picref", "picreg", "pictrel", "Picreq", "pictref", "icentry", "icreg", " picob", "pinentry", "phototab", "pcinfo", " picinfo", "icdef", " picconf", "pinrel", "icconf", "pinnum", "pinreq", "icrel", "pinreference", "txtob", "picreq", "ericRef", "picinfo", "ictab", "icro", "pictab", "txtref", "photocell", "icreference", "photoref", "ericreq", "pindef", "pictdef", "nicref", "pictnum", "txtinfo", "pcref", "picRef", "PicRef", "piclink", "piccell", "picro", "icreq", " picdef", "picdef", "nictab", "picob", "iccell", "pinref", "ericref", "pinconf", "photoro", "nicro"]}}
{"project": "qemu", "commit_id": "375cb560295484b88898262ebf400eff9a011206", "target": 0, "func": "static uint64_t pl110_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl110_state *s = (pl110_state *)opaque;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return idregs[s->version][(offset - 0xfe0) >> 2];\n\n    }\n\n    if (offset >= 0x200 && offset < 0x400) {\n\n        return s->raw_palette[(offset - 0x200) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* LCDTiming0 */\n\n        return s->timing[0];\n\n    case 1: /* LCDTiming1 */\n\n        return s->timing[1];\n\n    case 2: /* LCDTiming2 */\n\n        return s->timing[2];\n\n    case 3: /* LCDTiming3 */\n\n        return s->timing[3];\n\n    case 4: /* LCDUPBASE */\n\n        return s->upbase;\n\n    case 5: /* LCDLPBASE */\n\n        return s->lpbase;\n\n    case 6: /* LCDIMSC */\n\n        if (s->version != PL110) {\n\n            return s->cr;\n\n        }\n\n        return s->int_mask;\n\n    case 7: /* LCDControl */\n\n        if (s->version != PL110) {\n\n            return s->int_mask;\n\n        }\n\n        return s->cr;\n\n    case 8: /* LCDRIS */\n\n        return s->int_status;\n\n    case 9: /* LCDMIS */\n\n        return s->int_status & s->int_mask;\n\n    case 11: /* LCDUPCURR */\n\n        /* TODO: Implement vertical refresh.  */\n\n        return s->upbase;\n\n    case 12: /* LCDLPCURR */\n\n        return s->lpbase;\n\n    default:\n\n        hw_error(\"pl110_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 21306, "substitutes": {"opaque": ["oplque", " opaques", "Opity", "Opoid", "ropaques", "opoid", "ropaque", "oplaque", "ropoid", " opoid", "Opoxy", " opque", "opity", "oplity", " opoxy", "oplacity", "ropoxy", " opacity", "Opaque", "Opacity", "opacity", "opoxy", "opaques", "Opaques", " opity", "Opque", "opque"], "offset": ["message", "oid", "et", "article", "length", "topic", "payment", "timeout", "reset", "peer", "xy", "no", "ff", "now", "operation", "term", "path", "command", "after", "pos", "pointer", "client", "point", "padding", "response", "start", "o", "output", "ix", "order", "trace", "empty", "entry", "location", "area", "scroll", "at", "bound", "usage", "prefix", "Offset", "ref", "url", "style", "layout", "slot", "outer", "ptr", "kernel", "ft", "position", "buffer", "sp", "range", "len", "esi", "encrypted", "out", "set", "index", "off", "window", "OFF", "attribute", "key", "id", "code", "adjusted", "associated", "shift", "tif", "align", "seek", "addr", "error", "address", "offer", "pad", "origin"], "size": ["n", "name", "cap", "start", "message", "set", "sum", "length", "SIZE", "window", "format", "count", "code", "empty", "c", "body", "z", "shift", "ize", "send", "area", "mem", "Size", "sp", "address", "len", "type"], "s": [" parts", "ports", "izes", "is", " results", "ubs", "m", "ims", "forms", "sts", "des", "ds", "sis", " objects", "ches", "details", "packs", "ssl", "sv", "sw", "hs", "grades", "types", "ess", "es", "als", "ants", "less", "eds", "sb", "v", "ations", "sl", "ths", "ed", " formats", "aces", "a", "os", "iffs", "changes", "ns", "bs", "rows", " styles", " mods", "fs", "aws", "bis", "olds", "ions", "se", "sm", "ers", "values", "sets", "lines", "vs", "ats", "self", "ests", "g", "ts", "mods", "aches", "qs", "ords", "b", "tes", "comm", "t", "sys", "settings", "outs", "y", "stats", "ps", "services", "ments", "c", "z", "points", "ls", "ies", "S", "reports", "its", "sp", " values", "ists", " instruments", "p", "itions", "bits", "rates", " streams", "parts", "h", "ss", "ses", "ands", "aints", "sports", "rs", "gs", "ries", "styles", "umps", "j", "ials", "sam", " ads", "vals", "js", "sq", "erences", "ains", " counts", "resses", "ents"]}}
{"project": "FFmpeg", "commit_id": "eb38d8fe926bdce8110fa4be4fddf6598a079a20", "target": 0, "func": "static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,\n\n                sb_int8_array coding_method, int nb_channels,\n\n                int c, int superblocktype_2_3, int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    // This should never happen\n\n    if (nb_channels <= 0)\n\n        return;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 21311, "substitutes": {"tone_level_idx": ["tone_level_Idx", "tone_level_iden", "tone_level__idn", "tone_level_listg", "tone_levelllistpx", "tone_level_idxes", "tone_level_idsv", "tone_level3idox", "tone_level_ing", "tone_levellidb", "tone_levellidg", "tone_level_idev", "tone_level_Idg", "tone_level_timep", "tone_level_idep", "tone_level3timeg", "tone_levelllistb", "tone_level2idxs", "tone_level_idp", "tone_level2idx", "tone_level__idx", "tone_level__ing", "tone_level_idsxes", "tone_level__idxs", "tone_level_idsxs", "tone_level_inxs", "tone_levelllistx", "tone_level_idexs", "tone_level_idsox", "tone_level2idsg", "tone_level_inx", "tone_level_Idxs", "tone_level_timex", "tone_level2idn", "tone_level_idpx", "tone_level2idsxs", "tone_level3idp", "tone_level__idg", "tone_level__inx", "tone_level_idsx", "tone_level_timeg", "tone_level_idn", "tone_levelllistg", "tone_level3timex", "tone_level_idv", "tone_level__idxes", "tone_level_idsn", "tone_level_idsp", "tone_level2idsn", "tone_level_Idb", "tone_level_idex", "tone_level__inxs", "tone_level_idsg", "tone_level2idg", "tone_level3idx", "tone_level_listb", "tone_level_idg", "tone_level3timeox", "tone_level_listx", "tone_level_inn", "tone_level3idg", "tone_levellidx", "tone_level_ideg", "tone_level_listpx", "tone_level_idb", "tone_level_Idpx", "tone_levellidpx", "tone_level_Idn", "tone_level3timep", "tone_level__idp", "tone_level_idexes", "tone_level2idsx", "tone_level_idxs", "tone_level_timeox", "tone_level_idox", "tone_level__inn"], "tone_level_idx_temp": ["tone_level_idx0temp", "tone_level_idg_tmp", "tone_level_idx_current", "tone_level_idx2buffer", "tone_level_idx_local", "tone_level_idz_tmp", "tone_level_idg_current", "tone_level_idz_local", "tone_level_idg_buffer", "tone_level_idz_current", "tone_level_idg_result", "tone_level_idx2tmp", "tone_level_idg_temp", "tone_level_idx_Temp", "tone_level_idx0local", "tone_level_idz_temp", "tone_level_idx_result", "tone_level_idg_Temp", "tone_level_idx_tmp", "tone_level_idx2current", "tone_level_idg_cache", "tone_level_idx_cache", "tone_level_idx0current", "tone_level_idx2temp", "tone_level_idx_buffer", "tone_level_idx0tmp"], "coding_method": ["coding_data", "codingamedata", "codingameoptions", "coder_name", "coder_options", "codingamemethod", "coder_method", "coding_options", "codingamename", "coder_data", "coding_name"], "nb_channels": ["nb_Champles", "nb_chanamples", "nb_cannels", "nb_chars", "nb_Chones", "nb_chones", "nb_chanairs", "nb_achans", "nb_chairs", "nb_Chars", "nb_multipliers", "nb_achones", "nb_Chairs", "nb_Channels", "nb_cars", "nb_chiers", "nb_champles", "nb_cairs", "nb_chans", "nb_achannels", "nb_multiplans", "nb_Chans", "nb_multiplones", "nb_Chiers", "nb_chanannels", "nb_camples", "nb_chanans", "nb_multiplannels", "nb_achiers", "nb_chanars", "nb_cans"], "c": ["n", "t", "p", "rc", "cb", "f", "m", "h", "ac", "ct", "d", "count", "cs", "bc", "cv", "C", "cod", "lc", "cm", "sc", "cache", "cc", "b", "v", "l", "fc", "cp"], "superblocktype_2_3": ["superblocktype_1_1", "superblocktype_1_3", "superblocktype_3_3", "superblocktype_2_1", "superblocktype_3_7", "superblocktype_2_0", "superblocktype_2x7", "superblocktype_2x0", "superblocktype_1_2", "superblocktype_2x2", "superblocktype_2x3", "superblocktype_3_1", "superblocktype_1_0", "superblocktype_3_2", "superblocktype_2_7", "superblocktype_2_2", "superblocktype_2x1"], "cm_table_select": ["cm_type_select", "cm_table2table", "cm_type_table", "cm_table2selection", "cm_type_selection", "cm_table_selection", "cm_table2filter", "cm_type_filter", "cm_table_filter", "cm_table2select", "cm_table_table"], "ch": ["chat", "che", "sch", "cho", "all", "chart", "he", "et", "m", "th", "count", "con", "ot", " CH", "cd", "cur", "batch", "cht", "fr", "hr", "och", "br", " Ch", "qu", "gr", "bt", "cr", "_", "work", "channel", "zh", "yet", "chan", "gb", "x", "i", "cs", "ih", "ph", "sc", "new", "g", "chron", "chy", "b", "ech", "att", "cp", "ht", "vc", "chn", "chrom", "CH", "y", "tch", "atch", "hw", "z", "Ch", "sh", "kh", "sky", "gh", "ca", "uch", "ut", "cha", "history", "mk", "er", "mot", "cb", "ach", "chi", "ich", "h", "sk", "ac", "ct", "conn", "arch", "q", "cor", "ur", "ah"], "sb": ["sch", "esm", "arb", "erb", "sat", "jp", "zb", "sn", "bh", "ub", "sv", "ssl", "sw", "wb", "hs", "kb", "bt", "bb", "abb", "eb", "si", "hh", "bps", "ji", "gb", "ha", "bs", "ib", "lp", "SB", "bn", "bis", "nb", "se", "sm", "ibl", "fi", "db", "sc", "stab", "ebin", "usb", "sg", "b", "bj", "sit", "bi", "sys", "ssh", "sa", "bf", "osp", "sf", "sd", "gc", "mb", "lb", "isi", "fb", "s", "sr", "bg", "sh", "kh", "ja", "sp", "orb", "buff", "sbm", "shop", "shell", "serv", "ij", "dh", "rb", "cb", "src", "bc", "bot", "sth", "sam", "meg", "pb", "typ", "jj", "bp", "gov"], "j": ["bi", "ij", "aj", "n", "er", "p", "jac", "ht", "it", "jit", "ion", "jl", "m", "ix", "y", "ji", "bs", "pt", "note", "ot", "i", "eg", "str", "jp", "z", "fr", "ng", "jc", "bo", "k", "q", "jump", "J", "oj", "br", "pr", "jet", "ia", "ja", "db", "ju", "adj", "jas", "js", "jo", "g", "at", "sp", "job", "ik", "obj", "uj", "kj", "json", "kid", "je", "jj", "b", "v", "bj", "dj", "att", "l"], "tmp": ["perm", "td", "sup", "resp", "mk", "t", "p", "tt", "out", "txt", "Temp", "yet", "msg", "cb", "mmm", "mm", "MP", "qq", "gm", "aaa", "etc", "prep", "pkg", "src", "trap", "mp", "copy", "empty", "timeout", "test", "xy", "emp", "temp", "cmp", "snap", "ip", "result", "buf", "prop", "img", "prime", "amp", "sp", "appy", "buff", "np", "cmd", "tc", "obj", "cache", "pre", "pos", "tm", "jj", "cp", "tf", "attr"], "acc": ["perm", "ACC", "alloc", "cont", "sum", "ac", "arr", "fac", "aff", "aa", "alpha", "angle", "op", "cell", "adj", "sc", "inc", "amp", "conf", "cache", "mod", "rec", "cc", "att", "ca", "attr", "eff"], "esp_40": ["espxw", "ampxw", "esp8w", "espxtemp", "esp8mult", "amp_40", "espxmult", "esp840", "ampxtemp", "esp_w", "amp_mult", "esp_temp", "esp8temp", "ampx40", "espx40", "ampxmult", "esp_mult", "amp_temp", "amp_w"], "comp": ["perm", "sup", "com", "rc", "comment", "app", "qq", "change", "prep", "omp", "cmp", "proc", "ip", "img", "op", "butt", "Comp", "ctx", "cond", "component", "amp", "buff", "conf", "cache", "mod", "fc", "cp", "attr"], "add1": ["plus2", "attach1", "dd1", "ddOne", "add91", "Add3", "plusOne", "add100", "plus5", "Add100", "attachOne", "append2", "attach100", "Add1", "ADDOne", "addOne", "dd2", "Add4", " add5", "AddOne", "append91", "Add91", "plus1", " addOne", " add100", "ADD1", "add5", "append4", "Add2", "append1", " add91", "ADD2", "attach3", "Add5"], "add2": ["create6", "dd1", "Add6", "Add3", " add02", "Add1", "add42", "Add14", "dd4", "create2", "adder4", "create404", "addTwo", "Add4", "dd2", "att2", "pad404", "create1", "pad42", "att404", "add6", "create42", "att42", "createTwo", " add14", "add404", "Add2", "pad2", "add14", "adder14", " add6", "adder2", "add02", "dd3", "attTwo", "create02", "padTwo", "Add02"], "add3": ["find1", "ad3", "ext3", "attach43", "build3", "add103", "Add43", "apply003", " addthird", "create3", "make1", "apply3", "ext1", "findIII", "ad6", "findthird", "attach1", "createIII", "Add3", "makethree", "add43", " add02", " add003", "make3", "addIII", "make02", "add5", "ADD3", "ext5", "build1", " addIII", "ext6", " addThree", "ad1", "condThree", "cond1", " add03", "ADD4", "ADD43", "Add4", "create1", " add103", "Add2", "addThree", "add03", "ADD2", "add003", "add02", "ord3", "build02", "createthird", "apply103", " addthree", "addthree", "apply03", "attach5", "ad5", "addthird", "ord03", "cond43", "find3", "add6", "ord103", "cond3", "attachThree", "attach6", "ord003", "buildthree", "attach3", " add43"], "add4": ["ddFour", "addfour", "dd1", "Add6", " add04", "add9", "dd7", "append2", "Add04", "addFour", "Add1", "load4", "join4", "dd4", "ADD4", " addfour", "attachfour", "load04", " add7", "Add4", "dd2", "attach4", " add9", "append04", "add6", "Add7", "attach2", " addFour", "add7", "append4", "join9", "Add2", "attachFour", "add04", "attach6", "join3", "ADD04", " add6", "attach3", "ADD3", "dd3", "joinfour", "attach9", "load3"], "multres": ["modRES", "divRES", "modres", "_RES", "putRes", "_res", "_vals", "_Res", "putRES", "modRes", "divres", "putres", "modvals", "putvals", "divRes", "divvals"]}}
{"project": "qemu", "commit_id": "1e577cc7cffd3de14dbd321de5c3ef191c6ab07f", "target": 0, "func": "void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                        int flags)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    int i;\n\n\n\n    if (is_a64(env)) {\n\n        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);\n\n        return;\n\n    }\n\n\n\n    for(i=0;i<16;i++) {\n\n        cpu_fprintf(f, \"R%02d=%08x\", i, env->regs[i]);\n\n        if ((i % 4) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n        else\n\n            cpu_fprintf(f, \" \");\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t xpsr = xpsr_read(env);\n\n        const char *mode;\n\n\n\n        if (xpsr & XPSR_EXCP) {\n\n            mode = \"handler\";\n\n        } else {\n\n            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {\n\n                mode = \"unpriv-thread\";\n\n            } else {\n\n                mode = \"priv-thread\";\n\n            }\n\n        }\n\n\n\n        cpu_fprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\",\n\n                    xpsr,\n\n                    xpsr & XPSR_N ? 'N' : '-',\n\n                    xpsr & XPSR_Z ? 'Z' : '-',\n\n                    xpsr & XPSR_C ? 'C' : '-',\n\n                    xpsr & XPSR_V ? 'V' : '-',\n\n                    xpsr & XPSR_T ? 'T' : 'A',\n\n                    mode);\n\n    } else {\n\n        uint32_t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n", "idx": 21324, "substitutes": {"cs": ["csv", "rc", "ics", "ks", "icks", "css", "ys", "ix", "cus", "ns", "ss", "ps", "bs", "sts", "fs", "rs", "cv", "c", "ds", "s", "ec", "ctx", "ls", "CS", "ms", "vs", "ces", "hs", "sc", "cf", "js", "es", "ts", "acs", "cc", "cks", "cp", "cas"], "f": ["fn", "fx", "t", "p", "out", "bf", "r", "o", "h", "ef", "sf", "fo", "d", "fe", "uf", "fm", "e", "um", "fs", "fw", "c", "fb", "s", "fp", "fr", "ff", "ft", "full", "q", "fi", "fa", "rf", "cf", "xf", "g", "ile", "fd", "fl", "form", "F", "lf", "b", "l", "fc", "v", "file", "tf", "w"], "cpu_fprintf": ["cpu_cprint", "cpu_fxrep", "cpu_fpprintln", "cpu_dformat", "cpu_dapply", "cpu_rprint", "cpu_fwpdf", "cpu_fxprintf", "cpu_lprintln", "cpu_dpush", "cpu_fpdf", "cpu_reprint", "cpu_cpdf", "cpu_mapply", "cpu_mprint", "cpu_tprintf", "cpu_fprintln", "cpu_fwrite", "cpu_drep", "cpu_reprintf", "cpu_rprintf", "cpu_dprint", "cpu_fwprint", "cpu_mprintln", "cpu_dprintf", "cpu_cwrite", "cpu_rprintln", "cpu_cprintf", "cpu_rwrite", "cpu_fpprintf", "cpu_mprintf", "cpu_frint", "cpu_fformat", "cpu_reprintln", "cpu_fprint", "cpu_crep", "cpu_drint", "cpu___fpprintln", "cpu_tprint", "cpu_fpprint", "cpu___frint", "cpu_rformat", "cpu_dwrite", "cpu_tprintln", "cpu_fwprintf", "cpu_cformat", "cpu_dprintln", "cpu_fxprint", "cpu___fpprintf", "cpu___fprint", "cpu___fpprint", "cpu_tapply", "cpu_fwformat", "cpu_lprintf", "cpu___fprintln", "cpu_fxformat", "cpu_lformat", "cpu___fprintf", "cpu_frep", "cpu_fapply", "cpu_lprint", "cpu_fpush", "cpu_dpdf", "cpu_repush"], "flags": ["ports", "bits", "heads", "settings", "kind", "alf", "tags", "fee", "ints", "FLAG", "eps", "mask", "fs", "gs", "args", "comments", "frames", "files", "status", "details", "atts", "ms", "cond", "ats", "properties", "types", "pins", "limits", "ts", "ants", "Flags", "features", "ags", "ents", "options", "fps", "members", "flag", "ensions", "lag", "fields"], "cpu": ["core", "gpu", "ck", "processor", "process", "cn", "stat", "ack", "rom", "gc", "bench", "conn", "cu", "cv", "c", "arch", "proc", "hw", "mac", "setup", "ork", "pu", "ctx", "clock", "aco", "bean", "ka", "cf", "mem", "mx", "ola", "anc", "util", "pc", "tc", "CPU", "linux", "nc", "comp", "cp", "aq"], "env": ["esm", "et", "ce", "desc", "equ", "ten", "err", "dn", "eg", "vm", "worker", "server", "sw", "pe", "map", "oe", "ew", "v", "ev", "engine", "der", "context", "te", "enc", "e", "esc", "environment", "vs", "db", "self", "sc", "dev", "mem", "erd", "runner", "esp", "era", "cmd", "eng", "net", "scope", "qt", "ner", "pkg", "ei", "cv", "outer", "den", "ec", "proc", "hw", "ctx", "spec", "kernel", "config", "docker", "conf", "obj", "nc", "shell", "attr", "er", "en", "end", "rc", "org", "window", "init", "inv", "ie", "ea", "ext", "conn", "manager", "hl", "console", "viron", "priv", "js", "eu", "nv", "cfg"], "i": ["bi", "ij", "t", "p", "is", "\u0438", "ic", "it", "number", "si", "o", "di", "me", "index", "ai", "iu", "xi", "m", "ix", "list", "ims", " I", "multi", "ei", "zi", "key", "x", "id", " ii", "sim", "ind", "gi", " ti", "I", "c", "span", "ami", "qi", "ki", "ti", "j", "ini", "batch", "ip", "asi", "cli", "li", "ui", "ms", " bi", "oi", "in", "ci", " j", "g", " v", " pi", "mi", "ii", "pi", "v", "point"], "mode": ["master", "name", "time", "use", "move", "state", "model", "message", "role", "me", "mm", "te", "m", "device", "menu", "mid", "format", "ase", "key", "none", "style", "power", "mask", "code", "layout", "meta", "MODE", "md", "language", "mate", "show", "mac", "status", "lock", "mt", "password", "module", "position", "pe", "mit", "stage", "direction", "phrase", "sequence", "mem", "config", "command", "zero", "ode", "Mode", "mod", "metadata", "type"], "ns_status": ["ims_source", "ns_spin", "ns_source", "ns__status", "nz_atus", "ns_Status", "ns__source", "nz_status", "ims_Status", "ims_status", "ns_str", "ims_str", "ims__status", "ims__str", "ns__Status", "ims__source", "ims__Status", "nz_stats", "ns_stats", "ns__str", "nz_spin", "ns_atus"]}}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n    int ret = 0;\n\n\n\n    trace_vmstate_load_state(vmsd->name, version_id);\n\n    if (version_id > vmsd->version_id) {\n\n        error_report(\"%s: incoming version_id %d is too new \"\n\n                     \"for local version_id %d\",\n\n                     vmsd->name, version_id, vmsd->version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        if (vmsd->load_state_old &&\n\n            version_id >= vmsd->minimum_version_id_old) {\n\n            ret = vmsd->load_state_old(f, opaque, version_id);\n\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n\n            return ret;\n\n        }\n\n        error_report(\"%s: incoming version_id %d is too old \"\n\n                     \"for local minimum version_id  %d\",\n\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if (vmsd->pre_load) {\n\n        int ret = vmsd->pre_load(opaque);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n    while (field->name) {\n\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n\n        if ((field->field_exists &&\n\n             field->field_exists(opaque, version_id)) ||\n\n            (!field->field_exists &&\n\n             field->version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n", "idx": 21335, "substitutes": {"f": ["fx", "p", "t", "bf", "r", "o", "m", "ef", "h", "sf", "fed", "fee", "d", "con", "uf", "fm", "e", "fs", "fw", "c", "fb", "fp", "fr", "fi", "self", "rf", "xf", "cf", "ile", "fd", "form", "F", "af", "lf", "b", "l", "v", "fc", "file", "tf", "w"], "vmsd": ["vimsdis", "vcmsgd", "vejsd", "vemsord", "verbsdc", "viewmmdis", "vmsds", "vmosdi", "vmsdc", "vjsdi", "vbsdc", "cvmsd", "vminsmd", "vmemsord", "vmemsmd", "varmsde", "revcmsdx", "vmmds", "viewmsds", " vmssd", "vminsdis", "ventsdo", "veksdis", "evomsord", "vmossd", "vantsD", "vejsda", "vemsd", "avimsdis", "vatsd", "vmll", "vportssd", "vmsdh", "vminssd", "vmmdid", "vcmsds", "vvsdc", "vcmsdx", "vmyd", "vejssd", "vinsdm", "verbsd", "vmsl", "vinsds", "vinsd", "evmsde", "vlsdl", "cvatesl", "vcmsd", "vmsD", "vistsds", "vinsda", "mmesd", "vmersd", "vMSds", "vermsl", "vminsds", "vsysden", "vmsdi", "vmmdis", " vmsord", "vermsds", "vbsl", "varmsdo", "vermsdid", " varmsd", "mmesdh", "cmsdm", "vantsd", "vstatsisd", "vmyda", "vMSda", "cvatesd", "vmlgd", "verbsds", "cvatesda", "vmsisd", "revcmsds", "vemsdl", "vmydi", "vearsmd", "vatsbd", "mmesl", "evmsord", "vmesdm", "vistsgd", "vjsD", "vamsord", "vstatsdk", "varmsd", "mmsd", "vjsd", "vmmsda", "vantsdh", "vmld", "vyssd", "vatsden", "vantsda", "vmosd", "vermsD", "vksdis", "evomssd", "vcamsd", "vtsda", "vtsd", "cmesd", " vjsd", "vatsdid", "vMSD", "vmemsd", "vcmsdis", "vmesdx", "vminsdk", "vejsdl", "cmsd", "vamsbd", "viasdh", "revcmsdid", "vemsda", "vminsbd", "vmsde", "vksd", "cmesdm", "vmesl", "vamsd", "vmjsd", "vmosdh", " vmsdx", "vmersds", "vomssd", "vportsdl", "vmsda", "vminsden", "cmesda", "vmesgd", "vjsda", " vmsde", "vamsgd", "vistsdc", "veksdi", "vomsd", "vmosD", "ventsdx", "viasda", "vmjsds", "avmsdk", "vistsd", "revmsd", "vemsmd", "vcmsdc", "vvsdo", "vmemsds", "vatesd", "vimsdk", "cmsda", "vlssd", "vjsds", "avmsd", "vamsdm", "vmlda", "vmosord", "vjssd", " vjssd", "vmsdx", " varmsdx", "vemssd", "mmsl", " vmdsd", "verantsd", " vmdbd", "vatesl", " vjsdc", "vbsd", " vmdd", "vysd", "veratsdid", "vmjsD", "vminsd", "viasl", "revcmsd", "vemsdi", "verantsdi", "vearsd", "vatesgd", "veksda", "ventsd", "vysdo", "evomsd", "revmsds", "vermsbd", "evmssd", "vomsord", "vmmsmd", "vminsord", "mmsda", "vjsdc", "vksda", "vmsdid", "vmersdx", " varmsde", "vmersdo", "viewmmd", "vMSdis", "vmesda", "vamsds", "vermsdi", "vomsde", "vvssd", "vMSd", "vjsdl", "vmmd", "vmssd", "vbsds", "ventsde", "vmesdc", "vminsde", "vermsd", "veksd", "avmsisd", "vermsdc", "vmsdo", "revmsdid", "revmsdx", "vmdsd", "verbsl", "vksdi", "vcamsdc", "ventsdh", "avimsdk", "vmmsd", " varmsdo", "vmersde", "vimsisd", "vlsda", "vtsds", "vmsdl", "evmsd", "vminsdid", "vysdc", "cmesds", "vmesdh", "vtsdc", " vmsbd", "vantsdis", "vportsda", "cvatesgd", "vemsdis", "vsysdid", "vmjsda", "vmmsds", " vmdord", "vmsdis", "viewmmds", "vermsdh", "vearsord", "varmsdx", "avmsdis", " vjsdo", "vmydis", "vtsD", "vlsd", "vearsds", "vmsdk", "verantsD", "avimsd", "cvmsgd", "viewmsd", "vamsda", "vmesds", "vantsdi", "ventsda", "cmsds", "vmdbd", "vcamsds", "mmesda", "vmmsord", "vminsisd", "vjsdh", "vMSdid", "vcmsdid", "vamsdc", "veratsbd", "avimsisd", " vmsdc", "vemsds", "cvmsda", "vmosbd", "vmesdid", "vstatsdis", "mmsdh", "vvsd", "vstatsd", "vmesd", "vmsden", "vmsmd", "viewmsdid", "cvmsl", "ventsl", "veratsd", "vjsdo", "vsysd", "vcamsgd", "vsysbd", "vamssd", "vmdord", "veratsden", " vmsdo", "vmsdm", "vmsord", "vmersdid", "vermsden", "vmsgd", "viasd", "vimsd", "vatesda", "vtsl", "evomsde", "verantsdh", "vemsde", "vmsbd", "vmdd", "viewmsdis", "vportsd", "viewmmdid", "vmmsD"], "opaque": ["chatile", "ipatile", "operque", "operacity", "opent", "ipaque", "obaque", "Opaque", "itaco", "Opaques", "compacity", "opaco", "ipque", "opque", "chacity", " opaques", "oboch", "hopacity", "ipacity", "ipent", "opsent", "itaque", "imque", "opity", "imaques", "opsole", "pacity", "opacity", "opaques", " opempty", "obque", "pque", "opsque", " opsole", "compoch", "alaques", "compque", "opsaques", "alaque", "hopaque", "ipaques", "Opsolete", "psole", " opque", "imacity", "imaque", "hopempty", "chaque", "opempty", "compaque", "patile", "opsaque", "obacity", "popaques", "opatile", "choch", "ality", "operaques", "operity", "opsolete", "chaco", "obsolete", "hopsole", "obatile", "opoch", " opacity", "alatile", "itacity", "itatile", "popque", "pempty", "paque", "popsolete", "obity", " opent", "chque", "obaco", "popaque", "Opque", "operatile", "operaque", "obaques"], "version_id": ["versionxurl", "Version_type", "vision_id", "vision_long", "version_ip", "version_source", " version_if", "version____name", "vision1number", "versionityuid", "version___ad", "version___id", "versionxid", "Version_id", "version_ID", "vision_url", "version____ad", "versionTheb", "versioningpid", "version_oid", "version_url", "version_d", "versionetyid", "version_name", "vision_b", "version_pid", "module___id", " version_Id", "version1oid", "versionablebit", " version_info", "version_ide", "version2b", "versionThelong", "vision_mid", "versionWid", "node_name", "versioninginfo", " version_ids", "version_ad", "versionableids", "module_oid", " version_no", "version___oid", "version_type", "vision___id", "nodeetyname", "versionTheit", "versionetyname", "version2info", "versionableif", " version_uid", "version_flag", "nodeetyflag", "version2no", "version____source", "version_ids", "version2ids", "version_long", "version____id", "vision___ad", "vision_it", "versionWip", "version1mid", "Version_ID", "module___mid", "nodeetyid", "vision_number", "version_bit", "versionableid", "version_if", "vision_part", "versioningid", "vision___ids", "vision_i", " version_pid", "module___oid", "version2it", "version____part", "version____flag", "node_flag", "versionityif", "version_b", "versionxip", "vision_ad", "node_source", "vision1id", "versionWurl", "vision___part", "versionWi", "version1id", "version___mid", "version2id", "vision1mid", "version____ids", "versionetysource", "vision1oid", "module___d", "version_part", "version___d", "version_no", "versionetyflag", " version_bit", "versionityid", "Version_ids", "vision_oid", "version1number", "version___ids", "version_Id", "version_uid", "module_id", "module_mid", "module_d", "nodeetysource", "version_i", "versionxi", "node_id", "version_info", "version_it", "version_mid", "version_number", " version_ide", "vision_ids", "version___part", "vision_ip", "versionTheid", "version2long"], "field": ["value", "pair", "FIELD", "fe", "user", "ld", "node", "function", "word", "server", "lc", "feature", "term", "job", "util", "command", "pointer", "file", "local", "type", "fields", "name", "param", "comment", "list", "relation", "sim", "level", "Field", "cell", "link", "part", "entry", "rule", "service", "dr", "prefix", "handler", "tag", "task", "table", "display", "label", "def", "arg", "mount", "operator", "var", "good", "spec", "child", "module", "storage", "match", "range", "store", "line", "comp", "attr", "man", "window", "member", "attribute", "add", "domain", "item", "key", "row", "section", "ment", "manager", "address", "form", "ield", "lf", "flag", "class", "option", "lib", "holder"], "first_elem": ["first_eld", "first_elelement", "first_element", "first_eelements", "first_neep", "first_Elements", "first_elementlement", "first_selement", "first_eep", "first_belement", "first_Elem", "first_eleld", "first_elements", "first_elelements", "first_elementlems", "first_ele", "first_elementlem", "first_nele", "first_Ele", "first_elems", "first_seom", "first_eleom", "first_elelem", "first_eeep", "first_eelem", "first_selem", "first_beld", "first_nelem", "first_nelements", "first_beom", "first_elementlements", "first_seld", "first_belements", "first_eele", "first_Eep", "first_elelems", "first_eom", "first_belems", "first_belem"], "i": ["n", "p", "t", "phi", "it", "si", "o", "set", "r", "io", "xi", "m", "y", "x", "e", "I", "c", "j", "ip", "z", "li", "ci", "mi", "ii", "pi", "l", "v", "b"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n\n                          int128_get64(section->size));\n\n}\n", "idx": 21348, "substitutes": {"listener": ["Listency", "parentener", "Lister", "listender", "wardener", "listening", "broadcaster", "broadency", "openers", "lister", "opening", "parentening", "broadener", "opender", "parentender", "listeners", "leners", "parenteners", "lener", "broader", "Listcaster", "listcaster", "Listener", "lender", "opener", "wardency", "listency", "warder", "lening", "wardcaster"], "section": ["definition", "Section", "setting", "tag", "comment", "sec", "desc", "member", "session", "piece", "format", "table", "pair", "description", "sect", "journal", "size", "connection", "portion", "ment", "sections", "version", "word", "cell", "event", "directory", "part", "entry", "storage", "component", "division", "region", "area", "page", "config", "job", "prefix", "sector", "block", "address", "mod", "option", "header"], "state": ["parent", "is", "start", "tag", "private", "list", "State", "stat", "check", "root", " region", "al", "init", "bar", "row", "info", "test", "states", " State", "status", "lock", "dict", "city", "cor", "map", "rule", "up", "area", " states", "config", "instance", "runner", "store", "next", "port", "STATE", "monitor", "local", "type"]}}
{"project": "FFmpeg", "commit_id": "d59591fb02c29b41e5b8d611160971a4493394c2", "target": 1, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 4;\n\n                                else\n\n                                    s->repeat_pict = 2;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}", "idx": 21374, "substitutes": {"s": ["n", "p", "t", "sys", "a", "sac", "os", "set", "ans", "r", "f", "h", "m", "ss", "ns", "ses", "stats", "ps", "bs", "cs", "sts", "e", "rs", "gs", "aws", "fs", "c", "i", "ds", "ctx", "spec", "ls", "q", "ssl", "sw", "sv", "ats", "vs", "hs", "self", "sc", "S", "js", "service", "es", "g", "ins", "sq", "ts", "sp", "sg", "less", "sb", "b", "as", "v", "so", "w"], "avctx": [" avjp", " avpid", "averpid", "wavctx", " avcv", "avconfig", "cvcontext", "afjp", "avcmp", "wavcv", "cvobj", "avcontext", " avcu", " avcb", "avecb", "avpid", "ovcu", "avcv", " avcfg", "avjp", "auxcu", "avecv", "auxcfg", "abtx", "avcb", "avercontext", "avecmp", "avtx", "avectl", "avctl", "averctx", "aveconfig", "AVconfig", "avetx", "avecontext", " avcmp", "avercb", "afcontext", "avepid", "ovcfg", "cvctx", "afctx", "auxctx", "ovcontext", "AVcontext", "abctx", "afconfig", "AVctl", "avecu", "afctl", "ovctx", " avobj", "avectx", "avcfg", "avcu", "wavcmp", "AVctx", " avctl", "auxcontext", " avcontext", "avejp", "abobj", "avobj", " avtx", "wavtx", "AVcu", "cvtx", "abcontext"], "buf": ["msg", "pack", "desc", "foo", "length", "err", "late", "uf", "batch", "lim", "ff", "uv", "br", "bh", "tmp", "wb", "emb", "pos", "next", "port", "padding", "loop", "orig", "list", "words", "bl", "conv", "bs", "Buffer", "data", "bytes", "vec", "nb", "deg", "xff", "burst", "true", "seq", "db", "mem", "cmd", "cam", "bin", "sofar", "b", "eng", "cp", "paste", "bf", "ref", "act", "pkg", "def", "cv", "str", "args", "fb", "proc", "ctx", "raw", "ptr", "bo", "bg", "buffer", "box", "buff", "np", "pool", "pg", "cache", "len", "cast", "boxes", "history", "mat", "rb", "end", "txt", "cap", "alloc", "func", "cb", "off", "bed", "go", "window", "read", "aka", "Buff", "src", "arr", "bc", "que", "img", "prop", "nm", "queue", "grad", "iter", "doc", "pb", "block", "bp", "ctr"], "buf_size": [" buf_area", "buf_area", "buf_length", "buf_space", "buf_speed", "buf_start", " buf_speed", "queue_length", "queue_start", "buf7speed", "buf7size", "queue_size", "buf7area", "queue_space"], "pc": ["td", "asc", "p", "vp", "vc", "rc", "py", " cs", "func", "dc", "pm", "tp", "iac", "PC", "disc", "ac", "pac", "sync", "gc", "ct", "conv", "pro", "pt", "pp", "lp", "mp", "cs", "bc", "wp", "cu", "cv", "c", "pa", "peer", "cl", "ec", "cmp", "proc", "psc", "ctx", "pr", "icc", "lc", "sc", "px", "pan", "amp", "anc", "mc", "pb", "cam", "xc", "tc", "soc", "acl", "cc", "pd", "pi", "fc", "ca", "cp", "pic"], "buf_end": ["buf_start", "uf_max", "buf_ending", " buf1ends", "bufjend", " buf1end", "buf1ended", "buf8length", "buf8end", "buf_ended", "buf1start", "buf1end", " buf1ended", "buf1ends", "buf_max", "buffer_ends", "buf_stop", "uf_ends", "buf8stop", " buf_start", "buffer_length", " buf_End", " buf_ending", " buf_ends", "buf_length", " buf1start", "bufjstart", " buf_ended", "bufjlength", "uf_start", "buf_End", "buffer_end", "buf_ends", "uf_stop", "bufjends", "buf8start", "uf_length", "uf_end", "buffer_start"], "start_code": ["startlyCode", "end_Code", "start_start", "startPno", "end_cue", "startedtype", "end_error", "startCCode", " start_type", "startPstart", "startPCode", "end_class", "startlytype", "startedclass", "startedcode", "startCtype", "startedCode", "startCclass", "start00error", "end_type", "start00cue", "end_code", " start_no", "start_no", "start_error", "start_class", "startCcode", "startlyvalue", "start00Code", "start_Code", "startlycode", "start00code", " start_start", "start_type", " start_value", "startPcode", " start_Code", "start_cue", "start_value"], "frame_rate_index": ["frame_rate_Index", "frame_rates_index", "frame_range_sequence", "frame_rates_ind", "frame_rat_Index", "frame_rates_number", "frame_rate____Index", "frame_range_index", "frame_length_Index", "frame_rat_index", "frame_rate____index", "frame_rat_interface", "frame_range_ind", "frame_length_image", "frame_rate_offset", "frame_rate_ind", "frame_range_number", "frame_rate_interface", "frame_rate____interface", "frame_rate_number", "frame_rate_image", "frame_rat_find", "frame_rates_Index", "frame_length_offset", "frame_rate_sequence", "frame_rate____find", "frame_length_index", "frame_rate_find"], "ext_type": ["exturedescription", "ext_method", "ext_description", "exturemethod", "xt_type", "xt_method", "exturetype", "exturetypes", "xt_description", "ext_types", "xt_types"], "bytes_left": [" bytesPlength", "bytes_length", "terms_limit", "bytesJLeft", "videos_lt", "terms1lo", "bytesJleft", "bytes_lo", "bytes10lt", "bytes_lf", "bytes10left", "bytes_Left", "bits_left", "bytesPright", "bytes1left", "bytes_right", " bytesPleft", "videos10lf", "bytesPlength", " bytesPcost", "bytes1limit", "bytes10lf", "terms1left", " bytes_length", "bytesJlt", "bytes10Left", "bytesswlimit", " bytesPright", "bytes_lt", "bytes_cost", "videos10Left", "videos_Left", "bytesswlo", "bytesPcost", "bytes_limit", " bytes_right", "terms_last", "bits_Left", "bytes1lo", "videos_left", "terms_lo", "terms1last", "bytesJlf", "videos10left", "bytesPleft", "terms1limit", " bytes_cost", "videos_lf", "bits_right", "bytesswlast", "bytes_last", "terms_left", "bytesswleft", "bytes1last", "videos10lt"], "frame_rate_ext_n": ["frame_rate_ext2N", "frame_rate_ex_N", "frame_rate_ex_n", "frame_rate_ext2n", "frame_rate_ex_i", "frame_rate_ext2i", "frame_rate_ext_num", "frame_rate_ext_i", "frame_rate_ext2num", "frame_rate_ext_N", "frame_rate_ex_num"], "frame_rate_ext_d": ["frame_rate_ext_dim", "frame_rate_ex_d", "frame_rate_ex_n", "frame_rate_ex_t", "frame_rate_ex_dim", "frame_rate_ext_t"], "picture_structure": ["picture_restructure", "picture_restruction", "picture_restage", "picture_constage", "picture_structype", "picture_structage", "picture_stype", "picture_structructure", "picture_struction", "picture_restype", "picture_construction", "picture_constructure", "picture_constype", "picture_stage", "picture_structruction"], "top_field_first": ["top_fields_last", "top_fields_first", "top_field_def", "top_field_part", "top_fields_def", "top_fields_part", "top_field_last"], "repeat_first_field": ["repeat_firstlyfields", "repeat_top_fields", "repeat_first_key", "repeat_firstlykey", "repeat_firstlyfield", "repeat_top_field", "repeat_top_key", "repeat_first_fields", "repeat_firstlyframe", "repeat_top_frame", "repeat_first_frame"], "progressive_frame": ["prolead_feature", "progressive_picture", "proleadfulfeature", "progressive_frames", "prolead_frames", "progressive2frames", "prolead_frame", "progressivefulframe", "progressive2feature", "proleadfulpicture", "progressive2frame", "progressive2picture", "proleadfulframes", "progressivefulframes", "progressivefulfeature", "progressive_feature", "progressivefulpicture", "proleadfulframe", "prolead_picture"], "horiz_size_ext": ["horiz_size_ex", "horiz_space_external", "horiz_size_external", "horiz_size2external", "horiz_size_extra", "horiz_space_ex", "horiz_space_extra", "horiz_size2ext", "horiz_size2extra", "horiz_size2ex", "horiz_space_ext"], "vert_size_ext": ["vert_size_ex", "vert_size1extra", "vert_size1ex", "vert_size_xt", "vert_size1xt", "vert_size_extra", "vert_size1ext"], "bit_rate_ext": ["bit_rate_exp", "bit_rate_max", "bit_rate2extra", "bit_rates_exp", "bit_rate2exp", "bit_rates_ext", "bit_rate2max", "bit_rate_extra", "bit_rate2ext", "bit_rates_extra", "bit_rates_max"]}}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "func": "static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n", "idx": 21383, "substitutes": {"data": ["master", "done", "parent", "p", "state", "msg", "writer", "message", "o", "list", "group", "device", "window", "session", "rel", "aw", "table", "d", "ata", "val", "image", "reader", "bus", "def", "mu", "info", "test", "batch", "buf", "DATA", "dat", "num", "db", "dev", "ta", "Data", "action", "block", "cache", "next", "da"], "off": ["then", "head", "pt", "on", "oa", "hand", "ff", "now", "open", "command", "zero", "after", "pos", "front", "point", "art", "fun", "start", "o", "info", "pres", "handle", "op", "dev", "new", "wo", "cmd", "att", "push", "t", "load", "it", "track", "ref", "ef", "Off", "def", "along", "aff", "buf", "raw", "un", "from", "obj", "ut", "ok", "offs", "en", "old", "out", "end", "det", "index", "set", "window", "OFF", "offset", "read", "before", "ext", "over", "j", "ap", "ord", "shift", "ent", "full", "offer", "of", "pad", "eff"], "sig": ["jsigh", "specature", "jsIG", "sess", "nign", "psigma", "spet", "set", "sigh", "jsigma", "gsess", "spig", "ssigs", " sIG", "psigs", "gsig", "specig", " sigma", " sign", "sature", "nif", " sif", "ssig", " sert", "psig", "sIG", "gsign", "psature", "spign", "ssigma", " set", "jsig", "nig", "specert", "specigs", "sigs", "ssature", "sif", "specigma", " sigs", "sert", " sigh", " sess", "sigma", "gsigs", "spif", "net", "sign"], "i": ["bi", "n", "phi", "t", "\u0438", "is", "p", "ic", "it", "ri", "si", "o", "di", "me", "iu", "ai", "io", "xi", "ix", "m", "y", " I", "init", "multi", "im", "zi", "ei", "ie", "x", "id", " ii", "sim", "ind", "gi", " ti", "I", "e", "s", "qi", "ti", "j", "ini", "ip", "z", "li", "k", "q", "ui", "ms", "fi", "gu", " ni", "oi", "iter", "ci", " j", "mi", "u", "ii", "port", "pi", "hi", "b", "v", "l", "uri"]}}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385, "substitutes": {"sc": ["comm", "asc", "sch", "isc", "rc", "usc", "Sc", "context", "sec", "dc", "ss", "ac", "gc", "ct", "irc", "cs", "bc", "uc", "c", "cl", "esc", "ec", "cmp", "scl", "psc", "osc", "ctx", "arc", "sh", "lc", "cms", "ch", "ci", "ocr", "anc", "sp", "pc", "SC", "tc", "cr", "acs", "acl", "nc", "cc", "sl"], "duration": ["uration", " Duration", "during", "time", "distance", "start", "foundation", "message", "number", "amount", "delay", "record", "minimum", "length", "window", "value", "database", "latest", "relation", "d", "description", "resolution", "relative", "document", "timeout", "Duration", "span", "until", "application", "seconds", "portion", "century", "future", "gravity", "quarter", "video", "frequency", "translation", "component", "sequence", "direction", "date", "after", "len", "period", "lag", "padding"]}}
{"project": "FFmpeg", "commit_id": "1197c04896423c6c7db65f69da8bc3865b26bb50", "target": 1, "func": "static void fft_calc_c(FFTContext *s, FFTComplex *z) {\n\n\n\n    int nbits, i, n, num_transforms, offset, step;\n\n    int n4, n2, n34;\n\n    FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;\n\n    FFTComplex *tmpz;\n\n    const int fft_size = (1 << s->nbits);\n\n    int64_t accu;\n\n\n\n    num_transforms = (0x2aab >> (16 - s->nbits)) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 2;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[0].re + tmpz[1].re;\n\n        tmp5 = tmpz[2].re + tmpz[3].re;\n\n        tmp2 = tmpz[0].im + tmpz[1].im;\n\n        tmp6 = tmpz[2].im + tmpz[3].im;\n\n        tmp3 = tmpz[0].re - tmpz[1].re;\n\n        tmp8 = tmpz[2].im - tmpz[3].im;\n\n        tmp4 = tmpz[0].im - tmpz[1].im;\n\n        tmp7 = tmpz[2].re - tmpz[3].re;\n\n\n\n        tmpz[0].re = tmp1 + tmp5;\n\n        tmpz[2].re = tmp1 - tmp5;\n\n        tmpz[0].im = tmp2 + tmp6;\n\n        tmpz[2].im = tmp2 - tmp6;\n\n        tmpz[1].re = tmp3 + tmp8;\n\n        tmpz[3].re = tmp3 - tmp8;\n\n        tmpz[1].im = tmp4 - tmp7;\n\n        tmpz[3].im = tmp4 + tmp7;\n\n    }\n\n\n\n    if (fft_size < 8)\n\n        return;\n\n\n\n    num_transforms = (num_transforms >> 1) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 3;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[4].re + tmpz[5].re;\n\n        tmp3 = tmpz[6].re + tmpz[7].re;\n\n        tmp2 = tmpz[4].im + tmpz[5].im;\n\n        tmp4 = tmpz[6].im + tmpz[7].im;\n\n        tmp5 = tmp1 + tmp3;\n\n        tmp7 = tmp1 - tmp3;\n\n        tmp6 = tmp2 + tmp4;\n\n        tmp8 = tmp2 - tmp4;\n\n\n\n        tmp1 = tmpz[4].re - tmpz[5].re;\n\n        tmp2 = tmpz[4].im - tmpz[5].im;\n\n        tmp3 = tmpz[6].re - tmpz[7].re;\n\n        tmp4 = tmpz[6].im - tmpz[7].im;\n\n\n\n        tmpz[4].re = tmpz[0].re - tmp5;\n\n        tmpz[0].re = tmpz[0].re + tmp5;\n\n        tmpz[4].im = tmpz[0].im - tmp6;\n\n        tmpz[0].im = tmpz[0].im + tmp6;\n\n        tmpz[6].re = tmpz[2].re - tmp8;\n\n        tmpz[2].re = tmpz[2].re + tmp8;\n\n        tmpz[6].im = tmpz[2].im + tmp7;\n\n        tmpz[2].im = tmpz[2].im - tmp7;\n\n\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp1 + tmp2);\n\n        tmp5 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 - tmp4);\n\n        tmp7 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp2 - tmp1);\n\n        tmp6 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 + tmp4);\n\n        tmp8 = (int32_t)((accu + 0x40000000) >> 31);\n\n        tmp1 = tmp5 + tmp7;\n\n        tmp3 = tmp5 - tmp7;\n\n        tmp2 = tmp6 + tmp8;\n\n        tmp4 = tmp6 - tmp8;\n\n\n\n        tmpz[5].re = tmpz[1].re - tmp1;\n\n        tmpz[1].re = tmpz[1].re + tmp1;\n\n        tmpz[5].im = tmpz[1].im - tmp2;\n\n        tmpz[1].im = tmpz[1].im + tmp2;\n\n        tmpz[7].re = tmpz[3].re - tmp4;\n\n        tmpz[3].re = tmpz[3].re + tmp4;\n\n        tmpz[7].im = tmpz[3].im + tmp3;\n\n        tmpz[3].im = tmpz[3].im - tmp3;\n\n    }\n\n\n\n    step = 1 << ((MAX_LOG2_NFFT-4) - 4);\n\n    n4 = 4;\n\n\n\n    for (nbits=4; nbits<=s->nbits; nbits++){\n\n        n2  = 2*n4;\n\n        n34 = 3*n4;\n\n        num_transforms = (num_transforms >> 1) | 1;\n\n\n\n        for (n=0; n<num_transforms; n++){\n\n            const FFTSample *w_re_ptr = ff_w_tab_sr + step;\n\n            const FFTSample *w_im_ptr = ff_w_tab_sr + MAX_FFT_SIZE/(4*16) - step;\n\n            offset = ff_fft_offsets_lut[n] << nbits;\n\n            tmpz = z + offset;\n\n\n\n            tmp5 = tmpz[ n2].re + tmpz[n34].re;\n\n            tmp1 = tmpz[ n2].re - tmpz[n34].re;\n\n            tmp6 = tmpz[ n2].im + tmpz[n34].im;\n\n            tmp2 = tmpz[ n2].im - tmpz[n34].im;\n\n\n\n            tmpz[ n2].re = tmpz[ 0].re - tmp5;\n\n            tmpz[  0].re = tmpz[ 0].re + tmp5;\n\n            tmpz[ n2].im = tmpz[ 0].im - tmp6;\n\n            tmpz[  0].im = tmpz[ 0].im + tmp6;\n\n            tmpz[n34].re = tmpz[n4].re - tmp2;\n\n            tmpz[ n4].re = tmpz[n4].re + tmp2;\n\n            tmpz[n34].im = tmpz[n4].im + tmp1;\n\n            tmpz[ n4].im = tmpz[n4].im - tmp1;\n\n\n\n            for (i=1; i<n4; i++){\n\n                FFTSample w_re = w_re_ptr[0];\n\n                FFTSample w_im = w_im_ptr[0];\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].re;\n\n                accu += (int64_t)w_im*tmpz[ n2+i].im;\n\n                tmp1 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].im;\n\n                accu -= (int64_t)w_im*tmpz[ n2+i].re;\n\n                tmp2 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].re;\n\n                accu -= (int64_t)w_im*tmpz[n34+i].im;\n\n                tmp3 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].im;\n\n                accu += (int64_t)w_im*tmpz[n34+i].re;\n\n                tmp4 = (int32_t)((accu + 0x40000000) >> 31);\n\n\n\n                tmp5 = tmp1 + tmp3;\n\n                tmp1 = tmp1 - tmp3;\n\n                tmp6 = tmp2 + tmp4;\n\n                tmp2 = tmp2 - tmp4;\n\n\n\n                tmpz[ n2+i].re = tmpz[   i].re - tmp5;\n\n                tmpz[    i].re = tmpz[   i].re + tmp5;\n\n                tmpz[ n2+i].im = tmpz[   i].im - tmp6;\n\n                tmpz[    i].im = tmpz[   i].im + tmp6;\n\n                tmpz[n34+i].re = tmpz[n4+i].re - tmp2;\n\n                tmpz[ n4+i].re = tmpz[n4+i].re + tmp2;\n\n                tmpz[n34+i].im = tmpz[n4+i].im + tmp1;\n\n                tmpz[ n4+i].im = tmpz[n4+i].im - tmp1;\n\n\n\n                w_re_ptr += step;\n\n                w_im_ptr -= step;\n\n            }\n\n        }\n\n        step >>= 1;\n\n        n4   <<= 1;\n\n    }\n\n}\n", "idx": 21386, "substitutes": {"s": ["t", "p", "bits", "a", "r", "os", "f", "m", "h", "ns", "ss", "sf", "ses", "bs", "cs", "sts", "e", "gs", "fs", "rs", "c", "space", "ds", "scl", "q", "sv", "sw", "ats", "hs", "self", "S", "js", "es", "xs", "g", "sq", "ts", "conf", "sb", "w"], "z": ["t", "p", "zip", "rez", "out", "zh", "zes", "zz", "os", "zo", "f", "zy", "m", "zone", "y", "window", "ze", "gz", "d", "zi", "tz", "x", "nz", "ez", "az", "c", "j", "uz", "now", "q", "hz", "Z", "iz", "storage", "zer", "g", "yz", "zero", "iaz", "b", "zos", "v", "zen", "cz"], "nbits": ["cnwords", "ncwords", "numbs", "Nbs", "cnpoints", " nbytes", " nbs", "cnbytes", "Nbit", "dbits", "nwords", " nwords", "nbit", "cnbits", "nints", " nbit", " nints", "numbits", "numbit", "dbytes", "dints", "ncbytes", "ncbits", " npoints", "ncpoints", "Nbits", "mbs", "mbytes", "mints", "nbs", "nbytes", "npoints", "dbs", "mbits"], "i": ["bi", "ij", "p", "t", "ic", "it", "si", "index", "iu", "ai", "f", "m", "ix", "x", "I", "c", "j", "ip", "k", "ci", "g", "ii", "pi", "b", "v", "l"], "n": ["fn", "m", "dn", "count", "on", "span", "N", "no", "batch", "nu", "sn", "k", "br", "ex", "v", "local", "name", "gn", "o", "cn", "ns", "x", "note", "ind", "ann", "nb", "names", "num", "new", "g", "ren", "ln", "norm", "network", "net", "t", "rn", "number", "r", "nr", "y", "nw", "nor", "nn", "c", "ni", "un", "nt", "wn", "nc", "l", "el", "nan", "p", "en", "out", "index", "al", "ul", "init", "na", "hn", "conn", "j", "ng", "pn", "ne", "ll", "yn", "mn", "an"], "num_transforms": ["num_Transits", "num_subforms", "num_interactions", "num_ranslations", "num_Transmissions", "num_ransforms", "num_interlations", "num2inputposes", "num_Transposes", "num2transmissions", "num_timesposes", "num_Transform", "num_Transfixes", "num_transits", "num2transposes", "num_inputforms", "num_Transforms", "num_Transactions", "num_ransactions", "num_ransitions", "num_ransits", "num2transforms", "num2inputmissions", "num2translations", "num_interforms", "num_subitions", "num_ransform", "num_ransmissions", "num_transactions", "num_Transitions", "num_subfixes", "num_transposes", "num_interits", "num_surposes", "num_transfixes", "num_transitions", "num_ransmaps", "num_intermissions", "num2inputforms", "num2inputlations", "num_timeslations", "num_timesforms", "num_rendmissions", "num_inputmissions", "num_submissions", "num_rendmaps", "num_transform", "num_renditions", "num_surform", "num_timesmissions", "num_surforms", "num_ransfixes", "num_translations", "num_transmissions", "num_surmissions", "num_ransposes", "num_Translations", "num_inputlations", "num_inputposes", "num_rendforms", "num_Transmaps", "num_transmaps"], "offset": ["origin", "end", "office", "start", "stop", "print", "et", "o", "index", "Offset", "set", "delay", "force", "off", "length", "seed", "attribute", "transform", "window", "init", "order", "debug", "original", "style", "ot", "hop", "skip", "timeout", "onet", "slot", "initial", "reset", "size", "adjusted", "lock", "shift", "extra", "align", "link", "position", "seek", "padding", "operation", "ocation", "entry", "frequency", "location", "scroll", "error", "block", "address", "pos", "pointer", "pad", "encrypted", "ut", "point", "angle", "alias"], "step": ["loop", "load", "start", "stop", "set", "delay", "window", "scale", "sd", "power", "skip", "weight", "data", "dim", "sleep", "batch", "Step", "snap", "shift", "height", "chain", "shape", "error", "steps", "save", "ffff", "wait"], "n4": ["N3", "x1", "x6", "x4", "max1", "n6", "max4", "n3", "x3", "max3", "N6", "max6", "n1", "N1", "N4"], "n2": ["N3", " n3", " n25", "N02", "note3", "n25", "note25", "n02", "n3", "note2", "note02", "N2", "N25", " n02"], "n34": ["n03", "N3", " n3", "N35", " n23", "int3", "N23", "n3", "n35", " n03", "int03", " n35", "int35", "N03", "int23", "n23"], "tmp1": ["prop1", " tmp01", "pot2", "mp01", "temp1", "prop2", "cmp5", "perm5", "temp01", " tmpf", "perm3", "perm1", "temp3", "temp2", "tmpxy", "mpf", "mpxy", " tmp_", "prop3", "cmp1", "cmp2", "mp5", "tmpf", "perm2", "tcxy", "tmp_", "tc_", "cmp3", " tmpxy", "tcf", "mp2", "perm01", "pot1", "mp1", "mp3", "pot3", "mp_", "tmp01", "cmp01"], "tmp2": ["mp02", "table02", "temp1", "timeout4", "obj3", "buffTwo", "timeout02", "temp2", "timeout3", "buff2", "temp5", "mp4", "table2", "buff5", "tempTwo", "txt5", "cache1", "tmp02", "obj2", "timeout2", "mp5", "table4", "txt3", "cache2", "cache02", "table3", "txt2", "tmpTwo", "obj5", "obj4", "txt4", "mp2", "mp1", "mp3", "temp02", "buff02", "mpTwo"], "tmp3": ["prop1", "rep6", "timeout83", "mpThree", "pkg1", "tdThree", "pkg3", "timeout4", "mp6", "td03", "prop103", "temp3", "tmp03", "temp03", "mp03", "timeout3", "temp5", "pkgCommand", "mp4", "rep1", "cache4", "tmp103", "tmpThree", "tmp83", "prop3", "tempThree", "cache5", "rep3", "td3", "cache3", "timeoutCommand", "mpCommand", "mp103", "mp5", "rep103", "mp7", "timeout7", "prop6", "mp83", "timeout5", "cache7", "mp1", "mp3", "tmpCommand", "timeout1", "pkg83", "td5"], "tmp4": ["mp42", "mp44", "mp6", "temp44", "temp2", " tmp42", "temp42", "mp4", "cache4", "proc44", "cache6", "obj2", "obj44", "temp4", "tmp44", "mp5", "proc4", "cache2", "tmp42", "proc5", "tt4", "tt44", "obj4", "tt5", "mp2", "tt6", "obj6", " tmp44", "proc6"], "tmp5": ["cmp5", "top6", "top4", "top5", "mp6", "mpFive", "table5", "table6", "top2", "mp4", "table2", "cache4", "app4", " tmp45", "cache6", "cache1", "mp45", "time6", "cache5", "cmpFive", "mp5", "app5", "table4", "app2", "app6", "cmp45", " tmpFive", "tmp45", "time5", "cmd6", "time4", "time1", "obj5", "cmd1", "cmd5", "mp1", "obj1", "tmpFive", "obj6"], "tmp6": ["cmp5", "tmp68", "pkg5", "pkg6", "pot96", "mp6", "td4", "pot6", "tmp72", "td8", "pkgSix", "mp68", "pot8", "temp5", "mp4", "td6", "cache4", "cmp72", "temp6", "cache6", "cmp8", "cache5", "pkg72", "mp5", "pot72", " tmp68", "cmp6", "temp8", "tempSix", "cmp96", "pkg8", "cmp68", "tmpSix", "pkg96", "cache8", "tmp96", "mp8", "mpSix", "td5"], "tmp7": ["cmp7", "cmp5", "tu5", "tu7", "tu8", "cmp77", "mp6", "test7", "img5", "temp77", "temp3", "timeout3", "temp5", "temp7", "img7", "mp4", "cache4", "temp6", "cache6", "timeout6", "cmp8", "cache5", "mp5", "cmp6", "mp7", "temp8", "img8", "timeout7", "img4", "test8", "cmp3", "tu77", "tmp77", "timeout5", "cache8", "cache7", "test6", "mp8", "test4"], "tmp8": ["cmp7", "mp15", "mp80", "temp80", "mp9", "tmp15", "mp6", "tmpail", " tmp08", "temp2", "td8", "cp6", "proc80", "html6", "proc9", "tar08", "td6", "temp6", "tmp08", "cmp8", "temp08", "tmp80", " tmpail", "tar8", "html7", "cmp6", "temp8", "tarail", "temp9", "mp7", "cp7", "tmp9", "html8", "proc8", "tar2", "cp8", "td15", "td7", "mp8", "html15", "tempail", "proc6"], "tmpz": [" tmpyz", "tempzh", "timeoutgz", "ppoj", "buffarr", "appylike", "tmpyz", "timeoutzer", "tabzes", "ttstr", " tmpl", " tmpy", "tclike", "tarz", "mptry", "expriz", "pkgzi", "tczi", "ttzi", "tmpjs", "tmpzone", "applike", "tfz", "exprz", "potz", "tpyz", "mpzh", "appyzer", "mpld", "tdlike", "buffll", "templl", "tfzi", "tpzip", "cmdiz", "tdz", "tmpld", "tnld", "xxxj", "tabz", "sociz", "tnze", "tmparr", " tmpls", "mpze", "tempiz", "timeoutiz", "cvze", "cmdzip", "tuzip", "timeoutll", "timeoutzes", "timeoutstr", "imgtry", "appyzh", "propzes", "appyz", "potzip", "timeoutld", "tarzer", "tmplog", "potld", "tpzi", "propzi", "cmdoz", "buffz", "potzi", "propzip", "dumpl", "templd", "tpll", "exprzz", "tempcz", "tarzes", "appystr", "imgzer", "xxxz", "jsonstr", "buffze", "cptry", "nodecz", "cmpz", "cmpld", "tplike", " tmpzi", "permzi", "tuze", "tczer", "dumpz", "pkgiz", "tpiz", "ppoz", "exprzi", "tmptry", "tmpstr", "temparr", "tczh", "tempz", "appiz", "soczes", "pkggz", "appyzes", "permld", "tpzer", "timeoutz", "tmpcz", "nodezi", "appzer", "tfzh", "tczes", "cmpze", "xxxze", "tmpgz", "etcz", "taroz", "prefixgz", "buffzip", "potarr", " tmpjs", "pkglike", "tempzi", "tablog", "buffzh", "prefixz", "cmpzone", "tmpzz", "ttll", "prefixzip", "trapzi", "tmpzip", "tmpl", "mpz", "tnzer", "tmpll", "tarzip", "cmdz", "cmdzes", "cpz", "tmpzes", "appytry", "tarj", "qqz", "trapz", "buffld", "cmdzz", "cmpzi", "tmpls", "tempzer", "cvzh", "permz", "cmdtry", "tpz", "qqzh", "permzh", "tmpzi", "timeoutzone", "jsonlike", "tmpoz", "cmpzh", "tfze", "tuj", "tpzes", "ppotry", "nodez", " tmpcz", "tuz", "cpl", "etczone", "tcz", "etcll", "tartry", "tpls", "pkgzer", "templike", "tempzz", "mpstr", "soclog", "pkgld", "tmpiz", "etczi", "pkgll", "cpls", " tmptry", "tpzh", "tciz", "tplog", "tabiz", "tpgz", "dumptry", "tempzone", "tdld", "tmpzh", "tpl", "imgzes", "prefixzi", "trapzes", "pkgzone", "tuzes", "tpzone", "mpl", "propz", "socz", "tpjs", "tpze", "nodey", "buffzi", "pkgzes", "tmpze", "timeoutzi", "pkgzip", "tempy", "cvz", "ppozer", "cvzip", "appz", "jsonz", "tpstr", "tnj", "tempyz", "timeoutzh", "mpzer", "tparr", "tmpzer", "nbzh", "tntry", "tmplike", "cmdzer", "nbze", "timeoutoz", "tdzone", "nbzi", "qqzip", "tmpj", "tuoz", "buffzes", "tptry", "pkgzh", "tnz", "pkgz", "ttz", "potgz", "imgz", "nbz", "dumpzh", "tustr", "cmpgz", "pkgoz", "tmpy", "xxxstr", "tpld", "buffoz", "mpj", "trapzip", "cmdzi", " tmparr", "tempjs", "qqze", "jsonzh"], "accu": ["Accu", "acuum", "Accuum", "acccu", "acu", "raccu", "racur", "Accur", "Acccu", "acur", "accuum", "accur", "racuum", "racu"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                             int mmu_idx)\n\n{\n\n    mmu_ctx_t ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    env->error_code = 1 << 18;\n\n                    env->spr[SPR_IMISS] = address;\n\n                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;\n\n                    goto tlb_miss;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    goto tlb_miss_74xx;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    env->error_code = 0x40000000;\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    return -1;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_ESR] = 0x00000000;\n\n                }\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    /* XXX: this might be incorrect */\n\n                    env->error_code = 0x40000000;\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_ISEG;\n\n                    env->error_code = 0;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                        env->error_code = 1 << 16;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                        env->error_code = 0;\n\n                    }\n\n                    env->spr[SPR_DMISS] = address;\n\n                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;\n\n                tlb_miss:\n\n                    env->error_code |= ctx.key << 19;\n\n                    env->spr[SPR_HASH1] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[0], HASH_PTE_SIZE_32);\n\n                    env->spr[SPR_HASH2] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[1], HASH_PTE_SIZE_32);\n\n                    break;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                    }\n\n                tlb_miss_74xx:\n\n                    /* Implement LRU algorithm */\n\n                    env->error_code = ctx.key << 19;\n\n                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |\n\n                        ((env->last_way + 1) & (env->nb_ways - 1));\n\n                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;\n\n                    break;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] = 0x00800000;\n\n                    } else {\n\n                        env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                    return -1;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                if (env->mmu_model == POWERPC_MMU_SOFT_4xx\n\n                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] |= 0x00800000;\n\n                    }\n\n                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                } else {\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x0A000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x08000000;\n\n                    }\n\n                }\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or stwcx. */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    /* XXX: this might be incorrect */\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_DSEG;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 21387, "substitutes": {"env": ["esm", "msg", "eh", "et", "desc", "equ", "eni", "answer", "gear", "dt", "eg", "vm", "worker", "event", "server", "ew", "v", "ener", "ev", "kw", "eas", "engine", "context", "te", "e", "info", "esc", "environment", "vs", "actor", "entry", "db", "dev", "erd", "era", "cmd", "Environment", "eng", "network", "net", "ef", "ner", "ter", "cv", "outer", "operator", "den", "ec", "hw", "buf", "ve", "config", "req", "conf", "obj", "vp", "vt", "er", "en", "end", "org", "cb", "set", "window", "init", "editor", "inv", "conn", "query", "enter", "estate", "here", "manager", "console", "viron", "addr", "doc", "ah", "nv"], "address": ["dress", "reference", "message", "context", "a", "resource", "number", "r", "memory", "index", "record", "value", "offset", "attribute", "add", "object", "order", "ash", "description", "array", "e", "holder", "host", "handle", "ip", "result", "ress", "request", "ptr", " Address", "event", "word", "password", "server", "argument", "entry", "Address", "addr", "adr", "location", "region", "shape", "page", "service", "phrase", "prefix", "command", "path", "range", "interface", "block", "ace", "email", "pointer", "port", "route", "network", "point", "alias"], "rw": ["kw", "rb", "usr", "r", "ru", "nr", "write", "dq", "rew", "window", "offset", "aw", "nw", "rss", "nz", "wp", "rs", "row", "wr", "wind", "iw", "hw", "nb", "wx", "buf", "aux", "word", "ptr", "ng", "rt", "rans", "sw", "wb", "rh", "RW", "ow", "rf", "rid", "wd", "wer", "ew", "wn", "wa", "rd", "w"], "mmu_idx": ["mmu_idz", "mmu_idxf", "mmu_IdX", "mmu_Idx", "mmu_Idxf", "mmu_IDy", "mmu_IDnt", "mmu_Idy", "mmu_midxf", "mmu_midz", "mmu_midX", "mmu_idnt", "mmu_IDxf", "mmu_Idnt", "mmu_idX", "mmu_Idz", "mmu_idy", "mmu_midy", "mmu_midx", "mmu_midnt", "mmu_IDx"], "ctx": ["kw", "Context", "history", "jac", "scope", "txt", "cas", "context", "kt", "alloc", "dc", "qt", "co", "act", "conv", "ct", "pkg", "tz", "loc", "ctrl", "conn", "bc", "tk", "cv", "tx", "vm", "handle", "cur", "cmp", "hw", "wx", "aux", "ptr", "rt", "tmp", "kh", "self", "sc", "addr", "xs", " context", "anc", "mc", "nt", "config", "np", "cmd", "tc", "obj", "conf", "except", "nc", "cc", "ca", "ctl", "handler", "cp", "cfg", "xc"], "access_type": ["action_ype", "playprotype", "play_ty", "pressTypetyp", "playproype", "matchetyty", "actionureype", "accessTypeype", " access_level", " access_ty", "accessetytag", "play_Type", "press_type", "access_field", "playproty", "accessedfield", "accessuretype", "accessTypety", "access_types", "access_length", "actionureType", "accessproype", "access_tag", "matchetydetails", "press_length", "accessurety", "accessetyty", "accessTypetyp", "access_ty", "playproType", "matchetyType", "match_details", "pressTypelength", "access_typ", "accessurefield", "accessedType", "accessedtype", "accessTypetype", "action_type", "play_type", "accessuredetails", "play_ype", "access_details", "match_type", "accessTypeType", " access_mode", "accessetyType", "press_typ", "accessedype", "access_mode", "actionuretype", "accessprotype", "access_ype", "match_ty", " access_tag", "accessTypelength", "accessureType", " access_types", "accessetytype", "actionurefield", "accessureype", "action_field", "matchetytype", "accessetydetails", "accessproType", "access_Type", "accessproty", "access_level", "action_Type", "match_Type", "pressTypetype"]}}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392, "substitutes": {"ds": ["dh", "ysis", "dm", "els", "ks", "os", "dd", "ods", "di", "icks", "dq", "ys", "dc", "dis", "ns", "ss", "ows", "ims", "sd", "Ds", "d", "ps", "bs", "dt", "cs", "sts", "rs", "fs", "gs", "des", "dl", "s", "hd", "DS", "ls", "df", "vs", "db", "hs", "ded", "js", "ts", "fd", "ads", "dll", "dos", "qs", "eds", "uds", "da", "dds"]}}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n", "idx": 21411, "substitutes": {"bs": ["bi", "blog", "lbs", "bf", "ks", "ubs", "ns", "BS", "bps", "aos", "ss", "bl", "iss", "cs", "bc", "fs", "gs", "bn", "bd", "ds", "bis", "ls", "bm", "bh", "ms", "vs", "js", "es", "its", "ts", "sb", "bos", "bas", "bp", "b", "ba", "bb"], "sector_num": ["ector_name", " sector_number", "sector_loc", "sector_number", "sector2mon", "ector_number", "sector2num", "ector_num", "sector_nm", "sector_mon", "sector2name", " sector_loc", "sector2number", "sector_name", " sector_nm", "ector_mon"], "nb_sectors": ["nb_seors", "nb_servctors", "nb_idegments", "nb_segments", "nb_vegments", "nb_semissions", "nb_psegments", "nb_vectors", "nb_servors", "nb_seters", "nb_veors", "nb_peors", "nb_servgments", "nb_pemissions", "nb_pegments", "nb_pseors", "nb_idectors", "nb_veters", "nb_pectors", "nb_psectors", "nb_ideters", "nb_vemissions", "nb_servmissions", "nb_pseters", "nb_ideors"], "pnum": ["penom", "panenum", "wnUM", "pnenum", "wnenum", "pennum", "penummer", "pnummer", "pumb", "pnom", "penUM", "gnumb", "penenum", "panumer", "pinumer", "nnnum", "pnnum", "nnum", "nnUM", "panum", "panummer", "pum", "penumb", "panumb", "pnumer", "gnom", "gnenum", "wnum", "pinum", "penumer", "pnUM", "panom", "wnnum", "pinummer", "gnnum", "nnenum", "pinumb", "penum", "gnum", "pnumb"], "cluster_offset": ["clust_error", "clusterabilityoption", "clusterabilityOffset", "cluster_size", "clusters_offset", "cluster__offset", "clusterabilityerror", "clusteristindex", "clusteringoffset", "clust_Offset", "clocation_size", "cluster_error", "cluster__data", "cluster_data", "clusteristaddress", "cluster__Offset", "clusteringindex", "cluster_index", "clusterabilityoffset", "cluster__pos", "cluster_Offset", "clust_option", "cluster_option", "clusters_Offset", "cluster_pos", "clocation_address", "clocation_index", "clusteringaddress", "clusters_pos", "cluster_address", "clusteristoffset", "clust_offset", "clocation_offset", "clusteringsize", "clusteristsize", "clocationingaddress", "clocationingindex", "clocationingoffset", "clocationingsize", "clusters_data"], "ret": ["gt", " Ret", "cert", "fun", "t", "re", "prot", "out", "txt", "print", "et", "r", "red", "det", "cont", "ber", "back", "rets", "rem", "err", "hash", "Ret", "val", "inter", "ert", "arr", "arg", "ter", "pret", "reset", "lt", "tr", "result", "mt", "aux", "deg", "ft", "rt", "res", "alt", "reg", "nt", "RET", "cmd", "ne", "elt", "ry", "pat", "tf"]}}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_test_apply(MigrateSetParameters *params,\n\n                                      MigrationParameters *dest)\n\n{\n\n    *dest = migrate_get_current()->parameters;\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        dest->compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        dest->compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        dest->decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        dest->cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        dest->cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        dest->tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        dest->tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        dest->max_bandwidth = params->max_bandwidth;\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        dest->downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        dest->x_checkpoint_delay = params->x_checkpoint_delay;\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        dest->block_incremental = params->block_incremental;\n\n    }\n\n}\n", "idx": 21413, "substitutes": {"params": ["ports", "mas", "p", "settings", "masters", "param", "parts", "mm", "packages", "plugins", "ams", "tags", "users", "amps", "ims", "words", "changes", "units", "stats", "assets", "pkg", "images", "ps", "ops", "terms", "las", "keys", "headers", "gs", "args", "styles", "pers", "relations", "points", "ctx", "spec", "details", "marks", "names", "values", "caps", "photos", "devices", "pretty", "properties", "types", "shape", "makes", "vals", "pins", "cms", "chains", "posts", "pps", "config", "rpm", "modules", "conf", "versions", "options", "models", "docs", "fps", "actions", "roots", "members", "phys", "as", "sql", "errors", "parents"], "dest": ["ports", "must", "dep", "slave", "this", "source", "desc", "sum", "rel", "loc", "target", "decl", "peer", "host", "temp", "server", "tmp", "path", "gen", "port", "v", "success", "chain", "master", "resp", "orig", "list", "output", "root", "copy", "results", "data", "coord", "est", "opt", "dev", "new", "mem", "cmd", "bin", "public", "pas", "writer", "table", "total", "max", "good", "foreign", "spec", "other", "shape", "rest", "trans", "req", "conf", "obj", "comp", "dist", "attr", "p", "out", "end", "usr", "ver", "Dest", "transform", "etc", "src", "nom", "physical", "created", "test", "st", "result", "prop", "priv", "iter", "options", "origin"]}}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "void cpu_state_reset(CPUMIPSState *env)\n\n{\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", env->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n\n    tlb_flush(env, 1);\n\n\n\n    /* Reset registers to their default values */\n\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n\n                                 << env->cpu_model->CP0_LLAddr_shift;\n\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n\n    env->CCRes = env->cpu_model->CCRes;\n\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = env->cpu_model->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = env->cpu_model->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n\n    env->insn_flags = env->cpu_model->insn_flags;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->hflags = MIPS_HFLAG_UM;\n\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n\n       hardware registers.  */\n\n    env->CP0_HWREna |= 0x0000000F;\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n#ifdef TARGET_MIPS64\n\n    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n#endif\n\n#else\n\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n\n        /* If the exception was raised from a delay slot,\n\n           come back to the jump.  */\n\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n\n    } else {\n\n        env->CP0_ErrorEPC = env->active_tc.PC;\n\n    }\n\n    env->active_tc.PC = (int32_t)0xBFC00000;\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n    env->CP0_Wired = 0;\n\n    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);\n\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n\n    /* vectored interrupts not implemented, timer on int 7,\n\n       no performance counters. */\n\n    env->CP0_IntCtl = 0xe0000000;\n\n    {\n\n        int i;\n\n\n\n        for (i = 0; i < 7; i++) {\n\n            env->CP0_WatchLo[i] = 0;\n\n            env->CP0_WatchHi[i] = 0x80000000;\n\n        }\n\n        env->CP0_WatchLo[7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n", "idx": 21427, "substitutes": {"env": ["ee", "esm", "msg", "door", "eh", "et", "app", "desc", "equ", "eni", "ten", "err", "dn", "gear", "erb", "dest", "eg", "vert", "vm", "ds", "worker", "uv", "ov", "event", "web", "server", "stage", "oe", "ew", "sb", "ue", "v", "ener", "ev", "eas", "engine", "eur", "eb", "context", "ger", "erv", "order", "enc", "e", "esc", "export", "exc", "environment", "vs", "actor", "entry", "db", "dev", "erd", "era", "cmd", "Environment", "eng", "timer", "net", "header", "ef", "act", "ner", "ei", "ter", "cv", "outer", "operator", "var", "den", "ec", "oder", "hw", "buf", "ctx", "ve", "ja", "buffer", "nav", "req", "conf", "obj", "esi", "el", "shell", "vp", "vv", "forge", "serv", "vt", "alias", "er", "en", "rb", "end", "txt", "org", "cb", "gate", "window", "ende", "editor", "inv", "iv", "ea", "ext", "conn", "code", "het", "query", "enter", "keeper", "estate", "ent", "here", "manager", "queue", "console", "viron", "addr", "doc", "eq", "ah", "nv", "een", "eve"]}}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 21430, "substitutes": {"bs": ["bi", "sys", "lbs", "bits", "bf", "ks", "os", "bsp", "ubs", "ss", "BS", "bps", "aos", "bl", "ns", "ims", "ps", "bus", "cs", "bc", "sts", "fs", "aws", "gs", "bn", "rs", "ds", "bis", "abilities", "ls", "bm", "bh", "vs", "hs", "bes", "js", "cms", "its", "ts", "als", "obs", "pb", "bt", "acs", "qs", "sb", "bas", "cks", "bp", "b", "bos", "uts", "bb", "irms"], "op": ["ok", "p", "opa", "msg", "it", " cop", "o", "ack", "tp", "pop", "tip", "Op", "oper", "post", "top", "key", "ops", "pl", "x", "id", "hop", "e", "ext", "loc", "ps", "ot", "tx", "bit", "operator", " hop", "jp", "batch", "ip", "ap", "xp", "k", "pe", "operation", " ip", "opt", "up", "oop", "sp", "oe", "zero", "block", "prev", "cmd", "typ", "update", "oc", "ep", "mop", "OP", "comp", "pat", "cp", "cop", "type"], "errp": ["Erpe", "errps", "erp", "dieper", "nerpress", "nerpa", "errorpb", "arrpa", "errr", "errpa", " errper", "attrpp", "arrpress", "erpc", "errpress", "err", " errpc", "errorps", "errpp", "diepe", "arrp", "rrpp", " errpa", "attrp", " errpp", "errpc", "errpe", "errpb", " errpb", "Erper", "Erp", " errps", "attrpc", "erpp", " errr", " errpe", "rrps", " errpress", "rrpb", "errorp", "attrr", "diep", "rrp", "arrr", "nerp", "errorpp", "nerr", "errper"], "blocker": ["joiner", "blockER", "blockner", " blockger", "buser", " blockER", "blockzer", "ankner", "blockingener", "blener", "lockzer", "bler", "blockonder", "blockener", "joinner", "anker", "busonder", "blockinger", "ankers", "joinger", "ankger", " blockzer", "checkoser", "blockoser", "busER", "blocktimer", "checktimer", "lockER", "bltimer", "checkener", "blockers", "locker", "blockingoser", "buszer", "lockonder", "blockger", "joiners", " blockonder", "checker", " blockers", " blockner", "bloser", "blockingtimer"]}}
{"project": "qemu", "commit_id": "3ddf3efefa364505ee44582873612dd8f6abb838", "target": 0, "func": "static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21435, "substitutes": {"device": ["name", "hid", "end", "model", "resource", "slave", "kind", " Device", "serial", "driver", "description", "display", "plugin", "label", "Device", "controller", "query", "handle", "disk", "connection", "DEV", "pod", "family", "mode", "directory", "module", "product", "devices", "pe", "component", "location", "dev", "feature", "path", "command", "block", "address", "android", "remote", "pad", "VICE", "network", "series"], "aio_context": ["aive_Context", "aiao_context", "aip_context", "aiop_mem", "aao_cache", "aio_cache", "aiop_resource", "aIO_info", "aive_context", "aio_group", "aio_ctx", "aao____cache", "aio_resource", "aai_ctx", "aioaxycontext", "aio_mask", "aive_group", "aio____connection", "aiao_mask", "aio_connection", "aao____package", "aio___info", "aio_Context", "aio___mask", "aio_info", "aai_mask", "aio_scope", "aio____cache", "aiao_Context", "aao_context", "aio_package", "aip_mask", "aio____package", "aio_mem", "aao____context", "aai_scope", "aIO_Context", "aio____context", "aioaxyContext", "aio___ctx", "aive_condition", "aiop_context", "aio_tx", "aip_ctx", "aai_context", "aio___context", "aao_connection", "aiop_connection", "aioaxycondition", "aIO_context", "aao_package", "aao____connection", "aioaxygroup", "aiao_tx", "aio___Context", "aio_condition"], "errp": ["errps", "erp", "errP", "errpar", "errpa", "scorepar", " errP", "errpid", " errpa", " errpar", "erps", " errpid", "diepid", " errps", "scorep", "scorepid", "diepar", "scoreps", "erP", "dieps", "diep", "diepa", "erpa", "dieP"], "blk": ["blck", " blak", "broek", "bleck", "brok", " blke", "oblj", "toolak", "plck", " blkg", "blb", "toolkg", "bgck", "bgek", "Blck", "blek", "Blb", "oblke", "oblak", "plak", "oblk", " blck", "blke", "plj", "toolk", "oblck", " blj", "bleak", "slck", "bgak", "brob", "bgk", "blj", "blkg", "bleek", "toolck", " blb", "plk", "oblkg", "Blk", "brock", "Blj", " blek", "Blek", "blak", "slke", "Blak", "slak", "slk"], "bs": ["bi", "boxes", "lbs", "uses", "bits", "busters", "cb", "css", "boot", "ubs", "bed", "ns", "bps", "BS", "aos", "bl", "outs", "bus", "cs", "bc", "fs", "gs", "bd", "bis", "bytes", "flows", "ab", "ls", "bm", "bh", "ms", "bles", "vs", "bing", "banks", "vals", "bes", "js", "uts", "its", "ts", "obs", "pb", "aus", "blocks", "qs", "sb", "bos", "b", "bp", "bas", "bys", "bb", "irms"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n", "idx": 21450, "substitutes": {"str": ["name", "t", "p", "out", "txt", "it", "r", "f", "enc", "arr", "text", "cs", "i", "c", "st", "s", "cur", "tr", "fr", "buf", "raw", "spec", "br", "arc", "res", "seq", "STR", "buffer", "sc", "in", "ch", "sp", "stri", "b", "Str", "w"], "hci": ["cdi", " hcli", "rhcm", "rcci", "wco", "ahcgi", "rli", "htcul", "hecu", "rcu", "hcu", "hcul", "hpi", "ihcci", "htcci", "hco", "ncci", "heci", "nco", "Hpi", "wcci", "ahci", "hli", " hli", "wci", "htci", "nci", "cco", "hcci", " hdi", "Hcci", " hcm", "hcli", "Hco", "Hci", " hpi", "Hdi", "cpi", "ahcm", " hcu", "cci", "ihco", "ahcli", "wdi", "hecci", "rhcgi", "hcgi", "htco", " hcgi", " hcul", "rhcli", " hcci", "rci", "heli", "hdi", " hco", "ncul", "hcm", "rhci", "ihdi", "ihci"], "bdaddr": ["bdptr", "ddaddress", "desaddr", "bladdress", "bdreq", "desconn", "djadr", "bcadr", "ndcoord", "baaddress", "djside", "dptr", "disabledconn", "ddreq", "dbptr", "BDconn", "ddaddr", "daddr", "bdenv", "ndside", "cdadd", "bdcoord", "baenv", "bdrt", "bladd", "disabledloc", "ddcoord", "dbrt", "desadr", "cdnenv", "ndaddr", "BDptr", "ndadr", "ddconn", "BDadr", "bdside", "disabledcoord", "bcobj", "dbadr", "desside", "BDadd", "dbaddress", "bcreq", "cdptr", "ndloc", "bdobj", "condaddr", "ndconn", "bdadr", "BDaddr", "dadd", "BDaddress", "bdconn", "dbadd", "bdaddress", "bladdr", "cdnrt", "desobj", "ddloc", "bdloc", "disabledaddr", "bcaddress", "cdaddress", "bart", "cdnaddr", "daddress", "condadr", "dbenv", "bladr", "condobj", "bdadd", "cdnaddress", "djaddr", "bcaddr", "BDreq", "condconn", "dbaddr", "bcconn", "djconn", "baaddr", "cdaddr"]}}
{"project": "qemu", "commit_id": "58aebb946acff82c62383f350cab593e55cc13dc", "target": 0, "func": "static int cris_mmu_translate_page(struct cris_mmu_result *res,\n\n\t\t\t\t   CPUState *env, uint32_t vaddr,\n\n\t\t\t\t   int rw, int usermode, int debug)\n\n{\n\n\tunsigned int vpage;\n\n\tunsigned int idx;\n\n\tuint32_t pid, lo, hi;\n\n\tuint32_t tlb_vpn, tlb_pfn = 0;\n\n\tint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\n\n\tint cfg_v, cfg_k, cfg_w, cfg_x;\t\n\n\tint set, match = 0;\n\n\tuint32_t r_cause;\n\n\tuint32_t r_cfg;\n\n\tint rwcause;\n\n\tint mmu = 1; /* Data mmu is default.  */\n\n\tint vect_base;\n\n\n\n\tr_cause = env->sregs[SFR_R_MM_CAUSE];\n\n\tr_cfg = env->sregs[SFR_RW_MM_CFG];\n\n\tpid = env->pregs[PR_PID] & 0xff;\n\n\n\n\tswitch (rw) {\n\n\t\tcase 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;\n\n\t\tcase 1: rwcause = CRIS_MMU_ERR_WRITE; break;\n\n\t\tdefault:\n\n\t\tcase 0: rwcause = CRIS_MMU_ERR_READ; break;\n\n\t}\n\n\n\n\t/* I exception vectors 4 - 7, D 8 - 11.  */\n\n\tvect_base = (mmu + 1) * 4;\n\n\n\n\tvpage = vaddr >> 13;\n\n\n\n\t/* We know the index which to check on each set.\n\n\t   Scan both I and D.  */\n\n#if 0\n\n\tfor (set = 0; set < 4; set++) {\n\n\t\tfor (idx = 0; idx < 16; idx++) {\n\n\t\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\t\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \n\n\t\t\t\t\tset, idx, hi, lo, tlb_vpn, tlb_pfn);\n\n\t\t}\n\n\t}\n\n#endif\n\n\n\n\tidx = vpage & 15;\n\n\tfor (set = 0; set < 4; set++)\n\n\t{\n\n\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\n\n\t\ttlb_vpn = hi >> 13;\n\n\t\ttlb_pid = EXTRACT_FIELD(hi, 0, 7);\n\n\t\ttlb_g  = EXTRACT_FIELD(lo, 4, 4);\n\n\n\n\t\tD_LOG(\"TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\\n\", \n\n\t\t\t mmu, set, idx, tlb_vpn, vpage, lo, hi);\n\n\t\tif ((tlb_g || (tlb_pid == pid))\n\n\t\t    && tlb_vpn == vpage) {\n\n\t\t\tmatch = 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\n\n\tres->bf_vec = vect_base;\n\n\tif (match) {\n\n\t\tcfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);\n\n\t\tcfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);\n\n\t\tcfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);\n\n\t\tcfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);\n\n\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\t\ttlb_v = EXTRACT_FIELD(lo, 3, 3);\n\n\t\ttlb_k = EXTRACT_FIELD(lo, 2, 2);\n\n\t\ttlb_w = EXTRACT_FIELD(lo, 1, 1);\n\n\t\ttlb_x = EXTRACT_FIELD(lo, 0, 0);\n\n\n\n\t\t/*\n\n\t\tset_exception_vector(0x04, i_mmu_refill);\n\n\t\tset_exception_vector(0x05, i_mmu_invalid);\n\n\t\tset_exception_vector(0x06, i_mmu_access);\n\n\t\tset_exception_vector(0x07, i_mmu_execute);\n\n\t\tset_exception_vector(0x08, d_mmu_refill);\n\n\t\tset_exception_vector(0x09, d_mmu_invalid);\n\n\t\tset_exception_vector(0x0a, d_mmu_access);\n\n\t\tset_exception_vector(0x0b, d_mmu_write);\n\n\t\t*/\n\n\t\tif (cfg_k && tlb_k && usermode) {\n\n\t\t\tD(printf (\"tlb: kernel protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 2;\n\n\t\t} else if (rw == 1 && cfg_w && !tlb_w) {\n\n\t\t\tD(printf (\"tlb: write protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\t/* write accesses never go through the I mmu.  */\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (rw == 2 && cfg_x && !tlb_x) {\n\n\t\t\tD(printf (\"tlb: exec protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (cfg_v && !tlb_v) {\n\n\t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 1;\n\n\t\t}\n\n\n\n\t\tres->prot = 0;\n\n\t\tif (match) {\n\n\t\t\tres->prot |= PAGE_READ;\n\n\t\t\tif (tlb_w)\n\n\t\t\t\tres->prot |= PAGE_WRITE;\n\n\t\t\tif (tlb_x)\n\n\t\t\t\tres->prot |= PAGE_EXEC;\n\n\t\t}\n\n\t\telse\n\n\t\t\tD(dump_tlb(env, mmu));\n\n\t} else {\n\n\t\t/* If refill, provide a randomized set.  */\n\n\t\tset = env->mmu_rand_lfsr & 3;\n\n\t}\n\n\n\n\tif (!match && !debug) {\n\n\t\tcris_mmu_update_rand_lfsr(env);\n\n\n\n\t\t/* Compute index.  */\n\n\t\tidx = vpage & 15;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, pid, 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  pid,\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->phy = tlb_pfn << TARGET_PAGE_BITS;\n\n\treturn !match;\n\n}\n", "idx": 21459, "substitutes": {"res": ["resp", "rez", "re", "sys", "rc", "rev", "ret", "err", "val", "RES", "def", "rs", "tx", "reset", "des", "pres", "proc", "ress", "resh", "pr", "Res", "vals", "reg", "mem", "req", "rou", "rec", "serv"], "env": ["ee", "er", "en", "end", "org", "context", "param", "desc", "te", "equ", "ten", "ef", "window", "err", "eni", "inv", "ner", "con", "e", "conn", "code", "ext", "cv", "info", "operator", "den", "ec", "esc", "disk", "proc", "hw", "worker", "exc", "buf", "ctx", "here", "manager", "environment", "hess", "pe", "viron", "dev", "mem", "erd", "config", "era", "conf", "Environment", "pg", "ew", "nv", "eng", "v", "network", "net", "ev", "attr", "vt"], "vaddr": ["vstore", "vaddress", "cvaddress", " vaddress", "waddr", "vtoffset", "nvaddr", "waddress", "vtaddr", " vstore", "vtpad", "nvaddress", "svpad", "nvpad", "nvoffset", "vpad", "vconn", "cvconn", "wstore", "voffset", "svoffset", "svaddr", "wconn", "cvaddr", "vtaddress", " vconn", "cvstore", "svaddress"], "rw": ["kw", "resp", "rb", "writer", "rc", "r", "ru", "nr", "write", "rew", "aw", "nw", "rss", "rr", "ro", "wp", "fw", "writ", "wr", "wu", "iw", "hw", "wrap", "wx", "rt", "wb", "RW", "rf", "rid", "wcs", "wd", "range", "tw", "weak", "wn", "route", "rd", "w"], "usermode": ["testcache", "testflag", "userflags", "usrflags", "usrcache", "flagmode", "testmode", "usercache", "flagflag", "flagcache", "usrmode", "flagflags", "testflags", "usrflag", "userflag"], "debug": ["tag", "DEBUG", "comment", "depth", "dc", "progress", "scale", "d", "trace", "deb", "Debug", "coord", "warn", "web", "render", "db", "priv", "dev", "doc", "error", "date", "cache", "mod", "diff", "bug", "flag"], "vpage": [" Vage", " vchannel", "nvchannel", "nvage", "pport", "tnode", "ppage", " voffset", " vpc", "Voffset", "uvport", " vrow", " vport", "uvpage", "prow", " vpages", "vpages", " Vnode", "uvpc", " Vpage", "tpage", "nvoffset", "ppc", "vrow", "vport", "nvpage", "tage", "uvrow", "Vage", "voffset", "Vchannel", "vnode", "vpc", " vnode", " vage", "vchannel", "tpages", "Vpage", "vage", " Vpages"], "idx": ["idy", "idxd", "initxf", "IDy", "partx", "indrox", "party", "midx", "idn", "idey", "Idz", " idn", "indz", "identix", " idy", "idxes", "Idxs", "IDex", "IDxe", " idxs", "initxd", " idxf", "midex", "initrox", "IDx", "kidxes", "kidx", "idix", "initxe", "inity", "midxs", "Idx", "idexs", "IDlex", " idz", " idnex", "partxc", "indn", "Idy", "Idxes", "IDxd", "midnex", " idxd", "idnex", "idxe", " idxe", " idex", "indxf", "identnex", "indxs", "idxs", "idz", "kidy", " idlex", "idexes", "indy", "initex", "identx", "identex", "index", "idlex", " idxc", "Idex", "idrox", "initx", "idxc", "midy", "Idix", "ideix", "ideex", "idex", "idxf", "partlex", "kidix", "indx", "IDxc", " idix", "midn", "midz", "midix", " idrox"], "pid": ["phi", "p", "oid", "process", "pm", "vid", "mid", "sta", "win", "notice", "pkg", "pro", "pt", "id", "po", "pa", "proc", "base", "status", "pu", "png", "ctx", "pn", "part", "page", "pan", "phy", "wan", "pin", "fd", "pc", "typ", "pool", "pg", "sid", "pos", "pai", "port", "pi", "uid"], "lo": ["loop", "phi", "stone", "lr", "ilo", "o", "Lo", "zo", "los", "go", "h", "lu", "co", "fo", "LO", "lb", "loc", "po", "ro", "pl", "ld", "lan", "lon", "oo", "ko", "lt", "le", "mo", "que", "la", "ao", "local", "lim", "low", "no", "elo", "li", "bo", "loe", "lin", "lc", "lie", "ln", "mi", "isl", "iso", "lf", "l", "line", "so"], "hi": ["hid", "history", "phi", "upper", "hea", "ht", "ho", "ri", "py", "high", "hip", "hh", "ashi", "hy", "h", "hu", "go", "Hi", "mid", "fo", "ha", "wi", "loc", "id", "po", "i", "HI", "cu", "ro", "gi", "info", "mu", "ko", "ni", "hd", "no", "ip", "ti", "lim", "low", "hei", "ih", "li", "his", "bh", "ui", "fi", "ph", "sh", "hl", "rh", "hel", "ris", "ch", "ci", "wo", "mi", "iso", "pi"], "tlb_vpn": ["tlb_ivPN", "tlb_vPN", "tlb_vbn", "tlb_evbn", "tlb_tvn", "tlb_ppn", "tlb_ivbn", "tlb_ivgn", "tlb_vnp", "tlb_lbn", "tlb_pbn", "tlb_lpas", "tlb_pgn", "tlb_pnp", "tlb_evpn", "tlb_evn", "tlb_vn", "tlb_lgn", "tlb_vgn", "tlb_ivn", "tlb_avpn", "tlb_lpn", "tlb_tvpn", "tlb_avlan", "tlb_tvbn", "tlb_avnp", "tlb_tvPN", "tlb_ivpn", "tlb_avn", "tlb_plan", "tlb_pn", "tlb_vpas", "tlb_ivpas", "tlb_ppas", "tlb_tvlan", "tlb_tvnp", "tlb_evPN", "tlb_vlan"], "tlb_pid": ["tlb__pg", "tpl_pid", "tpl_pi", "tlb__pid", "tlb__p", "tlb_pg", "tlb_p", "tpl_pg", "tpl_p", "tlb__pi", "tlb_pi"], "tlb_g": ["tlb8g", "tlp_k", "tlb_gc", "tlp_gc", "tlb8p", "tlb8k", "tlp_g", "tlb_p", "tlp_p", "tlb8gc"], "tlb_v": ["tlp_k", "tlb_b", "tlp_v", "tlp_b", "tlp_w"], "tlb_k": ["tlp_k", "tlb_q", "tlp_v", "tlp_w", "tlp_q"], "tlb_w": ["tlp_r", "tlbxv", "tlbxr", "tlp_h", "tlp_v", "tlp_w", "tlb_h", "tlbxw", "tlb_r", "tlbxh"], "tlb_x": ["tlp_x", "tlb_y", "tlp_h", "tlp_w", "tlb_h", "tlp_y"], "cfg_v": ["ctrl_g", "ctrl_f", "cfg_f", "cfg_g", "ctrl_w", "ctrl_v"], "cfg_k": ["cfg_u", "config_v", "config_g", "config_u", "cfg_g", "config_k"], "cfg_w": ["cfgxw", "cfg_wk", "cfg_h", "cfg2w", "storage00w", "storage_h", "cfg00v", "storage00wk", "cfg00w", "cfgxwk", "cfg00wk", "storage_wk", "cfg00h", "storage00h", "storage_v", "storage00v", "cfg2v", "cfgxh", "cfg2h", "cfg2wk", "storage_w", "cfgxv"], "cfg_x": ["cfg_ex", "tm_w", "tm_x", "cfg_f", "tm_f", "tm_ex"], "set": ["msg", "move", "pack", "et", "commit", "sum", "pair", "reset", "batch", "no", "ex", "alt", "equal", "stage", "sche", "ser", "local", "chain", "type", "name", "use", "start", "single", "list", "spot", "pop", "sync", "ind", "i", "size", "handle", "se", "base", "see", "num", "split", "sc", "new", "run", "mark", "iat", "oto", "ident", "net", "it", "session", "scale", "act", "post", "def", "san", "Set", "spec", "ve", "try", "match", "sp", "range", "common", "store", "diff", "cast", "sha", "save", "en", "end", "setting", "ver", "index", "sec", "check", "go", "read", "add", "init", "id", "row", "section", "test", "st", "get", "shift", "SET", "draw", "sub", "tree", "clear", "site", "mod", "ate"], "r_cause": ["r__cause", "r___reason", "cr_forge", "cr_reason", "pr_controller", "cr__cause", "r__forge", "pr_cf", "cr_cause", "r_forge", "cr__ca", "r_cf", "pr_cfg", "r__reason", "r_controller", "r_reason", "r___ca", "r___forge", "cr_ca", "cr__forge", "cr__reason", "r___cause", "pr_cause", "r_ca", "r__ca"], "r_cfg": ["rdjcfg", "rdjconfig", "r_config", "R_cmd", "r2fg", " r_config", "rdjcategory", "r__cmd", " r2config", " r_category", "r_fg", "r__fg", "r__cfg", " r2category", "r_cf", " r_cf", " r2cfg", "R_config", "r2cf", "R_fg", "r_category", " r2cf", "r2category", "R_cfg", "r2cfg", "r__config", "r2cmd", "r_cmd", "r2config", "rdjcf"], "rwcause": ["RWscore", "rwreason", "winenotice", "RWnotice", "rwerr", "RWcause", "kwscore", "hwcorruption", "hwcause", "rwcorruption", "rfscore", "winereason", "nwreason", "rfcause", "wrerr", "rewcause", "wreason", "rewerr", "rfreason", "rwbecause", "wrcause", "wrreason", "rfbecause", "rewreason", "wcause", "rwnotice", "wrCause", "rwCause", "RWbecause", "winecause", "nwcorruption", "RWreason", "kwcause", "rwchoice", "nwcause", "kwbecause", "wCause", "winechoice", "kwcorruption", "hwreason", "werr", "kwreason", "rwscore", "RWchoice", "rewnotice", "rewchoice", "rewCause"], "vect_base": ["vectationoffset", "vectationbas", "vex_bas", "vector_b", "vector_offset", "vect__bas", "vect__offset", "vect_bas", "vectationb", "vect_balance", "vect_offset", "vect_b", "vect_Base", "vector_base", "vector_bas", "vect__b", "vex_balance", "vex_Base", "vex_base", "vectationbase", "vect__base"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n", "idx": 21466, "substitutes": {"ctx": ["kw", "ij", "Context", "jac", "mk", "vc", "txt", "context", "ck", "kt", "cb", "abc", "gc", "ct", "pkg", "loc", "unc", "ctrl", "conn", "bc", "tx", "c", "jp", "cmp", "cur", "bh", "tmp", "kh", "lc", "cm", "sc", "kb", "anc", "nt", "mc", "np", "cmd", "tc", "obj", "crit", "kj", "req", "nc", "cc", "jj", "ctl", "cp", "cfg", "ctr", "xc"]}}
{"project": "qemu", "commit_id": "96193c22ab39ea24f81e386ad7883260ff24f5fd", "target": 0, "func": "static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n", "idx": 21473, "substitutes": {"cpu": ["core", "p", "gpu", "ck", "alloc", "processor", "process", "boot", "ack", "tp", "gc", "bench", "cu", "vm", "c", "ec", "arch", "proc", "hw", "ork", "pu", "ctx", "chip", "clock", "aco", "nic", "apache", "hog", "bean", "mem", "ola", "anc", "pc", "uu", "cam", "CPU", "linux", "nc", "uda", "cp"], "env": ["expr", "chart", "eh", "et", "ce", "desc", "equ", "policy", "head", "gear", "vm", "peer", "eco", "worker", "server", "bean", "oe", "ew", "v", " en", "ev", "eas", "state", "engine", "response", "context", "e", "vas", "disk", "export", "exc", "environment", "vs", "entry", "db", "dev", "erd", "runner", "era", "Environment", "eng", "net", "header", "scope", "ef", "session", "ner", "ei", "cv", "outer", "ec", "buf", "ctx", "spec", "kernel", "ve", "config", "req", "obj", "shell", "vp", "forge", "vt", "er", "en", "end", "org", "gate", "window", "code", "conn", "ell", "enter", "ent", "here", "manager", "queue", "console", "viron", "eu", "ah", "cfg"], "i": ["bi", "ij", "n", "p", "t", "phi", "is", "\u0438", "ic", "it", "a", " si", "print", "si", "ri", "di", "index", "iu", "ai", "xi", "m", "ix", "go", "ims", "y", "ji", "multi", " m", "im", "zi", "key", "x", "id", " ii", "e", "sim", "ind", "gi", " ti", "I", "c", "mu", "span", "pers", "ami", "qi", "ti", "j", "ip", "ini", "batch", "asi", "li", "ui", "fi", "gu", " bi", "oi", "in", "ci", " j", " pi", "mi", "ii", "ni", "port", "pi", "v", " ki", " multi", "yi"], "esa": ["estro", "ESA", "aki", "uca", "isa", "eas", "anza", "emis", "usa", "sa", "ski", "cow", "edes", " Mesa", "acha", "mes", "aos", "ses", "essa", "ean", "ase", "abus", "atari", "ea", "asse", "ozo", "sama", "ya", "sis", "eta", "ideo", "aze", "ema", "ette", "eus", "iste", "osi", "una", "es", "sea", "era", "acs", "iso", "esi", "ista", "pai", "apa", "asar"], "s": ["n", "p", "t", "is", "sa", "r", "os", "set", "h", "ss", "ns", "us", "ses", "sd", "ps", "cs", "sts", "space", "rs", "gs", "fs", "c", "ds", "st", "se", "south", "spec", "ls", "sam", "sv", "vs", "hs", "S", "js", "sq", "ts", "sp", "sg", "w", "sb", "v", "sl", "serv"]}}
{"project": "qemu", "commit_id": "2bcf018340cbf233f7145e643fc1bb367f23fd90", "target": 0, "func": "int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n", "idx": 21487, "substitutes": {"env": ["en", "scope", "state", "engine", "org", "context", "te", "ten", "window", "gear", "e", "conn", "info", "handle", "esc", "proc", "EN", "buf", "estate", "ctx", "ptr", "manager", "environment", "server", "vs", "map", "viron", "mem", "stack", "En", "erd", "config", "Environment", "conf", "obj", "store", "eng", "v", "gov", "vp", "ev"], "raddr": ["Raddr", "rfx", "rAddress", "rcadr", " rfx", "rcaddress", "rarAddress", "Rfx", "rarfx", "Radr", " radr", "radd", "rcaddr", "Raddress", "Radd", " rAddress", " rarp", "rararp", " raddress", "radr", "raddress", "rcadd", "raraddr", "RAddress", "Rarp", " radd", "rarp"], "rw": ["lr", "rb", "rc", " wr", "write", "window", "aw", "nw", "wid", "wp", "weight", "row", "wr", "wind", "hw", "xp", "lock", "wx", "sw", "RW", "rf", "self", "wd", "ln", "rl", "wa", "eng", "w"], "addr": ["rc", "r", "arp", "ack", "ref", "ix", "offset", "add", "act", "src", "rad", "arr", "rr", "loc", "id", "rs", "tx", "coord", "buf", "ptr", "align", "ag", "rt", "res", "alt", "map", "mem", "ad", "dr", "wd", "amp", "address", "cmd", "ace", "pos", "obj", "store", "pad", "attr"], "flags": ["bits", "settings", "aps", "weights", "alf", "tags", "acts", "pages", "units", "ps", "ops", "mask", "fs", "args", "locks", "states", "fields", "faces", "planes", "ff", "vs", "properties", "grades", "levels", "types", "ts", "ants", "Flags", "features", "ags", "options", "fps", "actions", "flag", "limits", "lag", "events", "ents"]}}
{"project": "qemu", "commit_id": "6cded3a43ad0044d9831590795d9c6cf0dc2d2ee", "target": 0, "func": "static void nic_selective_reset(EEPRO100State * s)\n\n{\n\n    size_t i;\n\n    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n\n    //~ eeprom93xx_reset(s->eeprom);\n\n    memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n\n    eeprom_contents[0xa] = 0x4000;\n\n    if (s->device == i82557B || s->device == i82557C)\n\n        eeprom_contents[5] = 0x0100;\n\n    uint16_t sum = 0;\n\n    for (i = 0; i < EEPROM_SIZE - 1; i++) {\n\n        sum += eeprom_contents[i];\n\n    }\n\n    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;\n\n    TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eeprom_contents[EEPROM_SIZE - 1]));\n\n\n\n    memset(s->mem, 0, sizeof(s->mem));\n\n    uint32_t val = BIT(21);\n\n    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n\n\n\n    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));\n\n    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));\n\n}\n", "idx": 21492, "substitutes": {"s": ["n", "comm", "t", "p", "is", "sys", "bits", "a", "reads", "r", "os", "o", "source", "f", "h", "changes", "ns", "ss", "y", "ses", "stats", "bs", "ps", "ops", "e", "sts", "cs", "rs", "gs", "fs", "c", "aws", "ds", "bis", "args", "states", "status", "spec", "ls", "details", "ex", "sv", "sw", "vs", "ats", "hs", "ies", "S", "js", "in", "es", "its", "sq", "ts", "als", "ins", "http", "qs", "less", "store", "sb", "b", "l", "v", "sl", "events"], "i": ["bi", "n", "p", "phi", "\u0438", "ic", "it", " si", " vi", "si", "o", "di", "index", "ai", " x", "xi", "f", "m", "go", "ix", "y", "ji", "multi", " m", "im", "zi", "key", "x", " ii", "ind", "sim", "gi", "info", " ti", "span", "c", "I", " di", "qi", "ki", "ti", "j", "ini", "ip", "asi", "li", "k", "q", "ui", " k", "fi", " bi", " ni", "ci", " j", " pi", "mi", "ii", " mi", "pi", "b", "v", " ki", "l", "point", "uri"], "eeprom_contents": ["eeprom_compENTS", "eeprom_intent", "eeprom7content", "eeprom2Contens", "eeprom_intensions", "eeprom_datists", "eeprom_contentent", "eeprom_compers", "eeprom_extent", "eeprom_contants", "eeprom_presentents", "eeprom7contists", "eeprom_codensions", "eeprom2contensions", "eeprom7containers", "eeprom_contentists", "eeprom_variists", "eeprom_descENTS", "eeprom_compents", "eeprom2ContENTS", "eeprom_Content", "eeprom_constent", "eeprom_conters", "eeprom2contentents", "eeprom_codent", "eeprom_contentensions", "eeprom_presentaps", "eeprom_Contens", "eeprom_cments", "eeprom2content", "eeprom2contentENTS", "eeprom_datent", "eeprom7variainers", "eeprom_cmars", "eeprom_descents", "eeprom_codens", "eeprom2contens", "eeprom_constents", "eeprom_compaps", "eeprom_intants", "eeprom_contensions", "eeprom_varients", "eeprom_contars", "eeprom_ContENTS", "eeprom_contentaps", "eeprom_datents", "eeprom7contents", "eeprom2contENTS", "eeprom_variainers", "eeprom_constENTS", "eeprom2contentens", "eeprom_extENTS", "eeprom_contentainers", "eeprom_datainers", "eeprom_contentents", "eeprom_constars", "eeprom2contentensions", "eeprom_cment", "eeprom_codents", "eeprom_contaps", "eeprom_codants", "eeprom_codENTS", "eeprom7varients", "eeprom_extens", "eeprom_contists", "eeprom_descensions", "eeprom2Contents", "eeprom7variists", "eeprom_contentens", "eeprom_containers", "eeprom_intents", "eeprom_contentENTS", "eeprom_contentants", "eeprom_varient", "eeprom_descens", "eeprom_cmENTS", "eeprom_contens", "eeprom_extents", "eeprom2Content", "eeprom_contentars", "eeprom2contents", "eeprom_Contents", "eeprom_content", "eeprom7varient", "eeprom_presentENTS", "eeprom_presenters", "eeprom_contENTS", "eeprom_contenters"]}}
{"project": "qemu", "commit_id": "0208def1cadd4f72f862e62548c2af268a543b20", "target": 1, "func": "void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n", "idx": 21508, "substitutes": {"dev": ["ver", "die", "Dev", "det", "app", "device", "serial", "debug", "exec", "bus", "plug", "def", "conn", "Device", "test", "disk", "av", "hw", "DEV", " device", "spec", "ve", "devices", "dem", "de", "mem", "phy", "usb", "ad", "block", "cam", "pad", "v", "ev", "serv"], "conf": ["sch", "app", "sum", "scan", "err", "th", "loc", "con", "pub", "ff", "map", "auth", "work", "fab", "Con", "xc", "zh", "comment", "list", "ns", "conv", "um", " Conf", "info", "Conf", "apache", "db", "cf", "cmd", "cc", "acc", "cp", "com", "dc", "hash", "co", "disc", "pkg", "def", "c", "aff", "fg", "ctx", "spec", "try", "config", "range", "nav", "req", "cache", "cast", "ca", "inf", "alias", "cap", "rc", "func", "cb", "gate", "init", "etc", "fac", "conn", "bc", "query", "prop", "cm", "priv", "ch", "gov", "cfg", "cons"]}}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n", "idx": 21511, "substitutes": {"client": ["core", "Client", "p", "type", "window", "contact", "conn", "c", "node", "cl", "cli", "connection", "cell", "manager", "server", "product", "project", "service", " clients", "config", "path", "pc", " Client", "cmd", "cache", "grid", "channel"], "start_addr": ["end_src", "startxaddress", "startxaddr", "start_phys", "start_name", "start_src", "end_sha", "start_address", "startersha", "startfxsrc", "startfxphys", "startername", "startfxaddr", "startxsrc", "starteraddr", "starteraddress", "start_sha", "startxphys", "startfxaddress", "end_address", "end_name", "end_phys"], "end_addr": ["start_address", "end_cmd", " end_address", "end_adr", "end_address", " end_tag", "end_tag", "start_cmd", " end_adr"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 21513, "substitutes": {"opaque": ["opac", "oce", "OPac", "popac", "opsce", " opce", "pac", "OPaque", "OPacity", "oaque", "opade", "oade", "pacity", "OPque", "opsade", "opacity", "opce", "popque", "paque", "pque", "opsaque", "popaque", "opque", " opade", "popacity"], "addr": ["gt", " address", "dh", "lr", "rc", "start", "kt", "alloc", "ref", "ix", "err", "offset", "add", "hash", "ay", "act", "src", "tz", "arr", "loc", "x", "id", "eth", "tx", "var", "asm", "coord", "hw", "ord", "mt", "shift", "ctx", "ptr", "now", "align", "rt", "hz", "grad", "alt", "hl", "Address", "adr", "at", "ad", "dr", "mem", "trans", "sp", "np", "address", "cmd", "pos", "work", "pad", "l", "sha"], "s": ["n", "p", "t", "is", "a", "o", "os", "parts", "ubs", "h", "m", "ss", "ns", "ses", "stats", "d", "ps", "i", "sts", "rs", "gs", "fs", "c", "ds", "ations", "ls", "ers", "hs", "bes", "S", "js", "g", "es", "its", "sq", "ts", "ents", "acs", "b", "resses", "w"], "saddr": ["Sha", "synha", "dscmd", "scoord", "Scmd", "dsptr", "Saddr", "sadd", "Sref", "daddress", "dsha", " susr", " sptr", "submitaddress", "dsaddr", "svaddress", "synptr", "Saddress", "ssusr", " sref", "daddr", " saddress", "ssaddr", "svcoord", "skid", "dkid", "Skid", "susr", " scoord", "synaddr", "scmd", "ssref", "ssptr", "submitkid", "svptr", "dadd", "svaddr", "Sptr", "Susr", "Sadd", "Scoord", "saddress", "submitadd", "syncmd", "sref", "submitaddr", "sha", "sptr"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    int i;\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    qemu_irq dma_irqs[6];\n\n    DriveInfo *dinfo;\n\n    SysBusDevice *busdev;\n\n\n\n    if (!core)\n\n        core = \"ti925t\";\n\n\n\n    /* Core */\n\n    s->mpu_model = omap310;\n\n    s->cpu = cpu_arm_init(core);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP15XX_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    memory_region_init_ram(&s->emiff_ram, NULL, \"omap1.dram\", s->sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->emiff_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_EMIFF_BASE, &s->emiff_ram);\n\n    memory_region_init_ram(&s->imif_ram, NULL, \"omap1.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->imif_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_IMIF_BASE, &s->imif_ram);\n\n\n\n    omap_clkm_init(system_memory, 0xfffece00, 0xe1008000, s);\n\n\n\n    s->ih[0] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[0], \"size\", 0x100);\n\n    qdev_prop_set_ptr(s->ih[0], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0xfffecb00);\n\n    s->ih[1] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[1], \"size\", 0x800);\n\n    qdev_prop_set_ptr(s->ih[1], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[1]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_15XX_IH2_IRQ));\n\n    /* The second interrupt controller's FIQ output is not wired up */\n\n    sysbus_mmio_map(busdev, 0, 0xfffe0000);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap1_dma_irq_map[i].ih],\n\n                                       omap1_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma_init(0xfffed800, dma_irqs, system_memory,\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_DMA_LCD),\n\n                           s, omap_findclk(s, \"dma_ck\"), omap_dma_3_1);\n\n\n\n    s->port[emiff    ].addr_valid = omap_validate_emiff_addr;\n\n    s->port[emifs    ].addr_valid = omap_validate_emifs_addr;\n\n    s->port[imif     ].addr_valid = omap_validate_imif_addr;\n\n    s->port[tipb     ].addr_valid = omap_validate_tipb_addr;\n\n    s->port[local    ].addr_valid = omap_validate_local_addr;\n\n    s->port[tipb_mpui].addr_valid = omap_validate_tipb_mpui_addr;\n\n\n\n    /* Register SDRAM and SRAM DMA ports for fast transfers.  */\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->emiff_ram),\n\n                         OMAP_EMIFF_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->imif_ram),\n\n                         OMAP_IMIF_BASE, s->sram_size);\n\n\n\n    s->timer[0] = omap_mpu_timer_init(system_memory, 0xfffec500,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER1),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[1] = omap_mpu_timer_init(system_memory, 0xfffec600,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER2),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[2] = omap_mpu_timer_init(system_memory, 0xfffec700,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER3),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n\n\n    s->wdt = omap_wd_timer_init(system_memory, 0xfffec800,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_WD_TIMER),\n\n                    omap_findclk(s, \"armwdt_ck\"));\n\n\n\n    s->os_timer = omap_os_timer_init(system_memory, 0xfffb9000,\n\n                    qdev_get_gpio_in(s->ih[1], OMAP_INT_OS_TIMER),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->lcd = omap_lcdc_init(system_memory, 0xfffec000,\n\n                            qdev_get_gpio_in(s->ih[0], OMAP_INT_LCD_CTRL),\n\n                            omap_dma_get_lcdch(s->dma),\n\n                            omap_findclk(s, \"lcd_ck\"));\n\n\n\n    omap_ulpd_pm_init(system_memory, 0xfffe0800, s);\n\n    omap_pin_cfg_init(system_memory, 0xfffe1000, s);\n\n    omap_id_init(system_memory, s);\n\n\n\n    omap_mpui_init(system_memory, 0xfffec900, s);\n\n\n\n    s->private_tipb = omap_tipb_bridge_init(system_memory, 0xfffeca00,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PRIV),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n    s->public_tipb = omap_tipb_bridge_init(system_memory, 0xfffed300,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PUB),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n\n\n    omap_tcmi_init(system_memory, 0xfffecc00, s);\n\n\n\n    s->uart[0] = omap_uart_init(0xfffb0000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART1),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    s->drq[OMAP_DMA_UART1_TX], s->drq[OMAP_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap_uart_init(0xfffb0800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART2),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    s->drq[OMAP_DMA_UART2_TX], s->drq[OMAP_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap_uart_init(0xfffb9800,\n\n                                qdev_get_gpio_in(s->ih[0], OMAP_INT_UART3),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    s->drq[OMAP_DMA_UART3_TX], s->drq[OMAP_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->dpll[0] = omap_dpll_init(system_memory, 0xfffecf00,\n\n                                omap_findclk(s, \"dpll1\"));\n\n    s->dpll[1] = omap_dpll_init(system_memory, 0xfffed000,\n\n                                omap_findclk(s, \"dpll2\"));\n\n    s->dpll[2] = omap_dpll_init(system_memory, 0xfffed100,\n\n                                omap_findclk(s, \"dpll3\"));\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap_mmc_init(0xfffb7800, system_memory,\n\n                           blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_OQN),\n\n                           &s->drq[OMAP_DMA_MMC_TX],\n\n                    omap_findclk(s, \"mmc_ck\"));\n\n\n\n    s->mpuio = omap_mpuio_init(system_memory, 0xfffb5000,\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_KEYBOARD),\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_MPUIO),\n\n                               s->wakeup, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"clk\", omap_findclk(s, \"arm_gpio_ck\"));\n\n    qdev_init_nofail(s->gpio);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->gpio), 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_GPIO_BANK1));\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s->gpio), 0, 0xfffce000);\n\n\n\n    s->microwire = omap_uwire_init(system_memory, 0xfffb3000,\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireTX),\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireRX),\n\n                    s->drq[OMAP_DMA_UWIRE_TX], omap_findclk(s, \"mpuper_ck\"));\n\n\n\n    s->pwl = omap_pwl_init(system_memory, 0xfffb5800,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n    s->pwt = omap_pwt_init(system_memory, 0xfffb6000,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x11);\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"mpuper_ck\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(s->ih[1], OMAP_INT_I2C));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP_DMA_I2C_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP_DMA_I2C_RX]);\n\n    sysbus_mmio_map(busdev, 0, 0xfffb3800);\n\n\n\n    s->rtc = omap_rtc_init(system_memory, 0xfffb4800,\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_TIMER),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_ALARM),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->mcbsp1 = omap_mcbsp_init(system_memory, 0xfffb1800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1RX),\n\n                    &s->drq[OMAP_DMA_MCBSP1_TX], omap_findclk(s, \"dspxor_ck\"));\n\n    s->mcbsp2 = omap_mcbsp_init(system_memory, 0xfffb1000,\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_TX),\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_RX),\n\n                    &s->drq[OMAP_DMA_MCBSP2_TX], omap_findclk(s, \"mpuper_ck\"));\n\n    s->mcbsp3 = omap_mcbsp_init(system_memory, 0xfffb7000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3RX),\n\n                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, \"dspxor_ck\"));\n\n\n\n    s->led[0] = omap_lpg_init(system_memory,\n\n                              0xfffbd000, omap_findclk(s, \"clk32-kHz\"));\n\n    s->led[1] = omap_lpg_init(system_memory,\n\n                              0xfffbd800, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    /* Register mappings not currenlty implemented:\n\n     * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310)\n\n     * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310)\n\n     * USB W2FC\t\tfffb4000 - fffb47ff\n\n     * Camera Interface\tfffb6800 - fffb6fff\n\n     * USB Host\t\tfffba000 - fffba7ff\n\n     * FAC\t\tfffba800 - fffbafff\n\n     * HDQ/1-Wire\tfffbc000 - fffbc7ff\n\n     * TIPB switches\tfffbc800 - fffbcfff\n\n     * Mailbox\t\tfffcf000 - fffcf7ff\n\n     * Local bus IF\tfffec100 - fffec1ff\n\n     * Local bus MMU\tfffec200 - fffec2ff\n\n     * DSP MMU\t\tfffed200 - fffed2ff\n\n     */\n\n\n\n    omap_setup_dsp_mapping(system_memory, omap15xx_dsp_mm);\n\n    omap_setup_mpui_io(system_memory, s);\n\n\n\n    qemu_register_reset(omap1_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 21538, "substitutes": {"system_memory": ["problemityarea", "problemitymemory", " system_mem", "system5media", "problemitystorage", " system_media", "systemitymetadata", "system_mem", " system_library", "system_metadata", "system5region", "systempymedia", "system_area", "problemitymem", "baseitystorage", "problem_memory", "system_media", " system_region", "problem_storage", "base_metadata", "system_library", "baseitymem", "systemitystorage", "base_memory", "base_storage", "systempylibrary", "systempymemory", "problem_mem", "systemitymem", "system_region", "baseitymetadata", " system_storage", "base_mem", "system_storage", "system5memory", "systemityarea", "problem_area", "systempymem", "system5storage", "systemitymemory", "baseitymemory"], "sdram_size": ["sdram2size", "sdram2length", "sdgram2size", "sdrum_height", "sdgram_info", "sdram32SIZE", "sdram_SIZE", "sdgram_scale", "sdram2len", "sdram1scale", "sdram__length", "sdram32size", "sdram_len", "sdram32height", "sdgram_SIZE", "sdgram2SIZE", "sdram_scale", "sdram2scale", "sdgram2info", "sdram32shape", "sdram_info", "sdram_height", "sdgram_size", "sdgram_length", "sdram67SIZE", "sdram2name", "sdram_shape", "sdram__SIZE", "sdgram2length", "sdrum_size", "sdram67scale", "sdram_name", "sdram1size", "sdram2SIZE", "sdram1info", "sdram1SIZE", "sdrum_SIZE", "sdram__name", "sdgram2scale", "sdram67size", "sdram67info", "sdram_length", "sdram2info", "sdgram_len", "sdrum_shape", "sdgram_name", "sdgram2name", "sdram__size"], "core": ["prot", "any", "binary", "rc", "one", "processor", "process", "force", "gate", "ce", "css", "score", "sync", "gc", "program", "th", "ores", "ie", "cy", "board", "con", "ice", "ro", "copy", "random", "socket", "none", "currency", "c", "ge", "ore", "aster", "wheel", "library", "base", "Core", "cpu", "cer", "clock", "cor", "sw", "crypt", "sc", "pc", "cycle", "cr", "native", "pure", "CPU", "gp", "ca", "cp", "forge", "type"], "i": ["n", "t", "p", " init", "a", " si", "si", " x", " out", "m", " sp", " l", " I", " start", " m", " ii", "e", "I", " copy", " count", " len", " j", "sp", " pi", " v", " fi", " p", " err"], "s": ["ports", "all", "is", "esm", "source", "m", "ims", "ops", "space", "sts", "ds", "details", "sv", "sw", "hs", "es", "als", "params", "steps", "sb", "as", "v", "n", "a", "o", "os", "changes", "ns", "sync", "bs", "cs", "copy", "fs", "aws", "results", "e", "states", "se", "status", "sm", "ats", "vs", "service", "g", "has", "ts", "qs", "b", "comm", "t", "sys", "settings", "sa", "r", "y", "sd", "stats", "d", "ps", "services", "args", "c", "spec", "ls", "ies", "S", "its", "sp", "conf", "obj", "store", "l", "csv", "p", "bits", "set", "parts", "h", "ss", "ses", "sports", "rs", "gs", "j", "south", "ms", "sam", "js", "w"], "dma_irqs": [" dma_ibrqs", " dma_ibrgs", " dma_ibrqq", " dma_irqq", " dma_irq", " dma_IRqs", " dma_mrqq", " dma_IRq", " dma_mrgs", " dma_ibrq", " dma_mrqs", " dma_IRqq", " dma_irgs", " dma_IRgs", " dma_mrq"], "dinfo": ["vInfo", " ddata", "rinfo", "dInfo", "rInfo", " dInfo", "vdata", "ddata", "rdata", "vinfo"], "busdev": ["boardDev", " busdevice", "blockdevice", "blockDev", " busDEV", "blockDEV", "boarddev", "busdevice", "boarddevice", "boardDEV", " busDev", "busDEV", "busDev", "blockdev"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_client_close(NBDClient *client)\n\n{\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    client->closing = true;\n\n\n\n    /* Force requests to finish.  They will drop their own references,\n\n     * then we'll close the socket and free the NBDClient.\n\n     */\n\n    shutdown(client->sock, 2);\n\n\n\n    /* Also tell the client, so that they release their reference.  */\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n}\n", "idx": 21549, "substitutes": {"client": ["Client", "policy", "plugin", "con", "contact", "user", "close", "peer", "cli", "player", "event", "server", "open", "component", "command", "port", "local", "type", "channel", "name", "use", "response", "resource", "list", "ay", "google", "complete", "handle", "connection", "cell", "link", "entry", "db", "active", "rule", "self", "at", "new", "template", "prefix", "pc", "cmd", "remote", "ace", "handler", "net", "public", "header", "core", "quit", "private", "force", "null", "co", "confirmed", "c", "cl", "cod", "request", "module", "problem", "patch", "nt", "config", "obj", "store", "man", "builder", "out", "closed", "connect", "check", "window", "ct", "key", "secure", "current", "code", "conn", "row", "controller", "admin", "query", "band", "pattern", "friend", "control", "console", "project", "tree", "address", "block", "form", "lib"]}}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,\n\n                             bool *again, ram_addr_t *ram_addr_abs)\n\n{\n\n    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,\n\n                                              ram_addr_abs);\n\n    if (pss->complete_round && pss->block == rs->last_seen_block &&\n\n        pss->offset >= rs->last_offset) {\n\n        /*\n\n         * We've been once around the RAM and haven't found anything.\n\n         * Give up.\n\n         */\n\n        *again = false;\n\n        return false;\n\n    }\n\n    if (pss->offset >= pss->block->used_length) {\n\n        /* Didn't find anything in this RAM Block */\n\n        pss->offset = 0;\n\n        pss->block = QLIST_NEXT_RCU(pss->block, next);\n\n        if (!pss->block) {\n\n            /* Hit the end of the list */\n\n            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n            /* Flag that we've looped */\n\n            pss->complete_round = true;\n\n            rs->ram_bulk_stage = false;\n\n            if (migrate_use_xbzrle()) {\n\n                /* If xbzrle is on, stop using the data compression at this\n\n                 * point. In theory, xbzrle can do better than compression.\n\n                 */\n\n                flush_compressed_data(rs);\n\n            }\n\n        }\n\n        /* Didn't find anything this time, but try again on the new block */\n\n        *again = true;\n\n        return false;\n\n    } else {\n\n        /* Can go around again, but... */\n\n        *again = true;\n\n        /* We've found something so probably don't need to */\n\n        return true;\n\n    }\n\n}\n", "idx": 21567, "substitutes": {"rs": ["sys", "ras", "rc", "mr", "rates", "aps", "r", "ros", "ks", "os", "ack", "runs", "ss", "ims", "amps", "orts", "rss", "vr", "src", "ps", "bs", "rows", "cs", "sts", "ars", "fs", "times", "gs", "ds", "s", "rys", "vers", "sr", "ls", "rt", "Rs", "ms", "res", "vs", "hs", "ris", "rm", "xs", "wcs", "ins", "ts", "rpm", "qs", "fps", "ry", "RS", "rings", "ra", "acks"], "pss": [" pSS", "cpiss", "Pss", " pse", "Pcss", "pse", "piss", " pcss", "opse", "cpSS", "prSS", " piss", "cpss", " pess", "cpse", "ppws", "ppiss", "pws", "ppSS", "psSS", "cpws", "cpess", "psws", " pps", "preess", "ppss", "ppcss", "psess", "opSS", "opass", "phess", "cpass", "opess", "prps", " pass", " pws", "opcss", " phess", "ppess", "prhess", "PSS", "cpcss", "pcss", "Piss", "pess", "opws", "psss", "ppps", "pSS", "precss", "pps", "opss", "pphess", "prews", "Pass", "press", "Pess", "pass", "prss"], "again": ["still", "done", "another", "eas", "aye", "out", "average", "din", "yo", "fresh", "peat", "said", "stall", "second", "these", "Again", "repeat", "aaa", "etc", "please", "forth", "called", "actually", "there", "alin", "coin", "abl", "extra", "addon", "more", "alt", "some", "ebin", "only", "stay", " Again", "also", "later", "made", "after", "plain", "ago", "each", "often", "many", "successfully"], "ram_addr_abs": ["ram_add_abs", "ram_add_absolute", "ram_addr_absolute", "ram_addr_ab", "ram_add_ab", "ram_add_ref", "ram_address_ts", "ram_address_abs", "ram_address_absolute", "ram_addr_ts", "ram_addr_ref", "ram_address_ab"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n", "idx": 21569, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)\n\n{\n\n    Wmv2Context *const w = (Wmv2Context *) s;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (w->j_type_bit)\n\n            w->j_type = get_bits1(&s->gb);\n\n        else\n\n            w->j_type = 0; // FIXME check\n\n\n\n        if (!w->j_type) {\n\n            if (w->per_mb_rl_bit)\n\n                s->per_mb_rl_table = get_bits1(&s->gb);\n\n            else\n\n                s->per_mb_rl_table = 0;\n\n\n\n            if (!s->per_mb_rl_table) {\n\n                s->rl_chroma_table_index = decode012(&s->gb);\n\n                s->rl_table_index        = decode012(&s->gb);\n\n            }\n\n\n\n            s->dc_table_index = get_bits1(&s->gb);\n\n        }\n\n        s->inter_intra_pred = 0;\n\n        s->no_rounding      = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \\n\",\n\n                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,\n\n                   s->dc_table_index, s->per_mb_rl_table, w->j_type);\n\n        }\n\n    } else {\n\n        int cbp_index;\n\n        w->j_type = 0;\n\n\n\n        parse_mb_skip(w);\n\n        cbp_index = decode012(&s->gb);\n\n        if (s->qscale <= 10) {\n\n            int map[3]         = { 0, 2, 1 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else if (s->qscale <= 20) {\n\n            int map[3]         = { 1, 0, 2 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else {\n\n            int map[3]         = {2,1,0};\n\n            w->cbp_table_index = map[cbp_index];\n\n        }\n\n\n\n        if (w->mspel_bit)\n\n            s->mspel = get_bits1(&s->gb);\n\n        else\n\n            s->mspel = 0; // FIXME check\n\n\n\n        if (w->abt_flag) {\n\n            w->per_mb_abt = get_bits1(&s->gb) ^ 1;\n\n            if (!w->per_mb_abt)\n\n                w->abt_type = decode012(&s->gb);\n\n        }\n\n\n\n        if (w->per_mb_rl_bit)\n\n            s->per_mb_rl_table = get_bits1(&s->gb);\n\n        else\n\n            s->per_mb_rl_table = 0;\n\n\n\n        if (!s->per_mb_rl_table) {\n\n            s->rl_table_index        = decode012(&s->gb);\n\n            s->rl_chroma_table_index = s->rl_table_index;\n\n        }\n\n\n\n        s->dc_table_index   = get_bits1(&s->gb);\n\n        s->mv_table_index   = get_bits1(&s->gb);\n\n\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n\n        s->no_rounding     ^= 1;\n\n\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n\n                   s->rl_table_index, s->rl_chroma_table_index,\n\n                   s->dc_table_index, s->mv_table_index,\n\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n\n                   s->inter_intra_pred);\n\n        }\n\n    }\n\n    s->esc3_level_length = 0;\n\n    s->esc3_run_length   = 0;\n\n    s->picture_number++; // FIXME ?\n\n\n\n    if (w->j_type) {\n\n        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);\n\n\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21576, "substitutes": {"s": ["is", "source", "m", "ims", "err", "space", "sts", "ds", "ex", "sv", "sw", "ssl", "hs", "ess", "es", "ins", "als", "params", "less", "sb", "as", "v", "n", "state", "a", "os", "changes", "ns", "conv", "bs", "cs", "aws", "fs", "bis", "se", "status", "ers", "ats", "vs", "self", "g", "wcs", "ts", "sg", "qs", "wa", "b", "comm", "t", "sys", "settings", "y", "aw", "stats", "d", "ps", "services", "args", "c", "Ws", "z", "scl", "spec", "ls", "sh", "we", "ies", "S", "its", "sp", "conf", "l", "series", "serv", "csv", "p", "er", "bits", "parts", "set", "h", "ss", "ses", "https", "sports", "rs", "gs", "st", "south", "sam", "ms", "js", "http", "sq", "ges", "acs"], "w": ["kw", "t", "writer", "ht", "way", "mm", "wh", "write", "f", "h", "rew", "window", "ns", "y", "words", "ww", "aw", "nw", "wi", "d", "x", "wp", "rs", "fw", "c", "wr", "watch", "iw", "Ws", "hw", "lang", "rw", "wx", "wed", "word", "warning", "wl", "web", "q", "ex", "sw", "wb", "self", "we", "W", "ow", "wal", "mem", "g", "wine", "wcs", "wo", "cam", "wt", "wat", "tw", "work", "saw", "ew", "wa", "l", "v"], "cbp_index": ["cbp_zero", "cbpy_server", "cbpa_Index", "cbp_value", "cbpy_status", "cbpd_index", "cbpt_size", "cbptindex", "cbp_i", "cbp_num", "cbpd_handle", "cbpa_key", "cbpatIndex", "cbpti", "cbpt_position", "cbpt_seed", "cbptkey", "cbp_ind", "cbpy_num", "cbpa_i", "cbpy_index", "cbptIndex", "cbpati", "cbpatindex", "cbp_status", "cbp_Index", "cbp_server", "cbpatkey", "cbp_position", "cbp_entry", "cbp_size", "cbpa_index", "cbpt_index", "cbpd_entry", "cbpt_ind", "cbp_seed", "cbpd_zero", "cbp_handle", "cbp_key", "cbpt_value"], "map": ["master", "use", "cap", "view", "load", "age", "pack", "print", " Map", "maps", "app", "set", "list", "mm", "index", "check", "m", "filter", "window", "hash", "add", "transform", "menu", "scale", "table", "def", "mask", "copy", "down", "tap", "bridge", "ape", "bar", "code", "test", "size", "le", "snap", "show", "ap", "export", "wrap", "dict", "link", "mg", "MAP", "Map", "match", "config", "block", "clear", "conf", "tree", "cache", "pad", "v", "save"]}}
{"project": "FFmpeg", "commit_id": "a494792961a08f9f0e47e7eeed65e609178ff436", "target": 1, "func": "static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n", "idx": 21583, "substitutes": {"table": ["master", "all", "state", "final", "article", "source", "index", "list", "private", "set", "window", "database", "total", "array", "code", "empty", "row", "tab", "Table", "batch", "tr", "result", "module", "map", "buffer", "db", "entry", "page", "stable", "try", "TABLE", "able", "tree", "block", "interface", "cache", "variable", "store", "file", "public", "header"], "elemsize": ["Elecsizes", "elemescale", "eleminsize", "eleMSize", "eleMSizer", "Elecsizer", "elemersze", "elemscale", "elemesizes", " elemscale", "elecsize", "elelemsize", "elminsize", "elemsze", "elemsizer", " elemsime", "eleminsiz", "elmsiz", "elecsiz", "elemsocket", "Elemsizer", "elemsiz", "eleminscale", "elemsizes", "elelemsime", " eleminscale", "elemersizer", "eleminsizer", " eleminsize", "eleminsime", "elemersizes", " eleminsime", "elecsizer", "elemesze", "elmsizer", "elminsizer", "Elecsize", "elemesime", "elminsocket", "elemesizer", "elmsize", "elemesize", "elemersize", "elecsizes", "Elecsze", "Elemsizes", "elemsime", "Elemsze", "elelemscale", "elminsiz", "eleMSocket", "Elemsize", "elmsocket", "elecsocket", " eleminsizer", "elelemsizer", "elecsze", "eleminsocket", "eleMSiz", " elemsizer"], "inc": ["asc", "resp", "pack", "amount", "vol", "desc", "include", "ref", "sum", "err", "add", "disc", "ac", "init", "inv", "circ", "enc", "incre", "pl", "ind", "ext", "frac", "ec", "ipl", "Inc", "alpha", "exc", " INC", "sc", "INC", "up", "in", "iter", "integ", "ins", "conf", "occ", "rec", "gain", "cc", "acc", "fc", "inf", "includes"], "y_tab": ["y2tab", "y_buf", "yjtab", " y_Tab", "yttable", "y_ab", "y2Tab", "my_buf", "y2table", "yjtable", "yjlist", "my_tab", "y2ab", "yttab", "yjbuf", "my_table", "y_list", " y_ab", "my_list", "ytlist", "ytbuf", "y_Tab"], "i": ["bi", "n", "ij", "t", "phi", "\u0438", "is", "p", "ic", "it", "si", "di", "index", "iu", "ai", "xi", "f", "ix", "m", "y", "ims", "init", "multi", "ji", "im", "zi", "ei", "x", "id", " ii", "sim", "ind", "gi", "span", "I", "qi", "ki", "ti", "j", "ip", "ini", "batch", "asi", "cli", "li", "q", "ui", "fi", "oi", "in", "iter", "ci", "g", "mi", "ii", "pi", "hi", "v", "b", "chain"], "y_table": ["yPtable", "y__table", "yPtab", "yPTABLE", "my_master", "yPmaster", "my_tab", "my_TABLE", "y_master", "my_table", "y_top", "y__top", "y_buffer", "y_TABLE", "y_cache", "my_top", "my_cache", "y_t", "y__tab", " y_t", "y__cache", " y_buffer"]}}
{"project": "FFmpeg", "commit_id": "f3e5a7844bbf13620ca4b6a5e19aa087c9141b15", "target": 0, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 21584, "substitutes": {"alac": ["allacc", "placs", "aldacet", "aliace", "alacer", "elljac", "haljac", " alAC", "alcache", " alacc", "malacer", "placc", "aliaca", "alacc", "haliac", "aliact", "halacc", " alacet", "aldacon", "stalacon", "aliAC", " alAc", "aliacer", "alerac", "aldAC", "relaca", "malacc", "malace", "balacer", "alica", "stalacs", "altacon", "plac", "aliica", "aliAc", "alaca", "alicache", "placon", "aleraca", "stalcam", "balace", "balact", "alacet", "altfc", "alace", "relAc", " aljac", "elAC", "aldacs", "aliacet", "aliacc", "balAc", "talacon", "ellAC", "ellacc", "alAC", "allAc", "relac", "alifc", " alace", "altacs", " alacer", "balcache", "halac", "talac", "alcam", "altac", "alljac", "aldac", "malact", "stalAc", "elac", "altica", "alliac", "aliac", "elAc", "stalaca", "aliiac", "alact", "aljac", "malacon", "alAc", "allaca", "stalac", "allac", "altaca", "alerfc", "talacs", "talcam", "malacs", "alacon", "alijac", "altacc", "eljac", "alerica", "allAC", "alacs", "malcache", "malAc", "aldcam", "balac", "alfc", "malac", "ellac"], "ch": ["chat", "sch", "cho", "msg", "chart", " cs", "th", "unch", " sch", "cur", "batch", "cht", "col", "och", "bh", "qu", "gr", "bt", " ex", "client", " chip", "chain", "channel", "zh", "wh", "chan", "unk", " sc", "x", "i", "ind", "cs", "ih", "cell", "chron", "ech", "cp", "ht", "chn", "chrom", "CH", " col", "y", " y", "tch", "atch", "c", "cl", "Ch", "bg", "sh", "kh", " batch", "conf", " c", "gh", "ca", "el", " cha", "history", "mk", "out", "ach", "ich", "ek", "h", "go", "sk", "pl", "conn", " channel", "quant", " cur", "chip", "cor", "hl", " h", " th", " cho"]}}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static int put_cod(Jpeg2000EncoderContext *s)\n\n{\n\n    Jpeg2000CodingStyle *codsty = &s->codsty;\n\n\n\n    if (s->buf_end - s->buf < 14)\n\n        return -1;\n\n\n\n    bytestream_put_be16(&s->buf, JPEG2000_COD);\n\n    bytestream_put_be16(&s->buf, 12); // Lcod\n\n    bytestream_put_byte(&s->buf, 0);  // Scod\n\n    // SGcod\n\n    bytestream_put_byte(&s->buf, 0); // progression level\n\n    bytestream_put_be16(&s->buf, 1); // num of layers\n\n    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){\n\n        bytestream_put_byte(&s->buf, 2); // ICT\n\n    }else{\n\n        bytestream_put_byte(&s->buf, 0); // unspecified\n\n    }\n\n    // SPcod\n\n    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height\n\n    bytestream_put_byte(&s->buf, 0); // cblk style\n\n    bytestream_put_byte(&s->buf, codsty->transform); // transformation\n\n    return 0;\n\n}\n", "idx": 21585, "substitutes": {"s": ["n", "comm", "ties", "is", "sys", "gins", "a", "o", "os", "m", "h", "ns", "ss", "ims", "changes", "ses", "stats", "bs", "ps", "ops", "eps", "cs", "sts", "times", "aws", "gs", "rs", "e", "c", "ars", "ds", "bis", "fs", "results", "se", "ls", "details", "ers", "ms", "sv", "ats", "vs", "hs", "S", "js", "ess", "es", "g", "has", "sq", "ts", "als", "its", "xs", "gets", "ads", "sports", "conf", "params", "qs", "less", "acs", "sb", "b", "as", "tes", "events", "serv"], "codsty": [" codusr", "odestyle", "odsty", "codesty", "Codstyle", " copfo", "condstri", "codso", "codeso", "odstro", " copstyle", "odestyles", "odstyle", "odfo", "cvestyle", " copstro", "cvsty", "codstra", "labstra", "labsty", " copsty", " codstro", "rodusr", "rodstyle", "Codestyle", "codstro", "rodsty", "labusr", "cvstyle", "codestyle", "rodestyles", " codestyles", "odso", " codstri", "codstri", "Codsty", "labestyle", "codusr", "condstyle", " codestyle", "condsty", "codstyle", "odstra", "Codusr", "codfo", " codstra", "codestyles", "condfo", "odusr", "cvso", " codfo", "codeestyle", "odstri", " codstyle"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "substitutes": {"mr": ["mk", "lr", "rn", "r", "mm", "nr", "m", "pm", "irm", "ml", "vr", "rr", "rar", "rs", "wr", "RM", "tr", "MR", "asm", "hr", "mt", "sr", "bm", "br", "pr", "ms", "kr", "hm", "adr", "rm", "drm", "ocr", "dr", "rpm", "rl", "tm", "Mr", "mn", "MT"], "addr": ["r", "arp", "ack", "ref", "ix", "offset", "add", "hash", "act", "ha", "wid", "arr", "url", "id", "ld", "eth", "oad", "tx", "node", "var", "host", "ip", "hw", "coord", "ord", "ptr", "ag", "align", "rt", "res", "map", "ow", "dr", "ad", "address", "ace", "work", "pad", "sha", "attr", "alias"], "size": ["alloc", "sym", "sum", "SIZE", "length", "scale", "offset", "sd", "fee", "gz", "count", "needed", "style", "cs", "code", "dim", "max", "st", "bytes", "z", "mode", "ize", "sy", "iz", "sh", "owner", "storage", " sizes", "area", "mem", "Size", "ci", "sq", "ty", "address", "len", "sha", "ram", "type"], "client": ["name", "parent", "Client", "t", "et", "ping", "m", "window", "null", "connected", "file", "id", "contact", "sim", "conn", "socket", "confirmed", "con", "node", "cli", "connection", "ctx", "cell", "manager", "net", "server", "owner", "buffer", "self", "new", "util", "block", "address", "ient", "cache", "obj", "port", "local", "public"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n    int ret;\n\n\n\n    ret = bdrv_get_info(bs, &bdi);\n\n    if (ret < 0 || bdi.cluster_size == 0) {\n\n        return bs->request_alignment;\n\n    } else {\n\n        return bdi.cluster_size;\n\n    }\n\n}\n", "idx": 21622, "substitutes": {"bs": ["bi", "is", "lbs", "bits", "bf", "ks", "ubs", "ns", "bps", "BS", "ss", "ses", "bl", "iss", "ps", "cs", "bc", "sts", "fs", "gs", "rs", "ds", "bis", "s", "ab", "ls", "bm", "bh", "ms", "bles", "vs", "bes", "its", "ts", "obs", "pb", "bt", "blocks", "sb", "bos", "b", "cks", "bas", "bp", "bb"], "bdi": ["bbci", "cdi", "cini", "bbidi", "jci", "dini", "dci", "jdi", "bidi", "bmidi", "ddi", "abzi", "bmci", "wbidi", " bidi", " bci", "abni", " bini", "jidi", "cci", "cidi", "bddi", "bdidi", "bini", "wbdi", "abidi", "bni", "bbdi", "wbci", "didi", "bdzi", "bmdi", "wbni", "bdci", "bzi", "abci", "abdi", " bni", "bmzi", "bci"], "ret": [" Ret", "cert", "gt", "t", "re", "out", "lit", "it", "usr", "print", "et", "r", "cont", "set", "det", "red", "back", "f", "rets", "Return", "rem", "err", "Ret", "val", "inter", "ert", "ter", "ext", "oret", "bit", "reset", "sat", "tr", "status", "result", "mt", "deg", "ount", "ft", "rt", "vet", "res", "alt", "iter", "nt", "sub", "RET", "cmd", "elt", "ry", "att", "v"]}}
{"project": "FFmpeg", "commit_id": "40cf1bbacc6220a0aa6bed5c331871d43f9ce370", "target": 0, "func": "static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                        const AVFrame *frame, int *got_packet)\n\n{\n\n    int enc_size = 0;\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroEncoder *encoder = p_schro_params->encoder;\n\n    struct FFSchroEncodedFrame *p_frame_output = NULL;\n\n    int go = 1;\n\n    SchroBuffer *enc_buf;\n\n    int presentation_frame;\n\n    int parse_code;\n\n    int last_frame_in_sequence = 0;\n\n    int pkt_size, ret;\n\n\n\n    if (!frame) {\n\n        /* Push end of sequence if not already signalled. */\n\n        if (!p_schro_params->eos_signalled) {\n\n            schro_encoder_end_of_stream(encoder);\n\n            p_schro_params->eos_signalled = 1;\n\n        }\n\n    } else {\n\n        /* Allocate frame data to schro input buffer. */\n\n        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);\n\n        if (!in_frame)\n\n            return AVERROR(ENOMEM);\n\n        /* Load next frame. */\n\n        schro_encoder_push_frame(encoder, in_frame);\n\n    }\n\n\n\n    if (p_schro_params->eos_pulled)\n\n        go = 0;\n\n\n\n    /* Now check to see if we have any output from the encoder. */\n\n    while (go) {\n\n        int err;\n\n        SchroStateEnum state;\n\n        state = schro_encoder_wait(encoder);\n\n        switch (state) {\n\n        case SCHRO_STATE_HAVE_BUFFER:\n\n        case SCHRO_STATE_END_OF_STREAM:\n\n            enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n\n            if (enc_buf->length <= 0)\n\n                return AVERROR_BUG;\n\n            parse_code = enc_buf->data[4];\n\n\n\n            /* All non-frame data is prepended to actual frame data to\n\n             * be able to set the pts correctly. So we don't write data\n\n             * to the frame output queue until we actually have a frame\n\n             */\n\n            if ((err = av_reallocp(&p_schro_params->enc_buf,\n\n                                   p_schro_params->enc_buf_size +\n\n                                   enc_buf->length)) < 0) {\n\n                p_schro_params->enc_buf_size = 0;\n\n                return err;\n\n            }\n\n\n\n            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n\n                   enc_buf->data, enc_buf->length);\n\n            p_schro_params->enc_buf_size += enc_buf->length;\n\n\n\n\n\n            if (state == SCHRO_STATE_END_OF_STREAM) {\n\n                p_schro_params->eos_pulled = 1;\n\n                go = 0;\n\n            }\n\n\n\n            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {\n\n                schro_buffer_unref(enc_buf);\n\n                break;\n\n            }\n\n\n\n            /* Create output frame. */\n\n            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));\n\n            if (!p_frame_output)\n\n                return AVERROR(ENOMEM);\n\n            /* Set output data. */\n\n            p_frame_output->size     = p_schro_params->enc_buf_size;\n\n            p_frame_output->p_encbuf = p_schro_params->enc_buf;\n\n            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&\n\n                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))\n\n                p_frame_output->key_frame = 1;\n\n\n\n            /* Parse the coded frame number from the bitstream. Bytes 14\n\n             * through 17 represesent the frame number. */\n\n            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n\n\n\n            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,\n\n                                     p_frame_output);\n\n            p_schro_params->enc_buf_size = 0;\n\n            p_schro_params->enc_buf      = NULL;\n\n\n\n            schro_buffer_unref(enc_buf);\n\n\n\n            break;\n\n\n\n        case SCHRO_STATE_NEED_FRAME:\n\n            go = 0;\n\n            break;\n\n\n\n        case SCHRO_STATE_AGAIN:\n\n            break;\n\n\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown Schro Encoder state\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* Copy 'next' frame in queue. */\n\n\n\n    if (p_schro_params->enc_frame_queue.size == 1 &&\n\n        p_schro_params->eos_pulled)\n\n        last_frame_in_sequence = 1;\n\n\n\n    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);\n\n\n\n    if (!p_frame_output)\n\n        return 0;\n\n\n\n    pkt_size = p_frame_output->size;\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n\n        pkt_size += p_schro_params->enc_buf_size;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", pkt_size);\n\n        goto error;\n\n    }\n\n\n\n    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n\n    avctx->coded_frame->key_frame = p_frame_output->key_frame;\n\n    /* Use the frame number of the encoded frame as the pts. It is OK to\n\n     * do so since Dirac is a constant frame rate codec. It expects input\n\n     * to be of constant frame rate. */\n\n    pkt->pts =\n\n    avctx->coded_frame->pts = p_frame_output->frame_num;\n\n    pkt->dts = p_schro_params->dts++;\n\n    enc_size = p_frame_output->size;\n\n\n\n    /* Append the end of sequence information to the last frame in the\n\n     * sequence. */\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n\n        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n\n               p_schro_params->enc_buf_size);\n\n        enc_size += p_schro_params->enc_buf_size;\n\n        av_freep(&p_schro_params->enc_buf);\n\n        p_schro_params->enc_buf_size = 0;\n\n    }\n\n\n\n    if (p_frame_output->key_frame)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nerror:\n\n    /* free frame */\n\n    libschroedinger_free_frame(p_frame_output);\n\n    return ret;\n\n}\n", "idx": 21641, "substitutes": {"avctx": ["aptx", "cvcontext", " avconn", "aftx", "svctx", "avcontext", "abtx", "avtx", "apctx", "avctl", "apcontext", "svtx", "afcontext", "apctl", "abconn", "cvctx", "afctx", "cvconn", "abctx", "svconn", "afctl", "svcontext", " avctl", " avcontext", " avtx", "avconn", "cvtx", "abcontext"], "pkt": [" pdu", "pdu", "ppkt", " pqt", "packet", "cpkt", "cpdu", "ppqt", "pqt", "cpacket", "ppdu", "cpqt", "ppacket", " packet"], "frame": ["rame", "time", "hello", "message", "iframe", "allowed", "context", "one", "ce", "process", "f", "window", "image", "none", "trace", "code", "forced", "row", "fw", "data", "close", "info", "fb", "frames", "show", "profile", "Frame", "fr", "word", "event", "scene", " framed", "part", "AME", "feat", "cf", " timeframe", "face", " Frame", "sequence", "feature", "error", "instance", "ence", "block", "fram", "flow", "chain", "channel"], "got_packet": ["got_packed", "got_packET", "got_buckacket", "got_bucked", "got_packacket", "got_compacket", "got_ppET", "got_ppet", "got_pped", "got_ppacket", "got_bucket", "got_compET", "got_buckET", "got_comped", "got_compet"], "p_schro_params": ["p_schropromode", "p_schro__marks", "p_schlo_errors", "p_schro3ams", "p_schrocparam", "p_schra_data", "p2ch_", "p_schrojops", "p_schros_ams", "p_schro_points", "p_schro_pins", "p_schro__args", "p_schrob_ams", "p_schacocmodules", "p_schro_param", "p_schro_data", "p_schrojmarks", "p_schrob_args", "p_schro2ops", "p_schrob_data", "p_schra_params", "p_ch_", "p_schros_ops", "p_schlo_marks", "p_schros_caps", "p_schroptcaps", "p_schrospins", "p_schrosams", "p_schaco_ams", "p_schro__errors", "p_schrob_pins", "p_schlo_args", "p_schro_marks", "p_schro_conf", "p_schro2params", "p_schro_errors", "p_schro3args", "p_schro__params", "p2sch_", "p_schro2args", "p_schlo_ops", "p_schro_caps", "p_schacocparam", "p_schroproparams", "p_schroptams", "p_schro__ops", "p_schlo_points", "p_schlo_ams", "p_schro_ams", "p_schrocparams", "p_schro2ctx", "p_schrocmodules", "p_schaco_modules", "p_schroproams", "p_schro__ams", "p_schra__ams", "p_schro_ops", "p_schro3pins", "p_schro3params", "p_schro_args", "p_schroprodata", "p_schrosargs", "p_schros_names", "p_schro_names", "p_schrocams", "p_schlo_params", "p_schra__data", "p_schro__data", "p_schacocams", "p_schro2ams", "p_schacocparams", "p_schro_mode", "p_schrojparams", "p_schra__ctx", "p_schrosparams", "p_schro2data", "p_schrob_params", "p_schra_ams", "p_schro__ctx", "p_sch_", "p_schroptparams", "p_schro_modules", "p_schros_conf", "p_schrojerrors", "p_schrob_mode", "p_schros_args", "p_schro_ctx", "p_schroptconf", "p_schaco_param", "p_schra__params", "p_schaco_params", "p_her_", "p_schra_ctx", "p_schros_params", "p_Sch_"], "encoder": ["enoded", "Encoder", "encoded", "encoe", " encramer", "escoding", "ecoser", "ecamer", "escamer", "encoding", "encater", "Enciever", "ecramer", " enccer", " encuter", "enccer", "enoding", "enoe", "encoser", "ecoded", "enuter", "ecuter", "Encressor", "eciever", "Encoser", "enoser", "enener", "enater", "ecoder", "eccer", "encator", "encuter", "encressor", "ecressor", "ecator", "fcamer", "escoder", "enator", "fcener", "ecoe", "fccer", "enressor", "enoder", "fcoder", "escoe", "enciever", " encater", "ecater", "enramer", " encator", "encramer", "encener", "enamer", "eniever", "esccer", " encoded", "ecoding", "escener", "encamer", "encer"], "p_frame_output": ["p_frame2output", "p_frame2out", "p_frame2input", "p_frame_input", "p_frame_data", "p_channel_input", "p_frame2data", "p_channel_data", "p_frame_out", "p_channel_output", "p_channel_out"], "enc_buf": ["enc_uf", "ec_buf", " enc_cv", "encockuf", "dec2buff", "encablebu", "ec_uf", "abcablefunc", "ec_bag", "enc2buf", " enc_queue", "enc_msg", "enc2pkg", "abcablebu", "ENC_data", "enc_bu", "ec_buffer", "enc_code", "dec_buffer", "ENC_buff", " enc2buf", "encMemdata", " enc_vec", "dec2buf", "enc_queue", "enc_buffer", "ec_cb", "encockbuffer", "encablefunc", "abc_bu", "enc_func", "abc_buf", " enc_br", "ENC_msg", " enc_buff", "ENC_buf", "encMemmsg", "enc_cb", "enc_cv", "enc64func", "enc64br", "encockbag", "enc64pkg", " enc2br", "dec_vec", " enc_buffer", "ec_pkg", "enc2br", "dec_buff", "dec_buf", "enc_br", "enc2vec", "encockbuf", "enc_vec", "encablebuf", "ec_max", "enc_max", "encMembuf", " enc_code", "enc2queue", "enc_buff", "abc_func", "encMembuff", "enc64bu", "dec2buffer", "enc2buffer", "enc2uf", "enc2buff", "dec2vec", "enc_data", " enc2queue", "enc_bag", "enc64buf", " enc2buffer", "abcablebuf", "enc64buffer", " enc_uf", "enc64queue", "enc_pkg"], "presentation_frame": ["presentation____frames", "presentation____component", "presentATION_flow", "presentation_frames", "presentation_flow", "presentation____info", "presentATION_frames", "presentATION_component", "presentation____frame", "presentation____flow", "presentation_info", "presentATION_info", "presentation____event", "presentation_event", "presentATION_frame", "presentATION_event", "presentation_component"], "parse_code": ["se_code", "se_data", "se_error", "se_codes", "parse2code", "parse2error", "parse2codes", " parse_error", "parse_codes", "parse_error", "parse_data", "parse___error", "parse2data", "parse___code", "parseablecode", " parse_codes", "parse___message", "parseablecodes", "parse___codes", " parse_message", "parse_message", "parseableerror", "parseabledata"], "pkt_size": ["pkt_fee", "pkt_name", "packet_len", "packet_fee", "packet_size", "packet_name", "pkt_len"], "ret": ["gt", "resp", "out", "txt", "ref", "Ret", "gc", "format", "val", "info", "args", "reset", "jp", "result", "big", "fi", "res", "fin", "new", "mem", "RET", "cmd", "len", "flag"], "in_frame": ["inmyframe", "inmysample", "any_message", "in67Frame", "in67row", "inOnebody", "in67frame", "in_message", "any_frame", " in_Frame", "inOneFrame", " in_time", "in_Frame", "in_stream", "inOnesample", "in_body", " in_sample", "any67message", "inmyFrame", "any_row", "in_sample", " in_body", "any67row", "in67message", "inmybody", " in_stream", "in_row", "inOneframe", "in_time", "any_Frame", "any67frame", "any67Frame"], "err": ["resp", "er", "msg", "ror", "out", "usr", "rn", "mr", "txt", "die", "rb", "r", "it", "ach", "cb", "nr", "h", "notice", "order", "act", "gz", "ner", "vr", "count", "val", "arr", "rr", "code", "e", "or", "str", "fr", "buf", "br", "cer", "pr", "kr", "Er", "res", "iter", "try", "ch", "error", "Error", "inner", "req", "cr", "cmd", "conf", "obj", "bug", "cfg", "attr"], "state": ["name", "loop", "t", "scope", "msg", "start", "tag", "it", "where", "print", "r", "kind", "index", "list", "State", "stat", "commit", "policy", "go", "zone", "progress", "debug", "al", "m", "init", "count", "key", "style", "code", "trace", "info", "str", "test", "st", "states", "no", "status", "result", "lock", "mode", "event", "active", "reg", "area", "error", "has", "from", "clear", "store", "next", "can", "ne", "to", "STATE", "success", "type"]}}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int fill_default_ref_list(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n    int smallest_poc_greater_than_current = -1;\n\n    int structure_sel;\n\n    Picture sorted_short_ref[32];\n\n    Picture field_entry_list[2][32];\n\n    Picture *frame_list[2];\n\n\n\n    if (FIELD_PICTURE) {\n\n        structure_sel = PICT_FRAME;\n\n        frame_list[0] = field_entry_list[0];\n\n        frame_list[1] = field_entry_list[1];\n\n    } else {\n\n        structure_sel = 0;\n\n        frame_list[0] = h->default_ref_list[0];\n\n        frame_list[1] = h->default_ref_list[1];\n\n    }\n\n\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        int list;\n\n        int len[2];\n\n        int short_len[2];\n\n        int out_i;\n\n        int limit= INT_MIN;\n\n\n\n        /* sort frame according to POC in B slice */\n\n        for(out_i=0; out_i<h->short_ref_count; out_i++){\n\n            int best_i=INT_MIN;\n\n            int best_poc=INT_MAX;\n\n\n\n            for(i=0; i<h->short_ref_count; i++){\n\n                const int poc= h->short_ref[i]->poc;\n\n                if(poc > limit && poc < best_poc){\n\n                    best_poc= poc;\n\n                    best_i= i;\n\n                }\n\n            }\n\n\n\n            assert(best_i != INT_MIN);\n\n\n\n            limit= best_poc;\n\n            sorted_short_ref[out_i]= *h->short_ref[best_i];\n\n            tprintf(h->s.avctx, \"sorted poc: %d->%d poc:%d fn:%d\\n\", best_i, out_i, sorted_short_ref[out_i].poc, sorted_short_ref[out_i].frame_num);\n\n            if (-1 == smallest_poc_greater_than_current) {\n\n                if (h->short_ref[best_i]->poc >= s->current_picture_ptr->poc) {\n\n                    smallest_poc_greater_than_current = out_i;\n\n                }\n\n            }\n\n        }\n\n\n\n        tprintf(h->s.avctx, \"current poc: %d, smallest_poc_greater_than_current: %d\\n\", s->current_picture_ptr->poc, smallest_poc_greater_than_current);\n\n\n\n        // find the largest POC\n\n        for(list=0; list<2; list++){\n\n            int index = 0;\n\n            int j= -99;\n\n            int step= list ? -1 : 1;\n\n\n\n            for(i=0; i<h->short_ref_count && index < h->ref_count[list]; i++, j+=step) {\n\n                int sel;\n\n                while(j<0 || j>= h->short_ref_count){\n\n                    if(j != -99 && step == (list ? -1 : 1))\n\n                        return -1;\n\n                    step = -step;\n\n                    j= smallest_poc_greater_than_current + (step>>1);\n\n                }\n\n                sel = sorted_short_ref[j].reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n                frame_list[list][index  ]= sorted_short_ref[j];\n\n                frame_list[list][index++].pic_id= sorted_short_ref[j].frame_num;\n\n            }\n\n            short_len[list] = index;\n\n\n\n            for(i = 0; i < 16 && index < h->ref_count[ list ]; i++){\n\n                int sel;\n\n                if(h->long_ref[i] == NULL) continue;\n\n                sel = h->long_ref[i]->reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n\n\n                frame_list[ list ][index  ]= *h->long_ref[i];\n\n                frame_list[ list ][index++].pic_id= i;\n\n            }\n\n            len[list] = index;\n\n        }\n\n\n\n        for(list=0; list<2; list++){\n\n            if (FIELD_PICTURE)\n\n                len[list] = split_field_ref_list(h->default_ref_list[list],\n\n                                                 h->ref_count[list],\n\n                                                 frame_list[list],\n\n                                                 len[list],\n\n                                                 s->picture_structure,\n\n                                                 short_len[list]);\n\n\n\n            // swap the two first elements of L1 when L0 and L1 are identical\n\n            if(list && len[0] > 1 && len[0] == len[1])\n\n                for(i=0; h->default_ref_list[0][i].data[0] == h->default_ref_list[1][i].data[0]; i++)\n\n                    if(i == len[0]){\n\n                        FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n                        break;\n\n                    }\n\n\n\n            if(len[list] < h->ref_count[ list ])\n\n                memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));\n\n        }\n\n\n\n\n\n    }else{\n\n        int index=0;\n\n        int short_len;\n\n        for(i=0; i<h->short_ref_count; i++){\n\n            int sel;\n\n            sel = h->short_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->short_ref[i];\n\n            frame_list[0][index++].pic_id= h->short_ref[i]->frame_num;\n\n        }\n\n        short_len = index;\n\n        for(i = 0; i < 16; i++){\n\n            int sel;\n\n            if(h->long_ref[i] == NULL) continue;\n\n            sel = h->long_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->long_ref[i];\n\n            frame_list[0][index++].pic_id= i;\n\n        }\n\n\n\n        if (FIELD_PICTURE)\n\n            index = split_field_ref_list(h->default_ref_list[0],\n\n                                         h->ref_count[0], frame_list[0],\n\n                                         index, s->picture_structure,\n\n                                         short_len);\n\n\n\n        if(index < h->ref_count[0])\n\n            memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));\n\n    }\n\n#ifdef TRACE\n\n    for (i=0; i<h->ref_count[0]; i++) {\n\n        tprintf(h->s.avctx, \"List0: %s fn:%d 0x%p\\n\", (h->default_ref_list[0][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[0][i].pic_id, h->default_ref_list[0][i].data[0]);\n\n    }\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        for (i=0; i<h->ref_count[1]; i++) {\n\n            tprintf(h->s.avctx, \"List1: %s fn:%d 0x%p\\n\", (h->default_ref_list[1][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 21665, "substitutes": {"h": ["comm", "history", "p", "dh", "ht", "he", "it", "zh", "eh", "this", "hh", "o", "hal", "H", "f", "oh", "m", "y", "hash", "th", "c", "host", "hd", "handle", "j", "hw", "z", "ih", "k", "bh", "q", "hz", "here", "sh", "ph", "kh", "sw", "hl", "hs", "hm", "rh", "hp", "her", "ch", "g", "http", "mem", "has", "w", "cache", "ah", "each", "b", "event", "v", "header", "HH"], "s": ["comm", " inputs", "t", "p", "sys", "a", "os", "css", "f", "m", "ns", "ss", "session", "ims", "ses", " ts", "conv", "stats", "d", "src", "ps", "cs", "e", "sts", "fs", "gs", "aws", "rs", "c", "ds", "ap", "ab", "scl", "spec", "ls", "cpp", "ms", "sv", "sh", "sw", "ats", "hs", "sc", "S", "js", "g", "es", "wcs", "ts", "aus", " fs", "acs", "u", "w", "sb", "an", "b", "as", "v", "serv"], "i": ["n", "ij", "bi", "ori", "p", "phi", "t", "\u0438", "ic", "it", "ri", "si", "me", "index", "di", "iu", "ai", "xi", "f", "m", "go", "ix", "y", "us", "init", "multi", "ji", "im", "zi", "key", "x", "id", "ind", "e", "gi", "info", "I", "ami", "qi", "ki", "ini", "j", "ip", "cli", "batch", "ti", "z", "li", "k", "ia", "ex", "ui", "ir", "iter", "in", "ci", "g", "mi", "remote", "ii", "pi", "l", "v", "hi", "point", "uri", "chain", "instance"], "structure_sel": ["struction_sel", "structure__ls", "struction_ser", "structure__sel", "struction2ls", "structure_select", "structure_selected", "struction2ser", "structure_Sel", "struction2sels", "structure_ser", "struction2sel", "struction_selected", "struction_ls", "structure__ser", "struction_select", "struction_sels", "structure2ls", "structure_sels", "structure2ser", "structure_num", "struction_num", "structure2sel", "structure_ls", "struction_Sel", "structure__sels", "structure2sels"], "sorted_short_ref": ["sorted_shortlymem", "sorted_short_map", "sorted_short_mem", "sorted_short_def", "sorted_short2ref", "sorted_short2mem", "sorted_short_val", "sorted_short2val", "sorted_short2def", "sorted_long_arg", "sorted_long_ref", "sorted_shortlyref", "sorted_long_rel", "sorted_short_arg", "sorted_short_rel", "sorted_long_val", "sorted_short_Ref", "sorted_shortlyarg", "sorted_short2rel", "sorted_long_def", "sorted_shortlyrel", "sorted_long_mem"], "field_entry_list": ["field_entry2name", "field_def_list", "field_elementptlist", "field_element_list", "field_element_def", "field_entryationdef", "field_entry_type", "field_entryptlist", "field_element_top", "field_entry_def", "field_entryingdict", "field_entryingentry", "field_def_type", "field_def_entry", "field_entry_top", "field_elementptsequence", "field_entryationsequence", "field_entry_ref", "field_entryationlist", "field_entryptdef", "field_entry2type", "field_elementptdef", "field_entry_name", "field_element_sequence", "field_entry_dict", "field_entryationtop", "field_entrypttop", "field_def_def", "field_entryptsequence", "field_def_dict", "field_entry2ref", "field_entryingdef", "field_elementpttop", "field_entry_sequence", "field_entry_entry", "field_def_ref", "field_entryinglist", "field_def_name", "field_entry2list"], "frame_list": ["frameListtree", "frameactree", "frameaccache", "profilelistpair", "frame___list", "frame___pair", "frame___lists", "frameaclist", "field_cache", "window_pair", " frame_ref", "profile_lists", "frame_def", "profilelisttree", "window_tree", "profilelistlists", "frame_ref", "frame_path", "fieldaccode", "profile_pair", "frameListpath", "field_list", "frame_code", " frame_def", "frameaccode", "frameSetpair", "frameSetlists", "profile_tree", "frameablelists", "framelisttree", " frame_lists", "fieldaclist", "frameSetlist", "framelistpair", "Frame_pair", "frameListlist", "frameabledef", "frameListpair", "frameListcode", "window_list", "frame___tree", "profilelistlist", "framelistlist", "Frame_path", "window_lists", "frameablelist", "framelistlists", "fieldaccache", "fieldactree", "Frame_lists", "field_code", "field_tree", "frameableref", "frame_cache", "frame_pair", "profile_list", "frameSetpath", "frame_lists", "frame_tree", "frameListcache", "frameListlists", "Frame_list"], "list": ["elist", "name", "parent", "all", "set", "table", "count", "pair", "val", "def", "array", "code", "level", "info", "str", "test", "LIST", "st", "li", "spec", "num", "map", "lists", "ist", "conf", "List", "l"], "len": ["en", "all", "vl", "Len", "length", "rel", "loc", "label", "lan", "lon", "size", "le", "la", "li", "ls", "lic", "fin", "ln", "pos", "nl", "ll", "line", "l", "fl", "el", "layer"], "short_len": ["short2len", "short_ref", "short2ref", " short_length", "short2list", " short_list", "short_list", "short_length", "short2length", " short_ref"], "out_i": ["off_li", "go_ui", "go_e", "out_p", "out_di", "OUT_ini", "out_I", "outplaceit", " out_ji", "out_ii", "OUT_li", " best_ii", "outMemi", " best0li", "out_it", "out__e", "out__iu", "out0ii", "out__di", " out_iu", "out0li", "out____ci", "outdevis", "outMemit", "batch_init", "out_iu", "out____ip", "outaxyis", "out_multi", "out_l", "out__i", " out_di", "high_i", "outYmulti", "out0i", " best0i", "out_ip", "outplaceip", "outpti", "outplaceis", "OUT_I", " best_l", "outaxyinit", "out____di", "high_ci", "outplaceindex", "outdevindex", " best_zi", "outYi", "out_init", "outdevi", "out_ji", " best_li", "outplacei", "outplaceji", " best_p", "outMemip", "out0p", "batchYis", "outptli", "off_ip", "batch_is", "outdevji", "out_ini", "batch_multi", "out_e", " out_e", "outptini", " best0p", "off_it", "out_is", "outaxyi", "OUT_i", "outMemli", "go_iu", "out_ui", "outYinit", "go_i", " out_index", " best_i", "outaxymulti", "out_index", "high_di", "outptI", "out_li", "batchYmulti", "out____i", " best0ii", "batchYinit", "batch_i", " best_e", "high_ip", "out_ci", "outYis", "out_zi", "batchYi", "outplaceli", "off_i", " out_is"]}}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "substitutes": {"f": ["fn", "fo", "uf", "impl", "fr", "ff", "k", "_", "af", "v", "file", "tf", "o", "thread", "x", "fm", "um", "e", "fs", "fi", "self", "cf", "mem", "g", "cmd", "u", "b", "fc", "t", "bf", "r", "sf", "y", "exec", "gc", "d", "def", "c", "fb", "z", "ft", "fa", "buffer", "xf", "conf", "F", "uint", "comp", "l", "fx", "p", "out", "func", "h", "fw", "ge", "j", "fp", "q", "rf", "ile", "fd", "form", "lf", "w"], "vmdesc": ["vndeps", "vbindef", "vmanagedesc", "vMDec", "vmondef", "vmnesc", "vmdese", "vMDest", "mndew", "vndew", "vmderella", "wmdeca", "wcmdesc", "vmanagedest", "mndest", "mmdesp", "vamdef", "vmadew", "vcmdeps", "mndeps", "mmdeg", "vmdef", "mmdeca", "mndesc", "avmindesc", "mnderella", "vcddesc", "vmanderella", "vMDeps", " vmdef", "vundey", "vamdesc", "mndeg", "vmetesc", "vndeker", "mmdest", " vmanagedest", " vmanagedesc", "vMDesc", "vndesc", "vcmdeca", "vmneca", "wcmdest", "mndesp", "avmdpeg", "vcmdey", "vmandesp", "vmanagedef", "vamdest", "vcmdest", "vmeterella", "vunderella", "mnddesc", "vmandesc", "mmdesc", "vmdeg", "vmondeker", "vmetesp", "wmdec", "avmindec", "vmaderella", "vmetec", "mmddesc", "vndpeg", "mndeca", "mndeker", "vmondesc", "vmondew", "vsmdesc", "vMDese", "vmdeman", "vsmdey", "mndef", "vmdew", "vundesc", " vmanagedese", "vmdest", "vsmadey", "avmindeman", "vmondeg", "vsmderella", "vcdesc", "mmderella", " vmanagedef", "vbindesc", "vmdesp", "mmdec", "avmdec", "wmdesc", "vmdeker", "wmdest", "vndesp", "vsmadesc", "vmdeca", "vndeg", "mmdew", "vnderella", "vMDeca", "vmdpeg", "wcmdec", "vcdec", "vndeman", "vmdeps", "vcmdew", "vcmdeker", "vbindeg", "vmanagedese", "vsmaderella", "vamdese", "vnddesc", "vmandec", "vmddesc", "vcdeca", "vmindec", "vmindesc", "vndeca", "vcmderella", "vdmesc", "mmdeker", "vdmpeg", "vbindec", "vndec", "vcmdec", "wcmdeca", "vmondec", "avmindpeg", "avmdeman", "mmdeps", "vmnec", "mmdef", "vmindeman", "vmdey", "vndef", "vdmec", "vcmdesc", "vdmeman", " vmdest", "vsmdew", "vsmadew", "vmadesc", "vmdec", "vMDef", "avmdesc", "vmndesc", "vundew", " vmdese", "vndest", "mndec", "vmindpeg", "vmadey"], "vmdesc_len": ["vmdesc_length", "vmdec_len", "vmdec_Len", "vmdesc_Len", "vmdesc_ls", "vmdec_ls", "vmdec_length"], "se": ["ele", "he", "sing", "ce", "su", "th", "esse", "Se", "des", "sis", "cle", "sv", "sw", "spe", "pe", "ess", "es", "ser", "sche", "ry", "exe", "ene", "ste", "re", "use", "sel", "si", "me", "te", "ze", "e", "see", "ga", "send", "est", "entry", "de", "ae", "ace", "SE", "pse", "sys", "sa", "sex", "ade", "ase", "ice", "parse", "sr", "ke", "ve", "sh", "she", "we", "try", "sea", "ree", "esi", "so", "el", "sed", "ese", "ide", "sec", "ses", "al", "sle", "ie", "ge", "le", "lex", "ent", "ine", "sq", "ense", "ne", "sem"], "ret": ["gt", " Ret", "fun", "resp", "ben", "re", " RET", "msg", "out", "txt", "final", "usr", "red", "cb", "back", "ref", "tn", "rets", "desc", "rem", "err", "Ret", " alt", "gc", "val", "nz", "def", "code", "git", "str", "reset", "fail", "tr", "status", "result", "mt", "success", "deg", "ft", "ptr", "rt", "reply", "vet", "res", "alt", "num", "rm", "fin", "rat", "error", "nt", "sp", "RET", "after", "nl", "len", "ll", "elt", "att", "flag", "tf", "ctr", "fit"]}}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void mvp_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));\n\n\n\n    /* MVPConf1 implemented, TLB sharable, no gating storage support,\n\n       programmable cache partitioning implemented, number of allocatable\n\n       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs\n\n       implemented, 5 TCs implemented. */\n\n    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |\n\n                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |\n\n// TODO: actually do 2 VPEs.\n\n//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |\n\n//                             (0x04 << CP0MVPC0_PTC);\n\n                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |\n\n                             (0x00 << CP0MVPC0_PTC);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Usermode has no TLB support */\n\n    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);\n\n#endif\n\n\n\n    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,\n\n       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */\n\n    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |\n\n                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |\n\n                             (0x1 << CP0MVPC1_PCP1);\n\n}\n", "idx": 21694, "substitutes": {"env": ["ee", "er", "en", "engine", "end", "rb", "eb", "context", "eh", "et", "gate", "te", "equ", "ef", "window", "init", "etc", "ner", "gear", "enc", "erb", "bridge", "e", "code", "conn", "eg", "vm", "cv", "query", "ec", "esc", "export", "disk", "worker", "EN", "enter", "see", "buf", "ctx", "uv", "ent", "ov", "manager", "environment", "server", "ve", "sv", "here", "vs", "entry", "console", "open", "db", "dev", "doc", "En", "ev", "erd", "oe", "Environment", "obj", "ah", "ew", "nc", "eng", "v", "el", "vv", "forge", "w"], "def": ["kw", "definition", "lit", "det", "ref", "desc", "du", "ef", "Def", "pro", "decl", "tx", "vec", "buf", "ctx", "spec", "df", "dem", "dev", "ded", "doc", "define", "conf", "crit", " Def", "form", "DEF", "da"]}}
{"project": "FFmpeg", "commit_id": "ae3da0ae5550053583a6f281ea7fd940497ea0d1", "target": 1, "func": "static int decode_band(IVI45DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2, pos;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    if (!band->buf) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return result;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i * 2];\n\n        idx2 = band->corr[i * 2 + 1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    pos = get_bits_count(&ctx->gb);\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        if (tile->mb_size != band->mb_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n\n                   band->mb_size, tile->mb_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n", "idx": 21708, "substitutes": {"ctx": ["kw", "comm", "history", "resp", "jac", "sys", "org", "context", "kt", "ck", "this", "settings", "ang", "cb", "cn", "unk", "qq", "co", "piece", "act", "gc", "ct", "pkg", "conv", "tz", "conn", "bc", "cu", "cd", "cv", "tx", "c", "voc", "jp", "cmp", "batch", "hw", "mt", "wx", " cx", "grad", "lib", "cm", "px", "cf", "kb", "wcs", "config", "mc", "std", "params", "np", "cmd", "tc", "obj", "iat", "conf", "req", "cam", "buff", "nc", "cc", "ctl", "fc", "course", "cp", "cfg", "today", "ctr", "xc"], "plane_num": ["band_Num", "band1num", "band_mon", "plane_no", "band_no", "band1Num", "band_num", "band1no", "plane_Num", "band1mon", "plane_mon"], "band": ["ck", "ang", "app", "mm", "ack", "tool", "bands", "filter", "format", "pair", "bank", "plugin", "cd", "decl", "batch", "word", "idd", " Band", "command", "work", " cand", "port", "layer", "art", "bb", "chain", "binary", "raid", "back", "group", "unk", "broad", "pp", "power", "Band", "bd", "data", "camp", "disk", "ann", "cell", "bind", "burst", "db", "ogram", "bound", "wd", "cmd", "bin", "fam", "amber", "road", "tag", "chrom", "bright", "brand", "iband", "piece", "prep", "bool", "rad", "display", "style", "plug", "def", "bit", " bands", "library", "beam", "buf", "product", "cand", "report", "box", "and", "patch", "range", "buff", "cast", "need", "bag", "man", "plot", "org", " bandwidth", "bart", "dom", "bed", "hub", "key", "bridge", "bar", "tab", "byte", "flash", "bm", "grab", "grad", "ud", "amp", "play", "block", "form", "light", "bug", "flag", "bor", "bid", "lag"], "avctx": ["avetc", " avjac", "wavtc", "wavctx", "averca", "afcf", "avercmd", "avtc", "camctx", " avconn", "avcf", "avecas", "afcfg", "avcc", "jamctx", " avcu", "afconn", "navconn", "navcas", "avepkg", "avcas", "navctx", "avecfg", "avcp", "jamjac", "avtx", "avectl", "avctl", "afwcs", "averctx", "wavpkg", "navcf", "avercp", "aveconn", "aveca", "avetx", "afcmd", "avejac", " avcp", "avjac", "camcu", "wavjac", " avca", "jamtc", "avpkg", "avecp", "avca", "afctx", "avcmd", "averctl", "jampkg", "avecmd", "avecu", "camtx", "avecf", "averwcs", "avercc", "avectx", "avcu", "avcfg", "avecc", "avewcs", "avercfg", "averconn", " avctl", "avwcs", "afcas", "camctl", " avtx", " avcc", "avconn", "averjac"], "result": ["duration", "name", "valid", "definition", "were", "response", "out", "rc", "final", "message", "ret", "comment", " res", "r", "number", "record", "ger", "length", "err", "value", "RESULTS", "goal", "relation", "reason", "answer", "count", "val", "complete", "contact", "ter", "results", "def", "different", "created", "code", "data", "test", "currency", "tr", "mate", "status", "ULT", "function", "details", "event", "password", "product", " Result", "Result", "res", "true", "report", "new", "feature", "date", "match", "term", "error", "params", "zero", "json", "diff", "success", "ult", "chain", "type"], "i": ["n", "bi", "p", "is", "out", "phi", "ic", "it", "\u0438", "ri", "this", "si", "me", "index", "di", "iu", "ai", "xi", "ix", "m", "h", "y", "ji", "multi", "by", "im", "zi", "x", "id", "ind", "gi", "info", "I", "c", "ami", "qi", "ki", "ti", "j", "ip", "ini", "cli", "status", "PI", "li", "q", "ui", "ex", "series", "in", "ci", "g", "mi", "u", "ii", "b", "pi", "v", "l", "hi", "chain"], "t": ["n", "td", "p", "tt", "ht", "it", "kt", "txt", "o", "set", "task", "te", "type", "m", "f", "y", "tip", "qt", "title", "total", "pt", "x", "ot", "dt", "trace", " T", "tx", "c", "temp", "ti", "j", "tr", "ant", "T", "ent", "q", "rt", "unit", "ta", "at", "g", "ts", "nt", "tree", "ty", "tc", "wt", "tw", "tm", "port", "b", "l", "v", "token", "tu", "tf", "lat", "vt"], "idx1": ["idrx01", "idz01", " idy1", "idzOne", "fdx1", "idX1", "idex1", "idz3", "idX0", " idex1", " idX0", "fdrx2", "idy1", "idy01", "idv3", " idex2", "idxOne", "idex0", " idex0", "idix2", " idx0", "idxf1", "fdx2", "idix0", "idv0", "idX3", " idx01", " idy2", "fdrxONE", " idx3", "idx3", "idx0", "fdrx1", "idv2", "idxONE", " idyOne", "idrx1", " idXOne", "idyOne", "idrx2", "idz0", "idix1", "idx01", " idxOne", "idv1", " idy01", "fdx01", "idy2", "idrxONE", "idvOne", "fdrx01", "idex2", "idz2", "idxfONE", "idxf2", " idX1", "idvONE", "idXOne", " idX3", "idz1", "idv01", "fdxONE", "idxf01"], "idx2": ["prox10", "idt8", " idy1", "protxtwo", "idy1", "idxtwo", "namex1", "protx10", "idix2", "idtx2", "protx02", "proxtwo", "namextwo", "idix1", "idx102", "idy12", "idon12", "idX2", "idtxtwo", "protx2", " idy12", " idy2", "idtx8", "idix102", "idvtwo", "idX02", "idon102", "idytwo", "idixtwo", "idx02", "idy2", "namex2", "nameix1", "idy102", "idx12", "idx10", "nameixtwo", "prox2", "idon2", "nameix2", "idon1", "prox8", "idex02", "idx8", "idix12", "idxftwo", "idtx02", "idtx10", "idt2", "prox02", " idy102", "idXtwo", "idX10", "idv2", "protx8", " idx12", "idxf8", "idv1", "idextwo", "idex2", "idxf2", "idttwo", "idex10", " idx102"], "pos": ["p", "neg", "o", "os", "Pos", "ref", "pose", "offset", "val", "pro", "pt", "loc", "ps", "po", "ot", "total", "def", "top", "pres", "limit", "pid", "base", "col", "position", "POS", "cond", "part", "at", "doc", "rot", "trans", "pc", "conf", "len", "port", "pi", "pad", "origin", "point"], "tile": ["mat", "stone", "ele", "sel", "kt", "bolt", "entity", "tele", "pixel", "te", "member", "tle", "tip", "bat", "title", "piece", "late", "format", "table", "tier", "ie", "image", "file", "lay", "mobile", "il", "trace", "texture", "trip", "info", "bit", "tab", "test", "flake", "byte", "tu", "batch", "mate", "profile", "detail", "tif", "cell", "player", "ite", "chip", "tmp", "feat", "buffer", "unit", "face", "phy", "template", "feature", "ile", "term", "sector", "tree", "league", "tiny", "slice", "port", "grid", "til", "Tile", "tf", "layer"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723, "substitutes": {"dev": ["cho", "pack", "app", "vol", "desc", "scan", "debug", "err", "driver", "th", "loc", "des", "md", "pub", "event", "server", "env", "auth", "ow", "util", "game", "stick", "v", "ev", "der", "comment", "device", "enc", "info", "data", "watch", "disk", "send", "db", "home", "de", "mem", "usb", "wd", "cmd", "cam", "att", "vc", "tag", "die", "Dev", "dis", "disc", "sd", "d", "pro", "def", "max", "develop", "var", "av", "hw", "DEV", "buf", "ve", "ad", "req", "conf", "cache", "store", "serv", "build", "out", "end", "ver", "dd", "ach", "go", "serial", "val", "conn", "test", "prop", "draw", "gu", "dem", "addr", "priv", "doc", "error", "form", "mod", "bug", "w"], "vdev": ["vdes", " vdevice", "tdevice", "Vdef", "gev", "vedes", "tserv", "vdef", "tev", " vgu", "tdef", "pdef", "Vserv", "vegu", "gdevice", "vrver", "vgu", "vedev", "vdevice", " vev", "pserv", " vver", "pev", "vver", "vev", "vgo", "vever", "gdev", "vrgu", " vgo", "Vev", "vserv", "tgo", "tdev", "pdev", "vrdev", " vdes", "vrdes", "Vdev", "ggo"], "bus": ["length", "driver", "bank", "loc", "user", "mask", "host", "hand", "aux", "kit", "tmp", "util", "pos", "gen", "port", "as", "local", "chain", "loop", "state", "use", "os", "root", "bs", "board", "socket", "join", "data", "handle", "disk", "base", "BUS", "num", "db", "self", "usb", "b", "t", "sys", "plug", "mount", "bit", "c", "proc", "buf", "ctx", "buffer", "box", "nt", "pool", "cache", "cast", "out", "bits", "boot", "gate", "off", "h", "hub", "us", "ac", "bridge", "bc", "conn", "Bus", "lock", "full", "book", "addr", "http", "block", "bug", "phys"], "dev_len": ["dev_ran", "ev_en", " dev_Len", "dev_fun", "dev_den", "devtLen", "read_des", "devptdes", "readaxyran", "read_len", " dev_en", "dev_des", "dev_ls", "dev2len", "devaxylen", "ev_ls", "dev_ln", "dev_lif", " dev_l", "boot_en", "boot_len", " dev_le", "devptlen", "readaxyen", "devten", "dev_lan", "devaxyran", "dev2lig", "devtlen", "devptran", "ev_len", "boot_fun", "devtlig", " dev_lig", " dev2en", "boot_lif", " dev2Len", " dev2lig", "readaxylen", "dev_lig", "devpten", " dev2len", "ev_den", "dev_le", "read_ran", "dev2Len", "devaxydes", " dev_ln", "dev_en", "dev_l", "readaxydes", "dev_Len", "dev2en", "read_en", "devaxyen", " dev_lan"], "cpu": ["core", "sys", "gpu", "ck", "alloc", "memory", "processor", "process", "boot", "us", "thread", "pkg", "prof", "cu", "cum", "mu", "slot", "node", " CPU", "proc", "nu", "hw", "pid", "pu", "chip", "clock", "num", "nic", "uart", "nice", "mem", "pc", "uu", "CPU", "linux", "port", "phys", "cp"]}}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n", "idx": 21731, "substitutes": {"size": ["n", "name", "scope", "time", "capacity", "number", "set", "index", "sum", "length", "SIZE", "scale", "root", "window", "zone", "too", "fee", "offset", "init", "format", "count", "total", "description", "style", "id", "power", "space", "code", "empty", "timeout", "slot", "dim", "max", "bytes", "body", "height", "mode", "city", "ize", "password", "send", "position", "owner", "storage", "shape", "area", "usage", "Size", "doc", "dimension", "g", "term", "path", "range", "address", "pos", "len", "store", "small", "network", "news", "padding", "type"], "max_size": ["maxptblock", "Max_link", "maxoprange", "new5site", "MAX_length", " max_block", "max0range", "maxipblock", "max0length", "maxoplength", " max_SIZE", "MAX_size", "max_number", "max_block", "maxptsize", "new_Size", "MAX_since", "max5Size", "max_link", "max0size", "maxopsite", "MAX_site", "new_site", "max_since", "max_length", "Max_Size", "max0site", "Max_size", "MAX_range", "max10number", "new5Size", "Max_number", "max_SIZE", "maxiplength", " max_length", "new5size", "max_site", "maxopsize", "maxipSIZE", "max10size", "max_range", "max5size", "maxptSIZE", "new_size", "maxipsize", "max10Size", "maxptlength", "max_Size", "max10link", "MAX_SIZE", "max5site"], "resized": ["reserved", "preserved", "persize", "sizable", "persized", "rawizable", "rawized", "resizing", "served", "reized", "asizable", "rawizing", "revocated", "msocated", "presized", "presize", "perserved", "asizing", "msized", "asised", "persised", "resocated", "reerved", "persizing", "resizable", "reverved", "sized", "persizable", "revizing", "reocated", "reizing", "presizable", "resize", "asized", "resised", "mserved", "revized", "rawised", "msizing"], "host": ["name", "gt", "cert", "parent", "ost", "any", "context", "ssh", "container", "ref", "group", "h", "device", "root", "null", "domain", "loc", "x", "stream", "user", "empty", "target", "socket", "slot", "over", "node", "holder", "handle", "ready", "ip", "base", "mac", "height", "hook", "raw", "link", "full", "bind", "hard", "server", "here", "localhost", "ex", "handler", "owner", "map", "self", "home", "addr", "dev", "dr", "http", "path", "Host", "address", "native", "remote", "smart", "port", "cast", "local", "network", "public", "chain"], "resizeable": [" resizeabled", "resIZEable", "resignable", "resIZEorable", "rescaleabled", "RESizeabled", "rescaleble", "resizeabl", "resimable", "RESizeable", "resignability", "resignabled", "rescaleabl", " resizeabl", "resizabled", "resimabled", "RESizeorable", "resimizeabled", "resizable", "resimble", "resIZEabled", "resizble", "resimizeorable", "resizabl", "RESizeability", "resIZEability", "resizeorable", "resizeabled", "resizeability", "RESimizeability", "resimizeability", " resizable", "resimabl", " resizabl", "rescaleable", " resizble", "RESimizeable", "RESimizeabled", "resizeble", " resizabled", "RESimizeorable", " resizeble", "resimizeable", "resignorable"], "mr": ["lr", "rb", "rn", "usr", "r", "mm", "nr", "shr", "m", "pm", "irm", "gm", "ml", "vr", "mb", "rr", "rg", "mp", "rar", "rs", "wr", "RM", "MR", "mt", "hr", "mos", "sr", "rw", "bm", "br", "kr", "hm", "cm", "adr", "rm", "drm", "mx", "dr", "nah", "gr", "ocr", "rpm", "mc", "rl", "Mr", "mn"], "errp": ["errps", "erp", "arrnp", "errP", " errpost", "errpost", "arrpost", "errpa", " errP", "arrp", "ferP", "rrP", " errpa", "ferps", "ferp", "errnp", "erps", " errnp", " errps", "rrpost", "erP", "rrnp", "arrP", "rrp", "ferpa", "erpa"], "new_block": [" new_lock", "newetmix", "unique1Block", "new1device", "new1piece", " new_line", "newptlock", "newetlock", "new1lock", "new_base", "newlexpoint", "new_lock", " new_device", "news___mix", "new_bl", "new_device", "unique_snap", "news___word", "newJversion", "new_volume", " new__type", "newThesnap", "new___row", " new_piece", "uniqueptbl", " new_cell", "newlypage", "newlexprefix", "new_version", "newlyblock", "newedsnap", "newetpoint", "newlybl", "unique1block", "unique1base", "newptbl", " new_object", "newptblock", "new__row", " new_chain", "new_prefix", "new1block", "newedchain", "newedline", " new__row", "news_point", "newlyobject", "new_point", "New_session", "new_piece", "New_block", "unique_lock", "New_point", " new__block", "newptstruct", "new_snap", "newlingcell", "newedBlock", "uniqueptstruct", "newObjblock", "newedtag", "newObjBlock", "newJblock", "news_word", " new_tag", "unique1snap", "unique_base", "newObjbit", "new___chain", " new_snap", "new_bit", "news_block", "newThebase", "new_line", "newlylock", "uniqueptblock", "new_row", "newPobject", "news___block", " new_type", "new___tag", "new_session", " new_page", "new___lock", "new___point", "new_cell", "newetsession", " new__lock", " new_session", "newlystruct", "newobjvolume", "unique_struct", "newetword", " new_volume", "new_mix", "new_page", "news___point", "uniqueptlock", "new_box", "New_prefix", " new_Block", "new_word", "news_mix", "unique_Block", "newetblock", "new1version", "unique_block", " new_row", "newlinglock", "new1base", " new_bit", "new___mix", "newPblock", "newTheblock", "new__lock", "newedblock", "new_chain", "new___word", " new_version", "new___line", " new_box", "new_tag", "new__block", "new1snap", "newlexblock", "newedsession", "newobjchain", "new__type", "newobjblock", "new_struct", "new___block", "newObjbox", "newJpiece", "newTheBlock", "new_object", "new___volume", "new___Block", "new_type", "new_Block", "new1Block", "New_lock", "newlingblock", "newPpage", "unique_bl"], "local_err": [" local_rr", "localpyreq", "loc___error", "local_gz", "local___rr", "loc_msg", "local__error", " local_er", "local_req", " local_req", "local_error", "local_cb", "local___gz", "loc_err", "local___loc", "loc___err", " local_log", "local___error", "local_rr", "local___er", "local___err", "loc___gz", "localpyrr", "local_msg", "loc___loc", "local_log", "local__log", "localpyer", "localpyerr", " local_error", "loc_gz", "loc_error", "local__er", "local___req", "loc_loc", "loc_cb", "local__err", "local_er", "local_loc"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n", "idx": 21739, "substitutes": {"s": ["n", "t", "p", "is", "sys", "a", "r", "os", "f", "m", "h", "ns", "ss", "y", "us", "ses", "sync", "stats", "d", "cs", "i", "sts", "rs", "gs", "socket", "c", "ds", "z", "south", "sv", "sw", "self", "sc", "S", "js", "g", "es", "sq", "ts", "qs", "sb", "b", "as", "v", "w"], "type": ["name", "ype", "p", "state", "t", "Type", "tag", "et", "r", "kind", "ref", " TYPE", "TYPE", "style", "test", " typ", "rt", " pt", "pe", " kind", "tor", "types", " ty", "typ", "ty", "class", " Type"], "ret": ["gt", " Ret", "t", "re", " RET", "out", "lit", "rc", "rev", "usr", "cat", "red", "r", "ref", "back", "desc", "rets", "err", "Ret", "ct", "val", "inter", "def", "rs", "str", "reset", "st", "tr", "result", "mt", "aux", "ft", "rt", "res", " reg", "alt", "reg", "mem", "dr", "g", "ts", "nt", "RET", "std", "len", "ry", "att", "l", "flag", " def", " fut"], "arg": ["agg", " larg", " Arg", "asc", "msg", "mm", "ack", "Arg", " targ", "loc", "target", "jp", "ag", " reg", "alt", " argument", "v", "local", "param", "ax", "x", "empty", "op", "deg", "num", "opt", "mem", "g", "cmd", "eng", "star", "t", "tag", "r", "arp", "ref", "f", "act", "ar", "inter", "call", "args", "var", "mac", "parse", "raw", "other", "argument", "in", "ad", "pg", "attr", "ok", "gt", "ig", "valid", "p", "out", "rc", "usr", "sec", "field", "add", "al", "ob", "val", "arr", "pl", "j", "prop", "addr", "reg", "iter", "doc", "bug", "flag", "w"]}}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740, "substitutes": {"luks": ["fluk", " blukes", "flukes", "Lukes", " bluk", " blucs", "luk", "pukes", "lukas", "pukas", "pucs", "Lucs", "nucs", "flukas", "Luk", "nukes", "Luks", "flucs", " bluks", "nuks", "lucs", "fluks", "lukes", "puks", "nukas"], "luks_opts": ["luks_alls", "luks_opps", "luks_opnt", "luks_copts", "luks_spets", "luks_coptx", "luks_OPps", "luks_imters", "luks_dropcons", "luks_optioncons", "luks_optters", "luksdbopms", "luks_compjs", "luks_OPms", "luks_hopts", "luks_dropters", "luks_opms", "luks_catgs", "luks_optns", "luks_iopcons", "luks_iopts", "luks_optionops", "luks_logs", "luks_opsms", "luks_optimcons", "luks_opents", "luks_oks", "luks_opttons", "luks_optimths", "luks_crittons", "luks_opte", "luks_opv", "luks_optr", "luksdboptimts", "luks_opls", "luks_imtes", "luks_pret", "luks_oppt", "luks_prems", "luks_opttes", "luks_opertr", "luks_optiontx", "luks_logts", "luks_OPpt", "luks_OPents", "luks_OPops", "luks_OPts", "luks_optons", "luksdbopcons", "luks_OPtr", "luks__optes", "luks_opt", "luks_optes", "luks_optionths", "luks_optionts", "luks_optiont", "luks_imts", "luks_operts", "luksdbtyps", "luks__opts", "luks_pregs", "luks_cops", "luks_logents", "luks_optp", "luks_popt", "luks_prets", "luks_opsns", "luks_pors", "luks_OPths", "luks_opgs", "luks_opops", "luks_OPtp", "luks_props", "luksdbopths", "luks_OPnt", "luks_alpt", "luks_Ops", "luks_optps", "luks_portp", "luks_popts", "luks_hopjs", "luks_orts", "luks_imcons", "luks_copls", "luks_hopops", "luksdbtypts", "luks_orms", "luks_alcs", "luks_pres", "luks_optionss", "luks_porents", "luks_Opgs", "luks_hopt", "luks_opths", "luks_opters", "luksdboptimths", "luks_als", "luks_speps", "luks_compts", "luks_Opts", "luks_typs", "luks_hopnt", "luks_typths", "luks_optx", "luks_okps", "luks_opertx", "luks_coppt", "luks_optimtx", "luks_opcons", "luks_prots", "luksdboptimcons", "luks_OPv", "luks_specs", "luks_alps", "luks_typms", "luks_OPs", "luks_optms", "luks_opcs", "luks_OPtx", "luks_OPgs", "luks_typts", "luks_OPls", "luks_alte", "luksdbtypths", "luks_coptr", "luks_ports", "luks_ops", "luks_catouts", "luks_procs", "luks_compouts", "luks_opjs", "luks_optv", "luks_ors", "luks_spete", "luks__opms", "luks_iopths", "luks_Opps", "luks_critcons", "luks__opns", "luks_optcons", "luksdboptx", "luks_catjs", "luks_logtp", "luks_optimts", "luks_compgs", "luks_critts", "luks_optionsv", "luksdbopts", "luks_optths", "luks_popms", "luks_opstes", "luks_opers", "luks_catts", "luks_prote", "luks_hopgs", "luks_droptes", "luks_optionsts", "luks_okts", "luks_critters", "luks_OPt", "luks_opsts", "luksdbtypms", "luks_orgs", "luks_optionsps", "luks_opns", "luks_dropts", "luksdbops", "luks_hopouts", "luks_optimtes", "luks_optimtons", "luksdboptimtx", "luks_optionnt", "luks_pops", "luks_okgs", "luks_optimters", "luks_ioptx", "luks_alts", "luks_optts", "luks_opouts"], "local_err": ["internal___msg", "internal_error", "local__er", "internal_err", "internal_msg", "internal___err", "local___msg", "local___error", "internal___er", "local__err", "local__error", "local_er", "internal_er", "internal___error", "local___er", "local___err", "local_msg", "local_error", "local__msg"], "masterkey": ["primaryblock", "prefixdata", "mainkey", "prefixkey", "prefixblock", "primarykey", "primarydata", "masterdata", "mainblock", "masterblock", "maindata"], "slotkey": ["slotk", "splitbyte", "partKey", "partkey", "splitKey", "snapk", "snapbyte", "slotbyte", "snapkey", "snapKey", "partk", "slotKey", "splitk", "partbyte"], "splitkey": ["switchseed", "splitseed", "switchcode", "switchkey", "altseed", "splitcode", "splitKey", "halfseed", "halfcode", "altKey", "altcode", "halfKey", "halfkey", "altkey", "switchKey"], "i": ["bi", "phi", "p", "is", "a", "si", "di", "iu", "ai", "io", "h", "ix", "init", "id", "I", "ini", "j", "ip", "ia", "ui", "abi", "in", "ta", "ci", "bin", "ii", "pi", "b"], "cipher": ["cpter", "ccoder", "curpter", "chipher", "curipher", "cciper", "coder", "ccipher", "choder", "chpter", "ccpter", "curiper", "ciper", "chiper", "curoder"], "ivgen": ["ivergen", "ivergeneration", "evgen", "ivermsg", "evGen", " ivmsg", "iverGen", "ivmsg", "evgeneration", " ivGen", "evmsg", "ivgeneration", "ivGen", " ivgeneration"], "password": ["username", "Password", "message", "context", "comment", "secret", "private", "parser", "session", "attribute", "PASS", "hash", "description", "text", "query", "token", "security", "word", "auth", "buffer", "phrase", "prefix", "command", "address", "encrypted", "pass", "padding", "chain", "channel"], "cipher_alg": ["cipher___org", "cipher_org", "cipherfulmg", "cipher_attr", "cdriverfulmg", "cipher_img", "cipherfulorg", "cipherfulalg", "cipher___alg", "cip_attr", "cip_alg", "cdriver_img", "cdriver_alg", "cdriverfulimg", "cip_mem", "cdriverfulalg", "cip_mode", "cipher___img", "cdriver_mg", "cipher_mem", "cipher___mg", "cdriver_org", "cdriverfulorg", "cipherfulimg", "cipher_mg"], "cipher_mode": ["cursor_no", "cursorlyno", "cipherlytype", "cursor_mode", "cipher_md", "caster_md", "cipher_opt", "cipher___mode", "cipher_type", "cipher_operator", "caster_method", "cipher___opt", "cipher_method", "cipherlyopt", "caster_mode", "cipherlyno", "cipher_no", "cipher___type", "caster_operator", "cursor_opt", "cursorlymode", "cipherlymode", "cursor_type", "cursorlyopt", "cipher___no", "cursorlytype"], "ivgen_alg": ["ivgeneration_alg", "ivgen___alg", "ivgeneration_impl", "ivgen7arch", "ivgenxalg", "ivGen_op", "ivnode_alg", "ivgen7alg", "ivgenerationximpl", "ivgen_gen", "ivgen7mode", "ivGen_arch", "ivgen_rg", "ivgeneration_hash", "ivgenximpl", "ivgen7op", "ivgen_alt", "ivgen_mode", "ivgenximg", "ivgen___hash", "ivgen_hash", "ivgen_img", "ivgeneration_img", "ivGen_mode", "ivnode_alt", "ivgen_impl", "ivnode_rg", "ivgenxhash", "ivgen___img", "ivgenerationximg", "ivGen_alg", "ivgenerationxalg", "ivgenerationxhash", "ivgen_op", "ivgen___impl", "ivgen_arch", "ivnode_gen"], "ivgen_hash_alg": ["ivgen_hashmmalg", "ivgen_hashmmcmd", "ivgen_search_cmd", "ivgen_hash_cmd", "ivgen_hashmmorg", "ivgen_hashmmimpl", "ivgen_hash_org", "ivgen_search_org", "ivgen_search_impl", "ivgen_search_alg", "ivgen_hash_impl"], "hash_alg": ["search_gen", "hash_gen", "hashablefac", "hash_fac", "hashableexp", "hashgrfac", "hash_exp", "hash_aug", "search_mem", "shadowgrfac", "shadow_aug", "hash_attr", "shadow_alg", "search_alg", "shadow_fac", "hashableaug", "shadow_exp", "hashablealg", "shadowgrexp", "hash_mem", "shadowgralg", "shadowgraug", "hashgrexp", "hashgraug", "search_attr", "hashgralg"], "cipher_mode_spec": ["cipher_mode2spec", "cipher_mode_spe", "cipher_mode2spe", "cipher_type_tag", "cipher_type_spe", "cipher_type_match", "cipher_mode2match", "cipher_mode_tag", "cipher_mode_match", "cipher_type_spec", "cipher_mode2tag"], "iters": ["litering", "itering", "ITERS", "ITering", "liters", " itERS", "litERS", "itered", "ITered", " itering", "ITers", " itered", "litered", "itERS"]}}
{"project": "FFmpeg", "commit_id": "17269bdfcdb79679f6b92024d1228e876b799a63", "target": 1, "func": "static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n", "idx": 21750, "substitutes": {"s": ["n", "comm", "p", "t", "sys", "is", "settings", "a", "o", "source", "os", "parts", "r", "f", "m", "h", "ns", "ss", "ims", "ses", "stats", "cs", "bs", "ps", "eps", "sts", "sports", "fs", "gs", "aws", "times", "c", "rs", "ds", "services", "args", "j", "z", "scl", "ls", "details", "ms", "sv", "ats", "hs", "S", "js", "g", "ins", "sq", "als", "ts", "its", "comments", "qs", "less", "an", "b", "as", "v", "tes", "w"], "swf": ["swfx", "awf", "awfs", "avv", " swF", "svv", "essfw", "wsf", "essf", "Swf", "awF", "iwf", "Swfo", "swfw", " swfx", "essfx", "wsF", "iwfw", "swv", "SwF", "svf", "swfs", "wsv", "Swfs", "awfo", "avf", "avF", "avfx", "swfo", "iwfx", " swfw", "svfx", " swfo", " swfs", "svF", "swF", "wsfx"], "pb": ["td", "resp", "p", "eb", "bf", "func", "cb", "pm", "tp", "prototype", "bps", "gb", "gc", "pkg", "mb", "pt", "pp", "lp", "uf", "mp", "wp", "bj", "tk", "pl", "lb", "cv", "cp", "um", "pa", "PB", "fb", "jp", "proc", "nb", "ab", "fp", "buf", "ctx", "ptr", "bh", "ub", "wb", "dp", "db", "pan", "phy", "amp", "appy", "erb", "aus", "pc", "np", "pg", "pool", "tc", "emb", "typ", "tm", "sb", "obb", "b", "gp", "bp", "phys", "orp", "vp", "bb", "abb", "vt"], "enc": ["coll", "comm", "en", "rc", "vc", "iq", "alloc", "et", "ack", "abc", "ac", "conv", "act", "iv", "loc", "con", "code", "conn", "cv", "c", "ec", "vec", "cmp", "lang", "buf", "cod", "ctx", "ent", "eric", "sw", "inc", "ENC", "anc", "nt", "util", "pc", "xc", "rec", "nc", "nv", "acc", "comp", "eng", "fc", "erc", "Enc", "ev", "oc"], "video_enc": [" video_ENC", "Video_coll", "Video_crit", "video___coll", "channel_conn", "video___en", " video_ec", "Video_ent", "video___dec", "video_en", " video_dec", "video_coll", "Video_enc", "video_dec", "channel_con", "VIDEO_enc", "video___enc", "video___con", "video_inc", "video_ENC", "video___inc", "video_con", "Video_ec", "video___ent", "video___conn", "channel_en", "VIDEO_inc", "video_crit", "video___ec", "video_ec", "channel_enc", "video_conn", "VIDEO_en", "video___ENC", "video_ent", "VIDEO_ec"], "file_size": ["file_len", "file10small", "file_position", "file_small", "file___size", "file_length", "file64length", " file_speed", "file10size", "file64len", " file_position", " file_len", "file64size", "file___sized", "file_sized", "file10sized", " file_sized", "file_Size", " file_length", "file64Size", "file___small", " file_small", "file_speed", " file_Size"], "i": ["bi", "name", "t", "p", "phi", "\u0438", "ic", "it", "ri", "si", "me", "index", "di", "ski", "ai", "iu", "xi", "m", "ix", "y", "ims", "us", "init", "multi", "ji", "im", "zi", "key", "ei", "ie", "x", "id", "ind", "e", "sim", "gi", "info", "I", "c", "my", "ami", "qi", "ki", "ini", "j", "ip", "batch", "ti", "cli", "li", "q", "ex", "ms", "ui", "oi", "iter", "ci", "g", "mc", "mi", "ii", "pi", "l", "v", "hi", "uri", "chain"]}}
{"project": "FFmpeg", "commit_id": "fbfbd97be25c4da0562ef61e2f27192d1ec4d276", "target": 1, "func": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    XPMDecContext *x = avctx->priv_data;\n\n    AVFrame *p=data;\n\n    const uint8_t *end, *ptr = avpkt->data;\n\n    int ncolors, cpp, ret, i, j;\n\n    int64_t size;\n\n    uint32_t *dst;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n\n\n    end = avpkt->data + avpkt->size;\n\n    while (memcmp(ptr, \"/* XPM */\\n\", 10) && ptr < end - 10)\n\n        ptr++;\n\n\n\n    if (ptr >= end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n\n        return ret;\n\n\n\n    if (cpp <= 0 || cpp >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size = 1;\n\n    for (i = 0; i < cpp; i++)\n\n        size *= 94;\n\n\n\n    if (ncolors <= 0 || ncolors > size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size *= 4;\n\n\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n\n    if (!x->pixels)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n\n    for (i = 0; i < ncolors; i++) {\n\n        const uint8_t *index;\n\n        int len;\n\n\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        if (ptr + cpp > end)\n\n            return AVERROR_INVALIDDATA;\n\n        index = ptr;\n\n        ptr += cpp;\n\n\n\n        ptr = strstr(ptr, \"c \");\n\n        if (ptr) {\n\n            ptr += 2;\n\n        } else {\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        len = strcspn(ptr, \"\\\" \");\n\n\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n\n            return ret;\n\n\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n\n\n        for (j = 0; j < avctx->width; j++) {\n\n            if (ptr + cpp > end)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n\n                return ret;\n\n\n\n            *dst++ = x->pixels[ret];\n\n            ptr += cpp;\n\n        }\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    p->key_frame = 1;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 21762, "substitutes": {"avctx": [" avgc", " avcmd", " avconfig", "averkl", "avertx", "avecfg", "avecmp", "abtx", "avcp", "wavcfg", "abctl", "afcu", " avcmp", "abcu", "avecp", "afctx", "afcp", "ajcmd", " avreq", "ajcu", "wavcmp", "avercfg", " avctl", "vctx", "ajpkg", "averconfig", "avconfig", "avercmd", "avcmp", "avekl", "avercontext", "afpkg", "ajtx", "averctx", "avercp", "afcmd", "avercmp", "AVcontext", "averctl", "avecmd", "avecu", "avcu", "ajctl", " avcontext", " avtx", "abcontext", "avercu", "ajcp", "avereq", "aftx", "afgc", "afconn", "avepkg", " avcfg", "ajgc", "avtx", "avgc", "ajconfig", "avecontext", "averpkg", "vctl", "abctx", "avergc", "AVctl", "wavcontext", "afctl", "wavkl", "abgc", "avreq", "avconn", "wavctx", "avcontext", " avcu", "AVcfg", "vcontext", "abcfg", "avectl", "avkl", "avctl", "wavpkg", " avcp", "wavconfig", "ajcfg", "vtx", "avpkg", "avcmd", "averreq", "afconfig", "ajctx", "ajconn", "avectx", "avcfg", "averconn", "AVctx"], "data": ["name", "origin", "t", "out", "start", "message", "frame", "a", "r", "o", "ref", "f", "m", "device", "window", "value", "length", "read", "rel", "offset", "hash", "mid", "format", "table", "d", "ata", "key", "image", "id", "empty", "str", "mu", "xy", "bytes", "batch", "content", "buf", "extra", "raw", "mode", "DATA", "video", "dat", "buffer", "in", "mem", "error", "Data", "action", "block", "address", "bin", "obj", "form", "pos", "next", "pointer", "to", "pad", "file", "feed", "padding", "text"], "got_frame": ["gotpcode", "got_code", "gotpframe", "received_message", "received_frame", "gotpstate", "got_state", "gotpmessage", "received_state", "got_message", "received_code"], "avpkt": ["vanpct", "vanjptx", "afpkt", "avjpacket", "avnpacket", "afpcmd", "avpcacket", "avjpkt", "avjpct", "avPct", "avPacket", "avwptx", "vanjpst", "avwkt", "avcpkat", "avcpct", "avwkat", "avcpwk", "avptx", "afcpwk", "afcpdu", "avpckt", "avwpkt", "afpct", "avpacket", "afpkg", "avpckg", "avcpacket", "vanjpkt", "vanpst", "avwpct", "avppcmd", "avpwk", "avnpkt", "avcpkg", "avjptx", "avcpdu", "afPacket", "avwdu", "avjpst", "avcpkt", "avPst", "avPtx", "afpwk", "avwacket", "vanjpct", "avjpdu", "vanpkt", "avnpcmd", "avwpst", "avjpkat", "avcpcmd", "avpkat", "avpcmd", "avpcct", "vanptx", "avppwk", "avpdu", "afPct", "avnpwk", "avppkt", "afpacket", "avpst", "afcpkt", "afPkg", "avPkg", "avppacket", "avpkg", "afpkat", "avpct", "afPkt", "afcpkat", "afcpacket", "afcpcmd", "avPkt", "afpdu"], "x": ["fx", "xx", "t", "xes", "xt", "xe", "xxxx", "xi", "f", "ix", "check", "h", "y", "ax", "ox", "act", "inx", "tx", "my", "c", "xxxxxxxx", "xy", "xml", "X", "rx", "xp", "lex", "status", "z", "wx", "ctx", "ex", " cx", "px", "xf", "ux", "mx", "xs", "xxx", "client", "l", "v", "xc", "w"], "p": ["n", "t", "vp", "a", "o", "r", "f", "pm", "m", "h", "d", "pt", "pp", "lp", "c", "pa", "jp", "ap", "fp", "ctx", "P", "q", "pr", "ph", "g", "sp", "rep", "pb", "pc", "u", "b", "v", "cp", "w"], "end": ["orig", "en", "old", "all", "start", "stop", "begin", "set", "End", "ref", "off", "h", "length", "window", "offset", "head", "ending", "ended", "add", "id", "e", "ext", "END", "until", "max", " End", "st", "limit", "wind", "hend", "nd", "buf", "ff", "ent", "pent", "send", "est", "buffer", "addr", "dev", "rest", "bound", "pend", "range", "append", "next", "last", "w"], "ptr": ["rect", "prot", "dep", "length", "rel", "pt", "loc", "peer", "reset", "jp", "cur", "fr", "assert", "br", "prime", "inters", "pos", "pointer", "pointers", "point", "rev", "ix", "ind", "wind", "pr", "adr", "dr", "mem", "ts", "rep", "pend", "pc", "cmd", "inst", "push", "td", "r", "ref", "inter", "ter", "proc", "rod", "ctx", "buffer", "try", "sp", "req", "pre", "pi", "dist", "ij", "Ptr", "depth", "off", "tp", "offset", "tip", "src", " pointer", "tr", "fp", "shift", "far", "rt", "hl", "addr", "iter", "address", "each", "pad", "ctr"], "ncolors": ["Ncolorlections", " nColors", "nctores", "nicolores", "ncollers", "nrcolators", "nconstors", "ncolores", " nColores", "nconstores", "Ncolors", "ncolorlections", "ncontlections", " ncolorors", "nrconstores", "ncontainers", "nrcolors", "ncolorords", "nctors", "ncillers", "ncolourlections", "ncolourators", "ncontords", "nchords", " nColainers", "nctlections", "Ncolorors", "ncolourors", "nicolors", "ncontors", "nctORS", "ncolourores", "Ncolorores", "NcolorORS", " ncolorainers", "ncolorainers", "nconstlections", "ncolorators", "NcolORS", " ncolorores", "nicollections", "ncollections", "nCollers", "ncolORS", "nrconstators", "nColors", "nchores", "ncolators", " nCollers", "nrconstlections", "nchors", " ncolainers", "Ncolores", "ncolainers", " ncollections", "nchainers", "ncolorores", "ncilores", "nconstators", "nrcolores", "nColORS", " ncolORS", "ncontORS", " ncolorords", "ncilainers", "nchlers", "ncontores", "nicolORS", " ncolorlections", "nrconstors", "Ncollections", "nColores", " ncolords", "ncolorors", " ncolorORS", "nrcollections", "nCollections", " ncolores", "ncolords", "ncolorORS", "nColainers", " ncollers", "ncilors"], "cpp": ["sup", "xx", "prot", "cap", "ppo", "vp", "clip", "pack", "zh", "heads", "cb", "java", "tp", "ct", "pkg", "pp", "cs", "ext", "ipp", "crop", "cd", "cv", "c", "php", "omp", "mph", "jp", "cmp", "imp", "ip", "proc", "xp", "fp", "PP", "height", "ff", "ctx", "cpu", "xff", "html", "CP", "hl", "px", "cf", "kk", "inc", "js", "amp", "pps", "esp", "sp", "pc", "np", "cmd", "ffff", "fps", "pointer", "cc", "pi", "bp", "fc", "grow", "comp", "cp", "push", "ctr"], "ret": ["fun", "gt", "resp", " Ret", "re", "sys", "out", "lit", "rc", "it", "rev", "usr", "print", "red", "cont", "ber", "ref", "back", "rets", "rem", "err", "Ret", "gc", "tail", "val", "arr", "nz", "def", "ext", "reset", "jp", "flag", "status", "fr", "result", "repl", "mt", "prop", "ft", "rt", "reply", "res", "alt", "true", "buffer", "rf", "addr", "mem", "dr", "try", "iter", "rm", "nt", "RET", "nl", "ne", "ll", "elt", "ry", "att", "v", "success"], "i": ["n", "ij", "bi", "phi", "\u0438", "start", "it", "ic", "a", "si", "me", "di", "iu", "ai", "o", "xi", "m", "ix", "y", "us", "multi", "im", "zi", "ei", "ie", "id", "ind", "e", "gi", "sim", "I", "qi", "ki", "ti", "ip", "ini", "li", "ui", "gu", "ci", "mi", "ii", "pi", "hi", "v"], "j": ["n", "ij", "aj", "jac", "jl", "m", "ji", "ni", "jp", "z", "jc", "k", "jump", "J", "q", "br", "js", "g", "mi", "obj", "pos", "kj", "json", "jj", "b", "v", "l"], "size": ["m", "sum", "length", "err", "fee", "count", "space", "timeout", "sn", "ui", "sv", "sw", "zero", "pos", "v", "small", "sent", "padding", "type", "n", "name", "start", "si", "empty", "bytes", "export", "body", "send", "sc", "mem", "g", "flags", "time", "false", "number", "scale", "max", "c", "s", "z", "height", "ize", "sh", "storage", "buffer", "shape", "ci", "sp", "pi", "capacity", "set", "SIZE", "window", "offset", "member", "code", "iz", "speed", " Size", "Size", "ne", "news", "w"], "dst": ["pst", "bdbr", "dST", "fst", "bdsts", "fST", "dbr", "pST", "bdST", "fbr", "fsts", "bdst", "psts", "pbr", "dsts"]}}
{"project": "FFmpeg", "commit_id": "452ac2aaecf7210a2912d9156869c6314142a794", "target": 0, "func": "static void ripemd160_transform(uint32_t *state, const uint8_t buffer[64], int ext)\n\n{\n\n    uint32_t a, b, c, d, e, f, g, h, i, j;\n\n    uint32_t block[16];\n\n    int n;\n\n\n\n    if (ext) {\n\n        a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4];\n\n        f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9];\n\n    } else {\n\n        a = f = state[0];\n\n        b = g = state[1];\n\n        c = h = state[2];\n\n        d = i = state[3];\n\n        e = j = state[4];\n\n    }\n\n\n\n    for (n = 0; n < 16; n++)\n\n        block[n] = AV_RL32(buffer + 4 * n);\n\n\n\n    for (n = 0; n < 16 - 1;) {\n\n        ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_0_TO_15(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_0_TO_15(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_0_TO_15(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);\n\n    }\n\n    ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n    SWAP(a,f)\n\n\n\n    for (; n < 32 - 1;) {\n\n        ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_16_TO_31(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_16_TO_31(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_16_TO_31(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_16_TO_31(a,b,c,d,e,f,g,h,i,j);\n\n    }\n\n    ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n    SWAP(b,g)\n\n\n\n    for (; n < 48 - 1;) {\n\n        ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_32_TO_47(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_32_TO_47(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_32_TO_47(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_32_TO_47(e,a,b,c,d,j,f,g,h,i);\n\n    }\n\n    ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n    SWAP(c,h)\n\n\n\n    for (; n < 64 - 1;) {\n\n        ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_48_TO_63(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_48_TO_63(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_48_TO_63(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_48_TO_63(d,e,a,b,c,i,j,f,g,h);\n\n    }\n\n    ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n    SWAP(d,i)\n\n\n\n    for (; n < 75;) {\n\n        ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_64_TO_79(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_64_TO_79(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_64_TO_79(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_64_TO_79(c,d,e,a,b,h,i,j,f,g);\n\n    }\n\n    ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n    SWAP(e,j)\n\n\n\n    if (ext) {\n\n        state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e;\n\n        state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j;\n\n    } else {\n\n        i += c + state[1];\n\n        state[1] = state[2] + d + j;\n\n        state[2] = state[3] + e + f;\n\n        state[3] = state[4] + a + g;\n\n        state[4] = state[0] + b + h;\n\n        state[0] = i;\n\n    }\n\n}\n", "idx": 21766, "substitutes": {"state": ["history", "core", "loop", "p", "t", "start", "tag", "resource", "it", "context", "print", "r", "memory", "app", "list", "State", "check", "m", "device", "seed", "hash", "policy", "al", "init", "item", "call", "power", "user", "space", "the", "trace", "row", "info", "close", "test", "initial", "step", "handle", "states", "point", "base", "result", "see", "dict", "spec", "cell", "pal", "event", "q", "queue", "map", "open", "rule", "self", "unit", "area", "iter", "template", "job", "config", "range", "conf", "cache", "store", "port", "STATE", "monitor", "local"], "buffer": ["p", "vector", "view", "binary", "message", "capacity", "index", "output", "ref", "m", "window", "length", "offset", "program", "count", "array", "code", "bar", "Buffer", "size", "limit", "batch", "base", "buf", "function", "bm", "q", "queue", "sequence", "stack", "screen", "command", "buff", "address", "cache", "len", "input", "v", "padding"], "ext": ["ed", "valid", "quote", "end", "binary", "txt", "bf", "cont", "xt", "transfer", "ref", "check", "ef", "ended", "im", "enc", "embed", "def", "empty", "vert", "test", "tim", "Ext", "lex", "aux", "extra", "mult", "full", "ex", "seq", "EXT", "js", "rest", "only", "append", "external", "rend", "flag", "tf", "ctr", "fit", "text"], "a": ["aj", "er", "p", "t", "am", "access", "sa", "this", "o", "app", "ach", "da", "ai", "m", "y", "aaa", "ac", "al", "ar", "ata", "ea", " A", "x", "va", " ca", "pa", "ate", "s", "ao", "oa", "aa", "ap", "ab", "la", "aux", "ga", "A", "ia", "area", "ta", "ad", "ae", "au", "at", "era", "ak", "u", "af", "ma", "an", "l", " ba", "ca", "as", "att", "ba", " fa", "w"], "b": ["bi", "p", "rb", "eb", "it", "bf", "r", "cb", "o", "m", "y", "B", "bl", "gb", "ob", "by", "bs", "mb", "ib", "bc", "bar", "bd", "fb", "nb", "ab", "z", "bo", "br", "ble", "bg", "wb", "db", "ad", "bt", "be", "u", "bu", "sb", "to", "l", "v", "as", "ba", "bb", "w"], "c": ["com", "rc", "vc", "cat", "r", "cb", "ce", "cn", "o", "dc", "m", "y", "co", "ac", "gc", "ct", "ar", "unc", "con", "cs", "cu", "cd", "bc", "cv", "ec", "cur", "col", "arc", "cor", "lc", "cm", "sc", "cf", "ch", "ci", "ad", "mc", "cr", "tc", "u", "cache", "can", "cc", "v", "ca", "fc", "cp"], "d": ["ed", "td", "er", "t", "p", "dh", "der", "dm", "it", "dx", "r", "o", "dd", "di", "D", "m", "dc", "y", "du", "sd", "dn", "dir", "id", "dt", "ld", "cd", "ds", "md", "z", "nd", "df", "dat", "dp", "db", "dev", "de", "dr", "ad", "u", "l", "v", "da", "w"], "e": ["ed", "ee", "er", "en", "p", "it", "eb", "entity", "et", "r", "o", "me", "ing", "ek", "m", "ef", "y", "ei", "ie", "ea", "enc", "um", "eg", "ate", "ec", "le", "E", "se", "ent", "k", "q", "em", "eff", "de", "eu", "es", "ae", "oe", "u", "be", "ne", "l", "v", "el", "eng", "ue", "ev", "w"], "f": ["fn", "er", "t", "p", "it", "bf", "r", "o", "off", "m", "ef", "y", "sf", "err", "fo", "ul", "fe", "fac", "uf", "def", "um", "fm", "fg", "fb", " F", "z", "fr", "fp", "ff", "k", "df", "q", "fi", "fa", "cf", "fd", "conf", "u", "be", "form", "F", "of", "l", "v", "fl", "fc", "tf", "w"], "g": ["ig", "er", "p", "t", "msg", "ic", "it", "gas", "o", "r", "ger", "go", "m", "y", "gm", "gam", "G", "al", "gb", "gc", "gz", "im", "rg", "x", "um", "eg", "gi", "og", "gs", "fg", "s", "ge", "z", "ng", "ga", "ag", "q", "mg", "bg", "sh", "gu", "erg", "gl", "gg", "ch", "gr", "sg", "pg", "u", "gp", "l", "v", "gh", "w"], "h": ["p", "hang", "dh", "he", "it", "ic", "ho", "eh", "hh", "o", "hal", "r", "H", "oh", "m", "y", "hash", "ha", "th", "im", "ash", "x", "hd", "z", "hr", "ih", "bh", "q", "sh", "html", "kh", "ph", "rh", "hl", "hm", "hs", "hp", "help", "ch", "u", "ah", "hi", "l", "v", "ish", "gh", "w"], "i": ["ij", "bi", "ed", "er", "p", "phi", "is", "ic", "it", "ri", "o", "si", "r", "di", "iu", "ai", "io", "then", "m", "ix", "y", "im", "ie", "iy", "gi", "info", "s", "ti", "ip", "z", "ih", "li", "ia", "fi", "el", "oi", "ir", "ik", "ci", "mi", "u", "ii", "hi", "v", "pi", "l", "ish", "w"], "j": ["ij", "aj", "bi", "p", "er", "jac", "out", "it", "r", "o", "jl", "si", "m", "y", "ji", "ie", "im", "x", "note", "dt", "jp", "z", "fr", "jc", "jump", "J", "q", "el", "un", "ja", "db", "js", "ch", "at", "try", "job", "u", "uj", "kj", "json", "obj", "ne", "be", "jj", "v", "l", "dj", "hi"], "block": ["response", "view", "model", "pack", "frame", "set", "output", "ack", "group", "field", "check", "commit", "type", "window", "filter", "hash", "offset", "object", "sync", "image", "array", "join", "bit", "node", "batch", "Block", "lock", "other", "link", "k", "map", "open", "box", "unit", "blocks", "cache", "line", "chain", "channel"], "n": ["fn", "all", " fn", "m", "dn", "count", "con", "on", "span", "node", "no", "N", "sn", "k", "br", " len", "after", "v", "name", "gn", "o", "cn", "ns", "x", "note", "nb", "names", "num", "new", "ln", "ren", "norm", "nl", "t", "rn", "number", "tn", " l", "nor", "nn", "un", " N", "nt", "np", "len", "nc", "l", "nan", "syn", "p", "en", "out", "ul", "init", "na", "conn", "ng", "nm", "pn", "ne", "an", "yn", "mn", "w"]}}
{"project": "FFmpeg", "commit_id": "bc7eb330e3d42f6cff3f95432da999bd4538e2e1", "target": 0, "func": "static void opt_frame_size(const char *arg)\n\n{\n\n    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n\n        fprintf(stderr, \"Incorrect frame size\\n\");\n\n        av_exit(1);\n\n    }\n\n    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n\n        fprintf(stderr, \"Frame size must be a multiple of 2\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n", "idx": 21767, "substitutes": {"arg": ["agg", "name", "ig", "p", "param", "Arg", "ax", "ob", "ar", "val", "key", "arr", "bar", "og", "args", "str", "var", "parse", "op", "spec", "ag", "other", "event", "argument", "num", "reg", "in", "doc", "g", "ad", "config", "block", "cmd", "pg", "v", "flag", "oc"]}}
{"project": "FFmpeg", "commit_id": "20fe316e47fedb28787e77e77a7011133f3d4e73", "target": 1, "func": "static int sdl_write_trailer(AVFormatContext *s)\n\n{\n\n    SDLContext *sdl = s->priv_data;\n\n\n\n    sdl->quit = 1;\n\n\n\n    if (sdl->overlay)\n\n        SDL_FreeYUVOverlay(sdl->overlay);\n\n\n    if (sdl->event_thread)\n\n        SDL_WaitThread(sdl->event_thread, NULL);\n\n\n    if (sdl->mutex)\n\n        SDL_DestroyMutex(sdl->mutex);\n\n\n    if (sdl->init_cond)\n\n        SDL_DestroyCond(sdl->init_cond);\n\n\n\n\n    if (!sdl->sdl_was_already_inited)\n\n        SDL_Quit();\n\n\n\n    return 0;\n\n}", "idx": 21776, "substitutes": {"s": ["n", "p", "t", "a", "r", "os", "set", "o", "f", "h", "m", "ns", "ss", "d", "ps", "cs", "sts", "i", "aws", "fs", "gs", "rs", "c", "ds", "z", "sv", "ats", "S", "js", "sq", "als", "ts", "qs", "sb", "b", "l", "v", "w"], "sdl": [" cdsl", "ndli", "mdlp", "svdl", "skyl", "mdla", "sticklu", " sdlc", "sdli", "easl", "stickls", "hdl", "svli", "SDyl", "easdl", "mdli", "ndla", "sdlu", "stickle", "svlp", "sdql", "sdlp", "SDla", "skyli", "mddl", "sdlc", "ddli", "SDql", " sdls", "SDel", "stickL", "skyls", "easlu", "sdls", "stickl", "sdyl", "sdler", "easler", "easyl", "dkl", "mdl", "sdv", "dkla", "skyel", "sdsl", "dkql", " cddl", "ddlc", " sdsl", "sdla", "svyl", "svL", " cdlc", "SDlp", "SDL", "skyll", "dkL", "easls", "SDli", " sdlu", "dddl", "ddl", "SDler", "mdls", "nddl", "SDls", "skyler", " sdll", "sdL", "stickql", "SDl", "ndl", " sdle", "SDll", "skydl", "hddl", "svls", "easle", "SDv", "SDdl", "mdL", "svv", "sdel", "sdll", "hdla", "ddel", "hdli", " sdv", "svel", "svl", " cdl", "stickla", "ddsl", " sddl", "sddl", " sdL", "easel", "sdle"]}}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "void MPV_decode_mb(MpegEncContext *s, DCTELEM block[6][64])\n\n{\n\n    int mb_x, mb_y;\n\n    int dct_linesize, dct_offset;\n\n    op_pixels_func *op_pix;\n\n    qpel_mc_func *op_qpix;\n\n\n\n    mb_x = s->mb_x;\n\n    mb_y = s->mb_y;\n\n\n\n#ifdef FF_POSTPROCESS\n\n    quant_store[mb_y][mb_x]=s->qscale;\n\n    //printf(\"[%02d][%02d] %d\\n\",mb_x,mb_y,s->qscale);\n\n#endif\n\n\n\n    /* update DC predictors for P macroblocks */\n\n    if (!s->mb_intra) {\n\n        if (s->h263_pred || s->h263_aic) {\n\n          if(s->mbintra_table[mb_x + mb_y*s->mb_width])\n\n          {\n\n            int wrap, xy, v;\n\n            s->mbintra_table[mb_x + mb_y*s->mb_width]=0;\n\n            wrap = 2 * s->mb_width + 2;\n\n            xy = 2 * mb_x + 1 +  (2 * mb_y + 1) * wrap;\n\n            v = 1024;\n\n            \n\n            s->dc_val[0][xy] = v;\n\n            s->dc_val[0][xy + 1] = v;\n\n            s->dc_val[0][xy + wrap] = v;\n\n            s->dc_val[0][xy + 1 + wrap] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[0][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + wrap], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1 + wrap], 0, 16 * sizeof(INT16));\n\n            if (s->h263_msmpeg4) {\n\n                s->coded_block[xy] = 0;\n\n                s->coded_block[xy + 1] = 0;\n\n                s->coded_block[xy + wrap] = 0;\n\n                s->coded_block[xy + 1 + wrap] = 0;\n\n            }\n\n            /* chroma */\n\n            wrap = s->mb_width + 2;\n\n            xy = mb_x + 1 + (mb_y + 1) * wrap;\n\n            s->dc_val[1][xy] = v;\n\n            s->dc_val[2][xy] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[1][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[2][xy], 0, 16 * sizeof(INT16));\n\n          }\n\n        } else {\n\n            s->last_dc[0] = 128 << s->intra_dc_precision;\n\n            s->last_dc[1] = 128 << s->intra_dc_precision;\n\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n\n        }\n\n    }\n\n    else if (s->h263_pred || s->h263_aic)\n\n        s->mbintra_table[mb_x + mb_y*s->mb_width]=1;\n\n\n\n    /* update motion predictor, not for B-frames as they need the motion_val from the last P/S-Frame */\n\n    if (s->out_format == FMT_H263) { //FIXME move into h263.c if possible, format specific stuff shouldnt be here\n\n      if(s->pict_type!=B_TYPE){\n\n        int xy, wrap, motion_x, motion_y;\n\n        \n\n        wrap = 2 * s->mb_width + 2;\n\n        xy = 2 * mb_x + 1 + (2 * mb_y + 1) * wrap;\n\n        if (s->mb_intra) {\n\n            motion_x = 0;\n\n            motion_y = 0;\n\n            goto motion_init;\n\n        } else if (s->mv_type == MV_TYPE_16X16) {\n\n            motion_x = s->mv[0][0][0];\n\n            motion_y = s->mv[0][0][1];\n\n        motion_init:\n\n            /* no update if 8X8 because it has been done during parsing */\n\n            s->motion_val[xy][0] = motion_x;\n\n            s->motion_val[xy][1] = motion_y;\n\n            s->motion_val[xy + 1][0] = motion_x;\n\n            s->motion_val[xy + 1][1] = motion_y;\n\n            s->motion_val[xy + wrap][0] = motion_x;\n\n            s->motion_val[xy + wrap][1] = motion_y;\n\n            s->motion_val[xy + 1 + wrap][0] = motion_x;\n\n            s->motion_val[xy + 1 + wrap][1] = motion_y;\n\n        }\n\n      }\n\n    }\n\n    \n\n    if (!(s->encoding && (s->intra_only || s->pict_type==B_TYPE))) {\n\n        UINT8 *dest_y, *dest_cb, *dest_cr;\n\n        UINT8 *mbskip_ptr;\n\n\n\n        /* avoid copy if macroblock skipped in last frame too \n\n           dont touch it for B-frames as they need the skip info from the next p-frame */\n\n        if (s->pict_type != B_TYPE) {\n\n            mbskip_ptr = &s->mbskip_table[s->mb_y * s->mb_width + s->mb_x];\n\n            if (s->mb_skiped) {\n\n                s->mb_skiped = 0;\n\n                /* if previous was skipped too, then nothing to do ! \n\n                   skip only during decoding as we might trash the buffers during encoding a bit */\n\n                if (*mbskip_ptr != 0 && !s->encoding) \n\n                    goto the_end;\n\n                *mbskip_ptr = 1; /* indicate that this time we skiped it */\n\n            } else {\n\n                *mbskip_ptr = 0; /* not skipped */\n\n            }\n\n        }\n\n\n\n        dest_y = s->current_picture[0] + (mb_y * 16 * s->linesize) + mb_x * 16;\n\n        dest_cb = s->current_picture[1] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n        dest_cr = s->current_picture[2] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n\n\n        if (s->interlaced_dct) {\n\n            dct_linesize = s->linesize * 2;\n\n            dct_offset = s->linesize;\n\n        } else {\n\n            dct_linesize = s->linesize;\n\n            dct_offset = s->linesize * 8;\n\n        }\n\n\n\n        if (!s->mb_intra) {\n\n            /* motion handling */\n\n            if((s->flags&CODEC_FLAG_HQ) || (!s->encoding)){\n\n                if ((!s->no_rounding) || s->pict_type==B_TYPE){                \n\n                    op_pix = put_pixels_tab;\n\n                    op_qpix= qpel_mc_rnd_tab;\n\n                }else{\n\n                    op_pix = put_no_rnd_pixels_tab;\n\n                    op_qpix= qpel_mc_no_rnd_tab;\n\n                }\n\n\n\n                if (s->mv_dir & MV_DIR_FORWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture, op_pix, op_qpix);\n\n                    if ((!s->no_rounding) || s->pict_type==B_TYPE)\n\n                        op_pix = avg_pixels_tab;\n\n                    else\n\n                        op_pix = avg_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* add dct residue */\n\n            add_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            add_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            add_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            add_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            add_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            add_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        } else {\n\n            /* dct only in intra block */\n\n            put_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            put_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            put_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            put_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            put_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            put_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        }\n\n    }\n\n the_end:\n\n    emms_c(); //FIXME remove\n\n}\n", "idx": 21779, "substitutes": {"s": ["ties", "ports", "is", "m", "ims", "sts", "ds", "details", "ex", "sv", "sw", "hs", "es", "ins", "webkit", "als", "ants", "params", "less", "as", "n", "a", "os", "changes", "ns", "bs", "cs", "e", "i", "fs", "aws", "results", "bis", "se", "ers", "ats", "vs", "properties", "g", "has", "ts", "ads", "gets", "sg", "qs", "b", "comm", "sys", "settings", "orders", "y", "stats", "ps", "times", "services", "comments", "c", "z", "spec", "ls", "storage", "S", "its", "conf", "l", "p", "bits", "rates", "parts", "h", "ss", "ses", "eps", "terms", "rs", "gs", "styles", "pers", "locks", "ms", "js", "http", "sq", "tests", "uploads", "w"], "block": ["alloc", "record", "field", "length", "null", "bl", "object", "array", "code", "def", "row", "info", "data", "size", "byte", "Block", "lock", "buf", "raw", "map", "buffer", "shape", "config", "obj", "len", "line", "type"], "mb_x": ["MB_x", "mb_w", "orb_px", "mb67xml", "MB_y", "emb_y", "mb__y", "mb___xml", "mb_xml", "orb_y", "mb___px", "mb67y", "mb_m", "mb__x", "mb_px", "mb08rx", "mx_xp", "mb_ax", "mb_xp", "emb_xf", "emb_X", "media67x", "mb10ox", "media67ax", "MB_width", "mb67ox", "mb10y", "mm_x", "mb___x", "emb_ox", "orb___x", "emb_dx", "mb08x", "orb___y", "mb_z", "mb__width", "mb_rx", "media_xml", "mb_ox", "mb10x", "MB_rx", "mm_y", "mx_x", "mb_X", "orb_x", "mb___y", "MB_ex", "emb_x", "mb_ex", "orb_m", "media_ax", "mb___ax", "orb___m", "mb___m", "mb10xf", "mb_width", "media67px", "mb_dx", "mb_xf", "mx_ox", "mb__ex", "MB_image", "mb67xf", "orb___px", "mb_image", "mb08y", "mb67x", "mb67ax", "mb67px", "mm_z", "media_x", "mm_w", "media_px", "media67xml", "mb08image"], "mb_y": ["record68ym", "raw____ye", "record_yy", "big_iy", "mb_sy", "mb5yy", "mp_x", "mb____ye", "mb_yy", "mb5top", "mb_height", "mm_Y", "mb______yy", "mb_ys", "bigaxyy", "raw_ys", "record_top", "mb5ys", "record68y", "mp_Y", "mm_yy", "mbtx", "mbaxyiy", "mp_b", "mb68ym", "mm_vy", "mt_yy", "record68yy", "mt_xy", "mb_vy", "big_y", "mb_b", "bigaxyiy", "mb____ys", "mbJtop", "raw____y", "record_ym", "mbJym", "mbtb", "mm_y", "mb5y", "mp_y", "mb68y", "mb5ym", "mb_iy", "mb68yy", "mb68ye", "raw_ye", "mb68ys", "mb______Y", "mb68top", "mbtheight", "bigaxysy", "raw____ys", "mb_ye", "mb______vy", "mt_x", "record_y", "mp_height", "big_sy", "mb____y", "mbaxysy", "mb______y", "mt_y", "record68top", "raw____yy", "mbaxyy", "mb_top", "mb_ym", "mbty", "raw_y", "mbJyy", "mb5ye", "raw_yy", "mb_Y", "mb_xy", "mbJy", "mb____yy"], "dct_linesize": ["dct_inesz", "dct_codeszie", "dct_codesize", "dct_codesz", "dct_lineszie", "dct_linesz", "dct_linesizes", "dct_codesizes", "dct_valsz", "dct_valsizes", "dct_valszie", "dct_inesizes", "dct_inesize", "dct_valsize", "dct_ineszie"], "dct_offset": ["dft_origin", "dct_start", "dft_offset", "dct__pos", "dft_start", "dct_pos", "dft__origin", "dft__start", "dft_pos", "dct__offset", "dft__pos", "dft__offset", "dct__origin", "dct_origin", "dct__start"], "op_pix": ["op_jprix", "op_pixels", "op_jpix", "op_jpio", "op_jpixels", "op_pprix", "op_pio", "op_ppixels", "op_cpix", "op_cprix", "op_cpixels", "op_cpio", "op_ppio", "op_ppix", "op_prix"], "op_qpix": ["op_qppx", "op_qcpex", "op_wcpix", "op_qpx", "op_wcpex", "op_qcpix", "op_qpex", "op_qnpixels", "op_qpixels", "op_qnpix", "op_wpix", "op_qcpx", "op_qppix", "op_qppex", "op_qcpixels", "op_wcpx", "op_wcpixels", "op_wpixels", "op_qnpex", "op_wpex", "op_wpx", "op_qppixels", "op_qnpx"], "wrap": ["roll", "pack", "length", "format", "count", "wp", "crop", "rw", "sw", "edge", "ew", "angle", "chain", "wra", "kw", "loop", "orig", "use", "start", "py", "root", "order", "x", "wire", "safe", "round", "size", "wr", "wind", "scroll", "arrow", "wa", "grow", "push", "zip", "track", "wrapper", "scale", "aw", "nw", "inter", "skip", "max", "limit", "snap", "raw", "html", "we", "shape", "xf", "box", "patch", "rap", "sp", "range", "cycle", "len", "wait", "end", "cap", "set", "zag", "rew", "window", "offset", "add", "win", "code", "row", "tab", "step", "tr", "ap", "shift", "align", "draw", "hold", "each", "pad", "w"], "xy": ["expr", "ee", "cho", "io", "foo", "late", "ox", "fo", "yx", "wy", "timeout", "ti", "wx", "aux", "kit", "ex", "phy", "oe", "zero", "dj", "orig", "yy", "py", "o", "zz", "te", "pose", "ji", "x", "note", "copy", "lon", "dim", "my", "coord", "xp", "px", "scroll", "mx", "yz", "xxx", "mie", "mop", "lat", "zip", "xx", "proxy", "axy", "xxxx", "y", "xxxxxxxx", "mo", "ip", "zx", "bo", "dy", "oxy", "xf", "try", "box", "np", "iso", "route", "index", "xe", "go", "offset", "ie", "ey", "iy", "axis", "ge", "prop", "tif", "XY", "iter", "json", "gy", "ne"], "v": ["n", "qv", "t", "p", "vis", "vc", "it", "vi", "vol", "f", "m", "h", "value", "y", "conv", "inv", "iv", "vr", "val", "va", "mint", "current", "i", "x", "vert", "cv", "vm", "c", "size", "av", "tv", "j", "version", "uv", "ve", "sv", "vs", "vt", "up", "g", "ev", "u", "nv", "b", "l", "V", "vp", "lv", "pi", "vv", "w"]}}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n", "idx": 21794, "substitutes": {"ram_addr": ["ramptorder", "gramityid", "ramityid", "am_ptr", "rammyaddr", "ram_adr", "ram_add", " ram_len", "ram_order", "ram_ptr", "ramitysrc", "am_address", " ram_adr", "ram_src", "gramptaddr", "rampuborder", "gramptorder", "gramptdesc", "gram_cmd", "gram_addr", "ramityaddr", "ramptaddress", "ram_len", " ram_address", " ram_ord", "am_add", " ram_ref", "gramitysrc", "ram_cmd", "ram_ord", "rammyaddress", "gramitycmd", "gram_id", "gram_address", "ram_desc", "ram_id", "ramptaddr", "am_addr", "rampubaddress", "ram_address", "ram_ref", "gram_src", "ramitycmd", "rammyadd", "rampubdesc", "rammyptr", "gramptaddress", "rampubaddr", "gram_order", "gram_desc", "ramptdesc", "gramityaddr"], "page": ["parent", "p", "button", "Page", "age", "message", "stop", "comment", "number", "index", "list", "commit", "pixel", "group", "collection", "go", "window", "menu", "policy", "item", "table", "post", "image", "pl", "pp", "payment", "package", "current", "copy", "bar", "document", "empty", "wiki", "row", "section", "node", "tab", "peer", "step", "batch", "profile", "pid", "result", "see", "request", "link", "module", "server", "queue", "draw", "map", "entry", "buffer", "new", "phrase", "sp", "command", "pc", "block", "pool", "pg", "cache", "form", "next", "pointer", "port", "line", "pty", "file", "point", "wait"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int decode_i_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n    return 0;\n\n}\n", "idx": 21796, "substitutes": {"v": ["qv", "history", "p", "vd", "view", "vc", "rev", "ver", "vi", "f", "m", "value", "window", "y", "conv", "inv", "vr", "iv", "val", "x", "current", "i", "wire", "vm", "cv", "c", "s", "av", "j", "tv", "version", "uv", "ov", "q", "ve", "video", "sv", "vs", "env", "vt", "qu", "dev", "ch", "g", "vv", "cache", "form", "nv", "b", "l", "V", "vp", "lv", "ev", "w"], "gb": ["gt", "csv", "gif", "rb", "eb", "bf", "tg", "cb", "hub", "gm", "gam", "goo", "cgi", "gc", "ha", "gd", "mb", "bs", "rg", "uf", "bc", "eg", "vg", "gs", "cv", "bn", "gnu", "fb", "bytes", "xy", "bys", "nb", "hw", "ctx", "deg", "bm", "bg", "html", "gu", "wb", "db", "hog", "xf", "gg", "g", "kb", "pc", "bt", "Gb", "gy", "GB", "sb", "gh", "cfg", "bb"], "pqindex": ["preqindex", "pquposition", "pqfind", "pageqimage", "pageqiindex", "preqqx", "pqualx", "paqindex", "pqrow", "cqlnumber", "paqind", "pqqx", "cqind", "pqposition", "pqnumber", "paixind", "pqlind", "paixIndex", "Pqaxis", "preqposition", "paqname", "pQIndex", "pquantindex", "cqlindex", "pQindex", "pqualposition", "pqualrow", "pqqposition", "pqifind", "paqIndex", "pqqrow", "preqrow", "paixname", "pquindex", "pqqindex", "pQaxis", "pixaxis", "pqaxis", "piqIndex", "pageqifind", "pqux", "preqqindex", "pageqindex", "pqname", "cqnumber", "piqaxis", "pqurow", "Pixaxis", "pixname", "pixindex", "pqqind", "pquantimage", "preqx", "pageqiimage", "pqiimage", "pqind", "pueindex", "pqlnumber", "puenumber", "pageqfind", "pqqname", "pqIndex", "pixind", "pQind", "preqqrow", "pquantfind", "PqIndex", "pqualindex", "pixIndex", "cqlind", "preqqposition", "paixindex", "pqiindex", "pueind", "piqindex", "pqqIndex", "PixIndex", "Pixindex", "pqx", "pQnumber", "cqindex", "pqimage", "pqlindex", "Pqindex"]}}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n", "idx": 21820, "substitutes": {"s": ["n", "comm", "p", "t", "is", "sys", "si", "r", "os", "ns", "ss", "ses", "stats", "bs", "ps", "cs", "sts", "rs", "gs", "fs", "c", "ds", "bis", "ls", "sv", "hs", "S", "js", "es", "usb", "its", "sq", "ts", "gets", "sb", "b"], "mmcfg_addr": ["mmfg_addr", "mmcf_addr", "mmcf_attr", "mmcfg__offset", "mmconf_address", "mmconf_offset", "mmfg_ref", "mmcf_address", "mmcf_offset", "mmcfg__addr", "mmcfg__ref", "mmconf_addr", "mmcfg_address", "mmcfg_offset", "mmcfg_ref", "mmfg_address", "mmcfg__address", "mmcfg_attr"], "val": [" aval", "valid", "p", "lit", " arg", "ival", "sel", "ret", "hal", "vol", " eval", "aval", " el", "value", " value", "al", "rol", "eval", " al", "serv", "loc", "data", "Val", "vec", " Val", " bin", "pol", "buf", " bl", "ctx", " resp", "res", "VAL", "vals", "mem", "doc", "qual", " v", "util", " VAL", " msg", "sol", "v", "el", " lac", "vt"], "len": ["n", "en", " length", "t", " clen", "Len", "h", "length", " l", "mid", "wid", "lp", "lan", "ld", "size", "den", "le", "kl", "fil", " bl", "ls", "num", "un", "lc", " le", "fin", "mem", "ln", "nt", "nl", "pos", "ll", "lf", "elt", "l", "fl", "el", "lib", "syn"], "pci_dev": ["pct_dev", "pca_dev", "pci_gu", "pci_home", "pdi_loc", "pct_switch", "pciipadv", "pci_Dev", "pca_Dev", "pci_loc", "pca_gu", "pci_adv", "pca_home", "pci_device", "pciipdev", "pdi_device", "pci_switch", "pdi_dev", "pdi_ev", "pct_adv", "pciipswitch", "pci_ev"]}}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n", "idx": 21822, "substitutes": {"s": ["comm", "is", "sys", "state", "os", "set", "parts", "source", "h", "m", "ns", "ims", "ss", "ses", "conv", "stats", "d", "bs", "ps", "ops", "eps", "cs", "sts", "rs", "gs", "aws", "fs", "c", "span", "ds", "bis", "se", "status", "z", "spec", "ls", "details", "ms", "sv", "sw", "ats", "vs", "hs", "ies", "S", "js", "es", "xs", "its", "sq", "ts", "als", "ins", "g", "gets", "qs", "less", "store", "acs", "client", "sb", "as", "l", "tes", "serv"], "n": ["en", "t", "p", "a", "number", "o", "non", "cn", "m", "ns", "nw", "nor", "d", "count", "na", "x", "i", "e", "nn", "c", "N", "nos", "j", "nb", "no", "z", "ng", "sn", "nm", "k", "num", " N", "g", "nt", "np", "u", "nl", "len", "ne", "nc", "mn", "b", "l", "v", "nan", "net", "w"], "bit_index": ["bit8length", "bit8index", "bit_level", " bit_name", "bit_key", "git_key", "bit_max", "bit_name", "bit___name", "bit___ind", "byte_index", "bit_ind", "bit8ind", "byte_max", "bit___index", "bit8name", "bit_value", "bit_Index", "git_index", " bit_ind", " bit_length", " bit_set", "bit_num", " bit_Index", "bit_length", "bit_position", "byte_num", "bit_set", " bit_value", "byte_level", "bit___length", "git_position"], "buf": ["bag", "orig", "cap", "msg", "cb", "output", "desc", "off", "window", "err", "src", "arr", "dest", "fac", "uf", "loc", "bc", "nom", "str", "mu", "data", "max", "good", "vec", "limit", "cur", "keep", "nb", "lim", "img", "big", "raw", "br", "brace", "queue", "num", "bg", "seq", "env", "db", "buffer", "box", "dev", "doc", "bound", "norm", "buff", "cmd", "bu", "pos", "cache", "obj", "gen", "bin", "known", "text"]}}
{"project": "FFmpeg", "commit_id": "bf252f7f6fa9c79743242f3efdd30827c97407b4", "target": 0, "func": "static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    char *str = NULL;\n\n    int size;\n\n    uint16_t str_size;\n\n\n\n    if (c->itunes_metadata) {\n\n        int data_size = get_be32(pb);\n\n        int tag = get_le32(pb);\n\n        if (tag == MKTAG('d','a','t','a')) {\n\n            get_be32(pb); // type\n\n            get_be32(pb); // unknown\n\n            str_size = data_size - 16;\n\n        } else return 0;\n\n    } else {\n\n        str_size = get_be16(pb); // string length\n\n        get_be16(pb); // language\n\n    }\n\n    switch (atom.type) {\n\n    case MKTAG(0xa9,'n','a','m'):\n\n        str = c->fc->title; size = sizeof(c->fc->title); break;\n\n    case MKTAG(0xa9,'A','R','T'):\n\n    case MKTAG(0xa9,'w','r','t'):\n\n        str = c->fc->author; size = sizeof(c->fc->author); break;\n\n    case MKTAG(0xa9,'c','p','y'):\n\n        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;\n\n    case MKTAG(0xa9,'c','m','t'):\n\n    case MKTAG(0xa9,'i','n','f'):\n\n        str = c->fc->comment; size = sizeof(c->fc->comment); break;\n\n    case MKTAG(0xa9,'a','l','b'):\n\n        str = c->fc->album; size = sizeof(c->fc->album); break;\n\n    }\n\n    if (!str)\n\n        return 0;\n\n    get_buffer(pb, str, FFMIN(size, str_size));\n\n    dprintf(c->fc, \"%.4s %s\\n\", (char*)&atom.type, str);\n\n    return 0;\n\n}\n", "idx": 21828, "substitutes": {"c": ["coll", "comm", "n", "p", "t", "com", "rc", "ic", "vc", "cont", "cb", "ce", "f", "dc", "m", "h", "err", "abc", "co", "ac", "etc", "ct", "gc", "enc", "call", "con", "cs", "e", "bc", "cu", "cv", "cl", "ec", "cmp", "cur", "C", "ctx", "cod", "lc", "cm", "sc", "cf", "ch", "ci", "g", "anc", "config", "mc", "pc", "cr", "tc", "conf", "cache", "xc", "cam", "cal", "rec", "nc", "cc", "b", "fc", "v", "l", "cp", "ca", "chain"], "pb": ["td", "resp", "p", "sys", "msg", "rb", "eb", "cb", "pm", "tp", "gm", "ob", "pkg", "bank", "mb", "pl", "pp", "lp", "uf", "mp", "wp", "tk", "lb", "erb", "pt", "cp", "peer", "pa", "fb", "PB", "jp", "snap", "asm", "proc", "fp", "ctx", "tmp", "wb", "dp", "px", "pan", "patch", "amp", "sp", "pc", "np", "tc", "pool", "pg", "req", "mont", "emb", "sb", "bs", "b", "bp", "vp", "tf", "bb"], "atom": ["name", "atomic", "mat", "p", "element", "com", "msg", "orm", "ether", "tag", "binary", "ver", "sym", "app", "canon", "type", "m", "om", "tar", "kat", "al", "item", "format", "ata", "key", " app", "x", "or", "data", "node", "chem", "tab", "application", "coord", "base", "prop", "op", "word", "abel", "num", "part", "storage", "entry", "component", "unit", "at", "http", "term", "orb", "nt", "typ", "tem", "conf", "obj", "soc", "form", "tm", "b", "att", "attr", "text"], "str": ["expr", "name", "n", "t", "p", "msg", "out", "txt", "usr", "print", "r", "cont", "vol", "output", "list", "f", "err", "exec", "bl", "units", "init", "enc", "arr", "url", "i", "data", "st", "s", "bytes", "tr", "fr", "buf", "spec", "raw", "ptr", "br", "res", "seq", "STR", "buffer", "addr", "iter", "dr", "g", "rest", "sp", "gr", "rep", "tree", "cr", "obj", "pos", "inst", "dist", "v", "Str", "String", "ctr", "attr", "chain"], "size": ["n", "name", "scope", "use", "message", "si", "amount", "set", "loss", "type", "sum", "length", "SIZE", "scale", "member", "add", "notice", "fee", "ze", "format", "count", "style", "space", "weight", "empty", "args", "dim", "max", "ose", "get", "export", "body", "z", "see", "shift", "height", "function", "sn", "ize", "ui", "iz", "send", "num", "sw", "storage", "speed", "equal", "shape", "unit", "Size", "g", "sp", "global", "zero", "cache", "len", "form", "pos", "l", "small", "grow", "chain"], "str_size": [" str_SIZE", "str_ize", "str_set", "str_type", " str_ize", "str_Size", "str_length", "str_scale", "STR_size", "STR_set", "STR_SIZE", " str_Size", " str_type", " str_length", " str_scale", "str_SIZE"]}}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n", "idx": 21836, "substitutes": {"ctx": ["kw", "Context", "mk", "scope", "txt", "rc", "context", "kt", "ck", "alloc", "quit", "cb", "check", "ns", "ac", "co", "act", "gc", "ct", "pkg", "etc", "ops", "loc", "x", "unc", "ctrl", "conn", "bc", "tk", "timeout", "ind", "tx", "jp", "cmp", "hw", "xp", "setup", "warn", "wx", "aux", "tmp", "auth", "addr", "cf", "wcs", "wd", "config", "nt", "mc", "prefix", "that", "np", "cmd", "tc", "obj", "iat", "acl", "req", "crit", "nc", "cc", "ca", "cp", "cfg", "ctr", "xc"], "errp": ["errps", "erp", "rP", "erps", "errP", " errps", "rr", "rps", " errr", "errr", "erP", "err", " errP", "rp"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n\n                                        int buf_size, AVSubtitle *sub)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n\n\n    DVBSubRegion *region;\n\n    DVBSubRegionDisplay *display;\n\n    AVSubtitleRect *rect;\n\n    DVBSubCLUT *clut;\n\n    uint32_t *clut_table;\n\n    int i;\n\n    int offset_x=0, offset_y=0;\n\n\n\n    sub->rects = NULL;\n\n    sub->start_display_time = 0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    sub->format = 0;\n\n\n\n    if (display_def) {\n\n        offset_x = display_def->x;\n\n        offset_y = display_def->y;\n\n    }\n\n\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects <= 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,\n\n                                  sizeof(*sub->rects));\n\n    if (!sub->rects)\n\n        return AVERROR(ENOMEM);\n\n\n\n    i = 0;\n\n\n\n    for (display = ctx->display_list; display; display = display->next) {\n\n        region = get_region(ctx, display->region_id);\n\n        rect = sub->rects[i];\n\n\n\n        if (!region)\n\n            continue;\n\n\n\n        rect->x = display->x_pos + offset_x;\n\n        rect->y = display->y_pos + offset_y;\n\n        rect->w = region->width;\n\n        rect->h = region->height;\n\n        rect->nb_colors = 16;\n\n        rect->type      = SUBTITLE_BITMAP;\n\n        rect->pict.linesize[0] = region->width;\n\n\n\n        clut = get_clut(ctx, region->clut);\n\n\n\n        if (!clut)\n\n            clut = &default_clut;\n\n\n\n        switch (region->depth) {\n\n        case 2:\n\n            clut_table = clut->clut4;\n\n            break;\n\n        case 8:\n\n            clut_table = clut->clut256;\n\n            break;\n\n        case 4:\n\n        default:\n\n            clut_table = clut->clut16;\n\n            break;\n\n        }\n\n\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n        if (!rect->pict.data[1]) {\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n\n        if (!rect->pict.data[0]) {\n\n            av_free(rect->pict.data[1]);\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n\n\n        i++;\n\n    }\n\n\n\n    sub->num_rects = i;\n\n\n\n#ifdef DEBUG\n\n    save_display_set(ctx);\n\n#endif\n\n\n\n    return 1;\n\n}\n", "idx": 21841, "substitutes": {"avctx": ["aptx", " avcmd", "camctx", " avconn", "avcontext", "vcontext", "avtx", "apctx", "AVconn", "apcontext", "vtx", "AVcontext", "avcmd", "camcontext", "AVtx", "camtx", "apcmd", "camconn", "vcmd", "AVctx", " avcontext", " avtx", "avconn", "vctx"], "buf": ["cap", "msg", "alloc", "bf", "cb", "ref", "err", "read", "mb", "arr", "uf", "cv", "data", "vec", "img", "tmp", "queue", "seq", "db", "buffer", "mem", "doc", "buff", "pb", "bin", "b", "bp", "v"], "buf_size": ["buf_Size", " buf_SIZE", "buf_len", "buf2Size", " buf_len", "buf_SIZE", "buf2size", "buf2len", " buf_Size", "buf2SIZE"], "sub": ["rub", "search", "sing", "desc", "sum", "scan", "rel", "con", "span", "imp", "aux", "ub", "tmp", " subt", "job", "sb", "sup", "sel", "stat", "pop", " unsub", "bs", "Sub", "sim", "copy", "ray", "watch", "cmp", "coord", "replace", "repl", "seq", "part", "sc", "dev", "b", "push", "bi", "review", "tag", "summary", "exec", "rob", "pro", "snap", "ab", "sh", "utils", "rest", "subject", "match", "sp", "delete", " subsc", "req", "conf", "pre", "sur", " subp", "rc", "ver", "set", "sec", "member", "add", "val", "ext", "section", "tab", "test", "st", " subs", "sam", "control", "cond", "super", "reg", "rm", "ch", "sq", "pb", "form", "mod", "lib"], "ctx": ["fn", "comm", "Context", "resp", "kw", "mk", "jac", "sys", "vp", "txt", "org", "context", "ck", "kt", "func", "cb", "exec", "qt", "co", "act", "gc", "ct", "pkg", "conv", "tz", "loc", "def", "ctrl", "conn", "bc", "cd", "cv", "tx", "jp", "cmp", "hw", "xp", "setup", "ia", "lc", "cm", "px", "addr", "cf", "sc", "mem", "kb", "wcs", "config", "mc", "pb", "req", "cmd", "tc", "obj", "conf", "np", "cam", "pc", "iat", "cc", "ctl", "ca", "fc", "course", "cp", "cfg", "xc"], "display_def": ["displayistDEF", "display2des", "play_def", "play_decl", "displaypyif", "record_def", "displaylydef", "play_if", "record_DEF", "routedefparent", "recordtdict", "route_def", "displaylydec", "displaytdef", "display_decl", "displaylydefinition", "release_def", "displaypydec", "release_definition", "routedefdef", "releasepydefinition", "record_decl", "releasepydes", "display2dec", "displaydefid", "displaydefparent", "displaypydefined", "displaytdecl", "display2def", "displaytdict", "displayistdef", "displaypydefinition", "displaypydes", "displaydefdefined", "display_if", "route_id", "release_dec", "displaytDEF", "display_defined", "record_dict", "display_des", "routedefdefined", "display2definition", "release_des", "releasepydec", "displayistdict", "displaydefdef", "route_defined", "displaypydef", "display_dec", "recordtDEF", "display_dict", "play_defined", "recordtdef", "displaylydes", "releasepydef", "display_parent", "route_parent", "display_id", "display_definition", "display_DEF", "displaypydecl", "recordtdecl", "displayistdecl", "routedefid"], "region": ["reference", "role", "collection", "zone", "progress", "format", "roy", "resolution", "rar", "application", "directory", "component", "division", "direction", "feature", "angular", "command", "gru", "widget", "resource", "relation", "program", "riot", "dim", "Region", "language", "country", "connection", "cell", "render", "location", "area", "dimension", "REG", "remote", "network", "volume", "definition", "scope", "r", "memory", "summary", "gc", "table", "description", "script", "layout", "texture", "regulation", "slot", "library", "module", "rest", "config", "range", "cache", "monitor", "radius", "character", "record", "domain", "section", "ge", "associated", "manager", "reg", "unit", "block", "address", "browser", "grid"], "display": ["message", "role", "app", "process", "debug", "displayText", "no", "application", "plays", "player", "map", "screen", "command", "be", "visible", "widget", "local", "chain", "present", "PLAY", "readable", "list", "Display", "pose", "device", "condition", "program", "dim", "data", "show", "see", "render", "location", "gl", "remote", "execute", "update", "definition", "view", "dis", "rem", "disc", "by", "table", "d", "description", "def", "layout", "mac", "design", "position", "buffer", "report", "played", "rest", "range", "store", "route", "monitor", "out", "print", "record", "check", "domain", "full", "draw", "doc", "date", "find", "play", "form", "can", "browser", "origin"], "rect": ["expr", "prot", "ret", "cont", "dial", "desc", "tar", "err", "progress", "rel", "pt", "loc", "tri", "hist", "col", "assert", "br", "res", "feat", "rot", "client", "art", "RECT", "resp", "rr", "ind", "riot", "round", "Rect", "coord", "pr", "sc", "opt", "dr", "rep", "prefix", "rent", "cmd", "remote", "lat", "rn", "r", "ref", "rem", "rob", "act", "dir", "vr", "def", "ptr", "box", "rest", "nav", "store", "attr", "ror", "txt", "val", "row", "tr", "rog", "rt", "cor", "grab", "addr", "reg", "rm", "json", "form", "mod", "rib"], "clut": ["klut", "lut", "cont", "kluti", "llut", "cluti", "ccud", "Cluts", "lcut", "lluts", "lluti", "llutation", "sclott", "luts", "klcut", "luti", "_", "clute", "clat", "sclut", "ccuti", "ccat", "squou", "squat", "jpg", "lcust", "clutter", "crur", "comput", "lutation", "bl", "slut", "dim", "clu", "sclcut", "clou", "Cluti", "clott", "ctat", "squut", "clutation", "clur", "clud", "blud", "blutter", "klur", "crutt", " cluti", "cam", "ccutter", "cruti", "compou", " clutt", "slust", " clute", " clutter", "exec", "bluti", "def", "c", "select", "scluti", "llott", "squu", "llcut", "lcutter", "lcute", "klott", "obj", "slutter", "ctu", "ctou", "cluts", "blut", "clust", "Clut", "func", "Clutation", "slud", "clutt", "sluti", "ccut", "crut", "slute", "klutt", "compute", " clust", " clou", "lcou", "ccou", "ctut", "clcut", "ccu", " clur"], "clut_table": ["clut67function", "clUT_internal", "clurt___function", "clut_buffer", "clut___Table", "clut___table", "clurt___table", "clut2Table", "clut67table", "clut67Table", "clut_TABLE", "clut___function", "clurt_table", "clurt___interface", "clUT_Table", "clut_collection", "clUT_table", "clut2table", "clut_internal", "clUT_buffer", "clut___TABLE", "clut_function", "clut___interface", "clut___internal", "clurt_Table", "clut___buffer", "clurt_interface", "clUT_TABLE", "clurt___Table", "clut2TABLE", "clurt_function", "clUT_collection", "clut67interface", "clut_Table", "clut_interface"], "i": ["n", "ij", "bi", "ori", "phi", "p", "ic", "it", "ri", "si", "me", "index", "di", "r", "ai", "xi", "m", "ix", "y", "ji", "im", "ei", "iy", "x", "id", "ind", " ii", "sim", "gi", "I", "c", "qi", "ini", "j", "ti", "ip", "li", "ia", "k", " bi", "ik", "ci", " j", "mi", "ii", "pi", "yi"]}}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "static QUANT_FN(pvq_encode_band)\n\n{\n\n    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,\n\n                               lowband_out, level, gain, lowband_scratch, fill, 1);\n\n}\n", "idx": 21851, "substitutes": {}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n\n\t\t\t     ram_addr_t size,\n\n\t\t\t     ram_addr_t phys_offset)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - nothing to be done. */\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 21863, "substitutes": {"start_addr": ["starting_arm", "first_address", "end_add", "startxaz", "startableaddress", "start_grad", "starting_adr", "startippad", " start_az", "starting_attr", "start___arch", "start_az", "head_grad", "startableadd", "starting___addr", "startipattr", "start67tag", "from_arm", "start___err", "start00grad", "start_tag", "start_points", " start_arr", "startwoffset", "scan67addr", "start_cmd", "startobjord", "start_mt", "head00grad", "start_arm", "startxad", "startingingadr", "start67attr", "start___gz", "startingptattr", "start67ptr", "start__adr", "first_dir", "start_pad", "startxaddr", "start00alt", "start___mt", "start67addr", "scan67inter", "startableaddr", "starting_ptr", "first_add", " start__address", "startwarch", "head00alt", "startwmt", "start67arm", " start_points", "start67ad", " start_url", "start_offset", "fromablereq", "start2addr", "startwaddr", "wind_adr", "wind_attr", "start_arch", " start_attr", "start__ag", "startptconn", "startipurl", "startockarm", "wind_addr", "start_ord", "rootwaddr", "start67arr", "scan67arr", "startingjdir", "startobjerr", "startingdir", "start67conn", "startableerr", "startingingreq", "starting___err", " start__addr", "start_ad", "start_url", "start2adr", "startipaddr", "fromablearm", "start_ptr", "from_err", "start2mag", "head00addr", "head_conn", "start_add", "end_addr", "starting_dir", "startjdir", "start__add", "end_attr", "startjmag", "start_attr", "start_dir", "startobjgz", "startjpoints", "startipadr", "starting_req", "start_err", "startingurl", "starting_tag", "startabledir", "head00conn", "firstableaddr", "startingingaddr", "start___addr", "starting_gz", "starting_err", "starting_addr", "start_loc", "from_req", "startingloc", "startingptconn", "startingjmag", "startjpad", "fromableaddr", "startingptaddr", "startingjaddr", "start67adr", "start_conn", "start2dir", "firstabledir", "start67inter", "start__addr", "start67cmd", "startingmt", "start___ord", "start_address", "scan_inter", "start_inter", " start__ag", "start__ord", "startockreq", "rootwmt", " start_ord", "root_mt", "scan_arr", "start00addr", "startingingmt", "root_arch", "start_ag", "startingjadr", "from_addr", "fromableerr", "scan67adr", "starting_cmd", "end_address", "firstableaddress", "start_req", "startippoints", "startptattr", "startingattr", "startableconn", "startockerr", " start_ag", "start__address", "start_adr", "startingadd", "start_gz", " start_add", "startablegrad", "start_arr", "start67az", "startingaddress", "startptptr", "starting_ord", "scan_adr", "starting___ord", "starting_conn", "startablereq", "startockaddr", "head_addr", "startobjaddr", " start_address", "root_addr", "startjadr", "start_alt", "starting_mt", "head_alt", "first_addr", " start_pad", "startablearm", " start_ad", "firstableadd", "startingptptr", "starting___gz", "startablealt", "wind_loc", "startingaddr", "startingadr", "scan_addr", "root_offset", "start00conn", "startjaddr", " start_adr", "rootwarch", "start___offset", "start_mag", "rootwoffset", "starting_mag", "startingreq", " start__add", "startptaddr"], "size": ["izes", "message", "m", "sum", "length", "zone", "fee", "count", "needed", "space", "sized", "sw", "resources", "equal", "command", "zero", "pos", "members", "small", "type", "n", "name", "state", "start", "si", "stat", "large", "empty", "dim", "data", "body", "status", "mode", "send", " sizes", "area", "new", "dimension", "g", "scope", "time", "settings", "number", "sex", "scale", "by", "total", "style", "max", "z", "height", "ize", "sy", "sh", "storage", "shape", "len", "capacity", "index", "set", "SIZE", "window", "offset", "too", "member", "win", "id", "code", "shift", "south", "ms", "iz", "speed", "addr", "Size", "address", "news"], "phys_offset": ["phys____start", "phys_unit", "phys_pad", "phys___offset", "phys_padding", "hist_delay", "physongpadding", "physacpadding", "physjdelay", "physical_offset", "phys___address", "cpu_offs", "phys_Offset", "physical_off", "histactile", "phys___offer", "cpu_addr", "physical_offer", "histacdelay", "phys8offset", "phys_offer", "phys____Offset", "physjoffset", "hist_offset", "physical_pad", "phys_align", "physical_Offset", "hist_padding", "physical_address", "phys_delay", "phys____offset", "phys_address", "phys__Offset", "phys8addr", "physical_unit", "phys_off", "physableOffset", "physacoffset", "physipstart", "physacdelay", "cpu_offset", "histacpadding", "hist_tile", "physipOffset", "physipoffset", "physmingoffset", "phys8Offset", "physipposition", "physmingunit", "physongoffset", "physongdelay", "phys_tile", "physactile", "physical_count", "phys_count", "phys__offset", "physongtile", "phys___Offset", "physical_position", "phys_start", "phys_addr", "phys8offs", "phys__align", "histacoffset", "physablepad", "physical_addr", "physjtile", "cpu_Offset", "physableoffset", "physmingOffset", "physical_start", "physmingoff", "physical_align", "physablealign", "phys__pad", "phys_offs", "phys____position", "physjpadding", "phys_position"], "s": ["n", "comm", "t", "p", "state", "sys", "is", "settings", "a", "r", "os", "set", "m", "h", "ns", "ss", "ims", "ses", "ps", "space", "sts", "i", "fs", "rs", "gs", "args", "c", "ds", "sis", "z", "setup", "south", "sm", "spec", "ls", "sam", "sv", "ms", "sw", "hs", "self", "ies", "S", "js", "service", "g", "es", "its", "sq", "ts", "sp", "ares", "new", "conf", "w", "qs", "less", "sb", "support", "as", "v", "sl", "serv"], "mem": ["gem", "msg", "EM", "am", "ret", "mm", "m", "sum", "met", "mp", "ame", "hist", "md", "temp", "lim", "alt", "Mem", "map", "term", "emb", "med", "me", "pm", "program", "um", "copy", "sim", "my", "dim", "ann", "mt", "sm", "mx", "new", "cmd", "tm", "mop", "mind", "known", "ram", "mor", "arm", "memory", "ref", "imm", "lem", "rem", "mini", "mb", "slot", "tim", "mac", "gram", "buf", "raw", "ptr", "em", "buff", "tem", "mi", "cache", "store", "serv", "man", "mat", "txt", "alloc", "index", "go", "member", "item", "na", "val", "nom", "tab", "nm", "ms", "sam", "dem", "addr", "reg", "js", "rm", "doc", "ems", "mc", "mod", "ne", "mn", "phys"], "old": ["all", "et", "m", "two", "ld", "reset", "md", "temp", "low", "aux", "Old", "event", "hard", "ex", "tmp", "alt", "less", "small", "local", "art", "ed", "orig", "list", "back", "OLD", "told", "ind", "my", "lt", "olds", "expected", "existing", "new", "bound", "cmd", "last", "att", "high", "ref", "act", "lost", "def", "args", "var", "good", "raw", "other", "un", "and", "common", "range", "from", "buff", "obj", "pre", "el", "ard", "ver", "set", "off", "al", "item", "original", "val", "ext", "or", "dirty", "test", "older", "ord", "full", "au", "hold", "mod", "lf", "bold", "same"], "err": ["expr", "msg", "rel", "late", "fee", "count", "orer", " score", "eor", "fr", "res", " len", "Error", "cr", "elt", "ev", "n", "eas", "state", "der", "mr", "rev", "ger", "better", "rr", "e", "coord", "exc", "hz", "ler", "pr", "eric", "dr", "inner", "erd", "norm", "esp", "plain", "cmd", "yr", "timer", "t", "sys", "ere", "die", "act", "ner", "str", "rer", "z", "ptr", "cer", "Er", "kr", "try", "req", "conf", "obj", "len", "ered", "attr", " ptr", "valid", "er", "lr", "out", "cb", "aaa", "notice", "gz", "arr", "ext", "conn", "or", "test", "erer", "priv", "js", "iter", "doc", "orum", "error", "later", "ah", "ier", "cfg", "are"]}}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889, "substitutes": {"opaque": ["ocaque", "ipce", "appaque", "ipaddress", "opaddress", "opce", "appce", "occe", "ipaque", "ocaddress", "appaddress"], "addr": ["name", "start", "tag", "offset", "rel", "hash", "add", "src", "key", "url", "id", "label", "str", "var", "host", "handle", "ord", "spec", "ptr", "bind", "map", "Address", "req", "address", "cmd", "len", "attr"], "val": ["ee", " arg", "ref", "value", " value", "bl", "al", "eval", "arr", " tx", "arg", "tx", "Value", "Val", "vec", " interval", "base", "buf", "ctx", "db", "vals", "bin", "len", "b", "v", "sl", "serv"], "size": ["n", "name", "cap", "tag", "message", "index", "desc", "sum", "SIZE", "length", "offset", "scale", "fee", "count", "loc", "code", "weight", "empty", "info", "align", "ize", "send", "Size", "address", "pos", "len", "type"]}}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}", "idx": 21899, "substitutes": {"s": ["n", "comm", "p", "t", "sys", "is", "a", "r", "os", "set", "h", "m", "ss", "ns", "changes", "ims", "ses", "stats", "d", "ps", "bs", "ops", "terms", "cs", "e", "sports", "rs", "gs", "aws", "sts", "c", "comments", "ds", "bis", "status", "south", "spec", "ls", "details", "ex", "sam", "sv", "vs", "hs", "ies", "S", "js", "g", "its", "ts", "conf", "qs", "less", "sb", "b", "v", "tes", "w"], "height": ["density", "volume", "history", "radius", "hang", "build", "view", "distance", "ht", "capacity", "depth", "ows", "h", "window", "length", "y", "th", "total", "x", "style", "resolution", "Height", "data", "size", "angle", "gravity", "position", "shape", "ch", "background", "block", "ty", "bottom", "stroke", "ish", "grow", "padding", "w"]}}
{"project": "FFmpeg", "commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "target": 1, "func": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n", "idx": 21919, "substitutes": {"c": ["coll", "comm", "t", "p", "com", "rc", "ic", "vc", "cont", "cb", "ce", "f", "dc", "err", "abc", "ac", "co", "etc", "ct", "d", "count", "gc", "enc", "call", "con", "unc", "cs", "bc", "e", "cu", "cd", "cv", "uc", "cl", "ec", "cmp", "proc", "z", "C", "ctx", "chain", "lc", "cm", "sc", "cf", "at", "ch", "ci", "g", "anc", "config", "mc", "pc", "cr", "tc", "conf", "cache", "cam", "acl", "form", "nc", "cc", "ca", "fc", "b", "v", "cp", "l", "xc", "oc"], "buf": ["orig", "p", "rb", "cap", "msg", "txt", "end", "alloc", "bf", "begin", "cb", "ref", "off", "read", "bl", "loc", "stream", "uf", "bar", "Buffer", "bc", "cv", "data", "bytes", "vec", "cur", "batch", "ctx", "raw", "ptr", "br", "xff", "queue", "tmp", "seq", "map", "buffer", "mem", "new", "buff", "block", "pb", "pool", "cmd", "pos", "len", "b", "bp", "v", "cp", "ctr"], "buf_size": ["bufswargs", "buffer_Size", "buffer_size", "bufswSize", "buf_Size", "buf2ize", "buf2Size", "buf_SIZE", "buf2size", "buf2args", "buf_ize", " buf_Size", " buf_args", "buf_args", "buffer_SIZE", "bufswsize", "buffer_ize", "buf2SIZE"]}}
{"project": "FFmpeg", "commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "target": 1, "func": "static int hls_read_header(AVFormatContext *s)\n\n{\n\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n\n    HLSContext *c = s->priv_data;\n\n    int ret = 0, i;\n\n    int highest_cur_seq_no = 0;\n\n\n\n    c->ctx                = s;\n\n    c->interrupt_callback = &s->interrupt_callback;\n\n    c->strict_std_compliance = s->strict_std_compliance;\n\n\n\n    c->first_packet = 1;\n\n    c->first_timestamp = AV_NOPTS_VALUE;\n\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n\n\n    if (u) {\n\n        // get the previous user agent & set back to null if string size is zero\n\n        update_options(&c->user_agent, \"user-agent\", u);\n\n\n\n        // get the previous cookies & set back to null if string size is zero\n\n        update_options(&c->cookies, \"cookies\", u);\n\n\n\n        // get the previous headers & set back to null if string size is zero\n\n        update_options(&c->headers, \"headers\", u);\n\n\n\n        // get the previous http proxt & set back to null if string size is zero\n\n        update_options(&c->http_proxy, \"http_proxy\", u);\n\n    }\n\n\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = save_avio_options(s)) < 0)\n\n        goto fail;\n\n\n\n    /* Some HLS servers don't like being sent the range header */\n\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n\n\n    if (c->n_variants == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n    /* If the playlist only contained playlists (Master Playlist),\n\n     * parse each individual playlist. */\n\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n\n        for (i = 0; i < c->n_playlists; i++) {\n\n            struct playlist *pls = c->playlists[i];\n\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n\n                goto fail;\n\n        }\n\n    }\n\n\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n\n\n    /* If this isn't a live stream, calculate the total duration of the\n\n     * stream. */\n\n    if (c->variants[0]->playlists[0]->finished) {\n\n        int64_t duration = 0;\n\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n\n        s->duration = duration;\n\n    }\n\n\n\n    /* Associate renditions with variants */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *var = c->variants[i];\n\n\n\n        if (var->audio_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n\n        if (var->video_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n\n        if (var->subtitles_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n\n    }\n\n\n\n    /* Create a program for each variant */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *v = c->variants[i];\n\n        AVProgram *program;\n\n\n\n        program = av_new_program(s, i);\n\n        if (!program)\n\n            goto fail;\n\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n\n    }\n\n\n\n    /* Select the starting segments */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n\n    }\n\n\n\n    /* Open the demuxer for each playlist */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        AVInputFormat *in_fmt = NULL;\n\n\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->index  = i;\n\n        pls->needed = 1;\n\n        pls->parent = s;\n\n\n\n        /*\n\n         * If this is a live stream and this playlist looks like it is one segment\n\n         * behind, try to sync it up so that every substream starts at the same\n\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n\n         * all active streams within the first few seconds). This is not very generic,\n\n         * though, as the sequence numbers are technically independent.\n\n         */\n\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n\n            pls->cur_seq_no = highest_cur_seq_no;\n\n        }\n\n\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n\n        if (!pls->read_buffer){\n\n            ret = AVERROR(ENOMEM);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n\n                          read_data, NULL, NULL);\n\n        pls->pb.seekable = 0;\n\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n\n                                    NULL, 0, 0);\n\n        if (ret < 0) {\n\n            /* Free the ctx - it isn't initialized properly at this point,\n\n             * so avformat_close_input shouldn't be called. If\n\n             * avformat_open_input fails below, it frees and zeros the\n\n             * context, so it doesn't need any special treatment like this. */\n\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        pls->ctx->pb       = &pls->pb;\n\n        pls->ctx->io_open  = nested_io_open;\n\n\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n\n            goto fail;\n\n\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n\n            avformat_queue_attached_pictures(pls->ctx);\n\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n\n            pls->id3_deferred_extra = NULL;\n\n        }\n\n\n\n        if (pls->is_id3_timestamped == -1)\n\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n\n\n        /*\n\n         * For ID3 timestamped raw audio streams we need to detect the packet\n\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n\n         * on us if they want to.\n\n         */\n\n        if (pls->is_id3_timestamped) {\n\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n\n\n        /* Create new AVStreams for each stream in this playlist */\n\n        ret = update_streams_from_subdemuxer(s, pls);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n\n    }\n\n\n\n    update_noheader_flag(s);\n\n\n\n    return 0;\n\nfail:\n\n    free_playlist_list(c);\n\n    free_variant_list(c);\n\n    free_rendition_list(c);\n\n    return ret;\n\n}\n", "idx": 21925, "substitutes": {"s": ["n", "comm", "csv", "p", "t", "sys", "is", "times", "settings", "a", "os", "parts", "h", "m", "ss", "ns", "ims", "changes", "ses", "stats", "ps", "bs", "cs", "sts", "sports", "fs", "gs", "rs", "aws", "ds", "bis", "se", "south", "ctx", "spec", "ls", "ex", "sv", "sw", "sets", "ats", "vs", "hs", "sc", "S", "js", "xs", "es", "its", "sq", "ts", "ins", "sg", "conf", "qs", "less", "sb", "b", "as", "w"], "u": ["p", "t", "out", "it", "o", "r", "ru", "iu", "f", "su", "hu", "lu", "us", "ul", "etc", "uf", "um", "user", "cu", "mu", "gnu", "edu", "nu", "pu", "uv", "uni", "q", "ui", "ex", "un", "gu", "ur", "fu", "up", "eu", "ux", "unic", "g", "au", "ou", "yu", "util", "uu", "b", "ue", "uid", "tu", "uk", "ut", "upload", "U"], "c": ["coll", "comm", "n", "p", "t", "com", "rc", "vc", "r", "o", "cont", "ce", "cb", "cn", "f", "dc", "h", "m", "cus", "abc", "co", "ac", "gc", "ct", "etc", "enc", "unc", "con", "call", "current", "cs", "bc", "cu", "e", "cd", "cv", "comments", "uc", "cl", "ec", "cur", "cmp", "C", "ctx", "lc", "cm", "sc", "cf", "ci", "anc", "config", "mc", "pc", "cr", "tc", "conf", "cache", "cam", "can", "nc", "cc", "b", "ca", "fc", "cp", "l", "chain"], "i": ["n", "bi", "ij", "p", "t", "phi", "\u0438", "ic", "it", "iq", "ri", "r", "si", "index", "di", "iu", "me", "ai", "f", "xi", "m", "ix", "y", "ims", "us", "ji", "multi", "zi", "ei", "x", "id", "e", "sim", "gi", "ind", "I", "ami", "qi", "ki", "ini", "j", "cli", "ti", "ip", "batch", "li", "k", "ui", "oi", "ir", "o", "in", "ci", "g", "mi", "ii", "ma", "pi", "b", "l", "hi"], "pls": ["splis", " plls", "Plgs", "splts", "plls", "plis", " plgs", "plts", "slds", "Pls", " plds", "plgs", "plds", "slls", "splls", " plts", "slgs", "spls", "Plis", "Plds", "Plts", "slis", "sls", "Plls", " plis"]}}
{"project": "FFmpeg", "commit_id": "8a9641a652ed1546fedfda22584f79d3d423096e", "target": 0, "func": "AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n\n{\n\n    AVBitStreamFilter *bsf = first_bitstream_filter;\n\n\n\n    while (bsf) {\n\n        if (!strcmp(name, bsf->name)) {\n\n            AVBitStreamFilterContext *bsfc =\n\n                av_mallocz(sizeof(AVBitStreamFilterContext));\n\n            bsfc->filter    = bsf;\n\n            bsfc->priv_data =\n\n                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n\n            return bsfc;\n\n        }\n\n        bsf = bsf->next;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21938, "substitutes": {"name": ["n", "NAME", "p", "search", "scope", "cap", "tag", "ref", "alias", "type", "filter", "value", "title", "init", "order", "format", "key", "filename", "description", "power", "id", "ame", "code", "space", "on", "str", "info", "data", "admin", "size", "no", "named", "ment", "base", "family", "version", "word", "now", "names", "Name", "buffer", "new", "template", "sequence", "prefix", "path", "action", "w", "priority", "ne", "local", "text"], "bsf": ["itsf", "nsf", "psfac", "insf", "bpfs", "vsf", "abscf", "tsf", "bysfe", "besf", "vsfc", "atsfc", "gsfac", "itsfe", "jsuf", "cksfc", "atscf", "bsuf", "bpsfc", "byscf", "nsfs", "cksfp", "inscf", "itsfac", "bsv", "vsfac", "nsuf", "bescf", "ckscf", "jsfp", "atsf", "psuf", "bsfe", "bsfac", "nscf", "lsfx", "bpsv", "besfe", "psf", "tsfc", "bpcf", "besfs", "atsuf", "bysf", "bpfc", "bpsf", "pscf", "lsfc", "absfc", "bpsuf", "lsv", "bysfs", "gsfc", "nsfc", "bscf", "jscf", "gscf", "bpf", "absfac", "vscf", "psfp", "itsfc", "gsf", "jsfc", "tsfs", "tscf", "bsfx", "absf", "cksf", "jsf", "bpsfx", "itsfs", "bsfp", "gsv", "gsfx", "itscf", "bpscf", "insfc", "psfc", "lsf", "bsfs", "insfac"], "bsfc": ["ubsfc", "ubsfd", "fsfw", "bpsfac", "ksfc", "abscf", "ubscf", "ckscf", "lsfc", "kscf", "ubspic", "ubsfac", "absf", "absfc", "bsfd", "actionsfd", "bitsfw", "bsfw", "bpsfd", "ubsf", "fsunc", "absfd", "cksfw", "bsfac", "bitsfc", "kspic", "bspic", "fscf", "bpscf", "bscf", "bitsunc", "lsfd", "bitscf", "cksfc", "lscf", "ksf", "bpsfc", "bsunc", "actionsfac", "lspic", "fsfc", "ksfd", "actionscf", "actionsfc", "cksunc"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957, "substitutes": {}}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n", "idx": 21958, "substitutes": {"bdrv": ["ddrj", "bbrvd", "ddrw", "bdriw", "dsrv", "bdriv", "bsrj", "bcrvr", "bcrV", "btrv", "bsrv", "bderh", " bderf", "bdrV", "bcrv", "brvr", "dsri", "brv", "ddri", "bsrw", "bdrij", " bderm", "bbrvr", "dsrw", "btrh", "bdrh", "bcrvd", "bbrV", "bdrf", "bderj", "bdrvr", "brV", "btrm", "brvd", "bdrii", "bbdrvd", "bgrf", "bsri", "bbdrV", "bgrh", "btrf", " bdrh", "bgrv", "bbdrv", "bderv", "bdrw", "bderm", "bdri", "bdrj", "ddrv", "bdrm", "bbdrvr", "bgrm", "bderf", " bderv", "dsrj", " bdrm", " bdrf", " bderh", "bbrv", "bderi", "bderw", "bdrvd"], "index": ["process", "write", "column", "collection", "ox", "author", " indent", "connected", "count", "unknown", "loc", "timeout", "ask", "ex", "sw", "exist", "open", "zero", "stick", "EX", "local", "point", "coll", "Index", "loop", "present", "create", "context", "list", "ix", "IND", "x", "ind", "empty", "level", "size", "show", "connection", "eight", "send", "num", "dimension", "prefix", "update", "instance", "suggest", "number", "scale", "act", "display", "call", "label", " indic", "nn", "select", "mix", "bo", "foot", "\u00e7", "position", "in", "config", "cycle", "alias", "out", "capacity", "where", "gate", "connect", "check", "go", "seed", "add", "read", "key", "document", "row", "axis", "test", "query", " ind", " sidx", "draw", "seek", "iter", "date", "find", "address", "each"]}}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962, "substitutes": {"obj": ["expr", "resp", "orig", "any", "txt", "org", "ht", "it", "oid", "o", "os", "cont", "go", "object", "ob", "act", "inv", "unknown", "po", "tk", "onet", "str", "xy", "j", "hw", "bo", "ctx", "bh", "ex", "tmp", "obo", "Object", "stuff", "js", "Obj", "nt", "obs", "objects", "typ", "cmd", "inst", "elt", "att", "gov", "bj", "attr"], "nf": ["cnfb", "nfb", "nfo", " nfb", " nfg", "cnaf", "pnfc", "cnxf", "nuf", "cnfo", "cnfg", "nxf", " nfac", "nefo", " nbf", "pnfb", "onf", "onfe", "naf", "ynfc", " nxf", "cnf", "cnv", "ynxf", "ynbf", " nuf", "ynv", "nfac", "ynfb", "pnaf", "cnuf", "nef", "pnf", "nbf", " nfo", "onfo", "nefe", "cnbf", "nfg", "ynf", "pnfac", "ynaf", " nv", "nefc", "onfg", " nfe", "cnfc", "nv", "cnfac", "ynuf", "nfe", "onfc"], "nfc": ["ncf", "panlc", "Nf", "Ncf", "nxf", "anf", "ancf", " npc", "nonfc", "Nxf", "nonpc", "onf", " nxf", "anxf", "panfc", "panf", " ncf", "nonf", "nlc", "nonlc", "onlc", "onpc", "onfr", "Nfc", " nlc", "npc", " nfr", "panfr", "anfc", "nfr", "onfc"]}}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 21967, "substitutes": {"args": ["flags", "bits", "settings", "ks", "parts", "css", "ams", "ns", "ims", "uments", "amps", "gb", "init", "terms", "arg", "eps", "cs", "aws", "gs", "fs", "ds", "md", "Args", "caps", "atts", "ms", "vals", "properties", "limits", "ants", "ts", "config", "params", "aus", "cmd", "ags", "qs", "GS", "cfg", "fields"]}}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969, "substitutes": {"dev": ["er", "p", "out", "ver", "Dev", "os", "dd", "app", "desc", "go", "device", "h", "serial", "head", "d", "serv", "val", "pro", "def", "conn", "Device", "test", "des", "ds", "data", "var", "develop", "av", "disk", "hw", "DEV", "prop", "buf", "spec", "link", "ve", "env", "devices", "db", "home", "adj", "addr", "de", "priv", "ad", "mem", "adv", "nt", "cam", "cmd", "obj", "cache", "pad", "pi", "v", "dist", "ev", "w"], "err": ["ok", "resp", "er", "eas", "msg", "der", "txt", "mr", "usr", "rb", "it", "die", "r", "cb", "aaa", "order", "fee", "gz", "arr", "rr", "eps", "e", "ext", "eth", "rs", "str", "test", "ec", "warn", "result", "buf", "exc", "ptr", "kr", "Er", "res", "addr", "iter", "ch", "error", "Error", "req", "cr", "conf", "obj", "ah", "cfg", "ev", "errors"], "s": ["ports", "all", "is", "source", "m", "ims", "space", "sts", "ds", "details", "sv", "hs", "es", "als", "params", "_", "less", "sb", "as", "v", "n", "state", "a", "os", "changes", "ns", "bs", "i", "cs", "e", "fs", "aws", "states", "se", "vs", "ats", "self", "service", "g", "ts", "cmd", "qs", "b", "comm", "t", "sys", "settings", "r", "f", "y", "session", "exec", "stats", "ps", "def", "times", "services", "args", "str", "c", "z", "spec", "ls", "utils", "S", "its", "sp", "conf", "store", "l", "serv", "er", "p", "out", "func", "set", "h", "ss", "us", "ses", "sports", "rs", "gs", "get", "j", "ms", "sam", "addr", "js", "tests", "sq", "w"], "x86_iommu": ["x86_iOMue", "x86_iOMu", "x86_diommu", "x86_iommue", "x86_iowU", "x86_Iomu", "x86_iompU", "x86_iommpu", "x86_iowue", "x86_diowu", "x86_iormU", "x86_iompue", "x86_iompu", "x86_iomput", "x86_iormpu", "x86_IommU", "x86_Iommpu", "x86_diommue", "x86_iomu", "x86_Iompu", "x86_diowue", "x86_iomU", "x86_diommut", "x86_iomppu", "x86_iowut", "x86_diommU", "x86_iowu", "x86_iOMU", "x86_Iommu", "x86_iOMut", "x86_iormu", "x86_IomU", "x86_iommut", "x86_diowut", "x86_diowU", "x86_iommU"], "bus": ["loop", "t", "p", "state", "sys", "way", "is", "bits", "vc", "bolt", "os", "boot", "back", "h", "us", "ac", "driver", "bs", "board", "bridge", "bc", "bar", "Bus", "mount", "c", "data", "host", "handle", "machine", "proc", "lock", "buf", "chain", "BUS", "book", "box", "g", "usb", "config", "util", "block", "soc", "cache", "pos", "gen", "bug", "b", "as", "v", "phys", "local", "lib", " BUS"]}}
{"project": "FFmpeg", "commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "target": 1, "func": "int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)\n\n{\n\n    DynBuffer *d = s->opaque;\n\n    int size;\n\n    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};\n\n    int padding = 0;\n\n\n\n    if (!s) {\n\n        *pbuffer = NULL;\n\n        return 0;\n\n    }\n\n\n\n    /* don't attempt to pad fixed-size packet buffers */\n\n    if (!s->max_packet_size) {\n\n        avio_write(s, padbuf, sizeof(padbuf));\n\n        padding = FF_INPUT_BUFFER_PADDING_SIZE;\n\n    }\n\n\n\n    avio_flush(s);\n\n\n\n    *pbuffer = d->buffer;\n\n    size = d->size;\n\n    av_free(d);\n\n    av_free(s);\n\n    return size - padding;\n\n}\n", "idx": 21971, "substitutes": {"s": ["n", "comm", "t", "p", "is", "sys", "a", "sa", "r", "os", "source", "f", "m", "h", "ns", "ss", "ims", "ses", "stats", "bs", "ps", "cs", "sts", "i", "rs", "gs", "socket", "aws", "c", "fs", "ds", "st", "se", "sm", "ls", "ms", "sv", "ats", "hs", "self", "sc", "S", "js", "g", "es", "ins", "sq", "ts", "its", "sp", "gets", "qs", "less", "sb", "an", "as", "sl", "w"], "pbuffer": ["prebuffer", " pstream", "prebuf", "pingtable", "pbbuffer", "pblock", "pingstream", "ppointer", "dbuffer", "pbbuf", "Pblock", "pingbuf", "Ppointer", "plength", "prepointer", " plength", "pstream", "dpointer", "pbpointer", " pblock", "pbuf", "dbuf", "Pbuf", " pbuf", " ppointer", "pingbuffer", "dblock", " ptable", "Pbuffer", "dstream", "dtable", "prelength", "ptable", "pblength"], "d": ["n", "done", "p", "t", "dh", "dm", "dx", "D", "r", "dd", "di", "o", "del", "f", "dc", "m", "h", "dq", "did", "sd", "dn", "gd", "ld", "dt", "c", "des", "ds", "dl", "md", "j", "z", "dict", "dp", "db", "ded", "dr", "ad", "g", "fd", "dos", "mod", "pd", "b", "l", "v", "da", "w"], "size": ["n", "name", "p", "time", "cap", "start", "message", "capacity", "number", "set", "ce", "loss", "used", "group", "sum", "length", "zone", "window", "SIZE", "offset", "scale", "notice", "fee", "device", "count", "needed", "key", "description", "when", "IZE", "space", "e", "empty", "span", "data", "c", "max", "since", "handle", "z", "height", "sn", "now", "ize", "send", "position", "storage", "equal", "buffer", " sizes", "shape", "performance", "area", "speed", "Size", "dimension", "g", "sp", "address", "cache", "len", "v", "small", "news", "sent", "padding"], "padbuf": [" paddBuffer", "adbuf", "adbytes", "adbuffer", " paddbytes", "barbuf", "wrapbuf", "barqueue", "padbuffer", " padbuffer", "wrapbuffer", "adbuff", "barbuff", " paddbuffer", "padbytes", "adqueue", "adBuffer", "padqueue", "padbuff", " padqueue", "padBuffer", " padBuffer", "wrapqueue", "barbuffer", " padbuff", " paddbuf", "wrapbuff", " padbytes"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995, "substitutes": {"queue": ["master", "history", "core", "state", "quit", "context", "message", "cue", "processor", "Queue", "list", "force", "dq", "menu", "database", "ques", "count", "complete", "file", "info", "journal", "que", "batch", "worker", "lock", "result", "archive", "event", "q", "manager", "server", "handler", "utils", "seq", "env", "buffer", "sequence", "config", "job", "command", "util", "block", "pool", "league", "cache", "priority", "store", "client", "port", "grid", "ue", "widget", "wait", "channel"], "sender": ["sener", "mender", "isender", "insceiver", "insender", "resend", "isend", "nriber", "mceiver", "resiter", "mriber", " siter", "resceiver", "insend", "mener", "nporter", "csporter", "resender", "csender", "mend", " sceiver", "sceiver", "Sender", "csink", "send", "isiter", "mporter", "sporter", "csriber", "nender", "sriber", "Sener", "mink", "sink", "Sceiver", "isceiver", "siter", "Send", " send", "insener", "nink"], "flags": ["issues", " Flags", "leases", "ports", "offs", "links", "bits", "heads", "phones", "aps", "weights", "parts", "packages", "alf", "tags", "bugs", "acts", "window", "iffs", "amps", "stats", "count", "FLAG", "ops", "mask", "weight", "cs", "fs", "args", "data", "comments", "bytes", "s", "locks", "frames", "faces", "files", "details", "atts", "ms", "utils", "lines", "properties", "types", "grades", "reports", "vals", "posts", "ants", "Flags", "cmd", "ags", "options", "fps", "nets", "actions", "flag", "irms", "type"], "buf": ["bag", "orig", "rb", "cap", "msg", "txt", "cb", "window", "ob", "Buff", "pkg", "uf", "bar", "Buffer", "bc", "cv", "data", "bytes", "vec", "cur", "img", "ctx", "raw", "br", "map", "db", "buffer", "box", "mem", "doc", "fd", "buff", "block", "pg", "blocks", "bin", "b", "bp", "pad"], "size": ["name", " length", "time", "out", "any", "is", "message", "capacity", "number", "os", "loss", "set", "index", "sum", "length", "SIZE", "offset", " resize", "scale", "zone", "too", "fee", "format", "count", "total", "package", "id", "space", "code", "empty", "timeout", "info", "args", "data", "bytes", "limit", "cmp", "body", "since", "height", "ctx", "spec", "mode", "ize", "ui", "send", "num", "storage", "equal", " Size", " sizes", "shape", "area", "new", "Size", "sp", "address", "pos", "len", "small", "news", "sent", "type"], "sent_cb": ["sent2msg", "sentptmsg", "send_buf", "sent_buf", "sent____callback", "sent_pb", "sent2ctx", "sent_cv", "sent2cb", "sent___job", "sent_msg", "sent_callback", " sent_callback", "sent____job", "send_pb", "sent_ctx", "sent___cb", "sent___callback", "send_cb", "sent___rb", "sentptctx", "encrypted_ctx", " sent_cv", "send_callback", "sentptcb", " sent_rb", "encrypted_cb", "sent_job", "encrypted_bs", " sent_job", "sent_rb", "sent____cb", "sent____rb", "sent2bs", "sentptbs", "sent_bs", "encrypted_msg"], "packet": ["Packpet", "signet", "makeet", "claimunct", "pet", "buckacket", "packant", "payacket", "signunct", "packageET", "packageunct", "packageacket", "propet", "compett", "packsinet", "packette", "captec", "codec", "claimacket", "ppoint", "packsett", "pant", "codacket", "formett", "packed", "productpet", "pplet", "packsacket", "ppacket", "payset", "packoint", "productlet", "formacket", "buckunct", "lookacket", "bucket", "participunct", "formet", "participet", "codet", "compinet", "lookset", "packET", "signette", "packpet", "captet", "Packant", "claimette", "ppet", "payed", "productacket", "participant", "compant", "claimet", "ppec", "looked", "pppet", "packset", "packett", "cleanET", "codoint", "compet", "propunct", "looket", "packlet", "propacket", "packinet", "packunct", "propette", "Packline", "pET", "packec", "Packet", "captoint", "productet", "signacket", "cleanant", "packageant", "Packlet", "compacket", "cleanacket", "Packacket", "forminet", "participacket", "compline", "packacket", "cleanet", "makeed", "packline", "ppant", "packageet", "buckant", "ppline", "payet", "captacket", "makeacket", "makeset"]}}
{"project": "FFmpeg", "commit_id": "02591641f88097aec2a573f0ae384c8b87bcfe3b", "target": 1, "func": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n", "idx": 22003, "substitutes": {"s": ["n", "comm", "t", "p", "is", "sys", "settings", "a", "r", "os", "f", "h", "changes", "ns", "ss", "ims", "y", "ses", "stats", "bs", "ps", "cs", "sts", "space", "rs", "gs", "aws", "fs", "c", "ds", "bis", "services", "comments", "ls", "details", "sam", "sv", "ms", "ats", "hs", "S", "js", "es", "ins", "sq", "ts", "its", "als", "ares", "gets", "sg", "qs", "less", "sb", "ains", "b", "l", "events", "serv"], "channel": ["name", "parent", "chart", "chn", "frame", "CH", "chan", "group", "pixel", "color", "column", "panel", "filter", "member", "attribute", "domain", "table", "key", "label", "mask", "row", "Channel", "axis", "c", "category", "batch", "coord", "col", "version", "height", "server", "chip", "queue", "component", "unit", "ch", "annels", "range", "config", "chron", "block", "variable", "client", "hole", "v", "course", "uri", "chain"], "residual_size": ["residualtshape", "residualtSize", "residUAL_Size", "residitional_dim", "residitional_SIZE", "residitional_size", "residualtsize", "residual_Size", "residual_dim", "residUAL_shape", "residual_SIZE", "residitional_Size", "residUAL_size", "residual_shape"], "pred_order": ["pred_sort", "predationorder", "predNameorder", "predationsort", "pred_orders", "pred_after", "predNameOrder", "Pred_num", "pred___over", "pred___order", "pred___position", "pred_force", " pred8position", " pred_sort", "predationorders", "Pred_ord", "pred___force", " pred_over", "pred_num", "predityposition", "predationmode", "pred_Order", "predityover", "pred_ord", "predityforce", "pred8over", " pred8order", " pred_force", "Pred_after", "predityorder", " pred_position", "pred_mode", " pred_mode", " pred_orders", "pred_over", "Pred_order", " pred8over", "pred8position", "Pred_scale", " pred8force", "pred_scale", "Pred_Order", "pred_position", "pred8force", "pred8order", "predNamescale"], "sum": ["n", "sup", "average", "out", "sa", "comment", "si", "loss", "vol", " sums", "summary", "hash", "add", "su", "ul", "us", "m", " summed", "score", "scale", "Sum", "mean", "total", "count", "fac", "um", "sim", "weight", "cum", "max", "c", "size", "ass", " summ", "ge", "result", "other", "sam", "umm", "num", " Sum", "dev", "mem", "au", "hum", "pool", "cal", "u", "tm", "acc", "oss", "v", " SUM", "tu", "dot"], "i": ["is", "ic", "io", "m", "ims", "im", "I", "ti", "cli", "batch", "ui", "ex", "ir", "v", "point", "chain", "n", "name", "\u0438", "a", "si", "me", "list", "ai", "ix", "x", "ind", "sim", "e", "gi", "info", "ami", "at", "g", "iat", "u", "hi", "bi", "phi", "it", "r", "xi", "f", "y", "multi", "zi", "iri", "ei", "c", "qi", "ini", "ip", "z", "li", "ia", "in", "ci", "mi", "ii", "pi", "l", "ori", "ij", "p", "out", "di", "iu", "us", "init", "ie", "id", "ki", "iter"], "j": ["n", "ij", "aj", "jac", "bi", "p", "it", "jit", "r", "o", "jl", "di", "f", "m", "ix", "h", "y", "err", "ax", "ji", "by", "key", "bs", "pt", "bj", "x", "ot", "note", "ind", "c", "jp", "bot", "ge", "col", "z", "fr", "nd", "jc", "bo", "li", "other", "k", "jump", "J", "q", "br", "pr", "oj", "el", "ja", "ju", "js", "ch", "g", "at", "jo", "try", "_", "obj", "uj", "kj", "json", "u", "next", "jj", "b", "v", "l", "dj", "ev"], "coeffs": ["COefe", "coefficientss", "COefjs", "COffs", "coeffe", " coefes", "coeffjs", "coffs", "coefe", "COeffe", "COffes", "coefficients", "coefs", " coeffes", "coefficjs", "coeffes", "coeffice", "coeffS", "coEFFes", "COefS", "COeffjs", "coffes", "coefficiente", "coefficientses", "coefficientS", "coeffics", "COeffS", "coefficS", "COeffs", "coEFFs", " coefS", "coEFFS", "coefjs", " coefs", " coeffS", "COefs", "coffS", "coefes", "COeffes", "coefficientjs", "coefS"]}}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006, "substitutes": {"timer_list": ["ter_listed", "coordistint", "wrapper_collection", "timer_tree", "timeristint", "timerricint", "imer_link", "imer_li", "timerricalist", "imer_lists", "imer_module", "timer_li", "timer_int", "timeritylists", "timer_LIST", "wrapper_list", "timeritycollection", "Timer_List", "timerPlisted", "wrapperistname", "timer_link", "timeristnet", "timeristcollection", "Timer_tree", "ter_LIST", "wrapper_name", "coord_alist", "timerityList", "coordistnet", "timeristname", "timerPleft", "timer_collection", "timer_add", "ter_left", "timer_left", "imer_alist", "timerPlist", "timer_lists", "timeritytable", "Timer_list", "wrapperistlist", "wrapper_add", "Timer_table", "timeracadd", "timeristlisted", "timer_module", "timeraclist", "timeristlists", "timer_table", "imer_listed", "timeristlist", "imer_list", "timer_name", "coordistalist", "timerricnet", "coord_list", "timeristlink", "timeracname", "timeraccollection", "timeristadd", "coordistlist", "coord_net", "coord_int", "timeritylist", "timer_List", "ter_list", "timeristalist", "wrapperistcollection", "imer_collection", "wrapperistadd", "timer_listed", "timeritytree", "timer_net", "timer_alist", "timerriclist", "timerPLIST"], "expire_time": ["expirezstart", "expiration_count", "expiration_delay", "exiry_no", "expiretimeTime", "expirextime", "expiration_start", "expiretimetime", "expireztime", "expireptstart", "expire_Time", "expireThelock", "expiration_time", "exiryztime", "expirexdelay", "exiry_start", "expireptsequence", "expireUtime", "exiryUime", "exiryUno", "exiry_ime", "expirematno", "expireUime", "expirezsequence", "expireThestart", "exiry_time", "expire_start", "expire_no", "expirexTime", "expire_delay", "expirematime", "expire_lock", "exiry_lock", "exiryzlock", "expirepttime", "expiration_Time", "expiremattime", "expireUno", "expire_sequence", "exiryzstart", "expire_ime", "expireThetime", "expireptlock", "expiretimestart", "expirexcount", "exiryzsequence", "expireThesequence", "expire_count", "exiry_sequence", "expirezlock", "exiryUtime"]}}
{"project": "FFmpeg", "commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "target": 1, "func": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n\n                            int compressed_size, int uncompressed_size,\n\n                            EXRThreadData *td)\n\n{\n\n    unsigned long dest_len, expected_len = 0;\n\n    const uint8_t *in = td->tmp;\n\n    uint8_t *out;\n\n    int c, i, j;\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n\n            expected_len += (td->xsize * td->ysize * 2);\n\n        } else {//UINT 32\n\n            expected_len += (td->xsize * td->ysize * 4);\n\n        }\n\n    }\n\n\n\n    dest_len = expected_len;\n\n\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (dest_len != expected_len) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    out = td->uncompressed_data;\n\n    for (i = 0; i < td->ysize; i++)\n\n        for (c = 0; c < s->nb_channels; c++) {\n\n            EXRChannel *channel = &s->channels[c];\n\n            const uint8_t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22009, "substitutes": {"s": ["n", "comm", "t", "p", "sys", "is", "a", "sa", "r", "os", "set", "h", "m", "ss", "ns", "ims", "ses", "d", "ps", "cs", "sts", "e", "rs", "gs", "fs", "sports", "aws", "ds", "st", "sis", "sm", "south", "ctx", "spec", "ls", "ms", "sam", "sw", "sv", "ats", "hs", "self", "S", "js", "space", "g", "ins", "sq", "ts", "als", "sp", "sg", "qs", "less", "sb", "b", "l", "as", "v", "series"], "src": ["rect", "sys", "rb", "rc", "txt", "sel", "usr", "start", "r", "source", "init", "image", "dest", "stream", "impl", "rs", "str", "st", "sr", "img", "gin", "tmp", "ur", "sc", "addr", "ins", "inner", "trans", "sub", "sq", "rl", "bin", "sur", "input", "inst", "sb", "ser", "supp"], "compressed_size": ["compresseditywidth", "compendeditysize", "compressed_type", "compressed67type", "compended_size", "compressed_scale", "compendeditytype", "complied_name", "complied_Size", "compressedityscale", "compendedityscale", "compressed67size", "compressed_Size", "compendeditywidth", "complied_size", "compresseditysize", "compended_width", "complied_SIZE", "compressed67width", "compressed_SIZE", "compresseditytype", "compended_scale", "compressed_width", "compressed67scale", "compended_type", "compressed_name"], "uncompressed_size": ["uncompressededSize", "uncompressededtype", "uncomplated_Size", "uncomplated_type", "uncompressededtime", "uncomplated_time", "uncompressed_type", "uncomplated_size", "uncompressed_time", "uncompressededsize", "uncompressed_Size"], "td": ["gt", "t", "vd", "dh", "tt", "txt", "ht", "det", "dd", "ods", "dial", "desc", "dad", "tar", "sd", "dn", "table", "d", "th", "pt", "dt", "ld", "tk", "cd", "tap", "managed", "bd", "md", "dl", "ds", "hd", "tr", "cz", "them", "SD", "nd", "tif", "ent", "edd", "rt", "sam", "tmp", "dat", "cond", "db", "dem", "dev", "od", "ta", "ud", "ad", "ts", "nt", "fd", "std", "pb", "mont", "cmd", "tc", "dll", "TD", "pc", "tm", "elt", "pd", "pad", "ctl", "att", "tu", "tf", "xd", "vt"], "dest_len": ["Dest_len", "destityen", "destitylen", "dev_den", "destlylength", "dest_lit", "dest2length", " dest2len", "dest_length", "dest_lang", " dest2l", " dest2del", "Dest_ln", "dev_lang", "Dest_size", "destlydel", "dest2l", " dest_del", "dest_l", "dest_en", " dest_length", " dest2length", "current_len", "current_en", "dev_pos", "dest2len", "destitylit", "dest_del", "Dest_Len", "dev_len", "dest_den", " dest_l", "destlylen", "destlyl", "dest_pos", "dest2del", "dest_size", "dest_ln", "current_lit", "current_ln", "dest_Len", "destityln"], "in": ["n", "name", "t", "p", "en", "din", "is", "old", "r", "source", "o", "index", "ref", "f", "m", "rin", "id", "ind", "str", "data", "st", "IN", "raw", "gin", "tmp", "min", "inf", "up", "inc", "ins", "inner", "pin", "from", "inn", "bin", "In", "pos", "input", "file"], "out": ["n", "t", "p", "end", "it", "this", "OUT", "o", "set", "list", "output", "io", "outs", "window", "conv", "table", "image", "x", "ot", "array", "e", "data", "batch", "result", "op", "word", "Out", "ex", "tmp", "buffer", "new", "ch", "at", "nt", "ou", "pool", "u", "obj", "to", "b", "v", "file", "point", "chain", "w"], "c": ["n", "t", "p", "ic", "cat", "cont", "cb", "ce", "f", "dc", "m", "y", "co", "ac", "conv", "ct", "d", "count", "unc", "x", "con", "call", "cs", "cu", "bc", "cd", "cv", "uc", "ec", "col", "C", "k", "ex", "cor", "lc", "cm", "sc", "cf", "ch", "ci", "g", "ico", "at", "mc", "from", "cr", "tc", "cam", "cache", "b", "ca", "v", "fc", "l", "cp", "chain"], "i": ["is", "ic", "io", "m", "ims", " I", "im", "I", "ti", "cli", "ex", "ui", "point", "uri", "chain", "n", "name", "\u0438", "any", "si", "o", "me", "list", "ai", "ix", "ji", "x", "e", "sim", "ind", "gi", "info", "ami", "status", "oi", "at", "u", "remote", "b", "bi", "t", "phi", "it", "ri", "f", "xi", "y", "multi", "by", "zi", "ei", "qi", "ini", "ip", "li", "ia", "ci", "mi", "ii", "to", "pi", "l", "series", "ij", "p", "index", "di", "iu", "record", "h", "init", "ie", "ki", "q", "II"], "j": ["n", "ij", "aj", "jac", "p", "t", "it", "jit", "o", "r", "jl", "f", "m", "h", "ix", "y", "ji", "key", "bj", "x", "e", "bc", "jp", "z", "fr", "col", "jc", "k", "q", "br", "jump", "pr", "oj", "J", "ja", "js", "ch", "g", "try", "obj", "json", "kj", "uj", "mn", "b", "l", "v", "jj", "dj", "att"], "channel": ["all", "resource", "container", "chan", "column", "pixel", "panel", "color", "type", "attribute", "member", "conv", "table", "key", "board", "row", "Channel", "data", "category", "byte", "batch", "band", "ann", "connection", "col", "word", "cell", "chip", "video", "component", "buffer", "service", "ch", "feature", "config", "global", "chron", "cam", "can", "client", "course", "header", "chain"], "ptr": ["expr", "rect", "pert", "dep", "alloc", "index", "Ptr", "sec", "ref", "desc", "dq", "tp", "err", "offset", "rel", "ct", "iv", "prep", "pt", "loc", "inter", "arr", "embed", "code", "ind", "eps", "var", "ped", "cur", "tr", "proc", "coord", "tile", "fp", "fr", "buf", "deg", "br", "rt", "pr", "grad", "cond", "buffer", "addr", "adr", "iter", "dr", "prime", "inters", "js", "ts", "pend", "sp", "pc", "req", "cmd", "pos", "pre", "inst", "pointer", "pad", "bp", "dist", "ctl", "pointers", "vp", "ctr", "attr"]}}
{"project": "FFmpeg", "commit_id": "caa7a3914f499f74b3ee346f26d598ebdc0ec210", "target": 1, "func": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    int64_t total_size = 0;\n\n    MOVAtom a;\n\n    int i;\n\n\n\n    if (atom.size < 0)\n\n        atom.size = INT64_MAX;\n\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n\n        a.size = atom.size;\n\n        a.type=0;\n\n        if (atom.size >= 8) {\n\n            a.size = avio_rb32(pb);\n\n            a.type = avio_rl32(pb);\n\n            if (a.type == MKTAG('f','r','e','e') &&\n\n                a.size >= 8 &&\n\n                c->moov_retry) {\n\n                uint8_t buf[8];\n\n                uint32_t *type = (uint32_t *)buf + 1;\n\n                avio_read(pb, buf, 8);\n\n                avio_seek(pb, -8, SEEK_CUR);\n\n                if (*type == MKTAG('m','v','h','d') ||\n\n                    *type == MKTAG('c','m','o','v')) {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n\n                    a.type = MKTAG('m','o','o','v');\n\n                }\n\n            }\n\n            if (atom.type != MKTAG('r','o','o','t') &&\n\n                atom.type != MKTAG('m','o','o','v'))\n\n            {\n\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n\n                {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n\n                    avio_skip(pb, -8);\n\n                    return 0;\n\n                }\n\n            }\n\n            total_size += 8;\n\n            if (a.size == 1) { /* 64 bit extended size */\n\n                a.size = avio_rb64(pb) - 8;\n\n                total_size += 8;\n\n            }\n\n        }\n\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n\n        if (a.size == 0) {\n\n            a.size = atom.size - total_size + 8;\n\n        }\n\n        a.size -= 8;\n\n        if (a.size < 0)\n\n            break;\n\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n\n            if (mov_default_parse_table[i].type == a.type) {\n\n                parse = mov_default_parse_table[i].parse;\n\n                break;\n\n            }\n\n\n\n        // container is user data\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n\n                       atom.type == MKTAG('i','l','s','t')))\n\n            parse = mov_read_udta_string;\n\n\n\n        if (!parse) { /* skip leaf atoms data */\n\n            avio_skip(pb, a.size);\n\n        } else {\n\n            int64_t start_pos = avio_tell(pb);\n\n            int64_t left;\n\n            int err = parse(c, pb, a);\n\n            if (err < 0)\n\n                return err;\n\n            if (c->found_moov && c->found_mdat &&\n\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n\n                 start_pos + a.size == avio_size(pb))) {\n\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n\n                    c->next_root_atom = start_pos + a.size;\n\n                return 0;\n\n            }\n\n            left = a.size - avio_tell(pb) + start_pos;\n\n            if (left > 0) /* skip garbage at atom end */\n\n                avio_skip(pb, left);\n\n            else if (left < 0) {\n\n                av_log(c->fc, AV_LOG_WARNING,\n\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n\n                       (char*)&a.type, -left);\n\n                avio_seek(pb, left, SEEK_CUR);\n\n            }\n\n        }\n\n\n\n        total_size += a.size;\n\n    }\n\n\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n\n        avio_skip(pb, atom.size - total_size);\n\n\n\n    return 0;\n\n}\n", "idx": 22013, "substitutes": {"c": ["p", "t", "com", "rc", "ic", "vc", "cb", "ce", "cn", "f", "dc", "m", "h", "abc", "ac", "co", "gc", "ct", "call", "con", "cs", "e", "bc", "cu", "cd", "cv", "ec", "C", "ctx", "cod", "lc", "cm", "cf", "ci", "g", "anc", "mc", "pc", "cam", "tc", "conf", "cache", "cr", "cc", "b", "v", "fc", "l", "cp", "ca", "chain", "w"], "pb": ["td", "resp", "p", "sys", "rb", "eb", "cb", "BP", "tp", "prototype", "ob", "pkg", "bs", "pro", "pp", "lp", "uf", "mp", "wp", "pt", "tk", "apy", "erb", "cp", "pa", "PB", "fb", "jp", "snap", "asm", "proc", "ab", "ap", "ctx", "ub", "tmp", "wb", "dp", "db", "buffer", "px", "sc", "pan", "patch", "amp", "sp", "pc", "np", "tc", "pg", "emb", "apa", "ps", "client", "sb", "b", "bp", "bj", "vp", "tf", "bb"], "atom": ["msg", "orm", " o", "tg", "article", "app", "m", "om", "tar", "format", "top", " app", "unknown", "meta", " any", "xy", "no", "application", "alpha", "ANY", "tmp", "map", "term", "ym", " err", "atomic", "any", "binary", "canon", "x", "ator", " entry", "op", "cell", "num", " b", "entry", "some", "at", "ebin", "that", "cmd", "ace", " symb", "b", "att", " ans", "normal", "ether", " x", "abc", " exc", "operator", "abel", "other", "cer", "nt", "orb", "el", "attr", " orb", "mat", "p", "element", "ver", "window", "attribute", "item", "ob", "ata", "ext", "or", "het", "tab", "byte", "xml", "prop", " self", "unit", "http", "typ", "soc", "form", "phys", "news"], "a": ["another", "all", "am", "this", "app", "ack", "m", "oa", "la", "alpha", "ada", "aux", "as", "ba", "eas", "any", "access", "o", "x", "e", "aa", "ga", "part", "apache", "dev", "area", "at", "g", "ae", "era", "ace", "b", "att", "acc", "parent", "t", " ans", "sa", "act", "ar", "xa", "ao", "ab", "AA", "A", "ia", "and", "ta", "ma", "ca", "l", "el", "aq", "p", " ta", "aaa", "attribute", "ac", "al", "sta", "aka", "ata", "na", "ea", "test", "admin", "j", "ap", "au", "an", "apa"], "i": ["n", "p", "t", "it", "f", "m", " m", "x", " ii", "e", " ti", "I", "j", "z", "ia", " bi", "ci", " j", " v", "iat", "ii", " p", "pi", "b", "v", " e"], "parse": ["arse", "pack", "alloc", "func", "ack", "parser", "read", "init", "conv", "format", "gc", "aw", "pair", "unc", "info", "cmp", "fp", "raw", "P", "send", "util", "np", "json", "can", "cast", "bp", "cp"], "type": ["ype", "pack", "message", "role", "kind", "source", "desc", "length", "value", "format", "count", "dt", "timeout", "close", "no", "batch", "pe", "types", "action", "sche", "port", "file", "name", "state", "start", "comment", "group", "title", "info", "data", "size", "category", "status", "link", "part", "sequence", "template", "t", "scope", "time", "Type", "tag", "color", "ping", "null", "hash", "rank", "post", "description", "style", "weight", "var", "spec", "buffer", "shape", "try", "ty", "cache", "ver", "set", "index", "check", "member", "offset", "TYPE", "key", "id", "code", "test", "byte", "get", "version", "lock", "result", "speed", "unit", "error", "typ", "block", "tree", "not", "class"], "buf": ["cap", "end", "out", "rb", "pack", "alloc", "cb", "ref", "off", "length", "err", "offset", "read", "Buff", "count", "mb", "arr", "text", "uf", "code", "bar", "Buffer", "cv", "str", "data", "max", "bytes", "byte", "vec", "cur", "batch", "limit", "result", "ff", "ctx", "raw", "ptr", "br", "xff", "tmp", "queue", "buffer", "iter", "new", "buff", "cmd", "bin", "pos", "len", "next", "b", "bp"]}}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 22016, "substitutes": {"ad": ["aud", "ard", "end", "a", "dd", "ade", "ack", "arp", "add", "ax", "ac", "al", "ay", "d", "post", "rad", "adi", "id", "ld", "conn", "ind", "admin", "md", "ass", "ann", "ab", "ada", "pod", "AD", "ag", "db", "adj", "addr", "adr", "od", "and", "ud", "doc", "adv", "Ad", "wd", "play", "ads", "ace", "quad", "mod", "an", "pad", "att", "art"], "sglist": ["sglists", " sglists", "sblIST", "sblists", "sblist", " sgnalist", "sgzalist", "sgnists", "sgzIST", " sgnist", "sgnIST", " sglalist", " sglIST", "sgzists", "sblalist", "sglalist", "sgnalist", "sgnist", " sgnists", "sgzist", "sglIST", " sgnIST"], "cmd": ["comm", "build", "msg", "quit", "det", "cont", "cb", "kind", "check", "Cmd", "exec", "init", "act", "ct", "pkg", "call", "def", "ctrl", "conn", "news", "cd", "args", "c", "md", "cmp", "cli", "batch", "op", "cod", "ctx", "raw", "bind", "send", "auth", "map", "help", "ch", "kick", "range", "command", "req", "conf", "obj", "crit", "ctl", "cp", "cfg", "ctr"], "limit": ["origin", "cap", "end", "clip", "capacity", "alloc", "amount", "commit", "filter", "margin", "tail", "skip", "lim", "base", "lock", "maximum", "buffer", "page", "iter", "Limit", "bound", "range", "block", "pool", "limited", "slice", "limits"], "offset": ["offs", "end", "start", "alloc", "o", "amount", "Offset", "index", "set", "off", "sum", "length", "head", "top", "skip", "timeout", "attr", "row", "slot", "reset", "size", "base", "shift", "align", "ptr", "position", "seek", "entry", "buffer", "addr", "location", "scroll", "error", "sp", "range", "block", "address", "pos", "len", "next", "pointer", "slice", "pad", "origin", "point", "padding"], "prdt": ["sprdat", "Prmt", "PRtk", "Prdt", "propdt", "predtf", "preddl", "prmt", "prbd", "psmt", "prnot", " prdl", "preddt", "sprdt", "proptf", "sprbd", "PRdl", " prdat", "trbd", "trdat", "pstk", "PRmt", " prbd", "prdl", "trdl", "propnot", "psdt", "prtk", "prednot", "prdat", "sprdl", "trdt", " prtf", "Prdl", "propdl", "Prtk", " prnot", "psdl", "PRdt", "prtf"], "i": ["n", "bi", "ori", "p", "t", "phi", "\u0438", "ic", "it", "a", "ri", "r", "si", "index", "di", "me", "iu", " x", " pos", "xi", "m", "ix", "ai", "y", "ims", "f", "multi", " m", "item", "im", "zi", "ei", "ie", " index", "x", " ii", "e", "sim", "ind", "gi", "info", "I", "c", "qi", "ki", "ini", "j", "ip", "ti", "cli", "li", "k", "ui", " bi", "o", "oi", "ci", " j", " v", "mi", "u", "ii", "pi", "l", "v", "hi", "yi"], "tbl_entry_size": ["tbl_row_size", "tbl_Entry_sum", "tbl_entry_space", "tbl_entry_Size", "tbl_entry___size", "tbl_entry_index", "tbl_ry_size", "tbl_ry_SIZE", "tbl_entry_SIZE", "tbl_Entry_index", "tbl_ry_space", "tbl_entry_sum", "tbl_row_sum", "tbl_entry___index", "tbl_entry___Size", "tbl_Entry_size", "tbl_row_SIZE", "tbl_Entry_Size"], "bus": ["loop", "state", "proxy", "way", "vc", "bolt", "os", "boot", "gate", "device", "us", "card", "driver", "bs", "board", "Bus", "mount", "host", "handle", "base", "hand", "pod", "buf", "lock", "bind", "BUS", "book", "dev", "box", "cf", "config", "interface", "pos", "port", "b", "bug", "cc", "bid", "chain", "alias"], "qbus": ["qstate", " qstate", " qBus", "dqBus", "QBUS", "qBUS", "Qbus", "dqBUS", "qBus", "QBus", "Qstate", "dqstate", " qBUS", "dqbus"], "tbl": ["tbr", "tpl", " tBL", "nll", "pbl", "TBl", " tpl", " tbr", "tll", " tll", "bll", "Tpl", "nbl", "bBL", " tBl", "nBL", "tBl", "bbr", "Tbl", "pBl", "bbl", "ppl", "tBL", "nbr"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void dwt_encode97_int(DWTContext *s, int *t)\n\n{\n\n    int lev,\n\n        w = s->linelen[s->ndeclevels-1][0];\n\n    int *line = s->i_linebuf;\n\n    line += 5;\n\n\n\n    for (lev = s->ndeclevels-1; lev >= 0; lev--){\n\n        int lh = s->linelen[lev][0],\n\n            lv = s->linelen[lev][1],\n\n            mh = s->mod[lev][0],\n\n            mv = s->mod[lev][1],\n\n            lp;\n\n        int *l;\n\n\n\n        // VER_SD\n\n        l = line + mv;\n\n        for (lp = 0; lp < lh; lp++) {\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lv; i++)\n\n                l[i] = t[w*i + lp];\n\n\n\n            sd_1d97_int(line, mv, mv + lv);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n        // HOR_SD\n\n        l = line + mh;\n\n        for (lp = 0; lp < lv; lp++){\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lh; i++)\n\n                l[i] = t[w*lp + i];\n\n\n\n            sd_1d97_int(line, mh, mh + lh);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n    }\n\n}\n", "idx": 22034, "substitutes": {"s": ["n", "ties", "comm", "p", "is", "re", "bits", "rates", "a", "r", "os", "parts", "f", "ows", "h", "m", "ns", "ims", "ss", "ses", "irs", "conv", "stats", "d", "bs", "ps", "ops", "eps", "cs", "e", "sts", "rs", "gs", "times", "c", "fs", "ds", "bis", "se", "details", "ex", "sv", "sw", "ats", "vs", "hs", "S", "js", "g", "es", "ins", "sq", "ts", "als", "its", "aus", "xs", "sg", "qs", "less", "sb", "an", "b", "as", "v", "w"], "t": ["n", "td", "mat", "p", "all", "tt", "out", "txt", "it", "et", "r", "o", "xt", "tg", "te", "f", "m", "tp", "y", "qt", "table", "ct", "total", "pt", "ot", "dt", "tk", "trace", "target", "tl", "c", "st", "lt", "tr", "mt", "T", "ent", "rt", "ta", "at", "g", "ts", "nt", "bt", "tree", "tc", "wt", "ll", "to", "b", "v", "tu", "tf", "w"], "lev": ["lig", "lif", "gent", "ele", "leg", "Lev", "lvl", " elev", "depth", "vl", "vel", "ger", " lvl", "lem", "bal", "lu", "wid", "ie", "val", "pl", "loc", "lay", "ld", "weight", "eg", "level", "ind", "liv", "den", "vec", "le", "ell", "lo", "hend", "camp", "coord", "lim", "lex", "xp", "compl", "pol", "rog", "tile", "deg", "wl", "cell", "rax", "cod", "ble", "lin", "hl", "lc", "dem", "vals", "ded", "iter", "dr", "rep", "water", "league", "len", "gew", "ged", "elt", "v", "el", "vp", "lv", "lag", "ev", "serv"], "line": ["out", "frame", "o", "set", "ide", "go", "change", "call", "lay", "Line", "code", "online", "level", "lane", "row", "node", "byte", "limit", "le", "lo", "eline", "handle", "se", "lock", "fr", "LINE", "li", "mode", "link", "net", "ine", "lin", "position", "lines", "pe", "lc", "entry", "home", "edge", "rule", "page", "liner", "iter", "try", "ln", "path", "range", "block", "nl", "len", "store", "ne", "lf", "port", "file", "lv", "point", "w"], "lp": ["ij", "p", "oji", "lr", "msg", "lit", "pert", "lbs", "lvl", "sie", "jl", "bsp", "iu", "tp", "lu", "bps", "ml", "pkg", "ps", "pl", "lb", "pp", "loc", "wp", "lan", "phal", "isi", "yp", "cp", "php", "pa", "dl", "pers", "lt", "jp", "kl", "tf", "lang", "xp", "fp", "abl", "li", "ls", "pn", "pr", "lik", "hl", "lc", "LP", "ijk", "sp", "rl", "pb", "pc", "np", "sg", "lis", "len", "ll", "lf", "elt", "pi", "bp", "lip", "gp", "vp", "lv", "lag", "isp", "pd"], "l": ["n", "p", "lr", "lit", "o", "list", "m", "h", "al", "ul", "ml", "pl", "lb", "loc", "il", "ld", "tl", "c", "dl", "lt", "le", "ell", "lo", "la", "lock", "li", "ls", "wl", "lib", "lin", "hl", "lc", "g", "ln", "rl", "fl", "w", "nl", "ol", "lis", "ll", "b", "v", "el", "lv", "sl", "L"], "i": ["is", "ic", "this", "ski", "io", "ims", "ati", "im", "I", "jp", "ti", "cli", "asi", "ui", "ani", "v", "uri", "\u0438", "si", "me", "ai", "ix", "ji", "pp", "x", "ind", "sim", "il", "gi", "info", "ami", "ite", "oi", "at", "ik", "pc", "u", "hi", "bi", "phi", "it", "ri", "xi", "y", "multi", "zi", "ei", "iri", "isi", "ili", "ni", "qi", "ini", "ip", "li", "ia", "ici", "in", "ci", "mi", "ii", "pi", "ori", "ij", "p", "di", "iu", "init", "ie", "iy", "id", "ki", "iii", "iter", "bp"], "j": ["n", "ij", "bi", "aj", "jac", "p", "out", "it", "jit", "r", "jl", "di", "si", "io", "ix", "y", "ji", "init", "im", "ie", "bs", "pt", "note", "user", "gi", "str", "ni", "bis", "jp", "bot", "status", "z", "fr", "jc", "li", "bo", "br", "oj", "J", "jump", "pr", "q", "ja", "ju", "adj", "jas", "js", "try", "jo", "ijk", "sp", "job", "tree", "obj", "json", "uj", "kj", "next", "je", "jj", "v", "bj", "dj"]}}
{"project": "FFmpeg", "commit_id": "0424e052f83adc422d8a746e3cdc5ab6bc28679e", "target": 1, "func": "static void decode_postinit(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture *out = s->current_picture_ptr;\n\n    Picture *cur = s->current_picture_ptr;\n\n    int i, pics, out_of_order, out_idx;\n\n\n\n    s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_H264;\n\n    s->current_picture_ptr->pict_type= s->pict_type;\n\n\n\n    if (h->next_output_pic) return;\n\n\n\n    if (cur->field_poc[0]==INT_MAX || cur->field_poc[1]==INT_MAX) {\n\n        //FIXME this allows the next thread to start once we encounter the first field of a PAFF packet\n\n        //This works if the next packet contains the second field. It does not work if both fields are\n\n        //in the same packet.\n\n        //ff_thread_finish_setup(s->avctx);\n\n        return;\n\n    }\n\n\n\n    cur->interlaced_frame = 0;\n\n    cur->repeat_pict = 0;\n\n\n\n    /* Signal interlacing information externally. */\n\n    /* Prioritize picture timing SEI information over used decoding process if it exists. */\n\n\n\n    if(h->sps.pic_struct_present_flag){\n\n        switch (h->sei_pic_struct)\n\n        {\n\n        case SEI_PIC_STRUCT_FRAME:\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_FIELD:\n\n        case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n            cur->interlaced_frame = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n            if (FIELD_OR_MBAFF_PICTURE)\n\n                cur->interlaced_frame = 1;\n\n            else\n\n                // try to flag soft telecine progressive\n\n                cur->interlaced_frame = h->prev_interlaced_frame;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n            // Signal the possibility of telecined film externally (pic_struct 5,6)\n\n            // From these hints, let the applications decide if they apply deinterlacing.\n\n            cur->repeat_pict = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n            // Force progressive here, as doubling interlaced frame is a bad idea.\n\n            cur->repeat_pict = 2;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n            cur->repeat_pict = 4;\n\n            break;\n\n        }\n\n\n\n        if ((h->sei_ct_type & 3) && h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n\n            cur->interlaced_frame = (h->sei_ct_type & (1<<1)) != 0;\n\n    }else{\n\n        /* Derive interlacing flag from used decoding process. */\n\n        cur->interlaced_frame = FIELD_OR_MBAFF_PICTURE;\n\n    }\n\n    h->prev_interlaced_frame = cur->interlaced_frame;\n\n\n\n    if (cur->field_poc[0] != cur->field_poc[1]){\n\n        /* Derive top_field_first from field pocs. */\n\n        cur->top_field_first = cur->field_poc[0] < cur->field_poc[1];\n\n    }else{\n\n        if(cur->interlaced_frame || h->sps.pic_struct_present_flag){\n\n            /* Use picture timing SEI information. Even if it is a information of a past frame, better than nothing. */\n\n            if(h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM\n\n              || h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n\n                cur->top_field_first = 1;\n\n            else\n\n                cur->top_field_first = 0;\n\n        }else{\n\n            /* Most likely progressive */\n\n            cur->top_field_first = 0;\n\n        }\n\n    }\n\n\n\n    //FIXME do something with unavailable reference frames\n\n\n\n    /* Sort B-frames into display order */\n\n\n\n    if(h->sps.bitstream_restriction_flag\n\n       && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n        s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n        s->low_delay = 0;\n\n    }\n\n\n\n    if(   s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT\n\n       && !h->sps.bitstream_restriction_flag){\n\n        s->avctx->has_b_frames= MAX_DELAYED_PIC_COUNT;\n\n        s->low_delay= 0;\n\n    }\n\n\n\n    pics = 0;\n\n    while(h->delayed_pic[pics]) pics++;\n\n\n\n    assert(pics <= MAX_DELAYED_PIC_COUNT);\n\n\n\n    h->delayed_pic[pics++] = cur;\n\n    if(cur->reference == 0)\n\n        cur->reference = DELAYED_PIC_REF;\n\n\n\n    out = h->delayed_pic[0];\n\n    out_idx = 0;\n\n    for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame && !h->delayed_pic[i]->mmco_reset; i++)\n\n        if(h->delayed_pic[i]->poc < out->poc){\n\n            out = h->delayed_pic[i];\n\n            out_idx = i;\n\n        }\n\n    if(s->avctx->has_b_frames == 0 && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset))\n\n        h->next_outputed_poc= INT_MIN;\n\n    out_of_order = out->poc < h->next_outputed_poc;\n\n\n\n    if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)\n\n        { }\n\n    else if((out_of_order && pics-1 == s->avctx->has_b_frames && s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT)\n\n       || (s->low_delay &&\n\n        ((h->next_outputed_poc != INT_MIN && out->poc > h->next_outputed_poc + 2)\n\n         || cur->pict_type == AV_PICTURE_TYPE_B)))\n\n    {\n\n        s->low_delay = 0;\n\n        s->avctx->has_b_frames++;\n\n    }\n\n\n\n    if(out_of_order || pics > s->avctx->has_b_frames){\n\n        out->reference &= ~DELAYED_PIC_REF;\n\n        out->owner2 = s; // for frame threading, the owner must be the second field's thread\n\n                         // or else the first thread can release the picture and reuse it unsafely\n\n        for(i=out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i+1];\n\n    }\n\n    if(!out_of_order && pics > s->avctx->has_b_frames){\n\n        h->next_output_pic = out;\n\n        if(out_idx==0 && h->delayed_pic[0] && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset)) {\n\n            h->next_outputed_poc = INT_MIN;\n\n        } else\n\n            h->next_outputed_poc = out->poc;\n\n    }else{\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"no picture\\n\");\n\n    }\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n}\n", "idx": 22037, "substitutes": {"h": ["comm", "history", "p", "dh", "ht", "he", "zh", "eh", "hh", "o", "ach", "hal", "r", "H", "oh", "m", "hash", "th", "x", "info", "c", "host", "handle", "hd", "hw", "ih", "his", "k", "bh", "hz", "here", "sh", "ph", "kh", "rh", "hs", "hm", "hl", "hp", "self", "her", "ch", "http", "ah", "b", "l", "v", "hi", "w"], "s": ["n", " inputs", "t", "p", "is", "sys", "a", "os", "css", "m", "ss", "ns", "session", "ses", " ts", "conv", "stats", "th", "ps", "bs", "cs", "e", "fs", "gs", "sts", "rs", "c", "ds", "j", "sections", "sm", "ls", "his", "ms", "sv", "sh", "sw", "ats", "hs", "self", "S", "js", "ess", "g", "wcs", "its", "sq", "ts", "sp", "http", "ch", "w", "less", "sb", "b", "as", "v", "l", "sl", "serv"], "out": ["n", "t", "p", "sys", "OUT", "o", "os", "output", "m", "outs", "co", "ot", "gs", "c", "img", "op", "Out", "tmp", "res", "in", "new", "g", "conf", "w", "obj", "v", "serv"], "cur": ["ret", "cont", "desc", "err", "loc", "con", "close", "car", "col", "now", "tmp", "res", "qu", "gr", "cr", "ser", "coll", "kw", "cat", "comment", "conv", "copy", "cmp", " Cur", "ph", "sc", "dr", "cmd", "cp", "public", "r", "dc", "co", "gc", "cu", "pri", "cv", "str", "c", "ptr", "try", "ocr", "Cur", "nt", "req", "pg", "conf", "cache", "obj", "sur", "nc", "serv", "er", "lr", "rc", "usr", "ver", "etc", "current", "fac", "ctrl", "row", "tr", "keep", "result", "cor", "ur", "ch", "ah", "rec", "ctr"], "i": ["ori", "p", "is", " li", "it", "si", "o", "r", "io", "ai", "f", "ati", "x", "id", "e", " ii", "info", " ti", "I", "ti", "j", "ip", "li", " bi", "ci", "ii", " mi", "l"], "pics": ["npicks", "pik", "Pics", "npik", "Pic", "picks", " pik", " pic", "Pik", "npics", " picks", "npic", "Picks", "pic"], "out_of_order": ["out_OF_orders", "out_of_orders", "out_of_frame", "out_of_sequence", "out_OF_order", "out_OF_frame", "out_OF_sequence"], "out_idx": ["out_IdX", "out_midxs", "out_midX", "out_midxc", "out_midx", "out_Idx", "out_idxs", "out_idX", "out_Idxs", "out_Idxc", "out_idxc"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047, "substitutes": {"dst_errp": ["dst_errm", "dst_errpa", "dst_rrp", "dst_errps", "dst_arrP", "dst_errorm", "dst_statep", "dst_arrm", "dst_errorP", "dst__errP", "dst_rrpa", "dst_arrpa", "dst_rrP", "dst_errorp", "dst_erps", "dst_stater", "dst_stateP", "dst_arrps", "dst_errd", "dst_errP", "dst_erP", "dst_stated", "dst_rp", "dst_errorps", "dst_rrps", "dst_errr", "dst_rps", "dst_erp", "dst_err", "dst__errps", "dst_errorpa", "dst_rP", "dst_arrp", "dst__errp", "dst_erd", "dst_erpa", "dst_erm"], "local_err": ["localitypriv", "localityerr", " local_any", " local_rr", "local_priv", "localmyer", " local_cfg", "local__rr", "localityer", "loc_msg", "localmycmd", "local_cfg", "local__error", " local_er", "local_error", "local__msg", "local_cb", "localmyerr", " local_cmd", "localitycmd", " local_priv", "loc_er", "loc_err", "local___error", "local_rr", "local___er", "local___err", "local_msg", " local_notice", "local_cmd", "localmypriv", "local___msg", "local_any", " local_error", "local_notice", "local__er", " local_msg", "loc_cb", "local__err", "local_er"]}}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "substitutes": {"ret": ["expr", "valid", "re", "rc", "final", "rev", "ref", "rets", "Ret", "read", "eval", "val", "arr", "test", "cur", "result", "cell", "res", "alt", "buffer", "reg", "iter", "mem", "RET", "store", "flag"], "TCGv": ["ACGf", "TCGej", "TCHAv", "ACGv", "TCGPlu", "TCGef", "tcGw", "TCGc", "TCGDv", "TCGmax", "TCGPnv", "TCGItv", "ACGnv", "TCGregqv", "TCGj", "TCGAw", "TCGf", "TEGget", "TCGPw", "TCGAv", "tcGv", "TFGPj", "TCGarqv", "TEGc", "TCGUmax", "TCGraphlu", "TCGelu", "TCGregv", "ACGUnv", "TCGraphj", "ACGvs", "TCGAvs", "TPGUv", "TCGIv", "TCGPqv", "TCGraphf", "TPGUnv", "TCGlu", "TCLGvs", "TCGPvs", "TFGlu", "TCGregq", "WCGq", "TCGUtv", "TCGqv", "TCGarvs", "TPGtv", "TCGvi", "TFGj", "TCGPmax", "TEGUmax", "TCGve", "TCGUqv", "TCGnv", "TPGvi", "TPGGve", "WCGqv", "TPGGvs", "TCGregvar", "TEGUget", "TPGve", "TCGw", "TCGGvs", "TCGvs", "tcGPvs", "TCGPf", "TCGGv", "tcGPf", "TCHAmax", "WCGUv", "WCGUq", "TCGDnv", "TEGmax", "TCGAf", "TCGarv", "TCGUc", "TEGUc", "TCLGv", "TCGPc", "TCGPget", "TCGUf", "TCGDvi", "ACGUf", "TCGarw", "TCGDtv", "tcGPw", "TFGf", "TCGPve", "TCGPv", "TFGPv", "TCGPj", "TPGGv", "TCGUnv", "TCGvar", "tcGf", "TPGUvi", "TPGv", "TCHAc", "TCGev", "ACGUvs", "TFGPf", "TCGUget", "WCGv", "TPGqv", "TCGq", "TCGIvi", "TPGUtv", "TCGget", "TCGUq", "TPGGqv", "TCGtv", "TFGPlu", "TFGv", "TCGUvar", "TCGInv", "tcGPv", "TCGarvar", "TCHAget", "tcGvs", "TEGUv", "TPGvs", "TCGraphv", "TCGGve", "ACGUv", "TCGUvs", "WCGvar", "WCGUqv", "TCGarf", "TPGnv", "TCGUvi", "TCGarq", "TEGv", "TCGUve", "TCLGf", "TCGUv", "TCLGnv", "WCGUvar", "TCGGqv"], "uint32_t": ["uint256_l", "uint256_m", "uint32_n", "uint256_t", "uint256_p", "uint256_n", "uint32_l", "uint32_m", "uint32_p"]}}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 22065, "substitutes": {"STATUS_PARAM": ["STATUS_ParAM", "STATUS_ParAR", "STATUS_TAR", "STATUS_ParAMS", "STATUS_PARAMS", "STATUS_VAMS", "STATUS_VAR", "STATUS_TAM", "STATUS_TAMS", "STATUS_PARAR", "STATUS_ParV", "STATUS_VV", "STATUS_PARV", "STATUS_VAM", "STATUS_TV"], "aSign": ["aoIncre", "aDesign", "asDesign", " aForm", "aLog", " aForce", "saMask", "aPos", "aIncre", "aNeg", "asNeg", "ASign", "anSign", "paIdent", "aoSign", "saForm", "aaIdent", "asLog", " aPos", "aoForce", "aasign", "aSIGN", " aIncre", "acSign", "acSIGN", "asSIGN", " asign", "saNeg", " aSIGN", "aSc", "paSIGN", "acLog", "saDesign", "aForce", "ASIGN", "anIncre", "anPos", "sasign", "aaSign", "saSc", "cacheNeg", "aaSc", "aForm", "anForce", " aLog", "cacheMask", "aaSIGN", "cacheSign", "asign", "asSign", "AForm", "saSign", "aIdent", " aIdent", " aSc", "aMask", "paSign", "aoPos", "saSIGN", "Asign", "cacheDesign", "asMask"], "aExp": ["asReg", "aoIncre", "amEv", "aaExt", " aExpress", "aoExpress", "saExp", "amAg", " aEv", " aAg", " aRest", "eExt", "aaaExpress", " aExt", "amReg", "asExp", "akaEv", "asProp", "saSec", "arLog", "anReg", "aaaExt", "alphaExp", "aAg", "akaReg", "saReg", "aComp", "akaExp", "arEXP", "oaProp", "asEXP", " aSec", "aaaExp", "aoExp", "alphaIncre", "aaComp", "aExpress", "aaEXP", "aaEv", " aEXP", "amExp", "aProp", "areaExt", "aLog", " aComp", " aReg", "aaaIncre", "aIncre", "aReg", "oaExp", "aaLog", "alphaExpress", "xaExp", "aaExp", "eExp", "areaExp", "aSec", "aEx", "anExp", "xaEXP", "eEx", "arExpress", "aEXP", "areaEv", "areaComp", "eEXP", "arExp", "anEXP", "aExt", "saRest", "aEv", "aoExt", "anRest", "akaAg", "aRest", " aLog", "anProp", "aaEx", "oaReg", "xaEx", "alphaExt", "xaExt", "oaEXP", "anSec", "aaExpress"], "shiftCount": ["hiftType", "offsetCount", "hiftLength", "switchLength", "hiftSize", "pushSize", " shiftType", "offsetCode", " shiftSize", "ShiftCounter", "hiftCount", "pushCount", "offsetSize", "shiftCode", "shiftFlag", "ShiftCount", " shiftCounter", "shiftCondition", "ShiftFlag", "shiftcount", "shiftCounter", "hiftFlag", "shiftLength", "hiftcount", " shiftFlag", "hiftCondition", "pushType", " shiftcount", "hiftCode", "shiftSize", " shiftLength", "offsetCondition", "Shiftcount", "switchCount", " shiftCode", " shiftCondition", "pushcount", "hiftCounter", "shiftType"], "aSig": ["waSigs", "vaSSic", "aaSiger", "aSourceiger", "aDsiger", "aTIG", "vaSiger", "aSysiger", "asig", " aSigs", "aPsig", "saAsign", "aSSic", "aPosig", "aSignIG", "aAsess", "vaSSign", "aSigh", "aSysig", "aCSig", "asiger", "aSeg", "aSSig", " aAssigh", "aSigned", "aASigs", "aAssign", "aaSigma", "aPsIG", "aSess", "waSig", "aAssigned", "saAsigs", "aASig", "aPosiger", "saAsess", "aAsic", "aPosigs", "aSIG", " aSIG", "aAsign", "aAsig", "aAsiger", "aaSigned", "aDesig", "aAssig", "aASigh", "aSetock", "aSature", "aaAssigma", "aPosign", "vaSSig", "aSigniger", "aTigma", "asigs", " aAssig", "waSock", "waSourceig", "aaSg", "aBSig", "aaAssig", "vaSign", "aSignig", " aSigneg", "aTigned", "aSetigs", "aSSign", "aAssIG", "saSigs", "aDsIG", "aDsigma", "aaSig", "aAsigs", "aSigma", "aSignigs", "aCSigh", "aCSuff", "aPsature", "aAssigma", "vaSSiger", "waSiger", " aSigh", "aSg", "aSock", "aSiger", "aDsigned", "saAsig", "aAsIG", "asIG", "saSess", " aAssigs", " aSeg", "aBSg", "aAssigs", "aaSign", "vaSig", "aAssuff", "aSuff", "aASuff", "saSign", "aBSiger", "aSignock", "aPosess", "aDeseg", "aDsg", "aSourceig", "waSourceigs", " aSiger", "vaSic", " aSignig", " aSuff", "aaAssigned", "aPosIG", "aaAssIG", "aSic", " aSignIG", "aSourceock", "aSourceigs", " aSignature", "aSetiger", "aSigs", "aSysic", "aaSIG", "aDsign", "aAsature", "waSourceock", " aAssuff", "saSig", " aSature", "aSysign", "aSignature", "aSigneg", "aSSiger", "waSourceiger", "aAssigh", "aBSign", "aTig", "aCSigs", "aDesature", "aDsig", "aSetig", "aAssess"], "savedASig": ["savedFSig", "savedPSib", "saveAsig", "savedPSig", "saveAseg", "savedACick", "savedASick", "savesASIG", "savedACeg", "savedACig", "savedAsib", "savedASock", "savedASigs", "savedAseg", "savedFSeg", "savedSick", "savedASib", "savedACock", "savesBSick", "savedFSigs", "savedPSigs", "saveAsib", "savedASIG", "savedAsigs", "savedPSeg", "saveASigs", "savedFSib", "savedAsig", "savesASock", "saveASig", "savedBSig", "savesBSig", "savedSIG", "savesASig", "savedBSIG", "saveASeg", "savedSock", "saveASib", "savedBSock", "savedAsIG", "savedSig", "savedBSeg", "savedASeg", "savedBSick", "savesASick", "savesBSock", "saveAsigs", "savesBSIG", "savedACIG"], "z": ["n", "t", "zip", "p", "rez", "it", "zh", "o", "zo", "f", "zag", "h", "m", "zone", "y", "ze", " az", "gz", "d", "zi", "count", "tz", "nz", "oz", "x", "i", "ez", "az", "str", "c", "s", "j", "uz", "shift", "q", "hz", "Z", "iz", "sc", "g", "zer", "yz", "zero", "sign", "u", "w", "iaz", "b", "l", "v", "zen", "cz"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 22082, "substitutes": {"bs_queue": ["blesPqueue", "bs_buf", "js_entry", "bsuchspace", "bs__que", "js_ue", "bs_ue", "bs_client", "bsuchdq", "bs__queue", "bs_buffer", "blesPspace", "ns_entry", "ns_client", "BS_buf", "js_queue", "BS_queue", "bsuchque", "bsPdq", "bs_dq", "lbs_que", "bles_dq", "bs_que", "bles_que", "bsPqueue", "bs___component", "bles_space", "lbs_ue", "bs_space", "lbs_q", "BS_entry", "bs___entry", "bs__buffer", "bles_queue", "abs_entry", "abs_queue", "bs___queue", "ns_queue", "bs_component", "vs_ue", "bsPque", "bsuchqueue", "bs_master", "bsPspace", "bs_q", "bs__ue", "vs_buffer", "vs_queue", "lbs_queue", "vs_que", "bs___master", "abs_master", "js_que", "blesPdq", "ns_que", "BS_que", "abs_component", "blesPque"], "bs": ["bi", "boxes", "sys", "lbs", "ics", "bits", "ks", "aps", "os", "cb", "css", "ubs", "bed", "ns", "bps", "BS", "ss", "ses", "aos", "outs", "bl", "stats", "ps", "lb", "bus", "bridge", "cs", "bc", "sts", "fs", "aws", "bn", "gs", "ds", "bis", "ls", "bh", "hz", "ms", "vs", "ats", "vals", "bes", "js", "xs", "its", "ts", "fts", "als", "obs", "pb", "acs", "qs", "sb", "bos", "bas", "b", "bp", "browser", "bid", "uts", "bb"], "flags": ["issues", " Flags", "ports", "bits", "heads", "settings", "func", "aps", "weights", "parts", "tags", "acts", "amps", "orts", "outs", "stats", "ints", "ps", "FLAG", "ops", "terms", "mask", "cs", "comments", "args", "s", "locks", "states", "atts", "items", "sets", "utils", "ats", "tools", "properties", "types", "vals", "levels", "uts", "pins", "posts", "ts", "ants", "fts", "Flags", "features", "ags", "acs", "options", "fps", "actions", "members", "flag", "ensions", "lag", "cons", "fields"], "bs_entry": ["bn_entry", "blog__entry", "obs_member", "bs_member", "obs_entity", "bnMry", "bn_ry", "bs_entity", "bsMent", "bsMry", "bs_ent", "ts_entry", "bsMvalue", "bs__queue", "blog__system", "bsMchild", "bed_archive", "bs_Entry", "bed_ent", "obs_entry", "bs__channel", "bsMentity", "bnMentry", "bn_child", "obs_next", "bs_channel", "bs_system", "bnMchild", "blog_channel", "blog__channel", "bs__system", "bs__entry", "bn_entity", "bs_ry", "ts_queue", "bnMentity", "bsMarchive", "blog_entry", "blog_system", "blog_ry", "bed_entry", "blog__ry", "bsMsystem", "bs_next", "bs__Entry", "bs_value", "bsMchannel", "bsMentry", "bed_value", "bs__ry", "bs_archive", "bs_child", "ts_ry", "ts_Entry"]}}
{"project": "FFmpeg", "commit_id": "808c10e728db2d92ccbb0f8b3bcd4a2f4305a2cf", "target": 0, "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        AVBPrint part[3], int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    av_bprint_init(part+0, 0, 1);\n\n    av_bprint_init(part+1, 0, 1);\n\n    av_bprint_init(part+2, 0, 65536);\n\n\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                av_bprintf(part+0, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(parent);\n\n            }\n\n        }\n\n        av_bprintf(part+1, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    av_vbprintf(part+2, fmt, vl);\n\n\n\n    if(*part[0].str || *part[1].str || *part[2].str) {\n\n        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;\n\n        *print_prefix = lastc == '\\n' || lastc == '\\r';\n\n    }\n\n}\n", "idx": 22086, "substitutes": {"ptr": ["td", "resp", "p", "rect", "t", "pert", "txt", "alloc", "r", "xt", "cont", "Ptr", "ref", "desc", "ts", "tp", "err", "offset", "tip", "vr", "src", " pointer", "ps", "pt", "inter", "pl", "arr", "ipt", "pair", "loc", "eth", "peer", "handle", "cur", "tr", "snap", "proc", "hw", "fp", "mt", "checked", "fr", "ctx", "br", "pr", "hl", "tor", "buffer", "addr", "iter", "dr", "inters", "sp", "rep", "esp", "pc", "typ", "address", "np", "obj", "nt", "req", "pointer", "port", "pad", "pointers", "vp", "point", "ctr", "attr", "vt"], "level": ["tag", "lvl", "depth", "color", "vel", " lvl", "scale", "debug", "format", "loc", "style", "code", "Level", "ity", "le", "mode", "link", "lc", "levels", "unit", "ln", "fl", "priority", "pos", "line", "flag", "local", "layer"], "fmt": ["infmt", "infMT", "cmt", "clt", "fMT", "vmat", "vmt", " fmat", " fformat", "Fmt", "infmat", "Flt", "cformat", " flt", "cprintf", "Fprintf", "Fformat", "fformat", "flt", "fmat", "infprintf", " fMT", "vMT"], "vl": [" lev", "msg", " li", "vc", "sel", "lvl", "vol", " vol", "vel", "list", " lvl", "tp", "rel", "ml", " loc", "iv", "val", "pl", "kl", " dw", " cl", "VL", "abl", " bl", "wl", "pe", " rel", "phrase", " ml", " tv", "ln", "lists", " sl", "typ", "nl", "len", "bol", " fl", " il", " val", "l", "fl", "el", "vp", "lv", "elt", "v", " pl"], "part": [" parts", "msg", "first", "message", "vol", "process", "format", "party", "pair", " Part", "pt", "user", "repair", "space", "on", "span", "Part", "word", "quarter", "component", "PART", "command", "pos", "half", "work", "sample", "port", "layer", "point", "art", "name", "state", "der", "start", "power", "join", "partial", "base", "pod", "split", "phrase", "prefix", "star", "view", "one", "mid", "piece", "post", "inter", "var", "detail", "plan", "and", "try", "par", "ad", "patch", "per", "trans", "pre", "diff", "line", "vp", "p", "ror", "parts", "member", "attribute", "fix", "add", "test", "step", "error", "block", "pad", "pty"], "print_prefix": ["print_padding", "print___padding", "print_key", "printablepre", " print___padding", " print_padding", " print_leading", "printablefix", "print___leading", "printablekey", "printf_prefix", "print_fix", "printf_alias", " print___leading", " print___prefix", "printf_pre", "printf_fix", "print___fix", "print_alias", "printmmfix", "print2alias", "printableprefix", "print_leading", "printf_key", "print2fix", "print___prefix", " print_fix", " print___fix", "print_pre", "printmmprefix", "print2prefix", "printmmalias"], "type": ["name", "core", "ype", "t", "p", "time", "all", "Type", "start", "tag", "pack", "ver", "print", "comment", "role", "where", "index", "list", "set", "ping", "color", "tp", "length", "member", "null", "TYPE", "format", "count", "key", "top", "inter", "call", "style", "file", "state", "trace", "none", "scope", "info", "test", "var", "size", "status", "function", "link", "other", "pr", "position", "pe", "map", "buffer", "types", "shape", "try", "unit", "sort", "error", "sp", "range", "typ", "ty", "pre", "options", "form", "view", "port", "line", "cast", "class"], "avc": ["avect", "avg", "averc", "afcat", "avct", "aveC", "avercu", "afac", "afg", "aveic", " avct", "avcc", " avcu", "averic", "avic", "avercat", " avlc", "afcs", "avelc", "autc", "averC", "avac", "autcs", "avec", "averlc", "autic", "afc", "afct", "afcu", "aveac", "aveg", "averct", "avecs", "autC", " avg", "avcs", " avcs", " avcat", "averac", "avecu", "avcat", " avac", "avercc", "avC", "avcu", "avecc", "avercs", "avlc", " avcc"], "parent": ["master", "name", "man", "p", "source", "wrapper", "m", "root", "null", "tip", "rel", "relation", "pkg", "top", "ps", "key", "pt", "user", "peer", "var", "pa", "test", "node", "paren", "cmp", "snap", "mother", "ip", "pid", "fp", "mt", "prop", "op", "ctx", "parents", "holder", "child", "server", "pr", "tmp", "owner", "map", "fat", "self", "buffer", "up", "unit", "par", "stack", "per", "new", "sp", "global", "instance", "params", "pc", "tree", "pool", "nt", "remote", "client", "port", "comp", "cp", "origin", "net", "Parent", "chain"]}}
{"project": "FFmpeg", "commit_id": "1f4ff53aea7c5090f31cd1323d95f7c407c9b2bb", "target": 0, "func": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)\n\n{\n\n    if (cid != ctx->cid) {\n\n        int index;\n\n\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);\n\n            return AVERROR(ENOSYS);\n\n        }\n\n        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);\n\n\n\n        ff_free_vlc(&ctx->ac_vlc);\n\n        ff_free_vlc(&ctx->dc_vlc);\n\n        ff_free_vlc(&ctx->run_vlc);\n\n\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n\n                 ctx->cid_table->ac_bits, 1, 1,\n\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,\n\n                 ctx->cid_table->dc_bits, 1, 1,\n\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n\n                 ctx->cid_table->run_bits, 1, 1,\n\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n\n\n        ctx->cid = cid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22089, "substitutes": {"ctx": ["Context", "msg", "ck", "desc", "unc", "loc", "wp", "tk", "jp", "temp", "worker", "wx", "aux", "event", "tmp", "lc", "command", "std", "tc", "work", "ctl", "xc", "kw", "jac", "resp", "context", "cn", "conv", "cmp", "kl", "xp", "sc", "ka", "px", "cf", "kick", "wcs", "anc", "prefix", "that", "pc", "cam", "cmd", "iat", "crit", "tm", "inst", "cc", "handler", "cp", "cas", "td", "comm", "parent", "abc", "exec", "qt", "co", "act", "gc", "pkg", "tz", "cu", "cv", "tx", "args", "c", "cl", "proc", "hw", "kk", "nt", "nih", "config", "req", "conf", "obj", "nc", "comp", "ca", "history", "mk", "rc", "txt", "kt", "func", "cb", "check", "window", "etc", "ct", "ctrl", "conn", "bc", "document", "lex", "urg", "cm", "addr", "mc", "typ", "cfg"], "cid": ["ccdata", "CID", "ccide", "xcider", "ucip", "coid", " cpy", "Cdata", "camify", "recvalid", "mcident", "ucvalid", "cident", " cvalid", "cuident", "Crid", "cnip", "cuids", "xcit", "Cbid", "Cname", "Cit", "gcid", "cidem", "ccID", "Coid", "xcip", "cnid", "cider", "recip", "cpid", "cpix", "cnix", " cix", "cix", "cnify", "gcpy", "cppy", "cvalid", " cider", "cptry", "cip", "cID", "Cident", " cID", "gcidem", "recider", "cph", "camip", "xcid", "Cide", "Cid", "recid", "ctry", "acid", " cidem", "cit", "xcbid", "ucify", "xcname", " cname", "xcrid", "cpy", "xcvalid", "cify", "cpidem", "cdata", "xcID", "cids", "cuoid", "acID", "gctry", " crid", "cide", " cbid", "camid", "acide", "ucid", "acdata", "camvalid", "mcoid", " cip", "mcid", "cbid", "crid", "mcids", "Cids", "cuid", "cnvalid", "ccid", "ch", " cit", " ch", "cnh", "cname", " ctry"], "index": ["n", "Index", "loop", "available", "scope", "all", "number", "si", "list", "gate", "connect", "column", "f", "check", "ix", "set", "IND", "length", "value", "add", "read", "item", "count", "key", "loc", "x", "id", "current", "i", "ind", "empty", "code", "row", "max", "axis", "test", "size", "query", "select", "no", "j", "get", "connection", "lock", "link", "server", "ex", "draw", "num", "position", "open", "active", "page", "in", "new", "match", "find", "delete", "update", "from", "zero", "address", "pos", "len", "insert", "port", "local", "point", "instance"]}}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n", "idx": 22093, "substitutes": {"avctx": [" avjac", "wavctx", "savctx", "awcontext", " avconn", "aftx", "avcontext", " avcu", "awctl", "avecfg", "avercontext", "avtx", "avctl", "savcontext", "AVconn", "averctx", "wavcfg", "avercm", "aveconn", "avetx", "afcu", "avecontext", "avejac", "avcm", "savcu", "avjac", "afcontext", "avecm", "wavjac", "wavctl", "AVcontext", "afctx", "wavcm", "awctx", "awtx", "AVtx", "wavcontext", "avectx", "avcu", "avcfg", "avercfg", "AVctx", " avctl", "savtx", " avcontext", " avtx", "wavtx", "avconn"], "x4": ["x04", "php49", "xx2", "xmlrib", "php2004", "xml54", "upload464", "xmlFour", "rx104", "ix256", "ix2004", "px4", "tx04", "check104", "check2", " x2", "xml49", "x400", "php464", "xdfour", "X2", "php4", "rxFour", " x94", "ixrin", "upload94", "x2004", "phpfour", "rx84", "tx4", "ix4", "px49", "work400", "mx104", "xml4", "fxfour", "px256", "upload2", "x49", "X04", "ox2004", "xrib", "xx4", "php54", "x464", "xml2", "xrin", "ox400", "tx44", "wxrib", "fxFour", "fx4", "x104", "xx464", "x256", "ix49", " x464", "php256", "xml464", "upload4", "phpFour", " x6", "ixFour", "x2", "xmlOutput", "xml84", "rx4", "wx400", "check94", "xOutput", "workrib", "check4", "x44", "xd2", "oxrib", "X4", "xFour", " x44", "wx4", "x84", "xml04", "xfour", "work2004", "xx04", "wxfour", "php400", "mxfour", " x04", "Xfour", "x54", "work4", "ixrib", "ixfour", "fxrib", "xml104", "ixOutput", "xd4", "xd04", "wxFour", "ox4", "x94", "px2004", "rxrin", " xfour", "x6", "mx84", "xd6", "xmlfour", "php104", "tx6", "xd44", "rx49", "ix400", "check54", "check464", "rxfour", "mx4"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n", "idx": 22094, "substitutes": {"env": ["expr", "er", "en", "esm", "end", "org", "context", "eh", "me", "desc", "te", "h", "window", "act", "gear", "e", "code", "conn", "cv", "den", "ec", "esc", "proc", "enter", "ctx", "ptr", "environment", "ve", "server", "pe", "vs", "entry", "open", "viron", "dev", "erd", "config", "conf", "w", "obj", "ah", "ew", "next", "nv", "v", "shell", "ev", "forge", "vt"], "sigset": ["sigenSet", "sigsname", "sIGname", "insigmastart", "sesigmasc", "segmask", "sigmamask", "sigsset", "sogno", "sesigsc", "sgset", "sesigmalock", "sibmask", "sIGstr", "sIGmap", " siglist", "insigenset", "signset", "sesigmamask", " sigstring", "sigmap", "sIGmask", " sIGset", " sigget", "sigget", "sibset", "signame", "insigmask", "sigsbase", " sigstr", "sigenet", "signo", "insigenbase", "sigspace", "sigsclear", "signname", "insigmaset", "insigset", "signclear", "sigenbase", " sigsspace", "insigbase", "sogset", "signno", "signmap", "sigstart", "sogstart", "segget", " sIGname", "sigmalock", " sIGmask", "sigstr", "sgsc", "sIGset", "signget", "sesigmask", "sigclear", " sIGmap", "insigenSet", "insigno", " sigsset", " signame", " sIGclear", " sigsstring", "siglock", "siget", "sgmask", "sesigset", " sigsget", "sigsc", "insigstart", "sigmasc", "signstart", " sigmap", "sogmask", "sesigmaset", "signstring", "sigsspace", "sigmaset", "siglist", "insigenet", "sglock", "siblist", "segstr", "segset", "sigsstring", "sigsSet", "sigenset", "sigsget", "sibstr", "segspace", "insigSet", "signmask", "sigsmap", "signspace", " sigspace", "insigmano", "sigmano", "seglist", " sIGstr", "insigmamask", "insiget", "sesiglock", "sigbase", "sigSet", "sigstring", "sIGlist", "signlock", "segstring", "sigmastart", "sIGclear", "signsc", " sIGlist", " sigclear"], "sigmask": ["sigmatmask", " sigmaain", "sigmamask", "sigmak", "siblmask", "insammasks", "insammak", "Sigmamask", "insammask", "sigmaask", "sigake", "sirmake", " sigmaake", "sigmap", "sigrask", "insigmak", " sigmaask", "sigmaantle", "sigrmask", "Sigmmask", "sigmmask", " sigmain", " sigmape", "insigmask", "sigape", "semicask", "insammmask", " sigmaak", "Sigmake", "sigask", "sikkantle", "Sigmaake", " sigmamask", "sichak", " sigmatmask", "sigmaak", "siblask", "sigmatak", "sikkask", "sammmask", "sigmaap", " sigmak", "sammak", "sigmape", "sigmake", "sirmape", "insigmmask", "sigmasks", "semicak", "sikkak", "sichantle", "Sigmaask", "sichain", "sigmaasks", "semicmask", " sigmap", "Sigmask", " sigmaantle", "sigmatap", "sichask", "sigrak", "sigmatask", "sirmap", "siblake", "sigmaape", " sigmatask", "sigrasks", "sirmmask", "Sigmak", "sigmaake", "sammask", "sigmaain", "sikkain", "sigak", "insigmasks", "sirmask", " sigmatak", "sammasks", "sigmantle", "sikkmask", "semicantle", " sigmake", "Sigmaak", " sigmatap", "siblak", "sirmak", " sigmantle", " sigmaape", " sigmmask", "sigmain"], "r": ["n", "er", "p", "re", "t", "ror", "rc", "mr", "rn", "o", "f", "h", "m", "err", "rel", "d", "ar", "rr", "x", "e", "i", "rar", "rs", "or", "c", "R", "result", "rw", "fr", "k", "q", "rt", "pr", "kr", "dr", "g", "run", "cr", "u", "ry", "b", "l", "v", "attr", "rd", "w"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n", "idx": 22132, "substitutes": {"opaque": ["oplque", " opaques", "opa", "ipient", "iopaque", "iopient", "oplaque", "paques", "opvious", " opque", "operque", "opera", "ipaque", "iopa", " opvious", "iopque", "ipa", "opaques", "paque", "oplaques", "pque", "pvious", "oplvious", "ipque", "opque", "operient", "operaque", "opient"], "s": ["p", "t", "is", "a", "r", "o", "os", "f", "h", "ss", "y", "ns", "ps", "eps", "i", "cs", "sts", "aws", "gs", "rs", "fs", "c", "socket", "ds", "j", "z", "ls", "q", "ssl", "sv", "ats", "hs", "ess", "js", "S", "g", "es", "its", "sq", "ts", "als", "sp", "less", "b", "v"]}}
{"project": "FFmpeg", "commit_id": "de1824e970d448a84bedce4936c301c322baa714", "target": 0, "func": "static int mpeg_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    Mpeg1Context *s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n\n    av_dlog(avctx, \"fill_buffer\\n\");\n\n\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {\n\n        /* special case for last picture */\n\n        if (s2->low_delay == 0 && s2->next_picture_ptr) {\n\n            *picture = s2->next_picture_ptr->f;\n\n            s2->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return buf_size;\n\n    }\n\n\n\n    if (s2->flags & CODEC_FLAG_TRUNCATED) {\n\n        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n\n\n\n        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)\n\n            return buf_size;\n\n    }\n\n\n\n    s2->codec_tag = avpriv_toupper4(avctx->codec_tag);\n\n    if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32(\"VCR2\")\n\n                                           || s2->codec_tag == AV_RL32(\"BW10\")\n\n                                          ))\n\n        vcr2_init_sequence(avctx);\n\n\n\n    s->slice_count = 0;\n\n\n\n    if (avctx->extradata && !avctx->frame_number) {\n\n        int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);\n\n        if(*data_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"picture in extradata\\n\");\n\n            *data_size = 0;\n\n        }\n\n        if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n\n            return ret;\n\n    }\n\n\n\n    return decode_chunks(avctx, picture, data_size, buf, buf_size);\n\n}\n", "idx": 22137, "substitutes": {"avctx": [" avjac", " avconfig", "avertx", "abtx", "avcp", "afcu", " avcmp", "afcontext", "wavctl", "avecp", "afctx", "afcp", "wavtxt", "wavcmp", "vctx", "wavtx", "AVcu", "avconfig", "avcmp", "avconf", "abkt", "avercontext", "afpkg", "avesys", "aversys", "averctx", "wavsys", "aveconfig", " avsys", "wavcp", "aveca", "avercmp", "AVcontext", "averctl", " avtxt", "avecu", "avcu", " avcontext", " avtx", "abcontext", "averca", "aftxt", "avercu", "aftx", "avecb", "afconn", "avepkg", " avkt", "aveconf", "avtx", "avtxt", "ajconfig", "avetx", "avecontext", "avejac", "avjac", "averpkg", " avca", "avkt", "avca", "abctx", "wavcontext", "ajjac", "wavconn", "ajsys", "avconn", "wavctx", " avconn", "abcmp", "vkt", "avcontext", " avcu", " avcb", "ajconf", "avertxt", "vcontext", "avcb", " avpkg", "avectl", "avctl", "wavpkg", "aveconn", "avercb", "avsys", "vtx", "avpkg", "abpkg", "AVtx", " avconf", "ajctx", "ajcontext", "avectx", "avetxt", "averconn", "AVctx"], "data": ["name", "p", "t", "first", "message", "frame", "a", "device", "window", "value", "length", "read", "rel", "rew", "format", "table", "d", "ata", "images", "image", "reader", "package", "stream", "def", "empty", "join", "size", "bytes", "batch", "family", "media", "img", "raw", "DATA", "video", "dat", "buffer", "area", "Data", "block", "bin", " DATA", "next", "input", "sample", "to", "pad", "file", "feed", "text"], "data_size": ["data_cache", "data_start", "result_SIZE", " data_SIZE", "data8number", "result_size", "data8SIZE", " data_cache", " data_Size", "dataptSize", " data_length", "data8size", "data_number", "data_length", "data_count", "dataptlength", " data_number", "data_Size", "dataptcache", "data8Size", "result_count", "data_SIZE", "result_start", "dataptsize"], "avpkt": ["avewpnt", "avwpqt", "avwpkg", "averpction", "avdpkg", "avwpix", "averpkl", "avwppt", "avPnt", "avepkg", "avewpkg", "avpqt", "avjppt", "avcpqt", "avwpkt", "avewpacket", "avwpction", "avpacket", "avcpnt", "avPix", "avpkl", "avepacket", "avjpkl", "avdppt", "avewpqt", "avpix", "avPkg", "avepnt", "averpkt", "avewpkt", "avepct", "avjpkt", "avdpkt", "avcpkt", "avpkg", "avPct", "avewpix", "avpct", "avjpction", "averppt", "avwpnt", "avppt", "averdpction", "avPacket", "avwpacket", "avwpct", "avdpix", "avPqt", "avwpkl", "averdpkl", "avepix", "avepkt", "averdppt", "avewpct", "avdpkl", "averdpkt", "avdpacket", "avpction", "avPkt", "avcpct", "avepqt", "avdpction", "avpnt"], "buf": ["p", "rb", "msg", "txt", "cap", "rc", "alloc", "cb", "stat", "length", "err", "ob", "pkg", "Buff", "loc", "uf", "Buffer", "cv", "fb", "bytes", "vec", "batch", "img", "ctx", "raw", "br", "bh", "xff", "brace", "queue", "tmp", "wb", "seq", "map", "buffer", "box", "mem", "doc", "buff", "pb", "cmd", "cam", "np", "bin", "len", "pg", "next", "b", "text"], "s": ["n", "p", "t", "sys", "is", "a", "sa", "os", "parts", "source", "m", "h", "ss", "ns", "ims", "stats", "ps", "bs", "cs", "sts", "sports", "rs", "gs", "fs", "aws", "c", "ds", "st", "j", "sm", "ls", "sv", "ssl", "sw", "ats", "hs", "self", "sc", "S", "js", "ess", "g", "sq", "ts", "sp", "sb", "b", "v", "sl"], "picture": ["share", "name", "p", "gif", "pict", "Picture", "context", "frame", "stat", "photo", "policy", "movie", "length", "piece", "format", "pkg", "image", "style", "id", "document", "info", "query", "profile", "figure", "friendly", "fp", "img", "media", "pen", "png", "P", "ctx", "password", "peg", "video", "fi", "camera", "pr", "feat", "sharp", "feature", "util", "support", "file", "pic"], "s2": ["servlet", "s1", "ses1", "cs2", "ps2", "S1", "cstwo", "less2", "h2", "serv3", "cs1", " s1", "s12", "ses2", "selftwo", "ps02", "ses02", " stwo", "s02", "ds2", "less12", "sb1", "h3", "tssecond", "dssecond", "ps1", "ts1", "less02", " slet", " sorter", "sb3", "self2", "sb2", "stsorter", "S2", " s3", "ststwo", "h12", "S3", "ts3", "sestwo", "lslet", "sts3", "dstwo", "ps3", "tstwo", "pstwo", "csorter", "S02", "sts1", "sbtwo", "e2", "ls1", "e1", "sts2", " s02", "ls3", "h02", "stwo", "s3", "self3", "cssecond", "less3", " s12", "ts2", "lstwo", "ssecond", "selflet", "sorter", "slet", "serv2", "etwo", "ls2", "stslet", "servtwo"]}}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n", "idx": 22140, "substitutes": {"opaque": ["ropen", "ipatile", "Opoid", "opoid", "iopaque", "ropaque", "ipacity", " opaco", "Opaco", "imacity", "imque", "operque", "imaque", "OPaque", "operacity", "ropaco", "OPaco", "ipaque", " opacity", "Opaque", "pacity", "OPque", "iopque", "pen", "opacity", "paco", "iopoid", "open", "paque", "imatile", " open", "opaco", "ropacity", "Opque", "opque", "ipque", "operatile", "iopaco", "operaque", "opatile", "OPoid"], "chr": ["echro", "chrb", "Chc", "qrb", " chc", "Chdr", "shr", " chrc", "Chrc", "hwr", "ichdr", "echrc", " chro", "corar", "cordr", "ochar", "chmr", "Chmr", "shmr", "shar", "hwrc", "hwmr", "chro", "Chr", "qar", "qr", "ichro", "echr", "hwar", "ichr", "ochrc", "echdr", "chc", "corc", "Char", "qrc", "shrc", "chrc", "ochr", " chdr", "ichrc", " chrb", "corr", "chdr", "ochrb"], "s": ["n", "comm", "er", "p", "sys", "is", "a", "os", "source", "h", "ss", "ns", "ims", "ses", "stats", "ps", "bs", "cs", "sts", "rs", "gs", "fs", "c", "ds", "j", "se", "ls", "spec", "ex", "sam", "sv", "sw", "ats", "vs", "hs", "self", "S", "js", "ess", "g", "es", "its", "sq", "ts", "als", "ins", "http", "conf", "less", "sb", "b", "v", "sl", "serv"], "size": ["message", "loss", "sum", "length", "fee", "count", "space", "span", "no", "sn", "sized", "now", "city", "equal", "pos", "v", "small", "sent", "type", "n", "name", "any", "start", "si", "x", "e", "il", "empty", "dim", "export", "body", "see", "send", "num", "area", "mem", "g", "grow", "t", "scope", "number", "score", "scale", "args", "max", "c", "limit", "z", "height", "ize", "shape", "sp", "esi", "to", "l", "sha", "en", "capacity", "set", "index", "SIZE", "notice", "gz", "id", "since", "south", "speed", "iter", "Size", "year"], "len": ["n", "fun", "coll", "resp", "en", "t", "all", "end", "cap", "els", "del", "Len", "mil", "length", "al", "late", "gz", "wid", "enc", "val", "pl", "loc", "lp", "fac", "label", "lan", "il", "ld", "lon", "dl", "den", "le", "kl", "cmp", "limit", "la", "lim", "bytes", "fil", "li", "ls", "alt", "hl", "iter", "mem", "fin", "gl", "ln", "nt", "sp", "nl", "pos", "gen", "ll", "elt", "lf", "comp", "l", "mn", "fl", "el", "lib", "sl", "L"], "buf": ["orig", "p", "msg", "rb", "rc", "cap", "txt", "out", "cb", "ref", "window", "err", " buffers", " buffer", "Buff", "uf", "bar", "Buffer", "bc", "str", "cv", "data", "var", "fb", "bytes", "vec", "temp", "tr", " buff", "img", "ctx", "nm", "raw", "br", "bh", "queue", "tmp", "wb", "seq", "db", "buffer", "box", "iter", "mem", "doc", "buff", "cmd", "BU", "bin", "pos", "ah", "b", "v", "ba", "text"]}}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n", "idx": 22151, "substitutes": {"opts": ["ports", "prot", "optTS", "oprets", "synls", "opspt", "optths", "opsats", "porTS", "optpt", "opls", "opsnt", "ipt", "synts", "royps", "ackt", "alt", "ipts", "opths", "ackths", "opals", "synouts", "proms", "Opals", " opters", "opTs", " oprets", "imls", "ioprets", "alts", "iopps", "opt", "porTs", "opsjs", "optTs", " opt", "orters", "imters", "iopters", "optjs", "alms", "opTS", "opouts", "porters", "optnt", "opsts", "optts", "orts", "opnt", "imouts", "synters", "orats", "oppt", "orpt", "iopts", "optters", "opsouts", "opms", " opTs", "opst", "optals", "optls", "Opts", "imts", "ackts", "Opt", "royrets", " opTS", "royts", " opms", "opters", "optt", "opsths", "opjs", "opps", "Opouts", "ackjs", "optouts", "ipnt", "royters", "prots", "opsals", "opats", "optats", " opps", "opsters"], "val": ["cert", "cho", "all", "msg", "fol", "ret", "vol", " el", "value", "err", "rel", "rol", "eval", "pt", "tl", "sv", "vet", "res", "alt", "als", "elt", "sil", "v", "fl", "sl", "sel", " eval", "aval", "bl", "x", "echo", "ind", "il", "fail", "Val", "kl", "pol", "gold", "pal", "pr", "gl", "mem", "cal", "crit", "virt", "t", "leg", "it", "ref", "del", "def", "str", "tx", "var", "buf", "li", "ctx", "req", "conf", "obj", "len", "l", "el", "serv", " aval", "vt", "valid", "p", "old", "lit", "txt", "ival", "al", "ul", "item", "pl", "arr", "lay", "test", "compl", "lex", "cfg", "prop", "urg", "VAL", "gal", "vals", "reg", "lib"]}}
{"project": "qemu", "commit_id": "5829b097204189c56dd1fb62c7f827360394bb39", "target": 0, "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd, colour;\n\n    int args, len;\n\n    int x, y, dx, dy, width, height;\n\n    struct vmsvga_cursor_definition_s cursor;\n\n    uint32_t cmd_start;\n\n\n\n    len = vmsvga_fifo_length(s);\n\n    while (len > 0) {\n\n        /* May need to go back to the start of the command if incomplete */\n\n        cmd_start = s->cmd->stop;\n\n\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n\n        case SVGA_CMD_UPDATE:\n\n        case SVGA_CMD_UPDATE_VERBOSE:\n\n            len -= 5;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n\n            break;\n\n\n\n        case SVGA_CMD_RECT_FILL:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            colour = vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_FILL_ACCEL\n\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_RECT_COPY:\n\n            len -= 7;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            dx = vmsvga_fifo_read(s);\n\n            dy = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_RECT_ACCEL\n\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_DEFINE_CURSOR:\n\n            len -= 8;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            cursor.id = vmsvga_fifo_read(s);\n\n            cursor.hot_x = vmsvga_fifo_read(s);\n\n            cursor.hot_y = vmsvga_fifo_read(s);\n\n            cursor.width = x = vmsvga_fifo_read(s);\n\n            cursor.height = y = vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            cursor.bpp = vmsvga_fifo_read(s);\n\n\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n\n            if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n\n                    goto badcmd;\n\n            }\n\n\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n#ifdef HW_MOUSE_ACCEL\n\n            vmsvga_cursor_define(s, &cursor);\n\n            break;\n\n#else\n\n            args = 0;\n\n            goto badcmd;\n\n#endif\n\n\n\n        /*\n\n         * Other commands that we at least know the number of arguments\n\n         * for so we can avoid FIFO desync if driver uses them illegally.\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n", "idx": 22155, "substitutes": {"s": ["n", "ties", "comm", "er", "t", "p", "is", "sys", "ports", "a", "r", "os", "source", "set", "h", "m", "ss", "ns", "ims", "ses", "changes", "stats", "d", "serv", "im", "ps", "bs", "sts", "sports", "rs", "gs", "fs", "c", "ds", "bis", "j", "z", "sm", "ls", "details", "ers", "sam", "sv", "ms", "ats", "hs", "self", "bes", "S", "js", "es", "its", "sq", "ts", "ins", "erences", "params", "conf", "qs", "less", "sb", "an", "b", "as", "v", "sl", "series", "w"], "cmd": ["kw", "comm", "fun", "fn", "sys", "msg", "rc", "txt", "quit", "func", "kind", "cb", "stat", "desc", "Cmd", "err", "head", "init", "act", "method", "dir", "ct", "fast", "call", "id", "def", "ext", "code", "conn", "ind", "cd", "close", "c", "md", "cl", "cli", "batch", "col", "op", "ctx", "raw", "send", "bg", "g", "config", "job", "command", "req", "obj", "ctl", "flag", "cp", "cfg", "ctr", "text"], "colour": ["p", "focus", "state", "txt", "frame", "source", "wh", "color", "f", "grey", "h", "border", "filter", " Colour", "format", "d", "image", "filename", "rg", "style", "ind", "c", "fg", "xy", "md", "hair", "blue", "col", "fil", "which", "colored", "pal", "black", "theme", "draw", "html", "active", "phy", "g", "action", "stroke", "our", "l", "v", " colours", "text"], "args": ["n", "flags", "all", "bits", "ret", "func", "parts", "Len", "ns", "ax", "Arg", "arr", "rows", "arg", "cs", "alls", "fs", "gs", "axis", "ds", "md", "size", "fields", "Args", "ls", "num", "vals", "xs", "ts", "params", "ags", "pos", "actions", "l", "w"], "len": ["n", "fun", "fn", "lif", "coll", "en", "resp", "lit", "ellen", "rev", "els", "lvl", "vl", "list", "vol", "del", "Len", "length", "bl", "ul", "conv", "val", "pl", "loc", "lp", "lan", "lon", "tl", "var", "dl", "size", "den", "ell", "kl", "limit", "ann", "cmp", "lim", "compl", "vec", "li", "ls", "mult", "lin", "num", "vet", "lic", "hl", "lc", "alt", "un", "gl", "mem", "fin", "ln", "nt", "nl", "pos", "gen", "ll", "lis", "elt", "lf", "l", "fl", "el", "lib", "syn", "sl", "L"], "x": ["fx", "ij", "xx", "xt", "index", "xxxx", " xx", "xi", "f", "ix", "foo", "length", "ax", "ox", " i", "yx", "d", " tx", " ox", "i", "lon", "tx", "xy", "rx", "X", " ax", "ip", "xp", "lex", "wx", "ex", " cx", "lat", "px", "addr", "at", "xs", "mx", "ux", "path", "ry", "l", "v", "el", "xd", "xc", "w"], "y": ["t", "yy", "sys", "axy", "py", "hy", "ys", "ady", "ay", "key", "ey", "iy", "cy", "wy", "i", "ind", "fy", "yl", "ny", "ot", "on", "my", "vy", "ya", "xy", "asy", "uy", "j", "z", "yt", "sy", "oy", "icy", "sky", "Y", "ies", "ch", "ym", "ty", "yr", "gy", "yer", "yn", "ye", "b", "ry", "v", "yi"], "dx": ["fx", "xx", "dh", "del", "dq", "du", "ix", "xi", "ax", "ox", "yx", "dir", "d", "wy", "ind", "dt", "tx", "dim", "xy", "ds", "dl", "rx", "xp", "wx", "ex", "px", "dr", "xs", "mx", "eddy", "xd"], "dy": ["yy", "dh", "fly", "py", "die", "dd", "dial", "dq", "rison", "length", "ady", "ji", "dn", "dir", "d", "wy", "iy", "dt", "dies", "lon", "dim", "dl", "xy", "ds", "uy", "ded", "phy", "eddy", "ty", "dos", "yer", "dj", "dot"], "height": ["density", "volume", "history", "kw", "quality", "radius", "hang", "build", "ht", "capacity", "through", "confidence", "depth", "wh", "color", "h", "window", "length", "hash", "rank", "th", "total", "power", "resolution", "style", "weight", "headers", "dim", "Height", "size", " heights", "angle", "png", "gravity", "shape", "ch", "holes", "background", "ty", "hold", "bottom", "above", "strength", "grow", "padding", "w"], "cursor": ["dcursor", "dcoder", "cascade", "icascade", "xcoder", "icoder", "xctor", "xcursor", "icursor", "xcascade", "ctor", "coder", "ictor", "dctor", "dcascade"], "cmd_start": [" cmd_sp", "cmd_end", "cmd_st", " cmd_st", " cmd_end", "cmd_stop", " cmd_stop", "cmd_sp"]}}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 22167, "substitutes": {"st": ["ste", "t", "ost", "start", "usr", "stop", "r", "set", "stat", "desc", "sta", "th", "d", "src", "ind", "sts", "St", "str", "decl", "ast", "status", "mt", "fr", "ust", "rt", "est", "sc", "stage", "rest", "nt", "sp", "std", "irst", "ist", "inst", "l", "ST", "sty"], "buf": ["bag", "rb", "cap", "txt", "out", "msg", "cat", "cb", "ref", "desc", "off", "window", "err", " buffers", " buffer", "Buff", " Buffer", "pkg", "bs", "text", "uf", "Buffer", "str", "cv", "data", "var", "fb", "bytes", "vec", "cur", "batch", "tr", "nb", "result", " buff", "ff", "ctx", "raw", "ptr", "br", "queue", "tmp", "wb", " b", "db", "buffer", "box", "iter", "mem", "doc", "fd", "buff", "block", "pool", "pb", "bt", "cache", "pos", "cmd", "next", "b", "pad", "cast", "w"], "end": ["name", "en", "all", "out", "start", "it", "stop", "begin", "et", "comment", "End", "desc", "east", "h", "ef", "ending", "offset", "ended", "enc", "text", "dest", "id", "ext", "e", "END", "str", "data", "reset", "max", "ender", "ec", "hend", "close", " End", "wrap", "nd", "ff", "ent", "event", "send", "est", "alt", "dev", "fin", "rest", "ad", "pend", "term", "append", "except", "len", "last", "rend", "pad", " END", "w"], "sysfspath": ["sysfSPoint", "sysfslath", "sysfssath", "sysfscpath", "sysfSPopath", "sysfscoint", "sysfspaths", "sysfSPpath", "sysfaspath", "sysfspATH", "sysfispath", "sysvssile", "sysfaspopath", "sysvspath", "syscspaths", "sysfslile", "sysfslaths", "sysfispaths", "sysfaspATH", "sysfspopath", "syscSPoint", "sysfscopath", "sysfispopath", "sysfasppath", "sysfssaths", "sysfspoint", "sysfaspaths", "sysfospaths", "sysfosppath", "sysfsloint", "sysfisppath", "sysfSpATH", "sysfsspath", "syscsppath", "sysvspaths", "sysvsspath", "sysfssile", "syscSPopath", "syscSPpath", "sysvspile", "sysfsppath", "sysvssaths", "sysfslpath", "syscSPath", "syscspopath", "syscSpaths", "sysfospile", "syscSpATH", "syscspath", "syscspoint", "sysvssath", "syscSpopath", "sysfSpaths", "sysfslopath", "sysfSpath", "sysvsppath", "syscSpath", "sysfspile", "sysfSPath", "sysfscath", "syscspATH", "sysfSpopath", "sysfssopath", "sysfospath"], "ret": ["expr", " RET", "cont", "xt", "desc", "err", "rel", "pt", "uf", "dt", "eth", "reset", "no", "vet", "res", "alt", "RET", "after", "elt", "ry", "success", "fun", "resp", "re", "rev", "cat", "back", "rets", "nz", "mt", "deg", "num", "opt", "dr", "at", "cmd", "att", "net", "pas", " Ret", "t", "leg", "r", "red", "ref", "rem", "Ret", "gc", "arg", "def", "ter", "pret", "oret", "ft", "ptr", "try", "nt", "stay", "len", "vt", "gt", "out", "lit", "usr", "ort", "det", "func", "print", "val", "arr", "ext", "tr", "j", "ord", "result", "rt", "grad", "reg", "iter", "rm", "fd", "not", "flag"], "max_segments": ["max_megments", "maxlenbegment", "max_tegment", "max_tegments", "maxlenbeges", "max_beges", "max_vements", "maxlenbegments", "max_seges", "max_schelements", "max_delements", "max_vegment", "max_parsegments", "max_schegment", "max_parsements", "maxlensegment", "max_dements", "max_sements", "max_megment", "max_schements", "max_velevels", "maxlenseges", "max_bements", "max_meges", "max_begs", "maxlenbegs", "max_degments", "max_tegs", "max_begment", "max_degment", "maxlensegments", "max_belevels", "max_parselevels", "max_segs", "max_megs", "max_teges", "max_segment", "maxlensegs", "max_schegments", "max_parsegment", "max_selevels", "max_selements", "max_begments", "max_belements", "max_vegments"]}}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201, "substitutes": {"s": ["n", "ties", "comm", "p", "t", "is", "sys", "a", "os", "source", "h", "m", "ns", "ss", "session", "ses", "d", "ps", "bs", "cs", "sts", "i", "aws", "gs", "fs", "rs", "c", "services", "ds", "states", "se", "z", "sm", "spec", "ls", "details", "sv", "sw", "ats", "hs", "self", "ies", "sc", "S", "js", "es", "sq", "ts", "als", "qs", "less", "store", "sb", "an", "b", "l", "v", "serv"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250, "substitutes": {}}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n", "idx": 22265, "substitutes": {"bs": ["bi", "blog", "ubis", "ils", "lbs", "bits", "bf", "ks", "cb", "ubs", "ns", "BS", "bps", "aos", "bl", "ps", "ib", "cs", "bc", "sts", "fs", "gs", "rs", "ds", "bis", "bytes", "ls", "bm", "bh", "ms", "vs", "ats", "bes", "js", "its", "ts", "als", "obs", "pb", "bt", "sb", "bos", "b", "bp", "bas", "bb"], "options": ["offs", "ptions", "scope", "bits", "settings", "os", "parts", "policy", "ims", "stats", "ps", "ops", "terms", "style", "keys", "times", "results", "info", "args", "currency", "styles", "classes", "locks", "abilities", "details", "IONS", "caps", "atts", "values", "tools", "properties", "vals", "types", "als", "config", "ts", "params", "Options", "metadata", "tops", "option", "errors"], "flags": [" Flags", "uses", "bits", "settings", "aps", "parts", "tags", "bugs", "stats", "ps", "FLAG", "ops", "allows", "mask", "times", "args", "locks", "states", "faces", "files", "status", "details", "names", "atts", "ms", "lines", "properties", "levels", "types", "xf", "vals", "ts", "Flags", "features", "ags", "fps", "flag", "lag", "fields"], "errp": ["errps", "errP", "errpa", "rrpc", " errP", " errpc", "rrP", "rrpa", " erps", " errpa", "errpc", "errpb", " erpa", " errpb", " erpb", " erp", " errps", "errorpa", "rrps", "rrpb", "errorp", "errorP", "rrp", "errorpc"], "client": ["Client", "p", "proxy", "writer", "out", "context", "et", "app", "force", "io", "wrapper", "connect", "window", "session", "co", "google", "key", "secure", "call", "con", "contact", "i", "conn", "socket", "controller", "c", "close", "cl", "local", "cli", "batch", "ip", "connection", "lock", "cod", "bo", "cell", "manager", "web", "server", "entry", "open", "ch", "http", "nt", "oe", "config", "util", "block", "cmd", "remote", "cache", "obj", "store", "handler", "cp", "lib", "public", "channel"], "ret": [" RET", "prot", "cont", "xt", "desc", "sum", "err", "pt", "dt", "reset", "jp", "res", "alt", "RET", "after", "elt", "ry", "success", "fun", "resp", "re", "rev", "cat", "rets", "nz", "lt", "status", "mt", "deg", "reply", "num", "opt", "mem", "at", "cmd", "last", "att", " Ret", "ben", "t", "red", "ref", "tn", "rem", "Ret", "gc", "inter", "ert", "arg", "def", "ter", "pret", "oret", "ft", "ptr", "try", "nt", "sp", "len", "gt", "out", "txt", "usr", "final", "det", "print", "val", "arr", "ext", "tr", "j", "result", "rt", "reg", "rm", "ll", "flag"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22270, "substitutes": {"opaque": ["oplque", " opaques", "iopaque", "oplaque", "opasi", " opque", "OPaque", "iopaques", "OPaques", "Opaque", "OPque", "iopque", "iopasi", "OPasi", "opaques", "oplasi", "Opaques", "oplaques", " oplay", "OPlay", "Oplay", "opque", "Opque", "oplay"], "addr": ["expr", "ack", "err", "rel", "loc", "eth", "host", "ress", "now", "res", "alt", "pos", "n", "name", "state", "rev", "a", "ix", "ay", "x", "i", "handle", "cmp", "mt", "adr", "at", "dr", "cmd", "ace", "nl", "b", " address", "r", "arp", "ref", "hash", "act", "url", "tx", "ip", "mac", "hw", "ptr", "ad", "trans", "range", "np", "obj", "len", "sha", "attr", "alias", "gt", "dh", "end", "alloc", "index", "off", "offset", "add", "src", "arr", "id", "rs", "ord", "shift", "align", "rt", "Address", "block", "address", "pad", "phys"], "retval": ["mtvalue", " retv", "RETVal", " returnbal", "reval", "retcal", "retfac", "rev", "RetVal", "returnVal", "RETVAL", " retret", "fulval", "retsvol", "fulfac", " returnVAL", "fulvals", "returnvalue", " retVal", "RETval", "retVal", " retcal", " retvals", "fulvol", "retsvals", "retvals", "retv", "retvalue", " retfac", "mtval", "retVAL", "Retret", " returnval", "Retv", "returnval", "Retval", "retret", " returnVal", "mtVal", " retvol", "mtcal", "reret", "reVal", "RETbal", " retvalue", "retvol", "retsfac", "returncal", "retbal", "RetVAL", " retVAL", " retbal", "retsval"], "d": ["done", "dh", "dm", "D", "o", "dd", "di", "ade", "did", "du", "dc", "debug", "sd", "dn", "gd", "ld", "ind", "bd", "des", "ds", "dl", "md", "ord", "dict", "dat", "db", "ded", "od", "dr", "ad", "de", "fd", "cal", "dos", "mod", "pd", "ctl", "dj", "da"]}}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276, "substitutes": {"env": ["en", "esm", "eas", "engine", "end", "cap", "org", "context", "scope", "eh", "param", "gate", "te", "ef", "window", "gear", "vr", "e", "vm", "cv", "ec", "esc", "proc", "enter", "buf", "estate", "ctx", "uv", "ptr", "ov", "environment", "ve", "sv", "kh", "ope", "pe", "vs", "sc", "viron", "dev", "eu", "En", "erd", "sp", " environment", "Environment", "conf", "ah", "ew", "sb", "nv", "v", "eng", "vp", "ev", "serv"], "tlb": ["ttlbs", "tpl", "tlbs", "vlb", "antLB", "Tlb", "hotbh", "antlp", "hotlp", "ttlb", "vlbs", " tlp", " tpl", "hotlb", "antlbs", " tbh", "tLB", "tbh", "Tlp", "tlp", "antlb", "vpl", "Tpl", "itLB", " tlbs", "itlbs", "ttlp", "TLB", "Tlbs", "itlb", "ttbh", "hotlbs", "itlp"], "tlbncfg": ["tlbingov", "hlBNgov", "tlcnalg", "tlijnconfig", "tlbinconfig", "llbnjp", "tlbinfg", "tlbanfg", "tlbnconfig", "tlbmcmd", "tlijncfg", "tlgncfg", "rlbncfg", "tlbanjp", "llbmcfg", "hlbncfg", "tlgncmd", "tlbmjp", "rlbnconf", "tlBNconfig", "hlbnfg", "llbnconfig", "tlcncfg", "tlBNconf", "llbncfg", "tlbancfg", "tlbncmd", "rlcnfg", "llbnfg", "tlbmcfg", "tlbincfg", "rlbnalg", "tlcnconf", "hlBNconfig", "tlbnconf", "hlBNcfg", "rlcnconf", "tlbmalg", "tlbanconfig", "tlijnfg", "rlcncfg", "llbmcmd", "tlbnalg", "tlcnfg", "tlBNcfg", "tlbnjp", "tlbmconfig", "hlbngov", "llbmjp", "tlbmfg", "tlbincmd", "tlijngov", "rlcnalg", "tlbmconf", "tlgnconfig", "hlBNfg", "tlbnfg", "tlbngov", "tlBNjp", "llbmfg", "tlgnfg", "rlbnfg", "tlBNgov", "llbmconfig", "tlBNfg", "tlBNalg", "hlbnconfig", "llbncmd"], "tlbm_size": ["tlbm2Size", "tlbm_sum", "tlmn_ize", "tlbm2scale", "tlbm2SIZE", "tlbm2size", "tlbm_scope", "tlmn_Size", "tlbn_dim", "tlbm67Size", "tlbm_ize", "tlbm_scale", "tlbm67size", "tlbm_SIZE", "tlbm67scope", "tlbn_sum", "tlbal_Size", "tlbal_size", "tlbm67dim", "tlbn_SIZE", "tlbn_Size", "tlmn_SIZE", "tlmn_size", "tlbal_SIZE", "tlbm_dim", "tlbm_Size", "tlbn_scale", "tlbn_size", "tlbn_scope"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n", "idx": 22279, "substitutes": {"xfer": [" xlate", "yfer", "ixference", "hfer", "wxFER", "xxhr", "ixmit", "crossporter", "pxvert", "yfe", "rossfer", "xporter", "eyforge", "xpir", "xyfer", "pxfer", "xlate", "ryfer", "oxiter", "xhr", "hFer", "xforge", "ixporter", "htransfer", "yFER", "lexFER", "crossFER", "rossference", "workfer", " xferred", "ixpir", "xxfe", "rosspire", " xmit", "oxlate", "eyfer", "oxferred", "wxporter", "eypir", "oxvert", " xFER", "eyFer", "ryference", "pxpir", "ixforge", " xff", "ixvert", "pxferred", "xff", "rypire", "xference", "xffer", "wxfe", "ixlate", " xtransfer", "xpire", "xiter", "wxfer", "ixtransfer", "ixfer", " xiter", "xtransfer", "crossfer", "ixff", "ixFer", "xmit", "xyference", "wxmit", "oxfer", "ixFER", "workiter", "ixiter", " xference", "oxffer", "yhr", "pxference", "lexfer", "oxmit", "crossmit", "workference", "xvert", "xferred", "hffer", "ixffer", "xfe", "hference", "hff", "oxFER", "lexiter", "ixferred", "workffer", "oxference", "xFer", "pxforge", "eyffer", "xypire", "xFER", "xxFER", "xxfer", "eyference", " xffer", "pxiter", "wxhr"], "port": ["parent", "ports", "ort", "pport", "et", "ref", "PORT", "channel", "serv", "pt", "socket", "select", "test", "host", "limit", "pod", "link", "buffer", "mit", "Port", "range", "eport", "pc", "address", "cast", "gp", " sport", "type"], "ep": ["p", "cap", "eur", "eb", "dep", "ether", "Ep", "ek", "ef", "tp", "pp", "eps", "mp", "e", "eg", "eth", "tap", "cp", "ape", "ec", "ap", "EP", "ip", "op", "peak", "ope", "dp", "pe", "esp", "sp", "ew", "lip", "ech", " e", "bp", "vp", "gp", "point", "ev"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n", "idx": 22280, "substitutes": {"acb": [" cacb", "aconbo", "acbo", "aconbb", "acy", " acbb", "aconp", "Acb", "accfb", "acbb", "aconb", "accb", "acfb", "acony", "acp", " cacy", "Acbo", "Acp", "accy", " acbo", " acp", "acba", "aconfb", "aconba", " cacba", " cacfb", "accba", "Acbb"], "elem": ["nlem", " elt", "erlement", "ele", " elev", "erlev", "entlement", "eclem", "dlev", "eleg", "peom", "mept", "eom", " element", "teem", "entlem", "vem", "dlem", "telev", "spt", "celev", "dlement", "elt", "meem", "eclev", "melev", "pele", "pelems", "veleg", "slement", " ele", "erleg", "eem", "elam", "eelam", "elelement", " eom", "ept", "telement", "velement", "entm", "eept", "melam", " elems", "elelev", "npt", "elelt", "eelem", "eelements", "eelev", "velements", "elems", "melement", "pem", " elam", "ecleg", "velem", "eclement", "melem", "celems", "em", "pelam", "elelements", "eelems", "pelement", "celem", "elelems", "element", " em", "celt", "pelem", "entom", "nlement", "elements", "slem", "slev", "elelem", "nlam", "eelement", "velev", "dem", "elev", "eele", "telem", " ept", "erlem"], "pool": ["role", "process", "policy", "length", "driver", "pt", "timeout", "host", "temp", "phy", "util", "client", "port", "flow", "chain", "type", "loop", "state", "context", "list", "pm", "thread", "program", "prof", "socket", "size", "handle", "connection", "ools", "platform", "px", "mem", "prefix", "pc", "network", "cp", "core", "quote", "view", "memory", "wrapper", "table", "pkg", "pro", "layout", "select", "limit", "ool", "height", "ctx", "rain", "buffer", "phony", "shape", "box", "common", "range", "pg", "cache", "store", "p", "out", "meter", "container", "window", "conn", "profile", "lock", "manager", "queue", "block", "Pool", "hold", "pty"]}}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 22300, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "5952b8da0b7f65dfa23991e71737e0abdaeb339c", "target": 1, "func": "static int seek_test(const char *input_filename, const char *start, const char *end)\n\n{\n\n    AVCodec *codec = NULL;\n\n    AVCodecContext *ctx= NULL;\n\n    AVCodecParameters *origin_par = NULL;\n\n    AVFrame *fr = NULL;\n\n    AVFormatContext *fmt_ctx = NULL;\n\n    int video_stream;\n\n    int result;\n\n    int i, j;\n\n    long int start_ts, end_ts;\n\n\n\n    size_of_array = 0;\n\n    number_of_elements = 0;\n\n    crc_array = pts_array = NULL;\n\n\n\n    result = avformat_open_input(&fmt_ctx, input_filename, NULL, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't open file\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avformat_find_stream_info(fmt_ctx, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't get stream info\\n\");\n\n        return result;\n\n    }\n\n\n\n    start_ts = read_seek_range(start);\n\n    end_ts = read_seek_range(end);\n\n    if ((start_ts < 0) || (end_ts < 0))\n\n        return -1;\n\n\n\n    //TODO: add ability to work with audio format\n\n    video_stream = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n\n    if (video_stream < 0) {\n\n      av_log(NULL, AV_LOG_ERROR, \"Can't find video stream in input file\\n\");\n\n      return -1;\n\n    }\n\n\n\n    origin_par = fmt_ctx->streams[video_stream]->codecpar;\n\n\n\n    codec = avcodec_find_decoder(origin_par->codec_id);\n\n    if (!codec) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't find decoder\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx = avcodec_alloc_context3(codec);\n\n    if (!ctx) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate decoder context\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = avcodec_parameters_to_context(ctx, origin_par);\n\n    if (result) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't copy decoder context\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avcodec_open2(ctx, codec, NULL);\n\n    if (result < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Can't open decoder\\n\");\n\n        return result;\n\n    }\n\n\n\n    fr = av_frame_alloc();\n\n    if (!fr) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate frame\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);\n\n    if (result != 0)\n\n        return -1;\n\n\n\n    for (i = start_ts; i < end_ts; i += 100) {\n\n        for (j = i + 100; j < end_ts; j += 100)\n\n        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 0);\n\n        if (result != 0)\n\n            return -1;\n\n    }\n\n\n\n    av_freep(&crc_array);\n\n    av_freep(&pts_array);\n\n    av_frame_free(&fr);\n\n    avcodec_close(ctx);\n\n    avformat_close_input(&fmt_ctx);\n\n    avcodec_free_context(&ctx);\n\n    return 0;\n\n}\n", "idx": 22316, "substitutes": {"input_filename": ["input_string", " input_file", "input_fp", "inputilefp", "inputingusername", "inputingstring", "inputilefilename", "inputingfilename", "inputingfp", " input_package", " input_username", "input_package", "input_file", "inputilepackage", "inputilefile", " input_fp", " input_string", "input_username"], "start": ["name", "create", "time", "use", "first", "stop", "begin", "starting", "set", "check", "offset", "read", "add", "init", "change", "inter", "before", "close", "reset", "query", "st", "get", "step", "wind", "base", "Start", "seek", "part", "entry", "open", "help", "iter", "rest", "date", "match", "range", "from", "pos", "next", "art", "need"], "end": ["en", "old", "load", "out", "stop", "wall", "End", "east", "length", "ending", "add", "ended", "change", "post", "id", "e", "ext", "END", "until", "close", "max", "size", " End", "step", "nd", "send", "est", "open", "edge", "ad", "range", "except", "append", "term", "after", "last", "to", "pad", "chain"], "codec": ["CodEC", "pedoder", "coef", "camtor", "callec", "odeca", "acoder", "cod_", "coddec", "odEC", "Codec", " coddec", "cmp_", "acec", "odef", "codrc", "Codeca", " codtor", "odec", "codef", "codtor", "camEC", " codcc", "cododer", " codef", "codeca", "Cododer", " cod_", "pedec", " codEC", "oddec", "odrc", "od_", "coEC", "coec", " codeca", "calleca", "odstream", "codEC", "pedeca", " codstream", "cmpstream", "pedEC", "callcc", "camdec", " codrc", "codcc", "corc", "camec", "callEC", "acEC", "aceca", "odtor", "odcc", "codstream"], "ctx": ["kw", "jac", "mk", "sys", "txt", "context", "kt", "ck", "alloc", "cb", "co", "init", "act", "gc", "ct", "pkg", "loc", "unc", "ctrl", "conn", "bc", "cu", "cv", "tx", "fw", "voc", "jp", "cmp", "hw", "buf", "aux", "wx", "ptr", "tmp", "kr", "grad", "cond", "cm", "addr", "cf", "nt", "mc", "np", "cmd", "tc", "obj", "cache", "iat", "pool", "nc", "cc", "ca", "ctl", "cp", "cfg", "ctr"], "origin_par": ["origin__par", " origin_pol", "origin_rel", "origin_pol", "origin__param", "originerhar", "translation_rel", "translationetypar", " origin_har", "origin_comp", "origin_prep", "origin___pol", "origin_pair", "originityhar", " originerhar", "translation_prep", "origin_pas", "origin_part", "originetyprep", " origin_part", "originetyrel", "originitypas", "originetypair", "translationetyrel", "origin___comp", " origin_param", "origin__comp", " origin_pas", "originerpas", "originetypar", "originitypar", "translationetyprep", " originercomp", "origin___part", "origin___par", " originerpar", "origin_har", " origin_comp", "origin_param", "originitycomp", "translation_par", "translation_pair", "originercomp", " originerpas", "originerpar", "translationetypair"], "fr": ["fn", "rn", "FR", "arr", "fm", "fw", "fb", "jp", "tr", "pol", "fp", "mt", "nd", "ff", "ptr", "br", "rt", "pr", "fi", "res", "fin", "dr", "ch", "fd", "iat", "fc", "fl", "fram", "tf"], "fmt_ctx": ["flt_mk", "fmt_context", "fmt_mk", "flt_tx", "flt_cmd", "ftx_co", "flt_ctx", "fmt_tx", "ftx_ctx", "fmt_pkg", "fmt_dict", "ftx_pkg", "flt_dict", "fmt_cmd", "ftx_tx", "ftx_context", "fmt_co", "flt_context"], "video_stream": ["video___stage", "radio___stage", "video_host", "video\u064efield", "video___stack", "Video_stream", "radio___stick", "visual_stack", "radio_stream", "Video_Stream", "video_query", "radio___stream", "video_field", "Video_path", "visual_field", "video_path", "video____stage", "video_stack", "videoplestage", "video___iterator", "video___field", "video____stick", "video_stick", " video_Stream", "video___query", "video____stream", "video\u064estream", "radio___iterator", "video____iterator", "video___stick", "video_stage", "video\u064estack", "Video_host", "visual_query", "radio_stick", "video2Stream", "video2form", "video2stream", "visual_stream", "video_iterator", "video_form", "radio_iterator", "videoplestream", "videopleiterator", " video_form", "video_Stream", "video\u064equery", "videoplestick", "radio_stage", "video___stream"], "result": ["duration", "cert", "all", "message", "ret", "this", "process", "value", "err", "progress", "length", "goal", "answer", "count", "unknown", "none", "user", "contact", "rar", "cur", "folder", "function", "event", "res", "division", "feature", "term", "zero", "success", "sql", "successfully", "chain", "type", "name", "response", "create", "comment", "make", "list", "back", "relation", "complete", "power", "trace", "results", "important", "data", "coord", "status", "true", "db", "new", "mark", "uu", "public", "instance", "ception", "false", "number", "r", "task", "database", "score", "table", "reason", "total", "description", "def", "currency", "proc", "ptr", "Result", "report", "integer", "obj", "diff", "valid", "rc", "final", "ver", "record", "RESULTS", "notice", "current", "fac", "code", "created", "test", "tr", "error", "date", "json"], "i": ["n", "ij", "p", "t", "it", "a", "si", "r", "index", "f", "m", "y", "x", "I", "c", "ti", "z", "li", "ci", "mi", "ii", "pi", "b", "v", "l"], "j": ["n", "aj", "ij", "p", "t", "r", "m", "ji", "ind", "jp", "z", "shift", "jc", "k", "jump", "J", "q", "js", "g", "pos", "kj", "json", "b", "l", "v", "jj"], "start_ts": ["start_ds", "startpytile", "art_ds", "start_te", "start_times", "startxds", "start67te", "art_ts", "start_ptr", "start67ts", "origin67tile", "origin_ts", "startxts", "st_ts", "start_tes", "start_ms", "st_times", "startpyts", "origin_tile", "startxtes", "startxpoints", "art_tes", "start_points", "origin67ts", "startpytes", "startpyte", "start_tile", "start67tile", "start67tes", "origin67tes", "st_ptr", "origin_tes", "origin67te", "art_points", "origin_te", "st_ms"], "end_ts": ["end_times", " end_tp", "end__ms", "end_tes", "end_ms", "endmmtimes", " end_times", " end_ms", "end_tile", "end__times", "end_points", "endmmtile", " end_tes", "end__ts", " end_points", "endmmtp", "end__tes", "endmmts", "end_tp", " end_tile"]}}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330, "substitutes": {"bus": ["loop", "way", "cat", "os", "boot", "gate", "back", "hub", "us", "ac", "sync", "driver", "bs", "board", "bridge", "user", "bc", "conn", "Bus", "c", "mount", "host", "handle", "local", "proc", "connection", "base", "hand", "lock", "aux", "ctx", "link", "BUS", "book", "box", "dev", "ux", "usb", "http", "config", "util", "block", "store", "bug", "b", "cast", "route", "handler", "lib", "chain"], "cmd": ["comm", "name", "resp", "msg", "txt", "kt", "iq", "quit", "find", "func", "cont", "kind", "cb", "force", "check", "Cmd", "offset", "act", "method", "ct", "pkg", "count", "text", "id", "def", "ctrl", "ext", "code", "cd", "good", "md", "handle", "cmp", "cli", "cur", "content", "col", "prop", "op", "cod", "ctx", "request", "mode", "bind", "send", "seq", "auth", "addr", "cf", "kick", "config", "nt", "command", "action", "that", "req", "job", "crit", "form", "gen", "Command", "ctl", "cp", "cfg", "ctr", "type"], "address": ["enable", "reference", "start", "message", "context", "a", "resource", "number", "memory", "index", "ai", "record", "m", "length", "offset", "attribute", "add", "order", "condition", "table", "image", "description", "x", "id", "array", "trace", "before", "size", "ip", "base", "request", "ptr", "position", "padding", "operation", "exclusive", "Address", "location", "addr", "shape", "direction", "at", "error", "prefix", "command", "action", "pc", "interface", "block", "ace", "range", "path", "store", "each", "pointer", "port", "pi", "route", "point", "distance", "chain", "alias"], "len": ["n", "fun", "resp", "en", "all", "t", "list", "del", "Len", "h", "length", "offset", "late", "mid", "wid", "val", "pl", "loc", "lp", "id", "lan", "ld", "lon", "size", "bytes", "vec", "le", "no", "limit", "lang", "lim", "li", "ls", "ptr", "full", "num", "lic", "seq", "addr", "iter", "fin", "mem", "ln", "nt", "sp", "pos", "nl", "lis", "ll", "elt", "lf", "l", "Length", "el", "syn", "L"], "data": ["n", "name", "p", "t", "response", "message", "a", "list", "m", "device", "length", "value", " dat", "rel", "offset", "window", " buffer", "table", "d", "ata", "format", "def", "empty", "mu", "str", "partial", "size", "bytes", "batch", "connection", "buf", " payload", "extra", "DATA", "dat", "res", "buffer", "addr", "ad", "Data", "nt", "command", "block", "bin", " DATA", "next", "pointer", " Data", "padding", "text"], "i2c_bus": ["i2c_home", "i2C_ack", "i2c_ack", "i2e_boot", "i2c__base", "i2c___client", "i2c67ack", "i2c2controller", "i2C_hub", "i2gc___queue", "i2c_hub", "i2gc___config", "i2c__Bus", "i2cmyhub", "i2cm_board", "i2C_base", "i2c4boot", "i2c2boot", "i2gc___client", "i2c___bus", "i2c_config", "i2C_Bus", "i2sc_bus", "i2C_config", "i2cm_bar", "i2c_controller", "i2c___config", "i2c_box", "i2con_box", "i2C_client", "i2c__bus", "i2cm_boot", "i2cpyboot", "i2c2bus", "i2con_controller", "i2c67Bus", "i2c_base", "i2c2box", "i2c___queue", "i2c_Bus", "i2cmybus", "i2c_board", "i2cpybar", "i2cmyhome", "i2e_box", "i2sc_boot", "i2c_boot", "i2cpyboard", "i2gc_config", "i2C_home", "i2c4config", "i2c_queue", "i2c_cos", "i2C_boot", "i2c_client", "i2con_boot", "i2gc___bus", "i2con_bus", "i2gc_client", "i2c__ack", "i2gc_bus", "i2cmyBus", "i2cpybus", "i2c4bus", "i2sc_device", "i2C_bus", "i2sc_box", "i2c4client", "i2e_cos", "i2c_device", "i2e_bus", "i2gc_queue", "i2c_bar", "i2c67base", "i2c67bus", "i2cm_bus"], "i": ["bi", "n", "t", "phi", "is", "p", "out", "it", "a", "si", "me", "di", "index", "iu", "ai", "xi", "f", "m", "ix", "y", "init", "multi", "zi", "key", "x", "e", "ind", "sim", "gi", "info", "I", "c", "s", "qi", "ki", "cli", "j", "ip", "li", "ui", " bi", "abi", "in", "ci", "sp", "mi", "ii", "pi", "l", "b", "v", "point", "uri", "type"]}}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 22361, "substitutes": {"c": ["n", "p", "t", "rc", "a", "this", "cont", "ce", "f", "dc", "m", "h", "co", "gc", "ct", "d", "con", "cs", "e", "ctrl", "cv", "s", "ec", "C", "ctx", "lc", "cm", "self", "cf", "ci", "config", "cam", "tc", "conf", "u", "nc", "cc", "b", "v", "fc", "ca", "cp", "chain", "w"], "lumFilter": ["lulFil", "limSort", "limFilter", "lulfilter", "lumaSort", "lulSort", "lumSort", "lumaFilter", "limFil", "lumfilter", "LimFilter", "LimFil", "limfilter", "LumSort", "lulFilter", "lumafilter", "lumFil", "Limfilter", "lumaFil", "Lumfilter", "LumFil", "LumFilter", "LimSort"], "lumSrc": ["lutSrc", "lumSources", "lumVSrc", "lutVSRC", "lumVSvc", "lumVSources", "lumVsRC", "lumSvc", "lumVsvc", "lutVSrc", "lumSRC", "lutSources", "lutSvc", "lutVSvc", "lutSRC", "lumVSRC", "lumVsrc", "lutVSources", "lumVsources"], "lumFilterSize": ["lamBlockStyle", "lumBlockSize", "lamBlockLength", "lumBlockSIZE", "lamBlockSIZE", "lumStreamLength", "lumFilterLength", "lumFilterStyle", "lumBlockLength", "lumMaskStyle", "lumMaskSIZE", "lumStreamStyle", "lumMaskSize", "lamBlockSize", "lumStreamSize", "lamFilterSize", "lumStreamSIZE", "lamFilterSIZE", "lumFilterSIZE", "lumMaskLength", "lamFilterLength", "lamFilterStyle", "lumBlockStyle"], "chrFilter": ["CharFilter", "chrtFil", "chrtSpec", "chroFilter", "CharSpec", "ChrFilter", "ChrChannel", "CharChannel", "chrChannel", "chroSpec", "chrFil", "charFil", "chrtFilter", "chrtChannel", "chrSpec", "charChannel", "ChrFil", "chroChannel", "CharFil", "charSpec", "chroFil", "charFilter", "ChrSpec"], "chrUSrc": ["charSRC", "chrRSr", "chrRSRC", "chrSSfx", "chrSrc", "chrRSfx", "charSfx", "chrRSrc", "chrSr", "chrSfx", "charUSr", "chrUSfx", "chrUSr", "chrUSRC", "charUSrc", "charUSfx", "charSr", "charUSRC", "chrSSRC", "chrSRC", "chrSSrc", "charSrc", "chrSSr"], "chrVSrc": ["chrVSock", "chrVsock", "charVSrc", "chrVssrc", "chrVsrc", "charVssrc", "charVSsrc", "chrFSsrc", "chrFSock", "chrFSRC", "chrMSsrc", "chrVSsrc", "chrVSRC", "charVsock", "charVsRC", "charVSRC", "chrMSRC", "chrVsRC", "charVSock", "charVsrc", "chrMSrc", "chrFSrc", "chrMSock"], "chrFilterSize": ["chrsMaskMode", "chrfilterStyle", "chrMaskMode", "chrFilterMode", "chrfilterSIZE", "chrMaskStyle", "chrSortSize", "chrfilterMode", "chrsMaskSize", "chrSortMode", "chrFilterStyle", "chrsFilterSize", "chrFilterSIZE", "chrsFilterMode", "chrsFilterSIZE", "chrSortSIZE", "chrsMaskStyle", "chrMaskSIZE", "chrSortStyle", "chrfilterSize", "chrMaskSize", "chrsFilterStyle", "chrsMaskSIZE"], "alpSrc": ["alpsRsvc", "alpSvc", "alpRsr", "alpRsrc", "alpRsRC", "alpSr", "alpPsRC", "alpSRC", "alpsRsrc", "alpsRsRC", "alpPsrc", "alpPsr", "alpsSr", "alpPsvc", "alpsSvc", "alpsSrc", "alpsRsr", "alpsSRC", "alpRsvc"], "dest": ["master", "orig", "end", "way", "cas", "usr", "source", "Dest", "gate", "desc", "transform", "win", "table", "d", "src", "loc", "id", "target", "data", "st", "temp", "comb", "spec", "est", "wb", "shape", "iter", "mem", "rest", "trans", "path", "ident", "port", "dist", "v", "origin", "pas", "w"], "uDest": ["uuDist", "ucSync", "uAdd", "uDesc", "UDest", "uDist", "usQueue", "UTarget", "uuSync", "uuAdd", "uuQueue", "nuNow", "vTarget", "nuDest", "usDesc", "uQueue", "aDesc", "vDist", "uLoc", "nuDesc", "nuSync", "uTarget", "ucDest", "usAdd", "ucNow", "uuDest", "uNow", "uuTarget", "uuLoc", "usDest", "uuDesc", "vLoc", "ucDesc", "ULoc", "uSync", "aQueue", "aAdd", "uuNow", "UDist"], "vDest": ["gDest", "vDecl", "bDesc", "evNeg", "evDecl", "cvdest", "vEast", "VNeg", "gdest", "cvDest", "VDecl", "bdest", "VRest", " vRest", "bEast", " vNeg", "gDesc", "cvDesc", "vdest", "evRest", " vDecl", "vNeg", "cvEast", "gEast", "VDest", "evDest", "vDesc", "bDest", "vRest"], "aDest": ["ARest", " aWorld", "anTrans", "ADoc", "aaDest", "AQueue", "anDoc", "anQueue", "aTarget", "ADest", " aTrans", "aWorld", " aTarget", "vWorld", " aQueue", "adest", "aDesc", "aTrans", " adest", "aaTarget", "vdest", " aRest", " aDesc", "aRest", "nDest", "aDoc", " aDoc", "anDest", "Adest", "ATrans", "aQueue", "AWorld", "aaDesc", "nDesc", "nTarget", "vRest"], "dstW": ["udstV", "deltaW", "destV", "deltaV", "dstWin", "dstWI", "dpiWin", " destV", "dSTV", "destH", "drestW", "DsrcWin", "dstV", "deltaWI", " destW", "DstV", "drendW", "dsrcW", "dpiW", " dstBW", " destWidth", " dstV", "dputV", "dsrcV", "udstWe", "dSTBW", "dstBW", "DstWin", "dstH", "dstWe", "drestV", "dputBW", " destBW", "dpiV", "dsrcWin", "udstW", "udstH", "dSTWidth", "DstWI", "DsrcW", "DsrcWI", "udrendH", "destWe", "drestWe", "DstW", "dsrcWI", "drendWe", "dSTW", "destW", "dputWidth", " dstWidth", "udrendW", "destBW", "drestH", "drendH", "udrendWe", "udrendV", "destWidth", "dpiWI", "drendV", "DsrcV", "dstWidth", "deltaWin", "dputW"], "chrDstW": ["chrDrcC", "chrDestW", "chrLstR", "chrdstM", "chrDndW", "chrdSTM", "chrDstrN", "chrLstN", "chrDstM", "chrdstB", "chrDSTS", "chrLSTN", "chrDstrW", "chrDndS", "chrDSTH", "chrDstrH", "chrLstH", "chrdSTB", "chrdstN", "chrdstW", "chrLSTH", "chrDrcH", "chrDestM", "chrDSTW", "chrLSTC", "chrLSTBW", "chrDstR", "chrLstC", "chrDstC", "chrDrcB", "chrDSTBW", "chrDstS", "chrdSTN", "chrDrcW", "chrDndC", "chrdSTW", "chrDSTR", "chrLSTR", "chrDrcN", "chrLstW", "chrDstrR", "chrDrcBW", "chrDrcS", "chrDSTC", "chrDSTM", "chrDrcM", "chrLSTW", "chrDstB", "chrLstS", "chrLstBW", "chrDrcR", "chrDSTN", "chrDndBW", "chrLSTS", "chrDestN", "chrDstN", "chrDstH", "chrDstBW", "chrDSTB", "chrDestB"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 22364, "substitutes": {"errp": ["errps", "erp", "erps", " errpid", "errpid", "errP", " erP", " erp", " errps", "erpid", " erps", "erP", " erpid", " errP"], "info": ["is", "app", "io", "value", "debug", "fo", "user", "on", "meta", "ti", "warning", "details", "now", "event", "ui", "auth", "job", "command", "success", "about", "local", "type", "name", "Info", "state", "response", "start", "py", "ion", "comment", "list", "api", "note", "i", "trace", "data", "status", "op", "link", "num", "entry", "pretty", "inner", "edit", "update", "t", "time", "it", "one", "ref", "f", "summary", "exec", "by", "table", "image", "description", "def", "good", "ready", "ip", "detail", "parse", "request", "utils", "always", "report", "try", "jo", "import", "config", "information", "conf", "cache", "obj", "to", "pi", "inf", "alias", "history", "index", "INFO", "off", "check", "notice", "init", "item", "id", "row", "admin", "query", "test", "content", "version", "help", "iter", "doc", " Info", "error", "http", "interface", "address", "json", "option"], "s": ["is", "sing", "su", "m", "ims", "ops", "sts", "ds", "sis", "details", "sv", "sw", "hs", "xs", "params", "less", "sb", "as", "v", "sl", "n", "state", "response", "a", "os", "single", "changes", "ns", "bs", "i", "aws", "sm", "sets", "vs", "dev", "g", "ts", "b", "comm", "t", "sys", "sym", "f", "sf", "y", "stats", "ps", "times", "args", "c", "z", "spec", "ls", "ies", "S", "its", "obj", "store", "series", "p", "bits", "set", "parts", "h", "ss", "ses", "sports", "rs", "gs", "south", "ms", "js", "sq", "ges", "w"]}}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365, "substitutes": {"bs": ["ubis", "blog", "sys", "lbs", "bits", "ks", "ubs", "ss", "BS", "ns", "bps", "ses", "aos", "ps", "cs", "bc", "sts", "fs", "rs", "gs", "ds", "bis", "s", "ls", "aks", "bh", "ms", "bles", "vs", "ats", "bes", "cms", "js", "its", "ts", "als", "aus", "pb", "acs", "qs", "sb", "bas", "b", "bos", "bp", "cks", "uts", "bb", "irms"], "bitnum": ["intNum", "bitmult", "boolnm", "boolum", "blockNum", "Bitum", " bitno", "Bitnum", "blocknm", "intum", "blockno", "blockNUM", "intmult", "blocknum", "bitenum", "intNUM", "BitNUM", "bitNum", "bitnm", "intnum", "bitno", " bitNUM", "intenum", "Bitmult", " bitNum", "bitNUM", "blockenum", " bitmult", "blockum", "bitum", " bitenum", " bitum", "boolno", " bitnm", "boolnum"], "bitmap": ["bitwise", "bandap", "bitscache", "BITMap", "BITmaps", "BITmask", "taskmap", "shotrix", "bitopen", "bitcode", "beatopen", "bitsmap", " bitcode", "wordopen", " bitmaps", "byteset", "bandmask", "bandmap", "barcode", " bitwise", " bitmatch", "bitset", "bitmatch", "BITmap", "Bitmaps", "Bitmask", "gitopen", "taskmatch", "bandlay", "worddate", "latmap", " bitrix", "shotmap", "Bitset", " bitmask", "bytemap", "binmask", "beatlay", " bitMap", "BITcode", "binlay", "bitmaps", "bitlay", "bitrix", "barcache", "gitap", "latwise", "shotMap", "gitmap", " bitset", "bitmaster", "binap", "barmaps", "BITcache", "BitMap", "bitcache", "bitsmask", "latMap", " bitmaster", "beatap", "wordap", "shotwise", "laymap", "layrix", "wordmap", "barmap", "beatmask", "Bitcode", "beatmap", "bytemaps", "bitsmaster", "byteMap", "BITmaster", "beatdate", "laymatch", "bitmask", "binmap", "gitdate", "bitdate", "Bitmap", "bitap", "bitMap", "latrix", " bitcache", "taskrix"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int voc_probe(AVProbeData *p)\n\n{\n\n    int version, check;\n\n\n\n    if (p->buf_size < 26)\n\n        return 0;\n\n    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n\n        return 0;\n\n    version = p->buf[22] | (p->buf[23] << 8);\n\n    check = p->buf[24] | (p->buf[25] << 8);\n\n    if (~version + 0x1234 != check)\n\n        return 10;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 22379, "substitutes": {"p": ["er", "t", "vp", "it", "a", "r", "o", "app", "ping", "f", "m", "tp", "pm", "progress", "y", "d", "post", "pkg", "pro", "pt", "pp", "lp", "power", "ps", "wp", "c", "pa", "php", "jp", "j", "ap", "proc", "fp", "pod", "buf", "parse", "op", "P", "q", "dp", "up", "at", "ad", "g", "sp", "rep", "pc", "pb", "np", "pg", "cache", "pre", "b", "bp", "v", "pat", "pi", "cp", "l", "pd", "w"], "version": ["name", "time", "view", "tag", "ver", "bolt", "ion", "number", "index", "length", "release", "scale", "debug", "transform", "serial", "order", "hash", "format", "Version", "power", "package", "mint", "code", "x", "info", "data", "test", "size", "connection", "status", "VERSION", "lock", "server", "major", "value", "patch", "feature", "update", "action", "command", "vision", "iso", "v", "versions", "option", "type"], "check": ["ok", "core", "valid", "search", "out", "view", "start", "ck", "ver", "Check", "comment", "print", "force", "look", "value", "score", "read", "add", "rank", "key", "call", "id", "code", "info", "max", "test", "query", "fail", "c", "bit", "handle", "cmp", "status", "checked", "op", "CHECK", "checks", "q", "control", "equal", "help", "match", "find", "block", "cmd", "update"]}}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381, "substitutes": {"f": ["fx", "fn", "t", "p", "it", "bf", "o", "fal", "r", "m", "h", "sf", "y", "window", "ac", "fo", "d", "fac", "uf", "fm", "e", "um", "i", "fs", "fw", "c", "fb", "j", "fp", "fr", "z", "ff", "ft", "far", "full", "q", "fi", "rf", "xf", "cf", "g", "ile", "fd", "conf", "form", "F", "af", "lf", "b", "l", "fc", "v", "file", "tf", "w"], "opaque": ["Opaque", "popent", "popbuffer", "Opbuffer", "compbuffer", "opent", "poplay", "opbuffer", "Opent", "compaque", "popaque", "Oplay", "complay", "oplay", "compent"], "version_id": ["version__info", "version_is", "recordationrid", "dimensionTypeuid", "version__Id", "version_ID", "version__ID", "ver_info", "ver_t", "versionalid", "versionationname", "version_name", "versionalbit", "dimensionTypei", "ver_no", "version_ide", "program_t", "dimensionTypeid", "ver_Id", "program_id", "dimension_id", "version__id", "dimension_i", "versionationi", "versionTypeid", "ver_ID", "versionationid", "versionationis", "program_bit", "record_name", "version_rid", "version_t", "version_bit", "versionationId", "versionTypeis", "versionationuid", "program_name", "versionalt", "programalname", "record_id", "programalid", "programalt", "versionationide", "record_rid", "programalbit", "dimension_uid", "versionationno", "dimension_is", "versionTypei", "versionTypeuid", "dimensionTypeis", "versionationrid", "version_no", "recordationide", "recordationname", "versionationt", "version_Id", "version_uid", "versionalname", "ver_id", "version_i", "record_ide", "version_info", "recordationid"], "addr": ["ret", "ack", "ash", "loc", "mask", "eth", "ress", "map", "pos", "work", "elt", "port", "start", "access", "a", "ix", "order", "x", "i", "oad", "size", "mt", "adr", "at", "dr", "mem", "cmd", "nl", "ident", "lat", "r", "arp", "ref", "hash", "act", "gc", "mb", "url", "inter", "tx", "max", "aff", "ip", "mac", "hw", "points", "ptr", "ad", "np", "obj", "attr", "alias", "p", "build", "end", "rc", "alloc", "ach", "off", "offset", "add", "ac", "init", "src", "rs", "arch", "ord", "align", "hl", "Address", "address", "pad"], "flags": [" Flags", "ports", "links", "bits", "heads", "uses", "aps", "weights", "parts", "alf", "tags", "bugs", "acts", "type", "orts", "goal", "stats", "ints", "FLAG", "allows", "mask", "cs", "times", "fs", "rs", "args", "comments", "olds", "locks", "states", "planes", "fp", "fr", "details", "checks", "ptr", "sets", "ats", "lines", "properties", "types", "grades", "vals", "levels", "wcs", "cf", "posts", "ts", "ants", "fd", "Flags", "cmd", "features", "ags", "nl", "conf", "options", "actions", "members", "flag", "limits", "lag", "cons", "fields"], "id": ["name", "p", "end", "start", "it", "tag", "a", "oid", "ids", "ide", "index", "ref", "h", "aid", "hash", "head", "ID", "mid", "init", "key", "mask", "code", "i", "str", "tx", "data", "bit", "info", "md", "ip", "pid", "iden", "link", "map", "rid", "od", "Id", "ad", "mem", "iter", "in", "fd", "address", "sid", "kid", "ident", "line", "uid", "bid", "type"], "length": ["duration", "name", "volume", "history", "loop", "end", "distance", "time", "L", "capacity", "number", "index", "h", "root", "offset", "head", "SIZE", "piece", "title", "value", "count", "ength", "total", "description", "loc", "display", "str", "join", "data", "max", "test", "size", "limit", "base", "family", "height", "ptr", "position", "operation", "buffer", "shape", "location", "rest", "sequence", "sp", "path", "command", "term", "next", "last", "ENGTH", "l", "Length", "line", "pad", "padding", "chain", "type"], "block": ["name", "out", "model", "pack", "frame", "list", "set", "record", "group", "container", "field", "hash", "bl", "object", "piece", "key", "image", "x", "label", "bc", "info", "join", "bit", "row", "data", "cl", "byte", "snap", "base", "Block", "lock", "word", "link", "k", "part", "map", "buffer", "box", "in", "unit", "range", "prefix", "bin", "blocks", "BL", "obj", "line", "b", "blocking", "header", "chain", "type"], "len": ["coll", "en", "ref", "Len", "bl", "wid", "count", "val", "pl", "loc", "lp", "label", "lan", "il", "ld", "lon", "tl", "size", "lt", "no", "kl", "lang", "lim", "col", "lock", "buf", "li", "wl", "ls", "num", "seq", "hl", "lc", "iter", "fin", "mem", "ln", "nt", "nl", "pos", "ll", "slice", "lf", "elt", "l", "fl", "el", "sl", "L"], "host": ["cert", "master", "ost", "proxy", "context", "index", "container", "wrapper", "boot", "h", "hub", "root", "null", "hash", "head", "domain", "object", "ha", "th", "vr", "conn", "target", "slot", "node", "handle", "arch", "hd", "hw", "ip", "hand", "ghost", "hook", "here", "bind", "hard", "server", "localhost", "sh", "console", "home", "self", "dev", "iter", "dr", "mem", "http", "path", "Host", "address", "pool", "client", "browser", "local", "chain"], "ch": ["sch", "cho", "ht", "bits", "ssh", "zh", "high", "CH", "wh", "ach", "chan", "ich", "h", "y", "hash", "channel", "th", "ct", "x", "cs", "i", "tch", "cd", "c", "cl", "arch", "cht", "z", "col", "height", "ih", "och", "resh", "br", "Ch", "chip", "sh", "ph", "kh", "sc", "cmd", "ech", "v", "cp", "cha", "w"]}}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 22387, "substitutes": {"common": ["comm", "name", "core", "specific", "parent", "general", "com", "basic", "normal", "present", "bolt", "standard", "non", "one", "java", "set", "qualified", "processor", "check", "m", "summary", "pro", "unknown", "current", "con", "onet", "initial", "admin", "cli", "no", "san", "base", "low", " Common", "ctx", "other", "clean", "shared", "server", "un", "some", "new", "given", "inner", "runner", "global", "command", "from", "util", "plain", "cmd", "conf", "an", "ordinary", "to", "uch", "local", "known", "public", "Common", "primary"], "errp": ["ErP", "erp", "errps", "errP", " errping", "Erping", "errpa", "errd", " errper", "errpress", " errd", " errP", "errorper", "died", "rrpa", "rrd", " errpa", "erping", "riskP", "riskper", "Erp", " errps", "errping", "errorpress", "rrps", " errpress", "errorp", "erP", "errorP", "dieps", "diep", "rrp", "riskpress", "diepa", "riskp", "errper"], "state": ["name", "scope", "is", "out", "start", "tag", "resource", "all", "message", "print", "where", "this", "private", "set", "stat", "State", "task", "list", "type", "check", "policy", "index", "process", "session", "init", "stats", "change", "count", "style", "power", "trace", "info", "operator", "test", "st", "states", "body", "connection", "status", "base", "result", "see", "estate", "version", "spec", "event", "position", "un", "self", "we", "component", "rule", " states", "area", "unit", "runner", "update", "that", "action", "command", "job", "config", "ace", "form", "store", "port", "STATE", "monitor", "local", "public", "instance"], "bs": ["bi", "blog", "was", "is", "lbs", "sys", "bits", "cb", "os", "ubs", "bed", "bal", "ns", "BS", "bps", "aos", "us", "outs", "gb", "ps", "lb", "las", "cs", "bc", "socket", "fs", "gs", "rs", "sts", "ds", "bis", "ab", "bo", "ctx", "ls", "bm", "bh", "bg", "vs", "vals", "bes", "js", "its", "has", "ts", "obs", "pb", "bu", "sb", "bos", "b", "bp", "cks", "bas", "bb", "serv"], "backup": ["buckcp", "backp", "buckp", "backshot", "lookap", "backcp", "drout", "lookout", "checkdown", "backap", "backone", "drup", "buckup", "buckshot", "checkout", "checkupid", "cleanup", "saveap", " backshot", "Backout", "pickdown", "pickupid", "saveup", "pickup", "cleanone", "lookdown", "backout", "Backone", "drupid", "pickout", "Backcp", "Backp", "saveupid", "checkup", "cleanout", "lookup", "Backap", "cleanupid", " backcp", "lookupid", "Backupid", "Backup", "backupid", "backdown", "Backshot", "drone", " backp"], "local_err": [" local_dr", "global_er", " local_buf", "local____err", "client_err", "personal_err", " local_er", "personal_arr", "local_error", "global_msg", "personal_er", "local_buf", "global_r", "local____iter", "local_arr", "client____msg", "global_err", "client____err", "personal_error", "local____attr", "local_msg", "local____msg", "local_iter", "client____attr", "local_dr", "local_attr", "client_attr", "local_r", "client_iter", "local_er", "client_msg", "client____iter"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n", "idx": 22389, "substitutes": {"ctx": ["kw", "Context", "mk", "sys", "txt", "vc", "context", "ck", "kt", "rc", "cb", "dc", "ac", "act", "gc", "ct", "etc", "pkg", "ctrl", "conn", "bc", "tk", "cv", "tx", "c", "jp", "cmp", "cur", "hw", "wx", " cx", "tmp", "cm", "cf", "xs", "nt", "mc", "req", "cmd", "tc", "obj", "nc", "cc", "ca", "cp", "cfg", "ctr", "xc"]}}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n", "idx": 22392, "substitutes": {}}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399, "substitutes": {"env": ["er", "en", "rc", "org", "context", "eh", "param", "et", "set", "te", "window", "code", "conn", "e", "cv", "ec", "disk", "proc", "hw", "setup", "exc", "estate", "ptr", "here", "environment", "server", "pe", "map", "viron", "dev", "doc", "erd", "config", "cmd", "Environment", "conf", "ew", "eng", "v", "shell", "net", "ev", "vt"], "ctx": ["kw", "Context", "jac", "mk", "msg", "context", "kt", "ck", "alloc", "func", "cb", "index", "dc", "window", "exec", "co", "act", "conv", "ct", "pkg", "etc", "tz", "loc", "x", "unc", "ctrl", "conn", "tk", "cu", "timeout", "cv", "tx", "jp", "cmp", "hw", "ork", "wx", "aux", " cx", "tmp", "kh", "sc", "cf", "mem", " context", "nt", "that", "std", "np", "cmd", "tc", "obj", "crit", "cache", "req", "acl", "conf", "iat", "inst", "cc", "ctl", "cp", "cas", "xc"], "eaddr": ["edDR", "elldr", "edddr", "adstr", "eddDR", "decpr", "oadptr", "decdr", "ewaysr", "eadsr", "earDR", "ewDR", "eadrd", "ddrd", "dddr", "ankstr", "oadDR", "ewayDr", "decrd", "ddptr", "ellr", "ellhr", "eardr", "oaddr", "ankder", "eadDR", "adder", "ewaydr", "adDR", "awsr", "eadstr", "reamr", "earsr", "edr", "preadpr", "decptr", "preadrd", "oadhr", "ewayDR", "ewstr", "awdr", "ewder", "ewdr", "eadr", "reamhr", "reamdr", "preaddr", "addr", "ankDR", "eadptr", "oadr", "eadder", "edptr", "earDr", "eddr", "eddptr", "ankdr", "eadhr", "eadDr", "awDR", "awDr", "ddpr", "eadpr", "preadptr"], "rw": [" shr", "resp", "rc", "rn", "usr", " wr", "shr", "write", "rew", "window", "aw", "src", "wire", "rs", "wr", "asm", "hw", "rt", " sr", " resp", "rl", "req", "ew", "ry", "ctr", "rd", "w"], "type": ["name", "ype", "t", "time", "state", "p", "Type", "tag", "ver", "r", "kind", "tp", "rel", "TYPE", "count", "style", "weight", "test", "ptr", "rt", "pe", "buffer", "rule", "types", "error", "typ", "ty", "ry"], "hash": ["ashes", "tag", "ssh", "print", "esh", "shr", "ref", "oh", "h", "sum", "check", "err", "filter", "inv", "ash", "key", "id", "array", "str", "data", "test", "tr", "Hash", "flash", "result", "shift", "height", "hz", "sh", "html", "kh", "hat", "rh", " h", "addr", "ch", "has", "match", "ah", "sha"], "vsid": ["VSId", "VSID", "VSidem", "vesID", "fsId", "changesID", "uesident", "uesider", "kside", "csident", "uesiden", "VSids", "vsider", "psolid", "csz", " vsiter", "jsidem", "VS_", "lsider", "ksID", "lsID", " vsidem", "psiden", "Vsoid", "jsider", "imsid", "imsider", "vside", " vsz", "fsidem", "valuesiter", "lsolid", "lsoid", "hsigil", "hsid", "obsiden", "portsid", "portsidem", "Vsiter", "postsid", "postsID", "rsidem", "gsident", "obsigil", "portsident", "vsids", "hsId", "VSident", "vesidem", "Vsidem", " vside", "vsidem", "portsID", "obsID", "vsz", "ls_", "hsider", "rshid", "psident", "changesidem", "vesname", "VSname", "csids", "vsId", "valsID", "vsigil", "VSid", "csID", "vsolid", "changesoid", "nsidem", "psid", "obsident", "VSigil", "hsident", "lsidem", "Vsid", "jsid", "termsoid", "vesid", "VSz", "portshid", "gside", "VSide", "ksidem", "csidem", "valsidem", "psider", "vsname", "imsidem", "valuesid", "ksident", "vesident", "nsID", "lsid", "fsID", "vshid", "VShid", "portsiden", "csid", "hsiden", "valuesoid", "uesid", "fsid", "cside", "vsident", " vsids", "v_", "hsID", "vs_", "changesid", "valuesidem", "ksname", "valsoid", "imshid", "jsID", " vsoid", "obsid", "VSiden", "vsID", "hsidem", "postsId", "gsid", "vsiden", "vsoid", "termsID", "lsident", "termsid", "valsident", "psoid", "gsID", "nsid", "valsId", "nsId", "obshid", "ksid", "postsidem", "vsiter", "rsid", "termsidem", "valsid", "valsolid", "rsID", "imsID"], "pr": ["expr", "lr", "mr", "rev", "print", "r", "prov", "shr", "rem", "PR", "err", "spr", "rel", "por", "vr", "pir", "val", "ps", "pt", "rr", "pl", "po", "pro", "pri", "rs", "wr", "tr", "rer", "rate", "pol", "hr", "fr", "repl", "ptr", "br", "kr", "res", "dr", "ocr", "prime", "rot", "rep", "pc", "typ", "cr", "Pr", "serv"], "target_page_bits": ["target_pagelybits", "target_page_words", "target_node_bits", "target_page__bytes", "target_page_details", "target_page_pieces", "target_line_its", "target_node_details", "target_page32pieces", "target_page32bytes", "target_pagelyslot", "target_page__its", "target_node_points", "target_page_points", "target_page_parts", "target_line_bytes", "target_page32bits", "target_line_words", "target_line_bit", "target_line_bits", "target_page_bytes", "target_page_keys", "target_line_parts", "target_page__words", "target_pagelykeys", "target_node_its", "target_page_bit", "target_page_slot", "target_page__bits", "target_age_bits", "target_age_slot", "target_age_keys", "target_page_its"], "ret": ["resp", "re", "pert", "lit", "rev", "ref", "rem", "rel", "Ret", "val", "nz", "def", "reset", "mt", "ft", "rt", "res", "alt", "mem", "nt", "RET", "len", "ll", "elt", "flag", "net"], "ret2": [" ret1", "Ret0", "RET1", "RETpl", "RET2", " retpl", "ret1", "Ret1", "Ret2", "RET0", "Retpl", "retpl", "ret0", " ret0"], "slb": ["tlib", "islob", "mlbe", "svb", "plb", "lsB", "islt", "slbd", "tln", "ssln", "hlbr", "mlgb", "sslt", "rlbd", "sll", "SLib", "sslh", "slbb", "islbb", "SLB", "slt", "SLb", "islB", "lssb", "SLp", "spll", "slib", "hlb", " slh", "slv", "spotbb", "splc", "hlsb", "splgb", "slgb", " slbb", " slB", "isll", "splbr", "plgb", "slob", " slc", "lp", "svB", "lsh", "lsib", "evalb", "islb", "slB", "mlib", "svob", "slp", "splib", "rlv", "sslb", "splob", "snsb", "rlsb", "SLbd", "evalsb", "SLbe", "hlB", "lsbb", "sslgb", "sln", "snb", "helsb", "sslB", "mlbb", "helbd", "mlsb", " slv", "lb", "mlb", "rlb", " slp", "tlb", "slbe", "splbe", "helv", "SLsb", "sslbb", "evalB", "spotb", "lsb", "mlB", " slgb", "slc", "lB", "slbr", "splsb", "splb", "sslv", "islsb", "spln", "slh", "helb", "splB", "tlB", "islv", "sslib", "plc", "slsb", "svl", "snbb", "spotsb", " slib", " slt", "spotB", "evalbr", "plB", "snB", "SLv"], "pageaddr": ["agemap", "pagemap", "rowadd", "pageptr", "agestore", " pageAddress", "portord", "ageaddr", "pageoffset", "serveradr", "nextaddress", "nodeord", "pageast", "phraseaddress", " pageaddress", " pagestore", "phraseaddr", "pageadd", "portaddr", "serverast", "pageAddress", "nextstore", "serveradd", "nodeaddr", "ageptr", " pageptr", "nextaddr", "memoryadd", " pageord", "serveraddr", "rowast", "pageord", "rowaddr", " pageadr", "ageAddress", "rowptr", "nextAddress", "memoryaddr", "pageadr", "ageoffset", "pagestore", "phrasemap", "nodeadr", "rowadr", "phraseptr", "ageaddress", " pagemap", "memoryast", "memoryadr", " pageoffset", "portadr", "rowoffset", "pageaddress"], "segment_bits": ["segment32mask", "selement_mask", "sement_flags", "segment16bits", "selement16mask", "selement16bits", "sement_its", "segment_bytes", "segment32its", "segments_bit", "segment8bytes", "segment2bits", "segment_points", "segments_points", "selement16its", "segment32bits", "segment36flags", "selement_bytes", "sement2bytes", "segment16bytes", "segment2flags", "segments_its", "segment16mask", "segment_jobs", "sement_bytes", "segment_bit", "segment2bytes", "sement2bits", "sement_bits", "segment2its", "selement_its", "selement16bytes", "sement2its", "segments_bits", "segment36bytes", "segment_flags", "selement_bits", "segment_mask", "segment36its", "segment36bit", "segments_bytes", "segment8jobs", "segment16its", "segment36bits", "segments_jobs", "segment32bytes", "segment_its", "segment36points", "segment8its", "segment8bits"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n", "idx": 22413, "substitutes": {"sockfd": ["srcfd", "sockdir", "sOCKFD", " sockedfp", "srcFD", " sockFD", "insockedfd", "sockld", "sinkfp", "sOCKfd", "sinkfd", "insockFD", "insockedfp", "sockfp", "insockld", "sackfp", " sockdir", "srcld", "sockedld", " sockeddir", "sockFD", "sackFD", "sackfd", "sinkdir", " sockedfd", "srcfp", "sockeddir", "sackdir", "sockedfp", "insockfd", "sOCKfp", "insockedFD", "insockedld", "insockfp", "sinkFD", " sockfp", "sockedFD", " sockedFD", "sockedfd", "sOCKld"], "status": ["flags", "state", "response", "sys", "context", "settings", "message", "comment", "source", "index", "stat", "sex", "list", "desc", "check", "STAT", "progress", "sync", "condition", "stats", "reason", "format", "description", "call", "id", "code", "comments", "since", "temp", "result", "version", "security", "spec", "mode", "details", "server", "res", "speed", "console", "active", "sc", "service", "error", "config", "prefix", "params", "date", "tree", "action", "Status", "options", "atus", "ser", "flag", "wait", "type"], "iov": ["ovi", "ij", "comm", "resp", "vector", "john", "org", "iq", "ilo", "rev", "hero", "vi", "iu", "io", "ibr", "isco", "lu", "ior", "conv", "ocy", "rin", "iv", "vr", "iao", "inv", "pkg", "nom", "iour", "rage", "cv", "mu", "liv", "voc", "nov", "imp", "iw", "vec", "iol", "uv", "ia", "ov", "iph", "ivic", "uart", "ir", "phy", "ux", "vo", "verb", "np", "igr", "soc", "cmd", "uj", "iat", "vision", "typ", "ech", "v", "gov", "von", "voice", "icon", "serv"], "msg": ["comm", "man", "name", "mat", "gent", "resp", "alg", "txt", "message", "mess", "frame", "mail", "out", "vol", "stat", "desc", "m", "go", "err", "gm", "notice", "reason", "pkg", "call", "mp", "og", "mu", "str", "node", "tx", "md", "ge", "cmp", "body", "j", "cfg", "col", "mt", "nm", "mg", "module", "ms", "send", "res", "seq", "Msg", "cm", "addr", "reg", "mem", "g", "doc", "dr", "gr", "command", "req", "cmd", "sg", "obj", "game", "gen", "client", "mn", "v", "news", "net", "header"], "cmsg": ["cg", " cog", "ccmsg", " cMsg", "xcmn", "crmy", "cdr", "xcnode", "camcmd", "lcmsg", "lmsg", "camms", "ccmd", "cnode", "ncmn", "pccmd", "lcmn", " cdef", "lmn", "Cmsg", "mmessage", "uncog", " ccmd", "xcmsg", "Cmn", "pcmsg", "cammsg", "pcmessage", "cmy", "lcMsg", "dcmg", "lms", "pcbody", "acmn", "dcg", "acmsg", "dcmessage", "mcMsg", "mcdr", "cccmd", "ncmsg", " cmd", "xcmessage", "conmsg", "ccms", "dcmd", "lcmd", " cmessage", "rcmessage", "cmn", "cmd", "crbody", "unccmd", "dcmsg", "pcmy", " cg", "cog", "mmsg", "Cmessage", "lcdr", "cdef", "crmsg", "dcmy", "uncdef", "lcmessage", "ccmessage", "lcmg", "cMsg", "cbody", "mcmd", "dcmn", "crcmd", "lcnode", "xcmy", " cdr", "cms", "lcg", "mcmsg", "mmd", "condef", "dcbody", "Cnode", " cmn", "conog", "dccmd", "acmessage", "ncmessage", "concmd", "rcmsg", "cmg", "ccmn", "rcmy", "rccmd", " cmg", "cammn", "uncmsg", "cmessage", "xccmd"], "retval": [" retv", "RETVal", "RETvals", "interval", "RetVal", "returnVal", "RETVAL", "returnVAL", "pretVal", " retVal", "RETval", "retVal", " reteval", " retvals", "returnvals", "Reteval", "retvals", "retvalue", "retv", "returneval", "RETv", "altvalue", "pretv", "interVal", "retVAL", "intervalue", "RETeval", "altVal", "reteval", "returnval", "Retval", "pretval", "alteval", "altval", "Retvalue", "interVAL", "intereval", "RetVAL", " retVAL", "preteval"], "data": ["n", "name", "done", "resp", "p", "all", "valid", "start", "rev", "message", "a", "type", "device", "length", "window", "value", "err", "init", "format", "reason", "d", "ata", "x", "def", "dt", "empty", "timeout", "mu", "str", "size", "dl", "step", "bytes", "no", "fail", "base", "version", "buf", "nd", "mode", "DATA", "dat", "res", "buffer", "reg", "area", "fin", "dev", "error", "Data", "action", "command", "zero", "block", "pos", "len", "client", "to", "file", "padding", "text"], "fd": ["td", "fn", "done", "bf", "cb", "dd", "f", "sd", "dir", "d", "wid", "fe", "id", "dt", "fs", "ds", "dl", "pid", "fp", "nd", "fr", "ff", "ctx", "ptr", "df", "fi", "dat", "seek", " fid", "db", "addr", "fin", "ud", "std", "sid", "pos", "lf", "port", "pd", "fc", "fl", "file", "FD", "da", "rd"], "msg_control": ["msg_controller", "message_ctrl", "msg_ctrl", "message_Control", "cmd_ctrl", "cmd_controller", " msg_Control", "message_controller", "msg_rel", " msg_management", "message_ctr", "msg_management", "msg_Control", " msg_ctrl", "message_control", "message_rel", "cmd_control", "cmd_Control", "msg_ctr"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n", "idx": 22417, "substitutes": {"env": ["er", "en", "state", "engine", "end", "rb", "org", "context", "et", "app", "ce", "desc", "ten", "h", "window", "ner", "gear", "enc", "e", "conn", "impl", "code", "ind", "cv", "info", "data", "vm", "ec", "ped", "cur", "jp", "proc", "worker", "hw", "esc", "buf", "ctx", "manager", "environment", "ve", "server", "tmp", "sv", "vs", "db", "viron", "dev", "priv", "stage", "doc", "stack", "config", "sp", "esp", "obj", "store", "ah", "ew", "nc", "nv", "v", "gov", "shell", "cfg", "ev", "forge"], "mce": ["emce", "emcent", " mace", "mced", " mced", "Mcer", "MCE", "cace", "lCE", " mCE", "cCE", "emces", " mcent", "lcent", " mcer", "mace", "lces", "lce", "cced", "Mce", "cce", "emCE", "Mced", "mCE", "mces", "ccer", "mcer", " mces", "mcent", "Mace"], "flag": ["flags", "start", "tag", "age", "kind", "set", "sun", "group", "field", "policy", "Flag", "offset", "attribute", "count", "image", "FLAG", "package", "arg", "id", "mask", "weight", "ld", "level", "info", "bit", "limit", "batch", "status", "ff", "link", "cond", "stage", "feature", "command", "cmd", "bug", "line", "option", "lag", "sign", "type"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22418, "substitutes": {"ctx": ["kw", "resp", "txt", "kt", "context", "alloc", "cb", "ac", "co", "conv", "etc", "ct", "pkg", "unc", "loc", "bc", "conn", "cv", "tx", "c", "cl", "cmp", "hw", "setup", "wx", "cm", "sc", "cf", "xs", "wd", "nt", "anc", "req", "cmd", "tc", "conf", "crit", "pool", "obj", "cc", "cp", "cfg", "xc"], "fd": ["td", "fn", "ed", "done", "bf", "cb", "dd", "did", "f", "fed", " ff", "sd", "dir", "d", "fff", "file", "id", "stream", "dt", "ld", " ed", "ind", "fs", "cd", " td", "ds", "handle", "hd", " FD", "pid", "fp", "nd", "buf", "ff", "cod", "ptr", "df", "fi", " fid", "db", "addr", "cf", "fin", " df", " fin", "pos", "len", "lf", "pd", "fc", " fil", "FD", "ffff"], "node": ["n", "fn", "station", "parent", "t", "name", "msg", "normal", "missing", "slave", "source", "index", "list", "dd", "desc", "field", "f", "m", "root", "seed", "tip", "object", "Node", "nw", "item", "d", "post", "key", "note", "id", "e", "nn", "cd", "row", "data", "c", "leaf", "good", "local", "hd", "content", "nd", "result", "cell", "link", "event", "k", "child", "tmp", "entry", "self", "edge", "component", "adj", "new", "nt", "path", "ode", "tree", "obj", "cache", "anch", "handler", "holder", "attr", "instance"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421, "substitutes": {"env": ["kw", "ee", "en", "eh", "et", "cb", "te", "ef", "code", "ec", "esc", "cur", "hw", "EN", "buf", "environment", "sh", "pe", "map", "viron", "dev", "de", "conf", "ep", "ew", "eng", "ev"], "dc": ["dh", "DC", "dm", "vc", "di", "dd", "cca", "disc", "gc", "ct", "cs", "bc", "cd", "c", "ec", "dp", "lc", "cm", "sc", "mc", "tc", "nc", "cc", "ca", "fc", "da", "xc", "oc"]}}
{"project": "FFmpeg", "commit_id": "043800a96888f1a04732f12316ba477d8f098d3f", "target": 0, "func": "static int end_frame(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext    *ctx = inlink->dst;\n\n    FPSContext           *s = ctx->priv;\n\n    AVFilterLink   *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef  *buf = inlink->cur_buf;\n\n    int64_t delta;\n\n    int i, ret;\n\n\n\n    inlink->cur_buf = NULL;\n\n    s->frames_in++;\n\n    /* discard frames until we get the first timestamp */\n\n    if (s->pts == AV_NOPTS_VALUE) {\n\n        if (buf->pts != AV_NOPTS_VALUE) {\n\n            write_to_fifo(s->fifo, buf);\n\n            s->first_pts = s->pts = buf->pts;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\n                   \"timestamp.\\n\");\n\n            avfilter_unref_buffer(buf);\n\n            s->drop++;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* now wait for the next timestamp */\n\n    if (buf->pts == AV_NOPTS_VALUE) {\n\n        return write_to_fifo(s->fifo, buf);\n\n    }\n\n\n\n    /* number of output frames */\n\n    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\n\n                         outlink->time_base);\n\n\n\n    if (delta < 1) {\n\n        /* drop the frame and everything buffered except the first */\n\n        AVFilterBufferRef *tmp;\n\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n\n        s->drop += drop;\n\n\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n\n        flush_fifo(s->fifo);\n\n        ret = write_to_fifo(s->fifo, tmp);\n\n\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    /* can output >= 1 frames */\n\n    for (i = 0; i < delta; i++) {\n\n        AVFilterBufferRef *buf_out;\n\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n\n\n        /* duplicate the frame if needed */\n\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n\n            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n\n            s->dup++;\n\n        }\n\n\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n\n                                    outlink->time_base) + s->frames_out;\n\n\n\n        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n\n            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n\n            (ret = ff_end_frame(outlink)) < 0) {\n\n            avfilter_unref_bufferp(&buf);\n\n            return ret;\n\n        }\n\n\n\n        s->frames_out++;\n\n    }\n\n    flush_fifo(s->fifo);\n\n\n\n    ret = write_to_fifo(s->fifo, buf);\n\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n\n\n    return ret;\n\n}\n", "idx": 22425, "substitutes": {"inlink": ["cinslice", "intlink", "outplay", "dinlink", "cinlock", " outroute", "cinlink", "airline", "dinhandle", " inroute", "intline", " outhandle", "innlink", "dinline", "inplay", "inlet", "innstream", "innline", " outline", "inhandle", " inlet", "isinline", "inslice", "inlock", "airlock", "INframe", "dinroute", "INlink", "instream", "airlink", "INline", " inslice", "cinline", "incell", "outcell", " inlock", "innlet", "inframe", "outline", " inhandle", "isinlink", "INstream", "airslice", "isincell", " inframe", "intcell", "outlet", "intplay", "innframe", " instream", "outstream", "isinplay", "inroute"], "ctx": ["kw", "Context", "ij", "jac", "resp", "p", "t", "sys", "vp", "txt", "context", "kt", "ck", "cb", "ns", "window", "conv", "gc", "ct", "act", "pkg", "gz", "tz", "bs", "mom", "unc", "cs", "conn", "cu", "timeout", "cv", "tx", "gs", "c", "ds", "jp", "cmp", "kl", "wx", "bo", "k", "lc", "cm", "sc", "cf", "js", "mx", "kb", "wcs", "wd", "config", "anc", "mc", "nt", "ux", "np", "cmd", "tc", "conf", "iat", "cam", "nc", "cc", "ctl", "cp", "cfg", "xc"], "s": ["ties", "ports", "is", "m", "ims", "space", "sts", "ds", "sv", "sw", "hs", "es", "xs", "ins", "als", "less", "sb", "as", "v", "n", "a", "os", "stat", "changes", "ns", "bs", "cs", "socket", "fs", "aws", "sm", "ats", "vs", "service", "g", "ts", "sg", "qs", "b", "comm", "t", "sys", "f", "y", "stats", "pkg", "d", "ps", "services", "tx", "args", "c", "spec", "ls", "utils", "S", "its", "sp", "conf", "store", "actions", "l", "serv", "p", "bits", "ids", "h", "ss", "ses", "eps", "sports", "rs", "gs", "sam", "ms", "js", "http", "sq"], "outlink": ["skylink", "skybridge", " outbridge", "outdisk", " outroute", "unroute", "undisk", " outdisk", "outputroute", "skyline", "outputlink", "outLink", " outline", " outLink", "unlink", "outroute", "unLink", "outbridge", "outline", "outputLink", "inbridge", "outputdisk"], "buf": ["msg", "foo", "err", "ox", "uf", "temp", "cur", "batch", "ff", "uv", "br", "bh", "wb", "bt", "BU", "tc", "kw", "orig", "rev", "bl", "conv", "bs", "Buffer", "bytes", "vec", "cmp", "ann", "xff", "seq", "db", "mem", "cmd", "cam", "bin", "b", "cp", "bf", "ref", "gc", "pkg", "cv", "fg", "fb", "good", "av", "proc", "raw", "buffer", "box", "buff", "np", "pool", "pg", "cache", "vp", "bag", "rb", "cap", "txt", "alloc", "func", "cb", "bed", "gz", "Buff", "arr", "tab", "fp", "img", "nm", "grab", "queue", "pb"], "delta": ["dota", " dIFF", "danta", "nta", "dDelta", " diff", "melt", "fdDelta", "mota", "sdelta", "edanta", "edistant", "adelt", "fdelta", "Delta", "mIFF", " dta", "nynamic", "sdelt", " dota", "dIFF", "DDelta", "sdiff", "fdelt", "tota", "tynamic", "telt", "tta", " danta", "edDelta", "edelta", "adiff", "fdanta", "Distant", "Delt", "distant", "telta", "adta", "sdta", "nelta", "dynamic", " dDelta", "diff", "tIFF", "dta", "nelt", "sdynamic", "melta", "Danta", " delt", " distant", "adelta", "delt"], "i": ["n", "bi", "phi", "p", "t", "it", "a", "si", "me", "di", "o", "iu", "io", "ai", "xi", "index", "m", "ix", "f", "y", "ims", "us", "init", "multi", "im", "ei", "zi", "x", "id", " ii", "e", "ind", "sim", "gi", "info", "I", "c", "qi", "ki", "ti", "ini", "ip", "j", "batch", "cli", "li", "ui", "in", "ci", "g", "mi", "u", "ii", "pi", "hi", "v"], "ret": ["gt", "fun", "resp", " Ret", "t", "re", "txt", "it", "print", "r", "cont", "ref", "back", "rets", "Return", "rem", "Ret", "rel", "val", "mb", "arr", "def", "best", "reset", "jp", "lt", "tr", "no", "RT", "status", "result", "mt", "ft", "full", "rt", "jump", "reply", "res", "alt", "true", "rm", "try", "new", "mem", "nt", "RET", "after", "len", "ll", "elt", "ry", "last", "flag"], "frames_in": ["Frames_ins", "Frames_In", "frames__IN", "Frames__ins", "framesixin", "Frames__in", "Frames__IN", "framesixIn", "frames_In", "frames__In", "frames__in", "frames__ins", "Frames_IN", "frames_ins", "framesixIN", "Frames_in", "framesixins", "Frames__In", "frames_IN"], "drop": ["loop", "zip", "move", "clip", "stop", "delay", "kill", "root", "pop", " dropping", "Drop", "hop", "skip", "trace", "down", "crop", "trip", "throw", "slot", "rop", "dim", "reset", "hide", "dl", "step", "host", "close", "snap", "keep", "batch", " Drop", "no", "shift", "draw", "dp", "shape", "box", " dropped", "dr", "rest", "error", "delete", "carry", "drops", "dropping", "pause", "dro", "pool", "hold", "sample", "port", "grow", "trap", "pass"], "tmp": ["perm", "resp", "orig", "t", "zip", "old", "out", "tt", "txt", "msg", "Temp", "cont", "cb", "mm", "tp", "tar", "qq", "window", "gz", "table", "pkg", "etc", "mb", "mint", "uf", "mp", "cv", "dirty", "partial", "tab", "dust", "xy", "test", "temp", "tx", "snap", "cmp", "proc", "img", "ptr", "rt", "sam", "html", "stuff", "mem", "sp", "nt", "buff", "np", "obj", "tm", "vp", "vt"], "buf_out": ["buf_err", "buff_OUT", "bufockdot", "bufockout", "buff_out", "pageockout", "buf__out", " buf_Out", "buf_obj", "buf__obj", "buf__dot", "bufockerr", " buf_r", "pageockerr", "buf_alt", "page_dot", " buf_alt", "buff_net", "buf_r", "pageockdot", "buf_dot", "page_obj", "buf_OUT", "buff_in", "buf_net", "buf_Out", "page_out", "buf_in", "bufockobj", "buf__err", "page_err", "pageockobj"]}}
{"project": "FFmpeg", "commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "target": 1, "func": "static int roq_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    RoqDemuxContext *roq = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    unsigned int chunk_size;\n\n    unsigned int chunk_type;\n\n    unsigned int codebook_size;\n\n    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];\n\n    int packet_read = 0;\n\n    int64_t codebook_offset;\n\n\n\n    while (!packet_read) {\n\n\n\n        if (avio_feof(s->pb))\n\n            return AVERROR(EIO);\n\n\n\n        /* get the next chunk preamble */\n\n        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n\n            RoQ_CHUNK_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n\n\n        chunk_type = AV_RL16(&preamble[0]);\n\n        chunk_size = AV_RL32(&preamble[2]);\n\n        if(chunk_size > INT_MAX)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        chunk_size = ffio_limit(pb, chunk_size);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case RoQ_INFO:\n\n            if (roq->video_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);\n\n                roq->video_stream_index = st->index;\n\n                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;\n\n                st->codecpar->codec_tag    = 0;  /* no fourcc */\n\n\n\n                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)\n\n                    return AVERROR(EIO);\n\n                st->codecpar->width  = roq->width  = AV_RL16(preamble);\n\n                st->codecpar->height = roq->height = AV_RL16(preamble + 2);\n\n                break;\n\n            }\n\n            /* don't care about this chunk anymore */\n\n            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);\n\n            break;\n\n\n\n        case RoQ_QUAD_CODEBOOK:\n\n            if (roq->video_stream_index < 0)\n\n                return AVERROR_INVALIDDATA;\n\n            /* packet needs to contain both this codebook and next VQ chunk */\n\n            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;\n\n            codebook_size = chunk_size;\n\n            avio_skip(pb, codebook_size);\n\n            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n\n                RoQ_CHUNK_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n\n                codebook_size;\n\n\n\n            if (chunk_size > INT_MAX)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            /* rewind */\n\n            avio_seek(pb, codebook_offset, SEEK_SET);\n\n\n\n            /* load up the packet */\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n\n            if (ret != chunk_size)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = roq->video_stream_index;\n\n            pkt->pts = roq->video_pts++;\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case RoQ_SOUND_MONO:\n\n        case RoQ_SOUND_STEREO:\n\n            if (roq->audio_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);\n\n                roq->audio_stream_index = st->index;\n\n                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;\n\n                st->codecpar->codec_tag = 0;  /* no tag */\n\n                if (chunk_type == RoQ_SOUND_STEREO) {\n\n                    st->codecpar->channels       = 2;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n                } else {\n\n                    st->codecpar->channels       = 1;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22426, "substitutes": {"s": ["n", "p", "t", "sys", "a", "sa", "os", "set", "f", "m", "ns", "ss", "ims", "ses", "stats", "ps", "bs", "cs", "e", "sts", "aws", "gs", "rs", "i", "c", "times", "ds", "fs", "z", "south", "ctx", "spec", "ls", "q", "ms", "ats", "hs", "sc", "S", "js", "es", "ins", "sq", "ts", "its", "sp", "conf", "qs", "less", "sb", "b", "v", "w"], "pkt": ["cpkt", "pnt", " pqt", "spkg", "pkg", "cpkg", "spkt", "spnt", "pqt", "cpnt", "cpqt", "spqt", " pnt", " pkg"], "roq": ["rowqt", "robq", "robqt", "rowque", "robqu", "roz", "roQ", " roQ", "hoqu", "troqi", "troz", "groquest", "aroqu", "robquant", "troquest", "roquant", "troqt", "croqt", "hoql", " roqi", "raq", "stroq", "raqi", "roque", "croq", "hoqi", "robqi", "raquest", "roql", "hoq", "robQ", " roqt", "aroq", "aroquant", "roqi", "roqu", "raqu", "stroqi", "croz", "troQ", "groiq", " roque", "stroqu", "groq", "troq", "roiq", "troiq", " roqu", "roqt", "robz", "croqi", "groqu", "troque", "troqu", "rowq", "stroql", "raiq", "troquant", "aroqi", "raql", "roquest", "rowqi"], "pb": ["td", "p", "sys", "rb", "eb", "tg", "cb", "pm", "tp", "bps", "gb", "ob", "gc", "pkg", "pt", "pp", "lp", "uf", "mp", "pl", "tk", "wp", "lb", "tap", "cv", "cp", "pa", "PB", "fb", "jp", "kl", "snap", "proc", "nb", "fp", "buf", "ctx", "pr", "ub", "tmp", "dp", "wb", "pan", "kb", "phys", "sp", "buff", "pc", "np", "pg", "tc", "pool", "iat", "typ", "emb", "obj", "sb", "bp", "bj", "vp", "tf", "bb", "vt"], "chunk_size": ["chunk_offset", "chunkingsize", "chunkingSIZE", "chunk_time", "chblock_type", "chunkPoffset", "chacket_number", "chunks_status", "chunkPSIZE", "chunk_name", "chacketinglength", "chacket_SIZE", "chunkPsize", "chunks_size", "chunk_SIZE", "chblock_size", "chacketingsize", "chunk_length", "chunk_status", "chacket_length", "chunkingnumber", "chunkinglength", "chacketingSIZE", "chunk_len", "chunk_format", "chunk_number", "chacket_size", "chunks_name", "chunks_len", "chunkPtime", "chacketingnumber", "chblock_len"], "chunk_type": ["chunketyindex", "chdownloadetyindex", "chdownload_types", "chdownload_type", "chunk_types", "chdownloadetytypes", "chanch_kind", "chdownload_size", "chunk_index", "chanch_type", "chanch_class", "chdownloadetysize", "chunketytype", "chunk_class", "chunk_kind", "chanch_types", "chunketytypes", "chunk_tag", "chunk_state", "chdownloadetytype", "chdownload_index", "chunketysize"], "codebook_size": ["codebooks_offset", "codebook_address", "codebooks_size", "codebooks_address", "codebooks_length", "codebook_length"], "preamble": ["probbl", "repreamBLE", "reparmbles", "prambler", "proble", "preamBLE", "exprambler", " parmbles", "exparmBLE", " parmBLE", "repreambler", "parmbled", "pumble", "exparmbled", "prambles", "exparmbles", "preamle", " preamle", "pumbler", "parmBLE", "reparmbler", "preambles", "prambl", "preambled", "expreambler", "prombles", "expreambled", "reparmle", "parmble", "pemBLE", "reparmBLE", "exprambles", "parmbles", "reparmble", "pambles", "preambl", "pemble", "pumbles", "pramBLE", "probble", "expramble", " parmble", "pumle", "pembles", "expreamble", "prombler", "pramble", "expreambles", "pembled", "parmle", "probbled", "pambled", "pamBLE", "exparmble", " preambled", " preambl", "pamle", "pamble", "pramle", "repreambles", "repreamle", " parmbl", "promble", "parmbler", "exprambled", "prambled", " preamBLE", " parmle", "prombled", "pambler", "preambler", "expreamBLE", " parmbled", "repreamble", " preambles", "parmbl"], "codebook_offset": ["codebook__index", "codebook__off", "codebook_index", "codeBook_off", "codebook__offset", "codeBook_index", "codebook__size", "codebook_off", "codeBook_offset", "codeBook_size"], "st": ["td", "ste", "ost", "tt", "start", "it", "ck", "stop", "usr", "et", "set", "stat", "h", "ss", "add", "sta", "th", "ct", "pt", "sts", "St", "str", "step", "ast", "se", "z", "nd", "mt", "ust", "sn", "sm", "fr", "stan", "ft", "rt", "sh", "sw", "est", "sv", "tmp", "sc", "stable", "rest", "put", "sp", "nt", "std", "ts", "irst", "ist", "mont", "inst", "ST", "ut", "art", "sl", "sty"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,\n\n\t\t\t\t  int16_t *filter, int16_t *filterPos, int filterSize)\n\n{\n\n#ifdef HAVE_MMX\n\n\tassert(filterSize % 4 == 0 && filterSize>0);\n\n\tif(filterSize==4) // allways true for upscaling, sometimes for down too\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 4), %%mm1\\n\\t\"\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 4), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse if(filterSize==8)\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*4;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 16(%1, %%\"REG_BP\", 8), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 24(%1, %%\"REG_BP\", 8), %%mm5\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm4, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\t\t\t\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse\n\n\t{\n\n\t\tuint8_t *offset = src+filterSize;\n\n\t\tlong counter= -2*dstW;\n\n//\t\tfilter-= counter*filterSize/2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"mov %2, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%%\"REG_c\", %0), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%%\"REG_c\", %0), %%ebx\t\\n\\t\"\n\n\t\t\t\"mov %5, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%1), %%mm1\t\t\\n\\t\"\n\n\t\t\t\"movq (%1, %6), %%mm3\t\t\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_a\"), %%mm0\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_b\"), %%mm2\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm0, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"add $8, %1\t\t\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\" jb 2b\t\t\t\t\\n\\t\"\n\n\t\t\t\"add %6, %1\t\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"mov %3, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm4, (%%\"REG_a\", %0)\t\\n\\t\"\n\n\t\t\t\"add $4, %0\t\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t: \"+r\" (counter), \"+r\" (filter)\n\n\t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset),\n\n\t\t\t  \"m\" (src), \"r\" ((long)filterSize*2)\n\n\t\t\t: \"%\"REG_b, \"%\"REG_a, \"%\"REG_c\n\n\t\t);\n\n\t}\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\n\thScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<dstW; i++)\n\n\t{\n\n\t\tint j;\n\n\t\tint srcPos= filterPos[i];\n\n\t\tint val=0;\n\n//\t\tprintf(\"filterPos: %d\\n\", filterPos[i]);\n\n\t\tfor(j=0; j<filterSize; j++)\n\n\t\t{\n\n//\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]);\n\n\t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n\t\t}\n\n//\t\tfilter += hFilterSize;\n\n\t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...\n\n//\t\tdst[i] = val>>7;\n\n\t}\n\n#endif\n\n#endif\n\n}\n", "idx": 22429, "substitutes": {"dst": ["adrc", "pst", "dx", "ddx", "Dx", "dssrc", "ddst", " dsrc", "idsrc", "adx", " drc", "idst", "pdest", "dsrc", "idx", " dx", "prc", "Dst", "addest", " dset", "px", "adst", "Dset", "dset", "dsdest", "dsc", "Dsrc", "ddsrc", "drc", "idsc", "ddsc", "Dsc", " ddest", "Ddest", "dsst", "ddest", "dsset"], "dstW": ["deltaW", "dsrcL", "destV", "dctN", "dxN", "dstN", "dblV", "dsetV", "dsetVW", "drcW", "dstVW", "dblN", "drcV", "drcL", "dctW", " dstR", " dstSize", " dxSize", "dstV", "dblSize", "dsetW", "dstL", "dspWC", "dsetN", " dctR", "dsrcW", " dstV", " dstN", "dsrcV", " dxW", "dspL", "dxSize", "dsstV", "destN", "dsstL", "dsrcWC", "dstWC", "deltaR", "dctR", "dstSize", " dxV", "drcWC", "dsetR", " dctVW", "dstR", "dsstWC", "dblW", "dsetWC", "destW", " dctW", "dspV", " dctN", "deltaVW", " dstVW", "destSize", "deltaN", "dxW", "dsstW", " dxN", "dctVW", "dxV", "dsetL", "dspW"], "src": ["lr", "rc", "start", "r", "source", "cb", "rel", "dest", "loc", "stream", "x", "rs", "st", "s", "cur", "sr", "sn", "sc", "inc", "ins", "trans", "sub", "rl", "sur", "input", "sb", "ser"], "srcW": ["sourceH", "stA", "sourceW", "stW", "sourceN", "srcA", " srcA", " srcN", "srcH", "srcN", " srcH", "stH", "sourceA", "stN"], "xInc": ["rxINC", "xDec", "xxInc", "rxDec", " xINC", " xinc", "xxDec", "rxInc", " xDec", "xINC", "xxinc", "rxinc", "xinc", "xxINC"], "filter": ["frame", "source", "index", "ref", "f", "length", "scale", "window", "table", "count", "inter", "stream", "Filter", "fw", "test", "size", "limit", "reverse", "batch", "tr", "profile", "fp", "version", "fil", "ff", "spec", "control", "frequency", "map", "buffer", "shape", "iter", "sort", "feature", "match", "trans", "range", "term", "block", "header", "trigger", "file", "tf", "counter", "chain"], "filterPos": ["specPos", " filterTrans", "sortSize", "bufferPOS", "sortTrans", "rangePOS", "bufferSize", "termTrans", "sortLoc", "bufferLoc", " filterPo", "filterPOS", "rangeTrans", "termPOS", "termPos", " filterLoc", "specTrans", "sortPOS", "filterTrans", "filterPo", "sortPos", "filterLoc", "specPOS", "rangePo", " filterPOS", "termPo", "rangePos", "bufferPos"], "filterSize": ["FilterSIZE", "filterLimit", "blockSIZE", "filLimit", " filterLen", "filterSIZE", "filSize", "FilterSi", "FilterLen", " filterZ", "filPos", "filterSi", " filterLimit", "filterStyle", " filterCount", "filSi", "filCount", "filterLen", "filSIZE", "blockSize", "filterZ", " filterStyle", "filStyle", " filterSIZE", "FilterPos", "FilterSize", "FilterZ", "filterCount", "blockStyle", "filZ", " filterSi", "FilterCount", "hashSize", "hashSIZE", "hashCount", "blockLimit", "filLen"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "substitutes": {"f": ["fn", "p", "t", "bf", "r", "fal", "alf", "h", "ef", "m", "sf", "ac", "fo", "al", "fee", "d", "fe", "fac", "uf", "fm", "e", "fs", "fw", "c", "fb", "elf", "fp", "fr", "df", "q", "fi", "rf", "xf", "cf", "fd", "of", "form", "F", "af", "lf", "fab", "l", "b", "v", "file", "fc", "tf", "w"], "ret": ["gt", "resp", "re", " RET", "lit", "txt", "print", "cat", "red", "sec", "ref", "rets", "rem", "hash", "Ret", "val", "arg", "def", "ext", "bit", "reset", "des", "status", "result", "aux", "deg", "rt", "reply", "tmp", "res", "alt", "mem", "error", "nt", "RET", "req", "elt", "flag", "nil"]}}
{"project": "FFmpeg", "commit_id": "d3b4b74c32cf302d36a4c4d2cce08027f0a22560", "target": 0, "func": "static int encode_picture_lossless(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    MJpegContext * const m = s->mjpeg_ctx;\n\n    AVFrame *pict = data;\n\n    const int width= s->width;\n\n    const int height= s->height;\n\n    AVFrame * const p= (AVFrame*)&s->current_picture;\n\n    const int predictor= avctx->prediction_method+1;\n\n\n\n    init_put_bits(&s->pb, buf, buf_size);\n\n\n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    p->key_frame= 1;\n\n\n\n    ff_mjpeg_encode_picture_header(s);\n\n\n\n    s->header_bits= put_bits_count(&s->pb);\n\n\n\n    if(avctx->pix_fmt == PIX_FMT_RGB32){\n\n        int x, y, i;\n\n        const int linesize= p->linesize[0];\n\n        uint16_t (*buffer)[4]= (void *) s->rd_scratchpad;\n\n        int left[3], top[3], topleft[3];\n\n\n\n        for(i=0; i<3; i++){\n\n            buffer[0][i]= 1 << (9 - 1);\n\n        }\n\n\n\n        for(y = 0; y < height; y++) {\n\n            const int modified_predictor= y ? predictor : 1;\n\n            uint8_t *ptr = p->data[0] + (linesize * y);\n\n\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < width*3*4){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            for(i=0; i<3; i++){\n\n                top[i]= left[i]= topleft[i]= buffer[0][i];\n\n            }\n\n            for(x = 0; x < width; x++) {\n\n                buffer[x][1] = ptr[4*x+0] - ptr[4*x+1] + 0x100;\n\n                buffer[x][2] = ptr[4*x+2] - ptr[4*x+1] + 0x100;\n\n                buffer[x][0] = (ptr[4*x+0] + 2*ptr[4*x+1] + ptr[4*x+2])>>2;\n\n\n\n                for(i=0;i<3;i++) {\n\n                    int pred, diff;\n\n\n\n                    PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                    topleft[i]= top[i];\n\n                    top[i]= buffer[x+1][i];\n\n\n\n                    left[i]= buffer[x][i];\n\n\n\n                    diff= ((left[i] - pred + 0x100)&0x1FF) - 0x100;\n\n\n\n                    if(i==0)\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                    else\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                }\n\n            }\n\n        }\n\n    }else{\n\n        int mb_x, mb_y, i;\n\n        const int mb_width  = (width  + s->mjpeg_hsample[0] - 1) / s->mjpeg_hsample[0];\n\n        const int mb_height = (height + s->mjpeg_vsample[0] - 1) / s->mjpeg_vsample[0];\n\n\n\n        for(mb_y = 0; mb_y < mb_height; mb_y++) {\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < mb_width * 4 * 3 * s->mjpeg_hsample[0] * s->mjpeg_vsample[0]){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n            for(mb_x = 0; mb_x < mb_width; mb_x++) {\n\n                if(mb_x==0 || mb_y==0){\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n                                if(y==0 && mb_y==0){\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= 128;\n\n                                    }else{\n\n                                        pred= ptr[-1];\n\n                                    }\n\n                                }else{\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= ptr[-linesize];\n\n                                    }else{\n\n                                        PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n                                    }\n\n                                }\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n//printf(\"%d %d %d %d %8X\\n\", mb_x, mb_y, x, y, ptr);\n\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(s);\n\n    s->picture_number++;\n\n\n\n    flush_put_bits(&s->pb);\n\n    return pbBufPtr(&s->pb) - s->pb.buf;\n\n//    return (put_bits_count(&f->pb)+7)/8;\n\n}\n", "idx": 22436, "substitutes": {"avctx": ["wavctx", "avercmd", "avcmp", "awcontext", "avereq", " avconn", "avcontext", " avcu", "afconn", "verreq", " avbc", "avertx", "avbc", "avercontext", "avecmp", " avpkg", "avtx", "Avcontext", "awcmd", "Avbc", "averctx", "wavpkg", "avercam", "awcmp", "avecontext", "awconn", " avcmp", "afcontext", "averpkg", "Avtx", "afcmp", "avcam", "avpkg", "avercmp", "afctx", "avcmd", "awctx", " avreq", "avecmd", "wavcontext", "avecu", "awcam", "Avctx", "verctx", "avecam", "avectx", "avcu", "avreq", " avcontext", "averbc", "vercontext", " avtx", "wavtx", "avconn", "vercu"], "buf": ["rb", "cap", "rc", "msg", "bf", "cb", "ref", "window", "err", "src", "bs", "uf", "bar", "bc", "cv", "str", "fb", "bytes", "vec", "limit", "batch", "nb", "img", "ctx", "br", "bh", "queue", "tmp", "num", "wb", "box", "mem", "buff", "block", "cmd", "BU", "bu", "cache", "bin", "len", "port", "b", "text"], "buf_size": ["buf_Size", "buf_num", " buf_info", " bu_num", "buf_ize", " buf_source", " bu_size", "buf_source", " bu_ize", " buf_Size", "bufktsize", "bufktsource", "buf_info", "bufktinfo", "bufktSize"], "data": ["n", "txt", "start", "first", "r", "ref", "intel", "f", "type", "device", "value", "window", "hash", "rel", "offset", "length", "format", "table", "d", "ata", "images", "image", "label", "def", "empty", "str", "mu", "batch", "picture", "content", "img", "png", "height", "raw", "DATA", "video", "dat", "map", "Data", "block", "header", "bin", " DATA", "w", "obj", "form", "json", "cache", "pad", "padding", "text"], "s": ["ports", "is", "source", "ims", "ops", "sts", "ds", "details", "sv", "sw", "hs", "ess", "es", "ins", "sb", "as", "n", "state", "a", "o", "os", "ns", "conv", "bs", "cs", "fs", "aws", "vs", "ats", "self", "sc", "g", "ts", "qs", "b", "comm", "t", "sys", "settings", "sd", "stats", "d", "ps", "c", "ctx", "spec", "ls", "ies", "S", "its", "sp", "conf", "serv", "ss", "ses", "gs", "rs", "j", "ms", "js", "sq", "ares", "w"], "m": ["n", "man", "M", "dm", "r", "o", "mm", "f", "gm", "d", "mp", "vm", "c", "mt", "bm", "ms", "cm", "mem", "g", "mx", "mc", "tm", "mn", "b", "l"], "pict": ["fig", "fn", "mat", "pain", "txt", "ht", "Picture", "stat", "f", "act", "conv", "pt", "capt", "pl", "def", "jp", "pres", "picture", "proc", "img", "png", "pen", "ctx", "Pict", "br", "Pic", "dat", "fi", "res", "feat", "doc", "buff", "np", "cam", "obj", "pai", "vp", "pas", "pic"], "p": ["perm", "t", "vp", "it", "a", "o", "r", "ping", "f", "pm", "tp", "policy", "d", "pkg", "ps", "pt", "pp", "lp", "pro", "mp", "wp", "c", "pa", "pers", "jp", "php", "j", "ip", "ap", "picture", "fp", "op", "pen", "P", "pr", "par", "sp", "rep", "pb", "pc", "np", "pg", "b", "l", "pi", "bp", "cp", "pic"], "x": ["n", "fx", "t", "xx", "any", "xes", "dx", "o", "r", "index", "xt", "xxxx", "xi", "check", "ix", "ax", "ox", "yx", "key", "inx", "xa", "e", "on", "tx", "my", "xy", "rx", "X", "j", "xp", "z", "content", "wx", "k", "full", "ex", "px", "xf", "at", "scroll", "g", "xs", "ux", "mx", "xxx", "u", "l", "cross", "el", "lat", "xc", "w"], "y": ["n", "yy", "sys", "yo", "axy", "any", "py", "index", "hy", "ys", "ady", "ay", "yx", "by", "key", "cy", "iy", "yl", "ey", "wy", "yk", "ny", "my", "vy", "ya", "xy", "hot", "j", "ied", "z", "col", "height", "kit", "dy", "yt", "sy", "sky", "iny", "Y", "ies", "try", "ch", "ym", "ty", "yr", "tiny", "gy", "yer", "ye", "b", "ry", "l", "yi"], "i": ["is", "ic", "io", " I", "wi", "im", "I", "ti", "cli", "k", "ui", "uri", "chain", "\u0438", "si", "me", "ai", "ix", "ji", "ind", "sim", "e", "gi", "info", "ami", "status", "g", "u", "b", "hi", "bi", "phi", "t", "it", "iq", "ri", "f", "xi", "multi", "by", "zi", "ei", "ice", "c", "ni", "ity", "qi", "ini", "ip", "spin", "li", "in", "ci", "mi", "ii", "pi", "l", "ij", "index", "di", "iu", "us", "ie", "id", "ki", "j", "q"], "buffer": ["reference", "message", "pixel", "length", "uf", "xy", "batch", "screen", "command", "_", "pointer", "port", "button", "vector", "binary", "context", "comment", "jpg", "device", "program", "board", "Buffer", "size", "picture", "scroll", "new", "sequence", "b", "header", "frame", "memory", "database", "table", "image", "position", "stack", "buff", "pool", "obj", "cache", "history", "window", "bridge", "document", "byte", "tile", "result", "gray", "queue", "page", "block", "text"], "top": ["master", "parent", "upper", "first", "high", "middle", "list", "root", "offset", "table", "tail", "current", "below", "trace", "level", "best", "target", "hot", "there", "st", "bot", "height", "lower", "position", "tools", "up", "scroll", "at", "stack", "Top", "TOP", "bottom", "pos", "above", "center", "to", "l", "tops", "lat"], "topleft": ["tplelf", "topleut", "toopt", "stothelf", "totheut", "tothelf", "Topleft", "stothevel", "tloevel", "Tothept", "stotheft", "toplefts", "tplevel", "Toplevel", "tloelf", "stothefts", "Topleut", "Toplept", "tothevel", "toout", "stoplelf", "toovel", "tpleft", "tothefts", "Totheut", "tpleut", "tooft", "totheft", "Tothevel", "toplevel", "tplefts", "stopleft", "toplept", "Totheft", "stoplevel", "stoplefts", "tothept", "toplelf", "tloefts", "tloeft", "tplept"], "ptr": ["td", "rect", "dh", "pert", "end", "dep", "ret", "Ptr", "ref", "desc", "tp", "err", "offset", "rel", "iv", "pt", "loc", "arr", "ind", "ext", "xy", "vec", "tr", "cut", "deg", "br", "pr", "tmp", "grad", "addr", "iter", "dr", "prime", "inters", "rep", "buff", "req", "address", "cmd", "np", "pos", "pointer", "pad", "pointers", "ctr"], "linesize": ["inesz", "inesIZE", "linsizer", "setsize", "lineization", "lsiz", "blockszie", "valueszie", "inesizer", "linesIZE", " linesization", "linsize", "blocksize", "linespace", "linksz", "linksize", "setszie", "setsization", " linesiz", "lineize", "lineiz", "linesizer", "lsization", "linepace", "linsz", "linksIZE", "valuesization", "lspace", "setsized", "linksizer", "linesized", "linesiz", "linesz", "valuesize", "linesization", " linespace", "inesize", "lineszie", "blocksization", "valuesized", "linsIZE", "blocksized", "lsize"]}}
{"project": "FFmpeg", "commit_id": "934fe00680a1139cbc0950641655af5923dd7763", "target": 0, "func": "static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (o->format) {\n\n        if (!(file_iformat = av_find_input_format(o->format))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Unknown input format: '%s'\\n\", o->format);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n    if (o->nb_audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (o->nb_audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_channels[o->nb_audio_channels - 1].u.i);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (o->nb_frame_rates) {\n\n        av_dict_set(&format_opts, \"framerate\", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_sizes) {\n\n        av_dict_set(&format_opts, \"video_size\", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_pix_fmts)\n\n        av_dict_set(&format_opts, \"pixel_format\", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);\n\n\n\n    ic->video_codec_id   = video_codec_name ?\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;\n\n    ic->audio_codec_id   = audio_codec_name ?\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;\n\n    ic->subtitle_codec_id= subtitle_codec_name ?\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n    ic->interrupt_callback = int_cb;\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* open the input file with generic avformat function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    /* apply forced codec ids */\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        choose_decoder(o, ic, ic->streams[i]);\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        exit_program(1);\n\n    }\n\n\n\n    timestamp = o->start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n", "idx": 22459, "substitutes": {"o": ["oid", "io", "m", "fo", "ot", "on", "oa", "lo", "k", "ov", "sw", "ow", "after", "oos", "v", "oc", "n", "ed", "ion", "os", "te", "x", "e", "info", "oo", "op", "owner", "oi", "g", "u", "remote", "b", "t", "one", "f", "y", "co", "ooo", "image", "po", "ation", "onet", "c", " t", "ao", "ec", "bo", "other", "ve", "ta", "obj", "to", "oin", "l", "so", "ok", "er", "p", "out", "go", "h", "window", "ob", "original", "ro", "or", "q", "O", "options", "ate", "w"], "opt": ["kw", "fn", "p", "pot", "out", "txt", "it", "off", "fo", "init", "nom", "Opt", "info", "temp", "fp", "prop", "op", "ff", "ctx", "img", "option", "tmp", "seek", "config", "params", "cmd", "cp", "attr"], "filename": ["fn", "name", "n", "fig", "username", "orig", "p", "out", "msg", "txt", "rn", "final", "fle", "r", "source", "jpg", "output", "f", "title", "nam", "format", "etc", "program", "src", "Filename", "dest", "ames", "url", "unc", "ame", "unknown", "iov", "kl", "ption", "ERROR", "proc", "nu", "files", "fp", "result", "fil", "tif", "nm", "other", "names", "brace", "fi", "nil", "ren", "path", "ename", "prefix", "typ", "np", "mpeg", "json", "kj", "options", "bas", "upload", "til", "file", "wav", "unction"], "ic": ["ics", "vc", "rc", "aic", "et", " nic", "icing", "onic", "iac", "ac", "ct", "irc", "ot", "bc", "ican", "c", "ric", "voc", "ec", "ip", "ia", "wic", "IC", "eric", "icc", "nic", "ici", "lic", "lc", "ik", "ci", "ico", "tic", "mc", "pc", "tc", "mic", "iat", "cc", "pi", "fc", "cit", "pic", "oc"], "file_iformat": ["file_unicats", "file_ibrat", "file_mudrat", "file_ikkats", "file_unicata", "file_iformata", "file_ibata", "file_mudata", "file_ibat", "file_mudat", "file_ikkat", "file_instats", "file_iformiat", "file_ikkiat", "file_iformrat", "file_mudiat", "file_ikkrat", "file_instata", "file_instat", "file_instiat", "file_unicat", "file_ibiat", "file_uniciat", "file_ikkata", "file_iformats"], "err": ["resp", "er", "load", "msg", "usr", "rn", "r", "cb", "stat", "rank", "fee", "order", "rr", "e", " error", "test", "proc", "coord", "result", "fer", " resp", "res", "error", "Error", "fd", "race", "req", "attr"], "i": ["bi", "ij", "p", "t", "si", "index", "di", "iu", "io", "f", "m", "ix", "im", "d", "x", "id", "il", "e", "str", "I", "c", "ini", "ip", "cli", "li", "ui", "fi", "oi", "ir", "ik", "ci", "integer", "mi", "iat", "u", "ii", "pi", "b", "l", "v"], "ret": ["fun", "sys", "out", "txt", "set", "rel", "Ret", "gc", "val", "uf", "il", "jp", "no", "status", "result", "fi", "res", "alt", "mem", "new", "nt", "RET", "cmd", "flag"], "timestamp": ["timeestamp", "basename", "timename", "typtime", "typetime", "timeename", "timetime", "timtime", "basestamp", "basetime", "bastime", "timeetime", "typestamp", "typename"], "buf": ["msg", "foo", "progress", "uf", "temp", "cur", "batch", "ff", "br", "tmp", "wb", "bt", "conv", "bs", "Buffer", "empty", "data", "bytes", "vec", "kl", "seq", "mem", "cmd", "blocks", "bin", "b", "pkg", "stream", "cv", "str", "mu", "fb", "good", "proc", "ctx", "raw", "buffer", "box", "pause", "buff", "req", "pool", "cache", "wait", "bag", "boxes", "cap", "rb", "txt", "usr", "func", "cb", "uffer", "bed", "window", "read", "aka", "Buff", "arr", "bar", "bc", "tab", "fp", "result", "img", "prop", "queue", "iter", "doc", "pb", "block", "text"], "opts": ["prefs", " coptions", " copfs", "prets", " copts", "options", "OPtions", "pretions", "OPts", "pret", "OPfs", " copt", "OPt", "opfs"], "orig_nb_streams": ["orig_nb_pathers", "orig_nb_pathd", "orig_nb_inputings", "orig_nb_inputs", "orig_nb_inputers", "orig_nb_reamings", "orig_nb_reamers", "orig_nb_streamers", "orig_nb_streamings", "orig_nb_inputd", "orig_nb_reamd", "orig_nb_reams", "orig_nb_paths", "orig_nb_streamd", "orig_nb_pathings"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 22462, "substitutes": {"val": ["valid", "p", " arg", "ival", "it", "func", "vol", "ref", " eval", "value", " value", "al", "eval", "serv", "pt", "x", "tx", "Value", "data", "bit", "Val", "vec", " Val", "z", "uv", "q", "VAL", "vals", "dev", "in", "unit", " v", "als", "cal", "b", "ue", "v", "vt"], "u": ["t", "p", " tu", "o", "ru", "iu", "du", "f", "su", " su", "lu", "us", "ul", "d", "uf", "i", "cu", "uc", "c", " U", "you", "nu", " nu", " up", "pu", "bo", "uv", "q", "ui", "un", "gu", "fu", "ur", "up", "eu", "ud", "ux", "g", "au", "ou", "util", "uu", "uj", "bu", "b", "ue", "v", "uid", "tu", "upload", "ut", "U"]}}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n", "idx": 22465, "substitutes": {"linker": ["lighter", "toole", "tooler", "lockr", "linkier", "inkr", "locking", "tooller", "linking", "loadger", "lightger", "inker", "lockger", "loader", "linkger", "checkger", "lightier", "linked", "linkner", "checked", "toolner", "loading", " linke", "lighted", "locker", " linkner", "linkr", "inkger", "inked", "linke", "inkier", "checker", "checkier", "inking", "laye", "layner", " linkler", "loadr", "layler", "layer", "linkler"], "file_name": ["fileameName", "fileNamelength", " file_path", " file_no", "ile_path", "ile_Name", "file_length", "ile_name", " file_Name", "fileamename", "file_no", "fileamepath", "fileNamepath", "ile_length", "file_Name", "fileNameno", "file_address", "file_path", " file_address", "fileNameName", "fileNameaddress", "fileNamename", "fileamelength"], "start": ["name", "p", "t", "time", "end", "use", "it", "stop", "first", "begin", "source", "set", "starting", "index", "started", "check", "window", "root", "offset", "add", "length", "init", "id", "space", "skip", "data", "st", "get", "limit", "step", "base", "shift", "Start", "position", "part", "addr", "help", "rest", "import", "trans", "range", "sp", "from", "address", "pos", "len", "port", "origin", "art"], "size": ["n", "name", "time", "end", "message", "capacity", "number", "si", "index", "sum", "length", "SIZE", "offset", "scale", "score", "count", "description", "style", "resolution", "space", "e", "timeout", "empty", "data", "max", "bytes", "s", "export", "body", "shift", "height", "spec", "ize", "send", "num", "storage", "shape", "area", "Size", "range", "year", "len", "small", "news", "sent", "type"], "checksum": [" checksums", "hsums", "opensame", "cssum", "cksumb", "hsum", "checksul", "ksum", "checksub", "checksums", "cksum", "csub", "cksub", " checksumb", "checksumb", "ckssum", "ksul", " checkssum", "checksame", "checkssum", "csul", "csum", "kssum", "opensums", "ksub", "hssum", "openssum", "hsumb", "cksul", "cksame", "cksums", "opensum", " checksame"], "entry": ["search", "cue", "desc", "pair", "needed", "aux", "event", "server", "component", "job", "command", "client", "ry", "insert", "response", "comment", "list", "output", "e", "info", "data", "export", "se", "base", "connection", "see", "archive", "cell", "part", "self", "service", "inner", "rent", "ace", "ENT", "public", "instance", "parent", "way", "escape", "entity", "r", "Entry", "card", "rance", "table", "image", "inter", "def", "RY", "spec", "ptr", "try", "import", "match", "nt", "delete", "line", "valid", "csv", "element", "out", "print", "index", "set", "record", "field", "look", "check", "member", "attribute", "existent", "ries", "row", "or", "section", "query", "xml", "ment", "enter", "result", "pattern", "ent", "q", "error", "ient", "form"], "file": ["name", "t", "time", "out", "resource", "message", "model", "entity", "comment", "source", "force", "io", "record", "f", "field", "length", "offset", "channel", "format", "table", "dir", "key", "image", "filename", "url", "id", "user", "e", "il", "code", "issue", "info", "target", "data", "node", "byte", "le", "disk", "local", "handle", "body", "limit", "files", "base", "link", "full", "part", "db", "open", "buffer", "rule", "page", "File", "ile", "run", "range", "path", "util", "action", "block", "be", "cache", "form", "port", "line", "l", "angle", "type"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->internal->thread_ctx;\n\n    FrameThreadContext *fctx;\n\n    AVFrame *dst, *tmp;\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                          avctx->thread_safe_callbacks                   ||\n\n                          (\n\n#if FF_API_GET_BUFFER\n\n                           !avctx->get_buffer &&\n\n#endif\n\n                           avctx->get_buffer2 == avcodec_default_get_buffer2);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    if (!f->f->buf[0])\n\n        return;\n\n\n\n    if (avctx->debug & FF_DEBUG_BUFFERS)\n\n        av_log(avctx, AV_LOG_DEBUG, \"thread_release_buffer called on pic %p\\n\", f);\n\n\n\n    av_buffer_unref(&f->progress);\n\n    f->owner    = NULL;\n\n\n\n    if (can_direct_free) {\n\n        av_frame_unref(f->f);\n\n        return;\n\n    }\n\n\n\n    fctx = p->parent;\n\n    pthread_mutex_lock(&fctx->buffer_mutex);\n\n\n\n    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))\n\n        goto fail;\n\n    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,\n\n                          (p->num_released_buffers + 1) *\n\n                          sizeof(*p->released_buffers));\n\n    if (!tmp)\n\n        goto fail;\n\n    p->released_buffers = tmp;\n\n\n\n    dst = &p->released_buffers[p->num_released_buffers];\n\n    av_frame_move_ref(dst, f->f);\n\n\n\n    p->num_released_buffers++;\n\n\n\nfail:\n\n    pthread_mutex_unlock(&fctx->buffer_mutex);\n\n}\n", "idx": 22503, "substitutes": {"avctx": ["aucu", "varcmp", "aucontext", "avtc", "AVtxt", "cfcfg", "avertx", "avecfg", "avecmp", "auctx", "avcp", "afcu", "varctx", " avcmp", "navca", "afcontext", "avecp", "afctx", "afcp", "awctx", "awcp", "wavjp", "AVcp", "vercu", "cfcontext", "avcmp", "awjp", "avekl", "avjp", "navctx", "avercontext", "averkt", "navjp", "varkt", "averctx", "avercp", "wavcp", "aveca", "afcmp", "avercmp", "AVcontext", "awca", "vercp", "cfcmp", " avtxt", "avcu", " avcontext", " avtx", "averca", "avertc", "afjp", "avercu", "aftx", " avcfg", "avtxt", "avtx", "autc", "wavcu", "avetx", "avecontext", "avkt", "avca", "wavcontext", "wavkl", "vercontext", "navkl", "wavctx", " avtc", "avcontext", " avcu", "avertxt", "wavca", "avkl", "AVtx", "awtx", "verctx", "avectx", "avcfg", "cfctx", "AVctx", "AVca", "avejp", "afkt"], "f": ["kw", "fx", "fn", "t", "frame", "bf", "x", "ref", "alf", "h", "ef", "sf", "y", "m", "fed", "fo", "d", "fe", "fac", "uf", "fm", "e", "i", "file", "fw", "fs", "c", "info", "fb", "j", "elf", "fp", "fr", "z", "ff", "ft", "df", "q", "fi", "inf", "feat", "fu", "fa", "rf", "cf", "xf", "fen", "g", "feature", "fd", "fl", "conf", "u", "of", "form", "F", "lf", "b", "fab", "v", "fc", "l", "tf", "flow", "w"], "p": ["perm", "parent", "t", "vp", "app", "process", "ping", "pm", "tp", "m", "h", "pkg", "d", "post", "pro", "ps", "pp", "lp", "mp", "wp", "i", "c", "pa", "pers", "jp", "j", "ap", "ip", "pid", "proc", "fp", "parse", "op", "ctx", "P", "dp", "part", "pe", "up", "at", "par", "g", "patch", "sp", "rep", "pc", "pb", "np", "pg", "pool", "pre", "pi", "bp", "port", "l", "local", "cp"], "fctx": ["ftree", "fwcfg", "tcontext", "tctx", "vcfg", "fwcontext", "cfcfg", "tobj", "vcontext", " ftx", "fcontext", " fcontext", "ptree", " fcmp", "fcmp", "cfjac", "pcmp", "fcfg", "vtree", "pctx", "vtx", "fobj", "cftx", "pjac", "cfcmp", "ptx", " fobj", "vobj", "pcfg", "cfctx", "fwctx", "fjac", "pcontext", "ftx", "fwtree", "vctx", "ttx", "vjac", "cfcontext"], "dst": ["pst", "Dest", " dsts", "lot", "dsot", "dssts", "dest", "pdest", "pest", "lst", "drnd", "drest", " dot", "ldest", " dnd", "pnd", "dot", "Dnd", "drsts", "Dst", "dnd", "drst", "dsdest", "lsts", "Dsts", " dest", " ddest", "Ddest", "dsst", "ddest", "dsts"], "tmp": ["perm", "td", "resp", "orig", "t", "zip", "tt", "txt", "MP", "cb", "mmm", "tn", "m", "tp", "amps", "qq", "gm", "aaa", "err", "etc", "pkg", "mut", "pp", "mint", "uf", "mp", "timeout", "cv", "cp", "emp", "jp", "temp", "cmp", "j", "proc", "snap", "nd", "buf", "ff", "uv", "ptr", "sp", "nt", "pb", "np", "buff", "obj", "cache", "tm", "b", "jj", "v", "vp", "tf", "vv", "attr", "vt"], "num_released_buffers": ["num_released_rowsered", "num_released_itERS", "num_released_buffensions", "num_released_Buffensions", "num_released_rowsmers", "num_released__bufered", "num_released_Buffels", "num_released_flushers", "num_released_integackers", "num_released_integered", "num_released_buffmers", "num_released__buffered", "num_released_Buffered", "num_released_Buffeners", "num_released_integers", "num_released_buffackers", "num_released_Buffackers", "num_released_streammers", "num_released_Buffmers", "num_released_bufeners", "num_released_itered", "num_released__bufers", "num_released_flushered", "num_released_bufferered", "num_released_Bufferers", "num_released__buffeners", "num_released_binders", "num_released_buffERS", "num_released__bufeners", "num_released_bindels", "num_released_rowserers", "num_released_buffeners", "num_released_bindackers", "num_released_bufings", "num_released__buffings", "num_released_bufers", "num_released_bufferers", "num_released_streamerers", "num_released_itensions", "num_released_bufferERS", "num_released__buffers", "num_released_iters", "num_released_streamers", "num_released_Buffers", "num_released_flushings", "num_released_bindered", "num_released__bufings", "num_released_streamered", "num_released_bufered", "num_released_bufferensions", "num_released_buffings", "num_released_Buffings", "num_released_buffered", "num_released_BuffERS", "num_released_rowsers", "num_released_integels", "num_released_flusheners", "num_released_buffels"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n", "idx": 22531, "substitutes": {"queue": ["master", "history", "quote", "quit", "message", "frame", "cue", "list", "Queue", "dq", "menu", "ques", "table", "topic", "required", "Q", "forced", "que", "batch", "worker", "qa", "buf", "archive", "event", "q", "server", "seq", "entry", "buffer", "component", "qu", "sequence", "phrase", "prefix", "command", "job", "block", "priority", "store", "client", "port", "grid", "ue", "line", "flag", "file", "channel"], "free_func": [" free_obj", " freeerunc", " free_unc", "freeerobj", "free_unc", "de_func", " freeerobj", "freeerunc", "free_f", " free_var", "de_f", "de_unc", "free_obj", "free_var", " freeerfunc", "freeerfunc", " freeervar", "freeervar", "free_kw", "de_kw"]}}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534, "substitutes": {}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n", "idx": 22545, "substitutes": {"val": ["valid", "p", " arg", "ival", " num", "func", " slot", "index", "vol", "ref", " x", " eval", "bal", "value", " value", "add", "al", "fee", "eval", " update", " tx", "loc", "AL", "il", "slot", "tx", "test", "Val", " Val", " interval", "pol", "ctx", "num", "res", "cond", "VAL", "vals", " v", "als", "cal", "sol", "v", "el", "vt"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 22552, "substitutes": {"dc": ["kw", "DC", "rc", "dm", "ic", "vc", "di", "dk", "dd", "desc", "mm", "du", "cus", "cca", "exec", "disc", "ac", "gc", "dir", "d", "def", "dt", "bc", "cs", "cd", "cu", "wp", "currency", "c", "dim", "ds", "dl", "ec", "coord", "mac", "ctx", "ga", "df", "conn", "design", "draw", "dat", "dp", "lc", "cm", "db", "sc", "de", "dr", "doc", "mc", "params", "pc", "cr", "tc", "cmd", "tm", "rec", "nc", "cc", "ctl", "fc", "ca", "da", "oc"], "t0": ["t10", " tk", "timeZero", "T8", "t8", "wtable", "T1", "tempZero", "kt0", "tZero", " t000", "time0", " toval", "table", " t8", "wt0", "tempoval", "tk", "kt000", "T000", "Table", "t1", " T0", "time10", "temp10", "wt8", "vt0", "t3", "kt1", "wt1", " t10", "temp0", "t000", "Tk", " table", " tZero", "ktk", " t1", "timeoval", "vt3", "toval", "T3", "T0", " T1", "vt1", " t3"]}}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "AVInputFormat *av_find_input_format(const char *short_name)\n\n{\n\n    AVInputFormat *fmt = NULL;\n\n    while ((fmt = av_iformat_next(fmt)))\n\n        if (match_format(short_name, fmt->name))\n\n            return fmt;\n\n    return NULL;\n\n}\n", "idx": 22559, "substitutes": {"short_name": ["shortNamenames", "short_value", "short_names", "long_Name", "shortableName", "shortablename", "short_word", "long_name", "shortNamename", "shortablevalue", "short_Name", "shortNameword", "shortNameName", "long_value", "long_names", "long_word"], "fmt": ["pmp", "fabkt", " ftm", " fkt", "htm", "tlt", " fnt", "fabld", "tnt", "vkt", "fabformat", "mtm", "vmt", "fnt", " fformat", "aflt", "mformat", "ffformat", "pmt", "hformat", "afmt", " flt", "ttm", "hmt", "vformat", "ftm", "tmt", "afnt", "hmp", "mmt", "faclt", "fkt", "facmt", " fpl", "fmp", "fflt", "fformat", "factm", "flt", "fld", "facformat", "aftm", "hpl", "mkt", "hkt", " fmp", "fpl", "plt", "hlt", "ffmt", " fld", "vld", "fabmt", "ppl", "fftm"]}}
{"project": "FFmpeg", "commit_id": "b791a0831b0a027e7ba4eb6961cc0180472ac603", "target": 1, "func": "static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,\n\n                                      int mm_flags)\n\n{\n\n#if HAVE_SSE2_INLINE\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {\n\n        c->idct_put              = ff_idct_xvid_sse2_put;\n\n        c->idct_add              = ff_idct_xvid_sse2_add;\n\n        c->idct                  = ff_idct_xvid_sse2;\n\n        c->idct_permutation_type = FF_SSE2_IDCT_PERM;\n\n    }\n\n#endif /* HAVE_SSE2_INLINE */\n\n\n\n#if HAVE_SSE2_EXTERNAL\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;\n\n    if (mm_flags & AV_CPU_FLAG_ATOM) {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;\n\n    } else {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_sse2;\n\n    }\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_sse2;\n\n    } else if (!(mm_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        c->apply_window_int16 = ff_apply_window_int16_round_sse2;\n\n    }\n\n    c->bswap_buf = ff_bswap32_buf_sse2;\n\n#endif /* HAVE_SSE2_EXTERNAL */\n\n}\n", "idx": 22597, "substitutes": {"c": ["coll", "p", "t", "rc", "a", "cont", "o", "ce", "set", "container", "r", "dc", "m", "h", "err", "abc", "co", "ac", "etc", "ct", "d", "gc", "enc", "call", "con", "unc", "cs", "e", "bc", "cu", "cv", "ec", "content", "C", "ctx", "lc", "cm", "cf", "ch", "ci", "g", "new", "anc", "config", "mc", "pc", "cam", "conf", "tc", "cache", "can", "nc", "cc", "ca", "v", "fc", "l", "cp", "chain"], "avctx": ["aveobj", "navkw", "AVhw", "avhistory", "avcontext", " avcb", "avecb", "avhw", "avcas", "averctrl", "averhelp", "navctx", "varcontext", "avercontext", "avcb", "auctx", "avehw", "aveclient", "averctx", "ivercas", "varctx", "avkw", "avecontext", "varhelp", "navcontext", "auclient", "AVclient", " avhistory", " avctrl", "avclient", " avhelp", "avhelp", "ivercontext", "iverctx", " avkw", "avekw", "AVobj", "varcas", "avectx", "varhistory", "varctrl", "AVctx", " avcontext", "avctrl", " avcas", "avobj", "iverhistory", "navcb", "auobj", "auhw"], "mm_flags": ["mmetricpackages", "mmanystats", "mmanyflags", "ml_properties", "mletricmembers", "mm_stats", "mm417packages", "mm68flags", "mmetricvalues", "mm_type", "mletricstats", "mm2flags", "mm417values", "ml_stats", "mmanyproperties", "mmetricstats", " mm2sign", "mn417packages", "mletricflags", "mm_members", "mm2flag", "mm_values", "ml_flags", "mm2sign", "mm_sign", "mm_properties", " mm2type", " mm_sign", "mmetricproperties", "mmetricflags", "mn417values", "mletricproperties", "mm_flag", "mmetricmembers", "mmagicpackages", " mm_flag", "mmagicflags", "mm_includes", "mmagicincludes", "mm68type", "mm68flag", "ml_members", "mm2type", "mn_flags", "mn_values", "mm417includes", " mm2flag", "mn_packages", "mn_includes", "mmagicvalues", "mn417includes", "mmetricincludes", "mn417flags", "mm68sign", "mm417flags", "mm_packages", "mmanymembers", " mm_type", " mm2flags"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int au_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 24)\n\n        return 0;\n\n    if (p->buf[0] == '.' && p->buf[1] == 's' &&\n\n        p->buf[2] == 'n' && p->buf[3] == 'd')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 22601, "substitutes": {"p": ["er", "t", "out", "vp", "it", "a", "r", "app", "f", "m", "tp", "pm", "progress", "y", "d", "pkg", "post", "ps", "pro", "pp", "lp", "power", "mp", "wp", "pt", "info", "c", "pa", "jp", "j", "ap", "ip", "pod", "parse", "op", "P", "q", "dp", "part", "up", "at", "ad", "g", "rep", "pc", "pb", "np", "cache", "pre", "b", "bp", "v", "pat", "press", "cp", "att", "l", "w"]}}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615, "substitutes": {"opts": [" coptions", " opTs", " opars", "opTS", "ioptions", "optars", "optts", "optpt", " copTS", "Opts", "opars", "Ops", "opTs", "optes", "ops", "OPars", " opents", "ioptes", "optents", " opTS", " optes", "opters", " options", "OPs", "Opters", "OPTs", " ops", "OPts", "iopTS", "oppt", "opents", "optns", "OpTs", "operpt", "operents", "operns", " opns", " coptes", "optTs", " copts", "options", "iopts", "operts", "OPters", "opns", "optters", " oppt"], "machine": ["Machine", "volume", "engine", "way", "normal", "model", "frame", "slave", "memory", "me", "management", "di", "achine", "m", "device", "window", "zone", "session", "domain", "unknown", "power", "brain", "user", "mobile", "money", "vm", "managed", "node", "mo", "ghost", "mouse", "mode", "company", "manager", "module", "server", "mobi", "owner", "storage", "mem", "OTHER", "human", "mc", "smart", "interface", "computer", "iso", "mob", "metadata", "monitor", "handler", "network", "agent", "chain", "instance"], "filename": ["fn", "name", "n", "username", "println", "SOURCE", "txt", "rn", "fle", "bf", "mson", "jpg", "source", "f", "kan", "lua", "title", "src", "Filename", "ames", "ame", "fs", "journal", "kl", "files", "fp", "family", "fil", "png", "nm", "directory", "fi", "river", "buffer", "location", "nil", "ren", "subject", "path", "ename", "prefix", "fd", "json", "FIL", "bas", "til", "file", "wav"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,\n\n                        int *duration)\n\n{\n\n    int64_t out_pts = AV_NOPTS_VALUE;\n\n    int removed_samples = 0;\n\n\n\n#ifdef DEBUG\n\n    ff_af_queue_log_state(afq);\n\n#endif\n\n\n\n    /* get output pts from the next frame or generated pts */\n\n    if (afq->frame_queue) {\n\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n\n    } else {\n\n        if (afq->next_pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->next_pts - afq->remaining_delay;\n\n    }\n\n    if (pts) {\n\n        if (out_pts != AV_NOPTS_VALUE)\n\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n\n        else\n\n            *pts = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n\n       for the output packet and leave all frames in the queue */\n\n    if (afq->remaining_delay >= nb_samples) {\n\n        removed_samples      += nb_samples;\n\n        afq->remaining_delay -= nb_samples;\n\n    }\n\n    /* remove frames from the queue until we have enough to cover the\n\n       requested number of samples or until the queue is empty */\n\n    while (removed_samples < nb_samples && afq->frame_queue) {\n\n        removed_samples += afq->frame_queue->duration;\n\n        delete_next_frame(afq);\n\n    }\n\n    afq->remaining_samples -= removed_samples;\n\n\n\n    /* if there are no frames left and we have room for more samples, use\n\n       any remaining delay samples */\n\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n\n        int add_samples = FFMIN(afq->remaining_samples,\n\n                                nb_samples - removed_samples);\n\n        removed_samples        += add_samples;\n\n        afq->remaining_samples -= add_samples;\n\n    }\n\n    if (removed_samples > nb_samples)\n\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n\n    if (duration)\n\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n\n}\n", "idx": 22637, "substitutes": {"afq": ["agg", "affce", "efdq", "affz", "affiq", "agiq", "abquire", "afqu", "afg", "awquest", "authq", "afqq", "afft", "abcq", "afque", " afcp", "abv", "afqt", "fag", "agck", "fach", " afdq", "aftkg", "affg", "agdq", "awv", "abciq", "agq", "faq", "afquire", "afw", "awry", "abch", "alfce", "famck", "afcp", "ajq", "authque", "afdq", "authce", "ajay", "abqueue", "fary", "abq", "afch", "affq", "awq", "tifq", "alogq", "affrequ", "affcl", "alfquest", " afog", "famqu", "afj", "ajkg", "famq", "afck", "afqueue", "alogque", "awp", " afquest", "ajce", "afay", "awck", "ajry", " afquire", "affay", "tifrequ", "ajrequ", "afog", "awreq", "aftce", "abquest", "abcp", "agque", "aftque", "famque", "avcl", "rafck", "abj", "avque", "afz", "afce", "awg", "afcl", "avquest", "alogqu", "famqt", "aptquest", "affqueue", "ajdq", "alfk", "affque", "aitquire", "aitcp", "authkg", "abreq", "alfg", "rafq", "aft", "aftquest", "abcl", "alfck", "tifay", "face", "ajw", " afg", "affp", "avqs", "alogqt", "avqt", "rafque", "ajque", "awqt", "afkg", "abdq", " afk", "agreq", "abcdq", "ajqueue", "famkg", "abk", "alfz", "affdq", "awqs", "afv", "affch", "afrequ", "affkg", "avq", "fareq", "alfcl", "agqq", "ajqt", "alfdq", "afqs", "awch", "abt", "ajquest", "aptce", "afry", "afquest", "abry", "avreq", "afk", "afiq", "aitq", "alfque", "affw", "faqueue", "efq", "affry", "ajck", "affqt", "abp", "alfq", "affk", "affog", "affj", "affreq", "efk", "aptq", "eft", "awqq", "rafkg", "abcque", "aftq", "ajj", "ajqu", "affck", "alfog", "abw", "affquest", "afp", "ajreq", "awque", "tifquest", "aptque", "awqueue", "afreq", "affqs", "alfch", "affv", "ajz", " afqq", "aitquest", "awdq"], "nb_samples": ["nb_sinples", "nb_Stones", "nb_resultsamps", "nb_sems", "nb_inslements", "nb_resamples", "nb_svples", "nb_Saces", "nb_Slements", "nb_ssamples", "nb_damples", "nb____samples", "nb_saces", "nb_Sources", "nb_Samples", "nb_seacks", "nb_Sples", "nb_Sicks", "nb_isacks", "nb_sinplays", "nb_seources", "nb____sinamples", "nb___sances", "nb_restones", "nb_teststones", "nb_insources", "nb_eicks", "nb___samps", "nb_fpaces", "nb_sples", "nb_testsamples", "nb_Siles", "nb___samples", "nb_Sacks", "nb_isamples", "nb_sinamps", "nb_siles", "nb_spaces", "nb_Sems", "nb_testsances", "nb_seamples", "nb_sicks", "nb_eamps", "nb_nspaces", "nb____sinamps", "nb____splays", "nb_resultsamples", "nb_sances", "nb_sinamples", "nb_resances", "nb_usems", "nb_sacks", "nb_seaces", "nb_sources", "nb_eamples", "nb_nsamples", "nb_usamps", "nb_isamps", "nb_Sourses", "nb_famples", "nb____samps", "nb_Splays", "nb_isiblings", "nb_samps", "nb_insamples", "nb_ssamps", "nb_samp", "nb_stones", "nb___stones", "nb_svamples", "nb_fourses", "nb_usicks", "nb_damp", "nb____sinplays", "nb___resances", "nb_siblings", "nb_insamps", "nb_usamples", "nb_nsamps", "nb_Samp", "nb_resultsiles", "nb_Siblings", "nb____sples", "nb_isaces", "nb___resamples", "nb_sslements", "nb_seamps", "nb_Sances", "nb_Spaces", "nb_eems", "nb_svplays", "nb_damps", "nb_ssources", "nb_famps", "nb_resultsiblings", "nb_svamps", "nb_resamps", "nb_Samps", "nb_dources", "nb___restones", "nb___resamps", "nb_nsourses", "nb_splays", "nb____sinples", "nb_slements", "nb_seamp", "nb_sourses", "nb_isiles", "nb_testsamps"], "pts": ["PTries", "reqs", "uptions", "aptxs", "ptions", "iptps", "ppes", "ptxs", "pointS", "apts", "otS", "pointxs", "ntS", "posxs", "ppers", "montS", "aptps", "poss", "ipters", "ppxs", "ptds", "ptes", "pointries", "ptries", "PTts", "periodts", "ntns", "uptxs", "nts", "apters", "ptns", "posps", "iptxs", "PTns", "points", "reqions", "periodds", "PTxs", "pointts", "iptts", "ptts", "PTs", "ptps", "aptes", "pters", "aptts", "pointds", "periodxs", "montns", "otries", "ppions", "ots", "posts", "pps", "ipts", "periods", "ppds", "uptds", "monts", "ptS", "reqds", "PTS", "ppts", "PTds", "iptes", "reqxs", "upts"], "duration": ["uration", "volume", "quality", "t", "during", "time", "capacity", "confidence", "urations", "memory", "depth", "delay", "dates", "amount", "length", "window", "database", "latest", "relation", "d", "runtime", "description", "resolution", "dt", "document", "years", "timeout", "Duration", "span", "generation", "size", "century", "portion", "status", "version", "directory", "video", "position", "frequency", "padding", "properties", "performance", "sequence", "dimension", "date", "ts", "fd", "metadata", "period", "recorded", "distance", "dose"]}}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652, "substitutes": {"bs": ["bi", "ubis", "sys", "lbs", "bf", "os", "ubs", "ns", "bps", "BS", "aos", "gb", "ps", "lb", "ib", "cs", "bc", "fs", "rs", "gs", "ds", "bis", "ls", "bm", "bh", "bles", "vs", "js", "its", "ts", "obs", "pb", "blocks", "bas", "sb", "b", "bp", "bb"], "base": ["bi", "master", "name", "history", "parent", "p", "Base", "pse", "basic", "start", "state", "sys", "source", "boot", "back", "f", "h", "root", "ase", "mb", "ps", "id", "bar", "target", "bit", "max", "pa", "st", "reset", "bot", "profile", "se", "extra", "bo", "server", "bare", "db", "buffer", "super", "bound", "sp", "prefix", "based", "bu", "bottom", "cache", "bas", "sb", "b", "bp", "as", "file", "origin", "bb"], "base_id": ["base__name", "buffer_ip", "base_i", "base_link", "baseuulink", "buffer_name", "base__ip", " base_link", "buffer_id", "baseuuname", "baseuui", "base__id", " base_i", " base_name", "base_type", "buffer_type", "base_ids", "base_ip", "buffer_ids", "base_name", "baseuuid", "base__ids"], "speed": ["start", "sex", "slow", "sum", "length", "score", "scale", "rank", "fee", "driver", "fast", "count", "prof", "stream", "power", "Speed", "weight", " size", "pri", "size", "mph", "imp", "status", " speeds", "height", "peed", " Speed", "xff", "peg", "seek", "sw", "frequency", "spe", "buffer", "command", "EED", "priority", "fps", "port"], "cb": ["fn", "rb", "rc", "ck", "bf", "func", "cn", "callback", "cgi", "gb", "lb", "CB", "ctrl", "bc", "cs", "cd", "cv", "c", "fb", "good", "proc", "fp", "ff", "ctx", "cod", "cor", "db", "CBS", "cf", "job", "pb", "tc", "sb", "cc", "b", "nc", "obb", "fc", "cp", "cfg", "bb"], "opaque": [" opaques", "opois", "opula", "ipatile", "popatile", "bitaque", "ipaques", "ipois", "ipacity", " Opaque", " opica", " opque", " opois", "ipaque", "bitatile", " opacity", "opacity", "opica", "opaques", "optaque", "optque", "bitula", "optois", "ipica", " Opaques", "popacity", "optacity", "bitacity", "ipula", "popula", " Opacity", "popaque", "ipque", "opque", " Opica", "opatile"], "errp": ["sprr", "errps", "errwp", " errwp", "sprpo", "errpa", "errr", " errpo", "rrpa", " erps", " errpa", "ferp", "sprp", " erpa", " erwp", " erp", " errps", " errr", "rrwp", "errpo", "rrps", "ferr", "rrp", "ferpa", "ferpo", "sprpa"], "s": ["n", "comm", "i", "p", "t", "is", "start", "a", "sing", "o", "r", "single", "os", "f", "m", "h", "ns", "ss", "y", "ses", "stats", "e", "ps", "eps", "cs", "sports", "sts", "rs", "gs", "space", "aws", "fs", "c", "ds", "services", "local", "j", "se", "plays", "ls", "details", "sam", "ms", "sh", "sv", "vs", "ssl", "hs", "scripts", "S", "js", "g", "es", "ins", "sq", "sp", "ts", "qs", "less", "store", "sb", "sol", "b", "l", "so", "syn", "sl", "w"], "co": ["coll", "ano", "com", "ck", "o", "coe", "io", "go", "cover", "cro", "fo", "Co", "gc", "flo", "con", "po", "ro", "cs", "cu", "or", "ko", "c", "mo", "cur", "lo", "coord", " Co", "op", "bo", "ctx", "cor", "aco", "CO", "cm", "cf", "ci", "ico", "sp", "vo", "oe", "pc", "wo", "cycle", "soc", "tc", "nc", "cc", "so", "cons", "oc"]}}
{"project": "FFmpeg", "commit_id": "2711cb28f46463760f0326d806fe5ef9551ade2c", "target": 1, "func": "static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){\n\n    RateControlContext *rcc= &s->rc_context;\n\n    AVCodecContext *a= s->avctx;\n\n    const int pict_type= rce->new_pict_type;\n\n    const double last_p_q    = rcc->last_qscale_for[P_TYPE];\n\n    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];\n\n\n\n    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))\n\n        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;\n\n    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)\n\n        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;\n\n\n\n\n    /* last qscale / qdiff stuff */\n\n    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){\n\n        double last_q= rcc->last_qscale_for[pict_type];\n\n        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;\n\n\n\n        if     (q > last_q + maxdiff) q= last_q + maxdiff;\n\n        else if(q < last_q - maxdiff) q= last_q - maxdiff;\n\n    }\n\n\n\n    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring\n\n\n\n    if(pict_type!=B_TYPE)\n\n        rcc->last_non_b_pict_type= pict_type;\n\n\n\n    return q;\n\n}", "idx": 22655, "substitutes": {"s": ["n", "p", "sys", "times", "settings", "sa", "r", "os", "set", "h", "m", "ns", "ss", "ses", "d", "ps", "x", "cs", "e", "sts", "i", "rs", "gs", "fs", "aws", "c", "ds", "se", "ls", "ex", "sv", "ats", "hs", "S", "js", "es", "ins", "sq", "sb", "cc", "b", "as", "v", "w"], "rce": [" rCE", "rcle", "prce", "mrcle", "mrCE", "Rce", "mce", "rCE", "Rces", "mrce", "prCE", " rcle", "arcle", "rces", "mcle", " rces", "RCE", "prces", "arCE", "mrces", "prcle", "Rcle", "arce", "mCE", "mces", "arces"], "q": ["qv", "quality", "p", "t", "load", "question", "out", "it", "iq", "quit", "print", "comment", "requ", "force", "dq", "check", "h", "f", "m", "qq", "y", "qt", "pkg", "d", "pp", "x", "e", "Q", "weight", "bit", "query", "qi", "ip", "quant", "charge", "qa", "z", "lock", "shift", "k", "quest", " Q", "queue", "aq", "qu", "qual", "g", "ch", "eq", "sq", "req", "u", "qs", "quad", "place", "ll", "quick", "ue", "l", "cp", "w"], "rcc": [" rco", " rctl", "nrcy", "erpc", "rrdd", "rpc", "rctd", "nrct", "rtc", "rrbo", "ercc", "errctl", "erce", "srpc", "rrctl", " rct", "rcdd", "srctl", "rdd", " rcell", "rccc", "rrcc", "rarcc", "krcc", "crck", "rtd", "ercca", "nrCC", "rck", "rrtd", "wco", " rac", "rCC", "mce", "radcell", "mcc", " rbo", "rcca", "sracc", "rracc", "mpc", "wcc", "rct", "erck", "rac", "radacc", "nrctl", "srcca", "rartd", "Rcc", "rece", "srck", "rardd", "retc", "rco", "Rct", "crtc", " rck", "Rcci", "crcc", "crce", "rcy", "rcacc", "mcca", "rbo", "rrcell", "srac", " rtc", "rrcci", "reck", "radbo", "nrcc", "srcraft", " racc", "srcc", "eracc", "rcci", "rccell", "radcc", "srce", "racc", "rcco", "nrcci", "errcci", "rctl", "krac", " rCC", " rcraft", " rcci", "recc", "rarcell", "errcc", "RCC", "rcell", "wck", "rcraft", "wacc", "rcck", "rrcy", "krcraft", "errcy", "krctl"], "a": ["ed", "aj", "ee", "er", "p", "eas", "all", "t", "element", "any", "am", "access", "sa", "app", "set", "da", "ack", "ai", "f", "h", "window", "attribute", "abc", "al", "aka", "ac", "act", "sta", "aw", "ar", "na", "ata", "ea", "i", "e", "or", "c", "pa", "aff", "ao", "oa", "aa", "ast", "ab", "img", "aux", "ga", "A", "ia", "dev", "at", "area", "es", "ae", "au", "common", "angular", "ache", "era", "ak", "ma", "an", "b", "as", "ca", "att", "el", "apa", "acc", "w"]}}
{"project": "FFmpeg", "commit_id": "67400f6b6219892ab7a555fb61ef979c857692d7", "target": 0, "func": "static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n\n    int64_t pos = avio_tell(pb);\n\n\n\n    if (!track) { /* no media --> data handler */\n\n        hdlr      = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr     = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr     = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            hdlr_type = \"soun\";\n\n            descr     = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = \"sbtl\";\n\n            else                                      hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {\n\n            hdlr_type = \"hint\";\n\n            descr     = \"HintHandler\";\n\n        }\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"hdlr\");\n\n    avio_wb32(pb, 0); /* Version & flags */\n\n    avio_write(pb, hdlr, 4); /* handler */\n\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track || track->mode == MODE_MOV)\n\n        avio_w8(pb, strlen(descr)); /* pascal string */\n\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n\n    if (track && track->mode != MODE_MOV)\n\n        avio_w8(pb, 0); /* c string */\n\n    return update_size(pb, pos);\n\n}\n", "idx": 22662, "substitutes": {"pb": ["td", "resp", "p", "rb", "vp", "pack", "func", "cb", "pm", "tp", "gb", "gc", "pkg", "mb", "pt", "pp", "lp", "uf", "mp", "wp", "bc", "lb", "pl", "bj", "tk", "tab", "PB", "fb", "jp", "asm", "proc", "nb", "xp", "fp", "buf", "ctx", "bh", "pr", "ub", "tmp", "wb", "dp", "buffer", "px", "pan", "patch", "amp", "stab", "sp", "erb", "aus", "pc", "np", "pg", "tc", "emb", "pool", "sb", "bs", "b", "bp", "orp", "pad", "cp", "bb"], "track": ["roll", "move", "staff", "ck", "ack", "scan", "th", "contact", "tk", "trip", "jp", "batch", "feature", "job", "tc", "upload", "tf", "train", "Track", "comment", "param", "sync", "order", "complete", "rr", "package", "trace", "mt", "bind", "send", "rule", "kick", "sort", "cmd", "tm", "cp", "t", "sys", "tag", "task", "tn", "rank", "pkg", "call", "skip", "parse", "sound", "report", "try", "stack", "match", "config", "range", "req", "store", "metadata", "require", "save", "tt", "btn", "txt", "index", "set", "record", "tracks", "check", "tp", "add", "transform", "row", "tab", "tracking", "tr", "claim", "rt", "jump", "rack", "seek", "trak", "rm", "find", "hold", "form", "rec"], "hdlr": ["wdlr", "dhurl", "wdhl", "mdlt", "hdurl", "hydlr", "hydler", "hrl", "hler", "dhrl", "hdhl", "mdlly", "mdLR", "handlly", "HDhr", "hhr", "edlr", "edlt", "hdhr", "dhlr", "hdlly", "mdlr", "hLR", "edLR", "hurl", "HDler", "hdrl", "hdler", "mdler", "wdrl", "handrl", "hydrl", "HDurl", "hlr", "hdLR", "dhhr", "dhler", "handlr", "HDlr", "hydlly", "dhhl", "hlt", "mdhl", "hdlt", "edrl", "mdrl", "wdler", "handler"], "descr": ["desctr", "escral", "specr", "specrt", " desctr", "Descl", "Descrs", "Descur", "desr", "descl", "descR", "descre", "deslr", "riptlr", " desclr", "descriptionres", "riptre", "descerr", "descriptionrt", "descriptionbr", "reasonrs", "DescR", "descriptionlr", "descriptionrs", "Desclr", "reasonrem", "hdrem", "desclr", " descrs", " descrt", "descres", "DESrs", "desrl", "descn", " descbr", "descur", "Descrb", "descrem", " descsr", "riptur", "Desctr", "Descrl", "desre", "scrb", "specrs", "Descrr", "specbr", " descrb", "desur", "descrb", "scl", "desl", " descn", "esclr", "hdres", "scR", "DESerr", "hdral", "descsr", " descrem", "descriptionr", "descral", "descrt", "escR", "Descerr", " descerr", "riptr", "riptR", "descrr", " descres", "hdrs", "hdR", "descriptionsr", "Descre", "reasonsr", " descrr", "DESrr", "escrl", "DESr", "escl", "escr", "riptral", "hdsr", "Descr", "descbr", "descrs", "scr", "Descn", "reasonr", "specn", "hdr", "specsr", "desR", "spectr", " descR", "descrl", " descl"], "hdlr_type": ["hdlr_table", "hdrl_ype", "hdl_role", "hdlr_style", "hdlr_file", "hdr_types", "hdr_role", "hdlr_tag", "hdrl_role", "hdrl_TYPE", "hdrex_pe", "hdlr0type", "hdrl_ver", "hdlr___result", "hdlr_name", "hdr_type", "hdrl_file", "hdl_name", "hdlr_operator", "hdrex_type", "hdlr_Type", "hdlr_TYPE", "hdr_TYPE", "hdr_result", "hdrl_tag", "hdrl_name", "hdlr___role", "hddr_type", "hdlr___TYPE", "hdr_Type", "hdrl_type", "hdlr_ver", "hdlr_types", "hdrex_operator", "hdl_tag", "hdlr_pe", "hdlr___type", "hddr_name", "hdlr_role", "hdlr0table", "hdrex_tag", "hdlr0types", "hdl_type", "hdlr_ype", "hddr_TYPE", "hdr_table", "hdlr0Type", "hddr_style", "hdlr_result"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683, "substitutes": {}}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "substitutes": {"file": ["enable", "name", "valid", "present", "view", "message", "model", "resource", "print", "entity", "source", "f", "type", "field", "check", "foo", "null", "format", "dir", "table", "key", "image", "filename", "complete", "user", "e", "bar", "required", "forced", "le", "local", "files", "base", "fp", "word", "link", "full", "event", "db", "class", "buffer", "rule", "report", "page", "given", "template", "File", "ile", "path", "command", "block", "address", "email", "port", "line", "chain", "channel"]}}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_probe(AVProbeData *p)\n\n{\n\n    const unsigned char *ptr = p->buf;\n\n    int i, v, num = 0;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3;  /* skip UTF-8 BOM */\n\n\n\n    while (*ptr == '\\r' || *ptr == '\\n')\n\n        ptr++;\n\n    for (i=0; i<2; i++) {\n\n        if ((num == i || num + 1 == i)\n\n            && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)\n\n            return AVPROBE_SCORE_MAX;\n\n        num = atoi(ptr);\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22702, "substitutes": {"p": ["n", "t", "a", "r", "o", "f", "m", "h", "tp", "d", "pkg", "pp", "mp", "data", "c", "pa", "s", "jp", "j", "ap", "fp", "buf", "P", "q", "dp", "g", "pc", "pb", "b", "bp", "cp", "w"], "ptr": ["expr", "cert", "dep", "desc", "length", "rel", "th", "pt", "loc", "uf", "eth", "md", "cur", "fr", "assert", "hr", "br", "prim", "prime", "inters", "pos", "pointer", "pointers", "vector", "rev", "ind", "coord", "deg", "pr", "tor", "adr", "scroll", "dr", "ts", "pend", "rep", "pc", "cmd", "grow", "push", "td", "pert", "heads", "r", "ref", "cro", "ps", "inter", "proc", "buf", "ctx", "sh", "buffer", "sp", "buff", "req", "obj", "lr", "dh", "alloc", "depth", "Ptr", "index", "off", "tp", "offset", "src", " pointer", "arr", "pl", "ped", "tr", "fp", "shift", "grad", "hl", "addr", "iter", "js", "fd", "address", "each", "pad", "ctr"], "i": ["n", "bi", "ij", "t", "is", "\u0438", "ic", "it", "si", "o", "di", "index", "iu", "ai", "f", "xi", "m", "ix", "y", "multi", "im", "zi", "ei", "ie", "x", "id", "um", " ii", "sim", "ind", "I", "c", "s", "qi", "ki", "ini", "j", "ti", "ip", "li", "ui", "fi", "num", " ni", "in", "ci", "mi", "u", "ii", "pi", "l", "ish", "hi"], "v": ["n", "qv", "t", "vc", "vi", "f", "h", "m", "y", "conv", "vr", "x", "va", "cv", "vm", "c", "av", "j", "tv", "uv", "k", "q", "sv", "vs", "vt", "g", "ev", "u", "nv", "b", "l", "V", "lv", "vv", "w"]}}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 22705, "substitutes": {"s": ["n", "p", "t", "is", "sys", "state", "set", "h", "m", "ss", "ns", "ims", "ses", "sd", "stats", "d", "ps", "cs", "sts", "sports", "fs", "gs", "aws", "rs", "c", "e", "pers", "bis", "ds", "st", "j", "se", "status", "south", "spec", "ls", "ms", "sv", "sw", "ats", "hs", "self", "S", "js", "es", "g", "sq", "ts", "sp", "qs", "sb", "b", "v", "so", "w"], "dev": ["ver", "Dev", "dd", "boot", "desc", "device", "serial", "disc", "fo", "sd", "dn", "act", "d", "enc", "tech", "pro", "val", "loc", "def", "conn", "pri", "develop", "test", "var", "des", "hw", "pub", "DEV", "buf", "ve", "grad", "res", "gu", "devices", "dem", "de", "priv", "mem", "ad", "wd", "adv", "vo", "cam", "conf", "pad", "v", "eng", "ev", "serv"], "bus": ["loop", "sys", "way", "bolt", "os", "boot", "vol", "back", "root", "us", "driver", "dir", "bs", "board", "loc", "bridge", "user", "bc", "bar", "mount", "Bus", "data", "bill", "host", "proc", "lock", "buf", "bur", "BUS", "box", "block", "pool", "pos", "b", "phys", "local", "chain"], "qdev": ["qqver", "qbus", "qDev", "Qev", "qqserv", "qdata", "qudiv", "qqdev", "qver", "hdev", "hev", " qev", "qdiv", "pserv", "Qdev", "pev", "qudev", "hbus", "iqdata", "quserv", " qdiv", "pbus", "qudevice", "QDev", "qdevice", "qudata", "qqev", " qbus", "iqdiv", "pDev", "quev", "qserv", "iqdev", " qdata", " qDev", "Qdevice", "qev", "pdevice", "iqdevice", "pver", " qdevice", "hDev", "quver"], "next": ["bi", "txt", "first", "sec", "output", "nr", " NEXT", "ns", "children", "Next", "ner", "current", "nn", "data", "node", "proc", "z", "ng", "buf", "future", "li", "ptr", "link", "child", "tmp", "seq", "adj", "new", "sequence", "sq", "path", "sub", "prev", "after", "nl", "gen", "ne", "network", "net", "chain"], "pdev": ["ptDev", " pden", "Pden", "pkgdev", "pden", "pdef", "pkgdes", "pgu", " pdevice", "Pdef", "pkgev", "pdes", "qdes", "ptdevice", "pev", "ppdev", "Pev", "pkgdevice", "qdevice", "ppdevice", " pgu", " pdef", "pDev", "ptdev", "piev", "ppDev", " pev", "piden", "qev", "ptgu", "Pdev", "pidef", "pidev", "pdevice", "ppgu", " pDev", " pdes"], "pc": ["p", "vc", "dc", "pm", "PC", "ac", "disc", "ps", "pt", "pp", "lp", "pl", "mp", "cs", "bc", "c", "pa", "proc", "pod", "psc", "ctx", "pn", "pr", "lc", "px", "mc", "pb", "cam", "tc", "soc", "nc", "cc", "pi", "fc", "cp", "pic"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 22709, "substitutes": {"job": ["jar", "build", "com", "org", "process", "task", "group", "dq", "hub", "ob", "program", "image", "row", "node", "jp", "batch", "j", "band", "jobs", "low", "cell", "manager", "web", "module", "queue", "jam", "map", "project", "obs", "block", "pool", "cmd", "work", "Job", "jj", "gov"], "speed": ["density", "time", "start", "capacity", "delay", "slow", "efficiency", "sum", "length", "score", "scale", "ss", "rank", "fast", "wage", "payment", "power", "when", "weight", "Speed", "ly", "sports", "size", "mph", "shock", "limit", "percent", "rate", "status", " speeds", "spec", "peed", "gravity", "species", "send", "seek", "sw", "spe", "frequency", "shape", "performance", "command", "EED", "slice", "fps", "gain", "port", "distance"], "errp": [" erP", "errphp", "errP", " errP", "diepe", "ferP", "hrp", "errpe", "ferp", "errpb", "diepb", "hrP", " errpb", " errphp", " erpb", " erp", "ferphp", " errpe", "diep", "dieP", " erpe", "hrphp"], "s": ["p", "t", "sys", "is", "a", "r", "f", "m", "h", "ss", "ns", "d", "ps", "bs", "rs", "gs", "fs", "c", "ds", "j", "ls", "q", "sam", "sv", "S", "ess", "js", "g", "sq", "ts", "sp", "sb", "b", "v", "sl"]}}
{"project": "FFmpeg", "commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "target": 1, "func": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n", "idx": 22718, "substitutes": {"avctx": [" avcmd", "avcmp", " avconn", "AVcmd", "avcontext", "evctx", "vcontext", "AVcmp", "avtx", "evconn", "AVconn", "evcontext", " avcmp", "vtx", "AVcontext", "avcmd", "AVtx", "evcmp", "vcmd", "AVctx", " avtx", " avcontext", "vctx", "avconn"], "ctx": ["kw", "Context", "comm", "jac", "parent", "txt", "context", "kt", "ck", "settings", "desc", "check", "window", "act", "conv", "ct", "pkg", "gc", "pt", "loc", "ctrl", "cu", "timeout", "cv", "tx", "args", "cl", "jp", "cmp", "kl", "ann", "hw", "xp", "ork", "lib", "lc", "cm", "vals", "sc", "cf", "config", "nt", "command", "np", "cmd", "tc", "cam", "crit", "req", "obj", "nc", "cc", "ctl", "cp", "cfg", "cons", "xc"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 22741, "substitutes": {"path": ["fn", "name", "n", "mat", "p", "out", "txt", "context", "ref", "f", "type", "m", "value", "err", "transform", "format", "dir", "th", "pkg", "filename", "pt", "loc", "package", "con", "eth", "str", "c", "node", "Path", "PATH", "pattern", "mt", "mem", "template", "ath", "prefix", "cmd", "ATH", "pointer", "file", "chain", "w"], "un": ["n", "fun", "en", "old", "out", "Un", "gn", "det", " UN", "index", "vol", "sun", "une", "m", "su", "scan", "sum", "unt", "add", "ul", "unk", "aw", "unc", "con", "unknown", "uns", "uf", "um", "il", "uc", "node", "kun", "san", "ran", "unn", "bo", "other", "uni", "num", "open", "ur", "und", "una", "unit", "gun", "new", "mun", "don", "run", "ou", "from", "util", "cal", "u", "tun", "pos", " Un", "mod", "not", "an", "UN", "local", "ut"], "sock": ["nsox", "getsox", " src", "tsrc", "tix", "Sock", "gesock", "jsock", " soy", "skg", " Src", " sox", " socked", " skg", "isoot", " six", "isocks", "jsocked", " Socked", "nsock", "gesocked", "six", "stsig", "sinoot", "socked", "sinix", "nsix", "soy", " Sock", " sig", "stsocked", "getsocked", "rsix", " Sig", "tsocked", "sig", "rsocked", "stsock", "jskg", "gesOCK", "jsix", "sox", "nsocks", "stsrc", "Socked", " socks", "gesox", "soot", " sOCK", "socks", "sinock", "tock", "toot", "sinocked", "nsocked", "nsrc", "src", "sOCK", "rsock", "getsOCK", "isix", "Soy", "sinocks", "rsocks", "tsock", "getsock", "SOCK", "isock", "tocks", "tsocks"]}}
{"project": "qemu", "commit_id": "d9e0dfa2462e32cc5c6c49401ad7bff36453f75c", "target": 0, "func": "void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    Error *local_err = NULL;\n\n\n\n    memset(&bs->bl, 0, sizeof(bs->bl));\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* Default alignment based on whether driver has byte interface */\n\n    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;\n\n\n\n    /* Take some limits from the children as a default */\n\n    if (bs->file) {\n\n        bdrv_refresh_limits(bs->file->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n", "idx": 22752, "substitutes": {"bs": ["blog", "ports", "ks", "ubs", "ops", "sts", "ds", "jobs", "bh", "bles", "hs", "es", "ins", "als", "aus", "sb", "cks", "as", "bb", "eb", "os", "bsp", "iffs", "changes", "ns", "bps", "bl", "otes", "ib", "cs", "fs", "aws", "bn", "bis", "bytes", "vers", "abilities", "aks", "hz", "vs", "ats", "bes", "ts", "cases", "ads", "blocks", "qs", "bas", "nuts", "bi", "ils", "sys", "lbs", "bf", "css", "bel", "outs", "BS", "aos", "stats", "ps", "sels", "points", "ls", "books", "bing", "banks", "its", "bec", "blogs", "obs", "lets", "obj", "actions", "bys", "uts", "ubis", "boxes", "ics", "bits", "els", "cb", "rots", "bed", "ys", "ses", "ables", "bc", "rs", "gs", "bm", "ms", "vals", "js", "pb", "acs", "bos", "bp", "tops", "irms"], "errp": ["errps", "errpy", "errP", "nerpa", "errorpb", "errpa", "iterP", "iterpy", "nerP", "iterps", " errP", "errh", "rrpa", " errpy", " errpa", "rerpa", "scorepy", "iterp", "errpb", " errpb", "nerpb", " errps", "scorep", "scoreP", "errorpa", " errh", "scoreps", "errorp", "errorP", "rrp", "nerp", "rerp", "rerh", "rrh"], "drv": ["driv", "hdver", "srp", "derp", "drg", "derver", "rdv", "mrg", "brver", "mrvc", "hdv", "rdp", "rdver", "drvc", "drp", "brv", "hrv", "drisv", "drver", "driver", "derv", "crV", "hdvd", " drg", "rdg", "crsv", "hrg", "drV", "brvd", "crv", "mrV", "hdvc", "drvd", "brvc", "derg", " drV", "srver", "drivd", "hrvc", "hrV", " drvd", "drsv", "driV", " drsv", "mrv", "srv", "drivc", "srg", "crvd", " drvc"], "local_err": ["localyerr", "uniqueewcss", "locallybr", "internal_notice", "local_br", "locallypriv", "localFer", " local_gz", "localableerr", "internal_err", "local_priv", "local\u064ehr", "internal_rr", " local_cfg", "localederr", "localableerror", "local\u064epriv", "local_gz", "unique\u064ebr", "localedcss", "localFinv", "local___notice", "local_cfg", "localednotice", " local_er", "local_error", "localewerr", "localFcr", "localablenotice", "unique_priv", "local_inv", "local_css", "unique_err", "localybr", "local_rr", "internal_priv", "locallyerr", "local___err", "unique_error", "localedcfg", "local_hr", "uniqueewpriv", " local_notice", "localablecss", "local___css", "localewerror", "localewpriv", "unique_hr", "local\u064eerr", "unique\u064epriv", "unique\u064ehr", "localablerr", " local_css", "localewcss", "local_notice", "unique_css", "localablepriv", "localyhr", "localypriv", " local_inv", "uniqueewerr", " local_cr", "localFerr", "local\u064ebr", "local_cr", "uniqueewerror", "unique_br", "local_er", "locallyhr", "unique\u064eerr"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n                Error *local_err = NULL;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size,\n\n                                    &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22759, "substitutes": {"bs": ["ubis", "bi", "boxes", "is", "lbs", "bits", "access", "os", "ubs", "ns", "BS", "ss", "bps", "bl", "aos", "ps", "lb", "ops", "las", "cs", "bc", "fs", "rs", "gs", "aws", "bit", "meta", "ds", "bis", "bytes", "locks", "base", "ctx", "ls", "br", "bh", "ex", "bles", "vs", "hs", "js", "bitcoin", "its", "http", "ts", "ins", "obs", "pb", "aus", "obj", "qs", "sb", "bos", "b", "bp", "bas", "as", "ba", "bb"], "res": ["expr", "comm", "resp", "rez", "re", "response", "out", "der", "rc", "usr", "rev", "resource", "r", "red", "ber", "rem", "progress", "rel", "ox", "rss", "val", "ps", "rr", "RES", "ro", "resolution", "results", "rs", "reset", "pres", "ress", "result", "details", "resh", "pr", "ms", "resources", "Res", "vals", "reg", "rest", "gr", "prefix", "req", "rec", "rek", "cons"], "fix": ["valid", "gem", " init", "use", "general", " diff", "pack", "FIX", " FIX", "make", "set", "commit", " fixes", "check", "ix", "add", "init", "Fix", " prefix", "call", "def", "mask", " del", "issue", "dirty", "bit", "test", "fail", "get", "fixes", " patch", "replace", "mix", " clear", " Fix", " edit", "correct", "major", "patch", "edit", "prefix", " fixing", "block", "clear", "conf", "bin", " pack", "diff", "bug", " def", " format", " get", "update"], "rebuild": ["regconstruct", " rebuilding", "Reuild", "rebuilt", " reuild", "rebuilding", " rebuilt", "Reburn", "Rebuilding", "reburn", "Rebuild", "robuilt", "roconstruct", "reconstruct", "robuild", "Reconstruct", "robuilding", "reuild", " reburn", "regbuild", "regburn", " reconstruct", "Rebuilt", "reguild"], "refcount_table": ["refcount2data", "refcount_data", "refcache_table", "refcount2table", "refcount_list", "refcount_map", "refcounttdb", "refCount_table", "refcount___list", "refcache_list", "refcountttable", "refcache_TABLE", "refcache_able", "refcount___TABLE", "refcount___table", "refcounttarray", "refcount_TABLE", "refcount_able", "refCount_data", "refcount_db", "refcount2list", "refcounttmap", "refCount_map", "refcount_array", "refCount_list", "refcount2map", "refcount___able"], "nb_clusters": ["nb_colusters", "nb_glusters", "nb_combuster", "nb_CLroups", "nb_conusters", "nb2plients", "nb_combodes", "nb_constroups", "nb2pluster", "nb_plodes", "nb_collanches", "nb2plroups", "nb_constures", "nb_pluster", "nb_plients", "nb_clanches", "nb_coniders", "nb_collroups", "nb_plroups", "nb_colliders", "nb_clroups", "nb_CLiders", "nb2clroups", "nb_plures", "nb_constuster", "nb_constusters", "nb_clodes", "nb_conroups", "nb_clients", "nb_glroups", "nb_cliders", "nb_CLanches", "nb_cluster", "nb_colients", "nb2clients", "nb_colodes", "nb_collusters", "nb_colroups", "nb_combroups", "nb_combusters", "nb_CLusters", "nb_colures", "nb_clures", "nb_conanches", "nb2clusters", "nb_glients", "nb2cluster", "nb_coluster", "nb2plusters", "nb_gluster", "nb_plusters"], "s": ["comm", "ashes", "p", "is", "sys", "bits", "a", "os", "parts", "h", "ss", "ims", "ns", "y", "ses", "stats", "ps", "cs", "sts", "times", "rs", "gs", "aws", "fs", "ds", "j", "spec", "ls", "details", "ms", "sv", "ssl", "vs", "ats", "hs", "sw", "sam", "S", "js", "ess", "xs", "g", "its", "sq", "ts", "als", "ins", "es", "http", "qs", "less", "sb", "b", "sl", "series", "serv"], "i": ["bi", "n", "ij", "ori", "t", "p", "is", "phi", "ic", "it", "iq", "ri", "si", "o", "index", "set", "di", "ai", "iu", "xi", "ski", "ix", "m", "ims", "y", "us", "init", "multi", "im", "zi", "ei", "iri", "x", "id", "sim", "ind", "gi", "info", "e", "I", "c", "qi", "ki", "ti", "ini", "ip", "j", "batch", "cli", "li", "ui", "oi", "ci", "mi", "ii", "slice", "pi", "b", "l", "v", "uri"], "size": ["n", "name", "start", "capacity", "number", "si", "set", "sum", "length", "SIZE", "scale", "too", "large", "mini", "fee", "gz", "err", "count", "total", "package", "resolution", "space", "empty", "max", "dim", "bytes", "export", "body", "z", "height", "extra", "sized", "ize", "zone", "send", "num", "storage", "shape", "area", "new", "Size", "g", "mem", "error", "sp", "range", "zero", "address", "len", "sample", "small", "news", "grow", "padding"], "ret": ["expr", "prot", " RET", "value", "err", "rel", "dt", "reset", "tmp", "alt", "RET", "zero", "after", "elt", "fun", "resp", "re", "vector", "response", "rev", "back", "rets", "x", "nz", "status", "mt", "deg", "opt", "mem", "rep", "cmd", "att", "net", " Ret", "t", "it", "number", "r", "ref", "f", "rem", "hash", "Ret", "total", "arg", "def", "ter", "str", "limit", "ft", "ptr", "try", "nt", "len", "gt", "out", "lit", "final", "print", "det", "set", "ber", "Return", "val", "ext", "code", "tr", "j", "result", "far", "rt", "iter", "rm", "ll", "flag"], "offset": ["oint", "volume", "offs", "lag", "start", "oid", "et", "o", "memory", "set", "index", "Offset", "ref", "off", "f", "window", "length", "item", "table", "count", "top", "key", "total", "loc", "style", "id", "tz", "timeout", "row", "slot", "balance", "reset", "coord", "tile", "base", "shift", "link", "lower", "ui", "position", "seek", "buffer", "location", "addr", "area", "absolute", "error", "range", "prefix", "zero", "oot", "address", "block", "pos", "len", "iso", "slice", "pointer", "origin", "point", "padding", "alias"], "cluster": ["chard", "custer", "gluster", "loser", "sclause", "clust", "locus", "locuster", "slust", "luster", " clignment", "collus", "collard", " clclient", "collignment", "card", "locard", "slause", "colluster", "scluster", "collclient", "glust", "lard", "closer", "lust", "colloser", "glause", "chus", "chuster", "coser", "clause", "cust", "clus", " closer", "glclient", "glorable", "sluster", "sclust", "glignment", "locoser", "clclient", "slorable", "glard", "clorable", "gloser", "clignment", "sclorable", "choser", "clard"], "corruptions": ["corruptures", "corruptors", "corruptedions", "corruptedures", "corconnectors", "corconnectures", "corconnecturations", "interconnecturations", "corruptedors", "corruptedurations", "interrupturations", "interruptors", "corconnections", "interruptures", "interconnections", "corrupturations", "interconnectors", "interconnectures", "interruptions"], "new_nb_clusters": ["new_nb_glusters", "new_nb_Clusters", "new_nb_coroups", "new_nb\u043dclusiants", "new_nb_clusiants", "new_nb_custers", "new_nb_cousters", "new_nb_clusients", "new_nb2clients", "new_nb_cliants", "new_nb_comuster", "new_nb2Clusters", "new_nb_blients", "new_nb2Clients", "new_nb_glroups", "new_nb\u043dclients", "new_nb_couster", "new_nb_Cluster", "new_nb_cients", "new_nb_pliants", "new_nb\u043dclusters", "new_nb\u043dcluster", "new_nb_Clroups", "new_nb_comients", "new_nb_plroups", "new_nb_clients", "new_nb_cluster", "new_nb2Clroups", "new_nb_comroups", "new_nb\u043dclusients", "new_nb_clususters", "new_nb_plients", "new_nb_blroups", "new_nb_comusters", "new_nb_pluster", "new_nb_clususter", "new_nb2clroups", "new_nb_blusters", "new_nb_custer", "new_nb\u043dclususters", "new_nb_gluster", "new_nb_clroups", "new_nb_plusters", "new_nb\u043dclususter", "new_nb_gliants", "new_nb\u043dcliants", "new_nb_glients", "new_nb2clusters", "new_nb_coients", "new_nb_Clients"], "local_err": ["local_later", "label_str", "labelErvar", " local_rr", "localErdec", "locallyvar", "local_var", "labelErdec", "locallystr", " local_r", "local___dec", "locallyrr", "local____err", "local___usr", "local_dec", "local_str", "local_r", "locallydec", "labelErerr", "localErstr", "locallyer", "local____r", "locallyusr", "local___rr", "localErvar", "label_err", "local_rr", "local____error", "local_usr", "local___var", "labelErstr", "localErerr", " local_later", "label_dec", "local_er", " local_usr", "locallyerr", "local___er", "local___err", " local_er", "local____later", " local_error", "label_var", "local_error", "local___str"], "check_errors": ["checkptfailed", "read_failed", "check_error", "checkpterror", "checkptfail", "read_fail", "checkCountfail", "checkpterrors", "check_failed", "read_errors", "checkCounterrors", "checkCountfailed", "check_fail", "read_error", "checkCounterror"], "corruptions_fixed": ["corruptures_total", "corruptions___checked", "corruptions_checked", "corruptures_added", "corruptions_total", "corruptions___fixed", "corruptions___added", "corruptions_added", "corruptures_fixed", "corruptures_checked", "corruptions___total"]}}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801, "substitutes": {"opts": ["prot", "opcs", "optTS", "optcs", " copgt", "atuts", "experpt", "optpt", "popls", "olygs", "opls", " optsys", "optes", " opbs", "ops", " optts", "popTs", "popTS", " opgs", " optes", "OPt", "experbs", "oputs", "optsys", " opls", "OPps", "OPts", " opsm", "experrs", "iopcs", " optfs", " optouts", " copts", "opals", "edters", "rououts", "argls", "props", " opters", "expertm", "opTs", "argts", "popt", "opbs", "opgs", "oppls", "roups", "olybs", "iopps", "oprs", "atts", "optuts", "optm", "opds", "opt", " optters", "opfs", "oppts", "opsm", " opt", "iops", "popts", "att", "iopters", "OPds", "edts", " oppt", "iopouts", "opTS", "opouts", "olyfs", " opsys", "optsm", "popcs", "optts", "optms", "atters", "iopt", "opttes", "routers", " optm", "argpt", " oprs", "experms", "optfs", " optt", "olyts", " ops", "iopTS", "experals", "popgt", "oppTs", "optrs", "eduts", "oppt", "oppgt", " opouts", " copls", "iopts", " opds", "opgt", "experfs", "opsys", "optters", "opms", "optals", " opttes", "optls", "experts", "OPls", "routs", " opms", " copTs", "opters", "optt", "expergs", "OPs", " optrs", "opps", "optouts", "prots", "pros", "poppt", "opttm", " optsm", "argTS", " opals", "optds", " opps", " opfs", "edt"], "block_default_type": ["block_default_Type", "block_block_Type", "block_default2info", "block_default2type", "block_default_info", "block_default2Type", "block_default_types", "block_block_type", "block_block_info", "block_default2types", "block_block_types"], "buf": ["rb", "msg", "rc", "txt", "out", "alloc", "cap", "cb", "ref", "err", "read", "ob", "dir", "Buff", "pkg", "bus", "uf", "bc", "Buffer", "cv", "row", "data", "test", "var", "bytes", "cur", "batch", "img", "raw", "br", "queue", "tmp", "seq", "buffer", "dev", "iter", "mem", "box", "buff", "block", "cmd", "bin", "port", "b", "cp", "text"], "file": ["name", "time", "resource", "source", "io", "f", "offset", "channel", "dir", "image", "filename", "loc", "id", "user", "data", "local", "handle", "files", "base", "fp", "fil", "fi", "part", "db", "buffer", "File", "ile", "path", "action", "fd", "bin", "lf", "port", "line"], "serial": ["volume", "phone", "history", "roll", "zip", "sys", "normal", "final", "sex", "device", "root", "session", "sync", "driver", "tty", "bus", "id", "ro", "mobile", "socket", "special", "security", "Serial", "raw", "series", "dev", "par", "usb", "util", "sector", "address", "soc", "json", "kid", "iso", "ident", "ser", "local", "random", "serv"], "mediastr": ["datastr", "mediostri", "mediastrip", "mediardr", "mediastri", "datostr", "mediardri", "mediostrip", "datostrip", "datastrat", "mediostrat", "datostri", "datastrip", "mediastrat", "datastri", "mediawrat", "mediardrip", "mediostr", "mediawri", "mediawrip", "mediawr", "mediardrat", "datostrat"], "type": ["name", "TY", "parent", "ype", "t", "scope", "time", "Type", "tag", "state", "all", "ver", "pack", "start", "role", "kind", " TYPE", "ping", "color", " family", "check", "tp", "length", "y", "repeat", "TYPE", "count", "total", "style", "id", "e", "trace", "level", "info", "span", "test", " t", "var", "size", "no", "status", "family", " typ", "op", "event", "what", "pe", "part", "class", "rule", "types", "shape", "try", "sort", "ico", "pc", "block", "ty", "typ", "tiny", "PE", "port", "thing", " Type"], "media": ["volume", "history", "name", "communication", "resource", "memory", "mm", "java", "io", "policy", "m", "movie", "api", "material", "aka", "format", "image", "pro", "style", "relative", "document", "meta", "mo", "language", "library", "mac", "family", "mag", "mode", "storage", "area", "http", "medium", " Media", "Media", "ma", "metadata", "pi", "IA", "medi"], "bus_id": ["bus_ids", "busogaid", "bridge_aid", "buswaid", "busogid", "busxid", "bus8aid", "bus__ids", "bus_aid", "us_info", "bus__ref", "busxinfo", "bridge8ident", "busognumber", "bus8ident", "bus8id", "buswident", "bus8number", "bridge_number", "buswid", "bus__info", "bus_info", "busogident", "busxids", "us_id", "bridge8aid", "bus_ref", "bridge8number", "bridge8id", "bus_number", "bridge_id", "bus__id", "buswnumber", "busxref", "us_ref", "bus_ident", "us_ids", "bridge_ident"], "unit_id": ["unit_bid", " unit2id", "unit2ids", " unit2type", " unit2info", "unit_ids", " unit_info", "unit2info", " unit_bid", "unit_type", " unit_ids", " unit2ids", "unit_info", " unit_pid", "unit2type", "unit_pid", "unit2id", " unit_type"], "cyls": ["cyles", "styps", "cysels", "sycs", "syols", "tysels", "tyles", " cyles", "cryls", "crycs", "cyols", "syps", " cyols", "crysels", "styles", "sysels", " cyps", "tyls", "cyps", "syls", "tycs", "cryles", "styls", "syles", "cycs", "styols"], "heads": ["offs", "helps", "stocks", "links", "bits", "hops", "reads", "masters", "weights", "phones", "tags", "outs", "head", "HEAD", "hours", "rows", "terms", "cs", "boards", "times", "headers", "rs", "shots", "olds", "locks", "loads", "planes", "relations", "sections", "sticks", "views", "its", "mods", "modules", "blocks", "uploads", "days", "tops", "limits", "tails"], "secs": [" secrs", "sectis", "secjs", "secps", "townps", "secis", "logs", "secns", "sectps", "townjs", "seqrs", " secjs", "townns", "sects", " secns", "seqps", " secps", "logjs", "seqs", "sectrs", " secis", "towns", "seqis", "secrs", "logns", "logps"], "translation": ["history", "Translation", "formation", "normal", "resource", "comment", "transform", "title", "late", "relation", "FORMATION", "lations", "description", "info", "generation", "meta", "language", "binding", "tr", "lang", "library", "version", "selection", "mode", "control", "utils", "position", "operation", "heading", "location", "usage", "direction", "rot", "trans", "lation", "versions", "creation", "origin", "padding", "text"], "drv": ["crj", "crw", "crvr", "drw", "srj", "drvr", " drj", " drvr", " drw", "srv", "drj", "srvr", "srw", "crv"], "max_devs": ["max_defds", "max_evds", "max_evpoints", "max_defts", "max_defs", "max_devts", "max_devpoints", "max_defpoints", "max_evs", "max_evts", "max_execpoints", "max_exects", "max_execs", "max_execds", "max_devds"], "index": ["Index", "loop", "number", "write", "connect", "length", "head", "offset", "read", "scan", "order", "count", "key", "val", "loc", "x", "id", "label", "ind", "skip", "row", "info", "size", "lock", "link", "position", "num", "open", "active", "location", "addr", "iter", "address", "pos", "success", "insert"], "on_read_error": ["on_write_change", "on_read_err", "on_read_change", "on_write_start", "on_write_err", "on_read_start"], "on_write_error": ["on_writ_start", "on_write_data", "on_writ_data", "on_writ_error", "on_write_start", "on_write_err", "on_writ_err"], "devaddr": ["evaddr", "deviceaddress", "devicename", "devname", "deviceaddr", "evptr", " devptr", " devaddress", " devname", "devaddress", "evaddress", "devptr", "deviceptr", "evname"], "dinfo": ["Dinf", "dInfo", "Dinfo", " dInfo", "bdinfo", "dinf", "DInfo", " dinf", "bdInfo", "bdinf"], "io_limits": ["io_maps", "io_limit", "IO_limits", "IO_maps", "IO_settings", "IO_limit", "io_settings"], "copy_on_read": ["copy_on_disk", "copy_on_readable", "copy_on_Read", "copy_on_write"], "ret": ["vector", "out", "lit", "rc", "rev", "ref", "rel", "Ret", "count", "val", "total", "rs", "reset", "limit", "no", "prop", "rt", "num", "res", "mem", "nt", "trans", "ts", "pos", "len", "ry", "flag"], "error": ["er", "p", "ror", "danger", "comment", "r", "o", "ack", "err", "order", "relation", "info", "data", "ERROR", "status", "result", "op", "event", "Error", "instance", "action", "command", " err", "option", "errors"]}}
{"project": "qemu", "commit_id": "0b2c1beea4358e40d1049b8ee019408ce96b37ce", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815, "substitutes": {"qdict": ["qtable", "qqcontext", "qqdict", "qudict", "qualdir", "qualdd", "qucontext", " qcontext", "qualdict", "qcontext", "qqdd", "qutable", "qdir", "qudir", "qqtable", " qtable", " qdd", "qualtable", " qdir", "qqdir", "qdd"], "params": ["name", "parent", "p", "mas", "missing", "settings", "param", "sym", "ks", "parts", "css", "ams", "m", "changes", "tags", "value", "init", "ps", "terms", "keys", "target", "rs", "args", "pres", "result", "points", "ctx", "spec", "ls", "k", "names", "values", "ms", "strings", "tmp", "vs", "vals", "types", "errors", "par", "pins", "js", "new", "prefix", "conf", "json", "pos", "options", "pi", "actions", "v", "phys", "padding"], "implied_key": ["implied_field", "impliedingkey", "impliedjtype", "implied___key", "implified_Key", "impllied___key", "impliedingname", "impliedIresource", "impliedjkey", "implied_resource", "implied_Key", "implicated_tag", "impliedingtag", "impliced_field", "impliedingresource", "implified_resource", "implied_box", "implied_keys", "implied_link", "implied_name", "impllied___box", "implied_hash", "impliedJkey", "impliedjcode", "implied___hash", "impllied___parent", "implified_keys", "implied_no", "impllied_key", "impliced_code", "impliedjfield", "impliedIkey", "implicated_key", "implified_key", "implicated_resource", "implied_parent", "impliedJbox", "implied_code", "impliced_key", "implied___type", "impllied___link", "implicated_name", "implied___code", "implied___parent", "impllied_link", "implified_link", "implied_tag", "implified_hash", "implied___link", "impliced_type", "imploted_version", "implied___keys", "impllied_box", "imploted_keys", "implied_type", "impllied_parent", "implied_ip", "imploted_key", "implied___box", "implified_tag", "impliedIKey", "implied___field", "imploted_ip", "implied_version", "impliedJparent", "impliedIno", "impliedJlink", "implified_no"], "errp": ["errps", "derp", "errP", "warnp", "warnpp", "tracer", "errorpb", "derf", " errping", "errpa", "errf", "errr", " errpoint", " errP", "errpp", "errpid", "rrping", "rrP", "rrpa", " errpa", " errpp", "ferps", "rrpid", "derr", "ferp", "errpb", "riskr", "errorpoint", "errnp", "errorpid", " errpid", " errnp", "tracep", "ferpp", " errps", "errorping", "errping", "errorf", "derpa", " errr", "errorpa", "errpoint", "errorp", "rrf", "derpid", "rrpb", "errorr", "warnpa", "errorP", "riskpid", "rrp", "warnps", "ferpa", "dernp", "riskpoint", "derpb", "tracenp", "tracepa", "riskp"], "key": ["is", "this", "kind", "m", "sum", "policy", "value", "length", "err", "pair", "target", "host", "no", "k", "tmp", "ak", "pointer", "port", "v", "token", "padding", "chain", "type", "n", "name", "kw", "start", "a", "param", "te", "ns", "title", "x", "note", "i", "e", "data", "size", "base", "link", "prefix", "tiny", "net", "t", "tag", "sym", "one", "ams", "y", "hash", "null", "by", "table", "pkg", "ps", "ket", "skip", "pri", "str", "max", "var", "ip", "ke", "Key", "sky", "sp", "obj", "cache", "l", "nil", "mk", "p", "end", "ver", "set", "index", "ek", "field", "offset", "KEY", "tip", "sk", "item", "ey", "id", "keys", "code", "row", "query", "lock", "shift", "ms", "iter", "error", "json", "options"], "key_end": ["key2END", "key_ends", "keyLenend", "keyLenEND", " key_End", "key_End", " key_ends", "key_in", "key_END", "key_start", "KEY_END", "key_len", "key_e", "KEY_len", "key2start", "key_length", "key2End", "KEY_End", " key_length", "KEY_start", " key_ender", "KEY_in", "keyLenender", " key_END", "key2end", " key_e", "key_ender", "KEY_end", " key_start"], "s": ["is", "m", "ims", "sts", "ds", "sv", "sw", "hs", "es", "xs", "ins", "less", "sb", "as", "v", "sl", "n", "start", "rev", "a", "os", "ns", "bs", "x", "i", "e", "cs", "ars", "fs", "size", "bytes", "ats", "vs", "self", "g", "sort", "ts", "prev", "qs", "b", "tes", "t", "sys", "sym", "r", "y", "stats", "ar", "d", "ps", "str", "args", "c", "sr", "spec", "ls", "ies", "S", "its", "sp", "slice", "l", "p", "out", "bits", "parts", "h", "ss", "rs", "gs", "j", "south", "full", "ms", "js", "sq", "sub", "second", "w"], "len": ["fn", "ele", "msg", "length", "err", "rel", "format", "loc", "lan", "ld", "tl", "lim", "res", "alt", "lc", "fin", "rot", "pos", "gen", "elt", "sl", "n", "fun", "rev", "Len", "ilt", "lp", "elta", "il", "lon", "data", "dim", "dl", "size", "lt", "vec", "kl", "cmp", "bytes", "lang", "repl", "seq", "gl", "mem", "ren", "ln", "nl", "acl", "Length", "lv", "t", "ils", "ref", "del", " l", "bool", "label", "str", "den", "limit", "li", "ls", "sp", "nt", "slice", "l", "el", "syn", "gt", "valid", "en", "end", "lit", "els", "lvl", "offset", "tail", "le", "j", "compl", " bl", "lic", "hl", "js", "iter", "rl", "ll", "lf", "lib", "L"], "key_in_cur": ["key_out_cont", "key_in__sur", "key_out_ser", "key_out_current", "key_in__cur", "key_in_buf", "key_in__Cur", "key_out_rc", "key_in_sur", "key_in__rc", "key_out_cur", "key_in2Cur", "key_in_rc", "key_out_pri", "key_in_current", "key_in2ser", "key_in_ser", "key_in_cont", "key_in_pri", "key_out_Cur", "key_out_sur", "key_in2cur", "key_in_Cur", "key_out_buf"], "cur": ["coll", "sys", "rc", "usr", "rev", "cat", "cont", "r", "err", "co", "gc", "ct", "current", "con", "cu", "pri", "cv", "row", "c", "tr", "car", "col", "result", "buf", "dict", "sr", "ctx", "ptr", " Cur", "cor", "ph", "tmp", "ur", "sc", "iter", "dr", "ch", "ren", "new", "Cur", "gr", "cr", "pg", "obj", "cache", "prev", "cmd", "sur", "rec", "ser", "comp", "ctr", "serv"], "ret": [" Ret", "gt", "fun", "t", "re", " RET", "out", "en", "lit", "txt", "rev", "et", "red", "cont", "ref", "rets", "Len", "rem", "err", "length", "Ret", "rel", " alt", "ner", "tail", "arr", "def", "ext", "str", "reset", "lt", "j", "result", "sr", "repl", "ls", "rt", "tmp", "num", "res", "alt", "iter", "rest", "js", "match", "nt", "sp", "RET", "ts", "ll", "ne", "elt", "l"], "next": ["n", "gt", "p", "state", "sys", "end", "txt", "rev", "ver", "non", "me", "sec", "ns", "rel", "Next", "ner", "none", "current", "def", "ext", "target", "tri", "info", "data", "good", "jp", "j", "proc", "z", "nd", "ng", "big", "fr", "future", "result", "other", "link", "ptr", "more", "draw", "tmp", "seq", "self", "adj", "dev", "iter", "new", "prime", "js", "try", "nt", "req", "prev", "obj", "nl", "ne", "rec", "sche", "v", "gov", "net"], "val": ["p", "msg", "sel", "txt", "value", "eval", "ps", "str", "tx", "args", "test", "var", "Val", "buf", "ctx", "ls", "values", "res", "alt", "vs", "VAL", "sl", "vals", "als", "v", "attr", "serv"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)\n\n{\n\n    int16_t input[MDCT_SAMPLES];\n\n    int32_t output[AC3_MAX_COEFS];\n\n    float input1[MDCT_SAMPLES];\n\n    float output1[AC3_MAX_COEFS];\n\n    float s, a, err, e, emax;\n\n    int i, k, n;\n\n\n\n    for (i = 0; i < MDCT_SAMPLES; i++) {\n\n        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;\n\n        input1[i] = input[i];\n\n    }\n\n\n\n    mdct512(mdct, output, input);\n\n\n\n    /* do it by hand */\n\n    for (k = 0; k < AC3_MAX_COEFS; k++) {\n\n        s = 0;\n\n        for (n = 0; n < MDCT_SAMPLES; n++) {\n\n            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));\n\n            s += input1[n] * cos(a);\n\n        }\n\n        output1[k] = -2 * s / MDCT_SAMPLES;\n\n    }\n\n\n\n    err  = 0;\n\n    emax = 0;\n\n    for (i = 0; i < AC3_MAX_COEFS; i++) {\n\n        av_log(NULL, AV_LOG_DEBUG, \"%3d: %7d %7.0f\\n\", i, output[i], output1[i]);\n\n        e = output[i] - output1[i];\n\n        if (e > emax)\n\n            emax = e;\n\n        err += e * e;\n\n    }\n\n    av_log(NULL, AV_LOG_DEBUG, \"err2=%f emax=%f\\n\", err / AC3_MAX_COEFS, emax);\n\n}\n", "idx": 22826, "substitutes": {"mdct": ["ndCT", "mdcc", "cmdcd", "mdCT", " mdCT", "madcat", "MDcc", " mdcc", "madCT", "cmdCT", "cmdct", "madct", "mdcd", "mccd", "ndct", "MDcat", "madcc", " mdcat", "cmdcc", "mcCT", "ndcd", "ndcc", "MDCT", "mccc", "mcct", "MDct", "mdcat"], "lfg": ["lbG", "ldc", "llc", "lfl", "ldge", " lbG", "lbg", "ldl", "ldg", "lvG", " lbgu", "lfge", "lvge", " lbg", "dlc", "lbgu", "lvgu", " lbge", "llg", "lvg", "lfG", "lfgu", "lfc", "lbge", "dll", "dlge", "dlg", "llge", "lll"], "input": [" inputs", "p", "search", "load", "audio", "view", "out", "PUT", "context", "source", "index", "h", "seed", "read", "add", "Input", "image", "before", "array", "um", "empty", "issue", "row", "data", "initial", "bit", "query", "get", "ip", "raw", "request", "q", "accept", "buffer", " Input", "in", "import", "inner", "config", "ou", "error", "from", "interface", "address", "w", "form", "hidden", "local", "feed", "text"], "output": ["done", "response", "out", "PUT", "message", "print", "o", "source", "list", "write", "collection", "table", "key", "total", "image", "display", "current", "document", "target", "outer", "data", "generation", "batch", "result", "other", "web", "four", "queue", "position", "accept", "console", "buffer", "Output", "new", "put", "ou", "config", "block", "cache", "hidden", "next", "client", "to", "v", "success", "file", "network", "dot", "update"], "input1": [" input3", " input2", "output2", "output0", "image3", " input0", "Input4", "Input3", "input4", "Input0", " input4", "input3", "Input1", "Input2", "output3", "image1", "output4", "image2", "input2", "input0"], "output1": ["out3", "out2", "Output1", " output0", "output2", " outputOne", "output0", "outputOne", " output3", "Output3", "Output2", "out0", "inputOne", "Output0", "input3", "outOne", "output3", "input2", " output2", "input0", "out1"], "s": ["t", "p", "is", "sa", "r", "os", "m", "h", "ns", "ss", "sd", " ts", "stats", "d", "ar", "ps", "x", "cs", "sts", "rs", "gs", "c", "ds", "se", "sr", "spec", "ls", "ms", "sv", "ats", "ies", "S", "js", "es", "g", "its", "sq", "ts", "sp", "sb", "b", "sl", "w"], "a": ["er", "p", "am", "sa", "r", "o", "ach", "ai", "m", "ac", "ar", "ata", "d", "ea", "x", "va", "c", "aff", "pa", "ao", "aa", "ap", "ab", "alpha", "ga", "A", "ia", "fa", "at", "area", "g", "ae", "au", "u", "ma", "an", "b", "as", "pi", "apa", "ba"], "err": ["er", "p", "lr", "msg", "der", "mr", "rn", "it", "ere", "txt", "r", "rc", "f", "m", "h", "rel", "fee", "gz", "rss", "ar", "ie", "arr", "rr", "ind", "trace", "attr", "rs", "str", "c", "ec", "ell", "eor", "fr", "exc", "extra", "Er", "res", "erer", "ir", "orr", "iter", "error", "Error", "oe", "term", "req", "cr", "cmd", "conf", "diff", "elt", "v", "ev", "errors", "eff"], "e": ["ee", "ed", "er", "en", "ele", "element", "p", "eur", "eb", "ere", "et", "o", "r", "ce", "xe", "f", "te", "m", "ef", "east", "eeee", "d", "ie", "ei", "x", "eg", "c", "ate", "ec", "ge", "le", "E", "se", "ex", "pe", "edge", "eu", "g", "es", "error", "ae", "oe", "be", "u", "ue", "v", "el", "ev"], "emax": ["eemit", "eemaster", "esmAX", " emaxy", "emmed", "EMmax", "maxy", "mox", "emingood", "mmax", "lemake", "lemmax", "EMaz", "emsax", "emaz", "eemax", " emox", "emmax", "lemort", "esmit", "eminaxy", "emAX", "esmax", "omaxy", "eemAX", "aleAX", " emort", "esmox", "esmmed", "emsake", "max", "emort", "eminax", "esmmax", "aleaster", " emgood", "esmaster", "lemmed", "emaxy", " emmax", "aleax", "ommax", "emgood", "emsmed", "lemaz", "emit", "eminmax", "EMort", "esmake", "lemaster", "emaster", "omgood", "emake", " emaz", "aleit", "omax", "EMax", "emsaster", "esmaxy", "lemax", "emox"], "i": ["is", "ic", "this", "io", "m", "ims", " I", "wi", "im", "I", "ti", "cli", "batch", "ui", " bi", "v", "uri", "name", "\u0438", "si", "o", "me", "list", "ai", "ix", "ji", "x", " ii", "ind", "sim", "gi", "info", "ami", "oi", "at", "dr", "g", "remote", "u", "hi", "bi", "parent", "phi", "it", "ri", "xi", "y", "multi", "zi", "iri", "ei", "c", "qi", "ini", "ip", "li", "ci", "mi", "ii", "pi", "ij", "p", "print", "di", "index", "iu", "h", "us", "init", "id", "ki", "j", "iter"], "k": ["ok", "kw", "mk", "p", "ck", "kt", "ks", "o", "kind", "km", "ek", "kan", "m", "unk", "wk", "sk", "key", "isk", "tk", "ko", "c", "ku", "ki", "kl", "j", "kn", "kit", "K", "ke", "ask", "q", "kr", "num", "kh", "ka", "kk", "ik", "kick", "ijk", "ikk", "ak", "kj", "kid", "uk"], "n": ["name", "fn", "en", "all", "p", "gn", "rn", "o", "r", "cn", "nr", "m", "ns", "y", "dn", "nw", "na", "key", "note", "nn", "on", "c", "ni", "node", "N", "j", "no", "nb", "nu", "z", "nd", "ng", "kn", "sn", "nm", "pn", "br", "kr", "num", "un", "and", "new", "ln", "nt", "np", "ne", "ll", "mn", "an", "b", "nc", "v", "el", "nan", "net"]}}
{"project": "FFmpeg", "commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "target": 1, "func": "static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n", "idx": 22833, "substitutes": {"old_w": ["old00w", "old00win", "old_wn", "old_sp", "old10sp", "old00sp", "old_W", " old_win", "new_W", " old_sp", "new_wn", "old_win", "old10w", "old00h", "old10h", "old10win"], "old_h": ["store00hw", "old___w", "new_hal", "old_hal", "old_hw", "old48ht", "new_v", "store_ht", "old00w", "old00ht", "store00w", "old_ht", "old_v", "store00ht", "old___v", "old___hal", "store00h", "old___h", "old00hw", "store_w", "store_hw", "old00h", "old48h", "store_h", "old48hw", "old48w"], "sar": ["unsars", "iscar", "sqear", "nsara", " sara", " shar", "saris", "ispar", "ssar", "shar", "sarian", " sear", " saris", "tsars", "timesAR", "unscar", "usaris", "msar", "rsar", "nsar", "rsart", "sars", "sspar", " sarp", "msrar", "getsar", "isar", "ushar", "rsarl", "unspar", "srar", "getsaris", "getshar", "sear", "unsarp", "spar", "tsarp", "saer", "searl", "msart", "tsarian", " sarian", "isaer", "unsAR", "scar", "sAR", "timesar", "nsear", "timeshar", "ssAR", "sara", " saer", "sqar", "sarl", "nscar", "serar", " scar", "getsara", "sqcar", "seart", "sqara", "usar", "sshar", "unsarian", "tsar", "unsar", "unshar", "sart", "rsrar", "timespar", "usara", "msarl", "sarp", " spar", " sars", "unsaer"], "new_w": ["new_hw", "cell_W", "new64wd", "cell_wn", "new64h", "cell_w", "cell_wd", "new_wd", "new_W", "new64W", "new_wn", " new_hw", "new64hw", "new64wn", "new64w", " new_W"], "new_h": ["new00w", "new_l", " new_ht", " new__height", "new00zh", "new64height", "new__height", "new_height", "new_zh", "new64h", " new__h", "old_l", "new__ht", " new_height", "new_ht", " new__ht", "new00h", "new00l", "new64ht", "old_zh", "new__h"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834, "substitutes": {"bus": ["uses", "ck", " Bus", "boot", "device", "us", " board", "board", "Bus", "mount", "bit", " buses", "tx", "proc", "lock", " device", "BUS", "book", "dev", "box", "usb", "config", "block", " BUS", "bug", "cc", "chain"], "devfn": ["deviceFN", "devlen", "Devfilename", " devnm", "evlen", "evfilename", "evnm", " devfilename", "devn", "devFN", "testFN", "testlen", "testn", "evn", "testfn", "devnm", "devicen", "Devfn", "devicefn", "evFN", "devicelen", "devfilename", "evfn", "Devnm"], "offset": ["oint", "start", "oid", "o", "Offset", "index", " offsets", "set", "ref", "off", "length", "seed", "attribute", "OFF", "window", "optional", "tz", "loc", "style", "timeout", "attr", "info", "slot", "bit", "size", "shift", "event", "position", "location", "addr", "ta", "bound", "error", "prefix", "zero", "block", "address", "pos", "point", "padding"]}}
{"project": "FFmpeg", "commit_id": "ee90119e9ee0e2c54f1017bbe1460bfcd50555d0", "target": 1, "func": "static int decode_block(BinkAudioContext *s, float **out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = out[ch];\n\n\n\n        if (s->version_b) {\n\n            if (get_bits_left(gb) < 64)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n        } else {\n\n            if (get_bits_left(gb) < 58)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        if (get_bits_left(gb) < s->num_bands * 8)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            int value = get_bits(gb, 8);\n\n            quant[i]  = quant_table[FFMIN(value, 95)];\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else {\n\n                int v;\n\n                GET_BITS_SAFE(v, 1);\n\n                if (v) {\n\n                    GET_BITS_SAFE(v, 4);\n\n                    j = i + rle_length_tab[v] * 8;\n\n                } else {\n\n                    j = i + 8;\n\n                }\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            GET_BITS_SAFE(width, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    GET_BITS_SAFE(coeff, width);\n\n                    if (coeff) {\n\n                        int v;\n\n                        GET_BITS_SAFE(v, 1);\n\n                        if (v)\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        int j;\n\n        int count = s->overlap_len * s->channels;\n\n        if (!s->first) {\n\n            j = ch;\n\n            for (i = 0; i < s->overlap_len; i++, j += s->channels)\n\n                out[ch][i] = (s->previous[ch][i] * (count - j) +\n\n                                      out[ch][i] *          j) / count;\n\n        }\n\n        memcpy(s->previous[ch], &out[ch][s->frame_len - s->overlap_len],\n\n               s->overlap_len * sizeof(*s->previous[ch]));\n\n    }\n\n\n\n    s->first = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 22844, "substitutes": {"s": ["n", "comm", "er", "t", "p", "is", "sys", "bits", "rates", "settings", "a", "sym", "o", "os", "parts", "set", "m", "ns", "ss", "ims", "ses", "stats", "ps", "ops", "bs", "eps", "cs", "sts", "rs", "aws", "gs", "fs", "c", "sports", "ds", "span", "se", "spec", "ls", "details", "ex", "ms", "sv", "sw", "sam", "ats", "hs", "self", "sc", "S", "js", "in", "space", "es", "ins", "sq", "ts", "als", "g", "sp", "sg", "conf", "qs", "less", "sb", "ains", "b", "as", "series"], "out": ["n", "p", "t", "all", "sys", "OUT", "o", "os", "set", "list", "output", "io", "chan", "m", "outs", "y", "ot", "c", "batch", "result", "op", "raw", "Out", "tmp", "res", "sky", "buffer", "up", "in", "new", "g", "at", "params", "block", "obj", "cache", "to", "b", "w"], "use_dct": ["use_ppt", "use_dpt", "use_pCT", "use_fdbc", "use_puct", "use_rct", "use_rbt", "use_rpt", "use_Duct", "use_Dbc", "use_pbc", "use_duct", "use_dbt", "use_pbt", "use_dCT", "use_Dct", "use_fduct", "use_pct", "use_fdCT", "use_rCT", "use_dbc", "use_DCT", "use_fdct"], "ch": ["sch", "mk", "cho", "chart", "ht", "chrom", "zh", "chn", "high", "cb", "ach", "CH", "chan", "ich", "ek", "h", "y", "sk", "ay", "ct", "th", "count", "x", "ot", "code", "cs", "tch", "cd", "atch", "c", "batch", "cht", "col", "z", "height", "ih", "och", "br", "Ch", "ble", "sh", "chip", "kh", "ph", "hl", " Ch", "sc", "g", "chron", "bt", "b", "ech", "ca", "cp", "cha", "channel"], "i": ["is", "ic", "m", "value", "im", "I", "cli", "ti", "ui", "ir", "n", "si", "me", "o", "ai", "ix", "api", "ji", "x", "ind", "e", "gi", "info", "size", "ami", "status", "ik", "dr", "g", "hi", "b", "bi", "phi", "t", "it", "iq", "ri", "xi", "f", "y", "multi", "zi", "ei", "c", "qi", "ini", "ip", "z", "li", "ia", "in", "try", "ci", "mi", "ii", "slice", "pi", "l", "ori", "ij", "p", "index", "di", "iu", "h", "init", "ie", "key", "ki", "iter"], "j": ["n", "ij", "aj", "bi", "p", "t", "it", "r", "o", "jl", "si", "f", "h", "m", "y", "ji", "x", "e", "row", "max", "c", "jp", "z", "fr", "south", "jc", "br", "J", "jump", "ja", "js", "g", "try", "job", "uj", "kj", "json", "je", "jj", "b", "l", "dj", "pi", "w"], "k": ["kw", "n", "mk", "p", "ck", "ks", "km", "kind", "r", "o", "ek", "kan", "m", "unk", "sk", "key", "x", "ko", "c", "z", "K", "ke", "kh", "ka", "kk", "ik", "ijk", "ikk", "ak", "u", "kid", "w"], "q": ["n", "qv", "p", "t", "iq", "o", "requ", "f", "dq", "h", "m", "qq", "qt", " z", "x", "Q", " quad", " f", " qu", "weight", " qual", "c", "query", " flux", "qi", " g", "z", "qa", " Q", " req", "qu", "g", "sq", "u", "qs", " p", " query", "ue", " sq", "w"], "quant": ["specific", "complex", "quiet", "final", "mot", "cat", "private", "requ", "qq", "material", "stats", "count", "total", "mint", "ind", "important", "frac", "var", "good", "percent", "mix", "dict", "mult", "series", "deep", "qu", "qual", "patch", "Quant", "nt", "pick", "util", "buff", "integer", "ty", "config", "hold", "quad", "quart", "quick", "uint", "comp", "press", "random"], "coeff": ["COeff", " coef", "COff", " coefficient", "coef", " coff", "Coefficient", "Coff", "Coef", "COefficient", "Coeff", "coff", "COef", "coefficient"], "gb": ["ubis", "gt", "rect", "gif", "rb", "gpu", "eb", "py", "bf", "tg", "cb", "jpg", "hub", "large", "gm", "aaa", "goo", "gc", "gd", "ruby", "mb", "bs", "rg", "uf", "eg", "huge", "vg", "gs", "cv", "gnu", "fg", "fb", "xy", "hd", "nb", "hw", "ctx", "deg", "uv", "bm", "bg", "html", "lib", "wb", "yg", "db", "storage", "hog", "gg", "g", "kb", "phy", "global", "pb", "Gb", "pg", "tm", " GB", "sb", "GB", "b", "gp", "gh", "cfg", "bb"], "coeffs": ["coefficientsts", "COefficientsiths", "coceljs", "cocols", " coffitions", "coefficientes", "cocels", "coefficientsjs", " coeffls", "coeffS", "coeff_", "coffes", "coeffances", "coefficient_", " coeffts", " coffs", "COefficientse", " coeffitions", "coeffices", "Coeffs", "cocelitions", "Coeffes", "coaccends", "COeffjs", "coefS", "coef_", "coffts", "coeffiths", "coeffitions", "COefes", " coeffends", "coefficances", "COefficientsjs", "coffs", "coffls", "coefficientls", "coefances", "coeffes", "coefficientsitions", "coefficientses", "coeffics", "COefficientses", "Coffes", "coff_", "COefs", "coefes", "coefficientse", "coefficientjs", "COefances", "cocoliths", "coaccls", "cocole", "coefficientss", "coeffe", "cocolls", "coefficientsends", "coeffjs", "coffances", " coffends", " coeffes", "coefficiths", "coefficls", "coeffends", "COefficientsls", "Coeff_", "coeffice", "COefS", "cocelts", " coffts", "COeffS", "coefficS", "COeffs", "coeffts", "coaccs", "coffends", "coaccjs", "coffitions", "COeffances", "coefficientsls", "coefficientsiths", "COeffe", " coffjs", "coefficients", "coefs", "Coff_", "coeffls", "Coffs", " coeffjs", "COeffiths", " coffes", "COeffls", "coffS", "coffjs", "COeffes", "COefficientss", " coffls"], "v": ["n", "qv", "volume", "t", "p", "vector", "vd", "vc", "it", "rev", "ver", "vi", "vol", "f", "m", "h", "value", "y", "conv", "iv", "val", "va", "x", "vert", "vm", "cv", "c", "var", "av", "tv", "z", "version", "uv", "ve", "sv", "vs", "vt", "g", "vv", "u", "nv", "b", "l", "V", "vp", "lv", "ev", "w"]}}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875, "substitutes": {"cpu": ["core", "gpu", "ck", "alloc", "frame", "ilo", "cat", "processor", "process", "ce", "cow", "pixel", "cn", "tp", "device", "us", "thread", "gc", "ct", "pkg", "prof", "copy", "cu", "cum", "row", "c", "node", "reset", "cmp", "lo", "proc", "hw", "pu", "ctx", "hz", "chip", "clock", "nic", "pause", "pc", "np", "uu", "pool", "CPU", "linux", "comp", "gp", "cp"], "scc": [" scci", " suc", "sCC", "Suc", "tsCC", "sck", "jscs", "tscci", "jsCC", "scci", "SCC", " sCC", "sbc", "suc", "jscc", " scs", "Sck", " sbc", "tsbc", "Scs", "Sct", "scs", " sck", "sct", "Scc", "tscc", " sct", "jsct"]}}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n", "idx": 22876, "substitutes": {"s": ["n", "p", "t", "state", "is", "r", "ys", "h", "ns", "ss", "ses", "ps", "cs", "sts", "fs", "rs", "gs", "ds", "ls", "ers", "ms", "sh", "sv", "ats", "hs", "ies", "S", "js", "es", "its", "ins", "ts", "sb", "v"], "vs": ["ports", "ires", "ks", "ims", "ops", "sts", "vm", "ds", "ov", "sv", "hs", "xs", "es", "ins", "lists", "v", "uds", "irms", "ev", "vd", "changes", "ns", "words", "bs", "otes", "cs", "alls", "fs", "vers", "atts", "values", "lines", "views", "wcs", "posts", "ts", "ads", "gets", "qs", "docs", "ils", "flags", "lbs", "VS", "vc", "ears", "ows", "outs", "stats", "vr", "ps", "var", "ls", "Rs", " VS", "ies", "its", "blogs", "obs", "obj", "ves", "ii", "vp", "vv", "vt", "serv", "bits", "ver", " ss", "ss", "Vs", "inv", "eps", "terms", "rs", "gs", "ms", "vals", "js", "fps", "news", "ents"], "err": ["ok", "n", "resp", "er", "rez", "eas", "sys", "msg", "state", "txt", "usr", "out", "mr", "ver", "lr", "rc", "r", "rev", "nr", "off", "h", "y", "fee", "gz", "ner", "count", "arr", "rr", "nz", "id", "code", "e", "i", "conn", "rs", "str", "or", "trace", "test", "c", "ec", "cmp", "eor", "coord", "fr", "buf", "ptr", "br", "here", "hz", "pr", "Er", "kr", "res", "ir", "iter", "ch", "dr", "error", "Error", "oe", "ah", "elt", "ev", "attr"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906, "substitutes": {"info": ["is", "io", "sum", "debug", "fo", "user", "warning", "now", "details", "event", "auth", "job", "command", "Inf", "success", "about", "name", "Info", "state", "start", "py", "ion", "comment", "os", "list", "sync", "note", "i", "trace", "data", "link", "num", "entry", "dev", "mem", "update", "time", "it", "force", "f", "summary", "exec", "by", "def", "good", "ip", "request", "always", "report", "try", "config", "ist", "req", "conf", "information", "pi", "inf", "ok", "history", "txt", "where", "index", "INFO", "check", "tip", "add", "notice", "init", "current", "id", "conn", "admin", "query", "content", "warn", "version", "help", "iter", "doc", "error", "http", "interface"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931, "substitutes": {"ram_size": ["cpu_addr", "ram_addr", "cpu_size", "ram_name", "cpu_SIZE", "cpu_name", "ram_SIZE"], "do_init": [" fe_init", " cpu_out", " cpu1cmd", " fe_out", " cpu1size", " fe_size", " fe_cmd", " cpu_size", " cpu_cmd", " cpu1out", " cpu1init", " cpu_init"], "cpu_model": ["CPU_model", "cpu2label", "CPU_models", "cpu2model", "cpu_type", "gpu_Model", "gpu_model", "cpu_link", "cpu_Model", "CPU_Model", "cpu2link", "cpu2Model", "cpu_models", "gpu_label", "CPU_type", "cpu_label", "gpu_link"], "sysclk": ["sysclke", "sysCLdk", " sysClk", "syschk", " sysClke", "sysclck", " syscldk", "sysCLck", "sysCLk", "sysClks", "syschck", " sysClck", "syschdk", "sysCldk", " sysCldk", "sysCLks", "sysCLke", "sysClke", "syschke", "sysclks", " sysclks", " sysclke", "sysClk", "syscldk", "sysClck", " sysclck"], "cpu": ["core", "p", "python", "gpu", "rc", "ck", "alloc", "processor", "process", "ce", "cn", "stat", " pc", "tp", "null", "goal", "gc", "pkg", " cp", "bench", "prof", "loader", "conn", "cu", "cum", "vm", "cv", "c", "node", "php", " CPU", "jp", "cli", "proc", "nu", "hw", "pid", "ork", "pu", "coin", "result", "ctx", "chip", "clock", "CP", "aco", "aq", "hog", "component", "px", "mem", "phy", "pc", "np", "cam", "cal", "pool", "cache", "cmd", "computer", "obj", "CPU", "linux", "pai", "nc", "exe", "cp", "instance"], "env": ["door", "eh", "et", "app", "desc", "equ", "ten", "err", "eg", "worker", "uv", "event", "server", "sv", "bean", "term", "next", "ew", "ue", "v", "ev", "eas", "state", "engine", "start", "context", "menu", "enc", "e", "esc", "disk", "environment", "vs", "db", "entry", "sc", "dev", "mem", "erd", "esp", "era", "cmd", "Environment", "inst", "eng", "scope", "ef", "ei", "cv", "den", "ec", "proc", "hw", "buf", "ctx", "ptr", "ve", "kh", "buffer", "config", "np", "obj", "cache", "nc", "shell", "vp", "er", "en", "end", "org", "cb", "window", "win", "init", "ob", "aka", "ea", "conn", "ent", "here", "console", "viron", "priv", "js", "eu", "doc", "pb", "ah", "mn", "nv", "eve"], "irqs": ["nirqs", "irtfy", "irqa", "nirqa", "irfts", "iriqs", "pirqs", "irivals", "mirques", "irques", "iorqs", " irews", "pirqi", " irvals", "mirq", "irqi", "pirews", "iriigs", "mirews", "irfy", "rinews", "irq", " irfts", "nirqi", "rinqs", "irtvals", "iruds", "irtews", "iorqa", "irews", "pirques", " irqi", "mirfts", "irvals", " irques", "rinques", "nirques", " irigs", "mirqi", "mirqs", "irtuds", "iorqi", "irtigs", "irtqi", "irigs", " irfy", "rinq", "pirqa", " irq", "piruds", "rinfts", "rinqi", "irify", "rinuds", "irtqs", "iorques"]}}
{"project": "FFmpeg", "commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "target": 1, "func": "static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n", "idx": 22944, "substitutes": {"qtables": ["txtries", "ktries", "qqables", "txtables", "qtives", "vtigs", "qqries", "vtives", "ktigs", "qtigs", "txtues", "ktiers", "qqigs", "vtues", "eqables", "eques", "eqives", "vtiers", "qqiers", "eqries", "txtives", "vtables", "qtries", "ktables", "qtiers", "qtues", "vtries"], "q": ["n", "qv", "quality", "fx", "p", "t", " quer", "question", "it", "iq", "quit", "print", "r", "quer", "dq", "f", "m", "type", "length", "qq", "y", "qt", " eq", "d", "count", " z", " queries", "x", "Q", " qu", " queue", " qual", "c", "query", "qi", "que", "quant", "z", "qa", "k", "quarter", " Q", " k", "queue", "frequency", " req", "aq", "qu", "factor", "qual", "g", "ch", "eq", "sq", "u", "qs", "w", "quad", "work", " p", " query", "v", "ue", " quality", " sq", " quant"], "i": ["bi", "n", "ij", "t", "phi", "\u0438", "ic", "it", "ri", "print", "si", "me", "di", "index", "iu", "ai", " x", "xi", "m", "ix", "y", " I", "us", "init", "multi", "ji", "im", "zi", "ei", "val", "x", "id", "sim", "ind", "gi", "info", " ti", "I", "s", "qi", "ki", "ti", "j", "ini", "ip", "asi", "z", "status", "li", "ui", "fi", " bi", "iter", "ta", "ci", " j", "in", "ik", "mi", "ii", "client", "pi", "l", "v", "hi", "uri", "chain", "yi"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n", "idx": 22949, "substitutes": {"afq": ["apq", "afqueue", "arpue", "afck", " afql", "avue", "rafdq", "affiq", "auxiq", " afqu", "ajm", "afqu", "avqueue", "affql", "alfqq", "afqq", "ajql", "arpiq", " afqueue", "afque", "alfq", "auxq", "afm", "arpqs", "affue", "avqu", "apqu", "lfck", "affreq", " afreq", "arpql", "afql", "arpq", "arpque", "alfqu", "avq", "apue", "auxqq", "alfdq", "ajue", "affck", "auxdq", "ajq", "lfreq", "afqs", "afdq", "affque", "afue", "apqueue", "rafq", "auxqs", "afreq", "lfql", " afck", "lfq", "affqs", "affm", "auxque", "affq", " afue", "rafqq", "rafqu", "auxqu", "afiq", "arpm"]}}
{"project": "FFmpeg", "commit_id": "81cc7d0bd1eab0aa782ff8dd49e087025a42cdee", "target": 1, "func": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n", "idx": 22955, "substitutes": {"_dst": ["_Ddest", "_fsrc", "_dsrc", "_rbr", " _dist", " _dsrc", " _fist", "_fst", "_dist", "_fdest", "_dbr", "_dsbr", "_dsst", "_Dsts", " _fbr", "_fist", "_dsist", "_dsts", "_fot", "_dssrc", "_fsts", "_fbr", "_rsrc", "_rst", "_Dot", " _dbr", " _fst", " _fsrc", "_Dst", "_dot", "_ddest", "_rist"], "i": ["is", "ic", "ski", "m", "ims", " I", "wi", "im", " index", "span", "I", "jp", "ti", "batch", "asi", "ui", "ex", " bi", "v", " err", "uri", "chain", "\u0438", "si", "me", "ai", "ix", "ji", "x", " ii", "e", "sim", "ind", "gi", " ti", "fi", " ni", "oi", " pi", "hi", "b", "bi", "phi", "ogi", "it", "ri", "xi", "f", "y", "multi", " my", "zi", "qi", "ini", "li", "ci", "mi", "ii", " mi", "pi", "ij", "p", "di", "index", "iu", "us", "init", "id", " iter", "ki", "j", "ms", " wi", " multi"], "dst": ["Dust", "jdest", "jsts", "dbr", "dsbr", "daST", "daist", " dbr", "jnt", " dsts", "Dbr", "dnt", " dpt", "Dpt", "dpt", " dist", "dust", "daust", " dST", "dST", "jst", "Dst", "dast", " dnt", "dsdest", "Dist", "Dnt", "dspt", "DST", "Dsts", " dust", "dist", " ddest", "Ddest", "dsst", "ddest", "dsts"]}}
{"project": "FFmpeg", "commit_id": "1f80742f49a9a4e846c9f099387881abc87150b2", "target": 1, "func": "static void fill_coding_method_array(sb_int8_array tone_level_idx,\n\n                                     sb_int8_array tone_level_idx_temp,\n\n                                     sb_int8_array coding_method,\n\n                                     int nb_channels,\n\n                                     int c, int superblocktype_2_3,\n\n                                     int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n}\n", "idx": 22956, "substitutes": {"tone_level_idx": ["tone_level_intxs", "tone_level_iden", "tone_level_Idx", "tone_level_idsch", "tone_level_idxes", "tone_level_idsv", "tone_level_intg", "tone_level__idsu", "tone_level_Idg", "tone_level_intn", "tone_level_ipb", "tone_level_aidch", "tone_level_idep", "tone_level__idsg", "tone_level_idp", "tone_level_ipn", "tone_level_ider", "tone_level__idx", "tone_levelptaidv", "tone_level_aidg", "tone_levelptidch", "tone_level_idsxes", "tone_level__idu", "tone_level_intx", "tone_level_aidx", "tone_level__idsxs", "tone_level__idxs", "tone_level_idsxs", "tone_level_uidx", "tone_level_idexs", "tone_level_uidu", "tone_level_ipx", "tone_level_Idxs", "tone_level_idch", "tone_level__idg", "tone_levelptaidch", "tone_level_ipg", "tone_level_idsx", "tone_level_idn", "tone_levelptidx", "tone_level_idsu", "tone_level_idv", "tone_level__idxes", "tone_level_idsn", "tone_level_idsp", "tone_level_Idb", "tone_level_idex", "tone_level_idsg", "tone_levelptidg", "tone_levelptaidx", "tone_level_idg", "tone_level_idsr", "tone_level_uidg", "tone_level_idu", "tone_level_idb", "tone_level__idsx", "tone_levelptidv", "tone_level_Idn", "tone_level__idp", "tone_level_idexes", "tone_level_uidxs", "tone_level_idxs", "tone_level_aidv", "tone_levelptaidg", "tone_level_idr"], "tone_level_idx_temp": ["tone_level_idn_current", "tone_level_idg_tmp", "tone_level_idx_current", "tone_level_idx2buffer", "tone_level_idx__tmp", "tone_level_idn_temp", "tone_level_idx_tem", "tone_level_idx2tem", "tone_level_idx2tmp", "tone_level_idg_tem", "tone_level_idx2result", "tone_level_idn_buffer", "tone_level_idn_Temp", "tone_level_idg_temp", "tone_level_idx_Temp", "tone_level_idx__result", "tone_level_idx_result", "tone_level_idn_tem", "tone_level_idx_tmp", "tone_level_idn_tmp", "tone_level_idx2current", "tone_level_idx2temp", "tone_level_idx__temp", "tone_level_idx_buffer", "tone_level_idx__tem", "tone_level_idx2Temp", "tone_level_idg_result"], "coding_method": ["coding_data", "coder_table", "coder_method", "coding_map", "coder_map", "coding_table", "coder_data"], "nb_channels": ["nb_Champles", "nb_cannels", "nb_compannels", "nb_vertannels", "nb_chanunks", "nb_Channels", "nb_champles", "nb_vertans", "nb_chunks", "nb_chans", "nb_Chans", "nb_compans", "nb_compamples", "nb_chanannels", "nb_Chunks", "nb_camples", "nb_chanans", "nb_vertunks", "nb_cans"], "c": ["n", "t", "p", "rc", "cb", "f", "m", "h", "ac", "ct", "d", "count", "cs", "cv", "C", "lc", "cm", "sc", "config", "cache", "cc", "b", "v", "l", "fc", "cp", "ca"], "superblocktype_2_3": ["superblocktype_2p15", "superblocktype_2p1", "superblocktype_1_1", "superblocktype_1_3", "superblocktype_3_3", "superblocktype_2p3", "superblocktype_2_1", "superblocktype_3_7", "superblocktype_2x1", "superblocktype_2p4", "superblocktype_2_4", "superblocktype_2x7", "superblocktype_2x2", "superblocktype_2x3", "superblocktype_1_4", "superblocktype_3_1", "superblocktype_2_15", "superblocktype_1_15", "superblocktype_3_2", "superblocktype_2_7", "superblocktype_2_2"], "cm_table_select": ["cm_table2table", "cm_table_opt", "cm_type_table", "cm_table2selection", "cm_type_selection", "cm_table_selection", "cm_type_opt", "cm_table2opt", "cm_type_select", "cm_table2select", "cm_table_table"], "ch": ["chat", "che", "sch", "cho", "chart", "he", "et", "m", "th", "count", "ot", "cd", "cht", "hand", "och", "br", "bh", " Ch", "qu", "gr", "bt", "cr", "work", "channel", "eb", "zh", "chan", "gb", "x", "i", "cs", "ih", "cell", "ph", "sc", "chron", "b", "ech", "att", "cp", "ht", "vc", "chn", "chrom", "CH", "y", "tch", "atch", "hw", "Ch", "sh", "kh", "range", "gh", "uch", "cha", "history", "er", "mot", "cb", "ach", "chi", "ich", "h", "sk", "ac", "ct", "conn", "arch", "q", "cor", "hl", "ur", "ah"], "sb": ["sch", "esm", "arb", "su", "erb", "dt", "sat", "jp", "zb", "sn", "bh", "ub", "server", "sv", "ssl", "sw", "wb", "hs", "kb", "bt", "bb", "abb", "eb", "si", "hh", "stat", "bps", "ji", "gb", "ha", "bs", "ib", "SB", "bn", "bis", "nb", "se", "sm", "ibl", "db", "sc", "stab", "ebin", "usb", "sg", "b", "bj", "sit", "bi", "ben", "sys", "sa", "bf", "osp", "sf", "sd", "gc", "lb", "fb", "s", "sr", "bg", "sh", "kh", "ja", "sp", "orb", "buff", "sbm", "sid", "shop", "esi", "shell", "serv", "ij", "dh", "rb", "dB", "cb", "ob", "src", "bc", "gs", "bot", "nm", "sth", "sam", "meg", "pb", "typ", "jj", "bp", "gov"], "j": ["bi", "ij", "aj", "n", "er", "p", "it", "ret", "jit", "ion", "jl", "m", "y", "ji", "so", "pt", "ib", "ot", "i", "ind", "eg", "str", "jp", "z", "fr", "ng", "jc", "bo", "br", "q", "jump", "J", "oj", "pr", "jet", "ia", "ja", "db", "ju", "adj", "jas", "js", "g", "at", "jo", "sp", "job", "ik", "obj", "uj", "kj", "json", "kid", "je", "jj", "b", "v", "bj", "dj", "l", "att"], "tmp": ["td", "perm", "mitt", "sup", "mk", "t", "pot", "p", "tt", "msg", "txt", "Temp", "yet", "EMP", "MP", "mmm", "mm", "tn", "m", "tp", "qq", "gm", "aaa", "etc", "pkg", "src", "trap", "mint", "mp", "copy", "timeout", "test", "xy", "emp", "temp", "cmp", "proc", "angle", "prop", "result", "option", "prime", "amp", "sp", "appy", "prefix", "buff", "np", "cmd", "tc", "obj", "cache", "pos", "pre", "tm", "uu", "pad", "v", "jj", "cp", "tf", "vv", "attr"], "acc": ["perm", "ACC", "txt", "ack", "AC", "sum", "iff", "ac", "aw", "fee", "mom", "fac", "aff", "temp", "cmp", "aa", "ann", "alpha", "angle", "op", "ag", "cell", "adj", "sc", "dev", "inc", "Acc", "conf", "tc", "cache", "rec", "cc", "att", "ca", "tf", "attr", "eff"], "esp_40": ["fp_temp", "espxunit", "espxconv", "espxtemp", "fp_unit", "esp_unit", "esp_temp", "fp_conv", "fp_40", "esp_conv", "espx40"], "comp": ["perm", "sup", "com", "comment", "app", "change", "prep", "omp", "cmp", "proc", "ip", "img", "op", "butt", "ctx", "Comp", "cell", "cond", "component", "conf", "cmd", "cache", "mod", "diff", "fc", "cp", "attr"], "add1": [" add001", "sum2", "draw1", "ADD7", "dd1", "ddOne", "appOnce", "save001", "draw001", "addOnce", "added1", "Add1", "drawOnce", "app4", " add7", "added4", "save1", "addOne", "save4", "dd2", "Add4", "AddOne", " addOne", "app1", "Add7", "draw4", "ADD1", "add001", "add7", "Add001", "saveOnce", "Add2", "added001", "app001", "sum1", "added2", "ADD2", "sum4"], "add2": ["attach1", "addSecond", "dd1", "Add6", "Add3", "new4", "apply2", " add02", "Add1", "dd4", "make2", "create2", "createSecond", "addTwo", "dd2", "Add4", "attach4", "apply02", "apply6", "add6", "dd6", "attach2", "create4", "createTwo", "newTwo", "makeTwo", "Add2", "make4", "makeSecond", "attach6", "newSecond", "new2", " add6", "add02", "dd3", "apply1", "Add02"], "add3": [" addThree", "plus3", "attach1", "eff3", "createthree", "effthree", "Add03", "Add3", "add512", "sum3", "attach43", "add43", "added03", "Add1", "sum03", "addthree", "attach03", "post3", " add03", "sum43", "added6", "post43", "plus512", "eff512", "post03", "eff003", "create3", "Add4", "attach4", "create512", "plus003", "add6", "attach2", "plusthree", "append4", "post1", "addedThree", "append03", "Add2", "addThree", "add03", "added3", "append1", "attachThree", "attach6", "sum1", "append3", " add6", "attach3", "add003", "append2", "create003"], "add4": ["adder94", "attach1", " add04", "ext32", "load22", "build14", "plus94", "Add04", "adder3", "Add1", "update45", "plus45", "load4", "build429", "load1", "update4", "dd4", "attach04", "build4", "adder4", "add45", "adder45", "added4", "attach429", "Add32", " add16", "add16", "dd2", "Add4", "attach4", " add429", "ext4", "adderNo", "dd16", "add94", "addNo", "attach14", "add32", "attach2", "add5", "added5", "updateNo", " add14", "Add2", "plusNo", "build1", "update94", " add22", "plus4", "Add22", "adder16", "added1", "add04", "add14", "ext1", "added32", "adder2", "dd3", "add22", "ext5", "add429", "Add5"], "multres": ["subrem", "_ret", "divRes", "diffret", "_res", "divrem", "divret", "_Res", "diffres", "subres", "_rem", "subRes", "divres", "subret", "diffRes", "diffrem"]}}
{"project": "FFmpeg", "commit_id": "9ec39937f9c7f28a2279a19f71f290d8161eb52f", "target": 1, "func": "static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,\n\n                        int width, int height, int stride, Transform *t)\n\n{\n\n    int x, y;\n\n    IntMotionVector mv = {0, 0};\n\n    int counts[128][128];\n\n    int count_max_value = 0;\n\n    int contrast;\n\n\n\n    int pos;\n\n    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));\n\n    int center_x = 0, center_y = 0;\n\n    double p_x, p_y;\n\n\n\n    // Reset counts to zero\n\n    for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n        for (y = 0; y < deshake->ry * 2 + 1; y++) {\n\n            counts[x][y] = 0;\n\n        }\n\n    }\n\n\n\n    pos = 0;\n\n    // Find motion for every block and store the motion vector in the counts\n\n    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {\n\n        // We use a width of 16 here to match the libavcodec sad functions\n\n        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {\n\n            // If the contrast is too low, just skip this block as it probably\n\n            // won't be very useful to us.\n\n            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);\n\n            if (contrast > deshake->contrast) {\n\n                //av_log(NULL, AV_LOG_ERROR, \"%d\\n\", contrast);\n\n                find_block_motion(deshake, src1, src2, x, y, stride, &mv);\n\n                if (mv.x != -1 && mv.y != -1) {\n\n                    counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1;\n\n                    if (x > deshake->rx && y > deshake->ry)\n\n                        angles[pos++] = block_angle(x, y, 0, 0, &mv);\n\n\n\n                    center_x += mv.x;\n\n                    center_y += mv.y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pos = FFMAX(1, pos);\n\n\n\n    center_x /= pos;\n\n    center_y /= pos;\n\n\n\n    t->angle = clean_mean(angles, pos);\n\n    if (t->angle < 0.001)\n\n        t->angle = 0;\n\n\n\n    // Find the most common motion vector in the frame and use it as the gmv\n\n    for (y = deshake->ry * 2; y >= 0; y--) {\n\n        for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n            //av_log(NULL, AV_LOG_ERROR, \"%5d \", counts[x][y]);\n\n            if (counts[x][y] > count_max_value) {\n\n                t->vector.x = x - deshake->rx;\n\n                t->vector.y = y - deshake->ry;\n\n                count_max_value = counts[x][y];\n\n            }\n\n        }\n\n        //av_log(NULL, AV_LOG_ERROR, \"\\n\");\n\n    }\n\n\n\n    p_x = (center_x - width / 2);\n\n    p_y = (center_y - height / 2);\n\n    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;\n\n    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;\n\n\n\n    // Clamp max shift & rotation?\n\n    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);\n\n    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);\n\n    t->angle = av_clipf(t->angle, -0.1, 0.1);\n\n\n\n    //av_log(NULL, AV_LOG_ERROR, \"%d x %d\\n\", avg->x, avg->y);\n\n    av_free(angles);\n\n}\n", "idx": 22959, "substitutes": {"deshake": ["dateshank", "dewak", "dalshak", " dreshaze", "dulfark", "dismade", "dewask", "datesmrake", "deworkake", "dishank", " dewair", " dreshake", "dishcake", "fdreshake", "wreshark", "sdeshcake", "dalshade", "dsreshcake", "dishair", "deshask", "dahair", "dellyake", "dellyale", "dsreshank", "sdesmare", "fdeshoke", "dellyapp", "desmak", "ondishark", "dleshark", "mewake", "dleshapp", "dellaze", "ondeshare", "dideshare", "dulfake", "harshuke", "dashak", "desmache", "deshuke", "daeshale", " dewak", "dahare", "dreshask", "dalityaker", "fdeshare", "dreshak", "dseshank", "desmake", "dshank", "dalityake", "deshank", " dleshake", "dewark", " deshair", "dreshapp", "dalityare", " deshare", " deshaker", "didalityare", "mewark", "sewark", "dleshase", "ondishare", "dewcake", "darshcake", "dateshake", "dhlake", "heshask", "sdesmache", "deshoke", "fdreshare", "dreshark", "desmank", "didalityask", "dewair", " dewark", " dewaker", "dsreshake", "dideshaker", "darshache", "deware", " dleshalk", "dismalk", " deshase", "deshark", " deshaze", "deworkak", "meshare", "doothak", "dismake", "dellade", "dshalk", "datesmake", " dreshask", "dhlare", " deware", "deshcake", "darshuke", "daoothake", "desmare", "seshak", "ondishake", "seshark", "dleshade", "deworkank", "deshaker", " dreshak", "dalityak", "dseshcake", "dshrake", " dewake", "sdeshare", "sdeshake", "dahak", "dreshale", "dreshaze", "seshake", "harshake", "daoothak", "sdesmcake", "deshalk", "dhlark", " dleshase", "deshapp", "dethuke", "dalshake", "deworkcake", "desmapp", "dellak", "dethaker", "dewake", " dreshare", "meware", "deshair", "dleshalk", "dethoke", "desmalk", "desmrake", "desmark", "dishare", "dismase", "sdeshache", "meshak", "wreshaze", "dewade", "sewapp", "daeshak", "dreshare", "dethare", "dseshake", " deshade", "ondishair", "ondeshake", "dleshak", "darshare", " dleshade", "dreshoke", "dalshask", "dashake", "dateshalk", " dreshalk", "dreshrake", "dellyak", "darshake", "fdeshak", "deshache", "weshark", "wreshak", "dashaker", "doothale", "sewak", "ondeshair", "darshask", "didalityaker", "doothake", "dideshake", "dalshare", "dreshank", "deshase", "sewake", "fdeshake", "dashare", "ondeshark", "weshaze", "dahake", "wreshake", "daoothapp", "dethake", "meshark", " deshak", "daeshapp", "dshark", "daeshake", "deshale", "harshask", "deshak", "desmcake", "dewuke", "dalshaze", "fdreshoke", "dleshake", "dshake", "dreshcake", "sdesmake", "deshare", "deshade", "datesmank", "darshak", "dreshalk", "dshair", "dishark", "dsreshak", "deshrake", "dethask", "dhlak", "dleshaker", "dalityaze", "dewapp", "darshoke", "dulfaker", "doothapp", "daoothale", " deshalk", "dseshak", "dethalk", "didalityake", "seshapp", "weshake", "dishak", "dalityask", "heshare", "dishake", "dulfade", "dalityark", "harshare", "mewak", " deshask", "fdreshak", "dewaker", "weshak", "dreshase", "dshare", "dewaze", "dellake", "dreshake", "heshake", "deshaze", "dewache", "meshake", " deshark", "dideshask", " dreshade", "dalshalk", "dethak", "dateshrake", "datesmalk", "dreshade", "heshuke", "dahark"], "src1": ["src0", "rc0", "rc2", "rc3", "source2", "rc1", "source0", "source1", "source3", " src0", " src3", "src3"], "src2": ["rc4", "src0", "source4", "rc0", "rc2", "rc3", "src4", "source2", "rc1", "source0", "source1", "source3", " src0", " src3", "src3", " src4"], "height": ["density", "volume", "history", "radius", "hang", "ht", "he", "capacity", "depth", "ows", "hub", "length", "h", "pace", "window", "count", "val", "rows", "style", "resolution", "row", "Height", "size", "hei", "gravity", "padding", "sky", "buffer", "ow", "shape", "scroll", "ch", "range", "ty", "bottom", "stroke", "feed", "flow", "lat", "angle", "w"], "stride": [" strride", "strage", "STRage", "strride", "strategy", "striride", "distage", "STRend", " strides", "charride", "distide", "strend", "STRension", "slategy", "charension", "striide", "slride", "striice", "STRide", "slend", "STRategy", "charage", "strides", "distride", "STRride", "strice", "STRice", " strice", "STRides", "striides", " strategy", "strension", "distension", "slide", "charide", " strend"], "t": ["n", "td", "p", "tt", "txt", "it", "tg", "o", "r", "type", "f", "m", "tp", "title", "ct", "table", "total", "pt", "text", "ot", "e", "tk", "trace", " T", "target", "tl", "dt", "c", "st", "tr", "tv", "status", "ant", "T", "translation", "ta", "at", "g", "ts", "term", "tree", "tc", "wt", "tm", "l", "v", "tu", "tf", "vt"], "x": ["xes", "dx", "xt", "m", "ox", "yx", "im", "on", "xy", "X", "wx", "ex", "sw", "xs", "v", "inx", "xc", "n", "any", "ix", "ax", "i", "e", "lon", "xp", "px", "at", "dr", "ux", "mx", "g", "xxx", "att", "lat", "xx", "r", "xxxx", "sex", "xi", "f", "act", "by", "xa", "tx", "z", "zx", "xf", "ty", "l", "el", "xd", "fx", "p", "index", "xe", " xx", "check", "al", "ct", "key", "ware", "xml", "rx", "j", "lex", "q", "w"], "y": ["yo", "hy", "m", "wy", "cy", "yl", "ot", "on", "hot", "vy", "xy", "col", "ym", "yer", "ry", "v", "yy", "story", "any", "py", "a", "o", "ady", "ay", "fy", "i", "e", "ly", "my", "uy", "yt", "oy", "Y", "g", "yr", "b", "lat", "xx", "sys", "axy", "entity", "ery", "zy", "by", "aily", "c", "ya", "ity", "ip", "z", "sy", "sky", "ies", "try", "ty", "l", "yi", "p", "ys", "h", "hey", "key", "ey", "iy", "ny", "or", "asy", "j", "ch", "gy", "yn", "ye", "year"], "counts": ["ounts", "Countstats", "counterps", "counterstats", "contids", "ountps", "contals", " countids", "countps", "countals", " countries", "Counted", "ountstats", "ountments", "Counts", " countps", "Countls", "counters", " countls", " countments", "countments", "Countps", "countries", "countls", "ountls", " countals", "ounted", "ountals", "countered", "contments", "ountids", "countstats", "ountries", "conts", "counted", "countids", "Countries"], "contrast": ["distrib", "distract", "ontrib", "condact", "disterence", "distrast", "contract", "distact", "constride", "contrib", "sturb", "consterence", "contact", "condness", "constrast", "compurb", "disteff", "conurb", "onterence", " contract", "stact", "distride", "conride", "strast", "compact", "steff", " contride", "conturb", "compride", " conteff", "conrast", "condrast", "conterence", " conterence", "stract", "condrib", "contride", "comprast", "conderence", "ontact", "conteff", "constness", "condride", "conact", "ontrast", "contness", " contness"], "pos": ["n", "yes", "p", "val", "neg", "out", "start", "it", "o", "os", "index", "Pos", "vol", "ref", "pose", "offset", "win", "init", "Position", " Pos", "post", "top", "ps", "pt", "loc", "po", "pro", "pp", "ind", "def", "row", "slot", " position", "axis", "size", "pres", "limit", "no", "proc", "pid", "col", "prop", "spec", "min", "position", "POS", "tmp", "cond", "num", "px", "up", "rot", "sp", " POS", "pc", "conf", "len", "port", "pi", "l", "origin", "point"], "angles": ["boxes", "phi", "mas", "inches", "rates", "aces", "bits", "ays", "maps", "ates", "heads", "rots", "atters", "outs", "ims", "pages", "forms", "units", "amps", "ints", "balls", "images", "rows", "anges", "bars", "bytes", "s", "ions", "faces", "files", "points", "ians", "values", "bles", "lines", "vs", "views", "vals", "types", "errors", "xs", "chains", "angular", "ads", "objects", "params", "aches", "blocks", "actions", "rings", "rices", "assets", "bys", "ations", "angle"], "p_x": ["p___tx", "p2x", "l_x", "p_tx", "p2tx", "p___w", "l_y", "p2w", "l_tx", "p___x", "l_w", "p2y", "p_w", "p___y"], "p_y": ["p_by", " p___xy", "p_ry", "pointry", " p_ry", "p___by", " p___y", " p___ry", "p_xy", "p___xy", "pointby", " p_by", "pointxy", " p_xy", "p___ry", " p___by", "pointy", "p___y"]}}
{"project": "FFmpeg", "commit_id": "984f50deb2d48f6844d65e10991b996a6d29e87c", "target": 1, "func": "static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)\n\n{\n\n    DiracContext *s     = avctx->priv_data;\n\n    AVFrame *picture    = data;\n\n    uint8_t *buf        = pkt->data;\n\n    int buf_size        = pkt->size;\n\n    int i, data_unit_size, buf_idx = 0;\n\n    int ret;\n\n\n\n    /* release unused frames */\n\n    for (i = 0; i < MAX_FRAMES; i++)\n\n        if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {\n\n            av_frame_unref(s->all_frames[i].avframe);\n\n            memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));\n\n        }\n\n\n\n    s->current_picture = NULL;\n\n    *got_frame = 0;\n\n\n\n    /* end of stream, so flush delayed pics */\n\n    if (buf_size == 0)\n\n        return get_delayed_pic(s, (AVFrame *)data, got_frame);\n\n\n\n    for (;;) {\n\n        /*[DIRAC_STD] Here starts the code from parse_info() defined in 9.6\n\n          [DIRAC_STD] PARSE_INFO_PREFIX = \"BBCD\" as defined in ISO/IEC 646\n\n          BBCD start code search */\n\n        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {\n\n            if (buf[buf_idx  ] == 'B' && buf[buf_idx+1] == 'B' &&\n\n                buf[buf_idx+2] == 'C' && buf[buf_idx+3] == 'D')\n\n                break;\n\n        }\n\n        /* BBCD found or end of data */\n\n        if (buf_idx + DATA_UNIT_HEADER_SIZE >= buf_size)\n\n            break;\n\n\n\n        data_unit_size = AV_RB32(buf+buf_idx+5);\n\n        if (buf_idx + data_unit_size > buf_size || !data_unit_size) {\n\n            if(buf_idx + data_unit_size > buf_size)\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Data unit with size %d is larger than input buffer, discarding\\n\",\n\n                   data_unit_size);\n\n            buf_idx += 4;\n\n            continue;\n\n        }\n\n        /* [DIRAC_STD] dirac_decode_data_unit makes reference to the while defined in 9.3 inside the function parse_sequence() */\n\n        if (dirac_decode_data_unit(avctx, buf+buf_idx, data_unit_size))\n\n        {\n\n            av_log(s->avctx, AV_LOG_ERROR,\"Error in dirac_decode_data_unit\\n\");\n\n            return -1;\n\n        }\n\n        buf_idx += data_unit_size;\n\n    }\n\n\n\n    if (!s->current_picture)\n\n        return buf_size;\n\n\n\n    if (s->current_picture->avframe->display_picture_number > s->frame_number) {\n\n        DiracFrame *delayed_frame = remove_frame(s->delay_frames, s->frame_number);\n\n\n\n        s->current_picture->avframe->reference |= DELAYED_PIC_REF;\n\n\n\n        if (add_frame(s->delay_frames, MAX_DELAY, s->current_picture)) {\n\n            int min_num = s->delay_frames[0]->avframe->display_picture_number;\n\n            /* Too many delayed frames, so we display the frame with the lowest pts */\n\n            av_log(avctx, AV_LOG_ERROR, \"Delay frame overflow\\n\");\n\n\n\n            for (i = 1; s->delay_frames[i]; i++)\n\n                if (s->delay_frames[i]->avframe->display_picture_number < min_num)\n\n                    min_num = s->delay_frames[i]->avframe->display_picture_number;\n\n\n\n            delayed_frame = remove_frame(s->delay_frames, min_num);\n\n            add_frame(s->delay_frames, MAX_DELAY, s->current_picture);\n\n        }\n\n\n\n        if (delayed_frame) {\n\n            delayed_frame->avframe->reference ^= DELAYED_PIC_REF;\n\n            if((ret=av_frame_ref(data, delayed_frame->avframe)) < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    } else if (s->current_picture->avframe->display_picture_number == s->frame_number) {\n\n        /* The right frame at the right time :-) */\n\n        if((ret=av_frame_ref(data, s->current_picture->avframe)) < 0)\n\n            return ret;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    if (*got_frame)\n\n        s->frame_number = picture->display_picture_number + 1;\n\n\n\n    return buf_idx;\n\n}\n", "idx": 22966, "substitutes": {"avctx": ["avetc", "apconn", "aptx", "averpool", "avekb", "avecli", "navpool", "savctx", "savcli", "avtc", "avertc", " avtc", " avconn", "afcb", "avereq", "avcontext", "afconn", " avcb", "avecb", "navtx", "navctx", "vcontext", "avertx", "avercontext", "avpool", "avcb", "savsys", "avesys", "avtx", "apctx", "avepool", "aversys", "apcontext", "averctx", "aveconn", "avetx", "avecontext", "navtc", "avsys", "afcontext", "vtx", "afctx", "vconn", "averreq", "avercli", " avkb", "avcli", "savreq", "avectx", "avkb", "avreq", " avcontext", " avtx", "avconn", "vctx", "averkb"], "data": ["quality", "message", "this", "policy", "value", "length", "rel", "format", "none", "batch", "no", "media", "video", "map", "Data", "action", "padding", "type", "name", "present", "Picture", "a", "root", "package", "empty", "info", "join", "important", "size", "bytes", "password", "dat", "new", "sequence", "bin", "frame", "funding", "photo", "piece", "table", "d", "image", "url", "whatever", "def", "mu", "snap", "family", "extra", "raw", "buffer", "cache", "to", "actions", "metadata", "share", "p", "bits", "record", "window", "original", "ata", "id", "fp", "img", "png", "DATA", "block", " DATA", "input", "pad", "pic", "text"], "got_frame": ["got_next", "got_error", " got_offset", "got___offset", "got___next", "got_offset", "got_frames", "fetched_Frame", "kept_frame", "got_msg", "kept_fb", "fetched_frame", "got___msg", "fetched___Frame", "gotlyframe", "kept_frames", "gotNewoffset", "got___Frame", "fetched___msg", " got_next", "gotNewframes", "gotlytime", "gotlyFrame", " got_frames", "got_fb", "fetched_time", "fetched___time", "gotNewframe", "kept_error", "got_Frame", "got___frame", "got___time", "fetched___frame", "fetched_msg", "got_time", "got___frames", "gotNewnext", "gotlymsg"], "pkt": ["mdu", "pdu", "ppkt", "opdu", "prokt", "macket", "opacket", " pck", "opkt", "prock", " ppt", "cpdu", " pdu", "ppdu", "ppacket", "packet", "cpck", "mck", "cppt", "mkt", "produ", "cpkt", "pck", "ppt", "proacket", "cpacket", "opck", " packet", "pppt"], "s": ["ports", "is", "these", "ims", "sts", "ds", "details", "ex", "sv", "sw", "ssl", "hs", "ess", "ins", "als", "less", "sb", "as", "v", "local", "sl", "a", "os", "list", "changes", "ns", "bs", "cs", "fs", "aws", "states", "ats", "vs", "scripts", "sc", "service", "g", "ts", "qs", "events", "comm", "t", "sys", "sa", "stats", "d", "pkg", "ps", "services", "comments", "c", "ctx", "spec", "ls", "S", "its", "aunts", "actions", "p", "parts", "set", "h", "ss", "ses", "sports", "rs", "gs", "sam", "ms", "js", "sq", "ares", "w"], "picture": ["p", "pict", "Picture", "frame", "photo", "record", "policy", "root", "piece", "image", "style", "id", "document", "info", "profile", "pid", "fp", "family", "img", "media", "png", "P", "video", "fi", "camera", "feature", "file", "pic"], "buf": ["p", "rb", "cap", "txt", "msg", "pack", "func", "cb", "ref", "desc", "window", "err", "bl", "aka", "ob", "conv", "pkg", "Buff", "arr", "uf", "def", "bc", "Buffer", "cv", "fb", "bytes", "vec", "cur", "proc", "lim", "img", "ff", "prop", "ctx", "ptr", "br", "queue", "tmp", "seq", "env", "map", "db", "buffer", "box", "iter", "mem", "doc", "buff", "np", "cmd", "cam", "emb", "cache", "pool", "b", "cast", "v", "pad", "text"], "i": ["n", "bi", "ij", "p", "t", "\u0438", "phi", "ic", "it", "iq", "ri", "si", "me", "di", "index", "list", "ai", "iu", "xi", "f", "m", "ix", "io", "y", "ims", "ji", "multi", " m", "conv", "im", "zi", "x", "id", " ii", "e", "sim", "ind", "gi", " ti", "I", "c", "info", "my", "ami", "qi", "ki", "ini", "j", "ti", "batch", "ip", "asi", "cli", "li", "details", "ui", "ex", "fi", "mount", "oi", "ci", " j", "mi", "remote", "json", "ii", " mi", "pi", "v", "point", "uri"], "data_unit_size": ["data_unitingSize", "data_unit__Size", "data_unit\u05bcerror", "data_unit_string", "data_unit2type", "data_unit\u05bccount", "data_unit\u05bcSIZE", "data_unitingfrom", "data_block_Size", "data_block_type", "data_unit_SIZE", "data_block_size", "data_unitingSIZE", "data_unit\u05bcsize", "data_unit_vector", "data_unit__SIZE", "data_unit2size", "data_unitingsize", "data_Unit_size", "data_unit2Size", "data_Unit_Size", "data_unit_count", "data_unit_length", "data_unit2string", "data_unit_Size", "data_Unit_name", "data_unit__size", "data_unit_type", "data_unit_error", "data_unit_name", "data_unit__vector", "data_unit_from"], "ret": [" ptr", " ref", " num", " res", "si", " out", "Ret", "val", "il", "j", " ar", "fi", " resp", " bi", " count", "mem", " r", " status", "__", " new", "RET", "mi", "len", " af", " mi", "ry"], "buf_idx": ["buf_inex", "buf_indix", "bufptdix", "buf_idfx", "buf_IDdx", "buf_dixs", "buf_ix", "buf_logx", "buf_indexdx", "buf_idnex", "buf_idsic", "buf_idee", "buf_logdx", "buf_midx", "buf_storexs", "buf_iterdx", "buf_indexx", "bufptidxs", "buf_intern", "buf_idw", "buf_ixs", "buf_midty", "buf_indexz", "buf_iterix", "buf_ideox", "buf_indn", "buf_outic", "buf_idic", "buf_Idz", "buf_intere", "buf_idsx", "buf_IDnex", "buf_iddx", "buf_iz", "buf_handlex", "buf_IDox", "buf_indexax", "bufptidx", "buf_handleix", "buf_IDx", "buf_iterx", "buf_handleox", "buf_atxp", "buf_atn", "bufptiddx", "buf_indz", "buf_IDxs", "buf_idxp", "buf_IDrox", "buf_idxt", "buf_iterex", "buf_Idex", "buf_idxs", "buf_ideex", "buf_ate", "buf_idez", "buf_didx", "buf_idsv", "buf_handlety", "buf_IDix", "buf_Idx", "buf_iterox", "buf_ordix", "buf_idix", "buf_iterz", "buf_ordox", "buf_dix", "buf_indnex", "buf_indax", "buf_ordex", "buf_iax", "buf_indx", "buf_idsw", "buf_idsxt", "buf_indexxs", "buf_inddx", "buf_iternex", "buf_outx", "buf_index", "bufptdixs", "buf_idv", "buf_idew", "buf_idexp", "buf_outxt", "buf_idty", "buf_midox", "buf_logrox", "buf_keyox", "buf_indv", "buf_IDfx", "buf_ideix", "buf_idsix", "buf_indfx", "buf_keyty", "bufptidrox", "buf_idex", "buf_idz", "buf_keyix", "buf_iterfx", "buf_iden", "buf_iex", "buf_Idn", "buf_logxs", "buf_idrox", "buf_IDw", "buf_odx", "buf_idenex", "buf_indxs", "buf_idsex", "buf_odw", "buf_midix", "buf_storenex", "bufptdidx", "buf_interxp", "buf_storex", "buf_keyx", "buf_interx", "buf_dirox", "buf_storen", "buf_idax", "buf_ordx", "buf_idn", "buf_outw", "buf_iterv", "buf_ide", "buf_odox", "buf_idox", "buf_atx", "buf_odnex", "buf_in", "bufptdirox"]}}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969, "substitutes": {"env": ["er", "en", "scope", "rc", "context", "et", "h", "window", "ss", "init", "ens", "con", "e", "conn", "st", "ds", "ec", "esc", "hw", "setup", "exc", "buf", "ctx", "ptr", "environment", "server", "sw", "vs", "map", "sc", "viron", "erd", "config", "conf", "obj", "w", "sb", "nv", "v", "ev", "vt"], "s": ["n", "er", "p", "t", "sys", "is", "en", "a", "r", "os", "m", "ss", "ns", "ims", "ses", "stats", "src", "ps", "e", "sts", "rs", "gs", "aws", "args", "c", "ds", "ctx", "ls", "q", "ms", "sv", "ssl", "vs", "sc", "S", "js", "g", "es", "ins", "sq", "ts", "sp", "its", "sg", "conf", "obj", "sb", "b", "v", "serv"], "insn": ["rsc", "esm", "insnia", "outsen", "linsne", "opsk", "insN", "rson", "linsn", "INSpan", "outsgn", "linson", "insz", "msne", "csn", " inssn", "risne", "linsl", "kinsn", "ysize", "kinsyn", "insnr", "INSz", "linesl", "linesnia", "linsen", "outsize", "rsn", "opsN", "csns", "ysm", " insN", "INSen", " insize", "insne", "esn", "rsz", "insl", "linsnia", "insgn", "insize", "rsgn", "INSn", "inssn", "insen", " insne", "linsyn", " insin", " insm", "rsk", "outspan", "opsnr", "msn", "linsln", "mson", "opsgn", "rsln", "insc", "rison", "kinsl", "linsize", "rsnr", "insln", "risn", "linesn", "obsn", "insin", "INSin", "opsen", "opssn", "ysn", "inson", "opsln", "rsize", "outson", "linsnr", "outsn", "obsen", "linsgn", "linsns", "insk", "esize", "csen", "opsc", "linssn", "esne", "outssn", "linsk", "insyn", "cson", "rssn", "mssn", "obsns", "kinsnia", "linsc", "opspan", "rissn", "opsz", "insns", "rsN", "INSN", "insm", "opsn", "inspan", "linesyn", "obson", "ysne", "opsin", "INSsn", " insz"], "opsize": ["timesiz", "OPSIZE", "oopsize", "opize", " opseng", "bitsize", "OPSize", "topsIZE", "opsiz", "rsiz", "oopssize", "upsiz", "bitsiz", "oopsiz", "bysize", "bysIZE", "insization", "offsizer", "topsize", "insizer", "outsize", " opsizer", "timesize", "opersization", "psizer", "artsiz", "upssize", "upsization", "rsIZE", "opizer", "timesization", "opseng", " topsize", "bitsization", "insize", "offseng", "bitsizer", "offsization", "artsize", " topsizer", "opersiz", "upsize", "psize", "bitsIZE", " topsiz", "rsization", "opersizer", "outsiz", "outsIZE", "outsization", "psiz", "opssize", "opersize", "opsizer", "rsizer", "insiz", "opization", "opiz", "oopsization", "artsizer", " topsized", "rssize", " opsiz", "rsize", "inssize", "opsized", "oopsIZE", "OPSiz", "opsization", "topsization", "OPSsize", "OPSizer", "bysizer", " opsized", " opsization", "topsizer", "opsIZE", "openg", "oopsizer", "OPSization", "timesizer", "bysization", "artsization", "bitsized", "psization", "offsize"], "val": ["expr", "valid", "resp", "cho", "sel", "ival", "ret", "func", "vol", "stat", "ref", "bal", "value", "err", "rel", "al", "rol", "item", "eval", "key", "loc", "x", "arg", "def", "tx", "data", "test", "var", "Val", "vec", "local", "pol", "buf", "urg", "values", "grad", "res", "cond", "VAL", "vt", "vals", "addr", "mem", "doc", "util", "typ", "cal", "obj", "conf", "v", "el", "lib", "serv"], "addrp": ["addrps", "arrpa", " addrpre", "alignp", "ptrpa", "dirpre", "arrp", "arrpy", "oadup", "arppre", "oadp", "hostpc", " addrlp", "adpa", "alignpid", "arrpc", "arrlp", "oadjp", "alignpa", " addressp", " addresspc", "addrr", "addrpre", "addressps", "addressp", "adm", "adpar", " addrpy", "aliasps", " addrpa", " addrpc", "arpp", "alignjp", "hostpre", "ptrps", "alignps", " addrpid", "addrpid", "hostp", "arppc", " addrjp", "alignm", "ptrp", "addrjp", "oadps", "alignpar", "hostlp", "dirpy", "ptrpid", "ptrr", "alignr", "arplp", "addrup", "addresspid", "ptrm", "ptrP", "ptrpar", "dirlp", "aliasp", "arrpre", "adp", " addrps", "addressP", "addrP", " addresspa", "addrpar", " addrup", "addrpy", "aliaspid", "addrm", "alignup", " addrr", "aliasP", "addrpa", " addrm", "dirp", "addrpc", "addrlp"], "what": ["why", "fun", "were", "msg", "wash", "tag", "something", "where", "kind", "make", "wh", "did", "hod", " who", "WH", "act", "goal", "format", "aw", "have", "things", "how", "forth", "when", "hop", "whatever", "WHAT", "meaning", " how", "such", "important", "test", "nothing", "good", "want", "What", "having", "enough", "warn", "which", "spec", "here", "who", "because", " WHAT", "hat", "feat", " which", "stuff", "WHO", "wal", "doc", "wcs", "that", "from", "also", "everything", "typ", "w", "wat", "work", " why", "wrong", "thing", "yeah", "need", "type"], "reg": ["msg", "ret", "gro", "value", "err", "rol", "roy", "loc", "eg", "rar", "ress", "br", "res", "map", "region", "gr", "ser", "resp", "orig", "re", "state", "stat", "order", "rr", "data", "dat", "db", "adj", "mem", "g", "dr", "REG", "rep", "eng", "net", "sys", "leg", "tag", "r", "memory", "red", "ref", "rem", "Reg", "disc", "rank", "gc", "arg", "def", "var", "buf", "cod", "ptr", "trans", "req", "pg", "obj", "cache", "serv", "ig", "lr", "out", "rc", "org", "ru", "go", "key", "arr", "code", "conn", "row", "urg", "jump", "sam", "cond", "addr", "form", "mod", "rec", "grid", "bor"], "result": ["resp", "valid", "p", "response", "msg", "out", "rc", "final", "rn", "ret", "message", "func", "comment", "r", "cont", "make", "process", "output", "value", "err", "relation", "table", "pair", "total", "description", "complete", "current", "def", "results", "row", "data", "test", "cur", "cmp", "successful", "profile", "coord", "comb", "proc", "status", "first", "function", "other", "pr", "Result", "res", "rule", "report", "buffer", "new", "match", "sp", "term", "cache", "json", "diff", "next", "comp", "same", "v", "success", "public"], "offset": ["start", "index", "Offset", "ref", "off", "field", "count", "top", "loc", "slot", "var", "size", "coord", "base", "shift", "extra", "ptr", "seek", "addr", "error", "sp", "address", "obj", "pos", "cache", "pointer", "flag", "point"], "tmp": ["ret", "tar", "err", "top", "loc", "mint", "mp", "xy", "temp", "cur", "jp", "uv", "term", "tc", "v", "resp", "orig", " sp", "copy", "ind", "empty", "partial", "cmp", "uff", "new", "mem", "appy", "prefix", "prev", " prev", "acc", "cp", "t", "null", "table", "pkg", "cv", "var", "snap", "buf", "ctx", "extra", "ptr", "try", "rap", "sp", "nt", "buff", "np", "obj", "cache", "comp", "vp", "attr", "vt", "perm", "mk", "p", "old", "tt", "out", "txt", "tp", "etc", "gz", "src", " np", "emp", "img", "rt", "addr", "amp"]}}
{"project": "FFmpeg", "commit_id": "1330a0f31f373f3b9f1ea53d48b94edc47759b76", "target": 1, "func": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->bit_rate > 0) {\n\n        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n\n\n    if (avctx->rc_max_rate > 0)\n\n        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;\n\n\n\n    if (ctx->rc < 0) {\n\n        if (ctx->flags & NVENC_ONE_PASS)\n\n            ctx->twopass = 0;\n\n        if (ctx->flags & NVENC_TWO_PASSES)\n\n            ctx->twopass = 1;\n\n\n\n        if (ctx->twopass < 0)\n\n            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;\n\n\n\n        if (ctx->cbr) {\n\n            if (ctx->twopass) {\n\n                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;\n\n            } else {\n\n                ctx->rc = NV_ENC_PARAMS_RC_CBR;\n\n            }\n\n        } else if (avctx->global_quality > 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;\n\n        } else if (ctx->twopass) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;\n\n        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;\n\n        }\n\n    }\n\n\n\n    if (ctx->flags & NVENC_LOSSLESS) {\n\n        set_lossless(avctx);\n\n    } else if (ctx->rc > 0) {\n\n        nvenc_override_rate_control(avctx);\n\n    } else {\n\n        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;\n\n        set_vbr(avctx);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n}\n", "idx": 22970, "substitutes": {"avctx": ["savpool", "avtimeout", "avcf", "navcas", "averkl", "ovkw", "avehistory", "avertx", "avpool", "camhistory", "Avcontext", " avcrit", "averdocument", "varctx", "avkw", " avcmp", "navgc", "ovcf", "iamctx", "vartx", "ovinit", " avtimeout", "wavtx", "avfp", "avertimeout", "AVcu", "averkb", "varcf", "iamcontext", "devcontext", "avercmd", "devcas", "savkw", "avcmp", "Avcmp", "avercf", "camxy", "camsys", "avekl", "navctx", "avercontext", "iamtx", "aversys", "averctx", "aveca", "navcontext", "navkb", "wavcmd", "AVcontext", "devctx", "varkw", "avdocument", "avecmd", "avbatch", "ovctx", "varpool", "avcu", "avxy", "varinit", " avcontext", " avtx", " avmsg", "averca", "savctx", "avebatch", "avecrit", "camctx", "ajhistory", "averinit", "avepkg", "navtx", "AVcmp", "avtx", "avgc", "avetx", "avecontext", "averbatch", "savtimeout", "averxy", "avca", "avergc", "vardocument", "avmsg", "ajxy", "wavconn", "varfp", "avkb", "ajsys", " avcas", "avconn", "avercrit", "devtx", "wavctx", "averpool", "avcrit", " avconn", "avhistory", "averkw", " avbatch", "avcontext", " avcu", "avcas", "varmsg", "avinit", "wavca", " avpkg", "avkl", " avdocument", "avermsg", "averfp", "wavpkg", "aveconn", "avsys", "devkb", " avhistory", "Avtx", "averhistory", "devgc", "avpkg", " avkl", "avcmd", "AVtx", "ajctx", " avfp", "Avctx", "vartimeout", "avectx", "averconn", "AVctx", "iamcu"], "ctx": ["expr", "msg", "ppo", "ck", "desc", "unc", "loc", "wp", "tk", "timeout", "jp", "aux", "wx", "tmp", "xs", "std", "tc", "work", "ctl", "xc", "kw", "jac", "resp", "context", "iac", "conv", "ind", "dl", "cmp", "kl", "ann", "xp", "px", "ka", "cf", "prefix", "cmd", "iat", "crit", "tm", "inst", "cc", "cp", "cas", "td", "comm", "parent", "sys", "ht", "exec", "qt", "co", "act", "gc", "pkg", "tz", "def", "cu", "cv", "tx", "cl", "proc", "hw", "utils", "kk", "config", "nt", "req", "pg", "ca", "yes", "gt", "history", "mk", "txt", "kt", "func", "cb", "index", "check", "ac", "etc", "ct", "gz", "ctrl", "bc", "conn", "fw", "rt", "cm", "addr", "doc", "mc", "pb", "cfg"]}}
{"project": "FFmpeg", "commit_id": "8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f", "target": 1, "func": "static av_cold int vp3_decode_end(AVCodecContext *avctx)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if (avctx->is_copy && !s->current_frame.data[0])\n\n        return 0;\n\n\n\n    av_free(s->superblock_coding);\n\n    av_free(s->all_fragments);\n\n    av_free(s->coded_fragment_list[0]);\n\n    av_free(s->dct_tokens_base);\n\n    av_free(s->superblock_fragments);\n\n    av_free(s->macroblock_coding);\n\n    av_free(s->motion_val[0]);\n\n    av_free(s->motion_val[1]);\n\n    av_free(s->edge_emu_buffer);\n\n\n\n    if (avctx->is_copy) return 0;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        free_vlc(&s->dc_vlc[i]);\n\n        free_vlc(&s->ac_vlc_1[i]);\n\n        free_vlc(&s->ac_vlc_2[i]);\n\n        free_vlc(&s->ac_vlc_3[i]);\n\n        free_vlc(&s->ac_vlc_4[i]);\n\n    }\n\n\n\n    free_vlc(&s->superblock_run_length_vlc);\n\n    free_vlc(&s->fragment_run_length_vlc);\n\n    free_vlc(&s->mode_code_vlc);\n\n    free_vlc(&s->motion_vector_vlc);\n\n\n\n    /* release all frames */\n\n    if (s->golden_frame.data[0])\n\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n\n        ff_thread_release_buffer(avctx, &s->last_frame);\n\n    /* no need to release the current_frame since it will always be pointing\n\n     * to the same frame as either the golden or last frame */\n\n\n\n    return 0;\n\n}\n", "idx": 22976, "substitutes": {"avctx": ["wavctx", "navpkg", " avcmd", "cvcontext", " avcf", "navkw", "avcmp", "jamcontext", "avcf", "AVcmd", "avercf", "averkw", "avcontext", "jamctx", " avcu", "jamcm", "navctx", " avcm", "avecmp", "AVcmp", "navcp", " avpkg", "avcp", "avtx", "navcu", "jamcu", "averctx", "navcf", "navcm", "avetx", "wavcu", "avecontext", " avcmp", "avcm", "navcontext", "avkw", " avcp", "avecm", "averpkg", "avpkg", "AVcontext", "cvctx", "avecp", "wavcm", "avcmd", "cvcf", "avecmd", "wavcontext", " avkw", "avecu", "avecf", "avectx", "avcu", "AVctx", " avtx", " avcontext", "cvtx"], "s": ["ports", "is", "ims", "sts", "des", "ds", "details", "sv", "sw", "hs", "grades", "ess", "ins", "ants", "als", "less", "sb", "as", "v", "sl", "os", "changes", "ns", "bs", "cs", "results", "fs", "aws", "ers", "ats", "vs", "views", "sc", "has", "ts", "qs", "tes", "events", "comm", "sys", "aps", "ears", "y", "sd", "stats", "d", "ps", "services", "comments", "args", "c", "scl", "spec", "ls", "ies", "S", "its", "conf", "aunts", "actions", "bits", "parts", "h", "ss", "ses", "sports", "rs", "gs", "pers", "full", "ms", "js", "tests", "sq", "erences"], "i": ["is", "ic", "ski", "io", "m", "ims", " n", "I", "cli", "batch", "ti", "asi", "ex", "ui", " bi", " count", " v", "v", "chain", "\u0438", " si", "si", "me", "ai", "ix", "cgi", "ji", " m", "x", " ii", "sim", "ind", "gi", "info", " ti", "ami", "status", "g", " j", " pi", "hi", "bi", "t", "phi", "it", "iq", "ri", " x", "xi", "y", "multi", "zi", "c", "qi", "tim", "ip", "z", "li", "in", "ci", "mi", "ii", " mi", " c", "pi", "to", " ki", "ij", " li", "print", "di", "index", "iu", "init", "id", "ki", "j", "q", " k", "gu"]}}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980, "substitutes": {"vs": ["qv", "ports", "vd", "lbs", "ires", "VS", "vc", "videos", "ks", "css", "vl", "ys", "changes", "ss", "ns", "words", "Vs", "ims", "pages", "stats", "inv", "vr", "serv", "bs", "otes", "ps", "ops", "terms", "keys", "cs", "sts", "fs", "rs", "vm", "gs", "services", "var", "ds", "s", "vers", "args", "plays", "ls", "caps", "atts", "values", "ms", "sv", "lines", "hs", "views", "vals", "js", "es", "wcs", "ins", "its", "ts", "lists", "blogs", "obs", "pps", "verts", "qs", "docs", "fps", "v", "uds", "vp", "news", "irms", "vv", "vt"]}}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n", "idx": 22994, "substitutes": {"opts": ["opms", "OPTS", "OPrs", "alms", "otms", "opcs", "opTS", "optTS", "optcs", "itcs", "alters", "optms", "optts", " opters", "otters", "vets", "otcs", "ops", "itTS", "alcs", "ipt", " opcs", "alts", " opTS", " opms", " oprs", "opters", "OPt", "vers", "OPs", "veds", " ops", "oprs", "OPts", "opds", "itts", "ips", "ipts", "ipTS", "veTS", "otts", "itms", " opds", "OPds"], "opt": ["expr", "cho", "err", "ox", "fo", "pt", "dest", "none", "timeout", "decl", "xy", "tmp", "alt", "feat", "open", "term", "success", "oc", "kw", "name", "cat", "stat", "bl", "opted", "info", "rop", "lt", "esc", "cmp", "coord", "op", "pr", "num", "adj", "mem", "that", "cmd", "crit", "oss", "optim", "parent", "t", "alg", "tag", "it", "qt", "pkg", "arg", "def", "slot", "max", "bit", "var", "tv", "buf", "anon", "sp", "req", "obj", "OP", "attr", "ok", "gt", "out", "lit", "txt", "usr", "org", "off", "tip", "init", "etc", "val", "nom", "Opt", "ext", "tab", "tr", "j", "prop", "img", "rt", "iter", "block", "typ", "json", "option", "eff"], "desc": ["asc", "msg", "dep", "cont", "err", "rel", "loc", "dest", "cd", "decl", "des", "ds", "md", "cur", "col", "feat", "pos", "ser", "oc", "sup", "name", "resp", "der", "comment", "bl", "enc", "ind", "info", "dim", "esc", "cmp", "deg", "seq", "deep", "sc", "dev", "dr", "mem", "sort", "anc", "cmd", "crit", "sys", "disc", "dir", "d", "description", "def", "str", "good", "ec", "proc", "buf", "ctx", "ptr", "nt", "req", "obj", "diff", "comp", "dist", "save", "Desc", "txt", "org", "usr", "rc", "sec", "ext", "bc", "row", " Desc", "test", "tab", "img", "dict", "reg", "priv", "doc", "eq", "sub", "typ", "rib", "rec", "gov"], "value": ["message", "length", "format", "initial", "function", "word", "sv", "term", "example", "sample", "port", "ue", "v", "widget", "type", "name", "property", "VALUE", "state", "start", "comment", "output", "group", "trace", "data", "size", "status", "see", "password", "values", "true", "dev", "new", "w", "instance", "tag", "null", "hash", "image", "description", "total", "label", "Value", "max", "var", "range", "expression", "vp", "save", "valid", "hello", "index", "field", "attribute", "val", "key", "id", "test", "byte", "content", "version", "result", "unit", "native", "address", "json", "option", "text"]}}
{"project": "qemu", "commit_id": "e3da9921ebc554fad3224a9fdda9a7425ffd9ef7", "target": 0, "func": "static uint32_t nvic_readl(nvic_state *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t val;\n\n    int irq;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return (s->num_irq / 32) - 1;\n\n    case 0x10: /* SysTick Control and Status.  */\n\n        val = s->systick.control;\n\n        s->systick.control &= ~SYSTICK_COUNTFLAG;\n\n        return val;\n\n    case 0x14: /* SysTick Reload Value.  */\n\n        return s->systick.reload;\n\n    case 0x18: /* SysTick Current Value.  */\n\n        {\n\n            int64_t t;\n\n            if ((s->systick.control & SYSTICK_ENABLE) == 0)\n\n                return 0;\n\n            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n            if (t >= s->systick.tick)\n\n                return 0;\n\n            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;\n\n            /* The interrupt in triggered when the timer reaches zero.\n\n               However the counter is not reloaded until the next clock\n\n               tick.  This is a hack to return zero during the first tick.  */\n\n            if (val > s->systick.reload)\n\n                val = 0;\n\n            return val;\n\n        }\n\n    case 0x1c: /* SysTick Calibration Value.  */\n\n        return 10000;\n\n    case 0xd00: /* CPUID Base.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.cp15.c0_cpuid;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = s->gic.running_irq[0];\n\n        if (val == 1023) {\n\n            val = 0;\n\n        } else if (val >= 32) {\n\n            val -= 16;\n\n        }\n\n        /* RETTOBASE */\n\n        if (s->gic.running_irq[0] == 1023\n\n                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* VECTPENDING */\n\n        if (s->gic.current_pending[0] != 1023)\n\n            val |= (s->gic.current_pending[0] << 12);\n\n        /* ISRPENDING */\n\n        for (irq = 32; irq < s->num_irq; irq++) {\n\n            if (s->gic.irq_state[irq].pending) {\n\n                val |= (1 << 22);\n\n                break;\n\n            }\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)\n\n            val |= (1 << 26);\n\n        /* PENDSVSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)\n\n            val |= (1 << 28);\n\n        /* NMIPENDSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)\n\n            val |= (1 << 31);\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa05000;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* TODO: Implement Configuration Control bits.  */\n\n        return 0;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        /* TODO: Implement Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Configurable Fault Status unimplemented\\n\");\n\n        return 0;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n    case 0xd30: /* Debug Fault Status.  */\n\n    case 0xd34: /* Mem Manage Address.  */\n\n    case 0xd38: /* Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23016, "substitutes": {"s": ["ports", "is", "m", "ims", "ops", "sts", "ds", "sis", "plays", "details", "sv", "sw", "hs", "grades", "xs", "es", "ins", "als", "ants", "params", "less", "sb", "as", "v", "sl", "n", "a", "o", "os", "changes", "ns", "bs", "x", "i", "cs", "e", "fs", "aws", "results", "sim", "states", "vs", "ats", "views", "self", "service", "g", "ts", "gets", "cmd", "qs", "b", "events", "comm", "sys", "settings", "r", "y", "stats", "ps", "times", "services", "args", "c", "z", "spec", "ls", "utils", "ies", "S", "its", "conf", "store", "actions", "l", "series", "serv", "history", "p", "bits", "set", "parts", "h", "ss", "ses", "rs", "gs", "j", "south", "ms", "js", "http"], "offset": ["offs", "start", "oid", "o", "index", "Offset", "set", "ref", "off", "zone", "key", "tz", "style", "id", "trace", "timeout", "onet", "slot", "bit", "row", "size", "tile", "mt", "shift", "align", "location", "scroll", "error", "range", "from", "address", "pos", "len", "priority", "slice", "pointer", "pad", "l", "flag", "origin", "point", "padding", "type"], "cpu": ["n", "core", "parent", "p", "sys", "gpu", "alloc", "a", "o", "memory", "processor", "process", "os", "thread", "goal", "gc", "ct", " cp", "i", "conn", "cu", "onet", "vm", "slot", "c", " CPU", "proc", "hw", "pu", "ctx", "chip", "clock", "num", "CP", "mx", "util", "pc", "np", "pool", "CPU", "pai", "linux", " c", "local", "cp", "net"], "val": ["ee", "cho", " validate", "all", "ret", "vol", " vel", " el", " oval", "value", " value", "rel", "err", "rol", "eval", "pt", "tl", "what", "res", "alt", "fine", " v", "util", "zero", "pos", "elt", "v", "point", "ev", "sl", "type", "resp", "state", " valid", " eval", "aval", "x", "trace", "data", "fail", "Val", " interval", "pol", "base", "pal", "hz", "values", "pr", "num", "dev", "mem", "new", "cal", "iat", "crit", " lac", "td", " arg", "it", "ref", "bal", "bool", "call", "label", "def", "pret", "tx", "Value", "slot", "var", "buf", "obj", "len", "l", "el", "vt", " aval", "serv", "valid", "p", "ival", "func", "index", "al", "ul", "key", "pl", "arr", "test", "le", "prop", "VAL", "vals", "find", "hold", " ret", "lib"], "irq": ["irj", "irqu", " mirq", "nirquest", "arq", "firequ", "arque", "irwx", "drq", "ibrqi", "firequery", " mirqu", "iraquery", "drj", " irqu", "irquery", " irch", " irwx", "irqi", "nirq", "ibrque", "ironwx", "iriqi", "ironque", "ironq", "ironqi", "nirqi", "nirj", "nirquery", " irque", " irqi", "arqi", "irque", "drqi", "ibrwx", " irquery", " mirqi", "iraqi", "irequ", "irech", "fireq", "irch", " mirch", "irquest", "iraquest", "ireqi", "nirque", "iraq", "iriquest", "ibrq", "arj", "iraqu", "drque", "iriq", "firequest", "nirqu", "iriquery", " irquest", "ireq"], "t": ["td", "n", "p", "time", "tt", "txt", "it", "tg", "f", "h", "tp", "y", "ct", "d", "tz", "pt", "total", "x", "ot", "mint", "dt", "i", "tl", "c", "tr", "tv", "j", "ti", "z", "T", "ptr", "k", "rt", "tick", "at", "ta", "g", "ts", "typ", "ty", "tc", "w", "tm", "b", "l", "v", "tu", "vt"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int gxf_write_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    GXFContext *gxf = s->priv_data;\n\n    GXFStreamContext *vsc = NULL;\n\n    uint8_t tracks[255] = {0};\n\n    int i, media_info = 0;\n\n\n\n    if (!pb->seekable) {\n\n        av_log(s, AV_LOG_ERROR, \"gxf muxer does not support streamed output, patch welcome\");\n\n        return -1;\n\n    }\n\n\n\n    gxf->flags |= 0x00080000; /* material is simple clip */\n\n    for (i = 0; i < s->nb_streams; ++i) {\n\n        AVStream *st = s->streams[i];\n\n        GXFStreamContext *sc = av_mallocz(sizeof(*sc));\n\n        if (!sc)\n\n            return AVERROR(ENOMEM);\n\n        st->priv_data = sc;\n\n\n\n        sc->media_type = ff_codec_get_tag(gxf_media_types, st->codecpar->codec_id);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (st->codecpar->codec_id != AV_CODEC_ID_PCM_S16LE) {\n\n                av_log(s, AV_LOG_ERROR, \"only 16 BIT PCM LE allowed for now\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->sample_rate != 48000) {\n\n                av_log(s, AV_LOG_ERROR, \"only 48000hz sampling rate is allowed\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->channels != 1) {\n\n                av_log(s, AV_LOG_ERROR, \"only mono tracks are allowed\\n\");\n\n                return -1;\n\n            }\n\n            sc->track_type = 2;\n\n            sc->sample_rate = st->codecpar->sample_rate;\n\n            avpriv_set_pts_info(st, 64, 1, sc->sample_rate);\n\n            sc->sample_size = 16;\n\n            sc->frame_rate_index = -2;\n\n            sc->lines_index = -2;\n\n            sc->fields = -2;\n\n            gxf->audio_tracks++;\n\n            gxf->flags |= 0x04000000; /* audio is 16 bit pcm */\n\n            media_info = 'A';\n\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (i != 0) {\n\n                av_log(s, AV_LOG_ERROR, \"video stream must be the first track\\n\");\n\n                return -1;\n\n            }\n\n            /* FIXME check from time_base ? */\n\n            if (st->codecpar->height == 480 || st->codecpar->height == 512) { /* NTSC or NTSC+VBI */\n\n                sc->frame_rate_index = 5;\n\n                sc->sample_rate = 60;\n\n                gxf->flags |= 0x00000080;\n\n                gxf->time_base = (AVRational){ 1001, 60000 };\n\n            } else if (st->codecpar->height == 576 || st->codecpar->height == 608) { /* PAL or PAL+VBI */\n\n                sc->frame_rate_index = 6;\n\n                sc->media_type++;\n\n                sc->sample_rate = 50;\n\n                gxf->flags |= 0x00000040;\n\n                gxf->time_base = (AVRational){ 1, 50 };\n\n            } else {\n\n                av_log(s, AV_LOG_ERROR, \"unsupported video resolution, \"\n\n                       \"gxf muxer only accepts PAL or NTSC resolutions currently\\n\");\n\n                return -1;\n\n            }\n\n            avpriv_set_pts_info(st, 64, gxf->time_base.num, gxf->time_base.den);\n\n            if (gxf_find_lines_index(st) < 0)\n\n                sc->lines_index = -1;\n\n            sc->sample_size = st->codecpar->bit_rate;\n\n            sc->fields = 2; /* interlaced */\n\n\n\n            vsc = sc;\n\n\n\n            switch (st->codecpar->codec_id) {\n\n            case AV_CODEC_ID_MJPEG:\n\n                sc->track_type = 1;\n\n                gxf->flags |= 0x00004000;\n\n                media_info = 'J';\n\n                break;\n\n            case AV_CODEC_ID_MPEG1VIDEO:\n\n                sc->track_type = 9;\n\n                gxf->mpeg_tracks++;\n\n                media_info = 'L';\n\n                break;\n\n            case AV_CODEC_ID_MPEG2VIDEO:\n\n                sc->first_gop_closed = -1;\n\n                sc->track_type = 4;\n\n                gxf->mpeg_tracks++;\n\n                gxf->flags |= 0x00008000;\n\n                media_info = 'M';\n\n                break;\n\n            case AV_CODEC_ID_DVVIDEO:\n\n                if (st->codecpar->format == AV_PIX_FMT_YUV422P) {\n\n                    sc->media_type += 2;\n\n                    sc->track_type = 6;\n\n                    gxf->flags |= 0x00002000;\n\n                    media_info = 'E';\n\n                } else {\n\n                    sc->track_type = 5;\n\n                    gxf->flags |= 0x00001000;\n\n                    media_info = 'D';\n\n                }\n\n                break;\n\n            default:\n\n                av_log(s, AV_LOG_ERROR, \"video codec not supported\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        /* FIXME first 10 audio tracks are 0 to 9 next 22 are A to V */\n\n        sc->media_info = media_info<<8 | ('0'+tracks[media_info]++);\n\n        sc->order = s->nb_streams - st->index;\n\n    }\n\n\n\n    if (ff_audio_interleave_init(s, GXF_samples_per_frame, (AVRational){ 1, 48000 }) < 0)\n\n        return -1;\n\n\n\n    gxf_init_timecode_track(&gxf->timecode_track, vsc);\n\n    gxf->flags |= 0x200000; // time code track is non-drop frame\n\n\n\n    gxf_write_map_packet(s, 0);\n\n    gxf_write_flt_packet(s);\n\n    gxf_write_umf_packet(s);\n\n\n\n    gxf->packet_count = 3;\n\n\n\n    avio_flush(pb);\n\n    return 0;\n\n}\n", "idx": 23049, "substitutes": {"s": ["n", "comm", "p", "t", "sys", "is", "a", "os", "m", "ss", "ns", "us", "ses", "stats", "src", "bs", "ps", "cs", "sts", "times", "aws", "gs", "fs", "rs", "c", "ds", "ast", "scl", "south", "ctx", "ls", "ms", "sv", "ssl", "sw", "ats", "hs", "S", "js", "g", "es", "xs", "sq", "ts", "sp", "its", "aus", "sg", "conf", "obj", "qs", "sb", "b", "as", "v", "sql"], "pb": ["p", "t", "rb", "vp", "tg", "cb", "tp", "ob", "pkg", "bs", "pt", "pp", "lp", "pl", "mp", "uf", "bj", "ib", "cv", "tx", "pa", "PB", "jp", "proc", "xb", "ab", "fp", "buf", "ctx", "bm", "bh", "ub", "cm", "ts", "sp", "pc", "np", "pg", "tc", "typ", "soc", "buff", "sb", "b", "gp", "bp", "phys", "v", "cp", "vt"], "gxf": ["Gxc", "cfx", "gxc", "gxb", "rgxc", "gafe", "rgfx", " gxc", "gaxf", "Gfx", "Gcf", " gfe", "Gxb", "mxf", " gcf", "cfc", "ggxc", "gfe", "gafx", "gcf", "ggxf", "gf", "mcf", "Gxf", "sgxf", "sgf", "gaf", "gfx", "gfc", "jfx", "sgfe", "jcf", "cxf", "ggcf", "sgfx", "jfc", " gfx", " gf", "mxc", "jxf", " gxb", "rgcf", " gfc", "rgxf", "ggxb", "ccf", "mfx"], "vsc": ["VSC", "avsc", "vbc", "vSC", "avbc", "avSC", "jsc", "jSC", "Vmc", "Vsc", "Vbc", "vmc", "jbc", "jmc", "avmc"], "tracks": ["flags", "sys", "track", "icks", "bands", "tags", "amps", "length", "ints", "src", "rows", "stream", "bytes", "frames", "files", "items", "sets", "seek", "types", "js", "asks", "amples", "obs", "objects", "metadata", " track", "acks", "fields"], "i": ["n", "bi", "name", "ij", "t", "p", "phi", "ic", "it", "ri", "si", "me", "di", "index", "iu", "ai", "o", "xi", "m", "ix", "y", "ims", " I", "multi", "im", "zi", "ei", "ie", "x", "id", " ii", "sim", "ind", "gi", " ti", "I", "c", "mount", "qi", "ki", "ti", "j", "ini", "batch", "ip", "li", "k", "ui", " bi", "oi", "in", "ci", " j", "g", "mi", "u", "ii", " mi", "pi", "b", "v"], "st": ["td", "ste", "t", "p", "ost", "tt", "start", "must", "usr", "it", "sa", "set", "stat", "ss", "sta", "th", "ct", "src", "pt", "stream", "sts", "St", "str", "cl", "step", "tr", "ast", "se", "status", "z", "nd", "mt", "sm", "sn", "ctx", "ust", "ft", "fr", "rt", "sv", "sw", "sh", "est", "storage", "stable", "rest", "stack", "sp", "nt", "std", "ts", "ist", "irst", "obj", "store", "inst", "sb", "ST", "so", "ut", "net", "sl", "sty"], "sc": ["asc", "sch", " Sc", "scope", "isc", "rc", "usc", "Sc", "func", "sac", "cont", "sec", "desc", "dc", "go", "scan", "disc", "cgi", "ac", "gc", "enc", "capt", "cs", "bc", "cu", "tch", "cv", "uc", "sic", "c", "cl", "ec", "esc", "cmp", "mac", "scl", "psc", "osc", "ctx", "arc", "sv", "sw", "lc", "ch", "ci", "sp", "anc", "mc", "pc", " subsc", "tc", "cam", "cr", "nc", "cc", "sche", "scrib", "fc", "ctl", "SC"], "audio_tracks": ["audio____runs", "audio____fields", "music_fields", "music___tracks", "music_tracks", "audio_reads", "audio_runs", "music___fields", "audio___reads", "audio___tracks", "music_runs", "audio___fields", "music_reads", "audio___runs", "music___runs", "audio____reads", "audio_fields", "music___reads", "audio____tracks"], "media_type": ["media_time", "meta_type", "meta_source", "media_info", "meta_time", "mediaetytime", "media_source", "mediaetytype", "mediaetysource", "meta_info", "mediaetyinfo"]}}
{"project": "qemu", "commit_id": "2f464b5a32b414adb545acc6d94b5c35c7d258ba", "target": 0, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 23050, "substitutes": {"qxl": ["qexli", "questionwxl", "qxil", "iqxla", "qrxel", "questionwxlb", "qwxlb", "contextxL", "qwla", "quuxlt", "qinxla", "qxela", "qxmlls", "iqrxel", "qxmlfl", "qttli", "queryxxsl", "qpayll", "requxlist", "qlexli", "eqwxla", "corexill", " qlexli", "qwli", "qxyli", "eqxxsl", "qxxli", "qworkfl", "qxisl", "qxlp", "qxmll", "contextlexlb", "qxxsl", "queryuxl", "qoxln", "corexil", "qworkll", "qexhl", "flowxxla", "eqxla", "qq_", "qfxla", "flowxeli", "qplexls", "questpayll", "quxml", "qxmllit", "queryxsl", "eqxfl", "qplexl", "quxmlml", "qxcll", "quxmlls", "flowxel", "qxmlL", "queryxhl", "qxlb", "qmxhl", "qpxlt", "qtxl", "qlexL", "qoxlp", "qxg", "qxyls", "qexL", "sqmxml", "qxdel", "queryfxl", "qxali", "qzzl", "questionxxl", "qctml", "qxylist", "questxl", "requplexl", "qqrxls", "qxcla", "flowxl", "qfxfl", "qrxll", "requxL", "qxyL", "quxmlsl", "requxls", "qtryla", "requplexls", "eqxxlt", "qxclp", "eqxg", "qctla", "quxlt", "qrxL", "qtrylay", "qtryl", "qexfl", "qfxli", "eqwxg", "qttl", "qlexll", "qzzlt", "qmxlt", "q_", "queryfxli", "qxili", "qxill", "qmxml", "quxln", "eqxxfl", "qxcl", "qxalc", "qxxla", "qryl", "quxsl", "qwxli", "corexilb", "qxilan", "qtxls", "qlexlb", "qlexls", "qxmllan", "qxpfl", "qaxl", "questpayl", "qrxli", "sq_", "qrxl", "questpayls", "eqwxli", "questionxxla", "qwxla", "qxxlay", "qxhl", "qaxli", "qxpl", "qttel", "quxL", "qqrxlt", "questxls", "qeylb", "qxyl", "qxiel", "queryxel", "qtxml", "qxxll", "qoxl", "qwxurl", "queryxls", "qzzll", "questionxxlc", "flowxela", "qeyurl", "qwxg", "qwxhl", "qnewsln", "eqfxli", "qxli", "qxxlb", "qxxl", "queryxplan", "qxclt", "questxel", "requplexlist", "queryxln", "questionxl", "corexl", "flowxxl", "iqxel", "qctl", "iqxli", "qxel", "qdxla", "qplexL", "questionxurl", " qrxla", " qlexfl", "quxli", "qtryli", "iqxl", "quxmll", "qxxlt", "eqfxl", "qworklb", "qtxlt", "qxplit", "iqrxl", "quxfl", "qexls", "qwxel", "corexlb", "qdxlay", " qxel", "queryxlan", "qxcli", "qrxlb", "quxmllit", "sqxl", "contextxl", "queryxpel", "qxpsl", "contextxli", " qxfl", "queryxxel", "qpxfl", "queryxyl", "quxlit", "queryuxhl", "qxilit", "qxyel", "corexcln", "qxlay", "quxmlel", "corexll", "corexln", "qplexlist", "qxls", " qxla", "qinxlp", "qxlist", "qxml", "qrylc", "qxmlel", "questionxlb", " qrxel", "qnewsli", "qxeel", "qrxlt", "qxlan", "corexfl", "qlexfl", "qpayel", "queryxl", "qlexl", "queryuxls", "qmxl", "qtxla", "qoxla", "flowxli", "qxplan", " qrxhl", "flowxxlay", "qxelt", "sqxml", "qnewsls", "eqxel", "quxel", "qxpml", "qfxhl", "quxl", "queryxyhl", "queryuxel", "qxxel", "qxifl", "eqfxla", "qxxlc", "qxilb", "queryuxli", "qxlc", "queryuxln", "qttlt", "qfxl", "qxfl", " qxli", "corexclp", "corexlp", "qdxli", "qximl", "queryxli", "qfxlt", "queryxpfl", "queryfxhl", " qlexel", "qxeli", "qxag", "qxyla", "qdxl", "qpayls", "questionxli", "qrxla", "qmxel", "qxll", " q_", "qxlit", "qaxlb", "qrxhl", "queryxyfl", "flowxla", "qinxl", "queryxxli", "corexcl", "quxls", "queryxpl", " qrxl", "qxcln", "qdxel", "qqxl", "contextlexli", "qxln", "qxurl", " qrxL", " qrxli", "qnewsl", "qxsl", "qaxL", "qxdla", "qxehl", "eqwxl", "corexifl", "quxhl", "qexel", "qinxln", "qeyli", "qxmlsl", "eqxxl", " qxL", "qqxlt", "qxxfl", " qxhl", "quxll", "flowxlay", "qpayl", "qxiurl", "questionwxli", "eqxl", "qexl", "eqxlt", "qxala", "qryli", "questionxla", "qxpel", "qlexel", "sqxla", "contextlexl", "queryuxlt", "flowxlt", "sqmxl", "qfxls", "queryxxl", "flowxxli", "qxyhl", "sqmxla", "corexcla", "qexln", "qpxl", "qdxsl", "qeyl", "qxlt", "qxdli", "iqrxli", "questionxlc", "qpxsl", "qxal", "qxmlml", "requxl", "qwl", "questxll", "qqrxl", "eqxli", "corexla", "flowxelt", "qrxlist", "qworkl", "quuxli", "contextlexL", "requplexL", "questionxxli", "queryxyls", "qqxls", "quuxll", "questpayel", "quxmlL", "qxL", "questionwxurl", "qfxel", "qwg", "queryfxel", "eqxsl", "qryla", "quuxl", "queryxlt", "qrxls", " qlexl", "qzzli", "qwxl", "qxdl", "qxla", "eqfxel", "contextxlb", "iqrxla", "qxyfl", "queryxfl", "qttla", "qmxla"], "vga": [" vega", "qgas", "vegas", "veca", "wireega", "veanta", "gga", " vgd", "ggas", "invgp", "vmgo", "versioncca", " vba", "gna", "avga", "qna", " vgar", "wirema", " vcca", "vba", "Vga", "venda", "qcca", " vca", "vema", "qja", "versiongas", "Vca", "gja", "vmgp", "vja", "veenda", " vma", "invba", "wirega", "qega", "versiongd", "versionga", "devgar", "qgd", "devgas", "vrga", "vgd", "Vma", "vgp", "Vgas", "devanta", "invga", "vgas", "invgo", "avna", "wirecca", "vgo", "vrca", "qma", "vega", "avgas", "vmga", "vgar", "devga", "qga", " vgp", "vma", "vcca", "avja", " venda", "vca", "vanta", " vgas", " vgo", "vrgas", "vna", " vanta", "vegar", "vrenda", "vmba"], "i": ["is", "m", "ims", " I", "im", " index", "span", "I", "ti", "batch", "ui", " p", "v", "chain", "n", "start", " si", "si", "me", "o", "ai", "ix", "ji", " m", "x", " ii", "e", "sim", "ind", "info", " ti", "gi", "ami", "status", "fi", " ni", "oi", " j", " pi", "u", "hi", "instance", "bi", "it", "ri", "xi", "f", " l", "y", "multi", "zi", "ei", "c", "qi", "ini", "ip", "li", "in", "ci", "mi", "ii", " mi", "pi", "l", " ki", "yi", "ij", "er", "p", " li", "di", "index", "iu", "record", "us", "init", "item", "key", "id", " iter", "ki", "j", " wi", " multi"]}}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052, "substitutes": {"system_info": ["system_id", "sys_fo", "system_details", "System_info", "System_data", "sys_data", "system2data", " system_data", " system_INFO", "system2info", "system_information", "sys_info", "sys_id", "system2details", "system_fo", "System_fo", "system_data", "system_INFO", " system_details", "system2INFO", "System_information"], "freep": ["freec", "mediek", "faxp", "mediec", "mediep", " freek", "medipe", "treep", "freek", "sweek", " freap", "feeps", "feeap", " freEP", " freeps", "faep", "treq", "faek", "freeps", "feEP", " freyp", "faeps", "frepe", "Frexp", "fayp", "trexp", "swepe", "Freq", "feep", "faq", "sweec", "freEP", "feec", "sweep", "Freeps", "feyp", "freq", "feap", "freap", "freyp", "Freep", "feek", "feeeps", "fepe", "FreEP", "feepe", "feeep", "treeps", "Freek", " frepe", "Freap"], "i": ["bi", "t", "phi", "\u0438", "is", "ic", "it", "iq", "ri", "si", "me", "di", "index", "iu", "ai", "xi", "m", "ix", "y", " I", "us", "init", "multi", "ji", "zi", "ei", "x", "id", " ii", "sim", "ind", "gi", "info", " ti", "I", "c", " di", "qi", "ti", "j", "ini", "cli", "batch", "ip", "status", "li", "ui", "series", "oi", "ci", " j", "mi", "ii", "ma", "pi", "hi", "uri", "chain"], "cnt": [" ccount", "cct", "ncount", "ncnt", "Csec", "csec", " csec", "Cnc", "Cnt", "ctNT", "ncsec", "count", "ctnc", " cct", "ctnt", "nct", "Ccount", "nccount", "CNT", "nnt", "ccount", " count", "Count", " cNT", "nNT", " cnc", "cnc", "ctount", "Cct", "cNT", "ncNT"], "startaddr": ["Startobj", " startobj", "startadr", "endptr", "artaddress", "firstaddress", "artaddr", "endadr", "artoa", "Startptr", "artptr", "firstoa", "artpkg", "startptr", "starthash", "beginref", "endaddress", "beginptr", " startaddress", "startadd", "startref", "startoa", "Startaddr", "beginaddr", "startobj", "firstpkg", "firstptr", " startpkg", "firstref", "firsthash", "firstadr", "startpkg", "startaddress", "Startaddress", "Startadd", " startadr", " startref", "endadd", "firstaddr", " startadd", "beginaddress", "beginhash", "endobj", " startptr", "artadr", " startoa", " starthash", "beginadr"], "endaddr": [" endaddress", " endobj", "startadr", " endadd", "endptr", "vertaddress", "starthop", "startoffset", "findir", "enddr", "endadr", " endhop", "vertptr", "startdir", "endedaddress", "startptr", "endaddress", "sendaddr", "stopaddress", "appendadr", "startadd", "verthop", "startattr", " endoffset", "sendadd", "startobj", "endoffset", "closeptr", "endedaddr", "endedobj", "closeaddr", "maxaddr", "appendattr", " endptr", "stopdr", "closeaddress", "stopaddr", "endhop", "sendaddress", "startdr", " enddr", "startaddress", "closeattr", "stopptr", "finptr", "maxattr", "sendptr", "maxadr", "endadd", " enddir", "appendaddr", "endobj", "stopoffset", "vertaddr", " endattr", "finaddr", "finaddress", "endattr", "enddir"], "f": ["t", "p", "o", "r", "fal", "h", "m", "fo", "d", "fe", "x", "fm", "e", "fs", "fw", "c", "fb", "elf", "fp", "fr", "z", "q", "fi", "fa", "rf", "cf", "xf", "g", "fd", "F", "lf", "b", "l", "fc", "v", "file", "tf", "w"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 23066, "substitutes": {"host_port": ["host_pid", " host_PORT", " host_ports", "host_file", " host_file", " host_pid", "host_PORT", "host_ports"], "errp": ["rrpo", "errps", "errm", "rrpun", "errr", "ererpo", "orderpun", "orderpo", "orderp", "Erps", "rrping", "ererp", "Erm", "ererpun", "ererping", "rrr", "Erp", " errps", "errping", " errr", "errpo", "rrm", "rrps", "errpun", "rrp", " errm", "orderping", "Err"], "iaddr": ["siurl", "xicoord", "ipart", "xiurl", "biaddr", "iiaddr", "ipadr", "dipart", "sadd", "iadr", "biadr", "iattr", "ivar", "incoord", "biptr", "iadd", "sihost", "ihost", "inaddr", "sadr", "ipptr", "biadd", "ipaddr", " ipart", " iadr", "iipart", "diaddr", "Iattr", " iattr", "xiaddr", "inurl", "Iadd", "siadd", "iarp", "iiarp", "Iaddr", "siattr", "sicoord", "siaddr", "iurl", "diarp", "icoord", "ipadd", "Ihost", " iarp", "diadr", "sivar", "xivar", " ihost", "iptr", " iadd", "iiadr", "invar", "sptr"], "saddr": ["jsptr", "Sadr", "Saddr", "Sdist", "sadd", "ssadd", "nsadd", "psaddress", "osadd", " sdist", "psaddr", " sptr", "jsaddress", "tsadd", "sadr", "ssarp", "Saddress", "osaddr", "nsadr", " saddress", "nsaddress", "ssaddr", "tsaddr", "jsadd", "ssadr", "psadr", "sdist", " sadr", "psadd", "sarp", "tsadr", "Sptr", " sadd", "Sarp", "Sadd", "tsarp", "saddress", "osadr", "nsaddr", "osdist", "jsaddr", "sptr"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n", "idx": 23074, "substitutes": {"bs": ["bi", "ils", "lbs", "bits", "ubs", "ns", "bps", "ss", "BS", "ims", "aos", "bl", "iss", "bc", "fs", "gs", "ds", "bis", "bytes", "bh", "ats", "bing", "hs", "bes", "js", "its", "ts", "als", "aus", "obs", "acs", "sb", "bos", "cks", "bp", "b"], "s": ["n", "comm", "p", "t", "sys", "is", "a", "os", "h", "ns", "ss", "y", "ses", "ps", "i", "cs", "aws", "rs", "gs", "c", "ds", "sis", "j", "ls", "sv", "ats", "hs", "self", "S", "ess", "js", "its", "sq", "ts", "als", "sp", "ares", "qs", "sb", "b", "v", "sl"]}}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "substitutes": {"d": ["n", "ed", "p", "t", "dm", "r", "D", "o", "di", "dd", "f", "dc", "m", "h", "y", "sd", "dn", "x", "e", "c", "ds", "s", "md", "j", "z", "dat", "dr", "ad", "g", "fd", "dos", "b", "l", "v", "da", "w"], "drc": ["zRC", "mirc", "dirent", " drec", "bdrog", "adrb", " drent", "edrc", "adRC", "modsrc", "daRC", "dnrent", "daroc", "dRC", "mroc", "bdrs", "bdRC", "bdrc", "edrog", "modrc", "dready", " dhr", "sdRC", " droc", "mrt", "edrec", " dsrc", "zrc", " drect", "drec", "bdror", "dsrc", " durch", "lrc", "drs", "drog", "drt", "darc", "Drs", "aderoc", "edrs", "Drec", "zrec", "lirc", " dirc", "diRC", "bdroc", "dror", "bdrec", "darec", "edroc", "modRC", "Dirc", " dready", "sdrc", "adroc", "sdready", "dirc", "adeRC", " drt", "durch", "aderc", "edRC", " dror", "drh", "dnrc", "froc", "lrec", "adirc", "zirc", "lRC", "frc", "daready", " drb", "adrec", " drog", "bdsrc", "adrc", "dnurch", "dasrc", "drent", "mdsrc", "mdrs", "darh", " drs", "modroc", "diurch", " drh", "drb", "firc", "bdrect", "dahr", "dnRC", "Drect", "DRC", "mdror", "Drc", "frt", "droc", " dRC", "dhr", "Drh", "aderb", "mdrc", "mrc", "drect", "sdhr"], "drck": [" drkk", "derkw", " drk", "derkk", "drke", "derck", " drleck", "Drcker", " drke", "Drk", "derleck", "mrleck", "drkk", "hrck", "drleck", " drcker", "mrcker", "mrcheck", "drcker", "drkw", "hrkw", " drcheck", "drk", "mrck", "hrcker", "Drck", "dercheck", "derke", "Drkk", "derk", "drcheck", " drkw", "dercker", "hrke"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23088, "substitutes": {"current_env": [" current_en", "current__conn", "currently_conn", "current2env", "current_shell", "current__shell", "current__dev", "current2en", " current_eng", "currently_env", "current_environment", "current_cv", "current2conn", "current__eng", "current__env", "reported_environment", "reported_shell", "current_eng", " current_cv", "current__org", "current_en", "current_conn", "currently_org", "currently_en", "current__en", "reported_dev", "current__environment", "reported_env", "current_org", "current2org", "current_dev"], "addr": ["expr", "start", "rc", "a", "arp", "ack", "ref", "off", "ix", "add", "offset", "rel", "act", "ar", "src", "pkg", "url", "loc", "inter", "id", "arg", "arr", "rs", "host", "handle", "arch", "asm", "ip", "hw", "mac", "ptr", "align", "rt", "map", "adr", "at", "Address", "ad", "dr", "path", "address", "cmd", "ace", "pos", "pad", "pat", "art", "attr", "alias"], "len": ["fn", "fun", "en", " length", "sys", "lvl", "Len", "length", "offset", "rel", "val", "loc", "lp", "id", "label", "lan", "eth", "lon", "args", "size", "bytes", "vec", "lang", "ann", "lim", "spec", "ptr", "link", "seq", "mem", "fin", "ln", "pos", "lis", "nl", "ll", "lf", "elt", "l", "el", "lib"], "type": ["name", "ype", "t", "state", "p", "time", "Type", "tag", "ver", "role", "kind", "index", "ping", "tp", "length", "TYPE", "count", "key", "inter", "style", "id", "weight", "test", "size", "family", " typ", "like", "mt", "link", "rt", "what", "pe", "part", "rule", "types", " ty", "unit", "template", "error", "range", "action", "typ", "ty", "address", "year", "port", "class", " Type"], "bp": ["wordpress", "blog", "mk", "p", "pse", "lbs", "vp", "btn", "eb", "vc", "bf", "arb", "cb", "bsp", "arp", "BP", "tp", "bps", "circle", "pkg", "bs", "mb", "pp", "lp", "ps", "lb", "wp", "bc", "gs", "bn", "bd", "php", "pa", "PB", "jp", "batch", "snap", "ap", "asm", "xp", "fp", "ptr", "bm", "br", "bh", "bg", "kr", "dp", "adj", "hp", "phy", "kb", "sp", "esp", "pb", "pc", "bt", "np", "pg", "sb", "b", "gp", "bj", "cp", "bb", "pas"], "env": ["ee", "er", "en", "state", "engine", "end", "gn", "door", "context", "usr", "eh", "org", "et", "alias", "ef", "window", "qt", "act", "ner", "vr", "enc", "gear", "e", "conn", "eg", "ext", "cv", "tx", "peer", "node", "ec", "worker", "ng", "buf", "ctx", "ptr", "uv", "here", "ve", "environment", "server", "kh", "pe", "vs", "open", "edge", "dev", "iter", "priv", "doc", "stage", "eq", "np", "kg", "obj", "ep", "next", "ew", "ah", "nv", "nc", "v", "eng", "el", "vp", "timer", "ev", "eve", "vt"], "err": ["msg", "orm", "eh", "late", "fee", "count", "none", "rar", "peer", "cli", "eor", "fr", "br", "res", "Error", "term", "cr", "elt", "ry", "resp", "eas", "any", "der", "mr", "ger", "order", "rr", "i", "e", "trace", "pr", "ler", "dr", "drm", "inner", "erd", "norm", "plain", "virt", "timer", "rn", "it", "ere", "die", "r", "score", "irm", "act", "ner", "ter", "str", "buf", "raw", "ptr", "cer", "Er", "kr", "try", "req", "conf", "obj", "nil", "errors", "attr", "er", "lr", "rb", "out", "txt", "usr", "cb", "off", "aaa", "notice", "gz", "arr", "conn", "or", "test", "warn", "result", "here", "erer", "priv", "iter", "error", "later", "cfg"], "use_count": ["use_counter", "user_count", "usage_counter", "usage_count", "user_Count", "use__counter", "user_counter", "use__Count", "use__count", "use__max", "user_max", "use_Count", "usage_table", "use_max", "use_table"]}}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n", "idx": 23104, "substitutes": {"env": ["walker", "en", "er", "engine", "end", "rb", "context", "eh", "app", "set", "di", "cb", "desc", "te", "equ", "ef", "window", "err", "exec", "e", "bc", "conn", "cv", "vm", "ec", "esc", "hw", "worker", "EN", "buf", "ctx", "ov", "manager", "environment", "server", "sv", "sw", "vs", "hl", "db", "console", "em", "sc", "dev", "cf", "En", "ev", "erd", " environment", "obj", "ah", "ew", "nv", "v", "gov", "el", "shell", " en", "vv", "forge"], "t0": ["v50", "p0", "tZero", "str0", "st0", "dtZero", "p1", "str00", "tt25", "t25", "p25", "dt0", "dt25", "t50", "str50", "str000", "ttZero", "t00", "tt1", "dt1", "t000", "v00", "st00", "st000", "pZero", "v000", "v0", "tt0", "st50"], "t1": ["T001", "wone", "T1", " t2", "w2", "Tone", "tt001", "tt2", "tt1", "t001", "w0", "T2", "t2", "w1", "T0", " tone", "tt0", " t001", "tone"], "relation": ["duration", "quality", "definition", " cor", "response", "reference", "normal", "role", "r", "err", "behavior", "rel", "release", "order", "condition", " similarity", "ner", "nor", "degree", " rate", " probability", " condition", "rr", "relative", " proportion", "trace", " distance", "equality", "balance", "test", " correl", "reverse", " factor", "associated", "library", "portion", "relations", "NR", " percentage", " cross", "result", "status", "future", "family", "related", " rating", " fraction", " comparison", " record", " association", " relate", "ler", "position", " related", "sequence", "direction", " role", "norm", "address", " accuracy", "lation", "notation", "director", " ratio", " correlation", " motion", " relationship", " performance", "flag", "bor", "origin", "flow", "type"]}}
{"project": "qemu", "commit_id": "f0536bb848ad6eb2709a7dc675f261bd160c751b", "target": 0, "func": "static int img_info(int argc, char **argv)\n\n{\n\n    int c;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n", "idx": 23105, "substitutes": {"argc": ["argsv", "argce", "argct", "arrv", "Argc", "Argcs", "argcs", "argl", "argscs", "argsl", "argsce", "argumentl", "arrc", "argumentce", "Argce", " argcs", "argumentc", " argl", "arrl", " argct", "arrcs", " argce", "argsc", "argsct", "Argct", "argumentv"], "argv": ["argsv", "usevs", "Argx", " argvs", " argm", " argV", " argp", "argf", "Argc", "argsvs", "usec", "ArgV", "cmdf", "argp", "argx", "argsp", "cmdc", "argvs", "argsf", "usev", "argsx", "usep", "argV", "argsV", " argx", "argsm", "argm", "cmdm", " argf", "cmdv", "argsc", "Argv"], "c": ["n", "t", "p", "com", "rc", "cb", "ce", "f", "dc", "m", "h", "abc", "ac", "gc", "ct", " tc", "count", "d", "unc", "con", "cs", "cu", "bc", "cd", "e", "uc", "code", "category", "ec", "cmp", "cur", "z", " ec", "cod", "C", "k", "arc", "\u00e7", "lc", "cm", "sc", " count", "cf", "ci", "config", "mc", "pc", "tc", "conf", "cache", "nc", "cc", "l", "fc", "cp", "xc"], "filename": ["fn", "name", "username", "println", "csv", "binary", "txt", "fle", "bf", "source", "jpg", "kan", "f", "lua", "title", "format", "original", "src", "Filename", "url", "ames", "unc", "ame", "fs", "kl", "fp", "family", "buf", "fil", "png", "nm", "directory", "tmp", "buffer", "location", "ln", "subject", "path", "ename", "prefix", "FN", "json", "input", "til", "file", "origin", "nil"], "fmt": ["formformat", " ftm", "confmt", "htm", "cmt", "fMT", "lformat", "tprintf", "formprintf", " fformat", "Ftm", "formfm", "lmt", "ltm", "Fmt", "Flt", "cformat", "hformat", " flt", "ffm", "hmt", "confformat", "formmt", "ftm", "tmt", "ctm", "cMT", "tfm", " ffm", "Fprintf", "Fformat", "fformat", "flt", "tformat", "confMT", "FMT", " fMT", "hlt", "lprintf", "conffm", "tMT"], "output": ["username", "println", "message", "source", "write", "io", "format", "none", "target", "generation", "directory", "open", "region", " Output", "path", "client", "success", "file", "type", "name", "response", "binary", "ilo", "o", "echo", "data", "export", "connection", "status", "four", "render", "apache", "only", "prefix", "remote", "network", "update", "null", "image", "display", "style", "outer", "enabled", "module", "generated", "position", "buffer", "Output", "ou", "config", "ut", "icon", "csv", "out", "print", "STDOUT", "offset", "tail", "key", "secure", "fp", "result", "console", "OU", "unit", "ignore", "error", "json", "options", "input", "hidden", "option", "origin", "text"], "bs": ["bi", "ubis", "sys", "lbs", "bits", "eb", "bf", "cb", "os", "ubs", "bed", "ss", "bps", "BS", "ns", "bl", "aos", "gb", "stats", "ps", "cs", "bc", "fs", "gs", "rs", "bd", "bn", "ds", "bis", "bo", "ls", "bm", "details", "bh", "bg", "vs", "js", "its", "ts", "obs", "pb", "bt", "obj", "sb", "bos", "b", "bp", "bas", "cks", "bb"], "info": ["history", "Info", "is", "out", "sys", "txt", "it", " about", "o", "si", "index", "os", "stat", "io", "INFO", "f", "off", " details", "list", "summary", "fo", "init", "stats", "by", "image", "note", "id", "def", "i", "ext", "user", "fw", "data", "meta", " INFO", "ami", "ki", "ti", "no", " inf", "status", "details", "now", "ui", "fi", "inf", "entry", " data", "dev", "iter", "try", "ci", "doc", "error", " Info", "http", "mem", "ist", "mi", "information", "conf", "json", "obj", " fi", "iso", "ii", " mi", "cache", "pi", "about", "type"], "long_options": [" long_flags", "long_items", "long_flags", "longlyitems", "long___flags", " long_values", "long_values", "longlyoptions", " long2items", "long_option", "long2flags", "long2items", "long2options", " long2options", " long2flags", " long_option", " long_items", "long_objects", "longlyflags", "long___option", "long2values", "longlyvalues", "long___objects", "long___options", " long2values", " long_objects"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23108, "substitutes": {"resolver": ["provolve", "persolution", "solution", "wumer", "serolve", "reserver", "resumer", "provolver", "persolve", "persolver", "wolver", "resolution", "wolve", "provolution", "proverver", " resolution", "solver", "rolver", "solve", " resolve", "server", "solder", "rolve", "rumer", "serolution", "serolver", "perserver", " resolder", "resolve", "serolder", "rolution", "wolution", " resumer", "resolder"], "addr": ["expr", "aj", "name", "gt", "old", "a", "r", "arp", "ack", "ref", "ix", "ns", "err", "add", "ac", "hash", "act", "inv", "pkg", "ash", "arr", "rr", "ext", "conn", "rs", "tx", "host", "oa", "ip", "ast", "older", "ord", "ress", "mt", "ptr", "align", "ag", "res", "alt", "map", "Address", "adr", "dr", "ad", "at", "has", "adv", "prefix", "block", "address", "cmd", "ace", "pos", "obj", "elt", "pad", "news", "lat", "attr", "alias"], "naddrs": ["nlengthras", "npadls", "nlengthls", "nfindrs", "nattrs", "naddps", "npayrs", " nadls", "npadps", " naddners", "npayras", "naddras", " naddris", " naddRS", " nattls", "naddren", "nattps", "nlengthrs", "nappners", "nadls", "naddris", " naddls", "nbuildrs", "nadrs", "naddRS", "npadrs", " nadren", "nappls", "naddls", "nappps", "nbuildRS", "npadners", "napprs", "nfindRS", " nadris", "nfindls", "npayren", "nfindris", "nattls", " nadras", "npayls", "nbuildris", "nattners", " nadrs", " nattners", "naddners", "nlengthren", " nattrs", "nadris", "nadren", " naddren", "nadras", " naddps", "nbuildls", " nattps", "nadRS", " naddras", " nadRS"], "addrs": [" paddributes", "addths", "attres", " adners", "attrs", " addresses", " paddths", " paddners", "condr", " adths", "addres", " adrs", "adrd", "attresses", "condrs", "addners", "addributes", " addrd", " adr", " addners", "attrd", " paddrs", "adrs", " addths", "adresses", "addrd", "adres", "condributes", " addres", " paddr", " addributes", "addresses"], "errp": ["errps", "nerpa", "errpa", "rrpc", "rerper", "rrper", " errper", " errpc", "errorper", "errorps", "rerjp", "lerps", "errorjp", "errbp", " errpa", "lerp", "errjp", "errpc", "lerbp", " errbp", "lerpa", "rerpc", " errps", "nerps", "nerbp", "rrps", "errorp", "rrp", "rrjp", "errorpc", "nerp", "rerp", "errper"]}}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n    Error *err = NULL;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 23116, "substitutes": {"bs": ["bi", "ubis", "blog", "boxes", "sys", "lbs", "bits", "os", "ubs", "ns", "BS", "outs", "aos", "bl", "bps", "ps", "lb", "cs", "bc", "sts", "fs", "gs", "rs", "ds", "bis", "locks", "ls", "bm", "bh", "hz", "ms", "vs", "bing", "hs", "asis", "bes", "js", "its", "ts", "obs", "pb", "bt", "aus", "fps", "sb", "bos", "b", "bp", "bas", "bb"], "sector_num": ["sector_cal", "sector__num", " sector_index", " sector_number", "sector__cal", "sector_id", "section_num", " sector2index", "sector_number", "sector_index", "sector__number", " sector_mon", "sector_sum", " sector_cal", "section_number", "section_sum", "sector2num", " sector2num", " sector2cal", "sector_mon", "sector2cal", "section_id", " sector_len", "sector2number", "sector_len", "sector_con", " sector2number", "section_con", "sector2index", "sector__index"], "nb_sectors": ["nb_seors", "nb_comllers", "nb_spellers", "nb_comors", "nb_specs", "nb_svers", "nb_vellers", "nb_seitors", "nb_veitors", "nb_vectors", "nb_seters", "nb_veors", "nb_pellers", "nb_speors", "nb_seectors", "nb_sctors", "nb_vevers", "nb_peors", "nb_comctors", "nb_speitors", "nb_peonents", "nb_sellers", "nb_sors", "nb_speonents", "nb_seevers", "nb_comonents", "nb_spevers", "nb_seonents", "nb_sllers", "nb_veters", "nb_peters", "nb_pectors", "nb_vecs", "nb_secs", "nb_pevers", "nb_seeors", "nb_seeters", "nb_spectors", "nb_severs"], "qiov": [" qveh", "qiv", "qtovi", "Qveh", "questionconv", "quovi", "sqiv", "Qiv", "sqveh", "sqiov", "qnov", "Qiov", "dqveh", "quiov", "qconv", "dqconv", "qtiev", "quiv", "sqiev", " qiev", "questconv", "quveh", "dqiev", "questiour", " qnov", "questionnov", "questioniour", " qiour", "qiour", "quiev", "questioniov", "questiov", "qiev", "quconv", "dqiov", "qtconv", "qovi", " qconv", "Qiev", "qveh", "dqovi", "questnov", "qtiov"], "s": ["t", "p", "is", "sys", "settings", "os", "changes", "ns", "ss", "ims", "y", "ses", "stats", "ps", "eps", "cs", "sts", "i", "space", "rs", "gs", "fs", "c", "ds", "j", "abilities", "sn", "ls", "ms", "sv", "sw", "sam", "vs", "ats", "hs", "self", "S", "js", "service", "es", "its", "ins", "ts", "sp", "als", "sq", "conf", "less", "store", "sb", "ains", "b", "actions"], "index_in_cluster": ["index_in_clust", "index_in_scuster", "index_in_gluster", "index_in_chust", "index_in_chuster", "index_in_Cluster", "index_in_glust", "index_in_closer", "index_in_clusters", "index_in_scusters", "index_in_glusters", "index_in_Clusters", "index_in_gloser", "index_in_chusters", "index_in_ploser", "index_in_plusters", "index_in_Closer", "index_in_Clust", "index_in_scust", "index_in_pluster", "index_in_plust", "index_in_scoser"], "n": ["en", "t", "p", "rn", "number", "r", "non", "cn", "o", "nr", "m", "h", "ns", "y", "dn", "nor", "d", "na", "note", "i", "e", "nn", "c", "ni", "size", "N", "j", "nb", "nu", "nd", "ng", "sn", "nm", "num", "un", " N", "g", "ln", "nt", "norm", "np", "nl", "len", "ll", "ne", "nc", "mn", "b", "l", "v", "nan", "w"], "cluster_offset": ["cluster___pos", "cluster___offset", "clue_offset", "clust_flag", "clue_pos", "clastic_Offset", "cluster_prefix", "clusters_offset", "clust_Offset", "cluster___loc", "cluster_loc", "clusters_loc", "clust_prefix", "clusters_Offset", "cluster_pos", "cluster_op", "clust_off", "clust_offset", "clastic_num", "cluster_off", "cluster___Offset", "clastic_offset", "clue_Offset", "clust_op", "cluster_num", "cluster_Offset", "clusters_pos", "clue_off", "cluster_flag"], "hd_iov": ["HD_iov", "dh_iv", "hd_veh", "wd_liv", "hd__veh", "hd_liv", "hd_iour", "dh_voice", "hd_rolet", "hd___voice", "dh_iov", "dh_iour", "hd___liv", "HD_iv", "hd_voice", "hd___ovi", "wd_iov", "hd___iv", "hd__iour", "hd__ij", "hd__rolet", "HD_rolet", "hd__iov", "hd__voice", "hd_ij", "hd___iour", "hd__iv", "wd_ovi", "hd_ovi", "hd_iv", "wd_iv", "hd___iov", "HD_veh", "dh_ij"], "hd_qiov": ["hd_quickiop", "hd_iqovi", "hd_qovi", "hd_quickovi", "hd_dqiov", "hd_hiop", "hd_quiov", "hd_qiev", "hd_quiour", "hd_qiour", "hd_quickiov", "hd_qiop", "hd_sqiop", "hd_dqrolet", "hd_qrolet", "hd_quigroup", "hd_quiev", "hd_sqiv", "hd_dqiv", "hd_hiov", "hd_iqigroup", "hd_qurolet", "hd_iqiop", "hd_sqrolet", "hd_dqiop", "hd_quiop", "hd_quovi", "hd_hiev", "hd_qigroup", "hd_quickigroup", "hd_iqiov", "hd_hiour", "hd_sqiov", "hd_qiv", "hd_quiv"], "buf": ["orig", "msg", "cap", "rb", "txt", "alloc", "pack", "cb", "ref", "window", "late", "aka", "bl", "Buff", "pkg", "broad", "mb", "fac", "uf", "bc", "Buffer", "cv", "mu", "data", "bytes", "vec", "temp", "batch", "lim", "result", "img", "ctx", "raw", "br", "xff", "queue", "bg", "seq", "tmp", "map", "db", "buffer", "box", "mem", "doc", "norm", "buff", "pb", "cmd", "block", "bin", "cache", "emb", "BU", "cam", "pos", "np", "obj", "port", "b", "v", "cp"], "orig_buf": ["orig_bytes", " orig_loc", "orig___uf", "orig___vec", " orig_buffer", "orig_vec", "orig___buf", " orig_buff", "orig___bytes", "orig___buff", "original_buf", "orig___buffer", "orig_buffer", "original_buffer", "orig_loc", "orig_uf", "orig___loc", " orig_uf", "original_bytes", "orig_buff", "original_vec"], "err": ["er", "sys", "msg", "der", "rc", "usr", "mr", "txt", "r", "cb", "order", "ar", "arr", "rr", "e", "str", "ec", "exc", "Er", "kr", "res", "iter", "ch", "error", "Error", "gr", "cr", "ev"]}}
{"project": "FFmpeg", "commit_id": "9a0f60a0f89a7a71839dfa9def5a26f2037aed62", "target": 0, "func": "static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n\n{\n\n    int hours, minutes, seconds;\n\n\n\n    if (!show_bits(gb, 23)) {\n\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hours   = get_bits(gb, 5);\n\n    minutes = get_bits(gb, 6);\n\n    skip_bits1(gb);\n\n    seconds = get_bits(gb, 6);\n\n\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n\n\n    skip_bits1(gb);\n\n    skip_bits1(gb);\n\n\n\n    return 0;\n\n}\n", "idx": 23123, "substitutes": {"s": ["p", "is", "os", "set", "h", "m", "ss", "ns", "ses", "sd", "stats", "ps", "bs", "cs", "sts", "e", "aws", "gs", "rs", "fs", "c", "i", "ds", "st", "se", "sn", "ls", "ms", "sv", "ats", "hs", "S", "js", "es", "sq", "ts", "sg", "sb", "b", "so", "sl", "w"], "gb": ["gt", "csv", "rect", "gif", "rb", "vd", "bits", "eb", "py", "bf", "tg", "cb", "dd", "io", "hub", "gm", "goo", "gc", "google", "gz", "gd", "mb", "bs", "rg", "ib", "eg", "vg", "gs", "gio", "cv", "gnu", "bd", "fb", "bytes", "xy", "vm", "hd", "cz", "img", "ga", "ctx", "bg", "html", "yg", "wb", "sv", "db", "px", "gg", "g", "kb", "ch", "rl", "pb", "buff", "Gb", "sg", "bt", "pg", "pc", "gy", "GB", "sb", "gh", "fc", "cfg", "bb", " rgb"], "hours": ["places", "inches", "heads", "rooms", "hops", "phones", "lights", "dates", "tracks", "h", "hour", "Hours", " hrs", "ures", "agers", "ints", "mins", "images", "rows", "opens", "years", "times", "headers", "workers", "frames", "itudes", "jobs", "ages", "projects", "ours", "items", "utes", "shows", "hs", "views", "hm", "lines", "reports", "holes", "its", "facts", "pps", "modules", "ouses", "blocks", "archives", "arms", "days", "nuts", "rices", "members", "months", "events"], "minutes": ["Mineters", "minseters", "minuted", "mute", "tenues", "minsues", "Minents", "mineters", "Minues", "tenodes", "minsodes", "minsutes", "minute", "matents", "tenute", "minodes", "minsuted", "Minutes", "Minute", "minents", "mateters", "matutes", "minsents", "modes", "muted", "minsute", "Minuted", "tenutes", "minues", "matute", "mutes", "mues"], "seconds": ["places", "duration", "uses", "pieces", "videos", "scenes", "sec", "runs", "dates", "minimum", "words", "forms", "missions", "ses", "units", "bs", "rows", "terms", "times", "years", "timeout", "services", "gs", "classes", "bytes", "bis", "states", "fixes", "flows", "ions", "sections", "frames", "south", "values", "sets", "utes", "resources", "views", "ones", "bes", "reports", "feet", "tests", "erences", "obs", "gets", "steps", "beans", "uploads", "poses", "nets", "billion", "actions", "tes", "second", "months"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_restart(FTPContext *s, int64_t pos)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    const int rest_codes[] = {350, 0};\n\n\n\n    snprintf(command, sizeof(command), \"REST %\"PRId64\"\\r\\n\", pos);\n\n    if (!ftp_send_command(s, command, rest_codes, NULL))\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n}\n", "idx": 23136, "substitutes": {"s": ["n", "t", "p", "is", "a", "r", "f", "m", "h", "ss", "ns", "session", "ses", "ps", "cs", "sts", "e", "fs", "aws", "rs", "gs", "c", "socket", "ds", "q", "ssl", "sv", "ess", "js", "S", "sq", "ts", "b", "w"], "pos": ["resp", "p", "out", "o", "os", "index", "Pos", "pose", "length", "offset", "Position", " Pos", "top", "pro", "pt", "loc", "po", " position", "on", "size", "pid", "base", "op", "spec", "tmp", "position", "POS", "num", "res", " len", "at", "rot", " POS", "pc", " pose", "len", "to", "port"], "command": ["history", "communication", "create", "response", "message", "paste", "slave", "frame", "comment", "value", "length", "attribute", "channel", "menu", "key", "description", "package", "power", "call", "code", "empty", "controller", "initial", "query", "pattern", "result", "request", "raw", "word", "event", "password", "argument", "directory", "mode", "send", "buffer", "sequence", "template", "error", "delete", "prefix", "config", "cmd", "clear", "execute", "form", "example", "Command", "input", "chain", "text"], "rest_codes": ["rest2code", " rest_code", " rest2code", "rest2names", " rest_names", "rest_code", " rest_lines", " rest2names", "rest_lines", " rest_files", "rest2codes", "rest_files", "rest_names", " rest2codes"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n\n{\n\n    BlockDriverState *bs = child->bs;\n\n\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_offset;\n\n    unsigned int cluster_bytes;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* FIXME We cannot require callers to have write permissions when all they\n\n     * are doing is a read request. If we did things right, write permissions\n\n     * would be obtained anyway, but internally by the copy-on-read code. As\n\n     * long as it is implemented here rather than in a separate filter driver,\n\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n\n     * it could request permissions. Therefore we have to bypass the permission\n\n     * system for the moment. */\n\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 23140, "substitutes": {"child": ["parent", "ach", "task", "h", "unk", "root", "children", "add", "ac", "count", "key", "x", "id", "ind", "sim", "Child", "my", "c", "node", "cl", "handle", "batch", "j", "base", "brother", "q", "server", "ch", "job", "block", "cache", "client", "sb", "port", "b", "v", "shell"], "offset": ["offs", "t", "out", "start", "oid", "et", "o", "os", "index", "set", " offsets", "Offset", "ref", "off", "length", "root", "table", "count", "key", "image", "total", "id", "i", "timeout", "row", "slot", "size", "handle", "batch", "base", "fp", "shift", "ff", "extra", "ptr", "position", "seek", "owner", "buffer", "location", "addr", "error", "prefix", "oot", "address", "block", "pos", "pointer", "to", "oss", "encrypted", "file", "origin", "padding"], "bytes": ["izes", "offs", "out", "bits", "pieces", "settings", "reads", "memory", "parts", "os", "ows", "outs", "bps", "pages", "latest", "total", "rows", "eps", "keys", "times", "ries", "fs", "comments", "size", "classes", "byte", "loads", "s", "seconds", "files", "items", "values", "sets", "ites", "ies", "es", "its", "ips", "Bytes", "abytes", "steps", "blocks", "sofar", "len", "options", "elt", "tes", "pointers", "errors", "les"], "qiov": ["ffnov", "quvoice", "auxiol", "ffiov", "qiv", "eqiol", "qnov", "auxiov", "quiov", "quiol", "qiol", "eqiov", "dqiol", "ffiol", "qvoice", "qqiol", "qunov", "eqovi", "ffvoice", "auxvoice", "qqiv", "dqiov", "eqiv", "qovi", "qqovi", "dqovi", "auxnov", "qqiov", "dqiv"], "bs": ["bi", "blog", "boxes", "ubis", "sys", "lbs", "bits", "bf", "os", "cb", "css", "ubs", "ys", "bed", "ns", "BS", "bps", "aos", "bl", "outs", "ps", "bus", "cs", "bc", "fs", "gs", "rs", "bn", "ds", "bis", "s", "base", "bo", "ctx", "ls", "bm", "kit", "bh", "hz", "br", "vs", "bes", "js", "its", "ts", "obs", "pb", "bt", "aus", "qs", "fps", "sb", "bos", "b", "bp", "bas", "as", "bb"], "bounce_buffer": ["bounce\u043dframe", "benge67buffer", "bounced_index", "bounced_header", "benge_Buffer", "benge67Buffer", "benge_buffer", "bounce_Buffer", "bouncing_buffer", "bounced_buffer", "bounceableBuffer", "bounce\u043dBuffer", "bouncing_Buffer", "bouncelbuffer", "bounce_header", "bounce_buf", "bounced_cache", "bouncelcache", "bounce67initial", "bounced_buff", "bounce_command", "bounce_index", "bounceableheader", "bounce_buff", "bounce_frame", "bounceablebuffer", "bounce67buffer", "bounce67Buffer", "bounce_cache", "bouncing_command", "bounced_Buffer", "bouncelBuffer", "bounce_initial", "bounced_buf", "bounced_frame", "bouncelindex", "bounce\u043dbuf", "bounce\u043dbuffer", "bounce67command", "benge_initial", "benge67initial"], "drv": ["drvg", "driv", "drw", "ptrv", "ptrvg", " drvs", "hrw", "hru", "DRu", "hrv", "ptrvr", "drvs", " drc", "src", "drvr", " drw", "vrvr", "DRV", "drivs", "DRv", "drV", "vrvg", "srvs", "ptrV", "drvd", "DRvg", "DRw", " drV", "drivd", "dru", "hrV", "vrV", " drvd", "srvd", "dric", "drc", "srv", "vrv", "DRvr", " dru"], "iov": ["qv", "rov", "ird", "dq", "liv", "nov", "imp", "aux", "dyl", "river", " mus", " repertoire", "vector", "kov", "veh", "minecraft", " supporters", " civ", "conv", " vom", "iour", " bio", " multimedia", "vec", "iw", "vers", " fav", "ih", "iol", "drm", "ux", "ech", "von", "ever", "Iv", "chrom", "iq", " imb", "ibr", " vers", "vr", "ei", " vib", "iop", "cv", "voc", "tv", "iph", " volley", " mor", "nih", "rolet", "hovah", "ichael", "vp", "voice", "nil", "serv", "ovi", "ij", "ovo", "iu", "isco", " rav", "inv", "iv", "rio", "vo", "uj", "iva", "ouk", "rek", "news"], "bounce_qiov": ["bounce_eqiop", "bounce_qqij", "bounce_kij", "bounce_qqiol", "bounce_Qiop", "bounce_eqibl", "bounce_giev", "bounce_eqiov", "bounce_qiour", "bounce_kiov", "bounce2qiour", "bounce2qqiour", "bounce_kiev", "bounce_piov", "bounce_piol", "bounce_dibl", "bounce_qiol", "bounce_Qij", "bounce2qqiov", "bounce_Qiov", "bounce_qij", "bounce_kiour", "bounce_gibl", "bounce_qiop", "bounce2qqnov", "bounce2qnov", "bounce_qibl", "bounce_piev", "bounce_giol", "bounce_qqiop", "bounce2qqiop", "bounce_qiev", "bounce_giour", "bounce_qqiov", "bounce_giov", "bounce_giop", "bounce_diop", "bounce_qqiour", "bounce_qnov", "bounce_kiop", "bounce_qqiev", "bounce_qqnov", "bounce_qunov", "bounce_quiour", "bounce2qiop", "bounce_diov", "bounce_eqiour", "bounce_knov", "bounce_Qiev", "bounce_piop", "bounce2qiov", "bounce_quiop", "bounce_quiov", "bounce_diour"], "cluster_offset": ["clinicalfulposition", "cluster_parent", "clody_off", "clust_count", "clclus_Offset", "clusterptoffset", "clody_left", "clinical_position", "cluster_output", "clusterityindex", "clinical_open", "clusterfuloff", "clinical_offset", "cluster_left", "clust_Offset", "cluster_type", "clering_offer", "clering_offset", "clusterptoutput", "clering_area", "clust_index", "clust_offset", "clusterfulparent", "cluster_offer", "clclus_bytes", "clinicalfulopen", "clering_output", "cluster_off", "cluster_position", "clinicalfuloffset", "clust_bytes", "cluster_index", "clusterfulleft", "cluster_area", "clusterityoffset", "clusteritytype", "clusterptarea", "cluster_count", "clclus_offset", "clusterfuloffset", "clusterfulposition", "clust_type", "clusterptoffer", "clclus_slice", "cluster_Offset", "clody_parent", "clody_offset", "clinical_left", "cluster_slice", "cluster_open", "clusterfulopen", "clinicalfulleft"], "cluster_bytes": ["cluster2seconds", "cluster_tes", "clust_tes", "clancer_errors", "clust_files", "clust_size", "clust_len", "cluster_items", "clancer_bytes", "cluster_steps", "cluster2blocks", "cluster2Bytes", "clust2len", "cluster9bytes", "clust2seconds", "cluster9names", "clancer2seconds", "cllusterablesteps", "cluster9files", "clust_items", "cluster_len", "clancer_blocks", "clust_seconds", "clancer_seconds", "cluster2errors", "clust2errors", "cllusterablebytes", "cluster_Bytes", "cluster_files", "cluster_parts", "clust_errors", "clancer2errors", "clluster_steps", "clust2bytes", "cluster_size", "clust_codes", "clusterablebytes", "clust_bytes", "cluster_blocks", "cluster_errors", "cluster5bytes", "cluster2bytes", "cllusterableparts", "clluster_parts", "clusterableparts", "clust_names", "cluster_seconds", "cluster5parts", "cluster2tes", "cllusterablesize", "cluster_bps", "clust_Bytes", "cluster2size", "cluster5steps", "cluster5size", "clancer2bytes", "cluster_names", "clluster_size", "cluster_codes", "cluster9items", "clusterablesteps", "clluster_bytes", "clancer2blocks", "clust_bps", "clusterablesize", "cluster2len"], "skip_bytes": ["skip_seconds", " skip_reads", " skip_changes", " skip_seconds", "skip_Bytes", "skip_changes", "skip___reads", "skipvalchanges", "skip___bytes", "skip___tes", " skip_tes", "skipvalseconds", " skip_bits", " skip_Bytes", "skip_reads", "skip_tes", "skipvalbits", "skip___Bytes", "skipvalbytes", "skip_bits"], "ret": ["cert", " RET", "value", "err", "progress", "dt", "reset", "no", "res", "alt", "RET", "after", "elt", "tf", "fun", "resp", "re", "response", "rev", "back", "rets", "complete", "nz", "status", "mt", "deg", "reply", "num", "mem", "cmd", "att", "net", " Ret", "t", "ref", "del", "rem", "Ret", "url", "ert", "arg", "def", "ter", "ft", "try", "nt", "len", "nil", "gt", "er", "en", "out", "usr", "final", "print", "set", "Return", "val", "arr", "ext", "code", "get", "tr", "result", "rt", "jump", "addr", "reg", "iter", "rm", "ll", "flag"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n", "idx": 23145, "substitutes": {"s": ["n", "t", "p", "state", "is", "sys", "a", "sa", "r", "os", "f", "m", "ns", "ss", "ses", "ps", "e", "sts", "cs", "i", "rs", "fs", "gs", "c", "st", "ds", "sv", "S", "js", "sq", "ts", "sp", "sb", "b", "v"], "type": ["name", "ype", "t", "p", "time", "Type", "tag", "ver", "where", "kind", "set", " TYPE", "ping", "ref", "m", "tp", "length", "y", "TYPE", "ay", "method", "ct", "key", "pl", "style", "id", "info", "test", "var", "size", " typ", "ptr", "q", "pe", "types", " ty", "at", "new", "sp", "oe", "typ", "ty", "v", "file", " Type"], "ret": [" Ret", "gt", "cert", "resp", "t", "re", " RET", "out", "fun", "usr", "rev", "print", "det", "cont", "xt", "cat", "back", "del", "tn", "rets", "Return", "desc", "Ret", " alt", "val", "inter", "arr", "nz", "def", "ter", "ext", "code", "str", "over", "reset", "tr", "j", "status", "mt", "deg", "ft", "rt", "reply", "res", "alt", "rm", "try", "at", "nt", "RET", "cmd", "len", "ll", "ne", "elt", "ry", "att", "not", "flag", "l"], "arg": ["agg", "aj", " Arg", "ig", "p", "t", "msg", "tag", "a", "sa", "param", "r", "arp", "ref", "Arg", "ac", "ax", "act", "ar", "val", "arr", "pl", "pp", "loc", "args", "var", "ass", "j", "op", "ag", "argument", "reg", "mem", "g", "ad", "par", "au", "doc", "cmd", "cal", "ma", "v", "flag"], "ap": ["aj", "p", "cap", "am", "a", " heap", "aps", "app", " pc", "arp", " tap", " sp", " rep", "api", "ac", "ax", "al", "ar", " cp", " app", "aph", "pp", "mp", " mp", "tap", "ape", "pa", "av", "snap", "ip", "ab", "ait", "AP", " nap", "ag", " cap", "map", " ip", "ad", "amp", "sp", "np", "ak", "af", "ep", "ma", "att", "apt", "v", "apa", " sap", " av"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155, "substitutes": {"opaque": [" opaques", "opface", "iopaque", "oplaque", "iopca", "oplface", " opque", "iopaques", "opent", "iopent", "opca", " opca", "iopque", "popque", "opaques", "oplaques", "popent", " opface", " opent", "popaque", "opque", "popaques", "oplca", "iopface"], "offset": ["end", "reference", "start", "message", "alloc", "oid", "o", "amount", "set", "Offset", "ref", "delay", "off", "alias", "ix", "length", "window", "attribute", "object", "format", "key", "tz", "style", "id", "timeout", "row", "slot", "data", "axis", "reset", "eta", "outer", "handle", "batch", "base", "mt", "extra", "clock", "position", "ocation", "operation", "entry", "buffer", "location", "addr", "area", "scroll", "bound", "error", "sp", "command", "prefix", "range", "block", "address", "header", "pos", "len", "slice", "pointer", "pad", "origin", "point", "padding", "type"], "size": ["n", "name", "start", "message", "amount", "set", "h", "sum", "SIZE", "length", "fee", "code", "weight", "e", "c", "z", "ize", "num", "mem", "Size", "sp", "address", "len", "type"], "s": ["n", "comm", "t", "p", "is", "bits", "o", "os", "app", "m", "h", "ns", "ss", "y", "changes", "ses", "ims", "stats", "bs", "ps", "sts", "times", "fs", "gs", "rs", "aws", "ds", "sis", "bis", "states", "sn", "spec", "ls", "details", "sam", "ssl", "sv", "sw", "vs", "ms", "hs", "ies", "S", "js", "g", "es", "ins", "sq", "ts", "its", "params", "conf", "qs", "less", "store", "sb", "as", "sl", "serv"], "index": ["n", "Index", "loop", "start", "context", "ion", "connect", "alias", "ix", "length", "head", "order", "condition", "key", "val", "loc", "x", "id", "ind", "i", "code", "info", "row", "axis", "handle", "base", "lock", "request", "position", "num", "open", "page", "iter", "sort", "error", "find", "interface", "address", "pos", "slice", "pointer", "port", "route", "point", "instance"], "shift": ["sup", "share", "load", "time", "start", "ssh", "pack", "Shift", "set", "shr", "delay", "off", "strip", "sum", "length", "pop", "scale", "hash", "transform", "order", "zone", "aw", "mask", "skip", "timeout", " Shift", "join", "sleep", "handle", "reverse", "snap", "step", "wrap", "lock", "hift", "align", "ize", "sh", "seek", "position", "send", "patch", "sort", "sq", "sub", "hold", "pos", "diff", "slice", "pad", "flag", "save", "push", "distance"], "count": ["n", "core", "number", "amount", "list", "sum", "length", "act", "ct", "table", "key", "total", "val", "current", "id", "array", "code", "info", "max", "c", "currency", "limit", "nb", "base", "z", "found", "result", "status", "ctx", "ount", "OUNT", "more", "num", "page", "Count", "match", "nt", "common", "cache", "len", "last", "flag", "ctr", "counter"], "value": ["reference", "message", "process", "commit", "length", "format", "unknown", "function", "feature", "command", "port", "ue", "v", "success", "file", "type", "property", "name", "VALUE", "state", "vector", "start", "comment", "output", "root", "condition", "package", "trace", "data", "status", "see", "password", "values", "rule", "location", "sequence", "tag", "number", "memory", "summary", "session", "scale", "total", "description", "image", "style", "label", "weight", "Value", "child", "position", "buffer", "try", "expression", "save", "python", "hello", "field", "attribute", "domain", "val", "key", "code", "byte", "get", "result", "version", "unit", "block", "json", "priority", "text"], "lt_i": ["lt0ij", "lt0i", "lt__i", "lt__ij", "elt_p", "lt_ij", "lt0p", "elt_i", "elt_ci", "lt0ci", "lt_ci", "lt__p", "lt__ci", "elt_ij", "lt_p"]}}
{"project": "FFmpeg", "commit_id": "bb146bb57bea6647f9c080aa4f9323a3a789ad22", "target": 0, "func": "theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)\n\n{\n\n    struct ogg *ogg = ctx->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    struct theora_params *thp = os->private;\n\n    uint64_t iframe = gp >> thp->gpshift;\n\n    uint64_t pframe = gp & thp->gpmask;\n\n\n\n    if (thp->version < 0x030201)\n\n        iframe++;\n\n\n\n    if(!pframe)\n\n        os->pflags |= AV_PKT_FLAG_KEY;\n\n\n\n    if (dts)\n\n        *dts = iframe + pframe;\n\n\n\n    return iframe + pframe;\n\n}\n", "idx": 23159, "substitutes": {"ogg": ["ok", "aud", "ogs", "eas", "audio", "msg", "orm", "org", "readable", "ogi", "iot", "eb", "article", "oid", "pdf", "ob", "rss", "bool", "embed", "irc", "stream", "ib", "ink", "ot", "pp", "owl", "deb", "og", "gs", "ogl", "tt", "voc", "eg", "alert", "ott", "archive", "ga", "ood", "ov", "meg", "oga", "ik", "gg", "usb", "config", "obs", "mpeg", "android", "pg", "obb", "orp", "gp", "gov", "oss", "ech", "bb", "oc"], "os": ["ok", "Os", "is", "ost", "sys", "oid", "o", "ros", "io", "ows", "ys", "ns", "ss", "aos", "ob", "ps", "ops", "bs", "oz", "ot", "cs", "socket", "rs", "og", "ds", "s", "oa", "oids", "ott", "ms", "res", "osi", "ow", "oS", "ts", "obs", "soc", "OS", "dos", "pos", "oos", "bos", "oss", "oses", "oc"], "thp": [" thop", "etht", "otho", "ethm", "ithm", "thps", "thpl", "Tho", "THo", "ethcp", " tht", "thcp", "Thm", "othm", "THm", "thg", "thaps", "ethg", "thop", "thap", " thps", "thaop", "THp", "thapl", "ethp", "ethps", "thm", "shm", "ithp", "tht", " thm", "othp", "ithg", "ithcp", "sht", "othcp", " thpl", "ethop", "shp", "Thp", "tho", "ethpl", "othg"], "iframe": ["rame", "emi", " fps", "hid", "loop", "phi", "zip", "gif", "proxy", "plot", "is", "frame", "oid", "iu", "large", "movie", "window", "foo", "eye", "gz", "wi", "rss", "zi", "ei", "image", "embed", "id", "i", "empty", "timeout", "tx", "peer", "asia", "fb", "iam", "frames", "show", "hw", "pid", "alert", "fp", "z", "flash", "height", "tif", "xp", "ih", "hz", "ui", "fi", "html", "igm", "osi", " timeframe", "scroll", "cam", "soc", "xxx", "iso", "ii", "slice", "browser", "fps", "hi", "vp", "tf", "pic"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void av_build_index_raw(AVFormatContext *s)\n\n{\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    st = s->streams[0];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, s->data_offset, SEEK_SET);\n\n\n\n    for(;;) {\n\n        ret = av_read_frame(s, pkt);\n\n        if (ret < 0)\n\n            break;\n\n        if (pkt->stream_index == 0 && st->parser &&\n\n            (pkt->flags & PKT_FLAG_KEY)) {\n\n            add_index_entry(st, st->parser->frame_offset, pkt->dts, \n\n                            AVINDEX_KEYFRAME);\n\n        }\n\n        av_free_packet(pkt);\n\n    }\n\n}\n", "idx": 23161, "substitutes": {"s": ["n", "comm", "t", "p", "sys", "a", "r", "os", "source", "f", "h", "m", "ns", "ss", "conv", "stats", "ps", "bs", "cs", "sts", "aws", "gs", "fs", "rs", "c", "ds", "j", "se", "ctx", "spec", "ls", "sv", "ats", "vs", "S", "js", "g", "es", "its", "sq", "ts", "sp", "ins", "sg", "w", "qs", "less", "sb", "b", "v", "serv"], "pkt1": ["pft3", "pcmdId", "pft1", "pkt3", " pet1", " pkt3", "pqt3", "packetId", "cpacket1", "packet2", "packet0", "cpacketName", " pkt2", "pet1", " pkt0", "pqt1", " pet3", "packetName", "pcmd3", "pcmd1", "pcmdName", "packet1", "cpacketId", "pftId", "cpkt3", "cpacket3", "pktId", "pet0", " pet2", "pkt2", "cpktName", "pkt0", " pet0", "pqt0", "cpktId", "pet2", "pqt2", "pet3", "pktName", "packet3", "cpkt1", "pftName"], "pkt": [" pct", "ppkt", "Packet", "pkat", "pct", "ppmsg", "Pkt", "npnt", " pnt", " pkat", "tpet", "pet", "precmd", "ppet", "perkt", "tpacket", "pcmd", " pact", "npkat", "pact", "rnt", "rcmd", "ppacket", "rkt", " pet", "preet", "prekt", "premsg", "npkt", "racket", "packet", "ppnt", "pmsg", "tpact", "tpkt", "Pmsg", "Pact", "prent", "prekat", "peracket", "preacket", " pcmd", "npacket", "Pnt", "Pct", "perct", "ppcmd", "peret", " packet", "pnt", "Pet"], "ret": [" Ret", "cert", "resp", "gt", "t", "re", " RET", "out", "fun", "usr", "cat", " res", "r", "cont", "back", "ref", "f", "rets", "rem", "Ret", "conv", "val", "inter", "arr", "nz", "arg", "def", "ter", "round", " t", "tr", "j", "status", "mt", " ar", "deg", "ft", "rt", " resp", "res", "alt", "iter", "nt", "RET", "cmd", " val", "ry", "elt", "att", "flag", "ctr", " fut"], "st": ["ste", "t", "p", "state", "ost", "tt", "start", "must", "stop", "usr", "r", "set", "stat", "h", "sta", "th", "ct", "d", "pt", "stream", "ld", "sts", "St", "str", "decl", "step", "tr", "se", "mt", "fr", "ust", "sn", "nd", "ft", "sh", "sw", "sv", "est", "sc", "stable", "stage", "rest", "ts", "sp", "std", "nt", "ist", "util", "inst", "l", "ST", "v", "ut", "art", "sl", "sty"]}}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163, "substitutes": {"fw_cfg": ["xfptfab", "fwtfab", "wk_cgi", "fwptorig", "fwtfg", "fwMcfg", "w__gc", "wk_cfg", "fwtfee", "wk_config", "wk_bg", "fw_bg", "fw___properties", "fw___cgi", "fw___note", "xfptorig", "fwptfab", "fw_fg", "fwptjobs", "sw_cfg", "w__sg", "fwtcfg", "fw___comm", "w__conf", "fw__cmd", "xf_fg", "hw_config", "w_properties", "fw_fee", "fwptcfg", "hw_cfg", "fw_gc", "sw_cmd", "fw_comm", "xfptnote", "fw__fg", "fwmygc", "fw_log", "sw_fg", "sw_conf", "fwMconf", "fwptlog", "fwtconfig", "fw_cert", "w_conf", "fwlfg", "fw_fab", "wk_comm", "fw___fg", "fwmyconf", "xf_cfg", "fwJcgi", "fwptconfig", "xfptcfg", "fw_cgi", "fwJfg", "fwdbini", "fwtorig", "hw_cgi", "w_gc", "hw_jobs", "fwdbcert", "wk_fee", "hw_sg", "hw_log", "w_ini", "fwlcfg", "fw__sg", "fw___ini", "fwdbcfg", "fw_ini", "fw__conf", "fwptcgi", "w_cfg", "w__cfg", "fwMgc", "w_cert", "hw_fg", "fwmycfg", "fw___cert", "fw_properties", "fw_sg", "hw_orig", "fwmysg", "fwMsg", "fw_conf", "fw___orig", "fw_config", "xf_fab", "fw_cmd", "fw___cfg", "hw_fab", "fwptnote", "fwtcomm", "fwJjobs", "fw__cfg", "xfptfg", "fw_note", "fw__gc", "fw_jobs", "xf_orig", "w_sg", "fw___bg", "fwdbproperties", "fwlorig", "fwJcfg", "xf_note", "fw_orig", "fwlsg", "fwptfg"], "smbios_tables": ["smbios_entiers", "smbios_taps", "smbios_borders", "smbios_dtitles", "smbios__tasks", "smbios_entitles", "smbios_tors", "smbios_entable", "smbios_nasks", "smbios_transales", "smbios_bables", "smbios__tales", "smbios_sables", "smbios_Tabases", "smbios_transables", "smbios_tablerees", "smbios_nabases", "smbios_table", "smbios_dtiers", "smbios_entables", "smbios_tenable", "smbios_Tasks", "smbios_sors", "smbios_tableables", "smbios_sitles", "smbios__nales", "smbios_Titles", "smbios_tableaves", "smbios_Tables", "smbios_tasks", "smbios_dtries", "smbios_tales", "smbios_tableries", "smbios_transabases", "smbios_torders", "smbios_Talks", "smbios__nables", "smbios__tables", "smbios__tabases", "smbios_Taves", "smbios_tries", "smbios_dtables", "smbios_Torders", "smbios__nasks", "smbios_taves", "smbios_srees", "smbios_Tries", "smbios_trees", "smbios_entors", "smbios_nables", "smbios_Tors", "smbios_Tales", "smbios_Trees", "smbios_tenalks", "smbios_tenries", "smbios_entaves", "smbios_Taps", "smbios_transasks", "smbios_entorders", "smbios_entries", "smbios_Table", "smbios_tiers", "smbios_titles", "smbios_entrees", "smbios_baps", "smbios_Tiers", "smbios__nabases", "smbios_brees", "smbios_talks", "smbios_tabases", "smbios_entalks", "smbios_nales", "smbios_tenables", "smbios_entaps"], "smbios_anchor": ["smbios_chestpor", "smbios_chestors", "smbios_accessors", "smbios_chor", "smbios_aphor", "smbios_cho", "smbios_chestor", "smbios_chori", "smbios_chors", "smbios_accessOR", "smbios_entpor", "smbios_chestored", "smbios_factors", "smbios_anchors", "smbios_chestore", "smbios_chestory", "smbios_anchpor", "smbios_entor", "smbios_anchored", "smbios_accessori", "smbios_anchori", "smbios_chesto", "smbios_ancho", "smbios_entors", "smbios_mentore", "smbios_anchory", "smbios_chestori", "smbios_chory", "smbios_chore", "smbios_factOR", "smbios_factor", "smbios_aphored", "smbios_mentors", "smbios_entOR", "smbios_chored", "smbios_chestOR", "smbios_apho", "smbios_mentor", "smbios_accessor", "smbios_anchOR", "smbios_chOR", "smbios_factpor", "smbios_aphors", "smbios_mentory", "smbios_anchore"], "smbios_tables_len": ["smbios_tables_gen", "smbios_tables_size", "smbios_trees_size", "smbios_tasks_Len", "smbios_tables2Len", "smbios_tables2str", "smbios_tries_len", "smbios_tables_str", "smbios_tables_Len", "smbios_tables2en", "smbios_tries_Len", "smbios_tables_coll", "smbios_tables_base", "smbios_tries_gen", "smbios_trees_base", "smbios_trees_coll", "smbios_tasks_en", "smbios_tables2len", "smbios_trees_length", "smbios_tables_en", "smbios_tries_size", "smbios_tries_en", "smbios_tasks_str", "smbios_tables_length", "smbios_trees_Len", "smbios_trees_len", "smbios_tasks_len"], "smbios_anchor_len": ["smbios_anchor_ls", "smbios_anchors_Len", "smbios_ancher_en", "smbios_anchor_Len", "smbios_anchor__en", "smbios_anchor_pos", "smbios_ancher_len", "smbios_ancher_Len", "smbios_anchors_pos", "smbios_ancher_pos", "smbios_anchors_size", "smbios_anchor_num", "smbios_anchors_len", "smbios_anchors_num", "smbios_anchor__Len", "smbios_anchor__len", "smbios_anchor_size", "smbios_anchor_en", "smbios_anchors_ls", "smbios_anchor__pos"], "numa_fw_cfg": ["numa_fw_config", "numa_fw2config", "numa_fw2cfg", "numa_hw_conf", "numa_fw_conf", "numa_fw2fg", "numa_hw_config", "numa_hw_cfg", "numa_fw_fg", "numa_fw2conf", "numa_hw_fg"], "i": ["bi", "ij", "p", "t", "a", "si", "r", "io", "m", "y", "x", " ii", "gi", "I", "c", "ip", "z", "li", "ia", "ik", "ci", "mi", "ii", "pi", "b", "v", "l"], "j": ["n", "ij", "aj", "jac", "p", "r", "m", "ji", "d", "c", "ni", "jp", "z", "jc", "k", "q", "J", "jump", "js", "g", "job", "uj", "kj", "b", "l", "v", "jj"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23174, "substitutes": {"env": ["er", "en", "esm", "state", "engine", "end", "org", "context", "et", "param", "set", "te", "equ", "h", "policy", "window", "qt", "inv", "ner", "network", "ei", "e", "conn", "code", "cv", "vm", "operator", "den", "ec", "esc", "worker", "enter", "buf", "ctx", "kernel", "here", "manager", "environment", "server", "event", "vs", "entry", "open", "self", "viron", "dev", "erd", "config", "era", "cmd", "Environment", "w", "obj", "conf", " environment", "ah", "ew", "v", "eng", "vp", "net", "ev", "forge", "vt"], "vaddr": ["hadd", "vaddress", "nvptr", "hptr", "wadr", "vtadr", "wadd", "Vaddr", "rptr", " vadd", "wobj", " vreq", "Vadd", " vaddress", "vtreq", "vadd", "waddr", "radd", "vadr", "nvaddr", "mptr", "haddr", "mattr", "mobj", "waddress", "hreq", "haddress", "rattr", "vtaddr", "nvattr", "wptr", " vattr", "nvaddress", "hadr", "vptr", "madr", "radr", "vreq", " vobj", "raddress", "maddress", "vtptr", "vattr", "Vadr", "vobj", " vadr", "vtaddress", "Vattr", "vtattr", "maddr", " vptr", "wattr"], "rw": ["kw", "rb", "writer", "rc", "usr", "dx", " wr", "r", "ru", "wh", "nr", "shr", "rew", "ww", "aw", "nw", "rss", "wp", "weight", "row", "fw", "writ", "wr", "wind", "iw", "hw", "xp", "wx", "ng", "buf", "rt", " w", "sw", "wb", "rh", "RW", "ow", "rf", "wal", "wcs", "wd", "au", "wo", "tw", "ew", "wn", "wa", "rd", "w"], "asc": [" agg", " rc", " arg", "ras", "rc", " ps", "aps", " ac", " pc", "arp", "desc", "auc", " addr", "amps", " sc", "ac", "pac", " tc", " acc", "title", " exc", "asa", "ar", "unc", "arg", " enc", " inc", "rar", " esc", "uc", "admin", " ASC", "esc", " Asc", " win", "cmp", "asm", "ec", "alpha", " alpha", " ap", "sw", "ASC", "sc", "addr", "up", "sort", "anc", "pc", "tc", " pas", "pg", "acl", "soc", "acs", "acc", "as", "fc", "ra", " desc", " lac", "alias"], "raddr": ["paddress", "rcloc", "vaddress", "ropen", "rropen", "laddress", "Raddr", "wadr", "paddr", "wadd", "rptr", "rcaddress", "padr", "padd", " rptr", "vloc", "vargs", "vadd", "waddr", " radr", "radd", "vadr", "Radr", "rcptr", "mptr", " rloc", "pptr", "rcaddr", "waddress", "rattr", "Radd", "rloc", "wptr", "maddr", "laddr", "vptr", " ropen", "rraddr", "ladd", "rradd", " raddress", "radr", " rattr", "raddress", "rargs", "maddress", "vattr", " rargs", "vopen", " radd", "Rptr", "rrargs", "rraddress", "mattr"], "flags": ["inks", "ports", "helps", "packages", "acts", "pages", "fee", "goal", "mask", "products", "details", "feat", "types", "ants", "mates", "features", "rules", "fields", "plugins", "alf", "bugs", "amps", "words", "citizens", "fs", "pres", "states", "rights", "caps", "atts", "ats", "lines", "uart", "properties", "wcs", "posts", "ts", "ads", "Flags", "ags", "acl", "events", "heads", "settings", "aps", "intel", "f", "stats", "ps", "opens", "affles", "args", "comments", "pants", "frames", "utils", "doms", "actions", "links", "bits", "func", "phones", "weights", "dates", "tags", "fits", "fac", "terms", "headers", "styles", "workers", "xml", "locks", "fp", "ms", "finals", "cond", "vals", "fd", "acs", "options", "fps", "flag", "limits", "lag", "cons", "ents"], "sk": ["kw", "ok", "sch", "mk", "ark", "kt", "ck", "ks", "km", "ski", "dk", "ek", "unk", "wk", "alk", "mask", "tk", "cs", "ki", "kl", "se", "kn", "sn", "ank", "k", "ke", "ask", "sy", "kr", "sw", "seek", "spe", "sky", "sc", "ka", "kk", "ik", "SK", "kick", "craft", "sp", "kid", "Sk", "uk"]}}
{"project": "FFmpeg", "commit_id": "dbc1163b203b175d246b7454c32ac176f84006d1", "target": 0, "func": "static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,\n\n                                   int blocks_per_slice,\n\n                                   int plane_size_factor,\n\n                                   const uint8_t *scan)\n\n{\n\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n\n    int max_coeffs, bits_left;\n\n\n\n    /* set initial prediction values */\n\n    run   = 4;\n\n    level = 2;\n\n\n\n    max_coeffs = blocks_per_slice << 6;\n\n    block_mask = blocks_per_slice - 1;\n\n\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n\n        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];\n\n        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return 0;\n\n\n\n        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);\n\n        if (run < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        level = decode_vlc_codeword(gb, ff_prores_ac_codebook[lev_cb_index]) + 1;\n\n        if (level < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        pos += run + 1;\n\n        if (pos >= max_coeffs)\n\n            break;\n\n\n\n        sign = get_sbits(gb, 1);\n\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n\n            (level ^ sign) - sign;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23184, "substitutes": {"gb": ["gt", "csv", "gem", "gif", "rb", "ogg", "bf", "tg", "arb", "cb", "hub", "gm", "cgi", "gc", "google", "gd", "mb", "bs", "rg", "lb", "uf", "bc", "eg", "vg", "cv", "bn", "gs", "fb", "nb", "buf", "img", "ctx", "gin", "bm", "ub", "bg", "yg", "db", "storage", "hog", "gg", "g", "kb", "ch", "phy", "buff", "bt", "Gb", "pc", "pg", "pb", "sg", "GB", "sb", "gp", "cfg", "bb"], "out": ["n", "p", "all", "it", "OUT", "o", "os", "set", "list", "output", "outs", "table", "serv", "mask", "c", "result", "buf", "Out", "map", "buffer", "up", "in", "at", "ch", "new", "ou", "block", "pool", "conf", "bin", "can", "b", "v", "file", "clean", "net", "w"], "blocks_per_slice": ["blocks_PER_tile", "blocks_per_tile", "blocks_per_ice", "blocks_per_scale", "blocks_PER_slice", "blocks_perJslice", "blocks_per2slice", "blocks_current__section", "blocks_eachJice", "blocks_per_section", "blocks_perJcell", "blocks_PER_scale", "blocks_per_sample", "blocks_each_slice", "blocks_current_section", "blocks_perJice", "blocks_PER_sample", "blocks_per__section", "blocks_current_series", "blocks_per_cell", "blocks_eachJcell", "blocks_per__slice", "blocks_per2scale", "blocks_current__slice", "blocks_current_slice", "blocks_current__series", "blocks_eachJslice", "blocks_each_cell", "blocks_each_ice", "blocks_per__series", "blocks_PER_series", "blocks_per2series", "blocks_per_series"], "plane_size_factor": ["plane_size_digit", "plane_sizeulofloor", "plane_sizeulofact", "plane_sizeityfactor", "plane_sizeitydigit", "plane_sizeulofactor", "plane_size_floor", "plane_size_fact"], "scan": ["sys", "pack", "set", "gate", "reach", "pixel", "check", "score", "read", "scale", "sync", "bank", "miss", "mask", "skip", "row", "query", "warn", "parse", "spec", "black", "plan", "Scan", "spe", "map", "sky", "buffer", "sc", "pan", "range", "cam", "conf", "can", "slice", "gain", "pass"], "pos": ["neg", "loss", "length", "err", " Pos", "pt", "loc", "no", "col", "rot", "path", "port", "point", "oc", "n", "resp", "response", "start", "o", "os", "pose", "Position", "bs", "x", "i", "ind", "size", "pres", "body", "coord", "pid", "num", "px", "at", " rot", "pc", "oss", "pass", "lat", "tag", "ps", "pro", "po", "def", " position", "spec", "position", "POS", "up", "in", "trans", "range", "conf", "len", "sol", "pi", "yes", "p", "index", "Pos", "off", "offset", "add", "val", "pl", "id", "row", "cond", "doc"], "block_mask": [" block_filter", " block_sign", "blockLmask", "blockLmap", "block_filter", " block_limit", "lock_weight", "block_map", "blocklymap", "block_index", " block_flag", "blockLindex", "blocklyweight", "lock_index", "block_limit", "lock_mask", " block_map", "block_weight", "blocklyindex", "lock_map", "block_sign", "blocklymask", "block_flag", "blockLweight"], "run": ["n", "fun", "roll", "name", "loop", "re", "build", "plot", "rc", "frame", "r", "ru", "role", "depth", "runs", "record", "group", "une", "index", "go", "running", "length", "task", "rol", "rank", "order", "dir", "circ", "pair", "call", "con", "Run", "ro", "rown", "row", "round", "step", "ran", "rate", "rog", "family", "un", "rain", "rid", "reg", "unit", "rm", "runner", "range", "play", "job", "rot", "block", "cmd", "len", "work", "rec", "line", "ra", "pass", "rd", "type"], "level": ["coll", "roll", "loop", "scope", "state", "lvl", "where", "print", "role", "high", "depth", "index", "vol", "vel", "group", "field", "color", "length", "score", "scale", "co", "rol", "thread", "goal", "tail", "count", "key", "ps", "pl", "val", "loc", "po", "call", "ld", "label", "pri", "row", "Level", "round", "test", "size", "le", "limit", "lo", "compl", "col", "low", "version", "lev", "wl", "cell", "id", "cond", "pe", "lc", "levels", "sc", "stack", "block", "priority", "half", "len", "l", "local", "lv", "layer", "pass"], "sign": ["ig", "sch", "vis", "ign", "pack", "comment", "index", "depth", " SIGN", "sum", "ss", "length", "scale", "value", "rank", "score", "err", "sd", "x", "id", "mask", "sect", "ind", "code", "SIGN", "space", "round", "Sign", "dig", "ass", "s", "ann", "se", "z", "lock", "shift", "pen", "spec", "align", "turn", "sh", "sw", "speed", "sc", "shape", "S", "qual", "inc", "sort", "prime", "spect", "sp", "mod", "diff", "sb", "save", "pass"], "run_cb_index": ["run_cbrind", "run_rb_loc", "run_rb_index", "run_cbacid", "run_cbrnode", "run_cbznode", "run_cb__Index", "run_rb_node", "run_cbacref", "run_cbrindex", "run_cb_id", "run_cbzind", "run_rb_ser", "run_cb_ser", "run_cb_ind", "run_cb_Index", "run_cb_ref", "run_cb_loc", "run_cb__loc", "run_cbacindex", "run_rb_id", "run_cbzser", "run_rb_ref", "run_rb_ind", "run_cb_node", "run_cbzindex", "run_cb__index", "run_cbrser", "run_cb__id", "run_rb_Index", "run_cbacIndex"], "lev_cb_index": ["lev_cb_Index", "lev_cboeIndex", "lev_cboevalue", "lev_cb_id", "lev_cb_mix", "lev_rb_mix", "lev_cb_size", "lev_rb_Index", "lev_cbkout", "lev_cbixmix", "lev_rb_position", "lev_cbkindex", "lev_cbkmix", "lev_cbixindex", "lev_cboeindex", "lev_cb_out", "lev_callback_size", "lev_callback_index", "lev_cboesize", "lev_cbixout", "lev_rb_id", "lev_cbixIndex", "lev_callback_Index", "lev_cb_position", "lev_rb_out", "lev_callback_value", "lev_cbkIndex", "lev_cb_value", "lev_rb_index"], "max_coeffs": ["max_coffs", "max_coefficientes", "max_COefS", "max_COefps", "max_coefficientances", "max_coefps", "max_coefficientsS", "max_coeffps", "max_coefficientses", "max_coffes", "max_coefs", "max_coefls", "max_coeffances", "max_coefances", "max_COefes", "max_COefs", "max_coffls", "max_coefes", "max_COefficientsS", "max_COeffs", "max_coefficientps", "max_COefficientss", "max_coefficients", "max_coeffS", "max_COefficientses", "max_coefficientS", "max_COeffS", "max_coefficientls", "max_coeffls", "max_coeffes", "max_COeffps", "max_coefficientsps", "max_coffances", "max_COeffes", "max_coefS", "max_coefficientss"], "bits_left": ["bits_list", "bits_l", " bits2left", "its_allowed", " bits_wrong", " bits_cont", "rots64left", "bits2wrong", "ports_loaded", "bitsmmtop", "bits_top", "bitsonlast", "bits_cont", "its_left", "bitsmmleft", "bytes_right", "bitsonleft", "bits_exp", "ports_left", "bits64top", "bits_low", "rots_le", "ports__left", "bits2cont", "bits67lf", "bits2left", "bits_allowed", "bytes_list", "bits_inner", "ports_wrong", "bytes_lt", "bits64inner", "rots64low", "bits_le", "bits_lt", " bits2cont", "bits_last", "ports__wrong", "bytes_left", "bits_lf", "bits__loaded", "bits__wrong", "bits64only", " bits2wrong", "bits64low", "bits2right", "bits2low", " bits_top", "bits55right", "ports__loaded", "rots64le", "bitsmmonly", "bits2inner", "its_lf", "bytes_l", "its_right", "bits55allowed", "bits64left", "bits67left", "bits2lt", "bytes_low", "bitsonright", "its_exp", "bits_only", "bits55left", "its_low", "bitsonl", "bits2list", "bytes_inner", "bits64le", "bits_right", "bits__left", "bits64right", "bits67exp", "bits55low", "bytes_last", " bits_only", "rots_left", "bits64lt", "bits_wrong", "rots_low", "bits67right", "bits_loaded"]}}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}", "idx": 23186, "substitutes": {"ctx": ["kw", "Context", "mk", "txt", "context", "cb", "cn", "conv", "gc", "ct", "pkg", "loc", "x", "bc", "conn", "cu", "ksh", "tx", "cv", "cl", "jp", "cmp", "hw", "lex", "setup", "wx", "bh", " cx", "care", "cm", "px", "sc", "cf", "mem", "xs", "wcs", "anc", "nt", "req", "np", "tc", "nc", "cc", "ca", "fc", "cp", "cas", "xc"], "fs_path": ["fs_ref", "fs_Path", "fs_desc", " fs_mon", "fs_entry", " fs_Path", "fs_mon", "fs_context", " fs_ref", " fs_context", " fs_desc", " fs_entry"], "fs": ["sys", "Fs", "os", "f", "sf", "ns", "ss", "aos", "stats", "ps", "bs", "cs", "irs", "fw", "rs", "aws", "ds", "s", "FS", "files", "ls", "df", "ms", "vs", "cf", "ts", "fd", "obs", "fps", "oss", "fc"], "dirfd": ["Dircond", "filed", "directoryfd", "dd", "directorydir", "dFD", "idfd", "directoryid", " dirid", "folderfd", "filecond", "dirdir", "directoryd", "folderid", "dirFD", "folderdir", "directoryFD", "Dirfd", " dirFD", "folderds", " dird", "dircond", "directorycond", " dirds", " dirdf", "idd", "dirdf", "filedf", "DirFD", "directoryds", "dirds", "idFD", "filefd", " dirdir", "fileFD", "dfd", "dirid", "dird", "Dirds", "Dird", "iddf", "dds"], "stream": ["loop", "zip", "present", "context", "resource", "cont", "depth", "list", "wrapper", "record", "f", "window", "progress", "length", "Stream", "channel", "transform", "sync", "read", "driver", "dir", "table", "pair", "reader", "poll", "socket", "str", "row", "data", "test", "mount", "host", "local", "handle", "tr", "export", "ready", "status", "pod", "pipe", "spec", "clean", "child", "server", "draw", "sw", "ssl", "REAM", "console", "open", "buffer", "dr", "stack", " upstream", "fd", "find", "path", "tree", "pool", "hold", "form", "store", "next", "port", "encrypted", "file", "feed", "sl", "sign", "iterator"]}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, ac3_id;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd = (ctx->oformat == &mpeg1vcd_mux);\n\n    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_mux);\n\n    \n\n    if (s->is_vcd)\n\n        s->packet_size = 2324; /* VCD packet size */\n\n    else\n\n        s->packet_size = 2048;\n\n        \n\n    /* startcode(4) + length(2) + flags(1) */\n\n    s->packet_data_max_size = s->packet_size - 7;\n\n    if (s->is_mpeg2)\n\n        s->packet_data_max_size -= 2;\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n    mpa_id = AUDIO_ID;\n\n    ac3_id = 0x80;\n\n    mpv_id = VIDEO_ID;\n\n    s->scr_stream_index = -1;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        switch(st->codec.codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if (st->codec.codec_id == CODEC_ID_AC3)\n\n                stream->id = ac3_id++;\n\n            else\n\n                stream->id = mpa_id++;\n\n            stream->max_buffer_size = 4 * 1024; \n\n            s->audio_bound++;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            /* by default, video is used for the SCR computation */\n\n            if (s->scr_stream_index == -1)\n\n                s->scr_stream_index = i;\n\n            stream->id = mpv_id++;\n\n            stream->max_buffer_size = 46 * 1024; \n\n            s->video_bound++;\n\n            break;\n\n        default:\n\n            av_abort();\n\n        }\n\n    }\n\n    /* if no SCR, use first stream (audio) */\n\n    if (s->scr_stream_index == -1)\n\n        s->scr_stream_index = 0;\n\n\n\n    /* we increase slightly the bitrate to take into account the\n\n       headers. XXX: compute it exactly */\n\n    bitrate = 2000;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        bitrate += st->codec.bit_rate;\n\n    }\n\n    s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n    \n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n       s->pack_header_freq = 1;\n\n    \n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* every 40 packets, this is my invention */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n    \n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        stream->buffer_ptr = 0;\n\n        stream->packet_number = 0;\n\n        stream->start_pts = AV_NOPTS_VALUE;\n\n        stream->start_dts = AV_NOPTS_VALUE;\n\n    }\n\n    s->last_scr = 0;\n\n    return 0;\n\n fail:\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        av_free(ctx->streams[i]->priv_data);\n\n    }\n\n    return -ENOMEM;\n\n}\n", "idx": 23193, "substitutes": {"ctx": ["kw", "comm", "history", "resp", "jac", "ij", "fn", "com", "Context", "ppo", "txt", "org", "kt", "context", "ck", "sys", "cont", "cb", "desc", "abc", "aka", "act", "etc", "ct", "pkg", "conv", "bc", "conn", "cv", "tx", "c", "jp", "cmp", "kl", "hw", "xp", "setup", "wx", "aux", "std", "ia", " cx", "tmp", "cm", "care", "sc", "addr", "px", "cf", "qu", "wcs", "kb", "anc", "config", "mc", "nt", "pc", "np", "cmd", "tc", "aus", "req", "that", "conf", "nc", "cc", "ctl", "fc", "cp", "cfg", "xc"], "s": ["ports", "is", "m", "ims", "ops", "sts", "ds", "details", "sv", "ssl", "hs", "ess", "es", "xs", "ins", "als", "ants", "less", "sb", "as", "v", "sl", "n", "os", "changes", "ns", "bs", "cs", "results", "aws", "fs", "se", "status", "sm", "ers", "sets", "ats", "vs", "scripts", "g", "has", "ts", "sg", "qs", "b", "tes", "sys", "settings", "f", "y", "stats", "ar", "ps", "services", "args", "c", "spec", "ls", "utils", "ies", "S", "its", "obj", "actions", "l", "so", "set", "parts", "h", "ss", "us", "ses", "https", "eps", "sports", "rs", "gs", "pers", "j", "south", "ms", "sam", "js", "tests", "sq"], "bitrate": ["Bitrate", "brates", " bitRate", "Bitspeed", " bitrates", "bRate", " bitspeed", "bitrates", "rotspeed", "bitfrequency", "bfrequency", "binRate", " bitfrequency", "Bitrates", "bitRate", "binfrequency", "rotrates", "brate", "binrate", "bitspeed", "binrates", "rotrate"], "i": ["n", "ij", "bi", "phi", "p", "is", "t", "ic", "it", "ri", "si", "me", "index", "di", "iu", "ai", "xi", "f", "m", "ix", "go", "ims", "y", "h", "ji", "multi", "conv", "im", "zi", "ei", "ie", "x", "id", "ind", "e", "sim", "gi", "I", "c", "qi", "cli", "j", "ip", "ini", "ti", "batch", "li", "ui", "fi", "gu", "oi", "iter", "dr", "ci", "g", "try", "in", "mi", "ii", "to", "pi", "b", "v", "hi", "l", "chain"], "mpa_id": ["mpa_ide", "mpa___ID", "mpaamemagic", "mpa_mid", "mpa_vid", "mpaameno", "mpaoxmagic", "mpa_ID", "mpn_id", "mpan_mid", "mpan_id", "mpa_magic", "mpn_ide", "mpa_file", "mpa_source", "mp3ameno", "mpa_no", "mp3amemagic", "mpa___id", "mpa___source", "mp3_magic", "mpn_file", "mpn_source", "mp3_id", "mpan_vid", "mp3ameid", "mpaoxvalue", "mp3_value", "mpa___mid", "mpaamevalue", "mpa___vid", "mpan_ID", "mpa___file", "mpaoxid", "mp3_no", "mpa_value", "mpaameid", "mp3amevalue", "mpaoxno", "mpa___ide"], "mpv_id": ["mpi_vid", "mpv___name", "mpvoeinit", "mpv___vid", "mpv____id", "mpvoxdata", "mpvoeid", "mpu_id", "mpv_init", "mpvoedata", "mpv____ids", "mpi___init", "mpv___init", "mpv_ids", "mpv___ip", "mpv_in", "mpv_name", "mpvoevid", "mpv___i", "mpu_ide", "mpv_data", "mpvoxid", "mpvoxvid", "mpu_ids", "mpi_data", "mpv_i", "mpd_ip", "mpv___data", "mpd_id", "mpvoxinit", "mpv_ide", "mpv_vid", "mpd_i", "mpi_id", "mpi_init", "mpi___vid", "mpv____ide", "mpv___id", "mpv____in", "mpv_ip", "mpi___id", "mpu_in", "mpd_name", "mpi___data"], "ac3_id": ["ac3_h", "ac3_n", "acd_ID", "acrav___n", "ac3_name", "ac2_mid", "ac2_ID", "acrav_id", "ac3___n", "acd_oid", "ac3___id", "ac2_id", "acrav_h", "acrav_n", "ac2_ids", "acrav___name", "ac32oid", "acrav___id", "acrav___h", "acrav_name", "ac32ID", "ac3_ID", "ac3_ids", "ac32id", "ac3___h", "ac3___name", "ac3_mid", "ac3_oid", "acd_id"], "st": ["td", "ste", "t", "ost", "tt", "start", "it", "cont", "os", "stat", "desc", "h", "sta", "ct", "th", "src", "pt", "sts", "St", "str", "tx", "step", "tr", "ast", "se", "z", "nd", "mt", "sm", "sn", "sth", "rt", "sam", "sh", "sw", "sv", "est", "tmp", "storage", "sc", "stable", "stage", "stack", "rest", "sp", "nt", "std", "ist", "ts", "irst", "form", "store", "inst", "ST", "v", "so", "ut", "art", "sl", "w"], "stream": ["roll", "message", "cont", "source", "length", "filter", "head", "Stream", "driver", "reader", "host", "lo", "video", "ssl", "sw", "REAM", "stage", "path", "port", "upload", "v", "feed", "steam", "ream", "ev", "sl", "chain", "channel", "loop", "present", "response", "context", "readable", "package", "socket", "info", "data", "body", "status", "pod", "sc", "dr", "sequence", "service", "inner", "download", "instance", "t", "time", "view", "load", "writer", "wrapper", "table", "style", "poll", "str", "mount", "spec", "buffer", "stack", "pool", "store", "metadata", "ST", "out", "dd", "record", "field", "window", "transform", "iv", "src", "row", "test", "tr", "version", "pipe", "draw", "console", "http", "form", "iterator"], "audio_bound": ["audio_range", "video_end", "audio_min", "audio_visible", "audioCountbound", "audiollvisible", "meta_min", "audioCountBound", "video_Bound", "video_visible", "audiollbound", "audiollend", "meta_bound", "audio_end", "metaptmin", "meta_range", "audio___min", "audiollBound", "audio___bound", "audioptmin", "metaptrange", "meta_binding", "metaptbinding", "audio_binding", "audioptbound", "audio___binding", "audioCountend", "audioCountvisible", "audio___range", "audioptrange", "audioptbinding", "audio_Bound", "metaptbound"], "video_bound": ["photo_limit", "video_required", "videoptbound", "video32scope", "video32limit", "videombound", "videoptscope", "photoptlimit", "video___scope", "stream_allowed", "video___required", "video___bound", "videomrange", "photoptrequired", "photo_bound", "streammindex", "photoptscope", "video32bound", "streammrange", "videomindex", "photo_required", "videoptrequired", "video_range", "video32required", "videoptlimit", "video_index", "photo_scope", "stream_index", "streammallowed", "photoptbound", "video_allowed", "streammbound", "video_limit", "video___limit", "stream_bound", "videomallowed", "video_scope", "stream_range"]}}
{"project": "FFmpeg", "commit_id": "d7da4d47a6841444f12bf56dfe4230d3e4af8646", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n    int ret;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n    mxf->edit_units_per_packet = 1;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!url_feof(s->pb)) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n\n\n            if (!mxf->current_partition) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            if (!mxf->current_partition->essence_offset) {\n\n                /* for OP1a we compute essence_offset\n\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n\n                 */\n\n                int64_t op1a_essence_offset =\n\n                    round_to_kag(mxf->current_partition->this_partition +\n\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n\n\n                if (mxf->op == OPAtom) {\n\n                    /* point essence_offset to the actual data\n\n                    * OPAtom has all the essence in one big KLV\n\n                    */\n\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n\n                    mxf->current_partition->essence_length = klv.length;\n\n                } else {\n\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n\n                }\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else if (mxf->parsing_backward)\n\n                continue;\n\n            /* we're still parsing forward. proceed to parsing this partition pack */\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n\n\n                    /* only seek forward, else this can loop for a long time */\n\n                    if (avio_tell(s->pb) > next) {\n\n                        av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n\n                               klv.offset);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    /* we need to do this before computing the index tables\n\n     * to be able to fill in zero IndexDurations with st->duration */\n\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n\n        return ret;\n\n\n\n    if (mxf->nb_index_tables > 1) {\n\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    mxf_handle_small_eubc(s);\n\n\n\n    return 0;\n\n}\n", "idx": 23206, "substitutes": {"s": ["p", "t", "sys", "is", "os", "source", "m", "changes", "ns", "ss", "h", "us", "ses", "ims", "stats", "ps", "bs", "https", "x", "cs", "sts", "i", "aws", "gs", "fs", "rs", "c", "sports", "ds", "bis", "z", "scl", "south", "spec", "ls", "details", "ex", "ms", "ssl", "sw", "sv", "ats", "vs", "hs", "self", "S", "js", "es", "g", "ins", "sq", "ts", "its", "http", "webkit", "sg", "conf", "qs", "less", "sb", "b", "as", "v", "sql", "simple"], "mxf": [" mphp", "miffe", "gmxf", "gmxff", "modulecf", " mcolm", "munxf", "appxf", "mifif", "cmxff", " mlf", " mfs", "esmcf", "muncf", "munfo", " mfo", " mxff", "mcfw", "amcf", "Mcf", "Mxf", "Mxff", "lemftime", "mmxf", "mxff", "mcfs", "appfa", "nxc", "mxe", "lemcf", "mmfif", "mafe", "ncf", "modlf", "micf", " mfa", "amfs", "mfif", "appfif", "esmxff", "lemiffe", " mxc", "Mxe", "mmfw", "amxf", "lemphp", "modulexf", "kphp", "rmfa", "rmfif", "munphp", "mcolm", "modulefa", "meancf", "esmxc", "mfw", "modulexe", "gmcf", "rmxc", "cmxf", "cmxc", "Mxc", "mphp", "rmxff", "manfo", "mfs", " mcf", "mfa", "manxf", "manfw", "lemxf", "cmcf", " mfw", " mfif", "moduleafe", "nfa", " mftime", "mccf", "modxff", "mxc", "kxf", "meanxc", "modulexff", " mxe", "Mafe", "mcxf", "rmcf", "kiffe", "modcolm", "amfw", "lemfif", "manfif", " miffe", "Mlf", "nxf", "mftime", "gmcolm", "mmfo", "mcf", "meanfa", "mlf", "Mphp", "kcf", "meanxf", "rmxf", "appxff", " mafe", "modcf", "mixf", "modulefif", "mfo", "Mfo", "miftime", "esmxf", "modxf"], "klv": [" klf", "kelf", "klvl", "keval", "akvl", "kelv", " klif", " kdl", "ktLV", "unkserv", "kval", "ikserv", "oklif", "unkLV", "kserv", "cklev", "ckserv", "cklv", "ukval", "unkvon", "klr", "kdd", "arklev", "ktvl", "uklv", "unkval", "klif", "mklad", "mklu", "cklr", "klu", "ukwd", "kll", "ktll", " kvv", "eklv", "ckLV", " kll", "kvl", "eklif", "mkvP", "ktlv", "kvv", "arklf", "mklv", "Klv", "ckvl", "ukvon", "ekls", "unkwd", "kevP", " kLV", "KLV", "arklr", "kdl", "iklv", "keyvP", "iklev", "arkdd", "klad", "keylad", "kevon", "Kll", "arklvl", "kevv", "arkvv", "kelad", "aklv", "ktdl", "keylv", "kls", "arklu", "kelu", " klu", "arklv", "kwd", " klr", "kewd", "kelev", "ikLV", "kvon", "eklf", "okls", "kvP", " kdd", "unklev", "Kdl", "kLV", "ktvv", "kedd", "akll", "arkLV", "ckvv", "klev", " kls", "oklf", " klev", "klf", " klvl", "oklv", "unklv", "ckll", "akvv", "kelvl", "keylu"], "ret": ["resp", "re", " RET", "rev", "rew", "rem", "Ret", " alt", "val", " continued", "rs", "reset", " fmt", "result", "ft", "rt", " resp", "ral", "alt", "mem", "fin", "nt", "RET", " fin", "ry"], "metadata": ["kw", "definition", "csv", "msg", "dm", "message", "settings", "m", "met", "multi", " m", "ata", "info", "data", "meta", "md", "eta", "xml", "adata", "cmp", "mt", "details", "tmp", "ATA", "properties", "ka", "json", "primary"]}}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23213, "substitutes": {"retval": ["RETVal", "RETvals", "Retpol", "RetVal", " retVal", "RETval", "retVal", " retpol", " retvals", "RETvalue", "retvalue", "retvals", "retpol", "altVal", "Retval", "altvals", "altpol", "altval", " retvalue", "Retvalue", "Retvals"], "msg": ["mess", "message", "tg", "vol", "desc", "m", "err", "mask", "md", "pub", "event", "tmp", "res", "name", "resp", "title", "data", "bytes", "body", "mt", "send", "seq", "mem", "g", "sg", "cmd", "t", "ref", "gm", "mid", "reason", "pkg", "mb", "arg", "str", "args", "tx", "mu", "good", "buf", "ctx", "raw", "ptr", "module", "mg", "bg", "html", "buffer", "trans", "req", "obj", "out", "txt", "mail", "go", "notice", "gz", "arr", "ext", "og", "gs", "img", "nm", "ms", "Msg", "addr", "ch", "doc", "error", "mod", "mn", "cfg", "text"], "flags": ["ports", "bits", "heads", "settings", "kind", "weights", "type", "tags", "acts", "offset", "ints", "FLAG", "keys", "mask", "weight", "times", "fs", "args", "comments", "s", "locks", "frames", "states", "status", "points", "mode", "details", "module", "ms", "utils", "properties", "types", "grades", "levels", "reports", "limits", "ts", "ants", "posts", "modules", "prefix", "Flags", "features", "ags", "options", "actions", "flag", "ensions", "lag", "errors", "fields"], "nchars": [" nChents", " ncharats", "nchaps", "ncharats", "ncolars", " nChars", " nChas", " nchararts", "nChashes", " nChashes", " nChunks", "nscheents", "ncpashes", "nthats", "nscheales", "nchunks", "nchards", "nChaps", "nchants", "nshales", "ncolards", "ncaparts", "nmessunks", "nthars", "nChats", " nchunks", "Ncharts", "nchARS", "nChales", "ncharaps", "nchords", "ncharars", " nchashes", " nchas", "nuchARS", " nchales", "nChars", "ncolaps", "ncolants", "ntharts", "ncharards", "nshents", "nshars", " nChales", " nchARS", "nmessashes", "narchars", "nmessars", "nCharts", "nchents", "NchARS", "nChARS", "Nchords", "nuarchards", "nschearts", "ncapars", "nChas", "nuchants", "nmessARS", "nsharts", "Nchararts", "ncapARS", "nchashes", "ncharants", "nChords", "ncolas", "nChunks", "ncapords", "ncpars", "NcharARS", " nchents", "ncharords", "ncharARS", "nuchards", "nthARS", "ncharas", "narchants", "ncolARS", "nChents", "nchats", " ncharts", "nchales", "nuchars", "ncpARS", " nChaps", "nchararts", "nschears", "nuarchants", "ncpunks", "narchARS", "nchas", " nchats", " ncharars", "nuarchars", " nchaps", "ncharts", " nCharts", " ncharARS", "Nchars", "narchards", "nuarchARS", "Ncharords", " nChARS", "Ncharars"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n", "idx": 23237, "substitutes": {"r": ["er", "p", "re", "rect", "rb", "rc", "mr", "rn", "rev", "role", "red", "nr", "m", "rem", "err", "rel", "ar", "vr", "pair", "rr", "rg", "ro", "e", "rar", "rs", "R", "tr", "fr", "sr", "repl", "br", "rt", "q", "pr", "kr", "res", "rh", "ur", "rm", "dr", "rus", "g", "ren", "rl", "cr", "rec", "l", "attr", "rd"], "r_next": ["r___next", "rc__secondary", "r_prev", "r__Next", "r_env", "rc_next", "r__secondary", "vr_env", " r_path", " r_Next", "r__next", "r_Next", "r__member", "r__path", "r2next", "r___prev", "rc_secondary", " r__data", " r_data", "r_path", "rc_member", "r2secondary", "r2member", "rc_prev", "rc__next", "r__data", " r__next", "r___env", "r_secondary", "vr_prev", "rc__prev", "rc__member", "r__prev", "vr_obj", "r2prev", "r___obj", "r_data", " r__Next", "r_member", " r__path", "vr_next", "r_obj"], "h": ["history", "loop", "phi", "His", "ht", " clen", "he", "it", "ho", "zh", "hh", "ach", " dh", "hal", "H", "oh", " inh", "go", "y", " ph", "hash", "head", "m", "window", "ha", "th", "d", "pl", "x", "i", "pers", "ity", "host", "hd", "j", "hr", "ih", "his", "k", "bh", "hz", "rendered", "html", "ph", "kh", "sh", "hl", "hs", "hm", "rh", "hp", "ch", "g", " hang", "has", "hold", "orth", "ah", "each", "hi", "gh", "ish", " hash", "w"]}}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n", "idx": 23244, "substitutes": {"iscsilun": ["micsilum", "iscstatusund", "iscsevereession", "iscsinun", "iscinelun", "iscisoluno", "iscSilession", "iscstatesund", "iconssilund", "ircsiluna", "iscsilogun", "iscstatusun", "iscSilund", "techsilan", "iscsoluna", "ircsinon", "iscsiluch", "iscsieune", "iscsevereun", "iconssilune", "iscsinon", "techsevereun", "iscsolon", "isksilun", "ircsilun", "iconssilume", "isksilon", "iscsentung", "ircsinun", "iscspellun", "iscsiluno", "iscsilon", "iscsentuch", "iscsilume", "ircsilon", "iscseverean", "iscsentogun", "ischematicun", "iscsqlun", "iscsieund", "iscsqlon", "isksqlun", "iscsilrun", "micsentun", "iscSilun", "iscsinung", "iscspellum", "isksiluch", "techseverean", "iconsstatesun", "iscsilund", "micsentum", "iscsolrun", "iscspellogun", "ircsinuna", "micsentogun", "techsilund", "iscsqlung", "iscsilession", "iconsstatesune", "iscsentun", "micsentuno", "ischematicon", "iscinelune", "iscsenton", "isksqlung", "iscsieume", "iscsolun", "iscsentum", "techsilession", "iscsilum", "iscsiluna", "ircsilrun", "ischematicrun", "micsilogun", "iscstatusession", "iscinelume", "iscsinrun", "iscsentuno", "iscsieun", "iscstatusan", "iscsevereund", "isksilung", "isksqlon", "techsevereession", "micsiluno", "iscstatesune", "isksqluch", "ircsinrun", "ischematicuna", "iscsqluch", "techsilun", "iscstatesun", "iscstatesume", "iscsilan", "iscisologun", "micsilun", "iscsinuna", "iscSilan", "iscsilune", "techsevereund", "iscsilung", "iconsstatesume", "iconssilun", "iscisolun", "iscspelluno", "iscsinuch", "iconsstatesund", "iscinelund", "iscisolum"], "sector_num": ["sector_n", "sector_cal", "sectoripmon", "era_num", "sector_mult", "device_mult", "ector_n", "device_num", "sectoripn", "device_mon", "device_nom", "sector_Num", "ector_num", "sector_mu", "sectoripnum", "sector_mon", "ector_mu", "era_span", "era_Num", "era_cal", "sectoripmu", "sector_nom", "sector_span", "ector_mon"], "nb_sectors": ["nb_seors", "nb_psecs", "nb_pselements", "nb_syors", "nb_spelements", "nb_SEgments", "nb_segments", "nb_sygments", "nb_vegments", "nb_specs", "nb_SEors", "nb_vectors", "nb_veonents", "nb_selements", "nb_veors", "nb_seonents", "nb_speors", "nb_syctors", "nb_SEonents", "nb_velements", "nb_pseors", "nb_syonents", "nb_psectors", "nb_vecs", "nb_secs", "nb_spectors", "nb_SEctors"], "cluster_num": ["clusterAreaNUM", "clusterArean", "cluster____nom", "cluster__num", "cluster_Num", "cluster_nom", "clust_fac", "clutter_div", "clust_n", "clutter_num", "clorable_nu", "clutter__div", "clusterAreanu", "clutter__num", "cluster_n", "clorable_NUM", "clorable_n", "clutter_index", "clust_no", "cluster_index", "clusterIDdiv", "cluster____num", "clust_nom", "clust_Num", "cluster_no", "clusterAreanum", "clorable_num", "clusterIDindex", "clusterIDnum", "clutter__index", "cluster_fac", "cluster____Num", "cluster_nu", "cluster_NUM", "cluster_div", "clust_num", "cluster____fac", "cluster__div", "cluster__index"], "nb_clusters": ["nb_brusters", "nb_allients", "nb_slows", "nb_occuster", "nb_clients", "nb_plows", "nb_clashes", "nb_occusters", "nb_allocations", "nb_slusters", "nb_clores", "nb_chuster", "nb_pluster", "nb_occashes", "nb_clanches", "nb_brocations", "nb_cikers", "nb_cluster", "nb_slores", "nb_chashes", "nb2plores", "nb_chusters", "nb_clocations", "nb_Cluster", "nb_plores", "nb_planches", "nb_occanches", "nb_plashes", "nb_Clows", "nb_Clusters", "nb_allusters", "nb_clikers", "nb2clusters", "nb2clows", "nb2cluster", "nb_sluster", "nb_cients", "nb_brikers", "nb_cocations", "nb2pluster", "nb_chanches", "nb2plows", "nb2plusters", "nb2clores", "nb_Clores", "nb_clows", "nb_custers", "nb_plusters", "nb_allikers", "nb_brients"]}}
{"project": "qemu", "commit_id": "e511b4d783c47a32420da802104cfb0eb974b22f", "target": 0, "func": "int cpu_exec(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n#endif\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    uintptr_t next_tb;\n\n    SyncClocks sc;\n\n\n\n    /* This must be volatile so it is not trashed by longjmp() */\n\n    volatile bool have_tb_lock = false;\n\n\n\n    if (cpu->halted) {\n\n        if (!cpu_has_work(cpu)) {\n\n            return EXCP_HALTED;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    current_cpu = cpu;\n\n\n\n    /* As long as current_cpu is null, up to the assignment just above,\n\n     * requests by other threads to exit the execution loop are expected to\n\n     * be issued using the exit_request global. We must make sure that our\n\n     * evaluation of the global value is performed past the current_cpu\n\n     * value transition point, which requires a memory barrier as well as\n\n     * an instruction scheduling constraint on modern architectures.  */\n\n    smp_mb();\n\n\n\n    if (unlikely(exit_request)) {\n\n        cpu->exit_request = 1;\n\n    }\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n    cpu->exception_index = -1;\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n\n            /* if an exception is pending, we execute it here */\n\n            if (cpu->exception_index >= 0) {\n\n                if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = cpu->exception_index;\n\n                    if (ret == EXCP_DEBUG) {\n\n                        cpu_handle_debug_exception(env);\n\n                    }\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    cc->do_interrupt(cpu);\n\n#endif\n\n                    ret = cpu->exception_index;\n\n                    break;\n\n#else\n\n                    cc->do_interrupt(cpu);\n\n                    cpu->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = cpu->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        cpu->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        cpu->halted = 1;\n\n                        cpu->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                        cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n                        do_cpu_init(x86_cpu);\n\n                        cpu->exception_index = EXCP_HALTED;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#else\n\n                    if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n                        cpu_reset(cpu);\n\n                    }\n\n#endif\n\n                    /* The target hook has 3 exit conditions:\n\n                       False when the interrupt isn't processed,\n\n                       True when it is, and we should restart on a new TB,\n\n                       and via longjmp via cpu_loop_exit.  */\n\n                    if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                        next_tb = 0;\n\n                    }\n\n                    /* Don't use the cached interrupt_request value,\n\n                       do_interrupt may have updated the EXITTB flag. */\n\n                    if (cpu->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(cpu->exit_request)) {\n\n                    cpu->exit_request = 0;\n\n                    cpu->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit(cpu);\n\n                }\n\n                spin_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = true;\n\n                tb = tb_find_fast(env);\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tcg_ctx.tb_ctx.tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tcg_ctx.tb_ctx.tb_invalidated_flag = 0;\n\n                }\n\n                if (qemu_loglevel_mask(CPU_LOG_EXEC)) {\n\n                    qemu_log(\"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));\n\n                }\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~TB_EXIT_MASK),\n\n                                next_tb & TB_EXIT_MASK, tb);\n\n                }\n\n                have_tb_lock = false;\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                cpu->current_tb = tb;\n\n                barrier();\n\n                if (likely(!cpu->exit_request)) {\n\n                    trace_exec_tb(tb, tb->pc);\n\n                    tc_ptr = tb->tc_ptr;\n\n                    /* execute the generated code */\n\n                    next_tb = cpu_tb_exec(cpu, tc_ptr);\n\n                    switch (next_tb & TB_EXIT_MASK) {\n\n                    case TB_EXIT_REQUESTED:\n\n                        /* Something asked us to stop executing\n\n                         * chained TBs; just continue round the main\n\n                         * loop. Whatever requested the exit will also\n\n                         * have set something else (eg exit_request or\n\n                         * interrupt_request) which we will handle\n\n                         * next time around the loop.\n\n                         */\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        next_tb = 0;\n\n                        break;\n\n                    case TB_EXIT_ICOUNT_EXPIRED:\n\n                    {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n", "idx": 23245, "substitutes": {"env": ["er", "en", "cap", "rc", "org", "context", "et", "cb", "window", "init", "enc", "serv", "con", "e", "conn", "cv", "vm", "node", "ec", "proc", "hw", "ctx", "here", "environment", "ve", "server", "vs", "bean", "viron", "dev", "erd", "esp", "config", "cmd", "conf", "site", "ew", "erc", "nv", "eng", "v", "vp", "net", "ev", "vt"], "cpu": ["ck", "pie", "process", "pixel", "policy", "goal", "ruby", "none", "cum", "vm", "node", "reset", " CPU", "jp", "cli", "nu", "worker", "aux", "server", "clock", "bean", "component", "util", "client", "local", "name", "gpu", "ilo", "cn", "stat", "device", "thread", "program", "prof", "pp", "cs", "copy", "socket", "cmp", "coin", "environment", "hz", "num", "apache", "ka", "cf", "mem", "mx", "runner", "pc", "uu", "cmd", "cam", "computer", "cp", "network", "instance", "core", "sys", "frame", "exec", "gc", "pkg", "total", "cu", "cv", "currency", "c", "ec", "proc", "hw", "ip", "mac", "library", "ctx", "bo", "kernel", "utils", "docker", "rpm", "np", "pool", "cache", "linux", "nc", "comp", "nan", "en", "python", "alloc", "processor", "boot", "tp", "window", "ct", "bench", "physical", "conn", "php", "que", "profile", "pu", "race", "CPU", "phys"], "cc": ["ucc", "rc", "ck", "func", "cb", "css", "dc", "co", "ac", "gc", "ct", "CC", "cs", "bc", "cu", "ctrl", "conn", "cv", "uc", "c", "cl", "ec", "cmp", "ctx", "cell", "icc", "ssl", "cci", "lc", "cf", "ci", "mc", "pc", "tc", "cache", "nc", "acc", "ctl", "fc", "cp", "xc"], "x86_cpu": ["x85_cpu", "x85_cp", "x85_pu", "x86_cp", "x85_comp", "x86_pu", "x86_comp"], "ret": ["gt", "resp", " Ret", "t", "re", " RET", "prot", "sys", "out", "rev", "det", "cat", "cont", "ref", "back", "rets", "rem", "err", "hash", "Ret", "val", "inter", "url", "nz", "arg", "def", "ter", "ert", "eth", "str", "reset", "tr", "status", "result", "mt", "success", "ft", "rt", "vet", "res", "alt", "rm", "mem", "nt", "RET", "std", "len", "ll", "elt", "flag", "net"], "interrupt_request": ["interrupt_Request", "interrupt_flag", "interrupted_request", "interrupterrequest", "interrupted_required", "interrupt_question", "interrupt__response", "interrupt2response", "interrupt_req", "interruption2response", "intercept___mask", "interruptationtype", "interruption2type", "interruptablecomplete", "interruptThemask", "interruptederpair", "interrupt___mask", "interrupt2type", "interrupt_query", "interruptableRequest", "interruptablerequest", "interrupt__request", "intercept___request", "interruption2request", "intercept_request", "interruptingrequest", "interrupt_required", "interrupt___req", "interrupterrequired", "interrupt2request", "interrupt_complete", "interruptablepair", "interrupt_index", "interruptederrequired", "interruption__response", "interruption_request", "intercept_match", "interrupted_pair", "interruptTheflag", "interruption_type", "interruptationquery", "interpress_req", "interruptingevent", "interruption2query", "intercept___flag", "interrupt__question", "interruptThematch", "interruptationrequest", "interrupt_match", "interpress_event", "interrupt_type", "interrupt_mask", "interrupt_event", "interpress_request", "intercept___match", "interrupterpair", "interrupt___complete", "interruption_response", "interruption_index", "interruptablerequired", "interrupt_pair", "interruption_question", "interrupt_response", "interruptationresponse", "interrupt___match", "interruptTherequest", "interrupt2query", "interruption__index", "interruptablereq", "interrupt___request", "interrupt___flag", "interruptederrequest", "intercept_mask", "interrupt___Request", "interruption__question", "interruptingreq", "interruption_query", "intercept_flag", "interrupt__index", "interruption__request"], "tb": ["ptbar", "rtbar", "ptbe", "ptb", "tt", "rtbe", " tbar", "tbar", "rtb", "tbe", "ptt", " tbe", " tt", "rtt"], "tc_ptr": ["TC_tr", "TC_pointer", "tc_pointer", "TC__addr", "tc__addr", "tc_addr", "TC_ptr", "TC__tr", "tc__pointer", "tc__ptr", "tc_tr", "TC__ptr", "TC_addr", "TC__pointer", "tc__tr"], "next_tb": ["next_outbe", "next_tbr", "next2tbl", "next2mbe", "next_mbl", "next_tbl", "next_cbe", "next_mbr", "next_tsbr", "next_tsb", "next2tbe", "next_lb", "next_cbr", "next_tbe", "next2mb", "next_outb", "next2mbr", "next_mbe", "next_mb", "next_lbr", "next_outbr", "next_cb", "next_lbl", "next2tb", "next_tsbe", "next2mbl", "next2tbr", "next_outbl", "next_cbl", "next_tsbl", "next_lbe"], "sc": ["sch", "isc", "sys", "rc", "Sc", " ss", "dc", "ss", "sd", "sync", "gc", "ct", "cs", "bc", " esc", "uc", "c", "cl", "esc", "ec", "cmp", "scl", " ec", "osc", "ctx", "sv", "sh", "sw", "lc", "ch", "sq", "sp", "mc", "pb", "pc", "tc", "sb", "fc", "SC"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "substitutes": {"str": ["t", "sys", "msg", "quote", "txt", "vc", "r", "source", "index", "list", "vol", "window", "ns", "length", "err", "enc", "arr", "ext", "cs", "i", "st", "s", "cur", "tr", "fr", "buf", "spec", "ptr", "br", "pr", "seq", "STR", "buffer", "addr", "service", "dr", "sp", "gr", "stri", "prefix", "pos", "len", "pre", "input", "b", "Str", "ctr", "chain", "text"], "endptr": ["endPtr", "endproc", "endedpt", "Endaddr", "ENDptr", "endaddr", "ENDpointer", "endedexpr", "EndPtr", " endPtr", " endaddr", " endexpr", "Endpointer", "endedptr", "ndptr", "endpointer", "ndpointer", "endedaddr", "hendpointer", "endedpointer", " endpointer", "endexpr", "endedproc", "hendpt", "hendptr", " endpt", "endpt", "Endptr", "ENDaddr", " endproc", "ndproc", "ndexpr", "ENDPtr", "hendaddr"], "res": ["cons", "resp", "rez", "re", "p", "out", "ires", "rc", "rev", "ret", "r", "red", "vol", "os", "rem", "err", "rel", "val", "ps", "bs", "RES", "resolution", "cs", "results", "i", "rs", "des", "pres", "result", "ress", "resh", "pr", "ms", "Res", "vals", "reg", "js", "rest", "ts", "gr", "nt", "obj", "ser", "RS", "pas"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 23250, "substitutes": {"ysrc": ["iesource", "syssrc", "ysource", "nsrc", "mysusc", "ysusc", "nsr", "esusc", "yssrc", "mysource", "nsusc", "nssrc", "sysrc", "sysusc", "iesusc", "essrc", "ysr", "myssrc", "iesr", "iesrc", "esource", "mysrc", "sysr", "esrc", "iessrc"], "usrc": [" usirc", "usessrc", " ussrc", " usurg", "ussrc", "umsurg", "umsirc", "usurg", "Ussrc", "ossrc", "usesrc", " usource", "osurg", "osirc", "osrc", "usesource", "Usrc", "usource", "usirc", "umsrc", "Usource", "umssrc"], "vsrc": [" vstr", " vst", "pst", " vrs", "fst", "psrc", "ssource", " vrc", "vrc", "wsource", "src", "srs", "fstr", "ssrc", "wsrc", "vstr", "wrs", "prc", "pstr", "vst", "vsource", "frc", "vrs", " vsource", "fsrc", "wrc"], "dst": ["fdest", "fst", "lrest", "lput", " dput", "vput", "didtt", "didnd", "ddest", "lst", "drest", "ldest", "vrest", "didst", "vdest", "dsnd", "diddest", "dnd", " drest", "dtt", "vst", "fnd", "dsdest", "dstt", " ddest", "dsst", "ftt", "dput"], "height": ["density", "volume", "history", "radius", "hang", "build", "inches", "ht", "he", "zh", "depth", "wh", "ows", "h", "length", "y", "window", "th", "count", "cy", "rows", "resolution", "headers", "Height", "dim", "size", " heights", "HH", "family", "hei", "ih", "yt", "gravity", "hz", "html", "shape", "uh", "ty", "stroke", "gy", "gh", "hi", "dist", "w"], "lumStride": ["lumLide", "lumLrid", "lomStide", "lomStride", "limStrr", "limStrrate", "lumSTride", "limStide", "limStrride", "lumstide", "lumstride", "lumSTrate", "lumStrrid", "lumstr", "lomStrrid", "limStride", "lumSTide", "limStr", "lomStrride", "limStrate", "lumLride", "lumLr", "lumStr", "lumSTr", "lumstrate", "lomStrr", "lumStrid", "lumStrrate", "lumstrid", "lumStrride", "lumStide", "lumStrate", "lumStrr", "lomStr", "lomStrid"], "chromStride": ["romStrange", "chromSlride", "romStrip", "chromStide", "chromStrrip", "romStrrange", "chromSlrid", "chromstr", "romStrride", "romStrrid", "chromSlide", "chromSpide", "chromStrrange", "chromstrip", "chromSpr", "chromStrride", "chromStrrid", "chromSlrange", "chromStrid", "romStide", "chromstride", "chromStrange", "chromSTrange", "chromSpride", "chromstide", "romStrid", "chromStrip", "romStr", "romStrr", "chromSprip", "romStrrip", "chromStr", "chromStrr", "chromSTrid", "chromSTride", "chromSTide", "romStride"], "dstStride": ["dstStrip", "dndStr", "dststr", "dndStride", "dstRestno", "dndStrr", "dstStrride", "dstRestr", "dststride", "destStride", "dstStrno", "destStrr", "destStide", "dststide", "dstRestrip", "dstStide", "dstRestide", "destStrrip", "dstRestride", "dstStr", "destStrride", "dndStrno", "dststno", "dstStrr", "destStr", "dststrip", "dndStno", "dstStno", "dndStrride", "dstStrrip", "destStrip", "dndStide"]}}
{"project": "FFmpeg", "commit_id": "b7d9b4a1f1fcd01084ccbec6f7ef32c853681833", "target": 1, "func": "int ff_h263_decode_mb(MpegEncContext *s,\n                      int16_t block[6][64])\n{\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    const int xy= s->mb_x + s->mb_y * s->mb_stride;\n    int cbpb = 0, pb_mv_count = 0;\n    av_assert2(!s->h263_pred);\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        do{\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for(i=0;i<6;i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->mb_skipped = !(s->obmc | s->loop_filter);\n                goto end;\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 20);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra) goto intra;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n            cbpy ^= 0xF;\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n            /* 16x16 motion prediction */\n            s->mv_type = MV_TYPE_16X16;\n            ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n            if (s->umvplus)\n               mx = h263p_decode_umotion(s, pred_x);\n            else\n               mx = ff_h263_decode_motion(s, pred_x, 1);\n            if (mx >= 0xffff)\n            if (s->umvplus)\n               my = h263p_decode_umotion(s, pred_y);\n            else\n               my = ff_h263_decode_motion(s, pred_y, 1);\n            if (my >= 0xffff)\n            s->mv[0][0][0] = mx;\n            s->mv[0][0][1] = my;\n            if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n               skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type = MV_TYPE_8X8;\n            for(i=0;i<4;i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                  skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                mot_val[0] = mx;\n                mot_val[1] = my;\n    } else if(s->pict_type==AV_PICTURE_TYPE_B) {\n        int mb_type;\n        const int stride= s->b8_stride;\n        int16_t *mot_val0 = s->current_picture.motion_val[0][2 * (s->mb_x + s->mb_y * stride)];\n        int16_t *mot_val1 = s->current_picture.motion_val[1][2 * (s->mb_x + s->mb_y * stride)];\n//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;\n        //FIXME ugly\n        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=\n        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=\n        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=\n        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;\n        do{\n            mb_type= get_vlc2(&s->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);\n            if (mb_type < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b mb_type damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            mb_type= h263_mb_type_b_map[ mb_type ];\n        }while(!mb_type);\n        s->mb_intra = IS_INTRA(mb_type);\n        if(HAS_CBP(mb_type)){\n            s->bdsp.clear_blocks(s->block[0]);\n            cbpc = get_vlc2(&s->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);\n            if(s->mb_intra){\n                dquant = IS_QUANT(mb_type);\n                goto intra;\n            cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n            if (cbpy < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n                cbpy ^= 0xF;\n            cbp = (cbpc & 3) | (cbpy << 2);\n        }else\n            cbp=0;\n        av_assert2(!s->mb_intra);\n        if(IS_QUANT(mb_type)){\n            h263_decode_dquant(s);\n        if(IS_DIRECT(mb_type)){\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type |= set_direct_mv(s);\n        }else{\n            s->mv_dir = 0;\n            s->mv_type= MV_TYPE_16X16;\n//FIXME UMV\n            if(USES_LIST(mb_type, 0)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                s->mv_dir = MV_DIR_FORWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n            if(USES_LIST(mb_type, 1)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 1, &pred_x, &pred_y);\n                s->mv_dir |= MV_DIR_BACKWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[1][0][0] = mx;\n                s->mv[1][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do{\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 8);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\nintra:\n        s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n        if (s->h263_aic) {\n            s->ac_pred = get_bits1(&s->gb);\n            if(s->ac_pred){\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n                s->h263_aic_dir = get_bits1(&s->gb);\n        }else\n            s->ac_pred = 0;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(cbpy<0){\n            av_log(s->avctx, AV_LOG_ERROR, \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        pb_mv_count += !!s->pb_frame;\n    while(pb_mv_count--){\n        ff_h263_decode_motion(s, 0, 1);\n        ff_h263_decode_motion(s, 0, 1);\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (h263_decode_block(s, block[i], i, cbp&32) < 0)\n            return -1;\n        cbp+=cbp;\n    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)\n        return -1;\n    if(s->obmc && !s->mb_intra){\n        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)\n            preview_obmc(s);\nend:\n        /* per-MB end of slice check */\n    {\n        int v= show_bits(&s->gb, 16);\n        if (get_bits_left(&s->gb) < 16) {\n            v >>= 16 - get_bits_left(&s->gb);\n        if(v==0)\n            return SLICE_END;\n    return SLICE_OK;", "idx": 23256, "substitutes": {"s": ["ports", "is", "ims", "ops", "sts", "ds", "details", "sv", "sw", "hs", "es", "ins", "als", "ants", "less", "sb", "as", "v", "n", "re", "a", "os", "stat", "changes", "ns", "words", "bs", "cs", "results", "aws", "fs", "bis", "ions", "states", "se", "status", "ers", "sets", "ats", "vs", "views", "self", "has", "ts", "gets", "sg", "ags", "qs", "tes", "events", "comm", "t", "sys", "settings", "ears", "orders", "ows", "stats", "ps", "services", "comments", "c", "spec", "ls", "S", "its", "store", "save", "serv", "p", "set", "parts", "h", "ss", "ses", "eps", "sports", "rs", "gs", "test", "pers", "south", "ms", "sam", "js", "sq", "an", "news", "w"], "block": ["icon", "out", "pack", "frame", "record", "pixel", "field", "check", "ref", "value", "window", "channel", "object", " frame", "key", "image", "arr", "label", "code", "row", "bit", "byte", "band", "profile", "base", "Block", "lock", "img", "pipe", " bl", "raw", "word", "link", "map", "buffer", "box", "config", "blocks", "obj", "bin", "line", "flag", "point", "chain", "type"], "cbpc": ["sbfc", "nbfc", "ebpr", "bcpc", "nbcc", "cvcp", "cbcc", "rbproc", "nbproc", "cbpn", "fbpc", "cvpic", "sbpc", "rbcp", "cvpx", "ebpn", "cbproc", "rbfc", "erbpx", "sbproc", "nbcp", "ebcp", "cbpx", "rbcc", "nbbc", "bccp", "ebpc", "fbcp", "cvpc", "cvcc", "erbpn", "cvproc", "fbpic", "cbfc", "erbcc", "fbfc", "rbbc", "cbbc", "sbbc", "cbcp", "erbproc", "bcpn", "nbpc", "rbpx", "erbcp", "cbpr", "erbpr", "rbpic", "erbpc", "erbfc", "bcpr", "cbpic", "rbpc", "cvfc"], "cbpy": ["rbpy", "rbpr", "cbpm", "cvpm", "erbpy", "cbpo", "cvpr", "cvpy", "erbpo", "cbpr", "erbpm", "cvpo", "rbpo", "erbpr", "rbpm"], "i": ["bi", "ij", "n", "p", "phi", "is", "ic", "it", "si", "me", "index", "di", "iu", "ai", "xi", "f", "m", "go", "ix", "y", "init", "multi", "ji", "im", "zi", "ei", "x", "id", "ind", "sim", "gi", "info", "span", "I", "qi", "ki", "ti", "j", "ip", "ini", "cli", "status", "li", "ia", "ui", "fi", "gu", "oi", "ir", "in", "ci", "g", "mi", "ii", "pi", "hi", "l"], "cbp": ["cvf", "cbf", "cvpc", "gbpy", "cvpy", "gbp", "gbf", "pbf", "pbpc", "gbpc", "cvp", "pbpy", "pbp"], "pred_x": ["pred__ex", "pred__x", "pred00ex", "pred__xi", " pred_ex", "pred_ex", "pred00xi", " pred00ex", "pred00x", " pred00y", "pred00y", " pred_xi", " pred00xi", "pred__y", " pred00x", "pred_xi"], "pred_y": ["ref_cy", "ref_x", "pred_cy", "ref_py", "pred_py", "ref_y"], "mx": ["fx", "mk", "mr", "dm", "mm", "tp", "ox", "ml", "yx", "mp", "vm", "mu", "tx", "mac", "xp", "mt", "zx", "wx", "ms", "px", "xs", "mc", "mi", "mic", "tm", "ma", "mn", "xc"], "my": ["yy", "sys", "yo", "py", "sym", "mm", "ys", "gm", "mid", "ml", "yx", "fy", "cy", "ny", "md", "mt", "nm", "ms", "mon", "mc", "ym", "mi", "ty", "mys", "ky", "gy", "mn"], "dquant": ["dqu", "dimp", "jvalid", " dQuant", "limp", "dint", "jquant", "lQuant", " dimp", " dvalid", "domQuant", " dqu", " dint", "jint", "dQuant", "domquant", "lquant", "lqu", "Dvalid", "DQuant", "domqu", "Dquant", "jQuant", "domimp", "Dint", "dvalid"], "mot_val": ["mot_cal", "mot2Val", "ref2value", "mot_value", "ref2val", "motvval", "ref_Val", "ref_value", "motvVal", "mot2cal", "mot2val", "ref2Val", "ref_cal", "motvvalue", "motvcal", "ref_val", "mot2value", "mot_Val", "ref2cal"], "mb_type": ["mb_index", "emb_size", "mb_size", "emb_index", "emb_type", "emb_tag", "mb_tag"], "pb_mv_count": ["pb_mvxcount", "pb_mV2found", "pb_mv__counter", "pb_mvxfound", "pb_mx_Count", "pb_mV_sum", "pb_mx_count", "pb_mx_found", "pb_mv2found", "pb_mv2index", "pb_mV_index", "pb_mV_found", "pb_mvxsum", "pb_mv2Count", "pb_mx_counter", "pb_mV2index", "pb_mv_index", "pb_mv_found", "pb_mv2sum", "pb_mv_sum", "pb_mx2found", "pb_mV_count", "pb_mV2count", "pb_mv__found", "pb_mv2count", "pb_mv2counter", "pb_mx2count", "pb_mV2sum", "pb_mvxindex", "pb_mv__count", "pb_mx2Count", "pb_mv_counter", "pb_mv_Count", "pb_mx2counter", "pb_mv__Count"]}}
{"project": "FFmpeg", "commit_id": "92fabca427ff2d8fffa4bd4f09839d8d3822ef31", "target": 0, "func": "static void DEF(put, pixels16_x2)(uint8_t *block, const uint8_t *pixels, ptrdiff_t line_size, int h)\n\n{\n\n    MOVQ_BFE(mm6);\n\n    __asm__ volatile(\n\n        \"lea        (%3, %3), %%\"REG_a\" \\n\\t\"\n\n        \".p2align 3                     \\n\\t\"\n\n        \"1:                             \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"subl   $4, %0                  \\n\\t\"\n\n        \"jnz    1b                      \\n\\t\"\n\n        :\"+g\"(h), \"+S\"(pixels), \"+D\"(block)\n\n        :\"r\"((x86_reg)line_size)\n\n        :REG_a, \"memory\");\n\n}\n", "idx": 23259, "substitutes": {"block": ["volume", "name", "p", "view", "pack", "ck", "frame", "mm", "field", "device", "length", "hash", "PC", "object", "image", "board", "label", "mask", "row", "bit", "size", "cl", "byte", "kl", "proc", "ip", "Block", "lock", "pen", "word", "map", "buffer", "mem", "pc", "blocks", "line", "cp", "header", "chain", "type"], "pixels": ["apixels", "Piles", "Pixels", "pixel", "ipiles", "ipixel", "pix", " piles", "apixel", "ipixels", "spixel", "spixels", "ipix", "spiles", "Pix", "piles", "apix", " pixel", "spix", "Pixel", "apiles", " pix"], "line_size": ["line1scale", "line_length", "line_scale", "line_count", "block_scale", "block_count", "block_size", "Line_SIZE", "line1size", "Line_size", "line_SIZE", "line1count", "Line_length", "Line_ize", "line_ize"], "h": ["history", "p", "t", "end", "ht", "it", "he", "oid", "H", "f", "oh", " inh", "m", "y", "head", "hash", "th", "d", " H", "c", "handle", "height", "ih", "ptr", "k", "bh", "kh", "hl", "hs", "help", "uh", "hold", "hidden", "v", "header", "w"]}}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274, "substitutes": {"idstr": ["idStr", "cmdstring", "pidstring", "pidSTR", "keyfr", "vidstr", "idfr", "pidbr", "ridstr", " idbr", " idst", "oidStr", "refdr", "keyStr", "pidStr", "idstring", "ridSTR", "oidst", "oidstring", "pidst", "vidstring", " iddr", "idbr", "idSTR", "idst", "sidst", "keySTR", " idfr", "cmdSTR", " idSTR", "hchar", "sidbr", "hstr", "sidSTR", "refstr", "hbr", " idstring", "hstring", "idchar", "keystr", "refp", "piddr", "vidbr", "sidstr", "cmdstr", "keystring", "pidfr", "iddr", "pidchar", "ridst", "ridbr", "vidchar", "oidstr", "pidp", "refstring", " idStr", "idp", "cmdfr", " idp", "pidstr"], "instance_id": ["ances8source", "command_oid", "ances_id", "commandityid", "ance_ids", "instance_data", "Instance_Id", "instance__ID", "commandityoid", "ances_source", "instance_source", " instance_name", " instance_str", "instance_oid", "ance_Id", " instance_ID", "instance_pid", " instance_data", "instance_state", "ances8info", "instance__n", "ances_info", "instance__id", "instanceityname", "instancelename", "instanceityoid", "instance_n", "instanceNameinfo", "instance_info", "instance_str", "instance_Id", "node_oid", "Instance_ids", "instance__ids", "command_state", "instanceitymain", "ances8id", "instance__pid", "instanceledata", "node_pid", "instance_ad", "instance_main", "ances_ad", "instance_name", "ance_pid", "node_url", " instance_pid", "instance8info", "instance__info", "instanceitystate", "ances8ad", "Instance_ide", "command_id", "ance_id", "ance_info", "instanceitydata", " instance_main", "commanditystate", "instance__url", "ance_n", "instance_ide", "instanceityid", "instancelemain", "instanceleid", "instance8id", "instanceNamead", "instance_ids", "instance__oid", "instance_ID", "instanceNameid", "ance_ID", "instance_url", "node_id", "instanceNamesource", " instance_Id", "Instance_id", "instance__Id", "instance8ad", "instance8source"], "version_id": ["version___no", "versionableno", "versiondbId", "version_with", "version_no", "versionablewith", "missiondbid", "version___db", "versioningdir", "missiondbinfo", "mission_id", "mission_Id", "version_state", "version___id", "version_db", "missiondbId", "versionableid", "version___with", "sequence_name", "missiondbstate", "sequence_str", "sequence_dir", "section_no", "version_str", "sequence_id", "versiondbinfo", "versionalid", "versioningid", "version_Id", "version_dir", "versiondbid", "version_name", "versionalname", "versioningstr", "version_info", "section_id", "versionalstr", "versioningname", "versiondbstate", "section_with", "mission_info", "versionabledb", "versionaldir", "section_db", "mission_state"], "save_state": ["savealstate", "saveistinit", "saveistscope", "save_function", "saveophistory", "savelystates", "copy_function", "save_point", "saveiststate", "load_history", "savealevent", "copy_state", "savelyscope", "savelyfunction", "saveopstat", "save_history", "copylystate", "saveopstate", "save_event", "savelystate", "save___stat", "sign_init", "signlyinit", "copylyevent", "copy_states", "load_stat", "save___policy", "save_init", "save_policy", "savelyevent", "copylystates", "saveoppolicy", "signlyscope", "save_scope", "copy_event", "savealfunction", "saveistpoint", "sign_scope", "load_policy", "sign_point", "sign_state", "savelyinit", "signlystate", "save_states", "save___state", "signlypoint", "savealstates", "copylyfunction", "savelypoint", "save_stat", "save___history"], "load_state": ["load_private", "loadportstorage", " load_data", "loadlytype", "checkfulpolicy", "check_info", "check_policy", "load_type", "loadingprivate", "loadingstate", " load_policy", "check_state", "load_data", "load_storage", "loadtdata", "loadtlock", " load_lock", "loadfulstate", "check_space", "loadingtype", "loadtstorage", "loadingpolicy", "checkfulspace", "loadportdata", "loadlyprivate", "loadfulinfo", " load_type", "loadfulpolicy", "loadportstate", "load_policy", "checkfulinfo", "loadlystate", " load_private", "checkfulstate", "loadtstate", "loadlypolicy", "load_lock", " load_storage", "load_info", "loadportlock", "load_space", "loadfulspace"], "opaque": ["ipascript", "ipsolete", "operity", "oppacity", "opatile", "operaques", "Opascript", "ipatile", "opsolete", "ipaques", "Opsolete", "ipacity", "paques", "ipity", " opsolete", "opity", "oppatile", "ipaque", "oppaques", " opacity", "Opaque", "pacity", "Opacity", "opacity", "opascript", "opaques", "paque", "patile", "operatile", "oppaque", "pity", "operaque", " opascript"], "se": ["ele", "ce", "su", "th", "esse", "Se", "ape", "des", "ose", "cle", "server", "sv", "spe", "pe", "ess", "es", "sb", "ser", "sche", "ene", "sl", "sel", "si", "me", "te", "ze", "e", "see", "send", "est", "entry", "de", "ae", "ode", "ede", "ace", "SE", "sa", "ade", "session", "sd", "ase", "ice", "parse", "ke", "ve", "sh", "she", "we", "sea", "sp", "ree", "store", "el", "so", "sed", "isse", "ese", "ide", "sec", "set", "ses", "al", "sle", "ie", "ge", "le", "lex", "ine", "ane", "ense", "ne", "sem", "are"], "pse": ["expr", "ele", "spr", "pt", "mp", "reme", "pa", "ose", "jp", "asi", "ress", "fr", "spe", "pe", "prime", "next", "ste", "der", "py", "PS", "me", "te", "pose", "pm", "perse", "ppe", "prof", "trace", "meet", "pres", "phe", "pol", "pr", "ph", "seq", "bes", "ae", "ffe", "ace", "PE", "gre", "cp", "pas", "alse", "proxy", "paste", "sa", "ase", "ps", "po", "pri", "pret", "isi", "proc", "parse", "ptr", "ve", "peg", "ja", "sp", "req", "esi", "press", "p", "tp", "pex", "ge", "lex", "pty", "pipe", "ne", "gp", "bp", "phys", "pic"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "substitutes": {"klass": ["kkls", "skls", "Klass", " kclass", "skclass", "kklass", "iklass", "skcl", "kcl", "ikls", "Kls", "ikclass", "kklasses", "Kube", "Klasses", "sklass", "kclass", "klasses", " kube", " kcl", " kls", "kube", "kkube", " klasses", "kls", "ikcl"], "data": ["name", "state", " sd", "di", "rew", "value", "init", "d", "ata", "key", "id", "def", "mu", " Data", "result", "DATA", "module", "dat", "res", "new", "Data", " DATA", "json", "bin", "da", "attr", "w"], "dc": ["DC", "dm", "cat", "di", "dd", "desc", "iac", "cca", "disc", "ac", "gc", "ct", "d", "bc", "cu", "cd", "cp", "controller", "c", "currency", "uc", "ec", "ip", "mac", "ga", "df", "design", "cci", "draw", "nic", "dp", "lc", "cm", "sc", "adr", "cf", "dr", "mc", "pc", "cr", "tc", "cmd", "nc", "cc", "comp", "ca", "fc", "erc", "da", "oc"]}}
{"project": "FFmpeg", "commit_id": "042ef4b720f5d3321d9b7eeeb2067c671d5aeefd", "target": 1, "func": "static int decode_mb_cavlc(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;\n\n    int partition_count;\n\n    unsigned int mb_type, cbp;\n\n    int dct8x8_allowed= h->pps.transform_8x8_mode;\n\n\n\n    s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?\n\n\n\n    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);\n\n    cbp = 0; /* avoid warning. FIXME: find a solution without slowing\n\n                down the code */\n\n    if(h->slice_type != I_TYPE && h->slice_type != SI_TYPE){\n\n        if(s->mb_skip_run==-1)\n\n            s->mb_skip_run= get_ue_golomb(&s->gb);\n\n\n\n        if (s->mb_skip_run--) {\n\n            if(FRAME_MBAFF && (s->mb_y&1) == 0){\n\n                if(s->mb_skip_run==0)\n\n                    h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n                else\n\n                    predict_field_decoding_flag(h);\n\n            }\n\n            decode_mb_skip(h);\n\n            return 0;\n\n        }\n\n    }\n\n    if(FRAME_MBAFF){\n\n        if( (s->mb_y&1) == 0 )\n\n            h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n    }else\n\n        h->mb_field_decoding_flag= (s->picture_structure!=PICT_FRAME);\n\n\n\n    h->prev_mb_skipped= 0;\n\n\n\n    mb_type= get_ue_golomb(&s->gb);\n\n    if(h->slice_type == B_TYPE){\n\n        if(mb_type < 23){\n\n            partition_count= b_mb_type_info[mb_type].partition_count;\n\n            mb_type=         b_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 23;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else if(h->slice_type == P_TYPE /*|| h->slice_type == SP_TYPE */){\n\n        if(mb_type < 5){\n\n            partition_count= p_mb_type_info[mb_type].partition_count;\n\n            mb_type=         p_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 5;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else{\n\n       assert(h->slice_type == I_TYPE);\n\ndecode_intra_mb:\n\n        if(mb_type > 25){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"mb_type %d in %c slice too large at %d %d\\n\", mb_type, av_get_pict_type_char(h->slice_type), s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n        partition_count=0;\n\n        cbp= i_mb_type_info[mb_type].cbp;\n\n        h->intra16x16_pred_mode= i_mb_type_info[mb_type].pred_mode;\n\n        mb_type= i_mb_type_info[mb_type].type;\n\n    }\n\n\n\n    if(MB_FIELD)\n\n        mb_type |= MB_TYPE_INTERLACED;\n\n\n\n    h->slice_table[ mb_xy ]= h->slice_num;\n\n\n\n    if(IS_INTRA_PCM(mb_type)){\n\n        unsigned int x, y;\n\n\n\n        // We assume these blocks are very rare so we do not optimize it.\n\n        align_get_bits(&s->gb);\n\n\n\n        // The pixels are stored in the same order as levels in h->mb array.\n\n        for(y=0; y<16; y++){\n\n            const int index= 4*(y&3) + 32*((y>>2)&1) + 128*(y>>3);\n\n            for(x=0; x<16; x++){\n\n                tprintf(s->avctx, \"LUMA ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*((x>>2)&1) + 64*(x>>3)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA U ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 64 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA V ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n\n\n        // In deblocking, the quantizer is 0\n\n        s->current_picture.qscale_table[mb_xy]= 0;\n\n        h->chroma_qp = get_chroma_qp(h->pps.chroma_qp_index_offset, 0);\n\n        // All coeffs are present\n\n        memset(h->non_zero_count[mb_xy], 16, 16);\n\n\n\n        s->current_picture.mb_type[mb_xy]= mb_type;\n\n        return 0;\n\n    }\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] <<= 1;\n\n        h->ref_count[1] <<= 1;\n\n    }\n\n\n\n    fill_caches(h, mb_type, 0);\n\n\n\n    //mb_pred\n\n    if(IS_INTRA(mb_type)){\n\n            int pred_mode;\n\n//            init_top_left_availability(h);\n\n            if(IS_INTRA4x4(mb_type)){\n\n                int i;\n\n                int di = 1;\n\n                if(dct8x8_allowed && get_bits1(&s->gb)){\n\n                    mb_type |= MB_TYPE_8x8DCT;\n\n                    di = 4;\n\n                }\n\n\n\n//                fill_intra4x4_pred_table(h);\n\n                for(i=0; i<16; i+=di){\n\n                    int mode= pred_intra_mode(h, i);\n\n\n\n                    if(!get_bits1(&s->gb)){\n\n                        const int rem_mode= get_bits(&s->gb, 3);\n\n                        mode = rem_mode + (rem_mode >= mode);\n\n                    }\n\n\n\n                    if(di==4)\n\n                        fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );\n\n                    else\n\n                        h->intra4x4_pred_mode_cache[ scan8[i] ] = mode;\n\n                }\n\n                write_back_intra_pred_mode(h);\n\n                if( check_intra4x4_pred_mode(h) < 0)\n\n                    return -1;\n\n            }else{\n\n                h->intra16x16_pred_mode= check_intra_pred_mode(h, h->intra16x16_pred_mode);\n\n                if(h->intra16x16_pred_mode < 0)\n\n                    return -1;\n\n            }\n\n\n\n            pred_mode= check_intra_pred_mode(h, get_ue_golomb(&s->gb));\n\n            if(pred_mode < 0)\n\n                return -1;\n\n            h->chroma_pred_mode= pred_mode;\n\n    }else if(partition_count==4){\n\n        int i, j, sub_partition_count[4], list, ref[2][4];\n\n\n\n        if(h->slice_type == B_TYPE){\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=13){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"B sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      b_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n            if(   IS_DIRECT(h->sub_mb_type[0]) || IS_DIRECT(h->sub_mb_type[1])\n\n               || IS_DIRECT(h->sub_mb_type[2]) || IS_DIRECT(h->sub_mb_type[3])) {\n\n                pred_direct_motion(h, &mb_type);\n\n                h->ref_cache[0][scan8[4]] =\n\n                h->ref_cache[1][scan8[4]] =\n\n                h->ref_cache[0][scan8[12]] =\n\n                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;\n\n            }\n\n        }else{\n\n            assert(h->slice_type == P_TYPE || h->slice_type == SP_TYPE); //FIXME SP correct ?\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=4){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"P sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      p_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n        }\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            int ref_count= IS_REF0(mb_type) ? 1 : h->ref_count[list];\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) continue;\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    unsigned int tmp = get_te0_golomb(&s->gb, ref_count); //FIXME init to 0 before and skip?\n\n                    if(tmp>=ref_count){\n\n                        av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", tmp);\n\n                        return -1;\n\n                    }\n\n                    ref[list][i]= tmp;\n\n                }else{\n\n                 //FIXME\n\n                    ref[list][i] = -1;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(dct8x8_allowed)\n\n            dct8x8_allowed = get_dct8x8_allowed(h);\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) {\n\n                    h->ref_cache[list][ scan8[4*i] ] = h->ref_cache[list][ scan8[4*i]+1 ];\n\n                    continue;\n\n                }\n\n                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ]=\n\n                h->ref_cache[list][ scan8[4*i]+8 ]=h->ref_cache[list][ scan8[4*i]+9 ]= ref[list][i];\n\n\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    const int sub_mb_type= h->sub_mb_type[i];\n\n                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;\n\n                    for(j=0; j<sub_partition_count[i]; j++){\n\n                        int mx, my;\n\n                        const int index= 4*i + block_width*j;\n\n                        int16_t (* mv_cache)[2]= &h->mv_cache[list][ scan8[index] ];\n\n                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        if(IS_SUB_8X8(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]=\n\n                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;\n\n                            mv_cache[ 1 ][1]=\n\n                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;\n\n                        }else if(IS_SUB_8X4(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]= mx;\n\n                            mv_cache[ 1 ][1]= my;\n\n                        }else if(IS_SUB_4X8(sub_mb_type)){\n\n                            mv_cache[ 8 ][0]= mx;\n\n                            mv_cache[ 8 ][1]= my;\n\n                        }\n\n                        mv_cache[ 0 ][0]= mx;\n\n                        mv_cache[ 0 ][1]= my;\n\n                    }\n\n                }else{\n\n                    uint32_t *p= (uint32_t *)&h->mv_cache[list][ scan8[4*i] ][0];\n\n                    p[0] = p[1]=\n\n                    p[8] = p[9]= 0;\n\n                }\n\n            }\n\n        }\n\n    }else if(IS_DIRECT(mb_type)){\n\n        pred_direct_motion(h, &mb_type);\n\n        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;\n\n    }else{\n\n        int list, mx, my, i;\n\n         //FIXME we should set ref_idx_l? to 0 if we use that later ...\n\n        if(IS_16X16(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, 0, list)){\n\n                        val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                        if(val >= h->ref_count[list]){\n\n                            av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                            return -1;\n\n                        }\n\n                    }else\n\n                        val= LIST_NOT_USED&0xFF;\n\n                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, val, 1);\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                unsigned int val;\n\n                if(IS_DIR(mb_type, 0, list)){\n\n                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my);\n\n                    mx += get_se_golomb(&s->gb);\n\n                    my += get_se_golomb(&s->gb);\n\n                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                    val= pack16to32(mx,my);\n\n                }else\n\n                    val=0;\n\n                fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, val, 4);\n\n            }\n\n        }\n\n        else if(IS_16X8(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 4);\n\n                }\n\n            }\n\n        }else{\n\n            assert(IS_8X16(mb_type));\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 4);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if(IS_INTER(mb_type))\n\n        write_back_motion(h, mb_type);\n\n\n\n    if(!IS_INTRA16x16(mb_type)){\n\n        cbp= get_ue_golomb(&s->gb);\n\n        if(cbp > 47){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"cbp too large (%u) at %d %d\\n\", cbp, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        if(IS_INTRA4x4(mb_type))\n\n            cbp= golomb_to_intra4x4_cbp[cbp];\n\n        else\n\n            cbp= golomb_to_inter_cbp[cbp];\n\n    }\n\n    h->cbp = cbp;\n\n\n\n    if(dct8x8_allowed && (cbp&15) && !IS_INTRA(mb_type)){\n\n        if(get_bits1(&s->gb))\n\n            mb_type |= MB_TYPE_8x8DCT;\n\n    }\n\n    s->current_picture.mb_type[mb_xy]= mb_type;\n\n\n\n    if(cbp || IS_INTRA16x16(mb_type)){\n\n        int i8x8, i4x4, chroma_idx;\n\n        int chroma_qp, dquant;\n\n        GetBitContext *gb= IS_INTRA(mb_type) ? h->intra_gb_ptr : h->inter_gb_ptr;\n\n        const uint8_t *scan, *scan8x8, *dc_scan;\n\n\n\n//        fill_non_zero_count_cache(h);\n\n\n\n        if(IS_INTERLACED(mb_type)){\n\n            scan8x8= s->qscale ? h->field_scan8x8_cavlc : h->field_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->field_scan : h->field_scan_q0;\n\n            dc_scan= luma_dc_field_scan;\n\n        }else{\n\n            scan8x8= s->qscale ? h->zigzag_scan8x8_cavlc : h->zigzag_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;\n\n            dc_scan= luma_dc_zigzag_scan;\n\n        }\n\n\n\n        dquant= get_se_golomb(&s->gb);\n\n\n\n        if( dquant > 25 || dquant < -26 ){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"dquant out of range (%d) at %d %d\\n\", dquant, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        s->qscale += dquant;\n\n        if(((unsigned)s->qscale) > 51){\n\n            if(s->qscale<0) s->qscale+= 52;\n\n            else            s->qscale-= 52;\n\n        }\n\n\n\n        h->chroma_qp= chroma_qp= get_chroma_qp(h->pps.chroma_qp_index_offset, s->qscale);\n\n        if(IS_INTRA16x16(mb_type)){\n\n            if( decode_residual(h, h->intra_gb_ptr, h->mb, LUMA_DC_BLOCK_INDEX, dc_scan, h->dequant4_coeff[0][s->qscale], 16) < 0){\n\n                return -1; //FIXME continue if partitioned and other return -1 too\n\n            }\n\n\n\n            assert((cbp&15) == 0 || (cbp&15) == 15);\n\n\n\n            if(cbp&15){\n\n                for(i8x8=0; i8x8<4; i8x8++){\n\n                    for(i4x4=0; i4x4<4; i4x4++){\n\n                        const int index= i4x4 + 4*i8x8;\n\n                        if( decode_residual(h, h->intra_gb_ptr, h->mb + 16*index, index, scan + 1, h->dequant4_coeff[0][s->qscale], 15) < 0 ){\n\n                            return -1;\n\n                        }\n\n                    }\n\n                }\n\n            }else{\n\n                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);\n\n            }\n\n        }else{\n\n            for(i8x8=0; i8x8<4; i8x8++){\n\n                if(cbp & (1<<i8x8)){\n\n                    if(IS_8x8DCT(mb_type)){\n\n                        DCTELEM *buf = &h->mb[64*i8x8];\n\n                        uint8_t *nnz;\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            if( decode_residual(h, gb, buf, i4x4+4*i8x8, scan8x8+16*i4x4,\n\n                                                h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 16) <0 )\n\n                                return -1;\n\n                        }\n\n                        nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                        nnz[0] += nnz[1] + nnz[8] + nnz[9];\n\n                    }else{\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            const int index= i4x4 + 4*i8x8;\n\n\n\n                            if( decode_residual(h, gb, h->mb + 16*index, index, scan, h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale], 16) <0 ){\n\n                                return -1;\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    uint8_t * const nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                    nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(cbp&0x30){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++)\n\n                if( decode_residual(h, gb, h->mb + 256 + 16*4*chroma_idx, CHROMA_DC_BLOCK_INDEX, chroma_dc_scan, NULL, 4) < 0){\n\n                    return -1;\n\n                }\n\n        }\n\n\n\n        if(cbp&0x20){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++){\n\n                const uint32_t *qmul = h->dequant4_coeff[chroma_idx+1+(IS_INTRA( mb_type ) ? 0:3)][chroma_qp];\n\n                for(i4x4=0; i4x4<4; i4x4++){\n\n                    const int index= 16 + 4*chroma_idx + i4x4;\n\n                    if( decode_residual(h, gb, h->mb + 16*index, index, scan + 1, qmul, 15) < 0){\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n            nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n        }\n\n    }else{\n\n        uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);\n\n        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n        nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n    }\n\n    s->current_picture.qscale_table[mb_xy]= s->qscale;\n\n    write_back_non_zero_count(h);\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] >>= 1;\n\n        h->ref_count[1] >>= 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23299, "substitutes": {"h": ["history", "t", "dh", "ht", "he", "ssh", "zh", "eh", "this", "hh", "o", "r", "hal", "H", "oh", "m", "err", "hash", "th", "ash", "c", "host", "handle", "hd", "enh", "hw", "HH", "hr", "ih", "ctx", "his", "here", "bh", "hz", "html", "sh", "kh", "ph", "hl", "hs", "hm", "rh", "hp", "help", "self", "ch", "her", "uh", "http", "has", "dr", "obj", "cache", "ah", "b", "l", "v", "ish", "hi", "header", "w"], "s": ["is", "m", "ims", "ops", "sts", "ds", "details", "ssl", "sw", "sv", "hs", "es", "als", "sb", "as", "v", "sl", "n", "state", "a", "o", "os", "changes", "ns", "conv", "bs", "cs", "e", "fs", "bis", "se", "status", "sm", "his", "ats", "vs", "dev", "g", "has", "ts", "gets", "qs", "b", "comm", "t", "sys", "f", "stats", "ps", "str", "args", "c", "spec", "ls", "sh", "utils", "S", "its", "sp", "conf", "obj", "serv", "bits", "parts", "set", "ys", "ss", "ses", "rs", "gs", "south", "ms", "sam", "js", "http", "sq", "tests", "w"], "partition_count": ["partition2cache", "partitionationtable", "partitionablecount", "partitions_length", "partition2type", "partitionationtype", "partition_cache", "partition_counter", "partition2count", "partition_length", "partition_type", "partition_table", "partitionablecounter", "partitionablelength", "partitions_counter", "partitionationcount", "partitions_count", "partitionationlength"], "mb_type": ["mbTypetotal", "mbPmodel", "nbetyrel", "MB_types", "nb_relation", "mbPrelation", "nbetyrole", "mbetylevel", "mb_block", "bb_number", "mbPtype", "mbTypetype", "mbTypelevel", "emb_class", "mb_total", "mbetyrole", "mb_Type", "mbxtypes", "mb_level", "mb_count", "mob_typ", "mb_relation", "mb_typ", "mbxtype", "MB_type", "mb_style", "mb_model", "emb_count", "nb_block", "mb__type", "MB_Type", "mbTypenumber", "mb_class", "mbxcount", "emb_types", "nb_role", "mb_length", "mb_number", "nb_level", "mob_type", "nbetylevel", "emb_type", "mb_role", "nb_type", "nb_style", "mb_code", "mb_rel", "nb_rel", "mb__code", "mbxclass", "mob_count", "mb_time", "mbetytype", "nbetytype", "mob_Type", "mb__style", "nb_model", "mbetyrel", "mb_types", "mbPlength", "nb_code", "MB_time", "mb__block", "bb_level", "nb_length", "bb_total", "bb_type"], "cbp": ["bbpc", "bbP", "wbg", "CBg", "wbv", "CBpc", "wbp", "cvP", "bbpos", "CBp", "cvpos", "cvp", "cbP", "cbg", "cbpos", "cvpc", "bbv", "CBpos", "CBP", "bbg", "CBv", "cbpc", "bbp", "cbv", "wbP"], "mb_skip_run": ["mb_no_out", "mb_skip_skip", "mb_skip___load", "mb_skip___run", "mb_sp_ref", "mb_no_runs", "mb_skip___pre", "mb_sp_run", "mb_no_step", "mb_skip_out", "mb_skip_pre", "mb_skip_un", "mb_skipocout", "mb_no_check", "mb_skip_check", "mb_skip_ran", "mb_skip___step", "mb_save_run", "mb_save_ran", "mb_skip_load", "mb_skip_runs", "mb_sp_skip", "mb_skip___skip", "mb_save_task", "mb_skipocrun", "mb_skip___ref", "mb_no_load", "mb_no_pre", "mb_skip___un", "mb_skip_ref", "mb_skip_task", "mb_no_run", "mb_skipoccheck", "mb_skip_step", "mb_sp_un", "mb_skipocruns", "mb_save_runs"], "gb": ["gt", "gif", "rb", "eb", "hub", "gm", "gam", "gc", "gz", "gd", "mb", "rg", "eg", "vg", "gs", "fg", "xy", "nb", "gom", "img", "ga", "deg", "bg", "gallery", "yg", "db", "storage", "gl", "gg", "g", "kb", "Gb", "imag", "emb", "gy", " GB", "sb", "GB", "cfg", "vt"]}}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307, "substitutes": {"d": ["n", "done", "p", "dh", "dm", "dx", "D", "dd", "di", "dL", "du", "dc", "m", "dq", "device", "sd", "dn", "gd", "dt", "e", "ld", "bd", "c", "data", "dl", "md", "ds", "j", "nd", "dat", "db", "dev", "de", "dr", "g", "ad", "fd", "dos", "pd", "b", "l", "v", "da"], "address": ["reference", "message", "value", "length", "target", "application", "operation", "command", "work", "pointer", "port", "point", "padding", "chain", "type", "vector", "context", "device", "order", "ay", "x", "trace", "empty", "size", "base", " Address", "link", "location", "adr", "at", "service", "prefix", "ace", "network", "distance", "number", "memory", "act", "table", "image", "description", "array", "relative", "ip", "ptr", "position", "buffer", "always", "shape", "ad", "config", "range", "store", "route", "alias", "enable", "hello", "index", "gate", "record", "attribute", "offset", "add", "domain", "activity", "result", "align", "here", "Address", "date", "race", "interface", "block", "each"], "val": ["valid", "p", "ival", "tag", "ret", "vol", "ref", "type", "aval", "bal", "value", " value", "err", "rel", "bl", "rol", "al", "eval", "key", "arr", "pl", "x", "loc", "def", "pt", "tx", "Value", "data", "var", "test", "bit", "Val", "vec", "rx", "pol", "col", "buf", "pr", "values", "res", "VAL", "vt", "vals", "mem", "range", "rl", "cal", "pos", "l", "v", "el", "serv"], "len": ["n", "en", " length", "cap", "list", "Len", "h", "length", " l", "bl", "count", "lp", "lan", "ld", "lon", "tl", "c", "size", "bytes", "ity", "ail", "vec", "kl", "lim", "z", "li", "ls", "seq", "hl", "mem", "fin", "ln", "nl", "pos", "ll", "elt", "lf", "line", "l", "Length", "fl", "el", "v", "lib", "syn", "L"], "can_write": ["annot_see", "can_writer", "canopstore", "canblewrit", "canfulread", "canbleread", "can_read", "will_writer", " can_see", "canlywrite", "canlyexit", "canblewrite", "can_create", "will_write", "willentransfer", "Can_write", "can_store", " can_exit", "will_read", " can_create", " can_apply", "canopsee", " can_read", "can_exit", "canifyexit", "can_writ", "canenwriter", "cacheopsee", "Can_writ", "cacheopstore", "willenread", "can_link", "canifywrite", "willenwriter", "canfulcreate", "Can_link", "cache_writer", "cacheopwriter", "canfultransfer", "can2writ", "can2write", "canfulwrite", "canfulsee", "canenwrite", "canopwriter", "canblelink", "canifysee", "can_transfer", "annot_writ", "can8see", "cache_write", "can2link", "can_see", "canlyapply", "canentransfer", "can_apply", "will_transfer", "canenread", "can8store", "annot_write", "canifyapply", "Can_read", "can8write", "canopwrite", "annot_writer", "cacheopwrite", "cache_see", "can2read", "willenwrite", "canlysee", "cache_store", "canfulwriter", "can8writer"], "i": ["n", "p", "phi", "is", "start", "it", "ic", "si", "index", "di", "me", "ai", "iu", "xi", "m", "ix", "y", "ims", "progress", "init", "multi", "im", "zi", "complete", "x", "id", "ind", "e", "sim", "gi", "I", "c", "qi", "ki", "cli", "j", "ip", "ini", "batch", "ti", "tim", "status", "li", "k", "ex", "ui", "ir", "iter", "in", "ci", "try", "mi", "u", "ii", "port", "pi", "b", "v", "l"], "end": [" aval", "valid", " rem", " ref", " act", "ival", "ref", " pos", "bal", " start", " endpoint", "code", "Val", " Val", " rid", " begin", " tag", " pend", " rest", " count", " serv", " coff", " vend", " rend", "v", "serv"], "addr": ["p", "ret", "a", "dd", "arp", "gate", "ref", "index", "ix", "offset", "add", "rel", "err", "order", "act", "pkg", "arr", "loc", "code", "tx", "host", "handle", "ip", "ord", "ress", "ctx", "ptr", "align", "grad", "res", "alt", "map", "adr", "dr", "mem", "ad", "iter", "Address", "sp", "prefix", "np", "cmd", "ace", "pos", "obj", "pad", "pat", "attr"], "r": ["n", "er", "p", "re", "t", "rb", "lr", "rc", "mr", "rn", "usr", "nr", "h", "m", "rem", "err", "rel", "vr", "ar", "arr", "rr", "rg", "ro", "rar", "rs", "c", "R", "rx", "j", "sr", "repl", "rw", "br", "rt", "kr", "res", "rh", "rm", "dr", "g", "range", "rl", "cr", "rec", "l", "v", "attr", "rd", "w"], "reg": ["re", "state", "leg", "rc", "tag", "org", "ret", "index", "ref", "gro", "rom", "rem", "Reg", "rol", "rank", "gc", "ar", "key", "arr", "loc", "rr", "rg", "eg", "rar", "row", "var", "greg", "col", "sr", "urg", "cell", "br", "rt", "pr", "res", "region", "mem", "rm", "g", "dr", "rest", "gr", "REG", "rep", "pg", "mod", "rec", "serv"]}}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309, "substitutes": {"avctx": ["AVcc", "savctx", "avcontext", "savcc", "AVctx", "AVcontext", " avctl", "avctl", " avcontext", "savctl", "savcontext", "avcc", " avcc", "AVctl"], "s": ["ports", "search", "is", "m", "ims", "ops", "sts", "ds", "details", "ches", "ex", "sv", "sw", "hs", "es", "ins", "als", "ants", "params", "less", "sb", "as", "sl", "n", "a", "os", "changes", "ns", "sync", "bs", "cs", "results", "aws", "fs", "bis", "status", "ats", "vs", "g", "ts", "gets", "sg", "qs", "b", "events", "comm", "t", "sys", "r", "stats", "d", "ps", "args", "c", "spec", "ls", "ies", "S", "its", "conf", "obj", "l", "serv", "p", "bits", "parts", "set", "h", "ss", "sports", "rs", "gs", "ms", "js", "w"], "length": ["duration", "history", "loop", "t", "load", "all", " Length", "end", "L", "message", "capacity", "vector", "distance", "amount", "number", "ilo", "f", "type", "h", " l", "SIZE", "head", "offset", "available", "count", "ength", "total", "loc", "before", "php", "c", "size", "idth", "no", "expected", "p", "angle", "height", "ptr", "full", "sh", "position", "maximum", "buffer", "always", "shape", " len", "location", "deep", "sequence", "component", "enth", "block", "be", "len", "form", " lengths", "ENGTH", "l", "Length", "padding", "text"], "v": ["n", "qv", "t", "p", "vc", "it", "o", "r", "vi", " sv", "f", "m", "h", "value", "y", "gm", "conv", "iv", "d", "val", "x", "va", "um", "wire", "cv", "vm", "c", " ov", "var", "av", "j", "tv", "uv", "ov", "q", "ve", "sv", "vs", "buffer", "qu", "at", "g", "ev", "u", "w", "nv", "b", "l", "pi", "V", "vp", "lv", "vv", "vt"], "i": ["is", "ic", "m", "ims", "progress", "rel", "im", "span", "I", "ti", "cli", "PI", "ui", "ex", "res", "ir", "client", "point", "uri", "chain", "name", "\u0438", "si", "me", "o", "list", "ai", "ix", "ji", "x", "ind", "sim", "e", "gi", "info", "ami", "eric", "fi", "oi", "at", "g", "remote", "hi", "bi", "phi", "it", "ri", "f", "xi", "y", "multi", "ei", "zi", "ni", "qi", "ini", "ip", "li", "sky", "in", "try", "ci", "mi", "ii", "pi", "ori", "ij", "er", "p", "print", "index", "di", "iu", "us", "init", "ie", "key", "id", "ki", "j", "q", "page", "iter"]}}
{"project": "FFmpeg", "commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n", "idx": 23323, "substitutes": {"s": ["is", "source", "ims", "ops", "sts", "ds", "details", "ex", "sv", "sw", "hs", "es", "ins", "als", "ants", "less", "sb", "as", "v", "n", "a", "os", "changes", "ns", "bs", "cs", "aws", "fs", "bis", "se", "status", "ats", "self", "bes", "service", "has", "ts", "ags", "qs", "events", "comm", "t", "sys", "settings", "sym", "f", "y", "stats", "ar", "ps", "times", "comments", "c", "z", "spec", "ls", "conf", "l", "so", "er", "p", "parts", "set", "h", "ss", "ses", "sports", "rs", "gs", "ms", "js", "sq", "an", "same", "w"], "crc": ["accc", "acsum", "currc", "crand", "acrc", " ccc", "Crand", "ccc", "cred", "ctRC", "crib", " csum", "rcrand", "ccred", "comprs", "currib", "rcrs", "ccrc", " cRC", "ccrs", "ccrib", "ctcc", "rcrc", "acRC", "csum", "cRC", " crand", "Crs", "curred", "CRC", "comprc", "ctrc", "currs", "rcRC", "ctsum", "comprib", "crs", "Crc", "compred", " crs"], "S": ["Si", "Source", "M", "NS", "SR", "US", "Sample", "TS", "D", "set", "H", "G", "STAT", "BS", "B", "BIT", "RAW", "SL", " B", "Session", "SS", "SU", " T", "SB", "Q", "IS", "I", "SAM", "SEC", "R", "X", "N", "SP", "DS", " C", "SA", "SI", "SER", "C", "T", "P", "A", "SF", "CS", "J", "SH", "JS", "Size", "O", "F", "RS", "V", "String", "U", "L"], "bit": ["ret", "value", "IT", "hit", "mask", "I", "X", " tag", "SA", "AT", "word", "Bit", "bt", "virtual", "be", "port", "point", "state", "binary", "ion", "cat", "single", "back", "B", "condition", "board", "x", "i", "status", "base", "op", "sc", "at", "g", "bin", "b", "t", "it", "tag", "f", "G", "null", "BIT", "bool", "image", "slot", "limit", "ip", "bo", "P", "position", "in", "its", "match", "l", "ST", "V", "p", "out", "character", "bits", "print", "index", "set", "field", " bits", "offset", "id", "or", "test", "byte", "result", "ch", "block", "bug", "flag"]}}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339, "substitutes": {"env": ["ee", "msg", "cont", "desc", "equ", "err", "gear", "erb", "dest", "dt", "vm", "worker", "event", "server", "sw", "sv", "map", "_", "ew", "v", "ev", "context", "te", "e", "disk", "environment", "vs", "db", "sc", "dev", "erd", "cmd", "eng", "net", "act", "cv", "operator", "ec", "hw", "rod", "buf", "ctx", "ptr", "kh", "buffer", "sp", "req", "conf", "obj", "vp", "vt", "er", "en", "end", "rc", "org", "func", "h", "window", "init", "conn", "enter", "estate", "here", "manager", "queue", "viron", "priv", "ah", "w"], "arg1": ["varone", "stage01", " arg61", "argsOne", "pg1", "arg61", "param1", "match01", "cmd001", "matchone", "doc1", "group11", "prop001", "ag2", "match1", "commandav", "tag001", "pgav", "agg11", "cal001", "date15", "agg0", "target01", "Arg001", "paramized", "Arg51", "arg100", "app001", " arg3", "exp001", "command61", "targetOne", "command3", " argized", "cal100", "argized", "group001", "prop2", "ag1", "parized", "aggone", "date1", "tag2", "ag001", "command9", "param91", "prop0", "command1", "arg51", "prop3", "param001", "group01", "match15", " arg15", "app1", "arg9", "param01", " argid", "par001", "args1", "exp1", "cmd1", "date2", "agg1", "agg01", "matchav", "par1", "pg01", "calized", " argOne", "tag0", "prop9", "param100", "date001", "arg01", "cal1", "appone", "expone", "var1", "arg001", "agg2", " arg001", "command100", "target1", "agg001", "docone", "command001", "prop61", "doc001", "aggav", "var001", "groupone", "param51", "match001", "match11", "match2", "pg001", "agg51", "param2", "arg15", " arg01", "arg0", "commandized", "arg3", "stage1", "args01", "prop1", "tag1", "Arg01", "var01", "argOne", "group1", "groupav", "stage001", "propone", "dateone", "arg91", "argav", " argone", "arg11", "matchized", "cmdone", "date01", "group9", "args2", "matchid", "prop91", "ag91", "argone", "commandone", "propav", "target2", "parid", "argid", "Arg1"], "arg2": ["opTwo", "drTwo", "group02", "argument2", "doc02", "dr2", "propTwo", "agg7", "agg5", "act42", "prop02", "argTwo", "arg10", "arg6", "actTwo", "act02", "stage2", "arptwo", "iter2", "exp02", "agg02", "arp02", "param102", "match02", "val02", "item02", " arg3", "arg8", "ld2", "Arg5", "prop2", "exp42", "flag4", "expTwo", "arg7", "agg6", "tag2", "ld02", "agg8", "aggtwo", "op2", "item2", "arp2", "cmd02", "Arg3", "Arg2", "argument5", "param6", "ldTwo", "agg10", "dr02", "argtwo", "val5", "date7", "event2", "date2", "stagelet", "dr102", "agg1", "iter102", "eventTwo", "tag0", "arg5", "iter6", "argument8", "tag5", "cmd10", "dateTwo", "docTwo", "argument4", "event42", "param10", "arg102", "itemTwo", "agg2", "tag3", "datetwo", "val8", "match102", "tag02", "flag02", "match2", "group2", "groupTwo", " arg5", "param2", "agg102", "op02", "arg0", "arp7", "arg3", "stage1", "arg02", "date02", "tag1", "actlet", "method42", "act2", "methodlet", "flag1", "argument1", "param8", "tagTwo", " arg0", "param02", "doc2", "agg4", "cmd8", "argument0", "flag2", "cmd2", "iter5", "matchTwo", "arglet", "stage42", "argument02", "op102", "arg42", "exp2", "cmd5", "arg4", "method2", "val2", "iter02", "Arg1"], "mem_idx": ["mem_idxy", "mem_dirix", "mem_dj", "mem_dct", "mem_idep", "mem_tagz", "mem8idex", "mem8idix", "mem_idf", "mem_lockxi", "mem2idz", "memockidz", "mem_pidxs", "mem_pidx", "mem_idsz", "mem2Idxc", "mem_idsxc", "mem_idxs", "mem_tagx", "mem8dirx", "mem_idIndex", "memockidentx", "mem2Idex", "mem_midf", "mem_IdIndex", "mem_midxs", "mem_identf", "mem_iterj", "mem_idefx", "mem_tryct", "mem_endx", "mem8idx", "mem_tryx", "mem2idx", "mem_ridxc", "mem_Idz", "mem_identx", "mem_identxy", "memockidf", "mem_lockix", "mem_indexj", "mem_idxc", "mem8dirix", "mem_idj", "mem_ridx", "mem_idct", "mem2idex", "mem_midex", "mem_Idx", "mem_dx", "mem_idl", "mem_tagxc", "memockidentz", "mem_idxi", "mem_idz", "mem_lockx", "mem_midz", "mem_intx", "mem_iterex", "mem_endp", "mem2Idx", "memockidentxy", "mem_intxy", "mem_Idxc", "mem_idexs", "mem_dirxi", "mem_ridz", "mem8direx", "mem_endfx", "mem_idsx", "mem_idp", "mem_iterl", "mem_intz", "mem_indexl", "mem2idxc", "mem_intf", "mem_idex", "mem_midix", "mem_midxi", "memockidxy", "memockidx", "mem_pidex", "mem_midp", "mem_dirx", "mem8dirxi", "mem_endxs", "mem_iterxs", "mem_tagix", "mem_indexct", "mem_Idex", "memockidentf", "mem_ridIndex", "mem_midfx", "mem_pyz", "mem_midx", "mem_dl", "mem_lockex", "mem_pyx", "mem_pyxc", "mem_midxy", "mem_iterx", "mem_pyix", "mem_iterct", "mem_identz", "mem_idsex", "mem_idfx", "mem2Idz", "mem_direx", "mem_indexx", "mem_tryex", "mem_idix", "mem8idxi", "mem_pidct", "mem_tryxs"], "tmp": ["pot", "msg", "bolt", "tg", "mm", "m", "tar", "mp", "wp", "dt", " mp", "timeout", "xy", "temp", "aux", "uv", "now", "term", "bt", "tc", "v", "tf", "sup", "resp", "yy", "gb", "copy", "important", "cmp", "nb", "op", " resp", "db", "pretty", "stuff", "uff", "appy", "b", "cp", "td", "t", "zip", "MP", "mmm", "tn", "gm", "pkg", "mb", "var", "fb", "good", "proc", "ctx", "utm", "ptr", "html", "up", "nt", "sp", "buff", "np", "obj", "cache", "encrypted", "trap", "vv", "attr", "perm", "gt", "mk", "p", "csv", "tt", "txt", "lambda", "tp", "qq", "aaa", "ob", "etc", "gz", " np", "tab", "img", "tif", "js", "rm", "amp", "pb", "verb", "lib"]}}
{"project": "FFmpeg", "commit_id": "289520fd97395ffd5bf933ac80487e858bc4039d", "target": 0, "func": "static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n        int v = get_bits(&s->gb, 8);\n\n        if (v == 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\");\n\n            return -1;\n\n        }\n\n        if (intra && i == 0 && v != 8) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v);\n\n            v = 8; // needed by pink.mpg / issue1046\n\n        }\n\n        matrix0[j] = v;\n\n        if (matrix1)\n\n            matrix1[j] = v;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23344, "substitutes": {"s": ["n", "comm", "p", "is", "sys", "settings", "a", "os", "m", "h", "ss", "ns", "ims", "ses", "stats", "d", "ps", "bs", "cs", "e", "sts", "rs", "gs", "aws", "fs", "c", "ds", "j", "asm", "se", "south", "ls", "q", "ms", "sv", "sam", "sw", "ats", "vs", "hs", "S", "js", "ins", "sq", "ts", "sg", "conf", "qs", "acs", "sb", "ains", "b", "l", "serv"], "matrix0": ["matction180", "matrix3", "contrix180", "matform2", "matrix10", "contrix3", "matmat180", "matform0", "contrix08", "matgment3", "matction3", "matction08", "matmat08", "contgment180", "matrix08", "matform00", "contgment3", "matmat3", "matgment0", "metform2", "matmat0", "matric10", "matgment180", "matment10", "matrix180", "metrix0", "contgment0", "matgment08", "metform00", "metrix10", "metrix2", "matric0", "metform0", "matment0", "matric00", "matric2", "matrix00", "contgment08", "matform10", "matment00", "metform10", "matction0", "matrix2", "metrix00", "contrix0", "matment2"], "matrix1": ["matrice0", "userixable", "matempt1", "trice0", "catric01", "matrix01", "matempt0", "matrices1", "matrices01", "matrixable", "matvector1", "matrix100", "trice01", "catric2", "trix1", "matrices100", "matMatrix1", "useMatrix1", "trice100", "catric1", "catricOne", "userix1", "matMatrix2", "matrice1", "trix0", "catrix2", "matrice01", "matMatrixInf", "userixOne", "useMatrixOne", "matvectorInf", "matric1", "matMatrixOne", "matempt01", "trix01", "matvectorable", "matric01", "userixInf", "useMatrixable", "matrixInf", "matMatrix01", "trix100", "matMatrixable", "trice1", "catrixOne", "useMatrixInf", "matvectorOne", "matrices2", "matric2", "matricesOne", "catrix01", "catrix1", "matrixOne", "matempt100", "matrix2", "matrices0", "matrice100", "matricOne"], "intra": ["ortri", "Intra", "prettra", "contri", "ortrait", "ntri", "ortras", "Inttra", "pretRA", "pretra", "intras", "contra", "contrait", "intran", "Intran", "inttra", "intRA", "intrait", "intri", "ntra", "ortra", "pretran", "ntrait", "interRA", "interran", "interra", "contras", "IntRA", "intertra", "ntras"], "i": ["bi", "name", "ij", "n", "p", "phi", "is", "out", "t", "ic", "it", "print", "si", "me", "di", "index", "iu", "ai", "o", "xi", "f", "m", "ix", "y", "ims", "init", "multi", "ji", "im", "zi", "x", "id", "sim", "ind", "gi", "info", " ti", "I", "c", "qi", "ki", "ti", "j", "ip", "ini", "li", "ia", "k", "ex", "ui", "fi", "gu", "at", "in", "ci", " j", "mi", "u", "ii", "pi", "hi", "v", "l", "b"]}}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n", "idx": 23354, "substitutes": {"sig": ["sg", " sigs", "Sg", "Sig", "Sigs", " sg", "ssigs", "sigs", "ssg", "ssig"], "status": ["expr", "name", "n", "resp", "state", "msg", "out", "index", "stat", "output", "check", "STAT", "progress", "exec", "val", "current", "id", "x", "code", "i", "fs", "str", "c", "s", "handle", "pid", "compl", "result", "ex", "exist", "sc", "g", "error", "sp", "Status", "atus", "wa", "flag", "wait", "serv"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)\n\n{\n\n    int current_offset = s->pixel_ptr - dst->data[0];\n\n    int motion_offset = current_offset + delta_y * dst->linesize[0]\n\n                       + delta_x * (1 + s->is_16bpp);\n\n    if (motion_offset < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motion_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (motion_offset > s->upper_motion_limit_offset) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\",\n\n            motion_offset, s->upper_motion_limit_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (src->data[0] == NULL) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,\n\n                                            dst->linesize[0], 8);\n\n    return 0;\n\n}\n", "idx": 23361, "substitutes": {"s": ["comm", "p", "t", "is", "sys", "a", "os", "source", "set", "h", "changes", "ss", "ns", "ims", "us", "ses", "stats", "https", "bs", "ps", "ops", "cs", "i", "sts", "sports", "rs", "gs", "fs", "aws", "c", "ds", "sis", "bis", "services", "z", "south", "spec", "ls", "details", "ms", "sv", "sw", "ats", "vs", "hs", "self", "sc", "ies", "S", "js", "g", "es", "its", "sq", "ts", "ins", "ants", "als", "conf", "qs", "less", "eds", "sb", "ains", "as", "v", "so", "series", "w"], "src": ["sys", "rc", "rn", "sel", "usr", "r", "source", "conv", "th", "iv", "vr", "dest", "rs", "gs", "st", "proc", "hw", "sr", "img", "sn", "rt", "sv", "via", "ur", "sc", "in", "g", "ins", "webkit", "sq", "http", "std", "rl", "obs", "sub", "input", "wn", "sb", "ser", "b", "inst", "supp", "vp", "syn", "sl"], "dst": ["dlt", "lest", "dsest", "Dest", "rst", " dsts", "dssts", "Dlt", "dest", "lst", "ldest", " dnd", "Dnd", "dsnd", "Dst", "dnd", "rsts", "rnd", "dslt", "rest", "dsdest", "llt", "lsts", "Dsts", " dest", " ddest", "Ddest", "dsst", "ddest", "dsts"], "delta_x": ["delta_r", "delta___ex", "delta_ex", "dota_r", "dota_x", "delt_y", "delt_xy", "delt_x", "dota_ex", "delta___x", "delta_xy", "delta___r", "delta_X", "dota_X", "delta___X"], "delta_y": ["divot_y", "divot_Y", "divot_yo", "delta_Y", "delta___y", "dota_b", "dota_y", "delta2xy", "divot___Y", "divot___y", "divot___ym", "delta_xy", "delta_yo", "divot_ym", "delta_ym", "delta___ym", "dota_xy", "delta2y", "divot___yo", "delta___Y", "delta___yo", "delta_b", "delta2Y", "delta2b", "dota_Y"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n", "idx": 23371, "substitutes": {"dev": ["hid", "sys", "dm", "ver", "Dev", "go", "device", "scan", "sd", "d", "serv", "pro", "def", "conn", "Device", "test", "des", "ds", "watch", "av", "proc", "hw", "DEV", "spec", "vs", "devices", "env", "dem", "de", "mem", "ad", "doc", "cam", "cmd", "pad", "att", "ev", "w"], "s": ["ports", "is", "ops", "sts", "des", "ds", "details", "sv", "sw", "hs", "es", "ins", "als", "params", "steps", "less", "sb", "v", "sl", "n", "state", "o", "stat", "changes", "ns", "sync", "conv", "bs", "cs", "fs", "aws", "bis", "states", "se", "ats", "vs", "bes", "ts", "ads", "gets", "cmd", "ags", "qs", "b", "comm", "t", "sys", "sa", "r", "sd", "stats", "ps", "args", "c", "spec", "ls", "S", "its", "conf", "sol", "serv", "p", "bits", "set", "h", "ss", "ses", "sports", "rs", "gs", "pers", "j", "ms", "js", "tests", "sq"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374, "substitutes": {}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386, "substitutes": {"child": ["resp", "parent", "this", "comment", "ach", "task", "cow", "desc", "h", "root", "children", "add", "bl", "ac", "th", "count", "key", "pt", "ind", "sim", "bc", "Child", "bit", "c", "s", "handle", "batch", "j", "base", "fr", "request", "cell", "q", "sc", "ch", "nt", "job", "sub", "config", "buff", "block", "cache", "store", "client", "lf", "cc", "b", "v", "pty", "local", "shell", "lib", "w"], "req": ["expr", "comm", "resp", "msg", "usr", "Requ", "r", "requ", "ire", "desc", "sec", "dq", "ref", "rem", "qq", "err", "rel", "qt", "pkg", "pro", "rr", "ps", "required", "ext", "ind", "tx", "test", "md", "jp", "rx", "j", "proc", "fr", "rw", "wx", "urg", "ctx", "request", "aux", "q", "quest", "pr", "queue", "grab", "res", "seq", "rt", "reg", "mem", "ch", "wcs", "http", "sq", "job", "cmd", "obj", "crit", "rec", "comp", "dist", "require", "attr"], "offset": ["oint", "offs", "end", "start", "oid", "et", "os", " offsets", "index", "Offset", "set", "off", "length", "SIZE", "attribute", "order", "total", "loc", "trace", "timeout", "layout", "slot", "reset", "size", "byte", "handle", "tile", "base", "shift", "seek", "position", "buffer", "aligned", "addr", "location", "scroll", "iter", "error", "range", "prefix", "block", "address", "pos", "execute", "store", "iso", "slice", "pointer", "local", "origin", "point", "padding", "alias"], "bytes": ["izes", "offs", "bits", "pieces", "maps", "reads", " strides", "memory", " offsets", "parts", "outs", "bps", "pages", "words", "units", "SIZE", "length", "total", "ops", "rows", "allows", "keys", " bases", "times", "ries", "gs", "size", "byte", "classes", "loads", "faces", "frames", " slices", "files", "seconds", "fixes", "points", "items", "values", " blocks", "sets", "bles", "lines", " sizes", "ies", "ones", "grades", "es", "its", "ips", "Bytes", "abytes", "gets", "steps", "blocks", "versions", " reads", "len", "actions", "tes", "pointers", "errors"], "align": ["ign", "grade", "hal", "aug", " aligned", "length", "scale", "al", "margin", "order", "transform", "format", "rank", "count", "pair", "label", "mask", "layout", "dim", "aff", "size", "batch", "compl", "angle", "lock", "shift", "num", "padding", "equal", "aligned", "adj", "addr", "shape", "area", "mem", "ignore", " alignment", "rot", "config", "adjust", "range", "match", "block", "address", "cal", "hold", "attach", "work", "len", "half", "pad", "flag", "lag", "attr", "sign", "alias"], "qiov": [" qveh", "sqiop", "qmpeg", "iqiov", " qvector", "quovi", "sqveh", "sqiov", "quiov", "qconv", "sqiev", "sqovi", " qiev", "iqiop", "sqmpeg", "qiop", "quveh", "qumpeg", " qmpeg", "iqiour", "dqiop", " qiour", "qiour", "quiour", "quvector", "quiev", "quiop", "qiev", "quconv", " qovi", "dqiov", "dqiour", " qiop", "qovi", " qconv", "sqconv", "qveh", "sqvector", "dqovi", "sqiour", "qvector", "iqovi"], "flags": ["xx", "bits", "rates", "settings", "heads", "weights", "type", "tags", "bps", "Flag", "stats", "bool", "ps", "FLAG", "ops", "terms", "allows", "mask", "args", "comments", "locks", "friendly", "status", "checks", "atts", "ms", "utils", "properties", "types", "reports", "ants", "fts", "Flags", "fl", "features", "ags", "options", "fps", "actions", "flag", "magic", "limits", "lag", "sign", "fields"], "bs": ["blog", "sys", "lbs", "bits", "bf", "bolt", "os", "cb", "boot", "ubs", "ns", "BS", "bps", "aos", "bl", "outs", "ps", "ib", "bus", "cs", "bc", "socket", "fs", "gs", "bn", "bd", "rs", "ds", "bis", "base", "ctx", "bo", "ls", "bm", "bh", "hz", "vs", "bes", "box", "js", "its", "bec", "ts", "obs", "pb", "sb", "bos", "b", "bp", "bb"], "drv": ["srva", " drvr", "rdv", " drvs", "drj", "darvd", "hrm", "hrv", "vrb", "drvs", "derv", "darv", "drvr", "dervd", "vrvr", "vrvd", " drm", "drV", "drb", "srvs", " drva", "drvd", "rdm", "darva", " drV", "dervr", "hrV", "drm", " drvd", "srvd", " drb", "drva", "hrj", " drj", "rdj", "srv", "vrv", "rdV", "derb", "darvs"], "waited": ["awaisted", "Waitted", "watiter", "watired", "watited", "Waisted", "waisted", "awiter", "awaited", "awaitable", "watitted", "awitted", "waitable", "Waited", "waired", "witer", "watitable", "awaitted", "awired", "Waitable", "awaits", "Waits", "awaiter", "wited", "awaired", "witted", "watisted", "wits", "waits", "waiter", "Waiter", "awited", "waitted"], "ret": ["gt", " Ret", "resp", "done", "t", "re", "out", "lit", "it", "rev", "print", "cont", "set", "ref", "rets", "Return", "rem", "err", "Ret", "val", "tech", "arr", "ter", "il", "pret", "data", "reset", "sat", "lt", "tr", "selected", "result", "mt", "found", "ft", "rt", "tmp", "res", "alt", "reg", "mem", "nt", "RET", "len", "ll", "elt", "flag", "local", "sent", "fit"], "max_transfer": ["max_response", "max_send", "maximum_send", " max_trans", "max_Transfer", "maxuserresponse", "max2transfer", " max2download", "maxusertransfer", "maximum_transfer", " max_Transfer", " max_write", " max_download", "maxusertransform", " max2Transfer", "maximum_response", "max2Transfer", "max_trans", "max_download", "maxusersend", " max2transfer", "max2download", "max_transform", "max_write", "maximum_transform"]}}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "substitutes": {"bs": ["ubis", "blog", "boxes", "sys", "lbs", "bits", "os", "ubs", "ns", "BS", "ss", "bps", "outs", "aos", "iss", "ps", "lb", "cs", "bc", "sts", "fs", "gs", "rs", "ds", "bis", "ls", "bm", "ms", "vs", "ats", "hs", "bes", "js", "its", "ts", "obs", "pb", "aus", "sb", "bos", "b", "bp", "bb"], "sector_num": [" sector_master", "sectoritynom", "sector_master", "ser_num", "sectorNamemaster", "ector_nam", "sector_loc", "sector_number", "ector_number", " sector_mon", "ser_number", "sectorNamenom", "sectoritymaster", "sectoritynumber", "sectorNamenum", "sector_nam", "ector_num", "ser_loc", "sector0num", "sectorNamemon", "sectoritynum", "sectoritynam", "sector_mon", "sector0number", " sector_nom", "sectoritymon", "ser_mon", "sector_nom", "ector_mon", "sector0loc", "sector0mon"], "buf": ["rb", "msg", "cap", "bits", "off", "h", "length", "window", "err", "read", "late", "aka", "Buff", "uf", "bar", "Buffer", "bc", "cv", "data", "max", "fb", "bytes", "vec", "cur", "batch", "proc", "nb", "lim", "img", "rw", "ctx", "raw", "br", "xff", "queue", "num", "tmp", "seq", "db", "buffer", "doc", "buff", "pb", "block", "cmd", "bin", "blocks", "len", "np", "BU", "b", "bp", "pad", "padding"], "nb_sectors": ["nb_megments", "nb_mectors", "nb_pegs", "nb_seors", "nb_vegs", "nb_pselements", "nb_SElements", "nb_SEgments", "nb_segments", "nb_meors", "nb_seivers", "nb_vegments", "nb_veivers", "nb_SEors", "nb_vellers", "nb_psegments", "nb_vectors", "nb_selements", "nb_pellers", "nb_veors", "nb_lectors", "nb_peors", "nb_lellers", "nb_meivers", "nb_leors", "nb_segs", "nb_sellers", "nb_legs", "nb_velements", "nb_ectors", "nb_pseors", "nb_eors", "nb_egments", "nb_pectors", "nb_psectors", "nb_eivers", "nb_SEctors"], "cb": ["fn", "fun", "rb", "eb", "ck", "bf", "func", "callback", "dc", "gb", "etc", "erb", "lb", "CB", "unc", "ctrl", "bc", "dt", "conn", "cd", "cv", "c", "fb", "cli", "nb", "ctx", "wb", "db", "cf", "kb", "pb", "cmd", "tc", "conf", "nc", "cc", "b", "bp", "fc", "sb", "obb", "cp", "cfg", "abb"], "opaque": ["opula", "obcode", "epoch", "opcode", "iopaque", "hopaque", "ipacity", "potque", "uppula", "opsent", "epaque", "iopcode", "obus", "OPus", "operque", "OPaque", "operacity", "ompque", "opent", " opula", "hopent", "hopque", "potaque", "ipaque", "potacement", "operaque", "opoch", "obaque", "potent", "epula", "OPque", "iopque", "iopus", "uppaque", "ompula", "OPcode", "ompacity", "opacity", " opoch", "opacement", "uppoch", "operula", "ompaque", "obque", "uppacement", "opsaque", "opsque", "ipula", "epacement", "ipque", "opque", "hopacement", "opsacement", " opacement", "opus"], "acb": ["accp", " cacb", "micbl", "facor", "ainwb", "acona", "aconpb", "ackib", "abcob", "aconb", "pacib", "ascbar", "auwb", "acw", "acbe", "accbc", "facg", "aca", "acba", "aicob", "aub", "aclbe", "aclb", "Acob", " acw", "abb", "ainl", "Acgb", " acbar", "accf", "pacb", "aconp", " acbe", "ackbb", "iacn", "accnb", "aba", "acbr", "accgb", "Acnb", "facob", "acbar", "Acbd", "aicb", "acaib", "ascpb", "aubr", "Acn", "aclwb", "facb", " cacbr", "acl", "accbd", "ainb", "iacb", "accn", " cacbc", "abcbl", "accbb", " acl", "pacbb", "ainbe", "ocB", "aconbd", "acabb", "acca", "accb", "aicg", "acfb", "acgb", "abbd", " acB", "abcbd", " acwb", "pacfb", "acll", "aconbar", "acB", " cacwb", "ocb", " acpb", " acp", "accB", "acafb", "aconba", "acbc", "acib", "iacgb", "abf", "acob", "Acbl", "aconbb", "acwb", "acg", "acbd", "micob", "ackfb", "abg", "Acb", "acnb", "iacnb", "acab", "accwb", "abor", "aicor", "acbb", "ascB", "acbl", "abcb", "abob", "acn", "aconf", "ocbb", "acp", "acpb", "acf", "acor", "aconB", "aconw", "aubc", "ackb", "ocba", "accba", "accw", "micbd", "ascb", "accbr", "micb"], "s": ["n", "p", "is", "sys", "bits", "os", "ns", "ss", "ses", "stats", "ps", "cs", "sts", "rs", "gs", "fs", "ds", "ls", "vs", "ats", "hs", "S", "js", "g", "es", "its", "sq", "ts", "http", "ins", "als", "xs", "sb"], "bh": ["phi", "dh", "lr", "ht", "zh", "hun", "bf", "eh", "hap", "hh", "hal", "shr", "igh", "oh", "h", "hub", " inh", "bl", "ha", "lb", "fw", "mu", "thro", "ith", "bis", "hw", "hr", "ih", "bo", "bm", "br", "hz", "sh", "ph", "kh", "ssl", "rh", "hs", "hl", "hp", "phy", "uh", "bec", "rl", "bt", "sbm", "orth", "bol", "ah", "oth", "b", "bp", "hi", "gh"]}}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 23405, "substitutes": {"child": ["parent", "create", "ach", "f", "h", "window", "root", "children", "count", "x", "i", "ind", "sim", "Child", "row", "test", "c", "node", "close", "handle", "j", "col", "brother", "cell", "q", "entry", "ch", "job", "pc", "block", "kid", "client", "b", "v", "handler", "shell"], "sector_num": ["sector___nr", " sector_index", " sector_number", "sector___index", "sector_number", "sector_index", "sectoretynumber", " sector_mon", "sectoretyindex", "sectoretynum", "sector___num", "sector_nr", "sector_mon", "sectoretymon", "sector___number", " sector_nr"], "nb_sectors": ["nb_vesputers", "nb_neors", "nb_seors", "nb_perserers", "nb_neivers", "nb_spellers", "nb_necs", "nb_seivers", "nb_vesctors", "nb_speivers", "nb_specs", "nb_nearers", "nb_veputers", "nb_nectors", "nb_nellers", "nb_vellers", "nb_nevers", "nb_vectors", "nb_seearers", "nb_veors", "nb_perseors", "nb_speors", "nb_speputers", "nb_persectors", "nb_verers", "nb_vevers", "nb_seectors", "nb_nerers", "nb_sellers", "nb_vescs", "nb_severs", "nb_searers", "nb_spevers", "nb_persecs", "nb_spearers", "nb_vecs", "nb_secs", "nb_vesors", "nb_seputers", "nb_seeors", "nb_seeivers", "nb_spectors", "nb_serers"], "qiov": ["iqrov", "ckiov", "qiva", "iqiov", "ckovi", " qurov", "sqiov", "Qiov", "Qovi", "sqiev", "sqovi", "Qiour", "ckiev", "iqiour", " qiour", "qiour", "iqiva", "qiev", " quiva", " quiour", " qiva", "qrov", " qrov", "qovi", "Qiev", "ckiour", "sqiour", " quiov"], "flags": [" fps", " Flags", "bits", "heads", "settings", "rates", "phones", " signs", "weights", "alities", "alf", "tags", "bugs", "acts", " winds", " seeks", "fits", "FLAG", " styles", " interests", "comments", " lands", "locks", "faces", "files", "tif", "details", "atts", "utils", "cond", " quirks", "xf", " heads", "posts", "ads", " feats", "Flags", "cmd", "ags", "options", "fps", "members", "flag", "limits", "lag", " futures", " concerns", "ents"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n", "idx": 23411, "substitutes": {"signal": ["signaler", "Signaler", "Signal", " signals", " signalals", " signalal", "signals", " signaler", "Signals", " signalaler"]}}
{"project": "FFmpeg", "commit_id": "b3f9f7a33337e9b64e6044b0010e2722fa0b2f9c", "target": 0, "func": "static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)\n\n{\n\n    MpegTSFilter *tss;\n\n    PESContext *pes;\n\n\n\n    /* if no pid found, then add a pid context */\n\n    pes = av_mallocz(sizeof(PESContext));\n\n    if (!pes)\n\n        return 0;\n\n    pes->ts = ts;\n\n    pes->stream = ts->stream;\n\n    pes->pid = pid;\n\n    pes->pcr_pid = pcr_pid;\n\n    pes->stream_type = stream_type;\n\n    pes->state = MPEGTS_SKIP;\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);\n\n    if (!tss) {\n\n        av_free(pes);\n\n        return 0;\n\n    }\n\n    return pes;\n\n}\n", "idx": 23425, "substitutes": {"ts": ["td", "t", "sys", "tt", "TS", "kt", "aps", "te", "tp", "tar", "ss", "ims", "ns", "tis", "stats", "ps", "tz", "bs", "mint", "pt", "cs", "sts", "times", "fs", "rs", "tx", "ds", "s", "tr", "tim", "tv", "mt", "mos", "Ts", "ctx", "utt", "ls", "ms", "ats", "js", "pc", "tc", "wt", "tm", "tes", "uts"], "pid": ["perm", "mk", "p", "pse", "oid", "process", "pard", "ping", "vid", "mid", "por", "wid", "pkg", "key", "ps", "pt", "pp", "po", "id", "pri", "pa", "temp", "proc", "pipe", "png", "pen", "pr", "part", "pe", " PID", "db", "pan", "phy", "pin", "phys", "fd", "path", "ppa", "pc", " tid", "pg", "sid", "pos", "pai", "port", "pi", "uid", "pd", "pty", "bid", "PK", "pic", "type"], "pcr_pid": ["pcr_pa", "pcr_sid", "ptr_pid", "ptr_pi", "pcm_ps", "pcr_ps", "pcm_sid", "ptr_pa", "pcm_pid", "pcr_pos", "pcr_id", "ptr_pos", "ptr_port", "pcr_pc", "pcm_id", "ptr_pc", "pcr_pi", "pcr_port"], "stream_type": ["port_types", " stream_handle", " stream_comment", "stream_comment", "stream3types", "stream_ype", "stream_handle", " stream_ype", "port_name", "stream_Type", " stream_Type", "stream_name", "stream_types", "stream3comment", " stream_types", "stream3ype", "stream_key", "port_color", "stream3type", " stream_key", "port_type", "stream_color"], "tss": ["Tiss", "pst", "pse", " tst", " tcss", "TSS", "piss", "mss", "wtrss", "Trss", "wtss", "pss", " tSS", " tse", " trss", "tcss", "tst", "Tss", " tiss", "pcss", "trss", "tiss", "pSS", "wtSS", "mrss", "mcss", "wtst", "tse", "tSS", "wtiss", "mse", "prss"], "pes": ["ports", "xes", "phis", "ees", "pet", " peas", "las", "kes", "ape", "oples", "plings", "projects", "packs", "ces", "pe", "types", "es", "xs", "ins", "lists", "aus", "params", " pets", "ples", "eas", "maps", "plugins", "anes", "edes", "amps", "pots", "men", "pres", "ers", "vs", "ites", "odes", "posts", "pps", "qs", "PE", "cas", "plates", "pas", "mes", "mas", "pse", "aps", "ques", "ps", "inces", "mits", "photos", "lets", "ves", "ists", "pha", "Ps", " ps", "phones", " cups", "pex", "ses", "ames", "pl", " pops", "eps", "ducers", "pers", "ped", "locks", "elines", "lex", "GES", "Types", "vals", "makes", "pins", "ips", "ges", "ettes", " pas", "phys"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void mpeg_motion_internal(MpegEncContext *s,\n\n                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                 int field_based, int bottom_field, int field_select,\n\n                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int dxy, uvdxy, mx, my, src_x, src_y,\n\n        uvsrc_x, uvsrc_y, v_edge_pos;\n\n    emuedge_linesize_type uvlinesize, linesize;\n\n\n\n#if 0\n\nif(s->quarter_sample)\n\n{\n\n    motion_x>>=1;\n\n    motion_y>>=1;\n\n}\n\n#endif\n\n\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    src_x = s->mb_x* 16               + (motion_x >> 1);\n\n    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);\n\n\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n\n        if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){\n\n            mx = (motion_x>>1)|(motion_x&1);\n\n            my = motion_y >>1;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        }else{\n\n            uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n\n            uvsrc_x = src_x>>1;\n\n            uvsrc_y = src_y>>1;\n\n        }\n\n    }else if(!is_mpeg12 && s->out_format == FMT_H261){//even chroma mv's are full pel in H261\n\n        mx = motion_x / 4;\n\n        my = motion_y / 4;\n\n        uvdxy = 0;\n\n        uvsrc_x = s->mb_x*8 + mx;\n\n        uvsrc_y =    mb_y*8 + my;\n\n    } else {\n\n        if(s->chroma_y_shift){\n\n            mx = motion_x / 2;\n\n            my = motion_y / 2;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        } else {\n\n            if(s->chroma_x_shift){\n\n            //Chroma422\n\n                mx = motion_x / 2;\n\n                uvdxy = ((motion_y & 1) << 1) | (mx & 1);\n\n                uvsrc_x = s->mb_x* 8           + (mx >> 1);\n\n                uvsrc_y = src_y;\n\n            } else {\n\n            //Chroma444\n\n                uvdxy = dxy;\n\n                uvsrc_x = src_x;\n\n                uvsrc_y = src_y;\n\n            }\n\n        }\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0)\n\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&1) - h , 0)){\n\n            if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n               s->codec_id == AV_CODEC_ID_MPEG1VIDEO){\n\n                av_log(s->avctx,AV_LOG_DEBUG,\n\n                        \"MPEG motion vector out of boundary (%d %d)\\n\", src_x, src_y);\n\n                return;\n\n            }\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n\n                                17, 17+field_based,\n\n                                src_x, src_y<<field_based,\n\n                                s->h_edge_pos, s->v_edge_pos);\n\n            ptr_y = s->edge_emu_buffer;\n\n            if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n                uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize;\n\n                s->vdsp.emulated_edge_mc(uvbuf ,\n\n                                    ptr_cb, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n\n                                    ptr_cr, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                ptr_cb= uvbuf;\n\n                ptr_cr= uvbuf+16;\n\n            }\n\n    }\n\n\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n\n        dest_y += s->linesize;\n\n        dest_cb+= s->uvlinesize;\n\n        dest_cr+= s->uvlinesize;\n\n    }\n\n\n\n    if(field_select){\n\n        ptr_y += s->linesize;\n\n        ptr_cb+= s->uvlinesize;\n\n        ptr_cr+= s->uvlinesize;\n\n    }\n\n\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n\n    }\n\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n\n         s->out_format == FMT_H261){\n\n        ff_h261_loop_filter(s);\n\n    }\n\n}\n", "idx": 23429, "substitutes": {"s": ["n", "comm", "i", "er", "p", "t", "sys", "is", "times", "r", "os", "set", "source", "m", "ss", "ns", "ims", "changes", "ses", "stats", "d", "ps", "https", "bs", "cs", "e", "sports", "fs", "gs", "sts", "sim", "c", "rs", "ds", "aws", "se", "z", "ctx", "spec", "ls", "details", "q", "ex", "ms", "sv", "sw", "ats", "vs", "hs", "sc", "S", "js", "g", "es", "ins", "sq", "ts", "its", "webkit", "http", "conf", "qs", "less", "sb", "b", "as", "v", "w"], "dest_y": ["src_xy", "src_yy", "src_Y", "dest_xy", "dest_yy", "dest_Y"], "dest_cb": ["dest_cm", "dest_ca", "src_rb", "dest___ca", "dest___cm", "src_cb", "dest___cb", "dest_rb", "dest___rb", "src_ca", "src_cm"], "dest_cr": ["dest2rx", "src_r", "dest_rx", "src_rx", "src_cd", "dest2cr", "dest2cd", "dest_r", "dest_cd", "dest2r", "src_cr"], "field_based": ["rule_relative", "FIELD_fed", "field_listed", "field_used", "fieldlyrelative", "Field_base", "fieldvalspecified", "field2basic", "rulevalbased", "field8backed", "field8based", "field08linked", "FIELD_based", "field_checked", "fieldlybased", "rule_based", "FIELD_bas", "fieldvalrelative", "field_linked", "Field_basic", "field_Based", "fieldlyspecified", "field_basic", "FIELD_Based", "FIELD_bid", "fieldlylisted", "field_base", "field_relative", "FIELD_bent", "field8linked", "rule_specified", "field_specified", "fieldleBased", "field2relative", "Field_relative", "field____basic", "fieldlechecked", "rulevalspecified", "fieldablebased", "field_fed", "fieldlespecified", "field2base", "fieldlelisted", "rulevallisted", "rulevalrelative", "fieldablechecked", "rule_listed", "fieldlerelative", "field08base", "field_backed", "field____based", "FIELD_linked", "FIELD_used", "fieldableBased", "field08based", "fieldablebas", "FIELD_backed", "field____base", "fieldlebased", "field____relative", "field08backed", "fieldlebas", "FIELD_checked", "FIELD_base", "fieldvallisted", "field2based", "field_bent", "field_bas", "Field_based", "fieldvalbased", "field8base", "field_bid"], "bottom_field": ["bottomletmargin", "bottomlevelmargin", "orderletfield", "orderletweight", "orderletformat", "bottom_format", "bottomwatermargin", "bottomwaterweight", "bottom_weight", "bottomwaterfield", "bottomletformat", "bottomletfield", "order_format", "bottom_margin", "order_field", "bottomwaterformat", "bottomlevelformat", "order_weight", "bottomlevelfield", "order_margin", "orderletmargin", "bottomletweight", "bottomlevelweight"], "field_select": ["fieldityselect", "Field_selection", "field_selection", "field_selected", "Field_supported", "fieldityselected", "Field_select", "Field_selected", "fieldityselection", "fielditysupported", "field_supported"], "ref_picture": ["ref_image", "refgrcamera", "img_pic", "refgrpicture", "img_image", "ref_pic", "img_picture", "refgrimage", "refgcamera", "refgrpic", "refgpicture", "img_camera", "refgimage", "ref_camera", "refgpic"], "pix_op": ["pixels2info", "pix_comp", "pixels2comp", "pix___op", "pix2comp", "pixels2oper", "pix2op", "pix___oper", "pix_oper", "pixels_op", "pix2oper", "pix___info", "pixels_oper", "pixels2op", "pix2info", "pixels_info", "pix___comp", "pixels_comp", "pix_info"], "motion_x": ["motion____y", "motion____xx", "vision09y", "music_x", "prop_rx", "movie___y", "prop_x", " motion_z", "vision_y", "loss_num", "movie___xi", "motion03x", "motionTimexml", "loss_y", "vision_xf", "movie___x", "motion_z", "music09x", "music09xd", "propTimex", "motion___ex", "motion_el", "music_y", "motion_ex", "vision09x", "propTimerx", "motion03ax", "motion____x", "motion___y", "music09y", "motion09el", "motion03xi", "movie_x", "motion09xf", "motion03y", "motionTimeX", "motion_rx", "vision09xf", "vision_ex", "vision_x", "motion_xf", "motion_w", "motion____num", "Motion_y", "motion_xml", "Motion_xi", "music_xd", "movie_ax", "motion09xd", " motion_w", "motion___ax", "motion_num", "motion09ex", "loss_xx", "motion_xi", "movie_xi", "loss_x", "Motion_ex", "music09el", "motionTimerx", "motion_xd", "propTimeX", "motion_X", "propTimexml", "prop_xml", "motion09y", "motion_xx", "motion_ax", "movie___ax", "vision09ex", "motion___x", "Motion_x", "motion___xi", "motionTimex", "prop_X", "movie_y", "music_el", "motion09x"], "motion_y": ["motion00cy", "detail00entity", "motion08p", "motion08z", "motion_z", "position_sy", " motion_Y", "motion10sy", "position_yy", "motion00y", "motion______yy", " motion_entity", "motion10yy", "motion_entity", "motion_Y", "detail00ey", "motion_sy", "position_ny", "detail_y", " motion_cy", "motion00z", "movie_x", "motion______ny", "mission08z", "motion08y", "motion00Y", "detail_entity", "motion10ny", "motion______y", " motion_ny", "detail_z", "mission08x", "position_y", "movie_sy", "motion10y", "motion_ey", "motion______x", "mission08y", "movie_yy", "motion08x", "motion_yy", "mission_p", "motion00entity", "detail00z", "mission_y", "motion_ny", " motion_yy", "mission08p", "motion00ey", "motion_cy", "detail00y", "mission_z", "mission_x", "movie_y", "detail_ey", "motion_p"], "h": ["p", "t", "it", "hh", "H", "f", "oh", "m", "hash", "e", "i", "c", "hw", "z", "ih", "height", "k", "bh", "hz", "q", "kh", "hs", "ch", "b", "l", "v", "w"], "is_mpeg12": ["is_mp8", "is__mpeg12", "is__peg12", "is_peg12", "is_video12", "is_mp12", "is_video23", "is_peg2", "is_mpeg2", "is_mp2", "is_mpeg8", "is_peg23", "is_video2", "is_video8", "is_cam2", "is_cam11", "is__peg8", "is_peg8", "is_mpeg23", "is_cam23", "is__mpeg8", "is__peg2", "is_video11", "is_mpeg11", "is_peg11", "is__mpeg2", "is_cam12"], "mb_y": ["src_sy", "mboxy", "mb_yl", "MB_ye", "src64y", "mboxpy", "mb8Y", "mb08ye", "mb64sy", "MB_Y", "mboeY", "mb______y", "mb_sy", "MB8y", "mb00cy", "mb64yl", "MB_yy", "mboey", "mb______cy", "MB8py", "MB8yy", "mboxyy", "mb08ym", "mb_ym", "src_cy", "mb08y", "mb64cy", "mb_cy", "MB_y", "mb_yy", "mb00y", "mb8y", "mb8yy", "mboeyy", "src_yl", "mb_Y", "MB_py", "mb00sy", "mb64y", "src64cy", "mb8py", "src64sy", "mb______yl", "mb_ye", "MB8Y", "mb00yl", "mboepy", "src64yl", "MB_ym", "mb_py", "mb______sy", "mboxY", "mb08yy"], "ptr_y": ["ptr_ye", "ptr_xy", "ptr00y", "ptr_yy", "ptr00xy", "dest_xy", "dest_yy", "dest_ye", "ptr00yy", "ptr00ye"], "ptr_cb": ["ptr48cb", "dest_cgi", "ptr48cgi", "ptr_rb", "ptr___rb", "ptr48cy", "ptr_cgi", "dest_cy", "dest_rb", "ptr___cgi", "ptr___cy", "ptr___cb", "ptr48rb", "ptr_cy"], "ptr_cr": ["ptr55cd", "dest_col", "ptr_col", "ptr__col", "ptr_ctr", "ptr_cd", "ptr__ctr", "ptr55cr", "ptr55ctr", "dest_ctr", "ptr__cd", "dest_cd", "ptr55col", "ptr__cr"], "dxy": ["dux", "sdwy", "fdxf", "pdxf", "fdbits", "Dux", "pdoxy", "sdxy", " dxf", "bdxy", "bdwy", " doxy", "dbits", "pdxy", "bdux", "Dxy", "dXY", " dux", "bdwx", " dbits", "pdbits", "doxy", "sdoxy", " dXY", "odwx", "odoxy", "bdoxy", "odwy", "Doxy", "fdoxy", "DXY", "bdXY", "odxy", "dwy", "dwx", "dxf", "fdxy", "sdwx"], "uvdxy": ["nvdxy", "uvddbits", "uvhdgb", "uudxy", "nvdbits", "uvdbits", "uvdsaxy", "nvdhbits", "uvdiffaxy", "uvdhwy", "nvdhxy", "uvhdxy", "uvmdxy", "uvdsxx", "uvdtbits", "nvddj", "ukdiffXY", "uvdhdj", "uuhdxy", "ukdxx", "uvdsxy", "uvhdcho", "uvdddj", "uvmdcho", "uvdhxy", "uvddgb", "uvdiffxy", "nvdhdj", "uuhdwy", "uvdiffXY", "uuhdgb", "uvdhxx", "uvddxy", "ukdiffaxy", "uvdgb", "uvddj", "uvdhcho", "uudcho", "uvdtdj", "uvmdwy", "ukdiffxx", "uvdxx", "uvdhaxy", "uudwy", "nvdgb", "uvdsXY", "ukdaxy", "uvdhXY", "uvdcho", "uvdtgb", "uvmdgb", "uvdhgb", "uvdXY", "ukdxy", "ukdXY", "uudgb", "uvdiffxx", "ukdiffxy", "uvdhbits", "uvdtxy", "uvdwy", "uuhdcho", "uvdaxy", "uvhdwy", "nvdhgb"], "mx": ["MX", "mk", "yy", "xx", "mr", "py", "mm", "mmm", "m", "pm", "y", "ox", "ml", "yx", "mb", "ey", "x", "nz", "mp", "mint", "ias", "vm", "tx", "axis", "xy", "md", "rx", "mo", "mt", "wx", "mouse", "hz", "ms", "px", "ux", "xs", "mis", "mc", "MY", "yz", "mi", "mic", "mie", "tm", "mys", "mn", "wm"], "my": ["mk", "yy", "xx", "py", "me", "mm", "mmm", "ys", "m", "pm", "y", "mid", "ox", "ml", "yx", "fy", "mb", "cy", "x", "mp", "ny", "vy", "xy", "ami", "md", "mt", "mouse", "mg", "ms", "My", "js", "mem", "mon", "mc", "mis", "mi", "ty", "mic", "mys", "mie", "gy", "mn", "MI", "MY", "ram"], "src_x": ["src_ex", "mat", "source_xy", "func", "jpg", "src_xy", "ref", "source_dx", "src_dx", "def", "xy", "img", "source_y", "source_x", "new", "source_ex", "cam", "_"], "src_y": ["source_Y", "rc_yy", "src__ym", "src__yy", "source_ys", "src_yy", "src__x", "src_Y", "source_ym", "source_y", "rc_x", "rc_y", "rc_ym", "src__y", "src_ys", "src_ym"], "uvsrc_x": ["uvrc_x", "uvrc_y", "uvsrc_wx", "uvsrc_z", "uvsrc_X", "uvsource_xi", "uvsrc___wx", "uvdest_y", "uvdest_php", "uvrc_dx", "uvsrc___y", "uvsrc___dx", "uvdest_X", "uvrc_wx", "uvsource_z", "uvsrc_xi", "uvsource_y", "uvdest_x", "uvsrc_php", "uvsrc___x", "uvsrc_dx", "uvsource_x"], "uvsrc_y": ["uvdest_yy", "uvsyn_y", "uvsrc__a", "uvsrc__yy", "uvdest__x", "uvdest__n", "uvsrc_n", "uvsyn_a", "uvsyn_x", "uvdest_n", "uvsrc_a", "uvsrc__py", "uvsrc__n", "uvsrc__y", "uvdest_y", "uvsrc_yy", "uvsrc__x", "uvsrc_py", "uvsyn_py", "uvdest__y", "uvdest_x", "uvdest__yy"], "v_edge_pos": ["v_edge_position", "v_node_pos", "v_ge_Pos", "v_ge_pos", "v_ge_loc", "v_node_position", "v_node_Pos", "v_edge_loc", "v_ge_position", "v_edge_Pos", "v_node_loc"], "uvlinesize": ["uintlinesensor", "uvlinksiz", " ovlineszie", "uintlinesiz", " ovlinize", " ovlinesign", "uvlinkszie", "uvbytesiz", "uintineszie", "uvbytesensor", "uvbyteszie", " ovlinign", "uvlineszie", "uintinesensor", " ovlinesize", "uvlinesiz", "uvinesiz", "uvfieldszie", "uintlineszie", "uvlincale", "uvinesize", "uvlinize", " ovlinescale", "uvlinign", "uvfieldsign", "uvineszie", "uvlinzie", "uvlinesign", "uvlinsign", "uvlinesensor", "uvlinscale", "uvlinksize", " ovlinzie", "uvinesensor", "uvbytesize", "uvlinescale", "uintinesiz", "uvlinksensor", "uvlinsize", "uvlinszie", " ovlincale", "uintinesize", "uvfieldscale", "uintlinesize", "uvfieldsize"], "linesize": ["inessize", " linesizes", "codesize", "linesIZE", "framesize", "boxesizes", "elinesiz", "inesizer", "platesization", "boardssize", "platessize", " linesization", "boxesization", "codesizer", "boardsization", "pagessize", "pagesizer", "inesiz", " linesiz", "codesiz", "pagesize", "linesizer", "inesization", "platesizer", "elinesze", "boxesIZE", "linesze", "linesizes", "pagesiz", "codessize", "linesiz", "linessize", "inesze", "linesization", "boxesize", " linesIZE", "framesIZE", "elinesize", "inesize", "platesize", "framesizes", "boardsize", " linesze", "boardsizer", "inesizes", "elinesizes", "framesization"]}}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n", "idx": 23455, "substitutes": {"cpu": ["core", "gpu", "ck", "alloc", "ilo", "cat", "processor", "process", "xi", "met", "tp", "thread", "gc", "ct", "pkg", "prof", "copy", "conn", "cu", "cum", "mu", "vm", "c", "node", "jp", "proc", "hw", "mac", "pu", "aux", "kernel", "hz", "clock", "phy", "util", "pc", "uu", "CPU", "linux", "pai", "comp", "gp", "phys", "cp", "net"], "config_change": ["config_alter", "config08edit", " config_adjust", "config_edit", "configogchange", " config_check", " config2change", "config2edit", " config2edit", "config08change", "conf_change", "configletadjust", "configletedit", "config_adjust", "conf_alter", " config_edit", "config2check", "config2change", "config08conf", " config2conf", "config_add", "config08check", "configogadd", " config_conf", " config2check", "configletchange", "config2conf", "config_check", "conf_add", "config_conf", "configogalter"], "token": ["ok", "t", "state", "msg", "time", "txt", "tag", "number", "secret", "amount", "index", "tn", " random", "policy", "length", "scan", "seed", "channel", "session", "serial", "key", "total", "tty", "tk", "round", "node", "temp", "batch", "ti", "status", "lock", "KEN", "event", "password", "auth", "rule", "Token", "at", "template", " key", "fd", "util", "tree", "typ", "wt", "sid", "json", "TO", "stick", "strength", "local", "oken"]}}
{"project": "FFmpeg", "commit_id": "dde0af2df1caffb9e33855c08fc691dbbbbc72b3", "target": 0, "func": "static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)\n\n{\n\n    int i;\n\n    static const uint8_t LUT[256] = {\n\n        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n    };\n\n\n\n    /* Read all the lengths in first */\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* At most we need to read 9 bits total to get indices up to 8 */\n\n        int val = show_bits(gb, 8);\n\n\n\n        // read reverse unary\n\n        if (val) {\n\n            val = LUT[val];\n\n            skip_bits(gb, val + 1);\n\n            ctx->len[i] = val;\n\n        } else {\n\n            skip_bits(gb, 8);\n\n            if (!get_bits1(gb))\n\n                return -1;\n\n            ctx->len[i] = 8;\n\n        }\n\n    }\n\n\n\n    /* For any values that have length 0 */\n\n    memset(ctx->val, 0, ctx->size);\n\n\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* Check we have enough bits left */\n\n        if (get_bits_left(gb) < ctx->len[i])\n\n            return -1;\n\n\n\n        /* get_bits can't take a length of 0 */\n\n        if (ctx->len[i])\n\n            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23465, "substitutes": {"ctx": ["kw", "rc", "context", "ref", "conv", "ct", "pkg", "ctrl", "conn", "bc", "cv", "tx", "cmp", "setup", "bm", " cx", "cf", " context", "mc", "cmd", "conf", "obj", "tc", "nc", "cc", "ca", "fc", "cp", "xc"], "gb": ["gt", "ig", "gpu", "bf", "cb", "gm", "gc", "mb", "rg", "eg", "bc", "vg", "gs", "vm", "cv", "fg", "img", "bg", "lib", "db", "storage", "BG", "g", "kb", "sg", "GB", "sb", "uk", "cfg"], "i": ["bi", "M", "t", "p", " M", "m", " l", " I", " m", " ii", " n", "I", " t", "j", "li", " bi", " b", " j", " v", " pi", " offset", " d", "ii", " c", "pi", "b", "v", " e"], "LUT": ["Hut", "BLUB", "LUN", " Lut", "LUB", " LUN", "HUT", "BLUT", "HUN", "Lut", "BLUN", "HUB", "BLut", " LUB"]}}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n\n                const AVIOInterruptCB *int_cb)\n\n{\n\n    URLProtocol *up = NULL;\n\n    char proto_str[128], proto_nested[128], *ptr;\n\n    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n\n\n\n    if (filename[proto_len] != ':' || is_dos_path(filename))\n\n        strcpy(proto_str, \"file\");\n\n    else\n\n        av_strlcpy(proto_str, filename,\n\n                   FFMIN(proto_len + 1, sizeof(proto_str)));\n\n\n\n    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n\n    if ((ptr = strchr(proto_nested, '+')))\n\n        *ptr = '\\0';\n\n\n\n    while (up = ffurl_protocol_next(up)) {\n\n        if (!strcmp(proto_str, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n\n            !strcmp(proto_nested, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n    }\n\n    *puc = NULL;\n\n    return AVERROR_PROTOCOL_NOT_FOUND;\n\n}\n", "idx": 23470, "substitutes": {"puc": ["pcon", "hoc", "vud", "pcu", "vuu", "huc", "hunc", "nuc", "vcu", "poc", "hcu", "puu", "cunc", "munc", "noc", " puu", "nunc", "cuc", "muc", "ccon", "coc", "cuu", "nuu", " pbc", "cbc", "huu", " pud", "pud", "pbc", " punc", "punc", "mbc", "hud", " poc", " pcu", "mcon", " pcon", "ccu", "vuc"], "filename": ["fn", "n", "name", "username", "binary", "fle", "txt", "source", "jpg", "f", "tp", "lua", "length", "aka", "title", "dir", "original", "src", "Filename", "ames", "ame", "fs", "microsoft", "journal", "folder", "files", "fp", "family", "fil", "buf", "png", "nm", "names", "strings", "directory", "river", "position", "wit", "via", "location", "nil", "ren", "subject", "wcs", "path", "ename", "prefix", "fd", "cmd", "mpeg", "utf", "wikipedia", "kj", "json", "FIL", "til", "file", "origin", "uri", "wav"], "flags": ["issues", " Flags", "ports", "links", "bits", "heads", "uses", "func", "weights", "hips", "ods", "parts", "tags", "bugs", "acts", "amps", "stats", "ints", "FLAG", "aints", "terms", "licts", "fs", "groups", "args", "comments", "locks", "states", "faces", "frames", "rights", "planes", "status", "tif", "caps", "atts", "utils", "cond", "levels", "types", "cf", "properties", "pins", "wcs", "posts", "ants", "fts", "limits", "Flags", "features", "ags", "xxx", "options", "fps", "doms", "actions", "endif", "members", "flag", "includes", "ensions", "lag", " concerns", "fields"], "int_cb": [" int_callback", "int__callback", "int10cb", "int_obb", "int___abb", "int10obb", "int_conv", "int11erb", "int__erb", " int_pb", "int__cb", "int11callback", "int10callback", "int_conn", "int_pb", "int___conv", "int11conn", "int_abb", "int___cb", " int_erb", " int_obb", "int___callback", " int_conv", " int_abb", " int_conn", "int_callback", "int10pb", "int__conn", "int11cb", "int_erb"], "up": ["sup", "uper", "p", "all", "upper", "vp", "cap", "out", "prom", "through", "high", "prov", "Up", "du", " ups", "ul", " u", "pkg", "UP", "ps", "own", "uf", "um", " UP", "mp", "down", "wp", "user", "ump", " down", "over", "uc", "omp", "jp", "cmp", "local", "ip", "ap", "low", "pper", "op", "uv", "plus", "ub", " Up", "upid", "ex", "dem", "home", "ouch", "ow", "in", "ud", "ux", "au", "ou", "upt", "upp", "adv", "rup", "ups", "u", "uph", "pre", "upload", "ra", "cp", "flow", " upl", "U"], "proto_str": ["proto__br", "proto_def", "propo_ctr", "proto_dr", "protu_arr", "proto_string", "proto2str", "propo_string", "proto__str", "proto_tree", "proto__dr", "propo2char", "proto2char", "proto_char", "protu_str", "proto_ctr", "proTo_arr", "proTo_string", "protu_del", "proto_arr", "propo_str", "proto__string", "proto_br", "protu_tree", "proTo_r", "proto2string", "proto_r", "proTo_str", "proto_div", "proto___string", "propo2ctr", "propo2string", "propo_char", "proto___div", "proto2ctr", "propo2str", "proto_del", "proto___str", "proto__div"], "proto_nested": ["proto2norest", "proto_Nest", "proto_nEST", "proto_ngested", "proto_cnained", "proto_Nesting", "proto2nested", "proto_pached", "proto_pest", "proto_NEST", "proto_nanesting", "proto_tached", "proto_cest", "proto_neashed", "proto_nained", "proto_cnesting", "proto_norained", "proto_tumbered", "proto_tored", "proto_enored", "proto_pested", "proto_cnested", "proto_Nested", "proto_tested", "proto_ngored", "proto2nesting", "proto2norained", "proto_enest", "proto_noresting", "proto_Nained", "proto_nanest", "proto2norested", "proto_nesting", "proto_norached", "proto2nest", "proto_neest", "proto_norested", "proto_norest", "proto_ngest", "proto_cnest", "proto_neested", "proto_enesting", "proto_nest", "proto_nashed", "proto_ngesting", "proto_cashed", "proto_testing", "proto_pumbered", "proto_test", "proto_nored", "proto_cested", "proto_enested", "proto_nanEST", "proto_nanested", "proto_tEST", "proto_norumbered", "proto2noresting", "proto_numbered", "proto_nached", "proto2nained", "proto_pashed"], "ptr": ["t", "p", "lr", "alloc", "r", "Ptr", "ref", "tp", "offset", "rel", "bl", "th", "vr", "src", "ps", "pt", "loc", "arr", "dest", "str", "jp", "cur", "tr", "proc", "fp", "fr", "buf", "br", "pr", "buffer", "addr", "adr", "iter", "dr", "inters", "prime", "mem", "ts", "rep", "address", "pos", "len", "next", "pointer", "pad", "bp", "pointers", "ctr", "attr"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n", "idx": 23491, "substitutes": {"bs": ["bi", "ashes", "lbs", "ks", "ubs", "acts", "ss", "ns", "BS", "bps", "ses", "aos", "gb", "cs", "bc", "sts", "fs", "gs", "rs", "bn", "ds", "bis", "ls", "bm", "ms", "bg", "vs", "ats", "bes", "js", "xs", "its", "ts", "obs", "aus", "qs", "sb", "bos", "cks", "bp", "bb", "ths"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495, "substitutes": {"opaque": ["oba", "ropesh", "opa", "ropaque", " opque", "opacted", "ospesh", "obaque", " opacity", "openaque", "opena", "opesh", "opacity", " opesh", "openacity", " opa", "ospacted", "ropacted", "obque", "ospaque", "obacity", "openque", "opque", " opacted"], "addr": ["name", " address", "dh", "tag", "alloc", "ack", "ix", "offset", "add", "err", "hash", "act", "ar", "src", "arr", "loc", "x", "arg", "id", "eth", "rs", "tx", "host", "tr", "coord", "ord", "mt", "ress", "ctx", "ptr", "align", "rt", "res", "map", "adr", "dr", "ad", "prefix", "address", "cmd", "ace", "pos", "pad", "v", "attr"], "val": ["valid", "resp", "p", "lit", " arg", "ival", "it", "ret", "txt", "index", "vol", "ref", " eval", "value", " value", "add", "err", "fee", " buf", "eval", "serv", "key", "arr", "pt", "x", "arg", "tx", "Value", "data", "bit", "xy", "slot", "Val", "vec", "test", "buf", "prop", "ctx", "num", "res", "alt", "VAL", "vals", "reg", "unit", "mem", "au", " v", "cal", "pos", "len", "v", "vt"], "size": ["n", "name", "cap", "h", "SIZE", "length", "offset", "fee", "act", "count", "e", "weight", "args", "data", "z", "ize", "num", "unit", "area", "mem", "Size", "address", "len", "l", "v", "type"], "s": ["t", "p", "sys", "is", "settings", "sa", "r", "source", "parts", "os", "stat", "m", "h", "ss", "ns", "changes", "ses", "sync", "stats", "bs", "ps", "eps", "i", "sts", "socket", "rs", "gs", "fs", "comments", "c", "services", "ds", "bis", "pers", "sm", "spec", "ls", "details", "ms", "sv", "sw", "sam", "ats", "vs", "hs", "self", "ies", "S", "js", "es", "g", "its", "sq", "ts", "als", "params", "w", "qs", "client", "sb", "sol", "b", "an", "sl", "serv"]}}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n", "idx": 23504, "substitutes": {"cs": ["sys", "rc", "ck", "ks", "ce", "css", "ys", "cus", "ns", "acts", "sk", "gc", "ps", "bs", "uns", "rs", "fs", "c", "ds", "s", "ls", "CS", "caps", "ms", "sc", "cf", "js", "wcs", "ins", "ts", "pc", "acs", "cc", "cp", "cas", "acks"], "run": ["fun", "roll", "name", "train", "re", "build", "load", "gem", "rc", "use", "out", "end", "begin", "r", "ru", "set", "process", "runs", "boot", "write", "check", "go", "running", "scan", "exec", "add", "read", "call", "con", "Run", "ro", "skip", "row", "get", "step", "ran", "raw", "ve", "render", "draw", "un", "rain", "report", "unit", "in", "rm", "runner", "range", "play", "execute", "work", "ra", "flow", "pass", "update"], "cpu": ["comm", "core", "p", "sys", "gpu", "ck", "alloc", "this", "cat", "processor", "process", "cn", "boot", "pixel", "los", "cow", "device", "gc", "pkg", "prof", "bench", "lp", "conn", "cu", "cum", "copy", "cv", "uc", "currency", "c", " CPU", "reset", "cmp", "proc", "mac", "hw", "pu", "aux", "ctx", "kernel", "hz", "chip", "clock", "utils", "aco", "lc", "component", "px", "cf", "mem", "phy", "anc", "runner", "upt", "mc", "pc", "np", "cam", "cmd", "rpm", "cache", "util", "computer", "CPU", "linux", "client", "phys", "cp", "lib", "flow", "aq"], "switched_level": ["switchededequal", "switched_log", "switchedLEdata", "switched_prop", "switchedlylevel", "swressed_zero", "switched8level", "switched8local", "switched67level", "switchededcolor", "swpped_base", "swicted_vel", "swpped_data", "swictedEvel", "swaved_equal", "switched_data", "switched2level", "switchededlevel", "swicted_style", "switch8limit", "switchedinglevel", "switched2local", "switched_status", "switched8condition", "switched2condition", "swppedLEpoint", "switchedingstatus", "switched00zero", "switcheditylevel", "switchedEprop", "switcher_level", "switcher_mode", "switched00equal", "switcheditymode", "switched_mask", "switchededstate", "switches_status", "switched67data", "swpped_point", "switched_local", "switchedityinfo", "swressed_color", "switches_lvl", "switch8condition", "switched2limit", "switched00level", "switchededlock", "switchededlvl", "switched_allowed", "switched_info", "switch_condition", "switch8level", "switchededstatus", "switched_mode", "switched_state", "swicted_level", "switch_local", "switchedEvel", "switch_limit", "swictedEstyle", "swaved_lvl", "switcher_mask", "switchededzero", "swppedLElevel", "switched_base", "swaved_lock", "switched00color", "swppedLEdata", "switch8local", "swaved_level", "swpped_level", "switchedLEbase", "switched_lock", "switched_color", "switchedinglog", "swppedLEbase", "switchedLElevel", "switchedEstyle", "switched_zero", "swictedEprop", "switchedlybase", "swressed_equal", "switchedLEpoint", "switched67base", "swictedElevel", "switchedlypoint", "switch_level", "switched_style", "switched_equal", "switched_vel", "switched_limit", "switched_lvl", "switcheditymask", "switched67point", "switchedingallowed", "switched_condition", "swressed_level", "switches_level", "switchedElevel", "swicted_prop", "switched8limit", "switcher_info", "switches_state", "switched_point", "switchedlydata"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_trailer(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int res = 0;\n\n    int i, j, n, nb_frames;\n\n    int64_t file_size;\n\n\n\n    if (pb->seekable) {\n\n        if (avi->riff_id == 1) {\n\n            ff_end_tag(pb, avi->movi_list);\n\n            res = avi_write_idx1(s);\n\n            ff_end_tag(pb, avi->riff_start);\n\n        } else {\n\n            avi_write_ix(s);\n\n            ff_end_tag(pb, avi->movi_list);\n\n            ff_end_tag(pb, avi->riff_start);\n\n\n\n            file_size = avio_tell(pb);\n\n            avio_seek(pb, avi->odml_list - 8, SEEK_SET);\n\n            ffio_wfourcc(pb, \"LIST\"); /* Making this AVI OpenDML one */\n\n            avio_skip(pb, 16);\n\n\n\n            for (n = nb_frames = 0; n < s->nb_streams; n++) {\n\n                AVCodecParameters *par = s->streams[n]->codecpar;\n\n                AVIStream *avist       = s->streams[n]->priv_data;\n\n\n\n                if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                    if (nb_frames < avist->packet_count)\n\n                        nb_frames = avist->packet_count;\n\n                } else {\n\n                    if (par->codec_id == AV_CODEC_ID_MP2 ||\n\n                        par->codec_id == AV_CODEC_ID_MP3)\n\n                        nb_frames += avist->packet_count;\n\n                }\n\n            }\n\n            avio_wl32(pb, nb_frames);\n\n            avio_seek(pb, file_size, SEEK_SET);\n\n\n\n            avi_write_counters(s, avi->riff_id);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVIStream *avist = s->streams[i]->priv_data;\n\n        for (j = 0; j < avist->indexes.ents_allocated / AVI_INDEX_CLUSTER_SIZE; j++)\n\n            av_free(avist->indexes.cluster[j]);\n\n        av_freep(&avist->indexes.cluster);\n\n        avist->indexes.ents_allocated = avist->indexes.entry = 0;\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 23508, "substitutes": {"s": ["is", "this", "m", "ims", "sts", "ds", "sis", "sv", "sw", "hs", "es", "ins", "aus", "less", "sb", "as", "v", "a", "os", "ns", "bs", "cs", "e", "aws", "fs", "bis", "ast", "ats", "vs", "sc", "g", "ts", "sg", "ags", "qs", "b", "comm", "sys", "sa", "aps", "r", "stats", "ps", "times", "c", "ab", "scl", "spec", "ls", "S", "its", "sp", "conf", "vp", "p", "rb", "h", "ss", "ses", "eps", "sports", "rs", "gs", "ms", "sam", "js", "http", "sq", "w"], "avi": ["jac", "ano", "eas", "gif", "audio", "opa", "am", "liga", "sa", "vi", "nas", "ai", "eni", "audi", "AV", "aaa", "afi", "conv", "format", "wi", "annot", "iv", "adi", "xa", "aaaa", "pheus", "tap", "wiki", "liv", "VI", "ami", "bis", "av", "ti", "ab", "gra", "media", "ave", "ia", "ui", "video", "peg", "ats", "oga", "ja", "jam", "feat", "oi", "pan", "ta", "gg", "webkit", "au", "sav", "iga", "abba", "avan", "cam", "mi", "verb", "wikipedia", "mie", "mis", "pai", "ma", "pi", "v", "ra", "vp", "opus", " av"], "pb": ["td", "p", "sys", "rb", "eb", "py", "func", "cb", "pm", "tp", "bps", "ob", "conv", "pkg", "bs", "pt", "pp", "lp", "uf", "mp", "wp", "tk", "pl", "lb", "bj", "cv", "cp", "um", "pa", "PB", "oa", "jp", "fb", "bis", "snap", "proc", "ab", "pub", "fp", "mt", "buf", "ctx", "ub", "tmp", "dp", "wb", "cm", "px", "pan", "patch", "stab", "sp", "fts", "erb", "pc", "np", "pg", "tc", "typ", "soc", "buff", "pool", "pel", "sb", "b", "bp", "gp", "pi", "vp", "tf"], "i": ["ij", "bi", "p", "is", "ic", "it", "iq", "si", "r", "di", "me", "iu", "ai", "index", "xi", "o", "m", "ix", "y", "us", "multi", "im", "zi", "ei", "ie", "x", "id", " ii", "e", "sim", "ind", "gi", "I", "c", "ni", "ami", "ini", "ip", "ti", "batch", "li", "ia", "ex", "ui", "oi", "in", "ci", "g", "mi", "ii", "pi", "b", "v", "hi", "chain", "instance"], "j": ["ij", "bi", "aj", "p", "jit", "o", "jl", "index", "nr", "m", "err", "ji", "d", "pt", "bj", "x", "ind", "sim", "c", "ni", " J", "jp", "z", "ng", "jc", "li", "bo", "k", "jump", "J", "q", "oj", "br", "pr", "ja", "adj", "jas", "js", "try", "jo", "g", "job", "pos", "kj", "uj", "json", "ii", "kid", "jj", "b", "v", "l", "dj", "att", "ev"], "n": ["fn", "name", "t", "p", "en", "gn", "number", "o", "cn", "nr", "m", "ns", "y", "dn", "nw", "nor", "d", "na", "count", "hn", "note", "nn", "on", "c", "ni", "node", "N", "nos", "nb", "nu", "no", "z", "ann", "nd", "ng", "sn", "nm", "names", "num", "un", "new", "g", "ren", "ln", "nie", "nt", "np", "nl", "len", "ne", "wn", "mn", "an", "yn", "l", "v", "nc", "el", "nan", "syn"], "nb_frames": ["nb_bytes", "nb__bytes", "no_users", "no_files", "nb___bytes", "nbxframes", "nb_vals", "nb67vals", "nbuffybytes", "nob___frames", "node_rows", "nb___photos", "nb____files", "nb___headers", " neb____items", "nbuffyheaders", "no____frames", " neb_vals", "nb_faces", "cb_cells", "nbxphones", "nbxpages", "nob_frames", " neb____vals", " neb_frames", "nbwframes", "bn_photos", "nob___headers", "nbwusers", "nb_phones", "nb_rows", "nbwphones", "no____files", "nbxphotos", " neb_fram", "cb_frame", "nbxusers", "nb_photos", " neb____fram", "nb_fram", "bn_frames", "nb___frames", "nb___pages", "nb____frames", "nob___bytes", "nb67items", "nob___fram", "nbxerrors", "nob_bytes", "no____users", "nb____fram", "no_frames", "nb_cells", "nb67fram", "nb_headers", "bn_faces", "nb_frame", "nb67frames", "nb__frames", "nbxfaces", "nb___fram", "cb_frames", "nb_users", "nb_items", "nb_errors", "no____phones", "nb___faces", " neb____frames", "nbxrows", "nb_weights", "nb____vals", "nb____users", "nbuffyframes", "nbwfiles", "nb_pages", "nb____items", "bn_pages", "nob_headers", "nbuffyfram", "nbxweights", "nob_fram", "nb____phones", "node_frames", "no_phones", "node_errors", "nb__cells", " neb_items", "nb__frame", "cb_bytes", "node_weights", "nb_files", "nbxfiles"], "file_size": ["fileseqname", "file_sent", "fileseqsize", "file128Size", "filelogsent", "file2Size", "file_length", "file2SIZE", "filelexdata", "file128size", "file2size", " file_settings", "filelexsize", "filelexSize", " file_sent", "file2length", "fileseqsent", " file_SIZE", "file_name", "filelexsettings", " file_data", "filelogname", "file_Size", " file_name", " file_length", "filelogsize", "fileseqset", "file_settings", "file128data", " file_set", "filelogset", "file_set", "file_data", " file_Size", "file_SIZE", "file128settings"], "par": ["kar", "p", "param", "mm", "arp", "pard", "war", "rem", "tar", "rel", "pkg", "prep", "ar", "ps", "arr", "pp", "pro", "mp", "def", "rar", "pri", "tx", "var", "har", "pa", "jp", "pres", "arch", "car", "proc", "pol", "pub", "Par", "parse", "pal", "plan", "pr", "part", "dev", "dr", "per", "rep", "star", "req", "cam", "pre", "rec", "pi", "pat", "cp", "pass", "pas"], "avist": ["avift", "avoint", "avister", "savister", "vanis", " aviz", " avest", "ovist", "averistor", " avis", "averist", "averift", " avict", "Avist", "ajost", "ovIST", "ajest", "awists", "ajict", " avists", "ajist", "averict", "Avister", "ajoint", "avistant", "ajiz", "ajistant", "averisted", "avisted", "vanists", "ajistor", "vaniz", "aveift", "ajIST", "savIST", "aveist", "avict", "aveoint", "avIST", " avisted", "aveIST", "avis", "averoint", "oviz", "aveister", " avistor", "saviz", " avift", "avest", "savistant", "aveost", "aveistor", "avost", "ovistant", "avistor", "averest", "vanist", "awis", "savift", "Avift", "awiz", "savist", "AvIST", "aveict", "avists", "aviz", "ajisted", "awist", "averost"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516, "substitutes": {"opaque": ["oplque", " opaques", "ipaques", "oplaque", " opque", "OPaque", "OPacity", "ipvoid", "oplacity", "ipaque", "obaque", "Opaque", " opvoid", "OPque", "opvoid", "opacity", "opaques", "Opvoid", "Opaques", "obque", "obacity", "ipque", "opque", "Opque"], "addr": ["name", " address", "dh", "alloc", "r", "index", "ref", "ix", "offset", "add", "err", "hash", "act", "ay", "src", "arr", "loc", "x", "id", "eth", "row", "tx", "data", "var", "host", "handle", "coord", "hw", "ord", "ctx", "ong", "ptr", "now", "align", "self", "adj", "Address", "adr", "at", "ad", "dr", "mem", "reg", "prefix", "block", "address", "cmd", "obj", "pos", "work", "store", "pad", "sha", "attr"], "size": ["n", "small", "message", "capacity", "number", "m", "sum", "length", "SIZE", "offset", "zone", "scale", "fee", "count", "style", "space", "code", "e", "empty", "ity", "s", "body", "z", "sn", "align", "ize", "iz", "num", "send", "sh", "shape", "Size", "sp", "address", "len", "l", "grow", "sent", "type"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n", "idx": 23540, "substitutes": {"opaque": ["Opoid", "opulence", "opoid", " opulence", "Opulence", " Opaque", " Opque", " opoid", "OPos", " opque", "opsoid", "OPaque", " Opos", " Oplation", "plation", "Opaque", "OPlation", "OPque", "oplation", "opsulence", "opos", "paque", "pque", "opsaque", "opsque", "pos", "Opque", "opque"], "addr": ["fx", " address", "arp", "ack", "ref", "ix", "hash", "add", "rel", "ay", "act", "pkg", "src", "url", "loc", "inter", "rr", "arr", "id", "rs", "tx", "host", "ord", "ptr", "align", "ag", "alt", "hl", "db", "Address", "adr", "dr", "ad", "address", "cmd", "ace", "store", "pad", "attr"], "val": ["valid", "resp", "lit", "ival", "it", "ret", "vol", "ref", "aval", "bal", "value", " value", "al", "ul", "serv", "tx", "Value", "test", "bit", "Val", "pol", "buf", "ctx", "grad", "res", "alt", "cond", "VAL", "seq", "vals", "reg", "qual", "mem", "als", "cal", "len", "sol", "b", "v", "cas", "vt"], "d": ["n", "p", "t", "dh", "dm", "dx", "a", "D", "o", "dd", "r", "di", "del", "dq", "dc", "m", "did", "du", "sd", "dn", "ld", "ind", "i", "c", "des", "ds", "j", "z", "dat", "de", "dr", "g", "ad", "dos", "pd", "b", "v", "dj", "da"], "s": ["p", "t", "is", "os", "ss", "ns", "ses", "bs", "ps", "cs", "sts", "fs", "gs", "rs", "ds", "sis", "q", "sam", "sv", "ats", "hs", "ies", "S", "ess", "js", "es", "ins", "sq", "ts", "qs", "b", "as"]}}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555, "substitutes": {"dev": ["out", "dm", "ver", "Dev", " devs", "os", "ach", "dd", "device", "ac", "sd", "d", "def", "conn", "Device", "test", "des", "ds", "md", "data", "tr", "hw", "DEV", "spec", "ptr", "env", "devices", "priv", "de", "ad", "mem", "nt", "cam", "w", "pad", "att", "v", "ev", "serv"], "errp": ["errorpat", "ErP", "errP", "rrper", "noticeping", " errP", "rrpat", "errorper", "rrping", "rrP", "errpb", "noticeper", " errpb", "Erpb", "Erp", "errorping", "errping", "errpat", "errorp", "rrpb", "rrp", "noticepat", "noticep", "errper"], "fs": ["sys", "ics", "Fs", "bf", "ks", "f", "ows", "ns", "ims", "fits", "bs", "ps", "cs", "irs", "fw", "rs", "gs", "ds", "s", "FS", "files", "fr", "ls", "ms", "res", "ats", "vs", "hs", "cf", "js", "es", "ts", "fd", "qs", "fps", "oss", "fc"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n", "idx": 23560, "substitutes": {"s": ["n", "p", "t", "sys", "is", "a", "os", "set", "f", "h", "ns", "ss", "d", "src", "ps", "cs", "e", "i", "rs", "gs", "fs", "sts", "c", "ds", "ls", "sv", "S", "js", "ins", "sq", "sp", "sb", "b", "as", "v", "w"], "frame": ["rame", "ime", "state", "iframe", "bf", "ce", "force", "ref", "f", "window", "sf", "image", "fe", "def", "info", "bit", "fb", "frames", "show", "profile", "Frame", "fr", "word", "raw", "spec", "scene", "video", "fi", "seq", "feat", "AME", "cf", "face", "sequence", " Frame", "feature", " fr", "ence", "block", "form", "sample", "fram", "fc", "file", "point"], "flags": [" Flags", "bits", " features", "kind", " footprint", " bits", "Flag", "fee", "count", "FLAG", " mask", "fs", "args", " options", "faces", "ff", " flag", " whence", "Flags", "features", "ags", " fu", " fs", " usage", " af", "flag", "ffff", "fields"], "ist": ["ism", "oci", "is", "ost", "sys", "isc", "ic", "et", "xt", "ird", "ift", "iss", "pt", "ert", "ot", "wp", "ind", "IST", "IS", "isi", "imet", "st", "ith", "ast", "xp", "ust", "ih", "bh", "est", "iste", "osi", "aci", "ess", "ik", "alist", "its", "pect", "erd", "spect", "irst", "ush", "inst", "ista", "ists", "art"], "ctx": ["kw", "jac", "mk", "sys", "vc", "ck", "kt", "context", "ns", "act", "gc", "ct", "pkg", "wid", "pt", "loc", "ctrl", "bc", "cu", "cv", "tx", "voc", "jp", "cmp", "hw", "wx", " cx", "ka", "cf", "xs", "nt", "np", "cmd", "tc", "crit", "nc", "cc", "cp", "cfg", "ctr"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "void ff_h264_idct8_add_c(uint8_t *dst, DCTELEM *block, int stride){\n\n    int i;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    block[0] += 32;\n\n\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[0+i*8] + block[4+i*8];\n\n        const int a2 =  block[0+i*8] - block[4+i*8];\n\n        const int a4 = (block[2+i*8]>>1) - block[6+i*8];\n\n        const int a6 = (block[6+i*8]>>1) + block[2+i*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[3+i*8] + block[5+i*8] - block[7+i*8] - (block[7+i*8]>>1);\n\n        const int a3 =  block[1+i*8] + block[7+i*8] - block[3+i*8] - (block[3+i*8]>>1);\n\n        const int a5 = -block[1+i*8] + block[7+i*8] + block[5+i*8] + (block[5+i*8]>>1);\n\n        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        block[0+i*8] = b0 + b7;\n\n        block[7+i*8] = b0 - b7;\n\n        block[1+i*8] = b2 + b5;\n\n        block[6+i*8] = b2 - b5;\n\n        block[2+i*8] = b4 + b3;\n\n        block[5+i*8] = b4 - b3;\n\n        block[3+i*8] = b6 + b1;\n\n        block[4+i*8] = b6 - b1;\n\n    }\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[i+0*8] + block[i+4*8];\n\n        const int a2 =  block[i+0*8] - block[i+4*8];\n\n        const int a4 = (block[i+2*8]>>1) - block[i+6*8];\n\n        const int a6 = (block[i+6*8]>>1) + block[i+2*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[i+3*8] + block[i+5*8] - block[i+7*8] - (block[i+7*8]>>1);\n\n        const int a3 =  block[i+1*8] + block[i+7*8] - block[i+3*8] - (block[i+3*8]>>1);\n\n        const int a5 = -block[i+1*8] + block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1);\n\n        const int a7 =  block[i+3*8] + block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b7) >> 6) ];\n\n        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b2 + b5) >> 6) ];\n\n        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b4 + b3) >> 6) ];\n\n        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b6 + b1) >> 6) ];\n\n        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b6 - b1) >> 6) ];\n\n        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b4 - b3) >> 6) ];\n\n        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b2 - b5) >> 6) ];\n\n        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b7) >> 6) ];\n\n    }\n\n}\n", "idx": 23576, "substitutes": {"dst": ["dfr", "dbl", "rstr", "dstr", "rbl", "Dbl", " dbl", " dstr", "Dstr", " dfr", "Dst", "rfr", "rst", "Dfr"], "block": ["clip", "pack", "ck", "commit", "pixel", "filter", "none", "plugin", "user", "mask", "space", "word", "event", "map", "open", "zero", "work", "client", "file", "point", "layer", "chain", "type", "channel", "random", "loop", "use", "list", "group", "device", "bl", "sync", "condition", "board", "bus", "join", "base", "Block", "archive", "link", "part", "rule", "blocks", "bin", "b", "blocking", "network", "public", "core", "load", "view", "tag", "frame", "hash", "co", "object", "method", "table", "image", "stream", "label", "array", "def", "bit", "cl", "snap", "ip", "library", "proc", "buf", "bo", "spec", "other", "module", "buffer", "box", "config", "range", "cache", "BL", "line", "rock", "history", "valid", "p", "out", "model", "record", "check", "window", "secure", "bc", "row", "byte", "profile", "lock", "version", "manager", "control", "unit", "page", "ch", "http", "lib"], "stride": [" strride", "strides", "strride", "Stride", "Strride", "stide", "Strides", "Strize", " strides", " strize", "strize", "stides", "stize"], "i": ["is", "ic", "this", "io", "m", "ims", " I", "im", "I", "ti", "batch", "cli", "ui", "ex", " bi", "port", "v", "\u0438", "si", "me", "o", "vi", "ai", "ix", "ji", "conv", " m", "x", " ii", "sim", "ind", "gi", "info", " ti", "status", "oi", "at", "g", " j", "sequence", "u", "hi", "bi", "t", "time", "it", "ri", "r", "xi", "y", "multi", "zi", "ei", "s", "qi", "ini", "ip", "li", "ia", "try", "in", "ci", "mi", "ii", " mi", "pi", "series", "ij", "er", "p", "print", "di", "set", "iu", "index", "us", "init", "ie", "key", "id", "or", "ki", "j", "q", "mc", " multi"], "cm": ["com", "mr", "ck", "km", "cont", "mm", "dc", "m", "rem", "im", "mb", "fm", "um", "cd", "cv", "cl", "asm", "nm", "bm", "module", "lc", "cf", "cr", "tc", "conf", "mn", "ca", "fc", "cp"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587, "substitutes": {"val": ["ee", "valid", "t", "p", " arg", "sel", "it", "ret", "index", "ref", " eval", "value", "err", " value", "al", "eval", "serv", "pt", "x", "def", "tx", "data", "test", "var", "Val", " Val", "z", "ctx", " _", "pr", "sv", "VAL", " data", "vals", "reg", "mem", " v", " VAL", "cal", "pos", "len", "elt", "sol", "l", "v", "V", "lib", "sl", "vt"]}}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tlb_set_page(CPUArchState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    section = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n           \" prot=%x idx=%d pd=0x%08lx\\n\",\n\n           vaddr, paddr, prot, mmu_idx, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 23622, "substitutes": {"env": ["pee", "er", "en", "vp", "org", "context", "door", "et", "equ", "ef", "window", "ner", "ei", "e", "conn", "cv", "vm", "operator", "node", "test", "shell", "den", "ec", "esc", "hw", "enter", "see", "ctx", "here", "manager", "environment", "server", "ve", "vs", "pe", "her", "viron", "dev", "global", "era", "email", " environment", "Environment", "obj", "ah", "ew", "nv", "v", "eng", "network", "net", "ev", "vt"], "vaddr": ["paddress", "vcaddress", "vaddress", "laddress", "hptr", " vhost", "wadr", " vnow", "veadr", "Vaddr", "vcaddr", "padr", " vadd", "padd", "vcnow", "fadd", " vaddress", " vip", "faddress", "vadd", "phost", "veaddr", "pdr", "waddr", "vadr", "veptr", "vpadd", "haddr", "pptr", "waddress", "mip", "vehost", "vpaddress", "wptr", "vdr", "vhost", "pnow", "laddr", "vpaddr", "hadr", "vptr", "whost", "madr", "ladr", "faddr", " vdr", "vpip", "hhost", "vcadd", "mdr", "vnow", "maddress", "lptr", "Vhost", "Vadr", "pip", " vadr", "madd", "fhost", "vip", "Vaddress", "maddr"], "paddr": ["paddress", "vaddress", "Padd", " padd", "padr", "padd", " pattr", "Pptr", "Paddress", "vadd", "pdr", "vadr", "mptr", "vpadd", "pptr", "mattr", "vpaddress", "pattr", "vdr", "vpaddr", "vptr", "Padr", " padr", "mdr", "maddress", "Paddr", "vattr", " pdr", " pptr", "madd", " paddress", "maddr", "vpptr"], "prot": ["flags", "response", "vector", "ht", "ret", " proto", "zh", "stat", "io", "ping", "ref", "policy", "prototype", "tp", "ef", "format", "method", "pkg", "top", "tz", "pro", "style", "def", "ext", "dt", "eth", "status", "protection", "php", "xy", "ocol", "handle", "tr", " PROT", " protocol", "col", "version", "Prot", "height", "prop", "pattern", "tif", "ptr", "mode", "opt", "phy", "rot", "command", "chron", "pc", "typ", "pb", "cmd", "port", "pat", "pd", "period", "flag", "tf", "header", "type"], "mmu_idx": ["mmu_idey", "mmu_Idv", "mmu_basedv", "mmu_indexxs", "mmu_indy", "mmu_ipv", "mmu_basedy", "mmu_indv", "mmu_Idx", "mmu_idev", "mmu_idsv", "mmu_basedx", "mmu_idsn", "mmu_indx", "mmu_idn", "mmu__idx", "mmu_idsy", "mmu_Idn", "mmu_indexy", "mmu_basedj", "mmu_Idy", "mmu_idv", "mmu__idsv", "mmu_indexx", "mmu__idsn", "mmu_idex", "mmu_ipx", "mmu__idn", "mmu_indexn", "mmu_ipn", "mmu_ipy", "mmu_iden", "mmu_idxs", "mmu_idy", "mmu__idv", "mmu_Idj", "mmu_idsx", "mmu_idj", "mmu_idexs", "mmu__idy", "mmu__idsx", "mmu_indn", "mmu__idsy"], "size": ["name", "p", "time", "cap", "use", "start", "message", "capacity", "number", "set", "sum", "SIZE", "length", "scale", "zone", "too", "fee", "count", "total", "style", "power", "space", "timeout", "max", "data", "body", "z", "height", "sn", "city", "ize", "sy", "send", "sh", "sw", "sv", "num", "storage", "buffer", "shape", "page", "area", "mem", "Size", "sp", "np", "pos", "cache", "len", "pi", "small", "news"], "section": ["man", "master", "definition", "parent", "element", "state", "Section", "setting", "tag", "context", "org", "usr", "comment", "container", "sec", "group", "window", "member", "session", "table", "ner", "key", "image", "description", "sect", "row", "tab", "side", "journal", "established", "test", "establishment", "j", "profile", "connection", "se", "ment", "sections", "version", "portion", "selection", "mode", "environment", "server", "position", "part", "entry", "component", "region", "page", "area", "service", "division", "feature", "instance", "prefix", "job", "action", "sector", "block", "rup", "example", "mod", "site", "sb", "port", "second", "option", "net", "header", "channel"], "index": ["Index", "loop", "capacity", "ion", "si", "number", "set", "connect", "alias", "ix", "IND", "length", "offset", "order", "condition", "count", "key", "loc", "x", "id", "ice", "ind", "i", "code", "timeout", "row", " error", "axis", "select", "ity", "test", "connection", "height", "ize", "server", "ex", "position", "num", "open", "active", "addr", "location", "page", "inc", "iter", "find", "instance", "zero", "interface", "pos", "port", "route", "success", "option", "point", "insert"], "address": ["definition", "p", "vector", "end", "reference", "start", "resource", "message", "context", "a", "number", "comment", "memory", "ref", "device", "length", "value", "offset", "add", "attribute", "order", "table", "pair", "image", "description", "array", "code", "node", "ip", "connection", "result", "version", "ptr", " Address", "password", "position", "padding", "entry", "buffer", "Address", "location", "addr", "page", "area", "region", "shape", "adr", "service", "path", "command", "error", "range", "interface", "block", "email", "ace", "pointer", "port", "route", "network", "point", "distance", "alias"], "code_address": ["code___offset", " code_position", "code_reference", "code_position", "code___addr", "code___address", " code_offset", "code_addr", "code_record", "code_offset", "code__location", "code_location", "code__address", " code_record", " code_Address", " code_reference", " code_location", " code_addr", "code__position", "code___record", "code_Address", "code__offset"], "addend": ["addEnd", "sumend", "attachended", "addends", "adstart", "adEnd", "attachends", "ordended", "addedfrom", " addent", "addedender", "addfrom", "addending", "addension", "Addended", "addender", "Addend", "sumender", " addended", "adended", "AddEnd", "Addstart", "addrend", "sumension", " addending", " addfrom", "addstart", "addended", " addEnd", "addrfrom", "attachend", "attachending", "addent", "ordend", "Addent", "ordending", "addedended", "addrended", " addends", "addedent", " addension", " addender", "addedension", "addedend", "sumended", " addstart", "ordends", "adend"], "te": ["che", "ste", "t", "ele", "Te", "ige", "ere", "me", "xe", "ce", "ade", "tp", "tle", "fo", "ete", "ie", "note", "e", "ter", "ame", "ale", "test", "ge", "le", "ote", "ti", "se", "tile", "see", "ette", "ite", "ke", "ve", "ine", "tre", "pe", "we", "ta", "de", "lete", "ae", "delete", "TE", "oe", "ts", "ute", "ode", "ffe", "be", "ne", "ante", "je", "ye", "ue", "aste", "ate", "itte", "ene", "ome"], "iotlb": ["ttlbs", "otilab", "youtlb", "OTlr", "pitlas", "ytlb", "ytlr", "mintlbs", "ietlbs", "mintlr", "OTlbs", "otilr", "ietlb", "ioticbl", "iotlbs", "ioslab", "otilb", "mintlab", "ioticlb", "ioslb", "ietlas", "tterb", "iotlas", "ioslbs", "youtlbs", "iotbl", "ioticlab", "ioslr", "mintlb", "pitlb", "youtlab", "minterb", "ytbl", "ioticlr", "ioterb", "OTlab", "OTlb", "ytlab", "ttlab", "ytlbs", "pitlbs", "ietlab", "otibl", "youtlas", "pitlab", "yterb", "iotlab", "ttlb", "iotlr"]}}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 23626, "substitutes": {"opaque": ["Opac", " opaques", "opac", "OPac", "iopaque", "ropent", "ropaque", " opaco", "OPaque", "OPacity", "opent", "iopent", "ropaco", "OPaques", " opacity", "Opaque", "Opacity", "opacity", "opaques", "Opaques", " oplay", "opaco", " opent", " opac", "ioplay", "roplay", "oplay", "iopaco"], "addr": ["msg", "ret", "ack", "err", "ash", "loc", "mask", "eth", "host", "md", "res", "alt", "map", "pos", "work", "elt", "v", "aj", "state", "rev", "a", "ix", "order", "x", "coord", "mt", "db", "adr", "dev", "mem", "dr", "prefix", "cmd", "b", "att", "lat", " address", "tag", "r", "arp", "ref", "hash", "act", "pkg", "url", "inter", "tx", "var", "mac", "z", "ctx", "ptr", "ad", "sp", "req", "attr", "alias", "alloc", "index", "off", "offset", "add", "ac", "src", "arr", "id", "rs", "ord", "urg", "align", "grad", "Address", "address", "pad", "phys"], "val": ["cho", "msg", "ret", "vol", " vel", "value", " value", "err", "rel", "rol", " update", "eval", " tx", "pt", "xy", "alpha", "vet", "res", "alt", " ty", " cal", " v", "util", "elt", "v", "local", "resp", "sel", "stat", " eval", "aval", "bl", "x", "ind", "data", "fail", "Val", "pol", "gold", "pal", "hz", "num", "dev", "mem", "new", "cal", "crit", "b", " arg", "it", "ref", "bal", "act", "bool", "arg", "def", "str", "tx", "Value", "var", "buf", "mix", "bo", "ctx", " data", "obj", "el", "serv", "vt", " aval", "valid", "p", "lit", "txt", "ival", "ver", "al", "ul", "item", "key", "ext", "test", "lex", "urg", " bl", "grad", "cond", "VAL", "gal", "vals", "unit", "reg", "mod", "lib"], "s": ["n", "comm", "t", "p", "is", "sys", "state", "a", "r", "o", "os", "set", "m", "h", "ss", "y", "ns", "ses", "stats", "d", "serv", "ps", "bs", "i", "sts", "socket", "rs", "gs", "fs", "services", "cs", "ds", "bis", "j", "se", "z", "sm", "spec", "ls", "ex", "sam", "sv", "ssl", "sw", "vs", "hs", "S", "js", "service", "g", "es", "its", "sq", "ts", "sp", "als", "params", "obj", "qs", "store", "sb", "an", "b", "l", "v", "as", "sl", "w"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n", "idx": 23627, "substitutes": {"src": ["load", "sys", "rc", "usr", "txt", "sel", "source", "h", "scan", "dest", "copy", "impl", "bc", "rs", "st", "s", "cur", "ipl", "sr", "img", "sn", "gin", "ptr", "bh", "tmp", "sc", "ins", "sq", "sub", "rl", "np", "req", "sur", "input", "inst", "sb", "ser", "each", "ctr"], "stride": [" strride", "strride", "struse", "STRime", "STRend", "strend", " strade", "Strve", "strade", "Strade", "Struse", "STRide", "trime", "trride", " strve", "strime", " strime", "STRride", " struse", "divve", "divide", "strve", "divade", "Stride", "divuse", "trend", "tride", " strend"], "filter_p1": ["filter_q2", "filter_p2", "filter_m1", "filter_P2", "filter_P3", "filter_m2", "filter_q8", "filter_p8", "filter_p0", "filter_q0", "filter_m0", "filter_p3", "filter_m8", "filter_P1", "filter_m3", "filter_P0"], "filter_q1": ["filter_dq2", "filter_q2", "filter_qi", "filter_Q0", "filter_p2", "filter_Q1", "filter_qq1", "filter_Q2", "filter_dq1", "filter_eq0", "filter_qqOne", "filter_eq1", "filter_p0", "filter_q0", "filter_qq2", "filter_dq0", "filter_pOne", "filter_eqi", "filter_pi", "filter_qq0", "filter_qOne", "filter_dqi", "filter_eq2", "filter_QOne"], "alpha": ["alph", "asc", "p", "rc", "a", "da", "filter", " gamma", "ac", "al", " Alpha", "power", "fac", "weight", "aff", "la", "mix", "extra", " \u03b1", "capital", "inc", "error", "adv", "acl", "diff", "ma", "hi", "success", "ra", "Alpha", "anti", "attr", "alias"], "beta": ["bi", "phi", "lr", "binary", "normal", "dB", "confidence", "lambda", "secondary", "bps", "gam", "late", "fee", "bs", "two", "\u03b2", "bc", "vert", "mu", "dust", "xy", "blue", "bis", "eta", "bot", "igma", "nb", "mega", "Beta", "grad", "boost", "fine", "ta", "term", "gradient", "bet", "ii", "b"], "lim_p0q0": ["lim_p0p7", "lim_p1dq0", "lim_p1q7", "lim_p0f2", "lim_p1p1", "lim_p0qq0", "lim_p1q2", "lim_p0f0", "lim_p1dq2", "lim_p0p1", "lim_p1p7", "lim_p1dq1", "lim_p0q2", "lim_p0qu1", "lim_p0q7", "lim_p1q0", "lim_p0p2", "lim_p0qq1", "lim_p1q1", "lim_p0f7", "lim_p0dq2", "lim_p0qq7", "lim_p0p0", "lim_p0qu2", "lim_p0dq1", "lim_p1p2", "lim_p0f1", "lim_p1p0", "lim_p0qq2", "lim_p0qu0", "lim_p0dq0", "lim_p0q1"], "lim_q1": ["lim_q3", "lim_dq3", "lim_qq01", "lim_ue2", "lim_qone", "lim_dq2", "lim2q3", "lim_p2", "lim_Q1", "lim2dq3", "lim_q0", "lim_ueone", "lim2dq2", "lim_dq1", "lim_p3", "lim_qq2", "lim_qqone", "lim_ue01", "lim2q2", "lim2dq0", "lim_p0", "lim_q01", "lim_ue1", "lim_Qone", "lim2q1", "lim_Q3", "lim2q0", "lim_Q2", "lim_Q0", "lim2dq1", "lim_qq1", "lim_dq0", "lim_Q01", "lim_q2"], "lim_p1": ["lim_m8", "lim_m2", "lim_p2", "lim_v2", "lim_v1", "lim_m0", "lim_t2", "lim_P0", "lim_p8", "lim_p0", "lim_t0", "lim_t1", "lim_P1", "lim_P2", "lim_v8", "lim_m1", "lim_q8", "lim_q2"]}}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static int decode_subframe(WmallDecodeCtx *s)\n\n{\n\n    int offset        = s->samples_per_frame;\n\n    int subframe_len  = s->samples_per_frame;\n\n    int total_samples = s->samples_per_frame * s->num_channels;\n\n    int i, j, rawpcm_tile, padding_zeroes, res;\n\n\n\n    s->subframe_offset = get_bits_count(&s->gb);\n\n\n\n    /* reset channel context and find the next block offset and size\n\n        == the next block of the channel with the smallest number of\n\n        decoded samples */\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        if (offset > s->channel[i].decoded_samples) {\n\n            offset = s->channel[i].decoded_samples;\n\n            subframe_len =\n\n                s->channel[i].subframe_len[s->channel[i].cur_subframe];\n\n        }\n\n    }\n\n\n\n    /* get a list of all channels that contain the estimated block */\n\n    s->channels_for_cur_subframe = 0;\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        const int cur_subframe = s->channel[i].cur_subframe;\n\n        /* subtract already processed samples */\n\n        total_samples -= s->channel[i].decoded_samples;\n\n\n\n        /* and count if there are multiple subframes that match our profile */\n\n        if (offset == s->channel[i].decoded_samples &&\n\n            subframe_len == s->channel[i].subframe_len[cur_subframe]) {\n\n            total_samples -= s->channel[i].subframe_len[cur_subframe];\n\n            s->channel[i].decoded_samples +=\n\n                s->channel[i].subframe_len[cur_subframe];\n\n            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;\n\n            ++s->channels_for_cur_subframe;\n\n        }\n\n    }\n\n\n\n    /* check if the frame will be complete after processing the\n\n        estimated block */\n\n    if (!total_samples)\n\n        s->parsed_all_subframes = 1;\n\n\n\n\n\n    s->seekable_tile = get_bits1(&s->gb);\n\n    if (s->seekable_tile) {\n\n        clear_codec_buffers(s);\n\n\n\n        s->do_arith_coding    = get_bits1(&s->gb);\n\n        if (s->do_arith_coding) {\n\n            avpriv_request_sample(s->avctx, \"Arithmetic coding\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        s->do_ac_filter       = get_bits1(&s->gb);\n\n        s->do_inter_ch_decorr = get_bits1(&s->gb);\n\n        s->do_mclms           = get_bits1(&s->gb);\n\n\n\n        if (s->do_ac_filter)\n\n            decode_ac_filter(s);\n\n\n\n        if (s->do_mclms)\n\n            decode_mclms(s);\n\n\n\n        if ((res = decode_cdlms(s)) < 0)\n\n            return res;\n\n        s->movave_scaling = get_bits(&s->gb, 3);\n\n        s->quant_stepsize = get_bits(&s->gb, 8) + 1;\n\n\n\n        reset_codec(s);\n\n    } else if (!s->cdlms[0][0].order) {\n\n        av_log(s->avctx, AV_LOG_DEBUG,\n\n               \"Waiting for seekable tile\\n\");\n\n        s->frame.nb_samples = 0;\n\n        return -1;\n\n    }\n\n\n\n    rawpcm_tile = get_bits1(&s->gb);\n\n\n\n    for (i = 0; i < s->num_channels; i++)\n\n        s->is_channel_coded[i] = 1;\n\n\n\n    if (!rawpcm_tile) {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            s->is_channel_coded[i] = get_bits1(&s->gb);\n\n\n\n        if (s->bV3RTM) {\n\n            // LPC\n\n            s->do_lpc = get_bits1(&s->gb);\n\n            if (s->do_lpc) {\n\n                decode_lpc(s);\n\n                avpriv_request_sample(s->avctx, \"Expect wrong output since \"\n\n                                      \"inverse LPC filter\");\n\n            }\n\n        } else\n\n            s->do_lpc = 0;\n\n    }\n\n\n\n\n\n    if (get_bits1(&s->gb))\n\n        padding_zeroes = get_bits(&s->gb, 5);\n\n    else\n\n        padding_zeroes = 0;\n\n\n\n    if (rawpcm_tile) {\n\n        int bits = s->bits_per_sample - padding_zeroes;\n\n        if (bits <= 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Invalid number of padding bits in raw PCM tile\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        av_dlog(s->avctx, \"RAWPCM %d bits per sample. \"\n\n                \"total %d bits, remain=%d\\n\", bits,\n\n                bits * s->num_channels * subframe_len, get_bits_count(&s->gb));\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_coeffs[i][j] = get_sbits(&s->gb, bits);\n\n    } else {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            if (s->is_channel_coded[i]) {\n\n                decode_channel_residues(s, i, subframe_len);\n\n                if (s->seekable_tile)\n\n                    use_high_update_speed(s, i);\n\n                else\n\n                    use_normal_update_speed(s, i);\n\n                revert_cdlms(s, i, 0, subframe_len);\n\n            } else {\n\n                memset(s->channel_residues[i], 0, sizeof(**s->channel_residues) * subframe_len);\n\n            }\n\n    }\n\n    if (s->do_mclms)\n\n        revert_mclms(s, subframe_len);\n\n    if (s->do_inter_ch_decorr)\n\n        revert_inter_ch_decorr(s, subframe_len);\n\n    if (s->do_ac_filter)\n\n        revert_acfilter(s, subframe_len);\n\n\n\n    /* Dequantize */\n\n    if (s->quant_stepsize != 1)\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_residues[i][j] *= s->quant_stepsize;\n\n\n\n    /* Write to proper output buffer depending on bit-depth */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        int subframe_len = s->channel[c].subframe_len[s->channel[c].cur_subframe];\n\n\n\n        for (j = 0; j < subframe_len; j++) {\n\n            if (s->bits_per_sample == 16) {\n\n                *s->samples_16[c]++ = (int16_t) s->channel_residues[c][j] << padding_zeroes;\n\n            } else {\n\n                *s->samples_32[c]++ = s->channel_residues[c][j] << padding_zeroes;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handled one subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ++s->channel[c].cur_subframe;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23636, "substitutes": {"s": ["ports", "is", "m", "ims", "ops", "sts", "ds", "details", "ex", "sv", "sw", "hs", "xs", "es", "ins", "als", "ants", "params", "less", "sb", "as", "v", "a", "os", "changes", "ns", "bs", "cs", "results", "aws", "fs", "bis", "states", "status", "ers", "ats", "vs", "self", "bes", "g", "has", "ts", "gets", "qs", "ords", "b", "tes", "events", "comm", "sys", "settings", "r", "ows", "y", "stats", "ps", "times", "services", "comments", "args", "ls", "ies", "S", "its", "conf", "obj", "serv", "bits", "ids", "set", "parts", "h", "ss", "ses", "rs", "gs", "ms", "js", "tests", "sq", "ains", "w"], "i": ["ic", "io", "m", "ims", "progress", " I", "im", "I", "ti", "cli", "batch", "ui", "ex", "v", "point", "uri", "chain", "n", "name", "\u0438", "si", "me", "o", "list", "ai", "ix", "menu", "ji", "x", "ind", "e", "sim", "gi", "info", "ami", "status", "oi", "g", "remote", "u", "b", "hi", "bi", "parent", "phi", "it", "iq", "ri", "f", "xi", "y", "multi", "zi", "ei", "iri", "qi", "ini", "ip", "li", "in", "ci", "rest", "mi", "ii", "slice", "to", "pi", "series", "ori", "ij", "history", "p", "index", "di", "iu", "h", "init", "item", "ie", "key", "id", "ki", "q", "json"], "j": ["n", "ij", "aj", "jac", "p", "jl", "index", "ji", "jp", "z", "jc", "k", "q", "J", "jump", "ja", "js", "g", "uj", "kj", "ii", "jj", "l", "v", "b", "dj"], "rawpcm_tile": ["rawpcm_format", "rawpcm_seed", "rawpdu_id", "rawpdu_tile", "rawpdu_seed", "rawpdu_format", "rawpcm_id"], "padding_zeroes": ["padding_erones", "padding_zeros", "padding_neros", "padding_zoes", "padding_zereros", "padding_eroes", "padding_ereros", "padding_nones", "padding_noes", "padding_zerones", "padding_nos", "padding_zos", "padding_eros", "padding_zones"], "res": ["resp", "response", "bits", "os", "progress", "rel", "conv", "format", "val", "key", "rows", "RES", "resolution", "rs", "tx", "reset", "bytes", "pres", "ress", "result", "ms", "vals", "Res", "mem", "rest", "req", "pos"], "channels_for_cur_subframe": ["channels_for_cur_broadFrame", "channels_for_cur_broadframe", "channels_for_cur_popframes", "channels_for_cur_Subframe", "channels_for_cur_fullFrame", "channels_for_cur_subframes", "channels_for_cur_topchannel", "channels_for_cur_broadframes", "channels_for_cur_fullframes", "channels_for_cur_Subchannel", "channels_for_cur_Subframes", "channels_for_cur_popFrame", "channels_for_cur_popchannel", "channels_for_cur_topframe", "channels_for_cur_subFrame", "channels_for_cur_SubFrame", "channels_for_cur_popframe", "channels_for_cur_subchannel", "channels_for_cur_fullframe", "channels_for_cur_topFrame"], "channel": ["chat", "cho", "button", "character", "chn", "message", "frame", "entity", "cue", "container", "chan", "pixel", "color", "column", "panel", "member", "attribute", "disc", "domain", "call", "Channel", "node", "bit", "byte", "batch", "band", "connection", "version", "pipe", "player", "module", "server", "video", "queue", "chip", "tube", "actor", "camera", "console", "component", "unit", "ch", "annels", "service", "config", "mon", "command", "chron", "block", "variable", "cam", "remote", "store", "can", "client", "browser", "voice", "course", "net"], "cur_subframe": ["cur_Subchannel", "cur_superchannel", "cur_Subfram", "cur_popFrame", "cur_Subset", "cur_popchannel", "cur_searchFrame", "cur_Subhole", "cur_deeprender", "cur_shortstream", "cur_subrender", "cur_shortframe", "cur_subhole", "cur_substream", "cur_snapface", "cur_deepFrame", "cur_initialdraw", "cur_Subversion", "cur_subserver", "cur_shortFrame", "cur_initialframe", "cur_Subface", "cur_popframe", "cur_SubFrame", "cur_deepserver", "cur_snapframe", "cur_subFrame", "cur_conframe", "cur_popversion", "cur_searchfram", "cur_Substream", "cur_superversion", "cur_searchframe", "cur_deepvideo", "cur_descvideo", "cur_shortset", "cur_constream", "cur_modFrame", "cur_subchannel", "cur_descserver", "cur_conFrame", "cur_Subvideo", "cur_modframe", "cur_Subrender", "cur_initialFrame", "cur_subversion", "cur_superFrame", "cur_modface", "cur_subdraw", "cur_Subserver", "cur_descframe", "cur_Subframe", "cur_initialhole", "cur_conset", "cur_descFrame", "cur_snapFrame", "cur_superframe", "cur_searchrender", "cur_deepfram", "cur_subset", "cur_subface", "cur_subfram", "cur_Subdraw", "cur_subvideo", "cur_deepframe"]}}
{"project": "FFmpeg", "commit_id": "1bab6f852c7ca433285d19f65c701885fa69cc57", "target": 1, "func": "static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,\n\n                                 const int16_t *ubuf[2], const int16_t *bguf[2],\n\n                                 const int16_t *abuf0, uint8_t *dest,\n\n                                 int dstW, int uvalpha, int y)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];\n\n    const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1\n\n\n\n    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1b(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n", "idx": 23643, "substitutes": {"c": ["n", "p", "t", "rc", "cont", "f", "dc", "m", "h", "co", "ac", "ct", "con", "cs", "e", "bc", "cv", "s", "ec", "C", "ctx", "k", "lc", "cm", "ci", "g", "mc", "cam", "tc", "cache", "b", "cc", "v", "ca", "fc", "cp"], "buf0": ["cv2", "buffer3", "buff0", "buffer2", "buff2", "uf1", "buffer0", "uf0", "cv5", "buffer5", "buff1", "buf2", "buff3", "uf3", "buffer1", "cv0", "buf3", "cv1", "uf2", "uf5", "buf5"], "ubuf": ["udbf", "umbuff", "ubump", "ubbuf", "rubbuf", "rubump", "umuf", "umbuf", "rubuff", "umff", "ufbuff", "umbf", "abff", "ubff", "obbuf", "obuff", "ubbf", "abuff", "rubuf", "obuf", "ufbf", "ufbuf", "abuf", "ufuf", "ufff", "ubbuff", "ubuff", "umuff", "uduf", "udbuf", "udbuff", "umump", "obump", "abbuf", "ufuff"], "bguf": ["wbuf", "dbuff", "wbuff", "wbbuf", "bgbuf", "cbpu", "dbpu", "dbbuf", "wbpu", "cbuff", "bguff", "cbbuf", "dbuf", "cbuf", "bgpu"], "abuf0": ["abuffer1", "abuffer4", "abuffer8", "abbuf8", "abbuf0", "ubbuf8", "ubuf8", "abuf8", "abuff4", "abuffer0", "abuf1", "ubbuf1", "ubbuf4", "abuff0", "abuff8", "abuff1", "abbuf1", "abbuf4", "abuf4", "ubbuf0", "ubuf4"], "dest": ["master", "orig", "parent", "out", "end", "txt", "usr", "cas", "source", "Dest", "output", "desc", "ref", "dc", "window", "win", "src", "target", "st", "temp", "them", "comb", "result", "buf", "img", "ptr", "est", "wb", "self", "iter", "mem", "trans", "sp", "cmd", "port", "dist", "cp", "origin", "w"], "dstW": ["dstP", "DestP", "dblP", "destP", "ddestWidth", "destPos", "DstPos", "ddestP", "ddestPos", "dblWidth", "DestW", "DstW", "DstP", "DestWidth", "dblW", "destW", "DstWidth", "dblPos", "DestPos", "destWidth", "dstPos", "dstWidth", "ddestW"], "uvalpha": ["Uvalphi", "UVALphi", "upolphi", " uvalph", "uvalsph", "Uvalphy", "uvalspha", "uavalpha", "uavalph", "uvalph", "uavalphy", "upolmph", " uvalmph", "UVALph", "uVALph", "uVALphy", "uVALphi", "upolph", "UVALpha", " uvalphi", "upolpha", "uvalphy", "uvalsmph", "uvalsphy", "Uvalpha", "uavalphi", "UVALphy", "Uvalph", "uvalphi", "uvalmph", "uVALpha", "uvalsphi"], "y": ["p", "yy", "t", "py", "ay", "iy", "x", "i", "ly", "ny", "yp", "vy", "xy", "z", "dy", "sy", "oy", "iny", "Y", "ies", "yd", "ch", "ym", "ty", "gy", "ry", "b", "yi"], "ubuf0": ["ubbuff1", "ubuf2", "ubull1", "abbuf2", "abbuf0", "abuf5", "ubuff5", "abuf1", "ubbuf1", "ubbuff0", "ubbuf5", "ubuf5", "ubbuff5", "ubbuf2", "ubull6", "abbuf00", "ubull2", "ubuf6", "ubuff1", "ubbuf6", "ublf2", "ubuf00", "abbuf1", "ubbuf00", "ublf1", "abbuf6", "ublf0", "abuf00", "ubull0", "abbuf5", "ublf6", "abuf2", "abuf6", "ubuff00", "ubbuf0", "ubuff0", "ubbuff00"], "ubuf1": ["ubuf2", "abuff3", "ubuff3", "abbuf2", "abbuf0", "ublu2", "abuff2", "abuf5", "ubuff2", "ubuff5", "ublu1", "abuf1", "ubbuf1", "abuff0", "ubbuf5", "ubuf5", "ubbuf2", "abuff1", "ubbuf3", "ubuff1", "ublf2", "abbuf1", "ublf1", "ublf0", "ublu5", "abbuf5", "ublf3", "abuf2", "ubuf3", "ubbuf0", "ublu0", "ubuff0", "abuf3"], "buf1": ["buff2", "buf3", "buf2", "buff3", "buff1", "buffer2", "uf1", "buffer0", "uf2", "uf0", "uf3", "buffer3", "buff0", "buffer1"]}}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 23656, "substitutes": {"mon": ["man", "master", "monkey", "dm", "mot", "meter", "mm", "dom", "met", "member", "ox", "mut", "onet", "mu", "admin", "Mon", "pers", "den", "MON", "mate", "ann", "eor", "coord", "pid", "lock", "manager", "min", "bean", "unit", "mx", "mun", "util", "mont", "mi", "mons", "mic", "wat", "an", "mn", "monitor", "timer"], "qdict": [" qmap", "dqdict", "dqdir", "sqsession", "sqstr", "sqrect", "sqmap", "sqbody", "qcompl", "qmap", "sqdef", " qstr", "sqdict", "querstr", "sqsum", "iqdict", " qsession", "sqdir", "iqrect", "qdef", " qbody", " qdef", "qdir", " qrect", "qsum", " qsum", "iqcompl", "qbody", "quersum", "quersession", "dqdef", "sqcompl", "qsession", "querdict", " qcompl", "qstr", " qdir", "dqmap", "iqbody", "qrect"], "size": ["name", "state", "message", "capacity", "sym", "index", "set", "sum", "SIZE", "length", "scale", "count", "needed", "style", "space", "code", "empty", "span", "c", "max", "ose", "dim", "st", "height", "sn", "mode", "ize", "sy", "send", "ms", " Size", " sizes", "shape", "area", "Size", "sp", "zero", "address", "len", "small", "grow", "type"], "chardev": ["vardEv", "asserEv", "chardEv", "chartel", "edgedev", "chidEv", "asserdev", "vardv", "chartEv", "chiddev", "chardel", "asserev", "vardev", "charddev", "chardv", "arddev", "ardev", "edgedel", "edgedEv", "chartv", "vardel", "edgedv", "ardEv", "chartev", "chidev"], "data": ["name", "done", "t", "it", "message", "missing", "source", "rew", "value", "length", "rel", "read", "format", "table", "d", "ata", "image", "reader", "none", "def", "empty", "str", "partial", "des", "bytes", "step", "batch", "body", "result", "extra", "raw", "DATA", "dat", "buffer", "mem", "supported", "Data", "trans", " DATA", "cache", "len", "json", "bin", "form", "sample", "file", "feed", "text"], "errp": ["errps", "errm", " errjp", " errping", "errr", "rrpc", "corm", "arrping", "corp", "arrps", " errpc", "corpb", "arrp", " errpol", "errpol", "arrpb", "errjp", "privp", "errpc", "privpol", "errpb", "privping", " errpb", " erjp", "rrr", " erp", "privps", "errping", " errps", " errr", "arrjp", "corjp", "rrp", "arrm", "rrjp", " errm", " err", " erpc", "arrpol"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int do_bit_allocation(AC3DecodeContext *ctx, int flags)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i, snroffst = 0;\n\n\n\n    if (!flags) /* bit allocation is not required */\n\n        return 0;\n\n\n\n    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */\n\n        snroffst += ab->csnroffst;\n\n        if (ab->flags & AC3_AB_CPLINU)\n\n            snroffst += ab->cplfsnroffst;\n\n        for (i = 0; i < ctx->bsi.nfchans; i++)\n\n            snroffst += ab->fsnroffst[i];\n\n        if (ctx->bsi.flags & AC3_BSI_LFEON)\n\n            snroffst += ab->lfefsnroffst;\n\n        if (!snroffst) {\n\n            memset(ab->cplbap, 0, sizeof (ab->cplbap));\n\n            for (i = 0; i < ctx->bsi.nfchans; i++)\n\n                memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n\n            memset(ab->lfebap, 0, sizeof (ab->lfebap));\n\n\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    /* perform bit allocation */\n\n    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))\n\n        if (_do_bit_allocation(ctx, 5))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (flags & (1 << i))\n\n            if (_do_bit_allocation(ctx, i))\n\n                return -1;\n\n    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))\n\n        if (_do_bit_allocation(ctx, 6))\n\n            return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 23668, "substitutes": {"ctx": ["msg", "ppo", "ck", "pt", "loc", "tk", "jp", "wx", "aux", "tmp", "via", "kb", "tc", "ctl", "xc", "kw", "jac", "resp", "context", "unk", "dl", "handle", "cmp", "kl", "xp", "mt", " cx", "px", "sc", "cf", "ka", "wcs", "wd", "anc", "cmd", "cam", "iat", "tm", "cc", "support", "cp", "sys", "vc", "abc", "act", "gc", "pkg", "tz", "def", "cv", "tx", "cl", "proc", "hw", "buf", "ia", "kh", "nt", "pause", "np", "req", "conf", "obj", "kj", "nc", "ij", "history", "mk", "txt", "kt", "func", "cb", "qq", "aka", "etc", "ct", "gz", "bc", "conn", "rt", "addr", "js", "mc", "pb", "typ", "cfg"], "flags": ["ties", "ports", "packages", "acts", "mask", "products", "faces", "lands", "planes", "details", "grades", "types", "ants", "lists", "features", "members", "fields", "plugins", "bugs", "amps", "words", "FLAG", "allows", "fs", "olds", "rights", "status", "atts", "ats", "vs", "properties", "cf", "wcs", "posts", "ts", "Flags", "ags", "requires", "lbs", "heads", "settings", "aps", "stats", "ps", "groups", "args", "comments", "frames", "files", "points", "reports", "modules", "doms", "actions", "links", "bits", "rates", "ids", "weights", "tags", "eps", "terms", "gs", "styles", "locks", "marks", "ms", "finals", "forces", "cond", "vals", "levels", "pins", "fts", "options", "fps", "days", "flag", "tops", "limits", "lag", "ents"], "ab": ["rab", "jab", "rb", "eb", "am", "a", "bart", "app", "hal", "abe", "abc", "ac", "aka", "bl", "ob", "ash", "bank", "bs", "val", "ib", "um", "ief", "aba", "tab", "fb", "iam", "av", "hab", "ap", "nb", "ast", "abl", "ag", "Ab", "ub", "grab", "abi", " AB", "stab", "AB", "abin", "pb", "typ", "lab", "emb", "ace", "af", "amb", "fab", "b", "att", "bb", "abb"], "i": ["is", "ic", "this", "ski", "io", "m", "ims", "wi", "im", "span", "I", "ti", "cli", "PI", "k", "ui", "ex", " bi", "v", "point", "uri", "chain", "n", "\u0438", "any", " si", "si", "me", "o", "ai", "ix", "ji", "cgi", "x", " ii", "e", "ind", "gi", "sim", " ti", "my", " ni", "oi", " j", " pi", "u", "hi", "b", "bi", "t", "phi", " Xi", "it", "ri", "r", "xi", "y", "multi", "by", "d", "zi", "ei", "c", "s", "qi", "ini", "ip", "li", "in", "ci", "mi", "ii", " mi", "pi", "l", "ij", "er", "p", "di", "index", "iu", "go", "us", "ie", "key", "id", "ki", "j", "q", "gu", "eu", "ico", "mc", "json"]}}
{"project": "qemu", "commit_id": "761731b1805f6ef64eb615e5b82a0801db3cde78", "target": 0, "func": "void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 23680, "substitutes": {"device": ["volume", "name", "scope", "engine", "model", "DE", "window", "serial", "database", "driver", "image", "display", "Device", "controller", "test", "handle", "disk", "drive", "connection", "DEV", "pod", "family", "spec", "directory", "module", "product", "nexus", "server", "buffer", "component", "location", "dev", "project", "unit", "direction", "template", "feature", "sequence", "dimension", "path", "command", "block", "address", "interface", "remote", "port", "network"], "target": ["parent", "t", "root", "window", "transform", "table", "src", "image", "dest", "Target", "host", "handle", "base", "version", "spec", "buffer", "location", "direction", "template", "path", "address", "port", "file", "origin", "type"], "has_format": ["has_style", " has__format", "hat_format", " has__export", "has___module", "has_unit", "has__unit", " has__unit", "has_export", "has___format", "has__export", "has_options", "has67format", "has___style", "has_module", "has___options", " has__name", "has67export", "hat_options", " has_export", "has__format", "has_name", "has67name", "hat_module", "has67unit", " has_name", "has__name", " has_unit", "hat_style"], "format": ["fn", "name", "mat", "former", "tag", "message", "capacity", "it", "output", "f", "Format", "filter", "api", "scale", "transform", "title", "act", "filename", "text", "style", "layout", "flat", "test", "temp", "status", "fp", "version", "pattern", "mt", "ant", "tif", "spec", "option", "module", "MAT", "alt", "feat", "region", "unit", "at", "template", "error", "feature", "config", "path", "prefix", "term", "command", "address", "form", "port", "att", "file", "origin", "type"], "sync": ["enable", "loop", "scope", "sys", "use", "settings", "sym", "set", "connect", "write", "m", "scan", " synchronization", "scale", "disable", "driver", "stats", "style", "poll", "cs", "ync", "dirty", "disk", "rate", "status", "lock", "spec", "link", "directory", "buffer", "Sync", "scroll", "service", "np", "remote", "trigger", "so", "syn"], "has_mode": ["does___format", "has___mode", "does_profile", "has_profile", "has67profile", "Has_mode", "has___format", "hasTheformat", "has_force", "hasThemodule", "has67force", "hasThememory", "has67format", "has_module", "does___profile", "Has_module", "does_mode", "hasThemode", "has___profile", "does_force", "Has_memory", "does_format", "has67mode", "has___force", "has_memory", "does___mode", "does___force", "Has_format"], "mode": ["enable", "name", "scope", "time", "use", "move", "message", "settings", "model", "role", "set", "depth", "me", "m", "policy", "scale", "transform", "network", "driver", "image", "style", "id", "layout", "test", "MODE", "status", "version", "lock", "mt", "spec", "directory", "module", "theme", "position", "usage", "template", "direction", "error", "match", "only", "stage", "command", "Mode", "options", "mod", "metadata", "trigger", "flag", "option", "type"], "has_speed": ["haspletransform", "haspleengine", "have_wait", "facts_mode", "has_transform", "has42wait", "has_direction", "hasTheengine", "has_weight", "factsEspeed", "facts_engine", "hasEtransform", "has42weight", "has42direction", "factsEengine", "hasplemode", "hasEengine", "has42speed", "facts_transform", "have_speed", "hasThetransform", "factsEtransform", "have_direction", "has_wait", "hasThemode", "hasEmode", "hasplespeed", "hasEspeed", "have_weight", "facts_speed", "has_engine", "factsEmode", "hasThespeed"], "speed": ["state", "engine", "start", "access", "capacity", "index", "delay", "sex", "slow", "efficiency", "length", "score", "seed", "offset", "scale", "read", "transform", "driver", "count", "power", "skip", "weight", "timeout", "Speed", "limit", "rate", "status", "spec", "peed", "ize", "send", "seek", "frequency", "sw", "buffer", "performance", "scroll", "service", "error", "command", "interface", "address", "port", "type"], "has_on_source_error": ["has_on_src__error", "has_on_src__err", "has_on_source__error", "has_on_source_success", "has_on_source__ror", "has_on_src__ror", "has_on_source_ror", "has_on_src_ror", "has_on_src_err", "has_on_source_Error", "has_on_source__err", "has_on_source_err", "has_on_src_error"], "on_source_error": ["on_src_result", "on_image_error", "on_src_error", "on_sourcelyresult", "on_image00request", "on_source00err", "on_source00request", "on_image00err", "on_source_request", "on_source_result", "on_source00error", "on_image_err", "on_sourcelyerr", "on_image_request", "on_image00error", "on_source_err", "on_sourcelyerror", "on_src_err"], "has_on_target_error": ["has_on_target_owner", "has_on_source_success", "has_on_target_success", "has_on_source_owner", "has_on_target_err", "has_on_source_err"], "on_target_error": ["on_source_ror", "on_Target_err", "on_target___ror", "on_Target_error", "on_target_complete", "on_target_owner", "on_target___complete", "on_target_ror", "on_target__owner", "on_target__ror", "on_Target_owner", "on_target___err", "on_target__error", "on_target__err", "on_target_err", "on_source_err", "on_Target_ror", "on_target___error", "on_source_complete"], "errp": ["rrpoint", "rrpre", "erp", "derp", "errP", "drr", "warnp", "warnpe", "warnr", "rcpoint", "errpa", "errr", "err", " errP", "erpg", "drp", "derpin", "testpp", "errpp", "errpr", "derpc", "ererp", "rrP", "rrpa", "rrpp", "eorpc", "warnP", " errpa", "eorpin", "rcpre", "errpc", " erpin", "errpe", " erpun", "rcp", "eorp", "testp", " erp", "errpg", " errr", " errpe", "errpoint", "erP", " errpg", "ererpr", "errpun", "ererP", " errpr", "rrp", "drpg", "rrpr", "rcpp", "erpe", "errpin", "eorpun", "drP", "testpre", "ererpa", " erpc", "errpre", "testpoint", "derpun"], "bs": ["bi", "ubis", "boxes", "sys", "lbs", "eb", "bits", "settings", "cb", "ubs", "ys", "bed", "ss", "BS", "ns", "bps", "aos", "outs", "bl", "ps", "cs", "bc", "socket", "fs", "rs", "gs", "bn", "ds", "s", "bis", "bytes", "ls", "bm", "bh", "hz", "bles", "res", "vs", "bing", "uds", "hs", "bes", "box", "js", "its", "ts", "obs", "pb", "fps", "sb", "bos", "b", "cks", "bas", "bp", "bb"], "target_bs": [" target_ds", "target_BS", " target_BS", "target_ds", "target_sb", " target_sb"], "source": ["master", "Source", "volume", "SOURCE", "parent", "proxy", "start", "resource", "slave", "si", "object", "table", "src", "image", "dest", "stream", "id", "i", "copy", "join", "data", "select", "peer", "s", "local", "status", "pipe", "sn", "server", "service", "inner", "sp", "from", "interface", "remote", "site", "ource", "input", "ser", "port", "file", "origin", "instance"], "drv": ["srp", "drw", "srve", "drve", "crp", " drk", " drvr", "rdv", " drvs", "srvr", "rdp", "drp", "srV", "crV", "drvs", "drvr", " drw", "srf", "DRk", " drm", "DRv", "drV", "crv", "srvs", "rdve", " drva", "rdf", "DRva", "rdvr", "rdm", "trvs", "drk", "srm", "drf", "srw", "drm", "trva", "crvr", "DRvs", "drva", "trk", "rdvs", " drve", "srv", "rdw", "trv", " drf", "rdV"], "local_err": ["localewarr", "local2err", "remote2error", "remote_arr", "remote_error", "localewerr", "local2msg", "localewerror", "local2error", "local_arr", "remote2msg", "remote2arr", "remote_err", "remote2err", "localewmsg", "remote_msg", "local_msg", "local_error", "local2arr"], "flags": ["ports", "links", "bits", "heads", "settings", "tags", "stats", "ps", "ops", "FLAG", "mask", "weight", "cs", "times", "fs", "args", "locks", "frames", "faces", "states", "status", "relations", "tif", "names", "ms", "utils", "properties", "types", "ts", "fd", "Flags", "features", "ags", "options", "fps", "actions", "flag", "fields"], "size": ["name", "izes", "time", "start", "sum", "SIZE", "length", "offset", "read", "scale", "sd", "count", "timeout", "empty", "max", "bytes", "body", "z", "sn", "ize", "send", "mem", "Size", "ram", "type"], "ret": ["sys", " RET", " quiet", "Ret", "read", "val", " total", " number", "rs", "limit", "no", "status", " mem", " resp", "num", " returns", "mem", " status", "match", "RET", "params", "len", "port", "success"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688, "substitutes": {"opaque": [" opaques", "iopacity", "opatile", "iopace", "popatile", "iopaque", "ipaques", "iplay", "ipacity", "paques", "oace", "iopatile", "ipaque", "opace", " opacity", "pacity", "oatile", "oacity", "popace", "opacity", "opaques", "paque", " oplay", "play", "popaque", "oplay", "oaque", "popacity"], "addr": [" address", " ref", "rn", "rc", "alloc", "start", "a", " dst", "r", "cb", "index", "gate", "ack", "ref", "ix", "add", "offset", "err", "hash", "act", "wid", "src", "arr", "loc", "hop", "id", "inter", "x", "rs", "host", " mac", "hw", "ord", "height", "ctx", "ptr", "align", "res", "alt", "Address", "adr", "mem", "ad", "address", "cmd", "obj", "pos", "work", "ser", "pad", "l", "v", " err", "sha", "attr"], "val": ["cho", "msg", "ret", "vol", " vel", "value", " value", "err", "rel", "rol", " update", "eval", " tx", "pt", "xy", "res", "alt", " v", "util", "elt", "v", "resp", "sel", " valid", "stat", " eval", "aval", "bl", "x", "data", "fail", "Val", "pol", "pal", "pr", "num", " resp", " needle", "true", "dev", "mem", "cal", "t", " arg", "ref", "bal", "hash", "label", "def", "arg", "tx", "Value", "var", "buf", "ctx", "ve", "conf", "obj", "len", "sol", "el", "vt", " aval", "serv", "valid", "p", "txt", "ival", "index", "al", "ul", "item", "key", "arr", "pl", "test", "lex", "prop", "VAL", "vals", " ret", " msg"], "size": ["n", "name", " length", "cap", "h", "SIZE", "length", "offset", "d", "count", "code", "e", "data", "c", "z", "align", "ize", "num", " len", "mem", "Size", "sp", "address", "len", "l", "ffff", "type"], "s": ["n", "comm", "t", "p", "sys", "is", "os", "source", "set", "m", "changes", "ns", "ss", "y", "ims", "ses", "h", "stats", "ps", "bs", "ops", "cs", "sts", "rs", "gs", "fs", "services", "des", "ds", "sis", "bis", "st", "pers", "se", "sm", "sn", "spec", "ls", "sam", "ssl", "sv", "sw", "ats", "vs", "hs", "ms", "S", "js", "service", "es", "its", "sq", "ts", "sp", "ins", "params", "obj", "qs", "sb", "an", "sl", "serv"], "saddr": ["rsaddr", "scoord", "dsptr", "Saddr", "salign", "svalign", " snode", "waddr", "sptr", " sptr", "wsrd", "dsaddr", " snow", "wsptr", "waddress", "rsnode", "snow", "Saddress", "dsaddress", "Ssrc", "svnode", "ssrc", " saddress", "srd", "wsrc", "svcoord", "wsaddr", " scoord", "rscoord", " ssrc", "svptr", "svaddr", " srd", "saddress", "snode", "rsaddress", "wsnow", "dsalign", "svaddress"]}}
{"project": "FFmpeg", "commit_id": "94bb1ce882a12b6d7a1fa32715a68121b39ee838", "target": 0, "func": "static int revert_channel_correlation(ALSDecContext *ctx, ALSBlockData *bd,\n\n                                       ALSChannelData **cd, int *reverted,\n\n                                       unsigned int offset, int c)\n\n{\n\n    ALSChannelData *ch = cd[c];\n\n    unsigned int   dep = 0;\n\n    unsigned int channels = ctx->avctx->channels;\n\n\n\n    if (reverted[c])\n\n        return 0;\n\n\n\n    reverted[c] = 1;\n\n\n\n    while (dep < channels && !ch[dep].stop_flag) {\n\n        revert_channel_correlation(ctx, bd, cd, reverted, offset,\n\n                                   ch[dep].master_channel);\n\n\n\n        dep++;\n\n    }\n\n\n\n    if (dep == channels) {\n\n        av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel correlation!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bd->const_block = ctx->const_block + c;\n\n    bd->shift_lsbs  = ctx->shift_lsbs + c;\n\n    bd->opt_order   = ctx->opt_order + c;\n\n    bd->store_prev_samples = ctx->store_prev_samples + c;\n\n    bd->use_ltp     = ctx->use_ltp + c;\n\n    bd->ltp_lag     = ctx->ltp_lag + c;\n\n    bd->ltp_gain    = ctx->ltp_gain[c];\n\n    bd->lpc_cof     = ctx->lpc_cof[c];\n\n    bd->quant_cof   = ctx->quant_cof[c];\n\n    bd->raw_samples = ctx->raw_samples[c] + offset;\n\n\n\n    dep = 0;\n\n    while (!ch[dep].stop_flag) {\n\n        unsigned int smp;\n\n        unsigned int begin = 1;\n\n        unsigned int end   = bd->block_length - 1;\n\n        int64_t y;\n\n        int32_t *master = ctx->raw_samples[ch[dep].master_channel] + offset;\n\n\n\n        if (ch[dep].time_diff_flag) {\n\n            int t = ch[dep].time_diff_index;\n\n\n\n            if (ch[dep].time_diff_sign) {\n\n                t      = -t;\n\n                begin -= t;\n\n            } else {\n\n                end   -= t;\n\n            }\n\n\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1    ]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp        ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1    ]) +\n\n                     MUL64(ch[dep].weighting[3], master[smp - 1 + t]) +\n\n                     MUL64(ch[dep].weighting[4], master[smp     + t]) +\n\n                     MUL64(ch[dep].weighting[5], master[smp + 1 + t]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        } else {\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp    ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        }\n\n\n\n        dep++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23692, "substitutes": {"ctx": ["Context", "ck", "this", "loc", "tk", "timeout", "jp", "aux", "bh", "care", "std", "params", "command", "util", "tc", "work", "pat", "ctl", "course", "xc", "kw", "jac", "resp", "context", "cn", "conv", "x", "handle", "cmp", "kl", "ann", "xp", " cx", "sc", "px", "cf", "wd", "working", "anc", "prefix", "pc", "cmd", "iat", "crit", "tm", "cc", "fc", "cp", "cas", "comm", "sys", "act", "gc", "pkg", "tz", "mom", "cu", "cv", "tx", "hw", "bo", "ia", "utils", "kh", "shape", "config", "rpm", "np", "req", "pg", "conf", "obj", "nc", "ca", "history", "txt", "kt", "func", "etc", "ct", "val", "conn", "bc", "setup", "rt", "grad", "cm", "addr", "mc", "cfg"], "bd": ["ed", "ben", "vd", "dh", "ard", "bf", "ond", "cb", "dd", "di", "dis", "bed", "bel", "dc", "add", "bl", "sd", "gb", "disc", "th", "d", "gd", "bs", "board", "note", "def", "dt", "bc", "deb", "bar", "ld", "bn", "lay", "des", "dl", "md", "ds", "lt", "hd", "band", "bot", "nd", "bo", "bm", "edd", "bh", "bind", "br", "cond", "db", "ded", "dev", "cdn", "ad", "kb", "od", "js", "box", "fd", "pb", "bt", "BD", "sb", "pd", "b", "bp", "disabled", "bid", "da", "ba", "bb"], "cd": ["td", "ecd", "vd", "ck", "cb", "dd", "dial", "dom", "CD", "did", "dc", "sd", "gb", "ct", "d", "ands", "cs", "ld", "deb", "ds", "md", "cl", "hd", "nd", "cod", "cand", "cm", "dem", "cf", "od", "ad", "kb", "de", "cmd", "cr", "cc", "pd", "ca", "cp", "xd", "cz"], "reverted": ["revverted", "areverting", "REstructed", "areverted", "recferred", "resverting", "reschanged", "recved", "recvert", "resjected", "restructed", "reverting", "REferred", "recstructed", "referred", "recverted", "convert", "revferred", "revert", "resferred", "rejected", " rechanged", "REverted", "roverting", "roverted", "crejected", "revstructed", "REved", "creverted", "creferred", " reved", "conjected", "crevert", "areved", "rovert", "converted", "resved", "reved", " revert", "arevert", "roved", "conferred", "revved", "rechanged", "recchanged", "resvert", "resverted"], "offset": ["ed", "oint", "time", "end", "out", "start", "lag", "oid", "et", "o", "Offset", " offsets", "set", "ref", "index", "off", "f", "output", "unk", "ut", "attribute", "order", "conv", "needed", "image", "unc", "hop", "id", "online", "forced", "crop", "timeout", "attr", "adjusted", "size", "aff", "no", "batch", "coord", "base", "fp", "mt", "shift", "align", "q", "position", "frequency", "seek", "cm", "location", "addr", "scroll", " whence", "bound", "error", "rot", "amp", "unit", "block", "address", "pos", "pointer", "cp", "origin", "point", "padding", "channel"], "c": ["n", "p", "t", "com", "rc", "vc", "a", "cat", "o", "cb", "cn", "ce", "cont", "r", "f", "dc", "m", "h", "abc", "ac", "co", "conv", "gc", "ct", "d", "count", "unc", "x", "con", "e", "cs", "i", "bc", "cu", "cv", "uc", "category", "ec", "cmp", " C", "col", "C", "spec", "k", "q", "arc", "lc", "cm", " count", "sc", "cf", "ci", "g", "anc", "config", "mc", "pc", "cr", "tc", "conf", "cache", "nc", "b", "l", "v", "fc", "cc", "cp", "ca", "chain"], "ch": ["che", "comm", "sch", "cho", "chart", "vc", "ht", "chn", "zh", "cb", "ach", "CH", "wh", "chan", "ich", "spl", "channel", "ct", "th", "cs", "code", "tch", "cl", "arch", "cht", "proc", "pol", "col", "ches", "br", "Ch", "chip", "cand", "cor", "sh", "cm", "sky", "sc", "qu", "gr", "cmd", "cr", "conf", "ech", "v", "att", "cp", "cha", "chain", "cz"], "dep": ["dx", "desc", "vel", "dq", "debug", "rel", "im", "loc", "ld", "eg", "deb", "decl", "dig", "md", "imp", "hr", "pe", "pat", "resp", "pp", "ind", "yp", "dim", "dl", "cmp", "coord", "op", "deg", "dp", "db", "deep", "dev", "gl", "dr", "de", "cmd", "supp", "Dep", "cp", "push", "pas", "comm", "ref", "del", "dc", "rem", "dir", "d", "pkg", "inter", "depend", "def", "pri", "ptr", "df", "inc", "req", "dependent", "DEP", "dist", "p", "det", "depth", "index", "dd", "tip", "pl", "id", "hl", "dem", "iter", "ep", "rec", "lip", "gov"], "smp": ["Smp", "atsmp", "smt", "gspm", "nsmp", " samp", "spm", "spl", "scp", " spm", "ismp", "lscmp", "lspl", "atscmp", "nspm", "nscp", "smm", "hsmp", " smm", " scmp", " spl", "hspl", "gsmp", "osmp", "Scmp", "atsamp", "osmt", "gspar", "Smm", "csmt", "Samp", "ospm", "cspm", "ospar", "samp", "spar", "csmp", "cspar", "hspar", "lsmp", " spar", "scmp", "lspar", " scp", "hscmp", "atsmm", "isamp", "gsmt", "iscp", "ispm", "nsamp"], "y": ["t", "yy", "sys", "py", "ys", "m", "ay", "fy", "ey", "iy", "x", "cy", "i", "ly", "ny", "my", "vy", "ya", "xy", "j", "z", "ia", "sy", "oy", "sky", "iny", "Y", "ies", " ty", "ym", "ty", "gy", "ier", "yer", "ye", "ry", "b", "yi", "type"], "master": ["parent", "er", "primary", "slave", "masters", "secondary", "field", "m", "mid", "table", "top", "target", "my", "peer", "node", "max", "aster", "worker", "base", "manager", "tmp", "map", "Master", "mem", "pre", "mad", "origin", "counter"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n", "idx": 23696, "substitutes": {"hpet": ["hPet", "hopet", "hspel", "bhpret", "ihvet", "ihett", "ohpret", "Hett", "Hped", "hsett", "HPet", "harpel", "Hpret", " hPet", "Hpet", "exppret", "bhett", " hpit", "hanett", "exppet", "cpet", "ihpret", "ehvet", "ehPet", "ehett", "cpret", "harpet", " hvet", "ehpet", "cvet", "ohpet", "expPet", "hpret", "ohped", " hpel", "hett", " hped", "hopel", "cett", "hoett", "bhpel", "hsvet", "hpel", "hped", "hspet", "hopit", "harpit", "expett", "hanpet", "hanpel", "harett", "ohvet", "Hvet", "ihpet", "bhpet", "ihPet", "ihpit", "ohett", "hanpret", "hspit", " hpret", "hvet", "hpit", " hett"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;\n\n    }\n\n}\n", "idx": 23704, "substitutes": {"samples": ["jsamples", "assources", "sprints", "Siffs", "mamples", "serences", "aramps", " sprints", "aramples", "hamps", "Samples", "Sinks", " sples", "simens", "commactions", "mizes", "assocks", "namps", "assamples", "sources", "portsamples", "samps", " splays", "alsplays", "alsamples", "commimens", " samps", "assamps", "ariffs", "sples", "alsimens", "Sources", " simens", " sounds", "says", "commourses", "Sicks", "sinks", " sizes", "timesamples", "portsamps", "commamps", "Samps", "Sples", "nays", " sinks", "sourses", "arerences", "splays", " socks", "portsinks", "hamples", "timesiffs", "mamps", "sactions", "hounds", "Serences", " says", "nizes", "socks", " sicks", "sounds", "sicks", "Sourses", "commplays", " sources", "assples", "commples", "timeserences", "mays", "commamples", "timesamps", "jsamps", "jsounds", "hources", "assicks", "sizes", " sactions", "Socks", " sourses", "portsprints", "siffs", "namples", "alsactions", "Sprints", "jsources"], "i": ["is", "ic", "this", "io", "m", "ims", " I", "im", " index", "I", "batch", "cli", "ti", "asi", "ui", " bi", "ir", " err", "uri", "chain", "name", "\u0438", "si", "me", "ai", "ix", "ji", "x", " ii", "ind", "sim", "gi", " ti", "ami", " di", " it", " is", "fi", " ni", "oi", "g", " j", " pi", " me", "bi", "phi", "it", "iq", "ri", "xi", "y", "multi", " my", "zi", "ei", "iri", "qi", "ini", "ip", "li", "in", "ci", " key", " axis", "mi", "ii", "esi", " mi", "to", "pi", " ki", "ij", " li", "print", "di", "index", "iu", "us", "init", "key", "id", " iter", " im", "ki", "j", "iter", " multi"]}}
{"project": "FFmpeg", "commit_id": "cd1047f3911fa0d34c86f470537f343d23c8b956", "target": 0, "func": "static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    const AVPixFmtDescriptor *desc;\n\n    mfxSession session = NULL;\n\n    int iopattern = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n    int frame_width  = avctx->coded_width;\n\n    int frame_height = avctx->coded_height;\n\n    int ret;\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!desc)\n\n        return AVERROR_BUG;\n\n\n\n    if (!q->async_fifo) {\n\n        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));\n\n        if (!q->async_fifo)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {\n\n        AVQSVContext *user_ctx = avctx->hwaccel_context;\n\n        session           = user_ctx->session;\n\n        iopattern         = user_ctx->iopattern;\n\n        q->ext_buffers    = user_ctx->ext_buffers;\n\n        q->nb_ext_buffers = user_ctx->nb_ext_buffers;\n\n    }\n\n\n\n    if (avctx->hw_frames_ctx) {\n\n        AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;\n\n\n\n        if (!iopattern) {\n\n            if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)\n\n                iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;\n\n            else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)\n\n                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;\n\n        }\n\n\n\n        frame_width  = frames_hwctx->surfaces[0].Info.Width;\n\n        frame_height = frames_hwctx->surfaces[0].Info.Height;\n\n    }\n\n\n\n    if (!iopattern)\n\n        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;\n\n    q->iopattern = iopattern;\n\n\n\n    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;\n\n    param.mfx.FrameInfo.FourCC         = q->fourcc;\n\n    param.mfx.FrameInfo.Width          = frame_width;\n\n    param.mfx.FrameInfo.Height         = frame_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0)\n\n        return ff_qsv_print_error(avctx, ret,\n\n                                  \"Error initializing the MFX video decoder\");\n\n\n\n    q->frame_info = param.mfx.FrameInfo;\n\n\n\n    return 0;\n\n}\n", "idx": 23714, "substitutes": {"avctx": [" avjac", " avcmd", "avertx", "avecfg", "avcp", " avmom", " avcmp", "afcontext", "AVsc", "afctx", "navmom", "vctx", "devcontext", "AVconf", "avercmd", "avcmp", "avekt", "avconf", "AVcmd", " avct", "navctx", "devct", "avercontext", "ajtx", "aversys", "averctx", "avercp", "afcmd", "navcontext", "avercmp", "AVcontext", "devctx", "AVjac", "avecmd", "avmom", "afjac", "ajctl", " avcontext", " avtx", "averjac", "vjac", "ajcp", "aftx", "avecb", "avepkg", "navtx", " avkt", "AVcmp", "aveconf", "avtx", "avecontext", "avejac", "avjac", "averpkg", "avkt", "AVctl", "ajsys", "devsys", "navcb", "devtx", "avct", "vkt", "avcontext", " avcb", "ajconf", "AVcfg", "vcontext", "avcb", "aversc", "avemom", "avectl", "avctl", "devcp", "avsc", "avsys", "ajcfg", "avesc", "avpkg", "avcmd", "AVtx", "navct", "ajctx", "avectx", "avcfg", "AVctx", "AVpkg"], "q": ["kw", "comm", "p", "t", "msg", "it", "iq", "quit", "ck", "comment", "requ", "dq", "f", "m", "h", "qq", "qt", "pkg", "d", "needed", "x", "required", "ctrl", "Q", "conn", "c", "query", "qi", "j", "quant", "qa", "z", "lock", "ctx", "k", "quest", "queue", "qu", "ch", "g", "eq", "sq", "req", "conf", "w", "qs", "crit", "pg", "quick", "ue", "v", "l", "aq"], "desc": ["asc", "Desc", "msg", "txt", "dep", "DES", "sec", "dc", "err", "disc", "etc", "dir", "d", "gd", "pkg", "enc", "description", "def", "ext", "conn", "decl", "bd", "meta", "des", "ds", "ec", "esc", "cmp", "vec", "buf", "ptr", "sc", "dev", "mem", "doc", "dr", "req", "cmd", "conf", "cam", "rec", "dist"], "ret": ["resp", "re", "sys", "out", "sel", "ref", "back", "Ret", "val", "def", "proc", "status", "result", "tif", "rt", " resp", "res", "alt", "mem", "par", "RET", "req", "len", "ry", "flag"], "user_ctx": ["user_jac", " user_sys", "user_ct", "student_pkg", "user____pkg", "student_nt", "User_ctx", " user_tx", "User_tx", "student_jac", "user_cmp", "user_loc", "student_ctx", "user_sys", "user____nt", "user_tx", " user_na", " user_pkg", " user_ca", "user_obj", "user_nt", "user____jac", "User_pkg", "User_loc", " user_ct", " user_obj", "user_na", "user_pkg", " user_cmp", "user_ca", "user____ctx"], "frames_ctx": ["frames____ctx", " frames2ctx", " frames2src", "frames___conv", "lights___ctx", "frames2hw", "frames____conv", "lights_ctx", "lights_ck", " frames_hw", " frames_crit", " frames2hw", "lights___ck", " frames_src", "lights_conv", "frames2src", "lights___conv", "frames_src", "frames_conv", "frames_ck", "frames2ctx", "lights_comp", "frames____comp", "frames_crit", "lights___comp", "frames_hw", "frames_comp", " frames2crit", "frames____ck", "frames___comp", "frames2crit", "frames___ck", "frames___ctx"], "frames_hwctx": ["frames_hwobj", "frames_hwcfg", "frames_nwcfg", "frames_hwcmp", "frames_fwcfg", "frames_fwaddr", "frames_hmsys", "frames_httx", "frames_fwobj", "frames_iwkg", "frames_windctx", "frames_iwcmp", "frames_dllctx", "frames_iwaddr", "frames_fwctx", "frames_dllpkg", "frames_windkg", "frames_dllheight", "frames_htctx", "frames_hwheight", "frames_hmkg", "frames_hwtx", "frames_hwkg", "frames_iwheight", "frames_fwheight", "frames_windcmp", "frames_htaddr", "frames_htobj", "frames_iwpkg", "frames_htcfg", "frames_hwsys", "frames_hmcmp", "frames_nwobj", "frames_htpkg", "frames_hwpkg", "frames_nwtx", "frames_hmctx", "frames_fwtx", "frames_nwctx", "frames_iwsys", "frames_fwpkg", "frames_windsys", "frames_dllobj", "frames_iwctx", "frames_iwobj", "frames_hwaddr"]}}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n", "idx": 23744, "substitutes": {"proxy": ["clone", "core", "pse", "reference", "engine", "slave", "gate", "force", "connect", "ping", "callback", "device", "window", "domain", "shadow", "driver", "embed", "conn", "socket", "php", "host", "library", "connection", "profile", "roxy", "Proxy", "request", "link", "manager", "web", "server", "module", "map", "super", "project", "service", "phy", "pin", "pc", "pool", "native", "remote", "cache", "virtual", "mi", "client", "browser", "port", "boss", "gp", "cas"], "region": ["definition", "scope", "reference", "tag", "resource", "ion", "role", "memory", "contin", "desc", "group", "record", "window", "zone", "session", "domain", "item", "format", "relation", "gc", "roy", "rar", "script", "section", "dim", "Region", "regulation", "slot", "span", "ge", "local", "snap", "batch", "country", "city", "module", "res", "storage", "rule", "division", "location", "reg", "area", "dimension", "unit", "shape", "angular", "range", "command", "prefix", "block", "address", "REG", "remote", "esi", "port", "grid", "gru", "widget"], "cap": ["comm", "com", "ck", "aps", "cn", " caps", "ac", "act", "ct", "capt", "pp", "fac", "pl", "ctrl", "copy", "bc", "cum", "trace", "cv", "ipp", "ape", "c", "cl", "cmp", "snap", "ap", "ab", "pub", "cod", "Cap", "claim", "rip", "caps", "sam", "sh", "map", "sc", "cf", "pan", "ch", "rep", "cam", "cmd", "tc", "acl", "CAP", "acc", "lip", "ca", "fab", "cast", "cp", "cfg", "pay"]}}
{"project": "qemu", "commit_id": "d044be3714db9c3750c430a2bb1be74beee6fd27", "target": 0, "func": "static void mixer_reset (AC97LinkState *s)\n\n{\n\n    uint8_t active[LAST_INDEX];\n\n\n\n    dolog (\"mixer_reset\\n\");\n\n    memset (s->mixer_data, 0, sizeof (s->mixer_data));\n\n    memset (active, 0, sizeof (active));\n\n    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n\n    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n\n    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n\n\n\n    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n\n    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n\n    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n\n    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n", "idx": 23747, "substitutes": {"s": ["ties", "is", "m", "ims", "sts", "ds", "details", "ssl", "sv", "sw", "res", "hs", "xs", "ins", "less", "sb", "as", "v", "local", "sql", "sl", "n", "a", "os", "changes", "ns", "sync", "bs", "i", "cs", "fs", "aws", "states", "status", "sets", "g", "ts", "qs", "b", "tes", "comm", "t", "sys", "settings", "r", "f", "y", "stats", "ps", "c", "z", "spec", "ls", "S", "reports", "its", "sol", "l", "p", "bits", "h", "ss", "us", "ses", "sports", "rs", "gs", "locks", "j", "south", "full", "q", "ms", "js", "sq", "w"], "active": ["playing", "valid", "available", "all", "a", "memory", "h", "running", " all", "act", "activated", " dynamic", "current", " activated", " indexed", " busy", "tx", "data", " events", "actively", "locks", " inactive", " Active", "status", "selected", "live", " current", "full", "items", "shared", "pressed", "res", "seq", "initialized", "used", "stable", "js", " activate", " status", " reactive", "activate", "registered", "visible", " idle", "Active", "sol", "actions", "disabled", " interactive", "quick", "primary"]}}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751, "substitutes": {"bs": ["ubis", "bi", "sys", "lbs", "bits", "bf", "ks", "os", "cb", "ubs", "ss", "BS", "bps", "aos", "ses", "ns", "gb", "stats", "iss", "ps", "cs", "bc", "fs", "gs", "rs", "bn", "ds", "bis", "bytes", "s", "ctx", "ls", "bh", "ms", "bles", "vs", "bes", "js", "its", "ts", "obs", "pb", "sb", "bos", "b", "bas", "cks", "bp", "uts", "bb"], "offset": ["offs", "end", "start", "bf", "oid", "o", "amount", "Offset", " offsets", "index", "set", "ref", "off", "et", "length", "original", "key", "loc", "skip", "data", "reset", "size", "coord", "base", "mt", "shift", "seek", "position", "alt", "part", "entry", "addr", "bound", "error", "command", "prefix", "util", "block", "address", "offer", "iat", "pos", "len", "store", "slice", "pointer", "pad", "local", "origin", "point", "alias"], "count": ["n", "start", "message", "number", "cont", "amount", "comment", "depth", "index", "desc", "force", "check", "sum", "length", "latest", "total", "current", "code", "max", "c", "size", "limit", "cur", "batch", "no", "nb", "found", "buf", "ctx", "ount", "now", "child", "num", "cond", "part", "try", "Count", "nt", "cmd", "conf", "cache", "len", "nc", "cc", "b", "cast", "ctr", "counter", "type"], "co": ["coll", "cho", "ano", "com", "ror", "ho", "o", "coe", "io", "gro", "go", "cover", "flo", "fo", "Co", "circ", "con", "po", "ro", "cu", "oo", "ko", "c", "PO", "redo", "mo", "lo", "coord", "col", "bo", "aco", "CO", "ico", "vo", "pc", "cycle", "soc", "can", "cc", "fc", "xc", "oc"], "aio_context": ["aio___address", "aoop_document", "aio_document", "aio___container", "aoop_address", "aio___document", "aio___context", "aoop_iterator", "aoop___document", "aio_address", "aoop___context", "aio_container", "aio___iterator", "aio_iterator", "aio_ctx", "aio___ctx", "aoop_context", "aoop___iterator", "aoop___address"]}}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n", "idx": 23758, "substitutes": {"env": ["ee", "expr", "er", "en", "msg", "end", "txt", "org", "context", "usr", "desc", "ef", "window", "err", "inv", " ens", "pkg", "gear", "serv", "def", "e", "conn", "cv", "info", "den", "esc", "hw", "EN", "rod", "enter", "buf", "estate", "ctx", "ptr", "ov", "environment", "net", "ve", "server", "vs", "db", "home", "viron", "dev", "En", "erd", "vv", "era", " environment", "obj", "cmd", "req", "ah", "nv", "v", "ra", "vp", " en", "ev", "attr", "forge", "vt"], "addr": ["expr", "msg", "et", "ack", "loc", "eth", "host", "ag", "alt", "map", "pos", "oc", "aj", "ix", "rr", "ind", "atom", "oad", "handle", "coord", "mt", "db", "adj", "adr", "at", "mem", "dr", "cmd", " address", "tag", "r", "arp", "ref", "hash", "rank", "act", "ar", "pkg", "url", "inter", "tx", "var", "ip", "hw", "ctx", "ptr", "ad", "adv", "trans", "obj", "attr", "alias", "rc", "usr", "index", "gate", "offset", "add", "gz", "inv", "src", "arr", "row", "ord", "urg", "align", "rt", "grad", "iter", "address", "pad", "phys"], "val": [" aval", "valid", "resp", "msg", " arg", "it", "ival", "ret", "final", "func", "hal", "vol", "stat", "ref", " eval", "aval", "bal", "value", " value", "rel", "al", "rol", "err", "eval", "serv", "arr", "loc", "arg", "def", "tx", "Value", "data", "var", "test", "fail", "Val", "vec", "pol", "alpha", "buf", "urg", "ctx", "grad", "res", "VAL", "vals", "reg", "dev", "mem", " v", "util", "cal", "len", "elt", "b", "v", "el", "lib", "vt"]}}
{"project": "FFmpeg", "commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "target": 1, "func": "int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 23762, "substitutes": {"w": ["kw", "n", "a", "r", "wh", "NW", "window", "ww", "aw", "nw", "wi", "d", "x", "wp", "fw", "wr", "iw", "hw", "rw", "wx", "wl", "wb", "we", "W", "wal", "wd", "tw", "wt", "ew", "wa", "l", "v"], "h": ["n", "p", "dh", "ht", "he", "ho", "high", "r", "hh", "hal", "H", "oh", "m", "y", "ha", "th", "d", "x", "s", "hd", "hw", "z", "hr", "height", "ih", "bh", "sh", "kh", "hl", "rh", "ch", "g", "ah", "b", "hi", "v", "ish"], "sar": ["isear", "Sar", "psart", " sara", "sqare", "desarian", "sarian", " sear", "psarp", "s\u00e9r", " Spar", "servar", "rsar", " SAR", "rspar", " s\u00e9r", "sars", "servear", "isar", "scear", "servpar", "sqaver", "srar", "sear", "desaver", "Spar", "qsare", " Sar", " esrar", "scart", "spar", "servara", "qspar", "tsarp", "servcar", "psear", "saver", "scar", "qs\u00e9r", "isare", "sAR", "scara", "qsar", "psara", "ps\u00e9r", "tspar", "desar", "isars", "qsarian", "sara", "tscar", " sare", "qsaver", "Sear", "sqar", "rsars", " espar", "sare", "sqarian", " scar", "qsear", " esAR", "Sara", "tsar", "pscar", "Scar", " sart", "sart", "rsear", "rsrar", "pspar", "sccar", " esar", "rsAR", "rsare", "sarp", " Srar", "desare", " spar", "scars", "psar", "rsara", " sars"], "scaled_dim": ["scaling_Dim", "scale2dir", "scale_dir", "scale_dim", "scaled2num", "scale_dimension", "scaled_scale", "scaled2Dim", "scaled5dim", "scale2num", "scaled2dir", "scaling_dimension", "scale_num", "scaling5dim", "scale_member", "scaled_axis", "scaled2member", "scaled2di", "scale2dim", "scaling_scale", "scaling5Dim", "scaled_num", "scaled2dim", "scaling5scale", "scale_Dim", "scaled2scale", "scale_di", "scaling_dim", "scaled_di", "scaled_dir", "scale2di", "scaled_val", "scaled5Dim", "scaled_dimension", "scaled_Dim", "scaled2dimension", "scaled5dimension", "scaled5scale", "scaling5dimension", "scaled_member"]}}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n", "idx": 23769, "substitutes": {"s": ["n", "comm", "t", "re", "is", "p", "sys", "r", "parts", "m", "h", "ns", "ss", "ims", "changes", "ses", "stats", "ps", "bs", "cs", "sts", "times", "rs", "gs", "fs", "aws", "c", "comments", "ds", "bis", "se", "status", "ls", "details", "sam", "sv", "sw", "ms", "vs", "ats", "hs", "series", "S", "js", "ess", "g", "es", "ins", "sq", "ts", "als", "ants", "its", "erences", "conf", "qs", "less", "aunts", "sample", "sb", "an", "b", "as", "v", "tes", "ains", "events", "serv"], "count": ["n", "t", "re", "all", "number", "cont", "amount", "index", "list", "force", "check", "h", "sum", "length", "read", "gc", "th", "ct", "total", "current", "x", "code", "ind", "empty", "max", "c", "size", "limit", "body", "nb", "z", "result", "found", "ount", "now", "more", "num", "cond", "buffer", "cf", "try", "ch", "Count", "scroll", "match", "nt", "find", "zero", "conf", "cache", "len", "cc", "b", "cast", "l", "ctr", "counter", "type"], "i": ["ic", "this", "ski", "m", "ims", " I", "im", "span", "I", "batch", "ti", "cli", "PI", "ui", " bi", "client", "v", "token", "sql", "point", "uri", "chain", "n", "\u0438", "si", "me", "ai", "ix", "ji", "x", " ii", "sim", "ind", "e", "gi", "ami", "status", "oi", "g", " j", "bi", "t", "phi", "it", "iq", "ri", "xi", "y", "multi", "ei", "zi", "c", "ni", "qi", "ini", "ip", "li", "uni", "in", "ci", "docker", "mi", "ii", "pi", "ish", "series", "ori", "ij", "p", "print", "di", "iu", "init", "ki", "j", "ms", "page", "iter", "MI"]}}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n", "idx": 23771, "substitutes": {"mr": ["er", "lr", "mor", "rn", "km", "r", "shr", "nr", "m", "pm", "ns", "irm", "ml", "vr", "mb", "rr", "rar", "rs", "RM", "MR", "hr", "mt", "sr", "bm", "br", "ms", "kr", "cm", "adr", "rm", "drm", "dr", "mx", "mc", "rpm", "mi", "Mr", "mn", "wm"]}}
{"project": "qemu", "commit_id": "be18b2b53ebbf2eb3f00e7890d0b9ff8b58d22bf", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n        env->error_code = 0x10000000;\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x40000000;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (rwx == 1) {\n\n                env->spr[SPR_DSISR] = 0x42000000;\n\n            } else {\n\n                env->spr[SPR_DSISR] = 0x40000000;\n\n            }\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x08000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 23779, "substitutes": {"cpu": ["core", "p", "sys", "gpu", "context", "ck", "processor", "process", "cn", "stat", "tp", "exec", "thread", "gc", "ct", "bench", "conn", "cu", "onet", "mu", "vm", "c", "gnu", "ec", "jp", "arch", "cli", "proc", "nu", "mac", "hw", "ork", "pu", "ctx", "kernel", "hz", "clock", "nic", "aco", "apache", "sc", "mem", "upt", "rpm", "pc", "np", "cmd", "CPU", "linux", "pai", "nc", "cc", "ctl", "uda", "phys", "cp", "aq"], "eaddr": ["edDR", " edDR", " edrr", "elldr", "egdro", "eddDR", "eddfr", " elrr", " adrr", "oadptr", "egdr", " addr", "embeddro", "eddder", "oadDR", "eddhr", "ellfr", "egr", "eddstr", "ellr", "ellhr", "rawDR", " eltr", "oaddr", "egder", "eadDR", "embeddr", "eadfr", "winddr", " adDR", "eadstr", "embedder", " eddr", "eadrr", "edr", "oadhr", "embedr", "winder", "edder", "oader", "oadder", "oadfr", "oadstr", "windder", "eadr", "eaddro", "rawdr", "rawder", "windr", "oaddro", "rawstr", "eadptr", " eldr", " elDR", "eadder", "edptr", "eader", "eddr", "eddptr", " adtr", "eadhr", "eadtr", "edddr", "oadr", " edtr"], "rwx": ["rux", "randx", "wxix", "rwxf", "wheX", "winew", "rwy", "wxpx", "wwix", "wwx", "rufx", "winext", "RWz", "fwv", "wrax", "fwxp", "rewf", "rwv", "rwld", "wxfx", "rackax", "rwp", "wxxt", "wrxt", "wrx", "wrX", "norix", "wxld", "RWw", "wxc", "wxX", "wrpx", "kwx", "wxv", "rwX", "ruv", "rewX", "rackz", "rewxf", "rolly", "fwfx", "winex", "rwz", "kwpx", "wrz", "rwxp", "wrf", "wheix", "wxz", "rollxt", "rwix", "rackpx", "wrc", "owp", "fwX", "rewx", "wxy", "wry", "RWxt", "rww", "oww", "randix", "wxp", "rwpx", "owx", "rollX", "rwfx", "wrp", "rwf", "rwc", "fwix", "wrld", "kwz", "randpx", "fwx", "whex", "randz", "rwxt", "norX", "owc", "ruxp", "wxx", "wxxp", "wxw", "wwld", "RWx", "rewix", "rwax", "rollx", "wxf", "wrw", "wwf", "rackx", "fwf", "wrix", "whexf", "wxax", "norx", "kwix", "norxf", "winez"], "mmu_idx": ["mmu_idz", "mmu_IdX", "mmu_midv", "mmu_indX", "mmu_Idv", "mmu_bidy", "mmu_bidX", "mmu_Idx", "mmu_indv", "mmu_indz", "mmu_indx", "mmu_bidz", "mmu_Idy", "mmu_idv", "mmu_midz", "mmu_midX", "mmu_idX", "mmu_Idz", "mmu_idy", "mmu_midy", "mmu_midx", "mmu_bidx"], "cs": ["yes", "csv", "sys", "ics", "ck", "ks", "icks", "css", "cn", "ce", "ys", "ix", "cus", "ns", "ps", "bs", "uns", "Cs", "sts", "fs", "rs", "cv", "conn", "c", "ds", "s", "ec", "proc", "ctx", "ls", "checks", "CS", "caps", "vs", "ces", "hs", "cm", "sc", "cf", "js", "cms", "ci", "wcs", "ts", "pc", "cmd", "tc", "acs", "qs", "nc", "cc", "cks", "cp", "cas", "cons"], "env": ["er", "en", "eas", "scope", "end", "der", "cap", "state", "context", "esm", "eh", "engine", "et", "ce", "desc", "equ", "eni", "policy", "ef", "window", "err", "head", "editor", "inv", "ner", "ens", "enc", "ei", "e", "conn", "ext", "cv", "tx", "vm", "den", "esc", "ec", "export", "proc", "worker", "buf", "ctx", "spec", "ent", "event", "here", "environment", "manager", "vs", "entry", "em", "viron", "dev", "priv", "eu", "doc", "subject", "config", "term", "except", "era", "conf", "Environment", "ah", "ew", "next", "nv", "eng", "v", "shell", "agent", "ev"], "slb": ["selmb", "selbe", " slbb", "sslg", " slbe", "Slbb", "slg", "mlbe", "sslp", "splb", "islg", "sslv", "slbd", "slmb", "splB", "kelb", "Sla", " slv", "islv", "sslbar", "selB", "splmb", "mlb", " slp", "slbb", "slbe", "splbe", "SLg", "islb", "islbe", "slB", "ellbar", "kelbar", "ellbe", " sla", "slbar", "SLb", "slp", "sslbb", "islB", " slg", "mlbd", "mlbar", "sslb", "sla", "Slb", "islmb", "selb", "ssla", " slbar", "ellbd", "slv", "Slp", "SLbb", "kelg", "islp", "SLbar", "kelbb", "ellb", " slbd"], "pte_offset": ["ptee_address", "pte_location", "ptE_offset", "ptee_offset", "ptE_origin", "ptE_Offset", "ptee_Offset", "ptee_index", "pte_id", "ptee_location", "pte_index", "ptee_id", "pte_origin", "pte_Offset", "pte_address"], "pte": ["ptyb", "ctee", "cted", "apte", "epted", "cte", " ptel", "ptes", " ptb", "ctb", "epte", "pted", "ptye", "ptyel", "ptyee", "ptel", "aptee", "ptee", "ctel", " ptee", "ptb", "eptee", "ctes", "eptes", "aptes", "apted"], "pp_prot": ["pp_pro", "op__pro", "pp__pro", "op_pro", "op_type", "pp__tp", "op_prot", "op__type", "op__prot", "pp__prot", "pp_tp", "pp__type", "op_tp", "op__tp", "pp_type"], "amr_prot": ["amp_pc", "amr_rot", "amr_pc", "amr_phy", "amp_phy", "amp_prot", "amp_rot"], "prot": ["msg", " proto", "policy", "prototype", "pro", "uf", "def", "eth", "reset", "ocol", "col", "version", "Prot", "prop", "tif", "ptr", "platform", "crypt", "phy", "rot", " protocols", "chron", "pb", "typ", "inet", "port", "tf"], "new_pte1": ["new_ptpe8", "new_ptxe1", "new_pte0", "new_pte64", "new_ptxe64", "new_ptes8", "new_ptpe1", "new_ptxe8", "new_mintxe1", "new_minte0", "new_minte64", "new_mintxe8", "new_ptpe0", "new_mintxe0", "new_pte8", "new_ptes0", "new_mintxe64", "new_ptxe0", "new_ptpe64", "new_ptes64", "new_minte1", "new_ptes1", "new_minte8"], "need_prot": ["pg_rot", "ppLstat", "pg_prot", "pp2rot", "ppLprot", "pp_rot", "pp2stat", "pp_types", "ppLrot", "ppLtypes", "pg_stat", "pp2prot", "pg_types", "pp_stat", "pp2types"], "raddr": ["hhash", "Raddr", "hptr", "rAddress", "roa", "wadd", "rptr", "mAddress", " rptr", " roa", "waddr", "radd", "mptr", "haddr", "Raddress", "haddress", "waddress", "rhash", "rroa", " rAddress", "rraddr", "rradd", " raddress", "woa", "raddress", "Rhash", "maddress", "RAddress", " radd", "Rptr", " rhash", "rraddress", "maddr"]}}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    uint8_t const *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin = AV_RL16(buf+ 4);\n\n    ymin = AV_RL16(buf+ 6);\n\n    xmax = AV_RL16(buf+ 8);\n\n    ymax = AV_RL16(buf+10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf+66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes<<8) + bits_per_pixel) {\n\n        case 0x0308:\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            break;\n\n        case 0x0108:\n\n        case 0x0104:\n\n        case 0x0102:\n\n        case 0x0101:\n\n        case 0x0401:\n\n        case 0x0301:\n\n        case 0x0201:\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                ptr[3*x  ] = scanline[x                    ];\n\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        for (y=0; y<h; y++, ptr+=stride) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto end;\n\n        }\n\n\n\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n", "idx": 23786, "substitutes": {"avctx": ["wavctx", "AVconf", "AVcp", "afjp", "avconf", "avercu", "awcontext", " avconn", "averconf", "aftx", "avcontext", "afconn", "afobj", "avcpu", "airobj", "averjp", "avjp", "aircu", "avertx", "avepkg", "aveconf", "vrcontext", "afpkg", "avcp", "avtx", "airjp", "avctl", "averctx", "wavcpu", "avetx", "afcu", "awconn", "avecontext", "afcpu", "averobj", "afcontext", "airctx", "averpkg", "wavctl", "vrtx", "avpkg", "avecp", "AVcontext", "afctx", "afcp", "avercpu", "afconf", "awctx", "awtx", " avconf", "vrconf", "averctl", "AVpkg", "AVctl", "afctl", "avectx", "avcu", "AVctx", " avcontext", "avobj", " avtx", "wavtx", "avconn", "vrctx"], "data": ["name", "share", "t", "bits", "message", "first", "frame", "a", "record", "type", "device", "window", "value", "length", "read", "rel", "root", "table", "d", "ata", "image", "reader", "package", "def", "empty", "info", "size", "bytes", "batch", "family", "pipe", "raw", "DATA", "video", "dat", "map", "buffer", "area", "Data", "action", "block", "bin", "obj", "input", "next", "to", "pad", "file", "padding", "text"], "data_size": ["data__SIZE", " data_offset", " data_SIZE", "data_offset", "data__offset", " data_length", "data_length", "data__length", "data__size", "data_SIZE"], "avpkt": [" avcpkt", "avwpqt", "avwpck", "abnpqt", "abnpvt", "avnpqt", "AVpacket", "avpackft", "AVcpix", "avPvt", "avnpvt", "avjpacket", " avcpacket", " avcpet", "AVpft", "avopck", " avpacket", " avpet", "abpqt", "avpackix", "abnpkt", "avpqt", "avnpct", "AVcpkt", "avwpkt", "avopkt", "avpacket", "avwpvt", "avopacket", "avpix", "avcpix", "abnpct", "avcpacket", "abpkt", "avjpft", "avwpet", "avpackacket", "abpct", "avpft", "avjpkt", "avcpkt", "AVpix", "avPct", "AVcpft", "avpct", "avpck", "avopet", " avpck", "avcpck", "avwpacket", "avwpct", "avPqt", "avpackkt", " avcpck", "avpvt", "avcpet", "avjpix", "AVpkt", "avPkt", "avpet", "avnpkt", "avcpft", "AVcpacket", "abpvt"], "buf": ["msg", "pack", "desc", "err", "late", "uf", "cur", "batch", "ff", "uv", "br", "bh", "tmp", "map", "used", "emb", "pos", "front", "port", "orig", "list", "bl", "packed", "conv", "bs", "Buffer", "bytes", "vec", "coord", "deg", "xff", "burst", "dat", "seq", "db", "mem", "cmd", "cam", "bu", "b", "cp", "r", "ref", "pkg", "cv", "var", "fb", "ctx", "raw", "buffer", "box", "buff", "req", "pool", "pg", "cache", "cast", "vp", "bag", "rb", "cap", "txt", "alloc", "func", "cb", "aka", "init", "Buff", "fac", "tr", "result", "prop", "img", "nm", "queue", "iter", "doc", "pb", "pad"], "s": ["n", "t", "sys", "is", "a", "os", "ss", "ns", "stats", "ps", "cs", "sts", "socket", "rs", "gs", "fs", "c", "e", "ds", "ls", "ms", "sv", "sw", "ats", "S", "js", "space", "es", "sq", "ts", "sp", "acs", "sb", "b", "as"], "picture": ["share", "icon", "pic", "pict", "audio", "Picture", "context", "frame", "stat", "photo", "policy", "summary", "piece", "image", "style", "info", "important", "query", "pa", "profile", "status", "family", "img", "media", "pen", "conference", "png", "video", "finals", "camera", "feature", "screen", "panic", "file", "friendly"], "p": ["n", "t", "a", "r", "o", "f", "m", "d", "pkg", "ps", "pp", "c", "pa", "jp", "j", "ap", "fp", "op", "P", "par", "rep", "pb", "pc", "np", "cp", "pic"], "compressed": ["Compression", "suppress", "Compapped", "Complied", "ompressed", "compapped", "compress", "ompression", "suppressed", "suppression", " compress", "Compress", "Compressed", " compression", "ompress", "compression", " compapped", "supplied", "omplied", "complied", "ompapped"], "xmin": ["xystart", "ixstat", "xtmax", "ixmax", "xfirst", " xmins", " xfirst", "xyfirst", "ixmins", "yfirst", "oxmax", "exmin", "ymins", "ixfirst", "oxmin", " xstat", "xxmin", "xstart", "dxmax", "xymin", "exfirst", "wmin", "dxfirst", "oxmins", "exstart", "xxmax", "dxmin", "xxmins", "wmax", "xymax", "wmins", "xtfirst", "xtstart", "xmins", "dxmins", "oxfirst", "xstat", "xxstat", "ixmin", "exmax", "xtmin", "wfirst"], "ymin": ["symins", " ymins", "cymin", "mymax", "yymin", "ymins", "myMin", "symin", " yminute", "ystart", "sydir", "ynmin", "yMin", "cyMin", " ystart", " ydir", "yndir", " yMin", "ynmax", "Ymin", "yminute", "mymin", "xMin", "mystart", "yyminute", "ydir", "symax", "cymax", "yymax", "myminute", "ynmins", "xmins", "yystart", "YMin", "cyminute", "Yminute", "Ymax", "mymins"], "xmax": ["wax", "rxmin", "zxlast", "ixmax", "xyend", "wMAX", "xMAX", "exmin", "XMax", "rxlast", "xymin", "Xmax", "rxmax", "yMAX", "exend", "xyax", "ixlast", "rxMax", "exax", "Xlast", "wMax", "yax", "zxMax", "yMax", " xMax", "wmax", "xymax", " xMAX", "xend", " xend", "xax", "Xmin", "zxmax", "rxMAX", "zxmin", " xlast", "ixMAX", " xax", "xMax", "exmax", "xlast"], "ymax": ["ymmake", "yanast", "yanody", "iyody", "yanager", "iyake", "yrimax", "ypake", "ymmax", "ypager", "nyajor", "ymmari", "ymaze", "nyast", "yrimaj", "ymake", "ymager", "ymmag", "ymag", "yanode", "hmake", "yrimas", "hmaze", "nyode", "ymas", "ymast", "nmas", "ymari", "ymmajor", "ymmas", "iyager", "ymmast", "ymmaze", "nyax", "yrimari", "ymajor", "iyax", "ypag", "ymody", "ymode", "nmaj", "ypaze", "yanajor", "yanax", "hmag", "ymmaj", "nmari", "ymaj", "ypax", "yanake", "ypody", "ymmode", "hmax", "nmax"], "w": ["n", "kw", "r", "wh", "m", "window", "ww", "nw", "wid", "wi", "d", "wp", "fw", "row", "c", "size", "wr", "iw", "hw", "z", "rw", "wx", "height", "q", "ex", "sw", "wb", "W", "g", "wd", "cam", "wt", "tw", "work", "ew", "wn", "wa", "b", "l", "v"], "h": ["n", "en", "ht", "he", "ho", "high", "hh", "hal", "wh", "H", "f", "oh", "m", "hash", "ha", "max", "hd", "hr", "height", "ih", "k", "bh", "q", "hz", "html", "ph", "kh", "hs", "hm", "ch", "b", "hi", "v", "l"], "bits_per_pixel": ["bits_PER_channel", "bits_PER_word", "bits_per_color", "bits_per_channel", "bits_per__pixel", "bits_per2pixel", "bits_per_word", "bits_per2channel", "bits_PER_page", "bits_per_image", "bits_PER_byte", "bits_per__page", "bits_per_page", "bits_per__image", "bits_per2page", "bits_PER_color", "bits_PER_pixel", "bits_PER_cell", "bits_per_byte", "bits_PER_image", "bits_per_cell"], "bytes_per_line": ["bytes_permissionpixel", "bytes_permissionLine", "bytes_PER_line", "bytes_PER_Line", "bytes_per_section", "bytes_for_Line", "bytes_per_page", "bytes_per_block", "bytes_PER_block", "bytes_for_pixel", "bytes_PER_page", "bytes_per_Line", "bytes_PER_section", "bytes_permissionsection", "bytes_for_line", "bytes_per_pixel", "bytes_PER_pixel", "bytes_permissionline"], "nplanes": ["nframes", "mpages", "nbpacks", "nanes", "lplanes", "lpages", "mlines", "onframes", "cnpacks", "nsblocks", "onpages", "unframes", "lframes", "cnplanes", "cnanes", "nnlines", "numframes", "nlines", "cnframes", "manes", "numblocks", "nbframes", "onplanes", "nsplanes", "cnlines", "npacks", "nnpacks", "npages", "nspages", "nsmaps", "cnblocks", "mplanes", "cnpages", "nblocks", "onblocks", "numplanes", "nbplanes", " nlines", "nblines", " npages", "cnmaps", " nanes", "unblocks", "unpages", "nsframes", "nnframes", "numpages", "nmaps", "unplanes", "nnplanes", "unmaps", " nframes"], "stride": ["strides", "drope", "glides", "strage", "shrage", "drage", "shrides", "glope", "shrope", "dride", "glage", "glide", "shride", "drides", "strope"], "y": ["n", "yy", "t", "py", "hy", "m", "key", "cy", "iy", "ey", "ny", "vy", "xy", "j", "z", "col", "height", "dy", "sy", "Y", "ch", "ym", "gy", "b"], "x": ["n", "dx", "xi", "f", "m", "ix", "ox", "yx", "max", "xy", "X", "rx", "xp", "z", "wx", "height", "ex", "px", "xs", "l", "xc"], "bytes_per_scanline": ["bytes_per_checkblock", "bytes_per_Scanline", "bytes_per_readcell", "bytes_per_readline", "bytes_per_scanblock", "bytes_per_scanlines", "bytes_per_checklines", "bytes_per_Scanlines", "bytes_per_checkLine", "bytes_per_readLine", "bytes_per_Scanblock", "bytes_per_scancell", "bytes_per_checkline", "bytes_per_ScanLine", "bytes_per_scanLine", "bytes_per_Scancell"], "ptr": ["cap", "rc", "alloc", "desc", "ref", "progress", "src", "copy", "cur", "tr", "cmp", "fp", "pen", "ctx", "br", "tmp", "map", "buffer", "addr", "dr", "buff", "np", "cmd", "pointer", "pad", "pointers", "cp", "ctr", "attr"], "bufstart": [" bufoffset", "bufstop", "blockoffset", "bufferstart", "blockend", "bufoffset", "bufferend", " bufend", "bufferstop", "bufend", "blockstart", " bufstop", "bufferoffset", "blockstop"], "scanline": ["rowLine", " scanLine", " scanlines", "readline", "rowline", "readLine", "scanlines", "scanLine", "rowlines", "readlines"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "substitutes": {"list": ["n", "name", "p", "all", "is", "out", "print", "set", "single", "listed", "pair", "top", "pl", "x", "def", "level", "info", "flat", "LIST", "st", "s", "lt", "xml", "batch", "base", "word", "spec", "other", "map", "lists", "ist", "from", "List", "l", "v", "flag", "local", "lat", "L"], "qdict": ["qtable", " qmap", "qqtree", "qqdict", "sqword", "qdata", "qqword", "qualdata", "sqlist", "sqtree", "sqmap", "sqdata", "qcompl", "qdb", "qmap", "qtree", "quallist", "qqpath", "qualdict", "qword", "sqtable", " qlist", "qqdb", "sqdict", "qqcompl", "querytable", "querypath", "eqdict", "eqdb", "sqdb", "qqtable", " qdata", "eqcompl", "sqcompl", "querydict", "sqpath", "qlist", "qpath", "qualmap", "queryword", "eqtree"], "opts": ["opms", "OPrs", "ioppt", "opcs", "prpt", "optcs", "pts", "optts", " optte", "optps", " oputs", " opte", "ps", "pt", "ops", " optts", " opcs", " oprs", " opms", "optt", "optgs", "OPs", "oputs", "opgs", "opte", "opps", " ops", "OPps", "optuts", "oprs", "OPts", "prts", "iopcs", "iopte", "optrs", "opt", "oppt", "prcs", " opt", "iopts", "iops", "OPuts", "ioputs", "iopms", " optpt", "pcs", "OPgs", "iopgs", " opps", "prms", " oppt"]}}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816, "substitutes": {"ch": ["comm", "sch", "cho", "com", "ht", "mot", "chn", "ck", "chrom", "zh", "vc", "cont", "cb", "ach", "CH", "wh", "chan", "ich", "h", "y", "ched", "ct", "th", "serv", "cs", "i", "conn", "tch", "c", "cl", "cur", "arch", "cht", "j", "hw", "z", "ih", "ctx", "och", "k", "q", "Ch", "cand", "sh", "kh", "kr", "sw", "hl", "sky", "cm", "sc", "qu", "ow", "range", "chron", "cmd", "form", "chy", "gh", "ech", "cp", "ctr", "channel"], "current": ["aj", "history", "parent", "t", "state", "present", "p", "general", "context", "this", "cont", "choice", "ach", "set", "Current", "h", "value", "currently", "root", "m", "i", "on", "target", "c", "initial", "local", "cur", "content", "selected", "result", "bo", "ctx", "now", "ex", "self", "we", "active", "new", "config", "range", "command", "cmd", "remote", "next", "client", "v", "reported", "primary", "serv"], "br": ["bf", "bolt", "r", "bsp", "ber", "stat", "bra", "bal", "Br", "rel", "bl", "bs", "bus", "bridge", "bc", "bro", "str", "bn", "tr", "batch", "j", "bre", "fr", "buf", "hr", "bo", "bm", "bh", "brace", "jump", "pr", "bg", "rid", "dr", "sp", "prefix", "BR", "bt", "cmd", "block", "bol", "next", "browser", "b", "bp", "anch", "ctr", "chain", "serv"], "sel_mask": ["sel_map", "sel_ask", "sel5ask", "sel___mk", "el_lock", "sel_key", "el_map", "sel5mask", "sel_window", "sel67window", "sel5value", "sel___ask", "sl_ask", "sel_mk", "sell_mask", "sell67map", "sl_value", "sl_mask", "sel67set", "seltlock", "seltmagic", "selMask", "selMmap", "sell_set", "sel___mask", "sel67mask", "sel_lock", "sel_magic", "selMmask", "sel_set", "el_ask", "sell67mask", "sell_window", "selMmk", "sell67set", "seltmask", "el_key", "el_mk", "sel___map", "sel67map", "sl_lock", "sell67window", "el_mask", "sell_map", "el_magic", "sel5lock", "seltkey"], "sel_value": ["sel_map", "sel___position", "selvalfield", "sel_result", "el_value", "selvalresult", "el_result", "selvalval", "el_field", "sel___value", "sel_index", "el_position", "sel10widget", "sel10map", "sel_position", "el_index", "sel10value", "el_val", "sell_val", "sel___index", "sel10val", "selvalvalue", "sell_value", "sel___val", "sell_widget", "sell_map", "sel_val", "sel_field", "sel_widget"], "status": ["resp", "flags", "state", "vis", "msg", "sel", "uses", "sym", "comment", "index", "stat", "sex", "check", "STAT", "summary", "score", "progress", "rel", "currently", "stats", "code", "str", "info", "st", "pres", "compl", "flag", "result", "version", "spec", "details", "ex", "ssl", "sw", "res", "active", "sc", "sp", "chron", "priority", "Status", "atus", "sol", "ser", "sb", "success", "syn", "serv"], "cond": ["fun", "resp", "mat", "state", "ond", "respond", "cont", "red", "func", "rupt", "sec", "check", "pred", "Cond", "condition", "act", "ct", "bool", " condition", "con", "def", "bc", "ind", "pri", "or", "bit", "pres", "cmp", "compl", "lock", "wx", "cod", "bo", "bind", " Cond", "ex", "bound", "zero", "req", "cmd", "conf", "hold", "crit", "pos", "stick", "comp", "Condition"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n\n                               Jpeg2000Component *comp,\n\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j;\n\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n\n        int *src = t1->data[j];\n\n        if (band->i_stepsize == 16384) {\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = src[i] / 2;\n\n        } else {\n\n            // This should be VERY uncommon\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;\n\n        }\n\n    }\n\n}\n", "idx": 23854, "substitutes": {"x": ["ij", "t", "p", "xx", "dx", "r", "xt", "index", " xx", "xi", "m", "ix", "h", "ox", "e", "on", "tx", "c", "xy", "step", "rx", "X", "z", "height", "q", "ex", "px", "at", "in", "xs", "g", "l", "v", "w"], "y": ["t", "yy", "p", "axy", "py", "ery", "hy", "ys", "h", "m", "cy", "iy", "ey", "wy", "ny", "my", "vy", "xy", "asy", "uy", "z", "height", "dy", "yt", "sy", "oy", "sky", "iny", "Y", "ies", "ch", "ym", "gy", "ry", "b", "ye", "v", "yi"], "cblk": ["rblank", "cblak", "acblak", "cablk", "cBlak", "cdlk", "Cblkin", "ctbleke", "acBLak", "Cblck", " cplunk", "rblck", "cablkin", "cBLak", "cdlank", "cablck", "cBLck", "acblck", "cbleke", "ctbleck", "cdlck", "cplk", "cblank", "rblak", "acblk", "cplak", "ctblk", "cbrke", "cbcak", "cBlck", "cbck", "cablak", " cplak", "cBLkin", "Cblk", "acBLck", " cplk", "CBLak", "ctblke", "ctblck", "rplank", "cplank", "cplunk", "cplck", "rblk", "cbrk", "cbleak", "ctbleak", " cblak", "cbcck", "rplck", "cBlk", "rplak", "cbleck", " cblck", "acBLk", "cbrck", " cplck", "ctblak", "cBLk", "cblek", "cblkin", "CBLkin", "Cblak", "cdlak", " cblunk", "cblunk", "cbcunk", "CBLck", "cblke", "rplk", "ctblek", "cblck", "CBLk", "cbrak"], "comp": ["comm", "p", "com", "rc", "cont", "app", "sec", "co", "ac", "conv", "etc", "prep", "pro", "prof", "pp", "con", "mp", "sim", "c", "omp", "cmp", "proc", "coord", "compl", "col", "Comp", "prop", "op", "ctx", "cell", "cond", "lc", "component", "sc", "ch", "par", "stack", "rep", "buff", "cmd", "conf", "crit", "mod", "cc", "cp", "lib"], "t1": ["p0", "T1", "T6", " t2", "p1", "tt3", "t6", "t0", " t0", " t6", "t3", "tt2", "tt1", "p2", "T2", "t2", "T3", "tt6", "T0", " t3", "p3"], "band": ["plot", "binary", "bart", "bright", "brand", "dom", "back", "group", "bands", "field", "ack", "filter", "unk", "piece", "bank", "rad", "display", "power", "plug", "bridge", "plugin", "bar", "Band", "bit", "bd", "disk", "library", "beam", "grain", "nob", "word", "product", "burst", "cand", "part", " Band", "stage", "bound", "range", "block", "bin", "amber", "light", "b", "rend", "net", "road", "channel"], "i": ["ij", "bi", "er", "p", "phi", "is", "\u0438", "ic", "it", "ri", "print", "si", "me", "di", "iu", "ai", "io", "xi", "m", "ix", "ims", "init", "multi", "wi", "im", "ie", "zi", "ei", "id", "um", "ind", "sim", "gi", "info", "I", "c", "ami", "qi", "ki", "ini", "ip", "cli", "batch", "status", "ti", "li", "ia", "ui", "oi", "in", "dr", "ci", "try", "iter", "ik", "mi", "remote", "u", "ii", "pi", "l", "v", "b", "uri", "chain", "w"], "j": ["n", "ij", "aj", "jac", "t", "p", "msg", "it", "jit", "o", "jl", "index", "m", "ix", "h", "ax", "ji", "ie", "bj", "sim", "ind", "c", "jp", "z", "fr", "jc", "bo", "k", "jump", "J", "q", "pr", "el", "ja", "js", "ch", "try", "g", "jo", "job", "obj", "uj", "kj", "json", "u", "jj", "b", "v", "l", "dj"], "datap": ["octaps", " datab", "metap", "dataab", "datamap", "Datmap", "dateaps", "dateapa", "metab", "datapa", "DatAP", "octAP", "octap", "datab", "dataaps", "dataap", "datmap", "Dataps", " datapa", "metaps", "dataapa", "dataAP", "Datap", "dateap", "datAP", "dataps", " dataps", "octmap"], "src": ["sys", "view", "rc", "txt", "usc", "usr", "r", "source", "cont", "sec", "scan", "sync", "iv", "image", "url", "loc", "stream", "secure", "dest", "ind", "impl", "rs", "str", "data", "st", "s", "sr", "img", "sn", "tmp", "split", "sc", "stack", "rest", "sq", "sub", "rl", "req", "sur", "inst", "slice", "sb", "ser", "fc", "supp", "lib", "sl"]}}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855, "substitutes": {"s": ["n", "comm", "t", "p", "state", "is", "sa", "os", "ans", "set", "h", "m", "ns", "ss", "ses", "stats", "d", "ps", "bs", "cs", "sts", "i", "fs", "gs", "rs", "e", "c", "ds", "st", "bis", "se", "spec", "ls", "ms", "sam", "sv", "ats", "vs", "hs", "S", "js", "g", "es", "its", "sq", "ts", "sp", "als", "ins", "gets", "qs", "less", "an", "sb", "sl"], "sockaddr": ["sockedptr", "sinkname", "sckadd", "sockshash", "sckaddr", "sixlen", "ysockedptr", "sockptr", "sockorder", "psckaddr", " siporder", "socklen", "sinkaddr", "sockedadd", "psockptr", "sOCKptr", "socksaddress", "siporder", "sckptr", "ysockname", "sOCKaddr", " sockorder", "sockedaddr", "scklen", "sixadd", "sinkptr", "sinkaddress", "socksorder", " sockhash", " sockaddress", "sockhash", "sinkhash", "sixaddr", "psockaddr", " sipaddr", "sockaddress", "psockadd", "psocklen", "sockadd", "psckadd", "ysockedname", "sOCKadd", "sockedname", "socksaddr", "siphash", "sockedlen", "sinklen", "sipaddr", "pscklen", "ysockedaddr", "ysocklen", "sockname", "sipaddress", " siphash", "sixname", "ysockptr", "sixptr", "ysockaddr", "psckptr", "sinkorder", " sipaddress", "ysockedlen"], "len": ["n", "coll", "fn", "en", "vol", "ref", "Len", "h", "length", "err", "mil", "wid", "enc", "val", "loc", "lp", "lan", "il", "lon", "ld", "ds", "size", "lt", "vec", "kl", "bytes", "compl", "buf", "li", "ls", "lic", "seq", "fin", "doc", "mem", "ln", "nl", "pos", "ll", "elt", "lf", "l", "fl", "el", "lib", "L"], "fd": ["fn", "fee", "gd", "fe", "ld", "dt", "cd", "ds", "dig", "hd", "fr", "ff", "fin", " d", " fin", "pos", "elt", "port", "fl", "fun", " dur", "tty", "fm", "ind", "fs", " td", "dl", "handle", "pid", "dra", "fi", "dat", "db", "cf", "ln", "fc", "ffff", "td", "f", "du", "dc", " ff", "sd", "dir", "d", "stream", " f", "fb", "den", "nd", "buf", "ctx", "dy", "ptr", "df", " fid", "fa", "buffer", "l", "FD", "cb", "dd", "window", "fed", "fp", "tif", "ud", " df", "lf", "pd", " fa"]}}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferHEVC  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferHEVC   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH265Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH265MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        // general_profile_space == 0.\n\n        vseq->general_profile_idc = 1; // Main profile (ctx->codec_profile?)\n\n        vseq->general_tier_flag = 0;\n\n\n\n        vseq->general_level_idc = avctx->level * 3;\n\n\n\n        vseq->intra_period = 0;\n\n        vseq->intra_idr_period = 0;\n\n        vseq->ip_period = 0;\n\n\n\n        vseq->pic_width_in_luma_samples  = ctx->aligned_width;\n\n        vseq->pic_height_in_luma_samples = ctx->aligned_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1; // 4:2:0.\n\n        vseq->seq_fields.bits.separate_colour_plane_flag = 0;\n\n        vseq->seq_fields.bits.bit_depth_luma_minus8 = 0; // 8-bit luma.\n\n        vseq->seq_fields.bits.bit_depth_chroma_minus8 = 0; // 8-bit chroma.\n\n        // Other misc flags all zero.\n\n\n\n        // These have to come from the capabilities of the encoder.  We have\n\n        // no way to query it, so just hardcode ones which worked for me...\n\n        // CTB size from 8x8 to 32x32.\n\n        vseq->log2_min_luma_coding_block_size_minus3 = 0;\n\n        vseq->log2_diff_max_min_luma_coding_block_size = 2;\n\n        // Transform size from 4x4 to 32x32.\n\n        vseq->log2_min_transform_block_size_minus2 = 0;\n\n        vseq->log2_diff_max_min_transform_block_size = 3;\n\n        // Full transform hierarchy allowed (2-5).\n\n        vseq->max_transform_hierarchy_depth_inter = 3;\n\n        vseq->max_transform_hierarchy_depth_intra = 3;\n\n\n\n        vseq->vui_parameters_present_flag = 0;\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->vui_num_units_in_tick = avctx->framerate.num;\n\n            vseq->vui_time_scale        = avctx->framerate.den;\n\n        } else {\n\n            vseq->vui_num_units_in_tick = avctx->time_base.num;\n\n            vseq->vui_time_scale        = avctx->time_base.den;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->decoded_curr_pic.picture_id = VA_INVALID_ID;\n\n        vpic->decoded_curr_pic.flags      = VA_PICTURE_HEVC_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->reference_frames); i++) {\n\n            vpic->reference_frames[i].picture_id = VA_INVALID_ID;\n\n            vpic->reference_frames[i].flags      = VA_PICTURE_HEVC_INVALID;\n\n        }\n\n\n\n        vpic->collocated_ref_pic_index = 0xff;\n\n\n\n        vpic->last_picture = 0;\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n\n\n        vpic->diff_cu_qp_delta_depth = 0;\n\n        vpic->pps_cb_qp_offset = 0;\n\n        vpic->pps_cr_qp_offset = 0;\n\n\n\n        // tiles_enabled_flag == 0, so ignore num_tile_(rows|columns)_minus1.\n\n\n\n        vpic->log2_parallel_merge_level_minus2 = 0;\n\n\n\n        // No limit on size.\n\n        vpic->ctu_max_bitsize_allowed = 0;\n\n\n\n        vpic->num_ref_idx_l0_default_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_default_active_minus1 = 0;\n\n\n\n        vpic->slice_pic_parameter_set_id = 0;\n\n\n\n        vpic->pic_fields.bits.screen_content_flag = 0;\n\n        vpic->pic_fields.bits.enable_gpu_weighted_prediction = 0;\n\n\n\n        // Per-CU QP changes are required for non-constant-QP modes.\n\n        vpic->pic_fields.bits.cu_qp_delta_enabled_flag =\n\n            ctx->va_rc_mode != VA_RC_CQP;\n\n    }\n\n\n\n    {\n\n        mseq->video_parameter_set_id = 5;\n\n        mseq->seq_parameter_set_id = 5;\n\n\n\n        mseq->vps_max_layers_minus1 = 0;\n\n        mseq->vps_max_sub_layers_minus1 = 0;\n\n        mseq->vps_temporal_id_nesting_flag = 1;\n\n        mseq->sps_max_sub_layers_minus1 = 0;\n\n        mseq->sps_temporal_id_nesting_flag = 1;\n\n\n\n        for (i = 0; i < 32; i++) {\n\n            mseq->general_profile_compatibility_flag[i] =\n\n                (i == vseq->general_profile_idc);\n\n        }\n\n\n\n        mseq->general_progressive_source_flag    = 1;\n\n        mseq->general_interlaced_source_flag     = 0;\n\n        mseq->general_non_packed_constraint_flag = 0;\n\n        mseq->general_frame_only_constraint_flag = 1;\n\n        mseq->general_inbld_flag = 0;\n\n\n\n        mseq->log2_max_pic_order_cnt_lsb_minus4 = 8;\n\n        mseq->vps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->vps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->vps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->vps_max_latency_increase_plus1[0]   = 0;\n\n        mseq->sps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->sps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->sps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->sps_max_latency_increase_plus1[0]   = 0;\n\n\n\n        mseq->vps_timing_info_present_flag = 1;\n\n        mseq->vps_num_units_in_tick = avctx->time_base.num;\n\n        mseq->vps_time_scale        = avctx->time_base.den;\n\n        mseq->vps_poc_proportional_to_timing_flag = 1;\n\n        mseq->vps_num_ticks_poc_diff_minus1 = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            mseq->conformance_window_flag = 1;\n\n            mseq->conf_win_left_offset   = 0;\n\n            mseq->conf_win_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            mseq->conf_win_top_offset    = 0;\n\n            mseq->conf_win_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            mseq->conformance_window_flag = 0;\n\n        }\n\n\n\n        mseq->num_short_term_ref_pic_sets = 0;\n\n        // STRPSs should ideally be here rather than repeated in each slice.\n\n\n\n        mseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            mseq->aspect_ratio_info_present_flag = 1;\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                mseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                mseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                mseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                mseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (1) {\n\n            // Should this be conditional on some of these being set?\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format = 5; // Unspecified.\n\n            mseq->video_full_range_flag = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            mseq->colour_primaries = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coeffs = avctx->colorspace;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23870, "substitutes": {"avctx": ["devtx", "AVcp", "avcmp", " avfunc", "varhandle", "avercu", "avcontext", "avhw", "navtx", "ravtx", "avjp", "navctx", "vcontext", "varcontext", "AVcmp", "navjp", "averjp", "avcp", "varcmd", "avtx", "Avcontext", "varhw", "navcu", "vcmp", "ravcontext", "averctx", "ravcp", "navfunc", "avercam", "vhandle", "varctx", " avcmp", " avcp", "ravctx", "AVhandle", "navcontext", "avfunc", "Avtx", "vtx", "devhw", "avcam", "vrtx", "AVcontext", "devctx", "avcmd", "AVtx", "Avfunc", "avecu", "Avctx", "avecam", "vartx", "avcu", "avectx", "vrhw", "AVctx", "navcam", " avcontext", "vrcmd", "avejp", "avhandle", "devcmd", " avtx", "vctx", "vrctx"], "ctx": ["kw", "comm", "jac", "mk", "resp", "perm", "ppo", "txt", "org", "context", "ck", "func", "cb", "dc", "abc", "co", "act", "etc", "ct", "pkg", "conv", "loc", "ctrl", "conn", "cu", "bc", "wp", "cv", "tx", "offic", "jp", "cmp", "hw", "xp", "setup", "scl", "wx", "aux", "rt", "grad", "tmp", "aco", "px", "addr", "cf", "xs", "kb", "working", "config", "that", "mc", "prefix", "pb", "req", "cmd", "conf", "tc", "iat", "np", "rpm", "obj", "nc", "cc", "ctl", "phys", "cp", "cfg", "xc", "parents"], "vseq": [" vdesc", "nvprot", "vmstr", "wseq", "yzip", "invserv", "vref", "vstruct", "avseq", " vsyn", "svref", " vzip", "vvstruct", "vmdesc", " vvec", "convpkg", "evzip", "vmsequence", "invbuf", "invsequ", "vevec", "vvseq", "invsequence", "evseq", "svsequ", "nvseq", "convexpr", "gdesc", "avzip", "vvvec", "invfle", "convserv", "gexpr", "yseq", "vmmsg", "varsim", "Vexpr", "vmjob", "varsequ", "gzip", " vstr", "convzip", "wsequence", "gseq", "vvzip", "evsequ", "vyclip", "varseq", "conveval", "gvec", "ysequence", "evdesc", "vysequ", "Vcomp", " veval", "vertest", "vvsequence", "svpkg", "varprot", "vtest", "invseq", " vcomp", "nvsyn", "gsequ", "varref", "varsyn", "invtest", "vervec", " vsequence", "convsequence", "vexpr", "Vmsg", " vpkg", " vmsg", "veeval", "vsim", "vsyn", "convseq", "svvec", "vesequ", "verseq", "Vclip", " vsim", "vmsg", "vsequence", "invzip", "Vzip", "nvsequ", "verpkg", "convtest", "vardesc", "gsequence", " vfle", "ysequ", "invstruct", "vmzip", "vsequ", "wstruct", "invvec", "vezip", "varfle", "avref", " vexpr", "varzip", "vserv", "avsequ", " vclip", " vbuf", "vyseq", "nvzip", "evstruct", "veseq", "vmseq", "wsequ", "invsim", "vfle", " vref", "vclip", " vtest", "vvsequ", "Vsequence", "vvec", " vsequ", "vzip", "vmexpr", "vpkg", "vvpkg", "versim", "avsequence", "gstr", "svzip", "vmsequ", "verzip", "vesim", "Vseq", "gstruct", " vstruct", "veref", "geval", "vprot", "vdesc", "varbuf", "vstr", "nvstruct", "convsequ", "vcomp", "vycomp", "veval", "Veval", " vjob", "vjob", "varjob", " vprot", "avsim", "Vsequ", "vbuf", "vareval", "svseq", " vserv"], "vpic": ["uvpse", "avzip", "avpic", "uvctx", "avpse", "vzip", "uvzip", " vctx", " vpse", "uvpic", "vpse", "vctx", " vzip"], "priv": ["eas", "cap", "rc", "rev", "alloc", "private", "sec", "stat", "pkg", "prof", "riv", "loc", "pro", "conn", "Priv", "pri", "tx", "pres", "cmp", "proc", "pub", "prop", "caps", "pr", "env", "dev", "mem", "Pri", "sp", "pb", "cam", "conf", "soc", "pi", "gov", "phys", "cp", "cfg", "serv"], "mseq": [" msequence", " vsequence", " msequ", " vsequ", "gseq", "msequ", "gsequ", "gsequence", "mvec", "msequence", " mvec", "gvec", " vvec"], "i": ["n", "ij", "p", "t", "it", "a", "r", "o", "io", "m", "y", "im", "x", "id", " ii", "e", "I", "c", "j", "z", "li", "ia", " bi", "in", "ii", "b", "l", "v"]}}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "static void rdft_calc_c(RDFTContext *s, FFTSample *data)\n\n{\n\n    int i, i1, i2;\n\n    FFTComplex ev, od;\n\n    const int n = 1 << s->nbits;\n\n    const float k1 = 0.5;\n\n    const float k2 = 0.5 - s->inverse;\n\n    const FFTSample *tcos = s->tcos;\n\n    const FFTSample *tsin = s->tsin;\n\n\n\n    if (!s->inverse) {\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n    /* i=0 is a special case because of packing, the DC term is real, so we\n\n       are going to throw the N/2 term (also real) in with it. */\n\n    ev.re = data[0];\n\n    data[0] = ev.re+data[1];\n\n    data[1] = ev.re-data[1];\n\n    for (i = 1; i < (n>>2); i++) {\n\n        i1 = 2*i;\n\n        i2 = n-i1;\n\n        /* Separate even and odd FFTs */\n\n        ev.re =  k1*(data[i1  ]+data[i2  ]);\n\n        od.im = -k2*(data[i1  ]-data[i2  ]);\n\n        ev.im =  k1*(data[i1+1]-data[i2+1]);\n\n        od.re =  k2*(data[i1+1]+data[i2+1]);\n\n        /* Apply twiddle factors to the odd FFT and add to the even FFT */\n\n        data[i1  ] =  ev.re + od.re*tcos[i] - od.im*tsin[i];\n\n        data[i1+1] =  ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n        data[i2  ] =  ev.re - od.re*tcos[i] + od.im*tsin[i];\n\n        data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n    }\n\n    data[2*i+1]=s->sign_convention*data[2*i+1];\n\n    if (s->inverse) {\n\n        data[0] *= k1;\n\n        data[1] *= k1;\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n}\n", "idx": 23872, "substitutes": {"s": ["is", "app", "ims", "ops", "sts", "ds", "sv", "sw", "hs", "es", "ins", "als", "ants", "params", "less", "sb", "as", "n", "state", "a", "os", "ns", "conv", "bs", "cs", "e", "fs", "aws", "sim", "se", "sets", "ats", "g", "ts", "sg", "qs", "b", "comm", "t", "sys", "settings", "r", "f", "y", "stats", "ar", "ps", "args", "c", "spec", "ls", "sh", "S", "its", "sp", "conf", "l", "so", "p", "set", "parts", "h", "ss", "ses", "rs", "gs", "styles", "st", "js", "sq", "ains", "w"], "data": ["all", "first", "message", "this", "m", "users", "value", "filter", "rel", "format", "des", "ds", "xy", "no", "video", "res", "map", "component", "Data", "params", "zero", "next", "apps", "v", "members", "file", "chain", "n", "name", "done", "use", "button", "a", "o", "list", "output", "group", "device", "ns", "bus", "x", "e", "results", "empty", "trace", "info", "join", "size", "bytes", "values", "dat", "num", "entry", "dev", "new", "bin", "w", "blocks", "att", "update", "t", "time", "it", "settings", "number", "f", "hash", "aw", "table", "d", "image", "def", "array", "times", "str", "args", "good", "family", "extra", "raw", "position", "ta", "ad", "nt", "range", "cache", "ma", "to", "actions", "route", "save", "errors", "series", "history", "valid", "mat", "p", "final", "set", "off", "rew", "window", "add", "al", "ata", "images", "val", "keys", "code", "test", "query", "step", "content", "result", "version", "DATA", "full", "vals", "help", "error", "date", "block", "clear", "form", "input", "rec", "da", "text"], "i": ["bi", "ij", "n", "p", "phi", "is", "\u0438", "ic", "it", "ri", "si", "me", "di", "index", "iu", "ai", "vi", "xi", "io", "m", "go", "ix", "y", "ims", "ji", "multi", "im", "zi", "ei", "iri", "x", "id", " ii", "ind", "sim", "gi", " ti", "I", "ni", "bis", "ami", "qi", "ki", "ti", "j", "ip", "ini", "cli", "status", "batch", "li", "ite", "ui", " bi", "oi", "iter", "ci", " j", "g", "mi", "u", "source", "ii", "pi", "hi", "v", "chain"], "i1": ["mi81", "I1", "pi3", "pi1", "ui1", "riOne", "ip01", "i01", "piOne", "iri001", "key1", "key001", "uione", "li1", "di81", "iri81", "liOne", "ipOne", "li81", "i81", "mi1", "it15", "ic30", " iOne", "ii1", "li3", " i81", "iione", "li2", "lione", "I3", "li0", "i001", "ic1", "ui15", "pi2", "ip1", "iOne", "iiOne", "pione", "ic15", "key81", "I01", " i0", " i01", "di1", "key01", "di01", "ione", "i0", "I2", " i3", "it1", "mi0", "pi01", " ione", "di001", "pi0", "iri1", "mione", "ri01", "it30", "ipone", "ii01", "ri2", "ui30", "i30", "i3", "itone", "rione", "iri01", "ri1", "icone", "i15", "ri0"], "i2": ["xilo", "pi1", "li02", "u2", "xi42", "litwo", "ri42", "isTwo", "i20", "i5", " i5", "ipTwo", "ilet", "i14", "ip2", "xitwo", "lilo", "islet", "is2", "uitwo", "vi42", "ilo", "vi012", "li42", "mi1", "milo", "is42", "itwo", " i20", "ie1", "ip42", "ui42", "iriTwo", "xi5", "pi20", "li2", "zitwo", " itwo", "mi14", "pi2", "is14", "zi102", "i02", "bi2", "is012", "biTwo", "iriB", "zi2", "xi2", "vito", "u14", "ipB", "iTwo", "ritwo", "bi14", "zi14", "u1", "i42", "uiTwo", "isto", "iri42", "rito", "i012", "ui2", "ie02", "ziTwo", "zilet", "xi02", "iB", "ri012", "mi02", "i102", "ri102", "ri2", " i02", "iri2", "bilet", "ie20", "ui102", "vi2", "ito", "pi02", " i14", "zi42", "uiB", "mi2", "mi42", "li5", "ie2"], "ev": ["ee", "EV", "ele", " estim", "vol", " vel", " sv", " eg", "err", "eval", "eg", "nov", "uv", "ov", "event", "sv", "env", "erg", " v", "rav", "ew", "v", "ed", " EV", "eas", "vd", "eur", "eb", "rev", " vol", "erv", "enc", "e", " ke", " env", " ve", "vs", "adj", " vec", "dev", "Ev", "eng", "lv", " av", "ogg", "vc", "Dev", "ef", "rem", "vr", "ec", "av", "tv", "cod", "ve", " Ev", " dev", " tv", "req", "vision", "el", " rev", "ok", "er", "ver", " devs", "ek", "ob", "iv", " ov", "ell", "ent", "vo", "ep", "rec", "nv", " eve", "eve", "eff"], "od": ["ed", "td", "ok", "vd", "ost", "ard", "odic", "ond", "o", "dd", "ods", "oly", "off", "oh", "co", "ox", "sd", "ob", "d", "ot", "ld", "az", "cd", "or", "oad", "node", "good", "md", "ell", "hd", "ast", "rod", "ord", "pod", "nd", "cod", "yt", "ent", "edd", "ov", "ood", "idd", "odi", "oy", "OD", "ow", "dev", "yd", "ud", "ad", "ded", "and", "ick", "ode", "amd", "obj", "mod", "lad", "rec", "odd"], "tcos": ["tcus", "trices", "tscus", "rcoins", "tycons", "mmas", "tscin", " tdos", "mdos", "ndos", "tscos", " tcin", " tcons", "tcas", "Tkos", "rcus", "maccin", "mackos", "tmas", "dtcoins", " tcas", "ncos", "tycin", "Tcus", "maccos", "pcos", "pcus", "Tcos", "macrices", "tscons", " tcoins", "rrices", "tkos", " tmas", "dtrices", " tcus", "maccus", "mcus", "nmas", "tycas", "tsrices", "rkos", "prices", "tcoins", "pcin", "tcin", "dtcus", "mcos", "rcos", "tscas", "maccons", "tdos", "dtcos", "Tcin", "tycos", "rcin", " trices", "tcons", "ncus"], "tsin": ["tsinc", "timesin", "stsn", "etsar", "ttinn", "tersin", "stsin", "thsinn", "thsar", "atsine", "tscin", "omsinc", "tesis", "tisinn", "omsine", "thsinc", "fsin", "stsins", "csin", "tersine", "watersine", "tsar", "watersin", "atsin", "fsine", "thsn", "thscin", "tesoin", "atsinn", "stsine", "watersoin", "tersinn", "etsin", "atsins", "tisinc", "timesis", "omsin", "csn", "tsins", "csoin", "tesout", "tisins", "ttinc", "typesis", "tsn", "tersar", "typesin", "tisin", "tesin", "atscin", "tsine", "ttin", "atsinc", "tsout", "fsoin", "timesoin", "stsoin", "thsin", "tsinn", "tsoin", "typesoin", "ttins", "thsins", "omscin", "etsinn", "thsine", "timesout", "thsoin", "typesout", "tsis", "etsine", "fsins", "watersins", "csins"]}}
{"project": "FFmpeg", "commit_id": "aca490777f9da2a71b537874ed4e16105bb3df02", "target": 0, "func": "static av_cold int g726_init(AVCodecContext * avctx)\n\n{\n\n    AVG726Context* c = (AVG726Context*)avctx->priv_data;\n\n    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;\n\n\n\n    if (\n\n        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&\n\n         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n    if(index>3){\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of bits %d\\n\", index+2);\n\n        return -1;\n\n    }\n\n    g726_reset(&c->c, index);\n\n    c->code_size = c->c.tbls->bits;\n\n    c->bit_buffer = 0;\n\n    c->bits_left = 0;\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23877, "substitutes": {"avctx": ["wavkt", "ivermk", " avcmd", "awdyl", "averkl", "avehistory", "avertx", "avecfg", "avecmp", "abtx", "avcp", "wavcfg", "avkw", " avcmp", "afcontext", "ajkw", "avecp", "afctx", "awjac", "avanctx", "ajcmd", "awctx", " avreq", "afcp", " weavemk", "ivertx", "wavjp", "wavcmp", "avercfg", "ajmk", "avantx", "wavtx", "afrh", "avanpx", "aitcmp", "avercmd", "avcmp", "avekt", "camcmp", "iverkt", "avekl", "avjp", "avercontext", "averkt", "afpkg", " avpx", "avesys", "ajtx", "aversys", "averctx", " avsys", "avercp", "aveca", "aitctx", "iverdyl", "avercmp", "aitcp", "iverjac", " avtxt", "avecmd", "avecu", "avcu", "averaddr", "ajdj", "vertx", " avcontext", " avtx", "averca", "aftxt", "wavhistory", "camctx", "avercu", "aftx", "abkl", "afconn", "avepkg", "afhistory", "avpx", " avkt", "avtx", "avtxt", "afaddr", " weavectx", "avetx", "avecontext", "avejac", "avjac", "averpkg", " avca", "ajdyl", "avkt", "avdj", "ajca", "avca", "camcontext", "abctx", "afca", "ivercontext", "iverctx", "iverrh", "ajjac", "ajpx", "avreq", "vercontext", "ivercfg", "avmk", "avconn", "camcp", "wavctx", "awcfg", "avaddr", " avconn", "averkw", "avhistory", "aitcontext", "avcontext", " avcu", " avpkg", " weavecmd", "ajjp", "avkl", "avanreq", "ivercmd", "afkl", "iverdj", "wavpkg", " avaddr", " avcp", "avsys", "ajkl", "wavjac", "ajcfg", "averhistory", "avpkg", "iverkw", " avkl", "avcmd", "abpkg", "ajreq", "ajctx", "ajkt", "verrh", "verctx", " weavedj", "avectx", "avcfg", "avrh", "avetxt", "averconn", "avejp", "avdyl"], "c": ["n", "p", "t", "com", "rc", "ic", "a", "r", "cb", "cn", "ce", "cont", "f", "dc", "m", "h", "abc", "ac", "co", "gc", "ct", "d", "etc", "toc", "unc", "con", "cs", "e", "cu", "ctrl", "bc", "cv", "i", "ec", "cur", "z", "C", "ctx", "chain", "k", "cpp", "cor", "lib", "lc", "cm", "cf", "ch", "g", "ci", "mc", "pc", "cam", "tc", "u", "cache", "conf", "nc", "cc", "ca", "v", "b", "l", "cp", "fc", "xc", "w"]}}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "substitutes": {"addr": ["mk", "rc", "rn", "alloc", "gate", "ack", "ref", "off", "add", "init", "act", "pkg", "src", "ash", "inter", "loc", "asm", "aux", "ptr", "align", "seek", "env", "hl", "help", "at", "mem", "adr", "Address", "amp", "np", "address", "cmd", "obj", "pos", "work", "store", "pointer", "pad", "point"], "size": ["message", "amount", "sum", "length", "value", "fee", "format", "count", "needed", "space", "timeout", "sn", "sized", "sw", "prime", "term", "zero", "pos", "sample", "small", "sent", "padding", "type", "n", "name", "done", "start", "si", "e", "empty", "body", "expected", "status", "send", "num", "scroll", "new", "g", "scope", "time", "number", "sym", "score", "scale", "style", "weight", "args", "max", "s", "limit", "z", "height", "ptr", "ize", "gravity", "sh", "storage", "shape", "sp", "cache", "len", "perm", "capacity", "set", "index", "SIZE", "member", "notice", "code", "step", "result", "shift", "south", "speed", "Size", "error", "address", "news"], "offset": ["time", "end", "start", "o", "amount", "index", "Offset", "set", "ref", "off", "sum", "length", "attribute", "SIZE", "window", "count", "top", "needed", "url", "loc", "style", "id", "optional", "mask", "before", "bool", "timeout", "attr", "row", "slot", "reset", "expected", "result", "shift", "op", "extra", "ptr", "align", "seek", "position", "initialized", "location", "scroll", "error", "sp", "range", "prefix", "zero", "address", "pos", "next", "pointer", "slice", "pad", "flag", "origin", "point", "padding", "type"], "p": ["perm", "t", "ping", "f", "m", "tp", "pkg", "post", "d", "ps", "pl", "pp", "lp", "pro", "mp", "wp", "cp", "c", "pa", "pers", "jp", "ap", "proc", "pid", "ip", "fp", "ctx", "ptr", "P", "q", "ph", "part", "g", "sp", "pb", "pc", "np", "pos", "pre", "pi", "bp", "v", "pad", "vp", "point"], "tmp": [" cached", "msg", "ret", " ignored", "cont", "m", "tar", "err", "loc", "uf", "mp", " mp", "timeout", "crop", "xy", " leftover", " temp", "temp", "jp", "uv", "prime", " pad", "__", "term", "tc", "pos", "elt", "v", "resp", "orig", " sp", "copy", "cmp", "op", "stuff", " prev", " amp", "cp", "t", "tn", "pkg", "inter", " t", "var", "snap", "buf", "ctx", "ptr", " _", "nt", "sp", "buff", " tid", "np", "obj", "cache", "slice", "vp", "attr", "vt", " ptr", "perm", "mk", "tt", "out", " ref", "txt", " dst", "tp", "etc", "src", "nom", " np", " pts", "test", "emp", "j", "result", " ind", "img", "opp", "rt", "sam", "unit", "rm", "amp"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895, "substitutes": {"v": ["p", "t", "vis", "view", "vc", "ver", "r", "vi", "f", "m", "h", "conv", "inv", "d", "vr", "call", "x", "e", "i", "vm", "cv", "c", "av", "j", "tv", "z", "uv", "ov", "q", "ve", "sv", "env", "vs", "vt", "g", "verb", "vv", "u", "b", "l", "V", "vp", "lv", "ev", "w"], "errp": ["errps", "erp", "rrpre", "errm", "errP", "fxpa", "errpa", "errr", "rrpc", "err", " errP", " errpc", "errorps", "rrP", "errpad", " errpa", "errpc", "erps", "erm", "rrr", "fxps", "fxpad", " errps", " errpad", "errorpa", " errr", "rrm", "rrps", "errorp", " errpre", "errorP", "fxp", "rrp", "errorpre", "errorpad", "errorpc", " errm", "errpre"]}}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899, "substitutes": {"client": ["master", "core", "Client", "p", "app", "ce", "force", "connect", "qualified", "check", "collection", "window", "api", "co", "google", "call", "con", "plugin", "current", "code", "conn", "contact", "row", "close", "c", "admin", "controller", "cl", "cur", "cli", "public", "application", "connection", "pattern", "friend", "lock", "cod", "cell", "manager", "web", "server", "entry", "open", "component", "self", "at", "patch", "template", "ad", "http", "common", "config", "nt", "prefix", "util", "pc", "req", "cmd", "remote", "cache", "form", "ace", "store", "obj", "local", "lib", "net", "chain", "channel"], "fatal": ["fortattery", "ofattery", "refatal", "failed", "ferential", "cfailed", "ofatal", "refalf", "affalf", "fattery", "fortault", "fortailed", "cfalf", "cferential", "ofailed", "cfattery", "affating", "afferential", "cfault", "refating", "ofault", "fault", "fating", "referential", "cfating", "falf", "fortatal", "affatal", "cfatal"], "errp": ["errps", "erp", "derp", "errP", "errm", "errpa", "derpe", "errorm", " errP", "errorps", "rrlp", "derP", "rrP", "errorpe", " errpa", "Erpa", "errpe", "rarvp", "errpb", "diepb", " errpb", "Erpb", "derps", "erm", "errvp", "Erp", " errps", " errpe", "rarP", "erP", "errorp", " errlp", "errorP", " errvp", "diep", "rrp", "rarlp", "diepa", "rrvp", " errm", "errlp", "rarp"], "ret": ["gt", "cert", " Ret", "resp", "t", "re", "out", "lit", "rev", "backed", "print", "det", "r", "cont", "cat", "back", "ref", "rets", "rem", "Ret", "val", "mb", "arr", "arg", "def", "ext", "ter", "pret", "str", "reset", "sat", "get", "tr", "status", "mt", "result", "rt", "tmp", "res", "alt", "addr", "reg", "mem", "nt", "RET", "len", "ll", "elt", "pat", "att", "flag", "pas"]}}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912, "substitutes": {"node_path": ["nodeNamealias", "ode_path", "node_stat", "nodeNamepath", "odeNamename", "sourceletprop", "nodeptname", "odeNamepath", "node_alias", " node_stat", "node___Path", "nodeptalias", "nodeletname", "nodeNamename", "source_path", "node___path", "node___name", " node_name", "node___stat", "sourceletname", "source_prop", "node_prop", "node_log", "ode_alias", "nodeletroute", "source_route", "nodeptlog", "nodeptpath", "ode_name", "sourceletroute", "node_Path", "ode_log", " node_Path", "odeNamealias", "nodeNamelog", "nodeletpath", "sourceletpath", "source_name", "node_name", "nodeletprop", "odeNamelog", "node_route"], "prop": ["property", "name", "p", "com", "msg", "lit", "tag", "kind", "sec", "desc", "pred", "rel", "etc", "pkg", "pro", "key", "ps", "label", "def", "pri", "str", "test", "proc", "pid", "cfg", "col", "op", "Prop", "ctx", "pr", "feat", "priv", "term", "typ", "cmd", "conf", "obj", " props", "attr"], "val": ["name", "valid", "p", "msg", "out", "sel", "r", "vol", "stat", "ref", "value", "err", "al", "item", "eval", "serv", "pt", "loc", "arg", "def", "str", "tx", "data", "Val", "buf", "ctx", "pal", "values", "pr", "res", "VAL", "vals", "reg", "mem", "als", "obj", "v", "vt"], "len": ["n", "fun", "fn", "resp", "lif", "en", " length", "t", "end", "lit", "p", " clen", "L", "bf", "ref", "del", "Len", "length", " l", "err", "ob", "gz", "wid", "pl", "loc", "lp", "arg", "elta", "lan", "ld", "lon", "str", "var", "size", "dl", "vec", "ell", "cmp", "ann", "lim", "compl", "repl", " bl", "ls", " Len", "seq", "mem", "ln", "au", "nt", "bin", "nl", "lis", "ll", "lf", "elt", "l", "fl", "el", "lib", "syn", "type"], "path": ["cert", "m", "length", "format", "th", "pt", "loc", "node", "host", "Path", "col", "ath", "pointer", "port", "file", "local", "chain", "n", "name", "context", "list", "stat", "root", "x", "ind", "empty", "data", "pid", "base", "pr", "mem", "inner", "anc", "prefix", "pc", "cmd", "w", "cp", "parent", "t", "zip", "ref", "walk", "dir", "pkg", "pro", "url", "str", "mount", "c", "binding", "PATH", "ctx", "raw", "spec", "patch", "nt", "config", "l", "route", "history", "p", "en", "out", "index", "h", "transform", "win", "key", "pl", "id", "conn", "pattern", "lock", "full", "priv", "json", "text"], "f": ["fn", "p", "t", "a", "bf", "r", "o", "raf", "h", "ef", "sf", "alf", "ac", "fo", "d", "fe", "fac", "uf", "fm", "e", "fs", "c", "fb", "j", "elf", "fp", "fr", "z", "ff", "far", "full", "df", "fi", "open", "fa", "rf", "buffer", "cf", "g", "fd", "fl", "u", "form", "F", "af", "lf", "fab", "b", "fc", "v", "file", "l", "tf", "w"], "ret": ["gt", " Ret", "resp", "t", "re", " RET", "out", "lit", "en", "usr", "ort", "rev", "print", "cat", "cont", "set", "desc", "del", "rets", "Return", "rem", "err", "summary", "Ret", "Len", "tail", "ruby", "mb", "nz", "arg", "def", "ter", "dt", "ext", "rs", "str", "lt", "tr", "status", "result", "mt", "deg", "ft", "rt", "res", "alt", "num", "fin", "mem", "try", "nt", "RET", "cmd", "ll", "not", "elt", "ry", "att", "l", "flag", "lib", "net", "pas"], "pathlen": ["PATHlength", "PATHLen", "lengthlen", "PATHlen", "Pathlength", "PathLen", "Pathen", " pathLen", "athlen", "athstr", "Pathln", "pathlength", " pathln", "pathld", "pathstr", "Pathld", "athlength", "pathLen", "Pathstr", "athLen", "Pathlen", "athld", "PATHstr", " pathld", "lengthLen", "athln", "lengthen", "pathln", "lengthlength", " pathlength", " pathen", "pathen"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 23916, "substitutes": {"s": ["n", "comm", "t", "p", "is", "out", "sys", "state", "a", "r", "os", "o", "set", "source", "m", "h", "ns", "ss", "y", "ims", "ses", "ix", "us", "stats", "d", "x", "e", "sts", "socket", "rs", "gs", "cs", "i", "c", "ds", "j", "z", "sm", "ctx", "spec", "ls", "q", "ex", "ssl", "sv", "sw", "self", "S", "js", "in", "g", "es", "ts", "sg", "qs", "sb", "an", "b", "as", "v", "w"], "data": ["name", "ret", "a", "r", "o", "m", "device", "window", "rel", "d", "ata", "image", "x", "id", "bus", "def", "str", "tx", "mu", "size", "ds", "no", "ip", "ctx", "ptr", "DATA", "dat", " mem", "map", "reg", "mem", "ad", "dr", "Data", "address", "obj", "cache", "rec", "pointer", "da", "w"], "addr": ["n", " address", "rc", "start", "a", "r", "ref", "m", "offset", "add", "ac", "err", "act", "src", "ata", "url", "loc", "x", "id", "tx", "oa", "ip", "hw", "coord", "ord", "mt", "ctx", "ptr", "align", "ag", "link", "res", "map", " ip", "adr", "at", "mem", "ad", "dr", "Address", "error", "amp", "address", "obj", "nl", "pos", "pad", "v", "attr", "alias"], "oi": ["ori", "ovi", "ok", "ano", "phi", " mic", "opa", "ilo", "oid", "o", "si", "cb", "eni", "xi", "obi", "offset", "ati", "ei", "iri", "ois", " ii", "i", " ov", "xy", "oa", "bis", "ami", " iso", "ti", "ini", "eta", "ip", "uti", "asi", "fp", "ctx", "imei", "ui", "eric", "odi", "rio", "obo", "tmp", " bi", "osi", " os", "ta", "mx", "ico", " tid", "mi", "typ", "udi", "mic", "obj", "iso", "pointer", "oin", "pi", " ki", "hi", "attr", "oc"], "is_64": ["isU5", "isU64", "isi_864", " is_32", "is_5", "isU48", "is_48", " is_48", "isi_148", "is_32", "is_864", "is_148", " is_5", "isi_64", "isU32"], "addrz": ["urlzh", "ptryz", " addrzh", "locze", " addryz", "addrld", "clonez", " addresszi", "ptrze", "addrzo", "acej", "clonezo", " addrzi", "acezi", "locyz", "addrj", " addressz", "addryz", " addrld", "ptrz", "locld", "addrzi", "locz", "clonezh", "urlz", "ptrld", "acez", " addressj", " addrze", "urlzo", "addrzh", " addrzo", "addrze", " addrj"], "param": ["perm", "name", "p", "pas", "tag", "prom", "meter", "sym", "comment", "index", "mm", "arm", "ref", "field", "imm", "m", "value", "member", "offset", "Param", "attribute", "rank", "init", "im", "fac", "arg", "label", "weight", "um", "pri", "row", "dim", "admin", "var", "proc", "coord", "pid", "col", "prop", "ctx", "cpu", "tmp", "num", "position", "min", "part", "mem", "par", "error", "common", "command", "params", "aram", "cal", "pos", "mod", "pai", "pointer", "pi", "cp", "attr"], "func": ["fn", "fun", "expr", "kw", "rc", "must", "access", "FUN", "lambda", "cb", "wrapper", "callback", "f", "exec", "conv", "method", "act", "val", "unc", "call", "fac", "package", "con", "fw", "args", "var", "imp", "proc", "mac", "result", "aux", "function", "ctx", "cond", "lc", "cf", "fd", "util", "cmd", "amd", "Function", "cc", "comp", "cast", "fc", "attr"], "label_ptr": ["label_obj", "label_addr", "lab_pointer", " label_addr", "label2addr", "label2Ptr", "label2ptr", "label_pointer", "lab_ptr", "lab_Ptr", " label_obj", "lab_addr", "label2pointer", " label_pointer", "label_Ptr"]}}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n", "idx": 23918, "substitutes": {}}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23922, "substitutes": {"s": ["ports", "search", "is", "source", "m", "ims", "ops", "sts", "ds", "details", "sv", "sw", "hs", "es", "ins", "als", "params", "less", "sb", "as", "v", "n", "state", "a", "os", "changes", "ns", "bs", "cs", "i", "fs", "aws", "states", "se", "vs", "ats", "self", "properties", "bes", "g", "has", "ts", "mods", "qs", "b", "comm", "t", "sys", "settings", "sa", "r", "f", "sd", "stats", "ps", "services", "args", "c", "spec", "ls", "S", "rest", "its", "conf", "store", "l", "so", "save", "serv", "p", "set", "parts", "h", "ss", "us", "ses", "https", "sports", "rs", "gs", "j", "sam", "ms", "js", "http", "sq", "tests", "an", "w"], "dev": ["cho", "app", "desc", "dn", "eth", "des", "host", "md", "ds", "hd", "pub", "sw", "env", "v", "ev", "n", "name", "device", "api", "enc", "data", "handle", " device", "db", "de", "mem", "g", "usb", "wd", "cam", "cmd", "remote", "att", "eng", "hid", "t", "sys", "Dev", "del", "dis", "sd", "d", "def", "den", "av", "hw", "DEV", "buf", "raw", "spec", "ptr", "ve", "ad", "adv", "nt", "req", "conf", "obj", "er", "p", "dh", "end", "ver", "det", "dd", "di", "h", "go", "window", "iv", "val", "conn", "test", "dem", "addr", "priv", "js", "doc", "vo", "pad", "w"], "udev": ["udele", "uuver", "uderv", "uidver", "udoc", "udiv", "udend", "uidele", "urdev", "uuef", "uidov", "duev", "uidel", "uuev", "udew", "ddev", "ubev", "ubove", "audv", "ubov", "udv", "uidend", "udove", "auddev", "ddv", "ddoc", "ubend", "uuew", "uiderv", "vddev", "ubiv", "uberv", "uboc", "urdv", "dudev", "uidef", "udel", "duend", "uidew", "udver", "ddele", "vdv", "vdiv", "audele", "urdiv", "ubef", "uuov", "ubdev", "uidev", "dddev", "uuv", "uiddev", "uudev", "ubel", "ddef", "uidoc", "duel", "uddev", "ddove", "audev", "uuerv", "udef", "vdev", "uidv", "urddev", "uidiv", "uuove", "ubew", "ddver", "ubv", "udov"], "rc": ["ok", "coll", "asc", "isc", "rn", "ck", "func", "cont", "ce", "ack", "auc", "abc", "co", "ac", "sync", "act", "gc", "rin", "init", "src", "irc", "rr", "con", "ro", "cs", "bc", "code", "rs", "cv", "RC", "uc", "c", "ko", "row", "ec", "rx", "cur", "cmp", "rys", "clus", "cod", "rt", "arc", "cor", "roc", "initialized", "auth", "lc", "sc", "inc", "anc", "rl", "pc", "cr", "tc", "rec", "nc", "cc", "ry", "fc", "success", "ctr", "oc"]}}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924, "substitutes": {"new_size": [" new_Size", "next_size", "new_form", " new_user", "New_Size", "new_scale", "New_size", " new_SIZE", "newingsum", " new_form", "new_SIZE", "next_cache", "new_storage", "new23user", "new_Size", "new23size", "new_container", " new_container", "newjsize", "next_name", " new_storage", "newjcontainer", "new23length", "newingSIZE", " new_length", "newingsize", "new_name", "new_user", "New_scale", "new_length", "New_sum", "new_page", "new_sum", "New_page", "newingdump", "next_Size", "newjSIZE", "new_dump", "New_dump", "New_SIZE", "new23storage"], "errp": ["warnpc", "rrpre", "errpkg", "errP", "warnp", "arrpre", "arrpkg", "orderpa", "errpa", "orderpe", "arrpress", "nerpre", "errpress", "nerpolicy", " errP", " errpc", "orderp", "lrp", "lrpre", "arrp", "errorpe", "warnP", "errpolicy", " errpa", "privp", "errpc", "privpre", "errpe", "errpb", "irp", "lrpkg", "nerpb", "orderP", "privpkg", "errorpa", " errpe", "errorp", "rrpb", "privpress", "errorP", "warnpa", "rrpolicy", "rrp", "irpb", "irpolicy", "errorpc", "lrpress", "nerp", "irpre", "errpre"], "new_cache": ["newjbinary", "next_code", "ewJsuccess", " new_c", "new_binary", "newTheCache", "newJCache", "next_cache", "new_c", "ew_success", "ewJsize", "next_cas", "ewJcache", "new____cache", "new_spec", " new_cas", "ew_Cache", "newJcache", "newThecache", "newjCache", "ewJCache", "new_code", "newptcache", "new____Cache", "new____cas", "newptcas", "newJsize", "new_Cache", "newptcode", " new_spec", "newThec", "newjcache", "newptc", "new____binary", "ew_size", "newJsuccess", "new_success", "newjcas", " new_binary", "new_cas", " new_Cache", "next_c", "newThespec", "ew_cache"], "ret": ["gt", " Ret", "resp", "rez", "re", "t", "out", "final", "rev", "it", "print", "cont", "xt", "ref", "back", "rets", "Return", "rem", "progress", "Ret", "rel", "gc", "val", "inter", "nz", "arg", "def", "ext", "uf", "str", "reset", "lt", "tr", "status", "mt", "result", "ft", "rt", "res", "alt", "opt", "rm", "fin", "dr", "try", "new", "nt", "mem", "RET", "nl", "len", "ne", "elt", "l", "flag"]}}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933, "substitutes": {"sig": ["insign", "isig", "nsigs", "psigma", "insigs", "psamp", "insag", "psix", "isign", "msigma", " samp", "psigs", "insig", "sag", " sigma", "psign", "six", "Sign", "ssig", "isix", "vsig", "msamp", "psig", "tsig", "ssigma", "msig", "vsign", "Sig", "Sigs", "Sag", "nsig", "samp", "sigs", " sigen", "tsigen", "tsigma", "nsag", "nsign", "isigs", " sigs", "sigen", "msigs", "sigma", "ssigen", "vsigs", "vsix", "sign"], "ka": ["kw", "kt", "ck", "sa", "ks", "ica", "km", "ski", "kan", "KA", "unk", "kat", "sk", "aka", "Ka", "ker", "ha", "ket", "ama", "tk", "kas", "ko", "gha", "ku", "KO", "ki", "kl", "ema", "kit", "ctx", "k", "ke", "kr", "ja", "ta", "cki", "ak", "arma", "kj", "ken", "ca"], "info": ["isu", "ok", "Info", "is", "txt", "it", "si", "os", "stat", "desc", "INFO", "f", "check", "fo", "init", "prof", "loc", "def", "user", "ext", "conn", "data", "meta", "ami", "ki", "ti", " inf", "aux", "ctx", "now", "ui", "fi", "inf", "auth", "recent", "priv", "ta", "mem", "doc", "jo", "in", "ist", "information", "conf", "json", " fi", "metadata", "hi", " ki", "about", "text"], "set": ["name", "en", "create", "use", "end", "sys", "start", "msg", "pack", "context", "sa", "et", "list", "check", "m", "ut", "add", "init", "post", "pair", "def", "code", "tx", "data", "reset", "c", "size", "st", "get", "handle", "se", "setup", "parse", "Set", "dict", "op", "SET", "spec", "ctx", "k", "sh", "send", "map", "open", "equal", "sc", "up", "mem", "ch", "new", "sp", "range", "block", "clear", "pre", "gen", "store", "site", "sche", "save", "push"], "env": ["er", "en", "esm", "end", "org", "context", "et", "cb", "te", "ten", "ef", "window", "neck", "qt", "init", "ner", "gear", "ei", "inv", "loc", "va", "e", "tk", "cv", "vm", "ra", "st", "ec", "esc", "ote", "hw", "buf", "exc", "ctx", "uv", "manager", "environment", "server", "sv", "vs", "sc", "viron", "dev", "stage", "conf", "obj", "ah", "ew", "nv", "gov", "eng", "v", "vp", "net", "ev", "vt"], "frame_addr": [" frame_offset", "frame_loc", "Frame_loc", "frame_offset", "frame_pos", "Frame_ptr", " frame_address", "frame__loc", "frame_address", "frame__addr", "frame__ptr", "frame__address", "frame_ptr", "Frame_address", " frame_ptr", "Frame_addr", " frame_pos"], "r26": ["R65", "rr89", " r89", "r20", "r65", "rr65", "R0", "rr20", "ar26", "ar0", " r20", "R89", "r89", "ar16", "rr26", " r0", "R20", "r0", "R26", "R16", " r16", " r65", "r16"], "frame": ["message", "role", "ce", "process", "zone", "err", "fake", "shot", "user", "node", "fr", "function", "word", "event", "scene", "feat", "component", "stage", "feature", "command", "ence", "flow", "point", "chain", "channel", "rame", "state", "response", "context", "thread", "ze", "condition", "trace", "show", "connection", "base", "fi", "send", "rule", "cf", "face", "sequence", "remote", "header", "scope", "force", "ref", "f", "image", "call", "style", "def", "fb", "frames", "ctx", "request", "module", "line", "window", "init", "code", "row", "step", "profile", "setup", "Frame", "lock", "version", "draw", "page", "error", "block", "fram"], "i": ["bi", "n", "t", "phi", "\u0438", "p", "is", "ic", "it", "si", "me", "di", "o", "iu", "ai", " x", "xi", "index", "m", "ix", "h", "y", "ims", " I", "us", "ji", "multi", "zi", "ei", "key", "x", "id", " ii", "ind", "sim", "gi", " ti", "I", "c", "ami", " di", "qi", "ti", "j", "ip", "ini", "batch", "asi", "li", "ui", " k", " bi", " ni", "in", "dr", "ci", " j", " pi", "mi", "u", "ii", " mi", "pi", "l", "hi", "list", "point", "series"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938, "substitutes": {"dev": ["hid", "er", "sys", "dm", "ver", "Dev", "go", "device", "scan", "d", "pro", "def", "conn", "Device", "test", "des", "ds", "watch", "proc", "hw", "DEV", "spec", "ve", "devices", "dem", "de", "mem", "ad", "usb", "doc", "cam", "conf", "w", "pad", "att", "v", "ev", "serv"], "s": ["ports", "is", "ops", "sts", "des", "ds", "sis", "details", "sv", "sw", "hs", "es", "ins", "als", "less", "sb", "v", "sl", "n", "state", "os", "stat", "changes", "ns", "sync", "conv", "bs", "cs", "fs", "aws", "bis", "states", "se", "sm", "ers", "ats", "vs", "bes", "g", "has", "ts", "mods", "ads", "gets", "qs", "b", "comm", "t", "sys", "settings", "sa", "reads", "r", "sd", "stats", "ps", "services", "spec", "ls", "S", "its", "conf", "obj", "store", "l", "so", "serv", "p", "ver", "ids", "set", "parts", "ss", "ses", "terms", "sports", "rs", "gs", "pers", "locks", "south", "ms", "sam", "js", "tests", "sq"]}}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}", "idx": 23942, "substitutes": {"t": ["n", "p", "tt", "txt", "it", "kt", "a", "r", "o", "task", "te", "tn", "h", "tp", "f", "m", "qt", "ct", "tz", "pt", "ot", "dt", "tk", "c", "tr", "T", "rt", "ta", "ts", "nt", "tc", "wt", "tm", "b", "v", "tu", "vt"], "ev": ["ee", "ever", "expr", "EV", "ig", " event", "ele", "lif", "vc", "rev", "it", "ver", "veh", " sv", " eval", "ek", "err", "exec", "eval", "inv", " evict", "iv", "val", "vr", "enc", "e", "eg", " ov", " te", "ec", "ell", "ote", "tr", "tv", "av", " emit", "uv", "ent", "event", "ov", "ve", "sv", " dev", " vec", "dev", "Ev", " tv", "vent", "ep", "ew", "att", "v", "eng", "el", "lv", "attr", "serv"], "host_timer": ["Host_tim", "host_er", " host2Timer", "host_time", "server_tick", "host2tm", "server_Timer", "host2timer", " host2tm", " host_Timer", "host_tm", "host_tim", " host_time", "host_Timer", " host2time", " host_tm", "Host_timer", "Host_Timer", "host2Timer", "Host_er", "host2time", "server_tim", " host2timer", "server_timer", "host_tick"], "act": ["aj", "cap", "txt", "it", "am", "a", "sa", "et", "cont", " ac", "set", "ack", "h", "acts", "err", "ac", "ax", "init", "ct", "ACT", "enc", "pt", "fact", "x", "con", "sect", "ind", " enc", "cv", "tx", " acts", "ec", " cla", "ect", "j", "ann", "av", "xp", "ant", "ctx", "Act", "rt", "pr", "actor", "auth", "active", "and", "at", "action", "cmd", "obj", "ace", "iat", "crit", "acc", "att", "apt", "agent", "attr", "eff"]}}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23947, "substitutes": {"cc": ["isc", "rc", "vc", "ck", "hh", "cb", "cont", "sec", "dc", "cca", "co", "gc", "ct", "CC", "cs", "bc", "cu", "cd", "cv", "c", "cl", "ec", "cod", "ctx", "cci", "lc", "cm", "sc", "cf", "craft", "ci", "mc", "pc", "cmd", "tc", "nc", "acc", "ctl", "fc", "cp", "xc", "cz"], "pec": ["Spec", "pic", "ppo", "vc", "pes", "pac", "act", "ct", "wid", "ps", "pt", "pl", "lp", "eps", "mp", "cs", "yp", "cp", "c", "ec", "ped", "cmp", "xp", "fp", "scl", "cod", "spec", "ptr", "pr", "spe", "pe", "lc", "sc", "px", "cf", "pan", "phy", "pect", "per", "fif", "rpm", "ppa", "pc", "typ", "pel", "pi", "ctl", "fc", "lip", "pat", "vp", "xc"], "fh": ["xh", "fth", "hh", "ffth", "hth", "xhe", "bhd", "haddr", "bhandle", "xhandle", "fhd", "fkh", " fc", "efhe", " fhandle", "xid", "ffaddr", "bkh", "ffh", "bh", "ph", "efid", " fhd", " fkh", "fhe", "phandle", " fhe", "ffc", "efh", "pkh", "hc", "fhandle", "phd", "efhandle", "fc", " fth"], "fid": ["foid", "tfmid", "ckind", "tfkind", "ifids", "cmid", "vid", "lkid", "ckid", " fids", "frid", "fmid", "fids", "vrid", "vkid", "fhid", "xfid", "lrid", "utfid", "tfrid", "crid", "lhid", "vhid", "utfrid", "utfkind", "ifoid", "xfids", "xfoid", "ifid", "cid", "ifaddr", "xfaddr", "chid", "lid", "fkid", "fkind", "tfid", "utfmid", " foid"], "faddr": ["paddress", "laddress", "paddr", "qadr", "fisha", "fadd", "fptr", "padr", "qaddr", "fcadd", "faddress", "fiaddr", "lcoord", "pcoord", "waddr", "fiptr", "fcoord", "fcaddr", "qdate", " fdate", "waddress", " fptr", "fadr", "fpad", "fcdate", "wptr", " faddress", "qaddress", "laddr", "ladr", "qcoord", "fsha", " fadd", "fdate", "wsha", " fpad", "qpad", " fsha", "qadd", "fiaddress", "fcpad"], "e": ["ee", "n", "ed", "er", "t", "ele", "p", "end", "en", "eb", "r", "me", "xe", "o", "f", "te", "m", "debug", "eeee", "d", "ei", "note", "eg", "i", "c", "ge", "ec", "le", "E", "se", "el", "pe", "em", "eu", "g", "ae", "oe", "u", "be", "ep", "ne", "ye", "b", "l", "v", "ate", "ue"], "sei_cont": ["sei_Cont", "seiptcar", "sei_det", "ista_cont", "sei_cat", "seiptwell", "enei_com", "enei_cont", "seaamcont", "osi_cur", "sei_cur", "sei_com", "seiedcontroller", "ici_car", "sei_ont", "seiptcoll", "ici_dat", "uci_ont", "seiammont", "enei_controller", "sei_nav", "sei_cell", "seiedcar", "sei0car", "seiamcar", "sei_stream", "sei_dat", "sei_controller", "sei_mont", "seiptcont", "seiamcontainer", "nai_well", "nai_coll", "sei0cont", "nai_cell", "sei1stream", "seaammont", "sea_mont", "sei0well", "sei_car", "seieddat", "uci_cert", "sei1cat", "sea_cont", "osi_Cont", "seiedcom", "sei0coll", "sei_container", "sei_well", "ista_control", "uci_cont", "ista_cat", "enei_dat", "nai_car", "nai_det", "sei_cert", "osi_cont", "seiedcont", "sei1cont", "seaamcar", "seiamcont", "seaamcontainer", "sea_container", "sei_control", "uci_nav", "osi_com", "sei1control", "ista_stream", "seiedcert", "sea_car", "sei_coll", "ici_cert", "ici_cont", "nai_cont"], "s": ["n", "ties", "p", "t", "is", "sys", "state", "ports", "settings", "r", "set", "m", "h", "ss", "ns", "tains", "joined", "stats", "ps", "i", "sts", "fs", "gs", "services", "rs", "c", "ds", "sis", "bis", "states", "se", "ls", "details", "sets", "sv", "ats", "hs", "S", "js", "sq", "ts", "ares", "gets", "qs", "less", "sb", "v"]}}
{"project": "qemu", "commit_id": "81907a582901671c15be36a63b5063f88f3487e2", "target": 1, "func": "void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,\n\n                CPSRWriteType write_type)\n\n{\n\n    uint32_t changed_daif;\n\n\n\n    if (mask & CPSR_NZCV) {\n\n        env->ZF = (~val) & CPSR_Z;\n\n        env->NF = val;\n\n        env->CF = (val >> 29) & 1;\n\n        env->VF = (val << 3) & 0x80000000;\n\n    }\n\n    if (mask & CPSR_Q)\n\n        env->QF = ((val & CPSR_Q) != 0);\n\n    if (mask & CPSR_T)\n\n        env->thumb = ((val & CPSR_T) != 0);\n\n    if (mask & CPSR_IT_0_1) {\n\n        env->condexec_bits &= ~3;\n\n        env->condexec_bits |= (val >> 25) & 3;\n\n    }\n\n    if (mask & CPSR_IT_2_7) {\n\n        env->condexec_bits &= 3;\n\n        env->condexec_bits |= (val >> 8) & 0xfc;\n\n    }\n\n    if (mask & CPSR_GE) {\n\n        env->GE = (val >> 16) & 0xf;\n\n    }\n\n\n\n    /* In a V7 implementation that includes the security extensions but does\n\n     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control\n\n     * whether non-secure software is allowed to change the CPSR_F and CPSR_A\n\n     * bits respectively.\n\n     *\n\n     * In a V8 implementation, it is permitted for privileged software to\n\n     * change the CPSR A/F bits regardless of the SCR.AW/FW bits.\n\n     */\n\n    if (write_type != CPSRWriteRaw && !arm_feature(env, ARM_FEATURE_V8) &&\n\n        arm_feature(env, ARM_FEATURE_EL3) &&\n\n        !arm_feature(env, ARM_FEATURE_EL2) &&\n\n        !arm_is_secure(env)) {\n\n\n\n        changed_daif = (env->daif ^ val) & mask;\n\n\n\n        if (changed_daif & CPSR_A) {\n\n            /* Check to see if we are allowed to change the masking of async\n\n             * abort exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_AW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_A flag from \"\n\n                              \"non-secure world with SCR.AW bit clear\\n\");\n\n                mask &= ~CPSR_A;\n\n            }\n\n        }\n\n\n\n        if (changed_daif & CPSR_F) {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n", "idx": 23956, "substitutes": {"env": ["ee", "msg", "chart", "door", "et", "desc", "equ", "policy", "answer", "gear", "vert", "vm", "worker", "server", "open", "oe", "ew", "client", "v", "ener", "ev", "chain", "response", "engine", "context", "ger", "te", "menu", "enc", "e", "esc", "disk", "environment", "vs", "db", "entry", "self", "ka", "dev", "erd", "runner", "era", "cmd", "Environment", "cam", "timer", "eng", "net", "cookie", "ef", "qt", "act", "table", "ner", "pkg", "ei", "def", "ter", "loader", "cv", "outer", "operator", "var", "ec", "oder", "hw", "buf", "ctx", "kernel", "ve", "kh", "em", "config", "conf", "obj", "store", "shell", "vp", "vv", "attr", "forge", "vt", "er", "en", "end", "txt", "cb", "container", "gate", "window", "iv", "ey", "code", "conn", "query", "enter", "ent", "here", "manager", "hl", "console", "addr", "pb", "block", "ah", "nv", "w"], "val": ["all", "msg", "ret", "vol", "value", "eval", "pt", "xy", "alpha", "uv", "k", "res", "alt", "zero", "elt", "v", "local", "state", "sel", "stat", "aval", "bl", "x", "data", "fail", "Val", "vec", "kl", "base", "pol", "pal", "values", "pr", "db", "dev", "mem", "cal", "b", "lv", "t", "it", "ref", "arg", "def", "tx", "bit", "Value", "var", "fb", "z", "buf", "ctx", "buffer", "req", "conf", "cache", "len", "pre", "l", "el", "V", "vt", "serv", "valid", "p", "out", "ver", "index", "check", "al", "item", "iv", "key", "arr", "test", "lock", "prop", "VAL", "vals", "doc", "block", "flag", "lib"], "mask": ["pack", "delay", "m", "sum", "filter", "tar", "length", "count", "hide", "batch", "ask", "alt", "map", "Mask", "feature", "zero", "sign", "type", "name", "comment", "make", "condition", "broad", "level", "size", "allow", "mt", "mode", "part", "cf", "mark", "known", "flags", "tag", "hash", "scale", "style", "label", "skip", "layout", "bit", "mac", "black", "module", "buffer", "shape", "box", "xf", "patch", "match", "config", "ma", "cast", "perm", "mk", "mail", "set", "gate", "field", "check", "window", "fix", "sk", "transform", "mission", "key", "miss", "id", "code", "pattern", "lock", "shift", "ms", "block", "clear", "address", "hold", "form", "bug", "flag", "magic"], "write_type": ["write_key", "writeTypeype", "write__pe", "writer_ype", "write__type", "write_mode", "write_Type", "write_ype", "writer_type", "write__key", "write__Type", "writer_mode", " write_Type", " write_key", "write_pe", "writeTypetype", "writeTypemode", " write_pe"], "changed_daif": ["changed___daig", "changed_gaib", "changed_cail", "changed_shaIF", "changed_dail", "changed_caif", "changed__nail", "changed_daib", "changed__daig", "changed_deig", "changed_mait", "changed_taf", "changed_diaph", "changed_daip", "changed___naif", "changed_shaaph", "changed_daim", "changed_daiff", "changed_taif", "changed_maif", "changed_ndaaph", "changed__naif", "changed_daf", "changed_diim", "changed_nail", "changed___naib", "changed_ndaif", "changed_eaif", "changed_naif", "changed_daemon", "changed_diif", "changed___daif", "changed___naemon", "changed_eail", "changed_naemon", "changed_maiff", "changed_deif", "changed_diIF", "changed_eaip", "changed_deib", "changed_caip", "changed_ndaim", "changed__naig", "changed_naig", "changed_taiff", "changed_shaim", "changed_eaig", "changed_gaig", "changed_naip", "changed_shaif", "changed___daemon", "changed_daig", "changed_daaph", "changed_gaemon", "changed_maf", "changed__daip", "changed__daif", "changed_caig", "changed_naib", "changed___daib", "changed__dail", "changed_ndaIF", "changed_gaif", "changed__naip", "changed_dait", "changed_daIF", "changed___naig", "changed_tait", "changed_deemon"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 23965, "substitutes": {"vdev": ["vtdiv", "tdevice", " vcast", "ddevice", "vtdev", "mdevice", "avstore", "vdoc", "mDev", "vdevice", " vver", " vdoc", "pcmd", "avdevelop", "vardev", "vdevices", "avdoc", "vtcmd", "vtcast", "svdef", "fver", "pdev", "avdes", " vdevices", "mdem", "ldata", "avdevices", "vtdevice", "vlink", "svcam", " vdevice", "gev", "vmdiv", "vdef", "tev", "avconf", " vDEV", "fev", "mdb", "vDEV", "ddev", "tdevices", "avlink", " vpad", "vchw", "vmvar", "vvar", "vcam", "fpad", "pdem", " vswitch", "vev", "avdev", "vpad", "svdevice", "dev", "ldef", "vDev", "mconn", "vswitch", "avdiv", "mdes", "vcstore", "pdevice", "fdevelop", "vcdev", "vdes", "vdata", "dcam", "vdem", "ldev", "vtswitch", "vcast", "gdevice", " vev", "tcam", "dDev", " vstore", "mhw", "lconn", "vver", "vardes", "mcmd", "mswitch", "mDEV", "svdev", "vdb", "vconn", "vdevelop", "tdev", "vcdoc", "svconn", "avdevice", "fdevice", " vhw", "vtconf", "vconf", "fDEV", " vconf", "vtvar", "vstore", "mcast", "vmdev", "mlink", "vcdevice", "avvar", " vcam", "vhw", "vcdb", "gDev", "mdef", "avpad", "svev", " vdb", "vcconf", "vtdem", "mev", "vdiv", "tver", "vardevice", "mdev", "gdev", "varlink", "avcam", "vmconf", "svdata", " vdevelop", "mdata", "vcmd", "fdev"], "nr": ["n", "ij", "Ni", "radius", " NV", "sys", "mr", "usr", "org", " NR", "number", "r", "cb", "arity", "tn", "err", "nw", "nor", "ner", "nir", "vr", "inter", "rr", "nz", " np", "bar", " nm", " n", "nn", " nib", "attr", "NRS", "ni", " resid", "no", "nb", "NR", "hr", "ng", "sn", "nm", " sidx", "br", "kr", "num", "eno", " hr", "cor", " ni", "addr", "adr", "nar", "nie", "nih", "gr", "obs", "np", "yr", " neighbor", "uj", "obj", "NV", "ne", "next", "nc", "nv", "gov", "ctr", "byter"], "quirk": ["acquack", "iquirk", "iquirrel", "squlict", "aqulict", "iquirus", "squoise", "quirt", "quavour", "quiat", "chirus", "quorum", "wirrel", "inquail", "acquirk", "acquirus", "wirk", "squiet", "requirus", "chlict", "wiat", "acquavour", "quirus", "qirk", "chavour", "iquiat", "aquorum", " quavour", "squack", "requiry", "squirk", "iquirt", "acqulict", "shiat", "swirk", "shirus", " quirus", "swirus", "qulict", "qorum", "quoise", "inquirus", "acqurison", "aquirk", "qualirk", "shiet", "requirk", "clirt", "aqurison", "squail", "conirt", "requlict", "acquirrel", "squavour", "squirrel", "conirus", "squirt", "shirk", "requirrel", "requoise", "clirk", "conirk", "squirus", "qurison", "quirrel", "iquiet", "queryirus", "queryirt", "querylict", "QUavour", "QUiat", "chirk", "squiry", "iquiry", "squorum", "requiat", "quack", "QUirus", "qirrel", "coniry", "quallict", "qualirus", "inquirk", "aquirus", "inquack", "acquoise", "acquiry", "qualavour", "quiet", "quiry", " quiat", "requrison", "swirrel", "acquiat", "aquavour", "quail", "acquail", "squiat", "cllict", "qirus", "swavour", "wirus", "clirus", "acquirt", "aquirrel", "queryirk", "QUirk"], "mirror": ["borrr", "MirROR", "rerror", "Mirmont", "mintner", "mirrect", "irvert", "torvey", "mirgr", "mirvey", "mror", " mirri", "mirrup", "mirrored", "mervention", "intervey", "morrup", "mirri", " mirfix", "mirerect", "irri", "pirrelation", "merROR", "torior", "interROR", "pirride", "irder", "irgr", "porror", "borror", "verrored", "irride", "merrett", "mirr", "mirior", "irbug", "irrett", " mirrr", "irmror", "mireallow", "merior", " mirrup", "merrect", "pirvert", "rervert", "irrect", "mintfix", "porder", "merride", "pirvention", "merror", "murmit", "rerrelation", "irrage", "Mirror", "rervey", "mormit", "irmrect", "morrr", "miror", "verror", "irner", " mirgr", "irmROR", "bormit", "merrored", "morvention", "mintror", "irmit", "mride", "marror", "rerride", "marrr", "irrored", "pirrage", "merder", "mirbug", "torride", "marner", "murror", "irrr", "irmmont", "morror", "mvention", "libermit", "murROR", "interride", "mirvert", "morrect", "mirmit", "pirror", "verrect", " mirride", " mirvention", "mirerr", "mirner", "mirevey", "irvey", "irrelation", "mirvention", "mirmont", "mirROR", "mirebug", "interror", "mireror", "liberrr", "rerrect", "mirrelation", "Mirrect", "mirference", "mirallow", "irfix", "irallow", "rergr", " mirmit", "migr", "pirrect", " mirROR", "porvey", "ververt", " mirrect", "verrage", "verROR", "irror", "murmont", "mrect", " mirbug", "liberrect", "irference", "mirrr", " mirner", "mervey", "mintrect", "mirrage", " mirrored", "irrup", " mirvey", "borvey", " mirallow", "marvention", "mirfix", " mirference", "mirener", "mireder", "morvey", "miference", "pirgr", "irROR", "mirder", "torror", "rerder", "rerior", "liberror", "morner", "mirride", "mirrett", " mirder", "murrect", " mirrett", "murri", "porride"]}}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009, "substitutes": {"ctx": ["kw", "Context", "mk", "sys", "ck", "kt", "context", "this", "act", "ct", "pkg", "CC", "CT", "con", "conn", "bc", "cv", "tx", "c", "jp", "handle", "cmp", "cur", "hw", "setup", " cx", "tmp", "cm", "sc", "cf", "anc", "config", "mc", "np", "cmd", "tc", "req", "tm", "nc", "cc", "ca", "cp", "cfg", "xc"], "arg0": ["ig50", "tag4", "tag1", "tag0", " arg00", "param4", " arg4", "param1", "ig0", " arg50", "arg50", "Arg0", "param0", "Arg00", "ig1", "arg00", "param00", "Arg50", "arg4", "tag00", "ig00", "Arg1"], "arg1": ["tag4", "tag1", "tag0", "aggn", "tag2", "arg01", " arg4", "param1", " argn", "argn", "tag3", "args4", "paramn", "args2", "param01", "args3", "args1", "agg3", "arg4", "args0", "agg1", " arg3", "agg01", " arg01", "param3", "arg3"], "arg2": ["arg02", "prop1", "prop2", " arg4", "doc02", "doc4", " arg6", "prop3", "agg2", "doc2", "agg4", "arg6", "args2", "args3", "agg02", "args1", "prop6", "doc3", "agg3", "arg4", " arg3", "args6", " arg02", "arg3"], "sub": ["sup", "is", "false", "any", "rc", "tag", "neg", "sing", "set", "desc", "pred", "sum", "pop", "add", "mut", "broad", " Sub", "con", "Sub", "sim", "bc", "watch", "cmp", "pub", "big", "repl", "shift", "ub", "control", "un", "cond", "sc", "super", "reg", "ch", "delete", "match", "pre", "mod", "small", "push"]}}
{"project": "FFmpeg", "commit_id": "cd19c677cb5dcaecc472c021bd38370817740a5e", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, \n\n                             void *data, int *data_size,\n\n                             uint8_t *buf, int buf_size)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    MpegEncContext *s = &h->s;\n\n    AVFrame *pict = data; \n\n    int buf_index;\n\n    \n\n    s->flags= avctx->flags;\n\n    s->flags2= avctx->flags2;\n\n\n\n   /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_TRUNCATED){\n\n        int next= find_frame_end(h, buf, buf_size);\n\n        \n\n        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )\n\n            return buf_size;\n\n//printf(\"next:%d buf_size:%d last_index:%d\\n\", next, buf_size, s->parse_context.last_index);\n\n    }\n\n\n\n    if(h->is_avc && !h->got_avcC) {\n\n        int i, cnt, nalsize;\n\n        unsigned char *p = avctx->extradata;\n\n        if(avctx->extradata_size < 7) {\n\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n\n            return -1;\n\n        }\n\n        if(*p != 1) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown avcC version %d\\n\", *p);\n\n            return -1;\n\n        }\n\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n\n           so put a fake nal_length_size = 2 while parsing them */\n\n        h->nal_length_size = 2;\n\n        // Decode sps from avcC\n\n        cnt = *(p+5) & 0x1f; // Number of sps\n\n        p += 6;\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding sps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Decode pps from avcC\n\n        cnt = *(p++); // Number of pps\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize)  != nalsize) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding pps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Now store right nal length size, that will be use to parse all other nals\n\n        h->nal_length_size = ((*(((char*)(avctx->extradata))+4))&0x03)+1;\n\n        // Do not reparse avcC\n\n        h->got_avcC = 1;\n\n    }\n\n\n\n    if(!h->is_avc && s->avctx->extradata_size && s->picture_number==0){\n\n        if(decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0) \n\n            return -1;\n\n    }\n\n\n\n    buf_index=decode_nal_units(h, buf, buf_size);\n\n    if(buf_index < 0) \n\n        return -1;\n\n\n\n    //FIXME do something with unavailable reference frames    \n\n \n\n//    if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_index, buf_size);\n\n    if(!s->current_picture_ptr){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"error, NO frame\\n\");\n\n        return -1;\n\n    }\n\n\n\n    {\n\n        Picture *out = s->current_picture_ptr;\n\n#if 0 //decode order\n\n        *data_size = sizeof(AVFrame);\n\n#else\n\n        /* Sort B-frames into display order */\n\n        Picture *cur = s->current_picture_ptr;\n\n        Picture *prev = h->delayed_output_pic;\n\n        int out_idx = 0;\n\n        int pics = 0;\n\n        int out_of_order;\n\n        int cross_idr = 0;\n\n        int dropped_frame = 0;\n\n        int i;\n\n\n\n        if(h->sps.bitstream_restriction_flag\n\n           && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n            s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n            s->low_delay = 0;\n\n        }\n\n\n\n        while(h->delayed_pic[pics]) pics++;\n\n        h->delayed_pic[pics++] = cur;\n\n        if(cur->reference == 0)\n\n            cur->reference = 1;\n\n\n\n        for(i=0; h->delayed_pic[i]; i++)\n\n            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)\n\n                cross_idr = 1;\n\n\n\n        out = h->delayed_pic[0];\n\n        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)\n\n            if(h->delayed_pic[i]->poc < out->poc){\n\n                out = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        out_of_order = !cross_idr && prev && out->poc < prev->poc;\n\n        if(prev && pics <= s->avctx->has_b_frames)\n\n            out = prev;\n\n        else if((out_of_order && pics-1 == s->avctx->has_b_frames)\n\n           || (s->low_delay && \n\n            ((!cross_idr && prev && out->poc > prev->poc + 2)\n\n             || cur->pict_type == B_TYPE)))\n\n        {\n\n            s->low_delay = 0;\n\n            s->avctx->has_b_frames++;\n\n            out = prev;\n\n        }\n\n        else if(out_of_order)\n\n            out = prev;\n\n\n\n        if(out_of_order || pics > s->avctx->has_b_frames){\n\n            dropped_frame = (out != h->delayed_pic[out_idx]);\n\n            for(i=out_idx; h->delayed_pic[i]; i++)\n\n                h->delayed_pic[i] = h->delayed_pic[i+1];\n\n        }\n\n\n\n        if(prev == out && !dropped_frame)\n\n            *data_size = 0;\n\n        else\n\n            *data_size = sizeof(AVFrame);\n\n        if(prev && prev != out && prev->reference == 1)\n\n            prev->reference = 0;\n\n        h->delayed_output_pic = out;\n\n#endif\n\n\n\n        *pict= *(AVFrame*)out;\n\n    }\n\n\n\n    assert(pict->data[0]);\n\n    ff_print_debug_info(s, pict);\n\n//printf(\"out %d\\n\", (int)pict->data[0]);\n\n#if 0 //?\n\n\n\n    /* Return the Picture timestamp as the frame number */\n\n    /* we substract 1 because it is added on utils.c    */\n\n    avctx->frame_number = s->picture_number - 1;\n\n#endif\n\n    return get_consumed_bytes(s, buf_index, buf_size);\n\n}\n", "idx": 24018, "substitutes": {"avctx": ["avcc", "iverjp", " avconfig", "afcpp", "afcc", "avecmp", "abtx", "ajtmp", "ajcm", "ajcpp", "afcu", "avcomp", "avstack", "abconfig", "afctx", "ajcmd", "avecomp", "ajcu", "AVkt", "avercc", " avctl", "avekb", "avconfig", "cvcontext", "avcmp", "avekt", "avconf", "iverkt", "avjp", "cvpkg", " avcm", "avercontext", "afpkg", "iverctl", "ajtx", "averctx", "afcmd", "aftmp", "averstack", "avtmp", "afcmp", "AVjp", "averctl", "iverjac", " avkb", "ravcpp", "avcu", "ajcmp", "afjac", " avcontext", "cvkb", " avtx", "averjac", "abcontext", "ravcu", "avereq", "aftx", "avepkg", "avcpp", "aveconf", "avtx", "ajconfig", "avecontext", "ravctx", "avjac", "afstack", "averpkg", "avkt", "abctx", "iverctx", "AVctl", "avkb", "avreq", "avconn", " avconn", "abcmp", "avcontext", "ajconf", "ravcmd", " avpkg", "avectl", "ajcomp", "avctl", "aveconn", "afcomp", "avecm", "avcm", "iverpkg", "avpkg", "cvctx", "avcmd", " avconf", "ajreq", "averreq", "ajcontext", "ajctx", "abtmp", "iverstack", "afreq", "avectx", "avecc", "averconn", "AVctx", "avejp"], "data": ["t", "first", "frame", "a", "one", "r", "record", "f", "m", "device", "value", "window", "rew", "read", "rel", "table", "d", "ata", "na", "image", "def", "empty", "str", "bytes", "raw", "DATA", "dat", "map", "buffer", "in", "Data", "block", "bin", "obj", "json", "next", "to", "feed", "text"], "data_size": [" data_len", " data_offset", "data_offset", "data2len", " data_length", "data_length", "data_len", "data2offset", "data2size", "data2length"], "buf": ["rb", "cap", "alloc", "cb", "ref", "window", "err", "bl", "Buff", "pkg", "arr", "uf", "bar", "Buffer", "bc", "cv", "fb", "bytes", "vec", "tr", "img", "ff", "ctx", "br", "xff", "queue", "tmp", "wb", "seq", "db", "buffer", "box", "mem", "doc", "buff", "pb", "np", "cmd", "b", "v"], "buf_size": ["buf64size", "buf2Size", "buf2index", "buf64state", "queue_n", "buf_ize", "buf2n", "queue_size", "buffer_ize", "queue2SIZE", "queue2n", "buffer_size", "buf_len", "buf2ize", "queue2ize", "buffer_state", "buf_n", " buf_Size", "buffer_SIZE", "bufableize", "buf2size", "buffer_index", "bufablen", "queue2size", "buf_Size", " buf_len", "buf_SIZE", "buf64index", "buf64SIZE", "buf_count", "queue_SIZE", "buf_state", " buf_count", "bufableSIZE", "buf2SIZE", "bufablesize", "queue_ize"], "h": ["history", "t", "dh", "ht", "he", "eh", "high", "hh", "H", "f", "oh", "m", "y", "hash", "th", "x", "c", "host", "hd", "hw", "hr", "ih", "ctx", "his", "here", "bh", "hz", "q", "sh", "ph", "kh", "html", "hl", "hs", "hm", "rh", "hp", "her", "self", "ch", "g", "http", "subject", "cache", "ah", "b", "hi", "v", "l", "w"], "s": ["n", "t", "sys", "is", "settings", "a", "os", "m", "ss", "ns", "session", "sf", "stats", "d", "ps", "bs", "cs", "sts", "sports", "rs", "gs", "fs", "c", "ds", "se", "sections", "ctx", "spec", "ls", "caps", "cpp", "sam", "ssl", "sh", "sw", "ats", "sv", "vs", "hs", "self", "utils", "S", "js", "g", "es", "http", "sq", "ts", "sp", "mods", "sg", "conf", "qs", "sb", "cc", "b", "v", "so", "sl", "w"], "pict": ["fx", "fn", " fn", "ref", "f", "ef", "foo", " frame", " f", "fw", "cv", "fb", "frames", "Frame", "fr", "ff", "raw", "ft", "q", "fi", "rf", "fd", " fr", "buff", "req", "F", "fc", "fl", "vp", " fa"], "buf_index": ["uf__index", "bufrowaddress", "buf_position", "buf_address", "buf__window", "bufrowindex", "bufrowwindow", "bufrowposition", "uf_index", "buf__index", "uf__position", "bufstrindex", "buf__position", "uf_position", "uf_window", "buf__address", "bufstrposition", "bufstraddress", "buf_window", "uf_address", "uf__address", "uf__window", "bufstrwindow"], "i": ["n", "bi", "ij", "er", "phi", "is", "\u0438", "ic", "it", "iq", "ri", "this", "si", "me", "di", "index", "iu", "ai", "io", "xi", "m", "ix", "y", "ims", "us", " I", "init", "multi", "by", "ji", "im", "zi", "ei", "ie", "iy", "x", "id", "ind", "sim", "gi", "info", "I", "c", "ami", "qi", "ki", "ini", "ti", "ip", "j", "cli", "status", "iii", "PI", "li", "ui", "oi", "in", "iter", "ci", "eu", "mi", "ii", "port", "pi", "hi", "MI", "point"], "cnt": [" ccount", "cct", "ncount", "Cnz", " cnz", "ncnt", "Cant", "ecnt", "ncant", "ecct", "mcNT", "Cnt", "eccount", "count", "cNT", "mcnt", "lcount", "lcnt", " cant", " cct", "ecount", "cust", "Ccount", "CNT", "lcant", "ccount", " count", "Cust", "crnt", "Count", "mcnz", "crnz", "cant", " cNT", " cust", "crount", "Cct", "mcust", "lcNT", "crNT", "cnz", "ncNT"], "nalsize": ["nalfizes", "nsalesource", "nALSized", "nalsizer", "nelsization", "nsalfiz", "nalsization", "nalizer", "nalsized", "nalledizer", "talsIZE", "naledize", "nselsiz", " nalsization", "nALSource", "nelsizer", "nsalesiz", "nalsizes", "nalesIZE", "nalledizes", " naledization", "nelsiz", "nALSization", "nalfiz", "nsalsized", "nalfource", "nsalizer", "nalediz", "nselsized", "nalsource", "naldize", "nalfized", "nALSize", "nalsIZE", " naledizer", "celsized", "calsized", "nalization", "nsalfource", "celsization", "nALSIZE", "nsalized", "calsizer", "nsalsource", "nsalization", "nallsize", "naldource", "talsize", "naledizes", "nalized", "naledized", "nsalesize", "nelsize", "nALSiz", "nalource", "nsalsiz", "nallsiz", "nsalsize", "nalledization", "nalfization", "naldiz", "talsiz", "calsization", " naledize", "nselsize", "naliz", "calesizer", "nselsizer", "nalesize", "calesization", "nalize", "nsalsizer", " naledizes", "nALSizer", "nalesizer", "calsize", "calesize", " nalsizer", "nalesization", "talesized", "talesize", " nalsizes", "nalfizer", "talesIZE", "nsalsization", "nalesiz", "nalesource", "nsalfize", "talsized", "nalsiz", "celsizer", "nalesized", "calesiz", "nallsized", "nsalize", "naldizer", "calsiz", "nelsized", "nalfize", "nsalfizer", "naledizer", "nsalesizer", "celsize", "naledization", "nallsIZE", "talesiz", "nalledize"], "p": ["n", "perm", "vp", "it", "a", "o", "ping", "m", "tp", "progress", "y", "pkg", "d", "post", "ps", "pt", "pp", "pro", "lp", "pl", "wp", "c", "pa", "pers", "jp", "j", "ap", "ip", "pid", "xp", "pod", "fp", "op", "P", "q", "pn", "pr", "dp", "pe", "part", "up", "at", "par", "g", "sp", "rep", "pc", "pb", "np", "pg", "pos", "cache", "pre", "pi", "b", "bp", "pad", "port", "cp", "pat", "point", "padding"]}}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 24044, "substitutes": {"cpu": ["all", "ck", "pie", "process", "pt", "none", "cum", "vm", "node", "software", "jp", "cli", "aux", "clock", "component", "util", "ctl", "loop", "gpu", "resource", "ilo", "cat", "stat", "efficiency", "thread", "program", "prof", "pp", "cs", "copy", "coin", "hz", "num", "nic", "apache", "home", "sc", "mem", "runner", "upt", "prefix", "pc", "uu", "cmd", "execute", "computer", "cp", "net", "core", "sys", "memory", "gc", "stats", "pkg", "cu", "cv", "c", "proc", "hw", "mac", "library", "ctx", "kernel", "module", "utils", "aco", "performance", "config", "docker", "np", "pool", "cache", "linux", "nc", "comp", "aq", "kt", "alloc", "processor", "boot", "tp", "window", "current", "physical", "conn", "que", "profile", "pu", "chip", "CPU", "gp", "phys", "lib"], "cc": ["xx", "isc", "ck", "zz", "cb", "AC", "cca", "ac", "gc", "ct", "cy", "CC", "cs", "bc", "uc", "cl", "ec", "BC", "ctx", "cell", "cci", "icc", "lc", "cm", "cf", "ci", "mc", "pc", "tc", "soc", "oc", "nc", "acc", "ctl", "CCC", "fc", "ca", "cp", "cz"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047, "substitutes": {"list": ["loop", "t", "all", "parent", "out", "state", "print", "source", "set", "listed", "collection", "ul", "order", "table", "top", "array", "level", "info", "data", "test", "LIST", "batch", "base", "lock", "result", "li", "queue", "seq", "map", "shape", "sequence", "stack", "lists", "block", "tree", "List", "l", "v", "file", "lat", "chain"], "func": ["fn", "fun", "kw", "loop", "orig", " fn", "bf", "cb", "sec", "wrapper", "callback", "f", "go", "cover", "conv", "act", "closure", "unc", "fac", "con", "bc", "impl", "c", "proc", "function", "ctx", "now", " function", "cf", "inner", "action", "conf", "bin", "work", "nc", "cc", "b", "FC", "fc", "apply"], "opaque": [" opaques", "ipaques", "ipacity", " opaco", "paques", " opque", "ipaque", "obaque", " opacity", "pacity", "opacity", "ipaco", "opaques", "paque", "obque", "opaco", "obaco", "ipque", "opque", "obaques"], "abort_on_failure": ["abort_on_failerror", "abort_on_failURE", "abort_on_failures", "abort_on_successures", "abort_on_writeURE", "abort_on_failederror", "abort_on_successure", "abort_on_failedures", "abort_on_failedURE", "abort_on_passures", "abort_on_writeures", "abort_on_successURE", "abort_on_successerror", "abort_on_passure", "abort_on_failedure", "abort_on_writeerror", "abort_on_writeure", "abort_on_passURE"], "opts": ["prefs", "attcs", "OPTS", "opTS", "opcs", "ioptions", "atttions", "optTS", "optcs", "optls", "OPfs", "optts", "OPls", "opls", "ops", " opcs", "prels", " opTS", " options", "pres", "OPs", "optfs", " opls", " ops", "OPts", "iopcs", "attls", "opfs", "prets", "attts", "iopls", "options", "iopts", "OPcs"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n", "idx": 24050, "substitutes": {"opaque": ["opsute", "plient", " opque", "operque", "ogacity", "ogaque", "operlay", "ogque", "opient", "Opaque", "plque", "Opacity", "opacity", "plaque", " opute", " oplay", "opsaque", "opsque", "placity", "opslay", "Opient", "operute", "ogient", "Opque", "opque", "oplay", "operaque", "opute"], "addr": [" address", "dh", "end", "alloc", "a", "et", "r", "index", "arp", "ack", "ref", "off", "ix", "offset", "add", "ac", "src", "url", "loc", "arr", "id", "inter", "x", "dest", "eth", "rs", "tx", "asm", "ap", "coord", "ip", "ord", "ress", "ctx", "ptr", "align", "now", "ag", "grad", "seek", "res", "hl", "db", "adj", "adr", "help", "mem", "ad", "Address", "dr", "at", "au", "iter", "address", "cmd", "pos", "work", "store", "pad", "phys", "sha", "point", "attr"], "value": ["name", "VALUE", " address", "vector", " arg", "func", "r", "index", "set", "type", "field", "length", "ay", "format", "fee", "val", "key", "total", "code", " parameter", "Value", "data", "test", "size", "byte", "wise", "tv", " Value", "function", " weight", "values", "VAL", "buffer", "we", "unit", "mem", "address", "w", "bin", "json", " val", "ue", "v", "cas", "padding", "vt"], "len": ["n", "en", " length", "end", "lit", "ret", "Len", "h", "length", "offset", "fee", "enc", "val", "loc", "lp", "label", "ld", "lan", "ly", "lon", "size", "vec", "limit", "cmp", "kl", "lang", "z", "lock", "align", "ls", "seq", "hl", "mem", "fin", "ln", "nl", "pos", "lis", "ll", "elt", "last", "lf", "l", "Length", "lib", "L"], "mmio": ["mmia", "mios", "mbio", " mmios", "MMio", "mmiot", "mbIO", "dmio", "miu", " mmia", "mmisco", "dmogo", "miot", "dmait", "mxios", "mliu", "dmios", "mmogo", "mbia", "mmmiot", "mmait", "mbisco", " mmIO", "mmmisco", "mliot", "mmIO", "mmiu", "mmmio", "mlios", "mmmait", "mmmia", " mmisco", "mmmios", "mxio", "MMIO", "mio", "mmmogo", "mxogo", "MMios", "mmios", "mlio", "mmmiu", "mbios", "mxait"], "section": ["definition", "parent", "state", "Section", "setting", "tag", "context", "access", "comment", "ion", "set", "sec", "index", "group", "session", "null", "member", "shadow", "format", "relation", "key", " Section", "description", "sect", "tab", "test", "data", "journal", "slot", "size", "connection", "portion", "se", "sections", "version", "see", "ment", "function", "status", "ECTION", "position", "part", "entry", "lc", "division", "region", "area", "service", "dimension", "usage", "feature", "config", "prefix", "sector", "block", "address", "tower", "rup", "mod", "ser", "second", "option", "header"]}}
{"project": "FFmpeg", "commit_id": "48e52e4edd12adbc36eee0eebe1b97ffe0255be3", "target": 0, "func": "static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 24072, "substitutes": {"avctx": ["vcctx", "vrcmp", "avcmp", " avconn", "abcmp", "avcontext", "vcconn", "abwork", "avecmp", " avwork", "AVcmp", "vrcontext", "avtx", "AVconn", "avework", "avecontext", " avcmp", "vrtx", "AVcontext", "AVtx", "abctx", "vccontext", "avwork", "avectx", "AVctx", " avcontext", " avtx", "avconn", "vctx", "vrctx", "abcontext"], "ctx": ["expr", "msg", "ck", "desc", "loc", "wp", "timeout", "jp", "wx", "tmp", "lc", "xs", "command", "tc", "work", "ctl", "xc", "kw", "jac", "context", "conv", "info", "cmp", "kl", "xp", "sc", "ka", "cf", "wcs", "that", "prefix", "cmd", "iat", "crit", "acl", "tm", "inst", "cc", "github", "fc", "cp", "td", "comm", "t", "abc", "exec", "qt", "co", "act", "gc", "pkg", "cv", "tx", "c", "proc", "hw", "ia", "config", "nt", "np", "req", "pg", "conf", "obj", "nc", "comp", "history", "p", "txt", "rc", "org", "kt", "cb", "check", "window", "ct", "ctrl", "conn", "bc", "setup", "cm", "cfg", "today"], "dl_fn": ["pkg_fun", "dl___cb", "sel___fn", "dl1fn", "dlockfun", "pkg_fn", "dl___obj", "dl_cb", "dl___fn", "pkg_ln", "dl___compl", "dl1ln", "dlockfm", "pkgockfn", "dl_compl", "dl_fm", "pkgockfm", "dl_fun", "sel_fn", "dl_ln", "pkg_fm", "dlockfn", "dlockln", "pkgockfun", "sel_compl", "sel___obj", "sel___cb", "pkgockln", "dl1fun", "dl1fm", "sel_obj", "sel___compl", "sel_cb", "dl_obj"], "p_nvenc": ["p_Nvenec", "p_norenl", "p_nvenac", "p_nvenC", "p_nvencon", "p_kveng", "p_nrenC", "p_ngenec", "p_kvenl", "p_nvinl", "p_koreng", "p_navencon", "p_nveng", "p_nvinc", "p_Nrenec", "p_NrenC", "p_ngenac", "p_Nrenc", "p_noreng", "p_naveng", "p_nrenc", "p_nigenc", "p_nrenec", "p_NvenC", "p_nrenac", "p_korenl", "p_nvincon", "p_kvencon", "p_nvenec", "p_korenc", "p_navenl", "p_nigenac", "p_nigenC", "p_Nrenac", "p_Nvenc", "p_ngenc", "p_norenc", "p_nigenec", "p_nvenl", "p_navenc", "p_norencon", "p_Nvenac", "p_nving", "p_kvenc", "p_ngenC", "p_korencon"], "i": ["is", "ic", "io", "m", "ims", " I", "im", " index", "user", "I", "ti", "cli", "k", "ui", " bi", "point", "uri", "chain", "\u0438", "si", "me", "ai", "ix", "menu", "ji", " m", "x", " ii", "e", "sim", "ind", "gi", " ti", "info", "fi", "oi", "gl", " pi", "u", "remote", "b", "bi", "t", "phi", "it", "iq", "ri", "xi", "f", "y", "multi", "zi", "ei", "mount", "c", "qi", "ini", "ip", "z", "li", "request", "try", "in", "ci", "rest", "mi", "ii", "slice", " mi", "to", "pi", " ki", "series", "wait", "ij", "history", "p", " li", "print", "di", "index", "iu", "init", "key", "id", "ki", "j", " wi", "eu", " multi"], "nb_registered_frames": ["nb_registered_objects", "nb_registered_bytes", "nb_registeredptframe", "nb_registeredfobjects", "nb_recorded_files", "nb_registered_frame", "nb_registered_events", "nb_registered__events", "nb_registered2objects", "nb_recorded_faces", "nb_registered__bytes", "nb_registered2frames", "nb_recorded_events", "nb_recorded_frame", "nb_registeredffeatures", "nb_registered2features", "nb_registeredfframes", "nb_registeredptevents", "nb_registeredptbytes", "nb_registered2frame", "nb_recorded_objects", "nb_registered_faces", "nb_registeredptframes", "nb_recorded_bytes", "nb_registered_features", "nb_recorded_frames", "nb_registered__frames", "nb_registered_files", "nb_registeredfframe", "nb_recorded_features", "nb_registered__frame"]}}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n", "idx": 24075, "substitutes": {"cpu": ["core", "p", "t", "sys", "gpu", "processor", "process", "tp", "device", "thread", "gc", "bench", "conn", "cu", "cum", "target", "mu", "vm", "c", " CPU", "jp", "percent", "machine", "cli", "proc", "hw", "pu", "ctx", "kernel", "clock", "aco", "nic", "self", "mem", "ola", "runner", "pc", "np", "pool", "cache", "execute", "CPU", "linux", "pai", "phys", "cp"], "addr": [" address", "dh", "rc", "a", "r", "index", "arp", "ref", "off", "m", "ix", "hash", "offset", "add", "y", "rel", "act", "ar", "src", "inter", "loc", "x", "id", "target", "rs", "eth", "tx", "ip", "coord", "hw", "ord", "mt", "ctx", "ptr", "align", "now", "link", "res", "adj", "Address", "adr", "mem", "ad", "dr", "at", "sp", "address", "cmd", "pos", "to", "pad", "v", "sha", "attr"], "i": ["bi", "ij", "t", "phi", "is", "\u0438", "ic", "it", "ri", "print", "si", "di", "index", "iu", "ai", "list", "xi", "f", "m", "ix", "y", " l", " I", "init", "multi", " m", "zi", "ei", " index", "iy", "x", "id", " ii", "gi", "info", "str", "I", "c", "ami", "qi", "ini", "ti", "ip", "cli", "z", "li", "ui", "fi", " bi", "abi", " wi", "oi", "in", "ci", " pi", "mi", "ii", " p", "pi", " c", "v", " err", "uri"]}}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n", "idx": 24084, "substitutes": {"bs": ["bi", "is", "lbs", "bits", "ks", "ubs", "ss", "bps", "BS", "aos", "ses", "ns", "bl", "iss", "ps", "cs", "bc", "fs", "gs", "bn", "bd", "ds", "bis", " BS", "ls", "bm", "bh", "ms", "bles", "vs", "bing", "bes", "its", "has", "ts", "als", "obs", "pb", "blocks", "acs", "qs", "sb", "bos", "b", "bp", "bb"]}}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 24085, "substitutes": {"qov": ["qtov", " qvo", "Qnov", "qqhov", "qav", "qterv", "qthov", "qnov", "quove", "Qove", "qove", "qqvo", "qunov", "quov", " qnov", "qtvo", "qerv", "qqov", "quav", "qqerv", " qav", "qhov", " qhov", "qvo", "Qov", " qerv", " qove", "Qav"], "value": ["property", "name", "parent", "VALUE", "p", "any", "element", "python", "create", "message", "hello", "r", "source", "index", "memory", "record", "field", "type", "null", "attribute", "item", "val", "key", "package", "current", "none", "Value", "node", "data", "select", "content", "result", "function", "raw", "now", "values", "true", "entry", "buffer", "always", "new", "sequence", "expression", "block", "address", "tree", "w", "json", "variable", "ue", "v", "widget", "holder", "instance"], "e": ["ee", "n", "ed", "er", "t", "ele", "en", "p", "element", "eb", "a", "entity", "et", "o", "me", "xe", "ce", "ek", "te", "m", "h", "ef", "ze", "eeee", "ei", "ie", "ea", "eps", "eg", "i", "node", "c", "ate", "ec", "le", "ge", "se", "E", "ent", "est", "pe", "entry", "eu", "g", "es", "ae", "oe", "ep", "ne", "ue", "el", "ev", "ome"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n", "idx": 24087, "substitutes": {"x": ["xx", " xp", "message", "xt", "xe", "xi", "ix", "m", "y", "xa", "e", "tx", "xy", "xml", "X", "xp", "lex", "z", "ctx", "px", "xf", "ux", "xs", "v", "xc", "w"], "items": ["links", "bits", "ids", "orders", "users", "pages", "units", "item", "rows", "keys", "results", "groups", "args", "bytes", "workers", "faces", "files", "z", "jobs", "points", "names", "values", "lines", "vals", "types", "levels", "pins", "xs", "ips", "objects", "blocks", "Items", "codes", "actions", "members"], "size": ["n", "name", "parent", "scope", "start", "capacity", "message", "number", "si", "index", "set", "m", "sum", "SIZE", "length", "scale", "offset", "window", "score", "order", "item", "zone", "fee", "count", "total", "style", "space", "weight", "i", "empty", "data", "c", "max", "s", "body", "z", "height", "city", "now", "ize", "sy", "position", "storage", "shape", "area", "mem", "Size", "dimension", "g", "address", "len", "options", "to", "pi", "l", "v", "small", "grow", "type"], "p": ["n", "t", "a", "r", "ping", "f", "m", "ps", "pt", "pp", "lp", "pl", "i", "cp", "c", "pa", "php", "jp", "j", "ap", "ip", "pid", "fp", "P", "ptr", "q", "pr", "par", "g", "per", "sp", "rep", "pb", "pc", "np", "u", "pointer", "port", "pi", "v", "b", "vp"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090, "substitutes": {"vs": ["boxes", "ports", "vis", "sys", "VS", "ks", "changes", "ns", "Vs", "ses", "court", "stats", "vr", "iss", "bs", "otes", "ps", "ops", "eps", "cs", "sts", "rs", "fs", "gs", "ds", "pers", "ls", "caps", "atts", "values", "ms", "sv", "env", "hs", "vals", "js", "xs", "wcs", "ins", "posts", "ts", "lists", "blogs", "obs", "pps", "gets", "params", "ups", "qs", "docs", "fps", "nets", "roots", "v", "tops", "vp", "vt"], "x": ["n", "p", "t", "dx", "r", "m", "ix", "ax", "ox", "i", "on", "tx", "c", "xy", "rx", "X", "wx", "ex", " cx", "px", "xs", "l", "v"], "y": ["p", "yy", "axy", "py", "ery", "hy", "ys", "cy", "yl", "iy", "ny", "yp", "my", "xy", "yt", "sy", "oy", "iny", "Y", "yd", "ch", "ym", "gy", "ry", "b"], "w": ["n", "p", "t", "en", "r", "wh", "f", "m", "ww", "win", "nw", "wid", "wi", "d", "i", "fw", "wr", "iw", "hw", "z", "rw", "wx", "ex", "sw", "wb", "ow", "W", " W", "wd", "wt", "ew", "wa", "l", "v"], "h": ["n", "t", "p", "ht", "he", "high", "hh", "o", "r", "wh", "H", "oh", "m", "head", "d", "i", "c", "size", "z", "hr", "height", "ih", "hei", "bh", "q", "ph", "hl", "ch", "g", "hi", "b", "v", "l"], "palette": ["palettes", "filette", " pallete", " palet", "palet", "alette", "Palettes", "promette", "hollette", "whettes", "Palette", "Palene", "pallete", "Pallete", "Palte", "promlette", "palene", "whette", "fillette", "palte", "Pallette", "whlete", " pallette", "filene", "allette", "alte", "allete", " palte", "filte", "pallette", "stalene", "promlete", "holette", "holet", "whlette", "alettes", "stallette", "stalte", "alet", "stalette", "promte", "hollete"], "color_type": [" color_format", "colorEmethod", "colorLETYPE", "colortypeTYPE", " color_file", " color_pe", "colorETYPE", "colorityTYPE", "colorLEnum", "color_color", " color_num", "color_format", "color_set", "colortypetype", "color_file", " color_TYPE", "color_num", "colorityfile", "colorEfile", "colortypecolor", "color_TYPE", "colorLEtype", "color_no", "colorLEno", "coloritymethod", "coloritytype", " color_model", "colortypeformat", "colorEtype", " color_set", " color_method", " color_color", "color_model", "color_pe", "color_method", " color_no"], "png_ptr": ["ng__pointer", "ping_Ptr", "native_handle", "ng_ptr", "pngxPtr", "img_ptr", "png_pointer", "png_pointers", "draw_ptr", "pngxtp", "png__ptr", "pngEptr", "png_cmd", "pngTYpointer", "png_handle", "psy_pointer", "img_pointer", "png_rep", "pngxptr", "png__tr", "ng_tp", "png___cert", "pngacdata", "pngxrep", "pngTYcert", "psyTYcur", "img_pointers", "pngacpointer", "png__pt", "pngTYcur", "ping_pointer", "phot_dep", "png__pointer", "psy_ptr", "psy_cur", "ng__ptr", "pngacPtr", "png__obj", "ping_ptr", "png_pdf", "png_obj", "draw_pt", "pngxpointer", "psy_cert", "ngacpointers", "pngEdep", "ng_tr", "pngacptr", "png_Ptr", "pngEpdf", "ng_pointers", "phot_pointer", "pn_rep", "png__rect", "png_pt", "png_cur", "ng_Ptr", "psyTYptr", "ng_pointer", "native_cmd", "native_Ptr", "ng_obj", "img_addr", "pngEpointer", "psyTYpointer", "png___pointer", "png_dep", "pngTYptr", "png___rep", "png_data", "png_cert", "png_tp", "ngacPtr", "pn_pointer", "ngactp", "psyTYcert", "png_addr", "pngactp", "png_ret", "phot_pdf", "pngacpointers", "png_rect", "pn_ptr", "png___ret", "native_ptr", "ng__rect", "png___ptr", "pngxpointers", "draw_rep", "png__rep", "ping_data", "ng_rect", "pngxpt", "ng__obj", "png___cur", "png_tr", "ngacptr", "phot_ptr", "draw_pointer", "pn_ret"], "info_ptr": ["info_Ptr", "infopttile", "notice_addr", "info__pointer", " info_Ptr", "info__pt", "info__Ptr", "info____pt", "info_pointer", "info_obj", "info_pt", " info_obj", " info_pointer", " info_pt", "info_pointers", "infoptptr", "info__rel", " info_pointers", "info__ptr", "info____rel", " info_rel", "info_tr", "info_loc", "info_addr", " info_tr", "info_tile", "infoptaddr", "notice_tile", "info__pointers", "info____Ptr", "notice_loc", "notice_ptr", "infoptloc", "info_rel", "info____ptr"], "linebuf": ["linkbuff", "linkdata", "linebuffer", " linebuff", " linedata", "linkbuf", "linkbuffer", "pagedata", "pagebuf", "pagebuffer", "linedata", " linebuffer", "pagebuff", "linebuff"], "buf": ["cap", "msg", "txt", "out", "alloc", "cb", "ref", "conv", "pkg", "uf", "bc", "Buffer", "cv", "vec", "cur", "lim", "img", "queue", "tmp", "wb", "map", "buffer", "mem", "doc", "buff", "cmd", "b", "v"], "dy": ["done", "yy", "tie", "dx", "di", " height", "foo", "err", "dir", "d", "iy", "dim", "Height", "xy", "j", "low", "height", "deg", "foot", "draw", "ded", "ch", " d", "len", "diff", "ii"], "priv": ["expr", "cert", "resp", "rc", "usr", "rev", "alloc", "org", "private", "ilege", "sec", "prov", "policy", "err", "rel", " privilege", " Priv", "pkg", "pro", "def", "conn", "Priv", "pri", "deb", "or", "cp", "admin", " pri", "pub", "proc", "prop", "pal", "pr", "env", "trust", "auth", "dev", "Pri", "sp", "rep", "req", "soc", "ep", "rib", "Pr", "pty", "riv", "serv"]}}
