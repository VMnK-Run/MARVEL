{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 4093, "substitutes": {"usb_net_init": ["usb_net__init", "usb_net__setup", "usb_nets_init", "usb_nets_setup", "usb_net__config", "usb_net_setup", "usb_nets_config", "usb_net_config", "usb_net__set", "usb_net_set", "usb_nets_set"], "cmdline": ["cmdlin", " cmdl", "mdstring", "commandine", "commandline", "cmdl", "mdline", "commandLINE", "commandl", "cline", "commandstring", " cmdstring", "commandlin", "mdlin", " cmdine", "clLINE", "cmdine", "cll", " cmdlin", "clline", "cmdLINE", "cmdstring", "mdl", " cmdLINE"], "dev": ["data", "new", "Dev", "rc", "develop", "pub", "dist", "def", "od", " Dev", "rad", "result", "development", "diff", "adv", "d", " def", "di", "error", "de", "fi", "debug", "nov", "df", "DEV", " prod", "app", "conn", "test", "bug", "ev", "ready", "die", "device", "id", "obj", "dd", "var", "gd", "dc", "nd", "inst", "cam", "err", "info", "ad", "ver", "bd", "cd", "valid", "priv", "dem", "conf", "gu", "driver", "wd"], "opts": ["copps", "optt", "cops", "otls", "protes", " opns", "props", " optps", " optts", "OPts", "prots", "optns", "copls", "roptes", "optls", "OPs", "opns", "opttr", "ops", "optts", "optes", "ropps", " optes", "procs", "opt", " opt", "opcs", "otps", "OPns", "ropts", " opcs", "opttes", "opps", "optcs", "roptr", "optr", " optr", "copts", "opls", " opttes", "optps", "ots", "ropcs", " opps", "OPt", " ops", "otts"], "idx": [" idxc", "idpc", " idpc", "idc", "indix", "Idxc", "Idix", "idxs", "IDw", "Idc", " idc", "Idx", " idw", "IDxc", "pidX", "indX", " IDx", "idw", "lenxs", " idix", " IDpc", "lenxc", " IDxs", "pidxc", "lenpc", "indx", " idX", "IDx", " idxs", "idxc", "idix", "IdX", "pidc", "Idw", "idX", "indxc", "pidx", "lenx", " IDxc", "IDc"]}}
{"project": "FFmpeg", "commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "target": 1, "func": "static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,\n\n                              int dump_payload, AVRational time_base)\n\n{\n\n    HEXDUMP_PRINT(\"stream #%d:\\n\", pkt->stream_index);\n\n    HEXDUMP_PRINT(\"  keyframe=%d\\n\", (pkt->flags & AV_PKT_FLAG_KEY) != 0);\n\n    HEXDUMP_PRINT(\"  duration=%0.3f\\n\", pkt->duration * av_q2d(time_base));\n\n    /* DTS is _always_ valid after av_read_frame() */\n\n    HEXDUMP_PRINT(\"  dts=\");\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->dts * av_q2d(time_base));\n\n    /* PTS may not be known if B-frames are present. */\n\n    HEXDUMP_PRINT(\"  pts=\");\n\n    if (pkt->pts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->pts * av_q2d(time_base));\n\n    HEXDUMP_PRINT(\"\\n\");\n\n    HEXDUMP_PRINT(\"  size=%d\\n\", pkt->size);\n\n    if (dump_payload)\n\n        av_hex_dump(f, pkt->data, pkt->size);\n\n}\n", "idx": 4095, "substitutes": {"avcl": ["ajfi", "avfi", "ajsel", " avsh", "appsh", "ajsh", "avsh", " avfi", "appcl", "ajcl", "appsel", " avsel", "avsel", "appfi"], "f": ["func", "fn", "proc", "e", "d", "fed", "exec", "p", "rf", "df", "function", "h", "F", "r", "sf", "file", "l", "n", "s", "fd", "c", "m", "t", "fen", "fs", "g", "i", "fc", "w", "fr", "elf", "ff", "b", "fac", "tf", "fp", "feed", "v", "handler"], "level": ["local", "depth", "scale", "levels", "loc", "name", "enc", "limit", "vel", "len", "debug", "Level", "type", "stage", "lo", "temp", "mode", "path", "parent", "loop", "code", "lc", "lvl", "length", "count", "stream", "format"], "pkt": ["pet", "fnt", "cpcht", "compacket", "opnt", "facket", "compdt", "prokt", "cpnt", " punt", "apkt", "procht", "pcht", "Pet", "produkt", "perunt", "produet", "Pdt", "heth", "prunt", " pkl", " pant", "produkl", "pect", " pct", "pront", "apet", "pkl", " pwk", "Pct", "cpkt", "fct", " pnt", "prnt", "nkt", "proant", "Pkt", "Packet", "het", "Ppt", "compet", "pant", "copet", "pnt", "nacket", "peret", "peth", "prkt", " ppt", "opkt", "peacket", " packet", "punt", "produnt", "apacket", " peth", "pct", "cpant", "pernt", "apnt", "pept", "pret", "Pnt", "perkl", "compkt", "Peth", "opacket", "hkt", "Pwk", "opet", " pet", "pwk", "ppt", "pdt", "copacket", " pcht", "net", "copkt", "packet", "perkt", "fkt", "pekt", "copwk", "hdt", "nwk", " pdt"], "dump_payload": ["dump_playload", "dump_workload", "dump_enloaded", "dump_workq", "dump_payloads", "dump_shapeloads", "dump_workpack", "dump_paypack", "dump_playq", "dump_playpack", "dump_playflow", "dump_shapement", "dump_enpack", "dump_payment", "dump_Payload", "dump_payflow", "dump_playment", "dump_shapeload", "dump_payloaded", "dump_playloaded", "dump_workloaded", "dump_shapeflow", "dump_playloads", "dump_Payment", "dump_payq", "dump_enq", "dump_enload", "dump_Payloads", "dump_Payflow"], "time_base": ["timedbase", "addressalscale", "address_index", " time_index", "timefunit", "timealindex", "timedentry", "timealbody", "timecodescale", "clock_base", "address_scale", "time_entry", "time_type", " time_block", "time2unit", " time_type", "addressalbody", "timefbase", "time_part", "timefindex", "timecodebase", "address_base", "time_scale", " time_unit", "timealscale", "clock_data", "timespart", "clock_source", "timedunit", "time16part", "timecodeindex", "time_index", "timecodebody", "timessource", "address_body", "clock_part", " time_entry", "time_source", "time2base", "time2block", "timesbase", "timealbase", "timefentry", "time_unit", "time16data", "timedindex", "time_block", "addressalbase", "addressalindex", "time16base", "timesdata", "time2type", "time16source", "time_body", "time_data"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void handle_mousewheel(SDL_Event *ev)\n\n{\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n    SDL_MouseWheelEvent *wev = &ev->wheel;\n\n    InputButton btn;\n\n\n\n    if (wev->y > 0) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (wev->y < 0) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return;\n\n    }\n\n\n\n    qemu_input_queue_btn(scon->dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(scon->dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n}\n", "idx": 4104, "substitutes": {"ev": ["em", "EV", "eve", "lv", "e", "ae", "element", "enc", "exc", "event", "window", "ce", "ell", "esc", "eva", "ep", "ever", "eg", "env", "ek", "eng", "v", "entry", "rev", "vent", "ah", "ec", "cv", "el", "Event", "req", "model", "eb", "hw", "iv", "dev", "erv", "ov", "ew", "cell", "ee", "Ev", "vv"], "scon": [" scm", "dcl", " sCON", "jconf", "dconf", "Sconst", "Scm", "sconst", " scl", "sCON", "dcon", "dconn", "synconn", "sco", "sconf", "jconn", "jcl", "fcon", "Scon", "fcl", "psco", "pscon", "scm", "pscm", "scl", " sco", "syncl", "sconn", " sconn", "fconf", "psconst", "Sco", " sconst", "jcon", "synCON", "fconn", "syncon", "fCON"], "wev": ["WEw", "weh", "wef", "pef", "hev", "peh", "WEf", " wevs", "ouvs", "Wef", "wew", " wec", " wew", "ouv", "wec", "pev", "Wex", "wevs", "hef", "wf", " weva", "weva", "wv", "ouc", "WEv", " wex", "wex", "WEva", "ouf", "ww", " wef", "hevs", " weh", "hec", "wva", "Weh", "Wev", "pex"], "btn": ["batch", "ui", "tag", "wb", "uc", "fn", "rc", "ou", "bn", "text", "tk", "tn", "bool", "dt", "widget", "cli", "sync", "wx", "src", "don", "kk", "biz", "touch", "bug", "bb", "config", "focus", "bot", "fw", "cmd", "fb", "button", "butt", "txt", "ck", " bout", "ctx", "bc", "boot", "menu", "mot", "bg", "kt", "ctrl", "wp", "fc", "kn", "wt", "scroll", "tc", "cn", "bd", "poll", "b", " button", "qt", "cb", "bs", "fp", "bt", "ctl", "fl"]}}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n", "idx": 4141, "substitutes": {"s": ["sq", "sb", "browser", "sys", "src", "S", "sc", "ses", "r", "cs", "service", "sf", "ss", "c", "ts", "services", "fs", "f", "us", "ssl", "se", "w", "sd", "b", "http", "rs", "spec"], "bus": ["ash", "root", "Bus", "db", "build", "back", "hub", "self", "sync", "buf", "test", "bridge", "bug", "ch", "config", "device", "lib", "plugin", "id", "block", "plug", "ck", "boot", "bc", "host", "path", "usb", "pass", "book", "cat", "us", "serial", "mount", "cache", "BUS", "front", "pack", "board", "gen", "http", "bs", "os", "conf", "feed", "driver", "base"], "dev": ["av", "data", "root", "Dev", "dn", "pub", "dist", "def", "od", "development", "diff", "error", "de", "d", "di", "rad", "adv", "ve", "debug", "self", "dom", "nov", "DEV", "app", "h", "conn", "test", "bug", "ev", "ch", "die", "device", "off", "ready", "id", "pro", "obj", "plug", "dd", "block", "var", "v", "dc", "prov", "mod", "serial", "req", "cam", "ow", "der", "info", "err", "ver", "ad", "w", "user", "valid", "sd", "kind", "feature", "priv", "end", "conf", "serv", "gu", "driver", "spec"], "features": ["data", "options", "fn", "dist", "nets", "properties", "classes", " Features", "plugins", "fts", "devices", "fi", "debug", "models", "details", "rules", "args", "params", "faces", "conn", "atts", "config", "ips", "stats", "types", "products", " feature", " feat", "dim", "works", "fd", "fields", "fs", "f", "mac", "flags", "settings", "feat", "steps", "fc", "product", "ports", "prefix", "tests", "words", "fee", "Features", "reports", "feature", "format", "ins", "items", "results", "feed", "ributes", "driver", "bugs", "spec"]}}
{"project": "FFmpeg", "commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "target": 1, "func": "int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4159, "substitutes": {"pkt": ["parnt", "pet", "prct", "tpkt", "pelt", "parcht", "yacket", "payacket", "facket", "mkt", "pait", "mct", " punt", "cpnt", "fait", "pcast", "jpacket", "jpcast", "Pant", "pcht", " pki", "prekg", "lnt", "ppeth", "Pet", "pkg", "pki", "wpkt", "spacket", "paykt", "tpet", "lkt", "npct", "Pdt", "prcast", "jpct", "Pcht", "ppkt", " pant", " pct", "ykt", "spet", "preeth", "paynt", "Pct", "Pett", "cpkt", " pcast", "lpacket", " pnt", "prnt", "spelt", "promant", "perkg", "wpnt", "neth", "Pkg", "nkt", "npnt", "fpelt", "npacket", "paracket", "Pkt", "spkt", "Packet", " pelt", "lacket", "lelt", "cpct", "lpdt", "let", "npkt", "fpnt", "pant", "sacket", "ppacket", "pnt", "snt", "tpacket", "tpelt", "cpet", "promkt", "peracket", "peret", "peth", " pkg", "prkt", "upacket", "parkt", "Pait", " packet", "punt", " peth", "pct", "prekt", "wpacket", "nkg", "jpelt", "fet", "ynt", "Pnt", "fpet", "mkg", "Peth", "Punt", "payett", "fpkt", "npkg", "cpkg", " pait", "jpkt", "promacket", "upkt", "upunt", "ppnt", "promki", "Pki", " pet", "lpkt", "prent", "Pelt", "pdt", "spnt", "cpacket", "pett", "packet", "sett", "yeth", "perkt", "fkt", "wpcht", "jpnt", "skt", "nnt", "lpct", "macket", "upct", " pdt"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "end", "j", "di", "e", "d", "interface", "key", "multi", "fi", "cli", "ti", "yi", "isin", "slice", "is", "mi", "qi", "ii", "module", "u", "id", "n", "ni", "l", "ip", "s", "c", "m", "init", "ix", "ori", "oi", "f", "g", "zi", "io", "start", "ri", "ini", "info", "iv", "it", "x", "gi", "xi", "uri", "ci", "eni", "lc", "z", "in", "b", "iu", "I", "ai", "v", "si", "li"], "size": ["pos", "used", "sum", "set", "scale", "nice", "name", "ny", "ice", "sync", "slice", "type", "site", "id", "s", "any", "engine", "Size", "strength", "location", "fee", "reason", "timeout", "side", "six", "count", "term", "unit", "li", "data", "ui", "depth", "form", "member", "ie", "message", "get", "mini", "key", "grade", "ey", "h", "offset", "channel", "position", "sp", "load", "ize", "sized", "mode", "owner", "address", "weight", "sex", "path", "page", "day", "start", "code", "shape", "time", "send", "body", "storage", "sec", "small", "number", "general", "value", "len", "connection", "style", "last", "full", "speed", "SIZE", "use", "query", "line", "password", "n", "large", "go", "c", "content", "eng", "g", "shift", "capacity", "model", "security", "length", "zero", "align", "si", "x", "extra", "y", "end", "j", "error", "loc", "e", "core", "server", "fe", "zip", "function", "empty", "external", "version", "source", "max", "cache", "z", "live"], "p": ["py", "data", "y", "pi", "pc", "np", "k", "j", "vp", "pre", "param", "e", "d", "after", "pg", "pl", "tp", "op", "api", "prev", "app", "h", "ps", "up", "pr", "r", "patch", "u", "pa", "sp", "at", "dp", "P", "n", "l", "ip", "jp", "ap", "per", "s", "hp", "m", "c", "t", "g", "f", "pointer", "point", "pp", "a", "wp", "part", "w", "o", "lp", "python", "pe", "bp", "z", "b", "post", "po", "q", "fp", "cp", "v", "x", "port"]}}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n", "idx": 4165, "substitutes": {"dev": ["data", "Dev", "pc", "pi", "push", "pub", "proc", "def", "progress", "rad", "de", "d", "api", "app", "pid", "pad", "r", "ev", "ch", "dp", "device", " device", "u", "pro", "pipe", "plug", "c", "io", "prop", "cam", "req", "info", "ad", "ver", "w", "o", " priv", "md", "pu", "pack", "priv", "conf", "v", "private", "port"], "p": ["pb", "pi", "pc", "np", "proc", "vp", "param", "e", "tp", "op", "r", "dp", "P", "n", "m", "c", "t", "g", "f", "pp", "prop", "i", "w", "o", "bp", "fp", "cp", "v"], "s": ["an", "sq", "e", "d", "sb", "sys", "sync", "spec", "session", "S", "ps", "ses", "service", "sp", "ds", "stats", "n", "ops", "ss", "sr", "sg", "ts", "sh", "c", "m", "sym", "fs", "g", "ns", "ssl", "se", "o", "sl", "sv", "su", "js", "es", "os", "v", "rs", "si"]}}
{"project": "qemu", "commit_id": "4508d81a788f451c83604e1d0033243e191d71a7", "target": 1, "func": "ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,\n\n                                uint32_t flags)\n\n{\n\n    ram_addr_t bdloc;\n\n    int i, n;\n\n\n\n    /* We put the bd structure at the top of memory */\n\n    if (bd->bi_memsize >= 0x01000000UL)\n\n        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);\n\n    else\n\n        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);\n\n    stl_phys(bdloc + 0x00, bd->bi_memstart);\n\n    stl_phys(bdloc + 0x04, bd->bi_memsize);\n\n    stl_phys(bdloc + 0x08, bd->bi_flashstart);\n\n    stl_phys(bdloc + 0x0C, bd->bi_flashsize);\n\n    stl_phys(bdloc + 0x10, bd->bi_flashoffset);\n\n    stl_phys(bdloc + 0x14, bd->bi_sramstart);\n\n    stl_phys(bdloc + 0x18, bd->bi_sramsize);\n\n    stl_phys(bdloc + 0x1C, bd->bi_bootflags);\n\n    stl_phys(bdloc + 0x20, bd->bi_ipaddr);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);\n\n    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);\n\n    stl_phys(bdloc + 0x2C, bd->bi_intfreq);\n\n    stl_phys(bdloc + 0x30, bd->bi_busfreq);\n\n    stl_phys(bdloc + 0x34, bd->bi_baudrate);\n\n    for (i = 0; i < 4; i++)\n\n        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);\n\n    for (i = 0; i < 32; i++)\n\n        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);\n\n    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);\n\n    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);\n\n    n = 0x6A;\n\n    if (flags & 0x00000001) {\n\n        for (i = 0; i < 6; i++)\n\n            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);\n\n    }\n\n    stl_phys(bdloc + n, bd->bi_opbfreq);\n\n    n += 4;\n\n    for (i = 0; i < 2; i++) {\n\n        stl_phys(bdloc + n, bd->bi_iic_fast[i]);\n\n        n += 4;\n\n    }\n\n\n\n    return bdloc;\n\n}\n", "idx": 4166, "substitutes": {"env": ["em", "cfg", "nc", "rc", "def", "proc", "e", "enc", "tty", "ea", "buf", "ev", "config", "hl", "ef", "fs", "shell", "ed", "console", "vt", "inst", "ec", "en", "el", "emb", "iv", "code", "state", "environment"], "bd": ["data", "da", "gb", "vd", "od", "BD", "db", "bf", "d", "sb", "dh", "hide", "dt", "bm", "df", "bl", "bb", "dan", "die", "ds", "bot", "fb", "cdn", "dd", "fd", "gd", "ba", "not", "bc", "hd", "dc", "nb", "boot", "pd", "kb", "nit", "nd", "ande", "bin", "ad", "ud", "md", "cd", "sd", "b", "cb", "bt", "td", "ld", "wd"], "flags": ["ffff", "options", "fps", "bus", "mask", "blocks", "args", "bit", "offset", "bytes", "types", "stats", "ops", "lag", " bits", "ags", "fs", "Flags", "f", "vals", "flag", "ints", "lf", "bits", "xff", "bands", "features", "fg"], "bdloc": ["ndloc", "bflocation", "dkhop", "dballoc", "blloc", "ldalloc", " cdLOC", "bdconfig", "bbLOC", "bsrc", "blcor", "ndroot", "bbconn", "bdrc", "bborg", "bdok", "ndvoc", "ndhop", "bcalloc", "hdcoll", "BDLOC", "bcok", "mdlang", "bblang", "hdhome", "bdhop", "bcerror", "bcrc", "hdconn", "cballoc", "pdlang", "kblang", " cdloc", "bdlock", "bdcoll", "ndspec", "bdLOC", "pdconn", "hdroot", "bdstat", "hdrc", "bblocation", "bcspec", "bllang", "blsrc", "ldtag", "cblocation", "hdlocal", "bfloc", "bdspec", "hdlocation", "dkloc", "mdlocation", "hdalloc", "dbroot", "mdloc", "bdsrc", "bbcor", "hdutil", "btloc", "bblim", "bberror", "blstat", "bllock", "kbloc", "dLOC", "pdloc", "dblocation", "bclock", "dbvoc", "mdutil", "dblang", "ndlocation", "BDloc", "bdvoc", "cbtag", "pdlocation", "btutil", "dlang", "dbrc", "dkcor", "blang", "bdalloc", "bdlocal", "dloc", "dblocal", "hdlang", "BDhome", "btlocation", "hdconfig", "kblocation", "hdvoc", "bderror", "bdconn", "hdcor", "dkhome", "bcsrc", "dberr", "bchome", "bblocal", "bdlocation", "hderror", "bdorg", "ldlocation", "bcorg", "dbhop", "bbhome", "BDlocation", "dbstat", "bflocal", "pdok", "block", "hderr", "dklocal", "dbloc", "dbcor", "bbcoll", "cbloc", "bdlim", "btconfig", "pdcoll", "mdlim", "bcloc", "bblit", " cdhome", "blok", "bllocation", "bdroot", "dklocation", "dbconn", "bclang", "dkvoc", "kblit", "dblit", "bdtag", "hdlim", "dbspec", "bctag", "mdconfig", "bcconn", "nderr", " cdlocation", "bdhome", "bbvoc", "bclit", "bderr", "bclocation", "kblim", "dborg", "bdlang", "dkerror", "bclocal", "bcerr", "bdlit", "bdcor", "hdLOC", "bdutil", "ldloc", "dberror", "derr", "dbLOC", "pdstat", "bloc", "dbok", "bllim", "bflit", "hdloc", "bbloc", "bbok", "ndlocal"], "i": ["ui", "bi", "data", "y", "pi", "index", "ie", "ei", "j", "di", "diff", "si", "d", "e", "mini", "key", "multi", "fi", "ti", "p", "yi", "uli", "slice", "jit", "mi", "phi", "qi", "ii", "hi", "u", "ali", "ji", "ind", "id", "ni", "l", "ip", "chi", "jp", "c", "init", "ix", "g", "oi", "zi", "io", "ri", "ini", "info", "my", "gi", "o", "xi", "mu", "uri", "it", "ci", "eni", "lc", "code", "b", "in", "iu", "I", "ai", "v", "x", "li"], "n": ["nm", "nc", "fn", "np", "j", "e", "len", "p", "num", "u", " ni", "ind", "l", "ni", "s", "net", "m", "c", "t", "g", "f", "ns", "sn", "nr", "N", "o", "nt", "z"]}}
{"project": "qemu", "commit_id": "92cb05574b7bd489be81f9c58497dc7dfe5d8859", "target": 0, "func": "bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n", "idx": 4173, "substitutes": {}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4178, "substitutes": {"mon": ["mos", "mo", "an", "member", "pin", "am", "un", "mm", "mat", "wm", "message", "mont", "amon", "tom", "mons", "monitor", "mid", "dom", "connection", "mut", "MON", "ann", "don", "meter", "mi", "conn", "num", "tun", "client", "unit", " monitor", "module", "config", "mn", "bo", "man", "sym", "m", "mr", "mor", "gin", "ms", "platform", "mc", "mag", "om", "mac", "mount", "Mon", "master", "bin", "wat", "my", "mu", "manager", "atom", "mun", "dm", "com", "lock", "con", "phys", "stat"], "password": ["data", "wallet", "sword", "phrase", "sudo", "text", "name", "param", "enc", "auth", "key", "command", "p", "username", "channel", "login", "account", "patch", "config", "device", "cmd", "crypt", "word", "pattern", "encrypted", "address", "secret", "description", "pass", "padding", "attribute", "words", "prefix", "code", "Password", "wd", "token", "port"], "opaque": ["Opace", " opque", "opace", " opace", "hopque", "opacity", "Opque", "copace", "operque", "copaque", "opaques", "operaque", "ipque", "Opaque", "hopacity", "operacity", "ipaque", "copacity", " opacity", "opque", "hopaques", "ipaques", "ipacity", "hopaque", "copque", "Opacity", "operaques"], "bs": ["bi", "iss", "pb", "lb", "gb", "ras", "sb", "bos", "bm", "ks", "BS", "aos", "ls", "bl", "ps", "utils", "ses", "vs", "bay", "acs", "gs", "cs", "bb", "ds", "ob", "ss", "bes", "ba", "ils", "css", "bc", "fs", "ns", "ms", "as", "bis", "b", "bps", "rs", "bas"]}}
{"project": "FFmpeg", "commit_id": "9c3a8693a20da3ad89a327bf778e13c2cd74c81c", "target": 0, "func": "dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n\n                    enum dshowDeviceType devtype, IBaseFilter **pfilter)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IBaseFilter *device_filter = NULL;\n\n    IEnumMoniker *classenum = NULL;\n\n    IMoniker *m = NULL;\n\n    const char *device_name = ctx->device_name[devtype];\n\n    int skip = (devtype == VideoDevice) ? ctx->video_device_number\n\n                                        : ctx->audio_device_number;\n\n    int r;\n\n\n\n    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,\n\n                                   &CLSID_AudioInputDeviceCategory };\n\n    const char *devtypename = (devtype == VideoDevice) ? \"video\" : \"audio\";\n\n\n\n    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],\n\n                                             (IEnumMoniker **) &classenum, 0);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate %s devices.\\n\",\n\n               devtypename);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {\n\n        IPropertyBag *bag = NULL;\n\n        char *buf = NULL;\n\n        VARIANT var;\n\n\n\n        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        var.vt = VT_BSTR;\n\n        r = IPropertyBag_Read(bag, L\"FriendlyName\", &var, NULL);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        buf = dup_wchar_to_utf8(var.bstrVal);\n\n\n\n        if (pfilter) {\n\n            if (strcmp(device_name, buf))\n\n                goto fail1;\n\n\n\n            if (!skip--)\n\n                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n\n        } else {\n\n            av_log(avctx, AV_LOG_INFO, \" \\\"%s\\\"\\n\", buf);\n\n        }\n\n\n\nfail1:\n\n        if (buf)\n\n            av_free(buf);\n\n        if (bag)\n\n            IPropertyBag_Release(bag);\n\n        IMoniker_Release(m);\n\n    }\n\n\n\n    IEnumMoniker_Release(classenum);\n\n\n\n    if (pfilter) {\n\n        if (!device_filter) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not find %s device.\\n\",\n\n                   devtypename);\n\n            return AVERROR(EIO);\n\n        }\n\n        *pfilter = device_filter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4196, "substitutes": {"ctx": ["context", "cfg", "nc", "uc", "pc", "rc", "conv", "np", "cal", "loc", "cc", "anc", "cli", "p", "acl", "client", "xc", "conn", "sc", "cm", "config", "fw", "cmd", "cca", "tx", "Context", "cms", "ck", "c", "bc", "kb", "ctrl", "cl", "cv", "cam", "conf", "hw", "pkg", "concept", "fc", "cu", "qa", "wp", "cf", "ca", "tc", "cn", "ci", "lc", "ac", "cas", "fp", "cp"], "device_filter": ["device__filter", " device_fil", "device__format", "device_user", "devicepsearch", " device_sort", "user_format", " device_Filter", "user_search", "devicepfilter", " device_format", "device__Filter", "user_user", "devicepuser", "device_search", "device_Filter", "device__sort", "user_filter", "device_fil", "device_format", "devicepformat", "device_sort"], "classenum": ["classnum", "productmetadata", "classfeat", "Classfeat", "Classpath", "Classenum", " classconfig", "classmetadata", "typenum", "classpath", "classconfig", " classmetadata", "CLASSconfig", "productenum", "classum", " classum", "typefeat", "CLASSnum", "Classnum", " classnum", "Classen", "CLASSenum", "typepath", "classen", "productum", " classfeat", " classpath", "CLASSen", "Classconfig", "CLASSmetadata", " classen", "producten", "typeenum", "CLASSum"], "m": ["context", "gm", "y", "vm", "mt", "e", "d", "rm", "mm", "p", "bm", "sm", "metadata", "h", "mi", "module", "cm", "jam", "hm", "fm", "n", "l", "dim", "s", "man", "c", "mr", "t", "perm", "g", "f", "ms", "mc", "tm", "om", "mac", "mod", "model", "i", "o", "mu", "manager", "im", "M", "md", "dm", "b", "machine", "v", "port"], "device_name": ["deviceingid", "device_address", "dev_name", " device_group", "deviceacfilter", "devicesnames", "device_size", "deviceacnames", " device_number", "devicesgroup", "device_names", "device_group", "deviceFnames", "deviceingaddress", "devicesname", "dev_number", " device_names", "deviceFname", "deviceingname", "device_id", "devicesnumber", "deviceFnumber", "deviceFgroup", "deviceacname", "dev_address", "deviceingnumber", "dev_id", "device_number", "deviceacsize", " device_size"], "r": ["ru", "br", "rc", "re", "k", "end", "ner", "error", "result", "e", "d", "er", "p", "ur", "rg", "rh", "h", "hr", "u", "line", "n", "l", "rr", "res", "s", "lr", "c", "sr", "mr", "run", "t", "cr", "rec", "g", "f", "or", "R", "nr", "nor", "err", "w", "ar", "kr", "rar", "o", "it", "fr", "dr", "rt", "z", "rw", "rb", "b", "attr", "rl", "q", "v", "rs", "ret"], "device_guid": ["device_ruid", "device_collid", "device_guide", "device_Guip", "device_Guids", "device_guname", "device_uuin", "device_runame", "device_guip", "device_collin", "device_collide", "device_Guide", "device_uuid", "device_collids", "device_uuname", "device_Guname", "device_ruide", "device_guids", "device_Guin", "device_uuip", "device_uuide", "device_Guid", "device_ruip", "device_guin", "device_uuids"], "devtypename": ["devtyrenename", "devTypenum", "devTyrenum", "devtyperename", "devtyenname", "devtyperum", "devtymenum", "devTYperename", "devtymenname", "devtypername", "devtyrename", "devTYpenname", "devTypename", "devTypenname", "devtyrenname", "devTYpenAME", "devTyrename", "devTYpename", "devTypenename", "devTYpername", "devtyrenum", "devTYperame", "devtymenename", "devTYpenename", "devtypenename", "devtyenename", "devtyenAME", "devTYperAME", "devtymename", "devtypenum", "devtyperAME", "devtyename", "devTyrenname", "devTyrenename", "devtypenname", "devtyperame", "devtyrenAME", "devtypenAME"], "bag": ["batch", "tag", "data", "br", "package", "ab", "wrap", "packed", "sb", "card", "container", "p", "zip", "map", "slice", "filter", "pad", "bug", "box", "config", "go", "buff", "grab", "buffer", "array", "pkg", "bin", "w", "gate", "comb", "pak", "bags", "band", "bind", "ag", "pack", "jar", "b", "bed", "rb", "tab", "brush", "z", "rag"], "buf": ["batch", "pool", "data", "br", "uc", "func", "wb", "ref", "ab", "queue", "text", "sb", "Buffer", "val", "map", "src", "pad", "seq", "box", "bb", "config", "fam", "bytes", "vec", "fb", "block", "buff", "aux", "grab", "tmp", "bc", "buffer", "cv", "pkg", "alloc", "uf", "la", "ff", "rb", "b", "cas", "cb", "tab", "cmp", "ptr", "port"], "var": ["tag", "av", "func", "Var", "vari", "br", "ref", "vr", "bar", "ser", "str", "val", "variable", "p", "arr", "op", "slice", "type", "pad", "pr", "AR", "bb", "par", "rr", "per", "man", "sr", "t", "entry", "tmp", "cur", "parse", "cat", "err", "ar", "ver", "dev", "rar", "fr", "dr", "pack", "b", "attr", "arg", "jar", "Variable", "ptr", "v", "car", "adr"], "skip": [" sr", "allow", "rc", " c", "strip", "proc", "error", "sleep", "trace", " rec", "op", "ignore", "mid", "li", "no", "ski", "ry", "stop", "order", "need", "par", "sp", "include", "mn", "ip", "rn", "keep", "mode", "Skip", "all", "rec", "cr", "pass", "mc", "cl", "ro", "err", " s", "M", "loop", "me", "ipp", "jump", "process", "cmp", "row", " tr"]}}
{"project": "FFmpeg", "commit_id": "a755b725ec1d657609c8bd726ce37e7cf193d03f", "target": 0, "func": "static int do_decode(AVCodecContext *avctx, AVPacket *pkt)\n\n{\n\n    int got_frame;\n\n    int ret;\n\n\n\n    av_assert0(!avctx->internal->buffer_frame->buf[0]);\n\n\n\n    if (!pkt)\n\n        pkt = avctx->internal->buffer_pkt;\n\n\n\n    // This is the lesser evil. The field is for compatibility with legacy users\n\n    // of the legacy API, and users using the new API should not be forced to\n\n    // even know about this field.\n\n    avctx->refcounted_frames = 1;\n\n\n\n    // Some codecs (at least wma lossless) will crash when feeding drain packets\n\n    // after EOF was signaled.\n\n    if (avctx->internal->draining_done)\n\n        return AVERROR_EOF;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))\n\n            ret = pkt->size;\n\n    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n    } else {\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    if (ret == AVERROR(EAGAIN))\n\n        ret = pkt->size;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->internal->draining && !got_frame)\n\n        avctx->internal->draining_done = 1;\n\n\n\n    if (ret >= pkt->size) {\n\n        av_packet_unref(avctx->internal->buffer_pkt);\n\n    } else {\n\n        int consumed = ret;\n\n\n\n        if (pkt != avctx->internal->buffer_pkt) {\n\n            av_packet_unref(avctx->internal->buffer_pkt);\n\n            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        avctx->internal->buffer_pkt->data += consumed;\n\n        avctx->internal->buffer_pkt->size -= consumed;\n\n        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;\n\n        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    if (got_frame)\n\n        av_assert0(avctx->internal->buffer_frame->buf[0]);\n\n\n\n    return 0;\n\n}\n", "idx": 4198, "substitutes": {"avctx": [" avcms", "verctrl", "akcmp", "allcontext", "verconfig", "aircf", "avecu", "avloc", "allconfig", " avlc", "avconfig", "afctx", "ajcontext", "avtx", "avcmd", "avalctl", "navctx", "avalctx", "akpkg", "navxc", "afcdn", "akcf", "avalcu", "navcca", "aveloc", "afloc", "afcmp", "averc", "altx", "avecca", "aveqa", "navconn", "aptx", "avepkg", "avelc", "abcu", "ivctx", "avecontext", "apctx", "avpkg", "rafcontext", "navcu", " avloc", "afconn", "afcu", "afcn", "afcot", "avecms", "akconn", "navcn", "afctl", "aflc", "afpkg", "afcca", "ivcn", "avalcot", "allcf", "akctrl", "aveconfig", "ivrc", "verqa", "alctx", "avexc", "avcontext", "aveconn", "navcontext", "avconn", "afcms", "avcca", "avcn", "navconfig", "vercdn", "aircontext", "afsq", "avecmp", "avecas", "akctx", "avxc", "ajconn", "navsq", "verconn", "aircmd", "abcontext", "avcot", "rafctx", "afctrl", "abconn", "avcdn", "avcms", "afcf", "avcmp", "alconn", "afqa", "verctx", "avqa", "apcu", "rafcot", " avcf", "rafctl", "verxc", "avalcontext", "vercontext", "avcu", "allctx", "alcontext", "afconfig", "vercf", " avcontext", "avecf", "navcf", "afxc", "alcu", "avctl", "avcf", "avsq", "afcontext", "ivcontext", "avctrl", "avlc", "vercu", "akcontext", "apcontext", "avcas", "avrc", "abctx", "afrc", "airctx", "avalcmd", "ajsq", "avectx", "aftx", "avalcf", "afcmd", "avecn", "afcas", "avalcdn", "alcas", "ajctx"], "pkt": ["pet", "pucht", "prct", "tpkt", "lpkg", "felt", "pelt", "apkt", "ipacket", "pcht", " pkh", "pkg", "Pet", "lpant", "Pcht", "puet", " pant", " pkid", "pkid", "ipnt", " pct", "promett", "tpdt", " pett", "pk", "epnt", "puacket", "Pct", "Pett", "cpkt", "fct", " pka", "lpacket", " pnt", "cpelt", "Pkg", "tpant", "Pkt", "Packet", " pelt", "epkh", " pk", "lpdt", "cpct", "lpcht", "pant", "apkid", "tpcht", "cpk", "pnt", "lpkid", "cpet", "promkt", " pqt", "epkt", " pkg", "prkt", " packet", "promet", "apacket", "pct", "pukt", "cpka", "ipkh", "pkh", "cpkg", "epka", "promacket", "ipkt", "fqt", "lpkt", "cpqt", " pet", "pdt", " pcht", "cpacket", "prcht", "pett", "packet", "pka", "pqt", "epk", "fkt", "apkg", "epacket", "pracket", " pdt"], "got_frame": [" Got_frame", "Got_pixel", "gotfframe", " got_class", "Got_frame", "gotaysample", "gotaypointer", "gotfpixel", " got_word", "Got_position", "got_sample", "gotfposition", "got_slot", "got_class", " Got_range", "given_sample", "got_fram", "given_line", "got_hole", "given_frame", "got_pointer", "given_pointer", "gotableframe", " got_hole", "gotablepointer", "got_word", "got_size", "got_range", "got_position", " Got_size", " got_slot", "got_line", "gotablesample", "Got_fram", "gotayline", " Got_fram", "got_pixel", "gotffram", "gotableline", "gotayframe"], "ret": ["pet", "used", "msg", "mt", "result", "bf", "alt", "back", "str", "debug", "rf", "num", "id", "res", "f", "art", "en", "ft", "arg", "data", "re", "ref", "fun", "db", "att", "sb", "val", "sur", "r", "lt", "reg", "cat", "fit", "flag", "part", "det", "match", "code", "valid", "rb", "status", "rets", "ext", "rc", "sec", "url", "rep", "value", "len", "RET", "opt", "rev", "feat", "slot", "gt", "nt", "active", "Ret", "format", "def", "fail", "error", "success", " RET", "bad", "function", "bit", "resp", "usr", "obj", "ut", "fin", "lit", "reply", "rl", "desc", "sat", "final", "rt"]}}
{"project": "qemu", "commit_id": "e8f1f9db8787be08e0ae3ed5a94da68966dbfff1", "target": 0, "func": "void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n", "idx": 4209, "substitutes": {"mon": ["mos", "mo", "pin", "mt", "mat", "mm", "mont", "amon", "mons", "monitor", "dom", "mut", "MON", "ann", "meter", "mi", "kin", "bean", "bo", "mn", "dim", "mand", "man", "m", "mr", "mor", "gin", "mot", "bro", "mc", "mag", "Mon", "bin", "lin", "mu", "mun", "dm", "con", "met"], "vlan_id": ["vLAN_ids", "vlan_address", "vpn_name", "vpn_ids", "vlan_name", "vlan_ids", "vLAN_id", "vpn_type", "vLAN_name", "vpn_id", "vLAN_address", "vlan_type"], "device": ["tag", "data", "scope", "object", "target", "package", "name", "value", "d", "domain", "component", "devices", "android", "connection", " dev", "type", "conn", "channel", "service", "password", "plugin", "Device", "ip", "mode", "dc", "address", "host", "prop", "attribute", "serial", "model", "mobile", "phy", "dev", "product", "user", "project", "item", "node", "attr", "feature", "direction", "addr", "unit", "driver", "directory", "spec", "port"], "vlan": ["vl", "Vla", " vlas", "evla", "vda", "vpn", "vslan", "vsla", "vla", "vlas", " vl", "svpn", "evda", "evlan", " vla", "evnic", "Vlas", " vnic", "Vda", "Vnic", "vsl", " vda", " vpn", "vsnic", "Vlc", "svlan", "evl", "Vlan", "Vpn", "svlas", "svlc", " vlc", "vlc", "vnic"], "vc": ["nc", "dn", "rc", "pc", "vm", "vd", "vp", "lv", "loc", "vr", "auth", "cc", "nv", "wx", "api", "ce", "ll", "client", "oc", "xc", "conn", "ct", "cs", "bb", "service", "cmd", "vid", "ic", "wl", "c", "wk", "ctx", "dc", "bc", "cci", "rec", "serv", "vt", "sn", "cv", "hw", "fc", "cu", "gt", "dev", "cf", "ga", "cn", "ci", "lc", "ac", "rl", "cp", "ant", "v", "vv", "wd", "VC", "rt"]}}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static void vfio_bar_write(void *opaque, hwaddr addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf.byte = data;\n\n        break;\n\n    case 2:\n\n        buf.word = cpu_to_le16(data);\n\n        break;\n\n    case 4:\n\n        buf.dword = cpu_to_le32(data);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported write size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d) failed: %m\",\n\n                     __func__, addr, data, size);\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d)\\n\",\n\n            __func__, bar->nr, addr, data, size);\n\n\n\n    /*\n\n     * A read or write to a BAR always signals an INTx EOI.  This will\n\n     * do nothing if not pending (including not in INTx mode).  We assume\n\n     * that a BAR access is in response to an interrupt and that BAR\n\n     * accesses will service the interrupt.  Unfortunately, we don't know\n\n     * which access will service the interrupt, so we're potentially\n\n     * getting quite a few host interrupts per guest interrupt.\n\n     */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n}\n", "idx": 4211, "substitutes": {"opaque": ["plaques", "opaco", "plc", "OPaco", "OPec", " opca", "opacity", "OPc", "Opec", "opaques", " opec", "Opaque", "OPaque", "opc", "OPca", "OPacity", "OPaques", " opaco", "placo", "plaque", " opacity", "opca", "Opca", " opc", " opaques", "Opacity", "opec"], "addr": ["pos", "nc", "rc", "frame", "ada", "ref", "oa", "url", "area", "index", "ady", "asm", "name", "ord", "len", "server", "rx", "adr", "src", "args", "adder", "Address", "pad", "amd", "ace", "offset", "r", "config", "id", "ip", "word", "mode", "add", "layer", "address", "host", "pointer", "start", "nr", "part", "coord", "ad", "filename", "uri", "code", "dr", "amp", "attr", "alias", "ptr", "align", "x", "base"], "data": ["batch", "ui", "extra", "pos", "ada", "index", "da", "reader", "number", "bus", "DATA", "value", "input", "d", "name", "Data", "len", "val", "raw", "byte", "api", "base", "done", "pad", "offset", "image", "config", "empty", "bytes", "device", "id", "video", "block", "dd", "mode", "alpha", "address", "buffer", "next", "shift", "space", "array", "padding", "start", "a", "partial", "cache", "i", "ad", "prefix", "memory", "code", "uri", "la", "valid", "length", "null", "missing", "zero", "align", "work", "window", "format", "dat"], "size": ["complete", "pos", "extra", "storage", "from", "sec", "small", "end", "number", "scale", "error", "name", "e", "loc", "enc", "len", "false", "raw", "sync", "args", "function", "esc", "offset", "SIZE", "config", "empty", "bytes", "large", "ize", "mode", "c", "sized", "Size", "ctx", "address", "g", "shift", "send", "capacity", "sn", "max", "en", "a", "code", "cap", "shape", "length", "handle", "six", "count", "zero", "align", "handler"], "bar": ["batch", "br", "worker", "gar", "bag", "Bar", "ab", "queue", "db", "loader", "result", "browser", "hub", "camp", "row", "server", "container", "hand", "aer", "client", "bridge", "bug", "broad", "var", "arrow", "ker", "ba", "home", "cart", "cur", "bc", "bg", "buffer", "host", "consumer", "gap", "array", "cat", "foo", "mac", "cam", "bin", "cache", "parent", "ca", "project", "ga", "border", "cap", "job", "ac", "jar", "board", "b", "fac", "feature", "tab", "com", "bars", "ha", "work", "window", "car", "far", "base"], "buf": ["batch", "pb", "wb", "br", "uc", "rc", "lb", "abb", "func", "bag", "proc", "result", "queue", "ab", "loc", "Buffer", "fi", "src", "seq", "box", "config", "vec", "fw", "runner", "fb", "block", "obj", "buff", "aux", "home", "grab", "ctx", "bc", "buffer", "console", "cat", "foo", "cv", "alloc", "comb", "border", "cap", "uf", "bd", "ff", "rb", "cas", "board", "cb", "cp", "feed", "window", "port"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf5208evb_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    target_phys_addr_t entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"m5208\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_init_ram(ram, \"mcf5208.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, \"mcf5208.sram\", 16384);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, env);\n\n\n\n    mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used)\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, ELF_MACHINE, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 4213, "substitutes": {"args": ["aws", "am", "ras", "apps", "parts", "lines", "enc", "ae", "plugins", "arr", "acl", "ks", "api", "params", "resources", "atts", "gs", "empty", "config", "cs", "ands", "cmd", "plugin", "Args", "ass", "states", "ids", "sg", "init", "actions", "aux", "fields", "g", "arms", "ig", "assets", "ams", "parse", "ants", "vals", "flags", "alloc", "words", "ac", "arg", "ins", "Arg", "parser", "utils"], "cpu_model": ["cpu\u00b7controller", "cpu_module", "cpu\u00b7mode", "cpuingmodule", "cpu\u00b7address", "cpuingmanager", "cpu_network", "core_channel", "gpu_folder", "gpu_address", "cpu_lock", "cpu_folder", "cpu\u00b7model", "core_module", "gpu_module", "kernel_model", "cpu_channel", "cpu_manager", "cpu_address", "kernel_lock", "core_manager", "cpu\u00b7lock", "core_model", "cpu_mode", "cpu_controller", "cpu\u00b7folder", "kernel_controller", "cpuingmodel", "cpu_models", "gpu_model", "gpu_mode", "gpu_network", "cpuingchannel", "kernel_mode", "gpu_models"], "kernel_filename": ["kernelpfilename", "kernelpfile", "linux_file", "kernelbooklocation", "kernel__filename", "kernel_location", "cpu_filename", "kernelbookfile", "kernel_model", "kernel__location", "kernel__file", "linux_model", "kernelbookmemory", "kernelpconfig", "kernelbookfilename", "linux_config", "kernel__memory", "kernel_memory", "kernelpmodel", "kernel_file", "kernel_config", "cpu_file", "cpu_memory", "cpu_location", "linux_filename"], "env": ["context", "scope", "ext", "vm", "eu", "profile", "np", "proc", "db", "loader", "e", "skin", "enc", "exc", "equ", "core", "export", "ea", "session", "app", "energy", "conn", "vs", "image", "img", "config", "ev", "kernel", "viron", "dict", "inventory", "file", "obj", "enable", "txt", "ass", "eye", "her", "net", "init", "ctx", "bg", "ig", "shell", "console", "Environment", "en", "network", "ec", "cache", "err", "global", "iv", "esp", "manager", "gui", "dev", "eni", "priv", "conf", "v", "environment", "si"], "kernel_size": ["kernel64capacity", " kernel_mode", "kernel_capacity", " kernel_capacity", "kernel64size", "kernel64mode", "kernel_mode"], "elf_entry": ["ramalentry", "ramalreader", "elf_reader", "ram_row", "ramalslice", "ram_reader", "ramalrow", "elf_row", "ram_entry", "ram_slice", "elf_slice"], "entry": ["data", "icle", "index", "field", "view", "card", "row", "byte", "arr", "ry", "record", "image", "ii", "uple", "par", "vec", "file", "array", "parse", "ries", "info", "nt", "count", "ensor", "cell", "Entry", "base"], "pic": ["bi", "sci", "pen", "pick", "pc", "pi", "pin", "proc", "capt", "bus", "pins", "Pic", "piece", "mini", "circ", "jc", "fi", "cli", "sys", "typ", "sync", "ku", "quad", "cus", "style", "lic", "kin", "seq", "image", "pict", "nic", "qi", "config", "img", "git", "vec", "lib", "ic", "jp", "cy", "picture", "ctx", "bc", "cpu", "study", "ig", "mot", "pass", "console", "scan", "mag", "kit", "feat", "cache", "fc", "bin", "tick", "lin", "gui", "xi", "mic", "lc", "jack", "ics", "pres", "feature", "cycle", "doc", "lot", "spec"], "address_space_mem": ["address_spacextem", "address_pace_tem", "address_pace_ram", "address_spacelmem", "address_spacelreg", "address_x", "address_pace_loc", "address_surface_reg", "address_spacexmm", "address_spacebootmem", "address_space_program", "address_space___rom", "machine_x", "address_spacelmm", "address_pace_lim", "address_surface___mm", "address_spacealram", "address_pace_memory", "address_space___mm", "address_service_mode", "address_space_gram", "address_surface___rom", "address_surface_mm", "address_space_reg", "address_space___mem", "address_service_mm", "address_pace_program", "address_space_rom", "address_spacealprocess", "address_spacealmem", "address_pace_rm", "address_service_mem", "address_spacealprogram", "address_space_tem", "machine_\n", "address_pace_process", "address_surface___mem", "address_space_loc", "address_service_rm", "address_spacexmem", "address_pace_mm", "address_space_mm", "address_spacelrom", "address_\n", "address_space_ram", "address_surface_rom", "address_pace_mem", "address_space_rm", "address_space_process", "address_surface_mem", "address_space_memory", "address_space_lim", "address_surface___reg", "address_spacebootlim", "address_space___reg", "address_spacebootgram", "address_space_mode", "address_spacebootram"], "ram": ["nam", "sum", "vm", "pc", "ruby", "am", "sam", "rum", "region", "mm", "core", "mem", "sys", "rg", "gam", "program", "arm", "sc", "image", "cm", "jam", "dim", "gram", "man", "gem", "ctx", "mor", "space", "micro", "sim", "mc", "mac", "cam", "RAM", "rage", "hw", "lam", "iam", "rar", "Ram", "memory", "ray", "gra", "rw", "ra", "pack", "process", "dam", "disk", "resource"], "sram": ["ssgram", "absmem", "sescam", "abscam", "asram", "dsram", "Sgram", "absram", "sgram", "dsgram", " siam", "fmem", "ssmem", "dsmem", "siam", "asran", "sesgram", "Srum", "sesregion", " sallow", " sgram", "fgram", "Sram", "asiam", "ssallow", " sran", "ssrum", " srum", "ssregion", "sesram", "scam", "ssran", "sesmem", "sallow", "sran", "fram", "dsregion", "ssram", "fcam", "sregion", "srum", "asgram", "smem", "absgram", "ssiam", "Sallow"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4217, "substitutes": {"ctxt": ["ptxt", "cfXT", "pttxt", "cfext", "ptext", "CTxt", "cftxt", "cfxt", "ctext", "CTXT", "ptXT", "CText", "ctXT", "cttxt", "CTtxt"], "ap": ["av", "data", "context", "ak", "archive", "np", "oa", "xml", "au", "aj", "ab", "apa", "ae", "aval", "auth", "af", "tp", "op", "p", "arr", "acl", "api", "map", "pod", "AP", "app", "awa", "ep", "pa", "sp", "jp", "ip", "hap", "lex", "lap", "snap", "ctx", "Ap", "address", "gap", "ax", "apy", "array", "apper", "apache", " AP", "aps", "esp", "al", "aper", "ar", "amp", "tap", "apt", "ape", "cap", "apped", "bp", "ac", "attr", "pac", "aped", "arp", "nav", "cp", "ha", " sap"], "token": ["tag", "root", "data", "ak", "an", "oken", "fn", "object", "note", "translation", "seed", "target", "number", "error", "Token", "text", "element", "cho", "annot", "tool", "key", "len", "document", "call", "event", "rule", "quote", "session", "type", "stop", "KEN", "socket", "channel", "offset", "service", "stat", "sign", "cookie", "word", "child", "lex", "not", "t", "aa", "writer", "parent", "tick", "wt", "o", "kn", "prefix", "user", "atom", "item", "valid", "node", "iter", "tree", "po", "resource", "ant"], "val": ["data", "vl", "pos", "split", "ref", "cal", "vale", "eval", "au", "value", "sel", "aval", "label", "text", "name", "na", "pl", "key", "len", "fi", "str", "li", "p", "ol", "op", "ul", "rule", "true", "bl", "loc", "pr", "pa", "elt", "tx", "var", "ctx", "lat", "Val", "il", "pt", "vol", "serv", "lit", "cel", "vals", "el", "part", "sl", "VAL", "al", "pol", "rt", "valid", "b", "arg", "format", "ot", "doc", "unit", "v", "fl", "x", "base"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline uint64_t ldq_phys_internal(hwaddr addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 4218, "substitutes": {"addr": ["frame", "np", "mt", "name", "vr", "rx", "arm", "slice", "adder", "amd", "pad", "ace", "ack", "cmd", "id", "ip", "add", "ar", "grad", "wd", "asm", "data", "oa", "ref", "offset", "module", "r", "config", "rn", "mode", "inter", "layer", "address", " address", "start", "nr", "part", "size", "edge", "ext", "rc", "url", "ady", "rss", "len", "conn", "host", "ad", "xp", "amp", "route", "cmp", "align", "work", "access", "spec", "x", "adr", "rm", "ord", "src", "usr", "rr", "obj", "dd", "pointer", "hop", "coord", "dr", "md", "node", "attr", "alias", "rt"], "endian": ["endius", "enerial", "engians", "endedians", "endedian", "endsip", " endius", "endsians", "endians", "endial", "endedip", "endedator", " endial", "endip", "enerian", "endsian", "enerians", "endsator", " endians", "endsius", "endator", "engip", "enerius", "engator", "engian", "endsial"], "ptr": ["py", "pos", "br", "pb", "pc", "rc", "index", "ref", "proc", "eval", "eth", "loc", "bf", "uint", "len", "p", "arr", "src", "slice", "pair", "type", "buf", "pad", "peer", "offset", "pr", "cod", "r", "ctr", "dim", "Ptr", "plug", "buff", "butt", "fd", "inter", "ctx", "pend", "address", "pt", "tr", "pointer", "buffer", "kt", "point", "inst", "cel", "alloc", "code", "dr", "pe", "rect", "attr", "length", "handle", "grad", "cmp", "td", "driver", "adr", "rt"], "val": ["pc", "eval", "result", "aval", "alt", "vel", "bl", "vol", "el", "VAL", "ver", "b", "arg", "count", "serv", "unit", "v", "li", "data", "ref", "cond", "db", "key", "call", "test", "lt", "ind", "reg", " ret", "Val", "a", "part", "valid", "ee", "util", "base", "cal", "pre", "value", "fat", "len", "p", "style", "win", "lib", "all", "pt", "pass", "slot", "sl", "it", "al", "x", "format", "py", "end", "fail", "play", "loc", "ol", "pid", "l", "obj", "ctx", "vals", "err", "dev", "live", " Val", "sel", " data", "ret", "rt"], "section": ["root", "data", "layout", "member", "storage", "sec", "small", "area", "set", "package", "ner", "loc", "region", "division", "fat", "component", "key", "Section", "core", "server", "container", "connection", "slice", "session", "pair", "function", "search", "sc", "site", "module", "account", "vision", "patch", "config", "service", "sections", "cell", "ment", "environment", "option", "sect", "child", "instance", "ion", "setting", "sector", "entry", "version", "address", "description", "character", "location", "comment", "mod", "network", "group", "part", "parent", "se", "journal", "script", "sub", "lc", "shadow", "six", "sel"]}}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "func": "void main_loop_wait(int nonblocking)\n\n{\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n    int timeout;\n\n\n\n    if (nonblocking)\n\n        timeout = 0;\n\n    else {\n\n        timeout = qemu_calculate_timeout();\n\n        qemu_bh_update_timeout(&timeout);\n\n    }\n\n\n\n    os_host_main_loop_wait(&timeout);\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    qemu_run_all_timers();\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "idx": 4221, "substitutes": {"nonblocking": ["notlocking", "nonlinear", "nonlocking", " nonlocking", " Nonlinear", " Nonlocking", " nonlinear", "Nonblocking", "nonblock", " Nonblocking", " Nonblock", "notlinear", "notblocking", " nonblock", "Nonlocking", "notblock", "Nonblock"], "rfds": ["sfds", "rafdb", "rfdds", "rbdd", "rbDS", "xfDS", "rafd", "RFys", "sfdds", "refdb", "rbds", "xfda", "alfds", "alfdb", "xfys", "fwrs", "rbdb", "fda", "rfda", "rafda", "xfd", "lfds", "fwds", "lfys", "rfdd", "fd", "RFrs", "fds", "xfdd", "rfys", "RFd", "refds", "refdd", "rafDS", "alfDS", "sfys", "lfDS", "RFda", "fdds", "frs", "rafdd", "lfd", "fys", "rfDS", "rfrs", "RFdds", "alfda", "rfdb", "rfd", "fDS", "rafds", "fwd", "fwdds", "sfd", "RFds", "xfdb", "sfda", "refd", "rbd"], "wfds": ["swcfrd", "swfdds", "wrfda", "wcfrs", "wfsys", "wwxfcs", "wxfcs", " wfsda", " wfsns", "wcfds", "wwfds", "wdfcs", "wwxfds", "wxfdds", " wfsdds", " wfsays", "wfsks", "swcfdds", " wfsrd", "wfsords", "wwfords", "wfsns", " wfays", "wtfdds", "wrfds", "wFds", "wfsrd", "wcfdds", "wsfys", " wfsds", "wdfks", "wcfys", "wtfrd", "wfrd", " wfsys", "wfsdds", "wFys", " wfda", "wfys", "wsfrd", "wxfords", "swfys", "wfns", "wxfks", "wdfords", " wfrd", "wfsda", "wtfys", "wfcs", "wFda", "wxfds", "wfdds", " wfsrs", "swfds", " wfdds", "wwfks", "wwxfords", "wrfdds", "wrfys", "wcfns", "wfks", "wrfns", "wsfds", "wrfrs", "wxfays", "wfsds", "wdfds", "wfsays", "wtfds", "wsfdds", "swcfds", "wfda", "wfscs", " wfns", "wfays", "wfsrs", "wwfcs", "swcfys", "wwxfks", "wfords", "wxfys", "swfrd", "wFdds", " wfrs", "wfrs", "wrfays", " wfys", "wcfrd"], "xfds": ["sfds", "rafdb", "rfords", "cfords", "rfdds", "xfDS", "cfipes", "xfdds", "xfded", "xfld", "cfDS", "xfda", "sfdds", "fxdd", "fxipes", "fxades", "cfdds", "rfda", "fxDS", "xfd", "cfds", "rafdds", "fxded", "rfdd", "cfades", "xfords", "rfld", "rfipes", "fxdds", "xfades", "xfdd", "rfded", "rafded", "rafDS", "rfades", "cfda", "rafld", "fxds", "fxords", "rafdd", "sfDS", "rfDS", "rfdb", "rfd", "xfipes", "sfd", "rafds", "fxld", "sfdb", "xfdb", "fxd", "sfda", "cfd"], "ret": ["pet", "re", "rc", "ref", "def", "result", "success", "fun", "alt", "error", "att", "try", "len", "val", " Ret", "mem", "event", "num", "RET", "resp", "out", "response", "res", "obj", "temp", "inter", "rev", "lit", "req", "part", "err", "det", "ft", "match", "reply", "nt", "job", "trial", "live", "iter", "format", "status", "count", "round", "red", "rets", "Ret", "rt"], "nfds": ["wfd", "ncfd", "nrfd", "ntfds", "nufys", " nrfds", " nrfda", "ncfdds", "wrfd", " nfdds", "nfbds", "nfbdds", "nrfnas", "Ncfdds", "nfcs", "Nfdb", "ncfns", "nrfcs", "ncfys", "nwns", "nrfds", "nfbdb", "nfys", "Nfdds", "ntfdy", "Ncfns", "nfdy", "wrfds", "ncfld", "nfdb", " nrfcs", "ncfnas", "nxfdds", "ncfds", "wfld", "Ncfds", " nrfdds", "nrfdds", "Nfns", "wfys", "nxfda", "nufld", "nxfds", "nfd", "nsfcs", "nsfds", "ntfdds", "nfda", "nfbns", "nrfda", "wfdds", "nrfdy", "Nfds", "nrfys", " nrfnas", "ncfdb", "wrfdds", "wrfys", " nfnas", "wrfld", "nfld", "nrfld", "wfdy", "ncfdy", "Ncfdb", " nfda", "nufds", "nfdds", "nxfcs", " nfcs", "nwds", "nfnas", "nufd", "nwdds", "nsfda", "wrfdy", "nfns", "nufnas", " nrfd", "nwdb", " nfd", "nufdds", "ntfd", "nsfdds"], "tv": ["volt", "vm", "timer", "vv", "lv", "show", "TV", "exec", "val", "youtube", "fi", "server", "tty", "event", "vi", "up", "html", "test", "tun", "channel", "ev", "tt", "config", "video", "txt", "temp", "inter", "t", "tmp", "uv", "rev", "tm", "vt", "cv", "ssl", "json", "info", "dev", "loop", "tc", "stream", "twitter", "live", "sv", "rt", "ov", "qt", "time", "cb", "tf", "vc", "select", "td", "v", "window", "tz"], "timeout": ["pool", "root", "ticket", "seed", "timer", "Timeout", "number", "tube", "second", "sleep", "error", "value", "limit", "frequency", "len", "server", "event", "sync", "interrupted", "connection", "clock", "type", "socket", "beta", "offset", "tun", "out", "unit", "tt", "service", "n", "option", "block", "temp", "until", "init", "t", "period", "boot", "buffer", "range", "io", "duration", "blocking", "slot", "cache", "parent", "i", "table", "rate", "size", "scroll", "fee", "nt", "delay", "trial", "length", "time", "wait", "lock", "window", "token"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4253, "substitutes": {"errp": ["errpb", "erP", "errr", " errpb", "rarpb", "raiseP", "erp", "erc", " errpc", "errP", "erpc", "rarr", "erlp", "rarp", "raiselp", "errpc", " errP", "rarc", " errr", "err", " errc", "errlp", "raisep", " errlp", "erpb", "errc", "raisepc"], "bs": ["bi", "pb", "lb", "gb", "sb", "bid", "bos", "sync", "blocks", "BS", "ls", "src", "bl", "ps", "is", "vs", "ses", "cs", "bb", "bytes", "ds", "lib", "fb", "obj", "s", "abi", "ss", "bes", "ba", "css", "ctx", "bc", "bg", "fs", "banks", "ns", "boot", "ib", "bis", "as", "kit", "its", "bh", "bits", "bp", "state", "b", "ins", "bt", "os", "bps", "rs", "bas", "base"], "local_err": ["localOerr", "localacrr", "localOer", "global_error", "local_ver", " local_state", "local_er", "localOstate", "localserr", "localserror", "local_bug", " local_error", "global_err", "localacerr", " local_ver", "local_state", "local_msg", "localacer", " local_er", "local_error", " local_rr", "global_msg", "localOerror", "local_rr", "localser", "localacver", "localsbug", "global_er", " local_bug"], "it": ["section", "j", "end", "loc", " It", "exec", "op", "p", "ul", "and", "mit", "jit", "bit", "ibl", "edit", "IT", "ind", "id", "l", "ip", "c", "init", "entry", "ant", "ait", "which", "ib", "lit", "sit", "start", "iti", "bin", "axis", "i", "parent", "its", "pit", "It", "ci", "iterator", "in", "iter", "ins", "ite", "chain", "unit", "bas", "stat"], "aio_context": ["aio_version", "aio_connection", "aiojcontext", "aio__connection", "aioacctx", "aio_proxy", "aios_support", "aioacversion", "aioaccontext", "aiojctx", "aios_config", "aios_ctx", "aios_context", "aio__support", "aio_config", "aiojconfig", "aios_connection", "aio__context", "aios_temp", "aio__ctx", "aios_proxy", "aio_support", "aioactemp", "aio_ctx", "aiojproxy", "aio_temp", "aios_version"]}}
{"project": "FFmpeg", "commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "target": 1, "func": "static int parse_adaptation_sets(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    char *p = w->adaptation_sets;\n\n    char *q;\n\n    enum { new_set, parsed_id, parsing_streams } state;\n\n    if (!w->adaptation_sets) {\n\n        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 4255, "substitutes": {"s": ["an", "sci", "new", "sq", "e", "si", "sb", "self", "sync", "S", "ps", "sc", "ses", "cs", "r", "gs", "service", "u", "ds", "stats", "n", "ss", "c", "m", "ts", "t", "sg", "services", "rs", "fs", "g", "f", "ns", "sa", "ssl", "se", "sl", "o", "less", "sv", "su", "b", "js", "http", "os", "serv", "v", "south", "spec"], "w": ["new", "wb", "y", "k", "wcs", "e", "d", "way", "wm", "wr", "self", "wall", "wx", "wn", "W", "widget", "kw", "wo", "h", " W", "r", "this", "win", "u", "current", "fw", "n", "wl", "l", "word", "c", "wal", "m", "t", "wan", "web", "g", "f", "tw", "nw", "wa", "wei", "wu", "wp", "ow", "hw", "a", "we", "war", "writer", "wt", "ww", "wave", "iw", "wh", "sw", "rw", "b", "ew", "aw", "work", "v", "window", "wd", "x"], "p": ["pat", "pos", "y", "pc", "pi", "k", "np", "j", "vp", "pre", "e", "d", "pg", "tp", "op", "api", "pid", "h", "ps", "pad", "pair", "pr", "ep", "r", "patch", "pa", "dp", "sp", "u", "P", "n", "l", "ip", "per", "ap", "jp", "press", "m", "c", "t", "g", "f", "pp", "point", "ping", "a", "part", "i", "lp", "python", "pe", "bp", "z", "b", "post", "po", "fp", "cp", "v", "x", "port"], "q": ["depth", "y", "k", "sq", "end", "queue", "e", "d", "name", "question", "que", "eq", "iq", "h", "dq", "qi", "qs", "r", "ch", "u", "query", "sp", "ue", "id", "n", "P", "quality", "ip", "l", "qu", "c", "m", "sh", "t", "quick", "quant", "ix", "g", "f", "cl", "max", "qa", "Q", "quest", "req", "i", "ph", "qq", "pe", "z", "qt", "post", "count", "v", "x", "port"], "state": ["tag", "an", "are", "new", "y", "k", "private", "j", "am", "name", "e", "param", "key", "val", "self", "rule", "slice", "session", "style", "type", "pair", "un", "is", "ace", "conn", "old", "position", "ch", "config", "current", "u", "at", "stat", "id", "STATE", "State", "states", "m", "instance", "step", "t", "st", "cur", "g", "f", "art", "wa", "start", "a", "part", "parent", "err", "o", "al", "pe", "handle", "post", "po", "count", "resource", "ke", "work", "ate", "after", "port"], "mem": ["em", "pool", "mo", "sum", "vm", "ref", "am", "mm", "rm", "mat", "val", "mb", "du", "program", "bm", "buf", "mi", "num", "prom", "sp", "reg", "lim", "ip", "dim", "gram", "qu", "buff", "temp", "m", "sh", "Mem", "ram", "ctx", " Mem", "mor", "tm", "mc", "mod", "max", "hw", "rom", "bin", "cache", "ph", "im", "memory", "rem", "node", "ha", "access"], "as": ["from", "ans", "to", "with", "d", "er", "args", "num", "acs", "res", "asa", "ar", "has", "asm", "mas", "are", "an", "pas", "ase", "am", "ais", "ast", "auth", "nas", "app", "cs", "this", "r", "ap", "asc", "ss", "ts", "ns", "sa", "modules", "a", "was", "ac", "es", "ins", "http", "ai", "bas", "las", "ras", "asu", "parts", "ks", "atts", "gs", "ays", "ass", "As", "var", "instance", "all", "action", "ams", "inas", "us", "_", "ma", "al", "ra", "bs", "access", "rs", "x", "asts", "aws", "is", "seq", "at", "ask", "ars", "ance", "ms", "array", "master", "als", "cache", "pack", "cas", "alias", "com", "os", "AS"], "nb_as": ["nbNas", "nb25ase", "num_asc", "nb25ras", "nb_asu", "nb_sa", "nb_AS", "nbBas", "nbNras", "nb__as", "nblockas", "nblockwas", "nbBras", "num_mas", "nbllwas", "nb_an", "nb_nas", "nb25as", "nbllras", "sblockras", "nbBmas", "num_was", "sb_as", "sblockwas", "num_ras", "sb_was", "nb__asc", "num_nas", "nb__AS", "nb_asc", "num_ase", "num_asu", "nbJmas", "nb_mas", "nblockras", "nbllasu", "sb_ras", "nbNan", "num_as", "nb_was", "nblockasu", "nbllas", "nb25an", "nb_ras", "nb__sa", "sblockas", "nb__ras", "sblockasu", "num_sa", "nbJwas", "num_an", "num_AS", "nbJas", "nb__was", "nb_ase", "nbBasu", "nbJras", "sb_asu", "nbJAS", "nbNase", "nbJnas"]}}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}", "idx": 4256, "substitutes": {"ctxt": ["actct", "ptext", "ctert", "CTert", "actxt", "CTx", "cttxt", "catxt", "acttxt", "ctct", "CTxt", "actrt", "CTct", "ctrt", "catext", "ntrt", "catx", "ptxt", "pttxt", "ctx", "nttxt", "cattxt", "CText", "ntext", "actext", "CTrt", "CTtxt", "ntert", "actert", "ctext", "actx", "ntct", "ptx", "ntxt"], "token": ["note", "fn", "header", "target", "result", "Token", "text", "element", "name", "KEN", "type", "column", "pattern", "tree", "normal", "context", "root", "data", "seed", "tool", "key", "call", "rule", "quote", "channel", "bot", "stage", "txt", "t", "path", "start", "valid", "null", "iter", "ok", "status", "oken", "number", "value", "cho", "annot", "document", "track", "open", "connection", "session", "sign", "cookie", "option", "word", "lex", "opt", "pass", "comment", "wt", "prefix", "atom", "resource", "tag", "complete", "scope", "date", "field", "tn", "event", "variable", "stop", "socket", "request", "version", "tick", "reference", "o", "user", "node", "attr", "po", "stat"], "ret": ["complete", "data", "hash", "ext", "re", "ref", "url", "def", "mt", "result", "db", "fun", "alt", "att", "success", "auth", "get", "key", "val", " Ret", "fi", "mem", "aug", "arr", "base", "true", "conn", "RET", "bot", "reg", "usr", "obj", "res", "fin", "rev", "lit", "cat", "flag", "feat", "gt", "det", "ft", "utf", "match", "reply", "job", "valid", "pret", "arg", "format", "active", "rets", "Ret", "rt"]}}
{"project": "FFmpeg", "commit_id": "5b29af624fe8be5379fd649019a04ff44bfde04f", "target": 0, "func": "static int aac_encode_frame(AVCodecContext *avctx,\n\n                            uint8_t *frame, int buf_size, void *data)\n\n{\n\n    AACEncContext *s = avctx->priv_data;\n\n    int16_t *samples = s->samples, *samples2, *la;\n\n    ChannelElement *cpe;\n\n    int i, j, chans, tag, start_ch;\n\n    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];\n\n    int chan_el_counter[4];\n\n    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n    if (data) {\n\n        if (!s->psypp) {\n\n            memcpy(s->samples + 1024 * avctx->channels, data,\n\n                   1024 * avctx->channels * sizeof(s->samples[0]));\n\n        } else {\n\n            start_ch = 0;\n\n            samples2 = s->samples + 1024 * avctx->channels;\n\n            for (i = 0; i < chan_map[0]; i++) {\n\n                tag = chan_map[i+1];\n\n                chans = tag == TYPE_CPE ? 2 : 1;\n\n                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,\n\n                                  samples2 + start_ch, start_ch, chans);\n\n                start_ch += chans;\n\n            }\n\n        }\n\n    }\n\n    if (!avctx->frame_number) {\n\n        memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n               1024 * avctx->channels * sizeof(s->samples[0]));\n\n        return 0;\n\n    }\n\n\n\n    start_ch = 0;\n\n    for (i = 0; i < chan_map[0]; i++) {\n\n        FFPsyWindowInfo* wi = windows + start_ch;\n\n        tag      = chan_map[i+1];\n\n        chans    = tag == TYPE_CPE ? 2 : 1;\n\n        cpe      = &s->cpe[i];\n\n        for (j = 0; j < chans; j++) {\n\n            IndividualChannelStream *ics = &cpe->ch[j].ics;\n\n            int k;\n\n            int cur_channel = start_ch + j;\n\n            samples2 = samples + cur_channel;\n\n            la       = samples2 + (448+64) * avctx->channels;\n\n            if (!data)\n\n                la = NULL;\n\n            if (tag == TYPE_LFE) {\n\n                wi[j].window_type[0] = ONLY_LONG_SEQUENCE;\n\n                wi[j].window_shape   = 0;\n\n                wi[j].num_windows    = 1;\n\n                wi[j].grouping[0]    = 1;\n\n            } else {\n\n                wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel,\n\n                                              ics->window_sequence[0]);\n\n            }\n\n            ics->window_sequence[1] = ics->window_sequence[0];\n\n            ics->window_sequence[0] = wi[j].window_type[0];\n\n            ics->use_kb_window[1]   = ics->use_kb_window[0];\n\n            ics->use_kb_window[0]   = wi[j].window_shape;\n\n            ics->num_windows        = wi[j].num_windows;\n\n            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];\n\n            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];\n\n            for (k = 0; k < ics->num_windows; k++)\n\n                ics->group_len[k] = wi[j].grouping[k];\n\n\n\n            apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2);\n\n        }\n\n        start_ch += chans;\n\n    }\n\n    do {\n\n        int frame_bits;\n\n        init_put_bits(&s->pb, frame, buf_size*8);\n\n        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))\n\n            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n\n        start_ch = 0;\n\n        memset(chan_el_counter, 0, sizeof(chan_el_counter));\n\n        for (i = 0; i < chan_map[0]; i++) {\n\n            FFPsyWindowInfo* wi = windows + start_ch;\n\n            tag      = chan_map[i+1];\n\n            chans    = tag == TYPE_CPE ? 2 : 1;\n\n            cpe      = &s->cpe[i];\n\n            put_bits(&s->pb, 3, tag);\n\n            put_bits(&s->pb, 4, chan_el_counter[tag]++);\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]);\n\n                s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda);\n\n            }\n\n            cpe->common_window = 0;\n\n            if (chans > 1\n\n                && wi[0].window_type[0] == wi[1].window_type[0]\n\n                && wi[0].window_shape   == wi[1].window_shape) {\n\n\n\n                cpe->common_window = 1;\n\n                for (j = 0; j < wi[0].num_windows; j++) {\n\n                    if (wi[0].grouping[j] != wi[1].grouping[j]) {\n\n                        cpe->common_window = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            s->cur_channel = start_ch;\n\n            if (cpe->common_window && s->coder->search_for_ms)\n\n                s->coder->search_for_ms(s, cpe, s->lambda);\n\n            adjust_frame_information(s, cpe, chans);\n\n            if (chans == 2) {\n\n                put_bits(&s->pb, 1, cpe->common_window);\n\n                if (cpe->common_window) {\n\n                    put_ics_info(s, &cpe->ch[0].ics);\n\n                    encode_ms_info(&s->pb, cpe);\n\n                }\n\n            }\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n\n            }\n\n            start_ch += chans;\n\n        }\n\n\n\n        frame_bits = put_bits_count(&s->pb);\n\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n\n            break;\n\n        }\n\n\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n\n\n    } while (1);\n\n\n\n    put_bits(&s->pb, 3, TYPE_END);\n\n    flush_put_bits(&s->pb);\n\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n\n\n    // rate control stuff\n\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n\n        s->lambda *= ratio;\n\n        s->lambda = FFMIN(s->lambda, 65536.f);\n\n    }\n\n\n\n    if (!data)\n\n        s->last_frame = 1;\n\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n           1024 * avctx->channels * sizeof(s->samples[0]));\n\n    return put_bits_count(&s->pb)>>3;\n\n}\n", "idx": 4260, "substitutes": {"avctx": ["ajcomp", "aphctx", "aveca", "avecu", "avloc", "avconfig", "afctx", "ajcontext", "afcontainer", "evcu", "avca", "ajloc", "airmac", "ajlc", "afmac", "alctl", "aveloc", "afloc", "apca", "avecca", "ajconnection", "avemath", "aphcontext", "ajcontainer", "apctx", "avecontext", "afscope", "afconnection", " avloc", "afconn", "avconnection", "afcu", "evctx", "AVctx", "afctl", "aflc", "AVlc", "afcca", "evcontext", " avcomp", "aveconfig", "alctx", "avcontext", "avectl", "aveconn", "avconn", "ajcca", "avcontainer", "avcca", "aircu", "aircontext", "avcomp", "ajscope", "ajconn", "AVcontext", "aphconnection", "abcontext", "alloc", "aphscope", "ajctx", "apcu", "evmac", "avscope", "alcontext", "avcu", "afconfig", " avcontext", "ajmath", "avmac", "AVloc", "avctl", "afcontext", "avlc", "apcontext", "abctx", "abconfig", "afcomp", "airctx", "afmath", "avectx", "afca", "avmath", "avecontainer", "abcca"], "frame": ["fps", "scale", "frames", "document", "game", "event", "slice", "iframe", "seq", "image", "channel", "config", "meta", "video", "buffer", "f", "draw", "Frame", "fram", "code", "series", "state", "board", "time", "setup", "body", "window"], "buf_size": ["buflensize", "buf2capacity", "buf_capacity", "buf64scale", " buffer_shape", "buf64size", "buflenshape", " buffer_scale", "buf64shape", " buffer_capacity", "buf64capacity", " buffer2shape", "buflencapacity", " buffer2capacity", "buf2size", "buf2scale", " buffer2scale", " buffer2size", " buffer_size", "buf_scale", "buf2shape", "buflenscale", "buf_shape"], "data": ["complete", "batch", "ui", "ada", "da", "callback", "sample", "scale", "final", "di", "DATA", "result", "input", "d", "na", "message", "Data", "len", "multi", "none", "p", "ata", "zip", "base", "done", "slice", "function", "session", "pad", "image", "channel", "empty", "bytes", "response", "block", "video", "alpha", "repeat", "buffer", "f", "shift", "next", "draw", "as", "array", "start", "a", "partial", "cache", "media", "size", "memory", "append", "results", "body", "binary", "window", "dat"], "s": ["d", "sync", "args", "ops", "sg", "services", "fs", "f", "space", "sv", "b", "conf", "v", "sites", "sq", "sb", "params", "ses", "cs", "this", "r", "u", "sf", "ss", "ts", "t", "ns", "sa", "a", "its", "sis", "es", "http", "ins", "parts", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "n", "c", "g", "us", "ssl", "series", "su", "bs", "qs", "rs", "si", "sci", "y", "aws", "e", "server", "is", "sc", "support", "service", "ds", "l", "states", "sym", "m", "ctx", "ms", "as", "secondary", "js", "setup", "eps", "os", "stat"], "samples": ["pamps", "sample", "champles", " sourses", "dources", "tamples", "insamples", "sides", " sides", "nases", "sones", "tummies", "insannels", "laces", "inases", "sclasses", "slounds", "nannels", "inones", "namps", "chones", "inamples", "damples", "samps", " sample", "lamples", "issamples", "chases", "lamps", " summies", "Sources", "lannels", "issannels", "sframes", " sframes", " sclasses", "sounds", "lourses", "chides", "channels", "nample", "dannels", "sources", "lample", "slummies", "sases", "issample", "tounds", "chubs", "issframes", " sounds", "Sample", "sourses", "inannels", "summies", " sannels", "nubs", "pources", "chclasses", "tannels", "Sframes", "namples", "slannels", "Samples", "nummies", "pamples", "pannels", "insummies", "slamples", "insubs", "Sannels", "chummies", " saces", "Samps", "subs", "nones", "saces", "sannels", "damps"], "samples2": ["sannels1", "samples1", "sages52", "sages2", "samples52", "Samples1", "ssamps42", "socksTwo", "samps2", "Sannels1", "socks1", "samps1", "ssamps1", "sacters1", "nannelsdata", "sampsdata", "Samples2", "ssamples2", "sannels\n", "ssamples1", "socks52", "sannels42", "samps52", "yamples2", "Sannels02", "sannels02", "sacters2", "sampsTwo", "yamples1", "samplesTwo", "yocks52", "samplesdata", "samples02", "samps02", "Sannels2", "sannels2", "sagesTwo", "samples42", "Samples02", "yamplesTwo", "yocksTwo", "ssamples42", "samps42", "namples\n", "yocks2", "sannelsdata", "socks2", "yamples52", "yocks1", "sages1", "sacters42", "nannels\n", "samps\n", "ssamps2", "namplesdata"], "la": ["local", "da", "au", "capt", "loc", "ea", "arr", "lang", "ls", "lu", "ka", "l", "lo", "lag", "wal", "layer", "kl", "wa", "cl", "qa", "wat", "vals", "avi", "ma", "wave", "mu", "lc", "ha", "li"], "cpe": ["cpes", "pke", "pme", "Cme", "cene", "arcpe", "pfe", "cke", "acpe", "cme", "acpy", "arcene", " cpy", "Cke", "ppes", "pple", "acpes", "acke", "Cene", "pene", "Cpe", "acfe", "cpy", "Cfe", " cfe", " cpes", "arcke", "cple", "Cpes", "cfe", "acme", " cke", "ppy", "Cple", "ppe", "arcple"], "i": ["ui", "bi", "y", "index", "pi", "ie", "di", "name", "e", "d", "ik", "key", "multi", "fi", "p", "yi", "api", "slice", "type", "is", "mi", "phi", "qi", "ii", "ki", "ch", "r", "u", "inner", "ji", "id", "n", "l", "ni", "ip", "c", "m", "init", "ix", "ori", "g", "f", "zi", "io", "source", "start", "min", "ri", "ini", "info", "my", "gi", "it", "x", "xi", "code", "im", "ci", "eni", "uri", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"], "j": ["br", "y", "index", "ie", "aj", "jan", "e", "d", "key", "jc", "p", "h", "jit", "jl", "ij", "pr", "ii", "r", "ch", "ji", "ind", "dj", "n", "l", "jp", "jo", "c", "m", "g", "f", "pt", "ja", "jet", "uj", "kj", "syn", "el", "part", "jen", "o", "w", "x", "fr", "job", "z", "js", "b", "length", "adj", "q", "oj", "v", "J", "jj", "li"], "chans": ["ichatches", "chunks", "chars", "chants", "shants", " chunks", "shas", " chats", "ichants", "champs", "channels", "cheants", "shans", "schamps", " channels", "chats", " chan", "hannels", "chas", " chas", "shanes", "Chans", " champs", "cheases", "ichunks", "hants", "echants", "echannels", " chanes", "chan", "Chan", "hats", "hans", "chatches", "cheamps", "shases", " chases", "echan", "ichanes", " chants", "Chars", "echats", " chars", "cheans", "shats", "chases", "schatches", "ichannels", "echans", "schans", "echars", "Channels", "ichans", "chanes", "ichases", "schases", "cheats", "cheas", " chatches", "ichamps", "shunks", "schats", "ichats"], "tag": ["date", "batch", "brand", "real", "capt", "field", "loc", "key", "co", "ban", "bad", "rule", "lang", "session", "type", "bit", "style", "test", "tail", "big", "bug", "r", "patch", "use", "ack", "par", "stat", "reg", "month", "block", "word", "class", "g", "gap", "comment", "cat", "mod", "attribute", "min", "feat", "tick", "ad", "product", "ver", "user", "match", "code", "dr", "atom", "category", "Tag", "ag", "TAG", "length", "attr", "feature", "doc", "row", "year", "tags", "token"], "start_ch": ["start_chan", "start64ach", "start_Ch", " start_ach", " start_ech", "art67chan", "start_zh", " start_ich", "start_chn", "start_ich", "startJzh", "start_sch", "start67ch", "start64chi", " start_ci", "art_ch", "Start_ch", "startJich", "start_sh", "start67cho", "art67cho", "art_chan", "start_cher", "start_ech", "start64chan", "Start_k", " start_zh", "start_k", "art67sch", " start_cor", "start_ach", "startJch", "art_sch", " start_sh", "start64ich", " start_cher", " start_chi", "start64ch", "start67sch", "start_cho", "art67ch", "Start_chn", "art_cho", "start67chan", "start_ci", " start_chan", "start_chi", "Start_che", "startJchan", " start_Ch", "start_che", "start_cor", " start_sch"], "chan_map": ["chanOmeta", "chan_pool", "channel_default", "chanLpool", "chan2MAP", "chanOpad", "channel_map", "chan_config", "chanLmap", "channel_MAP", "chan_cache", "channel_pad", "chanNconfig", "chan_list", "chanOlist", "chan_block", "chanOmap", "chanOmaps", "chanLdefault", "ch_pos", "ch_block", "channel_cache", "chanLcap", "channel_pool", "chan_default", "chanNmap", "chan_meta", "ch_config", "chanDdefault", "chan_master", "chanLmaster", "channel_list", "chan_MAP", "chan_stream", "channel_master", "chanDcap", "chanOcache", "chan2meta", "chan_maps", "channel_cap", "chan_pad", "chanDmaster", "chanDmap", "chan2map", "channel_stream", "chan2maps", "chanOMAP", "chanNblock", "chan_pos", "channel_meta", "chanNpos", "chan_cap", "channel_maps", "ch_map", "chanLstream"], "chan_el_counter": ["chan_el_info", "chan_el6trace", "chan_list_seq", "chan_el_seq", "chan_list_trace", "chan_el_trace", "chan_el6seq", "chan_el6counter", "chan_list_counter", "chan_el6info", "chan_list_info"], "windows": ["mas", "new", "da", "wcs", "ows", "frames", "events", "nas", "devices", "multi", "wx", "details", "codes", "acs", "this", "win", "Windows", "n", "rows", "WINDOWS", "all", "Window", "ms", "views", "console", "array", "wa", "vals", " window", "flags", "ma", "w", "list", "gui", "ints", "wide", "images", "features", "window", "x"], "wi": ["ui", "wb", "wav", "wic", "di", "wcs", "ti", "wx", "wo", "mi", "Wi", "ni", "wal", "wan", "wei", "wa", "wu", "ini", "avi", "iw", "wt", "gi", "hea", "gui", "mic", "wid", "rw", "wk"], "ics": ["ices", "icks", "wcs", "icing", "ik", "igs", "circ", "isc", "cons", "lic", " ic", "nic", "cs", "acs", "xs", "ic", "ents", "ica", "ops", "ids", "css", "bc", "aic", "ix", "ns", "pic", "IC", "ig", "icon", "xes", "ICS", "ico", "mic", "icons", "isi", "icc", "ris", "irc", "ips"], "k": ["tk", "d", "ik", "key", "ks", "kw", "K", "kk", "ka", "n", "c", "unk", "m", " K", "kl", "g", "kt", "dk", "kn", "it", "km", "z", "sk", "b", "ok", "q", "v"]}}
{"project": "FFmpeg", "commit_id": "6a6bc43f5f79587b8936334cc0b3a6616f4807ac", "target": 0, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    GetByteContext gb;\n\n    GetBitContext  gb2;\n\n    int nslices, slice, slice_height, ref_slice_height;\n\n    int cur_y, next_y;\n\n    uint32_t off, slice_size;\n\n    uint8_t *Y, *U, *V;\n\n    int ret;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    nslices = bytestream2_get_le16(&gb);\n\n    off = FFALIGN(nslices * 4 + 2, 16);\n\n    if (src_size < off) {\n\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!nslices || avctx->height % nslices) {\n\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n\n                              avctx->width, avctx->height);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    ref_slice_height = avctx->height / nslices;\n\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n\n                              avctx->width, avctx->height);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y = pic->data[0];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n\n\n    cur_y  = 0;\n\n    next_y = ref_slice_height;\n\n    for (slice = 0; slice < nslices; slice++) {\n\n        slice_size   = bytestream2_get_le32(&gb);\n\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        if (slice_size > src_size - off) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n\n                   slice_size, src_size - off);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (slice_size <= 16) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n\n                   AV_RL32(src + off), slice_size - 16);\n\n        }\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n\n                             pic->linesize[0], pic->linesize[1],\n\n                             pic->linesize[2]);\n\n\n\n        Y += pic->linesize[0] *  slice_height;\n\n        U += pic->linesize[1] * (slice_height >> 1);\n\n        V += pic->linesize[2] * (slice_height >> 1);\n\n        off += slice_size;\n\n        cur_y   = next_y;\n\n        next_y += ref_slice_height;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4306, "substitutes": {"avctx": ["evcms", "axloc", " avcms", "afcup", "evconn", "avecor", "aveconf", "aveca", "avc", "avalcomponent", "avecu", "avetx", "avloc", "avconfig", " avconf", "avcos", "afctx", "afci", "axcontext", "ajcontext", "avtx", "afcomponent", "apconn", "evcu", "avsync", "ajctl", "avalctl", "afsync", "avca", "navctx", "avalctx", " avca", "avecomponent", "airqa", "aveloc", "afloc", "navsync", "afcmp", "airca", " avcor", "aveqa", " avcu", "apctx", "avecontext", "evloc", " avloc", "afconn", "Avctx", "afconsole", "afcu", "evci", "avcomponent", "avcor", "aveci", "evctx", "axctx", "ajcos", "AVcu", "AVctx", "afctl", "aflc", "AVlc", "evcontext", "avci", "aveconfig", "avercontext", "Avcontext", " avcup", "avcontext", "aveconn", "navcontext", "Avconn", "ajcomponent", "avconn", "avalc", "afcms", "avconsole", "apcf", "navconfig", "aircontext", "axcup", "averctx", "avconf", "averconsole", "avecmp", "afcos", "ajconn", "avercu", "AVcontext", "afconf", "avec", "afc", "avcms", "afcf", "avcmp", "afqa", "avqa", "afcor", "Avcf", "avcup", "avalcontext", "avcu", "aveconsole", "afconfig", " avcontext", " avconn", "avctl", "avcf", "afcontext", " avtx", "avlc", "avalcos", "apcontext", "evcmp", "airctx", "evlc", "avectx", "aftx", " avcmp", "afca", "avesync", "ajctx"], "pic": ["bi", "sci", "fn", "rc", "pc", "pin", "pi", "frame", "proc", "aci", "capt", "photo", "pins", "Pic", "piece", "mini", "fi", "typ", "sys", "sync", "quad", "cus", "seq", "image", "pict", "img", "git", "config", "module", "vec", "lib", "plugin", "ic", "file", "jp", "txt", "picture", "cci", "bc", "wire", "cube", "ig", "parse", "chat", "mac", "cam", "crop", "feat", "bin", "fc", "iv", "cf", "lc", "ac", "feature", "fig", "cb", "doc", "fp", "vc", "cycle"], "src": ["data", "sci", "split", "uc", "fn", "rc", "storage", "ref", "url", "proc", "loc", "input", "sb", "buf", "sc", "seq", "image", "img", "config", "cur", "ctx", "source", "inst", "fc", "sl", "filename", "iv", "uri", "sub", "rb", "attr", "in", "cb", "fp", "stream", "sel", "rs", "spec"], "src_size": ["rc_size", "src_Size", "share_ize", " src_clean", "src_body", "src_weight", "src2width", "slice_number", "srcallsize", "rc_width", "src_width", "src_data", "srcallclean", "src2Size", "srcallweight", "ssl_date", "src_scale", "src_ize", "rc_Size", "src_clean", "src_code", "src2size", "share_body", "slice_scale", "src_function", " src_time", "src_date", "srcalltime", "ssl_function", "ssl_size", "src_number", "slice_code", "src_length", "rc_data", "src2data", "ssl_length", " src_weight", "share_size", "src_time"], "gb": ["py", " rgb", "cfg", "gm", "abb", "pc", "storage", "nn", "db", "bf", "gpu", "sb", "hub", "cc", "mb", "byte", "gam", "rg", "bm", " rc", "gc", "gz", "gg", "cm", "gs", "bb", "gnu", "ki", "gram", "gio", "gd", "sg", "gal", "ctx", "bc", "bg", "gin", "g", "nb", "kb", "usb", "mc", "GB", "cv", "gp", "fc", "sl", " db", " eg", "ga", "ci", "lc", "Gb", "rb", "xb", "b", "cb", "gu"], "gb2": [" gcc2", " buffer2", "g2"], "nslices": ["nsucences", "nslines", "nsqlences", "onsplES", "lscies", "nslipes", "nscanences", "onsples", "nsigences", "nsligists", "nslaences", "outslicese", "nsligises", "nslicales", "nameslices", "nslicops", "outslicions", "outsealences", "nscilales", "lslicales", "nameslicences", "nscilences", "outslaions", "lslicists", "nsqueences", "nslicees", "nsqueores", "nsplences", "nslicises", "nslipises", "outsealets", "nslinies", "outslicences", "linsaules", "nsligets", "nslicES", "nsciales", "outslicets", "onslices", "nsciists", "nsquores", " nslicences", "nsaulences", "onsplees", "nscanes", "namesquees", "Nslipets", "Nslicets", "nsclises", "namesqueences", "nsealES", "nsplions", "Nslicises", "Nslices", "nscilores", "nsplES", "nslicences", "nslaions", "linslicales", "nsciles", "nsliges", "nscials", "nsquences", "nsigitions", "nsealese", "nsligions", "Nslipops", " nsucitions", "nslicals", "nscanales", "nsucitions", "nsplees", "nsqles", "linslicals", "nsigies", "nsplales", "outslices", "nslinees", "outseales", "nslicies", "nslipets", "outslaes", "outsealies", "nameslicores", "nsqlions", "nsquees", "nslinES", "onslicES", "lslices", "nsples", "nsealitions", "nameslicales", "nsclets", "nslinets", "nsaules", "lslicions", "linsaulals", "lsciists", "linsaulences", "nslicets", "outslaences", "nslaes", " nsuces", "nsqlese", "lsciales", "Nslipises", "nsaulals", "nslicese", "nscies", "nsligales", "onslicals", "nslaese", "Nslipes", "nslicores", "nsucES", "nsaulales", "nslicists", " nsucences", "nsealies", "linsaulales", "nscles", "namesqueales", "nsigES", "nslicitions", "nsquales", "nsplists", "linslicences", "lsciions", "nsiges", "nslicions", "nsigets", " nsucES", "nsuces", "outslaese", " nslicitions", "outslicies", "nsciES", "Nslicops", "namesqueores", "nsligops", "nsciees", "onslicees", "nscanals", "nseales", "nslinences", "nsealences", "nsplals", "onsplals", "nsciions", "nsealions", "nsqueales", "nsques", "nslipops", "linslices", " nslicES", "nslinals", "nsealets", "nsclops"], "slice": ["sci", "pos", "split", "pick", "seed", "ie", "sq", "sample", "scale", "diff", "loc", "region", "multiple", "slave", "len", "ice", "zip", "ski", "player", "mi", "offset", "image", "ii", "position", "pocket", "service", "inner", "dim", "video", "volume", "instance", "pie", "layer", "shift", "hole", "source", "range", "crop", "fit", " slicing", "part", "slot", "i", "sl", "uri", "pe", "edge", "trial", "live", "route", "shape", "node", "blade", "single", "missing", "unit", "li"], "slice_height": ["slice\u00b7width", "slice\u00b7height", "slice\u00b7size", "slice_data", " slice_data", "slice_weight", " slice_head", " slice_width", " slice_weight", "slice_head", "slice\u00b7head", "slice_width"], "ref_slice_height": ["ref_slot_dim", "ref_slice2length", "ref_slot_width", "ref_slot_size", "ref_slice_depth", "ref_slice2depth", "ref_slice2height", "ref_slice_width", "ref_slot_depth", "ref_scale_height", "ref_scale_size", "ref_scale_width", "ref_slice2size", "ref_slice_length", "ref_slice_size", "ref_slice2width", "ref_scale_length", "ref_slice_dim", "ref_slot_height"], "cur_y": ["curAllz", "ferAllx", "curJyn", "cur_ny", "curAlly", "cur_z", "curJny", " cur_x", "ferAlly", "curJy", "curOnny", "fer_x", "curJx", "ferAllyn", "curAllx", " cur_z", "next_Y", "curJY", "curOnx", "curJz", "curAllyn", "nextJy", "ferAllz", "fer_yn", "nextJx", "curOnz", "curOny", "next_z", "next_x", "fer_z", "cur_yn", "cur_x", " cur_ny", "fer_y", "nextJY", "nextJz", "cur_Y"], "next_y": [" nextPya", "next_ys", "nextPya", "nextPx", " nextPy", "nextPy", "nextWys", "nextOnery", "nextJyl", "next_yl", " nextJY", "post_ys", "nextWy", " nextJx", " nextJyl", "next_yd", "post_yd", "nextXY", "next_ya", "next_Y", "nextOneys", "nextXya", " next_ya", "post_y", "nextJy", "post_ry", "nextJx", "nextOney", "next_ry", "next_x", " next_x", "nextOneyd", "nextXy", "nextJya", "nextPY", " nextPx", " nextPY", " next_yl", " nextJy", "nextJY", "nextWry", "nextWyd", " next_Y", "nextXx"], "off": ["extra", "pos", "new", "Off", "low", "ext", "small", "end", "def", "ref", "on", "half", "error", "value", "region", "alt", "eff", "ord", "back", "len", "now", "raw", "open", "op", "no", "type", "style", "of", "num", "orig", "offset", "bit", "flow", "ack", "out", "SIZE", "old", "ip", "block", "obj", "load", "online", "shift", "OFF", "feat", "non", "o", "dev", "down", "front", "original", "ff", "valid", "length", "own", "ON", "offs", "unit", "output", "after"], "slice_size": ["slice_unit", "slot_ize", "sliceingunit", "sample_storage", "archive_size", "archive_unit", "sample_height", "archiveingsize", "sliceinglength", "archive_length", "slice_sized", "archiveinglength", "slot_size", "slice\u00b7sized", "archiveingunit", "slice\u00b7size", "slice_width", " slice_loc", "slice_ize", "slice_SIZE", "sample_SIZE", "slice_length", "slot_sized", "slice\u00b7loc", "slice_loc", " slice_sized", "slot_width", "sample_size", "sliceingsize", "slice_storage"], "Y": ["y", "CI", "IP", "B", "SH", "A", "W", "S", "type", "D", "F", "IX", "P", "PI", "MI", "YY", "ID", "Z", " y", "API", "UV", "Q", "N", "R", "GB", "C", "M", "H", "G", "I", "CH", "T", "X"], "U": ["UN", "UI", "UD", "O", "UC", "B", "OU", "US", "UL", "UR", "A", "W", "LU", "S", "D", "F", "u", "P", "L", "UT", "UV", "Q", "N", "R", "C", "M", "UU", "G", "I", "IL", "T", "X"], "V": ["VW", "NV", "B", "VC", "TV", "VL", "T", "W", "VI", "S", "D", "F", "P", "Vi", "L", "E", "VA", "UV", "Q", "N", "R", "C", "M", "H", "VT", "G", "I", "GV", "VD", "v", "J", "X"], "ret": ["data", "ext", "re", "ref", "def", "fail", "result", "fun", "success", "alt", "rep", "att", "value", "back", "len", " RET", "val", " Ret", "mem", "bad", "arr", "no", "num", "RET", "out", "reg", "id", "res", "rot", "aux", "fin", "f", "lit", "cat", "en", "info", "det", "match", "code", "nt", "reply", "arg", "red", "rets", "Ret", "rt"]}}
{"project": "FFmpeg", "commit_id": "6ebc7240606e8f1fccd2edbe4ffac150053a16cc", "target": 0, "func": "static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,\n\n                         GetBitContext *gb, SBRData *ch_data)\n\n{\n\n    int i;\n\n    unsigned bs_pointer = 0;\n\n    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots\n\n    int abs_bord_trail = 16;\n\n    int num_rel_lead, num_rel_trail;\n\n    unsigned bs_num_env_old = ch_data->bs_num_env;\n\n\n\n    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];\n\n    ch_data->bs_amp_res = sbr->bs_amp_res_header;\n\n    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];\n\n\n\n    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {\n\n    case FIXFIX:\n\n        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);\n\n        num_rel_lead                        = ch_data->bs_num_env - 1;\n\n        if (ch_data->bs_num_env == 1)\n\n            ch_data->bs_amp_res = 0;\n\n\n\n        if (ch_data->bs_num_env > 4) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /\n\n                   ch_data->bs_num_env;\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;\n\n\n\n        ch_data->bs_freq_res[1] = get_bits1(gb);\n\n        for (i = 1; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];\n\n        break;\n\n    case FIXVAR:\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_trail + 1;\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        for (i = 0; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);\n\n        break;\n\n    case VARFIX:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    case VARVAR:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        if (ch_data->bs_num_env > 5) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    }\n\n\n\n    if (bs_pointer > ch_data->bs_num_env + 1) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR,\n\n               \"Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\\n\",\n\n               bs_pointer);\n\n        return -1;\n\n    }\n\n\n\n    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;\n\n\n\n    ch_data->t_q[0]                     = ch_data->t_env[0];\n\n    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];\n\n    if (ch_data->bs_num_noise > 1) {\n\n        unsigned int idx;\n\n        if (ch_data->bs_frame_class == FIXFIX) {\n\n            idx = ch_data->bs_num_env >> 1;\n\n        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR\n\n            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);\n\n        } else { // VARFIX\n\n            if (!bs_pointer)\n\n                idx = 1;\n\n            else if (bs_pointer == 1)\n\n                idx = ch_data->bs_num_env - 1;\n\n            else // bs_pointer > 1\n\n                idx = bs_pointer - 1;\n\n        }\n\n        ch_data->t_q[1] = ch_data->t_env[idx];\n\n    }\n\n\n\n    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev\n\n    ch_data->e_a[1] = -1;\n\n    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0\n\n        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;\n\n    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1\n\n        ch_data->e_a[1] = bs_pointer - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 4307, "substitutes": {"ac": ["pc", "am", "rac", "enc", "iac", "cc", "anc", "AC", "af", "jac", "Ac", "acl", "gc", "cus", "oc", "auc", "soc", "inc", "acs", "ack", "cit", "ic", "cms", "c", "aux", "arc", "bc", "dc", "acc", "mc", "mac", "cam", "ec", "cache", "cu", "ad", "ca", "tc", "ag", "fac", "vc"], "sbr": [" sper", "jsbr", "wshr", "ansbr", "lbre", "wspr", " shr", "lfr", " spr", "shr", "anshr", "sBR", "wsbr", "lbr", "lper", "sfr", "sbre", "ansBR", " sBR", "jsfr", " sbre", "jsbre", "jsper", " sfr", "spr", "anspr", "sper", "wsBR"], "gb": ["py", "ui", "cfg", "abb", "gm", "storage", "pc", "gom", "db", "bf", "sb", "hub", "mb", "game", "rg", "gam", "bm", "gc", "gz", "gg", "gnu", "gs", "bb", "cm", "hm", "gram", "buff", "gy", "gd", "cgi", "ctx", "bg", "bc", "gin", "g", "nb", "kb", "usb", "ogg", "GB", "gp", "eb", "gt", "ga", "bd", "ge", "rb", "cb", "gu"], "ch_data": ["enchackdata", "unchirmaction", " ch_reader", "chackdatabase", "ch6method", "cha13dat", " chCmodel", "cy_style", "arch_da", " chCdata", "cm_batch", "chCdata", "ch1this", "chPad", "chPda", "ech_info", "ch7model", "chCinfo", "arch_template", "chAwriter", "ch_module", " chingthis", "chpmodel", "chPconfig", "che_data", "chingthis", "dev_DATA", "arch_data", "chCmanager", " ch_result", "chirmaction", "achacdata", "ch6ata", "chirmata", "chaocresults", "chstemplate", "challmodel", "cha_model", "unch_data", "chappsite", "archmdata", "cha8style", "chsdat", "chPdatabase", "ch_writer", "chn_dat", "chockdata", "chapptemplate", "chlexdata", "ch_config", "ch_window", "ch___config", "chirminfo", "cy___ata", "ech_dat", "chip5ata", "chackinfo", "ch6session", "chPresults", "cher_config", "unchirmmodel", "chaoctemplate", "chirmmodel", "chackmissing", "chkData", "cy_data", "ch5missing", "chsdiv", "chacdata", "chAdata", "dev_data", "ch13data", "chpdata", "ch7loader", " ch_parent", "cy_ata", "chn_data", "cha_site", "ch_session", "chsdata", "che_div", "cha_ata", " ch_info", "ch_script", "cha_method", "ch_loader", "chkloader", "unch_script", "cha8ata", "chAreader", "chsresults", "ch5ata", "cherpmissing", "chackdata", "ch_manager", "cha_style", "ch___method", "archkdata", "challtemplate", "chappwindow", "arch_module", "challthis", "cha_loader", "archkmodel", "cha_data", "chAinfo", "chPtemplate", "ch_this", "ch_entry", "chacthis", "ch8data", "chirmmodule", "chacla", "chsData", "chaymanager", "ch8style", "archmmodule", "ch_layout", "ch5this", "cmockbatch", "chPthis", "chtdata", " chingdatabase", "ch6data", "cha7model", "ach_data", "ch_dat", "cha7session", "chaydata", "chpdat", "achacla", "devallDATA", "challdata", "cm_this", "ch_pos", "chksession", "echmmanager", "cha8master", " ch_this", "chMdata", "unch_model", "arch_dat", "ch___missing", "achacwindow", "ch5ui", " ch_writer", "echmmissing", "chlexata", "chlexentry", "chpwriter", "ch_site", "ch_master", "ch1data", "chlexdatabase", "ch5info", "cherpdata", "ch7data", "cherpconfig", "chip_ata", "archmdat", "chlexwriter", "cha7loader", "chMdatabase", "enchackresult", "chmdata", "chnPad", "ch7DATA", "enchackmissing", "cher_missing", "chPdata", "ch5data", "chingdata", "devalldata", "chMmanager", "cha13method", "chmdat", "cherpdat", "cha7data", "chnPthis", "ch5entry", "cy_method", "chMda", "ch_ad", "chMdat", "chaymissing", "ch_results", "chayresult", " chingparent", "chn_this", "ch13site", "chmresult", "chappmethod", " chCwriter", "echmresult", "ch_method", "chmmodule", "ch7template", "challreader", "cy___style", "chttemplate", "chocresults", "ch_model", "chklayout", "ach_dat", "ch1ad", "chaocdata", "chip5data", "ch_ui", "ch8ata", "echmdat", "ch_da", "che_dat", "ch_result", "ch6style", "achacdat", "ch1method", "chip_entry", "ch_Data", "ech_result", "chpthis", "cha_pos", "chackwriter", "chmtemplate", "devalltemplate", "chktemplate", "dev_template", "chacdat", "che_Data", " chAinfo", "chackmanager", "cher_dat", "ch5batch", "ch_batch", "ech_missing", "ech_manager", "chirmentry", "ch_div", "chockthis", "ch_la", "ch_missing", "unchirmmodule", "chackresult", "cha_master", "chtdat", "chocdat", "ch6loader", "chip_data", "ch8master", "chn_ad", "ch1dat", "chkmodel", "enchackmanager", "ch5manager", "ch5result", "chCdat", "cha13data", "chfmodule", "devallthis", "cy___data", "cm_ui", "ch_style", "chnPdata", "chkdat", "chockui", "chmmanager", "chkresult", "cha13site", "chip_info", "cmockui", "chPparent", "chPmodel", "chappla", "chtmodule", "ch7session", "ch___style", "archmtemplate", "chappdat", "challwriter", " chingdata", "chPdat", "cmockthis", "ch1site", "chlexinfo", "unch_action", " chAreader", "chockbatch", "chip5info", " chCthis", "challDATA", "ch_info", "ch13dat", "ch7result", "ench_result", "chpmissing", "chocdata", "chip5entry", "ch_template", "challpos", "cha8data", "ch___ata", "ch_parent", "chPmissing", "ch_database", "cha_results", "dev_this", "unchirmdata", "chCmodel", "cha_dat", "cmockdata", "ch13method", " ch_model", "ech_data", "archktemplate", "chfdata", " ch_database", "ch___data", "echminfo", "cha_template", "chaocdat", "cha_session", "ench_missing", " ch_layout", " chAdata", "chocda", "chCthis", "chminfo", "cm_data", " chAwriter", "chingdatabase", "chkdiv", "choctemplate", "ench_manager", "chacparent", "ach_la", "chirmdata", "cher_data", "chfmodel", "ch_action", "unch_database", "ch7this", "arch_model", "ach_window", "ch7layout", "chMscript", "cha_writer", "chpconfig", "ch_ata", "chocmodel", "echmdata", "ch6model", "unch_module", "ch___dat", "chacdatabase", "ch_DATA", "chkdata", "chfaction", "challinfo", "chMinfo", "chacwindow", "ch_reader", "chmmissing", "chnPdat", "chappmodule", "chappdata", "ench_data", "unch_da", "archkda", "chCwriter", "chingparent", "chkda", "cy___method"], "i": ["bi", "index", "pi", "d", "multi", "ti", "slice", "qi", "hi", "inner", "id", "ip", "init", "f", "zi", "mu", "uri", "b", "in", "count", "v", "li", "ui", "data", "k", "ie", "key", "cli", "ii", "u", "ji", "abi", "ix", "start", "ini", "iu", "ai", "p", "mi", "ki", "n", "c", "oi", "g", "io", "gi", "it", "I", "x", "si", "y", "j", "di", "field", "e", "fi", "yi", "jit", "phi", "counter", "ni", "l", "ami", "m", "source", "min", "ri", "info", "o", "xi", "ci", "eni", "z", "gu"], "num_rel_lead": ["num_relttail", "num_relstail", "num_rev_leader", "num_relsedge", "num_rel_goal", "num_rev_tail", "num_reltedge", "num_rel2leading", "num_relslead", "num_relsleading", "num_revslead", "num_rel_leader", "num_rev_edge", "num_rel_tail", "num_reltlead", "num_reltleader", "num_revstail", "num_relsLead", "num_revsleader", "num_revsedge", "num_rel2Lead", "num_relingtail", "num_relinglead", "num_rel_leading", "num_rel_Lead", "num_rel2lead", "num_rev_lead", "num_relsleader", "num_relinggoal", "num_rel_edge"], "num_rel_trail": ["num_rel_rarail", "num_rel_protil", "num_rel_rail", "num_rel_trirail", "num_rel_protiling", "num_rel_protrail", "num_rel_triil", "num_rel_raill", "num_rel_triill", "num_rel_trarail", "num_rel_railing", "num_rel_traill", "num_rel_triiling", "num_rel_trailing", "num_rel_protill"]}}
{"project": "qemu", "commit_id": "45b339b18c660eb85af2ba25bfcaed5469660d77", "target": 0, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.result;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.result;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,\n\n                                                    async->td);\n\n            return TD_RESULT_NEXT_QH;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);\n\n    return TD_RESULT_COMPLETE;\n\n\n\nout:\n\n    /*\n\n     * We should not do any further processing on a queue with errors!\n\n     * This is esp. important for bulk endpoints with pipelining enabled\n\n     * (redirection to a real USB device), where we must cancel all the\n\n     * transfers after this one so that:\n\n     * 1) If they've completed already, they are not processed further\n\n     *    causing more stalls, originating from the same failed transfer\n\n     * 2) If still in flight, they are cancelled before the guest does\n\n     *    a clear stall, otherwise the guest and device can loose sync!\n\n     */\n\n    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {\n\n        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);\n\n        uhci_async_unlink(as);\n\n        uhci_async_cancel(as);\n\n    }\n\n\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n", "idx": 4315, "substitutes": {"s": ["sq", "sb", "sys", "p", "spec", "ls", "session", "S", "is", "ses", "cs", "r", "service", "ss", "sie", "sg", "m", "fs", "g", "ns", "f", "sa", "ssl", "south", "se", "sl", "o", "secondary", "sis", "sv", "su", "state", "status", "os", "conf", "rs", "si"], "td": ["dn", "pc", "od", "d", "dt", "std", "cmd", "rd", "tl", "nd", "table", "bd", "zh", " dd", "ln", "ht", "wd", "data", "pb", "db", "att", "sb", "dh", "typ", "lt", "elt", "ind", "txt", "ts", "t", "st", "tw", "kt", "tm", "tif", "BT", "det", "lc", "cd", "gb", "wn", "email", "cod", " sd", "butt", "fd", "tmp", "pt", "ssl", "ad", "nt", "lf", "pd", "token", "dat", "sth", "th", "tn", "pl", "cz", "lang", "dial", "ds", "dd", "TD", "dl", "ld", "fc", "dev", "md", "ff", "sd", "edd", "tf", "ctl"], "async": ["ASyn", "Assync", "acynchronous", "abssync", " asynchron", " assync", "assynchron", "rasync", "asynchronous", "ayn", "assynchronous", "ASsync", "assyn", "absync", " asynchronous", "Asynchronous", "rasyn", "acyn", "aynchron", " asyn", "Asynchron", "ASynchronous", "absynchronous", "acync", "asyn", "Ascent", "ascent", "abscent", "aync", "rasynchronous", "ASynchron", "rasynchron", "asssync", "aynchronous", "asynchron", "rassync", " ascent", "Async", "acsync", "Asyn", "assync", "ASync"], "int_mask": ["int_ask", "int_sum", "int1ask", "const_limit", "const128ask", "const128counter", "const128limit", "int1sum", "int64mask", "int128limit", "int_map", "int1mask", "const_mask", "int_offset", "int128ask", "const_counter", "int_limit", "int64ask", "const_hack", "const_ask", " int_ask", "int128counter", "int64counter", "int128mask", "const128mask", " int_map", "int_counter", "int_hack", "const_offset", "int1map", " int_sum", "int64limit", "const_map"], "max_len": ["maxloglen", "max64Len", "max__pos", " max_en", "min_pos", "max33len", " max_lif", "min_length", "max33lang", "max_pos", "min_el", "maxlogpos", "max64length", "max_en", "max_val", "min_len", "max_length", "max__len", "min_fail", " max_length", "max33lif", " max_lang", "min_val", "min_lin", " max_Len", "max__el", "maxlogel", " max_pos", "max_lif", "max64en", "max33pos", "max_lin", "max_lang", "max__lif", "max_Len", "max__lang", "maxlogfail", "max_fail", "max__fail", "max_el", "max64len"], "err": ["msg", "proc", "progress", "error", "fun", "exc", "er", "str", "sys", "rx", "arr", "mid", "conn", "resp", "ind", "rr", "res", "mr", "cur", "rev", "req", "cache", "dev", "ver", "attr", "cb", "cmp", "spec"], "ret": ["pat", "pet", "msg", "re", "ref", "def", "pre", "result", "success", "db", "alt", "fun", "att", "back", "rep", "len", "val", "fi", "mem", "arr", "last", "bit", "mi", "seq", "RET", "r", "resp", "lt", "reg", "res", "obj", "rot", "fin", "des", "cur", "opt", "rev", "lit", "cat", "flag", "el", "group", "feat", "det", "ft", "al", "match", "nt", "reply", "code", "rl", "arg", "format", "status", "rets", "Ret", "rt"], "pid": ["py", "pb", "pet", "ticket", "pos", "pc", " pos", "pin", "pi", "uid", "proc", "od", "sid", "kid", " proc", "oid", "si", "d", "db", "len", "val", "p", "mid", " conn", " pc", "mi", "phi", "pad", "conn", "pa", " pin", "ds", "vid", " p", "plugin", "id", "ind", "ip", "fd", "pron", "ix", "perm", "pt", "pointer", "prop", "sn", "bin", "slot", "pty", "nt", "ci", " tid", "pri", "addr", " dd", "pd", " id", "token"], "as": ["an", "are", "ak", "pas", "ach", "am", "ans", "ras", "asp", "ais", "with", "ast", "er", "nas", "app", "ann", "ay", "is", "acs", "at", "ask", "ap", "asha", "task", "ass", "asc", "As", "var", "asa", "action", "ms", "act", "sa", "or", "a", "was", "ad", "ar", "al", "ac", "es", "alias", "aw", "aster", "bs", "os", "ai", "AS", "las"]}}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n", "idx": 4337, "substitutes": {"f": ["xf", "fn", "j", "e", "d", "fx", "fi", "af", "fe", "p", "rf", "df", "h", "F", "r", "sf", "file", "l", "n", "s", "fd", "c", "m", "t", "fen", "fs", "g", "buffer", "i", "fc", "w", "filename", "fr", "b", "tf", "fp", "feed", "v"], "eflags": ["efrats", "efliales", "ecloags", "efrags", "efloars", "ecdlugs", "eclars", "efliagn", "efplages", "ecsag", "ecloages", "efflcatts", "eflyats", "efllars", "ebliars", "efflcases", "eflcars", "eflases", "eflacks", "eflaches", "eclays", "eflays", "eflag", "efslats", "alfflages", "efllugs", "efrinks", "evrats", "efllages", "efllags", "efslag", "alfflags", "efloagn", "eflugs", "efflats", "eflaages", "alfdlars", "evllages", "eflcats", "eclags", "efdlagg", "efloages", "eflcagn", "efdlugs", "evrages", "efliags", "eflaagg", "efrages", "efflcats", "eflars", "efflags", "eflcales", "efflatts", "eflcag", "efllinks", "eflcatts", "eclages", "evlags", "efsales", "efplags", "efsays", "efdlags", "evlinks", "eflatts", "alfflugs", "eflyases", "alflages", "eflaats", "eflbags", "alfflats", "ebliugs", "evrinks", "eflages", "efgag", "alfdlages", "efcag", "efcages", "ecdlags", "alflagg", "ecloars", "eflcags", "evllugs", "alfdlagg", "efgaches", "efplag", "eflyags", "eflagn", "eflyatts", "efrales", "efliag", "efsag", "alflats", "efrag", "efliacks", "eflcagg", "efllats", "ecsags", "eflagg", "eblags", "eblars", "ecdlales", "alflugs", "eflales", "efflugs", "efsags", "efrays", "efliays", "evlats", "evlages", "efdlales", "eflbases", "ecsales", "efplugs", "eflaugs", "efslags", "efgages", "eflcugs", "efdlages", "alfdlags", "eclagn", "efllacks", "evlugs", "efdlacks", "ecdlag", "eclugs", "eflinks", "ebliags", "efcaches", "efflages", "eflaags", "evlaches", "alflars", "eflbats", "eblacks", "evllag", "eblugs", "efliages", "evrags", "efdlars", "ebliacks", "efdlag", "eflbatts", "alflags", "ecloagn", "evraches", "eflcases", "efslinks", "efflases", "efliugs", "eflats", "eflaars", "evllags", "eclales", "efllag", "evlag", "efgags", "eflcages", "efloags", "efliars", "efraches", "efflcags", "ecsays", "evrag", "eclag", "efcags"], "cc_op_name": ["cc_oper_size", "cc_oper_id", "cc_oper_path", "cc_op_type", "cc_op_size", "cc_oper_str", "cc_op_no", "cc_oper_names", "cc_op_id", "cc_oper_name", "cc_op_path", "cc_oper_no", "cc_oper_type", "cc_op_names", "cc_op_str"]}}
{"project": "FFmpeg", "commit_id": "612ecfbbbb3f4238d44cca5f250ffc6147d03ec2", "target": 0, "func": "static int gif_read_image(GifState *s)\n\n{\n\n    int left, top, width, height, bits_per_pixel, code_size, flags;\n\n    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;\n\n    uint8_t *ptr, *spal, *palette, *ptr1;\n\n\n\n    left = bytestream_get_le16(&s->bytestream);\n\n    top = bytestream_get_le16(&s->bytestream);\n\n    width = bytestream_get_le16(&s->bytestream);\n\n    height = bytestream_get_le16(&s->bytestream);\n\n    flags = bytestream_get_byte(&s->bytestream);\n\n    is_interleaved = flags & 0x40;\n\n    has_local_palette = flags & 0x80;\n\n    bits_per_pixel = (flags & 0x07) + 1;\n\n\n\n    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);\n\n\n\n    if (has_local_palette) {\n\n        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));\n\n        palette = s->local_palette;\n\n    } else {\n\n        palette = s->global_palette;\n\n        bits_per_pixel = s->bits_per_pixel;\n\n    }\n\n\n\n    /* verify that all the image is inside the screen dimensions */\n\n    if (left + width > s->screen_width ||\n\n        top + height > s->screen_height)\n\n        return AVERROR(EINVAL);\n\n\n\n    /* build the palette */\n\n    n = (1 << bits_per_pixel);\n\n    spal = palette;\n\n    for(i = 0; i < n; i++) {\n\n        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);\n\n        spal += 3;\n\n    }\n\n    for(; i < 256; i++)\n\n        s->image_palette[i] = (0xffu << 24);\n\n    /* handle transparency */\n\n    if (s->transparent_color_index >= 0)\n\n        s->image_palette[s->transparent_color_index] = 0;\n\n\n\n    /* now get the image data */\n\n    code_size = bytestream_get_byte(&s->bytestream);\n\n    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,\n\n                       s->bytestream_end - s->bytestream, FF_LZW_GIF);\n\n\n\n    /* read all the image */\n\n    linesize = s->picture.linesize[0];\n\n    ptr1 = s->picture.data[0] + top * linesize + left;\n\n    ptr = ptr1;\n\n    pass = 0;\n\n    y1 = 0;\n\n    for (y = 0; y < height; y++) {\n\n        ff_lzw_decode(s->lzw, ptr, width);\n\n        if (is_interleaved) {\n\n            switch(pass) {\n\n            default:\n\n            case 0:\n\n            case 1:\n\n                y1 += 8;\n\n                ptr += linesize * 8;\n\n                if (y1 >= height) {\n\n                    y1 = pass ? 2 : 4;\n\n                    ptr = ptr1 + linesize * y1;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 2:\n\n                y1 += 4;\n\n                ptr += linesize * 4;\n\n                if (y1 >= height) {\n\n                    y1 = 1;\n\n                    ptr = ptr1 + linesize;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 3:\n\n                y1 += 2;\n\n                ptr += linesize * 2;\n\n                break;\n\n            }\n\n        } else {\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    /* read the garbage data until end marker is found */\n\n    ff_lzw_decode_tail(s->lzw);\n\n    s->bytestream = ff_lzw_cur_ptr(s->lzw);\n\n    return 0;\n\n}\n", "idx": 4341, "substitutes": {"s": ["sync", "native", "site", "vs", "ops", "sg", "services", "strings", "fs", "f", "sv", "b", "side", "features", "conf", "serv", "new", "sq", "sb", "plugins", "params", "h", "ses", "cs", "r", "sf", "ss", "ts", "t", "uns", "ns", "a", "its", "your", "es", "http", "hs", "ins", "parts", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "ims", "xs", "stats", "c", "g", "us", "ssl", "state", "qs", "rs", "spec", "si", "aws", "e", "is", "service", "ds", "stat", "l", "states", "sym", "m", "bis", "as", "settings", "se", "secondary", "o", "js", "os", "ips"], "top": ["TOP", "bottom", "target", "on", "th", "to", "name", "below", "wrong", "tops", "above", "dot", "op", "style", "client", "Top", "up", "lon", "offset", "stop", "position", "middle", "current", "bot", "sp", "temp", "t", "lat", "toc", "pt", "platform", "icon", "padding", "hop", "foo", "upper", "tip", "master", "parent", "front", "size", "leading", "high", "x", "first"], "height": ["depth", "layout", "huge", "bottom", "th", "Height", "thumbnails", "above", "wall", "rh", "h", "history", "up", "style", "thin", "rank", "head", "quality", "dim", "rows", "volume", "windows", "resolution", "dy", "lat", "alpha", "hd", "density", "inches", "padding", "max", "upper", "gh", "w", "size", "scroll", "level", "high", "shape", "length", "center", "ths", "ht", "window", "x"], "bits_per_pixel": ["bits_per\u00b7pixel", "bits_per\u00b7component", "bits_per___inch", "bits_per_component", "bits_PER_channel", "bits_per_integer", "bits_per_chip", "bits_per_inch", "bits_per__pixel", "bits_per\u00b7channel", "bits_Per_channel", "bits_per_character", "bits_Per_component", "bits_per_char", "bits_PER_pixel", "bits_per_channel", "bits_per_square", "bits_per___integer", "bits_per__integer", "bits_PER_square", "bits_Per_pixel", "bits_per_byte", "bits_per_double", "bits_per__inch", "bits_per___pixel"], "code_size": ["code_sized", "code___strength", "code64type", "call_size", "call_unit", "code___type", "code\u00b7sized", "code_unit", "code_type", "code\u00b7shape", "code64term", "code___size", "call_shape", "code_shape", "code64strength", " code64type", " code_term", "code64size", " code_type", " code64strength", "call_sized", "code_term", "code\u00b7size", " code64term", "code\u00b7unit", " code64size", " code_strength", "code_strength", "code___term"], "flags": ["data", "options", "fps", "lins", "parts", "frames", "lines", "mask", "tops", "lights", "details", "rules", "args", "links", "codes", "weights", "atts", "forces", "vs", "alls", "bytes", "stats", "types", "quality", "files", "seconds", "states", "ops", "fd", "windows", "lag", "ils", "strings", "ags", "fs", "weight", "f", "fields", "Flags", "padding", "ants", "vals", "flag", "settings", "ints", "bits", "bands", "reads", "features", "status", "errors", "groups", "planes", "utils", "fl", "steps", "styles"], "is_interleaved": ["is_interoleaved", "is_interleave", "is_interoleeded", "is_overleave", "is_overleaving", "is_overleeded", "is_interleaving", "is_interveaving", "is_overoleeded", "is_overleaded", "is_interleaveaved", "is_interleaveave", "is_overoleaved", "is_interluaded", "is_interoleaded", "is_interveave", "is_overoleaded", "is_interlueded", "is_interveaved", "is_interpleeded", "is_overoleave", "is_interpleaving", "is_interpleaded", "is_interleaveaving", "is_overleaved", "is_interleaveaded", "is_interluaved", "is_interleeded", "is_interveaded", "is_overoleaving", "is_interluaving", "is_interoleaving", "is_interleaded", "is_interoleave", "is_interpleaved"], "has_local_palette": ["has_local_palignment", "has_local_opalite", "has_local_pixelette", "has_local_opallete", "has_local_palettes", "has_local_opalettes", "has_local_pixelettes", "has_local_pixellete", "has_local_allnette", "has_local_borderlete", "has_local_filette", "has_local_pallete", "has_local_opalette", "has_local_alettes", "has_local_pixelnette", "has_local_alite", "has_local_allignment", "has_local_borderette", "has_local_pixelze", "has_local_borderze", "has_local_opalze", "has_local_pixelite", "has_local_palite", "has_local_allete", "has_local_alette", "has_local_filettes", "has_local_filnette", "has_local_allettes", "has_local_palze", "has_local_palnette", "has_local_borderettes", "has_local_pixelignment", "has_local_allette", "has_local_filignment"], "y": ["py", "j", "ny", "yy", "sky", "p", "yi", "type", "h", "image", "speed", "l", "yo", "yl", "t", "dy", "pt", "f", "yn", "padding", "Y", "xy", "w", "level", "z", "ya", "x"], "pass": ["py", "pos", "pc", "nn", "pin", "yy", "val", "wn", "zip", "xx", "up", "ep", "win", "password", "ss", "Z", "pt", "path", "pp", "min", "wp", "XX", "Y", "sl", "code", "rw", "col", "row", "X"], "y1": ["y2", "p2", "wone", " yone", "pone", "p1", "w2", " y2", "w1", "yone"], "linesize": ["linesIZE", "codesizes", "linesizes", "linesizing", "pagesizes", "pagesizing", "pinsIZE", "codesizing", "pagesize", "pinsize", "codesIZE", "pinsizes", "pinsizing", "pagesIZE", "codesize"], "n": ["nc", "nn", "np", "k", "j", "e", "d", "ny", "len", "p", "h", "num", "r", "ne", "u", "pn", "l", "ni", "net", "c", "m", "all", "t", "nb", "ns", "g", "f", "sn", "network", "N", "o", "w", "size", "nt", "cn", "z", "b", "v", "x"], "i": ["bi", "ui", "index", "pi", "j", "di", "name", "e", "d", "multi", "fi", "li", "p", "ti", "uli", "yi", "slice", "h", "mi", "phi", "qi", "ii", "ki", "u", "inner", "ji", "id", "ni", "chi", "ip", "l", "ami", "abi", "m", "c", "init", "ix", "oi", "f", "zi", "io", "ri", "ini", "info", "gi", "it", "xi", "x", "uri", "ci", "eni", "z", "b", "iu", "ani", "I", "ai", "v", "si"], "ptr": ["pos", "tile", "pc", "eth", "loc", "len", "tty", "fe", "arr", "src", "buf", "sp", "fd", "sh", "pt", "tr", "pointer", "inst", "cv", "alloc", "iv", "xp", "dr", "addr", "eps", "fp", "fl", "port"], "spal": ["instpal", "espel", "Spal", "ppall", "ispal", " spall", "servala", " spAL", "SPaler", "instala", "ispala", "SPall", "ppel", "servAL", "Spala", "spel", "spals", "ppal", " spel", "servaler", "instal", "spAL", "espall", "isppal", "ppala", "SPAL", "spaler", "SPals", "Spall", "sppal", "espala", " spals", "Spals", "instel", "serval", "espal", " spala", "ispel", "spall", "SPala", " sppal", " spaler", "spala", "SPal"], "palette": ["cellette", "Pallette", "allette", "isalble", "calette", "plette", "isallette", "alettes", "binettes", "palment", "callette", "filettes", "alue", "fillette", "opalble", "Palettes", " palettes", "palettes", "opallete", "alment", "binlette", "cellble", "cellettes", "isalette", "calment", " palue", "calettes", "isalettes", "pallette", "opalette", "opallette", "pallete", "plettes", "opalettes", "palble", "filette", "alhole", "filment", "celllette", "Palette", "palue", "plue", "binette", "plhole", "alette", " palhole", "Pallete", "palhole", "binlete"], "ptr1": ["pointerone", "pointer2", "bufferone", "trone", "pointer1", "buffer2", "buffer1", "tr2", "ptrone", "tr1", "ptr2"]}}
{"project": "FFmpeg", "commit_id": "43a4cb070bf7588c53fd192e8fbc71a52fa14a4c", "target": 0, "func": "static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                             int buf_size, void *data)\n\n{\n\n    AlacEncodeContext *s = avctx->priv_data;\n\n    PutBitContext *pb = &s->pbctx;\n\n    int i, out_bytes, verbatim_flag = 0;\n\n\n\n    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"input frame size exceeded\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (buf_size < 2 * s->max_coded_frame_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"buffer size is too small\\n\");\n\n        return -1;\n\n    }\n\n\n\nverbatim:\n\n    init_put_bits(pb, frame, buf_size);\n\n\n\n    if (s->compression_level == 0 || verbatim_flag) {\n\n        // Verbatim mode\n\n        const int16_t *samples = data;\n\n        write_frame_header(s, 1);\n\n        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {\n\n            put_sbits(pb, 16, *samples++);\n\n        }\n\n    } else {\n\n        init_sample_buffers(s, data);\n\n        write_frame_header(s, 0);\n\n        write_compressed_frame(s);\n\n    }\n\n\n\n    put_bits(pb, 3, 7);\n\n    flush_put_bits(pb);\n\n    out_bytes = put_bits_count(pb) >> 3;\n\n\n\n    if (out_bytes > s->max_coded_frame_size) {\n\n        /* frame too large. use verbatim mode */\n\n        if (verbatim_flag || s->compression_level == 0) {\n\n            /* still too large. must be an error. */\n\n            av_log(avctx, AV_LOG_ERROR, \"error encoding frame\\n\");\n\n            return -1;\n\n        }\n\n        verbatim_flag = 1;\n\n        goto verbatim;\n\n    }\n\n\n\n    return out_bytes;\n\n}\n", "idx": 4344, "substitutes": {"avctx": ["afcmp", "avalcam", "avalconn", "avcontext", "airca", "aveconn", "avalcontext", "accontext", "avcu", "abloc", "aveconsole", "avconn", "avecu", "afconfig", "abconsole", "avconsole", "avloc", "acqa", "avconfig", "avelc", "aircontext", "AVconfig", "afctx", "avecontext", "afcontext", "avlc", "avecmp", "avecam", "avsync", "AVconn", "afconn", "acctx", "afsync", "abctx", "afcu", "AVcontext", "abconfig", "avca", "abcontext", "avalctx", "abconn", "AVsync", "AVcu", "avalcmp", "AVctx", "airctx", "airqa", "avcmp", "aflc", "afqa", "afcam", "avectx", "acca", "AVlc", "avalcu", "afca", "avcam", "avqa", "avalconsole", "avalloc", "AVcmp", "aveloc", "avesync"], "frame": ["header", "sample", "element", "frames", "message", "document", "fi", "fe", "slice", "flow", "type", "iframe", "seq", "image", "channel", "config", "line", "fb", "video", "block", "sequence", "version", "buffer", "f", "point", "Frame", "fc", "fram", "size", "cf", "code", "series", "board", "setup", "fp", "window", "base"], "buf_size": ["buflexscale", "off_sized", "buf_Size", "buffer_set", " buf_length", "buf___size", "bufxSize", "off_size", "buf_small", "bufxsmall", " buf_scale", "offxsize", "buf_sized", " buf_z", "bufxsize", "buflexset", "buffer_shape", "offxSize", "buf_set", "buflexshape", "buflexsized", "buflexsize", "buffer_size", "buflexSize", "buffer_scale", "buf___length", "bufxsized", "offxsmall", "off_Size", "buf___scale", "buf_scale", "buflexsmall", "off_small", "offxsized", "buf_z", "buf_length", "buf___z", "buf_shape"], "data": ["batch", "pos", "new", "reader", "da", "sample", "DATA", "db", "input", "d", "frames", "parts", "message", "e", "Data", "raw", "none", "p", "slice", "dat", "buf", "record", "image", "this", "config", "ds", "block", "rows", "dd", "m", "c", "v", "buffer", "f", "next", "as", "array", "a", "cache", "xxx", "media", "o", "size", "sd", "board", "in", "es", "b", "body", "binary", "window", "x", "base"], "s": ["ans", "d", "ops", "sg", "services", "fs", "f", "sv", "b", "conf", "v", "south", "sq", "sb", "plugins", "params", "ses", "cs", "r", "u", "sf", "sp", "ss", "ts", "t", "ns", "sa", "a", "es", "storage", "small", "parts", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "xs", "types", "n", "c", "sup", "g", "us", "ssl", "su", "bs", "qs", "rs", "spec", "si", "aws", "e", "details", "is", "sc", "support", "service", "ds", "l", "sym", "m", "ctx", "summary", "as", "bis", "info", "secondary", "o", "js", "os"], "pb": ["wb", "pc", "lb", "gb", "proc", "vp", "ab", "db", "bf", "ppa", "pg", "sb", "pl", "hub", "tp", "p", "bos", "bm", "api", "mp", "buf", "um", "pa", "dp", "fb", "pro", "jp", "cpp", "ctx", "bc", "pm", "nb", "pd", "platform", "pp", "wp", "eb", "PB", "lp", "bh", "uf", "bp", "rb", "xb", "b", "cb", "bs", "fp", "cp", "bps", "parser", "prot", "rob"], "i": ["ui", "bi", "pi", "index", "ie", "j", "di", "d", "multi", "fi", "ti", "p", "slice", "type", "mi", "phi", "qi", "ii", "hi", "ji", "id", "n", "ni", "ip", "abi", "c", "init", "ix", "oi", "f", "zi", "io", "start", "a", "ri", "ini", "info", "gi", "mu", "xi", "x", "uri", "ci", "eni", "z", "b", "iu", "I", "ai", "v", "si", "li"], "out_bytes": ["out_bps", " out_bits", "out__seconds", "out_outs", "in_seconds", "outFbytes", "outFcycles", "out_tes", "outlextes", " out_bps", " out64bits", "outlexbits", "out_cycles", "in_cycles", "outFbits", "out64bytes", "in_bits", "out__bits", "outureouts", "outurebytes", "out_seconds", "out_bits", "outurebits", " out64bytes", "out_lines", "out64bits", "outFseconds", " out_tes", "out__bytes", "in_bytes", "outlexbps", "outurelines", "outlexbytes", "in_lines", " out_seconds", "out64seconds", "in_outs", " out64seconds"], "samples": [" samps", "examples", "pamps", " sources", "exannels", "camples", "sources", "Sages", "Samples", "pamples", "sipes", "samps", "pipes", " sannels", "sages", "cipes", "examps", "camps", "exources", "Sannels", "Samps", "cages", "Sipes", "Sources", "sannels", "pages"]}}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360, "substitutes": {"d": ["data", "dn", "da", "vd", "def", "di", "rad", "db", "diff", "e", "od", "de", "xd", "dh", "did", "dt", "du", "p", "dom", "sync", "done", "and", "session", "ded", "D", "ct", "dos", "config", "td", "ds", "cmd", "ind", "id", "n", "l", "dj", "dict", "dd", "s", "fd", "m", "c", "gd", "t", "dc", "g", "f", "ed", "draw", "nd", "dl", "ad", "dev", "o", "driver", "defined", "dr", "bd", "md", "cd", "sd", "b", "dx", "pd", "ld", "wd", "x", "dat"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "j", "di", "name", "e", "si", "mini", "multi", "fi", "cli", "ti", "p", "api", "type", "phi", "qi", "ii", "adi", "u", "inner", "ji", "ind", "id", "n", "l", "ni", "ip", "ami", "m", "c", "t", "oi", "f", "g", "zi", "io", "ri", "ini", "info", "o", "gi", "xi", "uri", "eni", "ci", "in", "b", "iu", "I", "ai", "v", "x", "li"], "r": ["ru", "br", "re", "rc", "k", "result", "e", "er", "p", "rf", "rg", "rx", "rh", "h", "u", "rr", "n", "l", "res", "sr", "m", "mr", "rd", "t", "c", "g", "f", "range", "ir", "R", "nr", "ri", "err", "w", "ar", "kr", "fr", "dr", "rb", "b", "v", "rs", "x", "rt"], "smram": ["ymgram", "smarm", "mrom", " smRAM", " smarm", "SMRAM", "mmran", "smgam", "ymrum", "smran", "sbram", "mmrum", "slgram", "smrum", "SMran", "slrom", "sbrom", "mgam", " smgram", "mmmm", " smrum", "ymram", "svgram", "slmm", "sharm", " smgam", "smmm", "SMgram", "sbmm", "mmrom", "smRAM", "slram", "marm", " smrom", "svran", "svrum", "sbgram", "shgam", "smgram", "shram", "SMram", "shrom", "svram", "ymRAM", "mram", "mmgram", "smrom", "mmram", "SMrum"], "smram_enabled": ["smram_available", "smream_supported", "smram_disabled", "smam_enabled", "smrom_available", "smram__Enabled", "smream_enable", "smram_led", "smrom_provided", "smram_Enabled", "smram__disabled", "smream_powered", "smam_Enabled", "smram_enable", "smram_provided", "smram__enabled", "smrom_disabled", "smram_powered", "smram_supported", "smam_disabled", "smam_led", "smram__led", "smrom_enabled", "smream_enabled"]}}
{"project": "qemu", "commit_id": "e98768d43799cd3f00b358bfbe455fdae793d3e8", "target": 1, "func": "static int vmdk_open_vmdk4(BlockDriverState *bs,\n\n                           BlockDriverState *file,\n\n                           int flags)\n\n{\n\n    int ret;\n\n    uint32_t magic;\n\n    uint32_t l1_size, l1_entry_sectors;\n\n    VMDK4Header header;\n\n    VmdkExtent *extent;\n\n    int64_t l1_backup_offset = 0;\n\n\n\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (header.capacity == 0) {\n\n        int64_t desc_offset = le64_to_cpu(header.desc_offset);\n\n        if (desc_offset) {\n\n            return vmdk_open_desc_file(bs, flags, desc_offset << 9);\n\n        }\n\n    }\n\n\n\n    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {\n\n        /*\n\n         * The footer takes precedence over the header, so read it in. The\n\n         * footer starts at offset -1024 from the end: One sector for the\n\n         * footer, and another one for the end-of-stream marker.\n\n         */\n\n        struct {\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED footer_marker;\n\n\n\n            uint32_t magic;\n\n            VMDK4Header header;\n\n            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];\n\n\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED eos_marker;\n\n        } QEMU_PACKED footer;\n\n\n\n        ret = bdrv_pread(file,\n\n            bs->file->total_sectors * 512 - 1536,\n\n            &footer, sizeof(footer));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Some sanity checks for the footer */\n\n        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||\n\n            le32_to_cpu(footer.footer_marker.size) != 0  ||\n\n            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||\n\n            le64_to_cpu(footer.eos_marker.val) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.size) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)\n\n        {\n\n            return -EINVAL;\n\n        }\n\n\n\n        header = footer.header;\n\n    }\n\n\n\n    if (le32_to_cpu(header.version) >= 3) {\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"VMDK version %d\",\n\n                 le32_to_cpu(header.version));\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                bs->device_name, \"vmdk\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n\n                        * le64_to_cpu(header.granularity);\n\n    if (l1_entry_sectors == 0) {\n\n        return -EINVAL;\n\n    }\n\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n\n                / l1_entry_sectors;\n\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n    }\n\n    extent = vmdk_add_extent(bs, file, false,\n\n                          le64_to_cpu(header.capacity),\n\n                          le64_to_cpu(header.gd_offset) << 9,\n\n                          l1_backup_offset,\n\n                          l1_size,\n\n                          le32_to_cpu(header.num_gtes_per_gte),\n\n                          le64_to_cpu(header.granularity));\n\n    extent->compressed =\n\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n\n    extent->version = le32_to_cpu(header.version);\n\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n\n    ret = vmdk_init_tables(bs, extent);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4362, "substitutes": {"bs": ["bi", "pb", "lb", "gb", "db", "bf", "sb", "bid", "bos", "BS", "ls", "bl", "ps", "utils", "lbs", "vs", "ses", "cs", "bb", "gs", "bytes", "ds", "fb", "s", "ss", "ba", "ils", "css", "obs", "bc", "bg", "fs", "banks", "ns", "ctx", "bis", "bh", "rb", "js", "b", "ins", "bt", "os", "rs", "bas", "base"], "file": ["data", "library", "fa", "reader", "db", "queue", "play", "name", "loader", "fat", "server", "zip", "base", "ile", "rule", "download", "full", "image", "channel", "bug", "File", "sf", "lib", "files", "fd", "content", "entry", "layer", "fs", "buffer", "f", "il", "path", "source", "io", "comment", "model", "settings", "cache", "bin", "table", "filename", "ca", "fr", "code", "stream", "state", "store", "b", "lock", "http", "fp", "resource", "feed", "work", "binary", "port"], "flags": ["options", "fps", "FLAG", "parts", "mask", "nil", " Flags", "details", "bit", "config", "sf", "lib", "stats", "types", " flag", "files", "ops", "fd", "ils", "version", " bits", "fields", "Flags", "fs", "nl", "ants", "vals", "flag", "settings", "filename", "ints", "fr", "lf", "bits", "features", "locks", "status", "dll", "conf", "linux", "utils"], "ret": ["msg", "mt", "result", "bf", "alt", "back", "str", "num", "res", "sr", "art", "el", "ft", "arg", "data", "hash", "re", "ref", "fun", "wrap", "att", "val", "html", "reg", "run", "cat", "fit", "flag", "det", "match", "code", "valid", "status", "red", "rets", "base", "let", "len", "arr", "no", "RET", "pt", "pass", "req", "gt", "al", "nt", "ag", "mer", "Ret", "format", "fail", "error", "success", "bad", "ll", "over", "resp", "usr", "obj", "lit", "err", "info", "reply", "rl", "final", "rt"], "magic": ["extra", "math", "depth", "reader", "general", "error", "domain", "binary", "special", "mini", "command", "acl", "base", "args", "metadata", "standard", "style", "agent", "orig", "generic", "seq", "module", "bug", "intel", "git", "config", "meta", "cmd", "stat", "cookie", "volume", "pillar", "pointer", "icon", "padding", "mag", "serial", "model", "master", "ini", "journal", "xxx", "cache", "info", "table", "filename", "prefix", "tech", "memory", "slot", "chip", "mic", "MAG", "gen", "kind", "format", "status", "count", "parser", "Magic", "spec", "handler"], "l1_size": ["l1rcapacity", "l1rsize", "l1rlength", "l1_capacity", "l1rsum", "l1_sum", "l3_sum", "l3_capacity", "l3_size", "l3_length", "l1_length"], "l1_entry_sectors": ["l1_entry_psectors", "l1_entry_psegments", "l1_entry_vecs", "l1_entry_vectors", "l1_entry_segments", "l1_entry_vegment", "l1_entry_segment", "l1_entry_gegments", "l1_entry_gegment", "l1_entry_secs", "l1_entry_vegments", "l1_entry_gecs", "l1_entry_psegment", "l1_entry_psecs", "l1_entry_gectors"], "header": ["data", "index", "reader", "frame", "section", "Header", "name", "queue", "message", "document", "er", "server", "container", "event", "rule", "adder", "metadata", "player", "client", "h", "conn", "tail", "module", "offset", "bridge", "config", "headers", "meta", "head", "line", "plugin", "request", "block", "pillar", "her", "creator", "content", "entry", "layer", "version", "buffer", "holder", "comment", "master", "flag", "writer", "parent", "journal", "info", "table", "filename", "manager", "cache", "fr", "cover", "dr", "code", "image", "feature", "channel", "parser", "driver", "token", "handler"], "extent": ["exprent", "Extrent", "exract", "exent", "exension", "Extract", "Extent", "exrent", "expension", "extrent", "extract", "Extension", "extension", "expent", "expract"], "pad": ["pick", "pc", "push", "stack", "bag", "scale", "od", "pod", "bad", "quote", "map", "quad", "pay", "dash", "dump", "offset", "cod", "patch", "blank", "ped", "butt", "add", "address", "shift", "Pad", "padding", "start", "cat", "crop", "mac", "part", "cast", "ad", "amp", "chip", "code", "cap", "ape", "ads", "addr", "cmp", "ptr", "align", "work"], "QEMU_PACKED": ["QEMU_PAATCHed", "QEMU_PAACKED", "QEMU_PAIXED", "QEMU_PAACKed", "QEMU_PAIXled", "QEMU_PACKTED", "QEMU_PACKENDED", "QEMU_PACH_", "QEMU_PIXING", "QEMU_PAATCHTED", "QEMU_PUACKED", "QEMU_PAIXING", "QEMU_PACHED", "QEMU_PUACKENDED", "QEMU_PATCHTED", "QEMU_PAIXed", "QEMU_PIXTED", "QEMU_PATCH_", "QEMU_PIXLED", "QEMU_PAACKTED", "QEMU_PUACKed", "QEMU_POCKED", "QEMU_PACK_", "QEMU_PUACK_", "QEMU_PADDED", "QEMU_PACKled", "QEMU_PATCHED", "QEMU_PADDING", "QEMU_PADDed", "QEMU_PIXed", "QEMU_PADDled", "QEMU_PADDLED", "QEMU_PACKed", "QEMU_PACKLED", "QEMU_PATCHENDED", "QEMU_PAATCHED", "QEMU_PATCHed", "QEMU_PIXED", "QEMU_PACHENDED", "QEMU_PIXled", "QEMU_POCKed", "QEMU_PACHed", "QEMU_PAACKING", "QEMU_PAATCHLED", "QEMU_PAACKled", "QEMU_PACKING", "QEMU_PATCHLED", "QEMU_PAACKLED", "QEMU_POCKled", "QEMU_POCKING", "QEMU_PADDTED"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385, "substitutes": {"control": ["form", "layout", "object", "error", "input", "element", "build", "exec", "controlled", "controller", "core", "server", "command", "event", "sync", "rule", "design", "flow", "type", "client", "full", "edit", "Control", "bridge", "hold", "ack", "config", "off", "contact", "create", "pull", "lib", "connect", "block", "follow", "accept", "contract", "protected", "load", "content", "respond", "forward", "address", "holder", "ctrl", "model", "master", "group", "rol", "close", "sub", "route", "length", "null", "http", "feed", "output", "update"]}}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n", "idx": 4389, "substitutes": {"vser": ["svserver", "evcer", "vserv", "lvserver", "lvsoc", "wSER", "svserv", "vcer", "svcer", "svsoc", "svser", " vSER", "lvser", "wsoc", "vserver", "vSER", "evSER", "wserver", "wser", "svSER", "evser", "lvSER", " vcer", " vserv", "vsoc", "evserv"], "vdev": ["vserv", "voltser", "evdes", " vdes", "lbus", " vdevice", "voltserv", "evdev", "vdevice", "varbus", "ldev", "vbus", "voltdes", "vardev", "varser", "lser", "evser", "vardevice", "ldevice", "voltdev", "vdes", " vserv", " vbus", "evserv"]}}
{"project": "FFmpeg", "commit_id": "56ee3f9de7b9f6090d599a27d33a392890a2f7b8", "target": 0, "func": "static int poll_filter(OutputStream *ost)\n\n{\n\n    OutputFile    *of = output_files[ost->file_index];\n\n    AVFrame *filtered_frame = NULL;\n\n    int frame_size, ret;\n\n\n\n    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n        return AVERROR(ENOMEM);\n\n    } else\n\n        avcodec_get_frame_defaults(ost->filtered_frame);\n\n    filtered_frame = ost->filtered_frame;\n\n\n\n    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n\n        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))\n\n        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,\n\n                                         ost->st->codec->frame_size);\n\n    else\n\n        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (filtered_frame->pts != AV_NOPTS_VALUE) {\n\n        filtered_frame->pts = av_rescale_q(filtered_frame->pts,\n\n                                           ost->filter->filter->inputs[0]->time_base,\n\n                                           ost->st->codec->time_base) -\n\n                              av_rescale_q(of->start_time,\n\n                                           AV_TIME_BASE_Q,\n\n                                           ost->st->codec->time_base);\n\n    }\n\n\n\n    switch (ost->filter->filter->inputs[0]->type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (!ost->frame_aspect_ratio)\n\n            ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n\n\n        do_video_out(of->ctx, ost, filtered_frame, &frame_size);\n\n        if (vstats_filename && frame_size)\n\n            do_video_stats(ost, frame_size);\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        do_audio_out(of->ctx, ost, filtered_frame);\n\n        break;\n\n    default:\n\n        // TODO support subtitle filters\n\n        av_assert0(0);\n\n    }\n\n\n\n    av_frame_unref(filtered_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 4411, "substitutes": {"ost": ["od", "POST", "ocl", "omm", "ood", "ocol", "pod", "bos", "oop", "oster", "roc", "owl", "online", "add", "art", "rost", "nd", "boost", "ort", "iol", "hyd", "ft", "lov", "ot", "stream", "oss", "rob", "object", "ast", "oper", "tto", "ott", "design", "oc", "tt", "orb", "rest", "st", "mot", "oh", "inst", "\u00f3", "ctor", "http", "oid", "OST", "oy", "rss", "eff", "ond", "ocr", "org", "et", "word", "obs", "host", "opt", "om", "ow", "osi", "nt", "ov", "post", "ist", "opp", "sth", "ust", "ord", "server", "op", "ct", "ous", "iot", "dd", "ob", "OD", "hop", "sta", "o", "OT", "dr", "rod", "node", "omp", "osta", "os", "ld"], "of": ["pos", "new", "object", "from", "ou", "set", "one", "on", "de", "to", "e", "with", "ast", "eff", "af", "ol", "df", "no", "alf", "org", "oc", "config", "off", "sf", "at", "orb", "et", "orf", "ob", "fd", "not", "f", "art", "OF", "or", "ow", "sta", "o", "iol", "fr", "Of", "ov", "own", "ot", "http", "os", "comp", "oid"], "filtered_frame": ["filteredUframe", "filcluded_frames", "filtered___frame", "filtered_orig", "filched_frame", "fillated_boot", "filteredUscene", "filtered_point", "fillated67boot", "filteredJframe", "filtered_element", "filteredUclass", "filtered_feature", "filteredKframe", "filteredKhost", "filted_feature", "filched_host", "filtered_message", "filtered1base", "filbedUscene", "filenced_slice", "filters_frame", "filatted_frame", "filbedUmodule", "filtered_Frame", "filted_message", "filtered_host", "filted_fram", "filted_base", "filned67sample", "filters_point", "filned67frame", "filtered___message", "filtered_record", "filned_feature", "filtered_slice", "fillated67frame", "filbed_scene", "filted_board", "filned_point", "filtered00frame", "filched_record", "filtered___video", "filcluded_frame", "filtered_scene", "filtered_thread", "filbedUframe", "filtered_board", "filters_orig", "filteredOframe", "filtered_base", "filered_boot", "filned67point", "filtered67iframe", "fillated67iframe", "filenced_stroke", "filchedOrecord", "filted_element", "filtered67point", "filted_frame", "filned67feature", "filteredJtime", "filtered_time", "filted_thread", "filtered_module", "filned_sample", "filteredOhost", "filchedOscene", "filteredUmodule", "filtered1element", "filatted_scene", "fillated_frame", "filenced_frame", "filtered67frame", "filatted_filename", "filchedOhost", "filned_frame", "filteredKscene", "filered_frame", "filched_scene", "filtered_motion", "filtered__frame", "filchedOframe", "filteredOmodule", "filteredOscene", "filbed_module", "filbedUclass", "filtered_iframe", "filtered1frame", "filbed_class", "filteredOclass", "filteredOrecord", "filtered_line", "filteredKrecord", "filered_time", "filtered___feature", "filted_part", "filtered67sample", "filcluded_Frame", "filtered___fram", "filtered_boot", "filcluded_motion", "filtered67feature", "filtered00thread", "filtered_sample", "filtered_filename", "filtered__line", "filtered_class", "filtered67boot", "filtered00part", "filtered_stroke", "filtered_video", "fillated_iframe", "filters_node", "filtered_fram", "filbed_frame", "filtered___filename", "filtered__fram", "filtered_frames", "filtered__sample", "filteredJiframe", "filteredJboot", "filted_video", "filtered___scene", "filtered_node", "filtered_part"], "frame_size": ["frame1SIZE", "image_resolution", "frame1speed", "frame_format", "framealsize", "page_size", "framealresolution", "frame_speed", "page_width", " frame_speed", "frame1size", "frame64size", "fram_range", "framealformat", "image_SIZE", "frame_resolution", "frame_sized", "image_rate", "image_format", "frame_range", "frame64width", "frame64SIZE", "fram_slice", "fram_width", "fram_size", "frame_width", "image_scale", "frame_slice", "image_size", "framealscale", "frame64scale", "frame_scale", " frame_SIZE", "frame_SIZE", "page_sized", "frame_rate", "frame64slice", "frame64rate", "frame64range"], "ret": ["data", "ext", "re", "rc", "ref", "def", "mt", "result", "rep", "fun", "alt", "att", "success", "back", "value", "len", "val", "sur", "ur", "rf", "arr", "last", "bit", "num", "RET", "empty", "reg", "id", "res", "ut", "all", "run", "fin", "cur", "f", "art", "pass", "lit", "en", "flag", "part", "feat", "det", "ft", "al", "match", "nt", "utf", "rb", "arg", "rets", "Ret", "format", "rt"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "substitutes": {"mr": ["br", "pc", "rc", "timer", "mt", "mm", "rm", "vr", "er", "rg", "rf", "bm", "mid", "rx", "rh", "hr", "pr", "shr", "r", "RR", "usr", "rr", "mn", "tx", "MR", "lr", "sr", "m", "rd", "Mr", "tr", "mc", "tm", "nr", "war", "err", "kr", "yr", "km", "gro", "fr", "dr", "lc", "md", "gr", "rb", "rl", "attr", "rs", "wk", "adr", "rt"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 4479, "substitutes": {"avctx": ["avcontext", "apca", "avcu", "vrctx", "apcn", "axcam", "avcn", "avclient", "avelc", "awclient", "abcu", "AVcam", "afctx", "apctx", "ajcu", "avcp", "awcv", "axcontext", "afcontext", "vrcv", "ajcontext", "afcp", "avlc", "akctx", "abcv", "ajcp", "akcontext", "apcontext", "avecp", "abctx", "afcu", "afcn", "AVcontext", "avca", "abcontext", "axctx", "AVcu", "AVctx", "awcontext", "awctx", "vrcontext", "ajlc", "avcv", "akca", "aflc", "afcam", "avectx", "axcu", "avecontext", "vrclient", "avcam", "afca", "akcn", "ajcv", "afclient", "ajctx", "afcv"], "afq": ["ampiq", "alfck", "affz", "afck", "awQ", "ampz", " afqu", "alfq", "alfquest", "ajq", "ajquest", "awqt", "alfk", " afqa", "afiq", "ajck", " afl", "ajiq", "awl", "awdq", "effquest", "ampquest", "effq", "afct", "afQ", "affqt", "awquest", "afl", "AFu", "affdq", "afk", "avck", " afquery", "fadq", "awiq", "effqa", "afdq", "afz", "ampq", "awk", "affq", "AFl", "awquery", " afu", "avquest", "awq", "avq", "faqt", "alfquery", "AFq", "awu", "afqa", "afu", "avqa", "ampqa", "ampck", "effck", "faq", "alfct", "afqt", "afqu", "faQ", "affqa", "awck", " afz", "ampqu", "afquery", "affQ", "AFk", "awct", "afquest", " afk", "affqu", "alfqa", " afct"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n", "idx": 4488, "substitutes": {"cpu": ["pool", "performance", "vm", "pc", "np", "lb", "proc", "gpu", "component", "GPU", "gc", "clock", "cm", "processor", "intel", "nic", "current", "kernel", "device", "c", "prem", "boot", "px", "pointer", "platform", "mac", "gp", "cache", "alloc", "chip", "cn", "lc", "pu", "process", "disk", "rpm", "cmp", "cp", "computer", "CPU"], "parm": ["nparm", " parms", "param", "para", "npattr", "Park", "lparm", " param", "nparms", "lpark", "pattr", "parms", " pattr", "pparms", "park", "lparms", "pbaram", "pparm", "Parms", "pbattr", "lpara", "nparam", "ppara", "pbarms", "Parm", "ppark", "Para", "pbarm"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint8_t *s = src;\n\n    const uint8_t *end;\n\n    const uint8_t *mm_end;\n\n    uint16_t *d = (uint16_t *)dst;\n\n    end = s + src_size;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*src):\"memory\");\n\n    __asm__ volatile(\n\n        \"movq          %0, %%mm7    \\n\\t\"\n\n        \"movq          %1, %%mm6    \\n\\t\"\n\n        ::\"m\"(red_15mask),\"m\"(green_15mask));\n\n    mm_end = end - 11;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movd          %1, %%mm0    \\n\\t\"\n\n            \"movd         3%1, %%mm3    \\n\\t\"\n\n            \"punpckldq    6%1, %%mm0    \\n\\t\"\n\n            \"punpckldq    9%1, %%mm3    \\n\\t\"\n\n            \"movq       %%mm0, %%mm1    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm3, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"psrlq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $3, %%mm3    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %2, %%mm3    \\n\\t\"\n\n            \"psrlq         $6, %%mm1    \\n\\t\"\n\n            \"psrlq         $6, %%mm4    \\n\\t\"\n\n            \"pand       %%mm6, %%mm1    \\n\\t\"\n\n            \"pand       %%mm6, %%mm4    \\n\\t\"\n\n            \"psrlq         $9, %%mm2    \\n\\t\"\n\n            \"psrlq         $9, %%mm5    \\n\\t\"\n\n            \"pand       %%mm7, %%mm2    \\n\\t\"\n\n            \"pand       %%mm7, %%mm5    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n            \"psllq        $16, %%mm3    \\n\\t\"\n\n            \"por        %%mm3, %%mm0    \\n\\t\"\n\n            MOVNTQ\"     %%mm0, %0       \\n\\t\"\n\n            :\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\n\n        d += 4;\n\n        s += 12;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        const int b = *s++;\n\n        const int g = *s++;\n\n        const int r = *s++;\n\n        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);\n\n    }\n\n}\n", "idx": 4519, "substitutes": {"src": ["rc", "gb", "sq", "loc", "rss", "sb", "sys", "sur", "ls", "slice", "gz", "sc", "image", "img", "r", "dest", "config", "ss", "sr", "c", "cur", "sup", "source", "start", "sn", "inst", "i", "sl", "sub", "rb", "b", "ins", "sel", "rs"], "dst": ["dptr", " dsc", "ddest", " dbl", " dsts", "adptr", "idbl", "Dbl", " dptr", "dysc", "iddest", "dbl", "idsts", "adsc", "idst", "dsts", "adst", "Ddest", "addest", "dyst", "Dst", "dsc", "Dsts", " ddest", "dydest", "dyptr"], "src_size": ["rc_size", "src_cap", " src_end", "src_scale", "src_end", " src_scale", "rc_cap", "rc_scale"], "s": ["opens", "sync", "args", "changes", "id", "seconds", "ops", "services", "fs", "f", "space", "sv", "b", "side", "features", "groups", "v", "south", "sites", "sq", "ats", "sb", "h", "ses", "r", "cs", "u", "sp", "ss", "ts", "t", "ns", "start", "a", "w", "its", "tests", "posts", "es", "q", "sec", "p", "blocks", "ks", "session", "S", "ps", "gs", "sets", "n", "ids", "c", "g", "sup", "us", "ssl", "sl", "su", "spec", "x", "si", "y", "j", "e", "events", "times", "is", "dos", "ds", "l", "states", "days", "sym", "m", "sh", "se", "i", "o", "words", "z", "sd"], "end": ["k", "sec", "set", "begin", "e", "enc", "open", "p", "h", "stop", "r", "win", "dest", "est", "n", "id", "ind", "m", "c", "all", "ion", "t", "st", "End", "f", "day", "nd", "start", "max", "en", "se", "w", "END", "ad", "size", "dev", "ent", "edge", "ff", "ending", "z", "ended", "b", "append", "send", "v", "x"], "mm_end": ["mm_offset", "mm00len", "mm_en", "vm_end", "vm_max", "mm_len", "mm00max", "mm_begin", "vm00end", "sm_begin", "mm_ended", "sm_max", "sm_len", "vm_len", "mm00offset", "vm00max", "mem_en", "mem_ended", "vm00offset", "mm_max", "sm_end", "mem_end", "vm00len", "mem_start", "mm_start", "mm00end", "vm_offset"], "d": ["data", "y", "dn", "da", " D", "j", "di", "diff", "e", "dh", "p", "h", "D", "r", "u", "ds", "ind", "id", "n", "l", "dd", "c", "m", "t", "dy", "dc", "g", "f", "i", "ad", "w", "o", "cd", "z", "sd", "b", "Ds", "dx", "q", "v", "x", "dat"]}}
{"project": "qemu", "commit_id": "e61031cdd81826c433a8bbfa3aca2bae4ffaf845", "target": 1, "func": "static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,\n\n                                void *opaque)\n\n{\n\n    GtkDisplayState *s = opaque;\n\n    int x, y;\n\n    int mx, my;\n\n    int fbh, fbw;\n\n    int ww, wh;\n\n\n\n    fbw = surface_width(s->ds) * s->scale_x;\n\n    fbh = surface_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    x = (motion->x - mx) / s->scale_x;\n\n    y = (motion->y - my) / s->scale_y;\n\n\n\n    if (x < 0 || y < 0 ||\n\n        x >= surface_width(s->ds) ||\n\n        y >= surface_height(s->ds)) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,\n\n                             surface_width(s->ds));\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,\n\n                             surface_height(s->ds));\n\n        qemu_input_event_sync();\n\n    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 4521, "substitutes": {"widget": ["gets", "scope", "layout", "loader", "theme", "skin", "game", "Widget", "wx", "wordpress", "session", "iframe", "image", "win", "fw", "pipe", "draw", "wp", "sl", "w", "scroll", "gui", "wid", "sw", "select", "window"], "motion": ["otion", "mo", "mos", "ui", "comm", "frame", "error", "theme", "element", "mm", "game", "anim", "mpeg", "move", "mp", "flow", "params", "up", "sc", "iframe", "image", "position", "webkit", "sp", "sem", "Motion", "mph", "mega", "video", "effect", "activity", "ss", "mode", "mouse", "draw", "wp", "model", "cam", "speech", "media", "scroll", "down", "km", "me", "upload", "select", "mission"], "opaque": ["OPac", " opque", " oponymous", "opsaque", "opusonymous", "opusque", "opacity", " opac", "OPonymous", "opac", "opaques", "opsonymous", "oponymous", "opsaques", "OPque", "OPaque", "OPacity", " opacity", "opque", "OPaques", "opusaque", "opusacity", " opaques", "opsac"], "s": ["d", "sync", "native", "sports", "site", "ops", "sg", "services", "fs", "f", "views", "en", "side", "features", "b", "conf", "south", "styles", "an", "data", "sites", "sq", "input", "submit", "sb", "plugins", "params", "ses", "r", "cs", "u", "sf", "ions", "ss", "ts", "t", "ns", "a", "its", "tests", "your", "less", "es", "http", "ins", "status", "storage", "parts", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "stats", "n", "c", "css", "g", "us", "ssl", "sl", "su", "qs", "rs", "si", "spec", "scope", "aws", "e", "ows", "server", "details", "is", "service", "ds", "spot", "request", "l", "states", "sym", "m", "sie", "ms", "as", "settings", "se", "i", "o", "words", "js", "os"], "x": ["an", "data", "ex", "index", "area", "on", "value", "e", "d", "name", "fx", "input", "key", "event", "p", "wx", "rx", "cross", "h", "xx", "image", "yx", "position", "win", "xs", "id", "n", "l", "tx", "m", "c", "t", "height", "ix", "px", "f", "wa", "point", "en", "Y", "xy", "i", "w", "xxx", "xp", "X", "xi", "size", "pe", "z", "b", "dx", "ya", "ax", "v"], "y": ["py", "oy", "ty", "ys", "zy", "ady", "name", "d", "ny", "yy", "yt", "iy", "ey", "p", "yi", "wx", "sky", "ish", "ry", "yan", "h", "ay", "ye", "ery", "lon", "sy", "cy", "yo", "vy", "gy", "yl", "m", "height", "t", "dy", "ym", "yn", "Y", "xy", "i", "w", "ky", "o", "python", "z", "b", "ya", "year"], "mx": ["py", "mo", "MX", "mm", "yy", "wm", "fx", "mb", "wx", "rx", "xx", "hz", "mi", "yx", "cm", "webkit", "ml", "fm", "mn", "tx", "cy", "hh", "fy", "zx", "gy", "m", "mr", "pm", "dy", "px", "ym", "ms", "wa", "mc", "mag", "wp", "xy", "wave", "xp", "memory", "me", "md", "ax", "wy"], "my": ["py", "mos", "nm", "nn", "MY", "am", "ady", "mm", "ny", "wm", "yy", "rx", "ry", "ay", "mi", "mys", "mph", "gray", "mn", "My", "cy", "ami", "fy", "gy", "any", "m", "mr", "zx", "sym", "pm", "dy", "ix", "ym", "ms", "mc", "mag", "xy", "ma", "ky", "i", "your", "Mi", "mic", "me", "mis", "md", "ya", "why", "mmm"], "fbh": ["fdw", "pbw", "fbk", "fdh", "bbk", "feh", "fxw", "fxhi", "bx", "ebh", "fdy", "pbh", "pbk", "few", "ebw", "bbh", "bk", "bbsh", "fcx", "bw", "fbx", "fxk", "pbhi", "fch", "ebx", "feg", "fbg", "fsh", "fbsh", "bbhi", "fsx", "bby", "fxsh", "fex", "fxh", "fsg", "fey", "fdsh", "bh", "fek", "bbw", "ebk", "fxy", "fcg", "fby", "fbhi", "fsy", "fcy"], "fbw": ["rbw", "rbx", "cfw", "bbm", "fx", "bbx", "cby", "fh", "bbh", "fw", "fcx", "cbw", "fbx", "cfv", "fy", "fch", "cbx", "fbm", "cfx", "bby", "fcv", "rby", "rbm", "cbh", "bbw", "fv", "cfh", "rbh", "fby", "fbv", "cbm", "fcw"], "ww": ["wb", "nn", "sq", "mm", "fx", "rx", "wx", "wn", "yah", "kw", "xx", "wo", "www", "fw", "sem", "wl", "dd", "hh", "wal", "nw", "tw", "wa", "oh", "wp", "hw", "qa", "gh", "w", "iw", "sw", "wed", "rw", "ew", "dx", "whe", "wow", "wy", "wd", "wk"], "wh": ["ffff", "han", "eth", "mm", "wm", "self", "wx", "kw", "who", "ko", "h", "wo", "hy", "www", "rh", "xx", "hi", "fw", "WH", "sh", "wal", "nw", "tw", "wa", "oh", "hop", "wp", "hw", "wr", "gh", "we", "ph", "w", "sw", "ff", "rw", "sk", "how", "whe", "rah", "Wh", "wy", "wd", "wk"]}}
{"project": "FFmpeg", "commit_id": "b46a77f19ddc4b2b5fa3187835ceb602a5244e24", "target": 0, "func": "int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,\n\n                         int level)\n\n{\n\n    VDPAUHWContext *hwctx = avctx->hwaccel_context;\n\n    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;\n\n    VdpVideoSurfaceQueryCapabilities *surface_query_caps;\n\n    VdpDecoderQueryCapabilities *decoder_query_caps;\n\n    VdpDecoderCreate *create;\n\n    void *func;\n\n    VdpStatus status;\n\n    VdpBool supported;\n\n    uint32_t max_level, max_mb, max_width, max_height;\n\n    VdpChromaType type;\n\n    uint32_t width;\n\n    uint32_t height;\n\n\n\n    vdctx->width            = UINT32_MAX;\n\n    vdctx->height           = UINT32_MAX;\n\n\n\n    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))\n\n        return AVERROR(ENOSYS);\n\n\n\n    if (hwctx) {\n\n        hwctx->reset            = 0;\n\n\n\n        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {\n\n            vdctx->decoder = hwctx->context.decoder;\n\n            vdctx->render  = hwctx->context.render;\n\n            vdctx->device  = VDP_INVALID_HANDLE;\n\n            return 0; /* Decoder created by user */\n\n        }\n\n\n\n        vdctx->device           = hwctx->device;\n\n        vdctx->get_proc_address = hwctx->get_proc_address;\n\n\n\n        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n\n\n        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&\n\n            type != VDP_CHROMA_TYPE_420)\n\n            return AVERROR(ENOSYS);\n\n    } else {\n\n        AVHWFramesContext *frames_ctx = NULL;\n\n        AVVDPAUDeviceContext *dev_ctx;\n\n\n\n        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit\n\n        // is called. This holds true as the user is not allowed to touch\n\n        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format\n\n        // itself also uninits before unreffing hw_frames_ctx).\n\n        if (avctx->hw_frames_ctx) {\n\n            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        } else if (avctx->hw_device_ctx) {\n\n            int ret;\n\n\n\n            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n            if (!avctx->hw_frames_ctx)\n\n                return AVERROR(ENOMEM);\n\n\n\n            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n            frames_ctx->format    = AV_PIX_FMT_VDPAU;\n\n            frames_ctx->sw_format = avctx->sw_pix_fmt;\n\n            frames_ctx->width     = avctx->coded_width;\n\n            frames_ctx->height    = avctx->coded_height;\n\n\n\n            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n            if (ret < 0) {\n\n                av_buffer_unref(&avctx->hw_frames_ctx);\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        if (!frames_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware frames context is \"\n\n                   \"required for VDPAU decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        dev_ctx = frames_ctx->device_ctx->hwctx;\n\n\n\n        vdctx->device           = dev_ctx->device;\n\n        vdctx->get_proc_address = dev_ctx->get_proc_address;\n\n\n\n        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n    }\n\n\n\n    if (level < 0)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        surface_query_caps = func;\n\n\n\n    status = surface_query_caps(vdctx->device, type, &supported,\n\n                                &max_width, &max_height);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    if (supported != VDP_TRUE ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n", "idx": 4524, "substitutes": {"avctx": [" avcas", "navtx", "avecu", "vcu", "AVpkg", " avlc", "hwcmp", "svctx", "afctx", "avtx", "navctx", "afbc", "svcontext", "ovbc", "navlc", "afcmp", "AVcas", "vctx", "hwcf", "navconn", "avbc", "navbc", "avepkg", "hwxc", "avecontext", "avpkg", "navcu", "afconn", "afcu", "vxc", "evctx", "afkb", "AVcu", "AVctx", "vcontext", "aflc", "avkb", "afpkg", "AVlc", "evcontext", "AVcmp", "hwcu", "navcmp", "avcontext", "navcontext", "abcf", "avekb", "avconn", "avecmp", "avxc", "verpkg", "ovcontext", "AVtx", "AVcontext", "abcontext", "svcv", "verkb", "hwcontext", "afcf", "avcmp", "verctx", "svcf", "evcf", "afcv", "vercontext", "avcu", " avcontext", "navcf", "ovconn", "afxc", "ovctx", "avcf", "navpkg", "afcontext", "avlc", "avcas", "abctx", "evcmp", "avcv", "evlc", "avectx", "aftx", "afcas", "navcv", "abcmp"], "profile": ["py", "pb", "def", "view", "val", "program", " preview", "details", " Profile", " prof", "Profile", "image", " profiles", "TYPE", "plugin", " proto", "file", " profiling", "picture", "summary", "buffer", "path", "prof", " prog", " mode", " plugin", "method", "port"], "level": ["scope", "local", "depth", "index", "stack", "scale", "levels", "name", "error", "vel", "limit", "len", "key", "where", "Level", "test", "clean", "line", "id", "stage", "wl", "l", "child", "temp", "mode", "layer", "VEL", "path", "model", "parent", "global", "loop", "code", "lvl", "length", "col", "count", "method", "thread"], "hwctx": ["iwtx", "hwcn", "hwconn", "lvcf", "hwcmp", "lvloc", "iwctrl", "fwsci", "hwctrl", "iwlc", "iwcontext", "rwcmp", "vdloc", "vcctx", "wxctx", "rwlc", "hawcf", "nvcontext", "rwcf", "hwcf", "rwsci", "hlctx", "fwcn", "hwxc", "fwconn", "iwkb", "hwlc", "hawcontext", "hawconn", "lvcontext", "hlcontext", "wxcontext", "fwctx", "fwloc", "hawsci", "hwloc", "fwcf", "iwxc", "hawctx", "iwloc", "hwkb", "wxxc", "avcontext", "hawxc", "rhcf", "iwctx", "vcconn", "rhcontext", "fwcmp", "hwcontext", "avcmp", "fwcontext", "vdcontext", "hlxc", "rwctrl", "iwconn", "lvctx", "vccontext", "rhloc", "nvtx", "vccf", "nvctx", "rhctx", "fwxc", "fwctrl", "hwsci", "avcf", "rwcontext", "wxcmp", "rwloc", "fwtx", "rwkb", "iwcmp", "rwcn", "vdcn", "iwcf", "fwkb", "fwlc", "hlcmp", "nvcmp", "rwctx", "hwtx"], "vdctx": ["xdcontext", "viddc", "vdcf", "sdctx", "vdsync", "hwcmp", "nvctrl", "hwcv", "nvcf", "svctx", "nvpkg", "hdcmp", "vdcp", "dlcontext", "hdconn", "nvcp", "nvcrit", "svcontext", "vcctx", "vvcrit", "hdtx", "vctx", "nvconn", "nvcontext", "hwxc", "nvkb", "vidcontext", "xdctx", "vdtx", "vvdc", "vdcv", "hdpkg", "vdconn", "vdcmp", "svkb", "vvcontext", "hdxc", "hwcp", "nvcli", "sdcv", "sdcontext", "vvcli", "hdctrl", "vidctx", "nvxc", "vdcrit", "vcconn", "vdctrl", "hdkb", "hwcontext", "vdcontext", "xdkb", "nvsync", "hdcontext", "svpkg", "vdcli", "vidcli", "vddc", "dlctrl", "nvcv", "vdkb", "vccontext", "nvtx", "nvctx", "dlsync", "hdctx", "hdsync", "hdcf", "vvcf", "vvctx", "hdcrit", "sdcp", "nvdc", "vdxc", "vdpkg", "dlctx", "xdpkg", "nvcmp"], "surface_query_caps": ["surface_view_abilities", "surface_view_cap", "surface_query_abilities", "surface_view_caps", "surface_view_pieces", "surface_query_pieces", "surface_query_cap"], "decoder_query_caps": ["decoder_query_abilities", "decoder_query_cards", "decoder_request_cap", "decoder_query_cap", "decoder_request_abilities", "decoder_request_cards", "decoder_request_caps"], "create": ["Create", "activate", "save", "open", "call", "write", "sync", "apply", "make", "stage", "enable", "creator", "add", "source", "draw", "parse", "invoke", "construct", "execute", "copy", "media", "define", "creat", "code", "setup", "process", "send", "update"], "func": ["unc", "nc", "fn", "pc", "callback", "conv", "fun", "exec", "cc", "call", "sys", "sync", "src", "function", "apply", "Function", "module", "ack", "cmd", "stage", "execute", "alloc", "code", "pack", "grad", "cb", "process", "setup"], "status": ["complete", "STAT", "result", "success", "name", " Status", "str", "Status", "sync", "function", "current", "stats", "stage", "obj", "mode", "summary", "source", "reason", "state", "active", "process", "unit", "method", "output", "stat"], "supported": ["used", " library", " required", " supports", " platform", " support", "function", "support", "lib", " compatible", " connected", " allowed", " capable", "Supported", "enabled", "platform", "prop", " valid", "mod", "flag", "compatible", " enabled", "valid", "state", "b", "null", " compatibility", " native"], "max_level": [" max_length", "max_layer", " max_layer", "maxallblock", "max67layer", "max_block", "max67block", "maxalllevel", "maxalllayer", "maxalllength", "max_length", "max67level", " max_block", "max67length"], "max_mb": ["min_lvl", "min_mb", "max_mode", "min_level", "max_lvl", "min_mode"], "max_width": [" max_length", "max___weight", "max___length", "max_window", "max___width", "max_weight", "max___window", "max_length", " max_window", " max_weight"], "max_height": ["maxaldata", "maxalwidth", "maxalh", "max_data", " max_data", "maxalheight", " max_h", "max_h"], "type": ["link", "y", "object", "set", "number", " typ", "error", "name", "value", "view", "ype", " TYPE", "key", "typ", "call", "op", "by", "p", "rule", "slice", "function", "style", "position", "unit", "TYPE", " Type", "types", "id", "block", "class", "t", "version", "source", "attribute", "parent", "code", "pe", "Type", "state", "shape", "kind", "role", "time", "resource", "rel", "method", "format", "port"], "height": ["ty", "depth", "layout", "index", "k", "Height", "input", "build", "deep", "container", "h", "history", "pad", "rank", "image", "hold", "thin", "style", "device", "id", "ip", "quality", "dim", "volume", "resolution", "alpha", "weight", "host", "strength", "density", "gap", "draw", "capacity", "padding", "inches", "max", "crop", "w", "stroke", "size", "memory", "definition", "shape", "length", "direction", "window", "x"], "frames_ctx": ["videos_ctx", "frames_lc", "flows_ctx", "flows_lc", "videos_chan", "frames_xc", "videos_context", "videos_xc", "frames_anc", "frames_context", "flows_anc", "frames_chan", "flows_xc"], "dev_ctx": ["dev_cb", "device_alloc", "device_context", "devjcb", "devjctx", "devPctx", "devjalloc", "dev_alloc", "devPalloc", "devjcontext", "devPcontext", "devPcb", "dev_context", "device_cb", "device_ctx"], "ret": ["re", "rc", "conv", "def", "result", "value", "back", "vel", "val", "deep", "ry", "RET", "resp", " result", "res", "all", "layer", "flag", "group", "det", "al", "ag", "col", "row", "Ret"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int estimate_qp(MpegEncContext *s, int dry_run){\n\n    if (s->next_lambda){\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = s->next_lambda;\n\n        if(!dry_run) s->next_lambda= 0;\n\n    } else if (!s->fixed_qscale) {\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);\n\n        if (s->current_picture.f.quality < 0)\n\n            return -1;\n\n    }\n\n\n\n    if(s->adaptive_quant){\n\n        switch(s->codec_id){\n\n        case AV_CODEC_ID_MPEG4:\n\n            if (CONFIG_MPEG4_ENCODER)\n\n                ff_clean_mpeg4_qscales(s);\n\n            break;\n\n        case AV_CODEC_ID_H263:\n\n        case AV_CODEC_ID_H263P:\n\n        case AV_CODEC_ID_FLV1:\n\n            if (CONFIG_H263_ENCODER)\n\n                ff_clean_h263_qscales(s);\n\n            break;\n\n        default:\n\n            ff_init_qscale_tab(s);\n\n        }\n\n\n\n        s->lambda= s->lambda_table[0];\n\n        //FIXME broken\n\n    }else\n\n        s->lambda = s->current_picture.f.quality;\n\n    update_qscale(s);\n\n    return 0;\n\n}\n", "idx": 4539, "substitutes": {"s": ["set", "d", "er", "sync", "args", "vs", "uploads", "ops", "sg", "services", "fs", "f", "b", "features", "grades", "conf", "serv", "south", "sites", "sq", "lines", "submit", "sb", "plugins", "ses", "cs", "r", "u", "ions", "ss", "ts", "t", "uns", "ns", "a", "its", "your", "sis", "rb", "es", "ins", "status", "storage", "uses", "comments", "self", "sys", "p", "ks", "ls", "session", "S", "ps", "ings", "gs", "ims", "sets", "xs", "stats", "n", "c", "css", "g", "us", "ssl", "su", "bs", "qs", "rs", "si", "spec", "scope", "aws", "e", "browser", "server", "times", "is", "service", "ds", "request", "rates", "states", "sym", "m", "ms", "sim", "as", "bis", "settings", "se", "i", "o", "js", "os", "results", "parser"], "dry_run": ["dry__module", "dryowrun", "dry__run", "dryowRun", "dry_true", "dryacmin", " dry_runs", "dyappoutput", "dry_min", "dryOvertrue", "dryowdate", "dryappoutput", "dy_run", "dryappmin", "dyapprun", " dry_module", "dyappmin", "dry_output", "dyappcall", "dryOverRun", " dry_runner", "dryOverdate", "dryOverrun", " dry_true", "dry__runs", "dy_min", "dry__runner", "dryapprun", "dry_runner", "dry_call", "dryacrun", "dry_Run", "dry_module", "dryappcall", "dy_call", " dry_date", "dy_output", "dryacoutput", "dryowtrue", "dry_date", "dryaccall", " dry_Run", "dry_runs"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 4540, "substitutes": {"ctx": ["context", "sci", "rc", "loc", "gpu", "component", "exec", "anc", "cli", "cc", "sync", "connection", "client", "xc", "conn", "sc", "cm", "config", "cmd", "cca", "Context", "tx", "obj", "c", "cgi", "cci", "bc", "cpu", "cv", "cam", "pkg", "qa", "parent", "cu", "ca", "tc", "ci", "lc", "cas", "cb", "vc", "cmp", "cp", "cpp"], "sprn": ["sprname", "prns", " sprN", "Sprname", "sprN", "prname", " sprns", "Sprn", " sprname", "SprN", "sprns", "prN", "Sprns", "prn"], "gprn": ["ggrn", "gPRn", " gPRns", "Gprns", " gPRn", "gsprn", "gprno", "ggrns", "Gprk", "gsprns", "gsprno", " gprns", "gPRno", " gprno", "gprk", "ggrk", "grrN", "gPRN", " gprN", "gsprN", "Gprn", "ggrN", "gprN", "gprns", " gPRno", "grrn", "grrk", "grrns", "GprN", " gPRN", "gPRns"]}}
{"project": "qemu", "commit_id": "46746dbaa8c2c421b9bda78193caad57d7fb1136", "target": 0, "func": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)\n\n{\n\n#ifdef CONFIG_KVM\n\n    struct kvm_irqfd irqfd = {\n\n        .fd = event_notifier_get_fd(&vdev->intx.interrupt),\n\n        .gsi = vdev->intx.route.irq,\n\n        .flags = KVM_IRQFD_FLAG_RESAMPLE,\n\n    };\n\n    struct vfio_irq_set *irq_set;\n\n    int ret, argsz;\n\n    int32_t *pfd;\n\n\n\n    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||\n\n        vdev->intx.route.mode != PCI_INTX_ENABLED ||\n\n        !kvm_resamplefds_enabled()) {\n\n        return;\n\n    }\n\n\n\n    /* Get to a known interrupt state */\n\n    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);\n\n    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n    vdev->intx.pending = false;\n\n    pci_irq_deassert(&vdev->pdev);\n\n\n\n    /* Get an eventfd for resample/unmask */\n\n    if (event_notifier_init(&vdev->intx.unmask, 0)) {\n\n        error_report(\"vfio: Error: event_notifier_init failed eoi\");\n\n        goto fail;\n\n    }\n\n\n\n    /* KVM triggers it, VFIO listens for it */\n\n    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);\n\n\n\n    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {\n\n        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    argsz = sizeof(*irq_set) + sizeof(*pfd);\n\n\n\n    irq_set = g_malloc0(argsz);\n\n    irq_set->argsz = argsz;\n\n    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;\n\n    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;\n\n    irq_set->start = 0;\n\n    irq_set->count = 1;\n\n    pfd = (int32_t *)&irq_set->data;\n\n\n\n    *pfd = irqfd.resamplefd;\n\n\n\n    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);\n\n    g_free(irq_set);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");\n\n        goto fail_vfio;\n\n    }\n\n\n\n    /* Let'em rip */\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n\n\n    vdev->intx.kvm_accel = true;\n\n\n\n    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);\n\n\n\n    return;\n\n\n\nfail_vfio:\n\n    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;\n\n    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);\n\nfail_irqfd:\n\n    event_notifier_cleanup(&vdev->intx.unmask);\n\nfail:\n\n    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n#endif\n\n}\n", "idx": 4551, "substitutes": {"vdev": ["vdiff", "vde", "Vdie", "pdd", "fdevice", "hdb", "pmd", "Vdc", "mdiff", "tvdiff", "kdef", " vmd", " vgu", "fdev", "pdiff", "svdev", "qdevice", "tvdev", "kdi", "voltdev", "jdef", "qdiv", "vdie", "nvdiv", "fdiff", "vdef", "nvdd", "kdev", "pdiv", "vdi", " vdi", "kdiv", " vdd", "gdc", "qdev", "pdevice", "voltdiv", "kde", "Vver", "pgu", "kver", "mdie", "vdebug", "mdev", "tvdb", " vdiv", "hdiff", "kdie", "svde", "hdevice", "nvdiff", "gdef", "voltrad", "pdev", "vdc", " vdebug", "krad", "vdd", "nvdie", "tvdevice", "nvdev", "pdb", "fver", "kdebug", "jrad", "mdiv", "pdie", "jdev", " vde", "svdie", "vmd", "vdb", "jdevice", "Vdi", " vdiff", "jdiv", "hdev", "qdebug", "gdev", "vgu", "svdc", "pver", "vver", "vdiv", "kdevice", " vdevice", "voltdi", "jdi", "Vdef", "Vdevice", "vdevice", " vver", "jdc", "kdc", "nvmd", "Vdev", "Vde", "vrad", "nvgu", "gdevice"], "irq_set": ["irq__send", "irshMexport", "irsh_export", "irsh_set", "irq_SET", "irq_default", "irq__id", "irqu_add", "irq_setting", "irquest__get", "irquest__send", "irQ_add", "irquest_send", "irq1default", "irquest_open", "irq_export", "irq_init", "irb_send", "irqu_Set", "irqu1set", "irqfopen", "irQ_get", "irqsid", "irqu1setting", "irq_open", "irqqset", "irqssend", "irqu_default", "irquest_et", "irqqdefault", "irqfSet", "irqrexport", "irq_get", "irq1set", "irqfget", "irshMsend", "irb_set", "irq_write", "irquest_init", "irq_id", "irqu1default", "irshMset", "irQ_set", "irquest_set", "irq_send", "irqrset", "irqMsend", "irqu_open", "irqu_set", "irqu1add", "irqsget", "irqu_setting", "irqfset", "irqrsetting", "irqMexport", "irq1setting", "irq__get", "irqfid", "irshMsetting", "irqqadd", "irqfsend", "irQ_write", "irqMsetting", "irq_add", "irq_Set", "irsh_setting", "irqrsend", "irqqsetting", "irqu_get", "irquest_id", "irquest__set", "irqMset", "irqsset", "irb_SET", "irquest_get", "irq__set", "irq_et", "irquest__id", "irq_start", "irb_start", "irsh_send", "irq1add"], "ret": ["rc", "sec", "def", "j", "fun", "len", "val", " RET", " Ret", "mem", "std", " rc", "ry", "RET", "sy", "reg", "res", " resp", "flag", " len", " gen", "nt", " code", " success", " res", "rets", "Ret"], "argsz": ["paramsz", "argza", "amsz", "valszip", "arggz", "argzen", "argsza", "argz", "argx", "bitsize", "amsZ", "bitsy", " argsiz", "bitszip", "argzip", "argsize", "argize", "paramsiz", "argszip", "argsx", "argzo", "paramszip", "argZ", "argy", "valsz", " argsZ", "bitsz", "valszo", "amsza", "argszo", " argsx", "argsZ", "Argsz", "amszen", " argszen", "argsy", "paramsy", "argiz", "Argsiz", "argsiz", " argsza", "Argsgz", "argszen", "argsgz", "Argsx", "paramszo", " argsgz", "valsiz", "ArgsZ", "paramsize"], "pfd": ["PFD", "Pf", "qfd", "qd", "cpFD", " pdf", "fFD", "Pdf", "ffd", "Pfd", "pf", " pd", "qdf", "cpdf", "pFD", " pFD", "pdf", "qFD", "cpfd", "fdf", "ff", " pf", "cpd", "pd"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 4555, "substitutes": {"ctx": ["context", "sci", "cfg", "nc", "pc", "rc", "cal", "wcs", "loc", "gpu", "component", "exec", "cc", "cli", "sync", "que", "cz", "cus", "sc", "conn", "xc", "ct", "cm", "cs", "git", "config", "crit", "cmd", "jp", "cca", "Context", "tx", "obj", "txt", "cms", "ck", "c", "css", "cgi", "bc", "cpu", "kb", "ctrl", "cv", "cam", "pkg", "hw", "qa", "fc", "cu", "cf", "ca", "tc", "cn", "ci", "lc", "gru", "cas", "grad", "vc", "comp", "cp", "cpp", "cmp", "linux"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 4556, "substitutes": {"opaque": ["ipopca", " opque", "operity", "oopicit", "ipopaques", " opca", "oopity", "opacity", "ipopacity", " opity", "opericit", "opity", "operque", "opaques", "oopaque", "operaque", "opicit", "operacity", "oopque", " opacity", "opque", "operca", "opca", " opaques", " opicit", "ipopaque", "operaques"], "offset": ["data", "pos", "object", "index", "reset", "ref", "set", "seed", "url", "optional", "error", "loc", "limit", "len", "key", "sync", "Offset", "no", "slice", "type", "seq", "position", "off", "et", "id", "skip", "mode", "entry", "address", "next", "pointer", "shift", "range", "location", "start", "padding", "attribute", "phase", "part", "slot", "parent", "initial", "alloc", "o", "fee", "delay", "bound", "notation", "length", "null", "timeout", "alias", "addr", "ptr", "align", "oid", "base"], "size": ["data", " bytes", "args", "SIZE", "bytes", " length", "ize", "Size", "address", "length", "ptr"], "s": ["er", "sync", "ops", "sg", "services", "fs", "f", "ar", "has", "b", " symbols", "south", "sq", "sb", "ses", "cs", "r", " results", "sf", "ing", " defaults", "ions", "ss", "ts", "t", "ns", "sa", "a", "its", "w", "ports", "es", "ins", "status", "hs", "storage", "ers", "sys", "p", "ls", "session", "S", "ps", "ings", "ies", "gs", "sets", "stats", "types", " values", "c", " parts", "g", "ed", "us", "ssl", "sl", "qs", "rs", "si", "scope", "y", "aws", "e", "erences", " signals", " statements", "server", "is", "sy", "service", "ds", "l", "states", "sym", "m", "as", "ums", "settings", "als", "i", "o", "secondary", " entries", "js", "os", "results", "ors"]}}
{"project": "qemu", "commit_id": "430b26a82da61876c4eaf559ae02332582968043", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    s->config_file = g_strdup(qemu_opt_get(opts, \"config\"));\n\n    ret = read_config(s, s->config_file, options, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the image file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    bs->supported_write_flags = BDRV_REQ_FUA &\n\n        bs->file->bs->supported_write_flags;\n\n    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &\n\n        bs->file->bs->supported_zero_flags;\n\n    ret = -EINVAL;\n\n\n\n    /* Set request alignment */\n\n    s->align = qemu_opt_get_size(opts, \"align\", 0);\n\n    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {\n\n        error_setg(errp, \"Cannot meet constraints with align %\" PRIu64,\n\n                   s->align);\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (ret < 0) {\n\n        g_free(s->config_file);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 4563, "substitutes": {"bs": ["bi", "iss", "pb", "lb", "gb", "outs", "sb", "plugins", "sync", "blocks", "ks", "BS", "ls", "bl", "socket", "client", "ps", "full", "Bs", "is", "ses", "vs", "utils", "cs", "bb", "gs", "bytes", "ros", "ds", "ubs", "qs", "fb", "file", "tails", "obj", "ops", "ss", "bes", "ts", "css", "ils", "ctx", "bc", "obs", "fs", "web", "ns", "banks", "sa", "bis", "us", "bin", "als", "its", "bh", "bits", "state", "js", "b", "es", "cb", "ins", "os", "bt", "bing", "bps", "http", "rs", "bas", "las", "base"], "options": ["scope", "keys", "optional", "pre", "opens", "outs", "cho", "e", "to", "none", "op", "p", "details", "args", "params", "ps", "values", "config", "lib", "pro", "option", "obj", "files", "ops", "c", "ts", "css", "fs", "f", "opt", "Options", "io", "array", "vals", "settings", "json", "info", "sl", "global", "o", "cache", "js", "es", "errors", "http", "os", "x"], "flags": ["FLAG", "parts", "mask", " Flags", "args", "bytes", "stats", "ents", "files", "ops", "lag", " bits", "ags", "fields", "Flags", "fs", "ants", "vals", "flag", "settings", "ints", "bits", "features", "format", "errors", "rets", "ips"], "errp": ["errf", "orderfp", "derc", "cryf", "errr", "errorpo", " errfp", "orderp", " errping", "crypc", "erp", " errpc", "errP", "ierp", " errper", " errpo", "yrpr", "errping", " errpr", "rrr", "errpre", "erpc", "errper", " erping", "errorp", " erp", "derpe", "yrpe", "rrfp", " erf", "yrp", "erpre", "errpc", " errpe", "derp", "derpr", "errpr", "erfp", "errorP", "rrpre", "ierper", " errP", " errr", "errfp", "orderpo", "errpe", " errc", "err", "ierf", "erf", "orderP", "cryp", "errorfp", "cryr", " errpre", " erper", "yrc", "rrp", "errc", "errpo", "ierping", " errf"], "s": ["d", "sync", "args", "site", "ops", "sg", "services", "fs", "f", "b", "sb", "plugins", "params", "h", "ses", "cs", "r", "u", "ss", "ts", "t", "uns", "ns", "sa", "its", "your", "http", "hs", "iss", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "n", "c", "css", "obs", "g", "ssl", "sl", "state", "su", "qs", "rs", "spec", "si", "scope", "e", "is", "service", "ds", "l", "states", "as", "bis", "settings", "i", "o", "secondary", "words", "js", "os"], "opts": ["okps", "copps", "optt", "copcs", "olpt", " oppt", "expercs", "olts", "OPcs", "okts", "operters", " optts", "OPtics", "oppt", "OPts", "olt", "experts", "catts", "copt", "optuts", "catters", "OPters", "expertics", "experters", "optty", "OPgs", "catuts", "copty", " optta", "copted", " opters", "optts", "optes", " optes", "olgs", " optt", " optcs", " opgs", "opted", "oputs", "opters", "opt", " opt", "opcs", "opta", " opted", " opcs", "opttes", "operps", "optted", "opps", "optcs", "copts", "okty", "optics", " opta", " oputs", "copters", "okt", "opty", "opgs", "optps", " opps", "OPpt", "OPt", "coptics", "opertes", "operts", "catcs", "optters", "optta"], "local_err": ["global_error", " local_error", "local_msg", "localIPerr", "local_error", "remote_msg", "remote_rh", "local_rh", "local5err", "local\u00b7err", "localererr", "global_err", "local_break", "localerout", "localacerror", "remote_error", "recent_err", "local_doc", " local_cry", "localalinit", " local_msg", "localIPorig", "global_init", "local_orig", "remote_err", "global_break", "local\u00b7error", "localalerror", "localacerr", "recent_orig", "localacinit", "localIPerror", "localererror", "recent_error", "local5error", " local_doc", "local\u00b7rh", "localalerr", " local_out", "local_init", "localercry", "local_er", "recentIPerror", "local5doc", "localalbreak", "local\u00b7er", "remote_er", "local_cry", "localacbreak", "remote_errors", "recentIPorig", "local_errors", "local_out", "recentIPerr"], "ret": ["pet", "mt", "result", "alt", "str", "num", "id", "res", "art", "en", "ft", "arg", "data", "re", "ref", "fun", "att", "val", "lt", "reg", "t", "run", "cat", "fit", "flag", "part", "det", "match", "code", "valid", "status", "rets", "base", "pat", "let", "ext", "pub", "len", " Ret", "sil", "mem", "no", "RET", "pt", "opt", "pass", "rev", "feat", "gt", "al", "nt", "active", "mer", "Ret", "x", "def", "success", " RET", "bit", "out", "ut", "obj", "fin", "lit", "reply", "sat", "rt"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n", "idx": 4569, "substitutes": {"str": ["br", "func", "text", "e", "enc", "er", "exec", "arr", "p", "style", "pr", "r", "Str", "cs", "sp", "STR", "rr", "res", "s", "txt", "sr", "st", "stri", "f", "fr", "code", "dr", "gr", "iter", "ptr", "rs"], "err": ["msg", "rc", "pre", "error", "result", "e", "try", "ner", "er", "ler", "arr", "rh", "order", "test", "pr", "r", "resp", "inner", "ind", "rr", "ctr", "n", "res", "var", "lr", "cr", "Er", "req", "nr", "Error", "ise", "der", "ar", "ver", "fr", "code", "dr", "gr", "valid", "iter", "aster", "cb"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,\n\n                                  unsigned size)\n\n{\n\n    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;\n\n    int w, i;\n\n    uint32_t ret = 0;\n\n\n\n    DPRINT_L2(\"read offset 0x%08x\\n\", offset);\n\n\n\n    switch (offset) {\n\n    case FIMD_VIDCON0 ... FIMD_VIDCON3:\n\n        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];\n\n    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:\n\n        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];\n\n    case FIMD_WINCON_START ... FIMD_WINCON_END:\n\n        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;\n\n    case FIMD_SHADOWCON:\n\n        return s->shadowcon;\n\n    case FIMD_WINCHMAP:\n\n        return s->winchmap;\n\n    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:\n\n        w = (offset - FIMD_VIDOSD_START) >> 4;\n\n        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;\n\n        switch (i) {\n\n        case 0:\n\n            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<\n\n            FIMD_VIDOSD_HOR_SHIFT) |\n\n            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 1:\n\n            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<\n\n                FIMD_VIDOSD_HOR_SHIFT) |\n\n                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 2:\n\n            if (w == 0) {\n\n                ret = s->window[w].osdsize;\n\n            } else {\n\n                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<\n\n                    FIMD_VIDOSD_AEN0_SHIFT) |\n\n                    pack_upper_4(s->window[w].alpha_val[1]);\n\n            }\n\n            break;\n\n        case 3:\n\n            if (w != 1 && w != 2) {\n\n                DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n                return 0xBAADBAAD;\n\n            }\n\n            ret = s->window[w].osdsize;\n\n            break;\n\n        }\n\n        return ret;\n\n    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:\n\n        w = (offset - FIMD_VIDWADD0_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;\n\n        return s->window[w].buf_start[i];\n\n    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:\n\n        w = (offset - FIMD_VIDWADD1_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;\n\n        return s->window[w].buf_end[i];\n\n    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:\n\n        w = (offset - FIMD_VIDWADD2_START) >> 2;\n\n        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<\n\n            FIMD_VIDWADD2_OFFSIZE_SHIFT);\n\n    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:\n\n        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];\n\n    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:\n\n        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;\n\n        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;\n\n        return s->window[w].keycon[i];\n\n    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:\n\n        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;\n\n        return s->window[w].keyalpha;\n\n    case FIMD_DITHMODE:\n\n        return s->dithmode;\n\n    case FIMD_WINMAP_START ... FIMD_WINMAP_END:\n\n        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;\n\n    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:\n\n        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];\n\n    case FIMD_TRIGCON:\n\n        return s->trigcon;\n\n    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:\n\n        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];\n\n    case FIMD_COLORGAINCON:\n\n        return s->colorgaincon;\n\n    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:\n\n        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];\n\n    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:\n\n        i = (offset - FIMD_SIFCCON0) >> 2;\n\n        return s->sifccon[i];\n\n    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:\n\n        i = (offset - FIMD_HUECOEFCR_START) >> 2;\n\n        return s->huecoef_cr[i];\n\n    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:\n\n        i = (offset - FIMD_HUECOEFCB_START) >> 2;\n\n        return s->huecoef_cb[i];\n\n    case FIMD_HUEOFFSET:\n\n        return s->hueoffset;\n\n    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:\n\n        w = ((offset - FIMD_VIDWALPHA_START) >> 3);\n\n        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;\n\n        return s->window[w].alpha_val[i] &\n\n                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);\n\n    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:\n\n        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;\n\n    case FIMD_BLENDCON:\n\n        return s->blendcon;\n\n    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:\n\n        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;\n\n    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:\n\n        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];\n\n    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];\n\n    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;\n\n    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;\n\n    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:\n\n        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;\n\n    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:\n\n        w = (offset - FIMD_PAL_MEM_START) >> 10;\n\n        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:\n\n        /* Palette aliases for win 0,1 */\n\n        w = (offset - FIMD_PALMEM_AL_START) >> 10;\n\n        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    }\n\n\n\n    DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n    return 0xBAADBAAD;\n\n}\n", "idx": 4570, "substitutes": {"opaque": ["operalias", "OPac", " opque", " opacs", "opatile", "oplaque", "opacs", "opacity", "OPacs", "oplacity", " opac", "opac", "operaque", "ipque", "opalias", "ipac", "OPque", "OPaque", "ipacs", "operacity", "ipaque", " opalias", " opacity", "opque", "oplalias", "oplatile", " opatile", "operatile"], "offset": ["operation", "pos", "index", "set", "starting", "element", "sync", "Offset", "api", "slice", "type", "energy", "off", "id", "ip", "online", "f", "range", "location", "timeout", "fp", "lock", "data", "seed", "ref", "limit", "afi", "position", "iso", "mode", "alpha", "address", "next", "start", "attribute", "part", "bound", "null", "addr", "ptr", "oid", "base", "outer", "url", "number", "len", "p", "connection", "style", "image", "et", "block", "entry", "shift", "padding", "slot", "alloc", "length", "align", "reset", "end", "optional", "error", "loc", "bit", "seq", "bytes", "exclusive", "buffer", "pointer", "array", "phase", "reference", "o", "esi", "alias"], "size": ["data", " sizes", " bytes", " error", "len", "args", "SIZE", "bytes", " length", "ize", "Size", "length", "timeout", "count", "align"], "s": ["er", "sync", "ops", "sg", "services", "fs", "f", "b", "conf", "v", "sq", "outs", "lines", "sb", "ses", "r", "cs", " results", "ing", "sf", "ions", " services", "ss", "ts", "t", "uns", "ns", "sa", "or", "its", "es", "ools", "ins", "hs", "ers", "sys", "self", "p", "ls", "session", "S", "ps", "ings", "ies", "gs", "sets", "ches", "stats", "rows", "c", "g", "ed", "us", "ssl", "sl", "su", "qs", "rs", "spec", "si", "aws", "e", "ows", "is", "service", "ds", "l", "states", "sym", "m", "settings", "o", "secondary", "js", "results", "utils"], "w": ["wb", "y", "index", "k", "end", "e", "d", "way", "ww", "now", "widget", "wall", "p", "wx", "W", "kw", "h", "wo", "num", "r", "win", "u", "off", "fw", "current", "n", "l", "wl", "c", "wal", "m", "t", "wan", "nw", "f", "tw", "g", "wa", "wei", "ow", "a", "wp", "we", "o", "wt", "iw", "nt", "week", "sw", "z", "rw", "b", "ew", "aw", "wait", "q", "work", "v", "window", "wk", "x"], "i": ["bi", "ui", "pi", "index", "k", "end", "j", "di", "e", "d", "ti", "p", "type", "mi", "ii", "u", "ret", "id", "n", "ni", "l", "ip", "m", "c", "t", "f", "zi", "start", "ini", "gi", "it", "x", "xi", "ci", "z", "b", "iu", "I", "v", "si", "li"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n", "idx": 4571, "substitutes": {"a": ["an", "data", "area", "au", "ab", "value", "input", "ae", "d", "ea", "A", "p", "ata", "h", "u", "pa", "n", "abc", "c", "m", "aux", "ba", "alpha", "f", "sa", "as", "i", "ma", "ad", "ga", "la", "ac", "b", "aa", "x"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qemu_chr_open_null(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ChardevCommon *common = backend->u.null;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 4607, "substitutes": {"id": ["root", "data", "url", "oid", "ref", "def", "sid", "name", "ident", "rid", "bid", "iq", "client", "seq", "create", "ip", "fd", "ids", "ID", "init", "wire", "path", "parent", "info", "uri", "code", "cb", "base"], "backend": ["Backend", "frontward", "backen", "frontender", " backended", "Backen", "Backender", "backid", "frontended", "Backid", " backward", "frontid", "frontend", " backen", " backid", " backender", "Backended", "backward", "backender", "backended", "fronten", "Backward"], "ret": ["complete", "data", "re", "rc", "ref", "def", "proc", "result", "success", "exec", "val", "fi", "mem", "gc", "buf", "conn", "RET", "lib", "reg", "obj", "res", "lex", "aux", "rec", "lit", "Ret"], "errp": ["acepi", "errr", " errfp", "errorpre", "erp", " errpi", "errP", "reqP", "errorp", "errps", "errpi", "erpre", "erfp", " errP", "errorr", " errr", "aceps", "reqp", "err", "aceP", "errfp", "errpre", "acep", "errorfp", " errpre", "reqps", "reqpi", " errps"], "chr": ["schrb", " chrc", "Chrn", " chrg", " chrb", "chru", "archru", "Chr", "charrn", " chb", "cherc", "chsr", "Chsr", "schr", "chdr", "Chrc", "anchr", "schrt", "chrr", " chsr", "chert", "Chb", "anchdr", "grri", "echb", "chardr", "charr", " chdr", "grrr", "echsr", "cher", "chri", "echr", "anchrt", "chrt", "chb", "cherrr", "cherb", "chrg", "cherr", "archri", "cherri", "Chrt", "grr", "chrn", "cherru", "charrb", "archr", "chrb", "Chrb", " chrn", "charrt", " chrt", "chern", "anchrg", "echrb", "archrr", "chrc", "grru", "charrg", "schrn"], "common": ["context", "foreign", "basic", "family", "general", "control", "document", "custom", "util", "native", "standard", "client", "known", "generic", "shared", "lib", "broad", "specific", "ctx", "comment", "parent", "cache", "global", "security", "info", "central", "recent", "valid", "complex", "normal", "con", "conf", "cmp", "fast", "public", "Common"]}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4609, "substitutes": {"s": ["sq", "aws", "e", "d", "sb", "sys", "self", "p", "sync", "spec", "ks", "args", "ls", "session", "S", "socket", "is", "ps", "ses", "site", "gs", "sets", "cs", "service", "u", "ds", "stat", "xs", "states", "ops", "ss", "m", "c", "ts", "sym", "services", "t", "sg", "v", "fs", "g", "ns", "f", "as", "a", "syn", "ssl", "settings", "se", "o", "its", "sis", "sv", "su", "js", "es", "in", "status", "hs", "os", "conf", "qs", "south", "si"], "mode": ["mo", "Mode", " module", "iden", "scale", "sid", "de", "ODE", "name", "slave", "gone", "cli", "grade", "no", "ode", "type", "style", "ace", "module", "device", " modes", "stage", "dim", "dd", "MODE", "ward", " m", "range", "source", "mod", "mac", "phase", "rage", "table", "loop", "code", "md", "level", "dm", "lane", "state", "side", "kind", "role", "direction", "driver"], "key": ["data", "link", "keys", "index", "k", "ie", "seed", "j", "kid", "error", "result", "e", "name", " Key", "er", "call", "ey", "connection", "kw", "type", "client", "order", "ace", "cor", "query", "service", "id", "ip", " connection", "class", "net", "ck", "ctx", "group", "info", "KEY", "fee", "match", "code", "pe", "state", "sk", "Key", "lock", "ke", "row", "ee", "x"], "pkt": ["Pcht", "cpct", "ppkt", "pet", "Pck", "parct", " pct", " pck", "pelt", "ppacket", "ppck", "parcht", "apet", "pnt", "payet", "ppwk", " pwk", "Pwk", "ppet", "payacket", "pk", "Pnt", "Pct", "ppnt", "cpkt", "apcht", " pet", "cpet", "pck", "pwk", "Pk", " pnt", "apkt", "ppelt", "Pelt", "cpelt", "Picket", " pcht", "cpacket", "parkt", "packet", " packet", "pcht", "apacket", "Pet", "paracket", "Pkt", "pct", "paykt", "Packet", "payicket", " pk", " picket", "picket", "ppk"], "conn": ["nc", "dn", "pc", "comm", "oa", "db", "enc", "pg", "auth", "co", "ai", "core", "cc", "p", "sync", "gn", "connection", "session", "client", "ann", "org", "ct", "cm", "cs", "ch", "config", "cmd", "reg", "n", "connect", "rn", "go", "Conn", "c", "sg", "wan", "ctx", "dc", "g", "ns", "act", "nw", "mc", "cat", "ec", "conf", "en", "syn", "ad", "gate", "ca", "cf", "ga", "nt", "cn", "ci", "lc", "ac", "adj", "po", "con", "cp", "oss", "rt"]}}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)\n\n{\n\n    int i;\n\n    for(i=0; i<4 && tags[i]; i++){\n\n        enum CodecID id= codec_get_id(tags[i], tag);\n\n        if(id!=CODEC_ID_NONE) return id;\n\n    }\n\n    return CODEC_ID_NONE;\n\n}\n", "idx": 4610, "substitutes": {"tags": ["users", "relations", "nets", "xml", "classes", "mat", "frames", "terms", "devices", "phones", "boxes", "p", "blocks", "ks", "chains", "codes", "ps", "tools", "atts", "ims", "Tags", "types", "stats", "heads", "rows", "s", "packages", "ids", "c", "ts", "strings", "members", "ags", "fields", "cases", "cats", "jobs", "names", "ports", "words", "tests", "bags", "images", "bands", "features", "reports", "groups", "bugs", "styles"], "tag": ["date", "name", "loc", "key", "bad", "type", "bit", "num", "image", "tail", "bug", "r", "patch", "at", "ind", "id", "month", "option", "ig", "comment", "cat", "attribute", "cache", "match", "code", "category", "Tag", "TAG", "ag", "length", "b", "time", "count", "year", "port"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "end", "j", "di", "e", "d", "si", "multi", "fi", "ti", "p", "slice", "h", "is", "mi", "phi", "qi", "ii", "r", "u", "ind", "id", "l", "ip", "m", "init", "ix", "oi", "f", "io", "a", "ri", "ini", "part", "info", "o", "gi", "it", "xi", "uri", "ci", "b", "iu", "I", "ai", "v", "x", "li"]}}
{"project": "qemu", "commit_id": "27e0c9a1bbd166a67c16291016fba298a8e47140", "target": 0, "func": "static void ide_atapi_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n\n\n    if (s->identify_set) {\n\n\tmemcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));\n\n\treturn;\n\n    }\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    /* Removable CDROM, 50us response, 12 byte packets */\n\n    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));\n\n    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */\n\n    put_le16(p + 20, 3); /* buffer type */\n\n    put_le16(p + 21, 512); /* cache size in sectors */\n\n    put_le16(p + 22, 4); /* ecc bytes */\n\n    padstr((char *)(p + 23), s->version, 8); /* firmware version */\n\n    padstr((char *)(p + 27), \"QEMU DVD-ROM\", 40); /* model */\n\n    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */\n\n    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */\n\n    put_le16(p + 62, 7);  /* single word dma0-2 supported */\n\n    put_le16(p + 63, 7);  /* mdma0-2 supported */\n\n#else\n\n    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */\n\n    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */\n\n#endif\n\n    put_le16(p + 64, 3); /* pio3-4 supported */\n\n    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */\n\n    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */\n\n    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */\n\n    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */\n\n\n\n    put_le16(p + 71, 30); /* in ns */\n\n    put_le16(p + 72, 30); /* in ns */\n\n\n\n    if (s->ncq_queues) {\n\n        put_le16(p + 75, s->ncq_queues - 1);\n\n        /* NCQ supported */\n\n        put_le16(p + 76, (1 << 8));\n\n    }\n\n\n\n    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */\n\n#endif\n\n    memcpy(s->identify_data, p, sizeof(s->identify_data));\n\n    s->identify_set = 1;\n\n}\n", "idx": 4611, "substitutes": {"s": ["set", "sync", "args", "site", "sg", "services", "fs", "f", "b", "features", "conf", "new", "sq", "sb", "plugins", "ses", "r", "cs", "sf", "sp", "ions", "ss", "ts", "t", "ns", "a", "its", "your", "sis", "es", "status", "hs", "ins", "parts", "comments", "sys", "ks", "ls", "session", "S", "ps", "gs", "sets", "xs", "stats", "n", "c", "g", "us", "ssl", "sl", "state", "qs", "rs", "spec", "si", "y", "aws", "e", "is", "service", "ds", "l", "sts", "states", "sym", "ms", "as", "settings", "se", "i", "js", "os"], "p": ["py", "data", "pb", "br", "y", "pi", "pc", "np", "k", "j", "proc", "vp", "pre", "progress", "e", "d", "pg", "pl", "tp", "op", "api", "prev", "u", "mp", "h", "ps", "up", "pr", "patch", "pa", "dp", "sp", "at", "P", "n", "l", "ip", "jp", "per", "ap", "hp", "press", "current", "m", "c", "t", "g", "f", "pointer", "page", "pp", "point", "wp", "part", "i", "o", "it", "ar", "lp", "pe", "bp", "z", "b", "post", "po", "q", "fp", "cp", "http", "v", "x", "port"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n", "idx": 4615, "substitutes": {"env": ["np", "er", "equ", "dt", "que", "args", "energy", "site", "enable", "init", "engine", "en", "agen", "el", "esp", "conf", "v", "context", "vm", " environment", "db", "loader", "enc", "exec", "ea", "ne", "config", "viron", "stage", "eye", "En", "Environment", "ah", "cv", "ini", "esm", "gui", "code", "inet", "qt", "environment", "ext", "eve", "eu", "cal", "export", "style", "conn", "dict", "et", "n", "password", "eng", "fen", "console", "ette", "manager", "atten", "dat", "nc", "reset", "end", "e", "exc", "vert", "core", "server", "event", "ev", "gear", "cdn", "net", "her", "assets", "ec", "global", "dev", "forge", "erv", "eni", "esi", "enh"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "j", "di", "e", "d", "multi", "fi", "vi", "p", "ti", "yi", "is", "mi", "phi", "qi", "ii", "hi", "u", "ind", "id", "n", "l", "ni", "ip", "chi", "s", "c", "m", "t", "ix", "f", "zi", "io", "a", "ri", "o", "it", "gi", "xi", "x", "w", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"], "r": ["ru", "br", "re", "rc", "k", "result", "e", "d", "er", "str", "p", "rg", "arr", "ur", "rh", "h", "hr", "n", "l", "res", "lr", "sr", "c", "m", "t", "run", "mr", "rec", "g", "f", "range", "array", "or", "ir", "R", "nr", "err", "w", "ar", "like", "rb", "b", "rl", "attr", "resource", "v", "rs", "x"], "xsave": ["plexsave", "rxpose", "xsav", "rxsave", "plexapply", "xscale", "mxadd", "xstage", "xapply", "rxsav", "sexsav", "exsav", "xset", "xxappend", "xxslave", "sexsave", " xstage", " xapply", "Xstage", "wxstage", "axwrite", " xappend", "mxsav", "ysav", " xsav", "excreate", "xready", "Xpose", "yxscale", "txave", "xiready", "xcreate", "plexave", "wxsave", "exave", "xxsave", "ycreate", "crosssave", "axcreate", "sexstage", "crossave", "exslave", "Xsaving", "nexcreate", "yxsaving", "txpose", "wxape", "sexparse", "xistore", "wxsav", "axappend", "yxsave", "xicreate", "xadd", "exparse", "axadd", "xsaving", "xstore", " xcreate", " xstore", "yxcreate", "xiwrite", "xxcreate", "crosssaving", "expack", "Xave", "xxadd", "mxsave", "xxsav", "xparse", "Xapply", "xxstore", "nexsave", "xisave", "xave", "exsave", "sexave", "txsave", "axparse", "xpack", "axslave", "Xset", "xisaving", "Xsave", " xset", " xape", "ysave", "axapply", "nexscale", "crossready", "Xready", "xpose", "xiave", "xwrite", "axsave", "xxparse", "Xsav", "rxave", "xape", "xxapply", "sexape", " xsaving", "ypack", " xwrite", "xxwrite", "txsav", "xslave", "xappend", "Xparse", "xxpack", "axsav", "mxcreate", " xave", "nexsaving", "plexset", " xparse", " xscale"], "cwd": [" cwt", "fwa", " cpt", "fcpt", "rcwk", "fcnt", "acwd", "conwd", "fnt", "rcwl", "acft", "fcwa", "conft", "acmd", "cwa", "cws", "conwk", "cft", "rcwd", "acws", "lcwd", "cmd", "cnt", "lcwt", "acwk", " cwl", "pcwd", "scwk", "pcwn", "lcwk", "conmd", " cws", "scwd", "fpt", "cpt", " cwk", "rcws", "cwn", " cwn", " cnt", "acwl", "scft", "cwl", "scmd", "pcwk", "cwk", "pcwt", " cwa", "lcwn", "fwd", "cwt", "fcwd"], "swd": ["swf", "smsd", "wwp", "swD", "twp", " swp", "swsd", "swl", "tws", "SWs", " swt", " swds", " twds", " sws", " tws", "sms", "wwsd", "ewf", "SWD", "twl", "wwD", "swt", "ewds", "SWds", "Swd", "wwf", " swf", "wwl", "wwd", " twt", "twD", "twsd", "Sws", "swp", "ewd", "sws", "Swds", "wws", "twds", "smp", "twt", "wwds", "swds", "ewp", "SWd", "smd", "Swl"], "twd": ["swf", "sext", "rws", "swsd", "sexl", "tws", "swl", "twc", " twl", "twl", "nwds", " twsd", "swt", " twc", "sexf", "wwt", "rwl", "wwf", "rwc", "wwl", "wxt", "wwd", "twf", "rwd", " twt", "nwd", "twsd", "sexd", "wws", "wxd", "twds", "twt", "wxl", "nwl", "wwc", "swds", " twds", " tws", "nwsd", "wxs"], "fop": ["rfhop", "fops", "cops", "cop", "foper", "hoper", "infoper", "fhop", "homp", "phop", " fomp", "flop", " fops", "nop", "hhop", "pop", "coper", "fomp", "flops", "infhop", "rfoper", "floper", "nomp", " foper", "flomp", "noper", "hop", "infomp", " fhop", "rfop", "poper", "nhop", "comp", "infop"]}}
{"project": "FFmpeg", "commit_id": "57d04d3f11290d1848efa3b47031762f936d4cb3", "target": 1, "func": "static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,\n\n\tint numLines, int levelFix)\n\n{\n\n\tint i;\n\n\tif(levelFix)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\t\t\t\t\t\t\"pxor %%mm4, %%mm4\t\\n\\t\"\n\n\n\n#define SCALED_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm0 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm1 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n\telse\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\n\n#define SIMPLE_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n}\n", "idx": 4639, "substitutes": {"dst": ["cdbl", "wstr", "cdst", "sdST", "Drc", "dST", "dsrc", "Dbl", "dsST", "wst", "sdbl", "dssc", "drc", "Dsc", "fstr", "cdstr", "Dsrc", "datbl", "fST", "dbl", "frc", "wbl", "DST", "sdsrc", "datST", "cdrc", "wrc", "fsc", "dstr", "dsst", "datst", "fst", "Dst", "dsc", "datsrc", "fbl", "sdst"], "dstStride": ["dssEstrobe", "dstRestr", "dscRestrite", "dstSTride", "dscStride", "dstSTr", "dstStrite", "dstEstrobe", "dstStrobe", "dssStrobe", "dscRestr", "dssStride", "dstScride", "dstEstwrite", "dstStr", "dstScwrite", "dstStore", "dststore", "dstRestride", "dstStrip", "dstTrite", "dssEstrip", "dstSTrip", "dstScrite", "dssStrip", "dstSTwrite", "dstStrb", "dstScrobe", "dstRestrb", "dscStrite", "dssStwrite", "dssEstwrite", "dsrcSterve", "dststrite", "dscStr", "dststerve", "dstTride", "dstTerve", "dssEstride", "dstScrip", "dstScrb", "dscRestrb", "dscStrb", "dstScr", "dscRestride", "dstTore", "dsrcStore", "dstEstrip", "dstRestrite", "dstSTrite", "dstSTrb", "dsrcStride", "dststride", "dstSterve", "dstEstride", "dstSTrobe", "dstStwrite", "dsrcStrite"], "src": ["sci", "split", "rc", "ruby", "url", "gb", "ref", "rss", "loc", "sb", "RC", "sync", "slice", "params", "gz", "sc", "resources", "seq", "img", "r", "config", "dest", "rub", "lib", "chrom", "rs", "sr", "gl", "cur", "sup", "source", "inst", "secure", "bin", "sl", "rib", "sub", "rb", "attr", "desc", "rl", "b", "cb", "ins", "in", "http", "resource", "SOURCE", "irc", "stat", "rob"], "srcStride": ["imgStrite", "srcStide", "srcRestridden", "srcScRI", "srcShrite", "srcSTide", "srcStandrite", "srcStrite", "srcRestride", " srcShride", "srcScide", "imgStRI", "srcStandridden", " srcShrite", "srcThrite", "srcRestrip", "srcShride", " srcScridden", " srcStridden", "srcScrip", "srcRestrite", " srcShridden", "srcSTride", "imgSTride", "imgSTrite", "srcShide", "imgSTRI", "imgSTide", "srcThride", "imgStide", "srcStandrip", "srcSTrite", "srcScride", " srcScrite", "srcShRI", "srcShridden", " srcScride", "srcThridden", "srcStrip", "srcSTRI", "imgStride", "srcScrite", " srcScrip", " srcShrip", "srcStRI", " srcStrip", "srcScridden", "srcShrip", "srcThrip", "srcStandride", " srcStrite", "srcStridden"], "numLines": ["numGlues", " numPlines", "numElites", "numBlanes", "numPllines", "numElues", "numNlines", " numLues", "numLs", "numBline", "numLites", "nlines", "numls", "numLanes", " numLlines", " numLine", "nLines", "numllines", "numNines", "nls", "numline", "numlinks", "numFllines", "numFls", "numLinks", "nLanes", " numLinks", " numLanes", "numElines", "numFlines", " numPlues", "numGlites", "nlanes", "numNanes", " numLites", " numPllines", "numNs", "numPlues", "numLues", "numPlines", "nllines", "nLlines", "numFlanes", "numLlines", "numBlines", " numPlites", "numlines", "numEllines", "numGllines", "numGlines", "nLs", "numBlinks", "numLine", "numPlites", "numlanes"], "levelFix": ["depthApply", " levelfix", "depthFixed", "levelUpdate", "threadApply", "LevelUpdate", "LevelApply", " levelFixed", "threadFix", "LevelFix", "threadfix", "depthUpdate", "levelApply", " levelUpdate", "LevelFixed", " levelApply", "Levelfix", "levelFixed", "levelfix", "depthFix"], "i": ["bi", "ui", "pi", "index", "ie", "j", "di", "diff", "field", "e", "multi", "fi", "ti", "p", "yi", "uli", "is", "mi", "phi", "qi", "ii", "uni", "hi", "ji", "id", "n", "ni", "l", "ip", "abi", "ix", "oi", "f", "strength", "zi", "io", "a", "ri", "ini", "info", "it", "gi", "xi", "mu", "uri", "x", "ci", "eni", "z", "b", "iu", "I", "ai", "v", "si", "li"]}}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n", "idx": 4645, "substitutes": {"tpm2_ptr": ["tpm2Optr", "tpm2_fd", "tpm2_loc", "tpm1_addr", "tpm1_str", "tpm1_desc", "tpm1_src", "tpm1_sth", "tpm1_Ptr", "tpm2_buffer", "tpm2_Ptr", "tpm2Oref", "tpm2_cur", "tpm2__loc", "tpm1_ptr", "tpm2_pert", "tpm2_src", "tpm2__pointer", "tpm2_ref", "tpm1_pert", "tpm2__ref", "tpm1_req", "tpm2_desc", "tpm2_pointer", "tpm2_req", "tpm2Oloc", "tpm2__req", "tpm1_fd", "tpm2_str", "tpm2__src", "tpm2__fd", "tpm1_cur", "tpm1_pointer", "tpm2Opointer", "tpm2_tr", "tpm2_sth", "tpm2_addr", "tpm2__buffer", "tpm1_ref", "tpm1_tr", "tpm2__ptr", "tpm1_loc", "tpm1_buffer"]}}
{"project": "FFmpeg", "commit_id": "ae93965359e71c1f88ba170f8efd6a198344c235", "target": 1, "func": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)\n\n{\n\n    do {\n\n        int nb_output = 0;\n\n        int min_poc   = INT_MAX;\n\n        int i, min_idx, ret;\n\n\n\n        if (s->sh.no_output_of_prior_pics_flag == 1) {\n\n            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n                HEVCFrame *frame = &s->DPB[i];\n\n                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&\n\n                        frame->sequence == s->seq_output) {\n\n                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n                }\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n            HEVCFrame *frame = &s->DPB[i];\n\n            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&\n\n                frame->sequence == s->seq_output) {\n\n                nb_output++;\n\n                if (frame->poc < min_poc) {\n\n                    min_poc = frame->poc;\n\n                    min_idx = i;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* wait for more frames before output */\n\n        if (!flush && s->seq_output == s->seq_decode && s->sps &&\n\n            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)\n\n            return 0;\n\n\n\n        if (nb_output) {\n\n            HEVCFrame *frame = &s->DPB[min_idx];\n\n            AVFrame *dst = out;\n\n            AVFrame *src = frame->frame;\n\n            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n\n            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);\n\n\n\n            ret = av_frame_ref(out, src);\n\n            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);\n\n            else\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < 3; i++) {\n\n                int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n\n                int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n\n                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +\n\n                          (frame->window.top_offset   >> vshift) * dst->linesize[i];\n\n                dst->data[i] += off;\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"Output frame with POC %d.\\n\", frame->poc);\n\n            return 1;\n\n        }\n\n\n\n        if (s->seq_output != s->seq_decode)\n\n            s->seq_output = (s->seq_output + 1) & 0xff;\n\n        else\n\n            break;\n\n    } while (1);\n\n\n\n    return 0;\n\n}\n", "idx": 4668, "substitutes": {"s": ["sample", "d", "sync", "slice", "site", "ops", "services", "fs", "f", "space", "in", "b", "side", "conf", "south", "new", "sq", "outs", "sb", "h", "ses", "cs", "r", "sf", "ss", "ts", "t", "uns", "ns", "a", "w", "less", "es", "http", "ins", "parts", "frames", "self", "sys", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "n", "c", "g", "us", "ssl", "sl", "single", "qs", "rs", "si", "spec", "scope", "y", "aws", "e", "server", "is", "service", "ds", "request", "l", "states", "sym", "m", "source", "as", "sim", "settings", "se", "o", "z", "js", "os"], "out": ["new", "ext", "fn", "conv", "ref", "outs", "call", "op", "p", "sys", "flow", "orig", "Out", "image", "img", "r", "ch", "config", "OUT", "cmd", "line", "n", "block", "obj", "again", "m", "c", "init", "t", "g", "f", "source", "point", "req", "err", "o", "w", "in", "b", "doc", "v", "output", "x"], "i": ["ui", "bi", "split", "y", "pi", "index", "ie", "j", "di", "si", "e", "mini", "key", "multi", "fi", "ti", "p", "vi", "yi", "base", "slice", "mi", "num", "phi", "image", "qi", "ii", "r", "hi", "module", "u", "id", "l", "ni", "ip", "m", "c", "ix", "ori", "oi", "f", "g", "zi", "io", "start", "ri", "ini", "info", "it", "gi", "xi", "mu", "uri", "eni", "ci", "in", "b", "iu", "I", "ai", "v", "x", "li"], "min_idx": ["min__idxs", "min_midxs", "min_Idz", "min_inX", "min_inx", "min_Idxs", "min_exitom", "min__idc", "min_Idom", "min_dx", "min_idxb", "min_idxs", "min_idX", "min__Idxs", "min_midX", "min__idX", "min_Idy", "min_inc", "min_Idp", "min_idc", "min_midc", "min_midx", "min_Idc", "min__idx", "min_dz", "min_indp", "min_Idxb", "min_idp", "min_idy", "min_inxs", "min__Idc", "min__IdX", "min_exity", "min_indy", "min_indom", "min_exitp", "min__Idx", "min_indx", "min_dxb", "min_idom", "min_IdX", "min_dc", "min_exitx", "min_idz", "min_Idx"], "ret": ["flat", "re", "rc", "ref", "def", "result", "fun", "alt", "att", "str", "val", " Ret", "fi", "len", "mem", "xt", "arr", "std", "bit", "full", "RET", "img", "res", "fin", "lit", "en", "part", "feat", "gt", "det", "info", "ft", "reply", "nt", "arg", "rets", "final", "Ret", "rt"], "frame": ["target", "sample", "scale", "element", "coll", "que", "slice", "iframe", "up", "rame", "ace", "flower", "file", "sequence", "screen", "f", "draw", "cf", "unit", "object", "zone", "message", "call", "module", "position", "config", "stage", "plane", "pse", "run", "layer", "hole", "parse", "face", "fram", "fr", "code", "driver", "scene", "layout", "profile", "sche", "frames", "component", "document", "game", "session", "flow", "style", "image", "ze", "line", "block", "c", "motion", "fen", "host", "feat", "state", "feature", "process", "cycle", "window", "format", "date", "scope", "cfg", "figure", "loc", "e", "core", "fi", "fe", "function", "video", "version", "source", "point", "Frame", "phy", "filename", "node", "setup", "framework"], "nb_output": ["nblogconfig", "nb64generated", "blog_export", "nl_output", "np_return", "nb64output", "nb2export", "nb64input", "nb_return", "nllogoutput", "nc_stop", "nb_target", "blog_output", "nb2update", "nc64input", "nbloghidden", "nb67target", "nb64stop", "nb_update", "nb_hidden", "nblogtarget", "np_input", "nb_stop", "nc_output", "nb_export", "nb67config", "nl_update", "blog_update", "nl_config", "nb_generated", "nbloginput", "nllogconfig", "nc_input", "nllogupdate", "nblogupdate", "np_output", "nc64generated", "blog_generated", "nb_input", "nb67update", "nc_generated", "nb67output", "nb2output", "nc64stop", "nb_config", "nc64output", "nb2generated", "nl_target", "nblogoutput", "np_hidden", "nblogreturn", "nllogtarget"], "dst": [" dsc", "fst", "Dbl", "Dst", " dsrc", "Dsc", "fsc", " dbl", "dsc", "fbl", "Dsrc", "fsrc", "dbl", "dsrc"], "src": ["rc", "sec", "ref", "target", "dist", "gb", "proc", "url", "loc", "sb", "sys", "sync", "slice", "buf", "sc", "record", "seq", "image", "img", "config", "dest", "stat", "sr", "gl", "ctx", "rec", "bc", "sup", "host", "source", "inst", "sn", "feat", "fc", "sl", "sub", "rb", "node", "attr", "setup", "cb", "comp", "sel", "rs", "spec", "scene"], "desc": ["data", "rc", "dir", "ref", "dist", "def", "sec", "de", "text", "loc", "d", "enc", "decl", "dep", "esc", "sc", "config", "dest", "meta", "reg", "asc", "des", "rec", "dc", "bc", "description", "comment", "info", "Desc", "code", "sub", "gen", "attr", "disc", "doc", "comp"]}}
{"project": "FFmpeg", "commit_id": "4b9ac0b5f070f35eff671d83cee436db40631112", "target": 0, "func": "static int mpegaudio_parse(AVCodecParserContext *s1,\n\n                           AVCodecContext *avctx,\n\n                           uint8_t **poutbuf, int *poutbuf_size, \n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    MpegAudioParseContext *s = s1->priv_data;\n\n    int len, ret;\n\n    uint32_t header;\n\n    const uint8_t *buf_ptr;\n\n\n\n    *poutbuf = NULL;\n\n    *poutbuf_size = 0;\n\n    buf_ptr = buf;\n\n    while (buf_size > 0) {\n\n\tlen = s->inbuf_ptr - s->inbuf;\n\n\tif (s->frame_size == 0) {\n\n            /* special case for next header for first frame in free\n\n               format case (XXX: find a simpler method) */\n\n            if (s->free_format_next_header != 0) {\n\n                s->inbuf[0] = s->free_format_next_header >> 24;\n\n                s->inbuf[1] = s->free_format_next_header >> 16;\n\n                s->inbuf[2] = s->free_format_next_header >> 8;\n\n                s->inbuf[3] = s->free_format_next_header;\n\n                s->inbuf_ptr = s->inbuf + 4;\n\n                s->free_format_next_header = 0;\n\n                goto got_header;\n\n            }\n\n\t    /* no header seen : find one. We need at least MPA_HEADER_SIZE\n\n               bytes to parse it */\n\n\t    len = MPA_HEADER_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    if (len > 0) {\n\n\t\tmemcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t\tbuf_ptr += len;\n\n\t\tbuf_size -= len;\n\n\t\ts->inbuf_ptr += len;\n\n\t    }\n\n\t    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {\n\n            got_header:\n\n\t\theader = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n\t\t    (s->inbuf[2] << 8) | s->inbuf[3];\n\n\n\n                ret = mpa_decode_header(avctx, header);\n\n                if (ret < 0) {\n\n\t\t    /* no sync found : move by one byte (inefficient, but simple!) */\n\n\t\t    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\t    s->inbuf_ptr--;\n\n                    dprintf(\"skip %x\\n\", header);\n\n                    /* reset free format frame size to give a chance\n\n                       to get a new bitrate */\n\n                    s->free_format_frame_size = 0;\n\n\t\t} else {\n\n                    s->frame_size = ret;\n\n#if 0\n\n                    /* free format: prepare to compute frame size */\n\n\t\t    if (decode_header(s, header) == 1) {\n\n\t\t\ts->frame_size = -1;\n\n                    }\n\n#endif\n\n\t\t}\n\n\t    }\n\n        } else \n\n#if 0\n\n        if (s->frame_size == -1) {\n\n            /* free format : find next sync to compute frame size */\n\n\t    len = MPA_MAX_CODED_FRAME_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n            if (len == 0) {\n\n\t\t/* frame too long: resync */\n\n                s->frame_size = 0;\n\n\t\tmemmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\ts->inbuf_ptr--;\n\n            } else {\n\n                uint8_t *p, *pend;\n\n                uint32_t header1;\n\n                int padding;\n\n\n\n                memcpy(s->inbuf_ptr, buf_ptr, len);\n\n                /* check for header */\n\n                p = s->inbuf_ptr - 3;\n\n                pend = s->inbuf_ptr + len - 4;\n\n                while (p <= pend) {\n\n                    header = (p[0] << 24) | (p[1] << 16) |\n\n                        (p[2] << 8) | p[3];\n\n                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n                        (s->inbuf[2] << 8) | s->inbuf[3];\n\n                    /* check with high probability that we have a\n\n                       valid header */\n\n                    if ((header & SAME_HEADER_MASK) ==\n\n                        (header1 & SAME_HEADER_MASK)) {\n\n                        /* header found: update pointers */\n\n                        len = (p + 4) - s->inbuf_ptr;\n\n                        buf_ptr += len;\n\n                        buf_size -= len;\n\n                        s->inbuf_ptr = p;\n\n                        /* compute frame size */\n\n                        s->free_format_next_header = header;\n\n                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;\n\n                        padding = (header1 >> 9) & 1;\n\n                        if (s->layer == 1)\n\n                            s->free_format_frame_size -= padding * 4;\n\n                        else\n\n                            s->free_format_frame_size -= padding;\n\n                        dprintf(\"free frame size=%d padding=%d\\n\", \n\n                                s->free_format_frame_size, padding);\n\n                        decode_header(s, header1);\n\n                        goto next_data;\n\n                    }\n\n                    p++;\n\n                }\n\n                /* not found: simply increase pointers */\n\n                buf_ptr += len;\n\n                s->inbuf_ptr += len;\n\n                buf_size -= len;\n\n            }\n\n\t} else \n\n#endif\n\n        if (len < s->frame_size) {\n\n            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)\n\n                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;\n\n\t    len = s->frame_size - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    memcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t    buf_ptr += len;\n\n\t    s->inbuf_ptr += len;\n\n\t    buf_size -= len;\n\n\t}\n\n        //    next_data:\n\n        if (s->frame_size > 0 && \n\n            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n\n            *poutbuf = s->inbuf;\n\n            *poutbuf_size = s->inbuf_ptr - s->inbuf;\n\n\t    s->inbuf_ptr = s->inbuf;\n\n\t    s->frame_size = 0;\n\n\t    break;\n\n\t}\n\n    }\n\n    return buf_ptr - buf;\n\n}\n", "idx": 4681, "substitutes": {"s1": ["cone", "c1", "ts11", "S81", "ts2", "sp1", "sp81", "gs0", "s11", "sone", "s0", "gs2", "S0", "c11", "s2", "ds1", "gs81", "s81", "S2", "ds2", "sp2", "c2", "dsone", "tsone", "gs1", "ds11", "ts1", "S1", "sp0"], "avctx": ["afcmp", "avcontext", "afconfig", "avconfig", "maccp", "afctx", "awcmp", "avcp", "afcontext", "afcp", "maccontext", "akconfig", "akctx", "akcontext", "AVcontext", "macconfig", "afkb", "AVctx", "awcontext", "awctx", "avcmp", "avkb", "macctx", "akcp", "awkb", "AVkb", "AVcmp"], "poutbuf": ["poutfb", "pOutfb", "mpoutfb", "pargbuf", " p_buf", "painsqueue", "pagainbuffer", "painsbuffer", "mpinfb", "pagainbuf", " p_buffer", "poutqueue", "pinbuf", "p_buffer", "mpinbuf", "mpoutbuffer", "pargbuffer", "pargfp", "poutbuff", " poutbuffer", "p_fp", "p_buf", "pOutbuf", "pOutbuffer", " p_fp", "pargbuff", "mpinbuffer", "p_buff", " poutfp", "pagainfp", "mpoutqueue", " poutbuff", "pagainbuff", "mpoutbuf", "painsfb", "poutbuffer", "pinqueue", "mpinqueue", " p_buff", "pinfb", "pOutqueue", "painsbuf", "pinbuffer", "poutfp"], "poutbuf_size": ["poutqueue_sized", "poutbuf_capacity", "poutfile_unit", "poutbuf___unit", "poutfile_size", "poutbuf___capacity", "poutbuf_Size", "poutbuf___scale", "poutfile_capacity", "poutqueue_Size", "poutbuf_unit", "poutbuf_sized", "poutbuf_scale", "poutfile_scale", "poutbuf___size", "poutqueue_size"], "buf": ["data", "pb", "wb", "uc", "queue", "uint", "Buffer", "src", "seq", "offset", "empty", "vec", "cmd", "fb", "block", "buff", "ctx", "bc", "tmp", "buffer", "cv", "alloc", "filename", "cf", "uf", "rb", "null", "b", "length", "cb", "fp", "zero", "window"], "buf_size": ["queue_len", "buffstart", "fbqnumber", "wav_size", "buf_capacity", "queue_Size", "wav_pos", "frame_Size", "wav_sized", "bufCcapacity", "buff_sec", "buf2body", "buff_body", "buffpos", "wavfpos", "buffSize", "buf_body", "frame67style", "frame67Size", "buf2size", "wavfsize", "bufFsync", "buf_start", "queue_capacity", "frame67size", "bufqpos", "buf67Size", "bufCSize", "fb_pos", "wavfcapacity", "fb_size", "frame_start", "buf2sec", "buff2body", "buf2sized", "fbqpos", "buff_sync", "buffsize", "bufacsize", "wavfsized", "bufClen", "bufFsec", "buf67size", "bufqsize", "bufacsec", "buf67start", "buf2pos", "buff2sec", "queue_size", "buff2sync", "fbqSize", "buffcapacity", "buf_sized", "bufqnumber", "frame67start", "bufacsync", "bufFsize", "buf_number", "frame_size", "buf_len", "bufqSize", "fbqsize", "bufacbody", "buffstyle", "buf_Size", "buf2capacity", "buff2size", "buf67style", "fb_number", "bufCsize", "buff_size", "buf_sync", "frame_style", "buf_style", "buf2sync", "fb_Size", "buffsized", "buf_sec", "bufFbody", "wav_capacity", "buf_pos"], "s": ["ans", "d", "sync", "site", "vs", "ops", "sg", "services", "strings", "fs", "f", "sv", "has", "b", "conf", "v", "data", "new", "sq", "h", "ses", "cs", "r", "u", "sf", "ss", "ts", "t", "uns", "ns", "sa", "a", "its", "w", "es", "ins", "hs", "parts", "comments", "sys", "self", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "ims", "xs", "stats", "n", "c", "g", "us", "ssl", "su", "qs", "rs", "si", "spec", "y", "e", "server", "is", "service", "ds", "l", "states", "sym", "m", "ctx", "ms", "bis", "as", "se", "i", "secondary", "o", "js", "os"], "len": ["Len", "data", "pos", "split", "low", "ie", "fun", "loc", "le", "limit", "pl", "val", "mem", "ler", "ul", "ls", "bl", "ll", "seq", "num", "conn", "lon", "lt", "hl", "vec", "elt", "ind", "line", "n", "l", "lim", "lib", "led", "fin", "L", "dy", "il", "f", "rev", "lit", "en", "dl", "el", "non", "lin", "sl", "size", "lp", "nt", "code", "lf", "lc", "la", "span", "z", "gen", "length", "lan", "count", "ln", "ld", "fl", "li"], "ret": ["msg", "hash", "rc", "re", "ref", "result", "fun", "success", "alt", "att", "back", "str", "val", " Ret", "arr", "no", "conn", "num", "RET", "resp", "reg", "usr", "res", "obj", "sr", "fin", "opt", "rev", "lit", "ben", "en", "flag", "bin", "err", "det", "ft", "match", "nt", "reply", "arg", "del", "count", "red", "rets", "Ret", "rt"], "header": ["data", "detail", "pin", "section", "margin", "Header", "name", "result", "message", "er", "str", "dt", "event", "rf", "type", "h", "player", "conn", "pair", "offset", "over", "column", "tail", "config", "headers", "meta", "head", "line", "fb", "rr", "cookie", "response", "protected", "pillar", "her", "version", "layer", "forward", "buffer", "f", "description", "writer", "err", "filename", "cf", "prefix", "code", "cap", "dr", "border", "title", "cover", "definition", "null", "cb", "fp", "ln", "body", "final"], "buf_ptr": ["queue_pointer", "queue_size", "buf_loc", "buf_flush", "buf_ctr", "bufUsize", " buf_pointer", "queue_addr", " buf_ctr", "queue_ptr", "buf_pointer", "bufUptr", "bufUpointer", " buf_flush", "buf_addr", " buf_loc", "bufUflush"], "inbuf_ptr": ["inbuf_pointer", "inbuf_cur", "inbuf0que", "inbuf_err", "infb_loc", "inbufNpointer", "inbuf0ptr", "inbuf0tr", "inbufNcur", "inbufNerr", "inbuf_ctr", "inbuf_size", "inbuf_tr", "infb_size", "inbuf0pointer", "inbuf_loc", "inqueue_loc", "inbuf_slice", "inqueue_fd", "inbuf0offset", "inbufNptr", "inqueue_pointer", "inqueue_cur", "inbuf_que", "infb_ptr", "infb_pointer", "inbuf_offset", "inbuf_fd", "inqueue_ptr", "inqueue_err", "inbuf_Ptr"]}}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n    JNIEnv *env = NULL;\n\n\n\n    *attached = 0;\n\n\n\n    pthread_mutex_lock(&lock);\n\n    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {\n\n\n\n        av_log(log_ctx, AV_LOG_INFO, \"Retrieving current Java virtual machine using Android JniInvocation wrapper\\n\");\n\n        if (check_jni_invocation(log_ctx) == 0) {\n\n            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libdvm.so\", log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libart.so\", log_ctx)) != NULL) {\n\n                av_log(log_ctx, AV_LOG_INFO, \"Found Java virtual machine using Android JniInvocation wrapper\\n\");\n\n            }\n\n        }\n\n    }\n\n    pthread_mutex_unlock(&lock);\n\n\n\n    if (!java_vm) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not retrieve a Java virtual machine\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);\n\n    switch(ret) {\n\n    case JNI_EDETACHED:\n\n        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Failed to attach the JNI environment to the current thread\\n\");\n\n            env = NULL;\n\n        } else {\n\n            *attached = 1;\n\n        }\n\n        break;\n\n    case JNI_OK:\n\n        break;\n\n    case JNI_EVERSION:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"The specified JNI version is not supported\\n\");\n\n        break;\n\n    default:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Failed to get the JNI environment attached to this thread\");\n\n        break;\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 4685, "substitutes": {"attached": ["ATTached", "attatched", "attachach", " attatched", "atapped", "Attached", "attachributed", "detachment", "assachment", " attapped", "atatched", "attracted", "Attach", "attributed", "ATTributed", "atached", "assatched", "assach", "assapped", "detach", "hatach", "ATTach", "Attapped", "attapped", "atach", " attach", "attachracted", "attachached", "hatached", "assached", "hatributed", "hatracted", "ATTracted", "attach", "Attachment", "detached", "detapped", "attachment"], "log_ctx": ["LOGingctx", "logMspec", "baseerctx", "writeurecb", "writeurectx", "logLogcf", "base_tx", "loglogloc", "logjcur", "log_cu", "loglexconsole", "logboardlc", "logertx", "modelboardctx", "log_config", "logingcb", "logingcf", "loglogctx", "logxcu", "LOG_tx", "logPconn", "LOGlcor", "log_csv", "Log_loc", "lex_cf", "writeureconn", "loglctx", "logxloc", "Log_co", "logalltx", "loglercb", "laWservice", "loglercourse", "log_loc", "write_ctx", "logalllc", " log_lc", "logplechannel", "la_ctx", "logjco", "model_channel", "LOGlcn", "logPctx", "logLogctx", "bug_context", "la_tx", "loglerctx", "LOGingcas", "logvalconnection", "logboardctx", "logWctx", " log_cb", "write_console", "LOG_cor", "logallctx", "writeureconsole", "log_cor", "laWspec", "Log_cur", "write_cb", "loglconfig", "logLogloc", " log_loc", "log_spec", "logplecsv", "logurecb", "logjctx", "logWspec", "modelboardlc", "logureconn", "logplelc", "logWservice", "log_co", "loglercf", " log_cf", "logxconfig", "baseerlc", "laWtx", "lex_ctx", "LOG_cn", "logMtx", "lex_location", "baseercf", "LOGingcontext", "logLoglocation", "logercf", "logMservice", "LOGlctx", "modelboardchannel", "loglcor", "log_course", "log_lc", "la_spec", "logurectx", "log_context", "write_conn", "logerctx", "log_cn", "logingctx", "log_tx", "log_cas", "loglogcur", "bug_loc", "logLloc", "logingcontext", "LOG_ctx", "LOGingtx", "logvalloc", "log_console", "logjloc", "log_connection", "loglogco", " log_tx", "LOG_loc", "logboardchannel", "logvalcontext", "log_cf", "base_cf", "Log_ctx", "loglexctx", "logWtx", "logPconsole", "modelboardcsv", "LOG_context", "logingcas", "model_csv", "logingtx", "logallconfig", "model_ctx", "logPcb", "logxctx", "model_lc", "logplectx", "base_ctx", "log_cur", "lex_loc", "baseertx", "loglexcb", "laWctx", "logLctx", "logureconsole", "loglexconn", "LOG_cas", "logvalctx", "logLlocation", "LOGlloc", "loglloc", "log_location", "logMctx", "log_conn", "bug_connection", " log_course", "loglcn", "base_lc", " log_config", " log_cu", "bug_ctx", "logerlc", "logllc", "log_service", "log_cb", "logingcourse", "logboardcsv", "log_channel", "logLcf", "la_service", "logltx"], "env": ["np", "eval", "lv", "result", "vr", "vel", "back", "equ", "api", "dep", "vs", "enable", "sg", "init", "en", "cf", "conf", "lock", "v", "output", "context", "data", "ex", "vm", "ref", "db", "enc", "val", "ea", "app", "config", "viron", "Environment", "cv", "code", "addr", "environment", "ext", "export", "session", "style", "conn", "RET", "dict", "password", "endif", "ef", "et", "tmp", "console", "rev", "req", "align", "window", "dat", "extra", "scope", "reset", "end", "loc", "e", "exc", "empty", "ev", "gear", "ec", "cache", "err", "dev", "erv", "attr", "alias", "ret", "rt"]}}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    Qcow2COWRegion *start = &m->cow_start;\n\n    Qcow2COWRegion *end = &m->cow_end;\n\n    unsigned buffer_size;\n\n    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);\n\n    bool merge_reads;\n\n    uint8_t *start_buffer, *end_buffer;\n\n    QEMUIOVector qiov;\n\n    int ret;\n\n\n\n    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);\n\n    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);\n\n    assert(start->offset + start->nb_bytes <= end->offset);\n\n    assert(!m->data_qiov || m->data_qiov->size == data_bytes);\n\n\n\n    if (start->nb_bytes == 0 && end->nb_bytes == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* If we have to read both the start and end COW regions and the\n\n     * middle region is not too large then perform just one read\n\n     * operation */\n\n    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;\n\n    if (merge_reads) {\n\n        buffer_size = start->nb_bytes + data_bytes + end->nb_bytes;\n\n    } else {\n\n        /* If we have to do two reads, add some padding in the middle\n\n         * if necessary to make sure that the end region is optimally\n\n         * aligned. */\n\n        size_t align = bdrv_opt_mem_align(bs);\n\n        assert(align > 0 && align <= UINT_MAX);\n\n        assert(QEMU_ALIGN_UP(start->nb_bytes, align) <=\n\n               UINT_MAX - end->nb_bytes);\n\n        buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes;\n\n    }\n\n\n\n    /* Reserve a buffer large enough to store all the data that we're\n\n     * going to read */\n\n    start_buffer = qemu_try_blockalign(bs, buffer_size);\n\n    if (start_buffer == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n    /* The part of the buffer where the end region is located */\n\n    end_buffer = start_buffer + buffer_size - end->nb_bytes;\n\n\n\n    qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0));\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    /* First we read the existing data from both COW regions. We\n\n     * either read the whole region in one go, or the start and end\n\n     * regions separately. */\n\n    if (merge_reads) {\n\n        qemu_iovec_add(&qiov, start_buffer, buffer_size);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n    } else {\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov);\n\n    }\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Encrypt the data if necessary before writing it */\n\n    if (bs->encrypted) {\n\n        if (!do_perform_cow_encrypt(bs, m->offset, start->offset,\n\n                                    start_buffer, start->nb_bytes) ||\n\n            !do_perform_cow_encrypt(bs, m->offset, end->offset,\n\n                                    end_buffer, end->nb_bytes)) {\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* And now we can write everything. If we have the guest data we\n\n     * can write everything in one single operation */\n\n    if (m->data_qiov) {\n\n        qemu_iovec_reset(&qiov);\n\n        if (start->nb_bytes) {\n\n            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        }\n\n        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);\n\n        if (end->nb_bytes) {\n\n            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        }\n\n        /* NOTE: we have a write_aio blkdebug event here followed by\n\n         * a cow_write one in do_perform_cow_write(), but there's only\n\n         * one single I/O operation */\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n    } else {\n\n        /* If there's no guest data then write both COW regions separately */\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);\n\n    }\n\n\n\nfail:\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    /*\n\n     * Before we update the L2 table to actually point to the new cluster, we\n\n     * need to be sure that the refcounts have been increased and COW was\n\n     * handled.\n\n     */\n\n    if (ret == 0) {\n\n        qcow2_cache_depends_on_flush(s->l2_table_cache);\n\n    }\n\n\n\n    qemu_vfree(start_buffer);\n\n    qemu_iovec_destroy(&qiov);\n\n    return ret;\n\n}\n", "idx": 4697, "substitutes": {"bs": ["bi", "iss", "pb", "lb", "gb", "aws", "db", "ab", "sb", "bid", "mb", "bos", "bm", "ks", "BS", "ls", "bl", "src", "is", "vs", "ses", "cs", "bb", "ds", "fb", "cms", "ss", "bes", "obs", "bc", "banks", "fs", "ns", "ms", "sa", "bis", "bh", "js", "b", "es", "cb", "ins", "bt", "os", "bas"], "m": ["an", "gm", "y", "k", "j", "am", "mt", "e", "d", "mm", "wm", "p", "bm", "sm", "mp", "arm", "h", "mi", "module", "cm", "r", "um", "u", "meta", "hm", "fm", "n", "l", "man", "mr", "c", "t", "mode", "pm", "ym", "g", "f", "ms", "mc", "tm", "om", "mod", "i", "o", "manager", "im", "M", "md", "dm", "b", "machine", "v"], "s": ["scope", "storage", "sec", "si", "d", "e", "p", "sm", "args", "session", "S", "params", "is", "ses", "cs", "r", "gs", "service", "ds", "n", "states", "ops", "ss", "c", "ts", "services", "t", "fs", "g", "ns", "ms", "f", "sa", "ssl", "settings", "w", "sl", "state", "b", "os", "conf", "v", "rs", "spec"], "start": ["data", "pos", "new", "from", "k", "ie", "set", "scale", "starting", "pre", "name", "seed", "diff", "get", "open", "self", "grade", "p", "mid", "sync", "and", "style", "stop", "Start", "last", "offset", "old", "use", "config", "current", "sp", "head", "ind", "id", "l", "load", "sh", "init", "add", "st", "step", "all", "cur", "next", "art", "source", "range", "parse", "check", "min", "max", "en", "part", "se", "i", "info", "ad", "it", "state", "sk", "in", "post", "work", "first"], "end": ["k", "f", "set", "begin", "e", "alt", "enc", "ord", "get", "export", "open", "server", "event", "p", "mid", "and", "last", "client", "orig", "stop", "order", "offset", "old", "um", "use", "win", "dest", "line", "inner", "id", "head", "env", "est", "ion", "add", "entry", "E", "address", "End", "ed", "range", "art", "nd", "or", "max", "en", "se", "w", "END", "size", "ad", "dev", "ent", "edge", "ending", "z", "ended", "append", "post", "send", "update", "after"], "buffer_size": ["buffer32shift", "buffer64range", "uffer_size", "queue_shape", "buffer_strength", "queue_offset", "buffer_fee", "buffer32offset", "buffer32scale", "bufferlexscale", "uffer_fee", "buffer_len", "queue_shift", "header_size", "table_size", "buffer_offset", "buffer64size", "buffer_sized", "bufferlexsize", "buffer64fee", "queue_size", "bufferlexoffset", "buffer_shift", "buffer32size", "buffer_bytes", "buffer64strength", "buffer_shape", "bufferlexshift", "header_bytes", "buffer_scale", "uffer_range", "queue_scale", "buffer_max", "queue_max", "table_capacity", "header_len", "table_number", "table_sized", "buffer_capacity", "buffer_number", "uffer_strength", "buffer_range"], "merge_reads": ["merge__bytes", "merge_read", "merge___reads", "mergeedreads", "mergrade___runs", "merge_runs", "mergment_breaks", "merger_loads", "merger_read", "mergment_runs", "merge_bytes", "mergrade___reads", "merge___runs", "mergrade_breaks", "mergeablebytes", "mergment_reads", "merge__breaks", "mergrade_runs", "mergeedread", "merger_reads", "merge__runs", "mergeedvalues", "merge___breaks", "mergeablereads", "merger_books", "mergeedruns", "mergeallbooks", "merge_breaks", "mergeablebreaks", "mergeallloads", "merge_values", "mergrade_reads", "mergeableruns", "merge__reads", "merge_loads", "mergeallreads", "merger_runs", "mergment_bytes", "merge_books", "mergrade___breaks", "merger_values", "mergeallread"], "start_buffer": ["start_entry", "cur_port", "startfullport", "read_layer", "start___device", "from_gear", "read_buf", " start_transfer", "read_buffer", "read67entry", "start___buffer", "start67layer", "start_layer", "start_port", "cur_buffer", "cur_button", "read67buf", "start_button", "startfullbuffer", "startfullbutton", "read67layer", "start___queue", "start_device", "start_uffer", "start_header", "start_resource", "startJentry", "startfullresource", "from_header", "start67buf", "start_buf", "from_buffer", "start67buffer", "start___transfer", "start_transfer", "read_entry", "start_gear", "start_queue", "startJbuffer", "read67buffer", " start_queue", "from_uffer", "cur_resource", "startJbuf", "start67entry", "startJlayer", " start_device"], "end_buffer": ["end__buffer", "begin_queue", "begin__buff", "end_queue", " end_server", "begin_buffer", "begin__buffer", "end\u00b7server", "end\u00b7queue", "end__buf", "begin__queue", "end_server", "end\u00b7buffer", " end_queue", "end_window", "end_buf", "end__queue", "begin_buff", "end\u00b7window", "begin_buf", " end_window", "begin__buf", "end_buff", "end__buff"], "qiov": ["qtliv", "qtmu", " qmu", "quiov", "quiro", "questliv", "qiro", "qaiov", "qiop", "qmu", "questiov", "qtiop", "qaiop", "qtiov", " qiop", "dqiro", "dqiov", "qaliv", "dqliv", "qiol", "qliv", "questiro", "questiol", "quiol", "quliv", "qamu", "dqiol", " qliv"], "ret": ["re", "rc", "def", "eval", "result", "value", "len", " RET", "val", " Ret", "std", " rc", "num", "RET", "resp", " result", "res", "rows", " val", " resp", "al", " success", " res", "row", "Ret"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "void sws_rgb2rgb_init(int flags)\n\n{\n\n#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX\n\n    if (flags & SWS_CPU_CAPS_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n    else if (flags & SWS_CPU_CAPS_MMX2)\n\n        rgb2rgb_init_MMX2();\n\n    else if (flags & SWS_CPU_CAPS_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    else if (flags & SWS_CPU_CAPS_MMX)\n\n        rgb2rgb_init_MMX();\n\n    else\n\n#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */\n\n        rgb2rgb_init_C();\n\n}\n", "idx": 4698, "substitutes": {"flags": ["ffff", "options", "ages", "fps", "FLAG", "caps", "properties", "fun", "opens", "parts", "frames", "plugins", "mask", "requires", " Flags", "rules", "afi", "args", "books", "cards", "faces", "powers", "atts", "lists", "alls", "types", "stats", "files", "fd", "lag", "members", "fields", "Flags", "fs", "f", "fires", "ants", "vals", "flag", "settings", "ports", "allows", "posts", "lf", "bits", "bands", "features", "locks", "offs", "groups", "limits", "planes", "format", "styles"]}}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static double tget_double(GetByteContext *gb, int le)\n\n{\n\n    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};\n\n    return i.f64;\n\n}\n", "idx": 4718, "substitutes": {"gb": ["ui", "gm", "storage", "pc", "db", "sb", "binary", "hub", "cli", "rg", "gam", "bm", "gc", "gg", "sc", "cod", "gs", "bb", "gnu", "gram", "abi", "gio", "gy", "gd", "gal", "ctx", "bg", "gin", "bc", "g", "ig", "kb", "usb", "ib", "mc", "GB", "gp", "hw", "eb", "sl", "gi", "ga", "ci", "lc", "ge", "rb", "b", "cb", "gu"], "le": ["stable", "let", "eu", "ie", "scale", "de", " LE", "e", "sle", "les", "LE", "slave", "len", "ve", "ele", "ice", "ler", "ile", "ce", "lu", "ue", "ne", "ole", "l", " ble", "led", "lo", "ly", "te", "ig", "ple", "el", "al", "leg", "ci", "lc", "he", "ge", "ule", "Le", "ee", "li"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_power5plus(CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    /* XXX: not correct */\n\n    gen_low_BATs(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 4760, "substitutes": {"env": ["output", "context", "ception", "ench", "nc", "ext", "eve", "eu", "np", "sites", " environment", "dir", "progress", "db", "e", "enh", "enc", "exc", "er", "equ", "export", "server", "event", "dt", "que", "ea", "args", "session", "style", "org", "energy", "conn", "site", "ev", "config", "viron", "dict", "gear", "password", "stage", "enable", "txt", "forest", "gov", "press", "eng", "engine", "fen", "shell", "console", "assets", "Environment", "ec", "en", "cv", "agen", "el", " environments", "err", "global", "kn", "gui", "erv", "forge", "het", "v", "environment", "spec", "dat"]}}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n", "idx": 4761, "substitutes": {"ctx": ["context", "sci", "rc", "conv", "gb", "loc", "component", "coll", "exec", "hub", "anc", "cli", "cc", "sync", "gc", "kw", "cus", "src", "client", "sc", "conn", "xc", "support", "ct", "cm", "cs", "config", "fw", "cmd", "crit", "cca", "tx", "cdn", "ck", "c", "css", "bc", "kb", "ctrl", "mc", "cl", "pkg", "cam", "cv", "hw", "qa", "concept", "fc", "cu", "cf", "ca", "tc", "cn", "ci", "lc", "cas", "cb", "cmp", "vc", "cp", "cpp", "fp", "ctl"], "bit_rate": ["bits_base", "rot_loop", "bitfrate", "bits_rate", "bits_type", "bit___rate", "bit_base", "bit__scale", " bit_address", "bit__rate", "bitfdelay", "bitfscale", "bitfrates", "bit_loop", "bits_rates", " bit_rat", " bit_scale", "biturescale", "bit_ration", " bit_rating", " bit_rates", "bit__type", "bit_width", "rot_scale", "rot_rate", "bit___rates", " bit_size", "bit_rat", "bit_rating", "bits_scale", "bit_size", "bituresize", "bits_delay", "bit___ration", "bit_scale", "bitureaddress", "bit__width", "bit_delay", "bit_rates", "bit___rat", " bit_ration", "rot_size", " bit_width", "bits_width", "bit_type", "bit_address", "biturerate"], "bits_per_sample": ["bits_per_group", "bits_per_size", "bits_in_scale", "bits_in_sample", "bits_per_space", "bits_in_channel", "bits_per_side", "bits_per_channel", "bits_per_scale", "bits_per_slice"]}}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb,\n\n                                  AVCodecParameters *par,\n\n                                  int native_id, int qt_id)\n\n{\n\n    AVIOContext *dyn_cp;\n\n    uint8_t *codecpriv;\n\n    int ret, codecpriv_size;\n\n\n\n    ret = avio_open_dyn_buf(&dyn_cp);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (native_id) {\n\n        ret = mkv_write_native_codecprivate(s, par, dyn_cp);\n\n    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (qt_id) {\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,\n\n                                                    par->codec_id);\n\n            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id\n\n                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)\n\n            ) {\n\n                int i;\n\n                avio_wb32(dyn_cp, 0x5a + par->extradata_size);\n\n                avio_wl32(dyn_cp, par->codec_tag);\n\n                for(i = 0; i < 0x5a - 8; i++)\n\n                    avio_w8(dyn_cp, 0);\n\n            }\n\n            avio_write(dyn_cp, par->extradata, par->extradata_size);\n\n        } else {\n\n            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))\n\n                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,\n\n                                                  par->codec_id);\n\n            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n                ret = AVERROR(EINVAL);\n\n            }\n\n\n\n            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);\n\n        }\n\n    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        unsigned int tag;\n\n        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);\n\n        if (!tag) {\n\n            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n\n                   avcodec_get_name(par->codec_id));\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n        if (!par->codec_tag)\n\n            par->codec_tag = tag;\n\n\n\n        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);\n\n    }\n\n\n\n    codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv);\n\n    if (codecpriv_size)\n\n        put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n\n                        codecpriv_size);\n\n    av_free(codecpriv);\n\n    return ret;\n\n}\n", "idx": 4762, "substitutes": {"s": ["context", "scope", "sq", "aws", "e", "sb", "server", "sys", "p", "ks", "session", "app", "client", "ps", "sc", "ses", "site", "cs", "gs", "r", "service", "sf", "ds", "u", "ops", "c", "sg", "services", "t", "ctx", "fs", "g", "f", "ns", "us", "ssl", "o", "sv", "js", "b", "os", "parser", "v", "spec"], "pb": ["pc", "proc", "vp", "cp", "sb", "pl", "typ", "tp", "src", "mp", "sc", "lib", "pro", "jp", "obj", "txt", "ctx", "bc", "pp", "wp", "PB", "lp", "rb", "cb", "fp", "pd", "cpp", "parser", "prot"], "par": ["pc", "mm", "er", "str", "mp", "dep", "pr", "processor", "har", "per", "Par", "ar", "ca", "cap", "pe", "PAR", "arin", "arg", "arp", "pard", "rel", "serv", "pal", "pas", "param", "particip", "view", "oper", "prev", "params", "app", "ep", "sp", "inter", "prem", "mor", "parse", "cat", "wp", "part", "rar", "pol", "fr", "comp", "aa", "star", "pub", "pre", "component", "p", "arr", "session", "ps", "inc", "patch", "jp", "var", "entry", "arc", "gap", "pass", "pp", "comment", "syn", "war", "like", "post", "cmp", "resource", "car", "spec", "adr", "proc", "bar", "op", "person", "peer", "pa", "request", "pro", "prep", "cur", "parent", "ph", "dr", "la", "attr", "parser"], "native_id": ["nativeaccheck", "remote_id", "nativeicalids", "native_ids", "nativeacids", "nativeacid", "native2info", "nativeicalid", "native_check", "native2type", "native_ident", "native2id", "formaticalident", "nativeacident", "nativeicalident", "native_info", "formaticalid", "format_ident", "nativeicalcheck", "remote_type", "format_check", "formaticalcheck", "format_id", "nativeappid", "formaticalids", "remote_info", "nativeappinfo", "nativeapptype", "format_ids", "native_type"], "qt_id": ["core00key", "qt00oid", "qt_source", "qt00key", "qt_index", "text_ids", "qtameindex", "core_key", "qt_oid", "core00id", "text_index", "qtIdids", "textameid", "textamesource", "qtamesource", "text_source", "core00ids", "core00oid", "qtameids", "core_oid", "qtameid", "qt00id", "qtIdsource", "qt00ids", "qtIdindex", "core_ids", "qt_key", "textameindex", "textameids", "qt_ids", "core_id", "qtIdid", "text_id"], "dyn_cp": ["dynjmp", "dummyADcp", "dynwpc", "dynADmp", "dyn_csv", "dynamic_pkg", "dynam_sk", "dyn67cp", "dyna_cat", "dyncch", "dyn67sk", "dynamic_zip", "dyna_pub", "dync_pc", "dyn_cpp", "dyn_zip", "dyntheproc", "dyn__rc", "dynADpub", "dyn_proc", "dyn_sk", "dynCcmp", "dynccol", "dyn_ch", "dynADcpp", "dummyADproc", "dyn67pp", "dyn__cp", "dynthecsv", "dyn_pub", "dynvcpp", "dyna_cp", "dynthecp", "dynADproc", "dummy_cp", "dynwcpp", "dummy_csv", "dynthecpp", "dyn67cmp", "dynADcp", "dynwcp", "dynamic_keep", "dyn_mp", "dyna_mp", "dync_cpp", "dyna_rc", "dyn_pkg", "dynccpp", "dynam_cp", "dynamic_cp", "dummyADcsv", "dynam_cmp", "dynvcp", "dynCsk", "dynjcmp", "dummyADcpp", "dyn_keep", "dynCpp", "dyn_rc", "dynjcp", "dynADcat", "dyna_cmp", "dyn_col", "dynvcol", "dynam_pp", "dummy_cpp", "dyn__mp", "dynccp", "dyn__cmp", "dyn_pp", "dynwcmp", "dynADcsv", "dummy_proc", "dyn__pub", "dynjrc", "dync_cmp", "dyn_pc", "dynCcp", "dyn_cat", "dync_cp", "dynvch", "dyn__cat", "dyn_cmp"], "codecpriv": ["codecname", "codacname", " codecprivate", "codefpriv", " codecname", "codecdata", "codacpriv", "codexname", " codacdata", "codefname", "codefdata", "codexprivate", " codecdata", " codacname", "codacprivate", "codexpriv", " codacprivate", "codefprivate", "codecprivate", " codacpriv", "codacdata", "codexdata"], "ret": ["let", "pet", "rc", "re", "ref", "def", "fail", "mt", "result", "success", "bf", "alt", "att", "fun", "back", "get", "len", "val", " RET", " Ret", "mem", "bad", "arr", "ry", "bit", "num", "RET", "resp", "reg", "id", "res", "ut", "sr", "cur", "fin", "pt", "art", "pass", "rev", "lit", "cat", "flag", "feat", "gt", "det", "ft", "match", "reply", "nt", "code", "valid", "rb", "rl", "arg", "status", "rets", "Ret", "rt"], "codecpriv_size": ["codecpriv_count", "codecinfo_count", "codecpriv_small", "codecinfo_len", "codecinfo_size", "codecinfo_small", "codecpriv_len"], "i": ["ui", "bi", "pi", "index", "k", "j", "di", "si", "e", "mini", "key", "multi", "fi", "ti", "p", "uli", "h", "phi", "qi", "ii", "hi", "inner", "ji", "ind", "n", "ni", "chi", "ip", "abi", "c", "m", "ix", "zi", "ri", "ini", "o", "gi", "xi", "uri", "ci", "z", "in", "I", "ai", "v", "x", "li"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n", "idx": 4766, "substitutes": {"dest": ["sum", "target", "dist", "result", "text", "name", "img", "delete", "die", "id", "dim", "temp", "output", "west", "ui", "data", "context", "miss", "done", "orig", "test", "config", "stage", "cont", "txt", "ward", "mode", "rest", "dc", "address", "trip", "path", "cl", "project", "shape", "null", "cb", "status", "select", "pull", "Dest", "outer", "uc", "de", "trans", "ident", "session", "option", "content", "home", "transfer", "sup", "shift", "opt", "prop", "feat", "origin", "comb", "route", "feature", "access", "transform", "flat", "wb", "options", "end", "di", "loc", "success", "ord", "vert", "camp", "src", "est", "usr", "cdn", "class", "source", "sort", "hop", "lit", "master", "parent", "global", "coord", "desc", "node"], "line_size": [" line_sized", "line_sized", "line_length", "line_time", "line64size", "line2time", " line_0", "line2length", "line2scale", "line_0", "line64scale", " line_scale", "line64sized", "line2size", "line640", "line_scale", "line20", "line2sized", " line_time", " line_length"], "block": ["Block", "section", "end", "pre", "name", "loc", "byte", "event", "none", "blocks", "map", "rule", "bl", "type", "clean", "module", "config", "line", "ip", "keep", "word", "content", "address", "buffer", "source", "page", "comment", "check", "cl", "group", "parent", "table", "match", "pack", "node", "col", "chain", "cp", "row", "lock"], "i": ["ui", "bi", "index", "pi", "k", "ie", "j", "di", "e", "d", "multi", "fi", "cli", "ti", "p", "api", "is", "mi", "qi", "ii", "ki", "u", "ji", "n", "ni", "l", "ip", "abi", "c", "t", "oi", "f", "zi", "io", "a", "info", "gi", "mu", "x", "xi", "uri", "ci", "z", "b", "col", "iu", "count", "I", "ai", "v", "si", "li"], "cm": ["em", "nm", "gm", "CM", "comm", "gom", "vm", "am", "member", "param", "mm", "wm", "co", "core", "cc", "que", "bm", "cus", "don", "image", "module", "cs", "config", "sem", "fm", "cca", "cont", "dim", "cy", "cum", "man", "cms", "m", "c", "mode", "prem", "ram", "pm", "cr", "ym", "address", "hem", "ctrl", "mc", "cl", "om", "rom", "cam", "mult", "iam", "cf", "ca", "km", "im", "cn", "ci", "lc", "rem", "com", "dem", "con", "cp", "uca", "asm"]}}
{"project": "qemu", "commit_id": "a01aedc8d32e6f5b08a4041b62be3c5fab7a3382", "target": 1, "func": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n", "idx": 4768, "substitutes": {"obj": ["object", "ref", "j", "coll", "val", "self", "op", "p", "api", "bj", "org", "module", "bot", "lib", "orb", "elt", "bo", "ob", "class", "act", "inst", "mod", "otype", "el", "Obj", "parent", "o", "code", "objects", "attr", "node", "b", "cb", "po", "os", "base"], "name": ["nam", "data", "object", "nice", "key", "len", "call", "none", "type", "old", "id", "n", "Name", "word", "f", "path", "pass", "comment", "part", "parent", "named", "o", "names", "prefix", "size", "code", "ame", "attr", "b", "NAME", "alias", "property", "x", "base"], "get": ["gets", "msg", "give", "neg", "ie", "play", "got", "Get", "show", "exec", "export", "ve", "call", "api", "client", "apply", "GET", "patch", "use", "make", "service", "create", "et", "want", "read", "init", "can", "g", "put", "parse", "check", "sort", "start", "it", "ge", "like", "gen", "fix", "find", "post", "getting", "send", "property", "update"], "set": ["pos", "reset", "push", "end", "diff", "clear", "vert", "export", "open", "call", "write", "sync", "base", "session", "un", "sc", "apply", "use", "patch", "change", "sign", "create", "et", "id", "Set", "read", "ut", "enable", "add", "force", "check", "SET", "mod", "parse", "put", "start", "en", "cast", "se", "it", "bind", "gen", "store", "handle", "process", "post", "find", "send", "unit", "cut", "util", "update"], "errp": ["errf", "errr", "isep", "erp", " errpc", "iseps", "erps", "erpc", " errf", "errps", "errorp", "Erps", "isepc", "errpc", "iser", "errorr", " errr", "Err", "err", "erf", "errorpc", "errorf", "Erp", "Erpc"], "prop": ["data", "root", "pb", "pos", "cfg", "term", "object", "np", "proc", "properties", "pot", "value", "val", "fi", "dt", "pod", "op", "p", "api", "mp", "type", "buf", "ps", "num", "phi", "pr", "rop", "bug", "config", "pro", "jp", "option", "init", "tmp", "nb", "Prop", "pointer", "opt", "lit", "cat", "pp", "conf", "pkg", "part", "parent", "info", "rb", "attr", "b", "col", "cb", "po", "cmp", "ptr", "cp", "comp", "pred", "prot", "property", "priv"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n", "idx": 4769, "substitutes": {"v": ["volt", "vm", "k", "conv", "j", "vd", "vp", "lv", "vu", "value", "e", "d", "view", "vert", "val", "ve", "vi", "p", "nv", "h", "vs", "ii", "r", "ev", "u", "n", "l", "var", "c", "t", "uv", "V", "f", "vol", "g", "vt", "or", "a", "i", "o", "iv", "w", "va", "z", "sv", "b", "q", "vv", "x"], "m": ["nm", "gm", "y", "vm", "pi", "k", "j", "e", "d", "mm", "p", "bm", "sm", "h", "mi", "cm", "r", "u", "mad", "hm", "n", "l", "mn", "dim", "s", "mr", "c", "pm", "g", "f", "ms", "mA", "mc", "mod", "a", "min", "i", "o", "mu", "M", "md", "dm", "z", "b", "q", "x"]}}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n", "idx": 4770, "substitutes": {"s": ["ssh", "d", "sync", "args", "site", "ops", "sg", "services", "fs", "f", "side", "b", "conf", "south", "an", "new", "sites", "sq", "sb", "plugins", "h", "ses", "cs", "u", "sf", "ss", "ts", "t", "uns", "ns", "a", "its", "w", "sis", "es", "http", "hs", "parts", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "c", "g", "ssl", "sl", "su", "qs", "rs", "si", "y", "aws", "e", "is", "service", "ds", "l", "states", "sym", "m", "ms", "as", "settings", "se", "i", "o", "js", "os"]}}
{"project": "FFmpeg", "commit_id": "ddef3d902f0e4cbd6be6b3e5df7ec158ce51488b", "target": 1, "func": "static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n\n                              MOVTrack *track, AVStream *st)\n\n{\n\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n\n                                      track->timescale, AV_ROUND_UP);\n\n    int version = duration < INT32_MAX ? 0 : 1;\n\n    int flags   = MOV_TKHD_FLAG_IN_MOVIE;\n\n    int rotation = 0;\n\n    int group   = 0;\n\n\n\n    uint32_t *display_matrix = NULL;\n\n    int      display_matrix_size, i;\n\n\n\n    if (st) {\n\n        if (mov->per_stream_grouping)\n\n            group = st->index;\n\n        else\n\n            group = st->codecpar->codec_type;\n\n\n\n        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,\n\n                                                            &display_matrix_size);\n\n        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))\n\n            display_matrix = NULL;\n\n    }\n\n\n\n    if (track->flags & MOV_TRACK_ENABLED)\n\n        flags |= MOV_TKHD_FLAG_ENABLED;\n\n\n\n    if (track->mode == MODE_ISM)\n\n        version = 1;\n\n\n\n    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */\n\n    ffio_wfourcc(pb, \"tkhd\");\n\n    avio_w8(pb, version);\n\n    avio_wb24(pb, flags);\n\n    if (version == 1) {\n\n        avio_wb64(pb, track->time);\n\n        avio_wb64(pb, track->time);\n\n    } else {\n\n        avio_wb32(pb, track->time); /* creation time */\n\n        avio_wb32(pb, track->time); /* modification time */\n\n    }\n\n    avio_wb32(pb, track->track_id); /* track-id */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track->entry && mov->mode == MODE_ISM)\n\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n\n    else if (!track->entry)\n\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n\n    else\n\n        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);\n\n\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb16(pb, 0); /* layer */\n\n    avio_wb16(pb, group); /* alternate group) */\n\n    /* Volume, only for audio */\n\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avio_wb16(pb, 0x0100);\n\n    else\n\n        avio_wb16(pb, 0);\n\n    avio_wb16(pb, 0); /* reserved */\n\n\n\n    /* Matrix structure */\n\n\n    if (st && st->metadata) {\n\n        AVDictionaryEntry *rot = av_dict_get(st->metadata, \"rotate\", NULL, 0);\n\n        rotation = (rot && rot->value) ? atoi(rot->value) : 0;\n\n    }\n\n\n    if (display_matrix) {\n\n        for (i = 0; i < 9; i++)\n\n            avio_wb32(pb, display_matrix[i]);\n\n\n    } else if (rotation == 90) {\n\n        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);\n\n    } else if (rotation == 180) {\n\n        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);\n\n    } else if (rotation == 270) {\n\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n\n\n    } else {\n\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n\n    }\n\n    /* Track width and height, for visual only */\n\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n\n        int64_t track_width_1616;\n\n        if (track->mode == MODE_MOV) {\n\n            track_width_1616 = track->par->width * 0x10000ULL;\n\n        } else {\n\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n\n                                                  track->par->width * 0x10000LL,\n\n                                                  st->sample_aspect_ratio.den);\n\n            if (!track_width_1616 ||\n\n                track->height != track->par->height ||\n\n                track_width_1616 > UINT32_MAX)\n\n                track_width_1616 = track->par->width * 0x10000ULL;\n\n        }\n\n        if (track_width_1616 > UINT32_MAX) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n\n            track_width_1616 = 0;\n\n        }\n\n        avio_wb32(pb, track_width_1616);\n\n        if (track->height > 0xFFFF) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n\n            avio_wb32(pb, 0);\n\n        } else\n\n            avio_wb32(pb, track->height * 0x10000U);\n\n    } else {\n\n        avio_wb32(pb, 0);\n\n        avio_wb32(pb, 0);\n\n    }\n\n    return 0x5c;\n\n}", "idx": 4781, "substitutes": {"pb": ["pc", "lb", "np", "pub", "gb", "proc", "bsp", "vp", "cp", "lv", "ppa", "bf", "pg", "sb", "pl", "hub", "tp", "typ", "p", "bos", "bm", "api", "bj", "um", "pa", "dp", "blog", "fb", "jp", "hp", "obj", "buff", "plug", "tmp", "bc", "ctx", "pm", "pt", "apy", "platform", "aph", "pp", "pkg", "eb", "wp", "dl", "PB", "lp", "bh", "uf", "lc", "bp", "xb", "rb", "b", "cb", "bs", "fp", "pd", "cpp", "bps", "prot"], "mov": ["smovo", "mmov", "amOV", "tmove", "amev", "smove", "mux", "amov", "migration", "mev", "move", "mOV", "smux", "emove", "tmigration", "tmovo", " move", "mood", "tmov", "amove", "rmove", "movo", "mmOV", "rmood", "smov", "emOV", "emev", "rmov", "cmov", "cmux", " migration", "emov", "cmood", "mmove", "cmove", "smigration", " movo", "rmux", "mmev", "smood"], "track": ["tag", "complete", "form", "note", "audio", "rack", "set", "package", "play", "coll", "trace", "call", "report", "event", "rule", "metadata", "session", "type", "rock", "record", "test", "order", "module", "ack", "config", "tracking", "contact", "Track", "request", "stage", "skip", "m", "mode", "step", "t", "add", "run", "forward", "tr", "gap", "song", "sort", "roll", "tm", "comment", "model", "hop", "group", "project", "match", "toggle", "trial", "route", "sound", "node", "time", "post", "round", "stream", "thread", "transform", "tracks", "token", "port"], "st": ["ste", "storage", "stack", "sth", "sam", "stress", "ast", "sb", "str", "std", "sm", "stab", "src", "bl", "stop", "ost", "sc", "client", "support", "sf", "sp", "stage", "St", "ist", "steam", "rest", "step", "tmp", "ctx", "tr", "pt", "station", "inst", "start", "sn", "sta", "sl", "ft", "stall", "stream", "sw", "sk", "store", "grad", "td", "ST", "stim"], "display_matrix": ["display_mathrix", "display_attression", "display_attrices", "display_matix", "display_metrix", "display_numribution", "display_manogram", "display_comprix", "display_attrix", "display_compix", "display_patrics", "display_patric", "display_mathric", "display_matric", "display_matrics", "display_dimrix", "display_atrix", "display_materialression", "display_manric", "display_dimrices", "display_materialix", "display_maturity", "display_mathix", "display_attix", "display_patribution", "display_meturity", "display_dimogram", "display_monrix", "display_attric", "display_matrices", "display_textrics", "display_matride", "display_monride", "display_materialric", "display_atix", "display_dimride", "display_textribution", "display_materialrix", "display_numrics", "display_manride", "display_dimric", "display_manrix", "display_mathurity", "display_morrix", "display_compression", "display_patrix", "display_matogram", "display_metix", "display_atric", "display_morric", "display_textric", "display_matression", "display_textrix", "display_compric", "display_monogram", "display_numrix", "display_numric", "display_morrices", "display_monric", "display_aturity", "display_matribution", "display_metric"], "display_matrix_size": ["display_matrices_small", "display_matrix_capacity", "display_matric_sum", "display_matrix_SIZE", "display_matrices_SIZE", "display_matrix_scale", "display_matric_Size", "display_matrices_size", "display_matrices_scale", "display_matric_size", "display_matrix_small", "display_matrix_sum", "display_matric_scale", "display_matric_capacity", "display_matrix_Size"], "i": ["pi", "j", "e", "si", "multi", "ti", "p", "slice", "ind", "id", "n", "ni", "ip", "s", "c", "g", "io", "a", "axis", "info", "ci", "z", "in", "I", "ai", "v", "x", "li"]}}
{"project": "FFmpeg", "commit_id": "4189fe11ffcbdcd311eb9a3437586a94492c4cde", "target": 1, "func": "static int vobsub_read_seek(AVFormatContext *s, int stream_index,\n\n                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)\n\n{\n\n    MpegDemuxContext *vobsub = s->priv_data;\n\n\n\n    /* Rescale requested timestamps based on the first stream (timebase is the\n\n     * same for all subtitles stream within a .idx/.sub). Rescaling is done just\n\n     * like in avformat_seek_file(). */\n\n    if (stream_index == -1 && s->nb_streams != 1) {\n\n        int i, ret = 0;\n\n        AVRational time_base = s->streams[0]->time_base;\n\n        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);\n\n        min_ts = av_rescale_rnd(min_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);\n\n        max_ts = av_rescale_rnd(max_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);\n\n        for (i = 0; i < s->nb_streams; i++) {\n\n            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,\n\n                                            min_ts, ts, max_ts, flags);\n\n            if (r < 0)\n\n                ret = r;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n\n\n    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,\n\n                                   min_ts, ts, max_ts, flags);\n\n}", "idx": 4798, "substitutes": {"s": ["sq", "e", "d", "sb", "comments", "events", "plugins", "self", "sys", "p", "sync", "spec", "sports", "ls", "session", "S", "ps", "sc", "is", "ses", "qs", "support", "cs", "sets", "gs", "service", "sf", "ds", "ips", "xs", "n", "uploads", "l", "ss", "c", "sg", "m", "services", "t", "sym", "fs", "g", "f", "ns", "sa", "sim", "us", "ssl", "settings", "se", "w", "sl", "o", "sv", "su", "js", "b", "es", "features", "ins", "os", "v", "rs", "si"], "stream_index": ["client_diff", "streamPind", "stream_level", "streamPslice", "input_slice", "resourceersize", "input_index", "resourceerindex", " stream_element", "streamsaddress", "streamPid", "record_index", "streamssize", "streamingind", "inputingid", "stream_handle", "streamerind", "streamsedge", "recordNameindex", "client_level", "stream_element", "resourceerind", "streamerindex", "streamingslice", "streamsindex", "streampindex", "streamingelement", "stream_num", "record_ini", "client_edge", "streampind", "streamersize", "streameraddress", "resource_address", "stream_slice", "inputingslice", "streamNamehandle", "resourceeraddress", "inputingindex", "streamslevel", "stream_edge", "streamNameindex", " stream_num", "streampslice", "resource_ind", "resource_size", "streamingid", "streamingnum", "streamsdiff", "recordNameini", "stream_ind", "input_id", "inputingind", "streampid", "input_ind", "client_index", "stream_size", "stream_ini", "stream_address", "streamingindex", "recordNamehandle", "stream_diff", "streamPindex", "streamNameini", "resource_index", "streamsind", "record_handle", "stream_id"], "min_ts": ["min__tz", "max_cases", "min_times", "min64TS", "min_its", "min_tp", " min_ments", "minalltimes", "minJtz", "min__times", "minableuts", " min_atts", "max_TS", "min64times", "minJpoints", "minabletimes", "max_tp", "min__points", "min_cases", "minablecases", "min_tz", "min__ts", "minallTS", "max_times", "min_atts", "minalltp", "min00ts", " min_ats", "min_ats", "max_points", "minJts", "min64its", "max_its", "min00times", "minablets", "min_points", "min00cases", "min64ts", "min_TS", "minallts", "minJtimes", "min00uts", "min_ments", "max_tz", "max_uts", "min_uts"], "ts": ["amps", "ages", "dates", "mt", "outs", "ras", "alt", "ats", "ets", "events", "verts", "ensions", "ks", "ls", "times", "ps", "uts", "test", "atts", "cs", "ims", "tt", "acs", "tips", "Ts", "alls", "types", "ents", "ays", "tags", "rows", "rs", "ids", "ss", "t", "ta", "ags", "fs", "tr", "ns", "ms", "pt", "min", "TS", "vals", "arts", "ails", "points", "tim", "its", "ints", "ports", "tests", "tc", "posts", "asts", "ics", "ths", "tes", "ickets", "tracks", "tz"], "max_ts": ["min_times", " max_ims", "max_ics", "max68ts", "max67times", " max_times", "max68ics", "maxNims", "max_tm", "max_ims", "max48ts", "max67tz", "max_td", "max_TS", "max48times", "max6ts", "maxNtimes", "max68times", "max48tim", "max33times", "min_tz", "max33ts", "max_tim", "max48tz", "max6times", " max_TS", "max_times", "min_ics", "maxLtimes", "max6ics", "max68tis", "maxLTS", "max67tim", "max_tis", "maxLtrans", "max_trans", "min_tim", "maxNts", "max6tis", " max_tm", "maxLts", " max_trans", "max67ts", "min_td", "maxNtm", "max33tm", "min_ims", "max_tz", "min_tis", "max33ims"], "flags": ["func", "options", "fps", "FLAG", "fun", "ats", "comments", "mask", "fts", "fo", "rules", "details", "args", "times", "faces", "vs", "forces", "atts", "alls", "orts", "stats", "types", "files", "fd", "windows", "lag", "ags", "fields", "Flags", "fs", "nl", "ants", "vals", "flag", "settings", "mods", "ints", "lf", "bits", "bands", "reads", "features", "reports", "locks", "planes", "rets", "utils", "styles"], "vobsub": ["vobpath", "voclpath", "tvobsc", "vorbsub", "svoblish", "vabsub", "vcbsc", "vabpath", "svorbube", "svorblish", "voblish", "tvobsub", "vaudlish", "vcbSub", "svobsub", "vabSub", "tvobSub", "tvobpub", "vobstart", "tvabSub", "vabstart", "ivobsub", "tvabpub", "vcbpub", "vobube", "vaudsub", "ivaudpath", "tvabsc", "vobbsec", "vobbube", "ivaudstart", "voclsec", "vorblish", "vorbube", "vorbsec", "vobSub", "vobsc", "voclsub", "vobblish", "vobpub", "vobsec", "svorbsec", "svobube", "vabpub", "ivobsec", "ivobpath", "vobbSub", "vabsec", "ivaudsec", "vobbpub", "vaudstart", "vcbsub", "ivaudsub", "ivobstart", "vaudube", "vabsc", "vobbsub", "vaudsec", "svorbsub", "svobsec", "vobbsc", "vaudpath", "voclstart", "tvabsub"], "i": ["ui", "bi", "y", "index", "pi", "k", "j", "di", "si", "e", "mini", "len", "multi", "fi", "ti", "p", "li", "slice", "type", "mi", "phi", "qi", "ii", "r", "hi", "u", "inner", "ind", "id", "n", "l", "ip", "abi", "c", "m", "t", "ix", "oi", "f", "ib", "io", "en", "ri", "ini", "o", "gi", "it", "x", "xi", "uri", "code", "ci", "b", "iu", "q", "I", "ai", "v", "ret"]}}
{"project": "FFmpeg", "commit_id": "c177f2ec4a21d62fdefd925ad69c24a2f9dad303", "target": 0, "func": "static av_cold int aac_encode_init(AVCodecContext *avctx)\n\n{\n\n    AACContext *s = avctx->priv_data;\n\n    int ret = AVERROR(EINVAL);\n\n    AACENC_InfoStruct info = { 0 };\n\n    CHANNEL_MODE mode;\n\n    AACENC_ERROR err;\n\n    int aot = FF_PROFILE_AAC_LOW + 1;\n\n    int sce = 0, cpe = 0;\n\n\n\n    if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to open the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->profile != FF_PROFILE_UNKNOWN)\n\n        aot = avctx->profile + 1;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the AOT %d: %s\\n\",\n\n               aot, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE,\n\n                                       1)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to enable SBR for ELD: %s\\n\",\n\n                   aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE,\n\n                                   avctx->sample_rate)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the sample rate %d: %s\\n\",\n\n               avctx->sample_rate, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    switch (avctx->channels) {\n\n    case 1: mode = MODE_1;       sce = 1; cpe = 0; break;\n\n    case 2: mode = MODE_2;       sce = 0; cpe = 1; break;\n\n    case 3: mode = MODE_1_2;     sce = 1; cpe = 1; break;\n\n    case 4: mode = MODE_1_2_1;   sce = 2; cpe = 1; break;\n\n    case 5: mode = MODE_1_2_2;   sce = 1; cpe = 2; break;\n\n    case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number of channels %d\\n\", avctx->channels);\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE,\n\n                                   mode)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set channel mode %d: %s\\n\", mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER,\n\n                                   1)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set wav channel order %d: %s\\n\",\n\n               mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_QSCALE || s->vbr) {\n\n        int mode = s->vbr ? s->vbr : avctx->global_quality;\n\n        if (mode <  1 || mode > 5) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"VBR quality %d out of range, should be 1-5\\n\", mode);\n\n            mode = av_clip(mode, 1, 5);\n\n        }\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Note, the VBR setting is unsupported and only works with \"\n\n               \"some parameter combinations\\n\");\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE,\n\n                                       mode)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the VBR bitrate mode %d: %s\\n\",\n\n                   mode, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    } else {\n\n        if (avctx->bit_rate <= 0) {\n\n            if (avctx->profile == FF_PROFILE_AAC_HE_V2) {\n\n                sce = 1;\n\n                cpe = 0;\n\n            }\n\n            avctx->bit_rate = (96*sce + 128*cpe) * avctx->sample_rate / 44;\n\n            if (avctx->profile == FF_PROFILE_AAC_HE ||\n\n                avctx->profile == FF_PROFILE_AAC_HE_V2 ||\n\n                s->eld_sbr)\n\n                avctx->bit_rate /= 2;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE,\n\n                                       avctx->bit_rate)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the bitrate %d: %s\\n\",\n\n                   avctx->bit_rate, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    /* Choose bitstream format - if global header is requested, use\n\n     * raw access units, otherwise use ADTS. */\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX,\n\n                                   avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the transmux format: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (s->latm && s->header_period) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD,\n\n                                       s->header_period)) != AACENC_OK) {\n\n             av_log(avctx, AV_LOG_ERROR, \"Unable to set header period: %s\\n\",\n\n                    aac_get_error(err));\n\n             goto error;\n\n        }\n\n    }\n\n\n\n    /* If no signaling mode is chosen, use explicit hierarchical signaling\n\n     * if using mp4 mode (raw access units, with global header) and\n\n     * implicit signaling if using ADTS. */\n\n    if (s->signaling < 0)\n\n        s->signaling = avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE,\n\n                                   s->signaling)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set signaling mode %d: %s\\n\",\n\n               s->signaling, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER,\n\n                                   s->afterburner)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set afterburner to %d: %s\\n\",\n\n               s->afterburner, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->cutoff > 0) {\n\n        if (avctx->cutoff < (avctx->sample_rate + 255) >> 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"cutoff valid range is %d-20000\\n\",\n\n                   (avctx->sample_rate + 255) >> 8);\n\n            goto error;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH,\n\n                                       avctx->cutoff)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the encoder bandwidth to %d: %s\\n\",\n\n                   avctx->cutoff, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to initialize the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to get encoder info: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n#if FF_API_OLD_ENCODE_AUDIO\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n#endif\n\n    avctx->frame_size = info.frameLength;\n\n    avctx->delay      = info.encoderDelay;\n\n    ff_af_queue_init(avctx, &s->afq);\n\n\n\n    if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER) {\n\n        avctx->extradata_size = info.confSize;\n\n        avctx->extradata      = av_mallocz(avctx->extradata_size +\n\n                                           FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto error;\n\n        }\n\n\n\n        memcpy(avctx->extradata, info.confBuf, info.confSize);\n\n    }\n\n    return 0;\n\nerror:\n\n    aac_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 4800, "substitutes": {"avctx": [" avcms", "acloc", "evconn", "avecu", "avloc", "afctx", "avtx", "avsync", "AVconn", "afsync", "afhw", "aucmp", "navctx", "avalctx", "akcca", "akpkg", "avcoll", "afloc", " avvoc", "afcmp", "avalcal", "accontext", "akscope", "acpkg", "avepkg", "avalcli", "alcoll", "avelc", "akhw", " avcu", " avcca", "apctx", "avecontext", "afvoc", "afscope", "avpkg", "afcoll", " avloc", "afconn", "Avctx", "afcu", "navscope", "evctx", "afkb", "AVctx", "aflc", "avkb", "afpkg", "AVlc", "Avtx", "afcca", "evcontext", "airsync", "akvoc", "alpkg", "versync", "AVcmp", "Avcontext", "alctx", "avcontext", "ausync", " avcal", "Avconn", "navcontext", "avekb", "avconn", "afcms", "avcca", "airpkg", "avcal", "aircontext", "aucontext", "akctx", "verpkg", "AVcontext", "avcms", "avcmp", "verctx", "avcli", "AVkb", " avcli", "appkg", "avscope", "avalcontext", "alcontext", "avcu", "vercontext", "auctx", " avcontext", "apcoll", "afcli", " avconn", "navpkg", "afcontext", " avtx", "avlc", "afcal", " avhw", "akcontext", "apcontext", "acctx", "AVsync", "airctx", "akcms", "avhw", "evlc", "avectx", "aftx", "accu", "avvoc"], "s": ["data", "y", "storage", "sq", "e", "si", "sb", "sys", "p", "sync", "ls", "session", "S", "is", "sc", "ses", "qs", "cs", "gs", "r", "service", "sf", "ds", "sets", "xs", "n", "ops", "ss", "c", "sg", "sym", "services", "t", "ctx", "fs", "g", "f", "sup", "ns", "sa", "bis", "us", "a", "ssl", "settings", "i", "info", "o", "sv", "su", "b", "js", "hs", "os", "v", "rs", "spec"], "mode": ["power", "layout", "Mode", "scale", "sid", "ODE", "name", "message", " error", "key", "disable", "command", "grade", "program", "move", "type", "channel", " coding", "module", "MAC", "TYPE", "device", " modes", " status", "id", "stage", "dim", "block", "plugin", "MODE", "activity", "m", "cade", " m", " ERROR", "range", "language", "mod", "phase", " Mode", "table", "END", "prefix", "manager", "code", "match", "when", "toggle", "lane", "md", "role", "direction", "MOD", "mission"], "err": [" ex", "msg", " r", "result", "aut", " error", "er", "str", " fe", "ler", "arm", "rh", "order", "pr", "later", " msg", "res", "temp", "mr", " cause", " resp", "Error", "erer", "der", "ver", " Error", " res", "fg", "aster", "conf", " sr", "reader", "finder", "ner", " reply", "orig", " er", "bug", "r", "ind", "yer", "magic", "eor", "ah", "wr", "nr", "ini", "rar", "fr", "rb", "iter", "cb", "doc", "rc", " act", "sys", "arr", " rc", "ry", " result", "var", "lr", "erg", "Er", "req", " exc", " errors", "spec", "y", "error", "e", " env", "server", " req", "resp", "usr", "rr", "ait", "act", "ir", "yr", "kr", "user", "dr", "gr", "attr", " f"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static int vorbis_floor1_decode(vorbis_context *vc,\n\n                                vorbis_floor_data *vfu, float *vec)\n\n{\n\n    vorbis_floor1 *vf = &vfu->t1;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t range_v[4] = { 256, 128, 86, 64 };\n\n    unsigned range = range_v[vf->multiplier - 1];\n\n    uint16_t floor1_Y[258];\n\n    uint16_t floor1_Y_final[258];\n\n    int floor1_flag[258];\n\n    unsigned class, cdim, cbits, csub, cval, offset, i, j;\n\n    int book, adx, ady, dy, off, predicted, err;\n\n\n\n\n\n    if (!get_bits1(gb)) // silence\n\n        return 1;\n\n\n\n// Read values (or differences) for the floor's points\n\n\n\n    floor1_Y[0] = get_bits(gb, ilog(range - 1));\n\n    floor1_Y[1] = get_bits(gb, ilog(range - 1));\n\n\n\n    av_dlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1_Y[0], floor1_Y[1]);\n\n\n\n    offset = 2;\n\n    for (i = 0; i < vf->partitions; ++i) {\n\n        class = vf->partition_class[i];\n\n        cdim   = vf->class_dimensions[class];\n\n        cbits  = vf->class_subclasses[class];\n\n        csub = (1 << cbits) - 1;\n\n        cval = 0;\n\n\n\n        av_dlog(NULL, \"Cbits %u\\n\", cbits);\n\n\n\n        if (cbits) // this reads all subclasses for this partition's class\n\n            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,\n\n                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);\n\n\n\n        for (j = 0; j < cdim; ++j) {\n\n            book = vf->subclass_books[class][cval & csub];\n\n\n\n            av_dlog(NULL, \"book %d Cbits %u cval %u  bits:%d\\n\",\n\n                    book, cbits, cval, get_bits_count(gb));\n\n\n\n            cval = cval >> cbits;\n\n            if (book > -1) {\n\n                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,\n\n                vc->codebooks[book].nb_bits, 3);\n\n            } else {\n\n                floor1_Y[offset+j] = 0;\n\n            }\n\n\n\n            av_dlog(NULL, \" floor(%d) = %d \\n\",\n\n                    vf->list[offset+j].x, floor1_Y[offset+j]);\n\n        }\n\n        offset+=cdim;\n\n    }\n\n\n\n// Amplitude calculation from the differences\n\n\n\n    floor1_flag[0] = 1;\n\n    floor1_flag[1] = 1;\n\n    floor1_Y_final[0] = floor1_Y[0];\n\n    floor1_Y_final[1] = floor1_Y[1];\n\n\n\n    for (i = 2; i < vf->x_list_dim; ++i) {\n\n        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;\n\n\n\n        low_neigh_offs  = vf->list[i].low;\n\n        high_neigh_offs = vf->list[i].high;\n\n        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin\n\n        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;\n\n        ady = FFABS(dy);\n\n        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 4801, "substitutes": {"vc": ["vim", "vm", "vd", "cop", "vp", "lv", "db", "vg", "asu", "vr", "cli", "cc", "util", "nv", "wx", "sys", "api", "gc", "gg", "client", "xc", "cs", "bb", "lib", "voc", "fb", "ic", "cdn", "c", "ctx", "bc", "dc", "uv", "ib", "ctrl", "vt", "cv", "cache", "fc", "gui", "ci", "lc", "sv", "cb", "http", "bt", "v", "vv", "wd", "VC", "rt"], "vfu": ["svf", "gpu", "vorpu", "svpu", "vorfs", "vorfu", " vpu", "fpu", "vorf", " vFU", "svFU", "gFU", "vpu", "ffs", "gf", "vfs", "ffu", " vfs", "vFU", "ff", "svfu", "gfu"], "vec": ["func", "fn", "fps", "def", "len", "ve", "buf", "seq", "cs", "lib", "vector", "dim", "buff", "version", "fs", "buffer", "prop", "cv", "vals", "xy", "fc", "score", "length", "feature", "q", "binary", "window"], "vf": ["svc", "mf", "Vfs", "avc", "svf", "vvfac", "svfe", "vb", "evf", "evfs", "vcf", "lfc", "mfe", "Vcf", "vfc", " vfc", "evb", "avcf", "svfac", "svfs", "vvcf", "Vfu", " vfen", "lfs", "svfen", " vfac", "vvfu", "vvfen", "lcf", "vfs", "avfs", "Vf", "svb", "vfe", "vfac", "avf", " vb", " vcf", " vfs", "lf", "vfen", "vvf", "mcf", "mfs", "svfu", "svfc", "svcf", "evcf", "vvc", " vfe"], "gb": ["ui", "cfg", "abb", "gm", "storage", "bn", "pc", "gom", "vd", "db", "vg", "bf", "gpu", "sb", "binary", "hub", "multi", "gow", "mb", "game", "rg", "gam", "bm", "gn", "gc", "metadata", "sync", "gz", "gg", "agg", "gnu", "gs", "bb", "git", "hm", "lib", "plugin", "gram", "gio", "gy", "gd", "bg", "bc", "gin", "g", "nb", "uv", "kb", "usb", "range", "vt", "GB", "gp", "cv", "eb", "gt", "ga", "ci", "database", "bp", "Gb", "rb", "gru", "cb", "gu"], "range_v": ["range00V", "range_V", "range00u", " range_u", " range_V", "range_u", "rangeallv", "rangeallh", "range00vector", "ange_v", "ange_V", "ange_h", "range_h", "rangeallV", " range_vector", "range_vector", "range00v"], "floor1_Y": ["floorOnePB", "floor1_DAY", "floor2Py", "floor2_Y", "floor1_GY", "floor1FileIS", "floorOnePP", "floor151_GY", "floor2_IP", "floor1_B", "floor1LB", "floorOne_B", "floor1HashP", "floor1PIP", "floor2PY", "floor1_X", "floor1_y", "floor1_P", "floor1AllYY", "floorOnePy", "floor1Filey", "floor1PYY", "floor1FileDAY", "floor2_YY", "floor1LogDAY", "floor1HashY", "floor1LogY", "floor1_IP", "floorOne_Y", "floor2_y", "floorOnePYS", "floor1Logy", "floor1LY", "floor151_Y", "floor151_y", "floor1PP", "floor1HashYY", "floor1AllYS", "floor1AllP", "floor1FileC", "floor1Jy", "floorOnePY", "floorOne_P", "floor1FileY", "floor1AllY", "floor151_C", "floor2PIP", "floor1LogIS", "floor1JY", "floorOnePX", "floor1_C", "floor1PB", "floor1_IS", "floor1_YS", "floor1_YY", "floorOne_YY", "floorOne_y", "floor1JB", "floor1LX", "floor1PX", "floorOnePYY", "floor1HashYS", "floorOne_YS", "floor1JX", "floorOne_X", "floor1FileGY", "floor2PYY", "floor1Ly", "floor1Py", "floor1PYS", "floor1PY"], "floor1_Y_final": ["floor1_Y_max", "floor1_Y_MAX", "floor1_YRfinal", "floor1_YRmax", "floor1_y_max", "floor1_y_Final", "floor1_y_final", "floor1_YRMAX", "floor1_YRFinal", "floor1_Y_Final", "floor1_y_MAX"], "floor1_flag": ["floor1_flags", "floor1_Z"], "class": ["complete", "object", "url", "section", "family", "scale", "bus", "package", "name", "classes", "CLASS", "component", "str", "p", "Class", "rule", "connection", "spec", "session", "type", "style", "function", "sc", "seq", "lass", "bridge", "test", "module", "full", "use", "config", "current", "lib", "plugin", "id", "file", "option", "s", "c", "instance", "version", "f", "source", "prop", "cl", "attribute", "model", "group", "part", "parent", "cache", "user", "code", "state", "attr", "length", "lock", "com", "count", "comp", "cell", "unit", "x"], "cdim": ["ndim", "xdIM", "ndims", "xdip", " cdima", "cdima", "ndIM", "cdsim", "CDims", "udima", "udsim", "ydima", " cdims", "CDIM", "CDip", "cdip", "ydsim", "xdims", "udims", "cdIM", " cdip", "xdim", "cdims", "cdom", "ydims", " cdsim", "ydim", "xdom", "ndom", "CDim", " cdIM", " cdom", "udim"], "cbits": ["pubs", "fops", "cops", " cwords", " cits", "vbits", "ucits", "ucints", "Cwords", "fval", "dcbits", "cubs", " cvals", "acvals", "acbs", "acbits", "Cbits", "lcits", "corevals", "crvals", " cplanes", "tcops", "cparts", " cints", "coreval", "vbit", "cwords", "crval", "acabs", "acval", "corebits", "lcplanes", "fvals", "crbs", "Cvals", " cbs", "tcparts", "lcval", "fbits", "cints", "Cbit", "dcparts", "coreops", "Cubs", "cbs", "lcbits", "cvals", " cops", "ucplanes", "Cval", "vvals", "lcints", "dcval", "pints", "lcparts", " cbit", "crbits", "ucbits", "cbit", "pvals", "Cabs", "cplanes", "Cints", "cits", " cubs", "tcval", "lcops", "tcbits", "vwords", "dcops", "pbits"], "csub": ["cksube", "nsube", "cksum", "nsug", "ksUB", "ksubs", "cksug", "rsUB", "lsug", "lsub", "csube", "ksuper", "cksuper", "cksub", "rsuc", "rsub", "ksum", "nsub", "lsube", "lsum", "csug", "codesuc", "lsuper", "csuc", "rsuper", "csuper", "csum", "nsuper", "codesUB", "codesuper", "ksub", "ksuc", "ksube", "lsubs", "csUB", "cksubs", "codesub", "csubs"], "cval": [" cret", "Cvals", " ceval", "cvalid", "csel", "pvalid", "cachevalue", " col", "acvalid", "pval", "lcval", "lcvals", "acvalue", "pvalue", "call", "cuabs", "dvals", "cpos", "Cret", "Cvalues", "cret", "cvalues", "lcsel", "dbits", " cvals", "Call", " csel", "cacheeval", "Cvalid", "pvals", "acval", " cpos", "Cabs", "Ceval", " cvalue", "cueval", " cvalid", "Cvalue", "acret", "aceval", " call", "cachepos", "pol", "ceval", "cuval", "lcbits", "cvals", "dval", "pvalues", " cvalues", "dsel", "col", "cuvalue", "acol", "pall", "cvalue", "Cval", "cacheval", "acpos"], "offset": ["pos", "outer", "index", "seed", "url", "area", "end", "optional", "error", "loc", "label", "annot", "len", "p", "Offset", "slice", "pad", "order", "ii", "position", "et", "iso", "option", "rot", "skip", "entry", "nb", "f", "shift", "range", "art", "sort", "padding", "start", "hop", "slot", "axis", "o", "origin", "length", "alias", "align", "after", "port"], "i": ["ui", "y", "index", "pi", "k", "ie", "di", "e", "d", "si", "fi", "li", "p", "yi", "type", "h", "jit", "mi", "phi", "qi", "ii", "u", "line", "ind", "id", "n", "l", "ni", "chi", "ip", "s", "udi", "m", "c", "ix", "f", "io", "start", "a", "ini", "part", "info", "o", "w", "gi", "xi", "it", "uri", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "lock", "v", "x"], "j": ["note", "y", "k", "ie", "section", "aj", "e", "d", "jc", "p", "un", "jl", "jit", "ij", "qi", "ii", "ch", "u", "ji", "dj", "n", "l", "jp", "jo", "c", "m", "g", "f", "range", "ja", "jj", "uj", "jet", "kj", "el", "part", "journal", "o", "w", "fr", "job", "z", "js", "b", "adj", "oj", "v", "ld", "J", "x", "li"], "book": ["library", " count", "uc", "object", "k", "chapter", " books", "family", "bus", "number", "half", "db", "label", "ab", "build", "back", "coll", "row", "cc", "books", "rule", "year", "session", "style", "un", "record", "test", "order", "old", "account", "box", "bb", "kk", " bus", "lib", "month", "file", "read", "block", "child", " record", "c", "home", "version", "bc", "author", "group", "bin", "journal", "school", "week", "code", "sheet", "letter", "trial", "valid", "pack", "b", "hour", "alias", "lock", "Book", "count", "BOOK", "cell", "unit", "base"], "adx": ["idx", "acw", "sdx", "sdp", "adw", "adp", "idX", "adX", "acp", "acX", "sdw", "idp", "sdX", "idw", "acx"], "ady": ["ty", "oy", "ada", "asy", "az", "ny", "yy", "ey", "mx", "wx", "ry", "yan", "ay", "hy", "kk", "yx", "sy", "dj", "axy", "fy", "px", "adh", "ky", "ca", "idy", "md", "edy", "wy", "eddy"], "dy": ["py", "zy", "dn", "da", "dir", "di", "d", "yy", "dt", "dq", "lon", "hi", "deb", "dp", "ds", "die", "dj", "dim", "dd", "vy", "gy", "dl", "xy", "md", "dx", "wy", "ld"], "off": ["pos", "low", "ox", "oa", "def", "on", "op", "no", "orig", "flow", "up", "num", "over", "lon", "out", "ip", "block", "mode", "home", "max", "o", "dev", "down", "ff", "ov", "length", "offs"], "predicted": ["indefined", "indiction", "dediction", "dedefined", "prediction", "indicted", "condicted", "condefined", "predefined", "indressed", "condiction", "dedicted", "condressed", "dedressed", "predressed"], "err": ["error", "result", "exc", "er", "len", "str", "rx", "arr", "orig", "order", "test", "bug", "later", "ev", "inner", "ind", "rr", "init", "rev", "req", "cache", "dev", "ver", "score", "iter", "errors", "cb"]}}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815, "substitutes": {"s": ["iss", "sq", "aws", "e", "sb", "sys", "p", "sync", "spec", "ks", "args", "ls", "session", "S", "is", "ps", "ses", "site", "cs", "gs", "sets", "service", "sf", "ds", "xs", "stat", "stats", "states", "ops", "ss", "m", "sg", "sym", "services", "c", "ts", "t", "uns", "sie", "fs", "ns", "self", "f", "bis", "sim", "ssl", "settings", "se", "sl", "secondary", "o", "sis", "series", "sv", "state", "su", "es", "js", "status", "bs", "os", "conf", "ins", "qs", "south", "si"], "bioc": ["biocal", " biOC", "bioco", " bioci", "cioc", " biocol", "ciocl", "diog", "abioco", "fiOC", "kiocl", "abiocl", " biog", "kiOC", "ciog", "fiocol", "abiog", "dioco", " biou", "miou", "abiocol", "abioc", "abiocal", " bioco", "fioc", "dioc", "biocol", " biocl", "miocl", "nioc", "biog", "abiOC", "bioci", "kioc", "mioc", "dioci", "biocl", "kioco", "ciou", "biou", " biocal", "niog", "miog", "abioci", "niocal", "biOC", "fiog", "niOC"], "fb": ["pb", "wb", "fn", "fa", "lb", "ref", "ab", "bf", "sb", "fi", "fe", "rf", "facebook", "buf", "bb", "deb", "sf", "fw", "FB", "orb", "fm", "obb", "buff", "ob", "fd", "fen", "raf", "tmp", "bg", "bc", "fs", "nb", "f", "usb", "eb", "fc", "fab", "cf", "RF", "ff", "xb", "rb", "cb", "fg", "fp"], "current_time": ["currentactime", "currentacpath", "currentacdelay", "current00time", "currentalimage", "contentallength", "current67image", "total_time", "currentingduration", "content_time", " current_path", "current67length", "current_runtime", "content_sleep", "current00TIME", " current_frequency", " current_count", "currentFfrequency", " current_TIME", "contentalsleep", "current67time", "current00frequency", "current_TIME", "currentingtime", "currentallength", "currentingruntime", "contentalimage", "current_delay", "current_length", "current_sleep", "current_duration", "currentFcount", "content_length", "current67sleep", "currentFtime", " current_Time", "contentaltime", "currentalsleep", "current_Time", "current00count", "current00delay", "total_duration", "current00path", "current_speed", "content_image", "currentFTIME", "current_image", "currentingspeed", "current_path", " current_delay", "total_speed", "current_frequency", "currentacTime", "current00Time", "total_runtime", "currentaltime", "current_count"], "local_err": ["custom_result", "foreign_dr", "global_error", "localipcache", "local_msg", "custom_rr", "localipdr", "foreignxdr", "local_error", "localableer", "foreignxprogress", "localipprogress", "localableresult", "localableorig", "local_progress", "local_result", "remote_state", "localapperror", "global_err", "local_state", "custom_err", "foreignxcache", "custom_msg", "remote_error", "localamstate", "global_er", "localableerr", "local_orig", "remote_err", "global_notice", "foreign_cache", "local_dr", "foreign_err", "localxprogress", "foreign_progress", "localapper", "localappnotice", "localiperr", "localxdr", "local_rr", "localamerror", "foreignxerr", "local_notice", "local_cache", "local_er", "localamerr", "localxerr", "localapperr", "localxcache", "global_result", "global_orig"], "ret": ["let", "rc", "re", "ref", "mt", "result", "fun", "bf", "alt", "att", "try", "success", "len", "val", " RET", " Ret", "no", "ry", "bit", "num", "RET", "resp", "out", "reg", "res", "rot", "sr", "pt", "pass", "rev", "lit", "flag", "det", "ft", "match", "reply", "nt", "code", "rt", "rb", "rl", "arg", "count", "red", "rets", "Ret"], "delay_ms": ["delay32ts", "delayvalms", "delayvalloads", "delay__ms", "delay_loads", " delay_bytes", "delayFms", "delayvalmins", "delay_yrs", "delayacmb", "delay_ts", "pause_mins", "delayacms", "delay_mb", "delayFts", "delay32mins", "pausevalloads", " delay_mb", "delay__loads", "delayingbytes", "delayingms", "delayvalyrs", "delayingmins", "delay32ms", "pausevalms", "delayingmb", " delay_mins", "delay32details", "delay_mins", "pausevalmins", "delay__yrs", " delay_ts", "delay_details", " delay_details", "pause_loads", "pause_ms", "delay__mins", "pausevalyrs", "delay_bytes", "delayacmins", "delayFdetails", "delayacbytes", "delayFmins", "pause_yrs"]}}
{"project": "qemu", "commit_id": "c97294ec1b9e36887e119589d456557d72ab37b5", "target": 0, "func": "static void pc_init1(QEMUMachineInitArgs *args,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(args->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (args->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = args->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = args->ram_size;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n\n\n    if (smbios_defaults) {\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            args->machine->name);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(system_memory,\n\n                       args->kernel_filename, args->kernel_cmdline,\n\n                       args->initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, args->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 4835, "substitutes": {"args": ["extra", "py", "msg", "ext", "pc", "aws", "ras", "argument", "parts", "cli", "self", "sys", "arr", "details", "ks", "acl", "params", "cus", "html", "conn", "atts", "cs", "gs", "config", "alls", "this", "ds", "cmd", "plugin", "Args", "ips", "current", "ass", "states", "ids", "sg", "actions", "init", "ana", "fields", "g", "arms", "ns", "ig", "ams", "parse", "ants", "vals", "conf", "flags", "cache", "global", "alloc", "size", "ac", "arg", "limits", "Arg", "doc", "ins", "parser", "utils", "spec"], "pci_enabled": ["pci_supported", "pci_protected", "pdi__enable", "pdi__enabled", "pci__protected", "pci__enabled", "pci__supported", "pci_enable", "pci__enable", "pdi_enabled", "pdi__supported", "pdi_protected", "pdi_enable", "pdi__protected", "pdi_supported"], "kvmclock_enabled": ["kvmClock_available", "kvmClock_disabled", "kvmclock_enable", "kvmclock_available", "kvmClock_enabled", "kvmclock_disabled", "kvmclock_supported", "kvmClock_supported"], "system_memory": ["systemsmedia", "systemsmemory", "system___memory", "systemsmachine", "system___model", " system_machine", "system___media", " system_model", " system_media", "systemsmodel", "system_machine", "system_model", "system___machine", "system_media"], "system_io": ["system_ios", "system_info", " system_info", " system_ios"], "i": ["pi", "proc", "j", "e", "d", "p", "is", "r", "n", "l", "ip", "s", "c", "m", "g", "f", "ed", "io", "a", "o", "im", "xi", "b", "iu", "disk", "I", "v"], "below_4g_mem_size": ["below_4g_mem_sum", "below_4g_memsscale", "below_4g_mem_type", "below_4g_mem_name", "below_4g_memstype", "below_4g_memssum", "below_4g_memory_sum", "below_4g_memory_scale", "below_4g_memssize", "below_4g_mem_scale", "below_4g_memory_type", "below_4g_memory_size"], "above_4g_mem_size": ["above_4g_mem_sec", "above_4g_mem_scale", "above_4g_memory_size", "above_4g_mem_small", "above_4g_mem_sum", "above_4g_memory_scale", "above_4g_memsscale", "above_4g_memory_sum", "above_4g_memssec", "above_4g_memssize"], "pci_bus": ["pci_boot", "pcm_bus", "pci__boot", "pci__bus", "pcm_block", "pci__block", "pci_usb", "pcm_usb", "pcm_boot", "pcijbus", "pcijblock", "pci__usb", "pcijusb", "pci_block", "pcijboot"], "isa_bus": ["isa_driver", "isa_device", "isa1boot", "isa1driver", "ci_bus", "ci_driver", "ci_device", "isa1bus", "isa_boot", "ci_boot", "isa1device"], "i440fx_state": ["i440fs2state", "i440fs2config", "i440fx2conn", "i440fxpport", "i440fxpconn", "i440fx_conn", "i440fx_config", "i440fx2config", "i440fs_port", "i440fxpconfig", "i440fs2conn", "i440fs_conn", "i440fx_port", "i440fx2port", "i440fs_config", "i440fs2port", "i440fxpstate", "i440fs_state", "i440fx2state"], "cpu_irq": ["cpu_irtce", "cpu_irQ", "cpu_irce", "cpu_pirQ", "cpu_irtq", "cpu_pirqs", "cpu_IRQ", "cpu_pirq", "cpu_IRce", "cpu_irtQ", "cpu_IRqs", "cpu_pirce", "cpu_irqs", "cpu_IRq", "cpu_irtqs"], "gsi": ["Gdi", "pni", "Gmi", "gni", "psi", "pmi", " gni", " gdi", " gmi", "Gsi", "Gni", "gdi", "pdi", "gmi"], "i8259": ["i8266", "i8192", "u8192", "u8266", "u8259", "i8255", "i6192", "i9255", "i9192", "i6255", "i6259", "i9266", "u8255", "i6266", "i9259"], "smi_irq": ["smi_mirqu", "smi_mirqs", "smi_earqu", "smi_irf", "smi_ironqu", "smi_mirq", "smi_irqu", "smi_earf", "smi_mirf", "smi_ironf", "smi_ironqs", "smi_ironq", "smi_earqs", "smi_earq", "smi_irqs"], "gsi_state": ["gdi_state", "gsi_type", "gsi_info", "gdi_info", "gdi_type", "gdi_config", "gsi_config"], "hd": ["vd", "xd", "dh", "hub", "du", "rh", "h", "dump", "hm", "dim", "hp", "dd", "udi", "gd", "hid", "hw", "HD", "dri", "dr", "bd", "cd", "md", "hs", "pd", "ha", "ht", "ld", "wd", "hard"], "MAX_IDE_BUS": ["MAX_IDERAMBUS", "MAX_IDEJbus", "MAX_IDERAMPU", "MAX_ISE_BI", "MAX_IDEJPU", "MAX_ISE_bus", "MAX_IDE_PU", "MAX_IDEADBUS", "MAX_ISE_USB", "MAX_IDEJBUS", "MAX_IDE_USB", "MAX_IDE_bus", "MAX_ISE_PU", "MAX_ISE_BUS", "MAX_IDEADUSB", "MAX_IDEADBI", "MAX_IDE_BI", "MAX_IDERAMbus"], "MAX_IDE_DEVS": ["MAX_IDE_DAVS", "MAX_IDE_DIVS", "MAX_IDE_DAFS", "MAX_IDE_DFS", "MAX_IDE_DIFS", "MAX_IDE_DIVERS", "MAX_IDE_DVS", "MAX_IDE_DIVICE", "MAX_IDE_DAVERS", "MAX_IDE_DEFS", "MAX_IDE_DVERS", "MAX_IDE_DAVICE", "MAX_IDE_DEVICE", "MAX_IDE_DVICE", "MAX_IDE_DEVERS"], "idebus": ["ideBUS", "idendev", "ipbook", "ipbus", "idenBUS", "ipdev", "idenbus", "sidedev", "idenbook", "idedev", "idebook", "sideBUS", "sidebus", "sidebook", "ipBUS"], "rtc_state": ["rtc_conn", "rtf_conn", "rtc_config", "rtf_state", "rtc_mode", "rtf_mode", "rtf_config"], "floppy": ["FLops", "FLappy", "ploppy", "plops", "plappy", "flipop", "zops", "plipop", "FLipop", "FLoppy", "zoppy", "zipop", "zappy", "flappy", "flops"], "ram_memory": ["system_mem", "system_data", "gram_memory", "ram_manager", "ram_data", "ram_address", "ram_usage", "gram_mem", "gram_address", "system_usage", "gram_manager", "ram_mem"], "pci_memory": ["pciicanmemory", "pci_connection", "pci_address", "pciicanconnection", "pciicanaddress", "pcm_connection", "pcm_mem", "pcm_memory", "pcm_address", "pciicanmem", "pci_mem"], "rom_memory": ["rom_mem", "rom_message", "ram__port", "ram_message", "ram__message", "rom_port", "ramplememory", "ramplemessage", "ram__mem", "ram_port", "ram__memory", "ram_mem", "rampleport", "ramplemem"], "icc_bridge": ["lc_config", "pc_bridge", "iccuredrive", "acl_drive", "icc_brid", "pc_dev", "acl_server", "icc_ridge", "iccurebridge", "iccMridge", "iccureserver", "iccureversion", "iccMpad", "icc_pad", "icc_state", "pc_brid", "iccMbridge", "lc_driver", "icc_server", "acl_version", "lc_bridge", "icc_driver", "pc_driver", "icc_version", "icc_config", "icc_dev", "cci_driver", "icc_drive", "acl_bridge", "cci_ridge", "lc_state", "cci_bridge", "cci_pad", "iccMdriver"], "fw_cfg": ["hw_cfg", "hw_config", "fw_state", "fw_config", "hw_fg", "fw_fg", "hw_state"], "guest_info": ["guess_status", "guestallcfg", "guestallstate", "guest1cfg", "guest1status", "guest_status", "guess_cfg", "guess_info", "guest1info", "guestallinfo", "guess_state", "guest_state", "guest1state", "guestallstatus", "guest_cfg"]}}
{"project": "qemu", "commit_id": "4bb3893908385836410346725dd9e584dcd24836", "target": 0, "func": "uint32_t wm8750_adc_dat(void *opaque)\n\n{\n\n    WM8750State *s = (WM8750State *) opaque;\n\n    uint32_t *data;\n\n\n\n    if (s->idx_in >= sizeof(s->data_in))\n\n        wm8750_in_load(s);\n\n\n\n    data = (uint32_t *) &s->data_in[s->idx_in];\n\n    s->req_in -= 4;\n\n    s->idx_in += 4;\n\n    return *data;\n\n}\n", "idx": 4842, "substitutes": {"opaque": ["ocaques", "ocque", "ocaque", "opacity", "ipec", "paque", "operque", "opaques", " opec", "operaque", "OPque", "OPaque", "operacity", "ocacity", "OPacity", "ipaque", "OPaques", "opque", "paques", "ipaques", " opaques", "pec", "opec", "operaques"], "s": ["an", "scope", "new", "sites", "aws", "e", "d", "sb", "self", "p", "sync", "spec", "ks", "slice", "ls", "session", "S", "params", "is", "ps", "ses", "gs", "sets", "cs", "u", "sf", "ds", "xs", "stats", "n", "states", "ops", "ss", "c", "sg", "m", "t", "sym", "services", "rs", "ts", "fs", "g", "f", "ns", "sa", "as", "a", "ssl", "settings", "i", "o", "sl", "its", "your", "state", "su", "b", "es", "in", "http", "ins", "os", "south", "si"], "data": ["batch", "ui", "output", "options", "da", "DATA", "value", "result", "d", "input", "e", "Data", "val", "p", "ata", "session", "style", "image", "r", "empty", "change", "bytes", "n", "response", "load", "m", "alpha", "wa", "as", "a", "partial", "bin", "cache", "i", "ad", "o", "media", "memory", "valid", "in", "results", "aa", "body", "v", "window", "dat"]}}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n", "idx": 4849, "substitutes": {"v": ["data", "vim", "k", "conv", "j", "vp", "lv", "value", "e", "view", "val", "vi", "p", "h", "vs", "u", "l", "s", "var", "m", "c", "t", "version", "uv", "V", "f", "g", "vt", "a", "i", "iv", "o", "virtual", "sv", "q", "vv", "x"]}}
{"project": "FFmpeg", "commit_id": "11de006babf735aafa3462d43dd2c02bb6ac6e2f", "target": 0, "func": "static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    struct video_data *s = s1->priv_data;\n\n    AVFrame *frame = s1->streams[0]->codec->coded_frame;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    int res;\n\n\n\n    av_init_packet(pkt);\n\n    if ((res = mmap_read_frame(s1, pkt)) < 0) {\n\n        return res;\n\n    }\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (frame && s->interlaced) {\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first = s->top_field_first;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    return pkt->size;\n\n}\n", "idx": 4873, "substitutes": {"s1": ["sOne", "s4", " s81", "ps1", "c1", "fone", "S81", "ses1", "ssone", " sone", "cs01", "c6", "sone", "s6", "ss6", "sesOne", " sOne", "ss2", "ssOne", "s2", "f81", " s01", "c4", "psOne", "ss4", "ss1", "fOne", "f1", "ses81", "s01", "cs4", "cs2", "SOne", "cs6", "s81", "cs81", "ses01", "ss81", "ps01", "cs1", "c2", "ps81", "S1", "csOne", "S01"], "pkt": ["pet", "mdt", "mnt", "psnt", "preet", "pskt", " pak", "ckt", "pnt", "mdr", "cqt", "mkt", " pet", "pdr", " pnt", " pqt", "prent", "Pak", "pdt", " pdr", "psacket", "peacket", "packet", " packet", "cdr", "Pet", "pqt", "preacket", "prekt", "Pkt", "psdt", "peak", "pak", "Packet", "pekt", "peet", "macket", "Pdt", "Pnt", "cacket", "mqt"], "s": ["data", "sq", "e", "parts", "si", "d", "sb", "frames", "sys", "p", "details", "session", "S", "ps", "ses", "gs", "cs", "r", "service", "ds", "sp", "stats", "n", "ss", "m", "c", "services", "t", "fs", "g", "f", "ns", "space", "source", "sa", "a", "ssl", "settings", "w", "o", "series", "b", "ins", "os", "v", "spec"], "frame": ["data", "scope", "object", "zone", "scale", "error", "element", "e", "frames", "component", "coll", "document", "core", "game", "event", "p", "none", "df", "slice", "function", "flow", "session", "style", "iframe", "record", "html", "image", "rame", "module", "position", "line", "fb", "fake", "video", "block", "pse", "c", "dy", "cpu", "summary", "f", "range", "draw", "point", "Frame", "fram", "w", "cf", "o", "fr", "state", "length", "node", "feature", "setup", "row", "lock", "window"], "res": ["br", "re", "reset", "rc", "ress", "ras", "result", "rep", "rss", "error", "len", "val", "arr", "blocks", "details", "rh", "ps", "runs", "r", "resp", " Res", "ros", "bytes", "reg", "id", "rows", "breaks", "rest", "resolution", "resh", "mr", "cr", "ms", "rev", "vals", "err", "rate", "reed", "rap", "gr", "rus", "js", "pres", "ris", "RES", "errors", "results", "os", "red", "Res", "nos", "rs", "ret"], "interlaced": ["interpace", " interpolaced", "interragged", "interpagged", "interraced", "interrated", "interpolagged", " interlagged", "interlace", "interpated", "interpolace", " interpolace", "interlated", "interpolated", " interpolagged", " interlated", "interpolaced", "interrace", "interpaced", " interpolated", "interlagged", " interlace"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n", "idx": 4874, "substitutes": {"klass": ["okclass", "Klass", "kcl", "skcl", "Kleton", "Kclass", "skclass", " kleton", "klasses", "ccclass", "sklass", "kclass", "Kcl", "sklasses", " klasses", "ccleton", "Klasses", "oklass", " kcl", "kleton", " kclass", "okcl", "cclass", "oklasses", "cclasses"], "data": ["rc", "reader", "da", "def", "di", "DATA", "input", "d", "Data", "raw", "ata", "p", "params", "config", "dd", "child", "load", "m", "ctx", "f", "parent", "cache", "i", "o", "dat"], "dc": ["nc", "uc", "dn", "rc", "da", "di", "d", "tk", "cc", "dt", "df", "design", "oc", "sc", "conn", "ct", "cca", "cdn", "ck", "c", "bc", "cr", "mc", "ec", "dk", "fc", "cf", "ca", "ga", "tc", "dr", "cd", "DC", "ac", "disc", "cp", "dat"], "k": ["kid", "e", "d", "tk", "ik", "cc", "self", "p", "ks", "kw", "oc", "K", "kin", "kick", "kk", "ku", "cs", "n", "s", "ck", "c", "m", "g", "f", "mc", "mk", "dk", "w", "o", "kn", "ad", "sk", "kind", "ok", "q", "ke", "spec"]}}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    MPADecodeHeader c;\n\n    int vbrtag_size = 0;\n\n    MP3DecContext *mp3 = s->priv_data;\n\n\n\n    ffio_init_checksum(s->pb, ff_crcA001_update, 0);\n\n\n\n    v = avio_rb32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return -1;\n\n\n\n    if (avpriv_mpegaudio_decode_header(&c, v) == 0)\n\n        vbrtag_size = c.frame_size;\n\n    if(c.layer != 3)\n\n        return -1;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n\n\n    mp3->frames = 0;\n\n    mp3->size   = 0;\n\n\n\n    mp3_parse_info_tag(s, st, &c, spf);\n\n    mp3_parse_vbri_tag(s, st, base);\n\n\n\n    if (!mp3->frames && !mp3->size)\n\n        return -1;\n\n\n\n    /* Skip the vbr tag frame */\n\n    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);\n\n\n\n    if (mp3->frames)\n\n        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},\n\n                                    st->time_base);\n\n    if (mp3->size && mp3->frames && !mp3->is_cbr)\n\n        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);\n\n\n\n    return 0;\n\n}\n", "idx": 4879, "substitutes": {"s": ["storage", "sq", "aws", "e", "sb", "self", "sys", "p", "sync", "spec", "src", "ls", "ks", "S", "session", "ps", "sc", "is", "ses", "qs", "cs", "sets", "gs", "service", "sf", "ds", "xs", "ches", "states", "ops", "ss", "m", "sg", "services", "t", "ts", "sym", "fs", "g", "f", "ns", "space", "sup", "sa", "sim", "us", "ssl", "se", "sl", "w", "its", "sv", "js", "b", "su", "es", "bs", "os", "conf", "rs", "si"], "st": ["ste", "storage", "sth", "stack", "ust", "e", "d", "ast", "sb", "str", "fe", "p", "std", "src", "style", "stop", "ost", "sc", "ct", "support", "cs", "r", "td", "sp", "ds", "est", "stage", "sts", "St", "ss", "rest", "ts", "t", "ctx", "step", "tmp", "sh", "sa", "nd", "start", "inst", "sn", "sta", "sl", "state", "sd", "b", "store", "stream", "ST", "si"], "base": ["stable", "ui", "bi", "root", "ase", "ada", "stack", "index", "gb", "set", "scale", "area", "end", "name", "bf", "len", "val", "server", "byte", "p", "Base", "api", "client", "beta", "pad", " bases", "ace", "old", "full", "ii", "r", "out", "hi", "u", "offset", "ases", "at", "id", "stage", "l", "temp", "rest", "based", "version", "address", "buffer", "f", "start", "kit", "a", "cache", "i", "ma", "prefix", "ver", "origin", "bound", "store", "b", "zero", "bas"], "v": ["volt", "pi", "vm", "conv", "k", " channel", "j", "vd", "lv", "value", "e", "d", "vert", "val", " version", "ve", "vi", "p", "api", "h", "channel", "vs", "r", "ch", "u", "at", "n", "l", "m", "t", "uv", "V", "f", "g", "rev", "a", "cv", "i", "w", "o", "ver", "iv", "code", "va", "z", "sv", "b", "store", "format", "vc", "q", "vv", "x"], "spf": ["SPfs", " spfw", "swf", " spfs", "arpfx", " spfx", "SPf", "aspfw", "arpf", "ipF", "spv", "scfe", "spb", "spp", "swb", "scfx", "aspfo", "scfd", "ipv", "ipfs", " spv", " spfe", "aspv", "ispfs", "ispfe", "spfd", " spF", "SPp", "scf", "epfs", "SPb", "spF", "spfx", "spg", "scg", "spfo", "aspf", "swfs", " spb", " spfd", "scfo", "scfs", "spfw", "spfg", "epv", "ispf", " spfo", "spfe", "swp", "spfs", "ipf", "scfg", "epf", " spfg", "scv", "epF", " spg", " spp", "arpfd", "ispfg", "scfw", "arpg"], "c": ["uc", "pc", "rc", "k", "e", "d", "enc", "coll", "co", "cc", "p", "spec", "ce", "h", "sc", "ct", "xc", "cm", "cs", "ch", "config", "u", "n", "l", "ic", "cy", "m", "t", "ctx", "bc", "dc", "cr", "g", "f", "ctrl", "mc", "cl", "a", "ec", "fc", "cu", "i", "cf", "C", "tc", "code", "ci", "lc", "ac", "b", "vc", "con", "cp", "x"], "mp3": ["mp23", "mb15", "mm3", "jp03", "av48", "mb53", "mp53", "mag6", "mb23", "MP6", "mb6", "mm6", "Mpcd", "mp13", "mp6", "map03", " mp15", "mp253", "amp2", "Mp6", "amp3", "mediathree", "comp03", "comp3", "mb03", "av253", "av03", " mp23", "mp4", "mpthree", "pm3", "pm23", "MP48", "media3", "av3", " mp1", "pp53", "comp48", "mt23", "MPthree", "map253", "jp3", "MP13", " mp2", "media23", "Mp13", "pp3", "mb253", "pp2", "pm03", "mt15", " mp4", "mp03", "comp13", "MP03", " mp6", "mag13", "Mp03", "mt6", " mpthree", "mp35", "jp1", "Mp3", "mm03", "MP3", "pp35", "pp03", "map3", "pm35", "mb1", "mp1", "mb35", " mpcd", "mp48", " mp53", "jp4", "Mp2", "mapthree", "mm53", "media03", "mp2", "amp6", "pp23", "avthree", "ampcd", "mp15", "mb3", "magthree", "mb2", "ppthree", "mb13", " mp03", "mpcd", "mb4", "mt3", "mbthree", "mag3"]}}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay_all(MemoryRegion *mr)\n\n{\n\n    IOMMUNotifier *notifier;\n\n\n\n    IOMMU_NOTIFIER_FOREACH(notifier, mr) {\n\n        memory_region_iommu_replay(mr, notifier, false);\n\n    }\n\n}\n", "idx": 4892, "substitutes": {"mr": ["br", "vm", "reader", "gb", " MR", "mt", "mm", "rm", "vr", "er", "rg", "mid", "rf", "bm", "rx", "rule", "rh", "hr", "mi", "module", "cm", "r", "ml", "RR", "fm", "mir", "rr", "mn", "MR", "lr", "sr", "m", "pm", "tr", "mc", "ir", "nr", "kr", "manager", "yr", "fr", "dr", "md", "gr", "dm", "rb", "ra", "attr", "ris", "rs", "adr", "rt"], "notifier": [" notger", "ntizer", "nonifier", "bitifer", "bitification", "nonification", "notifer", "nonifer", "notener", "nonener", " notifer", "annotifer", " notification", "notger", "Notifier", "annizer", "notizer", "annification", "bitger", "Notifer", "Notger", "Notification", "ntifer", " notener", "ntifier", "annotener", "bitifier", "notification", "annotifier", " notizer", "ntification", "annifier", "annotification", "annifer"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix3_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 4893, "substitutes": {"dev": ["data", "Dev", "pub", "end", "def", "development", "error", "diff", "rad", "d", "de", "adv", "loader", "debug", "DEV", "app", "conn", "test", "bug", "ev", "prom", "ch", "device", " device", "block", "dd", "mode", "v", "engine", "comment", "inst", "mod", "serial", "hw", "req", "err", "info", "w", "ver", "md", "desc", "kind", "grad", "priv", "dem", "conf", "gu", "spec"], "s": ["storage", "sq", "e", "d", "si", "sb", "server", "sys", "p", "sync", "session", "S", "ses", "sf", "ds", "n", "ss", "c", "sg", "m", "sh", "services", "t", "g", "f", "ssl", "settings", "i", "sl", "w", "o", "sv", "state", "b", "js", "os", "conf", "serv", "v", "south", "spec"], "pci_conf": ["pki_config", "pci_sum", "pii_config", "pki_conf", "pii_conf", "pcm_conn", "pci_conn", "pcm_sum", "pki_def", "pci_def", "pci_config", "pii_conn", "pcm_config", "pci_Conf", "pcm_conf", "pki_conn", "pii_Conf"]}}
{"project": "FFmpeg", "commit_id": "842b6c14bcfc1c5da1a2d288fd65386eb8c158ad", "target": 0, "func": "static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;\n\n    int val, stream_type, i;\n\n\n\n    q = data;\n\n    put16(&q, 0xe000 | service->pcr_pid);\n\n\n\n    program_info_length_ptr = q;\n\n    q += 2; /* patched after */\n\n\n\n    /* put program info here */\n\n\n\n    val = 0xf000 | (q - program_info_length_ptr - 2);\n\n    program_info_length_ptr[0] = val >> 8;\n\n    program_info_length_ptr[1] = val;\n\n\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        MpegTSWriteStream *ts_st = st->priv_data;\n\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        switch(st->codec->codec_id) {\n\n        case AV_CODEC_ID_MPEG1VIDEO:\n\n        case AV_CODEC_ID_MPEG2VIDEO:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG2;\n\n            break;\n\n        case AV_CODEC_ID_MPEG4:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG4;\n\n            break;\n\n        case AV_CODEC_ID_H264:\n\n            stream_type = STREAM_TYPE_VIDEO_H264;\n\n            break;\n\n        case AV_CODEC_ID_CAVS:\n\n            stream_type = STREAM_TYPE_VIDEO_CAVS;\n\n            break;\n\n        case AV_CODEC_ID_DIRAC:\n\n            stream_type = STREAM_TYPE_VIDEO_DIRAC;\n\n            break;\n\n        case AV_CODEC_ID_MP2:\n\n        case AV_CODEC_ID_MP3:\n\n            stream_type = STREAM_TYPE_AUDIO_MPEG1;\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;\n\n            break;\n\n        case AV_CODEC_ID_AAC_LATM:\n\n            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;\n\n            break;\n\n        case AV_CODEC_ID_AC3:\n\n            stream_type = STREAM_TYPE_AUDIO_AC3;\n\n            break;\n\n        default:\n\n            stream_type = STREAM_TYPE_PRIVATE_DATA;\n\n            break;\n\n        }\n\n        *q++ = stream_type;\n\n        put16(&q, 0xe000 | ts_st->pid);\n\n        desc_length_ptr = q;\n\n        q += 2; /* patched after */\n\n\n\n        /* write optional descriptors here */\n\n        switch(st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if(st->codec->codec_id==AV_CODEC_ID_EAC3){\n\n                *q++=0x7a; // EAC3 descriptor see A038 DVB SI\n\n                *q++=1; // 1 byte, all flags sets to 0\n\n                *q++=0; // omit all fields...\n\n            }\n\n            if(st->codec->codec_id==AV_CODEC_ID_S302M){\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'B';\n\n                *q++ = 'S';\n\n                *q++ = 'S';\n\n                *q++ = 'D';\n\n            }\n\n\n\n            if (lang) {\n\n                char *p;\n\n                char *next = lang->value;\n\n                uint8_t *len_ptr;\n\n\n\n                *q++ = 0x0a; /* ISO 639 language descriptor */\n\n                len_ptr = q++;\n\n                *len_ptr = 0;\n\n\n\n                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n\n                    next = strchr(p, ',');\n\n                    if (strlen(p) != 3 && (!next || next != p + 3))\n\n                        continue; /* not a 3-letter code */\n\n\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n\n\n                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n\n                    *q++ = 0x01;\n\n                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)\n\n                    *q++ = 0x02;\n\n                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)\n\n                    *q++ = 0x03;\n\n                else\n\n                    *q++ = 0; /* undefined type */\n\n\n\n                    *len_ptr += 4;\n\n                }\n\n\n\n                if (*len_ptr == 0)\n\n                    q -= 2; /* no language codes were written */\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            {\n\n                const char default_language[] = \"und\";\n\n                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n\n\n\n                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n\n                    uint8_t *len_ptr;\n\n                    int extradata_copied = 0;\n\n\n\n                    *q++ = 0x59; /* subtitling_descriptor */\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - extradata_copied >= 5) {\n\n                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n\n                            extradata_copied += 5;\n\n                            q += 4;\n\n                        } else {\n\n                            /* subtitling_type:\n\n                             * 0x10 - normal with no monitor aspect ratio criticality\n\n                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */\n\n                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n\n                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n\n                                /* support of old 4-byte extradata format */\n\n                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n\n                                extradata_copied += 4;\n\n                                q += 4;\n\n                            } else {\n\n                                put16(&q, 1); /* composition_page_id */\n\n                                put16(&q, 1); /* ancillary_page_id */\n\n                            }\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n\n                    uint8_t *len_ptr = NULL;\n\n                    int extradata_copied = 0;\n\n\n\n                    /* The descriptor tag. teletext_descriptor */\n\n                    *q++ = 0x56;\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3) {\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - 1 > extradata_copied) {\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 2);\n\n                            extradata_copied += 2;\n\n                            q += 2;\n\n                        } else {\n\n                            /* The Teletext descriptor:\n\n                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)\n\n                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.\n\n                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */\n\n                            *q++ = 0x08;\n\n                            *q++ = 0x00;\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                 }\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {\n\n                *q++ = 0x05; /*MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'd';\n\n                *q++ = 'r';\n\n                *q++ = 'a';\n\n                *q++ = 'c';\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor */\n\n                *q++ = 4;\n\n                *q++ = 'K';\n\n                *q++ = 'L';\n\n                *q++ = 'V';\n\n                *q++ = 'A';\n\n            }\n\n            break;\n\n        }\n\n\n\n        val = 0xf000 | (q - desc_length_ptr - 2);\n\n        desc_length_ptr[0] = val >> 8;\n\n        desc_length_ptr[1] = val;\n\n    }\n\n    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,\n\n                          data, q - data);\n\n}\n", "idx": 4896, "substitutes": {"s": ["ys", "y", "storage", "sq", "aws", "si", "parts", "server", "sys", "sync", "ks", "session", "S", "is", "ps", "ses", "support", "cs", "gs", "sets", "sf", "ds", "ches", "l", "states", "ss", "c", "t", "services", "v", "g", "f", "ns", "space", "sa", "sim", "as", "ssl", "settings", "sl", "its", "tests", "series", "sv", "js", "b", "su", "ins", "os", "qs", "rs", "spec"], "service": ["scope", "storage", "reader", "ie", "j", "server", "so", "sys", "sync", "connection", "session", "support", "image", "resource", "cs", "config", "query", "sp", "Service", "sr", "c", "services", "ctx", "fs", "g", "space", "settings", "se", "info", "sl", "sv", "sd", "js", "bank", "vc", "stream", "serv", "v", "si"], "ts": ["outs", "trans", "att", "ats", "ets", "ks", "ls", "ps", "uts", "test", "atts", "acs", "cs", "gs", "tt", "Ts", "ds", "ims", "ents", "tx", "tu", "ss", "rs", "t", "services", "fs", "tr", "ns", "ms", "TS", "tests", "tc", "ics", "qs", "tes", "utils"], "data": ["reader", "def", "DATA", "input", "d", "Data", "len", "raw", "mem", "arr", "byte", "map", "buf", "seq", "offset", "r", "empty", "config", "bytes", "ds", "read", "block", "ops", "rec", "buffer", "shift", "f", "array", "vals", "a", "req", "cache", "xxx", "length", "zero", "stream", "format", "dat"], "q": ["depth", "k", "sq", "queue", "value", "d", "charge", "iq", "type", "dq", "h", "seq", "qs", "qi", "ue", "ch", "query", "u", "id", "n", "l", "qu", "c", "t", "quant", "g", "f", "requ", "qa", "req", "Q", "quest", "w", "o", "qq", "z", "length", "qt", "count", "v", "x"], "desc_length_ptr": ["program_length32ptr", "program_length_info", "program_length_length", "program_length32pointer", "program_length_ptr", "program_length32length", "program_len_ptr", "program_length_pointer", "program_len_info", "program_len_pointer", "program_len_length", "program_length32info"], "program_info_length_ptr": ["program_info_length__pointers", "program_info_length_val", "program_info_length_tr", "program_info_info_val", "program_info_length_pointer", "program_info_info_pointers", "program_info_info_pad", "program_info_len_ptr", "program_info_info_tr", "program_info_info_ptr", "program_info_len_len", "program_info_len_length", "program_info_info_pointer", "program_info_info_length", "program_info_length_pointers", "program_info_length_length", "program_info_length_len", "program_info_length__length", "program_info_len_pointer", "program_info_length__pointer", "program_info_length_pad", "program_info_length__ptr"], "val": ["vl", "depth", "k", "ref", "cal", "sec", "eval", "au", "value", "e", "d", "sel", "aval", "fx", "alt", "len", "fl", "ival", "ol", "base", "ul", "bl", "buf", "seq", "r", "l", "tx", "bc", "Val", "il", "pt", "f", "vol", "max", "vals", "el", " v", "sl", "VAL", "al", "valid", "b", "grad", "v", " value", "x", "li"], "stream_type": ["resourceingcount", "streamingcount", "streamingvalue", "outputenid", "stream_TYPE", "source_id", "streaminglength", "program_id", "resourceingtype", "output_target", "channel_type", "program_name", "streamsstyle", "streamalvalue", "streamentarget", "streamsid", "streamerunit", "stream_template", "source_type", "sourcesmode", "streamingstate", "resourceingshape", "stream_target", "outputentype", "streamabletype", "streamableid", "streamenunit", "streamervalue", "streamingshape", "stream_mode", "streamalstate", "resourceingid", "stream_value", "ream_unit", "streamentype", "stream_shape", "outputentarget", "stream_name", "streamingname", "streamfformat", "output_length", "stream_count", "streamablemode", "streamingformat", "source_style", "sourcesid", "streamertype", "ream_list", "streamablestyle", "channel_TYPE", "channel_format", " stream_template", "streamerlist", "program_length", "streamalid", "resource_type", "streamalmode", "streamstype", "streamftemplate", "ream_format", "streamftype", "stream_list", "ream_type", "streamvaltype", "sourcestype", "streamingtemplate", "streamalformat", "resource_id", "sourcesstyle", "streamingTYPE", "streamenlist", "streamenlength", "streamingtype", "stream_length", "streamalstyle", "streamenid", " stream_id", "outputenlength", "streamingid", "streamfTYPE", "streamvaltemplate", "stream_format", "stream_style", "streamstarget", "stream_state", "streamslength", "stream_unit", "source_mode", "streamenvalue", "resource_shape", "program_type", "ream_value", "streamvalid", "output_id", "output_type", "streamaltype", "channel_template", "resource_count", "ream_state", "stream_id", "streamsmode"], "i": ["ui", "y", "index", "pi", "k", "ie", "j", "di", "si", "d", "e", "multi", "fi", "ti", "li", "yi", "uli", "mi", "phi", "qi", "ii", "hi", "u", "id", "ni", "ip", "abi", "m", "c", "ix", "oi", "zi", "io", "ri", "ini", "info", "o", "gi", "mu", "xi", "im", "uri", "my", "it", "ci", "eni", "b", "iu", "I", "ai", "v", "x"], "st": ["ste", "stal", "sth", "d", "stress", "ast", "sb", "str", "fe", "std", "src", "ost", "sc", "r", "sp", "ds", "est", "stage", "sts", "St", "ist", "sr", "rest", "t", "pt", "tr", "sa", "nd", "sn", "start", "inst", "sta", "sl", "fr", "stream", "sw", "sd", "td", "ld", "ST", "stim"], "ts_st": ["ds_sc", "ds_st", "ds_stream", "ts_sc", "ts_stream", "ts_ost", "ds_ost"], "lang": ["tag", "au", "th", "de", "trans", "enc", "ast", "pl", "str", "std", "src", "bl", "ml", "tx", "obj", "tu", "entry", "art", "sa", "nd", "en", "ga", "la", "lc", "sd", "in", "rs"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 4899, "substitutes": {"dc": ["data", "nc", "uc", "rc", "pc", "da", "dir", "di", "de", "db", "loc", "input", "d", "diff", "circ", "exec", "jc", "cc", "dt", "du", "ea", "df", "gc", "design", "sc", "ct", "conn", "cm", "config", "dp", "ds", "die", "cca", "cdn", "fd", "c", "enter", "bc", "draw", "mc", "ec", "fc", "cu", " DC", "cf", "gui", "ca", "tc", "ga", "dr", "lc", "cd", "dm", "DC", "ac", "desc", "disc", "vc", "doc", "dat"], "t0": ["p1", "t1", "te1", "it1", "T0", "T4", "tt80", "T80", "itfe", " t3", "tt1", "p4", "T1", "tt2", " t4", "T50", "t50", " t50", "T3", "te2", " t80", " tfe", "t80", "p0", "tt3", "tfe", "it0", "te0", "t3", "tt0", "te50", "T2", "Tfe", "t2", "tt50", " t1", "t4", " t2"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_trap (DisasContext *ctx, uint32_t opc,\n\n                      int rs, int rt, int16_t imm)\n\n{\n\n    int cond;\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    cond = 0;\n\n    /* Load needed operands */\n\n    switch (opc) {\n\n    case OPC_TEQ:\n\n    case OPC_TGE:\n\n    case OPC_TGEU:\n\n    case OPC_TLT:\n\n    case OPC_TLTU:\n\n    case OPC_TNE:\n\n        /* Compare two registers */\n\n        if (rs != rt) {\n\n            gen_load_gpr(t0, rs);\n\n            gen_load_gpr(t1, rt);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    case OPC_TEQI:\n\n    case OPC_TGEI:\n\n    case OPC_TGEIU:\n\n    case OPC_TLTI:\n\n    case OPC_TLTIU:\n\n    case OPC_TNEI:\n\n        /* Compare register to immediate */\n\n        if (rs != 0 || imm != 0) {\n\n            gen_load_gpr(t0, rs);\n\n            tcg_gen_movi_tl(t1, (int32_t)imm);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    }\n\n    if (cond == 0) {\n\n        switch (opc) {\n\n        case OPC_TEQ:   /* rs == rs */\n\n        case OPC_TEQI:  /* r0 == 0  */\n\n        case OPC_TGE:   /* rs >= rs */\n\n        case OPC_TGEI:  /* r0 >= 0  */\n\n        case OPC_TGEU:  /* rs >= rs unsigned */\n\n        case OPC_TGEIU: /* r0 >= 0  unsigned */\n\n            /* Always trap */\n\n            generate_exception(ctx, EXCP_TRAP);\n\n            break;\n\n        case OPC_TLT:   /* rs < rs           */\n\n        case OPC_TLTI:  /* r0 < 0            */\n\n        case OPC_TLTU:  /* rs < rs unsigned  */\n\n        case OPC_TLTIU: /* r0 < 0  unsigned  */\n\n        case OPC_TNE:   /* rs != rs          */\n\n        case OPC_TNEI:  /* r0 != 0           */\n\n            /* Never trap: treat as NOP. */\n\n            break;\n\n        }\n\n    } else {\n\n        int l1 = gen_new_label();\n\n\n\n        switch (opc) {\n\n        case OPC_TEQ:\n\n        case OPC_TEQI:\n\n            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);\n\n            break;\n\n        case OPC_TGE:\n\n        case OPC_TGEI:\n\n            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);\n\n            break;\n\n        case OPC_TGEU:\n\n        case OPC_TGEIU:\n\n            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);\n\n            break;\n\n        case OPC_TLT:\n\n        case OPC_TLTI:\n\n            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);\n\n            break;\n\n        case OPC_TLTU:\n\n        case OPC_TLTIU:\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n            break;\n\n        case OPC_TNE:\n\n        case OPC_TNEI:\n\n            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);\n\n            break;\n\n        }\n\n        generate_exception(ctx, EXCP_TRAP);\n\n        gen_set_label(l1);\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 4924, "substitutes": {"ctx": ["context", "sci", "rc", "conv", " c", " cx", "loc", "anc", "cc", "buf", " context", "conn", "ct", "sc", "config", "jp", "cca", "tx", "Context", "obj", "ck", "c", "bc", "kb", "ctrl", "cv", "cam", "pkg", "cu", "cf", "ca", "tc", "cas", "grad", "cb", "cmp", "fp", "utils"], "opc": ["ropc", "oopC", "OPci", "optC", "optenc", "operc", "OPc", "optcu", "opf", "OPcu", "copenc", "copC", "copc", "oopf", "opci", "opcu", "operC", "optc", "opC", "ropcu", "ropC", "iopC", "opcs", "opct", "oopenc", "copf", "openc", " opct", " opcs", "optct", "operci", "optcs", "operct", " opC", "optf", "opercu", "iopc", "opercs", "oopc", "OPC", "iopcu", "ropci"], "rs": ["rc", "ras", "rss", "rm", "vr", "RC", "RS", "rg", "rx", "src", "ls", "pps", "ps", "vs", "pr", "r", "cs", "ims", "xs", "ds", "ubs", "rr", "rates", "ars", "res", "lr", "sr", "mr", "rd", "tr", "ns", "sl", "mods", "kr", "dr", "sw", "rb", "rw", "ra", "rl", "ris", "ins", "hs", "rpm", "Rs", "eps", "spec"], "rt": ["RT", "ru", "rc", "mt", "rm", "alt", "vr", "rit", "rss", "ras", "rx", "rf", "ls", "irm", "rob", "r", "lt", "irt", "rr", "rot", "m", "sr", "mr", "rd", "rec", "cr", "pt", "tr", "tmp", "tm", "ri", "ort", "rat", "nt", "dr", "rb", "attr", "rin", "igr", "ptr", " rm"], "imm": ["em", "gm", "amm", "vm", "mt", "mm", "alt", "rm", "imi", "mem", "bm", "mit", "mi", "irm", "cm", "ims", "imp", "irt", "lt", "elt", "fm", "lim", "dim", "m", "pm", "tmp", "ym", "il", "pt", "serv", "sim", "tm", "inst", "mitt", "ort", "nat", "iv", "mods", "km", "im", "sl", "mun", "attr", "iter", "lig", "igr", "Imm", "orm", "adr", "asm"], "cond": ["pos", "Cond", "sec", "fail", "pre", "loc", "success", "len", "val", "bool", "co", "call", "no", "mit", "xc", "ct", "resp", "box", "cell", "crit", "ind", "cmd", "lim", "cont", "red", "fd", "c", "bc", "condition", "pt", "day", "part", "nt", "code", "reason", "lc", "bound", "fact", "rupt", "col", "lock", "count", "cmp", "con", "comp", "unit", "lay", "thread", "x"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPSR\\n\");\n\n        return 0;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPCR\\n\");\n\n        return 0;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4961, "substitutes": {"opaque": ["obaque", " opque", " opacle", "OPacle", "cophole", "OPhole", "copaque", "opaques", "ophole", "OPque", "OPaque", "obaques", "obhole", "copacle", "OPaques", "opque", "opacle", " opaques", "obque", "copque", " ophole"], "offset": ["operation", "pos", "index", "reset", "object", "ref", "set", "end", "url", "number", "from", "error", "loc", "element", "e", "limit", "len", "op", "p", "Offset", "type", "pad", "num", "order", "account", "position", "off", "et", "id", "skip", "online", "mode", "entry", "address", "f", "pointer", "shift", "range", "enabled", "array", "location", "padding", "start", "part", "slot", "initial", "i", "info", "o", "reference", "prefix", "length", "node", "alias", "addr", "count", "fp", "align", "token", "base"], "size": ["data", "pos", "from", "small", "set", "scale", "len", "args", "type", "SIZE", "bytes", " length", "ize", "Size", "address", "start", "fee", "timeout", "length", "desc", "count", "align", "format"], "s": ["eds", "d", "er", "sync", "ops", "sg", "services", "f", "ries", "b", "in", "v", "south", "new", "sites", "sq", "outs", "ients", "lines", "sb", "ses", "r", "cs", "u", "ing", "ions", "irs", " services", "ss", "ts", "t", "ns", "a", "w", "its", "ports", "your", "izes", "es", "ments", "ins", "ers", "parts", "ores", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "ies", "ings", "gs", "sets", "ims", "ands", "ches", "stats", "n", "ians", "rows", "c", "g", "ed", "us", "ssl", "su", "qs", "rs", "si", "spec", "y", "e", "ows", " comments", "erences", " signals", "ists", "server", "is", "service", "ds", "l", "sts", "states", "sym", "m", "settings", "als", "i", "o", "secondary", " entries", " changes", "os", "ips"], "ret": ["data", "pat", "re", "ref", "def", "result", "fun", "success", "alt", "rep", "back", "get", "len", "val", " Ret", "fi", " RET", "mem", "str", "bit", "seq", "num", "RET", "r", "resp", "out", "reg", "res", "fin", "g", "f", "rev", "lit", "flag", "feat", "gt", "det", "info", "ft", "match", "reply", "nt", "leg", "job", "desc", "rets", "final", "Ret"], "bank": ["result", "name", "ban", "type", "rank", "order", "device", "id", "file", "f", "range", "gp", "bin", "sk", "b", "count", "row", "ANK", "batch", "root", "k", "ank", "key", "grade", "rule", "app", "module", "bug", "change", "bot", "mode", "rec", "page", "cat", "group", "project", "Bank", "banks", "year", "machine", "brand", "base", "library", "division", "domain", "byte", "p", "bm", "session", "flow", "ku", "account", "query", "lib", "plugin", "block", "cy", "child", "comment", "model", "prefix", "nt", "length", "kind", "board", "feature", "plan", "resource", "feed", "work", "cell", "token", "tag", "scope", "field", "error", "core", "anc", "command", "op", "lang", "ch", "service", "pa", "buffer", "scan", "book", "hop", "cache", "user", "school", "company", "band", "alias", "com"]}}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;", "idx": 4995, "substitutes": {"s": ["sync", "sports", "rame", "site", "ops", "services", "screen", "fs", "f", "sv", "b", "features", "in", "conf", "context", "data", "sq", "sb", "ses", "cs", "this", "r", "u", "sf", "ss", "ts", "t", "ns", "a", "es", "ins", "parts", "frames", "sys", "self", "p", "ls", "session", "S", "ps", "gs", "sets", "n", "c", "css", "g", "us", "ssl", "sl", "cpp", "qs", "rs", "spec", "si", "e", "src", "is", "service", "ds", "l", "sym", "m", "ctx", "ms", "as", "bis", "se", "i", "js", "os"], "frame": ["j", "e", "frames", "view", "document", "game", "p", "session", "flow", "iframe", "image", "video", "c", "m", "ctx", "f", "Frame", "fram", "w", "fr", "series", "state", "b", " Frame", "v", "window", "scene"], "y": ["py", "oy", "ty", "ys", "zy", "yd", "j", "e", "ny", "yy", "iy", "ey", "yi", "sky", "p", "ry", "type", "hy", "ye", "ay", "sy", "n", "cy", "yo", "vy", "gy", "c", "m", "t", "dy", "ym", "yu", "f", "yn", "isy", " x", "Y", "xy", "i", "my", "w", "o", "yr", "ky", "z", "b", "ya", "year", "v", "x"], "P": ["Port", "CP", "NP", "IP", "RP", "PS", "p", "A", "FP", "W", "MP", "Ps", "S", "AP", "D", "F", "PP", "JP", "Point", "PA", "PIN", "LP", "E", "L", "Part", "V", "XP", "BP", "API", "Y", "Q", "R", "N", "VP", "TP", "PF", "C", "GP", "H", "Path", "DP", "FF", "HP", "I", "OP", "T", "PO", "J", "X", "ARP"]}}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 5035, "substitutes": {"opaque": ["ospatile", "ospaques", "oaacity", "openatile", "opatile", "openaques", "opifice", "opacity", "openaque", "copaque", "ospifice", "opaques", "oaaques", "copaques", "ospaque", " opifice", "openifice", "copacity", " opacity", " opatile", " opaques", "oaaque"], "new_rate": ["newWlimit", " new_range", "newWrated", "new_rates", "new_range", "new_rated", "newWrates", " new_limit", " new_rates", "newWrate", "new_limit", " new_rated"], "s": ["scope", "storage", "sec", "sq", "e", "ows", "submit", "sb", "sys", "p", "sync", "spec", "ks", "ls", "S", "ps", "ses", "gs", "cs", "sets", "sf", "ds", "ips", "n", "rates", "states", "ops", "ss", "m", "sg", "ts", "c", "services", "sym", "rs", "fs", "f", "ns", "ms", "sa", "ssl", "settings", "se", "als", "o", "sl", "secondary", "su", "es", "ments", "ins", "hs", "os", "qs", "south", "si"]}}
{"project": "FFmpeg", "commit_id": "aefdb735c3df9480c1ca9bcf4a3835bd66271bd1", "target": 0, "func": "static void reverse_matrixing(float *su1, float *su2, int *prev_code,\n\n                              int *curr_code)\n\n{\n\n    int i, nsample, band;\n\n    float mc1_l, mc1_r, mc2_l, mc2_r;\n\n\n\n    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {\n\n        int s1 = prev_code[i];\n\n        int s2 = curr_code[i];\n\n        nsample = 0;\n\n\n\n        if (s1 != s2) {\n\n            /* Selector value changed, interpolation needed. */\n\n            mc1_l = matrix_coeffs[s1 * 2    ];\n\n            mc1_r = matrix_coeffs[s1 * 2 + 1];\n\n            mc2_l = matrix_coeffs[s2 * 2    ];\n\n            mc2_r = matrix_coeffs[s2 * 2 + 1];\n\n\n\n            /* Interpolation is done over the first eight samples. */\n\n            for (; nsample < 8; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +\n\n                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);\n\n                su1[band + nsample] = c2;\n\n                su2[band + nsample] = c1 * 2.0 - c2;\n\n            }\n\n        }\n\n\n\n        /* Apply the matrix without interpolation. */\n\n        switch (s2) {\n\n        case 0:     /* M/S decoding */\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] =  c2       * 2.0;\n\n                su2[band + nsample] = (c1 - c2) * 2.0;\n\n            }\n\n            break;\n\n        case 1:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = (c1 + c2) *  2.0;\n\n                su2[band + nsample] =  c2       * -2.0;\n\n            }\n\n            break;\n\n        case 2:\n\n        case 3:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = c1 + c2;\n\n                su2[band + nsample] = c1 - c2;\n\n            }\n\n            break;\n\n        default:\n\n            assert(0);\n\n        }\n\n    }\n\n}\n", "idx": 5044, "substitutes": {"su1": ["suit10", "su100", "su01", "se2", "su31", "su61", "Su31", "loc1", "Su7", "se31", "su10", "gru2", "seOne", "su7", "semOne", "u31", " su01", "su81", "gru81", "Su1", " suone", "sing11", "se61", "semone", "suOne", "prof81", "suitone", "u1", "Su2", " sufirst", "ru11", "prof2", "ruOne", " su11", "sifirst", "prof1", "tu01", "ru2", "suone", "sefirst", "tuone", "Su61", "si2", "ru7", "se81", "tu10", "locone", "_", "si1", "se7", "sing100", "gru1", "u61", "suit1", "su11", "tu31", "suitOne", " su31", "tuOne", "SuOne", "sem10", "tu1", " su100", "sem1", "se1", "ru1", "sufirst", "loc31", "loc01", "ru100", "u2", "sing1"], "su2": ["usc3", "ru2", "suit62", "suit152", "su14", "se2", "su3", "usc2", " su36", "sf2", "site1", "sb", " sutwo", "ru152", "ru0", "sf152", "s22", "su36", "su152", "Su0", " su22", "suit2", "sf14", "Su22", "su20", " su4", "s2", "sftwo", "rub", "Sutwo", "sutwo", "ru14", "site0", "ru4", "su4", "se20", "Su02", "site2", "site20", "Su62", "suit4", "suittwo", "suit14", "se1", "ru36", "rutwo", "usctwo", "setwo", "Su2", "su0", "Su36", "se4", " su02", "se3", "su22", "usc4", "ru02", "se0", "sub", "su62", " su62", "su02", "Su4", " su3", " su20", " su0", "stwo", "Sub", "ru22"], "prev_code": ["pre_que", "prevlicline", "pre_line", "prev_line", "pre_div", "pre_codes", "pre_pair", "prev_codes", "prevlicdiv", "pre_code", "prev_div", "prev_que", "prevliccode", "prevliccodes", "prev_pair"], "curr_code": ["curre_code", "currs_count", "curre_cod", "curr_cod", "curr_count", "currs_id", "currs_code", "curre_codes", "curr_id", "currs_codes", "curr2count", "curr2id", "curr_codes", "curr2codes", "curr2code"], "i": ["bi", "ui", "index", "pi", "k", "ie", "j", "di", "e", "d", "si", "fi", "p", "slice", "ski", "h", "mi", "phi", "image", "qi", "ii", "ki", "u", "ind", "id", "n", "l", "ni", "ip", "ami", "s", "m", "c", "ix", "oi", "f", "inn", "io", "ri", "ini", "gi", "xi", "uri", "ci", "eni", "b", "in", "iu", "ani", "I", "ai", "v", "x", "li"], "nsample": ["namesamples", "nasample", "nassample", "namespler", " nsamp", "enssample", "nossample", "jsample", "nsape", "csanne", "antispling", "csamp", "bspling", "NSample", " nspring", "noscale", "unsolve", " nsape", "inssample", "nscale", "namespace", "npling", "tsamples", "naspring", "insample", "nsume", "outsammy", "ksample", "netsample", " nspling", "namesample", "netssample", "nasdim", "nsame", "bssample", "enscale", "nspler", "nasolve", "nsamples", "lssample", "nspec", "minssample", "nspring", "xsolve", "xsamp", "conspling", "NSsample", "onspec", "netspling", "nsamp", "nospling", " nspec", " nssample", "nasplay", "tssample", " nsame", "NSanne", "nosamples", "linsample", "psame", "csample", "tsample", "ssamples", "ksamples", "xssample", "nsammy", "psume", "NSamples", "kssample", "NSpling", "psample", "consamp", "naspace", "xsample", "ssample", "nosample", "netsply", "xslace", " nspler", "bsample", "ainssample", "nosamp", "insamp", "outsample", "linsamples", "antissample", "jspling", "namescale", "unsamp", "sspling", "antisample", "minsamples", "nample", "xsamples", "antispace", "xsply", "nslace", "anspler", "csamples", "ansanne", "jsammy", "ainsample", "nsply", "naspling", "nsdim", "nsplay", "NSape", "ansape", "nasape", "bsamples", "noslace", "unsample", "nspace", "namessample", "cssample", "minsample", "nspling", "anssample", "anspling", "sssample", "namesamp", "lsplay", "namesply", "inspling", "netsdim", "naspec", "onspling", "cspling", "enspring", "outspling", "nasammy", "nascale", "tspling", "lsamp", "consample", "nssample", "nsolve", "nasamp", "pssample", "nasamples", "unssample", " nsdim", "linssample", "minspling", "namespling", "naspler", "linspring", "namesume", "namesame", " nsume", "xspling", "ensample", "ansample", "kspring", "outssample", "lsample", "netsape", " nsanne", "onsample", "NSamp", "ainsamp", "conssample", "unspring", "onssample", "ainspling", "jssample", "namesplay", "namespec", "npec", "naslace", "unscale", "nsanne", "anspring", "onspler", "nasanne"], "band": ["power", "low", "section", "mm", "back", "slice", "pair", "type", "old", "qi", "off", "device", "f", "art", "range", "front", "bass", "bind", "bands", "count", "unit", "v", "output", "batch", "nn", "frequency", "key", "filter", "channel", "position", "ind", "stage", "mode", "layer", "weight", "Band", "path", "day", "page", "song", "group", "part", "product", "loop", "code", "bound", "direction", "brand", "number", "connection", "style", "use", "line", "plugin", "block", "word", "station", "gap", "pass", "io", "pp", "model", "list", "lf", "length", "board", "cell", "work", "tag", "j", "di", "field", "label", "road", "core", "mb", "function", "bit", "chrom", "net", "version", "cart", "boot", "nb", "force", "point", "phase", "xi", "letter", "port"], "mc1_l": ["mc1__e", "mc1nonlp", "mc1shlp", "mc1_b", "mc1Logp", "mc1nonrl", "mc15_dl", "mc1Logb", "mc1Logol", "mc2_e", "mc1_p", "mc1__l", "mc1Logl", "mc1_ol", "mc1_lp", "mc1nondl", "mc1__r", "mc1__b", "mc1_e", "mc1shrl", "mc15_lp", "mc15_l", "mc1_dl", "mc1_rl", "mc1nonl", "mc2_b", "mc15_rl", "mc2_p", "mc2_ol", "mc1shl", "mc1shdl"], "mc1_r": ["mc12b", "mc1_mr", "mc1_rt", "mc2_ur", "mc1_b", "mc12ur", "mc1__mr", "mc12r", "mcl_mr", "mc1_p", "mc1__l", "mc4_l", "mcl_r", "mc1__p", "mc12rt", "mcl_l", "mc1_ur", "mc2_rt", "mc1__r", "mc4__b", "mc1__b", "mc4__p", "mc4_r", "mc4_p", "mcl_b", "mc4__r", "mc2_b", "mc4__l", "mc4_b"], "mc2_l": ["mc0_s", "mc2__b", "mc0__l", "mcb_l", "mc0_v", "mc2__s", "mcb_nl", "mc2_e", "mc22_l", "mcb_rl", "mc2_s", "mc0_e", "mc0__e", "mc2__r", "mc2_la", "mc2_nl", "mc2__v", "mc2__l", "mc2__e", "mc22_b", "mc2__la", "mc0_l", "mc0__s", "mc0__v", "mc2_rl", "mcb_le", "mc2_le", "mc2_b", "mc2_v", "mc22_la", "mc22_r"], "mc2_r": ["mc2_sr", "mc4_rb", "mc4_v", "mc2_u", "mc2_rs", "mc2_rr", "mc0_u", "mc4_r", "mc0_rs", "mc2_R", "mc2_b", "mc0_r", "mc2_v", "mc4_b", "mc0_sr", "mc2_rb"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_reset(DeviceState *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n\n    uint64_t nb_sectors;\n\n\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    if (nb_sectors) {\n\n        nb_sectors--;\n\n    }\n\n    s->qdev.max_lba = nb_sectors;\n\n    /* reset tray statuses */\n\n    s->tray_locked = 0;\n\n    s->tray_open = 0;\n\n}\n", "idx": 5054, "substitutes": {"dev": ["data", "Dev", "dn", "def", " Dev", "de", "development", "diff", "di", "d", "ve", "dt", "dom", "DEV", "app", "conn", "ev", "ch", "prom", "device", " device", "ds", "block", "dd", "sh", "hw", "req", "err", "der", "info", "ver", "w", "md", "dm", "state", "grad", "priv", "dem", "conf"], "s": ["an", "sq", "e", "d", "si", "sb", "sys", "p", "sync", "ks", "ls", "session", "S", "params", "is", "ps", "ses", "cs", "gs", "sets", "service", "sf", "ds", "n", "l", "ss", "m", "sg", "ts", "sh", "sym", "c", "services", "uns", "fs", "g", "ns", "f", "t", "ssl", "south", "settings", "i", "o", "sl", "its", "sv", "su", "js", "es", "side", "b", "os", "conf", "qs", "rs", "spec"], "nb_sectors": ["nb_nevers", "nb_secgments", "nb_sexgments", "nb_vections", "nb_serivers", "nb_syctors", "nb_apections", "nb_severs", "nb_secs", "nb_syqs", "nb_sexctors", "nb_gections", "nb_serctors", "nb_vegment", "nb_seors", "nb_seqs", "nb_apegments", "nb_psecs", "nb_secctors", "nb_secivers", "nb_sections", "nb_sesctors", "nb_subsections", "nb_psevers", "nb_secapters", "nb_veqs", "nb_subctors", "nb_secers", "nb_syors", "nb_secsections", "nb_secctions", "nb_subcers", "nb_subgments", "nb_psections", "nb_sessections", "nb_servers", "nb_secqs", "nb_apectors", "nb_nectors", "nb_pegments", "nb_psectors", "nb_seapters", "nb_sescers", "nb_gegment", "nb_segments", "nb_pseapters", "nb_sesections", "nb_veors", "nb_gegments", "nb_negments", "nb_gectors", "nb_secors", "nb_sergments", "nb_sexvers", "nb_necs", "nb_vegments", "nb_apegment", "nb_seccers", "nb_psegments", "nb_pectors", "nb_sygments", "nb_pevers", "nb_geapters", "nb_sesgments", "nb_segment", "nb_pecs", "nb_vectors", "nb_secvers", "nb_seivers", "nb_sexivers"]}}
{"project": "FFmpeg", "commit_id": "eedd9148733ff4467c62092ad1c1a26d6125b249", "target": 1, "func": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n\n                               int *len, int *strid, int read_packet) {\n\n    AVIOContext *pb = s->pb;\n\n    PVAContext *pvactx = s->priv_data;\n\n    int syncword, streamid, reserved, flags, length, pts_flag;\n\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n\n    int ret;\n\n\n\nrecover:\n\n    startpos = avio_tell(pb);\n\n\n\n    syncword = avio_rb16(pb);\n\n    streamid = avio_r8(pb);\n\n    avio_r8(pb);               /* counter not used */\n\n    reserved = avio_r8(pb);\n\n    flags    = avio_r8(pb);\n\n    length   = avio_rb16(pb);\n\n\n\n    pts_flag = flags & 0x10;\n\n\n\n    if (syncword != PVA_MAGIC) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (reserved != 0x55) {\n\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n\n    }\n\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n\n        pva_pts = avio_rb32(pb);\n\n        length -= 4;\n\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n\n        /* PVA Audio Packets either start with a signaled PES packet or\n\n         * are a continuation of the previous PES packet. New PES packets\n\n         * always start at the beginning of a PVA Packet, never somewhere in\n\n         * the middle. */\n\n        if (!pvactx->continue_pes) {\n\n            int pes_signal, pes_header_data_length, pes_packet_length,\n\n                pes_flags;\n\n            unsigned char pes_header_data[256];\n\n\n\n            pes_signal             = avio_rb24(pb);\n\n            avio_r8(pb);\n\n            pes_packet_length      = avio_rb16(pb);\n\n            pes_flags              = avio_rb16(pb);\n\n            pes_header_data_length = avio_r8(pb);\n\n\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n\n                                          \"trying to recover\\n\");\n\n                avio_skip(pb, length - 9);\n\n                if (!read_packet)\n\n                    return AVERROR(EIO);\n\n                goto recover;\n\n            }\n\n\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n\n            if (ret != pes_header_data_length)\n\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n\n            length -= 9 + pes_header_data_length;\n\n\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n\n\n            pvactx->continue_pes = pes_packet_length;\n\n\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20)\n\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n\n        }\n\n\n\n        pvactx->continue_pes -= length;\n\n\n\n        if (pvactx->continue_pes < 0) {\n\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n\n            pvactx->continue_pes = 0;\n\n        }\n\n    }\n\n\n\n    if (pva_pts != AV_NOPTS_VALUE)\n\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n\n\n    *pts   = pva_pts;\n\n    *len   = length;\n\n    *strid = streamid;\n\n    return 0;\n\n}\n", "idx": 5060, "substitutes": {"s": ["an", "sci", "storage", "private", "sq", "e", "submit", "sb", "comments", "plugins", "core", "server", "self", "sys", "p", "spec", "ls", "session", "S", "client", "is", "sc", "ses", "support", "login", "cs", "gs", "site", "service", "sf", "ds", "stat", "request", "stats", "ss", "c", "sg", "ts", "services", "sie", "t", "sym", "m", "rs", "sup", "f", "ns", "g", "sa", "sim", "bis", "us", "secure", "ssl", "se", "secondary", "manager", "sv", "su", "b", "es", "js", "single", "http", "conf", "parser", "v", "south", "si"], "pts": ["ptns", "iptsets", "iptl", "iptns", "streams", "ctns", "streamns", "ctl", "ctsets", "streamsets", "streaml", "cts", "ipts", "ptsets", "ptl"], "len": ["Len", "pos", "split", "fn", "pre", "enc", "limit", "val", "bl", "lang", "ll", "buf", "ann", "lon", "lib", "lim", "l", "fin", "rev", "en", "el", "lin", "lf", "gen", "lan", "ln", "lock", "fl"], "strid": ["encids", "strids", "encid", "strID", "encId", "collId", "strId", "collids", "streamID", "collid", "collID", "streamId", "encID", "streamids"], "read_packet": ["read_framume", "read_octete", "read_octume", "read_framete", "read_signet", "read_signacket", "read_packacket", "read_signete", "read_octacket", "read_framet", "read_signume", "read_packete", "read_octet", "read_packume", "read_framacket"], "pb": ["ub", "wb", "uc", "phrase", "pc", "lb", "ref", "gb", "vp", "cp", "db", "bf", "ppa", "pg", "sb", "pl", "plugins", "hub", "tp", "typ", "mb", "p", "bm", "api", "mp", "login", "um", "bb", "pa", "dp", "plugin", "fb", "jp", "plug", "ctx", "bc", "pm", "summary", "platform", "primary", "prop", "cv", "pkg", "eb", "fc", "verb", "phys", "PB", "lp", "tc", "bh", "uf", "bp", "rb", "xb", "b", "cb", "rpm", "bs", "fp", "pd", "cpp", "parser", "prot", "bps", "rob"], "pvactx": ["pvortx", "pvcactx", "pvcactxc", "pvactxt", "pvectx", "pvACTxc", "pvortxc", "pvcortx", "pvACTx", "pvcortxt", "pvactex", "pvACTex", "pvactxc", "pvactc", "pVactx", "pvACTc", "pvartex", "pvACTy", "pvartx", "pvectxt", "pVACTxt", "pvcactc", "pvectxc", "pvarty", "pvartxt", "pvacx", "pvacex", "pVACTy", "pvcactxt", "pvortxt", "pVACTx", "pvectc", "pVacty", "pVactxt", "pVactex", "pVACTex", "pvcortxc", "pvacy", "pvacxt", "pvortc", "pvACTxt", "pvcortc", "pvacty"], "syncword": ["syncWord", "syncwords", "synbyte", "SyncWord", "syncbyte", "Synctag", "Syncbyte", "yncbyte", "syncletter", "readWord", "yncword", " syncwords", "synwords", "Syncletter", " syncletter", "synWord", "Syncword", "yncwords", "yncletter", "readword", "synword", "synctag", " synctag", "ynctag", "readwords", "readbyte", "syntag", " syncbyte", "Syncwords"], "streamid": ["reamid", "contextid", " streamID", "threadname", "modelname", "channelID", "threadID", " streamide", "StreamID", "threadid", "Streamid", "threadide", "contextID", "objectids", "streamids", "streamident", "modelip", "channelId", "modelID", "reamident", "streams", "modelId", " streams", " streamip", "streamID", "channelide", "contextident", "contexts", "streamId", "StreamId", "modelend", "reamID", "streamend", "streamname", "threadId", "reams", "channelid", "channelip", "streamip", "objectId", " streamident", " streamname", "channelend", "poolId", " streamend", "objectid", "modelid", " streamId", " streamids", "poolident", "poolname", "streamide", "threadident", "Streamname", "Streamids", "objectname", "poolid"], "reserved": ["preserv", "preservation", "Reserved", "reserve", "reserving", "Reserves", "preserving", "Reserve", "reserv", "reservation", "Reservation", "presigned", " reserv", " reserving", "Reserving", "unserve", "resigned", "unserved", "reserves", " reserve", "pserve", "rservation", "unserv", "pserves", "rserve", "rsigned", " reserves", "pserved", "Resigned", "unserving", "pserving", "rserved", "preserved", "preserve"], "flags": ["options", "fps", "relations", "levels", "parts", "lines", "mask", "details", "rules", "args", "links", "codes", "utils", "atts", "lists", "alls", "bytes", "stats", "types", "files", "ops", "ids", "lag", "strings", "ags", "fields", "fs", "Flags", "nl", "ants", "vals", "flag", "settings", "filename", "ints", "words", "lf", "bits", "reads", "features", "locks", "status", "errors", "items", "count", "planes", "tags", "ips"], "length": ["library", "options", "depth", "end", "number", "url", "total", "th", "section", "value", "Length", "build", "limit", "always", "key", "zip", "slice", "type", "style", "h", "full", "cost", "offset", "position", "id", "l", "quality", "block", "rows", "sequence", "load", "maximum", "sh", "L", "weight", "buffer", "path", "range", "capacity", "duration", "padding", "other", "mount", "partial", "sl", "ph", "size", "delay", "level", "shape", "time", "count", "ength", "lock", "pull", "angle"], "pts_flag": ["ptn_flags", "pts2count", "pts_field", "ptn_flag", "pts_count", "pts2flag", "ptn_field", "pts_fun", "ptsets_flags", "pts2len", "ptsets_log", "ptsets_len", "ptsets_count", "ptsets_fun", "pts_len", "ptsets_flag", "pts_flags", "ptn_count", "pts_log"], "startpos": [" startposition", "Startval", "stoppos", "endval", "endpos", "startPos", "startval", " startloc", "stopPos", " startval", "stopval", " startPos", "Startposition", "endloc", "Startpos", "startloc", "stoploc", "endPos", "startposition", "StartPos", "endposition"], "ret": ["batch", "re", "rc", "sec", "reset", "def", "result", "rep", "success", "alt", "back", "val", " RET", "seq", "RET", "resp", "reg", "res", "rs", "scan", "flag", "nt", "valid", "rel", "rets", "Ret"], "pes_signal": ["pes_Signaling", "pes_SIGNaler", "pes_ignal", "pes_signature", "pes_codaler", "pes_ignaler", "pes_Signal", "pes_Signature", "pes_signaling", "pes_seals", "pes_seon", "pes_ignaling", "pes_codal", "pes_ignals", "pes_codon", "pes_seal", "pes_signon", "pes_SIGNaling", "pes_Signaler", "pes_sealer", "pes_signaler", "pes_SIGNature", "pes_signals", "pes_SIGNal", "pes_ignature", "pes_ignon", "pes_codals"], "pes_header_data_length": ["pes_header_data_type", "pes_header_data_len", "pes_header_header_width", "pes_header_header_length", "pes_header_header_type", "pes_header_header_len", "pes_header_data_width"], "pes_packet_length": ["pes_packet_sequence", "pes_packet__width", "pes_packacket_len", "pes_packet_len", "pes_packet__sequence", "pes_packacket_sequence", "pes_packet__len", "pes_packacket_length", "pes_packacket_\n", "pes_packacket_1", "pes_packet__length", "pes_packacket_width", "pes_packet_\n", "pes_packet_1", "pes_packet_width"], "pes_flags": ["pes_flag", "pes___flags", "pes___data", "pe_flags", "pe_data", "pes___flag", "pes_data", "pes___comments", "pe_flag", "pe_comments", "pes_comments"], "pes_header_data": ["pes_headers_data", "pes_header__size", "pes_header_size", "pes_header__message", "pes_headers_size", "pes_header_message", "pes_header__data", "pes_headers_message"]}}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n", "idx": 5071, "substitutes": {"src": ["data", "sci", "low", "uc", "rc", "stack", "conv", "sec", "gb", "dist", "url", "seed", "loc", "input", "sb", "sync", "slice", "gz", "buf", "sc", "img", "config", "dest", "stars", "chrom", "sr", "cur", "sup", "shift", "source", "start", "inst", "req", "ssl", "scl", "sl", "iv", "size", "front", "uri", "sub", "rb", "rect", "attr", "b", "length", "cb", "ptr", "stream", "comp", "sel", "spec", "rob"], "stride": ["strade", " strside", "STRide", "striden", "stiden", "charice", "Strade", "Stride", "Striden", "slade", "hride", "charine", "STRided", "sliden", "charided", "strside", "charider", "Strice", "Strine", "hrider", "shride", "STRride", "slided", "stided", "charride", "strine", "shrice", "hrside", "STRside", "slide", "strided", "strider", "shrine", "shrided", "Strided", "hrided", " strided", " strider", "stide", "charide", "Strride", "strice", "stade", "strride", "STRider", "Strider"], "i": ["ui", "bi", "pi", "index", "k", "ie", "j", "di", "e", "d", "si", "mini", "multi", "fi", "ti", "p", "api", "h", "mi", "phi", "qi", "ii", "r", "hi", "u", "ji", "id", "chi", "l", "ni", "ip", "m", "init", "ix", "oi", "f", "strength", "zi", "io", "start", "ri", "ini", "info", "gi", "it", "xi", "mu", "uri", "ci", "eni", "b", "iu", "I", "ai", "v", "x", "li"], "dc0": ["DCx", "DC19", "DC8", "mc5", "c1", "fc8", "dcx", "ac2", "nc2", "rc5", "dc50", "cx", "mc8", "dc1", "c0", "fc0", "DC1", "dc5", " dcx", "dcarg", "mc50", "dc00", "rc0", "fc5", "mc0", "fc00", "lc8", " dcarg", "DC5", "carg", "lc0", "fc19", "rc8", "lc5", "fc2", "nc19", "dc8", "dc2", "DCarg", "DC00", "DC2", "nc00", "rc00", "c2", " dc1", " dc2", "rc2", "fc50", "dc19", "nc0", "ac0", "ac00", "lc50", "DC0"]}}
{"project": "qemu", "commit_id": "955cc8c9541779e09895a9c5ccbf8ace15d884f5", "target": 0, "func": "static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n", "idx": 5093, "substitutes": {"sch": ["kh", "wic", "shop", "gb", "ich", "sche", "cho", "gor", "sb", "Sch", "rh", "ocr", "sc", "soc", "cm", "shr", "ch", "cor", "service", "sp", "ss", "sh", "cr", "chn", "or", "cht", "osc", "conf", "gh", "se", "cer", "sl", "dev", "inch", "sw", "chid", "sk", "sd", "cp", "spec"], "addr": ["data", "pos", "oa", "ref", "url", "lace", "loc", "name", "alt", "ast", "len", "arr", "adr", "afi", "adder", "arm", "amd", "pad", "aid", "ace", "offset", "bridge", "ack", "config", "aff", "id", "dim", "ip", "tx", "ix", "address", "host", "art", "alpha", "act", "array", "hop", "padding", "mac", "nr", "coord", "ad", "ar", "prefix", "size", "amp", "rt", "route", "ag", "ac", "node", "alias", "grad", "ptr", "x", "balance"], "align": ["ign", "ange", "ref", "lace", "loc", "label", "adjust", "len", "val", "arr", "afi", "offset", "balance", "config", "aff", "rot", "lag", "gal", "aligned", "lead", "address", "ax", "range", "array", "el", "rol", "cache", "coord", "ad", "al", "length", "alias", "role", "cmp", "rel", "pal", "angle"], "index": ["pos", "end", "number", "diff", "loc", "input", "value", "show", "example", "len", "val", "xxxx", "none", "slice", "order", "inc", "offset", "image", "position", "config", "Index", "xxx", "off", "ind", "id", "dim", "ion", "version", "ix", "address", "weight", "pointer", "action", "host", "array", "sort", "start", "hop", "path", "ini", "axis", "i", "coord", "cache", "info", "prefix", "gate", "loop", "match", "size", "level", "route", "in", "length", "fix", "find", "active", "work", "update", "x"], "num": ["nam", "nm", "sum", "nn", "ref", "end", "number", "loc", "alt", "len", "no", "offset", "inc", "um", "uni", "config", "position", "out", "off", "nom", "id", "n", "ni", "dim", "net", "init", "nb", "inn", "max", "min", "bin", "coord", "prefix", "NUM", "valid", "node", "Num", "mon", "unit", "update"], "vdev": ["vvdev", "vde", "lDev", "ivconf", " vdb", "vfam", "vverror", "ivdef", "vmrad", "ldev", "ivdb", "svdb", "evdef", "vconf", "vtDev", "svdev", " verror", "nvdata", " vinfo", "livedev", "verror", "rvar", "ivdev", "vdie", "vmdist", "vtdev", "vdef", "vDev", "nvrad", "livedem", " vrad", "rconn", "vcrad", "vconn", "vmdev", " vconf", "vtdiv", "evfam", "vvserv", "svvar", "nvdem", " vdiv", "ivdem", "vdist", "svde", "vserv", "vcinfo", " vdem", "vcdev", "nvdev", "vvar", " vvar", " vfam", "ivdie", "livedes", "nverror", "liverad", " vde", "svdie", "nvdes", "vminfo", "ivfam", "vcdist", "vdb", "evconf", " vdist", "svconn", " vdata", "vdes", "vdem", " vserv", "nvserv", " vconn", "vtvar", " vDev", " vdes", "vdiv", " vdie", "rdev", "evdev", "vvdata", "rde", "svdem", " vdef", "vrad", "vdata", "vinfo", "lvar"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n", "idx": 5099, "substitutes": {"opaque": ["operoster", "oppque", "composter", "oppaque", "compaque", "oppec", "opace", "popacity", "compace", "compacity", "openec", "opacity", "opity", "catity", "cataque", "popace", "openaque", "operace", "poposter", "operaque", "catque", "oppity", "operacity", "popaque", "oposter", "opque", "openque", "openity", "catec", "opec"], "buf": ["batch", "data", "pool", "pb", "msg", "rc", "bag", "queue", "loc", "Buffer", "src", "seq", "img", "vec", "cmd", "buff", "fd", "cur", "bc", "buffer", "cv", "alloc", "cap", "uf", "rb", "b", "length", "null", "cb", "ptr", "fp", "v", "window", "port"], "size": ["data", "rc", "sec", "small", "scale", "name", "enc", "len", "type", "esc", "offset", "SIZE", "empty", "large", "block", "ize", "c", "sized", "Size", "address", "g", "capacity", "en", "fee", "code", "z", "shape", "length", "null", "timeout", "time", "six", "send", "unit"]}}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n", "idx": 5102, "substitutes": {"fs_ctx": ["fsdbcrit", "fsdbconn", "fs_la", "fs_git", "ts_git", "fsprecn", "ws_cu", "FS_cb", "FS_cl", "fsjctx", "fsdbcu", "fs32gc", "FS_sem", "ts_gc", "fsdbctx", "fs_gc", "cs_ca", "FS_cn", "ts_tx", "fs__ctx", "fs_tx", "fsprectx", "FS_wcs", "fs_scope", "fs__context", "fs__cas", "fsalctx", "fsjcontext", "fs_crit", "fsalcb", "fsptx", "fs_cl", "fs_wcs", "FS_tx", "cs_ctx", "fs_sem", "FS_scope", "fs_cor", "fs32tx", "ws_crit", "fspcb", "fsjcas", "fs_ca", "fsprecontext", "fsjcl", "fs32git", "cs_cor", "fs_context", "FS_ctx", "ts_ctx", "cs_conn", "FS_context", "fs_cas", "fsalcontext", "fs_cn", "FS_la", "fsaltx", "fsprewcs", "ws_ctx", "fspcontext", "fs_cb", "fs__cl", "fs32ctx", "fsalgit", "fs_conn", "fs_cu", "ws_conn", "fsalgc", "FS_cas", "fspctx"], "fs_path": ["fsmlcrit", "fc_object", "fs_object", "f_source", "fsscontext", "fsmlsource", "fc_context", "fsspath", "fs_crit", "fc_config", "fs___source", "fssobject", "f_crit", "f_path", "fs___crit", "fc_path", "fs___path", "fs___context", "fs_source", "fsmlpath", "fs_context", "fs_config", "fsmlcontext", "f_context", "fssconfig"], "credp": ["acredpi", "credl", "crafc", "ancreamp", "encdefc", "carppa", "scribh", "carpp", "ancreamP", "critp", "cachedP", "creampa", "chedpi", "cprivP", "credpa", "cdefP", "encredc", "scribpa", "acredP", "creditsc", "scredp", "scredpa", "crcpre", "chedc", "crcpt", "acrdc", "carph", "credpart", "cronp", "crafP", " creditspa", "creaml", " cribpt", " credpi", "critpre", "cribpc", "ancreaml", "credpi", "ancredpc", "credpc", "cedp", "creamc", "creampi", "cribP", "encdefP", "crcv", "encredpart", "cribv", "ancredP", "acrdp", "cribc", "cribpre", "crafpart", "cribpa", "acredc", " cprivp", "encredP", "encredp", "credc", " credc", "ancreampc", "caredl", "cprivpi", "cedP", " cribv", " creditspi", "cdefp", "carpc", " credv", " credpc", " credpt", "crdp", "caredP", "scribc", "encdefpart", "creampc", "ancredl", "cronpa", "scredh", " cribpre", "cachedc", "cronh", "scredc", "creamP", "caredp", "scribp", "cachedpart", "credP", "cdefpart", "creditsp", "chedpa", "crdP", "creditspi", "cprivp", " credpre", "credh", "credv", " credpa", "cprivc", " cprivpc", " cprivP", "cachedp", "crdc", "chedp", "crafp", "cribpi", "credpt", "critv", "crdpi", " creditsp", "encdefp", "cribh", " cprivc", "cronc", " cribp", "credpre", "cedl", "creditspa", "cribpt", "crcp", "acrdP", "caredpc", "creamp", "cedpc", "acredp", "cribp", "cdefc", "ancredp", "critpt", "acrdpi", " creditsc", " credP", "cprivpc"], "buffer": ["batch", "data", "header", "reader", "url", "seed", "loader", "queue", "name", "limit", "Buffer", " buffers", "len", "str", "slave", "byte", "map", "slice", "type", "buf", "flow", "pad", "bytes", "fb", "block", "buff", "abi", "transfer", "f", "source", "array", "padding", "uffer", "writer", "cache", " buf", "info", "reference", "size", "uf", "b", "length", "null", "iter", "cb", "count", "feed", "binary", "base"], "path": ["data", "root", "link", "uc", "object", "dir", "url", "ref", "area", "end", "PATH", "th", "loader", "text", "name", "loc", "enc", "key", "anc", "container", "p", "sync", "rh", "image", "config", "inner", "id", "file", "txt", "pattern", "temp", "child", "content", "home", "entry", "arc", "ith", "host", "pointer", "source", "location", "mount", "part", "parent", "cache", "filename", "prefix", "uri", "Path", "route", "node", "col", "ath", "binary", "transform", "port"]}}
{"project": "qemu", "commit_id": "ff9d38963e55598b40237735426225c35de6c7e5", "target": 0, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *child, *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    child = qdict_get(dst, \"vnc\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    vnc = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(vnc, \"listen\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    listen = qobject_to_qdict(child);\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n", "idx": 5104, "substitutes": {"src": ["uc", "rc", "ruby", "sec", "url", "sq", "ref", "dist", "rss", "loc", "sb", "RC", "nil", "sys", "sync", "slice", "gz", "sc", "support", "img", "r", "dest", "config", "remote", "lower", "lib", "go", "s", "sr", "gl", "ctx", "rec", "sup", "source", "scene", "inst", "sn", "pkg", "req", "secure", "ssl", "sit", "sl", "iv", "filename", "scripts", "uri", "sub", "stream", "gru", "rb", "sound", "https", "desc", "upload", "cb", "href", "http", "rect", "resource", "grad", "sel", "rs", "spec", "rob"], "dst": [" dsc", "cdst", "Ddat", "ddat", " dcr", "Dstr", " dsl", " dsts", "fsl", "cdcr", "dydat", "dysc", "Dsc", " dstr", "dysts", " ddat", "fcr", "cdsc", "fsc", "dstr", "adsc", "dcr", "fsts", "dsl", "dsts", "adst", "fst", "cdsl", "dyst", "Dst", "dsc", "adsts", "adcr", "Dsts"], "rule": ["tag", "root", "re", "reader", "result", "val", "rx", "ul", "record", "r", "rr", "block", "class", "Rule", "run", "comment", "ride", "roll", "rol", "parent", "user", "ule", "route", "attr", "role", "resource", "row"], "vnc": ["Vnt", "vdc", "Vconn", "vnd", " vrn", "fnt", "fnc", "svrn", "svnc", "pnt", "vnt", "vcn", "pnd", " vdc", "Vdc", " vnd", "svcn", "pdc", "qdc", "svnd", "pnc", "vconn", "Vnc", "prn", "qnd", "qconn", "Vcn", "Vnd", "fcn", "qnc", "fdc", "pcn", "vrn", " vcn", " vconn"], "acl": ["fn", "exec", "anc", "ol", "rx", "ul", "arr", "oc", "sc", "ack", "roc", "win", "gram", "asc", "lr", "ram", "ctx", "cr", "il", "acc", "cl", "el", "rol", "cache", "scl", "rar", "ac", "attr", "rl"], "listen": ["nullent", "listens", "Liste", "listener", "intean", " listener", " listens", "featener", "listened", "le", "liste", "ope", "featen", "len", "partened", "oper", "nullen", "open", "parten", "opent", "ler", "Listens", "Listener", "inten", "Listening", "intened", "inteni", "Lister", "Listen", "lent", "Listent", "parteni", "listent", "catening", "listening", "nullened", "lister", "nullening", "Listened", "catent", "featened", "caten", "featens", " listened", "listeni", "listean", "Listeni", "catened", "Listean", "partean"], "child": ["section", "result", "build", "jl", "ack", "inner", "id", "brother", "f", "range", "cel", "sub", "row", "rel", "root", "che", "local", "new", "reader", "anch", "get", "key", "draft", "r", "current", "protected", "rest", "rec", "Child", "cl", "cow", "fr", "ray", "q", "pull", "oy", "rc", "xml", "kid", "value", "slave", "session", "win", "block", "friend", "entry", "children", "comment", "ow", "model", "col", "resource", "cell", "work", "feed", "daughter", "leaf", "end", "core", "boy", "client", "baby", "ch", "remote", "create", "request", "cur", "gh", "parent", "cache", "global", "iv", "node", "ell"], "res": ["root", "re", "rc", "ress", "ref", "reader", "ras", "result", "error", "rss", "pre", "sys", "RS", "arr", "ry", "rh", "ps", "resources", "r", "resp", "cs", "Rs", "ros", "remote", "ch", "reg", "request", "rr", "response", "resh", "resolution", "rest", "rec", "des", "rev", "R", "req", "cache", "err", "rar", "rez", "rus", "gr", "rem", "js", "ris", "RES", "Res", "results", "resource", "os", "rel", "rs", "ret"], "rules": ["reader", "rss", "plugins", "comments", "rx", "blocks", "args", "params", "runs", "resources", "files", "rows", "ops", "lr", "ids", "vals", "Rules", "settings", "names", "scripts", "tests", "groups", "items", "results", "rights", "errors", "rs"]}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 5121, "substitutes": {"data": ["ada", "da", "reader", "DATA", "text", "input", "d", "result", "Data", "self", "p", "api", "done", "base", "test", "empty", "config", "this", "video", "txt", "temp", "m", "buffer", "f", "array", "start", "a", "parent", "writer", "cache", "xxx", "media", "ad", "database", "valid", "iterator", "parser", "format", "dat"], "unused": ["Unchecked", " unusable", "unusable", " Unused", "Unusable", "Unused", " Unuse", " unchecked", " unuse", "unuse", "Unuse", " Unchecked", "unchecked", " Unusable"], "tmp": ["pb", "tv", "vm", "j", "vp", "result", "e", "tp", "p", "nv", "api", "mp", "buf", "kk", "test", "img", "r", "this", "video", "obj", "txt", "var", "temp", "c", "t", "st", "uv", "f", "array", "vt", "copy", "cv", "cu", "verb", "tc", "rb", "b", "vc", "ptr", "cpp", "vv", "output", "base"], "v": ["tv", "vim", "vm", "k", "j", "vd", "vp", "lv", "e", "d", "ve", "vi", "p", "nv", "api", "h", "test", "vs", "ev", "u", "n", "l", "obj", "s", "temp", "m", "c", "t", "uv", "V", "f", "g", "vt", "cv", "i", "w", "o", "iv", "sv", "b", "vv"], "err": ["ref", "error", "e", "er", "str", "fi", "self", "p", "arr", "ler", "rh", "order", "test", "bug", "r", "resp", "ev", "acer", "ind", "n", "rr", "tx", "var", "temp", "c", "t", "cr", "f", "rev", "oe", "Er", "rage", "req", "Error", "erer", "der", "i", "ar", "ver", "fr", "dr", "z", "iter", "aster", "doc", "rs"]}}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}", "idx": 5129, "substitutes": {"bs": ["iss", "pb", "lb", "gb", "ab", "outs", "sb", "bid", "bos", "sync", "blocks", "BS", "ls", "bl", "src", "ps", "lbs", "vs", "ses", "cs", "bb", "ds", "ubs", "fb", "block", "obj", "ss", "bes", "ba", "css", "obs", "bc", "fs", "ns", "sa", "as", "bis", "ec", "bh", "rb", "state", "js", "b", "es", "cb", "ins", "os", "bing", "bas", "base"], "s": ["y", "sec", "sq", "e", "sb", "p", "sync", "spec", "ls", "S", "is", "ps", "ses", "site", "cs", "gs", "service", "ds", "stats", "ss", "c", "sg", "sie", "t", "services", "sym", "ts", "g", "ns", "f", "sa", "bis", "ssl", "i", "sl", "o", "state", "sv", "b", "js", "es", "su", "os", "si"], "ret": ["pat", "data", "ext", "re", "reset", "ref", "end", "fail", "mt", "result", "fun", "success", "alt", "pre", "bf", "att", "get", "len", "val", " Ret", "fat", "af", "mem", "arr", "rf", "std", "true", "plain", "bit", "num", "RET", "ct", "out", "lt", "reg", "et", "res", "ut", "error", "t", "run", "fin", "f", "art", "pass", "rev", "lit", "cat", "en", "flag", "group", "part", "fab", "gt", "det", "err", "ft", "al", "nt", "code", "active", "arg", "format", "rets", "Ret", "rt"]}}
{"project": "FFmpeg", "commit_id": "f7cf12b209c3a1ac2d6b797c585b593a5e9a461d", "target": 1, "func": "static int vc1_init_common(VC1Context *v)\n\n{\n\n    static int done = 0;\n\n    int i = 0;\n\n\n\n    v->hrd_rate = v->hrd_buffer = NULL;\n\n\n\n    /* VLC tables */\n\n    if(!done)\n\n    {\n\n        done = 1;\n\n        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,\n\n                 ff_vc1_bfraction_bits, 1, 1,\n\n                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,\n\n                 ff_vc1_norm2_bits, 1, 1,\n\n                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,\n\n                 ff_vc1_norm6_bits, 1, 1,\n\n                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,\n\n                 ff_vc1_imode_bits, 1, 1,\n\n                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        for (i=0; i<3; i++)\n\n        {\n\n            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,\n\n                     ff_vc1_ttmb_bits[i], 1, 1,\n\n                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,\n\n                     ff_vc1_ttblk_bits[i], 1, 1,\n\n                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,\n\n                     ff_vc1_subblkpat_bits[i], 1, 1,\n\n                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<4; i++)\n\n        {\n\n            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n", "idx": 5138, "substitutes": {"v": ["vl", "tv", "k", "conv", "vd", "vp", "lv", "value", "e", "d", "ve", "nv", "p", "h", "vs", "u", "vid", "n", "l", "s", "c", "m", "t", "uv", "V", "f", "g", "vt", "iv", "w", "sv", "b", "vc", "q", "vv", "x"], "i": ["ui", "bi", "y", "pi", "index", "ie", "ei", "j", "di", "field", "name", "gu", "d", "e", "key", "multi", "fi", "cli", "ti", "p", "li", "yi", "uli", "slice", "ski", "api", "idi", "mi", "num", "phi", "qi", "ii", "ki", "r", "u", "ji", "id", "chi", "ni", "l", "ip", "s", "c", "m", "init", "ix", "oi", "sup", "g", "f", "zi", "io", "ri", "ini", "part", "info", "hei", "it", "gi", "xi", "x", "uri", "o", "ci", "eni", "isi", "b", "iu", "ani", "I", "ai", "si"]}}
{"project": "FFmpeg", "commit_id": "73e8e8dbf969b9a0bc1591abcfeba474a42e47bc", "target": 1, "func": "int av_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, i;\n    AVStream *st;\n    for(;;){\n        AVPacketList *pktl = s->raw_packet_buffer;\n        if (pktl) {\n            *pkt = pktl->pkt;\n            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||\n               !s->streams[pkt->stream_index]->probe_packets ||\n               s->raw_packet_buffer_remaining_size < pkt->size){\n                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;\n                av_freep(&pd->buf);\n                pd->buf_size = 0;\n                s->raw_packet_buffer = pktl->next;\n                s->raw_packet_buffer_remaining_size += pkt->size;\n                av_free(pktl);\n                return 0;\n        av_init_packet(pkt);\n        ret= s->iformat->read_packet(s, pkt);\n        if (ret < 0) {\n            if (!pktl || ret == AVERROR(EAGAIN))\n                return ret;\n            for (i = 0; i < s->nb_streams; i++)\n                s->streams[i]->probe_packets = 0;\n        st= s->streams[pkt->stream_index];\n        switch(st->codec->codec_type){\n        case AVMEDIA_TYPE_VIDEO:\n            if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;\n            break;\n        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||\n                     !st->probe_packets))\n            return ret;\n        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);\n        s->raw_packet_buffer_remaining_size -= pkt->size;\n        if(st->codec->codec_id == CODEC_ID_PROBE){\n            AVProbeData *pd = &st->probe_data;\n            av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n            --st->probe_packets;\n            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes\n                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n                if(st->codec->codec_id != CODEC_ID_PROBE){\n                    pd->buf_size=0;\n                    av_freep(&pd->buf);\n                    av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);", "idx": 5146, "substitutes": {"s": ["set", "ans", "d", "sync", "site", "vs", "ops", "sg", "services", "fs", "f", "sv", "b", "side", "conf", "v", "styles", "new", "sq", "sb", "plugins", "params", "h", "ses", "cs", "r", "this", "u", "sf", "sp", "ions", "ss", "ts", "t", "ns", "sa", "its", "es", "ins", "hs", "uses", "parts", "comments", "self", "sys", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "xs", "c", "lex", "g", "us", "ssl", "sl", "su", "qs", "rs", "si", "spec", "sci", "aws", "e", "events", "server", "details", "is", "sc", "service", "ds", "l", "states", "sym", "m", "sh", "as", "settings", "se", "o", "js", "os", "ips"], "pkt": ["pet", "tpkt", "felt", "peck", "pelt", "peiece", "Pqt", "facket", "mkt", "apkt", "Pet", "twk", " piece", "spacket", " pct", "Pkl", "tkt", "spet", "pkl", "tpkl", " pwk", "pk", "racket", "Pct", "cpkt", "fct", "pck", " pnt", "spelt", "cpelt", "Pkt", "spkt", "Packet", " pelt", " pk", "Pck", "Piece", "piece", "pnt", "tpacket", "cpet", "tpt", " pqt", " ppt", "peacket", " packet", "apacket", "pct", "cpwk", "tqt", "fet", "Pnt", "apk", "mqt", "rkt", "tpct", " pck", "spqt", "rwk", "Pwk", "spk", "apct", "cpqt", "pwk", " pet", "melt", "ppt", "pewk", "Pelt", "spnt", "cpacket", "packet", "spct", "pqt", "fkt", "fkl", "pekt", "peet", "cppt", "macket", "Pk"], "ret": ["data", "pet", "let", "rc", "re", "sec", "ref", "def", "mt", "result", "rep", "fun", "alt", "success", "back", "att", "error", "len", "val", " RET", " Ret", "str", "xt", "sur", "bad", "bit", "num", "RET", "offset", "r", "reg", "id", "et", "res", "ut", "value", "t", "run", "fin", "cur", "f", "rev", "lit", "en", "flag", "part", "err", "det", "ft", "nt", "code", "reply", "rb", "iter", "arg", "status", "rets", "Ret", "rt"], "i": ["ui", "bi", "y", "pi", "index", "ie", "j", "di", "si", "e", "mini", "multi", "fi", "ti", "p", "li", "yi", "mi", "phi", "qi", "ii", "ki", "hi", "u", "inner", "ind", "id", "chi", "ni", "l", "ip", "n", "m", "init", "ix", "oi", "f", "io", "ri", "ini", "info", "o", "gi", "im", "xi", "it", "ci", "eni", "iu", "iter", "I", "ai", "v"], "st": ["ste", "sth", "stack", "set", "end", "ust", "trans", "ast", "sb", "back", "str", "std", "src", "stop", "ost", "sc", "ct", "tt", "td", "dest", "sp", "est", "stage", "sts", "ut", "St", "ss", "rest", "sh", "step", "tmp", "cr", "t", "ts", "pt", "add", "art", "sa", "nd", "inst", "sn", "sty", "start", "us", "se", "sta", "sl", "ft", "fr", "nt", "sw", "sd", "post", "ist", "ld", "ST", "first"], "pktl": ["pktlp", "plktL", "spacketrl", "cktL", "packetl", "pntl", "pktln", "ipwkn", "pwkn", "petlp", "pwkla", "packetL", "puntsl", "ipwksl", "cpacketlc", "ipktl", "pktL", "packetn", "pktel", "pwkel", "packetla", "pntlc", "cettL", "pwkrl", "cpktla", "cpktler", "pwklp", "pntla", "spktrl", "pkgla", "pttll", "pettL", "pktrl", "puntl", "puntln", "pctrl", "cettel", "pwkln", "petll", "plwkl", "paitL", "packetler", "pkglc", "pkgl", "cktel", "pctla", " packetls", "spktla", "ipwkl", "pktr", "pktla", "pettr", "petel", "spacketl", "paitli", "ipktln", "pctL", "spacketls", "petl", "pntler", "pwkl", "cpktl", "cpktlc", "cktl", "pttls", "cettl", "pntel", "packetr", "pktler", "packetlc", "packetrl", "paitls", "ipktsl", " pktll", "pktlc", "plwklp", "packetli", "pwksl", "packetll", "paitl", "plktl", "petL", "pctls", "plktel", "packetls", "cpacketler", "pctl", "pwkls", "petls", "pttl", " packetll", "pntL", "pctli", "cpacketl", " packetl", "pettl", "pwkL", "plktlp", " packetL", "cpacketla", "pkgler", "packetln", "plwkel", "pktll", "pktli", "packetsl", "pktn", "ipktn", "cettr", "ipwkln", "pktsl", " packetli", "pttL", "spacketla", "pntlp", " pktli", "petr", "pettel", " pktls", "puntn", " pktL", "packetel", "spktl", "cktr", "plwkL", "spktls", "pktls"], "pd": ["data", "pb", "pc", "da", "np", "vd", "od", "vp", "xd", "dra", "di", "ppa", "d", "bf", "dh", "tp", "dt", "p", "df", "std", "pid", "td", "dp", "ds", "pa", "dd", "fd", "gd", "raf", "dc", "hd", "pp", "PD", "dl", "wp", "ad", "lp", "bd", "ud", "cd", "md", "sd", "pard", "po", "ant", "ld", "wd"], "probe_packets": ["probe_hookings", "probe_buffet", "probe_buffets", "probe_states", "probe_statets", "probe___packets", "probe___packums", "probe___hookums", "probe_packessions", "probe___hookings", "probe___packes", "probe_packums", "probe_packings", "probe_buckets", "probe_buffsets", "probe_hookes", "probe_facets", "probe_packsessions", "probe_packssets", "probe_bucket", "probe_statums", "probe_packset", "probe___hookes", "probe_packes", "probe___packings", "probe_statings", "probe_facums", "probe_faces", "probe_facings", "probe___hookets", "probe_bucksets", "probe_packsets", "probe_buffessions", "probe_hookums", "probe_packet", "probe_hookets", "probe_buckessions"]}}
{"project": "qemu", "commit_id": "df8ad9f128c15aa0a0ebc7b24e9a22c9775b67af", "target": 1, "func": "static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n", "idx": 5171, "substitutes": {}}
{"project": "qemu", "commit_id": "b4f72e31b924bec2c18fe0b2a8c6462dbed9dcb2", "target": 1, "func": "static int net_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);\n\n    int rx_copy;\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"tx-ring-ref\",\n\n                             &netdev->tx_ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"rx-ring-ref\",\n\n                             &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n", "idx": 5172, "substitutes": {"xendev": ["crossenderv", "xendow", "xendingir", "crossendingev", "xstartee", "xtendov", "xendef", "lexendtr", "exndow", "tendev", "xendruction", "xendedev", "exndore", "xedgedev", "tendec", "xENDev", "crossendingerv", "xendedov", "xenderv", "exndev", "xendel", "xaddev", "xendere", "xendingov", "xenef", "xendingtr", "xendore", "yendedev", "xendedee", " xendingov", " xstartov", "xadev", " xendingruction", " xstartev", "xenee", "crossendurt", "exenddev", "rxenddev", "xstartow", "xendexp", "exendec", "tendeddev", "xendingev", "xendsef", "rxendedov", "rxendedev", "xendedere", "xendingruction", "yendedel", "yendedir", "xestir", "xendsec", "xendingere", "xtendserv", "xstartev", "xendingow", "xedgeev", "crossendov", "exendir", "xendedtr", "xnddev", "xedgeerv", "xnderv", "exendev", "xtendef", "xentov", "longendingere", "xendsdev", "xendsir", "xentdev", "xendec", "xadov", "xendingee", "yendexp", "xstartdev", "exndov", " xendruction", "yendeddev", "xtendsef", "xendingel", "xENDov", "xendsov", "xestdev", " xendingev", "xndir", "lexendserv", " xenderv", "xndever", " xendee", "xendee", "exnderv", "xndore", "lexendev", "yendederv", "xndee", "yendev", "rxendeddev", "yenddev", "lexenderv", "xendever", "xenddev", "rxendedever", "xendedurt", "xendedir", "xendir", "xendingec", "exenderv", "xenere", "longendingee", " xendingerv", "xenov", "xenrib", "exnddev", "xendeddev", "longendev", "yenderv", "xENDerv", "tendedov", "exndir", "xendsel", "xendtr", "xedgeexp", "xstartov", "xendurt", "xendingef", " xstartdev", "xendedef", "xenruction", "tenddev", "xenturt", "rxendov", "xendederv", "xestec", "xendedel", "yendir", "lexendef", "tendedev", "crossendingov", "xenev", "xendingerv", "xstarterv", "tendedec", "crossendingurt", "xadore", "xendingurt", "rxendev", "lexendstr", "xentever", "xendedec", "xENDrib", "longendere", "xenerv", "xenterv", "lexendsev", " xendov", " xENDrib", "longenderv", "longendingev", "xndov", "xndexp", "xendserv", "xendedexp", "xtendsev", " xstartee", "xndev", "exendow", " xENDev", "yendel", "xndow", " xENDov", "xendedrib", "xendsev", "lexendsef", "exendore", "longendingerv", "xendedruction", "yendedexp", "crossendev", " xendrib", "xtendsov", "xendrib", "longendee", "tendov", "xentev", "xendsore", "xendov", " xenddev", "exndec", "rxendever", "xestev", "exendov", "xtenderv", "xendingdev", "xndec", " xENDerv", "xendstr", "xtendev", "xendedever"], "netdev": ["natengine", "ortdev", "netDev", "webblock", "portdevice", "networkDev", "motprov", "webvalid", "fatev", "netengine", "networkerror", "netdevelopment", "networkdiff", "minrad", "motdev", "potself", " netdevelopment", " netver", "motev", "Netdevice", "networkDEV", "webdebug", " netengine", "fatdev", "actd", "ntrad", "networkengine", "userdev", "meldevice", "networkbreak", "networkapp", "natdevice", "webDev", "enDev", "ntpack", "Netapp", "netrad", "natev", "netblock", "weberror", "motblock", "meldev", "netd", "potev", "netver", "userdiv", "webrad", "portbreak", " netbreak", "webd", " netself", "userDEV", "minev", "ortdevelopment", "actdiv", "webflow", "fatDEV", "bootpub", "Netdev", "fatdiv", "networkd", "natdiv", "motend", "natdevelopment", "netdiv", "bootev", "netbreak", "bootrad", "netpub", "netprov", "ntdevice", "networkdiv", "NETd", "NETver", "bootdev", "networkprov", "netapp", "netev", "nutdiv", "networkflow", "networkblock", "webapp", "webprov", "nutdevelopment", "nutdev", "enerror", "fatd", "webself", "ntdiff", "netend", "networkself", "NETdev", "webdevice", "natconf", " netdiff", "webver", "potdiff", "networkdebug", " netblock", "networkpack", "enprov", " netd", "netpack", "fatdevice", "motdevelopment", "networkver", "netvalid", " netvalid", "mindevelopment", " netdevice", "NETdiv", "ntDEV", "ntdev", "ntev", "bootvalid", "networkdevice", "networkrad", " netdiv", "networkvalid", "fatblock", "netflow", "networkend", "netself", "natdev", "motdiv", "neterror", "end", "ortend", "netdevice", " netflow", "ntdevelopment", "webdiff", "endev", "webdevelopment", "networkpub", " netev", "netDEV", "fatrad", "fatbreak", "tundev", " netapp", "potdev", "nutprov", "actdevice", "portrad", "networkev", "melself", "mindev", "webdev", "actdev", "webev", "portdev", " netpub", "networkdevelopment", "tunrad", "userblock", "ntself", " neterror", "webdiv", "endevice", "netconf", "tunblock", "natblock", "webpack", "ortev", " netDEV", "networkdev", "tundiv", "motconf", "meldebug", "netdebug", "networkconf", "bootdevelopment", "netdiff", " netrad"], "rx_copy": ["rx_slave", "rx_match", "rx_left", " tx_copy", "rxfstore", "rxlogcopy", "rxfcopy", "rx__copy", "tx_cop", "rr_copy", "rx_repeat", "rxfCopy", " tx_slave", "rxlogmatch", "rx__cop", " tx_store", "rx_Copy", "rxfslave", "tx_match", "rx_size", "tx_copy", "rx_cop", " tx_Copy", "rx_store", "rxlogleave", "tx_repeat", "tx_size", "rr_left", "rx__left", "rx_leave", "rr_cop", "tx_leave"]}}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "substitutes": {"env": ["py", "context", "scope", "ext", "eu", "np", "end", "cal", "db", "e", "enc", "exc", "er", "export", "core", "server", "ea", "args", "style", "buf", "esc", "conn", "site", "img", "ev", "config", "viron", "dict", "stage", "obj", "enable", "txt", "ass", "forest", "eng", "init", "estate", "cur", "nw", "opt", "ah", "ec", "en", "req", "settings", "cache", "cv", "err", "esp", "forge", "code", "here", "fg", "age", "conf", "environment", "dat"], "value": ["complete", "data", "new", "index", "end", "number", "target", "set", "scale", "result", "name", "message", "key", "val", "none", "window", "expression", "type", "values", "num", "image", "update", "config", "current", "option", "Value", "VALUE", "version", "address", "enabled", "start", "max", "attribute", "paid", "size", "code", "valid", "null", "timeout", "age", "status", "v", "property", "format", "port"]}}
{"project": "FFmpeg", "commit_id": "9af6abdc17deb95c9b1f1d9242ba49b8b5e0b016", "target": 1, "func": "static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)\n\n{\n\n    int i,j,k,cnt;\n\n    int   components, coding_mode_selector, coding_mode, coded_values_per_component;\n\n    int   sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;\n\n    int   band_flags[4], mantissa[8];\n\n    float  *pCoef;\n\n    float  scalefactor;\n\n    int   component_count = 0;\n\n\n\n    components = get_bits(gb,5);\n\n\n\n    /* no tonal components */\n\n    if (components == 0)\n\n        return 0;\n\n\n\n    coding_mode_selector = get_bits(gb,2);\n\n    if (coding_mode_selector == 2)\n\n\n\n\n    coding_mode = coding_mode_selector & 1;\n\n\n\n    for (i = 0; i < components; i++) {\n\n        for (cnt = 0; cnt <= numBands; cnt++)\n\n            band_flags[cnt] = get_bits1(gb);\n\n\n\n        coded_values_per_component = get_bits(gb,3);\n\n\n\n        quant_step_index = get_bits(gb,3);\n\n        if (quant_step_index <= 1)\n\n\n\n\n        if (coding_mode_selector == 3)\n\n            coding_mode = get_bits1(gb);\n\n\n\n        for (j = 0; j < (numBands + 1) * 4; j++) {\n\n            if (band_flags[j >> 2] == 0)\n\n                continue;\n\n\n\n            coded_components = get_bits(gb,3);\n\n\n\n            for (k=0; k<coded_components; k++) {\n\n                sfIndx = get_bits(gb,6);\n\n\n\n                pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n\n                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n\n                coded_values = coded_values_per_component + 1;\n\n                coded_values = FFMIN(max_coded_values,coded_values);\n\n\n\n                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];\n\n\n\n                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);\n\n\n\n                pComponent[component_count].numCoefs = coded_values;\n\n\n\n                /* inverse quant */\n\n                pCoef = pComponent[component_count].coef;\n\n                for (cnt = 0; cnt < coded_values; cnt++)\n\n                    pCoef[cnt] = mantissa[cnt] * scalefactor;\n\n\n\n                component_count++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return component_count;\n\n}", "idx": 5190, "substitutes": {"gb": ["pc", "bf", "hub", "gam", "s", "gio", "gy", "sg", "bc", "gin", "usb", "gp", "bin", "ga", "xb", "b", "count", "binary", "abb", "db", "vg", "sb", "bb", "cgi", "Gb", "rb", "gm", "storage", "game", "bm", "gc", "gnu", "gs", "hm", "lib", "bo", "gd", "all", "hd", "g", "kb", "eb", "_", "gi", "ge", "gru", "py", "cfg", "wb", "lb", "mb", "rg", "src", "gz", "gg", "bg", "nb", "GB", "gh", "phy"], "pComponent": ["pInstance", " pProcess", "mComp", "pProcess", "PSample", "mProcess", "pComp", "PComponent", "pConnection", "ppComp", " pConnection", "PInstance", "ppComponent", "ppConnection", "pSample", "mComponent", "ppInstance", " pInstance", "PProcess", "cInstance", " pSample", " pComp", "cComp", "cConnection", "mSample", "PComp", "cComponent"], "numBands": ["numMbands", "numbannels", "sumMards", "nbBands", "numMannels", "numPlands", "nbBases", "NumBannels", "numBounds", "NumBands", "NumCbands", "numbands", "sumBards", "nbPlannels", "numChases", "sumMannels", "sumBannels", "numCards", "nbPlases", "numMounds", "numBannels", "NumCounds", "sumMands", "sumMounds", "numCannels", "nbBannels", "numBbands", "NumCannels", "numBases", "sumBounds", "numbounds", "numMands", "numPlases", "numChounds", "numChbands", "nbPlounds", "NumCands", "nbBounds", "sumBands", "NumBbands", "numPlounds", "numCands", "numCbands", "numPlannels", "numChands", "numMards", "numBards", "numbases", "nbPlands", "numCounds", "NumBounds", "numChannels"], "i": ["ui", "bi", "index", "pi", "ie", "di", "d", "multi", "fi", "ti", "p", "is", "mi", "phi", "qi", "ii", "ki", "u", "ji", "n", "ni", "chi", "ip", "l", "m", "c", "ix", "g", "zi", "io", "ri", "ini", "info", "gi", "x", "xi", "uri", "ci", "z", "b", "iu", "I", "ai", "v", "si", "li"], "j": ["pos", "br", "note", "y", "ie", "aj", "e", "d", "key", "jc", "p", "bj", "h", "jit", "jl", "ij", "offset", "ii", "ch", "u", "off", "ji", "dj", "je", "n", "l", "jp", "ijk", "obj", "jo", "m", "c", "dy", "g", "f", "ja", "jet", "kj", "uj", "el", "jen", "json", "o", "it", "x", "fr", "job", "z", "js", "b", "length", "adj", "q", "oj", "v", "J", "jj", "li"], "k": ["kh", "y", "kid", "e", "d", "ik", "key", "p", "ks", "kw", "ko", "h", "K", "kick", "kk", "ku", "ki", "r", "ch", "u", "ka", "n", "ck", "m", "c", "ek", "g", "f", "kj", "kat", "mk", "dk", "o", "w", "ky", "kn", "uk", "km", "kr", "it", "z", "sk", "b", "ok", "q", "ke", "work", "v", "x"], "cnt": ["ncny", "Cpt", " cpt", "fov", "cant", " count", "scnt", "pant", "fnt", " cct", "scov", "acant", "scount", "pnt", "cny", "ncant", "Cct", "acNT", "fct", " cnc", "pst", "pnc", "Cant", "Cnt", "CNT", " cNT", "ncNT", "acct", "cpt", "cnc", " cant", "cNT", "ncnt", "acst", "cst", "scct", "acnc", "fount", "cct", " cny", " cst", "acnt", "Cnc", " cov", "acpt", "count", "Cny", "cov"], "components": ["instances", " compances", "scands", "cands", "cances", "commlements", "ompances", "chones", "sconents", "Components", "instonents", "scones", "comones", "commonents", "codes", "commances", " compuments", "commants", "comands", "compodes", "compuments", "scances", "chonents", "chances", "commodes", "complements", "compones", "ompuments", "commones", "compances", "chodes", "compands", "Compuments", "compants", "conents", "instlements", "instants", "Compants", "comonents", "omponents", "Compances", "cones", "comances", "Complements"], "coding_mode_selector": ["coding_mode_lectore", "coding_mode_selectors", "coding_mode_SelectOR", "coding_mode_Selectors", "coding_mode_lectively", "coding_mode_electors", "coding_mode_Selectoring", "coding_mode_reflectOR", "coding_mode_selectOR", "coding_mode_Selector", "coding_mode_elective", "coding_mode_electore", "coding_mode_connectoring", "coding_mode_electoring", "coding_mode_connector", "coding_mode_lectOR", "coding_mode_connectors", "coding_mode_reflective", "coding_mode_connectively", "coding_mode_reflectively", "coding_mode_selectively", "coding_mode_reflector", "coding_mode_Selectore", "coding_mode_lective", "coding_mode_selectoring", "coding_mode_electOR", "coding_mode_lectors", "coding_mode_lector", "coding_mode_reflectore", "coding_mode_selective", "coding_mode_reflectoring", "coding_mode_reflectors", "coding_mode_Selective", "coding_mode_lectoring", "coding_mode_elector", "coding_mode_connective", "coding_mode_selectore"], "coding_mode": ["coding_distance", "casing_MODE", "coding__mode", "coding__MODE", "caling__mode", "casing_type", "caling__size", "caling_phase", "caling_MODE", "coding__phase", "coding_MODE", "caling__phase", "caling__MODE", "casing_range", "caling_mode", "casing_lane", "casing_distance", "caling_size", "coding_range", "coding_phase", "casing_mode", "coding_size", "coding_lane", "coding__size", "coding_type"], "coded_values_per_component": ["coded_values_PER_section", "coded_values_perjcomp", "coded_values_per_sample", "coded_values_PER_comp", "coded_values_per_comp", "coded_values_perjsample", "coded_values_per_pixel", "coded_values_PER_pixel", "coded_values_PER_component", "coded_values_perjcomponent", "coded_values_perjsection", "coded_values_per_section", "coded_values_PER_sample"], "sfIndx": ["ephIndxs", "sfindxs", "SFIndx", "fIndx", "findX", "sfIndexn", "sfImplx", "sfLenxs", "sfImplex", "sfIndexxs", "sfindex", "findx", "sfIndex", "sfIDn", "ephIndindex", "SFPtrx", "SFIndX", "sfIndX", "sfPtrex", "ephInx", "sfInn", "sfIndexindex", "findi", "sfPtrX", "sfLenX", "SFIndxs", "sfInitex", "sfImplX", "sfIniti", "sfIndi", "ephInxs", "sfInitX", "ephInn", "SFIndex", "SFPtrxs", "sfIDx", "sfIndn", "sfindX", "sfImpli", "ephIndn", "sfInx", "fIndex", "fIndi", "sfIndexx", "SFPtrX", "findex", "ephIndx", "sfLenex", "sfIDxs", "sfIndxs", "sfPtrx", "SFPtrex", "sfInxs", "fIndX", "sfInitx", "sfindi", "sfIDindex", "sfInindex", "ephInindex", "sfIndindex", "sfindx", "sfPtrxs", "sfLenx"], "coded_values": ["fed_value", "added___vals", "codedsValues", "fed_stores", " coded_Values", "codedsvals", "coded___vals", "added___members", "coded_settings", "ordered_value", "coded___members", "coded_Values", "added_vals", "coded67vals", "fed_values", "ordered_jobs", "ordered_values", "coded_value", "coded_members", "coded67members", " coded_vals", "added_values", "added_members", "coded67settings", "added___settings", "added_settings", "coded_stores", "codedsvalues", "coded___values", "coded___settings", "coded67values", "added___values", "coded_jobs", "coded_vals"], "max_coded_values": ["max_coded_frames", "max_coded_results", "max_coded00values", "max_coded\u00b7versions", "max_oded_versions", "max_coded00frames", "max_oded_Values", "max_coded\u00b7images", "max_coded_images", "max_oded_errors", "max_coded2results", "max_coded__versions", "max_coded_errors", "max_coded00errors", "max_oded_values", "max_coded__images", "max_oded_results", "max_coded\u00b7results", "max_oded_images", "max_coded2Values", "max_coded_versions", "max_coded_Values", "max_coded__values", "max_oded_frames", "max_coded\u00b7values", "max_coded2values", "max_coded\u00b7Values"], "quant_step_index": ["quant_step_count", "quant_step___count", "quant_group_ind", "quant_data_position", "quant_group_count", "quant_step_diff", "quant_scale_ind", "quant_data_ind", "quant_scale_index", "quant_scale_point", "quant_step___index", "quant_step_label", "quant_group_diff", "quant_group_label", "quant_group_sign", "quant_group_index", "quant_step0level", "quant_step_position", "quant_step0point", "quant_stepinglabel", "quant_data_column", "quant_step_column", "quant_step___sign", "quant_step_ind", "quant_stepingindex", "quant_step0index", "quant_step_level", "quant_data_index", "quant_step___diff", "quant_stepingind", "quant_group_point", "quant_scale_level", "quant_step_point", "quant_step0ind", "quant_step_sign", "quant_stepingpoint"], "coded_components": ["coded_communitions", "coded_quantitions", "coded_compuments", "coded_componentonents", "coded_quantonents", "coded_commounds", "coded_componentands", "coded_componentounds", "coded_cuments", "coded_quantounds", "coded_quounds", "coded_commonents", "coded_conents", "coded_counds", "coded_quonents", "coded_commuments", "coded_compitions", "coded_communounds", "coded_communonents", "coded_commands", "coded_compands", "coded_componentitions", "coded_compounds", "coded_quands", "coded_componentuments"], "band_flags": ["band_bits", "bandWsettings", "bands_flags", "bit_features", "band_features", "bit_flag", "bands_flag", "band___codes", "band___planes", "band__codes", "band__planes", "band2flags", "band2count", "band_codes", "bands_codes", "band2flag", "bands_planes", "bit_flags", "band_planes", "bandWflags", "band_settings", "bit_bits", "band2bits", "band__flags", "bandWfeatures", "bandWflag", "bit_settings", "band___flags", "band_count", "bit_count", "band___flag", "band__flag", "band_flag"], "mantissa": ["Mantica", "mktissa", "magnica", "Mantilla", "mentissa", "Mentilla", "mantilla", "magnile", "mktica", "mktilla", "mantile", "Mantissa", "mentica", "mktile", "magnissa", "mentile", "Mantile", "Mentissa", "mantica", "mentilla", "Mentile", "magnilla", "Mentica"], "pCoef": ["Pcoef", "pFlff", "Pcoaf", "Pcoff", "PCoff", "pcoef", "pcoaf", "Pcoffe", "pcoffe", "pReffe", "PCoef", "pCoaf", "pCoffe", "pFlffe", "pReef", "PCoffe", "pReaf", "pFlef", "pcoff", "pReff", "PCoaf", "pCoff", "pFlaf"], "scalefactor": ["scallefact", "scalepractor", "scalefrator", "scalescector", "scalescactor", "scalephector", "scalephractor", "scalefact", "scallefector", "scalescact", "scaldefractor", "scallefactor", "scalefector", "scalesefact", "scaldefactor", "scallefractor", "scalesefrator", "scalescractor", "scallescact", "scallescector", "scalefractor", "scaleseprator", "scallescractor", "scalephactor", "scalepact", "scalecactor", "scalesepactor", "scalecact", "scaldefector", "scaleprator", "scalesepact", "scalesefractor", "scalecractor", "scalephact", "scalesefactor", "scallescactor", "scaldefact", "scalesepractor", "scalecrator", "scalepactor", "scalescrator"], "component_count": ["component_size", "componentIDcount", "threadCountorder", "component_order", "component_length", "threadCountsum", "component2coll", "threadCountsize", "sample_length", "thread_count", "thread_sum", "component24count", "componentIDsum", "componentCountorder", "component_coll", "componentCountsize", " component_length", "sample_count", "componentCountcount", "threadCountcount", "component24coll", "component2count", "componentCountsum", "componentIDsize", " component_size", "thread_order", "sample2length", "sample2coll", "component2length", "component_sum", "thread_size", "sample_coll", "component24length", "componentIDorder", "sample2count"]}}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 5191, "substitutes": {"keybuf": ["rowseq", "bytebuffer", "keyqueue", "bytebuff", "charcb", " keybuff", " keycb", "rowcb", "rowuf", "keyuf", " keyuf", "keybuff", "valuebuffer", "valuebuf", "valueuf", "rowbuff", "keycb", "charbuf", "charbuffer", "kbuff", "kbuffer", "parentbuf", "kblock", "parentbuff", "valuequeue", " keybuffer", "charbase", "rowqueue", "kcb", " keyseq", "parentuf", "bytebuf", " keyblock", "rowbuf", "keybuffer", "kqueue", "keyblock", "charseq", "keybase", "parentbuffer", "charbuff", " keybase", "valueblock", "keyseq", "kbuf", "valuebuff", "kuf", "charqueue", "rowbuffer", "kbase", "bytecb", " keyqueue"], "q": ["y", "k", "sq", "j", "queue", "e", "d", "text", "key", "que", "sync", "iq", "dq", "h", "qs", "qi", "r", "ch", "query", "u", "patch", "P", "id", "l", "qu", "c", "sh", "t", "cur", "g", "f", "force", "check", "comment", "qa", "Q", "req", "w", "qq", "code", "pe", "z", "b", "qt", "v", "x"], "keycodes": [" keymaps", "macodes", "Keylines", "charlines", "Keypath", "keycoded", "lockcodes", "switchcards", " keycoded", "switchcodes", "kcode", "Keycodes", "keyodes", " keycards", "changecodes", "kcodes", "changeodes", "switchbuf", "keycards", "changecode", "Keycode", "changecoded", "maccoded", "maccodes", " keypath", " keylines", "charcodes", "keypath", "Keycards", "Keybuf", "kcoded", "switchcode", "maccode", "lockcode", "keylines", "charpath", "kmaps", "lockmaps", "lockcoded", "keymaps", "charcode", " keyodes"], "p": ["py", "pat", "pos", "y", "pi", "pc", "np", "k", "j", "php", "pre", "param", "e", "d", "pg", "pl", "tp", "op", "api", "pair", "h", "ps", "type", "pid", "pr", "r", "patch", "pa", "u", "sp", "at", "P", "n", "l", "ip", "jp", "ap", "s", "c", "m", "t", "g", "f", "pointer", "pp", "point", "qa", "a", "part", "cache", "o", "prefix", "lp", "python", "code", "pe", "b", "po", "fp", "cp", "v", "x"], "nb_keycodes": ["nb_callcodes", "nb_maccodes", "nb_calllines", "nb_keychecks", "nb_linkcodes", "nb_linklines", "nb_datecards", "nb_linkcats", "nb_keyxes", "nb_datecodes", "nb_callcards", "nb_myses", "nb_Keyxes", "nb_charses", "nb_myxes", "nb_switchlines", "nb_Keycodes", "nb_keycod", "nb_changelines", "nb_Keylines", "nb_Keychecks", "nb_charxes", "nb_changechecks", "nb_switchcod", "nb_keycards", "nb_Keymaps", "nb_charcodes", "nb_mycodes", "nb_callmaps", "nb_switchcodes", "nb_changecodes", "nb_keylines", "nb_callchecks", "nb_keycode", "nb_callcats", "nb_keyodes", "nb_macodes", "nb_maccode", "nb_keymaps", "nb_callcode", "nb_callodes", "nb_datecats", "nb_linkcards", "nb_callcod", "nb_keyses", "nb_datelines", "nb_keycats", "nb_changemaps", "nb_Keyses"], "keycode": ["checkode", "keyc", " keyode", "rowcodes", "calldesc", "ryode", "vercode", "checkdef", "valuecod", "Keycode", "levelcode", "typecodes", "xcoded", "ycodes", "keypath", "xcode", "vercoded", "lockc", "valuecode", "levelcycle", "callcodes", "checkcode", "pointcod", " keycod", "wordc", "keycoded", "lockcodes", "callcode", "keycomment", "skycode", "Keyfore", "opcode", " keyc", "pointode", "transferfore", "pointmessage", "typedesc", "checkc", "lockdef", "skycomment", "keydef", "Keycod", "levelfore", "verc", " keydesc", "skyc", "lockCode", "callcod", "opcod", "typecode", "levelcod", "xc", "rowcod", "typecod", "transfercycle", "Keycycle", "checkcod", " keycomment", " keypath", "ycoded", "keyode", "wordcomment", "rycoded", " keydef", "wordcode", " keyCode", "wordpath", "opcodes", "keyCode", "rowCode", "ycode", "valueode", "pointcode", "keycycle", "keydesc", "checkmessage", "rycode", "keycod", "transfercode", " keycoded", "skypath", "rowcode", "rycod", "ycod", "vercod", "opc", "keymessage", "transfercod", "keyfore", "valuecoded", "Keyode", "xcod", "rowcoded", "lockcode", "Keymessage", "lockcoded", "lockcod"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "j", "one", "di", "e", "multi", "fi", "cli", "ti", "yi", "api", "slice", "mi", "phi", "qi", "ii", "hi", "u", "inner", "ji", "id", "n", "ni", "l", "ip", "chi", "s", "abi", "m", "c", "init", "ix", "g", "f", "oi", "zi", "io", "start", "ri", "a", "ini", "info", "o", "gi", "mu", "xi", "uri", "x", "ci", "eni", "b", "iu", "I", "ai", "v", "si", "li"]}}
{"project": "qemu", "commit_id": "5d39c799c3245244ebb1e89da0177dbc089962b2", "target": 0, "func": "void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n", "idx": 5198, "substitutes": {"mon": ["mos", "mo", "am", "mat", "mem", "monitor", "bm", "mut", "mi", "tun", "reg", "mn", "man", "m", "mr", "pm", "mot", "Monitor", "prof", "mod", "my", "mu", "emon", "mun", "con", "mer", "met", "util"], "qdict": ["dqdef", "qdef", "dqdir", " qtable", "pdom", "qobject", "pdef", "qqdict", "qqdf", "qdom", "qudict", "qutable", "pdir", "sqdom", "qudf", " qobject", "qdf", " qdf", "qqobject", "sqdef", "dqdict", "qqtable", "qdir", "pdict", "qtable", "dqdom", "sqdict", "quobject", "sqdir"], "ret_data": ["regblocklist", "regblockdata", "retoutlist", "reg_class", "ret_list", "ret0list", "retblockresults", "retoutclass", "retblockclass", "reg_results", "retoutresults", "reg_list", "retblocklist", "retoutdata", "retblockdata", "ret_results", "ret0class", "regblockclass", "regblockresults", "reg_data", "ret0results", "ret_class", "ret0data"], "d": ["data", "dn", "da", "di", "diff", "e", "dh", " delta", "did", "dt", "p", " prod", "D", " dw", "dos", "u", "ds", "dict", " p", "n", "l", "id", "dim", "dd", " od", "fd", "m", "c", "t", "dy", "dc", " dy", "f", "day", "start", "mod", "dl", "i", "ad", "o", "w", "bd", "delay", "ind", "md", "cd", "dm", "sd", "length", "dx", "b", " dd", "pd", " D", "ld", "x", "dat"], "ptr": ["pos", "ext", "ref", "pert", "proc", "eth", "loc", "rep", "vr", "tch", "str", "len", "trace", "tty", "p", "arr", "src", "pair", "pad", "offset", "pr", "r", "dim", "Ptr", "fd", "inter", "t", "rd", "dy", "tmp", "address", "pt", "tr", "pointer", "fer", " pointer", "inst", "tip", "der", "dr", "attr", "dx", "length", "addr", "td", "ld", "pointers", "rt"], "s": ["data", "storage", "sq", "e", "parts", "si", "submit", "sb", "server", "sys", "better", "p", "sync", "details", "args", "ls", "session", "S", "socket", "is", "ses", "cs", "gs", "r", "service", "ds", "stat", "stats", "n", "states", "rs", "c", "sg", "m", "services", "t", "g", "f", "ns", "syn", "ssl", "settings", "sl", "o", "secondary", "w", "less", "state", "js", "b", "su", "single", "conf", "v", "south", "spec"], "value": ["data", "object", "result", "name", "text", "element", "message", "key", "val", "str", "p", "type", "values", "num", "test", "r", "current", "id", "block", "Value", "content", "m", "VALUE", "version", "address", "description", "start", "min", "json", "w", "fee", "null", "v", "property", "format"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5201, "substitutes": {"ctx": ["context", "sci", "cfg", "nc", "unc", "fn", "rc", "wcs", "loc", "gpu", "component", "exec", "cc", "anc", "cli", "sync", "que", "cz", "src", "gc", "cus", "sc", "conn", "ct", "xc", "soc", "cm", "cs", "git", "config", "crit", "cmd", "ctr", "jp", "cca", "Context", "tx", "txt", "ck", "c", "css", "bc", "cpu", "kb", "ctrl", "mc", "cl", "cv", "cam", "qa", "pkg", "hw", "fc", "cu", "cf", "ca", "tc", "cn", "ci", "lc", "gru", "cas", "grad", "vc", "cmp", "cp", "cpp"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "substitutes": {"ctx": ["context", "sci", "cfg", "rc", "conv", " cx", "np", "pai", "loc", "input", "component", "exec", "anc", "cc", "cli", "sync", "que", "sys", "connection", "src", "cus", "client", "sc", "conn", "cm", "cs", "git", "config", "crit", "cmd", "chan", "cca", "Context", "JC", "tx", "txt", "cms", "ck", "c", "bc", "cpu", "kb", "kt", "ctrl", "mc", "cv", "cam", "pkg", "hw", "qa", "concept", "cu", "cf", "ca", "tc", "cn", "ci", "gru", "cas", "qt", "cb", "cmp", "vc", "cp", "cpp", "utils"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n", "idx": 5222, "substitutes": {"vser": ["fsr", "vder", "vcer", "fserver", "vg", "vsder", "qcer", " vg", " vester", "vcur", "vsr", " vserver", "qg", "qser", "evcur", "fser", "vscer", " vder", "vserver", "vester", " vper", "vper", "wserver", "wser", "vsg", "wsr", " vsr", "fester", "qder", " vcer", "evser", "evper", "wcur", "vsser", "wper", "wester", " vcur", "evserver"], "buf": ["batch", "pool", "data", "msg", "pb", "uc", "func", "ref", "bag", "queue", "Buffer", "val", "src", "seq", "num", "box", "config", "vec", "cmd", "fb", "buff", "fd", "ctx", "bc", "buffer", "f", "req", "uf", "ff", "rb", "b", "length", "cas", "cb", "v", "port"], "len": ["Len", "data", "pos", "fn", "end", "fun", "e", "alt", "le", "enc", "limit", "str", "val", "mem", "li", "ler", "ll", "zen", "lic", "seq", "un", "offset", "num", "bytes", "line", "lib", "elt", " length", "n", "l", "lim", "id", "all", "fin", "f", "rev", "en", "el", "bin", "err", "size", "nt", "lf", "lc", "z", "gen", "length", "lan", "addr", "count", "ln", "v", "fl", "base"], "elem": ["oelement", "elelee", "Elem", "Eject", "element", "selee", "elelements", "eeject", "Elev", "ele", "eelem", "elele", "eelements", "elelement", "eleject", "oeject", "elee", "selements", "selem", "Element", "pelement", " elements", "pelem", "pele", "felev", "elelem", "elements", "oelem", "selement", "felem", "elev", "feject", "felement", "pelev", "peject", "eelement", "eele", " elee", "oelements", " element", "Elee", "pelements", "eject", "pelee", "oelee"], "vq": ["evg", "vque", " vue", "vpqu", "vvw", "evq", "evque", "vue", "vvq", "vg", "vw", "vpque", "vdq", "vdqu", "vquest", "vrqi", " vg", " vQ", "lq", "evw", "evQ", "vrque", "VQ", "vqueue", "voltquest", "vqu", "svq", "nvq", "Vqueue", "Vq", "Vw", "nvqu", "nvQ", " vbar", "lque", "svue", " vqueue", " vqu", "vqi", "vdqi", "evbar", "vQ", "svdq", "vbar", "vrqu", "Vg", "svquest", " vw", "voltue", "Vque", "lqu", "voltq", "vpq", "vpQ", "vrq", " vdq", "lqi", "evqueue", " vquest", "voltdq", "nvque", "vvbar", " vque", "vvque", "vdque"]}}
{"project": "qemu", "commit_id": "9a10bbb4e83b184faef6fa744396a6775283c0aa", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 5229, "substitutes": {"lpc_pci": ["lpc_pmi", "lpc_phpki", "lpc_pki", "lpc_mct", "lpc_hmi", "lpc_lco", "lpc_mcm", "lpc2mmi", "lpc_pcu", "lpc_lki", "lpc2pca", "lpc_mca", "lpc_phpoci", "lpc_lmi", "lpc_spci", "lpc_nci", "lpc_hcm", "lpc_pcm", "lpc_mcr", "lpc_Pki", "lpc_pili", "lpc2mca", "lpc_phpci", "lpc2mcm", "lpc_spco", "lpc_ncm", "lpc_pca", "lpc_fcr", "lpc2pci", "lpc_phpct", "lpc_fci", "lpc_hca", "lpc_lci", "lpc_ncu", "lpc2mci", "lpc_fcm", "lpc_pct", "lpc_moci", "lpc_Pcm", "lpc_Pcr", "lpc_spcm", "lpc2pmi", "lpc2pcm", "lpc_lca", "lpc_mmi", "lpc_nco", "lpc_mki", "lpc_Pci", "lpc_fili", "lpc_hcr", "lpc_spcu", "lpc_hci", "lpc_pcr", "lpc_poci", "lpc_hili", "lpc_lcu", "lpc_pco", "lpc_lcr", "lpc_mci", "lpc_lili", "lpc_lcm"], "pm": ["nm", "pi", "pc", "lv", "mm", "mp", "mn", "dim", "mand", "mr", "ym", "pkg", "gp", "gmail", "lp", "dm", "PM", "asm", "em", "pb", "vim", "vm", "member", "am", "db", "param", "wm", "module", "cm", "um", "fm", "prem", "period", "tm", "wp", "iam", "km", "mon", "mail", "pool", "gm", "imm", "pg", "p", "bm", "mi", "hm", "nom", "plugin", "jp", "gram", "ram", "tmp", "pt", "hem", "ams", "pp", "mag", "om", "model", "lam", "im", "manager", "cp", "pd", "py", "mo", "rm", "pl", "pa", "service", "ml", "sem", "m", "px", "rem", "rpm", "dem", "po", "gem"], "sci_irq": ["sci_irce", "sci_pircs", "sci_rw", "sci_mirw", "sci_rrQ", "sci_IRq", "sci_rrq", "sci_pirQ", "sci_rk", "sci_IRce", "sci_mircs", "sci_rrg", "sci_ircs", "sci_mirk", "sci_rce", "sci_rrcs", "sci_irk", "sci_pirq", "sci_irw", "sci_mirg", "sci_mirQ", "sci_pirg", "sci_IRk", "sci_IRw", "sci_rq", "sci_mirq", "sci_irg", "sci_irQ", "sci_mirce"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n", "idx": 5250, "substitutes": {"opaque": ["Opaque", "OPac", "ipac", "OPaque", "opgate", "ipcode", "OPcode", "ipgate", "opac", "Opcode", "ipaque", "Opgate", "OPgate", "opcode", "Opac"], "addr": ["data", "pos", "pc", "ref", "target", "proc", "asm", "eth", "error", "alt", "byte", "p", "afi", "arm", "src", "Address", "amd", "conn", "ace", "offset", "config", "device", "cmd", "fd", "inter", "add", "layer", "dc", "boot", "address", "host", "pointer", "hop", "start", "mac", "nr", "slot", "reference", "ad", "code", "dr", "rt", "node", "alias", "grad", "ptr", "align", "adr"], "ret": ["data", "ext", "re", "ref", "def", "eth", "result", "value", "db", "alt", "fun", "mt", "success", "back", "sb", "len", "val", " Ret", "mem", "byte", "arr", "base", "bit", "RET", "reg", "id", "res", "net", "lit", "flag", "gt", "det", "info", "al", "reply", "code", "nt", "rt", "valid", "arg", "rets", "Ret"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 5263, "substitutes": {"q": ["k", "sq", "queue", "d", "pg", "self", "p", "que", "sync", "quad", "iq", "dq", "client", "ue", "query", "config", "u", "id", "n", "qu", "c", "v", "t", "cur", "g", "f", "cl", "qa", "req", "Q", "cache", "o", "qq", "qt", "quit", "qs", "window"], "n_IRQ": ["n_RRQ", "n_RRMQ", "n_irQueue", "n_IRX", "n_IRMQ", "n_RRX", "n_REQ", "n_IRQueue", "n_IRF", "n_IRq", "n_SRX", "n_MRQ", "n_irQ", "n_RRQueue", "n_SRQ", "n_SRMQ", "n_irq", "n_MRMQ", "n_MRq", "n_SRq", "n_REF", "n_REQueue", "n_MRX", "n_REq", "n_irF", "n_RRq", "n_RRF"], "pending": ["ipadding", "ipaging", "Pending", "pushing", "ipending", "paging", " paging", "padding", "Paging", "ipushing", "Pushing", " pushing", " padding", "Padding"]}}
{"project": "FFmpeg", "commit_id": "77d2ef13a8fa630e5081f14bde3fd20f84c90aec", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n\n                                  MatroskaTrack *track)\n\n{\n\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n\n    uint8_t* data = *buf;\n\n    int isize = *buf_size;\n\n    uint8_t* pkt_data = NULL;\n\n    int pkt_size = isize;\n\n    int result = 0;\n\n    int olen;\n\n\n\n    if (pkt_size >= 10000000)\n\n        return -1;\n\n\n\n    switch (encodings[0].compression.algo) {\n\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n\n        return encodings[0].compression.settings.size;\n\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n\n        do {\n\n            olen = pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n\n        if (result)\n\n            goto failed;\n\n        pkt_size -= olen;\n\n        break;\n\n#if CONFIG_ZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n\n        z_stream zstream = {0};\n\n        if (inflateInit(&zstream) != Z_OK)\n\n            return -1;\n\n        zstream.next_in = data;\n\n        zstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            zstream.avail_out = pkt_size - zstream.total_out;\n\n            zstream.next_out = pkt_data + zstream.total_out;\n\n            result = inflate(&zstream, Z_NO_FLUSH);\n\n        } while (result==Z_OK && pkt_size<10000000);\n\n        pkt_size = zstream.total_out;\n\n        inflateEnd(&zstream);\n\n        if (result != Z_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n#if CONFIG_BZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n\n        bz_stream bzstream = {0};\n\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n\n            return -1;\n\n        bzstream.next_in = data;\n\n        bzstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n\n            result = BZ2_bzDecompress(&bzstream);\n\n        } while (result==BZ_OK && pkt_size<10000000);\n\n        pkt_size = bzstream.total_out_lo32;\n\n        BZ2_bzDecompressEnd(&bzstream);\n\n        if (result != BZ_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    *buf = pkt_data;\n\n    *buf_size = pkt_size;\n\n    return 0;\n\n failed:\n\n    av_free(pkt_data);\n\n    return -1;\n\n}\n", "idx": 5277, "substitutes": {"buf": ["batch", "br", "rc", "bag", "queue", "input", "Buffer", "len", "byte", "map", "src", "pad", "seq", "config", "vec", "cmd", "fb", "buff", "raf", "tmp", "bc", "buffer", "array", "padding", "Buff", "mount", "alloc", "uf", "rb", "b", "board", "cb", "addr", "feed", "port"], "buf_size": ["buf_Size", "block_address", "block_value", "buf_ize", "file_range", "file_Size", "file_ize", "block_size", "buf_address", "bufksize", "buf_range", "file_size", "block_width", "bufkaddress", "buf_value", "bufkwidth", "bufkvalue", "buf_width"], "track": ["tag", "ru", "form", "rack", "package", "trace", "type", "record", "test", "order", " tracks", "ack", "r", "train", "tracking", "Track", "step", "add", "tr", "trip", "path", "roll", "ACK", "transform", "project", "match", "dr", "board", "tab", "round", "seek", "stream", "row", "car", "tracks", "port"], "encodings": ["enccodions", "encodeing", "encodedrings", "enccodations", "encoding", "eccodides", "enccoders", "encodinging", "enccodrings", "ecodings", "encodeions", "encodors", "encodedors", "eccoders", "encodeations", "encodedions", "eccodrings", "ecodors", "encodedations", "ecodides", "encoders", "ecodations", "ecodrings", "encodations", "enccodors", "encodedands", "eccodions", "encodingings", "encodeides", "ecoding", "eccoding", "encodeers", "encordors", "encodeings", "encodingions", "ecoders", "encodrings", "encodedings", "enccodings", "eccodations", "enccoding", "ecodands", "encodides", "encording", "encodions", "eccodors", "encodeding", "encodeders", "eccodands", "encordings", "eccodings", "encodands", "ecodions", "enccodands", "encordrings", "encodedides", "enccodides", "encodingands"], "data": ["batch", "extra", "pos", "new", "three", "sample", "package", "DATA", "result", "input", "Data", "str", "multi", "devices", "len", "raw", "none", "ata", "zip", "api", "dat", "pad", "empty", "config", "bytes", "response", "dd", "temp", "all", "buffer", "next", " DATA", "start", "parent", "cache", "xxx", "media", "memory", "database", "la", "valid", "board", "results", "zero", "feed", "body", "window", "after", "base"], "pkt_data": ["pkt_batch", "pkt_start", "pwk_body", "packet_break", "packet_data", "pwk_size", "packet_size", "pkt2off", "pwk_data", "packet_align", "packet_value", "pkt_body", "pkt_align", "pkg_data", "pkt_break", "packet_off", "pkt_dat", "pkt2break", "pkg_size", "pkt_off", "pwk_cache", "pkt_done", "packet_body", "pkt_bin", "pkg_batch", "packet_start", "pkt_cache", "packet_bin", "packet_done", "pkt2data", "pkt_size", "pkt_value", "pkt2size", "packet_dat"], "olen": [" unused", "nn", "lins", "sid", "sle", "le", "len", "nil", "ele", "where", "won", " leftover", "numbered", "lif", "sol", "lost", "osen", "olo", "ole", "broken", "liv", "lim", "mn", "lo", "skip", "little", "temp", "ellen", "fin", "loss", "eden", "uno", "regon", "ken", "oven", "what", "linger", "eno", "serv", "foo", " len", "slot", "non", "oren", "kn", "legal", "lov", "less", "ien", "eni", "lvl", "valid", "oln", "oin", "oo", "normal", "ln", "unit"]}}
{"project": "FFmpeg", "commit_id": "63b1866ae1e19ff0d694746a84e2eac859cda462", "target": 0, "func": "static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_coefs; i++) {\n\n        int e;\n\n        int v = abs(coef[i]);\n\n        if (v == 0)\n\n            e = 24;\n\n        else {\n\n            e = 23 - av_log2(v);\n\n            if (e >= 24) {\n\n                e = 24;\n\n                coef[i] = 0;\n\n            }\n\n            av_assert2(e >= 0);\n\n        }\n\n        exp[i] = e;\n\n    }\n\n}\n", "idx": 5281, "substitutes": {"coef": ["codeeff", "codeef", "codeefficient", "cof", "Coff", "Coeff", "coff", "Coefficient", " coefficient", "koef", "COf", " coec", "koec", "coefficient", "Coec", "coec", " coeff", " coaf", " coff", "codeaf", "coeff", " cof", "koaf", "COeff", "COff", "Coef", "Coaf", "koeff", "Cof", "COef", "coaf"], "nb_coefs": ["nb_crossefsets", "nb_coefn", "nb_crossefp", "nb_coeffsets", "nb_COEFs", "nb_coevn", "nb_coeffn", "nb_coefficientss", "nb_crossefficientsp", "nb_COefp", "nb_coEFn", "nb_crossefficientsn", "nb_crossefs", "nb_crossefn", "nb_crossefficientssets", "nb_COefn", "nb_coefficientsp", "nb_coecsets", "nb_coefficientsn", "nb_coefsets", "nb_coecp", "nb_coevp", "nb_coEFes", "nb_coevs", "nb_COEFn", "nb_coeffp", "nb_COEFp", "nb_crossefficientss", "nb_coEFs", "nb_COefs", "nb_coefficientssets", "nb_coecn", "nb_coecs", "nb_coeffes", "nb_coEFp", "nb_coeves", "nb_coeffs", "nb_COefes", "nb_coefes", "nb_coefp", "nb_COEFes"], "i": ["ui", "bi", "y", "index", "pi", "ie", "ei", "j", "di", "si", "d", "key", "multi", "fi", "ti", "p", "api", "h", "is", "mi", "qi", "ii", "r", "hi", "u", "id", "n", "l", "ni", "ip", "s", "c", "m", "t", "ori", "ix", "oi", "f", "zi", "io", "ri", "ini", "o", "gi", "mu", "xi", "uri", "ci", "eni", "z", "b", "esi", "iu", "I", "ai", "v", "x", "li"], "e": ["y", "ie", "ei", "j", "diff", "de", "ae", "d", "element", "le", "er", "ve", "ea", "fe", "p", "ce", "h", "ace", "ue", "ne", "ev", "u", "ze", "r", "je", "n", "l", "s", "c", "m", "E", "g", "f", "ed", "oe", "be", "ec", "en", "el", "eb", "se", "o", "pe", "ge", "z", "esi", "es", "ke", "ee", "v", "x"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void vhost_log_stop(MemoryListener *listener,\n\n                           MemoryRegionSection *section)\n\n{\n\n    /* FIXME: implement */\n\n}\n", "idx": 5283, "substitutes": {"listener": ["listenser", "litener", "lineners", "latenser", "literver", "liteners", "listerver", "litenser", "linenser", "latener", "linerver", "listeners", "laterver", "linener", "lateners"], "section": ["sec", "area", "ECTION", "sea", "region", "division", "Section", " Section", "server", "connection", "protection", "channel", "vision", "sections", "plugin", "ment", "option", "except", "sect", "child", "sector", "entry", "or", "part", "writer", "sub", "environment"]}}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n", "idx": 5298, "substitutes": {"drc": [" drec", "lrec", "fRC", "tpc", "fsrc", " dpc", "bsrc", "fpc", "dsrc", "lsrc", "brec", "frc", "frec", "lRC", "dRC", " dsrc", "bRC", "dpc", "brc", "trc", "lrc", "drec", " dRC", "tRC", "trec"], "hp_action": ["HP_index", "hpfaction", "hp_act", "hp_index", "hpfact", "HP_id", "HP_act", "hpfindex", "hp_id", "HP_action", "hpfid"], "new_hp": ["final_hp", "NEW_gp", "new_hap", "finalFmph", "old_hop", "finalFgp", "new___hap", "finalFht", "old_gp", "old_cpp", " new_hop", "NEW_hap", "NEW_hp", "new___bh", " new_gp", "newFhp", "new67gp", "new_hy", "final_gp", "NEW_cp", "new___hw", "newJhp", "finalFhp", "new67hy", "newJcp", "new_cpp", "newJgp", "final_mph", "new_bh", "old_hp", " new_wp", "final_ht", "new_ht", "new_gp", "new_ih", "new_hop", "NEW_hw", "old_ih", "NEW_bh", "new_wp", "new_hw", "new___hp", "new67cp", "new67hp", "old_cp", "newFht", " new_hy", "newFmph", " new_cp", "new_cp", "newFgp", "new_mph"], "hdr": ["adhDR", "dhder", "chdr", "ghder", "qrid", "dhrid", "dhgr", "qdr", "shride", "ahdu", "shdr", "hdu", "hmstr", "Hride", "HDR", "hirt", "hDR", "ahder", "shrt", "hegr", "ghrt", " hirt", " hDR", "ahstr", "thder", "Hrc", "hride", "hhbr", "shint", "enhdr", "hrid", " hbr", "shirt", "shDR", "ghdu", "chint", "shrid", "phdr", " hstr", "hhrs", "hrt", "hhDR", "hmdr", "adhmt", "ahdr", "bhirt", "qmt", "hgr", "enhrid", " hint", "phDR", "hedr", "herid", "hrdr", " hmt", "shrc", "ghstr", "hmt", "enhmt", "dhdr", "adhrid", "hbr", "hint", "thstr", "chmt", "bhstr", "hrc", "heder", "phrt", "phrid", "hrride", "Hint", "ghirt", "chrid", "ohdr", "ghdr", " hrid", "thdu", " hrs", "hrrc", "hmirt", "thdr", "enhDR", "hrs", "ohgr", "ohder", "ghint", "ohrid", "hhdr", " hrt", "hder", "Hrs", "Hdr", "qint", "hrint", "Hbr", "bhdr", "adhdr", "hstr"], "v6hdr": ["v6bhr", "v6phr", "v6wver", "v6hint", "v6hhr", "v8hint", "v6hr", "v6shver", "v6bhhr", "v3bhdr", "v0hrt", "v6hrt", "v6bhdr", "v6hmld", "v6hmrt", "v0hmrt", "v6hrid", "v6hver", "v6hldr", "v6hmhr", "v6bhld", "v0hdr", "v6wdr", "v6thrid", "v6shost", "v6hyver", "v6hlld", "v6bhDR", "v6bhrt", "v8wost", "v16hdr", "v16hhr", "v6chDR", "v3bhDR", "v6shint", "v0hld", "v6chct", "v3hrid", "v6hmdr", "v6thct", "v0hmrr", "v6hlrr", "v6wost", "v8wint", "v3bhct", "v8wdr", "v6bhrr", "v3hct", "v6hyint", "v6chdr", "v8hver", "v16hr", "v16hmr", "v6bhct", "v6wint", "v8hdr", "v16hmhr", "v6hlrt", "v6thdr", "v6phDR", "v6hmrr", "v0hmld", "v6bhrid", "v16hmdr", "v6hmr", "v8host", "v6shdr", "v6thDR", "v6phhr", "v6hrr", "v6hct", "v6phdr", "v3hdr", "v8wver", "v3hDR", "v16hDR", "v0hrr", "v6hyost", "v0hmdr", "v16hmDR", "v6hDR", "v6host", "v6chrid", "v6hydr", "v6hmDR", "v3bhrid", "v6hld"], "maina": [" mainA", "mine", "mina", "Maina", "mini", "maine", "mainA", "masterb", "masteraa", "MainA", " maini", "minas", "masteri", " maine", "mainc", "mastere", "Mainb", "Mainaa", "masterc", "minA", "minb", "minaa", "maini", " mainas", "mainas", "mastera", " mainc", " mainaa", "mainaa", "Mainc", "masteras"], "mainb": ["donback", "primaryb", "centralk", "dateba", "westab", "masterB", "primarya", "masterb", "publicb", " mainobject", "Mainbody", "minobject", "mainba", "Mainbar", " mainbe", "centralf", " mainbad", " mainf", "centralba", "minba", "minbar", "donk", "minB", "mina", "defaultbody", "Maina", "defaulta", "maine", "centrala", "sideb", "mainbad", "minbe", "sideobject", "Mainab", "minb", "mainbe", "mastera", "centralb", "mainbody", "masterbar", "publicbad", "defaultc", "mainback", "mainbar", "westa", "masterab", "Mainba", " mainbar", " mainbody", "Mainas", "mink", "mainf", "minab", " maine", "mainobject", "maink", "primaryba", "primaryas", "sidebe", "dateas", "mainas", "publicback", "mainab", " mainback", "datea", "mainB", "donb", "mine", " mainab", "sidea", "weste", "westb", "mainc", " maink", "Mainb", "dateb", " mainba", "minf", "publick", "donbad", " mainc", " mainB", "Mainc", "defaultb"], "hp": ["np", "pai", "php", "ih", "vp", "ssh", "him", "wm", "dh", "tp", "cli", "p", "rh", "h", "hy", "drm", "config", "hm", "mph", "dp", "hl", "imp", "jp", "ip", "hh", "cpp", "hap", "hop", "wp", "gp", "hw", "pkg", "ssl", "phy", "ph", "xp", "lp", "prot", "bh", "bp", "adj", "HP", "hs", "fp", "cp", "ha", "health", "ht"], "drck": ["drke", "rack", "hrke", "hrk", "DRck", "drack", "prck", "drk", "DRke", "rck", "hrcc", "drcc", "hrq", "hrack", "prk", "drq", "rcc", " drack", " drcc", "DRk", "prcc", "DRcc", "prke", "rq", " drq", "hrck"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,\n\n                               TCGMemOp s_bits, int which)\n\n{\n\n    const TCGReg r0 = TCG_REG_O0;\n\n    const TCGReg r1 = TCG_REG_O1;\n\n    const TCGReg r2 = TCG_REG_O2;\n\n    int tlb_ofs;\n\n\n\n    /* Shift the page number down.  */\n\n    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);\n\n\n\n    /* Mask out the page offset, except for the required alignment.  */\n\n    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n", "idx": 5304, "substitutes": {"s": ["private", "sq", "e", "d", "si", "sb", "server", "sys", "self", "p", "sync", "details", "native", "session", "S", "h", "client", "is", "socket", "ses", "support", "site", "r", "sets", "gs", "u", "sf", "xs", "cs", "ions", "stat", "ds", "l", "stats", "current", "n", "rows", "states", "sym", "c", "m", "sg", "t", "services", "ctx", "v", "fs", "g", "f", "ns", "us", "a", "ssl", "settings", "i", "info", "w", "secondary", "js", "b", "groups", "http", "conf", "qs", "spec"], "addr": ["data", "rc", "ref", "proc", "sample", "sid", "asm", "name", "ord", "nil", "rx", "p", "src", "arm", "slice", "type", "Address", "amd", "seq", "conn", "offset", "ace", "ack", "config", "reg", "usr", "class", "sg", "add", "layer", "ctx", "address", "host", "pointer", "pkg", "nr", "Error", "mac", "flags", "ar", "size", "xp", "x", "amp", "arch", "dr", "rt", "alias", "cmp", "ptr", "align", "rs", "spec"], "mem_index": ["mem_slice", "memfposition", "Mem_index", " mem_mask", "mem_mask", " mem_slice", "memingslice", "memingindex", "mem_Index", "memfindex", "memfIndex", "memingmask", "Mem_position", "mem_position", "Mem_Index"], "s_bits": ["num_length", "s5bytes", "S_flags", "s_bit", "s2bits", "s5bits", "S_BIT", "num_bytes", "s5length", "num_bits", "s_lins", "s_bytes", "num_lins", "s_BIT", "s_length", "s5lins", "s2bit", "s2BIT", "S_bit", "s2flags", "s_flags", "S_bits"], "which": ["extra", " unused", "func", " how", "rc", "proc", "asm", "loc", "where", "src", " rc", "who", "num", "test", "dest", "config", "est", "mode", "version", "ctx", "shift", "hift", "mac", "supp", " mode", "desc", "how", "spec", "port"], "tlb_ofs": ["tlb_notits", "tlb_lengthts", "tlb_lengths", "tlb_lengthi", "tlb_offb", "tlb_notds", "tlb_ofb", "tlb_ofits", "tlb_effds", "tlb__ofb", "tlb_ifs", "tlb_ofd", "tlb_Ofb", "tlb_ofds", "tlb_ofhs", "tlb_lengthn", "tlb_Ofi", "tlb_lengthits", "tlb_ofts", "tlb_offp", "tlb_Ofd", "tlb_ifts", "tlb_OFs", "tlb_lengthd", "tlb_notts", "tlb_offs", "tlb_offds", "tlb__ofs", "tlb_Ofds", "tlb_offts", "tlb_Ofhs", "tlb_nots", "tlb_ifp", "tlb_OFd", "tlb_lengthc", "tlb_Ofs", "tlb_effb", "tlb_ofn", "tlb_Ofn", "tlb_ofi", "tlb_effhs", "tlb__ofd", "tlb_lengthb", "tlb_effs", "tlb__ofc", "tlb_ofc", "tlb_lengthds", "tlb_notd", "tlb_offd", "tlb_lengthp", "tlb_ofp", "tlb_offhs", "tlb_OFb", "tlb_ifd", "tlb_OFds", "tlb_notp", "tlb_Ofc"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5306, "substitutes": {"curl": ["cURL", " crawl", "Curl", "acurl", "acur", "crawl", "cur", " cURL", "acURL", " cur", "Crawl", "acrawl", "Cur", "CURL"], "fd": ["data", "func", "fn", "fa", "flo", "xd", "cond", "db", "fun", "director", "d", "fax", "fed", "fx", "exec", "nil", "fi", "dt", "fe", " FD", "draft", "df", "function", "socket", "fff", "dial", "FD", " sd", "sf", "ds", "fw", "pipe", "fm", "fb", "dd", " d", "fen", "dc", "fs", "f", "pointer", "wd", "nd", "dl", "ld", "ln", "fc", "ad", "cf", "feed", "bd", "stream", "md", "cd", "sd", "null", "cb", "fp", "pd", "driver", " fid", "fl", "handler"], "action": ["data", "ception", "operation", "func", "index", "url", "error", "name", "ction", "view", "handler", "val", " act", "call", "event", "ACTION", "args", "function", "type", "style", "Action", "filter", "channel", "change", "sign", "id", "effect", "class", "activity", "actions", "step", "version", "ix", "act", "path", "what", "sort", "xxx", "i", "ault", "timeout", "active", "direction", "method", "base"], "s": ["WS", "set", "e", "d", "sb", "server", "sys", "none", "p", "sync", "ls", "S", "socket", "u", "sf", "ds", "n", "l", "ss", "c", "sg", "sym", "t", "services", "fs", "f", "ns", "sa", "sit", "sn", "ssl", "i", "o", "sl", "w", "size", "sw", "sv", "sd", "su", "null", "side", "in", "http", "status", "v", "south", "si"], "sp": ["pc", "proc", "e", "fe", "p", "std", "ps", "sc", "resp", "sf", "ds", "P", " p", "ip", "ss", "sh", "ctx", "fs", "page", "cl", "w", "amp", "sw", "sv", "SP", "ptr", "fp", "si"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)\n\n{\n\n#if defined(HAVE_MMX2) || defined(HAVE_MMX)\n\n    if(c->flags & SWS_CPU_CAPS_MMX2){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX2;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX2;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX2;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX2;\n\n\t}\n\n    }\n\n    if(c->flags & SWS_CPU_CAPS_MMX){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX;\n\n\t}\n\n    }\n\n#endif\n\n#ifdef HAVE_MLIB\n\n    {\n\n\tSwsFunc t= yuv2rgb_init_mlib(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n#ifdef HAVE_ALTIVEC\n\n    if (c->flags & SWS_CPU_CAPS_ALTIVEC)\n\n    {\n\n\tSwsFunc t = yuv2rgb_init_altivec(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n\n\n    av_log(c, AV_LOG_WARNING, \"No accelerated colorspace conversion found\\n\");\n\n\n\n    switch(c->dstFormat){\n\n    case PIX_FMT_BGR32:\n\n    case PIX_FMT_RGB32: return yuv2rgb_c_32;\n\n    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;\n\n    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;\n\n    case PIX_FMT_RGB565:\n\n    case PIX_FMT_BGR565:\n\n    case PIX_FMT_RGB555:\n\n    case PIX_FMT_BGR555: return yuv2rgb_c_16;\n\n    case PIX_FMT_RGB8:\n\n    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;\n\n    case PIX_FMT_RGB4:\n\n    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;\n\n    case PIX_FMT_RGB4_BYTE:\n\n    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;\n\n    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;\n\n    default:\n\n    \tassert(0);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 5308, "substitutes": {"c": ["context", "nc", "uc", "pc", "rc", "k", "wcs", "e", "d", "exec", "cc", "self", "call", "p", "ce", "h", "sc", "ct", "cm", "cs", "ch", "config", "u", "cod", "n", "l", "cont", "cy", "s", "m", "t", "ctx", "dc", "bc", "cur", "g", "f", "cr", "mc", "cl", "cat", "ec", "cv", "conf", "cam", "cache", "cu", "cf", "ca", "C", "ci", "lc", "ac", "center", "b", "com", "cb", "vc", "con", "cp", "v", "x"]}}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n", "idx": 5314, "substitutes": {"vs": ["ys", "vm", "vp", "lv", "vas", "vg", "vr", "pg", "sb", "lines", "VS", "events", "plugins", "self", "ks", "ls", "versions", "ps", "values", "ses", "ves", "cs", "qs", "gs", "alls", "ds", "changes", "stats", "env", "sts", "blogs", "s", "var", "ss", "net", "ils", "ts", "services", "obs", "fs", "ns", "vers", "ms", "views", "vt", "cv", "vals", "Vs", "wp", "flags", "ums", "ports", "docs", "posts", "va", "sv", "state", "ov", "es", "sk", "fg", "http", "bs", "vc", "eps", "oss", "v", "rs", "utils", "verts"], "mode": ["ui", "nm", "scope", "purpose", "Mode", "object", "vm", "member", "scale", "de", "name", "mm", "value", "slave", "key", "grade", "op", "map", "rule", "mp", "move", "type", "username", "module", "device", "cmd", "password", "id", "option", "MODE", "m", "mr", "version", "address", "ms", "path", "source", "prop", "mod", "operator", "manager", "project", "size", "me", "md", "dm", "state", "route", "node", "kind", "role", "alias", "direction", "status", "language", "method"], "mn": ["nm", "mins", "fn", "dn", "MN", "nn", "vm", "pin", "mm", "rm", "wm", "na", "mb", "MC", "mx", "bm", "gn", "mp", "ann", "mi", "cm", "ml", "fm", "n", "man", "m", "mr", "pm", "ns", "ms", "mc", "nor", "Mi", "cn", "mis", "md", "dm", "misc", "ains", "ln"], "vd": ["dn", "od", "xd", "lv", "vg", "nv", "adder", "vision", "vid", "dd", "fd", "gd", "hd", "uv", "wd", "nd", "vt", "hov", "ld", "dl", "cv", "dk", "uds", "bd", "ud", "va", "md", "sv", "sd", "vc", "pd", "VD", "ant", "vv", "eddy"], "num_exclusive": ["numAllshared", "number_sharing", "number_shared", "max_external", "number_clusive", "num_clusive", "numwexternal", "numwexclusive", "max_clusive", "max_seconds", "numAllclusive", "max_exclusive", "numAllexclusive", "numwseconds", "numwclusive", "num_seconds", "num_sharing", "numAllsharing", "number_exclusive", "num_external", "num_shared"]}}
{"project": "FFmpeg", "commit_id": "7cc8d616aab68ba5534e5a74214786ad08aac5ce", "target": 1, "func": "uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)\n\n{\n\n    uint32_t scratch = 0;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n\n\n    for (; buf < buf_end - 3; buf += 4)\n\n        scratch ^= *((const uint32_t*)buf);\n\n\n\n    scratch = xor_32_to_8(scratch);\n\n\n\n    for (; buf < buf_end; buf++)\n\n\n\n\n    return scratch;\n\n}", "idx": 5327, "substitutes": {"buf": ["batch", "data", "av", "pos", "br", "func", "uc", "rc", "wb", "pub", "bag", "proc", "ab", "queue", "begin", "loc", "bf", "af", "ul", "src", "seq", "num", "offset", "img", "um", "bb", "config", "fam", "off", "vec", "cmd", "fw", "fb", "usr", "block", "plug", "buff", "fd", "home", "cur", "bc", "buffer", "f", "shift", "wa", "cv", "feat", "alloc", "cf", "cap", "bh", "uf", "ff", "rb", "length", "b", "fac", "tab", "cb", "count", "ptr", "cp", "feed", "fp", "cmp", "port"], "buf_size": ["buflensize", "queue_size", "buf_name", "buffer_center", "queue_end", "buf0end", "buffer_end", "buffer_size", "buf0name", "buflencenter", "queue_name", "buflenend", "buf_center", "buf0size"], "buf_end": ["buf2start", "uf_end", "bufsEnd", " buf0end", "cap_start", "uf_End", " buf0start", "bufllast", "cap_stop", "buf_last", " buf0size", "buf0end", "bufsend", "buf0ending", "buf2ending", "buf_End", "buf2end", "uf_start", "buf0start", "bufslast", "bufsstart", "buflend", " buf_start", "cap_end", "buflEnd", "buf_stop", "uf_last", "buf2size", "buflstart", " buf0ending", "buf_start", "buf_ends", "buf_ending", "cap_ends", "buf0size", " buf_ending"]}}
{"project": "FFmpeg", "commit_id": "f354f30836a3148275ce60d19bbc581310249ad2", "target": 0, "func": "void ff_er_frame_start(ERContext *s)\n\n{\n\n    if (!s->avctx->err_recognition)\n\n        return;\n\n\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n\n    s->error_count    = 3 * s->mb_num;\n\n    s->error_occurred = 0;\n\n}\n", "idx": 5353, "substitutes": {"s": ["data", "new", "comm", "sq", "ans", "e", "d", "lines", "sb", "comments", "sys", "self", "sync", "p", "ks", "details", "ls", "S", "ps", "is", "ses", "cs", "gs", "sets", "sf", "ds", "n", "l", "rates", "sym", "ops", "ss", "c", "sg", "ts", "services", "t", "ctx", "m", "v", "fs", "g", "ns", "f", "ms", "a", "ssl", "settings", "als", "i", "o", "js", "in", "es", "ins", "hs", "os", "qs", "rs", "stat"]}}
{"project": "FFmpeg", "commit_id": "f98c9fb27de84dc4f6123537b754eb2fe1a80c02", "target": 0, "func": "av_cold int MPV_common_init(MpegEncContext *s)\n\n{\n\n    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads;\n\n\n\n    if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n\n        s->mb_height = (s->height + 31) / 32 * 2;\n\n    else if (s->codec_id != CODEC_ID_H264)\n\n        s->mb_height = (s->height + 15) / 16;\n\n\n\n    if(s->avctx->pix_fmt == PIX_FMT_NONE){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"decoding to PIX_FMT_NONE is not supported.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&\n\n       (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx))\n\n        return -1;\n\n\n\n    dsputil_init(&s->dsp, s->avctx);\n\n    ff_dct_common_init(s);\n\n\n\n    s->flags= s->avctx->flags;\n\n    s->flags2= s->avctx->flags2;\n\n\n\n    if (s->width && s->height) {\n\n        s->mb_width  = (s->width  + 15) / 16;\n\n        s->mb_stride = s->mb_width + 1;\n\n        s->b8_stride = s->mb_width*2 + 1;\n\n        s->b4_stride = s->mb_width*4 + 1;\n\n        mb_array_size= s->mb_height * s->mb_stride;\n\n        mv_table_size= (s->mb_height+2) * s->mb_stride + 1;\n\n\n\n        /* set chroma shifts */\n\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift),\n\n                                      &(s->chroma_y_shift) );\n\n\n\n        /* set default edge pos, will be overriden in decode_header if needed */\n\n        s->h_edge_pos= s->mb_width*16;\n\n        s->v_edge_pos= s->mb_height*16;\n\n\n\n        s->mb_num = s->mb_width * s->mb_height;\n\n\n\n        s->block_wrap[0]=\n\n        s->block_wrap[1]=\n\n        s->block_wrap[2]=\n\n        s->block_wrap[3]= s->b8_stride;\n\n        s->block_wrap[4]=\n\n        s->block_wrap[5]= s->mb_stride;\n\n\n\n        y_size = s->b8_stride * (2 * s->mb_height + 1);\n\n        c_size = s->mb_stride * (s->mb_height + 1);\n\n        yc_size = y_size + 2 * c_size;\n\n\n\n        /* convert fourcc to upper case */\n\n        s->codec_tag = ff_toupper4(s->avctx->codec_tag);\n\n\n\n        s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);\n\n\n\n        s->avctx->coded_frame= (AVFrame*)&s->current_picture;\n\n\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this\n\n        for(y=0; y<s->mb_height; y++){\n\n            for(x=0; x<s->mb_width; x++){\n\n                s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride;\n\n            }\n\n        }\n\n        s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n\n\n\n        if (s->encoding) {\n\n            /* Allocate MV tables */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n\n            s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n\n            s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n\n            s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n\n            s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n\n            s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n\n\n\n            if(s->msmpeg4_version){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);\n\n            }\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail);\n\n\n\n            /* Allocate MB type table */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n\n\n            if(s->avctx->noise_reduction){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)\n\n            }\n\n        }\n\n    }\n\n\n\n    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail)\n\n    for(i = 0; i < s->picture_count; i++) {\n\n        avcodec_get_frame_defaults((AVFrame *)&s->picture[i]);\n\n    }\n\n\n\n    if (s->width && s->height) {\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)\n\n\n\n        if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n\n            /* interlaced direct mode decoding tables */\n\n            for(i=0; i<2; i++){\n\n                int j, k;\n\n                for(j=0; j<2; j++){\n\n                    for(k=0; k<2; k++){\n\n                        FF_ALLOCZ_OR_GOTO(s->avctx,    s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                        s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1;\n\n                    }\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                    s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1;\n\n                }\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n            }\n\n        }\n\n        if (s->out_format == FMT_H263) {\n\n            /* cbp values */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);\n\n            s->coded_block= s->coded_block_base + s->b8_stride + 1;\n\n\n\n            /* cbp, ac_pred, pred_dir */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)\n\n        }\n\n\n\n        if (s->h263_pred || s->h263_plus || !s->encoding) {\n\n            /* dc values */\n\n            //MN: we need these for error resilience of intra-frames\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n\n            s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;\n\n            s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;\n\n            s->dc_val[2] = s->dc_val[1] + c_size;\n\n            for(i=0;i<yc_size;i++)\n\n                s->dc_val_base[i] = 1024;\n\n        }\n\n\n\n        /* which mb is a intra block */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n\n        memset(s->mbintra_table, 1, mb_array_size);\n\n\n\n        /* init macroblock skip table */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);\n\n        //Note the +1 is for a quicker mpeg4 slice_end detection\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);\n\n\n\n        s->parse_context.state= -1;\n\n        if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){\n\n            s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n        }\n\n    }\n\n\n\n    s->context_initialized = 1;\n\n    s->thread_context[0]= s;\n\n\n\n    if (s->width && s->height) {\n\n    if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {\n\n        threads = s->avctx->thread_count;\n\n\n\n        for(i=1; i<threads; i++){\n\n            s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n\n            memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n\n        }\n\n\n\n        for(i=0; i<threads; i++){\n\n            if(init_duplicate_context(s->thread_context[i], s) < 0)\n\n                goto fail;\n\n            s->thread_context[i]->start_mb_y= (s->mb_height*(i  ) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n            s->thread_context[i]->end_mb_y  = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n        }\n\n    } else {\n\n        if(init_duplicate_context(s, s) < 0) goto fail;\n\n        s->start_mb_y = 0;\n\n        s->end_mb_y   = s->mb_height;\n\n    }\n\n    }\n\n\n\n    return 0;\n\n fail:\n\n    MPV_common_end(s);\n\n    return -1;\n\n}\n", "idx": 5356, "substitutes": {"s": ["sum", "ans", "d", "sync", "sports", "args", "site", "vs", "ops", "sg", "services", "fs", "f", "b", "features", "conf", "new", "sites", "sq", "sb", "params", "h", "ses", "cs", "this", "r", "u", "sf", "ss", "ts", "t", "uns", "ns", "a", "its", "w", "tests", "es", "ins", "hs", "uses", "parts", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "ims", "xs", "stats", "n", "c", "g", "us", "ssl", "su", "qs", "rs", "spec", "si", "aws", "e", "cons", "is", "service", "ds", "l", "states", "sym", "m", "ms", "as", "bis", "settings", "o", "words", "js", "os", "results"], "y_size": ["c6small", "c_speed", "y6small", "c_small", "y6size", "y_small", "y_speed", "c6speed", "c6size", "y6speed"], "c_size": ["c7shape", "cwloffset", "ct7shape", "c7offset", "c7length", "ct7offset", "c_length", "ct_size", "ct7length", "ct_length", "c_shape", "ct_shape", "c_offset", "cwllength", "c7size", "ct7size", "ct_offset", "cwlsize", "cwlshape"], "yc_size": ["yl_capacity", "yc_capacity", "yl_small", "yc_speed", "yc_small", "yl_speed", "yl_size"], "i": ["index", "pi", "e", "d", "si", "p", "slice", "h", "ii", "u", "id", "n", "ip", "m", "c", "t", "f", "io", "axis", "ci", "z", "b", "in", "I", "v"], "mb_array_size": ["mb_table_capacity", "mb_table_size", "mb_table_scale", "mb_table_empty", "mb_array_capacity", "mb_array_scale", "mb_array_empty"], "mv_table_size": ["mv_table0size", "mv_table__width", "mv_table0shape", "mv_col__width", "mv_thread___size", "mv_col__shape", "mv_table_shape", "mv_thread___small", "mv_table_len", "mv_col_capacity", "mv_table0width", "mv_col_shape", "mv_thread___capacity", "mv_table__shape", "mv_table__capacity", "mv_table_capacity", "mv_thread___len", "mv_col__capacity", "mv_table0capacity", "mv_table_small", "mv_table___capacity", "mv_col__size", "mv_thread_size", "mv_thread_small", "mv_table___len", "mv_table___size", "mv_col_width", "mv_thread_capacity", "mv_col_size", "mv_thread_len", "mv_table_width", "mv_table___small", "mv_table__size"], "x": ["data", "ex", "index", "d", "p", "rx", "slice", "image", "xs", "id", "n", "c", "m", "height", "ctx", "f", "xy", "w", "size", "pixel", "z", "dx", "time", "X"], "y": ["e", "d", "yy", "p", "type", "h", "n", "vy", "temp", "m", "c", "t", "height", "dy", " dy", "g", "f", "Y", "o", "w", "size", "z", "b", "v"], "threads": ["colls", "rounds", "colnum", "threadnum", "roundCount", "streams", "threadls", "cols", "colCount", "streamls", "threadCount", "streamnum", "roundls", "streamCount", "roundnum"]}}
{"project": "FFmpeg", "commit_id": "03847eb8259291b4ff1bd840bd779d0699d71f96", "target": 0, "func": "int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\n\n                          const char *filename, void *logctx,\n\n                          unsigned int offset, unsigned int max_probe_size)\n\n{\n\n    AVProbeData pd = { filename ? filename : \"\", NULL, -offset };\n\n    unsigned char *buf = NULL;\n\n    int ret = 0, probe_size;\n\n\n\n    if (!max_probe_size) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size > PROBE_BUF_MAX) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size < PROBE_BUF_MIN) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (offset >= max_probe_size) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;\n\n        probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {\n\n        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\n\n        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\n\n        void *buftmp;\n\n\n\n        if (probe_size < offset) {\n\n            continue;\n\n        }\n\n\n\n        /* read probe data */\n\n        buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n\n        if(!buftmp){\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        buf=buftmp;\n\n        if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n\n            /* fail if error was not end of file, otherwise, lower score */\n\n            if (ret != AVERROR_EOF) {\n\n                av_free(buf);\n\n                return ret;\n\n            }\n\n            score = 0;\n\n            ret = 0;            /* error was end of file, nothing read */\n\n        }\n\n        pd.buf_size += ret;\n\n        pd.buf = &buf[offset];\n\n\n\n        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n\n\n\n        /* guess file format */\n\n        *fmt = av_probe_input_format2(&pd, 1, &score);\n\n        if(*fmt){\n\n            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration\n\n                av_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n\n            }else\n\n                av_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n\n        }\n\n    }\n\n\n\n    if (!*fmt) {\n\n        av_free(buf);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* rewind. reuse probe buffer to avoid seeking */\n\n    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);\n\n\n\n    return ret;\n\n}\n", "idx": 5357, "substitutes": {"pb": ["abb", "wb", "pc", "lb", "vp", "ab", "db", "ppa", "bf", "pg", "sb", "pl", "tp", "p", "bm", "api", "client", "pa", "dp", "fb", "pm", "bc", "ctx", "apy", "platform", "wp", "pkg", "fc", "PB", "lp", "tc", "bh", "uf", "bp", "xb", "rb", "cb", "fp", "pd", "cpp", "rob"], "fmt": ["fMT", "fnt", " frt", "sfnt", "fformat", "cfrt", "sfMT", "sfformat", "frt", "cfmt", "cfformat", "Fformat", "cfMT", "sfmt", "Fmt", " fformat", "FMT", "Fnt", " fnt", " fMT", "Frt"], "filename": ["jpg", "wb", "fn", "wav", "header", "phrase", "url", "Filename", "name", "binary", "document", "nil", "tty", "open", "metadata", "username", "file", "files", "txt", "fd", "word", "fil", "kl", "which", "buffer", "f", "enabled", "path", "prefix", "utf", "size", "xff", "rb", "attr", "length", "null", "dll", "brush", "fp", "title", "method", "directory", "format"], "logctx": ["logfn", "evkb", "logprefix", "evctx", "evprefix", "debugfn", "evfn", "catfn", "debugprefix", "catctx", "catprefix", "debugkb", "debugctx", "catkb", "logkb"], "offset": ["pos", "index", "reset", "ref", "area", "number", "end", "optional", "error", "loc", "limit", "name", "len", "op", "Offset", "base", "order", "position", "off", "skip", "mode", "layer", "alpha", "address", "pointer", "shift", "range", "location", "padding", "start", "attribute", "phase", "part", "slot", "i", "o", "size", "prefix", "origin", "fee", "bound", "timeout", "length", "alias", "addr", "ptr", "fp", "align", "zero", "format"], "max_probe_size": ["max_prober_small", "max_probe\u00b7size", "max_prober_size", "max_probe_capacity", "max_probe_code", "max_probe_offset", "max_prober_width", "max_prober_storage", "max_probe_scale", "max_prober_offset", "max_prove_scale", "max_probe1capacity", "max_probe2speed", "max_probe\u00b7storage", "max_prober_capacity", "max_probe_storage", "max_prober__scale", "max_probe_small", "max_probe\u00b7name", "max_probe2size", "max_probe_width", "max_prove_size", "max_probe__size", "max_prove_num", "max_probe1size", "max_probe__code", "max_probe_name", "max_probe_num", "max_probe__scale", "max_probe2storage", "max_probe_sized", "max_prober__code", "max_prove_capacity", "max_probe_speed", "max_prober_scale", "max_prober_code", "max_prober_name", "max_prove_sized", "max_prober_speed", "max_probe1small", "max_prober__size"], "buf": ["batch", "data", "pool", "br", "uc", "wb", "rc", "header", "func", "ru", "bag", "proc", "pub", "conv", "fn", "result", "queue", "loc", "Buffer", "uber", "fi", "src", "seq", "ux", "img", "box", "msg", "config", "fam", "dest", "vec", "cmd", "fw", "fb", "runner", "usr", "block", "buff", "fd", "home", "ctx", "tmp", "bc", "bg", "buffer", "cur", "ctrl", "prop", "Buff", "prof", "cv", "pkg", "feat", "cache", "alloc", "cf", "comb", "cap", "bd", "uf", "abb", "ff", "rb", "cas", "cb", "font", "fp", "cp", "feed", "ptr", "output", "port"], "probe_size": ["prose_source", "procer_storage", "probe__source", "prober_engine", "prose_unit", "provision_scale", "procel_source", "probe_offset", "probi\u00b7weight", "procer_size", "probe__name", "prote_type", "procel_weight", "prober_offset", "probi_size", "provisionsize", "prose_name", "prouse_ize", "prose__unit", "probi\u00b7rate", "prose__name", "probe__size", "probe_speed", "prouse_address", "probi_weight", "probe\u00b7size", "prob_form", "provision_ize", "provision_size", "probe_capacity", "prose_size", "prote_name", "probesize", "probi_rate", "probe_number", "probe_len", "prose__source", "prouse_size", "procel_speed", "probe_unit", "prober_number", "provisionsscale", "prober_size", "prose__size", "procer_capacity", "probe_ize", "probessize", "probe_weight", "probe\u00b7shape", "prote_address", "probesscale", "procel_size", "probe_scale", "procel_page", "probe_form", "probe\u00b7rate", "probe_page", "probe_rate", "prob_size", "probe_source", "probe\u00b7engine", "probe_name", "procel_len", "procer_ize", "prob_scale", "probe\u00b7weight", "prober_id", "probe_id", "probe_engine", "probe_type", "prob_speed", "probe_address", "provisionssize", "prote_size", "prober_shape", "probi\u00b7size", "probe__unit", "probe_shape", "procel_capacity", "prouse_scale", "probe_storage"], "buftmp": ["buftcmp", "buctm", "bufortMP", "bufortpl", "buaftyp", "buftap", "buftep", "bufyp", "fuaftMP", "buktmp", " buctape", "fuftMP", "buaftmp", "bustpl", " buctep", " buctcmp", "fuaftpl", "fuftpl", "buktep", "buktap", "buptcmp", "buctcmp", "buktyp", "buktape", " buctyp", "buptmp", "buktm", "buptyp", " buftcp", "buftpl", "buctep", "buaftpl", " buftcmp", "buftcp", "fuftyp", " buftep", "buctap", "buktcp", "buaftap", "buaftep", "buctcp", "bufortyp", "buftMP", "buftyp", "buctmp", " buftm", "buctape", " buftape", " buftyp", " buctap", "fuaftmp", "buftape", " buctmp", "bufcp", "bustmp", "bufmp", "bustMP", "buaftm", " buctcp", "buftm", "buctyp", " buctm", "bustyp", "buktcmp", "fuaftyp", "bufape", "bufortmp", "fuftmp", " buftap", "buptcp", "buaftMP"]}}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 5361, "substitutes": {"s": ["iss", "y", "sites", "uses", "sq", "aws", "j", "e", "d", "sb", "self", "p", "sync", "spec", "sys", "ls", "session", "S", "is", "ps", "full", "ses", "site", "gs", "cs", "this", "service", "u", "ds", "xs", "ims", "stats", "n", "l", "states", "sets", "ops", "ss", "m", "c", "ts", "t", "sg", "services", "sym", "uns", "fs", "g", "ns", "us", "r", "ssl", "south", "se", "sl", "o", "sis", "less", "state", "js", "b", "es", "sv", "su", "http", "ins", "qs", "rs", "si"], "mon": ["date", "mo", "mail", "pos", "on", "mt", "db", "mer", "mm", "mat", "fun", "sun", "pre", "tom", "mem", "mons", "mid", "sm", "mut", "MON", "pid", "ann", "un", "mi", "conn", "type", "tun", "module", "cm", "unit", "config", "num", "month", "mn", "lo", "man", "sym", "m", "mode", "danger", "pm", "ms", "chron", "mag", "min", "en", "den", "Mon", "bin", "ln", "my", "non", "lin", "mu", "emon", "mun", "col", "con", "conf", "lock"], "exported_dir": ["exported_mode", "exped_path", "exped_directory", "exported_directory", "exported_path", "exported_file", "exped_mode", "exped_dir", "exped_file", "exported_dict", "exped_dict"], "vserver_addr": ["vserver_port", "vserver2address", "vserveraddrport", "vserveraddraddr", "vserver_dir", "vserveraddrblock", "vserver_address", "vserver2addr", "vserver_block", "vserver2block", "vserveraddraddress", "vserver2port", "vserver2dir"], "instance": ["performance", "index", "member", "section", "result", "name", "error", "example", "trace", "connection", "type", "client", "record", "image", "offset", "fff", "month", "stage", "child", "class", "mode", "ance", "version", "micro", "array", "inst", "master", " inst", "parent", "i", "Instance", "project", "usage", " i", "node", "method", "thread", "port"], "smb_conf": ["semb__conf", "sbb_aff", "sbb_con", "smb_con", "smb__dir", "smb_cmp", "smb2con", "smb__conf", "smbpsum", "semb__dir", "sbb_conn", "smb_conv", "smb2conn", "smb__ref", "smb__aff", "sbb_cmp", "semb_ref", "semb__con", "smb_aff", "smb_Conf", "sbb_conf", "smbpconf", "smb_config", "smb_sum", "sfb_conf", "smb_def", "sfb_config", "sfb_con", "smb__con", "smb_conn", "smbpconv", "smb2Conf", "sfb_dir", "smb_dir", "samb_conf", "samb_conv", "samb_sum", "smbpdir", "smb__cmp", "smb_ref", "samb_dir", "semb_con", "smb__Conf", "smb2conf", "semb_conf", "semb__ref", "sbb_Conf", "sfb_def", "semb_dir"], "smb_cmdline": ["smb2msgl", "smbbcmdl", "smbbcmdlate", "smb_defline", "smbblogline", "smb2cmdname", "smb_deflin", "smb_cleanline", "smb2cmdLine", "smb_msgline", "smb_commandlin", "smb2cmdl", "smb_shortline", "smb2msgline", "smb_commandLine", "smb_cleanstring", "smb_deflc", "smb_cmdLine", "smb2msgLine", "smb_cmdlin", "smb_cmdl", "smb_loglate", "smb_commandline", "smb_logline", "smb_msglate", "smb_commandlate", "smb_commandname", "smbbcmdline", "smb_cmdname", "smb_cmdlc", "smb_commLINE", "smb_cleanLINE", "smb_commandLINE", "smb_commandlc", "smb_shortLine", "smb_defl", "smb_cmdlate", "smb_shortl", "smbbloglate", "smb_msgl", "smb_commandl", "smb_msgLine", "smb2msgname", "smb_shortname", "smb_cmdLINE", "smb_commstring", "smb_commandstring", "smb2cmdline", "smb_msgname", "smbblogl", "smb_cmdstring", "smb_logl", "smb_commline"], "f": ["xf", "form", "fn", "fa", "y", "j", "e", "bf", "d", "fx", "fo", "fi", "fe", "p", "rf", "df", "of", "h", "F", "r", "u", "sf", "fw", "fb", "file", "l", "n", "files", "fd", "c", "m", "fu", "t", "fen", "fs", "g", "fit", "fc", "info", "w", "i", "cf", "o", "fr", "b", "fp", "feed", "v", "x"]}}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "substitutes": {"env": ["context", "cfg", "nc", "ext", "rc", "eu", "np", "proc", "db", "loader", "e", "queue", "enc", "exc", "exec", "ea", "server", "conn", "ep", "ev", "config", "viron", "et", "ef", "obj", "txt", "net", "init", "eng", "engine", "ctx", "dc", "console", "Environment", "ec", "en", "network", "ini", "global", "kn", "dev", "manager", "gui", "inet", "eni", "qt", "conf", "v", "environment"], "vaddr": ["tvconfig", "phost", " vconfig", "vadd", "pptr", "qptr", "fdr", "Vdr", "padd", "qhost", " vserver", "foffset", "qaddr", "faddr", "fhost", "fptr", "pdr", "vserver", " vadd", "vhost", "zaddr", " voffset", "zaddress", "whost", "tvserver", "voffset", "vconfig", "qaddress", "pserver", "wadd", "vptr", "zhost", " vhost", "pconfig", "faddress", "Vaddr", "waddr", "Vaddress", " vaddress", "vaddress", "zptr", "vdr", " vdr", "tvaddress", "Voffset", "waddress", "tvaddr", "paddress"], "paddr": [" poffset", "valign", " palign", "vadd", "pptr", "vpptr", "padd", "poffset", "vpaddress", " pptr", "faddr", "npaddr", "palign", "vpoffset", "npairs", "fmode", "npoffset", "pyoffset", "fadd", "vpairs", " voffset", " vairs", "voffset", "pairs", "pyaddress", " paddress", " padded", "vptr", "padded", "npaddress", " pmode", "vmode", "faddress", "pyaddr", " vaddress", "pmode", "vaddress", " padd", "vpaddr", "vpalign", "pyadded", "vadded", "paddress"], "prot": ["ext", "reset", "np", "conv", "eth", "sil", "ocol", "typ", "cli", "rx", "rf", "thin", "config", "ret", " proto", "pro", "inf", "dim", "rot", "lo", "fen", "period", "lat", "Prot", "platform", "prop", "lit", "bis", "nat", "phy", "iol", "prefix", "uri", "inet", "rin", " protocol", "pri", "addr", "fp", "fl", "stat"], "mmu_idx": ["mmu_idy", "mmu_indf", "mmu_idg", "mmu_idsy", "mmu_idsv", "mmu_indb", "mmu_sidx", "mmu_sidxc", "mmu_sidf", "mmu_sidg", "mmu_idv", "mmu_sidv", "mmu_indg", "mmu_idsxc", "mmu_ridy", "mmu_idsx", "mmu_ridxc", "mmu_idf", "mmu_sidb", "mmu_idb", "mmu_ridx", "mmu_idxc", "mmu_sidy", "mmu_indx", "mmu_ridv"], "size": ["data", "ffff", "sum", "storage", "sec", "small", "number", "scale", "name", "loc", "value", "limit", "len", "offset", "SIZE", "empty", "bytes", "password", "large", "class", "ize", "c", "sized", "Size", "capacity", "page", "sn", "max", "en", "security", "global", "memory", "uri", "code", "cap", "fee", "z", "shape", "length", "desc", "timeout", "count", "unit", "si"], "p": ["pb", "pi", "pc", "np", "j", "vp", "pre", "e", "d", "pg", "tp", "sync", "api", "h", "ps", "pr", "r", "pa", "dp", "sp", "pn", "P", "n", "l", "ap", "jp", "c", "t", "pm", "f", "page", "pp", "point", "pkg", "parent", "i", "o", "w", "lp", "python", "pe", "bp", "b", "po", "fp", "cp", "v"], "pd": ["pos", "pc", "pi", "np", "da", "od", "ppa", "d", "lda", " delta", "dt", "pod", " prod", "std", "slice", "api", "dep", "pad", "pr", "dp", "sha", " da", "dim", "pattern", "nd", "lp", "bd", "pe", "pard", " dd", "wd", "pb", "vd", "xd", "pins", "att", "dh", "mode", "dc", "adh", "cd", "pat", "pg", " rc", "wordpress", " td", " sd", "plugin", "fd", "gd", "hd", "pp", "ad", "python", "delay", "si", "dat", "py", "sth", "php", "dra", "tp", "pid", "pa", "ds", "ped", "dd", "pm", "wa", "PD", "dl", "md", "sd", "edd", "po", "priority", "td", "ld"], "index": [" indexes", "pos", "ffff", "pc", "loc", "len", "val", "byte", "fe", "slice", "type", "position", "Index", "config", "pattern", "ion", "dc", "pointer", "part", "bin", "ci", "length", "count", "si", "base"], "address": ["object", "ress", "area", "number", "package", "element", "region", "message", "adjust", "server", "event", "pair", "Address", "order", "ace", "image", "offset", "module", "position", "password", "ip", "enter", "entry", "host", "pointer", "capacity", "point", "location", "array", "attribute", "network", "reference", "prefix", "memory", "uri", "code", "route", "shape", "node", "state", "alias", "addr", "resource", "output", "adr", "port"], "code_address": ["codeoutnumber", "codeouthost", "code2reference", "code_host", "code_location", "cache_host", "cache_number", "cache_address", "data_location", "code_reference", "data_addr", "cache_reference", "code_addr", "code_number", "code2address", "codeoutreference", "codeoutaddress", "data_address", "code2host", "code2number"], "addend": [" addending", "readest", "addending", " addends", "loadends", "loadend", " addest", "loadending", "Addends", "Addend", "addends", " addpath", "addstart", "Addpath", " addstart", "readend", "readends", "pushends", "pushending", "pushstart", "addest", "Addest", "pushend", "loadstart", "addpath", "readpath"], "te": ["ext", "eu", "au", "de", "e", "slave", "pl", "fe", "ep", "ue", "ne", "ffe", "inf", "txt", "ss", "ta", "tw", "oe", "inst", "ette", "we", "se", "fee", "eni", "ite", "oss", "ee", "port"], "wp": ["pb", "wb", "pc", "np", "php", "vp", "wm", "pg", "tp", "widget", "op", "wx", "pod", "api", "wordpress", "mp", "kw", "ep", "dp", "fw", "pn", "plugin", "jp", "wl", "ip", "hp", "ctx", "dc", "WP", "pp", "hop", "wu", "gp", "hw", "iw", "w", "xp", "lp", "bp", "arp", "fp", "cp", "wk"], "iotlb": ["ietlas", "bootlb", "ontlb", "ietb", "iottb", "iotlp", "otlb", "iollab", "iottlas", "ittl", "otl", "youtla", "ontl", "ietlab", "nitrb", "iotlr", "ietll", "otb", "iotla", "iollas", "ontll", "otrb", "nitl", "iotl", "iottlb", "youtlb", "ietlb", "ietlr", "cotl", "cotlp", "bootl", "ietlp", "otlab", "otlr", "iottlab", "cotlas", "ontlp", "iottlp", "iotlas", "youtl", "ietla", "nitlp", "iottlr", "ittlb", "youtlp", "iotll", "cotlb", "ietl", "ioll", "bootlab", "nitla", "bootlas", "ittlp", "nitlb", "iottl", "iollb", "ietrb", "iotrb", "otlas", "iotb", "iotlab", "ittll", "otlp"]}}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "func": "void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,\n\n                         const uint32_t *intbit_to_level,\n\n                         qemu_irq **irq, qemu_irq **cpu_irq,\n\n                         unsigned int cputimer)\n\n\n\n{\n\n    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;\n\n    SLAVIO_INTCTLState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->intbit_to_level = intbit_to_level;\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n\tslavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);\n\n\tcpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,\n\n                                     slavio_intctl_io_memory);\n\n    }\n\n\n\n    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);\n\n    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);\n\n\n\n    register_savevm(\"slavio_intctl\", addr, 1, slavio_intctl_save, slavio_intctl_load, s);\n\n    qemu_register_reset(slavio_intctl_reset, s);\n\n    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);\n\n\n\n    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);\n\n    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];\n\n    slavio_intctl_reset(s);\n\n    return s;\n\n}\n", "idx": 5386, "substitutes": {"addr": ["data", "pos", "nc", "rc", "index", "oa", "ei", "ref", "name", "e", "ast", "ord", "call", "mx", "p", "afi", "arm", "args", "base", "src", "amd", "Address", "conn", "ace", "seq", "offset", "r", "config", "device", "cmd", "at", "id", "ip", "c", "add", "ix", "address", "host", "g", "mac", "nr", "sta", "ad", "ar", "gate", "x", "amp", "code", "dr", "arch", "eni", "node", "alias", "ptr", "work", "ld", "adr", "asm"], "addrg": ["addressG", "hostG", "drgp", "aimgp", "adrg", "drG", "addressgi", "addrgp", "ACEgp", "adrG", "adrgi", "addrG", "hostg", "drg", "aimg", "ACEG", "hostgi", "ACEg", "addrgi", "addressg", "aimG"], "intbit_to_level": ["intbit_to_vel", "intbit_from_vel", "intbit_from_layer", "intbit_to_left", "intbit_to_log", "intbit_from_log", "intbit_to_layer", "intbit_from_level", "intbit_from_left"], "irq": ["irp", "irecharge", " irqs", " irqa", "ierqa", " irquest", "iercharge", "arqs", "ierq", "ireqa", "arv", "arq", " irp", "irep", "irv", "ierquest", "irev", " ircharge", " irv", "irqa", "ireqs", "irequest", "arp", "irquest", "ireq", "irqs", "ircharge"], "cpu_irq": ["cpu_arf", "cpu_irQ", "cpu_IRf", "cpu_irqu", "cpu_IRqu", "cpu_rrquest", "cpu_arq", "cpu_irf", "cpu_IRQ", "cpu_arqs", "cpu_iperf", "cpu_iperqs", "cpu_iperQ", "cpu_IRqs", "cpu_irquest", "cpu_rrq", "cpu_arQ", "cpu_IRquest", "cpu_irqs", "cpu_IRq", "cpu_rrqs", "cpu_rrqu", "cpu_iperq"], "cputimer": ["cptier", "cperer", "cptiver", " cptimer", " cputer", "cputim", "cPUTiper", "cPUTim", " cptier", " cputim", "cputer", "cperiper", "cmultiplier", "cptiper", "cmultipler", "cmultiplimer", "cputiper", "cpter", "cputiver", " cputier", "ccter", "cptim", "cPUTimer", "cptimer", " cputiver", " cPUTimer", "cctiver", " cputiper", " cPUTim", "cctier", " cPUTiper", " cpter", "cPUTer", "cmultipliver", "cctimer", "cputier", " cPUTer", "cperimer", "cperim", " cptiver"], "slavio_intctl_io_memory": ["slavio_intctl_io_write", "slavio_intctl_system_mem", "slavio_intctl_system_cache", "slavio_intctl_auto_memory", "slavio_intctl_io_cache", "slavio_intctl_io_mem", "slavio_intctl_storage_mem", "slavio_intctl_system_memory", "slavio_intctl_auto_cache", "slavio_intctl_auto_mem", "slavio_intctl_storage_memory", "slavio_intctl_storage_write", "slavio_intctl_system_write"], "slavio_intctlm_io_memory": ["slavio_intctlm_storage_cache", "slavio_intctlm_no_mem", "slavio_intctlm_no_cache", "slavio_intctlm_io_size", "slavio_intctlm_io_cache", "slavio_intctlm_auto_cache", "slavio_intctlm_no_capacity", "slavio_intctlm_storage_memory", "slavio_intctlm_storage_size", "slavio_intctlm_storage_mem", "slavio_intctlm_io_device", "slavio_intctlm_io_mem", "slavio_intctlm_no_memory", "slavio_intctlm_io_capacity", "slavio_intctlm_auto_device", "slavio_intctlm_auto_mem", "slavio_intctlm_auto_memory"], "i": ["ui", "index", "pi", "k", "j", "di", "e", "d", "multi", "fi", "ti", "p", "yi", "uli", "slice", "mi", "phi", "qi", "ii", "u", "ji", "id", "n", "l", "ni", "ip", "dim", "abi", "m", "c", "t", "ix", "oi", "f", "zi", "ri", "ini", "info", "o", "w", "gi", "x", "xi", "mu", "uri", "ci", "eni", "z", "b", "iu", "I", "ai", "v", "si", "li"], "s": ["set", "sample", "d", "sync", "sports", "args", "site", "sg", "services", "fs", "f", "has", "b", "in", "groups", "conf", "v", "south", "new", "sites", "sq", "sb", "h", "ses", "r", "cs", "u", "sf", "ss", "ts", "t", "ns", "sa", "a", "w", "its", "less", "sw", "es", "http", "hs", "storage", "small", "sys", "self", "p", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "n", "rows", "c", "g", "us", "ssl", "sl", "su", "rs", "si", "spec", "x", "scope", "func", "e", "server", "socket", "is", "client", "service", "ds", "l", "states", "sym", "m", "settings", "o", "secondary", "z", "js", "os", "ips"]}}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 5408, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "fc5a905a6d0c76d9fb8d838ac83f6219a7a5e20f", "target": 0, "func": "static void start_children(FFStream *feed)\n\n{\n\n    if (no_launch)\n\n        return;\n\n\n\n    for (; feed; feed = feed->next) {\n\n        if (feed->child_argv && !feed->pid) {\n\n            feed->pid_start = time(0);\n\n\n\n            feed->pid = fork();\n\n\n\n            if (feed->pid < 0) {\n\n                http_log(\"Unable to create children\\n\");\n\n                exit(1);\n\n            }\n\n            if (!feed->pid) {\n\n                /* In child */\n\n                char pathname[1024];\n\n                char *slash;\n\n                int i;\n\n\n\n                av_strlcpy(pathname, my_program_name, sizeof(pathname));\n\n\n\n                slash = strrchr(pathname, '/');\n\n                if (!slash)\n\n                    slash = pathname;\n\n                else\n\n                    slash++;\n\n                strcpy(slash, \"ffmpeg\");\n\n\n\n                http_log(\"Launch command line: \");\n\n                http_log(\"%s \", pathname);\n\n                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n\n                    http_log(\"%s \", feed->child_argv[i]);\n\n                http_log(\"\\n\");\n\n\n\n                for (i = 3; i < 256; i++)\n\n                    close(i);\n\n\n\n                if (!ffserver_debug) {\n\n                    i = open(\"/dev/null\", O_RDWR);\n\n                    if (i != -1) {\n\n                        dup2(i, 0);\n\n                        dup2(i, 1);\n\n                        dup2(i, 2);\n\n                        close(i);\n\n                    }\n\n                }\n\n\n\n                /* This is needed to make relative pathnames work */\n\n                chdir(my_program_dir);\n\n\n\n                signal(SIGPIPE, SIG_DFL);\n\n\n\n                execvp(pathname, feed->child_argv);\n\n\n\n                _exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 5416, "substitutes": {"feed": ["allow", "form", "reader", "pub", "end", "url", "control", "rss", "Feed", "input", "build", "fed", "circ", "hub", "throw", "row", "server", "report", "event", "raw", "df", "zip", "flow", "full", "channel", "image", "bug", "bb", "config", "blog", "file", "connect", "read", "inf", "follow", "accept", "child", "fd", "load", "feeding", "keep", "skip", "add", "entry", "run", "host", "f", "food", "source", "page", "pass", "comment", "draw", "model", "parent", "cache", "fc", "insert", "sl", "cook", "cf", "loop", "ga", "valid", "gen", "post", "wait", "stream", "sel", "pull", "update"], "pathname": [" Pathnames", " pathno", "fulln", "athname", "Pathpath", "pathlen", "filenamed", "fileName", " Pathnam", " Pathname", "partname", "athnamed", "pathName", "Pathstart", "pitnamed", "pathnamed", " pathnames", "pathno", "partpath", "pitname", "Pathnames", "athName", "PathName", "hostname", "Pathlen", " pathlen", "partn", "fullstart", "Pathn", " pathnam", "fileno", "Pathnam", " pathName", " pathstart", "Pathname", "fullpath", "pathn", "athpath", "athno", " Pathno", "hostName", "Pathno", " pathn", "partName", "pathnames", "fullname", "filename", "filen", "pitn", "hostno", "athn", "hostlen", " pathpath", "fullName", "pathpath", "pathstart", "pathnam"], "slash": ["flat", "splashed", "clASH", "slASH", "SLlash", "splitch", "plah", "Sllash", "plashes", "clash", "SlASH", "plat", "splah", "clah", "plashed", "Slitch", "Slah", "plashing", "SLash", " slASH", "Slash", "slat", "glug", " slitch", "swashing", "spllash", "glashing", "SLashed", "sllash", "splat", " sllash", "slashing", "flashing", "slitch", "Slashing", "SLug", "plash", "slashes", "glash", "splashing", "Slashed", "clashed", " slashed", "Slug", "glashed", "clashes", "swash", "slug", "flah", "swashed", "slashed", " slashes", "swug", "flash", "Slashes", "slah", "splash", " slug"], "i": ["bi", "pi", "index", "one", "name", "d", "multi", "ti", "api", "slice", "qi", "hi", "inner", "id", "ip", "init", "zi", "mu", "uri", "b", "in", "v", "li", "ui", "iii", "ie", "ei", "diff", "mini", "key", "cli", "ii", "u", "abi", "ix", "a", "ini", "code", "isi", "iu", "ai", "p", "connection", "n", "c", "g", "oi", "io", "gi", "it", "I", "x", "si", "split", "y", "j", "di", "e", "fi", "yi", "is", "phi", "ni", "l", "m", "ri", "info", "o", "xi", "ci", "eni", "z", "esi"]}}
{"project": "FFmpeg", "commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "target": 1, "func": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    int i, j;\n\n\n\n    if (!mov->fragment_index_complete)\n\n        return 0;\n\n\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n\n        if (mov->fragment_index_data[i]->track_id == st->id) {\n\n            MOVFragmentIndex *index = index = mov->fragment_index_data[i];\n\n            for (j = index->item_count - 1; j >= 0; j--) {\n\n                if (index->items[j].time <= timestamp) {\n\n                    if (index->items[j].headers_read)\n\n                        return 0;\n\n\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5429, "substitutes": {"s": ["an", "sci", "storage", "sec", "sq", "e", "si", "sb", "server", "self", "sys", "p", "ks", "src", "ls", "sc", "ses", "support", "cs", "gs", "sets", "service", "ds", "stats", "states", "ops", "ss", "c", "m", "ts", "services", "v", "ctx", "t", "sg", "sym", "g", "f", "ns", "us", "ssl", "rs", "se", "sl", "w", "sw", "sv", "js", "su", "es", "b", "http", "os", "qs", "south", "spec"], "st": ["ste", "stable", "storage", "sth", "stack", "sam", "ast", "sb", "str", "std", "src", "sm", "ost", "sc", "sp", "est", "stage", "sts", "St", "ss", "c", "rest", "sh", "step", "t", "cr", "station", "sa", "inst", "start", "sn", "sta", "sl", "state", "sd", "sv", "td", "ST", "si"], "timestamp": ["impoint", "timcast", "scheestamp", "timetime", "Timestamp", "Timetime", "imest", "imetime", "timest", "scheest", "imestamp", "timeest", "Timcast", "schecast", "Timest", "timeetime", "schepoint", "Timpoint", "timpoint", "timepoint", "timeestamp", "imcast"], "mov": ["Mocr", "mmov", "ymovi", "fov", "fove", "moc", "tmove", "amev", "mmocr", "ymoc", "tmrav", "amov", "Mov", " mev", "mrav", "mev", " mouf", "move", "Mrav", "imov", "ymove", "Moc", " move", "imocr", "mood", "pov", "tmov", "imev", "mouf", "amove", "pove", " movi", "fouf", "pood", "cmev", " moc", " mocr", "food", "cmoor", "pouf", "cmov", "Move", "tmocr", " moor", " mrav", "mmove", "cmove", "moor", "Movi", " mood", "amoor", "imove", "mocr", "ymov", "mmev", "movi"], "i": ["ui", "bi", "y", "pi", "k", "ie", "di", "e", "d", "si", "multi", "ti", "p", "yi", "api", "h", "is", "mi", "qi", "ii", "r", "ki", "u", "ji", "ind", "id", "n", "l", "ni", "ip", "c", "m", "ix", "oi", "f", "g", "zi", "io", "ri", "ini", "o", "gi", "xi", "uri", "eni", "ci", "b", "iu", "I", "ai", "v", "x", "li"], "j": ["bi", "br", "y", "k", "ie", "section", "aj", "e", "d", "jc", "p", "bj", "bl", "h", "jl", "num", "ij", "qi", "ne", "u", "off", "ji", "ind", "je", "n", "l", "jp", "dj", "obj", "jo", "m", "c", "t", "dy", "ix", "g", "f", "ja", "jj", "uj", "jet", "kj", "rev", "el", "journal", "jen", "json", "o", "it", "x", "xi", "fr", "ci", "job", "z", "js", "b", "adj", "q", "oj", "body", "v", "ld", "J", "si", "li"], "index": ["complete", "data", "context", "date", "new", "form", "header", "url", "section", "diff", "value", "element", "input", "e", "name", "document", "key", "open", "sync", "slice", "connection", "search", "type", "style", "full", "conn", "inc", "image", "module", "Index", "config", "pull", "ind", "id", "n", "connect", "block", "instance", "ion", "version", "entry", "run", "alpha", "lead", "action", "f", "page", "sort", "comment", "inst", "point", "author", "master", "group", "initial", "cache", "info", "table", "part", "match", "script", "item", "level", "pack", "node", "fix", "body", "output", "update", "x"]}}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5430, "substitutes": {"track": ["complete", "form", "note", "rack", "play", "component", "coll", "trace", "call", "report", "event", "grade", "sync", "metadata", "type", "agg", "gg", "record", "test", "order", "module", "edit", "ack", "config", "tt", "tracking", "Track", "rr", "follow", "txt", "step", "layer", "tr", "gap", "sort", "roll", "tm", "comment", "model", "ride", "group", "info", "project", "match", "trial", "toggle", "route", "sound", "attr", "node", "setup", "round", "feed", "cross", "transform", "tracks", "token", "port"], "pb": ["pool", "wb", "pc", "lb", "np", "lab", "proc", "vp", "cp", "ab", "db", "bf", "pg", "sb", "pl", "hub", "tp", "p", "bm", "api", "mp", "buf", "pa", "dp", "lib", "plugin", "fb", "jp", "obj", "pm", "bc", "ctx", "buffer", "summary", "ib", "platform", "eb", "pkg", "wp", "fc", "PB", "lp", "loop", "bh", "uf", "lc", "bp", "rb", "xb", "fp", "bps", "cpp", "prot", "rob"], "tag": ["date", "brand", "name", "loc", "key", "event", "type", "bit", "test", "image", "bug", "ack", "patch", "reg", "month", "block", "word", "class", "step", "gap", "comment", "attribute", "tick", "feat", "match", "code", "category", "Tag", "TAG", "ag", "feature", "round", "year", "method", "tags", "token"]}}
{"project": "FFmpeg", "commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "target": 1, "func": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n\n{\n\n    int ret = 0;\n\n    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        AVInputFormat *iformat;\n\n\n\n        if (!buf)\n\n            return AVERROR(ENOMEM);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n\n\n        if (!(iformat = av_find_input_format(\"asf\")))\n\n            return AVERROR_DEMUXER_NOT_FOUND;\n\n\n\n        rt->asf_ctx = avformat_alloc_context();\n\n        if (!rt->asf_ctx) {\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n\n\n        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {\n\n            av_dict_free(&opts);\n\n            return ret;\n\n        }\n\n\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0) {\n\n            av_free(buf);\n\n            return ret;\n\n        }\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 5437, "substitutes": {"s": ["root", "storage", "sq", "e", "d", "sb", "server", "self", "sys", "spec", "args", "ls", "session", "S", "client", "ps", "sc", "h", "ses", "cs", "r", "gs", "service", "u", "ds", "sf", "stats", "n", "ops", "ss", "c", "sg", "init", "t", "services", "ctx", "m", "sr", "fs", "g", "ns", "f", "parser", "sa", "us", "a", "ssl", "sl", "w", "o", "sv", "su", "b", "es", "http", "os", "serv", "v", "rs", "si"], "p": ["data", "pat", "pos", "pc", "np", "proc", "vp", "e", "d", "input", "pl", "tp", "api", "h", "ps", "pr", "r", "pa", "u", "sp", "P", "jp", "n", "l", "m", "c", "t", "ctx", "pt", "f", "pp", "padding", "prop", "a", "wp", "i", "o", "lp", "pe", "bp", "b", "post", "q", "fp", "cp", "v", "base"], "pb": [" PB", "root", "wb", "pool", " subp", "pc", "lb", "np", "ref", "gb", "vp", "db", "ab", "bf", "pg", "sb", "pl", "tp", "typ", "mb", "bm", "api", "src", " rc", "mp", "client", "username", "r", " eb", "dp", "meta", " proto", "fb", "tx", "TB", "obj", "buff", "txt", "abc", "ctx", "bc", "tmp", "buffer", "summary", "pd", "ib", "kb", "platform", "eb", "gp", "pkg", "i", "fc", " db", "prefix", "PB", "lp", "tc", "bh", "uf", "bp", "rb", "b", "attr", "cb", "bs", "fp", "cp", "prot", "rob"], "rt": ["RT", "ru", "rc", "mt", "att", "vr", "yt", "tp", "dt", "typ", "xt", "rf", "rh", "dat", "NT", "conn", "ct", "rob", "r", "tt", "irt", "ret", "rr", "tx", "rn", "rot", "ut", "txt", "sr", "gd", "rd", "raf", "t", "boot", "pt", "tr", "art", "ird", "kt", "nd", "vt", "ort", "pit", "rat", "BT", "gt", "ft", "fr", "nt", "dr", "apt", "rb", "rl", "qt", "ot", "rin", "urt", "bt", "ant", "ht", "rs", "Ret", "adr"], "opts": ["otters", "deft", "optt", "opter", "optTS", "defts", "OPtt", " optTS", "optments", "OPcs", "optrs", "opTS", "ropters", " optts", "OPts", "optter", "opments", " optuts", "optuts", "optns", "OPters", "otTS", "optionns", "opttt", "otments", "OPs", "optionts", "ropments", "opns", "opttr", "deftt", "ops", "optts", "oputs", "defs", " optrs", "opters", "opt", "opcs", "OPns", "ropts", "otuts", " opcs", "optionters", "ropter", "otter", "oprs", "otrs", "optr", "optcs", " optr", "optiont", "OPtr", "OPt", " opt", "optters", "otts"], "buf": ["data", "context", "wb", "func", "uc", "rc", "lb", "br", "ref", "bag", "conv", "gb", "proc", "queue", "loc", "sb", "Buffer", "len", "val", "fi", "src", "h", "seq", "box", "bytes", "vec", "cmd", "fw", "fb", "buff", "fd", "ba", "aux", "ctx", "tmp", "bc", "buffer", "Buff", "cv", "pkg", "req", "alloc", "cf", "cap", "bd", "uf", "bh", "la", "bp", "rb", "b", "cas", "cb", "fp", "cp", "fl", "base"], "iformat": ["iplat", "iformaton", "piraton", "inylater", "specificoat", "oidAT", "olidarat", "specificat", " uniformam", "iplaton", "ificAT", "ificant", "olidaton", "iformater", "pirarat", "iformoat", "iplant", "oidaton", "piroat", "inylat", "iformam", "inylant", "olidoat", "ivant", " uniformant", " uniformat", "olidat", "inylam", "ivat", "iformant", "oidant", " uniformater", "ificaton", "ificat", "iformAT", "iplAT", "pirat", "specificaton", "iformarat", "specificarat", "ivam", "oidat", "ivater"]}}
{"project": "FFmpeg", "commit_id": "9a3f10695a011861dcf5a649e3e72580b1a4eed4", "target": 1, "func": "static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                              int buf_size, void *data)\n\n{\n\n    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};\n\n    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};\n\n    RA144Context *ractx;\n\n    PutBitContext pb;\n\n    int32_t lpc_data[NBLOCKS * BLOCKSIZE];\n\n    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];\n\n    int shift[LPC_ORDER];\n\n    int16_t block_coefs[NBLOCKS][LPC_ORDER];\n\n    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */\n\n    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */\n\n    int energy = 0;\n\n    int i, idx;\n\n\n\n    if (buf_size < FRAMESIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n\n        return 0;\n\n    }\n\n    ractx = avctx->priv_data;\n\n\n\n    /**\n\n     * Since the LPC coefficients are calculated on a frame centered over the\n\n     * fourth subframe, to encode a given frame, data from the next frame is\n\n     * needed. In each call to this function, the previous frame (whose data are\n\n     * saved in the encoder context) is encoded, and data from the current frame\n\n     * are saved in the encoder context to be used in the next function call.\n\n     */\n\n    for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {\n\n        lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) {\n\n        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >>\n\n                      2;\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab,\n\n                                    32)];\n\n\n\n    ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,\n\n                      LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON,\n\n                      0, ORDER_METHOD_EST, 12, 0);\n\n    for (i = 0; i < LPC_ORDER; i++)\n\n        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] <<\n\n                                        (12 - shift[LPC_ORDER - 1]));\n\n\n\n    /**\n\n     * TODO: apply perceptual weighting of the input speech through bandwidth\n\n     * expansion of the LPC filter.\n\n     */\n\n\n\n    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {\n\n        /**\n\n         * The filter is unstable: use the coefficients of the previous frame.\n\n         */\n\n        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]);\n\n        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);\n\n    }\n\n    init_put_bits(&pb, frame, buf_size);\n\n    for (i = 0; i < LPC_ORDER; i++) {\n\n        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);\n\n        put_bits(&pb, bit_sizes[i], idx);\n\n        lpc_refl[i] = ff_lpc_refl_cb[i][idx];\n\n    }\n\n    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);\n\n    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);\n\n    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);\n\n    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,\n\n                            energy <= ractx->old_energy,\n\n                            ff_t_sqrt(energy * ractx->old_energy) >> 12);\n\n    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);\n\n    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);\n\n    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);\n\n    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));\n\n    for (i = 0; i < NBLOCKS; i++)\n\n        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,\n\n                              block_coefs[i], refl_rms[i], &pb);\n\n    flush_put_bits(&pb);\n\n    ractx->old_energy = energy;\n\n    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];\n\n    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);\n\n    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)\n\n        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;\n\n    return FRAMESIZE;\n\n}\n", "idx": 5452, "substitutes": {"avctx": ["avcontext", "avcu", "avconn", " avcontext", "AVpkg", "avmac", "ajcu", "AVmac", "afctx", " avmac", "avcf", "afcontext", " avtx", "ajcontext", "avtx", "akctx", "avpkg", "akcontext", "AVconn", "afconn", "AVtx", "afcu", "AVcontext", "ajcf", "AVcu", "akconn", "AVctx", "akpkg", "afcf", "aftx", "afpkg", "afmac", "ajctx", "AVcf"], "frame": ["context", "object", "family", "value", "element", "frames", "message", "document", "event", "slice", "flow", "type", "iframe", "image", "channel", "file", "block", "buffer", "Frame", "fram", "code", "state", "node", "time", "body", "window", "base"], "buf_size": ["box_small", "buf_capacity", "buf_ize", "buf_small", "box_size", "buf_no", " buf_capacity", " buf_SIZE", "box_SIZE", "buf_SIZE", "box_no", " buf_ize"], "data": ["batch", "ui", "power", "new", "ei", "sample", "di", "DATA", "value", "input", "result", "e", "d", "message", "Data", "ea", "byte", "buf", "image", "offset", "config", "bytes", "response", "block", "load", "alpha", "buffer", "next", "draw", "array", "ee", "a", "parent", "cache", "media", "o", "size", "memory", "length", "body", "window", "output", "format", "dat"], "sizes": ["size", "pizes", "Sources", "Size", "pources", "papes", "scapes", "scources", "sapes", "scizes", "scize", "Sizes", "Sapes", "sources", "pize"], "bit_sizes": ["bit_shigs", "bit_shize", "bit_fize", "bit_sumbers", "bit_shumbers", "bit_fumbers", "bit_nizes", "bit_numbers", "bit_nigs", "bit_fizes", "bit_nize", "bit_sigs", "bit_size", "bit_figs", "bit_shizes"], "ractx": ["hausty", "pullxx", "ctxe", "ortz", "haustx", "ractex", "antxs", "appx", "anty", "lateex", "ortxx", "antx", "ractionux", "incty", "ractorex", "latez", "racter", "ractioner", "ractz", "latexx", "ortx", "ractionxe", "ractxx", "ortex", "pullx", "ractiony", "ractory", "inctx", "latex", "ractxs", "ctex", "ctx", "hauster", "racty", "appxs", "pullex", "inctex", "appex", "appy", "ractorxs", "ractionex", "ortxe", "incter", "pullz", "ractxe", "haustex", "antex", "ractux", "ctux", "ortux", "ractorx", "ractionx"], "pb": [" PB", " CT", "pc", " subp", " ecc", " conf", " PA", " pl", " PL", " FC", "p", " prod", " mp", " rc", " pc", " eb", " proto", " macro", " app", "tx", " dup", " img", "PB", " cab", " impl", " plugin", " pa", " pu", " bc"], "lpc_data": ["lpcsdata", "lPC_block", "lfc_done", "lpm1window", "lpc1dat", "lpc_next", "lpcallcache", "lpc_memory", "lpc7data", "lfc_error", "lpm_window", "lpc_actions", "lpc_body", "lPC_data", "lpm_data", "lpcsmemory", "lPC_DATA", "lfc_memory", "lpc_error", "lpc_cache", "lpc_buffer", "lpcallresults", "lpc7memory", " l\n", "lpc1block", "lPC_actions", "L\n", "lpc7error", "lpc_DATA", "lpcswindow", "lpm1block", "lfc_dat", "lfc_results", "lpcallwindow", "lfc_next", "lpc_block", "lfc_body", "lpc_dat", "lpcsbuffer", "lpcsdat", "lpcsbody", "lpcsresults", "lfc_data", "lfc_cache", "lpm1data", "lpc_window", " L\n", "lpc1data", "lpcalldat", "lpc_done", "lfc_window", "lfc_buffer", "lpcallbody", "lpm1dat", "lpcalldata", "lpc1window", "lpc_results", "lpm_dat", "l\n", "lpm_block", "lpcallerror", "lpc7next"], "lpc_coefs": ["lpc_coffn", "lpc_coofsets", "lpc_coofs", "lpc_coffd", "lpc_coofn", "lpc_coofd", "lpc_coefsets", "lpc_coefn", "lpc_coeffd", "lpc_coffsets", "lpc_coeffn", "lpc_coeffsets", "lpc_coffs", "lpc_coefd", "lpc_coeffs"], "LPC_ORDER": ["LPC_ADDAR", "LPC_ORDERC", "LPC_ENDER", "LPC_NUMer", "LPC_ORER", "LPC_ENTR", "LPC_ORDBER", "LPC_GENER", "LPC_ORDAR", "LPC_ORDERS", "LPC_ANDER", "LPC_ENTer", "LPC_NUMERC", "LPC_ADDBER", "LPC_ANDBER", "LPC_ENTAR", "LPC_ENDAR", "LPC_ENTERS", "LPC_ORDR", "LPC_GENer", "LPC_ENDer", "LPC_ENDBER", "LPC_NUMBER", "LPC_ADDER", "LPC_ORer", "LPC_ORR", "LPC_ENDR", "LPC_ANDer", "LPC_ORDer", "LPC_ANDR", "LPC_ANDERS", "LPC_ORBER", "LPC_GENERC", "LPC_NUMER", "LPC_NUMR", "LPC_GENBER", "LPC_ENTBER", "LPC_ENDERS", "LPC_ADDer", "LPC_ENDERC", "LPC_ENTER"], "shift": ["ffff", "ress", "len", "raw", "offset", "hift", "size", " shifts", "align"], "block_coefs": ["block_coafs", "block_coeffn", "block_coefferences", "block_coafn", "block_coefn", "block_coffs", "block_coafsets", "block_coffsets", "block_cofferences", "block_coffn", "block_coeffsets", "block_coeffs", "block_coeferences", "block_coefsets", "block_coaferences"], "NBLOCKS": ["NPLACKSE", "NBLACKs", "NBLLOCKES", "NBLLOCKs", "NBLANKs", "NBLINKS", "NPLACKs", "NBLACKS", "NPLACKS", "NPLANKES", "NBLINKDS", "NBLINKTS", "NPLOCKDS", "NBLOCKTS", "NPLOCKs", "NPLACKTS", "NBLINKIDS", "NBLANKES", "NBLACKES", "NBLOCKIDS", "NPLANKS", "NBLANKDS", "NBLINKES", "NPLOCKTS", "NBLLOCKIDS", "NPLOCKES", "NBLLOCKS", "NPLANKIDS", "NBLOCKES", "NPLOCKSE", "NBLOCKs", "NBLANKS", "NPLANKDS", "NBLACKSE", "NBLINKSE", "NBLANKIDS", "NBLOCKSE", "NBLANKSE", "NPLACKES", "NBLACKDS", "NBLOCKDS", "NPLOCKS", "NBLACKTS", "NBLANKTS", "NPLOCKIDS", "NPLANKs", "NBLINKs"], "lpc_refl": ["lpc_prebl", "lpc_rell", "lpc_mll", "lpc_mbl", "lpc_recfl", "lpc_prefl", "lpc_recbl", "lpc_mfl", "lpc_prell", "lpc_rebl", "lpc_recll"], "refl_rms": ["refl_erms", "refl_rels", "refl_rtmb", "refl_ermb", "refl_remb", "refl_rtls", "refl_rems", "refl_remi", "refl_erls", "refl_ermi", "refl_rls", "refl_rtms", "refl_rmi", "refl_rmb", "refl_rtmi"], "i": ["ui", "bi", "y", "index", "pi", "ie", "ei", "j", "di", "diff", "field", "e", "si", "d", "mini", "key", "multi", "fi", "cli", "ti", "p", "yi", "api", "slice", "type", "h", "mi", "phi", "qi", "ii", "module", "hi", "u", "current", "inner", "ji", "id", "n", "ni", "l", "ip", "c", "m", "ix", "ori", "oi", "f", "g", "zi", "io", "source", "ri", "ini", "info", "my", "it", "gi", "xi", "mu", "uri", "iv", "o", "ci", "eni", "me", "z", "b", "in", "iu", "I", "ai", "v", "x", "li"], "idx": [" idxc", "idxs", " idex", "sidxs", "pidxc", "pidex", "sidxc", "sidex", "pidx", "idex", "pidxs", "sidx", " idxs", "idxc"]}}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n", "idx": 5457, "substitutes": {"gb": ["ub", "ui", "wb", "pc", "lb", "storage", "db", "bf", "sb", "hub", "anc", "rg", "sync", "bm", "gc", "src", "gz", "gg", "sc", "gs", "bb", "cca", "gram", "gy", "gd", "ctx", "bc", "bg", "gin", "kb", "usb", "mc", "GB", "eb", "fc", "kr", "ga", "ci", "lc", "cd", "rb", "cb", "vc", "binary"], "rc": ["ru", "nc", "uc", "pc", "loc", "RC", "co", "isc", "cc", "anc", "sys", "rg", "rx", "sync", "src", "gg", "sc", "auc", "xc", "inc", "rank", "r", "roc", "ack", "irc", "hl", "config", "cs", "usr", "rr", "ic", "cca", "uci", "abc", "rn", "asc", "ck", "c", "instance", "sr", "gd", "ctx", "bc", "rec", "cur", "dc", "cr", "inst", "ec", "fc", "dr", "ci", "lc", "rb", "rw", "rect", "rl", "ra", "attr", "ac", "rin", "vc", "rs", "rog", "rt"], "cumFreq": [" cumFirequency", "cumFrequality", " cumFiq", "cumLeqs", "cumFreeqs", "cumFreference", "cumfreqs", " cumFreQ", "cumFiqs", "cumFreequality", "cumFqs", " cumFiqs", " cumfreq", " cumfrequality", "cumStraference", " cumfreue", "cumFirequency", " cumFreqs", "cumfreQ", "cumFreqs", "cumFq", "cumFreue", "cumStraqs", "cumFrequency", " cumFrequality", "cumStrarequency", "cumFference", "cumFiq", " cumfreqs", "cumFrerequency", " cumFreference", " cumfreQ", " cumFiference", "cumFiference", "cumFreQ", "cumfrequality", " cumFreue", "cumFreeq", " cumFrerequency", "cumLeq", "cumfreue", "cumLeQ", "cumFreeQ", "cumLeue", "cumStraq", "cumfreq"], "freq": ["freeQ", " frece", "frqs", "luq", "freequality", "freqs", "faq", "luQ", "faqs", "frece", "Freq", "freQ", "frQ", "frq", "faQ", "luqs", "faquality", "freeq", " frequality", " freQ", "frquality", "FreQ", "freece", "Frece", "luquality", "frequality", "Frequality"], "total_freq": ["total_latq", "total_perq", "total_latf", "total_freeue", "total_freance", "total_latux", "total_Freence", "total_Freq", "total_compq", "total_freux", "total_freeqs", "total_compue", "total_compqs", "total_freeence", "total_freequality", "total_freeq", "total_perance", "total_freence", "total_Freqs", "total_latance", "total_Freue", "total_fref", "total_Frequality", "total_Freance", "total_freeance", "total_perf", "total_compquality", "total_freue", "total_freqs", "total_frequality", "total_perux"]}}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static int dmg_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    s->fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (s->fd < 0)\n\n        return -errno;\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    /* read offset of info blocks */\n\n    offset = lseek(s->fd, -0x1d8, SEEK_END);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    info_begin = read_off(s->fd, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(s->fd, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(s->fd, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    /* read offsets */\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(s->fd, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(s->fd, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = qemu_realloc(s->types, new_size/2);\n\n\t    s->offsets = qemu_realloc(s->offsets, new_size);\n\n\t    s->lengths = qemu_realloc(s->lengths, new_size);\n\n\t    s->sectors = qemu_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(s->fd, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = qemu_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    return 0;\n\nfail:\n\n    close(s->fd);\n\n    return -1;\n\n}\n", "idx": 5482, "substitutes": {"bs": ["bi", "pb", "lb", "gb", "aws", "ab", "sb", "bos", "blocks", "ks", "BS", "ls", "bl", "ps", "ses", "vs", "cs", "bb", "gs", "bytes", "ds", "fb", "ops", "ss", "ts", "obs", "bc", "fs", "ns", "ms", "us", "ssl", "bh", "bits", "rb", "js", "b", "es", "cb", "os", "qs", "rs"], "filename": ["data", "wb", "dylib", "fn", "phrase", "url", "Filename", "name", "nil", "arf", "tty", "whatever", "username", "file", "wl", "files", "txt", "fd", "fil", "kl", "il", "buffer", "f", "which", "path", "source", "location", "prefix", "utf", "original", "lf", "rb", "length", "dll", "fp", "binary", "directory"], "flags": ["ffff", "options", "FLAG", "mask", "args", "faces", "config", "bytes", "stats", "types", "file", "files", "ops", "fs", "Flags", "ants", "vals", "flag", "settings", "info", "fee", "lf", "bits", "xff", "features", "locks", "ips"], "s": ["ans", "d", "sync", "args", "native", "ops", "services", "fs", "f", "sv", "b", "conf", "sites", "sq", "outs", "sb", "plugins", "h", "ses", "cs", "ions", "ss", "ts", "uns", "ns", "sa", "a", "its", "tests", "es", "ins", "hs", "http", "storage", "parts", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "c", "g", "us", "ssl", "sl", "state", "su", "qs", "rs", "si", "aws", "e", "server", "is", "service", "ds", "l", "states", "sym", "m", "as", "bis", "settings", "js", "os", "stat"], "info_begin": ["info01create", " info_create", "informationPinformation", " info_pair", "infoPenter", "information_seven", "info__enter", "info__information", " info_initial", "info01enter", "informationPseven", "infoPseven", "info_pair", "info__begin", " info_enter", "infoacenter", " info_size", "info_mid", "inf_pair", "inf_create", "info__end", "infoacbegin", " info_mid", "Info_start", "informationPbegin", "inf_enter", "info_enter", "info00enter", "Info_cur", "info_create", "infoJstart", "info00pin", "inf_pin", "inf_begin", "info_information", "info_size", "info00begin", "info__mid", "infoacpair", "infoJcur", "Info_enter", "infoacpin", "informationPenter", "info_initial", "info01begin", "information_begin", "info_seven", "inf_message", "info_pin", "info_cur", "info00message", "infoPinformation", "Info_begin", "infoPbegin", "information_enter", "info01pair", "info__seven", "infoacmessage", "info_start", "info_message", "infoacsize", "infoJbegin", "infoJenter", "information_information"], "info_end": ["infoREend", "information_END", "information_ended", "off_ending", "Info_end", "Info_start", "infoREdate", "Info_length", "info_length", "info_END", "info_start", "information_end", "info_ended", "info_ends", "Info_date", "info_date", "info_ending", "off_end", "information_begin", "infoRElength", "infoREstart", "off_ends"], "last_in_offset": ["last_inanderror", "last_in_error", "last_out_number", "last_in_entry", "last_out_Offset", "last_out_entry", "last_iningerror", "last_iningoffset", "last_in_progress", "last_in_number", "last_out_error", "last_iningnumber", "last_in__entry", "last_in__Offset", "last_in_Offset", "last_iningprogress", "last_inandoffset", "last_out_progress", "last_inandnumber", "last_inandprogress", "last_in__offset"], "last_out_offset": ["last_outedentry", "last_out_size", "last_outedline", "last_outedoffset", "last_in_entry", "last_outedsize", "last_out_Offset", "last_out_entry", "last_out_line", "last_out__Offset", "last_out__position", "last_in_line", "last_in_Offset", "last_out_end", "last_in_position", "last_in_end", "last_out__offset", "last_in_size", "last_out__end", "last_out_position"], "count": ["low", "sum", "index", "name", "coll", "Count", "num", "old", "id", "common", "cf", "timeout", "found", "missing", "depth", "total", "limit", "get", "key", "many", "call", "h", "position", "current", "weight", "path", "start", "flag", "group", "part", "size", "match", "code", "high", "base", "pool", "number", "len", "connection", "no", "large", "child", "c", "content", "all", "check", "list", "length", "col", "process", "more", "allow", "end", "error", "core", "catch", "seq", "counter", "skip", "act", "array", "max", "parent", "cache", "info"], "i": ["pos", "split", "index", "fi", "ti", "p", "slice", "h", "is", "ii", "inner", "ind", "id", "n", "ip", "abi", "c", "init", "f", "io", "a", "ini", "ci", "b", "in", "I", "ai", "si"], "offset": ["operation", "pos", "index", "area", "set", "Offset", "api", "slice", "order", "off", "ip", "online", "f", "range", "location", "fee", "timeout", "fp", "output", "data", "ui", "object", "ref", "limit", "position", "offer", "address", "next", "page", "start", "attribute", "flag", "part", "size", "addr", "ptr", "seek", "base", "layout", "url", "number", "amount", "len", "connection", "image", "line", "et", "option", "entry", "shift", "enabled", "padding", "slot", "initial", "length", "append", "post", "align", "format", "extra", "split", "reset", "end", "optional", "error", "loc", "function", "seq", "at", "exclusive", "skip", "pointer", "point", "parent", "o", "attr", "alias"], "type": ["tag", "ty", "py", "date", "y", "area", "number", "total", "error", "name", "value", "ype", "key", "val", "call", "p", "base", "api", "rule", "style", "bug", "TYPE", "types", "id", "large", "block", "class", "all", "weight", "comment", "ping", "cat", "part", "parent", "info", "size", "match", "code", "pe", "like", "Type", "state", "length", "time", "http", "post", "year", "port"], "new_size": ["newXscale", "new67number", "gen_capacity", "new_count", " new_range", "new_number", "gen_size", "genfsize", "newJaddress", "newXrange", "newfsize", "newJsize", " new_order", " new_channel", " new_address", "new_scale", "new48address", " new_set", "new_order", "new_address", "new_set", "new\u00b7size", "new67size", "gen_count", "newXnumber", "newJchannel", "newXsize", "new48size", "new\u00b7set", "new67scale", "newfcapacity", "newfcount", " new_number", "new\u00b7address", "new_range", "new48order", "new_channel", "new_capacity", "genfcount", " new_scale", "newJorder", "new67range", "genfcapacity", "new48channel"], "chunk_count": ["chunkerermax", "chunkererlimit", "chworkercount", "chunk6number", "chwork_count", "chunk64weight", "chunk_len", "chunkerernumber", "chunkerlen", "chunkerercount", "chunk_limit", "chwork_weight", "chunker_number", "chunkerlimit", "chunk6count", "chunker_limit", "chunker_count", "chunk2sum", "chworkerweight", "chunk64count", "chunk_weight", "chunk_size", "chunk6max", "chunkername", "chunk_number", "chunker_max", "chunk64name", "chworkername", "chunk2c", "chwork_len", "chunk_c", "chworkerlen", "chunk_sum", "chunk6limit", "chunkermax", "chunk2size", "chunkerweight", "chunk_name", "chunk2count", "chunk_max", "chunkercount", "chunkernumber", "chwork_name", "chunk64len"]}}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n", "idx": 5490, "substitutes": {"pkt": ["cpct", "pet", " pct", "pkh", " pwk", "ipkt", "Pwk", "pk", "Pkh", "mkt", "spk", "Pct", "cpkt", "spwk", "pwk", " pet", "cpet", "ipacket", "cpacket", "ipwk", "packet", " packet", " pkh", "mk", "Pet", "pct", "Pkt", "spacket", "spkt", "Packet", "macket", "ipkh", " pk", "mwk"]}}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 5500, "substitutes": {"data": ["builder", "da", "result", "d", "api", "type", "id", "init", "f", "art", "media", "missing", "li", "ui", "new", "object", "reader", "DATA", "input", "view", "get", "key", "test", "module", "this", "config", "change", "u", "load", "alpha", "parse", "start", "cat", "a", "code", "database", "valid", "base", "Data", "self", "p", "style", "g", "model", "qa", "json", "ad", "it", "post", "work", "window", "dat", "end", "di", "na", "command", "and", "client", "obj", "dd", "class", "wa", "as", "parent", "cache", "i", "info", "o", "la", "parser", "first"], "json_string": ["json_number", " json_str", "json_data", "jsonMatfilename", "json_str", "json_object", "input_object", "json_filename", "input_filename", "input_length", "jsonMatstring", "json_length", "input_string", "jsonMatobject", " json_data", "jsonMatlength", " json_number"], "v": ["av", "y", "vm", "k", "conv", "j", "vd", "vp", "lv", "value", "e", "d", "vic", "view", "vert", "val", "ve", "vi", "p", "nv", "api", "h", "vs", "ev", "u", "n", "l", "s", "var", "c", "m", "t", "uv", "V", "f", "g", "cv", "i", "iv", "o", "ver", "cover", "va", "z", "sv", "ov", "q", "vc", "vv", "x"]}}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}", "idx": 5508, "substitutes": {"path": ["root", "data", "context", "ex", "dir", "url", "PATH", "loader", "name", "text", "loc", "error", "enc", "handler", "key", "core", "open", "p", "base", "conn", "method", "r", "id", "file", "pattern", "temp", "c", "home", "entry", "ith", "address", "host", "pointer", "pass", "location", "parent", "cache", "w", "filename", "prefix", "uri", "code", "here", "Path", "ath", "work", "binary", "port"], "sockfd": ["sockerfat", "swinFD", "socksbuf", " sockfn", "dsocksfat", "sbootfd", "sckfun", "sinkfn", "sckaddr", "dsocksfd", "sbootfn", "sockaddr", " sockFD", "dinkFD", " socksaddr", " swinfun", "dockFD", " socksf", "sockeraddr", "dsocksaddr", "scpfat", "dockstream", " sockaddr", "socksfd", "sinkf", "sesockfun", "sigFD", "dinkstream", "sourcefd", "sesinkfd", "sinkfun", "dsockfd", "scpFD", "sockerfd", "sockbuf", "dsockFD", "sigfd", "sigstream", " swinfd", "scpfd", "sourceaddr", "sinkfd", "sesockFD", "sesockaddr", "dockbuf", " swinFD", "dockfd", "sinkstream", "sinkbuf", " sockfun", "swinfun", "socksfun", "sesinkaddr", "sbootFD", "sockf", "socksf", "dinkbuf", "sesockfd", " swinfn", "sesinkFD", "sesinkfun", "dsockaddr", "sinkaddr", "sigbuf", "socksfat", "sockstream", " socksFD", "sckfd", "scpaddr", "sourceFD", "socksFD", "dsockfat", "swinfd", "swinfn", "sockfun", "dsocksFD", "sourcef", "sockfat", "sockfn", " socksfd", "dinkfd", "sinkFD", "socksaddr", "sbootfun", "sckFD", "socksstream", " sockf", "sockerFD", "sockFD"], "size": ["complete", "sum", "storage", "sec", "small", "scale", "loc", "name", "len", "fe", "ice", "sync", "ey", "esc", "offset", "speed", "SIZE", "empty", "large", "ize", "content", "sized", "c", "Size", "address", "g", "weight", "capacity", "iz", "sn", "max", "security", "fee", "x", "code", "length", "time", "count", "send", "unit", "si"], "helper": [" Helpher", "schemer", "Helper", "hypper", "hyper", "halper", "scheper", "helpert", " helperpert", "helport", "improper", "haller", "hper", "hapers", "thelped", " heller", " helperper", "helpler", "haber", "helped", "hport", "waler", "permer", "impropper", "perper", "thelper", "harport", "helmer", "harter", "impropher", "thelber", "hypert", "harber", "scheler", "harper", " helter", "harpper", "heller", "wamer", "haper", "schepler", "hyter", "helpher", " Helpers", "helpper", "helpers", "hapher", "helber", "halpers", "impropers", " Helper", "perler", "Helter", "Helpert", "helter", "Helpper", "haped", " helperpper", "wapler", "harpers", "haler", "hpper", "harler", "harped", "haport", " helpers", "halter", "waper", " Helpper", "happer", "theller", "perpler", " helperter"]}}
{"project": "qemu", "commit_id": "a1c3e4b839f8e7ec7f1792b8a11c63ca845aa021", "target": 1, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n{\n    EHCIState *s = ptr;\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n    uint32_t old = *mmio;\n    int i;\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n        return;\n    if (addr < OPREGBASE) {\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    /* Do any register specific pre-write processing here.  */\n    switch(addr) {\n    case USBCMD:\n        if (val & USBCMD_HCRESET) {\n            ehci_reset(s);\n            val = s->usbcmd;\n            break;\n        /* not supporting dynamic frame list size at the moment */\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);", "idx": 5509, "substitutes": {"ptr": ["scope", "iii", "sth", "ref", "proc", "eth", "e", "sb", "str", "fi", "tty", "p", "src", "buf", "r", "ctr", "Ptr", "fd", "temp", "sh", "ts", "t", "inter", "tmp", "address", "pt", "tr", "pointer", "f", "buffer", "inst", "sl", "tc", "dr", "dll", "fp", "si", "port"], "addr": ["nm", "pos", "index", "frame", "od", "sid", "eth", "mt", "alt", "vr", "fx", "str", "nil", "rx", "arm", "adder", "slice", "amd", "pad", "ace", "cmd", "id", "rd", "pkg", "hw", "ar", "cap", "grad", "asm", "data", "nn", "oa", "xd", "db", "ast", "sb", "ea", "grade", "afi", "offset", "r", "intel", "config", "ne", "hl", "bb", "rn", "mode", "inter", "layer", "dc", "address", "kt", "start", "mac", "nr", "part", "kn", "size", "code", "direction", "driver", "base", "ext", "rc", "url", "len", "p", "arr", "conn", "c", "host", "padding", "slot", "ad", "xp", "amp", "route", "align", "adr", "x", "nc", "loc", "ord", "rg", "aug", "src", "seq", "rr", "dd", "ctx", "pointer", "point", "hop", "sta", "coord", "dr", "eni", "md", "anne", "lvl", "attr", "node", "alias", "ld", "rt"], "val": ["pos", "index", "set", "eval", "alt", "aval", "nil", "ival", "bl", "num", "old", "pr", "vol", "el", "VAL", "b", "arg", "serv", "unit", "v", "li", "data", "local", "new", "ref", "cond", "db", "key", "test", "ne", "elt", "reg", "ind", "Value", "Val", "pol", "valid", "store", "role", "status", "ee", "base", "vl", "cal", "pre", "value", "len", "sil", "byte", "p", "arr", "sol", "bo", "var", "all", "pt", "prop", "slot", "sl", "bal", "al", "delay", "state", "fl", "x", "fail", "play", "ve", "fi", "ol", "pid", "stat", "vals", "err", "dev", "live", "sel", "update", "ret"], "s": ["sync", "slice", "args", "vs", "site", "sg", "services", "fs", "f", "sv", "b", "conf", "serv", "v", "new", "sq", "sb", "h", "ses", "r", "cs", "this", "u", "sf", "ss", "ts", "t", "ns", "a", "w", "your", "es", "ins", "storage", "slave", "self", "sys", "p", "ls", "session", "S", "ps", "gs", "sets", "stats", "n", "c", "instance", "g", "us", "ssl", "sl", "state", "su", "qs", "rs", "spec", "si", "scope", "e", "server", "socket", "is", "service", "ds", "request", "l", "states", "sym", "m", "sie", "settings", "se", "o", "secondary", "js", "os"], "mmio": ["mdios", "memios", "mdiao", " mmiao", "mmiao", " mmcho", "mmIO", "mmiol", "mpno", "mdri", "mmo", "memiol", "mpio", " mmIO", "mmori", " mmo", " mmri", "mmno", " mmno", "mdcho", "mdori", "memo", "mpiao", "memIO", "mpios", "mmios", "memri", "memio", " mmori", "mdIO", "mmcho", "mdno", "mdo", "memcho", " mmios", "mdiol", " mmiol", "memori", "mmri", "mdio"], "i": ["pi", "end", "j", "e", "d", "p", "is", "r", "n", "l", "c", "m", "f", "ed", "io", "or", "a", "err", "z", "b", "I", "v", "x"]}}
{"project": "FFmpeg", "commit_id": "cf7d2f2d2134c0854edf2db91e7436ac2bc9874f", "target": 0, "func": "static av_cold int dnxhd_encode_init(AVCodecContext *avctx)\n\n{\n\n    DNXHDEncContext *ctx = avctx->priv_data;\n\n    int i, index, bit_depth, ret;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV422P:\n\n        bit_depth = 8;\n\n        break;\n\n    case AV_PIX_FMT_YUV422P10:\n\n        bit_depth = 10;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"pixel format is incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);\n\n    if (!ctx->cid) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"video parameters incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"cid %d\\n\", ctx->cid);\n\n\n\n    index = ff_dnxhd_get_cid_table(ctx->cid);\n\n    if (index < 0)\n\n        return index;\n\n    ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n\n\n    ctx->m.avctx    = avctx;\n\n    ctx->m.mb_intra = 1;\n\n    ctx->m.h263_aic = 1;\n\n\n\n    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;\n\n\n\n    ff_blockdsp_init(&ctx->bdsp, avctx);\n\n    ff_fdctdsp_init(&ctx->m.fdsp, avctx);\n\n    ff_mpv_idct_init(&ctx->m);\n\n    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);\n\n    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);\n\n    if (!ctx->m.dct_quantize)\n\n        ctx->m.dct_quantize = ff_dct_quantize_c;\n\n\n\n    if (ctx->cid_table->bit_depth == 10) {\n\n        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;\n\n        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 4;\n\n    } else {\n\n        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 3;\n\n    }\n\n\n\n    if (ARCH_X86)\n\n        ff_dnxhdenc_init_x86(ctx);\n\n\n\n    ctx->m.mb_height = (avctx->height + 15) / 16;\n\n    ctx->m.mb_width  = (avctx->width  + 15) / 16;\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {\n\n        ctx->interlaced   = 1;\n\n        ctx->m.mb_height /= 2;\n\n    }\n\n\n\n    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;\n\n\n\n#if FF_API_QUANT_BIAS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&\n\n        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)\n\n        ctx->intra_quant_bias = avctx->intra_quant_bias;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    // XXX tune lbias/cbias\n\n    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 5539, "substitutes": {"avctx": ["Avcmp", "aveca", "avloc", "avconfig", "averpkg", "afctx", "avcmd", "AVxc", "AVconn", "Avbc", "avca", "navctx", " avca", "AVca", "navcmd", "avercp", " avctl", "aveloc", "afloc", "avcb", "afcmp", "navconn", "averkb", "avbc", "avepkg", "AVbc", "avecontext", "avpkg", "afconn", "Avctx", " avbc", "afcu", "airconn", "afkb", "AVcu", "AVctx", "vercmd", "avkb", "afpkg", "aircb", "AVcmp", "avercontext", "Avcontext", "vercb", "avcontext", "avectl", "aveconn", "avekb", "navcontext", "avconn", "aircontext", "averctx", "AVconfig", "avcp", "AVcp", "avecmp", "avxc", "avecp", "verconn", "AVcontext", "abcontext", " avcmd", "AVcmd", "avcmp", "AVctl", "verctx", "vercv", "AVkb", "vercmp", "avecv", "AVcv", "AVcf", " avxc", " avcf", "Avcf", "vercontext", "avcu", "afconfig", " avcontext", " avconn", "averctl", "AVloc", "afxc", "avctl", "avcf", "Avcu", "afcontext", "abctx", "abconfig", "airctx", "avcv", "AVcb", "avectx", " avcmp", "afcmd", "abcmp"], "ctx": ["context", "sci", "data", "nc", "cfg", "fn", "pc", "rc", "conv", "msg", "sq", "cal", "cp", "wcs", "loc", "input", "component", "co", "exec", "anc", "cc", "cli", "connection", "kw", "cus", "client", "xc", "conn", "sc", "support", "cm", "cs", "config", "fw", "cmd", "chan", "jp", "cca", "tx", "txt", "cms", "ck", "c", "instance", "bc", "act", "kb", "ctrl", "cat", "cv", "cam", "pkg", "qa", "hw", "concept", "fc", "cu", "conf", "media", "cf", "ca", "prefix", "tc", "cn", "ci", "lc", "la", "cas", "cb", "cmp", "vc", "comp", "fp", "utils"], "i": ["ui", "pi", "k", "j", "di", "e", "ti", "base", "num", "ii", "ind", "ip", "c", "ib", "io", "ri", "info", "it", "x", "uri", "ci", "iu", "count", "I", "ai", "si", "li"], "index": ["pos", "section", "result", "element", "example", "coll", "sync", "slice", "type", "num", "inner", "id", "connect", "condition", "diff", "input", "key", "val", "offset", "position", "ind", "weight", "address", "page", "partial", "ini", "part", "match", "null", "value", "len", "connection", "no", "search", "full", "conn", "inc", "query", "include", "option", "instance", "all", "action", "check", "list", "length", "active", "append", "find", "cmp", "zero", "x", "date", "end", "error", "loc", "e", "fe", "empty", "Index", "out", "update", "head", "point", "info", "insert", "office"], "bit_depth": ["bit64Depth", "bit64deep", "bit_len", "bit_rate", "bitSdeep", "bin_table", "bit2height", " bit2height", "bitSdepth", "bin_deep", "bin_depth", "bitalllen", " bit_rate", "bit64depth", "bit_table", "bitalllength", "bitalldepth", "bit32Depth", "byte_dist", "byte_source", "bit32rate", "bit_dist", " bit_roots", " bit_count", "bit_count", "bit_deep", "bit_length", "bit64count", " bit_height", " bit_deep", "bit_height", "byte_deep", " bit2depth", " bit_dist", "bit_Depth", " bit_size", " bit2rate", "byte_depth", "bit_source", "bit2depth", "byte_len", "bit2rate", "bit_size", "bit2Depth", "bit_roots", "bitStable", "bit32height", "byte_length", " bit2Depth", "bit32depth", "bitallsource", " bit_Depth"], "ret": ["batch", "rc", "ref", "result", "success", "alt", "val", "mem", "arr", "gc", "orig", "seq", "resp", "reg", "obj", "res", "abc", "aux", "entry", "rev", "feat", "reply", "rem", "arg", "col", "row"]}}
{"project": "FFmpeg", "commit_id": "ccce723c6d0ea1ea89ea6c47160a07d37cdeeba2", "target": 0, "func": "static int vc1_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size, n_slices = 0, i;\n\n    VC1Context *v = avctx->priv_data;\n\n    MpegEncContext *s = &v->s;\n\n    AVFrame *pict = data;\n\n    uint8_t *buf2 = NULL;\n\n    const uint8_t *buf_start = buf, *buf_start_second_field = NULL;\n\n    int mb_height, n_slices1=-1;\n\n    struct {\n\n        uint8_t *buf;\n\n        GetBitContext gb;\n\n        int mby_start;\n\n    } *slices = NULL, *tmp;\n\n\n\n    v->second_field = 0;\n\n\n\n    if(s->flags & CODEC_FLAG_LOW_DELAY)\n\n        s->low_delay = 1;\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {\n\n        /* special case for last picture */\n\n        if (s->low_delay == 0 && s->next_picture_ptr) {\n\n            *pict = s->next_picture_ptr->f;\n\n            s->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n\n\n        return buf_size;\n\n    }\n\n\n\n    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {\n\n        if (v->profile < PROFILE_ADVANCED)\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1;\n\n    }\n\n\n\n    //for advanced profile we may need to parse and unescape data\n\n    if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n        int buf_size2 = 0;\n\n        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n        if (IS_MARKER(AV_RB32(buf))) { /* frame starts with marker and needs to be parsed */\n\n            const uint8_t *start, *end, *next;\n\n            int size;\n\n\n\n            next = buf;\n\n            for (start = buf, end = buf + buf_size; next < end; start = next) {\n\n                next = find_next_marker(start + 4, end);\n\n                size = next - start - 4;\n\n                if (size <= 0) continue;\n\n                switch (AV_RB32(start)) {\n\n                case VC1_CODE_FRAME:\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start = start;\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    break;\n\n                case VC1_CODE_FIELD: {\n\n                    int buf_size3;\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start_second_field = start;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    /* assuming that the field marker is at the exact middle,\n\n                       hope it's correct */\n\n                    slices[n_slices].mby_start = s->mb_height >> 1;\n\n                    n_slices1 = n_slices - 1; // index of the last slice of the first field\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    init_get_bits(&s->gb, buf2, buf_size2 * 8);\n\n                    ff_vc1_decode_entry_point(avctx, v, &s->gb);\n\n                    break;\n\n                case VC1_CODE_SLICE: {\n\n                    int buf_size3;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                }\n\n            }\n\n        } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { /* WVC1 interlaced stores both fields divided by marker */\n\n            const uint8_t *divider;\n\n            int buf_size3;\n\n\n\n            divider = find_next_marker(buf, buf + buf_size);\n\n            if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Error in WVC1 interlaced frame\\n\");\n\n                goto err;\n\n            } else { // found field marker, unescape second field\n\n                if (avctx->hwaccel ||\n\n                    s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    buf_start_second_field = divider;\n\n                tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                if (!tmp)\n\n                    goto err;\n\n                slices = tmp;\n\n                slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!slices[n_slices].buf)\n\n                    goto err;\n\n                buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf);\n\n                init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                              buf_size3 << 3);\n\n                slices[n_slices].mby_start = s->mb_height >> 1;\n\n                n_slices1 = n_slices - 1;\n\n                n_slices++;\n\n            }\n\n            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);\n\n        } else {\n\n            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);\n\n        }\n\n        init_get_bits(&s->gb, buf2, buf_size2*8);\n\n    } else\n\n        init_get_bits(&s->gb, buf, buf_size*8);\n\n\n\n    if (v->res_sprite) {\n\n        v->new_sprite  = !get_bits1(&s->gb);\n\n        v->two_sprites =  get_bits1(&s->gb);\n\n        /* res_sprite means a Windows Media Image stream, AV_CODEC_ID_*IMAGE means\n\n           we're using the sprite compositor. These are intentionally kept separate\n\n           so you can get the raw sprites by using the wmv3 decoder for WMVP or\n\n           the vc1 one for WVP2 */\n\n        if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n            if (v->new_sprite) {\n\n                // switch AVCodecContext parameters to those of the sprites\n\n                avctx->width  = avctx->coded_width  = v->sprite_width;\n\n                avctx->height = avctx->coded_height = v->sprite_height;\n\n            } else {\n\n                goto image;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->context_initialized &&\n\n        (s->width  != avctx->coded_width ||\n\n         s->height != avctx->coded_height)) {\n\n        ff_vc1_decode_end(avctx);\n\n    }\n\n\n\n    if (!s->context_initialized) {\n\n        if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0)\n\n            goto err;\n\n\n\n        s->low_delay = !avctx->has_b_frames || v->res_sprite;\n\n\n\n        if (v->profile == PROFILE_ADVANCED) {\n\n            s->h_edge_pos = avctx->coded_width;\n\n            s->v_edge_pos = avctx->coded_height;\n\n        }\n\n    }\n\n\n\n    /* We need to set current_picture_ptr before reading the header,\n\n     * otherwise we cannot store anything in there. */\n\n    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {\n\n        int i = ff_find_unused_picture(s, 0);\n\n        if (i < 0)\n\n            goto err;\n\n        s->current_picture_ptr = &s->picture[i];\n\n    }\n\n\n\n    // do parse frame header\n\n    v->pic_header_flag = 0;\n\n    if (v->profile < PROFILE_ADVANCED) {\n\n        if (ff_vc1_parse_frame_header(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    } else {\n\n        if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"pict_type: %c\\n\", av_get_picture_type_char(s->pict_type));\n\n\n\n    if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE)\n\n        && s->pict_type != AV_PICTURE_TYPE_I) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Sprite decoder: expected I-frame\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if ((s->mb_height >> v->field_mode) == 0) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"image too short\\n\");\n\n        goto err;\n\n    }\n\n\n\n    // process pulldown flags\n\n    s->current_picture_ptr->f.repeat_pict = 0;\n\n    // Pulldown flags are only valid when 'broadcast' has been set.\n\n    // So ticks_per_frame will be 2\n\n    if (v->rff) {\n\n        // repeat field\n\n        s->current_picture_ptr->f.repeat_pict = 1;\n\n    } else if (v->rptfrm) {\n\n        // repeat frames\n\n        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;\n\n    }\n\n\n\n    // for skipping the frame\n\n    s->current_picture.f.pict_type = s->pict_type;\n\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    /* skip B-frames if we don't have reference frames */\n\n    if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) {\n\n        goto err;\n\n    }\n\n    if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) ||\n\n        (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||\n\n         avctx->skip_frame >= AVDISCARD_ALL) {\n\n        goto end;\n\n    }\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto end;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (ff_MPV_frame_start(s, avctx) < 0) {\n\n        goto err;\n\n    }\n\n\n\n    v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE);\n\n    v->s.current_picture_ptr->f.top_field_first  = v->tff;\n\n\n\n    s->me.qpel_put = s->dsp.put_qpel_pixels_tab;\n\n    s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab;\n\n\n\n    if ((CONFIG_VC1_VDPAU_DECODER)\n\n        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);\n\n    else if (avctx->hwaccel) {\n\n        if (v->field_mode && buf_start_second_field) {\n\n            // decode first field\n\n            s->picture_structure = PICT_BOTTOM_FIELD - v->tff;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n\n\n            // decode second field\n\n            s->gb = slices[n_slices1 + 1].gb;\n\n            s->picture_structure = PICT_TOP_FIELD + v->tff;\n\n            v->second_field = 1;\n\n            v->pic_header_flag = 0;\n\n            if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"parsing header for second field failed\");\n\n                goto err;\n\n            }\n\n            v->s.current_picture_ptr->f.pict_type = v->s.pict_type;\n\n\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        } else {\n\n            s->picture_structure = PICT_FRAME;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        }\n\n    } else {\n\n        if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err; // This codepath is still incomplete thus it is disabled\n\n\n\n        ff_er_frame_start(s);\n\n\n\n        v->bits = buf_size * 8;\n\n        v->end_mb_x = s->mb_width;\n\n        if (v->field_mode) {\n\n            uint8_t *tmp[2];\n\n            s->current_picture.f.linesize[0] <<= 1;\n\n            s->current_picture.f.linesize[1] <<= 1;\n\n            s->current_picture.f.linesize[2] <<= 1;\n\n            s->linesize                      <<= 1;\n\n            s->uvlinesize                    <<= 1;\n\n            tmp[0]          = v->mv_f_last[0];\n\n            tmp[1]          = v->mv_f_last[1];\n\n            v->mv_f_last[0] = v->mv_f_next[0];\n\n            v->mv_f_last[1] = v->mv_f_next[1];\n\n            v->mv_f_next[0] = v->mv_f[0];\n\n            v->mv_f_next[1] = v->mv_f[1];\n\n            v->mv_f[0] = tmp[0];\n\n            v->mv_f[1] = tmp[1];\n\n        }\n\n        mb_height = s->mb_height >> v->field_mode;\n\n        for (i = 0; i <= n_slices; i++) {\n\n            if (i > 0 &&  slices[i - 1].mby_start >= mb_height) {\n\n                if (v->field_mode <= 0) {\n\n                    av_log(v->s.avctx, AV_LOG_ERROR, \"Slice %d starts beyond \"\n\n                           \"picture boundary (%d >= %d)\\n\", i,\n\n                           slices[i - 1].mby_start, mb_height);\n\n                    continue;\n\n                }\n\n                v->second_field = 1;\n\n                v->blocks_off   = s->mb_width  * s->mb_height << 1;\n\n                v->mb_off       = s->mb_stride * s->mb_height >> 1;\n\n            } else {\n\n                v->second_field = 0;\n\n                v->blocks_off   = 0;\n\n                v->mb_off       = 0;\n\n            }\n\n            if (i) {\n\n                v->pic_header_flag = 0;\n\n                if (v->field_mode && i == n_slices1 + 2) {\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Field header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                } else if (get_bits1(&s->gb)) {\n\n                    v->pic_header_flag = 1;\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Slice header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n            s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height);\n\n            if (!v->field_mode || v->second_field)\n\n                s->end_mb_y = (i == n_slices     ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            else\n\n                s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            if (s->end_mb_y <= s->start_mb_y) {\n\n                av_log(v->s.avctx, AV_LOG_ERROR, \"end mb y %d %d invalid\\n\", s->end_mb_y, s->start_mb_y);\n\n                continue;\n\n            }\n\n            ff_vc1_decode_blocks(v);\n\n            if (i != n_slices)\n\n                s->gb = slices[i].gb;\n\n        }\n\n        if (v->field_mode) {\n\n            v->second_field = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n\n                memcpy(v->mv_f_base, v->mv_f_next_base,\n\n                       2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));\n\n            }\n\n            s->current_picture.f.linesize[0] >>= 1;\n\n            s->current_picture.f.linesize[1] >>= 1;\n\n            s->current_picture.f.linesize[2] >>= 1;\n\n            s->linesize                      >>= 1;\n\n            s->uvlinesize                    >>= 1;\n\n        }\n\n        av_dlog(s->avctx, \"Consumed %i/%i bits\\n\",\n\n                get_bits_count(&s->gb), s->gb.size_in_bits);\n\n//  if (get_bits_count(&s->gb) > buf_size * 8)\n\n//      return -1;\n\n        if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err;\n\n        if(!v->field_mode)\n\n            ff_er_frame_end(s);\n\n    }\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\nimage:\n\n        avctx->width  = avctx->coded_width  = v->output_width;\n\n        avctx->height = avctx->coded_height = v->output_height;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            goto end;\n\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n\n        if (vc1_decode_sprites(v, &s->gb))\n\n            goto err;\n\n#endif\n\n        *pict      = v->sprite_output_frame;\n\n        *data_size = sizeof(AVFrame);\n\n    } else {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            *pict = s->current_picture_ptr->f;\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            *pict = s->last_picture_ptr->f;\n\n        }\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *data_size = sizeof(AVFrame);\n\n            ff_print_debug_info(s, pict);\n\n        }\n\n    }\n\n\n\nend:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return buf_size;\n\n\n\nerr:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return -1;\n\n}\n", "idx": 5567, "substitutes": {"avctx": ["navcam", "avloc", "avconfig", "AVctrl", "svcam", "auqa", "allcms", "afctx", "svctx", "AVcam", "avechan", "ajcontext", "allconn", "ajctrl", "aucmp", "navctx", "afbc", "afcam", "svcontext", "apconfig", " avcb", "auchan", "avcb", "afcmp", "AVcas", "aveqa", "avbc", "navbc", "apctx", "svcmp", " avbc", "auloc", "avchan", "akconn", "AVctx", "appcms", "AVcmp", "appctx", " avctrl", "avcontext", "navcontext", "verloc", "avconn", "allcam", "aucontext", "avecmp", "akctx", "AVcontext", "abcontext", "avcms", "avcmp", "afqa", "verctx", "aucas", "avcam", "avqa", "auctx", "vercontext", "allctx", "afconfig", "apcmp", " avcontext", "appcam", "appconn", "AVloc", "afcontext", "avctrl", "apcontext", "avcas", "abctx", "ajcb", "abconfig", "vercas", "akcam", "AVcb", "akcms", "avectx", "afchan", " avcam", "ajctx", "abcmp"], "data": ["batch", "audio", "frame", "reader", "sample", "capt", "DATA", "result", "input", "d", "queue", "value", "message", "text", "Data", "raw", "open", "p", "src", "client", "pad", "image", "img", "config", "bytes", "current", "device", "video", "block", "buff", "content", "aux", "picture", "buffer", "f", "a", "parent", "cache", "media", "ad", "memory", "database", "b", "length", "body", "window", "dat"], "data_size": ["data_string", "data2address", " data_length", "data6address", "data2string", "page_len", "page_type", "data_len", "data_SIZE", "page_SIZE", "data6size", "data6length", "data_length", "page_size", " data_string", " data_address", "data6string", "data_address", "data_type", "data2size", "data2length"], "avpkt": ["avupunch", "afceth", "avjpki", "avpka", "AVfkt", "AVpacket", "avbpkt", "avdeth", "afckt", "avepki", "AVfacket", "avcacket", "avupkt", "afpacket", "avlpki", "avpunch", "avejpcht", "AVfka", "avbpka", "avlpacket", "avPki", "avdkt", "avjpkt", "avpki", "avbpacket", "avbpke", "avceth", "avcunch", "avepkt", "avejpki", "avejpacket", "avjpcht", "avjpacket", "avdke", "avPkt", "avepacket", "avPacket", "avfke", "AVpke", "AVfke", "afpeth", "avdacket", "avpcht", "avdka", "afcacket", "avdunch", "afpunch", "afcunch", "avepcht", "avfka", "avejpkt", "avfkt", "AVpkt", "avlpcht", "avupacket", "avupeth", "avpke", "avlpkt", "avpacket", "AVpka", "avfacket", "avckt", "avPcht", "avpeth", "afpkt"], "buf": ["batch", "context", "pb", "wb", "uc", "br", "rc", "func", "conv", "ref", "bag", "proc", "capt", "queue", "loc", "Buffer", "fi", "src", "pad", "seq", "img", "box", "config", "vec", "cmd", "fb", "block", "buff", "fd", "aux", "bc", "BU", "ctx", "buffer", "prop", "lit", "Buff", "cv", "feat", "fab", "alloc", "cf", "code", "cap", "uf", "ff", "rb", "cas", "cb", "fp", "cp", "window", "port"], "i": ["ui", "pi", "k", "conv", "j", "si", "d", "ti", "p", "slice", "image", "ii", "u", "ind", "n", "l", "ip", "m", "c", "t", "g", "f", "ci", "b", "I", "ai", "x", "li"], "v": ["volt", "tv", "vim", "vm", "conv", "vd", "j", "vp", "lv", "vu", "vg", "vic", "vert", "ve", "vi", "nv", "p", "vs", "u", "vid", "n", "l", "video", "c", "m", "t", "uv", "V", "f", "vt", "cv", "iv", "w", "va", "sv", "ov", "b", "vc", "q", "vv"], "s": ["d", "sync", "slice", "vs", "ops", "sg", "services", "fs", "f", "sv", "b", "conf", "serv", "sq", "sb", "h", "ses", "cs", "r", "u", "sf", "sp", "ss", "ts", "t", "ns", "sa", "w", "es", "storage", "share", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "xs", "stats", "n", "c", "g", "sup", "us", "ssl", "sl", "su", "qs", "rs", "spec", "si", "scope", "sci", "j", "e", "server", "is", "support", "service", "ds", "l", "sym", "m", "summary", "o", "secondary", "js", "os"], "pict": ["sci", "photo", "sq", "proc", "capt", "si", "Pic", "fat", "phot", "fi", "pid", "sc", "conn", "ct", "seq", "img", "image", "ch", "config", "csv", "ctr", "obj", "buff", "txt", "picture", "ctx", "mot", "pic", "asa", "cam", "feat", "Pict", "fig", "doc", "conf", "stat"], "buf2": ["buffer4", "buffer2", "buf0", "buf3", "uf1", "uf4", " buf3", " buf1", "buf1", "buff0", "buffer0", "buff2", "uf2", "buf4", "uf0", "uf3", "buff4", "buff3", "buffer1", " buf4", "buff1"], "buf_start": ["buf2start", "cv_end", "cv_len", "cv_start", "buf2end", "buf2stop", "buf_stop", "buf_len", "buf2len", "cv_stop", "buf_end"], "buf_start_second_field": ["buf_start_first_flag", "buf_start_second__fields", "buf_start_first_field", "buf_start_second_fields", "buf_start_second__field", "buf_start_second__flag", "buf_start_first_fields", "buf_start_second_flag"], "mb_height": ["buf_height", "buflexlast", "mb_size", "buf_last", "mb_last", "mb_width", "buflexsize", "buflexheight", "buflexwidth", "buf_size", "buf_width"], "slices": ["seales", "sifes", "slicions", "sslice", "sslicions", "ssplayes", "splayed", "splayions", "sslices", "sifions", "slice", "seale", "ssliced", "splayes", "sealions", "splaye", "ssplaye", "sealed", "ssplayions", "sifed", "ssplayed", "sliced", "sife"], "tmp": ["conv", "proc", "etc", "mpeg", "src", "mp", "params", "img", "config", "csv", "vid", "fb", "ctr", "video", "obj", "txt", "temp", "st", "bg", "videos", "bis", "stuff", "cv", "cam", "xxx", "cache", "media", "cb", "cmp"], "size": ["storage", "small", "scale", "name", "message", "gz", "offset", "image", "position", "SIZE", "empty", "unit", "file", "ize", "sized", "mode", "content", "Size", "address", "capacity", "en", "code", "shape", "length", "send", "body"], "n_slices": ["n_inseales", "n_sealES", "n_slinge", "n_inslicES", "n_insealES", "n_slingES", "n_slicse", "n_sece", "n_slingse", "n_inslicse", "n_seale", "n_secES", "n_seces", "n_sealse", "n_inslice", "n_seales", "n_insealse", "n_inseale", "n_slice", "n_secse", "n_slicES", "n_inslices", "n_slinges"]}}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "func": "void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)\n\n{\n\n    bs->detect_zeroes = blk->root_state.detect_zeroes;\n\n}\n", "idx": 5581, "substitutes": {"blk": [" blb", "BLkt", " blkt", "blck", "bldk", "Blk", "Blkt", "BLck", "frdk", "blb", "Blck", "blkt", "frb", "frck", "BLb", " blck", " bldk", "BLk", "Blb", "frk", "Bldk"], "bs": ["bi", "pb", "br", "bn", "gb", "sb", "bid", "plugins", "bos", "blocks", "BS", "ls", "bl", "SB", "ps", "vs", "gs", "cs", "bytes", "ds", "BC", "fb", "ops", "ss", "ba", "obs", "bc", "boot", "fs", "bg", "ns", "as", "bh", "bits", "rb", "b", "os", "rs", "bas", "base"]}}
{"project": "qemu", "commit_id": "42119fa3568dc7e8c82447c861678a5987d06d91", "target": 0, "func": "vcard_emul_mirror_card(VReader *vreader)\n\n{\n\n    /*\n\n     * lookup certs using the C_FindObjects. The Stan Cert handle won't give\n\n     * us the real certs until we log in.\n\n     */\n\n    PK11GenericObject *firstObj, *thisObj;\n\n    int cert_count;\n\n    unsigned char **certs;\n\n    int *cert_len;\n\n    VCardKey **keys;\n\n    PK11SlotInfo *slot;\n\n    VCard *card;\n\n\n\n    slot = vcard_emul_reader_get_slot(vreader);\n\n    if (slot == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    /* count the certs */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    /* allocate the arrays */\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    /* fill in the arrays */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        /* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in */\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); /* key obj still has a reference */\n\n    }\n\n\n\n    /* now create the card */\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n", "idx": 5582, "substitutes": {"firstObj": ["firstObject", "FirstObject", "thisInst", "prevOb", "topPo", "thirdPo", "prevOrg", "firstVal", " firstVol", " firstOrg", " firstVo", "topPtr", "topVo", "topVal", " firstPart", "thisVo", "topPart", "FirstExt", "FirstObj", "thisVol", "firstInd", "firstVo", " firstInst", "thisObject", "topObject", "FirstVol", "firstPart", " firstObject", "topOb", "topObj", "firstInst", "firstPo", "frontInd", "thisExt", " firstPo", " firstExt", "thisPtr", " firstPtr", "frontObj", "firstOb", "thirdObject", "firstExt", "prevInd", " firstInd", "frontOrg", "thirdOb", "thisOb", " firstOb", "firstOrg", "frontOb", "thirdInst", "firstPtr", "firstVol", "thirdObj", " firstVal", "prevObj"], "thisObj": ["primaryExt", "differentInd", "THISObj", "oneObject", "selfObject", "primaryInd", "thisVol", "Thisobj", "currentObj", "oneObj", "firstOb", "selfExt", "transObject", "currentObject", "transObj", "currentCh", "firstObject", "thisInd", "theseObject", " thisAct", " thisobj", " thisCh", "THISInst", "theseObj", "ThisExt", "firstAct", "thisInst", "thisCh", "differentObject", "thisobj", "firstInd", "oneOb", "selfObj", "ThisObj", "primaryObj", " thisObject", "firstExt", " thisInst", "thisOb", "firstVol", "oneExt", "sharedOb", "ThisObject", "differentobj", "sharedExt", "differentOb", "ThisInst", "differentObj", " thisInd", " thisOb", "thisObject", "THISObject", "transOb", "ThisOb", " thisVol", "differentExt", "transVol", "thisExt", "thisAct", "THISExt", "selfOb", "sharedAct", "differentAct", "sharedObj", "primaryOb", "transInd", "theseCh", " thisExt"], "cert_count": ["certxlen", "certaccount", "file_loop", "cert0count", "certIPloop", "certIPcount", "certlwidth", "certncache", "acc_counter", "ver_max", "fileaclow", "config_cache", " cert_group", "fileaccount", "certncounter", "cert_base", "certLcount", "configncache", "certLcoll", "key_limit", "cert_cache", "cert_limit", "ver_size", "certIPtotal", "key_length", " cert_length", "acc6counter", "ver_count", "cert_length", "cert0size", "configncounter", "certIPgroup", "certIPmax", "file_count", "certxcount", "certIPcoll", "cert_size", " cert_number", "acc_length", "certacnumber", "key_len", "cert_max", "certIPsize", "certLsize", "configncount", "certnlen", "cert8count", "certncount", "cert8low", "certIPoffset", "certIPlow", "certNcount", " cert_size", "certlnumber", " cert_low", "cert0width", "certaclow", "certacloop", "fileacnumber", "cert_counter", "cert8number", "acc6count", "confignlen", "cert_Count", "cert6counter", "acc6length", "cert_width", " cert_offset", "ver_coll", "cert_number", "acc_sum", "certllow", " cert_width", "certlcount", "cert_low", "certldepth", " cert_depth", "config_counter", "certNCount", "certlsize", "cert0depth", "cert_sum", "certLmax", "cert_loop", "acc6sum", "certxlimit", "key_count", "cert6length", "key_total", " cert_base", "certNgroup", "certIPnumber", "file_low", "cert8size", "fileacloop", " cert_Count", "acc_count", "cert_coll", "cert_group", "certNoffset", "certIPlength", "config_count", "cert_offset", "config_len", "file_number", "cert6sum", "cert6count", "cert_total", "cert_depth", "certIPCount"], "certs": ["cld", "Certsets", "Certs", "contractd", " certes", "reqses", "Certd", "reqes", "certes", "contractes", "certses", "configabs", "reqerences", "clses", "cls", "Certerences", " certks", "Certks", "configses", "Certses", "certks", "contractses", "reqs", "Certes", "reqls", " certsets", " certabs", "Certabs", "Certls", "certsets", "configes", " certerences", "certd", "certabs", "configs", "reqabs", "contracts", "cles", "reqks", " certls", "certerences", "certls", "reqsets"], "cert_len": ["cert64lan", "tr5len", "cert8Len", "cert8den", "cert\u00b7diff", "secret9len", "secret_lan", "tr_count", "key_diff", "tr5width", "tr_log", "key_length", "cert8len", "secret9lan", "cert_length", "tr_width", "cert64len", "cert64li", "secret_Len", "key_len", "cert5count", "secret9li", "cert8count", "cert_log", "cert_lan", "tr5count", "cert_val", "cert\u00b7len", "cert5log", "cert6val", "cert9lan", "cert_width", "cert_den", "cert5len", "secret_li", "cert9Len", "key_fin", "cert_li", "cert5width", "key_val", " cert_den", " cert_Len", "tr5log", "tr_len", "cert64Len", "cert6len", "cert\u00b7Len", "key_count", "cert_fin", "secret9Len", "cert9len", "cert_Len", "cert6fin", "cert\u00b7length", "cert_diff", "cert6count", "secret_len", "key_Len", "cert9li"], "keys": ["options", "users", "k", "properties", "parts", "trans", "lines", "key", "ks", "args", "links", "params", "codes", "cards", "ps", "chains", "values", "ses", "cs", "lists", "headers", "rings", "stars", "ds", "types", "pieces", "files", "rows", "states", "Keys", "ops", "ids", "windows", "parents", "services", "owners", "members", "fields", "fs", "ns", "ms", "vers", "checks", "vals", "drivers", "cats", "names", "ports", "letters", "locks", "ics", "groups", "items", "errors", "qs", "ors", "ips"], "slot": ["pool", "scope", "pos", "layout", "index", "storage", "zone", "pin", "object", "oid", "sid", "loc", "share", "key", "shot", "game", "acl", "slice", "connection", "session", "type", "socket", "bit", "biz", "channel", "module", "account", "image", "git", "service", "spot", "lib", "plugin", "option", "Slot", "block", "snap", "entry", "secret", "host", "pointer", "hole", "vol", "space", "parse", "location", "comment", "cat", "group", "part", "bin", "parent", "sl", "shadow", "trial", "role", "tab", "cell", "lock", "lot", "token"], "card": ["index", "cand", "result", "coll", "ard", "controller", "circ", "row", "cc", "event", "raw", "ARD", "gc", "ce", "cards", "style", "record", "bug", "crit", "id", "file", "cont", "cookie", " cards", "load", "class", "Card", "cart", "arc", "entry", "cube", "host", "day", "book", "draw", "comment", "cat", "parse", "mac", "pass", "parent", "cache", "carry", "list", "cf", "match", "letter", "lc", "valid", "board", "node", "cmp", "cell", "car", "format"], "derCert": ["serPriv", " dercert", " derKey", "DerExt", "Dercert", " derVal", "DERMult", "serAlt", "drExt", "drKey", "derServ", "drFac", "oderKey", "DERCert", "oderCert", "DerFac", "DerDoc", "derAlt", "DERServ", "derExt", "DerCert", "serFac", "serTr", "derPriv", "DerPriv", "terPriv", "serCert", "DerAlt", "derMult", "derVal", "DerKey", "derDoc", "DerVal", "terCert", "derKey", "DERExt", "DERcert", "terAlt", "DerServ", "DerMult", "derFac", "DerTr", "dercert", "DERKey", " derDoc", "oderDoc", "DERVal", "drTr", " derServ", "derTr", "drCert", "drMult"], "cert": ["date", "ext", "cand", "url", "pub", "result", "text", "alt", "att", "cot", "pl", "key", "compl", "val", "str", "vert", "call", "Cert", "ce", "pair", "html", "test", "order", "ct", "trust", "config", "sp", "crit", "sign", "ind", "ctr", "fake", "contract", "txt", "temp", "ert", "enter", "cur", "cr", "pt", "tr", "secret", "opt", "acc", "cat", "cel", "conf", "req", "ssl", "cook", "ver", "ca", "user", "cf", "valid", "fac", "cb", "font", "del", "con", "dat"], "rv": ["RV", "Rv", "srp", " rval", "srv", "vrv", "vrV", "srb", " rp", "rf", "vrval", " rb", "srV", "Rval", "rval", "vrf", " rV", "rp", "srf", "Rf", "Rb", "rb", "rV", "Rp", " rf"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n", "idx": 5587, "substitutes": {"curtime": ["clientspace", " curTime", "curmoney", " curdef", "gukey", "cursize", "curtim", "uruser", "schesize", "sertimes", "cartimes", "curtimes", " cursize", "drtime", "charmoney", "schetime", "latclass", "urspace", "curset", "curtimer", "cardate", "chartim", "gucase", "cattimer", " curdate", "facname", " curtim", "clienttime", "chevalue", " curbase", "cattim", " curset", "curname", "curTime", "drtim", "chetim", " curtimes", "scheset", "curclass", "scheyear", "facmoney", "urm", "Curtime", "curbase", "latvalue", "Curuser", " curname", "urkey", "factime", "chetime", "sertime", "guyear", " curuser", "checlass", "factim", " curvalue", "curvalue", "curt", "urdef", "curkey", "charname", " curmoney", " curtimer", "urTime", "curspace", "curyear", "drtimer", "clientm", "gusize", "sert", "curcase", "curuser", "lattim", "gutime", "curdate", "serdate", "lattime", "guset", " curcase", "curdef", "clientbase", " curt", " curm", " curyear", "gudef", "cart", " curspace", "cattime", "CurTime", "urtime", "urbase", " curclass", "chartime", "urcase", "curm", " curkey", "cartime"], "bcd_time": ["bnd_clock", "bnd_time", "bcd_clock", "bcd__hour", "bmd_hour", "bcd__rate", "bcd_hour", "bmd_rate", "bnd_hour", "bmd_c", "bcd_Time", "bmd_time", "bcd__time", "bcd_c", "bcd__c", "bcd_rate", "bnd_rate", "bnd_Time"]}}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n", "idx": 5607, "substitutes": {"cookie": ["extra", "data", "cfg", "nc", "ticket", "zone", "url", "sid", "name", "label", "domain", "co", "custom", "cc", "byte", "container", "event", "rule", "gc", "ce", "session", "conn", "cost", "query", "inner", "request", "vid", "cdn", "child", "temp", "c", "menu", "secret", "path", "cat", "cache", "cook", "info", "gi", "ookie", "fee", "prefix", "qq", "code", " cookies", "timeout", "cb", "conf", "token"], "flow": ["low", "note", "frame", "one", "element", "fx", "wall", "sync", "ce", "forward", "fs", "f", "draw", "cf", "fee", "week", "ga", "front", "gen", "fp", "row", "balance", "fly", "form", "view", "call", "grade", "rule", "bug", "fw", "load", "cow", "loop", "lane", "driver", "base", "pool", "layout", "flo", "control", "card", "game", "container", "full", "image", "account", "use", "block", "go", "child", "instance", "fall", "io", "comment", "qa", "model", "ow", "ge", "route", "board", "feed", "work", "Flow", "fl", "allow", "fail", "progress", "ork", "zip", "client", "out", "create", "request", "flows", "cart", "force", "parent", "cache", "node"]}}
{"project": "FFmpeg", "commit_id": "fc9b22dd2e5de851a89245b5357e710b93587278", "target": 0, "func": "static int rtp_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    RTPContext *s;\n\n    int port, is_output, ttl, local_port;\n\n    char hostname[256];\n\n    char buf[1024];\n\n    char path[1024];\n\n    const char *p;\n\n\n\n    is_output = (flags & URL_WRONLY);\n\n\n\n    s = av_mallocz(sizeof(RTPContext));\n\n    if (!s)\n\n        return AVERROR(ENOMEM);\n\n    h->priv_data = s;\n\n\n\n    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,\n\n              path, sizeof(path), uri);\n\n    /* extract parameters */\n\n    ttl = -1;\n\n    local_port = -1;\n\n    p = strchr(uri, '?');\n\n    if (p) {\n\n        if (find_info_tag(buf, sizeof(buf), \"ttl\", p)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (find_info_tag(buf, sizeof(buf), \"localport\", p)) {\n\n            local_port = strtol(buf, NULL, 10);\n\n        }\n\n    }\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port, local_port, ttl);\n\n    if (url_open(&s->rtp_hd, buf, flags) < 0)\n\n        goto fail;\n\n    local_port = udp_get_local_port(s->rtp_hd);\n\n    /* XXX: need to open another connection if the port is not even */\n\n\n\n    /* well, should suppress localport in path */\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port + 1, local_port + 1, ttl);\n\n    if (url_open(&s->rtcp_hd, buf, flags) < 0)\n\n        goto fail;\n\n\n\n    /* just to ease handle access. XXX: need to suppress direct handle\n\n       access */\n\n    s->rtp_fd = udp_get_file_handle(s->rtp_hd);\n\n    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);\n\n\n\n    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);\n\n    h->is_streamed = 1;\n\n    return 0;\n\n\n\n fail:\n\n    if (s->rtp_hd)\n\n        url_close(s->rtp_hd);\n\n    if (s->rtcp_hd)\n\n        url_close(s->rtcp_hd);\n\n    av_free(s);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 5617, "substitutes": {"h": ["j", "ih", "e", "d", "hand", "uh", "rh", "hr", "ch", "hm", "hl", "n", "l", "eh", "hp", "hh", "c", "m", "sh", "v", "t", "g", "host", "f", "oh", "ah", "cl", "hw", "gh", "ph", "o", "H", "bh", "he", "z", "b", "http", "hs", "q", "ha", "ht", "x"], "uri": ["ui", "data", "dir", "url", "text", "component", "str", "cli", "api", "slice", "base", "mi", "username", "qi", "uni", "r", "query", "u", " URI", "id", "ip", "abi", "address", "range", "iri", "io", "source", "ri", "i", "iv", "filename", "gi", "prefix", "origin", "database", "route", "href", "http", "fp", "resource", "prot", "URI", "format"], "flags": ["ffff", "local", "options", "ages", "linux", "FLAG", "caps", "properties", "opens", "fun", "parts", "lines", "ats", "comments", "mask", "plugins", " Flags", "args", "links", "alf", "faces", "atts", "orts", "sf", "ips", "stats", "types", "files", "ops", "fd", "lag", "ags", "fields", "Flags", "fs", "f", "ants", "vals", "flag", "settings", "ints", "utf", "lf", "bits", "ff", "reads", "features", "offs", "items", "status", "errors", "planes", "prot", "utils", "fl", "format"], "s": ["d", "sports", "site", "ops", "sg", "services", "fs", "f", "sv", "b", "sk", "conf", "v", "sq", "sb", "ses", "cs", "r", "u", "sf", "ss", "ts", "t", "ns", "sa", "w", "es", "http", "hs", "ins", "storage", "parts", "sys", "ks", "ls", "session", "S", "ps", "gs", "sets", "xs", "n", "c", "g", "us", "ssl", "sl", "su", "bs", "qs", "rs", "si", "spec", "y", "aws", "j", "e", "socket", "is", "sc", "service", "ds", "l", "sym", "m", "sh", "ctx", "source", "as", "sn", "settings", "i", "o", "js", "os"], "port": ["pos", "pi", "index", "ress", "url", "end", "target", "name", "text", "limit", "component", "import", "key", "ure", "ocol", "server", "slice", "type", "pid", "username", "offset", "method", "phone", "position", "patch", "test", "line", "password", "id", "file", "ip", "PORT", "m", "rest", "version", "address", "host", "f", "page", "hop", "mobile", "ort", " transport", "sl", "ports", "prefix", "code", "project", "length", "col", "direction", "http", "post", "select", "v"], "is_output": ["isckout", " is_progress", "isckwritten", "is_format", " is_format", " is_default", " is_out", " is_written", "is_written", "isckformat", "is_out", "is_progress", "is_default", "isckoutput"], "ttl": ["optn", "ottb", "tsli", "tsol", "ottlc", "optt", "ntn", "gtlc", "zzl", "ttb", "ottd", "zzol", "ettll", "tsn", "ottll", "gytl", "tzl", "ttt", "ntl", "gtd", "tsl", "ettp", "ttd", "tzlc", "tsll", "tzd", "gylen", "ttll", "ttn", "rtp", "ottul", "rtl", "gyt", "tttl", "ttp", "rtb", "ottp", "gtl", "gyl", "rttl", "ottli", "zzli", "ettl", "gtli", "optl", "ntt", "rtll", "rtt", "tslen", "ettb", "ttli", "tzli", "tstl", "ottol", "optll", "rtlen", "ttul", "tsul", "ttlc", "tst", "ttol", "ntll", "zzul", "ttlen", "ottl"], "local_port": ["localvelport", "remote_port", "localvelports", "local67host", "remote_value", "localityhost", " local_host", "local_prefix", "local_line", "local_nat", "localityport", "localvelnat", "global_address", "localveladdress", "local_host", "local_ports", "remote_pod", "localtheprefix", "localvelhost", "global_port", "local_address", "local_value", " local_line", "local_pod", " local_slice", "localityslice", "localtheport", " local_nat", "local67pod", "local_slice", "local67value", "global_host", "global_prefix", "localtheports", "localthehost", "localityline", "remote_ports", " local_ports", "global_ports", "local67port", "remote_host"], "hostname": ["serverna", "HostName", "hostsize", "Hostsize", "hardnam", "fullsize", "hardno", " hostName", "portnames", " hostsize", "hardname", "portpart", "homename", "serverline", "Hostnames", "hardline", "containerpart", "Hostname", "homenam", "hostline", "containername", "hostna", "hostpart", "homepath", "containernames", "portname", "Hostline", "hostName", "serverno", "hardnames", "servername", " hostna", "servernames", " hostpath", "fullname", "hardpath", "hostno", "hardna", " hostno", "serverName", "fullName", "hardName", "hostnames", "hostnam", " hostnames", "hostpath", " hostnam", "fullnames", " hostpart"], "buf": ["msg", "br", "callback", "text", "Buffer", "img", "cmd", "file", "buff", "grab", "bc", "f", "Buff", "pkg", "front", "b", "count", "fp", "v", "binary", "batch", "data", "context", "pb", "ref", "bus", "begin", "val", "map", "box", "config", "txt", "cv", "mount", "loop", "code", "uf", "rb", "null", "cb", "http", "font", "base", "pool", "uc", "rc", "bag", "len", "vec", "block", "fd", "c", "home", "prop", "padding", "feat", "prefix", "bh", "length", "feed", "window", "wb", "func", "proc", "loc", "queue", "src", "seq", "fb", "ctx", "cur", "buffer", "array", "cache", "ph", "filename", "la"], "path": ["root", "data", "context", "rc", "dir", "url", "ref", "proc", "PATH", "text", "name", "value", "loc", "str", "key", "anc", "type", "full", "resource", "box", "config", "cmd", "password", "id", "file", "request", "temp", "content", "home", "host", "buffer", "pointer", "prop", "cat", "mount", "parent", "bin", "cache", "ph", "prefix", "code", "Path", "route", "board", "desc", "alias", "http", "ath", "stream", "method"], "p": ["py", "data", "pb", "pi", "pc", "np", "proc", "vp", "pre", "param", "e", "tp", "op", "api", "params", "type", "ps", "pr", "r", "pa", "u", "sp", "pn", "P", "l", "n", "ip", "jp", "ap", "m", "c", "t", "f", "pointer", "pp", "padding", "prop", "pkg", "wp", "part", "parent", "i", "o", "prefix", "lp", "pe", "bp", "b", "null", "po", "fp", "cp", "parser", "v"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n\n                                       PutBitContext *pb, const float *in,\n\n                                       const float *scaled, int size, int scale_idx,\n\n                                       int cb, const float lambda, const float uplim,\n\n                                       int *bits)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    float cost = 0;\n\n    int qc1, qc2, qc3, qc4;\n\n    int curbits = 0;\n\n\n\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    for (i = 0; i < size; i += 4) {\n\n        const float *vec, *vec2;\n\n        int curidx, curidx2, sign1, count1, sign2, count2;\n\n        int   *in_int = (int   *)&in[i];\n\n        float *in_pos = (float *)&in[i];\n\n        float di0, di1, di2, di3;\n\n        int t0, t1, t2, t3, t4;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 8 * qc1;\n\n        curidx += qc2;\n\n\n\n        curidx2 = 8 * qc3;\n\n        curidx2 += qc4;\n\n\n\n        curbits += p_bits[curidx];\n\n        curbits += upair7_sign_bits[curidx];\n\n        vec     = &p_codes[curidx*2];\n\n\n\n        curbits += p_bits[curidx2];\n\n        curbits += upair7_sign_bits[curidx2];\n\n        vec2    = &p_codes[curidx2*2];\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n", "idx": 5621, "substitutes": {"s": ["proc", "e", "sb", "sys", "p", "sync", "ls", "session", "ps", "sc", "ses", "cs", "gs", "ds", "ops", "ss", "c", "ts", "fs", "g", "f", "sa", "ssl", "sv", "b", "setup", "spec"], "pb": ["ub", "pc", "gb", "proc", "vp", "ppa", "PC", "pg", "sb", "ses", "kB", "fb", " p", "abc", "pm", "bc", "pd", "ib", "pp", "wp", "cv", "PB", "lp", "bp", "rb", "bps", "cp", "cpp"], "in": ["data", "index", "pin", "input", "d", "str", "val", "din", "isin", "src", "slice", "inc", "image", "cm", "login", "out", "config", "query", "inner", "at", "nin", "again", "m", "In", "gin", "f", "inn", "source", "pass", "scan", "min", "ssl", "bin", "scl", "lin", "ints", "ins", "con", "complex", "vin", "IN"], "scaled": ["escalled", "SCalled", "oscraped", " scalled", "scaling", "scale", "configalled", "configraped", "expaled", "configaped", "Scaped", " Scaped", "SCaved", "Scilled", " scaped", " Scalled", "staped", " scraped", "scaved", "SCaled", "oscalled", "Scaved", "escaped", "Scaled", "oscaled", "SCaling", "expaped", " scaling", "staled", "expilled", "Scalled", "stilled", " scaved", "scalled", "stalled", "scraped", "Scale", " Scale", "scilled", "configaled", "expalled", "oscaling", "Scaling", "Scraped", " Scaled", "escaled", "scaped", "escale"], "size": ["ffff", "np", "small", "sec", "sq", "scale", "loc", "len", "cm", "uni", "SIZE", "ii", "cs", "ize", "mode", "sh", "Size", "c", "sn", "crop", "code", "ci", "shape", "six"], "scale_idx": ["scale_pidx", "scale_idced", "scale_countxp", "scale_initb", "scale_countX", "scale_pidz", "scale_initced", "scale_pidg", "scale_idexes", "scale_idex", "scale_idX", "scale_indx", "scale_idsv", "scale_idxp", "scale_idg", "scale_ideced", "scale_namexp", "scale_nameX", "scale_ideb", "scale_initxes", "scale_pidv", "scale_indb", "scale_idv", "scale_idsg", "scale_countx", "scale_indxes", "scale_idsz", "scale_idb", "scale_counte", "scale_initx", "scale_indced", "scale_idz", "scale_namex", "scale_idxes", "scale_idsx", "scale_namee", "scale_ide"], "cb": ["nc", "abb", "wb", "uc", "lb", "low", "gb", "db", "bf", "sb", "core", "src", "buf", "kk", "cod", "cm", "bb", "cor", "fb", "ctr", "obb", "abc", "ob", "buff", "CB", "ctx", "bc", "dc", "repeat", "nb", "uv", "kb", "ctrl", "crop", "cv", "fc", "cf", "loop", "lc", "cd", "ff", "rb", "cmp", "cpp"], "lambda": [" gamma", "func", "UC", "nc", "da", "appa", "sq", "circ", " disp", "beta", "phi", " beta", " lam", "mega", "abc", "LA", "dc", "alpha", " sig", "cl", "qa", "mu", "la", "shape", "igma", " la"], "uplim": ["Uplim", "usplam", "uclength", "uPLength", "uPLim", "uclims", "usplim", "usplims", "Uplims", "usplength", "uclim", "uPLims", "Uclam", "uPLam", "Uclims", "uclam", "uplims", "Uplength", "Uclim", "Uclength", "uplength", "uplam", "Uplam"], "bits": ["batch", "pos", "fps", "gb", "pins", "blocks", "bit", "ps", "forces", "bytes", "pieces", "rows", "ops", "bis", "flags", "its", "ints", "units", "bands", "features", "b", "bs", "bps", "planes", "ips"], "i": ["bi", "ui", "y", "pi", "index", "k", "ie", "ei", "j", "di", "e", "mini", "multi", "fi", "li", "p", "ti", "yi", "uli", "slice", "type", "h", "is", "mi", "phi", "ij", "qi", "ii", "adi", "uni", "u", "inner", "ji", "ind", "id", "n", "ni", "l", "ip", "chi", "abi", "c", "ix", "oi", "f", "sup", "zi", "io", "min", "a", "ini", "info", "iv", "gi", "mu", "xi", "x", "uri", "it", "my", "ci", "eni", "z", "b", "iu", "I", "ai", "vis", "v", "si"], "qc1": ["qdc2", " qdc2", "qsc4", "sqc4", "qc8", "sqsc1", "qcs8", "qf1", "qsc2", "qdc91", "qcs1", "qf2", "qcsone", "ql2", "qf8", "ql1", "sqsc91", " qcone", "qc91", "sqsc2", " qdc1", "qdc4", "qcs2", "qfone", "sqc1", " qdc8", " qc8", "qdcone", "qdc1", "qcone", "qsc91", "qsc1", "sqc2", "qdc8", " qdcone", "sqsc4", "sqc91", "ql4", "ql91"], "qc2": ["klc2", "kc42", "qc8", "qc182", "qrFuture", " qcFuture", "qcs8", "qsc2", "qsc32", "qce8", "qcr32", "qr8", "qlc2", "qcs2", "qsc8", "klc32", "qc32", "qlc32", "qcs182", " qc8", "kc32", "qr182", "kc8", "qcr42", " qr182", "qcsFuture", " qc182", "qcr8", "qceFuture", "qsc42", " qr8", "qr2", "qcr2", "klc8", "kc2", "qce2", "qc42", " qr2", "qlc42", "qlc8", "qcFuture", "qce182", "klc42", " qrFuture"], "qc3": ["qr3", "qcs23", "qc8", " qcs3", "qr5", " qc5", " qsc5", "qb3", " qsc15", "qc15", "qp6", "qc23", "qpc8", "qr6", "qc6", "qp3", "qcs5", "qcs3", "qsc8", " qc23", "qpc5", "qp23", "qpc3", "qpc15", " qc8", "qsc5", "qsc3", " qsc3", " qsc8", " qcs23", "qr23", "qsc15", "qcs6", " qcs6", " qc15", "qp5", "qc5", " qc6", " qcs5", "qb5", "qb8", "qb15"], "qc4": ["qlc7", " qf7", " qfCore", "quci6", " qc5", "quci4", "qc7", "qlcCore", "qvc4", " qf4", "qci04", " qcCore", "qci6", "qvc7", "qC6", "qc6", "quci04", "qlc6", "qlc54", "qci54", "qf7", "qc04", "qC04", "quc04", "qc54", "quci54", "qC54", "quc54", "qcCore", "qC4", "qfCore", "qlc5", "quc4", "qlc04", "qf5", " qf5", "qf4", "qlc4", "qc5", " qc7", "qvcCore", "qci4", "qvc5", "quc6"], "p_bits": ["p_bytes", "p_flags", "P_ops", "P_bits", "P_flags", "P_bytes", "p_ops"], "p_codes": ["c_desc", "p_desc", "c_code", "c_codes", "c_vec", "p_vec", "p_code"], "vec": ["flat", "def", "mat", "circ", "vert", "len", "str", "slice", "nec", "buf", "sc", "seq", "crit", "vector", "ctr", "norm", "version", "cube", "tri", "cat", "cv", "feat", "ver", "cap", "spec"], "vec2": ["vert2", "exp5", "vec0", "vert5", "vec5", "vert1", "vec1", "exp1", "cv1", "vert0", "exp0", "cv2", "cv5", "cv0", "exp2"], "curidx": [" curidy", "curridy", "curidc", "curidy", "curridp", "curIdx", "curridx", "curidey", " curIdy", " curIdp", "curidp", "curidep", "curIdp", " curIdx", "curIdc", "curridc", " curIdc", "curidec", "curidex", "curIdy", " curidc", " curidp"], "curidx2": ["curidn4", "curidx4", "curidn1", "curidn32", "curidz4", "curidx32", "curidx1", "curidz2", "curidy1", "curidy32", "curidy4", "curidz32", "curidn2", "curidz1", "curidy2"], "sign1": ["sum2", "SignA", "sumA", " signA", "Sign2", "Sign1", "signA", "sum1"], "count1": ["weightone", " count01", "signone", "count01", "countone", "sign01", " countone", "weight01", "weight1"], "sign2": ["count0", "Sign4", "sum2", "sum4", "Sign0", "count4", "sum0", "Sign1", "sign4", "Sign2", "sum1", "sign0"], "count2": [" count4", "countb", " count8", "sign8", "count4", "patch8", " countb", "patchb", "sign4", "patch2", "patch4", "count8", "signb"], "in_int": ["inc_int", "inc_ind", "inc_float", "in_float", "in_ind", "in_index", "inc_index"], "in_pos": ["in67pos", "in67position", "in_rot", "in67flo", " in_flo", " in_rot", "in_position", " in_position", "in67rot", "in_flo"], "di0": ["ni1", "ni0", "ni80", "ti1", " di50", "di80", "ti50", "ni50", "ti0", "di50", "ti80", " di80"], "di1": ["ni1", "ni3", "ni0", "d0", "dim3", "d3", "d8", "d1", "dim1", "di8", "dim0", "dim8", "ni8"], "di2": ["ini5", "mi0", "mi2", "i4", "di4", "ini0", "ini2", "mi4", "mi5", "i5", "di5", "i2", "i0", "ini4"], "di3": ["bi3", "bi4", "bi33", "i3", "i4", "i15", "di4", "Di4", "i33", "di15", "di33", "Di3", "Di33", "bi15", "Di15"], "t0": ["p6", "p00", "p0", "p2", "e2", "t00", "e6", "e0", " t00", "e00", "t6", " t6"], "t1": ["T2", "p2", "p0", "p1", "T1", "pt0", "pt1", "T0", "pt2"], "t2": ["T2", "type1", "T4", "type4", "type0", "T1", "pt0", "pt1", "pt4", "T0", "pt2", "type2"], "t3": ["TThree", "itThree", "te15", "t15", "te3", "teThree", "te1", "T1", "T15", "it15", "it1", "tThree", "T3", "it3"], "t4": ["T2", "it2", "t04", "T384", "it384", "it4", " t384", "T04", "T4", " t04", "t384", "it04"]}}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n", "idx": 5624, "substitutes": {"tokens": ["takenos", "tokenen", "tokenenos", "toksenos", "toksen", "atokenens", "pakenos", "pokenos", "toksens", "targets", "atokenets", "atokenents", "atokenen", "takens", "targents", "takets", "tokenens", "tokenents", "tokenos", "toksets", "atokents", "paken", "taken", "tokenets", "atokets", "pokets", "tokets", "toksents", "atokens", "pokens", "atoken", "pakets", "targen", "tokents", "targens", "pakens", "poken", "token"], "ap": ["ak", "au", "ab", "rep", "apa", "af", "p", "api", "mp", "AP", "app", "ps", "ep", "pa", "sp", "at", "jp", "ip", "Ap", "apy", "gap", "as", "apper", " AP", "aps", "ar", "aper", "al", "tap", "amp", "apt", "cap", "ape", "rap", "ac", "arp", "ax"], "errp": ["erP", "interfp", "errr", " errfp", "erp", "interp", "errP", "interlp", "erlp", "interP", "rorpp", " errpp", "rorfp", "errpp", "erfp", " errP", " errr", "errfp", "err", "errlp", "rorp", " errlp", "erpp", "rorr"], "working": ["data", "worker", "new", "looking", "starting", "opening", "raw", "moving", "won", "p", "checking", "base", "binding", "acting", "using", "calling", "ing", "inner", "reading", "works", "obj", "Working", "setting", "containing", "packing", "array", "padding", "writing", "ping", "learning", "processing", "w", "prefix", "ising", "going", "forcing", "workers", "loading", "missing", "resource", "running", "work", "existing", "testing"], "result": ["date", "root", "data", "math", "new", "complete", "func", "object", "final", "success", "value", "element", "message", "raw", "p", "arr", "df", "answer", "order", "Result", "r", "current", "dict", "response", "res", "obj", "instance", "f", "next", "page", "array", "comment", "other", "master", "parent", "cache", "err", "json", "product", "match", "valid", "attr", "arg", "found", "results", "resource", "work", "output"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int init_directories(BDRVVVFATState* s,\n\n                            const char *dirname, int heads, int secs,\n\n                            Error **errp)\n\n{\n\n    bootsector_t* bootsector;\n\n    mapping_t* mapping;\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster_buffer=g_malloc(s->cluster_size);\n\n\n\n    /*\n\n     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),\n\n     * where sc is sector_count,\n\n     * spf is sectors_per_fat,\n\n     * spc is sectors_per_clusters, and\n\n     * fat_type = 12, 16 or 32.\n\n     */\n\n    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n\n    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */\n\n\n\n    s->offset_to_fat = s->offset_to_bootsector + 1;\n\n    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;\n\n\n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n\n\n    /* add volume label */\n\n    {\n\n        direntry_t* entry=array_get_next(&(s->directory));\n\n        entry->attributes=0x28; /* archive | volume label */\n\n        memcpy(entry->name, s->volume_label, sizeof(entry->name));\n\n    }\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    s->cluster_count=sector2cluster(s, s->sector_count);\n\n\n\n    mapping = array_get_next(&(s->mapping));\n\n    mapping->begin = 0;\n\n    mapping->dir_index = 0;\n\n    mapping->info.dir.parent_mapping_index = -1;\n\n    mapping->first_mapping_index = -1;\n\n    mapping->path = g_strdup(dirname);\n\n    i = strlen(mapping->path);\n\n    if (i > 0 && mapping->path[i - 1] == '/')\n\n        mapping->path[i - 1] = '\\0';\n\n    mapping->mode = MODE_DIRECTORY;\n\n    mapping->read_only = 0;\n\n    s->path = mapping->path;\n\n\n\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n\n        /* MS-DOS expects the FAT to be 0 for the root directory\n\n         * (except for the media byte). */\n\n        /* LATER TODO: still true for FAT32? */\n\n        int fix_fat = (i != 0);\n\n        mapping = array_get(&(s->mapping), i);\n\n\n\n        if (mapping->mode & MODE_DIRECTORY) {\n\n            mapping->begin = cluster;\n\n            if(read_directory(s, i)) {\n\n                error_setg(errp, \"Could not read directory %s\",\n\n                           mapping->path);\n\n                return -1;\n\n            }\n\n            mapping = array_get(&(s->mapping), i);\n\n        } else {\n\n            assert(mapping->mode == MODE_UNDEFINED);\n\n            mapping->mode=MODE_NORMAL;\n\n            mapping->begin = cluster;\n\n            if (mapping->end > 0) {\n\n                direntry_t* direntry = array_get(&(s->directory),\n\n                        mapping->dir_index);\n\n\n\n                mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;\n\n                set_begin_of_direntry(direntry, mapping->begin);\n\n            } else {\n\n                mapping->end = cluster + 1;\n\n                fix_fat = 0;\n\n            }\n\n        }\n\n\n\n        assert(mapping->begin < mapping->end);\n\n\n\n        /* next free cluster */\n\n        cluster = mapping->end;\n\n\n\n        if(cluster > s->cluster_count) {\n\n            error_setg(errp,\n\n                       \"Directory does not fit in FAT%d (capacity %.2f MB)\",\n\n                       s->fat_type, s->sector_count / 2000.0);\n\n            return -1;\n\n        }\n\n\n\n        /* fix fat for entry */\n\n        if (fix_fat) {\n\n            int j;\n\n            for(j = mapping->begin; j < mapping->end - 1; j++)\n\n                fat_set(s, j, j+1);\n\n            fat_set(s, mapping->end - 1, s->max_fat_value);\n\n        }\n\n    }\n\n\n\n    mapping = array_get(&(s->mapping), 0);\n\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n\n    s->last_cluster_of_root_directory = mapping->end;\n\n\n\n    /* the FAT signature */\n\n    fat_set(s,0,s->max_fat_value);\n\n    fat_set(s,1,s->max_fat_value);\n\n\n\n    s->current_mapping = NULL;\n\n\n\n    bootsector = (bootsector_t *)(s->first_sectors\n\n                                  + s->offset_to_bootsector * 0x200);\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    /* media descriptor: hard disk=0xf8, floppy=0xf0 */\n\n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n\n    bootsector->number_of_heads = cpu_to_le16(heads);\n\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    /* drive_number: fda=0, hda=0x80 */\n\n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n\n           sizeof(bootsector->u.fat16.volume_label));\n\n    memcpy(bootsector->u.fat16.fat_type,\n\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 5630, "substitutes": {"s": ["d", "sync", "site", "sg", "services", "fs", "f", "sv", "b", "in", "conf", "south", "private", "new", "sites", "sq", "sb", "params", "ses", "cs", "this", "r", "u", "sf", "current", "ss", "ts", "t", "ns", "a", "its", "your", "es", "status", "http", "storage", "parts", "sys", "self", "p", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "n", "c", "setting", "g", "us", "ssl", "state", "same", "single", "qs", "rs", "si", "spec", "e", "server", "is", "service", "ds", "l", "states", "sym", "m", "source", "settings", "se", "secondary", "o", "js", "os"], "dirname": ["filenam", "dirpath", "dirword", "directionpath", "dirnam", "dirame", "directioname", "foldersize", "dirsize", "fileword", "folderword", "directionname", "DIRname", "foldername", "DIRName", "directoryname", "directionsize", "directorypath", "dirName", "DIRame", "directionnam", "filesize", "filename", "directoryName", "directoryame", "directionName", "foldernam", "DIRpath", "directionword"], "heads": ["nc", "depth", "rc", "header", "loc", "frames", "lines", "blocks", "src", "links", "ls", "tail", "head", "tails", "files", "cycles", "rows", "ops", "fs", "max", "names", "ints", "bits", "reads", "locks", "ptr", "lock", "rs"], "secs": ["seqsize", " secseconds", "descs", "secsize", " secsize", "secd", "seqseconds", "descd", "seqd", "seqs", "descseconds", "secseconds", "descsize", " secd"], "errp": ["irp", "errorping", "errorfp", "errping", "erps", "errorp", "erfp", "errps", "irping", "irps", "errorps", "erp", "errfp", "irfp", "erping"], "bootsector": ["voltsection", "voltsector", " bootsection", "locksector", " bootaddress", "bootsection", "lockaddress", "bootaddress", "voltaddress", "locksection"], "mapping": ["mashing", "mappings", "pashing", "Mapped", "pappings", "remapper", "moding", "mapper", "matching", "bapping", "bapped", "smailing", "Matching", " mapper", "bapper", "rematching", " migration", "mapped", "douting", "reminding", "smigration", "Mapping", "mording", "remapping", "naming", "mending", "Mapper", "hailing", "Mashing", "dapped", "dapper", "napping", "tashing", " mapped", "Mailing", "bashing", " moding", "digration", "Mending", "Mappings", "smouting", "lapper", "papper", "migration", "minding", "loding", "doding", " minding", "happing", "Migration", "lording", "smatching", " mappings", "mouting", "dapping", "smapped", "laming", "tapping", "nashing", "smoding", "noding", "smappings", "smashing", "hinding", "napper", "tapper", "latching", "papping", "smapper", "dappings", "dinding", "tatching", "nording", "lashing", " mailing", "sminding", "mailing", "lapped", "smapping", "smending", " mouting", "datching", "Moding", "lapping", "maming", " mending", "smording", "happer", "smaming", "Minding"], "i": ["ui", "bi", "y", "pi", "index", "di", "e", "d", "limit", "mini", "multi", "fi", "ti", "p", "yi", "slice", "type", "h", "mi", "phi", "qi", "ii", "anti", "u", "inner", "id", "n", "ni", "l", "ip", "dim", "chi", "abi", "c", "m", "init", "t", "sup", "f", "zi", "start", "ini", "parent", "axis", "info", "o", "gi", "size", "xi", "x", "uri", "mu", "ci", "eni", "lc", "z", "b", "in", "iu", "length", "count", "I", "ai", "v", "si", "li"], "cluster": ["licause", "clause", "luster", "closer", "lause", "licoser", "CLuster", "licuster", "CLoser", "lusters", "CLusters", "CLause", "licusters", "clusters", "loser"], "entry": ["data", "archive", "object", "index", "reader", "ie", "section", "de", "name", "element", "e", "way", "ident", "import", "key", "row", "server", "the", "connection", "no", "ry", "record", "image", "module", "line", "id", "file", "option", "child", "her", "enter", "ion", "next", "path", "source", "parse", "or", "ries", "attribute", "parent", "info", "o", "feed", "nt", "ent", "ge", "alias", "cell", "mission", "directory", "Entry"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n", "idx": 5646, "substitutes": {"base": ["py", "builder", "scope", "ase", "proxy", "frame", "ada", "area", "gb", "target", "scale", "name", "e", "server", "p", "Base", "type", "ace", "site", "ases", "id", "ip", "temp", "c", "home", "address", "buffer", "f", "source", "start", "kit", "info", "i", "prefix", "b", "addr", "bas"], "irqs": ["ireviews", "rinq", "rinviews", "irq", "mirviews", " irquest", "IRq", "mirqs", "irviews", "mirq", "irfs", " irq", "ireq", "irefs", "IRks", "irks", "rinqs", " irks", "IRquest", "mirquest", "rinfs", "ireqs", "mirks", "irquest", "IRqs", "mirfs"], "s": ["an", "options", "sq", "e", "d", "sb", "server", "p", "sync", "spec", "session", "S", "r", "u", "sf", "service", "ds", "n", "ss", "m", "c", "sym", "ts", "t", "fs", "g", "f", "ns", "array", "ssl", "settings", "i", "o", "secondary", "w", "span", "z", "js", "b", "conf", "v", "si"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    ram_addr_t sram_base, q2_base;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    /* Core */\n\n    s->mpu_model = omap2420;\n\n    s->env = cpu_init(core ?: \"arm1136-r2\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,\n\n                    (q2_base = qemu_ram_alloc(NULL, \"omap2.dram\",\n\n                                              s->sdram_size)) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,\n\n                    (sram_base = qemu_ram_alloc(NULL, \"omap2.sram\",\n\n                                                s->sram_size)) | IO_MEM_RAM);\n\n\n\n    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);\n\n\n\n    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n\n    cpu_irq = arm_pic_init_cpu(s->env);\n\n    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],\n\n                    cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],\n\n                    omap_findclk(s, \"mpu_intc_fclk\"),\n\n                    omap_findclk(s, \"mpu_intc_iclk\"));\n\n\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i ++)\n\n        dma_irqs[i] =\n\n                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),\n\n                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),\n\n                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),\n\n                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER1],\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER2],\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER3],\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER4],\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER5],\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER6],\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER7],\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER8],\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER9],\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER10],\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER11],\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER12],\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),\n\n                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C1_TX],\n\n                    omap_findclk(s, \"i2c1.fclk\"),\n\n                    omap_findclk(s, \"i2c1.iclk\"));\n\n    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),\n\n                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C2_TX],\n\n                    omap_findclk(s, \"i2c2.fclk\"),\n\n                    omap_findclk(s, \"i2c2.iclk\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = sysbus_from_qdev(s->gpio);\n\n    sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);\n\n    sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);\n\n    sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);\n\n    sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,\n\n                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,\n\n                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n\n                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,\n\n                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],\n\n                    /* Ten consecutive lines */\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    /* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 5670, "substitutes": {"sdram_size": ["sdram_sized", "sdcam_size", "sdram_fee", "sdram_sec", "sdram2address", "sdram_SIZE", "sdgram_size", "sdmem_model", "sdram2small", "sdram_small", "sdram_name", "sdam_SIZE", "sdmem_Size", "sdmem_sized", "sdram_Size", "sdram2size", "sdram_type", "sdgram_sec", "sdam_size", "sdram_scale", "sdram2SIZE", "sdmem_size", "sdcam_fee", "sdmem_scale", "sdram_ize", "sdram_bytes", "sdram_address", "sdam_small", "sdgram_type", "sdmem_ize", "sdcam_name", "sdam_address", "sdmem_bytes", "sdram_model"], "core": ["root", "scope", "nc", "ext", "rc", "k", "name", "Core", "sync", "native", "type", "sc", "pure", "channel", "cm", " Core", "processor", "resource", "ore", "external", "cy", "c", "mode", "ram", "cr", "cpu", " cores", "path", "platform", "ro", "model", "carry", "global", "gate", "score", "C", "python", "code", "arch", "node", "col", "con", "cp", "binary", "environment", "base"], "s": ["set", "d", "sync", "args", "ops", "sg", "services", "fs", "f", "b", "features", "conf", "south", "new", "sites", "sq", "sb", "h", "ses", "r", "cs", "u", "ss", "ts", "t", "uns", "ns", "sa", "a", "w", "its", "tests", "less", "es", "status", "hs", "ins", "sys", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "n", "c", "g", "us", "ssl", "sl", "state", "su", "qs", "rs", "si", "spec", "y", "aws", "e", "is", "sc", "service", "ds", "l", "states", "sym", "m", "settings", "se", "o", "secondary", "js", "os"], "sram_base": ["sram_address", "sram_size", "sram_area", "smem_source", "smem_base", "sramnsize", "sgram_size", "sram4size", "sram_source", "sramnarea", "sram_type", "sram4base", "sramfbase", "sram4address", "sramnsource", "smem_size", "sramfsize", "smem_area", "sramnbase", "sramftype", "sramfaddress", "sgram_address", "sram4type", "sgram_type", "sgram_base"], "q2_base": ["q2farea", "qnet_address", "q2_address", "q2fcache", "q2parea", "q2_cache", "q2pchannel", "q2pcache", "qnet_base", "q2_area", "qnet_area", "qtwo_cache", "qtwo_base", "q2_prefix", "q2fchannel", "qtwo_channel", "qtwo_area", "q2fbase", "q2_channel", "qnet_prefix", "q2pbase"], "cpu_irq": ["cpu_mirk", "cpu_igrqs", "cpu_nrq", "cpu_iperqu", "cpu_nirq", "cpu_irak", "cpu_nrqs", "cpu_igrquest", "cpu_nirqs", "cpu_pirk", "cpu_irap", "cpu_irqu", "cpu_ireqi", "cpu_IRk", "cpu_irequ", "cpu_mirqs", "cpu_iperqs", "cpu_irek", "cpu_ierqs", "cpu_mirqi", "cpu_irequest", "cpu_nirqu", "cpu_mirQ", "cpu_iraq", "cpu_ierk", "cpu_mirq", "cpu_irQ", "cpu_pirp", "cpu_ierq", "cpu_ierj", "cpu_igrqi", "cpu_pirq", "cpu_iraQ", "cpu_ireqs", "cpu_mirp", "cpu_IRqs", "cpu_igrq", "cpu_irk", "cpu_irqi", "cpu_irj", "cpu_pirQ", "cpu_iperk", "cpu_nrk", "cpu_nirk", "cpu_nrj", "cpu_ireq", "cpu_irquest", "cpu_IRj", "cpu_irqs", "cpu_IRq", "cpu_irp", "cpu_mirquest", "cpu_iperq"], "dma_irqs": ["dcpu_mirqs", "dcpu_iriqs", "dcpu_riqs", "dcpu_riqt", "dcpu_iriqt", "dcpu_iriqu", "dcpu_mirq", "dcpu_riqu", "dcpu_iriq", "dcpu_mirqt", "dcpu_irq", "dcpu_irqt", "dcpu_riq", "dcpu_irqu", "dcpu_irqs", "dcpu_mirqu"], "dinfo": ["dirinfo", "vdhi", "vdinfo", "dirmi", " ddef", "ddef", " dhi", "vddef", "dmi", "dirhi", "dhi", " dmi", "vdmi", "dirdef"], "i": ["bi", "pi", "j", "e", "d", "ti", "p", "is", "ii", "u", "ip", " I", "c", "m", "f", "a", "ri", "info", "o", "it", "gi", "b", "I", "ai", "v", "si", "li"], "busdev": [" busdi", "boarddi", "boarddev", "boardname", " busname", "busdef", "Busdi", " busdef", "Busdef", "Busdev", "busname", "boarddef", "busdi", "Busname"], "ta": ["fa", "da", "oa", "ao", "ast", "na", "ea", "ti", "ata", "beta", "ua", "sha", "ba", "dc", "wa", "sa", "tta", "sta", "ma", "ca", "ga", "ista", "tap", "va", "ora", "ama", "ra", "ya"]}}
{"project": "qemu", "commit_id": "c878da3b27ceeed953c9f9a1eb002d59e9dcb4c6", "target": 0, "func": "static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)\n\n{\n\n    int s_bits;\n\n    int ir;\n\n    int opc = label->opc;\n\n    int mem_index = label->mem_index;\n\n    int data_reg = label->datalo_reg;\n\n    int data_reg2 = label->datahi_reg;\n\n    int addr_reg = label->addrlo_reg;\n\n    uint8_t *raddr = label->raddr;\n\n    uint8_t **label_ptr = &label->label_ptr[0];\n\n\n\n    s_bits = opc & 3;\n\n\n\n    /* resolve label address */\n\n    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);\n\n\n\n    /* slow path */\n\n    ir = 3;\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);\n\n#if TARGET_LONG_BITS == 32\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#else\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n    ir |= 1;\n\n#endif\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#endif\n\n    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    switch (opc) {\n\n    case 0|4:\n\n        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));\n\n        break;\n\n    case 1|4:\n\n        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));\n\n        break;\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        if (data_reg != 3)\n\n            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);\n\n        break;\n\n    case 3:\n\n        if (data_reg == 3) {\n\n            if (data_reg2 == 4) {\n\n                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);\n\n            }\n\n            else {\n\n                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);\n\n            }\n\n        }\n\n        else {\n\n            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);\n\n            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n        }\n\n        break;\n\n    }\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n", "idx": 5672, "substitutes": {"s": ["sample", "d", "sync", "native", "site", "sg", "services", "fs", "f", "b", "groups", "conf", "v", "south", "private", "context", "local", "sq", "input", "sb", "ses", "cs", "r", "current", "ss", "t", "sing", "ns", "a", "secure", "less", "es", "http", "sys", "self", "p", "ls", "session", "S", "full", "gs", "sets", "xs", "n", "c", "g", "sup", "us", "ssl", "sl", "x", "spec", "scope", "y", "e", "is", "service", "ds", "request", "l", "states", "sym", "m", "sie", "ils", "settings", "se", "secondary", "o", "js", "os", "stat"], "label": ["note", "lab", "target", "hide", "bl", "jl", "shield", "el", "pal", "binary", "li", "data", "local", "ref", "ab", "loader", "input", "message", "tool", "key", "config", "ind", "lead", "address", "group", "bel", "role", "layout", "url", "cal", "abel", "facebook", "session", "Label", "lu", "sign", "plugin", "lib", "cookie", "block", "child", "yl", "console", "comment", "model", "sl", "prefix", "els", "route", "col", "align", "cell", "spec", "def", "field", "error", "loc", "pl", "bool", "ll", "BL", "fb", "l", "unknown", "sym", "gl", "il", "summary", "dl", "info", "desc", "alias", "ell"], "s_bits": [" s__its", "s_bit", "xs_bits", " s__bits", " s__details", "s__its", "s_its", " s_its", "s_locks", "s___details", "s__bits", "s_details", "s___its", "d_bit", "d_locks", "s__locks", "xs_vals", "s___flags", "s__vals", "xs_locks", "s___bits", "d_bits", "d_flags", "s_vals", "s__details", " s_flags", " s__flags", " s_details", "s_flags", "s__bit", "s__flags"], "ir": ["ear", "br", "outer", "rc", "dir", "ref", "area", "ih", "ner", "loc", "circ", "ior", "isc", "ur", "rf", "iris", "rx", "oc", "hr", "is", "inc", "pr", "shr", "r", "imp", "irt", "pir", "inner", "mir", "air", "id", "rr", "IR", "l", "irs", "n", "lr", "ril", "sr", "nir", "inter", "cur", "cr", "ire", "iri", "min", "nor", "req", "err", "ira", "i", "ar", "yr", "x", "fr", "iv", "dr", "vir", "iron", "rin", "in", "iter", "Ir", "arin", "http", "rel", "irc", "adr"], "raddr": ["rlen", " rreg", "wptr", "Raddress", "Rptr", "readdress", "wdr", "pdata", "plen", " rlen", "rarr", "Rdr", "Raddr", "parr", "paddr", "breg", "bdr", "readdr", "drdata", "draddr", "raddress", "rreg", "rptr", "reptr", "drarr", "baddr", "rereg", " rptr", " rdata", "baddress", "bptr", " raddress", "waddr", "drlen", "rdr", " rarr", "rdata", "waddress"], "label_ptr": ["data_ref", "label_pointer", "data_dr", "label_addr", "label__addr", "label_loc", "code_pointer", "label__ptr", "label__pair", "code_ref", "data_addr", "label__ref", "code_pair", "data_pointer", "label_dr", "data_ptr", "data_loc", "code_ptr", "label_pair", "label__pointer", "label_ref"]}}
{"project": "qemu", "commit_id": "46321d6b5f8c880932a6b3d07bd0ff6f892e665c", "target": 0, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,\n\n                                     uint32_t opt, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (length < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    length -= sizeof(namelen);\n\n    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    length -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    length -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != length / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        length -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN,\n\n                                          opt, errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, length, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 5673, "substitutes": {"client": ["local", "google", "pc", "queue", "input", "get", "co", "core", "cli", "server", "command", "call", "open", "api", "connection", "ce", "session", "socket", "conn", "image", "cod", "config", "remote", "cmd", "plugin", "Client", "ic", "connect", "child", "net", "c", "cart", "host", "sim", "min", "cache", "gi", "gui", "product", "project", "prefix", "cn", "manager", "close", "http", "q", "con", "cell", "serv", "irc", "public"], "length": ["section", "text", "Length", "build", "yet", "slice", "type", "id", "maximum", "sequence", "range", "duration", "timeout", "count", "lock", "angle", "available", "depth", "form", "total", "view", "limit", "message", "key", "offset", "position", "load", "address", "weight", "path", "other", "part", "size", "match", "code", "shape", "time", "http", "q", "pull", "library", "url", "number", "value", "len", "style", "email", "full", "cost", "tail", "large", "child", "join", "all", "height", "capacity", "character", "supp", "list", "delay", "level", "ength", "before", "end", "th", "error", "loc", "command", "zip", "seq", "support", "l", "broad", "impl", "sh", "buffer", "se", "ph", "filename", "letter"], "opt": ["operation", "allow", "options", "ext", "url", "optional", "open", "server", "op", "command", "params", "session", "socket", "seq", "config", "cmd", "option", "mode", "all", "path", "settings", "prefix", "attr", "timeout", "time", "method", "access", "port"], "myflags": ["sharedata", " sockdata", "mydata", "shareflags", "mystats", " sockstats", "sharestats", "mathdata", "shareFlags", "mathFlags", "mathstats", "myFlags", " sockflags", "mathflags", " sockFlags"], "errp": ["angerpre", "irp", "irapi", "hereps", "angerp", " errfp", "aerpre", "errorpre", "crypc", "Erpre", "irpre", "erp", " errpi", " errpc", "errP", "herepi", "herepre", "errorp", "errps", "Erapi", " errpp", "aerp", "errpi", "acerp", "errapi", " errwp", "errpc", "errpp", "erfp", "erwp", "errorP", "errorps", " errP", "herep", "errpre", "errfp", "cryp", "cryP", "errorpc", "acerfp", " errpre", "aerps", "aerpi", "acerwp", "cryps", "errwp", "angerpp", "Erp", " errapi", "errorpp", " errps", "angerpc"], "rc": [" cmd", " r", " conf", " reply", "RC", " error", " rec", " row", "src", " rs", "r", " payload", "id", " result", " ret", " alloc", " answer", " sc", " resp", " cur", "code", " ans", " success", " pri", " src", " res", " err", " enc"], "name": ["data", "new", "url", "number", "package", "error", "message", "len", "str", "mask", "key", "hello", "call", "command", "no", "connection", "search", "type", "num", " names", "change", "create", "id", "n", "block", "Name", "word", "all", "version", "address", "path", "description", "comment", "a", "common", "part", "parent", "info", "names", "size", "list", "prefix", "code", "cap", "ame", "desc", "NAME", "time", "count", "resource", "base"], "requests": ["reqences", "questencies", "compirements", "questes", "requestends", "latests", "commesters", "requients", "cencies", "sequients", "requasks", "lates", "reqencies", "requends", "resents", "multesters", "compests", "quirements", "compesters", "tasks", " requresses", "reqresses", "questests", "requencies", "multirements", " requensions", "reqests", "generesters", "resests", "Requests", "sequencies", "questirements", "sequences", "commests", " requirements", "reqensions", "reqesters", " requares", "tests", "compences", "reques", "triasks", "reqents", "compencies", "seques", "requares", "quresses", "sequests", "reqasks", "reqients", "questends", "requresses", "latends", "contests", "cirements", "generencies", "commients", "tirements", "triirements", "requestests", "resences", "quests", "contares", "requents", "quences", "ces", "questesters", "reqirements", "sequirements", "reqes", "multests", "sequents", "requirements", "reqares", "triests", "generirements", "requensions", "generests", "requesters", "contensions", "Requesters", "cests", "Requirements", "requences", "sequesters", "requestes"], "request": ["complete", "data", "allow", "object", "header", "callback", "push", "demand", "xml", "progress", "result", "queue", "error", "input", "message", "import", "hello", "server", "command", "required", "Request", "report", "call", "event", "session", "type", "pair", "record", "order", "download", "search", "QUEST", "use", "config", "query", "create", "issue", "task", "response", "except", "child", "effect", "press", "friend", "version", "transfer", "address", "buffer", "path", "lease", "req", "quest", "reference", "user", "require", "item", "route", "attr", "time", "post", "raise", "resource", "access", "pull"], "namelen": ["goldelien", "nameleize", "namelien", "goldlenien", "namelsense", "namllener", "samilener", "samellener", "timllon", "namillener", "namelineens", "namelsen", "samllen", "namileno", "nameltpen", "namelineng", "namelineener", "namlleno", "amelpen", "namillened", "namielener", "goldelen", "sameleno", "namellien", "namelinen", "namilon", "namelenc", "namlleng", "namellun", "nameleener", "samilened", "homellen", "namelinelen", "namellener", "samelize", "namilen", "nameleon", "samellen", "namilens", "namelena", "namelpen", "goldelener", "namelun", "namellpen", "samelened", "namlenisen", "samellens", "timelener", "namellen", "namellened", "namlenener", "namewense", "namewener", "namileng", "namellize", "namellena", "namllen", "samelen", "namillen", "timelon", "namlenien", "namelisen", "namewength", "samelpen", "namelength", "amelenc", "namelon", "namelener", "amelsen", "namelinpen", "amelsength", "nameltened", "goldlenener", "namllens", "homelener", "samelens", "samilpen", "nameleen", "amellenc", "namelinenc", "namewlen", "namelened", "amellened", "nameleng", "amelsens", "nameltisen", "namelten", "namelllen", "samllens", "nameleens", "namewena", "goldlenisen", "namellens", "timllen", "namilpen", "namewen", "timilun", "nameltener", "namelens", "homellena", "namilize", "namlenen", "namllpen", "amelense", "namielen", "namelinength", "timelen", "sameleng", "namellenc", "timllens", "timllener", "namelinener", "timileng", "amelens", "homellener", "amelened", "namelsength", "namewens", "namelleng", "namelepen", "namelineen", "homelen", "namilened", "amelen", "namilun", "namllon", "timilener", "timelens", "samileng", "amellen", "namielpen", "goldelisen", "namelineeno", "amelener", "namelineena", "timelun", "amelength", "samelener", "namilener", "namellisen", "namielenc", "goldlenen", "samllener", "samlleno", "nameltien", "nameleno", "samellize", "timilen", "nameleun", "amelsense", "namelinense", "nameleened", "namelinens", "samilen", "namelense", "timeleng", "homelena", "amellpen", "namilleng", "nameleeng", "namelize", "amellener", "namelsens", "homelllen"], "sizes": ["size", "statamples", "sized", "outsizes", "outsamples", "setsamples", "statizes", "outsize", "statize", "setsized", "statized", "setsizes", "samples", "setsize", "outsized"], "buf": ["data", "br", "ref", "bag", "loc", "queue", "Buffer", "mem", "map", "seq", "box", "bytes", "block", "buff", "var", "ba", "buffer", "array", "bin", "cache", "alloc", "cap", "uf", "b", "desc", "ptr", " buffer", "base"], "msg": ["cfg", "comm", "header", "help", "error", "text", "gor", "message", "str", "command", "mess", "call", "game", "lang", "mp", "type", "html", "module", "bug", "gs", "cmd", "id", "mn", "go", "man", "m", "sg", "Msg", "og", "bg", "g", "ms", "description", "sim", "comment", "hop", "pkg", "global", "info", "ma", "err", "reason", "ge", "ag", "gen", "desc", "arg", " message", "Message", "doc", "fg", "conf", "cmp", "body"]}}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5676, "substitutes": {"cmd": ["msg", "cfg", "func", "comm", "nc", "input", "auth", "custom", "cli", "command", "cc", "call", "dom", "client", "conn", "clean", "module", "cod", "cm", "config", "device", "plugin", "head", "ctr", "cdn", "cookie", "block", "child", "ck", "c", "mode", "add", "ctx", "dc", "host", "ctrl", "cat", "mac", "req", "pkg", "hw", "conf", "carry", "cf", "code", "md", "cd", "node", "grad", "cb", "vc", "cmp", "cp", "window", "Cmd"], "dev": ["data", "root", "Dev", "reader", "end", "def", "proc", "di", "diff", "rad", "de", "d", "exec", "ve", "server", "debug", "self", "mem", "dom", "nov", "DEV", "orig", "client", "app", "pad", "conn", "ev", "die", "device", "off", " device", "block", "dd", "var", "gd", "mode", "engine", "prof", "mod", "serial", "cam", "hw", "der", "info", "w", "ver", "nt", "md", "dm", "valid", "node", "grad", "priv", "conf", "v", "driver", "wd"], "buf": ["msg", "br", "header", "conv", "result", "text", "Buffer", "uber", "pad", "img", "off", "buff", "aux", "grab", "bc", "uv", "f", "usb", "Buff", "cf", "cap", "bd", "border", "b", "v", "batch", "data", "pb", "bn", "db", "ab", "begin", "app", "box", "config", "bb", "fam", "cat", "cv", "mac", "uf", "bound", "rb", "cb", "tab", "doc", "ptr", "ha", "uc", "rc", "bag", "gb", "vec", "bo", "block", "fd", "prop", "feat", "alloc", "utf", "comb", "bh", "wb", "func", "proc", "queue", "loc", "exc", "src", "seq", "fb", "ctx", "cur", "bg", "buffer", "nb", "array", "cache", "fab", "bu", "band", "port"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)\n\n{\n\n\tint arith_opt, move_opt;\n\n\n\n\t/* TODO: optimize more condition codes.  */\n\n\n\n\t/*\n\n\t * If the flags are live, we've gotta look into the bits of CCS.\n\n\t * Otherwise, if we just did an arithmetic operation we try to\n\n\t * evaluate the condition code faster.\n\n\t *\n\n\t * When this function is done, T0 should be non-zero if the condition\n\n\t * code is true.\n\n\t */\n\n\tarith_opt = arith_cc(dc) && !dc->flags_uptodate;\n\n\tmove_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;\n\n\tswitch (cond) {\n\n\t\tcase CC_EQ:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\t/* If cc_result is zero, T0 should be \n\n\t\t\t\t   non-zero otherwise T0 should be zero.  */\n\n\t\t\t\tint l1;\n\n\t\t\t\tl1 = gen_new_label();\n\n\t\t\t\ttcg_gen_movi_tl(cc, 0);\n\n\t\t\t\ttcg_gen_brcondi_tl(TCG_COND_NE, cc_result, \n\n\t\t\t\t\t\t   0, l1);\n\n\t\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\t\tgen_set_label(l1);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, \n\n\t\t\t\t\t\tcpu_PR[PR_CCS], Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_NE:\n\n\t\t\tif (arith_opt || move_opt)\n\n\t\t\t\ttcg_gen_mov_tl(cc, cc_result);\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tZ_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_CS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_CC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tV_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_PL:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, bits);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cc, 1);\n\n\t\t\t} else {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_MI:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, 31);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_HI:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv tmp;\n\n\n\n\t\t\t\ttmp = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\ttcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\t\t/* Overlay the C flag on top of the Z.  */\n\n\t\t\t\ttcg_gen_shli_tl(cc, tmp, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, tmp, cc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\n\n\t\t\t\ttcg_temp_free(tmp);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_GE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\ttcg_gen_xori_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_LT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_GT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\t\t\t\t/* invert Z.  */\n\n\t\t\t\ttcg_gen_xori_tl(z, z, 2);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_xori_tl(n, n, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_or_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_P:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_A:\n\n\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tBUG();\n\n\t\t\tbreak;\n\n\t};\n\n}\n", "idx": 5694, "substitutes": {"dc": ["context", "nc", "uc", "rc", "pc", "da", "dir", "director", "db", "input", "d", "tk", "coll", "exec", "jc", "anc", "dt", "du", "df", "design", "oc", "sc", "ct", "conn", "config", "dp", "ds", "cmd", "cca", "cdn", "ck", "c", "enter", "ctx", "bc", "cci", "draw", "mc", "ec", "fc", "cu", " DC", "cf", "gui", "tc", "ga", "dr", "lc", "cd", "dm", "DC", "ac", "center", "disc", "vc", "doc", "spec", "dat"], "cc": ["nc", "uc", "rc", "pc", "input", "PC", "RC", "coll", "co", "jc", "anc", "ice", "call", "ce", "cus", "gg", "client", "sc", "ct", "kk", "inc", "conn", "cod", "cs", "cm", "config", "ack", "cca", "dd", "CC", "ck", "c", "ctx", "cci", "bc", " CC", "acc", "pp", "mc", "cl", "ucc", "ec", "cel", "comment", "fc", "cf", "tc", "code", "ga", "ci", "lc", "cd", "ac", "vc", "cmp", "comp", "cell", "ctl", "spec"], "cond": ["Cond", "sec", "def", "pre", "loc", "co", "bool", "exec", "bit", "xc", "ct", "seq", "cm", "config", "cell", "cmd", "ind", "crit", "cont", "prep", "fd", "c", "ctx", "cr", "bc", "condition", "day", "cl", "tc", "comb", "reason", "lc", "ac", "fact", "col", "cb", "count", "comp", "cmp", "red", "unit", "format"], "arith_opt": ["arith_hop", "aruth_op", "arth_token", "arith_token", "arith_exp", "aruth_pot", "arith__option", "arith_optim", "arth_opt", "aruth_exp", "arth_option", "arith_pot", "aruth_optim", "arinth_oct", "arith__hop", "arinth_open", "arith__token", "arth_hop", "arith__op", "arith_oct", "arith__exp", "aruth_opt", "arith_open", "arith_option", "arith__opt", "aruth_option", "arinth_option", "arith_op", "arinth_opt"], "move_opt": ["move__option", "move_Opt", "movekorig", " move_Opt", " move_ort", "move__off", "move_orig", " move_option", "moveadoption", "move__opt", "moveayopt", "moveadort", " move_err", " move_tr", "movekoption", " move_mode", "move_ort", "move_option", " move_test", "moveadtest", "move__tr", "move_off", "move_err", "moveaymode", "moveayoption", " move_orig", "move_tr", "move__Opt", "moveadopt", " move_off", "move__err", "move_mode", "move_test", "moveayorig", "movekopt", "movekmode"], "l1": ["lone", "L3", "l6", "Lone", "L91", "li2", "li1", "ul2", " lone", " l6", "ln1", "L2", " l3", " l91", "l61", "ln91", "lione", "l01", " l2", "L1", "L61", "li3", "li01", "ln3", "li6", " l01", " l61", "ul1", "l91", "L01", "ul3", "ul61", "l2", "ln2", "L6", "l3"]}}
{"project": "qemu", "commit_id": "b4854f1384176d897747de236f426d020668fa3c", "target": 0, "func": "void do_smm_enter(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong sm_state;\n\n    SegmentCache *dt;\n\n    int i, offset;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"SMM: enter\\n\");\n\n    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);\n\n\n\n    env->hflags |= HF_SMM_MASK;\n\n    if (env->hflags2 & HF2_NMI_MASK) {\n\n        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;\n\n    } else {\n\n        env->hflags2 |= HF2_NMI_MASK;\n\n    }\n\n    cpu_smm_update(env);\n\n\n\n    sm_state = env->smbase + 0x8000;\n\n\n\n#ifdef TARGET_X86_64\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        offset = 0x7e00 + i * 16;\n\n        x86_stw_phys(cs, sm_state + offset, dt->selector);\n\n        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stq_phys(cs, sm_state + offset + 8, dt->base);\n\n    }\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);\n\n    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);\n\n    for (i = 8; i < 16; i++) {\n\n        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);\n\n    }\n\n    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);\n\n    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);\n\n#else\n\n    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        if (i < 3) {\n\n            offset = 0x7f84 + i * 12;\n\n        } else {\n\n            offset = 0x7f2c + (i - 3) * 12;\n\n        }\n\n        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);\n\n        x86_stl_phys(cs, sm_state + offset + 8, dt->base);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);\n\n    }\n\n    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);\n\n#endif\n\n    /* init SMM cpu state */\n\n\n\n#ifdef TARGET_X86_64\n\n    cpu_load_efer(env, 0);\n\n#endif\n\n    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n", "idx": 5707, "substitutes": {"cpu": ["cfg", "nc", "vm", "pc", "rc", "np", "lb", "proc", "eu", "loader", "gpu", "component", "core", "server", "cli", "clock", "pid", "conn", "num", "cm", "processor", "config", "intel", "kernel", "jp", "bench", "net", "c", "ctx", "dc", "boot", "px", "platform", "ec", "hw", "cache", "fc", "chip", "cn", "lc", "pu", "node", "cmp", "fp", "cp", "cpp", "linux", "environment", "CPU"], "env": ["ou", "np", "er", "que", "args", "ce", "energy", "ace", "site", "inv", "s", "init", "engine", "bc", "en", "el", "conf", "output", "context", "oa", "loader", "db", "enc", "exec", "ea", "cli", "ne", "config", "viron", "ah", "Environment", "cv", "osc", "ini", "esm", "gui", "code", "here", "het", "qt", "cb", "addr", "doc", "environment", "iss", "ext", "eu", "cal", "de", "skin", "export", "org", "ocr", "style", "conn", "dict", "et", "ef", "ass", "eng", "fen", "all", "g", "console", "req", "den", "_", "extra", "py", "scope", "cfg", "nc", "func", "end", "e", "exc", "core", "anc", "server", "ev", "impl", "net", "her", "ctx", "assets", "ec", "cache", "err", "global", "dev", "eni"], "cs": ["ys", "CS", "nc", "pc", "rc", "gb", "wcs", "core", "cc", "sys", "cli", "sync", "ks", "ls", "cus", "ce", "sc", "conn", "vs", "acs", "ch", "ds", "cms", "ck", "c", "css", "ctx", "bc", "cells", "fs", "ns", "ix", "cat", "acks", "cache", "cf", "ca", "tc", "code", "cn", "ci", "lc", "ac", "js", "sk", "cas", "Cs", "cks", "cb", "bs", "cmp", "cp", "vc", "qs", "cing", "spec", "ces"], "sm_state": ["sm__stat", "smkstate", "sm_area", " sm_context", "sm_grade", "sm__config", "sm__state", "utm_state", "Sm_state", "sm_shape", "wp_store", "si_estate", " sm_powered", "sm_stat", "smPstring", "shappresource", "sh_form", "sm_model", "mm_string", "sm64set", "sm_size", "sm___powered", "sm___string", "utm_status", "mm_STATE", "sm___status", "sm_STATE", "sm___resource", "sm_core", "sm_config", "sm5state", "sm_set", "SM_state", "Sm_State", "sm_string", "mm_state", "mm_family", "smappstate", "sb_err", "sm5status", "smappresource", " sm_string", "sm_State", "smPstate", "sm5err", "sm64class", "sm_class", "shapptag", "Sm_model", "sm___value", "sm_status", "mm_model", "sm_powered", "sb_state", "utm_shape", "sm_context", "sm___shape", " sm_area", "sm__core", " sm_size", "wp_class", "mm_resource", "sm_store", "sb_set", "sm5set", "SM_stat", "sm___state", "sh_resource", "shappform", "smPvalue", "smkresource", "SM_config", "sm_resource", "si_state", "Sm_grade", "smapptag", "smappform", "smkfamily", "sh_state", "sm_err", "mm_config", "SM_core", "utm_resource", "wp_state", "sm_estate", "sm_form", "sm_value", "sh_tag", " sm_value", "sm_tag", "wp_set", "smPpowered", "sm64state", "sm64store", "smkSTATE", "shappstate", "sb_status", "si_rule", "sm_family", "sm_rule", "si_resource"], "dt": ["note", "dn", "gm", "ou", "da", "timer", "di", "mt", "db", "d", "tn", "tk", "att", "dh", "dat", "dq", "conn", "tt", "tz", "lt", "elt", "ds", "dp", "cmd", "DT", "jp", "ut", "tu", "dd", "txt", "ts", "t", "ta", "dc", "pd", "kt", "tm", "vt", "tif", "dl", "tick", "nat", "utt", "gt", "wt", "tc", "dr", "bd", "md", "dm", "qt", "cb", "tf", "bt", "td", "ee", "rt"], "i": ["ui", "bi", "y", "index", "pi", "ie", "j", "di", "e", "d", "multi", "fi", "ti", "p", "li", "uli", "yi", "ski", "type", "mi", "phi", "qi", "ii", "uni", "adi", "u", "ji", "id", "n", "ni", "chi", "ip", "l", "ami", "s", "abi", "udi", "c", "ix", "oi", "f", "zi", "io", "start", "ri", "ini", "it", "gi", "x", "xi", "uri", "code", "ci", "eni", "z", "b", "iu", "count", "I", "ai", "v", "si", "base"], "offset": ["ui", "pos", "ext", "outer", "index", "reset", "optional", "error", "len", "p", "Offset", "base", "slice", "api", "style", "order", "image", "ii", "position", "off", "et", "iso", "option", "article", "entry", "layer", "address", "action", "f", "pointer", "shift", "range", "enabled", "art", "padding", "start", "hop", "attribute", "phase", "part", "slot", "o", "info", "size", "scroll", "origin", "item", "iterator", "timeout", "attr", "alias", "addr", "append", "fp", "ptr", "align", "port", "si"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n", "idx": 5718, "substitutes": {"nd": ["nc", "dn", "nn", "da", "np", "dist", "vd", "od", "ng", "de", "di", "d", "adv", "idd", "zn", "custom", "none", "nv", "wn", "mid", "std", "nov", "nz", "td", "ds", "cmd", "ind", "device", "n", "id", "cdn", "rn", "dd", "fd", "mind", "gd", "init", "rd", "hd", "dc", "nb", "nw", "inn", "anda", "ini", "dk", "ad", "nt", "bd", "ci", "cd", "md", "sd", "node", "kind", "und", "pd", "ND", "ld", "brand", "nda", "dat"], "default_model": ["default_language", "defaultlexdevice", " default_type", "defaultingmodels", " default_models", " default_device", "default_device", "default_Model", "defaultlexModel", "defaultlexlanguage", "defaultingtype", "defaultlexmodels", " default_Model", "defaultlextype", "default_models", "defaultingdevice", "defaultingmodel", " default_language", "default_type", "defaultlexmodel"], "default_devaddr": ["default_evref", "default_devname", "default_evaddr", "default_evaddress", "default_devaddress", "default_devref", "default_deviceref", "default_devicename", "default_evname", "default_deviceaddr", "default_deviceaddress"], "devaddr": ["Devref", "devicename", "diskattr", "evref", "deviceref", "diskaddr", "devname", " devname", "diskaddress", "devref", "diskref", "deviceaddr", "devaddress", "evname", "deviceattr", "deviceaddress", " devaddress", " devref", "evattr", "devattr", "evaddress", "Devaddr", "evaddr", "Devaddress"], "pci_dev": ["pci__conf", "pcu__conf", "pcu__ev", "pcu_device", "pci_device", "pcu_des", "pci_conf", "pcu__device", "pcu_conf", "pci__def", "pci_des", "pci__ev", "pcu__def", "pci__dev", "pci_ev", "pci_def", "pci__device", "pcu__dev", "pcu_ev", "pcu_def", "pcu_dev"], "dev": ["data", "Dev", "develop", "dist", "def", "di", "development", "rad", "error", "de", "adv", "d", "diff", "ve", "debug", "dom", "DEV", "conn", "test", "bug", "ev", "prom", "die", "device", "id", "block", "dd", "var", "gd", "init", "v", "dc", "mod", "err", "info", "ad", "ver", "user", "nt", "md", "cd", "sd", "priv", "dem", "conf", "gu", "wd", "private"], "i": ["ui", "bi", "y", "pi", "index", "k", "j", "di", "e", "d", "ti", "p", "type", "qi", "ii", "r", "u", "ind", "id", "n", "ni", "l", "ip", "m", "c", "t", "f", "zi", "io", "a", "ri", "ini", "o", "gi", "xi", "uri", "x", "in", "b", "iu", "I", "ai", "v", "si", "li"]}}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n", "idx": 5731, "substitutes": {"c": ["context", "nc", "pc", "rc", "e", "enc", "cc", "self", "p", "sc", "xc", "cm", "cs", "ch", "config", "s", "m", "t", "ctx", "dc", "bc", "arc", "g", "f", "cr", "cur", "ctrl", "mc", "ec", "cv", "fc", "cf", "ca", "C", "tc", "ci", "lc", "ac", "cb", "vc", "cmp", "cpp", "v"], "avctx": ["avkb", "avcontext", "AVcontext", "AVconfig", "afctx", "AVkb", " avkb", "afkb", " avconfig", "afcontext", "afconfig", "AVctx", " avcontext", "avconfig"]}}
{"project": "FFmpeg", "commit_id": "295b79b5d8c0cf0a9691f8d6b512aa1e289d528d", "target": 1, "func": "static av_cold int roq_encode_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;", "idx": 5754, "substitutes": {"avctx": ["ajcmp", "avaldc", "avecu", "avetx", "avloc", "avconfig", "archctx", "afctx", "avdc", "ajcontext", "avtx", "AVconn", "navctx", "avalctx", "afcdn", "Avloc", "avalcu", "ajcli", "aveloc", "afloc", " avvoc", "afcmp", "avelc", "afsci", " avcu", "afvoc", "avecontext", "apscontext", "afconn", "Avctx", "afcu", "archconn", "apsconn", "akconn", "AVctx", "avesci", "afctl", "aflc", "AVlc", "avevoc", "aveconfig", "Avcontext", "navcmp", "avcontext", "avectl", "aveconn", "Avconn", "avalvoc", "avecdn", "navcontext", "verloc", "avsci", "avconn", "vertx", "navconfig", "avecmp", "akctx", "verconn", "AVcontext", "akloc", "avcdn", "apsctx", "afcf", "avcmp", "aksci", "apscdn", "verctx", "avcli", "archcontext", "vercmp", "akcu", " avcf", "avalconn", "avalcontext", "vercontext", "avcu", "afconfig", " avcontext", "afdc", "avecf", "afcli", "avedc", " avconn", "avctl", "avcf", "afcontext", "avecli", "avlc", "vercu", "akcontext", "avalsci", "avectx", "aftx", "avvoc", "archctl", "ajctx"], "enc": ["pc", "ou", "od", "build", "coll", "equ", "acl", "ce", "rh", "ang", "kg", "bc", "ENC", "nw", "cel", "en", "hw", "el", "ver", "ew", "adj", "bn", "oa", "ae", "exec", "ann", "oc", "app", "config", "ic", "load", "dc", "rec", "acc", "cat", "mac", "code", "ent", "lc", "ac", "vc", "ee", "util", "oy", "unc", "ext", "uc", "rc", "eu", "sec", "sys", "ocr", "conn", "inc", "win", "lib", "et", "c", "eng", "ssl", "sl", "nt", "con", "ant", "adr", "nc", "loc", "e", "anc", "cc", "Enc", "nec", "lang", "client", "auc", "ct", "ch", "ev", "env", "cdn", "ctx", "cur", "act", "ec", "oder", "cache", "fc", "iv", "emb", "dev", "eni", "anne", "pack", "node", "ell"]}}
{"project": "FFmpeg", "commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "target": 1, "func": "void ff_h264_flush_change(H264Context *h)\n\n{\n\n    int i, j;\n\n\n\n    h->next_outputed_poc = INT_MIN;\n\n    h->prev_interlaced_frame = 1;\n\n    idr(h);\n\n\n\n    h->poc.prev_frame_num = -1;\n\n    if (h->cur_pic_ptr) {\n\n        h->cur_pic_ptr->reference = 0;\n\n        for (j=i=0; h->delayed_pic[i]; i++)\n\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n\n                h->delayed_pic[j++] = h->delayed_pic[i];\n\n        h->delayed_pic[j] = NULL;\n\n    }\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n\n\n    h->first_field = 0;\n\n    ff_h264_sei_uninit(&h->sei);\n\n    h->recovery_frame = -1;\n\n    h->frame_recovered = 0;\n\n    h->current_slice = 0;\n\n    h->mmco_reset = 1;\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        h->slice_ctx[i].list_count = 0;\n\n}\n", "idx": 5755, "substitutes": {"h": ["hash", "kh", "y", "han", "k", "beh", "ih", "th", "e", "him", "d", "self", "p", "uh", "rh", "hr", "history", "html", "hi", "ch", "u", "hl", "head", "hm", "hist", "n", "l", "eh", "hp", "hh", "m", "sh", "c", "t", "v", "hd", "her", "home", "host", "f", "g", "oh", "ah", "adh", "ec", "hw", "gh", "ph", "w", "o", "H", "bh", "he", "wh", "zh", "b", "how", "rah", "http", "hs", "q", "ha", "work", "ht", "x"], "i": ["ui", "bi", "y", "index", "pi", "k", "ie", "ei", "di", "e", "d", "mini", "fi", "ti", "yi", "p", "api", "slice", "is", "mi", "phi", "qi", "ii", "r", "u", "ji", "ind", "id", "n", "ni", "l", "ip", "jp", "s", "abi", "m", "c", "t", "ix", "oi", "f", "g", "zi", "io", "start", "a", "ri", "ini", "info", "o", "it", "gi", "x", "uri", "xi", "eni", "ci", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"], "j": ["bi", "br", "y", "k", "ie", "aj", "si", "e", "key", "jc", "p", "jit", "jl", "ij", "ii", "r", "u", "ji", "dj", "ind", "n", "jp", "l", "je", "obj", "jo", "c", "m", "ix", "f", "ja", "kj", "uj", "o", "xi", "fr", "x", "eni", "job", "z", "js", "b", "iu", "adj", "v", "J", "jj", "li"]}}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)\n\n{\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    void *dst;\n\n    if (o_out)\n\n        *o_out= o;\n\n    if (!o || o->offset<=0)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n\n\n    if (o->max*den < num*intnum || o->min*den > num*intnum) {\n\n        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n\n        return AVERROR(ERANGE);\n\n    }\n\n\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n\n\n    switch (o->type) {\n\n    case FF_OPT_TYPE_FLAGS:\n\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_RATIONAL:\n\n        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n\n        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5762, "substitutes": {"obj": ["pos", "nc", "object", "np", "ref", "oa", "j", "end", "ab", "e", "eff", "ord", "coll", "pl", "val", "len", "str", "op", "p", "bm", "api", "src", "bj", "buf", "image", "img", "out", "off", "bot", "lib", "ind", "orb", "n", "jp", "id", "ut", "ob", "lo", "tmp", "ctx", "ant", "oi", "nb", "act", "opt", "io", "nd", "en", "Obj", "ad", "nt", "lc", "objects", "js", "b", "Object", "cb", "po", "os", "lock", "oid", "x"], "name": ["nam", "data", "nm", "new", "ext", "fn", "object", "number", "label", "key", "str", "len", "anc", "no", "type", "old", "id", "n", "l", "option", "dim", "Name", "word", "m", "version", "f", "path", "max", "min", "part", "parent", "i", "info", "named", "filename", "names", "prefix", "size", "cn", "null", "NAME", "alias", "time", "x", "base"], "num": ["nm", "sum", "index", "np", "one", "umi", "un", "uni", "four", "off", "id", "mn", "dim", "f", "en", "bin", "mu", "gen", "b", "term", "unit", "an", "form", "bn", "begin", "param", "done", "offset", "tun", "um", "position", "u", "lim", "una", "size", "mom", "valid", "gener", "mon", "nam", "number", "nu", "len", "du", "dom", "no", "don", "inc", "lon", "nom", "n", "eight", "block", "uno", "om", "initial", "im", "NUM", "su", "Num", "con", "zero", "loc", "rum", "na", "ul", "sem", "norm", "m", "nb", "min", "i", "coord", "ten", "span", "hum", "node", "hom"], "den": ["low", "pen", "dn", "nn", "flo", "Den", "dir", "di", "sen", "diff", "de", "ner", "begin", "limit", "len", "none", "du", "wall", "don", "zen", "un", "lon", "ven", "uni", "dan", "ne", "die", "line", "sem", "lim", "ni", "dim", "norm", "bench", "fen", "version", "des", "nen", " DEN", "range", "ben", "min", "en", " Den", "una", "non", "ten", "lin", "ver", "hen", "gen", "side", "su", "plan", "dem", "con", "mon", "nan", "DEN"], "intnum": [" intblock", "integernu", " inten", "intername", "doublenum", "doubleno", "indnumber", "integernom", "indnu", "Intnumber", "intlen", "ntunit", "integerblock", "intname", "extname", "extnumber", "extnum", "intblock", "intmem", "internum", "intoffset", " intname", " intbegin", "Intnu", " intum", " intnom", "Intnom", "bitum", "doublenumber", "indmem", "intbegin", "pointbegin", "pointnu", "stringunit", "intnumber", "doubleloc", "incnom", "intnode", "indunit", "intnom", "stringnu", "incnum", "integerbegin", "intunit", "indname", "bitblock", "ntoffset", "integerlen", "pointnom", "inclen", "integermem", "bitnum", "intloc", "integernum", "stringnum", "inten", "intum", "indnom", " intlen", "stringnode", "bitnumber", " intno", "pointnum", "pointblock", "ntlen", "indnum", " intnumber", "Intblock", "extlen", "intno", "integernumber", "pointen", "ntnom", "pointnumber", "doublename", "ntnum", "indnode", "Intnum", "interloc", "ntname", "indloc", "incnumber", "ntno", "ntnu", " intoffset", "pointmem", "doubleoffset", "intnu", "integeren", "ntnumber", "ntnode", "integername", "Intum", "internumber"], "o_out": ["s_out", " o_in", "s_sync", " o_Out", "s_off", " o_o", "o_off", "o_in", "o_o", "o_Out", "o_sync", " o_off", "s_in"], "o": ["mo", "options", "O", "object", "ou", "oa", "k", "oid", "one", "e", "d", "so", "none", "op", "p", "no", "ko", "offset", "out", "u", "off", "offer", "n", "l", "bo", "option", "lo", "go", "ob", "iso", "online", "m", "c", "t", "oi", "f", "opt", "io", "oe", "or", "i", "w", "b", "oin", "oo", "po", "os", "v", "office"], "dst": ["ldsc", " dsc", " dste", "xdst", "ddest", "oddest", "odsts", "indste", "odst", "daSt", " dbl", " dcr", " dST", "indpush", "odste", "xdST", "isdpush", "ldstr", "dST", " dsts", "adST", "nST", "isdst", "dSt", " dsp", " dstore", "Dbl", "dasts", "xdste", "dast", "idste", "adstr", "Dcr", "Dsc", "isdstore", "dstore", " dstr", "isdste", "nsp", "dbl", "dsp", "DST", "dabl", "nst", "ldst", "indst", "nste", "DSt", "idsts", "ldST", "indstore", "dste", "idcr", "dcr", "dstr", "Dste", "idst", "dsts", "adst", " dpush", "xdsts", " dSt", "addest", "Dsp", "Dst", "adste", "dpush", "adsts", "dsc", "ldste", "Dsts", " ddest"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qemu_mutex_init(&qxl->track_lock);\n\n    qemu_mutex_init(&qxl->async_lock);\n\n    qxl->current_async = QXL_UNDEFINED_IO;\n\n    qxl->guest_bug = 0;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        io_size = 8;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        io_size = 16;\n\n        break;\n\n    case 3: /* qxl-3 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V10;\n\n        io_size = 32; /* PCI region size must be pow2 */\n\n        break;\n\n    case 4: /* qxl-4 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V12;\n\n        io_size = pow2ceil(QXL_IO_RANGE_SIZE);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Invalid revision %d for qxl device (max %d)\",\n\n                   qxl->revision, QXL_DEFAULT_REVISION);\n\n        return;\n\n    }\n\n\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), \"qxl.vrom\",\n\n                           qxl->rom_size, &error_abort);\n\n    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);\n\n    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), \"qxl.vram\",\n\n                           qxl->vram_size, &error_abort);\n\n    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);\n\n    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), \"qxl.vram32\",\n\n                             &qxl->vram_bar, 0, qxl->vram32_size);\n\n\n\n    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,\n\n                          \"qxl-ioports\", io_size);\n\n    if (qxl->id == 0) {\n\n        vga_dirty_log_start(&qxl->vga);\n\n    }\n\n    memory_region_set_flush_coalesced(&qxl->io_bar);\n\n\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);\n\n\n\n    if (qxl->vram32_size < qxl->vram_size) {\n\n        /*\n\n         * Make the 64bit vram bar show up only in case it is\n\n         * configured to be larger than the 32bit vram bar.\n\n         */\n\n        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n", "idx": 5767, "substitutes": {"qxl": ["qufxL", "Qxlc", "qyls", "quebyll", "qrxli", "qyli", "qxxlb", "qrxll", "qctl", "qxxlc", "qxr", "qexll", "iqxll", "quyl", "quxtl", "qXlb", "quxll", "qxxL", "qpxlc", "quxls", "qfxel", "nxli", "sqaxle", "qbyll", "qaxdl", "quxtlc", "qxli", "Qexli", "qtxlc", "Qexlc", "quickxl", "quickaxdl", "qwxlc", "qaxll", "qexsl", "qxf", "Qexl", "qlexla", "qbylb", "quickxdl", "qtxli", "naxli", "qaxlc", "qexle", "Qxli", "qlexrl", "quebykl", " quxll", "qxlb", "qxle", " qrxlc", "sqxr", " quxlp", "quxdl", "quxlp", "quexkl", "sqxl", "qrexlc", " qxll", "qxcll", "quexll", "iqexlb", "qtxls", "iqexlc", "qxxli", "sqxel", "qexli", "Qxll", "qaxle", "qxL", "quxrl", "qwdl", "qaxr", "quickxli", "qxel", "quxtel", "QxL", "qxlp", "quxl", "qextll", "qexr", "qpxle", "quyli", "nxll", "qtxll", "sqxle", "qwxdl", "qyla", "qxxlp", "quxlc", "qrexli", "qzxlb", " qxls", "qextlb", "qulexla", "qexlb", "qexrl", "qlllb", "qswl", "qxla", "qwel", "qufxl", "quexlb", "Qexel", "qwl", "qysl", "Qxel", "quxla", "iqexll", "qtxel", "qxtli", "qyl", "qufxls", "qlll", "qylc", "sqaxlc", "qxsl", " quxsl", "qrxrl", " quxli", "qttl", "iqexel", "qauxl", "nxl", "qaxel", "qulexrl", "qpxl", "qXel", "qrxlc", "qswli", "quebylb", "qtxl", "qxtel", "qttli", "qlexl", "qwlc", "qaxl", "qxcl", "qswll", "quickaxel", " qrxll", "qulexl", "qexel", "qextl", "qauxel", " qxlc", "qXlc", "iqxel", "Qxl", "qlexlc", "qexl", "qtxL", "QexL", "qrxl", "qfxL", " qxel", "sqaxl", "sqxdl", "qexls", "qxkl", "qxxel", "qrexl", "qXl", "qxlc", "quxel", "qextkl", "qbyl", " qrxel", "qrxel", "qpxr", "qzxll", " qxsl", "qfxli", "iqxlc", "qlllc", "sqaxr", "quylc", "qxxkl", "qxtlc", "qxtl", "quickaxl", "qwxel", "qexla", "qexlc", "qzxl", "qaxli", "qulexlc", "qaxf", "qxxll", " qxlp", "iqxlb", "qzxlc", "qauxf", "sqwl", "quickaxli", "quxtli", " quxls", " qrxl", "naxl", "qfxlp", "qxrl", "iqxl", "qswlc", "qrexdl", "qxxf", "iqexl", "sqwlc", "naxll", "quexl", "qctlc", "sqxlc", "qbykl", "qwxl", "qttf", "qauxli", " quxel", "quxf", "qrxla", "qufxll", "sqwdl", "qfxls", "quxsl", "qctll", "quickxel", "sqwel", "qttel", "qxxl", "qctli", "qfxll", "quebyl", " qxli", "qexL", "qfxl", "Qexll", "qxclb", "quxL", "quyla", "naxlc", " quxl", "qxdl", "qllel", "qxll", "qxclc", "nxlc", "quxli", "qtxdl", "qrexel", "qxls"], "errp": ["rartp", "rarb", " errfp", "errjp", "Erfp", "erb", "erp", "ertp", " errjp", "rarfp", "errap", "erjp", "Erb", "errtp", "rarp", "erap", "erfp", "Erjp", "errfp", "Ertp", " errap", "errb", "Erap", "Erp"], "config": ["data", "context", "cfg", "options", "storage", "sec", "cal", "proc", "set", "control", "Config", "text", "name", "param", "input", "db", "component", "controller", "server", "program", "connection", "args", "design", "client", "conn", "support", "channel", "ch", "current", "service", "cont", "connect", "mode", "c", "init", "setting", "bc", "address", "expl", "host", "path", "model", "master", "ini", "settings", "cache", "gui", "project", "ca", "state", "length", "fig", "license", "con", "conf", " Config", "driver", "output", "spec"], "pci_device_rev": ["pci_devicesorig", "pci_device___rev", "pci_gpu_ref", "pci_devicesrev", "pci_model_re", "pci_model_ctr", "pci_gpu___ref", "pci_device__ref", "pci_mode_rel", "pci_device_re", "pci_gpu_rel", "pci_device_ref", "pci_model_orig", "pci_device_build", "pci_device__rev", "pci_dev_id", "pci_devicestag", "pci_device__rel", "pci_gpu_rev", "pci_device_ctr", "pci_device_rel", "pci_device___rel", "pci_model_rev", "pci_gpu___rev", "pci_device_prev", "pci_mode_rh", "pci_device_id", "pci_dev_rev", "pci_device_orig", "pci_devicesbuild", "pci_gpu_version", "pci_gpu___version", "pci_dev_orig", "pci_mode_prev", "pci_device_rh", "pci_device_tag", "pci_device___version", "pci_model_tag", "pci_device__version", "pci_device___ref", "pci_dev_ref", "pci_device_version", "pci_device__prev", "pci_gpu___rel", "pci_mode_rev", "pci_dev_version", "pci_device__rh", "pci_model_build"], "io_size": ["io___strength", "IO_strength", "io___fee", "rioacalign", "io6size", "iofwidth", "iofstrength", "ioamsign", "io_number", " io_fee", " ioacsized", " io_len", "ioacvalue", "system_range", "ioacwidth", "io6value", "ioalstrength", "IOfstrength", "io6loc", " io_loc", " io_sized", "rio_strength", "iofcost", "ioalsize", " io6loc", "systemamnumber", "systemamsign", " ioacsize", "ioacfee", " io_value", "ioacsize", "io___align", "io___width", "ioacsized", "io_len", "IO_cost", "io___sized", "IO_width", "io___size", "system_sign", "rio_align", "system_size", "rio_width", "io_sized", "io_strength", "rioacwidth", "iofsize", "io_loc", " io6size", "io_cost", "rioacsize", "ioacloc", " io6len", "IO_size", "io_align", "ioacstrength", "ioaclen", "io_range", "io_fee", "io_shape", "ioalcost", "rioacstrength", "IOfcost", "systemamrange", " io_shape", "ioacalign", "io_sign", "ioacshape", "ioamnumber", "IOfsize", "system_number", " ioacfee", "io___shape", "systemamsize", "ioamsize", " ioacshape", "IOfwidth", "io_value", "ioalwidth", "io6len", " io6value", "ioamrange", "rio_size", "io_width"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 5781, "substitutes": {"dest": ["target", "dist", "result", "text", "name", "num", "img", "delete", "die", "id", "ctr", "dim", "contract", "temp", "draw", "table", "output", "west", "data", "ui", "miss", "member", "db", "done", "orig", "test", "config", "stage", "cont", "txt", "mode", "rest", "dc", "address", "trip", "path", "cl", "start", "shape", "null", "cb", "status", "select", "Dest", "de", "trans", "ident", "dom", "session", "option", "content", "home", "tmp", "transfer", "sup", "shift", "opt", "prop", "feat", "origin", "comb", "route", "access", "transform", "wb", "end", "loc", "success", "ord", "src", "head", "est", "usr", "cdn", "class", "source", "sort", "hop", "lit", "master", "parent", "err", "coord", "desc", "node"], "linesize": ["linesiz", "linedhip", "linsiz", "casesization", "linsize", "casesize", "linship", " linesization", "linesizing", "linediz", "nsize", "linedsize", " linesiz", "linedize", "nsization", "linssize", "nsizing", " linessize", " lineship", "lineship", "casesizing", "casessize", " linesizing", "linesization", "nssize", "linessize"], "block": ["Block", "object", "ref", "section", "def", "end", "name", "none", "event", "blocks", "map", "bl", "type", "num", "clean", "channel", "unit", "config", "line", "contract", "load", "word", "bc", "address", "buffer", "source", "comment", "cl", "check", "copy", "group", "cache", "table", "list", "match", "pack", "node", "col", "chain", "row", "lock"], "i": ["ui", "bi", "pi", "index", "k", "ie", "j", "di", "e", "d", "si", "multi", "fi", "cli", "ti", "p", "api", "mi", "qi", "ii", "hi", "u", "ji", "n", "l", "ni", "ip", "ami", "abi", "c", "oi", "f", "zi", "io", "info", "gi", "mu", "xi", "uri", "ci", "b", "col", "iu", "count", "I", "ai", "v", "x", "li"], "cm": ["em", "gm", "CM", "comm", "vm", "am", "param", "mm", "rm", "wm", "co", "cc", "que", "bm", "don", "module", "um", "config", "hm", "cmd", "fm", "sem", "cont", "cum", "dim", "cy", "man", "cms", "m", "c", "mode", "ram", "ctx", "pm", "cr", "ym", "dc", "address", "hem", "ctrl", "mc", "om", "cam", "rom", "iam", "im", "cf", "km", "ca", "tc", "cn", "ci", "lc", "cd", "dm", "rem", "DC", "center", "com", "dem", "cp", "car", "asm"]}}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n", "idx": 5789, "substitutes": {"src": ["conv", "dist", "text", "build", "sync", "img", "connect", "s", "bc", "uv", "sit", "sub", "sound", "grad", "usc", "stream", "data", "input", "view", "sb", "upp", "typ", "config", "dest", "hl", "hh", "rest", "st", "rec", "inst", "cv", "secure", "rb", "upload", "cb", "http", "comp", "uc", "rc", "url", "gb", "control", "rss", "buf", "inc", "tmp", "sup", "req", "ssl", "supp", "sl", "cmp", "bs", "rs", "transform", "spec", "func", "split", "proc", "loc", "reflect", "aug", "sc", "support", "chrom", "impl", "cur", "source", "sort", "fc", "iv", "pack", "node", "attr", "desc", "sel", "obl", "stat"], "stride": ["etriden", "erided", "rider", "fided", "shride", "frine", "rides", "brided", "yrine", "frided", "strided", "instice", "ride", "shrider", "erider", "instided", " strider", "yrider", "drider", "brine", "intide", "brice", "driden", "stipe", "dride", "fride", "instider", "stid", "erride", "strine", "brid", "yride", " strid", " strided", "strice", "brise", "drided", "intided", "bride", "etride", "striden", "intine", "frider", "shrided", "fise", "stripe", "erides", "stide", "errider", "stider", "erine", "drides", "intider", "ripe", "etrider", "stise", "fider", "brider", "bripe", "stided", "shrice", "eride", "drine", "strider", "fide", "errided", "strides", "etrided", "strid", "yrided", "errine", "rided", "strise", " striden", "instide"], "mode": ["link", "operation", "Mode", "dir", "def", "scale", "theme", "slave", "grade", "ode", "slice", "type", "style", "ace", "module", "config", "plugin", "id", "stage", "dim", "MODE", "ward", "m", "guide", "path", "source", "range", "prop", "ride", "mod", "phase", "code", "md", "toggle", "route", "attr", "role", "direction", "method", "driver", "transform"], "r": ["ru", "br", "rc", "re", "k", "e", "d", "er", "p", "h", "hr", "u", "n", "l", "rr", "m", "mr", "c", "sr", "t", "cr", "f", "range", "or", "ir", "nr", "R", "a", "i", "err", "w", "ar", "o", "rb", "rw", "ra", "b", "row", "v", "rs"]}}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 5797, "substitutes": {"opaque": ["obaque", "copptr", " opque", "opace", "opsaque", "openaques", "opacity", "opsacity", "operec", "opsque", "openaque", "copace", "opaques", "copec", "operace", "operptr", "copaque", "openacity", "operaque", "opsaques", "obptr", "obace", "obec", " opacity", "opque", " opaques", "openque", "opptr", "opec"], "addr": ["data", "pos", "ext", "rc", "oa", "ref", "url", "eth", "asm", "name", "loc", "advert", "enc", "ord", "fx", "str", "call", "p", "arr", "src", "adder", "amd", "pad", "ace", "offset", "r", "ack", "sta", "bb", "hl", "ip", "mode", "inter", "add", "layer", "dc", "address", "host", "pointer", "art", "kt", "hop", "start", "mac", "en", "part", "ad", "alloc", "size", "x", "xp", "amp", "ino", "code", "dr", "md", "rt", "route", "grad", "ptr", "align", "work", "adr"], "len": ["Len", "data", " bytes", "str", "val", "mem", "type", "seq", "bytes", "off", " size", "lib", " length", " mem", " str", "en", "bin", " lib", "size", "code", " clen", "length", "lan", " data"], "opp": ["cop", "od", "odd", "advert", "ppa", "cho", "eff", "coll", "Opp", "obo", "oper", "upp", "op", "stick", "pps", "app", "oc", "ost", "kick", "oop", "kk", "agg", "org", "ack", "opers", "nick", "off", "obb", "jp", "ip", "obj", "plug", "hack", "effect", "online", "unknown", "tmp", "owner", "oph", "oi", "pp", "inst", "ppo", "ogg", "supp", "operator", "iv", "front", "lov", "ipp", "ov", "own", "omp", "oga", "append", "cmp", "comp", "cpp", "rog"], "idx": [" idxc", "indwork", "pidv", " idwork", "Idy", "Idxc", "dindex", "sidx", "IDw", "intpe", "idv", "pidy", "idindex", " idindex", "Idx", "Idwork", " idw", "IDn", "dw", "Idpe", "indX", "pidX", "idwork", "idw", "idpe", "intz", " idn", "IDX", " idv", "intX", "IDindex", "indx", " idX", " idz", "dz", " idy", "IDx", "Idz", "sidz", "idz", " idpe", "idxc", "IDz", "idy", "IdX", "intx", "Idv", "idn", "dx", "indxc", "idX", "sidxc", "pidx", "IDy", "sidX", "Idn"]}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "static void gen_exception_insn(DisasContext *s, int offset, int excp)\n\n{\n\n    gen_a64_set_pc_im(s->pc - offset);\n\n    gen_exception(excp);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n", "idx": 5810, "substitutes": {"s": ["new", "sq", "e", "d", "sb", "server", "self", "p", "sync", "sys", "ks", "args", "src", "S", "ps", "is", "ses", "gs", "sets", "cs", "service", "u", "stats", "ss", "c", "sg", "ts", "services", "t", "m", "sym", "fs", "g", "f", "ns", "sup", "a", "ssl", "settings", "i", "your", "js", "b", "es", "os", "parser", "rs", "spec"], "offset": ["data", "pos", "index", "reset", "ref", "set", "error", "loc", "limit", "adjust", "p", "Offset", "slice", "type", "pad", "seq", "num", "image", "position", "address", "pointer", "shift", "range", "location", "padding", "start", "phase", "parent", "i", "prefix", "origin", "timeout", "length", "addr", "cmp", "fp", "count", "align", "port"], "excp": ["expCP", "Excpp", "essbp", "Exip", "excpp", "explip", "essCP", "exip", "explcp", "esscp", "explcpp", "expcp", "ExCP", "explCP", "expip", "exbp", "Excp", " exCP", "exCP", "Exbp", " exbp", "expcpp"]}}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n", "idx": 5820, "substitutes": {"request": ["complete", "context", "data", "object", "frame", "push", "xml", "result", "try", "input", "error", "message", "hello", "call", "report", "Request", "self", "type", "client", "order", "QUEST", "patch", "query", "r", "head", "create", "id", "response", "child", "instance", "condition", "path", "model", "req", "quest", "parent", "user", "require", "subject", "post", "q", "resource"], "errp": ["erP", "errr", "finderpre", "lerP", "Erc", " errping", "errorpre", "erp", " errpc", "herping", "lerping", "errP", "erping", "nerpc", "errping", "rrpc", "rrping", "erps", "erpc", "nerp", "errorp", "errps", "ErP", "lerr", "finderping", "erpre", "errpc", "herr", "herP", "finderc", "rrpre", " errP", "errorr", "nerps", "errpre", " errr", "err", " errc", "errorpc", " errpre", "finderp", "nerP", "rrc", "rrp", "errc", "Erp", "rrP", " errps", "lerp", "herp", "Erpc"], "ent": ["ou", "sec", "end", "od", "ict", "de", "loc", "e", "anch", "enc", "ident", "exec", "equ", "cent", "anc", "event", "rent", "pent", "ce", " entity", "intent", "Ent", "gent", "conn", "inc", "ct", " entry", "ch", "ev", "query", "ENT", "inner", "elt", "ment", "et", "ents", "ind", "id", "ut", "enter", "entry", "cart", "entity", "rec", "dc", "pt", "art", "sett", "kt", "nd", "inst", "vent", "en", "ec", "parent", "se", "det", "nt", "ect", "ant", "ente", "sent"], "arg_name": ["argaccommon", "enc_len", "arg_nm", "enc_name", "arg_code", "arg__Name", "enc_value", "argacobj", "attracnm", "enc__name", "arg_value", "argument_code", " arg_names", "arg__key", "attr_nm", "enc__value", "arg_names", "arg_word", "argument_key", "argSName", "enc_obj", "arg__value", "arg_common", "argument_name", "argument_Name", "arg__obj", "argument__Name", "attr_obj", "Arg_obj", "enc__obj", "argacnm", "argument__name", "argument__key", "arg__names", "arg__len", "argSobj", "arg__name", "Arg_Name", "arg__code", "attracname", "enc__len", "Arg_word", "Arg_name", "argSword", "argacname", "attr_common", " arg_Name", "attr_name", "arg_key", "arg_len", "attraccommon", "argument__code", "attracobj", "argSname", "arg_Name"], "arg_obj": ["arg__obj", "ar_obj", "arg__object", "Arg_obj", "arg_ob", "arg_xy", "ar_object", "arg__ob", "ar_name", "arg_val", " arg_object", "arg__name", "Arg_val", "Arg_xy", "Arg_object", " arg_ob", "ar_ob", "arg_object"], "dict": ["data", "hash", "index", "object", "dir", "da", "set", "def", "di", "ict", "db", "diff", "result", "d", "value", "back", "document", "str", "coll", "collection", "dt", "arr", "df", "map", "dom", "details", "session", "conn", "ct", "inc", "module", "record", "full", "out", "config", "query", "ds", "head", "file", "response", "obj", "inf", "pillar", "instance", "init", "entry", "rec", "dc", "condition", "path", "nd", "array", "cat", "req", "parent", "cache", "err", "table", "dev", "list", "nt", "dr", "code", "state", "tree", "po", "doc", "count", "lock", "dat"]}}
{"project": "FFmpeg", "commit_id": "7e4fe5162ab94a413e04caae19193c5e7a4c6478", "target": 0, "func": "static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])\n\n{\n\n    uint32_t block[80];\n\n    unsigned int i, a, b, c, d, e;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 80; i++) {\n\n        int t;\n\n        if (i < 16)\n\n            t = AV_RB32(buffer + 4 * i);\n\n        else\n\n            t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1);\n\n        block[i] = t;\n\n        t += e + rol(a, 5);\n\n        if (i < 40) {\n\n            if (i < 20)\n\n                t += ((b&(c^d))^d)     + 0x5A827999;\n\n            else\n\n                t += ( b^c     ^d)     + 0x6ED9EBA1;\n\n        } else {\n\n            if (i < 60)\n\n                t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC;\n\n            else\n\n                t += ( b^c     ^d)     + 0xCA62C1D6;\n\n        }\n\n        e = d;\n\n        d = c;\n\n        c = rol(b, 30);\n\n        b = a;\n\n        a = t;\n\n    }\n\n#else\n\n    for (i = 0; i < 15; i += 5) {\n\n        R0(a, b, c, d, e, 0 + i);\n\n        R0(e, a, b, c, d, 1 + i);\n\n        R0(d, e, a, b, c, 2 + i);\n\n        R0(c, d, e, a, b, 3 + i);\n\n        R0(b, c, d, e, a, 4 + i);\n\n    }\n\n    R0(a, b, c, d, e, 15);\n\n    R1(e, a, b, c, d, 16);\n\n    R1(d, e, a, b, c, 17);\n\n    R1(c, d, e, a, b, 18);\n\n    R1(b, c, d, e, a, 19);\n\n    for (i = 20; i < 40; i += 5) {\n\n        R2(a, b, c, d, e, 0 + i);\n\n        R2(e, a, b, c, d, 1 + i);\n\n        R2(d, e, a, b, c, 2 + i);\n\n        R2(c, d, e, a, b, 3 + i);\n\n        R2(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 60; i += 5) {\n\n        R3(a, b, c, d, e, 0 + i);\n\n        R3(e, a, b, c, d, 1 + i);\n\n        R3(d, e, a, b, c, 2 + i);\n\n        R3(c, d, e, a, b, 3 + i);\n\n        R3(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 80; i += 5) {\n\n        R4(a, b, c, d, e, 0 + i);\n\n        R4(e, a, b, c, d, 1 + i);\n\n        R4(d, e, a, b, c, 2 + i);\n\n        R4(c, d, e, a, b, 3 + i);\n\n        R4(b, c, d, e, a, 4 + i);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n}\n", "idx": 5826, "substitutes": {"state": ["context", "scope", "data", "object", "index", "seed", "set", "error", "value", "element", "back", "message", "key", "open", "sync", "rule", "session", "style", "type", "function", "conn", "position", "config", "stat", "STATE", "State", "states", "statement", "layer", "transfer", "address", "g", "space", "range", "source", "start", "model", "parent", "size", "manager", "list", "shape", "length", "store", "lock", "resource", "body", "update", "private", "port"], "buffer": ["batch", "data", "object", "frame", "header", "queue", "message", "Buffer", "command", "byte", "p", "flow", "buf", "image", "channel", "offset", "position", "bb", "r", "n", "buff", "v", "transfer", "f", "io", "uffer", "table", "size", "code", "shape", "length", "board", "timeout", "null", "I", "binary", "window", "x"], "block": ["batch", "Block", "frame", "object", "index", "section", "number", "error", "loc", "input", "label", "element", "view", "key", "ban", "byte", "sync", "blocks", "map", "rule", "bl", "type", "flow", "buf", "bit", "channel", "position", "out", "config", "line", "head", "ip", "contract", "address", "condition", "range", "array", "comment", "point", "group", "bin", "cache", "parent", "table", "list", "code", "pack", "board", "lock", "node", "chain", "row", "unit", "output", "base"], "i": ["bi", "pi", "index", "multi", "ti", "api", "slice", "qi", "hi", "id", "ip", "init", "f", "zi", "mu", "uri", "in", "v", "li", "ui", "k", "ie", "ei", "diff", "mini", "cli", "vi", "ii", "r", "u", "ji", "abi", "ix", "ini", "isi", "iu", "q", "ai", "p", "mi", "adi", "n", "oi", "io", "gi", "it", "I", "si", "x", "y", "j", "di", "fi", "yi", "is", "phi", "anti", "at", "l", "ni", "ri", "info", "o", "xi", "ci", "eni", "z"], "a": ["an", "ak", "y", "fa", "da", "ie", "area", "am", "au", "j", "ab", "ae", "na", "ai", "ea", "A", "p", "api", "h", "r", "u", "at", "n", "l", "s", "m", "ba", "ta", "alpha", "g", "f", "wa", "as", "sa", "be", "ma", "w", "ar", "o", "ad", "ca", "aaa", "code", "va", "z", "ac", "ia", "aw", "aa", "v", "x"], "b": ["bi", "an", "wb", "y", "lb", "k", "gb", "B", "j", "db", "ab", "bf", "sb", "bar", "p", "bl", "app", "h", "r", "bb", "ch", "u", "fb", "n", "l", "s", "ob", "m", "ba", "bc", "g", "f", "ib", "as", "be", "eb", "el", "bin", "o", "w", "emb", "ca", "ad", "bh", "rb", "z", "cb", "bs", "aa", "v", "x", "base"], "c": ["y", "k", "co", "p", "ce", "h", "sc", "cm", "r", "cs", "ch", "u", "n", "l", "cy", "s", "m", "dc", "cr", "bc", "g", "f", "cat", "cl", "ec", "cu", "w", "o", "cf", "ca", "C", "cn", "ci", "lc", "cd", "z", "ac", "q", "con", "cp", "v", "x"], "d": ["y", "dn", "da", "k", "j", "di", "db", "dh", "dt", "p", "h", "D", "r", "u", "ds", "id", "n", "l", "dd", "s", "m", "dy", "dc", "g", "f", "w", "ad", "o", "cd", "z", "q", "v", "x"], "e": ["an", "y", "eu", "k", "ie", "ei", "j", "end", "de", "ae", "element", "er", "ea", "fe", "p", "ce", "h", "r", "ne", "u", "n", "l", "ef", "s", "m", "E", "g", "f", "ed", "oe", "be", "en", "el", "ec", "se", "o", "w", "pe", "z", "es", "ee", "v", "x"], "t": ["ty", "y", "k", "set", "j", "mt", "text", "dt", "tp", "ti", "p", "the", "type", "h", "r", "tt", "u", "at", "et", "n", "l", "id", "ut", "tu", "s", "m", "ts", "v", "ta", "st", "te", "f", "g", "pt", "tm", "o", "wt", "w", "token", "it", "table", "nt", "z", "tf", "q", "ant", "T", "x"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n", "idx": 5834, "substitutes": {"f": ["fa", "ref", "j", "e", "d", "fx", "fat", "fo", "fi", "self", "p", "rf", "df", "h", "F", "img", "fw", "file", "l", "obj", "buff", "fd", "m", "c", "t", "fs", "g", "i", "o", "w", "fr", "lf", "ff", "b", "fp", "conf", "x"], "pv": ["PV", "Pf", "pb", " pp", "Pv", "apv", "Pp", "app", "Pb", "apf", "cpV", "pf", " pV", "cpb", "pV", "apV", "pp", "cpv", " pb", " pf", "cpf"], "size": ["data", " sizes", "value", "e", " V", "val", " n", "fff", "SIZE", "l", "large", "ize", "c", "Size", "g", "V", " Size", "iv", "w", "z", "shape"], "v": ["data", "tv", "k", "j", "vp", "lv", "value", "e", "d", "val", "ve", "vi", "p", "nv", "vs", "u", "inv", "n", "l", "video", "volume", "s", "m", "c", "t", "uv", "V", "g", "vt", "i", "o", "iv", "sv", "b", "q", "x"]}}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "idx": 5837, "substitutes": {"build_opaque": ["build_operaque", "build_opsifice", "build_operesc", "build_operque", "build_iopifice", "build_opsacity", "build_operifice", "build_opacity", "build_opsaque", "build_cataque", "build_operacity", "build_opsesc", "build_iopque", "build_opifice", "build_catesc", "build_opsque", "build_iopaque", "build_iopacity", "build_catque", "build_opesc", "build_opque", "build_catacity"], "offset": ["pos", "index", "from", "ref", "set", "end", "scale", "limit", "len", "ocol", "initialized", "order", "seq", "off", "ip", "address", "shift", "pointer", "array", "padding", "start", "code", "length", "count", "zero", "os", "port", "ips", "base"], "build_state": ["built_start", "buildocstate", "buildocstates", "clean_stat", "buildingstat", "work_object", "work_context", "buildercontext", "builterresource", "work_state", "clean_state", "buildappstate", "build_id", "buildappSTATE", "clean_states", "build_data", "workercontext", "built_state", "work_info", "build_config", "build6states", "build_stat", " build_State", "buildocspec", "clean_config", "buildingstates", "builterstate", " build_states", "builderinfo", "builterState", "user_spec", "build_states", "update_config", "build_settings", "buildappinfo", " build_statement", "buildingstate", "builderstate", "workerobject", "buildappobject", "update_state", "build6statement", "build_State", " build_STATE", "buildingconfig", "workerinfo", "buildappcontext", "buildappspec", "built_State", "built_resource", " build_notice", "build_object", "builderState", " build_settings", "buildappstruct", "build_struct", "user_struct", "build_notice", "build_start", "builderstart", "update_states", "build_info", "builterstart", "build_spec", "build_statement", "build_resource", "build_context", "build_STATE", "build6notice", "buildocsettings", "workerstate", " build_id", "build6state", "user_STATE", "user_state", "builderobject", "update_data", "builderresource", " build_spec"], "tables": [" tees", "Tests", "tributes", "pable", "vable", "fable", "atipes", "Tas", "ateries", " tests", "ptrees", "untables", " table", "Table", "fributes", "tenips", "untributes", " teries", "ptables", "ptipes", "tas", "Tables", "trees", "untipes", " tips", " tas", "Tamps", "fests", "tips", "tamps", "pipes", "qtables", " tamps", "tipes", "pables", "tubs", "Tipes", "fables", "vables", " tubs", "atables", "qtips", "fipes", "tenables", "Trees", "Teries", "table", " trees", " tipes", "tenubs", "tests", "vipes", "qtable", "atas", "tees", " tributes", "fees", "qtubs", "tenable", "untees", "ptamps", "teries"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_nb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 8000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    avctx->frame_size  = 160;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->enc_state = Encoder_Interface_init(s->enc_dtx);\n\n    if (!s->enc_state) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Encoder_Interface_init error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->enc_bitrate = avctx->bit_rate;\n\n\n\n    return 0;\n\n}", "idx": 5845, "substitutes": {"avctx": ["ajdc", "afcb", "avaldc", "aveca", "avc", "avecu", "akcs", "avloc", "avconfig", "avcos", "afctx", "avdc", "ajcontext", "avsync", "ajctl", "afsync", "avalctl", "avca", "afbc", "avalctx", "avalcoll", "avalloc", "ajcv", "avcoll", "aveloc", "afloc", "avcb", "afcmp", "avbc", "afcs", "amkb", "avecontext", "ajsync", "afcoll", "avebc", "afconn", "afcu", "afcn", "airconn", "afkb", "ajcos", "afctl", "avkb", "ajca", "amctx", "avcontext", "aveconn", "verdc", "avconn", "avcn", "aircontext", "ajcs", "verca", "avecmp", "akctx", "ajconfig", "afcos", "avxc", "amsync", "ajconn", " avcn", "amcontext", "avec", "afc", "avalcmp", "afcf", "avcmp", "ajbc", "verctx", "vercn", "akcu", "afcv", "avalsync", "avecoll", " avxc", " avcf", "avalcontext", "vercontext", "avcu", " avconfig", "afconfig", " avcontext", "afdc", "avcs", "vercf", "avedc", "afxc", "ajkb", "avctl", "ajcu", "avcf", "afcontext", "avalcb", "vercu", "akcontext", "avalcos", "ajcb", "airc", "airctx", "avcv", "ajxc", "avectx", "ajctx", "akcv"], "s": ["data", "sq", "e", "parts", "d", "sb", "sys", "p", "sync", "self", "ks", "args", "ls", "session", "S", "h", "ps", "sc", "is", "ses", "qs", "cs", "acs", "gs", "r", "sets", "ds", "service", "u", "xs", "l", "ops", "ss", "c", "m", "sg", "services", "ts", "ctx", "sym", "t", "fs", "g", "f", "ns", "bis", "a", "ssl", "i", "w", "its", "o", "js", "b", "es", "ins", "hs", "os", "v", "si"]}}
{"project": "FFmpeg", "commit_id": "c6bdc90890250ce351b260eff69ce3c0d0745a62", "target": 1, "func": "void help(void)\n\n{\n\n    printf(\"dct-test [-i] [<test-number>]\\n\"\n\n           \"test-number 0 -> test with random matrixes\\n\"\n\n           \"            1 -> test with random sparse matrixes\\n\"\n\n           \"            2 -> do 3. test from mpeg4 std\\n\"\n\n           \"-i          test IDCT implementations\\n\"\n\n           \"-4          test IDCT248 implementations\\n\");\n\n    exit(1);\n\n}\n", "idx": 5846, "substitutes": {}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "func": "static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n", "idx": 5864, "substitutes": {"pb": ["abb", "wb", "pc", "lb", "db", "ppa", "bf", "sb", "pl", "hub", "tp", "p", "api", "mp", "buf", "pa", "fb", "plug", "obj", "txt", "cpp", "ctx", "bc", "pm", "tmp", "platform", "pp", "eb", "pkg", "wp", "pit", "fc", "PB", "lp", "tc", "bh", "bp", "rb", "xb", "fp", "pd", "bt", "bps", "prot"], "len": ["Len", "pos", "split", "fn", "url", "le", "limit", "fat", "val", "ler", "base", "ls", "ll", "lic", "seq", "lon", "lt", "line", "lib", "elt", "l", "layer", "f", "lit", "en", "dl", "el", "part", "den", "lin", "size", "lp", "lf", "lc", "length", "lan", "ln", "body", "fl", "li"], "n": ["an", "nc", "dn", "nn", "fn", "y", "k", "j", "number", "ner", "nu", "name", "e", "d", "na", "p", "gn", "no", "ann", "h", "un", "num", "conn", "ne", "u", "pn", "l", "mn", "ni", "rn", "s", "net", "c", "m", "init", "t", "not", "nb", "ns", "f", "g", "next", "sn", "min", "en", "nr", "nor", "N", "non", "network", "i", "o", "size", "nt", "cn", "node", "b", "adj", "ln", "v"], "n1": ["nn2", "nn", " nn", "N2", "p1", "N8", "napp", "N1", "none", "Nn", " n61", " none", "ne3", "ne2", "l8", "pn", "nnn", "ncn", "n3", "N3", "papp", " napp", "n8", "n61", " n2", "nn61", "n2", "ncone", "pone", "nn1", "ncapp", "l2", "N61", "l1", "ne1", "nc1", "l3", "ne8"]}}
{"project": "qemu", "commit_id": "e5ba83c53add51796e8ea787d2b7cb1f9c3cb72d", "target": 0, "func": "CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n\n                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],\n\n                        int do_init, const char *cpu_model)\n\n{\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"440-Xilinx\"; // XXX: should be 440EP\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_booke_timers_init(env, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 5875, "substitutes": {"address_space_mem": ["address_spaceofmc", "address_space_mc", "address_spaceofmem", "address_spaceofmm", "address_sp_mem", "address_sp_mc", "address_sp_mm", "address_space_mm"], "ram_size": ["ram_sized", "ram_model", "ramFaddress", "ramxoffset", "ram_offset", "ramxmemory", "ram_mode", "ramFsize", "memory_offset", "ramxsize", "memory_size", "ramfsize", "mem_memory", "memory_num", "ram_address", "access_sized", "ram_name", "mem_address", "ramxaddress", "ram\u00b7offset", "ram\u00b7size", "ramfname", "ram_num", "access_model", "mem_size", "ramfnum", "ramFoffset", "ramFmemory", "memory_name", "mem_offset", "ram_memory", "ram\u00b7name", "access_mode", "ramfoffset", "access_size", "ram\u00b7num"], "pcip": ["pcipes", "ccipes", "PCips", "cip", "pcid", "ccips", "pcips", "cips", "ccip", "ccid", "PCip", "PCipes", "cipes", "PCid", "cid"], "pci_irq_nrs": ["pci_irq_nls", "pci_irq_Nodes", "pci_irq_Nls", "pci_irq_cws", "pci_irq_nws", "pci_irq_Nrs", "pci_irq_cls", "pci_irq_codes", "pci_irq_Nws", "pci_irq_crs", "pci_irq_nodes"], "do_init": ["cpu_set", "do_alloc", "do_set", "cpu_alloc", "cpu_init"], "cpu_model": ["cpujlocation", "machinejmemory", "memorylexmodels", "memory_size", "cpualmodel", "cpulexmodels", "memorylexdescription", "memorylexsize", "ram_params", "cpuplocation", "cpu_store", "cpu_params", "cpu_source", "machine_location", "machine_memory", "ram_query", "cpulexdescription", "cpupmodel", "cpu_query", "cpujmodels", "cpupmodels", "machine_models", "machinejmodels", "cpu_description", "ram_model", "cpujmodel", "machine_model", "cpualquery", "machinejmodel", "machinejlocation", " cpu_size", "memory_models", "memorylexmodel", "cpulexmodel", "cpu_size", "ram_location", "memory_model", "cpujmemory", "memory_description", "cpulexsize", "cpu_models", "cpuallocation", "cpualparams", " cpu_store", " cpu_source", "cpupmemory", "cpu_location", "cpu_memory"], "ram_memories": ["ram_shory", "ram_temories", "ram_morts", "ram_mories", "ram_matories", "ram_mores", "ram_monory", "ram_shories", "ram_shorts", "ram_temorts", "ram_processories", "ram_memries", "ram_shores", "ram_temors", "ram_temores", "ram_memores", "ram_mory", "ram_monories", "ram_processory", "ram_monors", "ram_matory", "ram_matorts", "ram_processries", "ram_monorts", "ram_temory", "ram_memorts", "ram_temries", "ram_memory", "ram_memors", "ram_processores", "ram_mators", "ram_mries"], "ram_bases": ["ram_baches", "args", "ram_buffias", "ram_components", "ram_buffaches", "ram_mbases", "ram_mbasses", "ram_buffasing", "ram_buffased", "ram_nbias", "r", "ram_buffasses", "ram_nbasing", "ram_buffonents", "ram_baraches", "ram_based", "ram_buffases", "ram_bonents", "ram_brased", "ram_nbases", "ram_barias", "ram_nias", "all", "ram_mbaches", "ram_compases", "cpu", "g", "_", "ram_nasses", "ram_nases", "ram_brasing", "func", "ram_compasses", "ram_bias", "ram_basing", "ram_brias", "ram_barasses", "ram_brases", "ram_compias", "ram_basses", "ctx", "ram_nonents", "ram_mbias", "ram_barases", "ram_nbased"], "ram_sizes": ["ram_banguages", "ram_sanguages", "ram_lources", "ram_bize", "ram_camples", "ram_nosigs", "ram_sources", "ram_outsanguages", "ram_samples", "ram_bources", "ram_cists", "ram_lifts", "ram_timesets", "ram_sists", "ram_timesifts", "ram_stylesets", "ram_timesamples", "ram_nosizes", "ram_bizes", "ram_cigs", "ram_cizes", "ram_nosamples", "ram_lets", "ram_timesizes", "ram_stylesamples", "ram_ligs", "ram_lamples", "ram_stylesifts", "ram_languages", "ram_outsizes", "ram_nosists", "ram_sifts", "ram_stylesizes", "ram_sets", "ram_lizes", "ram_outsize", "ram_sigs", "ram_lists", "ram_lize", "ram_outsources"], "env": ["stack", "np", "eval", "vel", "equ", "que", "args", "vs", "img", "enable", "init", "engine", "en", "cf", "pec", "fg", "conf", "lock", "v", "context", "pect", "db", "loader", "enc", "exec", "ea", "app", "module", "config", "viron", "stage", "txt", "eye", "Environment", "ah", "cv", "size", "gui", "here", "me", "qt", "doc", "environment", "rc", "eu", "export", "session", "style", "conn", "ku", "inc", "dict", "eng", "fen", "ig", "shell", "console", "manager", "window", "dat", "scope", "nc", "dir", "e", "exc", "anc", "event", "empty", "ev", "gear", "obj", "impl", "net", "her", "ctx", "bg", "ec", "cache", "err", "dev", "erv", "eni", "enh"], "pic": ["pc", "pin", "proc", "bus", "pot", "capt", "pins", "Pic", "enc", "mini", "fi", "typ", "sync", "lic", "image", "pict", "nic", "config", "lib", "ic", "lli", "picture", "cci", "bc", "ig", "eric", "mc", "mac", "bin", "cache", "fc", "xi", "gui", "mic", "lc", "fig", "doc", "li"], "irqs": ["pirns", "irtquest", "IRces", "IRrows", " irlocks", "pircs", "irces", "mirrows", "irq", " irquest", " irws", "irtques", "irtq", "IRq", "mirns", "IRws", "mirqs", "mirques", "iraqs", "mirws", "irques", "riqs", "irarows", "IRques", "irws", "mirq", "riq", " irq", "iraces", "ircs", "pirq", "irlocks", "irrows", "irecs", "IRcs", "mirlocks", "IRquest", " ircs", "mirquest", "irens", "irtqs", "mirces", "riquest", "ireqs", "iraq", "mircs", "irquest", "rilocks", "IRqs", "irns", "ireq", "pirqs"], "pci_irqs": ["pci_pirq", "pci_mirq", "pci_arq", "pci_mirqs", "pci_irq", "pci_arqs", "pci_irques", "pci_pirques", "pci_irqa", "pci_arques", "pci_pirqa", "pci_arqa", "pci_pirqs", "pci_mirqa", "pci_mirques"]}}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n", "idx": 5899, "substitutes": {"dev": ["data", "Dev", "develop", "push", "end", "def", "dist", " Dev", "rad", "diff", "development", "error", "adv", "di", "debug", "self", "mem", "dom", "DEV", "app", "conn", "module", "bug", "ev", "prom", "die", "device", "config", "block", "dd", "v", "init", "engine", "dc", "comment", "inst", "mod", "serial", "req", "start", "der", "info", "w", "ver", "err", "state", "desc", "kind", "grad", "dem", "conf", "gu", "wd"], "d": ["dn", "da", "di", "diff", "db", "e", "dh", "dt", "p", "dom", "ded", "D", "r", "config", "u", "ds", "device", "ind", "id", "n", "l", "dict", "dd", "fd", "c", "m", "gd", "t", "dc", "g", "f", "draw", "a", "dl", "i", "ad", "w", "driver", "dr", "bd", "md", "dm", "z", "cd", "sd", "b", "del", "pd", "v", "ld", "dat"], "pci_conf": ["pci_sum", "pci_con", "pki_const", "pci5conf", "pcin_cf", "pcin_config", "pcin_sum", "pki_conn", "pii_Conf", "pci_fam", "pci_const", "pci5config", "pci_Conf", "pki_config", "pki_Conf", "pci_cf", "pii_config", "pki_conf", "pii_conf", "pcm_gate", "pki_def", "pii_con", "pci5fam", "pci5gate", "pcin_conf", "pci_gate", "pci_conn", "pci_def", "pcm_fam", "pci_config", "pcm_config", "pcm_conf"]}}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n", "idx": 5905, "substitutes": {"_dst": ["_delsts", "_hST", "_delost", "_dsrc", "_dsst", "_delst", "_duost", "_inost", "_inst", "_dost", "_inct", "_dct", "_lsc", "_hsc", "_lST", "_hst", "_dST", "_dust", "_hrc", "_duct", "_dsts", "_dssc", "_dsST", "_delct", "_dusts", "_dsc", "_lrc", "_drc", "_lst", "_insts"], "_src": ["__sl", "__src", "__rc", "pconst", "psrc", "_sl", "_dist", "__source", "_const", " _dist", " _sl", " _source", "psource", " _const", "_source", " _rc", "_rc", "prc"], "stride": ["bride", " strice", "striding", "spides", "trided", " striding", "stiding", "brance", "Stride", "triding", " strance", "shride", "stided", "shrice", "brided", "Strides", " strid", "strided", "shrided", "strides", "Strided", "spide", " strides", "trides", "spided", "strance", "shrance", "Strid", " strided", "stides", "strid", "stide", "strice", "tride", "brice", "spid"], "i": ["bi", "ui", "y", "index", "pi", "k", "j", "di", "e", "d", "si", "multi", "fi", "ti", "p", "api", "qi", "ii", "adi", "r", "u", "ali", "ji", "id", "n", "l", "ni", "ip", "c", "ix", "oi", "f", "zi", "io", "a", "ri", "o", "gi", "xi", "ci", "pixel", "z", "b", "in", "col", "iu", "I", "ai", "v", "x", "li"], "dst": ["rdconst", "dsth", "madput", " dsts", " dsp", "fdste", "lsts", "drc", "dsp", " dct", "nst", "madsc", "dsost", "dsts", "fst", "ldset", "rdst", "dptr", " dsc", " dste", " dost", "idstart", " dsth", "madsts", "dsrc", "Dsc", "dput", "dest", "ndost", "dost", "ldost", "ldsts", "idsts", "rptr", "ndst", "ddsc", "dsest", "fsc", "nrc", "fsts", "dsst", "ldconst", " dput", "dedst", "dconst", "rdset", "Dsts", "Dest", " dset", " drc", "nsc", "madost", "fdst", "rst", " dconst", "lconst", "lst", "rdput", "rdsc", "dct", "dedsts", "ldst", "rsc", " dest", "fdsth", "dste", "rdsts", "idsp", "madset", "ddstart", "fdost", "dedconst", "idsc", "madst", "dset", "dssth", "dssc", "dedct", "rsts", "dstart", "fptr", "dssts", "Dost", "dsste", "ddsp", "ddst", "idptr", " dstart", "lct", "nsts", "ndsts", "idst", "Dst", "dsc", "ndset"], "src": ["start", "sci", "low", "uc", "rc", "sec", "url", "gb", "sq", "dist", "loc", "text", "uint", "rss", "sb", "component", "ser", "sync", "sur", "spec", "sc", "support", "img", "image", "site", "use", "dest", "bb", "config", "lib", "chrom", "cont", "s", "rest", "gl", "cur", "st", "bc", "sup", "source", "sort", "inst", "sit", "sn", "req", "secure", "ssl", "supp", "fc", "feat", "sl", "iv", "size", "filename", "uri", "rb", "sound", "b", "attr", "desc", "usc", "cb", "rect", "status", "comp", "pack", "rel", "stat", "rob"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n\n{\n\n    int i;\n\n    int ret = av_frame_ref(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!h->sps.crop)\n\n        return 0;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n\n        dst->data[i] += off;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5908, "substitutes": {"h": ["header", "ih", "e", "d", "self", "p", "uh", "rh", "hr", "r", "hi", "u", "hm", "hl", "head", "l", "eh", "tx", "hp", "s", "hh", "c", "m", "sh", "ht", "ctx", "hd", "v", "t", "g", "f", "oh", "ah", "adh", "hw", "gh", "w", "ph", "H", "FH", "bh", "he", "b", "http", "hs", "ha", "enh", "x"], "dst": [" dsc", " dost", "ssth", " drc", "edost", "dsth", " dST", "Drc", " dsth", "sconst", "dST", " dsts", "dsrc", "adsth", "edsts", " dconst", "edsth", "drc", "Dsc", "Dsth", "sdsth", "sst", "Dost", "Dsrc", "ssrc", "dost", "datsc", "DST", "datST", "Dconst", "datrc", " dsrc", "sdost", "adsc", "adost", "sost", "datst", "dsts", "adst", "Dst", "dconst", "dsc", "ssts", "edst", "Dsts", "sdst", "sdsc"], "src": ["rc", "sth", "url", "ref", "gb", "loc", "sb", "RC", "rh", "sc", "image", "img", "r", "roc", "dest", "config", "inf", "sr", "sh", "st", "ctx", "cur", "source", "sn", "inst", "req", "iv", "rb", "rect", "b", "rl", "cb", "stream", "sel", "rt"], "i": ["bi", "ui", "index", "pi", "ie", "j", "di", "e", "si", "d", "mini", "val", "multi", "fi", "cli", "li", "p", "ti", "vi", "base", "api", "mi", "qi", "ii", "r", "adi", "hi", "u", "line", "id", "n", "l", "ni", "chi", "ami", "s", "c", "init", "ix", "oi", "f", "ib", "zi", "io", "start", "ri", "a", "ini", "info", "it", "gi", "x", "xi", "uri", "eni", "ci", "z", "b", "in", "iu", "count", "I", "ai", "v", "ret"]}}
{"project": "qemu", "commit_id": "100f8f26086ad85a9361f2883edd55bc337ce594", "target": 1, "func": "void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n", "idx": 5920, "substitutes": {"ts": ["ys", "options", "outs", "tes", "trans", "ats", "ers", "tp", "cons", "ks", "lets", "ls", "args", "times", "ps", "uts", "atts", "cs", "acs", "tt", "ims", "Ts", "ds", "xs", "tips", "types", "ents", "stats", "sts", "tx", "s", "states", "ters", "ops", "ss", "t", "services", "ta", "gs", "css", "fs", "te", "ns", "ms", "tr", "TS", "arts", "als", "mods", "docs", "tests", "tc", "js", "ics", "bs", "qs", "rs", "asts"], "is_write": ["as_write", "as_writing", "as_writer", "as_external", "ispubcontrol", "as_control", "as_written", "is\u00b7external", "is\u00b7control", "is_control", "ispubwrite", "is\u00b7writing", "is_writer", "is\u00b7write", "ispubexternal", "is_writing", "is_written", "is_external", "ispubwriting"], "size": ["low", " sizes", "form", "storage", "huge", "small", "second", "number", "scale", "general", "name", "loc", "value", "len", "grade", "sync", "style", "offset", "position", "SIZE", "empty", "bytes", "speed", "password", "large", "izer", "ize", "sized", "content", "c", "Size", "address", "capacity", "city", "settings", "security", "parent", "money", "fee", "code", "izes", "units", "needed", "shape", "timeout", "time", "grow", "six", "count", "zero", "unit", "si"]}}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n", "idx": 5931, "substitutes": {"bs": ["bi", "iss", "pb", "lb", "bn", "gb", "bus", "ab", "sb", "bid", "bos", "bm", "blocks", "BS", "ls", "ps", "vs", "bay", "cs", "bb", "ds", "fb", "ops", "ss", "bes", "ba", "bc", "bg", "fs", "ns", "sa", "bis", "us", "bh", "bp", "b", "cas", "http", "bt", "banks", "rs", "bas", "base"], "attached_aio_context": ["attached_aios_ctx", "attached_aios_address", "attached_aio_address", "attached_aio_channel", "attached_aio_config", "attached_aios_config", "attached_aios_channel", "attached_aio2config", "attached_aios_context", "attached_aio2channel", "attached_aio_connection", "attached_aios_connection", "attached_aio_ctx", "attached_aio2ctx", "attached_aio2context"], "detach_aio_context": ["detach_aios_connection", "detach_aios_resource", "detach_aios_config", "detach_aio_config", "detach_aio_ctx", "detach_aio2context", "detach_aios_center", "detach_aios_ctx", "detach_aio_resource", "detach_aio_connection", "detach_aio2ctx", "detach_aio2config", "detach_aios_context", "detach_aio2resource", "detach_aio_center"], "opaque": ["Opaques", "operula", " oponymous", "ocaque", "operonymous", "operhole", "opacity", " opac", "cophole", "opac", "copaque", "ocula", "opaques", "operac", "ophole", "Opacho", "operaque", " opacho", "Opaque", "oponymous", "operacho", "operacity", "ocacity", "copacity", "opacho", "opula", " opacity", " opula", " opaques", "oconymous", "copac", "Opacity", "operaques", " ophole"], "ban": ["tag", "an", "batch", "anon", "ticket", "fn", "fa", "bn", "pin", "han", "kan", "iban", "bid", "auth", "ork", "card", "anc", "rule", "native", "ann", "don", "un", "kin", "bridge", "bay", "bug", "ang", "pa", "Ban", "pan", "bo", "block", "go", "man", "fen", "wan", "can", "ana", "bon", "scan", "bat", "cat", "comment", "author", "bin", "fan", "ver", "gate", "ga", "gan", "span", "lan", "cas", "bank", "plan", "feature", "anan", "con", "AN", "stat", "base"], "ban_next": ["ban_sec", "ban_handle", " ban2next", " ban2last", "bn_sec", "ban2last", "ban_last", "ban_first", "bn_prev", "ban2next", " ban_first", " ban_last", "ban2first", "bn_next", " ban2first", "bn_handle", "ban_prev"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n", "idx": 5962, "substitutes": {"s": ["storage", "sec", "e", "sb", "sys", "p", "sync", "session", "S", "h", "is", "ps", "app", "ses", "support", "cs", "sets", "gs", "service", "sf", "ds", "c", "m", "sg", "t", "services", "ctx", "fs", "g", "ns", "f", "ssl", "settings", "i", "scl", "secondary", "sv", "js", "es", "conf", "v", "south"], "val": ["data", "ref", "cal", "def", "eval", "pre", "value", "loc", "d", "enc", "exec", "mem", "p", "arr", "buf", "seq", "test", "expr", "u", "ind", "reg", "tx", "all", "v", "Val", "pt", "f", "prop", "vals", "el", "xxx", "err", "i", "sl", "VAL", "al", "x", "valid", "b", "grad", "serv", "sel", "util", "stat", "base"], "rlow": [" rhigh", "Rhigh", "rflow", " rflow", "rrow", "dlow", "rclow", "dhigh", "rchigh", "RLow", "rcLow", " rLow", "Rflow", "Rrow", "rcflow", "rhigh", "rLow", "dLow", "drow", " rrow", "Rlow"], "tmp": ["py", "data", "pb", "wb", "storage", "np", "sample", "pot", "cp", "result", "db", "ppa", "sb", "emp", "tp", "p", "api", "slice", "mp", "app", "buf", "beta", "kk", "test", "img", "bb", "tt", "Temp", "jp", "fake", "obj", "TB", "buff", "txt", "fd", "temp", "t", "ctx", "pointer", "vt", "stuff", "copy", "cache", "xxx", "qq", "cro", "pty", "tc", "amp", "tem", "rb", "b", "tab", "cmp", "ptr", "fp", "cpp", "v"], "tmp2": ["vt0", "emp4", "txt4", "vt2", "bag4", "bagTwo", "tmp4", " tmp4", "temp52", "tmp0", "temp1", "emp2", "temp2", " tmp1", "mp1", "temp0", "tmp52", "emp1", "emp52", "temp4", " tmp0", " tmpTwo", " tmp52", "bag2", "txt2", "txtTwo", "mp4", "tmp1", "tmpTwo", "vt1", "mp2"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963, "substitutes": {"dev": ["av", "data", "Dev", "google", "pub", "dist", "def", "fail", "di", "rad", "diff", "error", "bus", "d", "loader", "exec", "ve", "devices", "mem", "du", "self", "DEV", "api", "app", "conn", "img", "bug", "ev", "prom", "ch", "device", "lib", "pro", "block", "temp", "gd", "v", "engine", "home", "dc", "g", "f", "comment", "mod", "serial", "cam", "hw", "cache", "der", "info", "ad", "ver", "w", "md", "pu", "valid", "node", "grad", "dem", "conf", "serv", "gu", "driver"], "bmdma_base": ["bmdma_bas", "bmdma_cache", "bmdfa2Base", "bmdima_cache", "bmdfa_base", "bmdma__unit", "bmdma__base", "bmdma__bas", "bmdima_unit", "bmdma_bin", "bmdma2Base", "bmdma__cache", "bmdfa_bin", "bmdfa_Base", "bmdfa2bas", "bmdma2bas", "bmdma_Base", "bmdima_base", "bmdma2base", "bmdima_bas", "bmdfa_bas", "bmdma2bin", "bmdma_unit", "bmdfa2base", "bmdfa2bin"], "ide_base": ["idaoutbase", "ideableroot", "ide_bot", "idekb", "idekbased", "ide_based", "idexserver", "idexhome", "ide_resource", "ideoutbot", "idejstore", "ide_stable", "ide_server", "ine_source", "ine_root", "idi_server", "idejbase", "idaoutbot", "idekstore", "ided_resource", "idejkey", "ideksource", "inekb", "synckbased", "ida_stable", "ideenkey", "inekbase", "ida_bot", "idejbased", "idi_base", "ide_b", "ida_key", "ided_bas", "sync_store", "ideenstable", "ide_home", "idaoutkey", "idaoutstable", "ided_server", "idi_area", "idekbase", "ine_base", "idexbase", "ide_area", "idexarea", "ideoutkey", "ideableb", "idekroot", "ida_base", "ide_source", "ideenbot", "ide_bas", "synckbase", "idi_home", "ideablesource", "sync_base", "ide_root", "ide_key", "ided_base", "ide_store", "ideablebase", "ideoutbase", "ideoutstable", "idejbot", "sync_based", "idejstable", "synckstore", "ine_b", "ineksource", "ideenbase", "inekroot"], "status": ["msg", "pos", "sum", "index", "notice", "result", "name", "str", "debug", "sync", "num", "id", "temp", "bc", "reason", "count", "serv", "unit", "data", "cli", "ity", "grade", "git", "current", "sp", "stage", "ss", "magic", "weight", "flag", "score", "code", "valid", "kill", "rc", "Status", "gc", "session", "style", "standard", "full", "login", "speed", "sign", "stats", "g", "action", "pass", "comment", "ssl", "feat", "security", "state", "su", "active", "wait", "spec", "date", "complete", "fail", "progress", "error", "success", "seq", "version", "buffer", "source", "flags", "cache", "err", "info", "update", "stat"], "buf": ["data", "pool", "br", "uc", "wb", "rc", "lb", "bag", "fun", "queue", "bf", "loc", "result", "text", "len", "fi", "mem", "que", "src", "bl", "seq", "config", "dest", "vec", "cmd", "fb", "lim", "block", "buff", "fd", "c", "aux", "home", "ctx", "bc", "buffer", "f", "lit", "cv", "feat", "cache", "coord", "filename", "cf", "comb", "bh", "uf", "la", "ff", "rb", "cas", "b", "cb", "cmp", "fp", "port", "output", "fl", "base"], "cmpbuf": ["cbbuffer", "diffbuffer", "tmpbuf", "compbuf", "compbuff", "rcbuff", "diffcb", "ctrlbuff", "diffbuff", "cmpbuffer", "tmpbuffer", "cmpqueue", "ctrlbuffer", "eqbuffer", "cmpcb", "rcbuf", "compbuffer", "tmpvec", "diffbuf", "rcvec", "compcb", "cmpvec", "eqbuf", "ctxbuf", "cmpbuff", "cbbuff", "eqbuff", "ctxbuff", "tmpbuff", "cbbuf", "rcbuffer", "ctxbuffer", "eqvec", "cbqueue", "ctxcb", "eqqueue", "ctrlbuf", "ctrlqueue"], "prdt": ["prdh", "prt", "brdt", "sprdt", "Prtz", "lrdat", "lrdh", "lrdt", "protd", " prdist", "PRdt", "pardat", "prtf", " prtf", " prdl", " prtd", "sprdl", "prot", "chdh", "frtz", "prtd", " prqt", "PRdm", "frdl", "prtz", "brqt", "Prdt", "brdm", "pldh", " PRtd", "sprqt", "provkt", "frdt", "plqt", "PRkt", "rrdt", " prkt", "crdt", "rrqt", "prqt", " prdh", "frdh", "lrkt", "pldt", " PRdt", "provqt", "prkt", "protf", "rrkt", "pardt", "rrtd", "prodt", "prdm", " PRtf", "partd", "crdh", "prdist", "Prdl", " prdat", "crkt", "pldm", "prdl", "rrdh", "PRdl", " prt", "crdat", "chtz", "sprdist", "prdat", "provdt", "Prdh", " PRt", "rrdat", "chdl", "brkt", "plkt", "provdh", "pldl", "parqt", "brdl", "chdt", "brdist"]}}
{"project": "FFmpeg", "commit_id": "33f58c3616d2870d3861da68217ef9d05cc5047a", "target": 1, "func": "static int idcin_read_packet(AVFormatContext *s,\n\n                             AVPacket *pkt)\n\n{\n\n    int ret;\n\n    unsigned int command;\n\n    unsigned int chunk_size;\n\n    IdcinDemuxContext *idcin = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n    int palette_scale;\n\n    unsigned char r, g, b;\n\n    unsigned char palette_buffer[768];\n\n    uint32_t palette[256];\n\n\n\n    if (s->pb->eof_reached)\n\n        return AVERROR(EIO);\n\n\n\n    if (idcin->next_chunk_is_video) {\n\n        command = avio_rl32(pb);\n\n        if (command == 2) {\n\n            return AVERROR(EIO);\n\n        } else if (command == 1) {\n\n            /* trigger a palette change */\n\n            if (avio_read(pb, palette_buffer, 768) != 768)\n\n                return AVERROR(EIO);\n\n            /* scale the palette as necessary */\n\n            palette_scale = 2;\n\n            for (i = 0; i < 768; i++)\n\n                if (palette_buffer[i] > 63) {\n\n                    palette_scale = 0;\n\n                    break;\n\n\n\n\n            for (i = 0; i < 256; i++) {\n\n                r = palette_buffer[i * 3    ] << palette_scale;\n\n                g = palette_buffer[i * 3 + 1] << palette_scale;\n\n                b = palette_buffer[i * 3 + 2] << palette_scale;\n\n                palette[i] = (r << 16) | (g << 8) | (b);\n\n\n\n\n\n        chunk_size = avio_rl32(pb);\n\n\n\n\n\n        /* skip the number of decoded bytes (always equal to width * height) */\n\n        avio_skip(pb, 4);\n\n        chunk_size -= 4;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (command == 1) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n            memcpy(pal, palette, AVPALETTE_SIZE);\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n        pkt->stream_index = idcin->video_stream_index;\n\n        pkt->duration     = 1;\n\n    } else {\n\n        /* send out the audio chunk */\n\n        if (idcin->current_audio_chunk)\n\n            chunk_size = idcin->audio_chunk_size2;\n\n        else\n\n            chunk_size = idcin->audio_chunk_size1;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        pkt->stream_index = idcin->audio_stream_index;\n\n        pkt->duration     = chunk_size / idcin->block_align;\n\n\n\n        idcin->current_audio_chunk ^= 1;\n\n\n\n\n    if (idcin->audio_present)\n\n        idcin->next_chunk_is_video ^= 1;\n\n\n\n    return ret;\n", "idx": 5965, "substitutes": {"s": ["sci", "sq", "aws", "submit", "sb", "p", "sync", "spec", "ks", "sports", "ls", "S", "sc", "ses", "support", "cs", "sets", "gs", "service", "sf", "ds", "stats", "ss", "c", "sg", "ts", "services", "rs", "ctx", "sym", "t", "f", "ns", "sa", "bis", "ssl", "settings", "se", "scl", "sl", "secondary", "sis", "sv", "su", "sk", "conf", "qs", "south", "si"], "pkt": ["btk", "Peth", " pct", "placket", "hkg", "pnt", "backet", "hkt", "hnt", "wnt", " ptk", "Pct", "wct", "ptk", "pldt", " pnt", "apkt", "wacket", "peth", "pdt", "bkt", "Ptk", " pkg", "hct", "hacket", "Pkg", "apeth", "packet", " packet", "wkt", "apacket", "pkg", " peth", "bkg", "pct", "Pkt", "Packet", "apkg", "plkt", "plct", "Pdt", "Pnt", " pdt"], "ret": ["data", "real", "msg", "hash", "rc", "re", "reset", "ref", "url", "def", "end", "repl", "mt", "result", "value", "rep", "alt", "fun", "error", "att", "back", "success", "len", "val", "db", "str", "open", "get", "arr", "rf", "session", "last", "bit", "RET", "resp", "out", "reg", "res", "rot", "sr", "lag", "run", "buffer", "opt", "pass", "rev", "lit", "cat", "flag", "err", "det", "info", "al", "ft", "match", "reply", "nt", "code", "rt", "after", "active", "arg", "format", "rets", "final", "Ret", "base"], "command": ["batch", "operation", "power", "three", "comm", "sudo", "total", "error", "argument", "input", "slave", "message", "clear", "event", "connection", "move", "session", "last", "type", "function", "channel", "image", "bug", "resource", "git", "config", "service", "cmd", "request", "password", "response", "option", "child", "pattern", "class", "mode", "magic", "lag", "Command", "communication", "which", "action", "force", "buffer", "comment", "attribute", "model", "random", "group", "info", "media", "qq", "reply", "md", "timeout", "length", "active", "direction", "count", "conf", "send", "method", "final", "directory", "format", "handler"], "chunk_size": ["chacket_count", "chunkingcount", "chacket_size", "chatch_pos", "chunk_address", "chunks_data", "chunks_scale", "chacket_length", "chunk_length", "chunk_data", "chunkedsize", "chatchnlength", "chunk64ize", "chunk__address", "chunks_size", "chatch_length", "chunk_scale", "chunk8ize", "chatchnpos", "chunk_mode", "chunk64size", "chunknsize", "chunkingsize", "chunk_sized", "chunk64cache", "chunk8length", "chunk_ize", "chunkedscale", "chunk__pos", "chunk__length", "chunk8count", "chunk_pos", "chet_ize", "chunk__size", "chunknpos", "chunk_cache", "chet_mode", "chatchnsize", "chunk_count", "chunk8size", "chet_size", "chunknlength", "chatch_size", "chunk64mode", "chunkeddata", "chunkedsized", "chet_cache", "chatchnaddress", "chacket_ize", "chunkinglength", "chunknaddress", "chatch_address", "chunkingize", "chunks_sized"], "idcin": [" idxc", "incu", "idci", "itvin", "itci", "dcit", " idvin", "adcit", "dci", "dcin", "idcs", "midcs", "midcin", "idcn", "advin", "itcin", "adci", "bidvin", "idcit", "bidcs", "adxc", "dvin", "adcu", "bidcn", "itcit", "incin", "idcu", "adcin", "midvin", "idxc", "midcn", "adcn", "invin", "inxc", "bidcin", " idcu", "adcs", "idvin"], "pb": ["ub", "wb", "phrase", "pc", "lb", "np", "vm", "proc", "vp", "cp", "db", "ab", "ppa", "bf", "pg", "sb", "pl", "hub", "tp", "typ", "p", "bm", "acl", "api", "bb", "pa", "dp", "bot", "plugin", "fb", "jp", "abc", "buff", "txt", "raf", "ctx", "bc", "pm", "buffer", "summary", "nb", "pt", "platform", "primary", "pp", "prop", "usb", "kt", "eb", "pkg", "wp", "pit", "fc", "PB", "lp", "bh", "bp", "rb", "xb", "cb", "fp", "pd", "cpp", "bps", "prot", "utils", "rob"], "i": ["ui", "bi", "y", "index", "pi", "ie", "j", "di", "field", "diff", "e", "d", "si", "mini", "key", "multi", "fi", "ti", "p", "yi", "base", "slice", "api", "type", "is", "mi", "phi", "image", "qi", "ii", "hi", "u", "inner", "ji", "id", "n", "l", "ni", "ip", "c", "m", "init", "ix", "f", "zi", "io", "source", "ri", "ini", "info", "my", "gi", "it", "xi", "uri", "ci", "eni", "lc", "z", "in", "iu", "I", "ai", "v", "x", "li"], "palette_scale": ["palettes_cale", "palettes_scale", "palette_size", "palette_span", "pallete_margin", "palette_cale", "palette\u00b7span", "pallete_size", "pallete_total", "pallette_fill", "palette_min", "palette_unit", "palette__scale", "palette\u00b7scan", "pallette_scale", "palette_rate", "palette_scan", "palette__fill", "pallete_rate", "palette\u00b7scale", "palette_fill", "palette\u00b7unit", "paletteerrate", "paletteerscale", "paletteertotal", "palettes_span", "palette__size", "pallete_scale", "palettes_scan", "palettes_size", "pallette_size", "palette_total", "palettes_unit", "paletteersize", "palette\u00b7cale", "palette__min", "palette_margin", "pallette_min", "palettes_scope", "palette\u00b7size", "palette_scope"], "r": ["ru", "br", "re", "rc", "k", "e", "d", "vr", "er", "rg", "p", "rh", "h", "hr", "u", "reg", "rr", "l", "n", "sr", "m", "c", "mr", "f", "range", "ro", "a", "R", "nr", "err", "w", "fr", "ga", "dr", "gr", "rb", "G", "v", "rs", "x"], "g": ["gm", "y", "k", "gb", "vg", "e", "d", "pg", "mg", "rg", "p", "gn", "gam", "gc", "gg", "gs", "u", "reg", "n", "l", "m", "sg", "c", "bg", "gin", "f", "ig", "gp", "group", "gh", "gre", "w", "gi", "ga", "gr", "ge", "gen", "G", "fg", "q", "v", "x"], "b": ["wb", "abb", "y", "lb", "k", "B", "ab", "db", "e", "d", "sb", "bar", "mb", "p", "h", "bb", "u", "bot", "fb", "n", "l", "bo", "ob", "c", "t", "f", "ib", "be", "eb", "a", "o", "w", "bh", "bd", "rb", "xb", "z", "bs", "v", "x"], "palette_buffer": ["palette__buffer", "palette_batch", "palize_batch", "palette__buf", "palize_buffer", "paletteingreader", "palizeablequeue", "palette2queue", "pallette_buff", "palette2surface", "pallette_header", "palizeablereader", "paletteingbuffer", "paletteOlist", "paletteingqueue", "paletteedlist", "palotation_buffer", "palettes_slice", "palettes_buffer", "paletteOdevice", "palette_list", "palotationObuffer", "paletteeddevice", "palettes_buf", "palizeablebuffer", "palettealbuffer", "palettes_buff", "palette2header", "paletteablebuffer", "palotation_list", "palettealqueue", "palette_device", "palette2buffer", "paletteedbuffer", "paletteablereader", "palette_pause", "palizeablebatch", "paletteablequeue", "paletteablebatch", "palettealslice", "palettes_queue", "palette2buf", "pallette2queue", "pallette_queue", "palette_header", "palette_queue", "palotation_device", "paletteOpause", "paletteedpause", "palette_slice", "palette_buf", "palette2buff", "palette_reader", "palette_buff", "palettes_surface", "palettes_store", "pallette2header", "palette_surface", "pallette_buffer", "palotationOlist", "pallette2buff", "palette__surface", "palotation_pause", "paletteObuffer", "palize_reader", "palotationOdevice", "palette__buff", "paletteingbatch", "palettealstore", "palette_store", "palotationOpause", "pallette2buffer", "palize_queue"], "palette": ["allette", "plette", "alettes", "Palenge", "callette", "Palble", "Palettes", " palble", " palettes", "aletta", "paletta", "palettes", "alble", "palenge", "plet", " palenge", "calettes", "plenge", "pallette", "plettes", "palble", "pilllette", "palet", "pillettes", "caletta", " palet", "Palette", "pilletta", "alet", "Palet", "pillette", "alette", "calette"], "pal": ["py", "pat", "real", "local", "stal", "opal", "cal", "lab", "apple", "ab", "att", "skin", "fat", "pl", "sil", "bl", "app", "Pal", "pid", "pad", "socket", "isal", "pel", "ne", "ch", "cell", "ask", "pan", "chi", "ind", "ijk", "plug", "wal", "boot", "chal", "nl", "bat", "cel", "el", "bin", "cache", "ph", "al", "bel", "ill", "sk", "pac", "tab", "nav", "conf", "align", "panel", "li"]}}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,\n\n                                        const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                        const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                        const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                        const uint16_t *abuf1, uint8_t *dest,\n\n                                        int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    x86_reg uv_off = c->uv_off << 1;\n\n\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2RGB(%%REGBP, %5, %6)\n\n        \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n        \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n        \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n        \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n        WRITERGB15(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither), \"m\"(uv_off)\n\n    );\n\n}\n", "idx": 5981, "substitutes": {"c": ["e", "d", "enc", "exec", "call", "self", "p", "ce", "h", "oc", "ct", "cm", "cs", "r", "config", "u", "this", "n", "l", "cit", "cy", "s", "m", "t", "cur", "ctx", "dc", "g", "f", "ctrl", "mc", "a", "ec", "cv", "cache", "cu", "w", "cf", "ca", "C", "ci", "lc", "z", "ac", "b", "cb", "con", "conf", "v"], "buf0": ["buff00", "buf3", "uf1", "port0", "buf2", "port00", "buff0", "port2", "buff2", "uf2", "buff10", "buf00", "uf0", "uf3", "uf00", "buff3", "buf10", " buf10", "port3", "uf10", "buff1"], "buf1": ["seq2", "ufb", "uf01", "uf1", "bufb", "buf2", "cv2", "buf01", " buf01", "uf2", "seq0", " bufb", "cv1", " buf2", "uf0", "seq1", "cvb", "cv0", "seq01"], "ubuf0": ["abbuf1", "ubef0", "ubufk", "ubbuff1", "ubbuf00", "abbuf0", "abbufk", "ubuf2", "ubbuf0", "ubuc3", "ubbuff3", "ubef2", "ubbuff0", "abuf3", "ubbuff2", "abbuf00", "ubuc1", "abufk", "ubbuf3", "ubef1", "abuf2", "ubbufk", "abbuf2", "ubuf00", "ubbuf2", "ubuc00", "ubuf3", "abbuf3", "ubbuf1", "ubuc0", "abuf00", "ubbuffk", "ubbuff00", "ubefk"], "ubuf1": ["abbuf1", "ubuffn", "ubef0", "ubbuff1", "abbufn", "ubefn", "abbuf0", "ubuf2", "ubbuf0", "ubef2", "ubbuff0", "ubbuff2", "ubufn", "ubef1", "abuf2", "ubuff0", "abbuf2", "ubbuffn", "ubbuf2", "ubbuf1", "abufn", "ubuff1", "ubbufn"], "vbuf0": ["bufn", "vbuff1", "vuf1", "vbufn", "vbuff2", "vufn", "vmemn", "bbuf1", "buf2", "vmem0", "bbuf0", "vmem2", "bbuf2", "vuf0", "vbuf2", "bbufn", "vbuff0", "vbuffn", "vuf2", "vmem1"], "vbuf1": ["vuf1", "bbufon", "vab1", "bufb", "vufb", "bbuf1", "vmem0", "bufon", "bbuf0", "vuf0", "bbufb", "vmemon", "vabb", "vbufon", "vmem1", "vufon", "vmemb", "vabon", "vbufb", "vab0"], "abuf0": ["abbuf1", "abaf2", "abf2", "abbuf0", "bbuf1", "abaf0", "buf2", "bbuf0", "bbuf2", "abuf2", "abf4", "abbuf2", "buf4", "bbuf4", "abf0", "abf1", "abaf4", "abaf1", "abbuf4", "abuf4"], "abuf1": ["abbuf1", "abufone", "abuc1", "abbuf0", "buf11", "abbuff1", "abbufone", "bbuf1", "bbuf0", "abbuff0", "abuc0", "abbuf11", "bufone", "bbufone", "abuf11", "abuc11", "abucone", "abbuffone", "bbuf11", "abbuff11"], "dest": ["Dest", "wb", "dir", "neg", "target", "dist", "di", "loc", "trans", "mem", "src", "dep", "orig", "img", "ctr", "cont", "dim", "norm", "rest", "home", "dc", "shift", "opt", "source", "trip", "prop", "feat", "coord", "dev", "origin", "comb", "route", "gen", "desc", "attr", "shape", "grad", "transform"], "dstW": ["dstw", "dblB", " dblW", " dblA", " dstB", " dstA", "dstA", " dstw", "dscw", "dconstA", "dblA", "dscW", " dblw", "dscA", "dconstB", "dblw", "dblW", "dstB", "dconstW", "dscB", "dconstw", " dblB"], "yalpha": [" ybeta", "xalpha", "sylambda", " ylambda", "yAlpha", "ybeta", "syAlpha", "xAlpha", "sybeta", "ylambda", "xlambda", "syalpha", " yAlpha", "xbeta"], "uvalpha": ["unvaluepha", "unvalappa", "unvaluelambda", "uvallambda", "uvaluepa", "unvalpa", "uavalappa", "unvaluepa", "unvalueappa", "unvallambda", "ubalappa", "uvaluelambda", "uvalappa", "uavalpha", "uavalpa", "uvalpa", "uballambda", "ubalpha", "unvalpha", "ubalpa", "uvalueappa", "uavallambda", "uvaluepha"], "y": ["oy", "ys", "e", "d", "yy", "ey", "p", "yi", "ry", "h", "ay", "ye", "u", "cy", "vy", "yl", "t", "ym", "f", "Y", "i", "w", "o", "z", "b", "ya", "x"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n", "idx": 6007, "substitutes": {"s": ["sec", "sq", "e", "d", "sb", "server", "p", "sync", "spec", "args", "S", "is", "ps", "ses", "gs", "r", "cs", "service", "sf", "ds", "ops", "ss", "m", "sg", "c", "v", "services", "sym", "g", "f", "ns", "a", "ssl", "o", "less", "js", "b", "es", "q", "os", "conf", "serv", "qs", "rs", "si"], "req": ["ext", "ref", "sq", "j", "def", "progress", "proc", "e", "er", "str", "call", "op", "rx", "rf", "p", "iq", "rh", "dq", "hr", "org", "seq", "pr", "r", "resp", "request", "rr", "jp", "res", "obj", "load", "temp", "sr", "mr", "cur", "rec", "tr", "f", "next", "requ", "wa", "ec", "quest", "cache", "err", "w", "ar", "cf", "fr", "require", "gr", "z", "qt", "desc", "arg", "cb", "q", "comp", "fp", "rs", "pull", " request", "spec"]}}
{"project": "FFmpeg", "commit_id": "f7a02d5d694bcef993b0229c9e57f22421fed637", "target": 0, "func": "static int output_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n\n\n    AVPacket avpkt;\n\n    if (!ist->saw_first_ts) {\n\n        ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;\n\n        ist->pts = 0;\n\n        if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {\n\n            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong\n\n        }\n\n        ist->saw_first_ts = 1;\n\n    }\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = ist->dts;\n\n    }\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6008, "substitutes": {"ist": ["dist", "set", "ict", "mt", "past", "er", "isc", "std", "adder", "empt", "ace", "old", "add", "dit", "ird", "art", "best", "nd", "ort", "esp", "ft", "IST", "fp", "oss", "ht", "wd", "pect", "att", "ast", "tt", "ind", "ic", "rest", "st", "mot", "kt", "inst", "start", "wp", "part", "isi", "ess", "ide", "pull", "istor", "pick", "ext", "aint", "nant", "xt", "p", "irst", "edit", "et", "pt", "artist", "feat", "ad", "it", "list", "osi", "nt", "state", "post", "work", "ant", "irc", "isd", "alist", "gest", "end", "asp", "ust", "ord", "ard", "ists", "op", "lect", "pop", "est", "at", "dd", "ait", "act", "sett", "hop", "iste", "sta", "erd", "dr", "exist", "ism", "ld", "rt"], "pkt": ["pet", "tpkt", "pelt", "cpcht", "facket", " pft", "mkt", "apkt", "ipacket", "pcht", "cpft", "spunt", "prunt", "pft", "prwk", "ipnt", " pct", "t\n", "tkt", "P\n", "apet", " pwk", "pk", "Pct", "cpkt", "binch", " pnt", "praser", "spelt", "cpelt", "npacket", "npk", "Pd", "Pkt", "spinch", "tft", "tpwk", "spkt", "Packet", "bunt", "p\n", " pelt", " pk", "ipct", "npkt", "tpcht", "mft", "cpk", "opwk", "pnt", "bwk", "maser", "paser", "cpet", " pqt", "tpaser", " pd", "bkt", "spcht", "tet", "prkt", "opkt", " packet", "punt", "opcht", "pinch", "apqt", "npcht", "pct", "tqt", "pd", "Pnt", "mwk", "spqt", "tacket", "mcht", "opacket", "ipkt", "fqt", "spwk", " pet", "pwk", "melt", "apelt", " pcht", "princh", "prcht", "cpacket", "packet", " p\n", "pqt", "fft", "fkt", "telt", "macket", "td", "met", "apcht"], "i": ["ui", "pi", "j", "di", "d", "fi", "ti", "p", "slice", "h", "mi", "ii", "hi", "inner", "ind", "n", "ni", "ip", "c", "t", "f", "io", "it", "ci", "iu", "I", "si", "li"], "got_output": ["gotwresponse", " got_out", "got_response", "got_version", "got_out", "lost_version", "lost_response", "got2response", "lost_output", "got2output", "gotwoutput", "gotwversion", "got2out", " got_response"], "avpkt": ["avcpkh", "avsput", "varpkt", "avfkh", "avbpkt", "svpkh", "avfelt", "compacket", "AVpinch", "varspkt", "AVcpet", "avbpet", "avbppt", "avmqt", "avbpetsk", "akprft", "avcpinch", "evpcht", "avpetsk", "avtinch", "avbpcht", "avpcft", "avapwk", "evpet", "avcpwk", "akprke", "avpdt", "comopelt", "avpkh", "avpft", "akpke", "avpacket", "akpkt", "avopetsk", "avecpnt", "AVcpinch", "avecpqt", "avnpnt", "navpelt", "AVpet", "avlpet", "varspft", "akpritter", "varpft", "avcpet", "navnpdt", "avcppt", "avnpdt", "avpelt", "avcpnt", "avpnt", "avdkt", "varspdt", "avpcdt", "evcpcht", "AVcpkt", "avbpacket", "varsput", "avtpkt", "avopdt", "avnpelt", "varpdt", "avtpke", "avmnt", "avtpcht", "avspkt", "avepwk", "svcpcht", "avpcht", "avpinch", "avpet", "avapkt", "avfkt", "avlpcht", "akpft", "compelt", "avspdt", "competsk", "avtpet", "svcpkh", "navnpnt", "avtkt", "avcpacket", "avdelt", "avcpcht", "avspke", "comopetsk", "avepqt", "akprkt", "avlpkh", "avcompdt", "avspitter", "avtpitter", "avepnt", "avpwk", "avprkt", "avput", "avepkt", "avtet", "avppt", "svpkt", "avopelt", "navpnt", "evcpet", "avmkt", "avcomput", "navpdt", "avpke", "evcpkt", "avnpkt", "avcompkt", "avecpwk", "AVpcht", "evppt", "avlppt", "avprft", "avpckt", "varput", "compkt", "avopacket", "svpacket", "avtpft", "navpkt", "avpritter", "avopkt", "avspft", "comopkt", "avdnt", "svcpacket", "avprke", "avtpinch", "avapnt", "avlpacket", "avtcht", "AVcpcht", "evcppt", "avpcut", "svcpkt", "avopnt", "navnpelt", "avfetsk", "avfcht", "avcompft", "comopacket", "avpqt", "avecpkt", "avcpqt", "avbpelt", "svpcht", "AVpkt", "avlpkt", "avpitter", "akpitter", "evpkt", "navnpkt", "avfacket", "avcpkt", "avddt", "avmwk", "avapqt"], "duration": ["sec", "total", "result", "fun", "d", "len", "debug", "fe", "done", "resp", "id", " result", "obj", "res", "sg", "g", "f", "gap", "start", "group", "err", "loop", "code", "gen", "desc", "wait"]}}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}", "idx": 6025, "substitutes": {"re": ["real", "root", "ru", "replace", "reset", "rc", "ref", "pre", "result", "ree", "e", "de", "get", "server", "sys", "rule", "Re", "ry", "bre", "record", "r", "resp", "ren", "change", "rex", "reg", "per", "response", "res", "rer", "c", "entry", "run", "rec", "rev", "parse", "ro", "gre", "RE", "cache", "se", "rem", "release", "ra", "com", "rew", "resource", "row", "rel", "ret"], "nre": ["lcre", "neRE", " ncre", "lrec", "lre", "Nre", "nerec", "nres", "ncre", "Nres", "Ncre", "lres", "necre", " nRE", "Nrec", " nres", "nrec", " nrec", "nRE", "nere", "NRE"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n", "idx": 6032, "substitutes": {"sd": ["SD", "gb", "vd", "od", "sam", "dist", "db", "di", "diff", "d", "sb", "dh", "dt", "li", "df", "std", "ls", "ses", "cod", "cs", "td", "sf", "ds", "sem", "ze", "ic", "dal", "dd", "s", "fd", "gd", "sg", "sh", "dy", "hd", "dc", "des", "g", "dis", "ed", "zi", "nd", "sim", "sn", "dl", "dk", "se", "sl", "ad", "dev", "ci", "bd", "lc", "ud", "md", "dm", "cd", "sv", "sk", "su", "tf", " dd", "dem", "pd", "ld", "eddy", "si", "dat"], "bdrv": ["bsrf", " bdrvs", "byrh", "byrvin", " bdrw", " bdrc", "bDrV", "bderc", " bdrvd", "bsrc", "bhrw", "bDrc", "bcrw", "bDRv", " bdrV", " bsrv", "bstrh", "bdrc", "bsrb", "bhrc", "bderh", "bhrvd", "cdrv", "bstrvin", "bstrv", "bdriv", "bDrv", "ddrvin", "crdv", "bDRp", "Bsrc", "bstrk", "bDrb", "bcrva", "bdrw", "bdrva", "ddervin", "bgriv", "bdrh", "dderh", "ddrv", " bdriv", "bhrk", "bDrvd", " bsrc", "bhrV", " bDrv", "brv", "bhrv", "bdervin", "bdrk", "bDRb", "bdrV", "bgrw", "brdw", "brdv", "cdrp", " bdrva", "bcrv", " bsrva", "bdrvin", "BsrV", " bsrvs", "BdrV", "bderv", "crdp", "bsrk", " bsrw", "bhrva", " bDrc", "dderv", "cdrb", "ddrh", "bderk", "bhrp", "bsrvs", "brV", "bstrV", "Bdrk", "Bsrv", "bhrb", "bsrV", "cdrw", "Bdrc", " bDrV", "dderk", "crdb", "bhrvs", "bdrvd", "ddrk", " bdrb", " bdrf", "crdw", "bsrv", "bdrf", "bsrw", "bsriv", "bstrc", "brvd", "bdrb", "Bdrv", "bcrvs", "bdrp", "bderw", "bsrva", "bDrf", "bgrv", "brdp", "bgrc", "bdrvs", "Bsrk", "brc", "bderiv", "byrk", "byrv", " bDrvd", "brdb", "bDRw", " bsriv"], "size": ["sum", "section", "set", "scale", "name", "equ", "esc", "zen", "engine", "Size", "en", "fee", "six", "term", "form", "ie", "sq", "total", "grade", "ey", "test", "offset", "position", "config", "ize", "mode", "sized", "ix", "address", "weight", "sex", "iz", "cl", "secure", "group", "code", "sw", "shape", "send", "body", "storage", "sec", "small", "len", "conn", "speed", "SIZE", "password", "n", "c", "content", "shift", "capacity", "security", "see", "length", "complete", "loc", "e", "cc", "server", "zip", "sc", "empty", "sh", "version", "sn", "max", "ec", "se", "z", "desc", "ect", "cess"], "sect": ["ign", "pect", "form", "sec", "section", "sq", "vel", "fat", "len", "fts", "equ", "cc", "zip", "cross", "filter", "zen", "ct", "conn", "seq", "test", "offset", "patch", "aff", "config", "sections", "connect", "ection", "except", "pattern", "sector", "act", "sex", "pass", "array", "iz", "ec", "qa", "crop", "part", "feat", "det", "ft", "scroll", "sw", "sub", "edge", "ff", "length", "ctor", "own", "ect", "subject", "ECT", "round", "six", "select", "access"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 6033, "substitutes": {"d": ["dn", "da", "od", "xd", "db", "e", "dh", "did", "dt", "p", "df", "ded", "D", "dos", "dp", "ds", "ind", "dict", "dd", "fd", "gd", "c", "t", "dy", "dc", "dad", "dl", "ad", "driver", "bd", "md", "dm", "cd", "dx", "pd", "ld", "dat"], "index": ["batch", "pos", "depth", "note", "ref", "end", "url", "loc", "len", "byte", "base", "num", "offset", "inc", "position", "Index", "config", "ind", "id", "block", "address", "f", "start", "part", "bin", "axis", "i", "info", "prefix", "fee", "uri", "loop", "level", "route", "node", "iter", "addr", "count", "ln", "ld"], "nb": ["batch", "bi", "split", "note", "abb", "nn", "lb", "bn", "seed", "gb", "wb", "db", "bf", "sb", "bm", "quad", "uni", "bb", "aff", "lib", "buff", "bc", "kb", "ib", "nd", "eb", "slot", "bin", "nob", "NB", "fee", "bd", "bp", "rb", "b", "timeout", "node", "cb", "base"], "leaf": ["batch", "root", "abb", "split", "nn", "lb", "ref", "kid", "lv", "bf", "nil", "ignore", "af", "cc", "quad", "offset", "fff", "lib", "inf", "abc", "child", "pattern", "urse", "layer", "bc", "children", "f", "flag", "parent", "slot", "loop", "lf", "lc", "level", "node", "tree", "ld", " Leaf"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n\n                              const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        if (check_fit_tl(args[0], 13)) {\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);\n\n        } else {\n\n            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,\n\n                           args[0] & 0x3ff, ARITH_OR);\n\n        }\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n            uint32_t old_insn = *(uint32_t *)s->code_ptr;\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            /* Make sure to preserve links during retranslation.  */\n\n            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));\n\n        } else {\n\n            /* indirect jump method */\n\n            tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0]));\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL);\n\n        }\n\n        tcg_out_nop(s);\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_call:\n\n        if (const_args[0]) {\n\n            tcg_out_calli(s, args[0]);\n\n        } else {\n\n            tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL);\n\n        }\n\n        /* delay slot */\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_br:\n\n        tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]);\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n\n        break;\n\n\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32):    \\\n\n        glue(glue(case INDEX_op_, x), _i64)\n\n\n\n    OP_32_64(ld8u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n\n        break;\n\n    OP_32_64(ld8s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n\n        break;\n\n    OP_32_64(ld16u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n\n        break;\n\n    OP_32_64(ld16s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n\n        break;\n\n    OP_32_64(st8):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STB);\n\n        break;\n\n    OP_32_64(st16):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STH);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STW);\n\n        break;\n\n    OP_32_64(add):\n\n        c = ARITH_ADD;\n\n        goto gen_arith;\n\n    OP_32_64(sub):\n\n        c = ARITH_SUB;\n\n        goto gen_arith;\n\n    OP_32_64(and):\n\n        c = ARITH_AND;\n\n        goto gen_arith;\n\n    OP_32_64(andc):\n\n        c = ARITH_ANDN;\n\n        goto gen_arith;\n\n    OP_32_64(or):\n\n        c = ARITH_OR;\n\n        goto gen_arith;\n\n    OP_32_64(orc):\n\n        c = ARITH_ORN;\n\n        goto gen_arith;\n\n    OP_32_64(xor):\n\n        c = ARITH_XOR;\n\n        goto gen_arith;\n\n    case INDEX_op_shl_i32:\n\n        c = SHIFT_SLL;\n\n    do_shift32:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        c = SHIFT_SRL;\n\n        goto do_shift32;\n\n    case INDEX_op_sar_i32:\n\n        c = SHIFT_SRA;\n\n        goto do_shift32;\n\n    case INDEX_op_mul_i32:\n\n        c = ARITH_UMUL;\n\n        goto gen_arith;\n\n\n\n    OP_32_64(neg):\n\n\tc = ARITH_SUB;\n\n\tgoto gen_arith1;\n\n    OP_32_64(not):\n\n\tc = ARITH_ORN;\n\n\tgoto gen_arith1;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);\n\n        break;\n\n    case INDEX_op_divu_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i32:\n\n        tcg_out_setcond_i32(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i32:\n\n        tcg_out_movcond_i32(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    case INDEX_op_add2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_ADDCC, ARITH_ADDX);\n\n        break;\n\n    case INDEX_op_sub2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_SUBCC, ARITH_SUBX);\n\n        break;\n\n    case INDEX_op_mulu2_i32:\n\n        c = ARITH_UMUL;\n\n        goto do_mul2;\n\n    case INDEX_op_muls2_i32:\n\n        c = ARITH_SMUL;\n\n    do_mul2:\n\n        /* The 32-bit multiply insns produce a full 64-bit result.  If the\n\n           destination register can hold it, we can avoid the slower RDY.  */\n\n        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c);\n\n        if (SPARC64 || args[0] <= TCG_REG_O7) {\n\n            tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX);\n\n        } else {\n\n            tcg_out_rdy(s, args[1]);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld_i32:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], false);\n\n        break;\n\n    case INDEX_op_qemu_ld_i64:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], true);\n\n        break;\n\n    case INDEX_op_qemu_st_i32:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n    case INDEX_op_qemu_st_i64:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STX);\n\n        break;\n\n    case INDEX_op_shl_i64:\n\n        c = SHIFT_SLLX;\n\n    do_shift64:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        c = SHIFT_SRLX;\n\n        goto do_shift64;\n\n    case INDEX_op_sar_i64:\n\n        c = SHIFT_SRAX;\n\n        goto do_shift64;\n\n    case INDEX_op_mul_i64:\n\n        c = ARITH_MULX;\n\n        goto gen_arith;\n\n    case INDEX_op_div_i64:\n\n        c = ARITH_SDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_divu_i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_ext32s_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        break;\n\n    case INDEX_op_trunc_shr_i32:\n\n        if (args[2] == 0) {\n\n            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i64:\n\n        tcg_out_movcond_i64(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 6043, "substitutes": {"s": ["d", "sync", "native", "site", "sg", "services", "fs", "f", "en", "b", "groups", "conf", "v", "south", "private", "an", "local", "sites", "sq", "sb", "h", "ses", "cs", "r", "this", "u", "sf", "ions", "ss", "ts", "t", "uns", "ns", "a", "w", "its", "your", "es", "http", "hs", "sys", "self", "p", "ks", "session", "S", "ps", "gs", "sets", "xs", "ches", "stats", "n", "g", "us", "ssl", "su", "qs", "rs", "si", "spec", "scope", "e", "client", "is", "service", "ds", "l", "states", "sym", "m", "se", "i", "secondary", "o", "js", "os", "stat"], "opc": ["Opct", "opte", "opere", "opnc", "ipc", "ope", "operf", "iopnc", "operc", " opnc", "opf", "Opf", "ipci", "opci", "ipnc", "Opc", "optc", "Ope", "opct", "iopci", " opci", " opct", "optct", "operct", "iopct", "optf", "iopc", "ipct"], "args": ["result", "mm", "changes", "Args", "res", "init", "ants", "features", "arg", "grades", "pres", "groups", "v", "data", "lines", "enc", " arg", "call", "kw", "params", "bug", "cs", "alls", "config", "ts", "ix", "ns", "arms", "axis", "w", "size", "limits", "ins", "ys", "ages", "sec", "ras", "parts", "p", "arr", "ks", "ay", "atts", "uments", "gs", "ims", "headers", "xs", "stats", "ass", "ids", "fields", "g", "ig", "ams", "Arg", "items", "x", "spec", "py", "aws", "dates", "argument", "is", "empty", "ds", "days", "m", "members", "ms", "as", "flags", "points", "words", "gas", "js"], "const_args": [" const_Args", "param_bits", "const_flags", " const_flags", "const_parts", "const_keys", "param_parts", "param_keys", "const_bits", "const_Args", "param_args"], "c": ["unc", "nc", "pc", "end", "e", "p", " rc", "h", "xc", "r", "cs", "n", "l", "ctx", "dc", "f", "a", "fc", "i", "cu", "C", "ci", "lc", "ac", "b"]}}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    EightSvxContext *esc = avctx->priv_data;\n\n    int n, out_data_size;\n\n    int ch, ret;\n\n    uint8_t *src;\n\n\n\n    /* decode and interleave the first packet */\n\n    if (!esc->samples && avpkt) {\n\n        int packet_size = avpkt->size;\n\n\n\n        if (packet_size % avctx->channels) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");\n\n            if (packet_size < avctx->channels)\n\n                return packet_size;\n\n            packet_size -= packet_size % avctx->channels;\n\n        }\n\n        esc->samples_size = !esc->table ?\n\n            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;\n\n        if (!(esc->samples = av_malloc(esc->samples_size)))\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* decompress */\n\n        if (esc->table) {\n\n            const uint8_t *buf = avpkt->data;\n\n            uint8_t *dst;\n\n            int buf_size = avpkt->size;\n\n            int i, n = esc->samples_size;\n\n\n\n            if (buf_size < 2) {\n\n                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            /* the uncompressed starting value is contained in the first byte */\n\n            dst = esc->samples;\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *(dst++) = buf[0]+128;\n\n                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);\n\n                buf += buf_size / avctx->channels;\n\n                dst += n / avctx->channels - 1;\n\n            }\n\n        } else {\n\n            raw_decode(esc->samples, avpkt->data, esc->samples_size);\n\n        }\n\n    }\n\n\n\n    /* get output buffer */\n\n    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n\n    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;\n\n    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = esc->frame;\n\n\n\n    out_data_size = esc->frame.nb_samples;\n\n    for (ch = 0; ch<avctx->channels; ch++) {\n\n        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;\n\n        memcpy(esc->frame.data[ch], src, out_data_size);\n\n    }\n\n    out_data_size *= avctx->channels;\n\n    esc->samples_idx += out_data_size;\n\n\n\n    return esc->table ?\n\n        (avctx->frame_number == 0)*2 + out_data_size / 2 :\n\n        out_data_size;\n\n}\n", "idx": 6063, "substitutes": {"avctx": ["Avcmp", "avutils", "verconfig", "afwcs", "avecu", "verhw", "avetx", "avloc", "avconfig", "afctx", "ajcontext", "avtx", "avalutils", "avcmd", "ajctrl", "afhw", "varcli", "navctx", "avalctx", "ajlc", "versci", " avctl", "AVutils", "varctl", "avalloc", "avalcu", "ajpkg", "alctrl", " avcb", "afloc", "avcb", "afcmp", "navconn", "alxc", "avclient", "avalxc", "avelc", "afsci", "avecontext", "avpkg", "navcu", " avloc", "afconn", "Avctx", "afcu", "evctx", "AVcu", "AVctx", "afctl", "aflc", "avalconfig", "afpkg", "evcontext", "aveconfig", "Avcontext", "alctx", "avexc", "varctx", " avctrl", "avcontext", "avalcup", "aveconn", "navcontext", "alcb", "avsci", "avconn", "vertx", "navconfig", "avcp", "avecmp", "ajconfig", "afutils", "avxc", "avecp", "ajconn", "verpkg", "AVcontext", "avewcs", "avalctrl", "avalcmp", "afcf", "avcmp", "verctx", "Avconfig", "avcli", "ajwcs", "aveutils", " avcli", "verclient", "varcontext", "avalcp", "afclient", "evcf", " avxc", "avecmd", "avalhw", "avcup", "avalcontext", "vercontext", "avcu", "avecup", "afconfig", " avcontext", "ajclient", "avecf", "navcf", "afcli", "ajutils", "avectrl", "afxc", "avctl", "ajcmd", "avcf", "afcontext", "avlc", "avctrl", "ajcp", "avecb", "avwcs", "evcmp", "avalsci", "avhw", "avectx", "aftx", "ajcup", "afcmd", "ajctx"], "data": ["batch", "ui", "rc", "index", "da", "reader", "def", "final", "DATA", "result", "input", "d", "queue", "value", "Data", "devices", "call", "ata", "slice", "image", "channel", "module", "config", "empty", "bytes", "device", "response", "video", "read", "block", "content", "address", "buffer", "next", "start", "a", "parent", "cache", "bin", "media", "ad", "size", "memory", "code", "length", "in", "addr", "results", "body", "window", "after", "dat"], "got_frame_ptr": ["got_frame_pointer", "got_frame_alloc", "got_fram_alloc", "got_fram_buffer", "got_fram_ptr", "got_frame_buffer", "got_fram_pointer"], "avpkt": ["affck", "avwcht", "avopeth", "avfkh", " avpbkt", "afpect", "avPnt", "avppct", "avepct", "avPkt", " avptch", "avcke", "avpkh", " avpeth", " avpkh", "avpacket", "avcct", "afpnt", "avpbtch", " avpbeth", "avmke", "avwkt", "avspct", " avpcht", "avwpkt", "avpptch", "AVpptch", "afckt", "avnpect", "avwkh", " avlpacket", "avfpacket", "avcpnt", "avpnt", " avpbnt", "avspiece", " avlpcht", "avwacket", "avlptch", "avspkt", "avpcht", "avefpct", "avpbeth", "avmect", "AVppiece", "avpbkt", "avmck", "avfkt", "avlpcht", "AVpiece", "avlpiece", "avptch", " avpacket", "avckt", "afcke", "avpbnt", "avpeth", "afpkt", "avcpck", "avcpacket", " avlpkt", "avfck", "avefpeth", "afpck", "afcck", "avcacket", "afpacket", "avlpkh", "afcect", "avceth", "avepkt", " avpbtch", "avnpke", "avefpacket", "affkt", "avepacket", "avlpct", "avwpeth", "avmkt", "avepeth", "avpct", "avefpkt", "avpke", " avpnt", "avnpkt", "avfct", "avcck", "affnt", "avpck", "avnpck", "avppkt", "avfeth", "avopkt", "avwptch", "afpke", "AVppct", "avfpeth", "AVpct", "avlpacket", "avfnt", "avopnt", "AVppkt", "avfpkt", "avfcht", "avPck", "avPacket", "avsptch", "AVptch", "affacket", "avoptch", "avfpct", "AVpkt", "avwpnt", "avppiece", "avlpkt", " avlpkh", "avcect", "avpiece", "avfacket", "avcpkt", "avpect"], "esc": ["eval", "ssh", "equ", "isc", "que", "ce", "ace", "ctr", "abc", "ese", "cr", "esp", "cf", "usc", "six", "context", "ex", "EC", "ae", "enc", "exec", "ea", "SC", "LC", "oc", "ep", "escape", "eg", "asc", "ek", "dc", "acc", "cl", "osc", "ecd", "cv", "eca", "Desc", "code", "lc", "https", "DC", "unc", "uc", "ext", "rc", "sec", "Esc", "pg", "decl", "org", "xc", "election", "ef", "eng", "css", "qa", "ssl", "ega", "access", "irc", "complete", "nc", "loc", "e", "exc", "cc", "nec", "sc", "auc", "ASC", "egal", "ev", "imp", "env", "ctx", "oe", "ec", "fc", "tc", "desc", "esi", "ect"], "n": ["nm", "nc", "fn", "y", "k", "np", "j", "number", "nu", "name", "e", "d", "na", "p", "num", "conn", "r", "ne", "u", "pn", "l", "ni", "s", "net", "m", "c", "t", "nb", "ns", "f", "g", "sn", "network", "en", "nr", "N", "o", "w", "nt", "cn", "z", "b", "count", "v", "x"], "out_data_size": ["out_data64size", "out_buffer_len", "out_data_len", "out_buffer_name", "out_data64name", "out_data64len", "out_data_name", "out_buffer_size"], "ch": ["batch", "nc", "k", "ach", "th", "name", "cho", "ry", "h", "conn", "cor", "chan", "l", "res", "qu", "ck", "c", "f", "sn", "err", "ver", "nt", "code", "z", "col", "q", "conf"], "ret": ["batch", "rc", "ref", "result", "enc", "back", "na", "len", "val", "mem", "rx", "arr", "no", "ann", "nz", "seq", "img", "resp", "ne", "res", "aux", "rec", "err", "code", "rem", "cb", "sel"], "src": ["func", "fn", "rc", "url", "gb", "loc", "sync", "sc", "seq", "img", "dest", "config", "tmp", "rec", "bg", "buffer", "source", "inst", "cv", "sub", "rb", "attr", "rl", "cb", "stream", "sel", "rs", "port"], "buf": ["batch", "pool", "pb", "br", "uc", "wb", "rc", "wav", "header", "bag", "bus", "ab", "queue", "loc", "text", "Buffer", "fi", "ha", "que", "map", "h", "pad", "seq", "auc", "img", "box", "config", "off", "vec", "cmd", "fb", "block", "buff", "fd", "ba", "grab", "cur", "bc", "cube", "uno", "buffer", "f", "Buff", "cv", "wave", "cf", "comb", "code", "cap", "bd", "uf", "ff", "band", "rb", "b", "cb", "cp", "feed", "port"], "dst": [" dste", "dedstage", "idstal", "sdsts", " dbl", "dstage", " dST", " dstage", "sdST", "dST", " dsts", "idbl", "lsts", "lst", "dbl", "DST", "ldsts", "ldst", "dedsts", "idsts", "ndst", "dstal", "ldST", "instage", "dste", "inst", "inST", "ndsts", "Dste", "idST", "idst", "dsts", "ndST", "dedST", " dstal", "lstal", "insts", "dedst", "lST", "Dst", "dedste", "ldste", "Dsts", "sdst", "ndbl", "sdste"], "i": ["ui", "bi", "index", "pi", "k", "ie", "j", "di", "e", "d", "si", "multi", "fi", "ti", "p", "h", "phi", "qi", "ii", "ki", "u", "ji", "ni", "chi", "ip", "c", "ori", "ix", "oi", "f", "zi", "io", "ini", "o", "w", "gi", "xi", "uri", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "x", "li"]}}
{"project": "qemu", "commit_id": "80dcfb8532ae76343109a48f12ba8ca1c505c179", "target": 0, "func": "static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n    int ret;\n\n\n\n    if (version_id > 3) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* The virtio device */\n\n    ret = virtio_load(&s->vdev, f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n    }\n\n\n\n    /* The config space */\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    tswap32s(&max_nr_ports);\n\n    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {\n\n        /* Source could have had more ports than us. Fail migration. */\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6069, "substitutes": {"f": ["xf", "form", "fa", "fn", "k", "ref", "e", "d", "bf", "fed", "fx", "fo", "fi", "fe", "af", "p", "rf", "df", "function", "h", "F", "fore", "r", "framework", "sf", "fw", "fm", "fb", "file", "l", "fish", "inf", "buff", "fd", "m", "c", "fen", "t", "fs", "g", "fc", "cf", "fr", "uf", "ff", "b", "fac", "tf", "fp", "feed", "v"], "opaque": ["oca", "copca", "oacity", " opacs", "opaco", "oplaque", "opacs", "opacity", "Opacs", "oplacity", "oplca", " opac", "opac", "operaco", "oaque", "copaque", "operac", "Opac", "operaque", "Opaque", "operacs", "copacity", " opaco", "opca", "Opaco"], "version_id": ["versionadid", " version_desc", "versionadfor", "versionFstatus", "ver_i", " version_name", "versionertype", "versioneri", "versioningids", "versionerids", "version_i", "version_name", "version_ids", "versionadname", "ver_ids", "version_for", "ver_for", "vert_name", "versionFid", "ver_name", "versioningid", "version_type", "versionOno", "versioningi", "versioningtype", "vert_no", "versionerid", "version_no", "versionFname", "version_iden", " version_ids", "versionOiden", "ver_id", "versionOid", "vert_iden", "ver_status", "versionFfor", "version_status", "vert_id", "version_desc", "versionadstatus", "ver_type", "versionOname"], "s": ["form", "sq", "j", "e", "d", "parts", "sb", "server", "self", "p", "sync", "spec", "details", "slice", "ls", "session", "S", "socket", "ps", "is", "ses", "site", "gs", "r", "service", "sf", "ds", "sp", "u", "l", "ops", "ss", "m", "c", "ts", "services", "sg", "t", "sym", "fs", "g", "ns", "sup", "source", "sa", "sim", "bis", "ssl", "settings", "se", "info", "sl", "o", "sv", "su", "b", "es", "side", "js", "http", "os", "conf", "feed", "v", "south", "si"], "port": ["tag", "data", "Port", "form", "proxy", "object", "target", "j", "end", "text", "trans", "slave", "import", "component", "export", "server", "report", "p", "op", "rule", "connection", "function", "type", "client", "test", "bridge", "bug", "patch", "config", "service", "device", "plugin", "plane", "ip", "child", "PORT", "m", "ion", "t", "address", "host", "source", "point", "model", "gp", "ort", "part", "parent", "nat", "o", "sl", "ports", "table", "project", "ported", "match", "manager", "state", "route", "post", "cp", "feed", "machine", "v", "driver", "public"], "max_nr_ports": ["max_nr__times", "max_nr00ports", "max_nr75ports", "max_nr_images", "max_num_rows", "max_nr_port", "max_nr33devices", "max_nr_orts", "max_num_orts", "max_nr_rows", "max_nor_rows", "max_nr_players", "max_num_times", "max_nr__devices", "max_nr__ports", "max_nr67planes", "max_nr67players", "max_nr00devices", "max_nr2ports", "max_nr67orts", "max_nr68planes", "max_nr_devices", "max_nr2rows", "max_num_planes", "max_nr2devices", "max_num_services", "max_nr68ports", "max_nor_items", "max_nr_services", "max_nr68players", "max_nor_port", "max_nr2images", "max_num_points", "max_nr33ports", "max_nr__rows", "max_nr__port", "max_num_players", "max_nr_times", "max_num_images", "max_num_devices", "max_nr00rows", "max_nr00items", "max_nr75devices", "max_nr_items", "max_nr_planes", "max_nr67ports", "max_nr75images", "max_nr00services", "max_nr68orts", "max_nr00port", "max_num_port", "max_nor_ports", "max_num_ports", "max_nr33services", "max_num_pins", "max_nr__points", "max_nr33orts", "max_nr75rows", "max_nr__pins", "max_nr_pins", "max_nr__items", "max_nr00orts", "max_nr_points"], "nr_active_ports": ["nr_active23port", "nr_active__orts", "nr_nr_ports", "nr_active___orts", "nr_active___ports", "nr_active23ports", "nr_active__parts", "nr_active__modules", "nr_active23guards", "nr_active_guards", "nr_active___devices", "nr_nr_port", "nr_active_modules", "nr_nr_orts", "nr_active__port", "nr_active_devices", "nr_active__ports", "nr_nr_modules", "nr_active_parts", "nr_active___modules", "nr_active__devices", "nr_active_port", "nr_nr_devices", "nr_nr_parts", "nr_active_orts"], "ports_map": ["ports_data", "ports_dict", "ports2dict", "orts_dict", "export_list", "orts_maps", "orts_list", "export_app", "services_maps", "portsingmaps", "ports_maps", "ports_list", "services_data", "ports2list", "services_default", "services_list", "exportingmaps", "portsingmap", "services_map", "ports2map", "export_map", "ports_default", "orts_map", "ports_app", "export_maps", "exportingapp", "exportinglist", "exportingmap", "ports2maps", "portsinglist", "services_dict", "portsingapp"], "i": ["bi", "ui", "y", "index", "pi", "ie", "j", "di", "e", "d", "si", "mini", "len", "multi", "fi", "ti", "p", "yi", "slice", "type", "is", "mi", "phi", "qi", "ii", "r", "out", "hi", "u", "inner", "ind", "n", "ni", "l", "ip", " j", "c", "net", "m", "t", "init", "ix", "oi", "zi", "io", "ri", "ini", "info", "it", "gi", "xi", "mu", "uri", "nt", "ci", "eni", "z", "b", "iu", "count", "I", "ai", "v", "x", "li"], "ret": ["rc", "re", "reset", "ref", "j", "def", "mt", "result", "success", "fun", "alt", "att", "back", "bf", "get", "len", "val", " RET", " Ret", "bl", "num", "RET", "r", "out", "reg", " result", "res", "obj", "t", "fin", "art", "pass", "ben", "lit", "en", "flag", "part", "_", "fab", "det", "al", "x", "match", "nt", "reply", "ft", "valid", "b", "status", "red", "rets", "Ret", "rt"], "id": ["root", "ider", "Id", "proxy", "index", "url", "uid", "sid", "kid", "name", "ident", "rid", "bid", "key", "import", "p", "mid", "api", "connection", "pid", "type", "aid", "image", "vid", "ip", "child", "ids", "ID", "entry", "address", "act", "path", "lit", "parent", "info", "ad", "code", "like", "ide", "gen", "in", "oid", "x"], "host_connected": ["host_connection", " host_updated", "hostingconnected", "host_closed", "object_connected", "hostallavailable", "hostallcalled", "hostingupdated", "hostlexcontact", "object_contact", "host_conn", " host_available", "host_available", "hostallupdated", "hostalconnect", "hostfulcontrolled", "objectlexconnected", "objectlexcontrolled", "port_selected", "hostingconnect", "port_connected", "port_connection", "host_contact", " host_called", "hostlexlinked", "host_called", "hostingselected", "hostallconn", "host_linked", "hostalselected", "host_controlled", " host_linked", "hostalconn", "host_opened", "hostlexconnected", "hostinglinked", " host_conn", "objectlexlinked", "hostfulconnected", "host_selected", "hostallconnected", "hostalcalled", "hostalllinked", "objectlexcontact", "object_linked", "hostfullinked", "port_closed", "hostalopened", "host_connect", " host_connect", "hostalconnected", "object_controlled", "host_updated", "hostallconnect", "hostfulcontact", "port_opened", "hostalavailable", "hostlexcontrolled", "hostingopened", "port_connect"], "elem_popped": ["elem_moipped", "new", "elem_cropping", "linux", "elem_Poipped", "elem_coiped", "elem_dropped", "elem_cropper", "elem_mopped", "elem_droipped", "elem_cropped", "elem_dropping", "this", "device", "elem_poipped", "elem_coipped", "elem_copped", "elem_Popped", "elem_croipped", "elem_moiped", "g", "elem_Popping", "_", "elem_Popper", "elem_popper", "elem_popping", "elem_copping", "elem_croiped", "elem_poiped", "elem_mopping", "addr", "elem_dropper"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n", "idx": 6092, "substitutes": {"id": ["root", "data", "Id", "url", "uid", "ref", "def", "sid", "kid", "ident", "bid", "pid", "type", "head", "create", "ip", "ids", "ID", "fs", "path", "start", "parent", "info", "desc", "in", "cb", "q", "oid"], "backend": ["BACKen", "Backend", "backen", "frontward", "frontender", "Backen", "udend", "BACKend", "frontends", "Backender", "uden", "BACKends", "frontend", "backends", "BACKdn", " backdn", " backen", "backdn", "udward", "udender", " backends", "frontdn", "backward", "backender", "fronten", "Backward"], "ret": ["re", "rc", "urn", "ref", "def", "eth", "result", "att", "val", "fi", "mem", "sys", "gc", "conn", "RET", "rets", "resp", "reg", "res", "fs", "tr", "sa", "reply", "gr", "rs", "Ret"], "errp": ["ersp", "errsp", "strr", "strp", "errr", "erP", "strP", "errP", " errsp", "erp", " errP", " errr", "err", "strsp"], "name": ["nam", "data", "new", "dn", "e", "d", "na", "key", "self", "none", "p", "connection", "type", "client", "n", "option", "Name", "word", "c", "m", "version", "g", "f", "path", "pass", "sn", "a", "part", "parent", "i", "named", "o", "names", "prefix", "filename", "info", "size", "code", "ame", "b", "alias", "NAME", "x", "base"], "chr": ["chesr", "anchrr", " chrc", " chrg", " chc", " chrb", "Chrn", "Chrr", "Chr", "schr", " chrr", "chsr", "clrl", "anchr", "schp", "chp", "Chrc", "chrr", "ochp", "shlr", "chelr", "cherl", "anchrc", "cllr", "shr", "anchrn", "cher", "ochc", " chp", "CHrb", "chrl", "chra", "chrg", "schra", "chlr", "CHrg", "ochra", "chrn", "shsr", "CHrc", "clsr", " chra", "ochr", "chc", "schc", "chrb", "Chrb", " chrn", "clr", "chrc", "Chrg", "CHr", "shrl"], "s": ["sq", "sb", "server", "sys", "p", "spec", "ls", "session", "S", "h", "ps", "socket", "ses", "r", "gs", "cs", "sf", "ds", "n", "l", "ops", "ss", "c", "sg", "ts", "m", "sie", "sym", "fs", "ns", "f", "sa", "ssl", "south", "sl", "o", "js", "su", "b", "es", "os", "rs", "si"]}}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n", "idx": 6098, "substitutes": {"cpu": [" CPU", "nc", "uc", "pc", "frame", "vm", "proxy", "lb", "proc", "np", "loader", "gpu", "component", "core", "android", "GPU", "gc", "clock", "flow", "pid", "conn", "auc", "processor", "roc", "config", "uci", "bench", "c", "instance", "ctx", "boot", "px", "pointer", "ctrl", "mac", "cache", "chip", "cn", "lc", "gru", "pu", "node", "cmp", "comp", "cp", "linux", "CP", "uca", "CPU", "CU"], "breakpoint": ["breakerargument", "breakingpt", "breakpt", "Breakpointer", "breakingpoint", "breakart", "breakPoint", "Breakpoint", " breakpt", "breakingart", " breakdown", "breakingdown", "breakingargument", " breakpointer", "breakerpoint", "breakingframe", " breakargument", "Breakart", "breakframe", "Breakade", "breakerdown", "breakingPoint", " breakPoint", "breakdown", "breakpointer", "breakade", "BreakPoint", "breakerframe", " breakade", "breakerPoint", "breakingpointer", " breakframe", "breakerpt", "breakingade", " breakart", "breakargument"]}}
{"project": "FFmpeg", "commit_id": "1eaff98c8320d9ba48fbaec2a558f31f4104de98", "target": 1, "func": "static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n", "idx": 6103, "substitutes": {"s": ["sq", "rss", "e", "si", "d", "submit", "sb", "comments", "p", "sync", "ks", "sports", "ls", "S", "is", "ses", "support", "cs", "sets", "gs", "service", "xs", "ds", "n", "l", "ss", "c", "sg", "ts", "services", "t", "ctx", "sym", "v", "fs", "sup", "f", "ns", "g", "sa", "a", "ssl", "settings", "se", "sl", "w", "series", "sv", "js", "b", "es", "su", "in", "single", "ins", "os", "qs", "rs", "spec"], "file_size": ["block_rate", "file_scale", "file64time", "filexcount", "file64size", "file__Size", "file_speed", "image_number", "block_size", "filextime", " file_data", "block_scale", "data_count", "file_Size", "file_count", "file_ize", "block_name", "file__size", " file_sum", "filexize", "file_time", "image_speed", "file64count", "data_size", "file__sum", " file_Size", "file_sum", "file_rate", "filexsize", "data_ize", "data_time", "image_size", "file64ize", "file_name", "file_number", "file__data", "file_data"], "pb": ["ub", "wb", "library", "pc", "lb", "gb", "lab", "vp", "db", "ab", "ppa", "loc", "queue", "pg", "sb", "bf", "pl", "hub", "tp", "typ", "mb", "p", "bm", "api", "um", "orp", "pa", "dp", "plugin", "fb", "jp", "plug", "ctx", "bc", "pm", "summary", "parser", "pd", "platform", "wp", "eb", "cv", "pkg", "dl", "fc", "verb", "PB", "lp", "bh", "uf", "lc", "bp", "rb", "xb", "b", "cb", "bs", "fp", "cp", "cpp", "bps", "prot", "ld", "rob"], "flv": ["elb", "elc", "flvs", " flV", "FLc", "llf", "flf", "flV", "elv", "wlvs", "wlc", "FLf", "flb", "llv", " flb", " flf", " flp", "llb", " flc", "elp", "wlv", "slc", "slV", "FLb", "flc", " flvs", "slvs", "llp", "elf", "FLv", "flp", "slv", "wlV"], "i": ["ui", "bi", "y", "pi", "index", "ie", "j", "di", "e", "d", "multi", "fi", "ti", "p", "yi", "slice", "mi", "phi", "qi", "ii", "hi", "u", "inner", "n", "l", "chi", "ip", "ni", "jp", "m", "ori", "ix", "oi", "f", "g", "zi", "io", "ri", "ini", "info", "o", "gi", "mu", "xi", "x", "uri", "iv", "ci", "eni", "b", "iu", "I", "ai", "v", "si", "li"], "enc": ["sci", "nc", "ext", "ou", "pc", "sec", "loc", "e", "equ", "core", "anc", "sys", "Enc", "cc", "acl", "nec", "oc", "conn", "inc", "cod", "cs", "ch", "ev", "et", "ic", "env", "c", "eng", "ctx", "dc", "bc", "ant", "ENC", "acc", "cl", "cel", "ec", "en", "oder", "cv", "ssl", "fc", "sl", "emb", "iv", "code", "ent", "lc", "ac", "vc", "con", "spec"], "sc": ["sci", "nc", "uc", "pc", "rc", "sq", "sb", "Sc", "pl", "cc", "anc", "SC", "src", "esc", "soc", "cs", "ch", "sem", "cms", "ss", "c", "ctx", "cr", "dc", "bc", "sa", "mc", "cl", "osc", "ec", "cv", "cam", "ca", "tc", "ga", "lc", "sw", "sub", "spec"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 6108, "substitutes": {"opaque": ["oacity", "obaque", "ropaques", "ropaque", "uppacity", "uppaque", "opayne", "obacity", "uppaques", "opacity", "ropayne", "oaque", "copaque", "opaques", "OPayne", "copaques", "oaques", "ropacity", "OPaque", "obaques", "copacity", "OPacity", "OPaques", "uppayne"], "fdt_orig": ["fdtt_ext", "fdtt_src", "fdt__orig", "fdt_original", "fdtn_real", "fdtm_ctr", "fdt__original", "fdt_ext", "fdt_real", "fdt_src", "fdt_slice", "fdt__ctr", "fdt_new", "fdtm_new", "fdt_ctr", "fdtt_origin", "fdtm_orig", "fdtn_orig", "fdt__new", "fdtn_slice", "fdt_origin", "fdtt_orig", "fdtm_original"], "match_data": ["match1def", "match_buffer", "match1buffer", "test_buffer", "match1data", "match_def", "test_data", "test_def"], "load_addr": ["loader_data", "loaduregrad", "load_order", "load67addr", "load67grad", "load_grad", "load67order", "load67address", "loader_coord", "loader_addr", "load_address", "loader_address", "loadureaddr", "loader_grad", "load_coord", "loadureaddress", "load_data", "loadureorder", "loader_order"], "s": ["storage", "second", "sea", "sq", "e", "d", "sb", "server", "self", "sys", "p", "sync", "spec", "session", "S", "is", "sc", "ps", "sch", "ses", "cs", "gs", "r", "service", "u", "n", "ops", "sie", "c", "m", "sh", "services", "ss", "sg", "rs", "g", "f", "ns", "space", "source", "sa", "ssl", "se", "o", "sl", "secondary", "sis", "state", "su", "b", "os", "south", "si"], "machine": ["note", "vm", "object", "storage", "di", "loader", "element", "slave", "message", "component", "interface", "mini", "core", "controller", "mage", "game", "command", "p", "template", "self", "bm", "connection", "server", "session", "sm", "player", "Machine", "image", "module", "bug", "jam", "service", "kernel", "hard", "config", "volume", "man", "m", "mode", "instance", "engine", "home", "ram", "shell", "source", "mc", "model", "mac", "part", "ma", "info", "manager", "mom", "project", "M", "memory", "database", "state", "node", "b", "computer", "office", "private", "base"], "cmdline": ["mdstring", " cmdl", "msgl", "commandline", "cmdl", "mdline", "commandLINE", "commandl", " cmdstring", "msgLINE", " cmdLine", "mdLine", "hostline", " cmdlines", "hoststring", "Cmdlines", "msgLine", "CmdLine", "cmdLINE", "commandlines", "hostLine", "cmdstring", "Cmdline", "hostLINE", "mdLINE", "Cmdl", "cmdlines", "cmdLine", " cmdLINE", "msgline", "commandLine"], "err": ["br", "result", "er", "str", "ler", "arm", "rh", "order", "ace", "pr", "cor", "die", "inner", "runner", "ctr", "sr", "mr", "init", "cr", " Err", "f", "nor", "Error", "der", "ar", "ver", "aster", "count", "raise", "ner", "call", "orig", "test", "bug", "r", "ind", "magic", "eor", "ah", "wr", "nr", "ise", "rar", "fr", "me", "iter", "orr", "cb", "rag", "len", "self", "arr", "aer", "ry", "acer", "n", "var", "lr", "Er", "req", "proc", "error", "loc", "resp", "rr", "cry", "dy", "fer", "act", "rage", "ir", "cache", "yr", "kr", "dr", "attr"], "fdt": ["dld", "FDT", "fedt", "fcwt", "dt", "dltr", "dlta", "fcdt", "fdwt", "sdt", "dbc", "wdt", "dftm", "fftt", "dfwt", "sdtf", "vdnt", "ffte", "fedtm", "dbts", "dlout", "dfta", "dltt", "fdT", "ldc", "ldtf", "FDnt", "dfe", "vddt", "fde", "fdta", "dlt", "vdtt", "cftt", "debdt", "dle", "dayt", "fct", "dbtf", "dtt", "cft", "FDtt", "wdtt", "dlT", "dfT", "fxt", "fdte", "ldts", "fdts", "ldt", "fdout", "fddt", "fdg", "daydt", "cftm", "vdt", "fdc", "dltf", "fdtt", "ffta", "wdtr", "dldt", "dtm", "dlnt", "fdnt", "fdtm", "debt", "fedtt", "sdnt", "dfout", "wdta", "sde", "fedte", "fxtt", "fcd", "dfte", "dftf", "dbt", "dltm", "fxte", "dayd", "dg", "fcout", "dft", "fdd", "cfg", "fctm", "FDtm", "fdtr", "dlwt", "dftt", "fctf", "debnt", "dfg", "FDte", "daytm", "dftr", "dfc", "dfts", "fdtf", "dfnt", "fft", "fxta", "dlte", "debtt", "FDt"], "fdt_sz": ["fdt_nosgd", "fdt_wsiz", "fdt_drc", "fdt_src", "fdt_dce", "fdt__sze", "fdt_timescz", "fdt_isci", "fdt_bz", "fdt__scz", "fdt_wsz", "fdt_wiz", "fdt_dgd", "fdt_sze", "fdt_dzip", "fdt__dze", "fdt_wzi", "fdt_szen", "fdt_sgd", "fdt_diz", "fdt_wce", "fdt_dzi", "fdt_szi", "fdt__sci", "fdt_dszn", "fdt_dzen", "fdt_dsz", "fdt_sinci", "fdt_lszen", "fdt_isz", "fdt_sinze", "fdt__sgd", "fdt_scz", "fdt__dzen", "fdt_iszn", "fdt_sst", "fdt_lsgd", "fdt__szen", "fdt_wszi", "fdt_bci", "fdt_dz", "fdt_timesze", "fdt_bzn", "fdt_dsci", "fdt__dgd", "fdt_wzip", "fdt_sincz", "fdt_bst", "fdt_nosz", "fdt_nosze", "fdt_wsrc", "fdt_noszen", "fdt_isst", "fdt_wrc", "fdt_timesci", "fdt_szip", "fdt_lsze", "fdt_lsz", "fdt_dsst", "fdt_sci", "fdt__dz", "fdt_siz", "fdt__sz", "fdt_dze", "fdt_sce", "fdt_sinz", "fdt_wz", "fdt_szn", "fdt_timesz"], "ram_low_sz": ["ram_low_timeszi", "ram_low_psiz", "ram_low_psze", "ram_low_sx", "ram_low_asx", "ram_low_dz", "ram_low_fz", "ram_low_psz", "ram_low_fiz", "ram_low_dzi", "ram_low_aszek", "ram_low_asze", "ram_low_sfl", "ram_low_timesz", "ram_low_aszi", "ram_low_diz", "ram_low_dfl", "ram_low_szo", "ram_low_pszo", "ram_low_timesze", "ram_low_timesfl", "ram_low_timeszek", "ram_low_Sx", "ram_low_sze", "ram_low_Szo", "ram_low_szi", "ram_low_timesiz", "ram_low_asfl", "ram_low_fx", "ram_low_Sz", "ram_low_aszo", "ram_low_siz", "ram_low_asz", "ram_low_fze", "ram_low_asiz", "ram_low_Siz", "ram_low_Sze", "ram_low_szek"], "ram_high_sz": ["ram_high_asz", "ram_high_ssiz", "ram_high_aszen", "ram_high_fzip", "ram_high_fz", "ram_high_sidz", "ram_high_asze", "ram_high_siz", "ram_high_sszi", "ram_high_sidzen", "ram_high_szen", "ram_high_aszi", "ram_high_Szip", "ram_high_Szo", "ram_high_sidiz", "ram_high_fiz", "ram_high_szi", "ram_high_Sze", "ram_high_ssz", "ram_high_aszo", "ram_high_szo", "ram_high_Siz", "ram_high_fzi", "ram_high_ssze", "ram_high_sszo", "ram_high_Szi", "ram_high_asiz", "ram_high_sidzi", "ram_high_sszip", "ram_high_Sz", "ram_high_szip", "ram_high_sze"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n#if CONFIG_ZLIB\n\n    AVIOContext ctx;\n\n    uint8_t *cmov_data;\n\n    uint8_t *moov_data; /* uncompressed data */\n\n    long cmov_len, moov_len;\n\n    int ret = -1;\n\n\n\n    avio_rb32(pb); /* dcom atom */\n\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n\n        return AVERROR_INVALIDDATA;\n\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_rb32(pb); /* cmvd atom */\n\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n\n        return AVERROR_INVALIDDATA;\n\n    moov_len = avio_rb32(pb); /* uncompressed size */\n\n    cmov_len = atom.size - 6 * 4;\n\n\n\n    cmov_data = av_malloc(cmov_len);\n\n    if (!cmov_data)\n\n        return AVERROR(ENOMEM);\n\n    moov_data = av_malloc(moov_len);\n\n    if (!moov_data) {\n\n        av_free(cmov_data);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    avio_read(pb, cmov_data, cmov_len);\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n\n        goto free_and_return;\n\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n\n        goto free_and_return;\n\n    atom.type = MKTAG('m','o','o','v');\n\n    atom.size = moov_len;\n\n    ret = mov_read_default(c, &ctx, atom);\n\nfree_and_return:\n\n    av_free(moov_data);\n\n    av_free(cmov_data);\n\n    return ret;\n\n#else\n\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n\n    return AVERROR(ENOSYS);\n\n#endif\n\n}\n", "idx": 6112, "substitutes": {"c": ["context", "uc", "pc", "k", "e", "cc", "p", "client", "h", "xc", "ct", "cm", "cs", "ch", "config", "cit", "l", "cy", "m", "dc", "cr", "bc", "g", "f", "ctrl", "mc", "cv", "ec", "fc", "cf", "ca", "C", "tc", "cn", "ci", "lc", "cd", "icc", "ac", "b", "vc", "con", "cp", "cmp"], "pb": ["wb", "pc", "lb", "np", "gb", "proc", "lab", "db", "ab", "ppa", "bf", "pg", "sb", "pl", "hub", "typ", "tp", "p", "bm", "api", "mp", "cm", "bb", "pa", "dp", "plugin", "fb", "jp", "bc", "tmp", "pd", "apy", "kb", "platform", "pkg", "eb", "wp", "fc", "PB", "lp", "tc", "bh", "lc", "bp", "rb", "xb", "b", "cb", "http", "fp", "cp", "cpp", "bps", "prot", "rob"], "atom": ["tag", "data", "object", "bn", "xml", "material", "asm", "element", "att", "sb", "document", "tom", "op", "container", "p", "spec", "acl", "type", "app", "ann", "num", "module", "cm", "orbit", "bb", "config", "kernel", "at", "orb", "external", "mol", "obj", "class", "temp", "m", "instance", "chem", "t", "article", "tmp", "sym", "bc", "acc", "ctrl", "prop", "tm", "mag", "om", "cat", "cache", " Atom", "fab", "mom", "tc", "atomic", "ac", "node", "b", "com", "attr", "term", "cell", "unit", "x", "base"], "ctx": ["context", "sci", "nc", "pc", "rc", "conv", " cx", "wcs", "loc", "exec", "cc", "acl", " rc", "gc", " context", "sc", "xc", "conn", "ct", "cm", "acs", "config", "cca", "tx", "aux", "bc", "dc", "kb", "ctrl", "mc", "cv", "qa", "pkg", "cam", "cu", "cf", "ca", "tc", "cn", "ci", "lc", "cas", "cb", "cmp", "fp", "cp", "utils"], "cmov_data": ["cmov__len", "cmov_ad", "cmood_dat", "cmav_data", "cmove_la", "cmav_style", "cmovsdat", "cmovo_dat", "cmove_len", "cmovo_Data", "cmove_style", "cmoodsempty", "cmood_empty", "cmovo_ad", "cmovo_len", "cmov_dat", "cmav_len", "cmovtdata", "cmovtempty", "cmov_style", "cmovtdat", "cmovacdata", "cmov_Data", "cmoodslen", "cmovo_data", "cmovspos", "cmoodsdata", "cmov__pos", "cmovslen", "cmov__data", "cmov_pos", "cmovaclen", "cmav_size", "cmovsad", "cmovtlen", "cmov_empty", "cmovo_pos", "cmove_data", "cmood_len", "cmov_la", "cmovsdata", "cmovsData", "cmoodsdat", "cmovacsize", "cmove_pos", "cmovsempty", "cmov_size", "cmovacstyle", "cmood_data"], "moov_data": ["moantklen", "moov__length", "moovsdat", "moova__data", "moovospos", "moova__size", "moov__size", "moove_data", "moov_dat", "moov_last", "moov_slice", "moova_data", "moovend", "loovend", "moov__data", "moovo_dat", "moovacdata", "moovsdata", "mooveend", "moov_length", "moovosdata", "moov_pos", "moovoend", "moantklast", "moov_body", "moovacsize", "moovksize", "moove\n", "moova_size", "moovo_pos", "moovaend", "moovo_data", "moovo_slice", "moovkdata", "moova__body", "moov_break", "moovaclength", "moant_len", "moov__body", "loovoend", "moove_la", "moova_length", "moovklast", "moovssize", "moovacbody", "loovo\n", "moovo_size", "moant_last", "moov\n", "moantksize", "moova__length", "moove_bin", "moove_len", "moovo_break", "moov_size", "moovspos", "moantkdata", "moovossize", "moovo_len", "moant_data", "moov_la", "moovklen", "moov_bin", "moova\n", "moovo\n", "moovosdat", "moova_body", "loov\n", "moant_size"], "cmov_len": ["cmosh_lon", "cmov11len", "cmov__len", "cmovddata", "cmov_length", "cmovaslen", "cmov0pos", "cmov64lon", "cmosh64length", "cmove_len", "cmovdlim", "cmov64length", "cmovo_len", "cmove_depth", "cmov__lon", "cmosh64lon", "cmov0lim", "cmov0size", "cmov_lan", "cmov_lon", "cmosh_length", "cmov11Len", "cmova_len", "cmov_depth", "cmov__lan", "cmood_pos", "cmov__length", "cmovassize", "cmove_Len", "cmovo_data", "cmovdsize", "cmovssize", "cmov64len", "cmov0len", "cmova_length", "cmovslen", "cmosh64lan", "cmood_size", "cmov_pos", "cmosh_lan", "cmovdlen", "cmovasdata", "cmovslength", "cmova_size", "cmov64lan", "cmovdpos", "cmovo_pos", "cmove_data", "cmood_len", "cmosh_len", "cmosh64len", "cmovsdata", "cmov11depth", "cmov_lim", "cmovaslength", "cmova_data", "cmov_Len", "cmov_size", "cmood_lim", "cmov11data", "cmovdlength"], "moov_len": ["moov_l", "moov_fin", "moovnfin", "moovnlen", "mooy1size", "moov__val", "moov0len", "moov1size", "moovtlen", "moova_len", "moov__size", "moove_data", "moovatpos", "moom_en", "moom_lim", "moov_lon", "mooy_len", "moom0lim", "moov1lon", "moovParval", "moov_length", "moova_id", "moov_pos", "moom_size", "moov64val", "moovnlim", "moova_fin", "mooy_l", "moove_limit", "mooy1l", "moovksize", "moove_val", "moov0size", "moov64size", "mooy1lon", "moovtid", "moovnbin", "moova_pos", "moovtlength", "moovParlen", "moom0size", "moovtpos", "moovPardata", "moom0len", "moov_den", "moovatlen", "moov_val", "moov1l", "moov0lim", "mooy_size", "moom_len", "moova_length", "mooy_den", "moov_limit", "moovatid", "moovParlimit", "moov64len", "moom0en", "moove_len", "moov_size", "moov1len", "moov64den", "mooy1len", "moovatlength", "moov__den", "moov__len", "moov_lim", "moov0en", "moovklen", "moov_bin", "moov_id", "moovken", "mooy_lon", "mooy_val", "moovklim", "moov_en", "moova_bin", "moova_lim"]}}
{"project": "FFmpeg", "commit_id": "170870b77c8c71304f9eae946d49aa5e30a464bc", "target": 1, "func": "static int sdp_parse_rtpmap(AVFormatContext *s,\n\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n\n                            int payload_type, const char *p)\n\n{\n\n    char buf[256];\n\n    int i;\n\n    AVCodec *c;\n\n    const char *c_name;\n\n\n\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n\n     * see if we can handle this kind of payload.\n\n     * The space should normally not be there but some Real streams or\n\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n\n     * have a trailing space. */\n\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n\n    if (payload_type >= RTP_PT_PRIVATE) {\n\n        RTPDynamicProtocolHandler *handler;\n\n        for (handler = RTPFirstDynamicPayloadHandler;\n\n             handler; handler = handler->next) {\n\n            if (!strcasecmp(buf, handler->enc_name) &&\n\n                codec->codec_type == handler->codec_type) {\n\n                codec->codec_id          = handler->codec_id;\n\n                rtsp_st->dynamic_handler = handler;\n\n                if (handler->open)\n\n                    rtsp_st->dynamic_protocol_context = handler->open();\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* We are in a standard case\n\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n\n        /* search into AVRtpPayloadTypes[] */\n\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n\n    }\n\n\n\n    c = avcodec_find_decoder(codec->codec_id);\n\n    if (c && c->name)\n\n        c_name = c->name;\n\n    else\n\n        c_name = (char *) NULL;\n\n\n\n    if (c_name) {\n\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n        i = atoi(buf);\n\n        switch (codec->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n\n            if (i > 0) {\n\n                codec->sample_rate = i;\n\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n                i = atoi(buf);\n\n                if (i > 0)\n\n                    codec->channels = i;\n\n                // TODO: there is a bug here; if it is a mono stream, and\n\n                // less than 22000Hz, faad upconverts to stereo and twice\n\n                // the frequency.  No problem, but the sample rate is being\n\n                // set here by the sdp line. Patch on its way. (rdm)\n\n            }\n\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n\n                   codec->sample_rate);\n\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n\n                   codec->channels);\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 6125, "substitutes": {"s": ["sq", "aws", "e", "sb", "cli", "sys", "server", "sports", "session", "client", "ps", "sc", "tools", "ses", "gs", "sets", "r", "cs", "service", "ds", "stats", "m", "lex", "t", "services", "fs", "g", "ns", "f", "bis", "us", "ssl", "js", "b", "setup", "http", "os", "conf", "parser", "rs", "spec"], "codec": ["codeef", "codeenc", "defec", "codeus", " codef", "Codect", "codenc", "libec", "CodEC", "codeex", "validentity", "taxesc", "codeEC", "Codex", " codocol", "coduc", "codac", "copesc", "codect", "metesc", " codect", " codeco", "codeuc", "codeeca", " codentity", "odroc", "odrec", "codeca", "genec", "modec", "codeac", " coderc", "Codesc", "codEC", "predef", "equex", "oduc", "odEC", "preduc", "copec", "odocol", " codeca", "odec", "validec", "predec", " codrec", "codocol", "codeco", "codfc", "coddec", "Codef", "copac", "libef", "taxentity", "codrec", "metex", " codfc", " codEC", "predEC", "libesc", "metdec", "oddec", "odex", "equuc", "codefc", "codeect", "Coderc", "defac", "codedec", "defesc", "valideco", "codesc", "genesc", " codesc", "codef", "codex", "codeec", "taxeco", "coderc", "predrec", "copef", "codeeus", "odeca", "Codec", "odesc", "defef", " codroc", "odef", "equec", "codroc", "odenc", " codeus", "codeesc", " coduc", "moduc", "codeerc", "genroc", "equeca", "predeca", "metenc", "codentity", "taxec", "codeocol", "modfc", "metec", "libEC", "Coduc", "modeus", "validesc", "metuc"], "rtsp_st": ["rtsv_sth", "rtsp1stream", "rtsp1ST", "rtspfst", "rtsp_stream", "rtsp1st", "rtsv_stream", "rtsp_sts", "rtsfp_sth", "rtsfp_stream", "rtsp2stream", "rtspJst", "rtsv_st", "rtspfsth", "rtsp_sta", "rtsv_sts", "rtsp_ST", "rtsfp_ST", "rtspJsth", "rtspfinst", "rtsp_sth", "rtsp2st", "rtspfstream", "rtsp_inst", "rtsp2sta", "rtspJinst", "rtsfp_st", "rtsp2sts", "rtsv_inst", "rtsv_sta", "rtspJstream", "rtsp1sth"], "payload_type": ["payec_types", "payload_id", "payload_types", "payec_name", "payloadaltype", "payload_number", "payec_type", "payloadalnumber", "payec_number", "payloadalid", "payload_name", "payec_id"], "p": ["pc", "pi", "np", "j", "vp", "param", "e", "d", "tp", "op", "api", "params", "type", "h", "ps", "r", "pa", "sp", "at", "P", "n", "ap", "ip", "l", "m", "t", "ctx", "g", "f", "point", "padding", "wp", "o", "lp", "pe", "bp", "b", "q", "fp", "v", "format", "port"], "buf": ["bi", "msg", "br", "ru", "conv", "result", "text", "bf", "Buffer", " b", "que", "img", "cmd", "buff", "grab", "bc", "f", "Buff", "pkg", "cap", "bd", "b", "binary", " buffer", "batch", "data", "pb", "bus", "ab", "db", "input", "map", "orig", "box", "config", "fam", "txt", "cv", "uf", "bags", "rb", "cb", "addr", "font", "pool", "uc", "rc", "bag", "received", "vec", "block", "fd", "prop", "feat", "bh", "bed", "feed", "func", "wb", "wav", "lb", "proc", "queue", "exc", "src", "seq", "auc", "fb", "ctx", "cur", "buffer", "cache", "filename", "la", "ff", "desc", "brace"], "i": ["ui", "bi", "y", "pi", "index", "ie", "area", "j", "di", "diff", "e", "d", "mini", "multi", "cli", "ti", "api", "slice", "type", "is", "mi", "phi", "qi", "ii", "ki", "anti", "hi", "u", "adi", "ji", "n", "ni", "l", "ip", "ami", "abi", "m", "init", "t", "ori", "alpha", "f", "zi", "io", "wei", "ri", "ini", "info", "gi", "mu", "xi", "uri", "x", "it", "ci", "eni", "b", "esi", "iu", "length", "count", "I", "ai", "v", "si", "li"], "c": ["nc", "uc", "pc", "rc", "k", "e", "d", "enc", "coll", "co", "cc", "anc", "ce", "h", "client", "xc", "ct", "oc", "cm", "r", "ch", "cs", "u", "n", "l", "cy", "m", "t", "ctx", "dc", "bc", "arc", "g", "f", "rec", "ctrl", "mc", "cl", "ec", "cache", "fc", "cu", "o", "cf", "ca", "C", "tc", "code", "cn", "ci", "lc", "cd", "ac", "b", "in", "col", "cmp", "con", "chain", "v"], "c_name": ["c_id", "enc_name", "c_num", "c2name", " c_size", "c_data", " c_prefix", "c_no", "c2key", "cJprefix", "cJno", "c___key", "enc_num", "c_la", "c_block", "p_la", "c__data", " c_data", " c_NAME", "cJname", "C_key", "c_type", "c_size", " c_no", "cJsize", "c2type", "cJNAME", "C_block", "c_key", "cJdata", "c___block", "c_value", "C_id", "enc_type", "enc_key", "c_NAME", "c2num", "cJvalue", "p_name", "C_name", "c_prefix", " c_value", "c___name", "c___id", "p_id", "c__name", "c__size", "c__prefix"], "handler": ["callback", "folder", "area", "result", "name", "er", "api", "slice", "type", "later", "inner", "runner", "file", "f", "definition", "object", "reader", "package", "loader", "message", "key", "widget", "hand", "player", "h", "filter", "channel", "config", "handled", "magic", "layer", "address", "path", "page", "Handler", "guard", "or", "loop", "code", "job", "handle", "driver", "worker", "controller", "connection", "cher", "lib", "plugin", "application", "cookie", "child", "fd", "lr", "entry", "holder", "model", "manager", "wrapper", "item", "route", "feed", "end", "field", "error", "core", "server", "command", "event", "function", "client", "service", "response", "man", "ctx", "pointer", "phase", "writer", "band", "parser"]}}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n", "idx": 6140, "substitutes": {"s": ["storage", "sq", "e", "sb", "sys", "self", "p", "sync", "src", "ls", "session", "S", "client", "is", "ps", "ses", "support", "cs", "sets", "gs", "service", "u", "ds", "sf", "n", "l", "ops", "ss", "c", "sg", "m", "services", "t", "ts", "sym", "ctx", "fs", "g", "f", "ns", "bis", "a", "ssl", "i", "sl", "o", "its", "js", "b", "es", "su", "in", "os", "qs", "rs", "si"], "xvmc_acceleration": ["xvmc_acceling", "xvmc_accelation", "xvmc_enccelerations", "xvmc_acllation", "xvmc_aclling", "xvmc_acllations", "xvmc_enccelermentation", "xvmc_accentations", "xvmc_accelmentation", "xvmc_accentmentation", "xvmc_acllmentation", "xvmc_accelering", "xvmc_accelerations", "xvmc_encceling", "xvmc_accelermentation", "xvmc_enccelering", "xvmc_accentation", "xvmc_encceleration", "xvmc_accenting", "xvmc_enccelations", "xvmc_enccelation", "xvmc_enccelmentation", "xvmc_accelations"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARNINGDS", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_WARDS", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_warningS", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_warnings", "FF_ENABLE_DEPRECATION_warningDS"]}}
{"project": "FFmpeg", "commit_id": "b67f3d65757e9b08a797f584ee818ad7cfe7b303", "target": 1, "func": "static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n\n{\n\n    int i, err;\n\n    AVFormatContext *ic;\n\n    int nopts = 0;\n\n\n\n    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);\n\n    if (err < 0)\n\n        return err;\n\n    /* copy stream format */\n\n    s->nb_streams = ic->nb_streams;\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st;\n\n        AVCodec *codec;\n\n\n\n        // FIXME: a more elegant solution is needed\n\n        st = av_mallocz(sizeof(AVStream));\n\n        memcpy(st, ic->streams[i], sizeof(AVStream));\n\n        st->codec = avcodec_alloc_context();\n\n        if (!st->codec) {\n\n            print_error(filename, AVERROR(ENOMEM));\n\n            ffmpeg_exit(1);\n\n        }\n\n        avcodec_copy_context(st->codec, ic->streams[i]->codec);\n\n        s->streams[i] = st;\n\n\n\n        codec = avcodec_find_encoder(st->codec->codec_id);\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_sample_fmt(st, codec);\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (video_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_pixel_fmt(st, codec);\n\n        }\n\n\n\n        if(!st->codec->thread_count)\n\n            st->codec->thread_count = 1;\n\n        if(st->codec->thread_count>1)\n\n            avcodec_thread_init(st->codec, st->codec->thread_count);\n\n\n\n        if(st->codec->flags & CODEC_FLAG_BITEXACT)\n\n            nopts = 1;\n\n    }\n\n\n\n    if (!nopts)\n\n        s->timestamp = av_gettime();\n\n\n\n    av_close_input_file(ic);\n\n    return 0;\n\n}\n", "idx": 6160, "substitutes": {"s": ["ex", "sq", "aws", "si", "icing", "plugins", "sys", "p", "spec", "ks", "ls", "cus", "S", "session", "is", "ps", "ses", "cs", "gs", "acs", "sets", "service", "xs", "ds", "l", "ops", "ss", "c", "sg", "ts", "services", "ix", "fs", "g", "ns", "sac", "f", "ms", "sa", "sn", "us", "ssl", "se", "its", "sl", "ess", "ac", "es", "ics", "ins", "bs", "os", "qs", "rs", "x"], "filename": ["msg", "ename", "wb", "fn", "phrase", "url", "Filename", "SourceFile", "name", "message", "document", "nil", "username", "sf", "File", "password", "file", "wl", "l", "files", "txt", "fd", "word", "fil", "kl", "il", "buffer", "f", "nl", "path", "location", "prefix", "utf", "uri", "rl", "dll", "fp", "IL", "title", "binary", "directory"], "i": ["bi", "ui", "y", "pi", "index", "ie", "j", "ih", "di", "e", "ik", "multi", "fi", "ti", "p", "yi", "h", "mi", "ace", "qi", "ii", "u", "ind", "id", "ni", "l", "ip", "c", "m", "ix", "oi", "f", "g", "zi", "io", "start", "ri", "a", "ini", "info", "o", "it", "gi", "xi", "x", "mu", "uri", "eni", "ci", "z", "b", "iu", "I", "ai", "v", "si", "li"], "err": ["ie", "ner", "error", "e", "er", "str", "core", "fi", "call", "ler", "arr", "fe", "arm", "ry", "rh", "orig", "h", "order", "phi", "ace", "pr", "bug", "r", "test", "out", "cor", "ind", "rr", "rn", "lr", "sr", "mr", "init", "c", "dy", "cr", " Err", "Er", "min", "ir", "nr", "req", "ini", "nor", "Error", "der", "ar", "yr", "rar", "ver", "dev", "code", "dr", "size", "ise", "it", "gr", "in", "iter", "aster", "cb", "ee"], "ic": ["sci", "ex", "pc", "ici", "wic", "aci", "icing", "enc", "ik", "exc", "exec", "isc", "iac", "ican", "anc", "cc", "xt", "fi", "sys", "p", "acl", "gc", "cli", "oc", "lic", "ct", "ace", "xc", "inc", "acs", "nic", "u", "cit", "ip", "ck", "c", "ctx", "cci", "aic", "ix", "rec", "pic", "bc", "IC", "dc", "icer", "ig", "mc", "cl", "ec", "cu", "fc", "ico", "tc", "mic", "ci", "lc", "icc", "ac", "ia", "ics", "vc", "ai", "irc", "x"], "st": ["ste", "stack", "set", "mt", "back", "str", "std", "bl", "ost", " est", "sr", "rd", "cr", "f", "art", "nd", "sty", "ft", "stall", "stream", "ast", "sb", "test", "lt", "tt", "sp", "stage", "ss", "rest", "ts", "t", "kt", "sa", "put", "inst", "cl", "start", "fr", "lc", "sw", "ess", "de", "p", "style", "et", "St", "c", "pt", "us", "sl", "ad", "nt", "post", "ist", "public", "sth", "end", "th", "ust", "play", "fe", "stem", "src", "stop", "sc", "ct", "est", "sts", "ut", "sh", "sn", "be", "se", "sta", "dr", "sd", "td", "ld", "ST", "first"], "codec": [" codcode", "pedesc", "conteus", "codeenc", "codeaque", "codeerer", "coderer", "codeus", "logeco", "Codoc", "Codect", "codenc", "odect", " codaque", "CodEC", "logaque", "dependac", "codeEC", "coduc", "codeeco", "casteus", "coder", "logeus", "codac", "codect", "castoc", " codect", " codeco", "odac", "codeuc", "codeeca", "dependeus", "pedeco", "contcode", "codeca", "codcode", "layoc", "consterer", "Codenc", "modec", "codeac", " coderc", "Codesc", "constec", "codEC", "congac", "celec", "codic", "dependec", "oduc", "odEC", "coderec", "codeic", "contec", "oxyeco", "celEC", "cheEC", "castec", " codeca", "layuc", "odec", "cheec", "odoc", "Coddec", "predeus", "constesc", " codac", "codoc", "Codeus", "layeus", "predec", " codrec", "codeco", "coddec", "legoc", "codrec", " codEC", "codeoc", " codenc", "modac", "Codac", "projectect", "layec", "cheuc", "legec", "oddec", "odeus", "codeect", "codedec", "codesc", "celic", " codesc", "Codeca", "predenc", "codeec", " coder", "coderc", "legerc", "contac", "congenc", "predect", " codic", "codeeus", "odeca", "Codec", "legrec", "odesc", "oxyesc", "congeus", "dependenc", "odenc", "pedec", "logec", "celeco", " codoc", "casteco", "logoc", " codeus", "codeesc", " coderer", "oxyec", "codaque", "cheect", " coduc", "codeerc", "logect", " coddec", "oder", "codeer", "oxyEC", "projectac", "Coduc", "congec", "modeus", "projectec", "modcode", "odeco", "pedEC"]}}
{"project": "FFmpeg", "commit_id": "ff763351e74550df3b9a0465634d1ec48b15b043", "target": 1, "func": "static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}", "idx": 6165, "substitutes": {"ctx": ["context", "scope", "pc", "rc", "np", "sq", "cc", "anc", "src", "sc", "conn", "ct", "xc", "cm", "cs", "cca", "tx", "Context", "cms", "c", "init", "bc", "pkg", "cv", "cam", "cf", "ca", "tc", "ci", "lc", "cas", "cmp", "fp", "cp", "cpp"], "s": ["context", "scope", "sq", "ans", "e", "sb", "sys", "self", "p", "sync", "spec", "src", "ks", "ls", "S", "ps", "sc", "is", "ses", "cs", "gs", "this", "sets", "ds", "xs", "n", "ops", "sym", "c", "sg", "ss", "services", "ts", "sr", "fs", "g", "ns", "f", "sa", "ssl", "se", "i", "sl", "o", "sv", "js", "os", "qs", "rs", "si"]}}
{"project": "qemu", "commit_id": "47e04430ed3e6ab835f023a5c84381ca2ce9f4d8", "target": 0, "func": "static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,\n\n                                             DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t off10;\n\n    int32_t r1, r2;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_BO_S1D(ctx->opcode);\n\n    r2  = MASK_OP_BO_S2(ctx->opcode);\n\n    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);\n\n    op2 = MASK_OP_BO_OP2(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_BO_CACHEA_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_W_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_I_SHORTOFF:\n\n        /* instruction to access the cache */\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_POSTINC:\n\n    case OPC2_32_BO_CACHEA_W_POSTINC:\n\n    case OPC2_32_BO_CACHEA_I_POSTINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_PREINC:\n\n    case OPC2_32_BO_CACHEA_W_PREINC:\n\n    case OPC2_32_BO_CACHEA_I_PREINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEI_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEI_W_SHORTOFF:\n\n        /* TODO: Raise illegal opcode trap,\n\n                 if tricore_feature(TRICORE_FEATURE_13) */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_POSTINC:\n\n    case OPC2_32_BO_CACHEI_WI_POSTINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_PREINC:\n\n    case OPC2_32_BO_CACHEI_WI_PREINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_ST_A_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_A_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LESL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_A_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_B_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_B_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_UB);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_B_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_D_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_D_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_D_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_H_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_H_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_H_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_SHORTOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_POSTINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_W_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    case OPC2_32_BO_ST_W_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_W_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    }\n\n}\n", "idx": 6186, "substitutes": {"env": ["context", "iss", "cfg", "vm", "eu", "np", "stack", "db", "queue", "loader", "e", "enc", "exc", "ea", "cli", "que", "dep", "style", "buf", "conn", "config", "ev", "viron", "tx", "impl", "eng", "engine", "prov", "chal", "console", "inst", "en", "ec", "req", "iv", "dev", "erv", "priv", "cb", "enh", "environment"], "ctx": ["context", "sci", "scope", "func", "nc", "rc", "conv", "sq", "wcs", "loc", "exc", "exec", "anc", "cc", "cli", "sync", "wx", "std", "src", "kw", "sc", "conn", "cs", "this", "config", "cmd", "cca", "Context", "tx", "obj", "ck", "c", "kb", "ctrl", "cv", "cam", "pkg", "qa", "mac", "hw", "cu", "kn", "cf", "ca", "cn", "ci", "lc", "cas", "sk", "cb", "cmp", "vc", "conf", "utils"], "op2": ["oper0", "oper1", "op0", "op1", "OP2", " op3", "OP1", "OP32", "oper2", "OP20", "option2", "hop2", "hop1", "oper10", "op32", " op10", "option02", "OP3", " op32", "op20", "oper32", "op10", "option3", "op02", "hop3", "option10", "hop0", "OP0", "oper3", " op02", " op20", "op3", "oper20", "oper02"], "off10": ["down110", "OFF110", "ext090", "off090", "OFF30", " off15", "off20", "out40", "out50", "down30", "out30", "down40", " off110", "off50", "ext10", "off40", " off20", "OFF15", " off30", "down20", "off110", " off40", "off30", "OFF40", "down50", "out10", "off15", "OFF090", "down10", "OFF20", "ext30", "down15", "OFF10", " off50", " off090"], "r1": ["p1", "R11", "p8", "R2", "r3", "p2", " r11", "p11", "r8", "R3", "r11", "p3", "R8", " r3", " r8", "R1"], "r2": ["err2", "vrTwo", "rc62", " r62", "p1", "Rtwo", "rc5", " r0", "rcall", "hrall", "p02", "rTwo", "r0", "hr2", "dr02", "l62", "R02", "rc0", "hr62", "R62", " rTwo", " r5", "R2", "r5", "hrtwo", "R0", "vr1", "r3", "p2", "rtwo", " r02", " rtwo", "vr2", "dr2", "err62", "R3", "drtwo", "p3", "rctwo", "r62", "R5", "RTwo", "dr1", "rc1", "rall", "vr5", "rc2", "r02", "l5", " r3", "l2", "l1", "errall", "R1", "errtwo"], "temp": ["data", "cfg", "gb", "tk", " tmp", "gc", "buf", " gp", "out", "Temp", " buffer", " ret", "var", " generator", "tmp", "buffer", " vec", "vt", " v", "w", "gi", "null", "vc", "v", "vv", "output", " output"]}}
{"project": "qemu", "commit_id": "bee62662a312b99b4418b558a99b3963a4cbff07", "target": 0, "func": "static int kvm_mips_get_fpu_registers(CPUState *cs)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int err, ret = 0;\n\n    unsigned int i;\n\n\n\n    /* Only get FPU state if we're emulating a CPU with an FPU */\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        /* FPU Control Registers */\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,\n\n                                    &env->active_fpu.fcr0);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_IR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        }\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,\n\n                                    &env->active_fpu.fcr31);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_CSR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        } else {\n\n            restore_fp_status(env);\n\n        }\n\n\n\n        /* Floating point registers */\n\n        for (i = 0; i < 32; ++i) {\n\n            if (env->CP0_Status & (1 << CP0St_FR)) {\n\n                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),\n\n                                              &env->active_fpu.fpr[i].d);\n\n            } else {\n\n                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),\n\n                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);\n\n            }\n\n            if (err < 0) {\n\n                DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", __func__, i, err);\n\n                ret = err;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 6189, "substitutes": {"cs": ["ys", "CS", "nc", "pc", "rc", "ras", "wcs", "core", "cc", "sys", "cons", "sync", "ks", "ls", "cus", "sc", "conn", "ace", "vs", "acs", "gs", "ds", "cms", "rs", "c", "css", "ctx", "cells", "ix", "fs", "ns", "ms", "ec", "cache", "cer", "cf", "code", "cn", "ci", "lc", "js", "sk", "cas", "cks", "cb", "ced", "vc", "bs", "cp", "qs", "cing", "spec", "ces"], "cpu": ["cfg", "vm", "pc", "np", "proc", "gpu", "component", "core", "fi", "cli", "sys", "conn", "cm", "processor", "config", "uci", "bench", "c", "instance", "css", "ctx", "boot", "fs", "platform", " cp", "ec", "cache", "fc", "cf", "chip", "cn", "lc", "pu", "pec", "node", "cp", "CP", "CPU"], "env": ["ou", "np", "lv", "er", "equ", "que", "args", "ce", "energy", "ace", "vs", "site", "engine", "en", "hw", "el", "esp", "cf", "pec", "conf", "v", "em", "context", "vm", "oa", "zone", " environment", "db", "loader", "enc", "exec", "ea", "cli", "agent", "module", "ne", "config", "viron", "Environment", "gui", "inet", "edge", "ee", "environment", "iss", "ext", "eu", "skin", "eff", "export", "session", "conn", "dict", "c", "eng", "estate", "console", "eb", "req", "state", "spec", "scope", "cfg", "nc", "e", "exc", "core", "anc", "server", "ev", "obj", "net", "her", "ctx", "oe", "ec", "settings", "cache", "dev", "eni", "priv", "gu"], "err": ["br", " r", "result", "good", " error", "er", "str", "nil", "better", "ler", "arm", "rh", "type", "hr", "order", "irm", "later", "off", "inner", "runner", "res", "mr", "init", "orer", " Err", "nor", "Error", "erer", "der", "ar", "ver", "aster", "asm", "finder", "ner", "val", "grade", "orig", " er", "bug", "r", "ind", "magic", "eor", "ah", "wr", "nr", "ise", "rar", "code", "here", "iter", "orr", "status", "far", "rc", "try", "len", "arr", "ry", "acer", " result", "var", "lr", "erg", "g", "Er", "req", "more", "work", "end", "j", "error", "op", "ll", "resp", "out", "usr", "rr", "ait", "rage", "ir", "yr", "kr", "dr", "gr", "attr", "rt"], "i": ["ui", "bi", "y", "pi", "index", "ie", "end", "j", "di", "e", "d", "er", "mini", "multi", "key", "fi", "ti", "p", "yi", "api", "slice", "is", "phi", "qi", "ii", "anti", "adi", "module", "u", "r", "ret", "ind", "id", "n", "ni", "l", "ip", "temp", "c", "m", "init", "t", "ix", "f", "zi", "io", "source", "start", "ri", "ini", "info", "it", "gi", "xi", "uri", "x", "o", "ci", "eni", "code", "z", "b", "in", "iu", "esi", "I", "ai", "v", "si", "li"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,\n\n                                 int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson\";\n\n    TCGv t0, t1;\n\n\n\n    if (rd == 0) {\n\n        /* Treat as NOP. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n#endif\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"mult.g\";\n\n        break;\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n        tcg_gen_ext32u_tl(t0, t0);\n\n        tcg_gen_ext32u_tl(t1, t1);\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"multu.g\";\n\n        break;\n\n    case OPC_DIV_G_2E:\n\n    case OPC_DIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"div.g\";\n\n        break;\n\n    case OPC_DIVU_G_2E:\n\n    case OPC_DIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"divu.g\";\n\n        break;\n\n    case OPC_MOD_G_2E:\n\n    case OPC_MOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"mod.g\";\n\n        break;\n\n    case OPC_MODU_G_2E:\n\n    case OPC_MODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"modu.g\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmult.g\";\n\n        break;\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmultu.g\";\n\n        break;\n\n    case OPC_DDIV_G_2E:\n\n    case OPC_DDIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"ddiv.g\";\n\n        break;\n\n    case OPC_DDIVU_G_2E:\n\n    case OPC_DDIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"ddivu.g\";\n\n        break;\n\n    case OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 6193, "substitutes": {"ctx": ["context", "sci", "rc", "conv", " cx", "loc", "cc", "rx", " context", "conn", "xc", "cm", "tx", "Context", "abc", "txt", "ck", "kb", "ctrl", "cv", "cam", "alloc", "ca", "ci", "cas", "grad", "cb", "cmp", "cp"], "opc": ["ripC", "copn", "opernc", "opnc", "ipc", "opern", "OPcs", "ripn", "ripf", " opf", " opb", "OPc", "copnc", " opnc", "operc", "opf", "copc", "ipcs", "operb", "opC", "OPf", "opcs", "copb", " opcs", "ripc", "OPn", "ipf", " opC", "ipC", "OPC", "opb"], "rd": ["ru", "wb", "rc", "fail", "od", "xd", "dra", "db", "loc", "d", "rm", "vr", "ord", "rid", "pl", "rg", "rf", "rx", "RS", "adr", "src", "ARR", "rh", "dat", "hr", "cn", "ct", "ha", "rob", "r", "ren", "lt", "ds", "RR", "ind", "rr", "rn", "dd", "fd", "lr", "sr", "aa", "pt", "rost", "nd", "ri", "rat", "aug", "RD", "fr", "dr", "lf", "bh", "la", "RF", "ud", "rb", "rw", "ra", "rl", "rin", "rod", "rect", "cd", "td", "red", "ld", "wd", "rax"], "rs": ["ru", "rc", "ras", "rss", "rm", "vr", "RC", "RS", "rx", "rg", "rf", "src", "ls", "ps", "pr", "r", "cs", "rings", "xs", "ds", "rr", "ars", "rows", "res", "lr", "sr", "mr", "cr", "tr", "ints", "dr", "sw", "rb", "rw", "ra", "rl", "ins", "Rs"], "rt": ["RT", "ru", "rc", "mt", "rss", "rm", "vr", "RC", "rid", "rx", "rf", "rh", "ct", "r", "lt", "irt", "ret", "rr", "rn", "rot", "t", "rec", "pt", "tr", "art", "nd", "vt", "ri", "gt", "wt", "ft", "fr", "nt", "dr", "rb", "rin", "rl", "addr", "ptr", "adr"], "opn": ["optn", "ropt", "operr", "ropr", "opr", " opns", "opern", "Opn", "opercn", "ropc", "opcn", " opN", "operc", "Opcn", " opcn", "opns", "opN", "Opc", "optc", "Opns", "operN", "opt", "ropn", "optr", "operns", " opr", "optN", "opert", " opt"], "t0": ["ta000", "pt8", "ta1", "f2", "te3", "te1", "pt3", "T00", "pt0", " t9", "f0", "pt1", "T050", "tty00", "T0", "T4", " t3", "tt1", "t00", "nt050", "nt50", "nt0", "l50", "tt9", "l0", " mt9", "tty0", "T50", "t50", "T1", " t50", "T3", " t4", "T8", "ret1", " mt50", "f1", " mt1", " tau", "t000", " t8", "te0", "tty1", "ttyau", "ta50", "t3", "f4", " t050", "t9", "ret00", "ret0", "tt0", "te50", "T2", "t8", "tau", "l000", "t2", "tt50", " mt0", "l1", " t000", "te00", " t2", "ta0", "retau", "t4", "t050", " t00", "nt1"], "t1": ["dt1", "wt1", "tie1", "pt0", " t5", "pt4", "tty81", "T1", " t4", "t100", "wt001", "unt001", "kt1", "tty1", "targ", "tONE", "T151", "t2", "tty100", "kt4", "wt127", "ntONE", "ta1", "t5", "p1", "unt127", "t151", "Tapp", "T0", "Tone", "tt1", "nt0", "T5", "taone", "t001", "tt110", "tty001", "unt1", " t151", "tty110", "dt0", " t100", "kt151", "kt0", "nt1", "ta2", "t127", "wt81", "tty127", "t81", "itONE", "tapp", "nt121", "p0", "p2", " t8", "it0", "t110", "T2", "tt100", "pt8", "tone", "ta0", "tie0", "TONE", "pt5", "it1", "pt1", "T4", "unt81", "it121", " t110", "ttyONE", "tty0", "t121", "ttyapp", "T121", "T8", "Targ", "tie4", "dtapp", "dtONE", "t8", "pone", "tiearg", "t4", "ptarg"]}}
{"project": "qemu", "commit_id": "7d489dcdf5fd71b5052ffd401b869a627e1c751f", "target": 0, "func": "static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6196, "substitutes": {"vdev": ["svver", "vdiff", "vtr", "vde", "ldi", "avdev", "lev", "Vcase", "ldie", "mdevice", "ndie", "svdata", "ldev", "wdev", "evdc", "svself", "vdevelopment", "Vconf", "evev", "vconf", "lver", "svdev", "lconf", "avdd", "Vev", "evvar", " verror", "tvdev", "verror", "ldc", "ndevice", "vdie", "vdef", "Verror", "vdi", " vdi", " vself", " vdevelopment", "navev", "Vdd", "pev", "vapp", "vconn", "wev", "svev", "Vver", " vconf", "vedef", "ltr", "vdebug", "mdev", "vedev", "tvdebug", "vcase", "mver", "wdevice", "ldef", "vself", "nvdevice", "svde", "pdev", "vdc", " vdebug", "vdd", "tvdevice", "avde", "nvdev", "vvar", "gdevice", "nvvar", "vev", "vprivate", "tvdevelopment", " vapp", " vde", "lerror", "Vprivate", "evdevice", "nvver", "svdd", "svdevice", "navprivate", "lconn", "ndev", " vev", "vecase", " vdiff", "svconn", " vdata", "lcase", "gdev", "svdc", "pver", " vconn", "nev", "vver", " vtr", "avdevice", "pprivate", " vdie", " vdevice", "gapp", "evver", "Vdef", "evdev", "Vdevice", "vdevice", " vver", "svdi", "gde", "navdev", "wtr", "veerror", "lself", "Vdev", "ldebug", "lapp", "ldevice", "Vde", "svdiff", "lde", "ldiff", "ldevelopment", "vdata", "mvar", "navver", "ldata"], "size": ["pos", "sum", "area", "scale", "name", "sync", "slice", "args", "type", "num", "Size", "sector", "range", "fee", "timeout", "six", "count", "unit", "data", "member", "oa", "offset", "cm", "cs", "position", "ize", "sized", "mode", "address", "network", "code", "shape", "handle", "time", "storage", "sec", "small", "value", "len", "false", "speed", "SIZE", "use", "n", "large", "c", "g", "capacity", "memory", "needed", "length", "zero", "si", "complete", "loc", "e", "now", "core", "function", "empty", "max", "global", "i", "ci"], "bytes": ["ones", "data", "gets", "used", "users", "sec", "nets", "total", "outs", "classes", "parts", "lines", "les", "len", "raw", "byte", "blocks", "rules", "args", "ls", "zip", "codes", "ks", "loads", "full", "values", "offset", "charges", "forces", "cs", "out", "vs", "flows", "pieces", "seconds", "files", "cycles", "s", "rows", "ops", "abytes", "css", "cells", "boot", "ns", "io", "pages", "ipes", "settings", "steps", "fee", "allows", "units", "bits", "reads", "Bytes", "es", "eps", "count", "os", "bs", "bps", "errors", "nos", "tes", "runs", "items", "ips"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "substitutes": {"ctx": ["context", "nc", "pc", "rc", "loc", "anc", "cc", "event", "call", "sync", "cli", "gc", "connection", "kw", "cus", "client", "sc", "conn", "xc", "ct", "support", "cm", "cs", "config", "fw", "cmd", "jp", "cca", "tx", "Context", "cms", "ck", "c", "instance", "css", "bc", "cr", "thread", "ctrl", "cl", "cv", "qa", "req", "pkg", "fc", "cu", "cf", "ca", "tc", "ga", "cn", "ci", "lc", "cas", "grad", "cb", "cmp", "comp", "cp", "vc", "util"], "blocking": ["locked", "complete", "starting", "exec", "cli", "interrupted", "blocks", "bl", "client", "full", "calling", "using", "block", "exclusive", "protected", "bc", "rolling", "buffer", "enabled", "locking", "padding", "cl", "partial", "ssl", "restricted", "including", "regular", "working", "prefix", "quiet", "successful", "loading", "background", "ocking", "http", "running", "testing"]}}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "substitutes": {"data": ["batch", "reader", "da", "def", "proc", "package", "DATA", "result", "input", "d", "di", "Data", "exec", "val", "devices", "multi", "p", "sync", "connection", "done", "buf", "config", "device", "dd", "ops", "init", "buffer", "next", " DATA", "array", "a", "parent", "cache", "info", "valid", "pack", "timeout", "append", "window", "dat"], "dev": ["Dev", "rc", "da", "pub", "dist", "def", "od", "diff", "rad", "di", "package", "d", "adv", "enc", "error", "ve", "fo", "debug", "self", "DEV", "api", "app", "conn", "bug", "ev", "prom", "off", "device", "config", "reg", "pro", "id", "plug", "dd", "var", "v", "engine", "dc", "boot", "prov", "tr", "prof", "mod", "serial", "hw", "req", "gh", "ow", "cache", "der", "info", "w", "ver", "ad", "md", "valid", "pu", "node", "grad", "priv", "vc", "conf", "gu", "driver", "wd"], "bus": ["local", "index", "pub", "Bus", "proc", "def", "db", "build", "pl", "hub", "fi", "self", "sync", "connection", "port", "buf", "bit", "conn", "test", "bridge", "ux", "bug", "this", "config", "device", "lib", "plugin", "plug", "block", "class", "boot", "bc", "path", "usb", "book", "pass", "io", "cat", "us", "serial", "mount", "cache", "BUS", "pu", "board", "b", "http", "cmp", "os", "feed", "driver", "base"], "tx": ["context", "ty", "worker", "pc", "rc", "reader", "def", "loc", "trans", "auth", "fx", "co", "ti", "sync", "wx", "test", "ux", "device", "Tx", "txt", "temp", "ck", "t", "raf", "ctx", "ta", "ix", "bc", "pt", "tr", "mc", "req", "gh", "cache", "der", "ran", "cf", "ca", "w", "tc", "trial", "ac", "rw", "cas", "ra", "q", "TX", "ax", "rel", "cross", "pull", "x"], "rx": ["ru", "rc", "pc", "reader", "eth", "rss", "rel", "loc", "vr", "fx", "co", "wx", "rg", "rf", "src", "sync", "ry", "rh", "xc", "ux", "r", "fw", "rr", "lr", "ck", "lex", "mr", "rd", "raf", "ctx", "wa", "ri", "req", "nr", "rb", "rw", "ra", "rl", "rin", "ax", "rou", "rs", "wd", "x", "rt"], "alloc": ["pool", "oca", "uc", "pc", "rc", "au", "rac", "loader", "loc", "enc", "coll", "exec", "isc", "nil", "anc", "mem", "wx", "acl", "afi", "org", "oc", "buf", "sc", "conn", "ux", "soc", "auc", "ack", "config", "win", "voc", "go", "asc", "c", "aux", "raf", "ctx", "toc", "init", "bc", "vol", "capacity", "pkg", "hw", "ec", "mac", "random", "cache", "req", "cu", "fee", "ga", "pu", "ac", "gen", "pack", "valid", "attr", "aw", "addr", "cmp", "vc", "conf", "access", "util"], "func": ["unc", "nc", "fn", "pc", "worker", "callback", "proc", "package", "fun", "exec", "val", "cc", "sys", "self", "sync", "call", "src", "function", "buf", "conn", "Function", "module", "lib", "obj", "class", " function", "bc", "f", "lambda", "fc", "cf", "loop", "code", "lc", "wrapper", "rb", "cb", "dll", "addr", "work"], "rvq": ["rvvflow", "rwflow", "rvvw", "Rvw", "rpq", "rwq", "rpflow", "rvflow", "RpQ", "rww", "Rvflow", "rvvQ", "Rpq", "rvQ", "rvvq", "RvQ", "Rpflow", "rpQ", "rvw", "rpw", "Rpw", "rwQ", "Rvq"], "tvq": ["vuq", "uvqueue", "voltqueue", "uvqa", "tvqa", "uvqs", "voltqs", "voltqa", "uvq", "vuqa", "tvqueue", "vuqueue", "tvqs", "voltq", "vuqs"], "socket": ["pool", "sq", "proc", "server", "sync", " sock", "src", "buf", "conn", "seq", "channel", " sockets", "config", "sf", "ss", "ocket", "cpu", "sn", "ssl", "slot", "sl", "Socket", "timeout", "stream", "ockets", "port"], "sv": ["av", "vl", "sq", "ipt", "lv", "db", "isl", "sb", "sys", "vi", "nv", "zip", "api", "sm", "vs", "support", "service", "sf", "csv", "sp", "vector", "ds", "via", "s", "temp", "ss", "sh", "services", "uv", "vt", "sn", "sql", "cv", "ssl", " SV", "sl", "iv", "ft", "series", "sd", "su", "timeout", "null", "sk", "ov", "status", "vc", "serv", "v", "vv", "si"], "ret": ["re", "rc", "pin", "ref", "result", "fun", "success", "alt", "att", "len", "val", "fi", "mem", "no", "bit", "RET", "r", "reg", "res", "inter", "fin", "cur", "f", "pass", "lit", "ben", "en", "flag", "det", "ft", "nt", "reply", "code", "valid", "arg", "addr", "status", "rets", "Ret", "rt"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n", "idx": 6241, "substitutes": {"str": ["br", "text", "enc", "er", "exec", "arr", "hr", "test", "pr", "r", "Str", "empty", "inner", "STR", "rr", "obj", "s", "txt", "res", "sr", "st", "stri", "tr", "f", "kr", "fr", "dr", "iter", "doc", "rs"], "err": ["msg", "rc", "ner", "error", "result", "e", "er", "ler", "arr", "rh", "test", "inc", "pr", "r", "resp", "inner", "ind", "rr", "res", "var", "lr", "cr", "rev", "Er", "req", "Error", "nr", "ise", "der", "ar", "ver", "fr", "code", "dr", "gr", "valid", "iter", "aster", "count", "cb", "ptr"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_validate_certificate(struct VncState *vs)\n\n{\n\n    int ret;\n\n    unsigned int status;\n\n    const gnutls_datum_t *certs;\n\n    unsigned int nCerts, i;\n\n    time_t now;\n\n\n\n    VNC_DEBUG(\"Validating client certificate\\n\");\n\n    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {\n\n\tVNC_DEBUG(\"Verify failed %s\\n\", gnutls_strerror(ret));\n\n\treturn -1;\n\n    }\n\n\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n\n\treturn -1;\n\n    }\n\n\n\n    if (status != 0) {\n\n\tif (status & GNUTLS_CERT_INVALID)\n\n\t    VNC_DEBUG(\"The certificate is not trusted.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\n\t    VNC_DEBUG(\"The certificate hasn't got a known issuer.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_REVOKED)\n\n\t    VNC_DEBUG(\"The certificate has been revoked.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6243, "substitutes": {"vs": ["iss", "vp", "sb", "VS", "server", "ks", "ls", "session", "versions", "ps", "ses", "cs", "gs", "alls", "ds", "xs", "changes", "env", "sts", "s", "ops", "ss", "ils", "ts", "v", "services", "fs", "ns", "vers", "ms", "vt", "ants", "vals", "ums", "settings", "manager", "va", "sv", "sk", "es", "http", "bs", "os", "hs", "vc", "qs", "rs", "verts"], "ret": ["pet", "detail", "rc", "re", "ref", " r", "fail", "progress", "pre", "result", "success", "value", "alt", "att", "repl", "fun", "back", "er", "len", "val", "Status", "mem", "ll", "RET", "r", "resp", "stat", "reg", " result", "res", "obj", "ut", "sr", "tr", "f", " resp", "rev", "lit", " fut", "flag", "info", "det", "al", "ft", "reply", "job", " success", "rt", "pret", "iter", "rets", "Ret", "base"], "status": ["complete", "date", "msg", "note", "index", "sec", "progress", "error", "result", "success", "si", "name", "message", "sb", "received", "str", "Status", "confirmed", "server", "ity", "sys", "sync", "grade", "gc", "session", "type", "style", "seq", "html", "login", "git", "speed", "site", "current", "service", "sp", "stat", "id", "stage", "sign", "stats", "skip", "temp", "sr", "content", "version", "fs", "summary", "f", "source", "comment", "flag", "ssl", "settings", "security", "err", "info", "flags", "rate", "score", "match", "code", "reason", "state", "active", "wait", "update", "spec"], "certs": ["signes", "Certs", " certes", "Certd", "privp", "reqes", "certes", "signp", "certb", "reqb", "signb", "reqs", "Certes", "signls", "Certi", " certi", "prives", "Certls", "privs", "reqd", "reqp", "signi", "certp", "signs", "certd", "Certp", "privd", "certi", " certls", "certls", "Certb"], "nCerts": ["nCurc", "nCertes", "nCerti", "nSignp", "nCurs", "nSignn", "nCooks", "nCuri", "nCertis", "nLogi", "nCookp", "nCurd", "ncertes", "nSigns", "nSignes", "pCertes", "ncertc", "pCerts", " nCurs", "pCertis", "nLogd", " nCurd", "nSigni", "pCertp", "nCookis", "ncerti", "pcerts", " nCuri", "pcertis", "nSignis", "ncertis", "pcertp", "nCertn", " nCurc", "nCookes", "ncertns", "nCertp", " nCertd", "ncertp", "ncertn", "ncerts", " nCerti", "nSignns", "pcertes", "nLogc", " nCertn", " nCertns", "nLogs", "ncertd", " nCertc", "nCertc", "nCertns", "nCertd"], "i": ["ui", "bi", "y", "index", "pi", "ie", "j", "di", "e", "d", "mini", "multi", "fi", "ti", "p", "yi", "slice", "type", "h", "mi", "phi", "inc", "qi", "ii", "u", "ind", "id", "n", "ni", "l", "ip", "c", "t", "ix", "sup", "f", "g", "zi", "io", "ri", "ini", "info", "gi", "it", "xi", "ci", "eni", "z", "b", "iu", "I", "ai", "v", "si", "li"], "now": ["Now", "date", "low", "new", "func", "gm", "form", " NOW", "from", "j", "result", "mm", "since", "import", "get", "self", "df", "NOW", "no", "function", "session", "type", "old", " current", "this", "current", "off", "create", "at", "id", "not", "st", "today", "ctx", " Now", "next", "day", "start", "max", "or", "parent", "size", "md", "night", "length", "omp", "time", "wait", "age", "created", "comp", "v", "after"], "cert": ["br", "ext", "cand", "url", "pub", "j", "cp", "name", "alt", "cot", "pl", "key", "val", "str", "Cert", "ce", "type", "pair", "dat", "order", "pr", "resource", "trust", "config", "dest", "ch", "sp", "sign", "ificate", "ind", "ctr", "crit", "ert", "class", "temp", " Cert", "cur", "pt", "secret", "opt", "cat", "cl", "cel", "req", "ssl", "non", "err", "sl", "ver", "ca", "cf", "user", "valid", "gen", "fac", "priv", "font", "chain"]}}
{"project": "qemu", "commit_id": "85df0de4cfe54fd64df7e37448cd152d0c9199a4", "target": 0, "func": "int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n", "idx": 6251, "substitutes": {"opaque": ["oacity", "Ophole", "defec", "oec", "operoch", "operhole", "opacity", "defacity", "oaque", "opaques", "ophole", "opoch", "defaque", " opec", "operaque", "Opaque", "defaques", "oaques", "operacity", " opacity", " opaques", " opoch", "Opoch", "Opacity", "opec", " ophole"], "key": ["keys", "name", "element", "coll", "ce", "type", "pair", "ye", "order", "ace", "ack", "cor", "id", "ip", "any", "lease", "ver", "fee", "pe", "sk", "count", "row", "lock", "hash", "k", "ie", "seed", "enc", "call", "rule", "kw", "channel", "trust", "change", "air", "ek", "mode", "ck", "start", "mac", "part", "KEY", "match", "code", "ame", "lc", "here", "close", "ac", "Key", "ee", "year", "base", "oy", "sec", "url", "kid", "value", "ype", "connection", "no", "ry", "conn", "patch", "query", "sign", "block", "cy", "entry", "req", "prefix", "length", "kind", "col", "ke", "work", "token", "x", "date", "ak", "mix", "error", "play", "core", "op", "seq", "ask", "ctx", "secret", "act", "hop", "max", "parent", "cache"], "callback": ["batch", "func", "worker", "fn", "object", "closure", "Callback", "future", "rc", "progress", "fun", "value", "error", "result", "success", "back", "message", "queue", "collection", "call", "sync", "native", "connection", "function", "type", "buf", "client", "conn", "config", "fb", "buff", "CB", "class", "forward", "buffer", "f", "consumer", "next", "array", "cache", "loop", "delay", "wrapper", "background", "timeout", "attr", "cb", "cmp", "parser", "method", "token", "handler"], "callback_opaque": ["callback_opque", "callback_paques", "callback_opaco", "callback_oppity", "callback_oaque", "callback_offaque", "callback_operity", "callback_copaques", "callback_oppque", "callback_copaque", "callback_pity", "callback_offaques", "callback_offacity", "callback_opacity", "callback_oaco", "callback_openacity", "callback_copity", "callback_operaque", "callback_offaco", "callback_operaco", "callback_operaques", "callback_openaques", "callback_oppaques", "callback_oppaque", "callback_paco", "callback_openaco", "callback_openaque", "callback_opaques", "callback_opity", "callback_copque", "callback_operacity", "callback_oaques", "callback_paque", "callback_oity"], "data": ["batch", "msg", "pos", "ada", "frame", "DATA", "queue", "result", "value", "input", "message", "Data", "val", "open", "ata", "arr", "api", "done", "base", "buf", "seq", "offset", "bytes", "response", "read", "content", "entry", "buffer", "next", "start", "part", "cache", "info", "media", "size", "delay", "length", "addr", "cb", "body", "format", "dat"], "len": ["Len", "low", "pos", "split", "fn", "msg", "db", "fun", "loc", "enc", "limit", "val", "byte", "mem", "ler", "li", "ls", "lang", "buf", "seq", "conn", "offset", "lon", "line", " length", "n", "l", "block", "lo", "load", "all", "fin", "buffer", "f", "lit", "min", "en", "el", "bin", "cache", "part", "err", "partial", "lin", "size", "list", "fee", "lf", "lc", "delay", "z", "length", "lan", "count", "ln", "lock", "stat", "base"], "s": ["new", "e", "si", "d", "sb", "sys", "p", "ks", "ls", "S", "h", "is", "ps", "client", "ses", "qs", "r", "cs", "gs", "service", "u", "ds", "this", "n", "l", "states", "ss", "c", "m", "ts", "services", "fs", "g", "f", "ns", "sa", "a", "ssl", "settings", "i", "sl", "o", "js", "b", "es", "su", "os", "conf", "v", "rs", "spec"]}}
{"project": "FFmpeg", "commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "target": 1, "func": "static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],\n\n                                   int order, int qlevel, int len, int bps)\n\n{\n\n    int i, j;\n\n    int ebps = 1 << (bps-1);\n\n    unsigned sigma = 0;\n\n\n\n    for (i = order; i < len; i++)\n\n        sigma |= decoded[i] + ebps;\n\n\n\n    if (sigma < 2*ebps)\n\n        return;\n\n\n\n    for (i = len - 1; i >= order; i--) {\n\n        int64_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (int64_t)decoded[i-order+j];\n\n        decoded[i] -= p >> qlevel;\n\n    }\n\n    for (i = order; i < len; i++, decoded++) {\n\n        int32_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (uint32_t)decoded[j];\n\n        decoded[j] += p >> qlevel;\n\n    }\n\n}\n", "idx": 6272, "substitutes": {"decoded": ["recoded", " decated", "DECoded", "ecided", "ecored", "collated", "reccoded", "collrypted", "encoding", "encided", "encoded", "declcoded", "ecoded", "declrypted", "decloded", "DECrypted", "encoder", "DECided", " decrypted", "descached", " decoding", "ecoder", "ecoding", "deccoded", "DECcoded", "declored", "recrypted", "collided", " decored", "colloded", "enccoded", "decored", "encrypted", "decoder", " decided", "desccoded", " decoder", "declached", "descored", "decloder", "ecached", "eccoded", "encated", "decoding", "decided", " deccoded", "decached", "decrypted", "decated", "encored", "descoded", "ecrypted", "recided"], "coeffs": ["coEFFps", "coefures", "coEFFures", " coefes", "cosss", " coeffses", "coeffments", "coEFFs", "coefp", "coefficientsds", "coeffics", "cossds", "coefficientss", "coefficientsps", " coeffes", "coefes", " coefs", " coffes", " coeffps", "coefficses", "coefps", "coffes", "coefments", "coeffices", " coeffments", "coefds", " coffments", "coeffures", "coefses", "coffses", "coeffp", "coeffses", " coeffp", " coeffures", "coefficures", "coeffes", "coeffps", "coefficps", "coefs", " coefp", "coffments", "coffs", " coefds", "cossp", " coeffds", "coEFFes", "coefficments", " coffses", "cossps", " coffs", " coefures", "coeffds", "coefficientsp", " coefps"], "order": ["index", "dir", "seed", "end", "scale", "pre", "db", "error", "alt", "limit", "ord", "er", "vert", "now", "grade", "p", "rule", "style", "player", "Order", "rank", "offset", "record", "test", "r", "ii", "position", "ordering", "off", "id", "block", "asc", "orders", "mode", "all", "degree", "version", "layer", "address", "page", "sort", "start", "en", "ORD", "random", "err", "info", "der", "rate", "rar", "code", "user", "size", "level", "shape", "length", "direction", "count", "priority", "ai", "row", "ordered", "ell", "base"], "qlevel": [" qwl", "qlength", "pplevels", " qdepth", "quvalue", " qscale", "Qlevel", "qvalue", "sqval", "qdepth", "Qscale", "qulevel", "pdepth", "ppwl", "qval", "qlevels", "qulevels", "qindex", "qwl", " qlevels", "quval", "qulength", "pindex", "ppscale", " qval", "sqvalue", "Qlevels", "Qwl", " qlength", " qindex", "qudepth", "plevel", "quindex", " qvalue", "plevels", "qscale", "sqlength", "sqlevel", "pplevel"], "len": ["Len", "pos", "split", "pre", "lv", "limit", "pl", "val", "li", "p", "base", "ls", "bl", "ll", "seq", "lon", "lt", "elt", "line", "lim", "l", "n", "all", "layer", "dl", "en", "el", "bin", "den", "part", "lin", "lp", "code", "lf", "lc", "lvl", "z", "length", "iter", "count", "ln", "lock", "ell", "fl"], "bps": ["hops", "fps", "lins", "pre", "pins", "parts", "lines", "limit", "p", "blocks", "pps", "ls", "params", "ps", "pad", "hz", "bytes", "tips", "pieces", "s", "ops", "ns", "pages", "pp", "bis", "ipes", "points", "steps", "lp", "bits", "bp", "b", "eps", "limits", "offs", "planes", "items", "ips"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "di", "e", "si", "d", "ik", "multi", "fi", "ti", "p", "yi", "api", "is", "mi", "phi", "qi", "ii", "ki", "u", "ji", "ind", "id", "n", "l", "ni", "ip", "s", "m", "c", "ori", "ix", "oi", "f", "zi", "io", "a", "ri", "ini", "part", "info", "o", "gi", "my", "xi", "uri", "it", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "v", "x", "li"], "j": ["bi", "ui", "br", "y", "k", "ie", "aj", "e", "si", "key", "jc", "p", "bj", "jit", "jl", "ij", "pr", "ii", "qi", "u", "ji", "je", "n", "jp", "l", "obj", "jo", "m", "t", "ix", "g", "f", "pt", "ja", "jet", "uj", "a", "el", "jen", "o", "it", "x", "job", "ju", "z", "js", "b", "q", "oj", "v", "J", "jj", "li"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static int read_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic = NULL;\n\n    int err, i, ret;\n\n    int st_index[AVMEDIA_TYPE_NB];\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int eof = 0;\n\n    int pkt_in_play_range = 0;\n\n    AVDictionaryEntry *t;\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;\n\n    SDL_mutex *wait_mutex = SDL_CreateMutex();\n\n\n\n    memset(st_index, -1, sizeof(st_index));\n\n    is->last_video_stream = is->video_stream = -1;\n\n    is->last_audio_stream = is->audio_stream = -1;\n\n    is->last_subtitle_stream = is->subtitle_stream = -1;\n\n\n\n    ic = avformat_alloc_context();\n\n    ic->interrupt_callback.callback = decode_interrupt_cb;\n\n    ic->interrupt_callback.opaque = is;\n\n    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret = AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if (genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    err = avformat_find_stream_info(ic, opts);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    if (ic->pb)\n\n        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    if (seek_by_bytes < 0)\n\n        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT);\n\n\n\n    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    is->realtime = is_realtime(ic);\n\n\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_VIDEO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n\n                                wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n\n    if (!audio_disable)\n\n        st_index[AVMEDIA_TYPE_AUDIO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n\n                                wanted_stream[AVMEDIA_TYPE_AUDIO],\n\n                                st_index[AVMEDIA_TYPE_VIDEO],\n\n                                NULL, 0);\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n\n                                wanted_stream[AVMEDIA_TYPE_SUBTITLE],\n\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n\n                                NULL, 0);\n\n    if (show_status) {\n\n        av_dump_format(ic, 0, is->filename, 0);\n\n    }\n\n\n\n    is->show_mode = show_mode;\n\n\n\n    /* open the streams */\n\n    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n\n    }\n\n\n\n    ret = -1;\n\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n\n        ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n\n    }\n\n    if (is->show_mode == SHOW_MODE_NONE)\n\n        is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;\n\n\n\n    is->refresh_tid = SDL_CreateThread(refresh_thread, is);\n\n\n\n    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    if (infinite_buffer < 0 && is->realtime)\n\n        infinite_buffer = 1;\n\n\n\n    for (;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                is->read_pause_return = av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL\n\n        if (is->paused &&\n\n                (!strcmp(ic->iformat->name, \"rtsp\") ||\n\n                 (ic->pb && !strncmp(input_filename, \"mmsh:\", 5)))) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int64_t seek_target = is->seek_pos;\n\n            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n\n            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n\n//      of the seek_pos/seek_rel variables\n\n\n\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            } else {\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n                if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n\n                   //FIXME: use a cleaner way to signal obsolete external clock...\n\n                   update_external_clock_pts(is, (double)AV_NOPTS_VALUE);\n\n                } else {\n\n                   update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n            eof = 0;\n\n            if (is->paused)\n\n                step_to_next_frame(is);\n\n        }\n\n        if (is->queue_attachments_req) {\n\n            avformat_queue_attached_pictures(ic);\n\n            is->queue_attachments_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (infinite_buffer<1 &&\n\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n\n            || (   (is->audioq   .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)\n\n                && (is->videoq   .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request)\n\n                && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) {\n\n            /* wait 10 ms */\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        if (eof) {\n\n            if (is->video_stream >= 0) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->video_stream;\n\n                packet_queue_put(&is->videoq, pkt);\n\n            }\n\n            if (is->audio_stream >= 0 &&\n\n                is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->audio_stream;\n\n                packet_queue_put(&is->audioq, pkt);\n\n            }\n\n            SDL_Delay(10);\n\n            if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) {\n\n                if (loop != 1 && (!loop || --loop)) {\n\n                    stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n\n                } else if (autoexit) {\n\n                    ret = AVERROR_EOF;\n\n                    goto fail;\n\n                }\n\n            }\n\n            eof=0;\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret == AVERROR_EOF || url_feof(ic->pb))\n\n                eof = 1;\n\n            if (ic->pb && ic->pb->error)\n\n                break;\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n\n                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *\n\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n\n                <= ((double)duration / 1000000);\n\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        avformat_close_input(&is->ic);\n\n    }\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    SDL_DestroyMutex(wait_mutex);\n\n    return 0;\n\n}\n", "idx": 6277, "substitutes": {"arg": ["pc", "rc", "argument", "param", "loc", "play", "enc", "val", "fi", "call", "arr", "args", "lang", "ace", "inc", "AT", "ang", "AR", "par", "BB", "abc", "var", "inter", "arc", "rec", "g", "ig", "API", "or", "parse", "mac", "ad", "ar", "Ar", "lc", "ag", "ac", "Arg", "util"], "is": ["bi", "pi", "ik", "isc", "api", "id", "ip", "s", "any", "init", "IS", "ar", "uri", "Is", "has", "in", "ui", "ie", "ais", "get", "iris", "app", "oc", "isu", "cs", "iso", "can", "next", "pic", "ib", "or", "ini", "was", "its", "sis", "isi", "mis", "ac", "es", "http", "iss", "isl", "sys", "ish", "self", "p", "ls", "mi", "instance", "css", "us", "kit", "it", "im", "lis", "bs", "ist", "irc", "si", "x", "ists", "isa", "act", "as", "bis", "ri", "parent", "cache", "info", "iv", "ci", "esi", "ics", "ris", "os"], "ic": ["bi", "sci", "pi", "rc", "ici", "pc", "aci", "wic", "ict", "enc", "ik", "co", "isc", "iac", "fi", "exec", "cli", "op", "sync", "ican", "acl", "gc", "oc", "lic", "xc", "inc", "ct", "nic", "ch", "lib", "voc", "cit", "ip", "cy", "c", "ck", "init", "ctx", "icer", "aic", "cci", "ix", "pic", "ig", "IC", "bc", "act", "mc", "cl", "ec", "ini", "cu", "fc", "im", "tc", "mic", "ci", "lc", "script", "icc", "ac", "ia", "ics", "bank", "vc", "ai", "ht", "irc", "x"], "err": ["msg", "br", "end", "ner", "error", "result", "loc", "try", "e", "exc", "er", "len", "str", "val", " error", "call", "ler", "arr", "rx", "arm", "rh", "orig", "order", "test", " er", "pr", "bug", "r", "resp", "ch", "die", "inner", "runner", "ind", "usr", "rr", "acer", "res", "lr", "sr", "mr", "init", "magic", "conf", "Er", "ir", "req", "Error", "erer", "wr", "ise", "der", "nr", "dev", "ver", "kr", "fr", "rar", "code", "dr", "ar", "yr", "here", "gr", "attr", "iter", "cb", "status", "aster", "doc"], "i": ["ui", "bi", "y", "index", "pi", "j", "di", "e", "ik", "multi", "fi", "li", "p", "ti", "yi", "h", "mi", "phi", "qi", "ii", "ki", "hi", "r", "u", "inner", "ind", "id", "ni", "chi", "ip", "l", "ami", "n", "abi", "m", "c", "init", "ix", "g", "f", "oi", "zi", "ri", "ini", "info", "it", "gi", "xi", "mu", "uri", "x", "ci", "eni", "lc", "z", "in", "b", "iter", "iu", "I", "ai", "v", "si"], "ret": ["pat", "let", "ref", "def", "mt", "result", "fun", "success", "alt", "att", "fat", "len", "val", "str", " Ret", "arr", "bit", "num", "RET", "resp", "lt", "reg", "et", "res", "ut", "rot", "fin", "bc", "rev", "lit", "cat", "flag", "part", "gt", "det", "ver", "ft", "nt", "reply", "iter", "sat", "status", "rets", "Ret", "rt"], "st_index": ["storagelexind", "st_body", "stipindex", "St_offset", "stayoffset", "st_position", "st_ind", "stallbody", "st_thread", "storagelexdata", "st1index", "st1thread", "st_offset", "stalloffset", "stayindex", "st_connection", "stream_id", "staybody", "stream_index", "storage_ind", "storagelexoffset", "stipdata", "stipoffset", "storagelexindex", "storage_index", "storage_offset", "stayconnection", "stlexind", "st1position", "stipind", "St_index", "st_data", "stream_position", "stlexdata", "stlexoffset", "stallindex", "storage_data", "stlexindex", "stream_thread", "st_id", "st1id", "stallconnection", "St_connection", "St_body"], "pkt1": ["Packet3", " pkt2", "pce1", "packet1", " packet0", "Packet2", "Pkt3", "pct3", "pct2", " packet1", "pkt4", "packet3", " packet2", "pct0", "Packet1", "pkg4", " pkt4", "pkt2", " packet4", "Packet0", "Pkt0", "pce3", "pct1", "pkg1", "packet4", "Pkt2", "pkg0", "Pkt1", "pkg2", " pkt0", "pkt0", "pkt3", "pce2", "packet0", "pct4", "packet2", "pce0"], "pkt": ["ppkt", "Pck", "Pct", "ppct", " pct", "Packet", " pck", "pck", "packet", " packet", "ppacket", "ppck", "Pkt", "pct"], "t": ["y", "j", "text", "e", "d", "tn", "att", "dt", "tp", "ti", "p", "template", "T", "type", "h", "dat", "ct", "test", "r", "tt", "u", "n", "ut", "tu", "txt", "c", "m", "ts", "st", "tmp", "ta", "pt", "f", "g", "tm", "o", "tc", "rt", "qt", "ot", "tf", "ant", "v", "tz"], "opts": ["opte", "optt", "coptes", "optte", "cops", "opter", "optTS", "OPter", "operter", " opls", " opTS", "opTS", " opte", "operters", "OPts", "copTS", "optter", "OPters", "optls", "precs", "operts", "optionts", " opters", "ops", "optionTS", "optts", "optes", " optes", "opters", "opt", "opcs", "pretes", "optionls", "opttes", " opcs", "optionte", "copts", "optcs", "opls", "prets", "opert", "OPt", " ops", "preters", "optters"], "orig_nb_streams": ["orig_nb_lengthd", "orig_nb_contd", "orig_nb_threadflows", "orig_nb_lengthS", "orig_nb_threads", "orig_nbofthreads", "orig_nb_lengthflows", "orig_nb_lengths", "orig_nb_lengthds", "orig_nbofstreamds", "orig_nbofthreadd", "orig_nbofthreadds", "orig_nb_streamings", "orig_nb_lengthries", "orig_nb_streamries", "orig_nb_rounds", "orig_nb_threadries", "orig_nb_paths", "orig_nb_pathd", "orig_nb_pathds", "orig_nb_contries", "orig_nb_threadS", "orig_nbofstreamings", "orig_nb_streamS", "orig_nb_threadd", "orig_nb_lengthings", "orig_nbofstreamd", "orig_nb_contS", "orig_nbofthreadings", "orig_nbofstreams", "orig_nb_threadds", "orig_nb_streamd", "orig_nb_pathflows", "orig_nb_streamds", "orig_nb_roundds", "orig_nb_threadings", "orig_nb_streamflows", "orig_nb_conts", "orig_nb_roundings", "orig_nb_roundd"], "wait_mutex": ["wait_motx", "wait_utex", "wait_condx", "wait_condex", "wait_condru", "wait_mutout", "wait_utru", "wait_motru", "wait_utout", "wait_condout", "wait_mutx", "wait_utx", "wait_motex", "wait_mutru", "wait_motout"]}}
{"project": "FFmpeg", "commit_id": "859bb3cfee28efff9c965d4c9320c7837b85849e", "target": 0, "func": "int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2];\n\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n\n\n    assert(avctx);\n\n    if (!render || render->xvmc_id != AV_XVMC_ID ||\n\n        !render->data_blocks || !render->mv_blocks) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Render token doesn't look as expected.\\n\");\n\n        return -1; // make sure that this is a render packet\n\n    }\n\n\n\n    if (render->filled_mv_blocks_num) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n\n               render->filled_mv_blocks_num);\n\n        return -1;\n\n    }\n\n    if (render->allocated_mv_blocks   < 1 ||\n\n        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||\n\n        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||\n\n        render->next_free_data_block_num >\n\n                        render->allocated_data_blocks -\n\n                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    render->picture_structure = s->picture_structure;\n\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n\n    render->p_future_surface  = NULL;\n\n    render->p_past_surface    = NULL;\n\n\n\n    switch(s->pict_type) {\n\n        case  FF_I_TYPE:\n\n            return 0; // no prediction from other frames\n\n        case  FF_B_TYPE:\n\n            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];\n\n            if (!next)\n\n                return -1;\n\n            if (next->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_future_surface = next->p_surface;\n\n            // no return here, going to set forward prediction\n\n        case  FF_P_TYPE:\n\n            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];\n\n            if (!last)\n\n                last = render; // predict second field from the first\n\n            if (last->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_past_surface = last->p_surface;\n\n            return 0;\n\n    }\n\n\n\nreturn -1;\n\n}\n", "idx": 6293, "substitutes": {"s": ["options", "storage", "seed", "sq", "aws", "set", "e", "si", "parts", "save", "sb", "submit", "ser", "comments", "server", "self", "p", "sync", "details", "sports", "ls", "params", "S", "prev", "is", "sc", "ses", "cs", "sets", "gs", "service", "sf", "ds", "states", "ss", "c", "rs", "ts", "services", "m", "v", "t", "sym", "fs", "g", "ns", "f", "source", "parse", "a", "ssl", "settings", "se", "i", "sl", "init", "your", "series", "sv", "js", "su", "es", "http", "os", "conf", "send", "qs", "south", "spec", "styles"], "avctx": ["afcmp", " avpkg", "avcontext", "avalconn", "navcontext", "avalcontext", "avcrit", "navconn", "avconn", "afconfig", " avci", " avcontext", "AVpkg", "wavctx", "avconfig", "wavcontext", "afctx", "apctx", "afcontext", "avlc", "AVqa", "apconn", "avpkg", "AVconn", "awconn", "afconn", "Avctx", "apcontext", "ablc", "abctx", "AVcontext", "wavlc", "abcontext", "navctx", "avalctx", "wavcrit", "AVci", "AVctx", "awcontext", "awctx", "apqa", "avcmp", "aflc", "AVcrit", "Avci", "navqa", "avalconfig", "AVlc", "avqa", "awconfig", "avci", "Avpkg", "afcrit", "AVcmp", "Avcontext", "abcmp"], "last": ["data", "reverse", "replace", "future", "end", "bottom", "result", "name", "build", "show", "Last", " first", "li", "prev", "style", "full", "latest", "later", "use", "middle", "runner", "cur", "tr", "rev", "nd", "draw", "max", "start", "parent", "cache", "err", "size", "fr", "code", "flash", "worst", "send", "final", "after", "first"], "next": ["data", "new", "future", "end", "second", "result", "value", "below", "success", "then", "er", "now", "mini", "open", "li", "dot", "prev", "design", "latest", "big", "later", "config", "current", "middle", "head", "Next", "inner", "lower", "response", "follow", "obj", "child", "again", "respond", "page", "bis", "primary", "start", "other", "be", "max", "front", "code", "reply", "job", "valid", "handle", "adj", "business", "doc", "more", "missing", "feed", "output", "after", "first"], "render": ["plot", "header", "result", "theme", "build", "nder", "hide", "download", "apply", "order", "later", "represent", "flower", "draw", "cook", "Render", "aster", "output", "trigger", "consider", "begin", "view", "show", "write", "design", "player", "r", "load", "run", "respond", "parse", "author", "match", "handle", "http", "gener", "send", "driver", "after", "display", "reverse", "layout", "material", "save", "component", "document", "style", "use", "follow", "child", "rendered", "transform", "replace", "end", "play", "ser", "report", "reflect", "template", "make", "head", "request", "rr", "response", "master", "user", "cover", "dr", "require", "flash", "rend", "update"]}}
{"project": "FFmpeg", "commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "target": 1, "func": "static int calculate_bitrate(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    int i, j;\n\n    int64_t lensum = 0;\n\n    int64_t maxpos = 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n\n\n        if (!st->nb_index_entries)\n\n            continue;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n\n        lensum += len;\n\n    }\n\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n\n        return 0;\n\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n\n        return 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n        int64_t duration;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n\n            continue;\n\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n\n        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n\n    }\n\n    return 1;\n\n}\n", "idx": 6307, "substitutes": {"s": ["sq", "e", "sb", "sys", "p", "sync", "spec", "ks", "ls", "S", "is", "sc", "ps", "ses", "qs", "cs", "gs", "r", "u", "sf", "ds", "xs", "this", "service", "n", "l", "txt", "ops", "ss", "c", "sg", "ts", "m", "sym", "services", "sh", "t", "fs", "sup", "f", "ns", "g", "sa", "sim", "a", "ssl", "settings", "se", "w", "o", "sis", "sv", "js", "su", "b", "in", "os", "v", "rs", "si"], "avi": ["av", "bi", "ui", "audio", "vim", "pi", "wav", "rc", "oci", "aj", "di", "umi", "ahi", "co", "ava", "fi", "cli", "vi", "api", "afi", "ati", "mi", "audi", "adi", "ii", "vid", "ic", "video", "ami", "wi", "bc", "aic", "aa", "sa", "bis", "iti", "wp", "ini", "iv", "mic", "oga", "ani", "ai", "ave", "si"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "di", "e", "d", "ik", "multi", "fi", "ti", "p", "yi", "h", "is", "mi", "ij", "qi", "ii", "r", "ki", "anti", "u", "inner", "ji", "ind", "id", "n", "ni", "l", "ip", "ami", "c", "m", "init", "ix", "ori", "oi", "f", "g", "zi", "io", "ri", "ini", "info", "o", "it", "my", "x", "xi", "uri", "gi", "mu", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"], "j": ["ui", "pos", "br", "y", "index", "k", "ie", "section", "aj", "ng", "si", "d", "e", "key", "jc", "p", "bj", "bl", "h", "jit", "jl", "ij", "pr", "ii", "ch", "u", "ji", "ind", "je", "n", "l", "jp", "dj", "obj", "jo", "m", "ix", "pt", "f", "jon", "g", "ja", "jet", "uj", "oh", "kj", "other", "el", "part", "jen", "json", "o", "w", "x", "fr", "job", "z", "js", "b", "adj", "q", "oj", "v", "ld", "J", "jj", "li"], "st": ["ste", "iss", "sth", "end", "mt", "ust", "d", "stress", "ast", "sb", "str", "dt", "fe", "p", "std", "stab", "bl", "style", "stop", "ost", "sc", "ct", "dest", "td", "sp", "est", "ds", "stage", "l", "sts", "obj", "St", "dd", "ss", "sh", "rest", "t", "stri", "step", "ts", "rd", "pt", "sett", "sa", "nd", "sn", "inst", "start", "cl", "be", "tta", "se", "sta", "sl", "ft", "fr", "nt", "dr", "pe", "sd", "ist", "ld", "ST"], "duration": ["date", "urations", "depth", "url", "dist", "number", "diff", "fun", "db", "d", "vr", "frequency", "len", "dt", "style", "pad", "cost", "dp", "vid", "distance", "video", "days", "volume", "lag", "period", "version", "loss", "dy", "uv", "repeat", "gap", "description", "range", "uration", "mult", "rate", "fee", "delay", "elta", "span", "series", "timeout", "length", "time", "doc", "count", "unit", "Duration", "angle"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335, "substitutes": {"val": ["py", "data", "func", "pc", "ref", "def", "eval", "fail", "play", "value", "sel", "aval", "exec", "call", "rx", "arr", "p", "rule", "pid", "old", "pr", "this", "empty", "lib", "reg", "fb", "ind", "obj", "var", "temp", "Val", "pt", "prop", "vals", "el", "bin", "parent", "VAL", "rt", "valid", "rb", "gen", "arg", "grad", "v", "x", "base"], "addr": ["pos", "func", "frame", "callback", "ref", "name", "ord", "str", "ard", "rx", "arm", "adder", "src", "amd", "pad", "offset", "obj", "dd", "add", "address", "host", "pointer", "holder", "point", "part", "ad", "prefix", "x", "amp", "dr", "md", "attr", "node", "arg", "grad", "ptr", "align", "work", "wd", "adr", "base"], "index": ["pos", "ref", "end", "number", "diff", "loc", "value", "element", "name", "call", "slice", "type", "num", "inc", "offset", "image", "position", "Index", "ind", "id", "ion", "address", "action", "weight", "pointer", "point", "part", "i", "level", "length", "find", "x"]}}
{"project": "qemu", "commit_id": "2f295167e0c429cec233aef7dc8e9fd6f90376df", "target": 1, "func": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n", "idx": 6346, "substitutes": {"klass": ["Klass", "iklasses", "kcl", "iklass", "skcl", "Kclass", "skclass", "klasses", "skass", "ikcl", "sklass", "okass", "okazz", "kclass", "Kcl", "sklasses", " klasses", "kass", "Klasses", "oklass", "kazz", " kcl", " kazz", "skazz", " kclass", " kass", "oklasses", "ikclass"], "data": ["rc", "da", "def", "di", "DATA", "result", "input", "d", "Data", "dt", "params", "config", "device", "ds", "dd", "load", "ctx", "bc", "rec", "array", "parent", "cache", "info", "ac", "dat"], "dc": ["nc", "pc", "rc", "da", "di", "db", "deck", "d", "jc", "controller", "cc", "dt", "df", "gc", "design", "oc", "sc", "conn", "ct", "xc", "cm", "config", "cca", "cdn", "abc", "c", "enter", "bc", "mc", "ec", "dk", "fc", " DC", "cf", "tc", "ga", "dr", "lc", "cd", "DC", "ac", "disc", "vc", "doc"], "hc": ["hscs", "pfc", "pc", " hfc", "htfc", "hdc", "plc", " hpc", " hlc", "Hcs", "hci", "hpc", " hdc", " hcs", "pci", "hsdc", "htc", "hfc", "hlc", "hsc", "Hc", "Hdc", "Hpc", "hspc", "htlc", "hcs", "htci", " hci"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n", "idx": 6374, "substitutes": {"saddr": ["Sha", "sesnode", "snode", "sadd", "sord", "taddr", "sha", "paddr", " sad", "dsaddress", " saper", "tpad", "wadder", " spad", "shipaddr", "spha", "sadr", "skyhost", " sconn", "lsaddress", " solver", "paddress", "lsaddr", "dsaddr", "Saddress", "sad", "daddr", "opensaddr", "opensadder", "saddress", "fha", "opensoder", "thost", "daper", "woder", "svr", "saper", "skyad", "dadd", "spnode", "safi", "sesaddress", "dord", " sadder", "pvr", "tadr", " sadd", "fnode", "sesaddr", "lspad", " sord", "dhost", "shipaddress", "Sconn", "tad", " soder", "skyaddr", "symaddress", "skyafi", "Saddr", " shost", "faddress", "sesha", "sconn", " svr", "solver", "symaddr", "polver", " saddress", "soder", "waddress", " safi", "shost", "tafi", "taddress", "faddr", "symvr", "dsadd", " sadr", "opensaddress", "daddress", "dshost", "lsadr", "sadder", "shipord", "spaddr", "symolver", "waddr", "spaddress", "shipaper", " sha", "spad"], "errp": ["errf", "aerP", "erP", "errr", " errfp", "aerpre", "errorpre", "Erpre", "erp", "errP", "rrr", " errpr", "Erpr", "errorp", "ErP", "rrf", "aerp", "aerpr", "erpre", "erfp", "errpr", "errorP", "rrpre", " errP", "rrfp", " errr", "errpre", "errfp", "erf", "errorfp", " errpre", "rrp", "Erp", " errf"], "ai": ["iat", "bi", "ru", "an", "ui", "AU", "fa", "ei", "oci", "au", "pai", "ais", "ae", "na", "fi", "af", "api", "afi", "ay", "mi", "conn", "qi", " ca", " AI", "adi", "config", "air", " bi", "jp", "ni", "abc", "ami", "abi", "aim", "hai", "AI", "ait", "address", "aa", "wa", "sa", "as", "agi", "iri", "a", " api", "qa", "ini", "i", "info", "ca", "aud", "aaa", "uri", " mi", "ci", "eni", "ac", "ia", "aii", "attr", "ha", "ee", "si"], "res": ["func", "re", "ress", "ref", "ras", "result", "rss", "sys", "rx", "arr", "details", "rh", "ps", "r", "resp", "cs", "ros", "reg", "rr", "response", "rn", "rows", "s", "resh", "mr", "rest", "rec", "rev", "req", "R", "RE", "rar", "reply", "rez", "rem", "gr", "cas", "addr", "RES", "Res", "results", "resource", "os", "rel", "errors", "rs", "ret"], "rc": ["nc", "uc", " succ", "pc", " r", "ras", "error", "loc", "result", "RC", "exc", "co", "cc", " rec", "anc", "rx", "src", "ann", "rh", "sc", "auc", "inc", "irm", "ack", "roc", " reg", "r", "rr", "rn", "ck", "sr", "c", "cur", "bc", "rec", " sc", " RC", "dc", "cr", "req", "fc", "ror", "rar", "tc", "code", "dr", "lc", " exc", " rac", "rb", " src", "rl", "ok", "cb", "vc", "irc", "rt"], "err": ["msg", "reader", "ner", "error", "result", "e", "rm", "ras", "exc", "er", " error", "fi", "sys", "ler", "arr", "rh", "order", "ace", "inc", "pr", "bug", "r", "resp", "fam", " er", "ev", "ind", "acer", "rr", "ctr", "tx", "rn", "lr", "mr", "cr", "Er", "ir", "req", "Error", "rage", "ise", "der", "cer", "ar", "rar", "fee", "fr", "aaa", "reply", "dr", "gr", "ra", "rl", "attr", "errors", "cb", "aster", "conf", "rs", "raise"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void bamboo_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    PCIBus *pcibus;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr loadaddr = 0;\n\n    target_long initrd_size = 0;\n\n    DeviceState *dev;\n\n    int success;\n\n    int i;\n\n\n\n    /* Setup CPU. */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"440EP\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    if (env->mmu_model != POWERPC_MMU_BOOKE) {\n\n        fprintf(stderr, \"MMU model %i not supported by this machine.\\n\",\n\n            env->mmu_model);\n\n        exit(1);\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n    ppc_booke_timers_init(cpu, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                   ram_memories,\n\n                                   ram_bases, ram_sizes,\n\n                                   ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, 1);\n\n\n\n    /* PCI */\n\n    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,\n\n                                PPC440EP_PCI_CONFIG,\n\n                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],\n\n                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],\n\n                                NULL);\n\n    pcibus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pcibus) {\n\n        fprintf(stderr, \"couldn't create PCI controller!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, PPC440EP_PCI_IOLEN);\n\n    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 6385, "substitutes": {"machine": ["data", "note", "vm", "object", "storage", "profile", "proc", "loader", "slave", "message", "component", "interface", "controller", "core", "server", "game", "template", "program", "connection", "session", "Machine", "image", "module", "bug", "processor", "config", "service", "kernel", "device", "environment", "plugin", "m", "mode", "instance", "engine", "boot", "host", "space", "source", "comment", "mobile", "mac", "model", "part", "cache", "info", "manager", "mom", "project", "database", "state", "node", "process", "normal", "cell", "linux", "computer", "hard", "base"], "kernel_filename": ["system_filename", "system_location", "system_username", "kernel2filename", "kernel_location", "kernel_prefix", "kernel_directory", "kernellogfilename", "kernel_username", "kernel_software", "kernel2location", "system_software", "kernel2username", "system_description", "kernellogdescription", "kernellogsoftware", "kernellogdirectory", "system_directory", "kernel_description", "system_prefix", "kernel2prefix"], "kernel_cmdline": ["kernel__cmdlines", "kernel_cmdname", "kernel__cmdle", "kernel_cmdl", "kernel__cmdline", "kernel__hostle", "kernel_mdline", "kernel_commandle", "kernel_commandlines", "kernel_commandname", "kernel_deflines", "kernel_cmdlines", "kernel_mdname", "kernel_mdlines", "kernel_hostl", "kernel_commandl", "kernel_hostle", "kernel_hostname", "kernel_defl", "kernel__hostline", "kernel_hostlines", "kernel__hostname", "kernel__cmdname", "kernel_cmdle", "kernel_defline", "kernel_hostline", "kernel__hostlines", "kernel_commandline", "kernel_mdle"], "initrd_filename": ["initrn_url", "initrd_prefix", "initrt_Filename", "initrn_filename", "initrt_filename", "initrd_initial", "initrn_file", "initrt_bytes", "initrdsprefix", "initrn_prefix", "initrd_file", "initrdsfilename", "initrt_initial", "initrdsfile", "initrdsurl", "initrd_bytes", "initrd_url", "initrd_Filename"], "pci_irq_nrs": ["pci_irq_numodes", "pci_irq_Nros", "pci_irq_Nrd", "pci_irq_nros", "pci_irq_crd", "pci_irq_numrd", "pci_irq_numrs", "pci_irq_Nrs", "pci_irq_nrd", "pci_irq_cros", "pci_irq_numros", "pci_irq_codes", "pci_irq_Nodes", "pci_irq_crs", "pci_irq_nodes"], "address_space_mem": ["address_space_ram", "address_area_mem", "address_space_memory", "address_space_lim", "address_area_ram", "address_area_lim", "address_area_memory"], "isa": ["aci", "pai", "oci", "ina", "imi", "asu", "mini", "isc", "ai", "fi", "anti", "ang", "acs", "esa", "cca", "ami", "cci", "ISA", "agi", "ini", "asi", "iam", "xi", "eni", "va", "ani", "aa", "irc", "adr"], "ram_memories": ["ram_amory", "ram_temories", "ram_mions", "ram_amources", "ram_mories", "ram_matories", "ram_messages", "ram_mources", "ram_temages", "ram_messores", "ram_matources", "ram_amories", "ram_temors", "ram_memages", "ram_temores", "ram_memores", "ram_matages", "ram_mory", "ram_memions", "ram_amions", "ram_matory", "ram_memources", "ram_mations", "ram_memory", "ram_memors", "ram_messories", "ram_messors", "ram_matores", "ram_mators"], "ram_bases": ["ram_vases", "ram_bruses", "ram_bias", "ram_lases", "ram_vase", "ram_brias", "ram_base", "ram_brases", "ram_vias", "ram_brase", "ram_lase", "ram_lias", "ram_buses", "ram_luses", "ram_vuses"], "ram_sizes": ["ram_setsists", "ram_setsiz", "ram_cists", "ram_siz", "ram_cides", "ram_setsizes", "ram_offsiz", "ram_sists", "ram_offsizes", "ram_offsists", "ram_ciz", "ram_cizes", "ram_offsides", "ram_setsides", "ram_sides"], "pic": ["py", "pc", "pin", "proc", "pins", "mini", "fi", "anc", "cc", "sync", "quad", "pid", "oc", "mi", "module", "nic", "lib", "ic", "bc", "ig", "agi", "mc", "mac", "bin", "fc", "xi", "mic", "lc", "doc"], "irqs": [" ircks", " irqa", "rincs", "rinq", "rincks", "IRqa", "mirqa", "iraks", "irq", "IRq", "mirqs", "mirques", "iraqs", " irques", "irques", "IRcks", "IRques", "mirq", " irq", "ircs", "IRks", "irks", "rinqs", "IRcs", " ircs", "irqa", "mirks", "ircks", "iraq", "mircs", "IRqs", "iracs"], "pcibus": ["pcus", "pcopus", "puopus", "incubis", "incibus", "incus", "puubis", "pdubis", "pdopus", "pdibus", "puibus", "pcubis", "incopus", "puus", "pdus"], "cpu": ["pool", " CPU", "performance", "nc", "cfg", "vm", "pc", "proxy", "np", "lb", "proc", "loader", "queue", "gpu", "core", "none", "mem", "que", "GPU", "gc", "clock", "pid", "conn", "processor", "nic", "chu", "ne", "kernel", "runner", "jp", "hp", "bench", "net", "instance", "ctx", "boot", "uno", "px", "consumer", "platform", "console", "hw", "gp", "cache", "cow", "chip", "cn", "eni", "lc", "gru", "pu", "ilo", "node", "process", "cmp", "cp", "linux", "computer", "CPU"], "env": ["np", "theme", "vel", "equ", "que", "api", "args", "dep", "energy", "site", "device", "engine", "en", "el", "exe", "conf", "v", "context", "vm", "object", "zone", " environment", "db", "loader", "enc", "exec", "ea", "agent", "ne", "config", "viron", "Environment", "network", "gui", "environment", "ext", "profile", "eu", "de", "skin", "devices", "export", "session", "conn", "image", "password", "cookie", "eng", "shell", "opt", "console", "manager", "agents", "state", "extra", "scope", "end", "queue", "e", "exc", "core", "server", "ev", "cdn", "net", "ec", "cache", "err", "global", "eni", "attr", "priv", "enh"], "elf_entry": ["elf___cmp", "elf_mac", "elf___mac", "elf__entry", "elf__mac", "elf_port", "elf__cmp", "elf___entry", "elf_cmp", "elope_port", "elope_cmp", "elope_entry", "elope_mac", "elf___port", "elf__port"], "elf_lowaddr": ["elf_oldaddress", "elf_oldattr", "elf_oldAddress", "elf_highAddress", "elf_loadaddr", "elf_lowaddress", "elf_highaddr", "elf_highattr", "elf_oldaddr", "elf_loadaddress", "elf_loadattr", "elf_highaddress", "elf_lowAddress", "elf_loadAddress", "elf_lowattr"], "dev": ["data", "pos", "Dev", "proc", "bus", "de", "loader", "error", "slave", "exec", "debug", "mem", "DEV", "app", "conn", "ev", "device", "ip", "boot", "serial", "cache", "iv", "ver", "user", "node", "priv", "disk", "conf"], "success": [" test", " succ", " r", "error", " error", "ea", " b", " rc", " unit", " e", "device", " status", " result", " ret", " d", " num", " j", " h", " cores", " vi", "err", "code", " code", "va", " pri", " res"], "i": ["ui", "pi", "j", "e", "d", "cli", "p", "type", "num", "ii", "line", "id", "n", "ni", "ip", "s", "c", "mode", "init", "io", "start", "info", "xi", "ci", "b", "I", "si"]}}
{"project": "qemu", "commit_id": "6476615d385eb249105b25873ef30ba4b9c808dc", "target": 0, "func": "void HELPER(stpq)(CPUS390XState *env, uint64_t addr,\n\n                  uint64_t low, uint64_t high)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    if (parallel_cpus) {\n\n#ifndef CONFIG_ATOMIC128\n\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n#else\n\n        int mem_idx = cpu_mmu_index(env, false);\n\n        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);\n\n\n\n        Int128 v = int128_make128(low, high);\n\n        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);\n\n#endif\n\n    } else {\n\n        check_alignment(env, addr, 16, ra);\n\n\n\n        cpu_stq_data_ra(env, addr + 0, high, ra);\n\n        cpu_stq_data_ra(env, addr + 8, low, ra);\n\n    }\n\n}\n", "idx": 6408, "substitutes": {"env": ["context", "worker", "ex", "ext", "vm", "eu", "np", "nc", "end", "proc", "db", "queue", "e", "loader", "enc", "exc", "er", "exec", "server", "ea", "que", "args", "org", "buf", "esc", "energy", "conn", "vs", "ep", "config", "ev", "vag", "viron", "ef", "txt", "net", "eng", "init", "engine", "ctx", "chal", "path", "console", "ah", "Environment", "ec", "en", "req", "qa", "cache", "err", "esp", "erv", "code", "eni", "here", "anne", "state", "qt", "priv", "conf", "enh", "environment", "dat"], "addr": ["pos", "nc", "ext", "worker", "index", "oa", "dist", "ady", "loc", "alt", "ord", "len", "ea", "ha", "arm", "src", "adder", "org", "amd", "pad", "seq", "ace", "offset", "config", "device", "usr", "id", "rr", "ip", "dd", "ass", "ctx", "alpha", "address", "host", "pointer", "cpu", "mac", "nr", "hw", "pkg", "sta", "coord", "ad", "ar", "x", "uri", "arch", "dr", "eni", "osi", "amp", "la", "anne", "gru", "edge", "attr", "grad", "cmp", "ptr", "align", "work", "access", "adr", "base"], "low": ["pos", "new", "from", "small", "end", "scale", "loc", "good", "le", "len", "open", "server", "Low", "mid", "flow", "last", "up", "old", "offset", "hi", "lower", "off", "lim", "l", "lo", "little", "quick", "address", "next", "range", "start", "min", "light", "size", "lc", "level", "ra", "zero", "slow"], "high": ["pen", "index", "end", "diff", "name", "alt", "limit", "higher", "open", "p", "mid", "High", "last", "full", "highest", "up", "inc", "big", "h", "r", "hi", "remote", "pop", "top", "large", "lim", "maximum", "asc", "path", "range", "max", "min", "upper", "master", "peak", "bound", "pe", "close", "release", "round"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n", "idx": 6432, "substitutes": {"dstU": ["sstsM", " dstI", "dstUR", "dSTP", "dstsU", "dspP", "dSTUR", "dspU", "sstsU", " dSTI", "sstsV", "dspM", "dstM", "dstI", "dsrcU", "destU", "dSTM", "dsrcM", " dSTM", "dSTI", "dSTUV", "destUR", " dSTU", " dstM", "dspUV", "sstV", "dsrcUV", "dstsUV", " dSTV", "sstsUR", "dSTV", " dstUV", "dstsV", "dsrcP", "dSTU", "destM", "destV", "dstsI", "dstP", " dSTP", "destUV", "dstsM", "dstsUR", "sstUR", "destI", "sstU", " dstP", "sstM", " dSTUV", "dstUV"], "dstV": [" dstI", "dsrcv", " dstv", "dsrcV", "drcV", "dstsU", "drcI", "idstsV", "drcUV", "idstU", " dsrcB", "DsrcI", "ddestV", "idstI", " dstB", "dsrcVI", "drcVI", "dstI", "DstI", " dsrcV", "dstsv", "dsrcU", "destU", "ddestI", "dscUV", "idstsU", "ddestB", " dsrcv", "dsrcB", "dsrcUV", "dscV", "idstsI", "dscVI", "dstsV", "DstV", "dscI", "dsrcI", "idstsv", " dsrcI", "dstsB", "destV", "DsrcV", "DsrcVI", "idstV", "dstsI", "dstVI", "destI", "DsrcUV", "destv", "DstVI", "idstv", "dstB", "DstUV", "ddestv", "dstv", "dstUV"], "src1": ["sourceOne", "url2", "source3", " src3", "source0", "proc1", " src01", "distV", "sourceA", "rc3", "srcV", "src3", "url1", "rcU", "source1", "rcV", "url01", "url3", "srcone", "rc0", "src100", " srcV", " srcone", " srcA", "procOne", "source2", "imgone", "sourceU", "dist2", "src01", "dist1", "img100", "rc01", "src0", "img1", " src100", "rcA", "srcU", " srcU", " src0", "dist0", "rc1", "procone", "rc2", "proc100", "imgOne", "srcA", " srcOne", "srcOne", "rcOne"], "src2": ["rc02", "src4", "srcV", "img2", "rcV", "source1", "rc0", "source4", " srcV", "source2", " src02", " src4", "img0", "src02", "src0", "img1", "rc4", " src0", "source02", "rc1", "rc2", "imgV"], "i": ["bi", "ui", "pi", "index", "k", "j", "di", "diff", "e", "d", "multi", "fi", "ti", "p", "uli", "vi", "api", "slice", "h", "phi", "qi", "ii", "adi", "hi", "u", "ji", "id", "n", "l", "ip", "abi", "var", "child", "temp", "c", "m", "init", "t", "ix", "oi", "zi", "io", "start", "ri", "ini", "info", "o", "gi", "mu", "xi", "x", "uri", "it", "ci", "eni", "lc", "z", "length", "b", "iu", "count", "I", "ai", "v", "si", "li"]}}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){\n\n    int i,j,xy,yz;\n\n    int res;\n\n    for(i=0; i<8; i++){\n\n        for(j=1; j<7; j++){\n\n            xy = j * stride + i;\n\n            yz = j * 8 + i;\n\n            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];\n\n            res +=2;\n\n            res >>=2;\n\n            dest[xy] = (uint8_t)res;\n\n        }\n\n    }\n\n}\n", "idx": 6452, "substitutes": {"dest": ["data", "Dest", "flat", "wb", "outer", "target", "dist", "end", "proc", "trans", "d", "super", "slice", "done", "dep", "destroy", "test", "img", "later", "die", "usr", "cdn", "cont", "class", "rest", " Dest", "dc", "tr", "opt", "source", "sort", "master", "parent", "coord", "comb", "route", "gen", "desc", "output"], "src": ["data", "split", "reverse", "rc", "stack", "conv", "url", "gb", "dist", "loc", "trans", "sb", "slice", "gz", "sc", "seq", "support", "img", "image", "config", "inf", "impl", "sr", "rest", "init", "st", "cur", "sup", "source", "sort", "inst", "start", "supp", "bin", "ssl", "sl", "size", "sub", "rb", "b", "desc", "attr", "grad", "cb", "comp", "stream", "spec", "rob"], "stride": ["striider", "strange", "striding", "constiding", "STRide", "etride", " striding", "etrider", "Stride", "constider", "constide", "striide", " strange", "STRid", "strision", "strider", "STRision", "Strid", " strider", "strid", "Strision", "striange", "striiding", "etrid", "etrision", "constange", "STRider", "Strider"], "i": ["ui", "bi", "y", "pi", "index", "ie", "e", "d", "ik", "li", "p", "h", "jit", "mi", "is", "phi", "qi", "ii", "r", "u", "ji", "ind", "id", "ni", "jp", "ip", "l", "m", "c", "ori", "oi", "f", "zi", "start", "a", "ri", "ini", "im", "x", "xi", "ci", "eni", "z", "b", "iu", "I", "ai", "v", "si"], "j": ["py", "y", "k", "ie", "aj", "e", "jc", "p", "zip", "jl", "ij", "qi", "ii", "u", "ji", "dj", "n", "jp", "l", "ni", "jo", "m", "v", "dy", "ori", "g", "f", "ja", "jet", "uj", "jen", "o", "it", "job", "z", "js", "b", "q", "oj", "jj", "J", "x", "li"], "xy": ["py", "data", "pos", "zy", "pick", "index", "ie", "gb", "loc", "e", "yy", "yt", "fx", "val", "XY", "p", "rx", "zip", "wx", "quad", "gz", "xx", "nz", "orig", "seq", "phi", "biz", "ii", "vec", "ji", "dj", "id", "zx", "dy", "ori", "px", "f", "zi", "syn", "xe", "xxx", "info", "qq", "coord", "phy", "xxxxxxxx", "code", "rez", "exe", "z", "comp", "wy", "x"], "yz": ["flat", "zy", "y", "ie", "sq", "kid", "loc", "rep", "az", "yy", "ny", "iaz", "yt", "fi", "sky", "rx", "wx", "zip", "cz", "yi", "gz", "rh", "nz", "xx", "biz", "qi", "ii", "yx", "resp", "zon", "xs", "ji", "dj", "dim", "obj", "axy", "zx", "resolution", "dy", "des", "ori", "ix", "zi", "iz", "uj", "req", "info", "err", "xxx", "score", "qq", "eni", "isi", "ez", "rez", "zh", "z", "zz", "js", "jing", "eddy", "rt"], "res": ["pos", "re", "ress", "ras", "result", "rep", "rss", "len", "val", "cons", "rx", "arr", "ps", "seq", "powers", "vs", "r", "resp", "cs", "Rs", "vec", "ret", "reg", "rex", "rates", "rows", "ops", "resolution", "css", "des", "cr", "ms", "rev", "ries", "min", "vals", "req", "err", "ver", "rez", "rem", "z", "js", "es", "pres", "ris", "RES", "eps", "results", "os", "Res", "nos", "rs", "x"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                  %0, %%\"REG_a\"         \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq  (%1, %%\"REG_a\",2), %%mm0             \\n\\t\"\n\n        \"movq 8(%1, %%\"REG_a\",2), %%mm1             \\n\\t\"\n\n        \"psrlw                $8, %%mm0             \\n\\t\"\n\n        \"psrlw                $8, %%mm1             \\n\\t\"\n\n        \"packuswb          %%mm1, %%mm0             \\n\\t\"\n\n        \"movq              %%mm0, (%2, %%\"REG_a\")   \\n\\t\"\n\n        \"add                  $8, %%\"REG_a\"         \\n\\t\"\n\n        \" js                  1b                    \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src+width*2), \"r\" (dst+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++)\n\n        dst[i]= src[2*i+1];\n\n#endif\n\n}\n", "idx": 6455, "substitutes": {"dst": [" dsc", "dsbl", " dbl", "adST", " dST", "ssp", "fsrc", "dST", "adbl", " dsts", "dsrc", "lsrc", " dsp", "dsST", "sST", "dssc", "lsts", "sst", "lst", "idsrc", "dbl", "dsp", "fST", "fsp", "idsts", "adsc", "fsts", "dsst", "idst", "dsts", "adst", "fst", "idsp", "dsc", "ssts", "lsp"], "src": ["rc", "sth", "ruby", "url", "sq", "dist", "gb", "loc", "sb", "sur", "reflect", "sync", "slice", "gz", "sc", "support", "img", "dest", "config", "lib", "sr", "rest", "sh", "st", "gl", "ctx", "sup", "source", "inst", "secure", "ssl", "sl", "filename", "scripts", "rib", "sub", "rb", "rect", "attr", "rl", "grad", "cb", "ins", "bs", "sel"], "unused": ["unprotected", "munchecked", " unprotected", "unsprotected", "unsusing", " unchecked", "unsused", "munusing", "unschecked", "munused", " unusing", "unchecked", "unusing", "munprotected"], "i": ["bi", "ui", "pi", "index", "k", "j", "di", "si", "d", "e", "multi", "fi", "ti", "p", "vi", "h", "phi", "qi", "ii", "hi", "u", "id", "n", "l", "ni", "ip", "c", "m", "init", "t", "ix", "oi", "f", "zi", "page", "io", "start", "ri", "ini", "info", "hei", "gi", "o", "xi", "w", "it", "mu", "ci", "z", "length", "b", "iu", "in", "count", "I", "ai", "v", "x", "li"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n", "idx": 6486, "substitutes": {"i": ["ui", "bi", "y", "pi", "index", "ie", "j", "di", "e", "d", "multi", "fi", "ti", "p", "li", "yi", "slice", "ski", "mi", "qi", "ii", "module", "u", "inner", "id", "n", "l", "ni", "ip", "s", "abi", "m", "c", "init", "ix", "ori", "oi", "f", "io", "ri", "ini", "info", "o", "it", "gi", "xi", "iv", "uri", "x", "ci", "eni", "lc", "b", "in", "iu", "I", "ai", "v", "si"], "encoded": ["Enccoded", "engoded", "Encoding", "encoding", "Encoded", "enoded", "encoder", "engcoded", "decode", "deccoded", "inccoded", "enccoded", "incored", "decored", "decoder", "enored", "decoded", "engoding", "coder", "enoding", "coding", "enode", "Encode", "incoding", "coded", "encode", "decoding", "engoder", "ccoded", "incoded", "Encoder", "encored", "Encored", "enoder"], "test_cases": ["testslines", "test_scripts", "test__ases", "casestimes", "testscases", "testing_ases", "testing_tests", "testingscases", "test__cases", "test67scripts", "testing_errors", "teststimes", "example67scripts", "test_errors", "test_case", "testing_case", "testingstimes", "case_times", "testplecomments", "testalltests", "testencodes", "teststests", "test_comments", "test_tests", "testplecase", "case_case", "testencases", "example67case", "testingslines", "testscase", "testing_cases", "test___tests", "example_comments", "case_tests", "casestests", "test_lines", "testingstests", "test_codes", "test_times", "test_ases", "test67cases", "testalltimes", "testplecases", "testplescripts", "test__codes", "test___cases", "test67case", "example_scripts", "case_cases", "casescase", "testing_codes", "testing_times", "example_case", "testencase", "testing_lines", "testalllines", "testallcases", "test___errors", "example67comments", "testenases", "example67cases", "casescases", "test___case", "example_cases", "test__case", "test67comments"], "qint": ["quin", "questin", " qnt", "qstr", "quinc", "qainter", "qualpoint", " qinc", "qashort", "qpoint", "qqx", "qvert", "quaddress", "sqINT", "qnt", "xind", "shobject", "qunt", "questpoint", "requINT", "qinter", "eqinter", "qqind", "qqinc", "requint", " qinteger", "queryint", "eqint", "qualin", "qux", " qx", "qqint", "qext", "shint", "queryext", "qx", "questaddress", " qobject", " qort", "quint", "qaddress", "queryort", "qaext", "queryINT", "xint", "qupoint", "qaint", "qin", " qINT", "queryinter", "sqvert", "qobject", "requvert", "shINT", "qort", "qinteger", "qshort", "sqint", "questint", "qqnt", "queryshort", "xinc", "qind", "qINT", "eqshort", " qstr", " qind", "requinteger", "qqstr", "qualaddress", "qinc", " qvert", "qualint", "xstr", "sqinteger", "queryobject", "eqext"], "str": ["data", "br", "strip", "name", "text", "enc", "coll", "val", "er", "arr", "type", "style", "hr", "sc", "pr", "r", "Str", "cs", "sp", "STR", "id", "voc", "dict", "obj", "s", "txt", "sr", "c", "st", "stri", "cur", "cr", "tr", "pass", "err", "sl", "kr", "fr", "code", "dr", "iter", "doc", "rs", "strike", "spec"]}}
{"project": "FFmpeg", "commit_id": "951e715cebfaffced7f13c1525771ff917fe1d38", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489, "substitutes": {"arg": ["rc", "ref", "asm", "argument", "param", "play", "enc", "val", "fi", "p", "arr", "args", "ace", "inc", "ang", "AR", "par", "Args", "abc", "var", "inter", "arc", "mor", "g", "ig", "as", "array", "or", "parse", "ad", "ar", "emb", "Ar", "amp", "ray", "like", "ag", "Arg", "util"], "is": ["isc", "api", "vs", "id", "ip", "s", "ops", "any", "init", "IS", "ori", "ar", "uri", "Is", "has", "in", "serv", "are", "ui", "ie", "ais", "get", "the", "iris", "app", "ses", "ii", "ic", "iso", "ss", "his", "iz", "or", "inst", "parse", "ini", "its", "sis", "isi", "mis", "es", "http", "ai", "iss", "isl", "sys", "ls", "full", "image", "css", "obs", "us", "kit", "it", "im", "see", "lis", "active", "bs", "ist", "vis", "irc", "si", "rid", "nis", "op", "isin", "isa", "il", "mes", "ms", "as", "bis", "ri", "ir", "i", "info", "eni", "bits", "esi", "ics", "ris", "os"], "frame": ["note", "layout", "ref", "element", "frames", "view", "document", "fi", "shot", "game", "fe", "window", "slice", "session", "flow", "iframe", "rame", "image", "config", "ze", "line", "fb", "file", "fake", "plane", "video", "block", "picture", "boot", "host", "f", "force", "draw", "point", "Frame", "model", "part", "parent", "fab", "za", "fram", "fr", "live", "state", "series", "node", "setup", "feature", "cycle", " Frame", "framework", "thread", "base"], "pts_int": ["pts1bit", "ptsets_int", "pts_inter", "pts1full", "ptsets_full", "pts_str", "pts1int", "ptts_long", "pts_bit", "ptsets_bit", "pts_full", "ct\n", "ptts_str", "pt\n", "ptts_int", "pts_long", "PT\n", "point\n", "ptts_inter"], "pts": ["ctd", "ptd", "periods", " prefsi", "periodcount", "ctsets", "periodS", " ptsets", "ptcount", "PTd", "ptls", " ptsi", "ptS", "periodd", "PTcount", "ctS", " prefls", "ctls", "PTS", "ctcount", "ctsi", " prefsets", "PTs", "ptsi", " prefs", "cts", "ptsets", " ptls"], "ret": ["let", "hash", "re", "ref", "def", "mt", "result", "fun", "alt", "att", "back", "len", "val", " Ret", " RET", "mem", "arr", "seq", "conn", "RET", "resp", "reg", "id", "res", "ut", "obj", "rot", "fin", "opt", "rev", "lit", "cat", "part", "feat", "gt", "det", "ft", "match", "nt", "reply", "status", "rets", "Ret", "rt"], "graph": ["context", "pool", "scope", "layout", "closure", "google", "proxy", "stack", "ghost", "hou", "pg", "gpu", "view", "document", "hub", "dot", "widget", "container", "ha", "connection", "facebook", "session", "flow", "h", "conn", "image", "module", "bridge", "config", "query", "connect", "go", "man", "growth", "gd", "g", "raph", "path", "draw", "network", "gp", "group", "model", "parent", "cache", "gh", "hog", "Graph", "edge", "shadow", "shape", "node", "gen", "complex", "grad", "tree", "gener", "stream", "feed"], "filt_out": ["facet_in", "fft_external", "flt_work", "filt_list", "failJin", "facet_out", "fft_out", "filtJstring", "facet_list", "filt_Out", "flt_out", "filt_string", "filtJin", "failJref", "filt_work", "filt_in", "fft_string", "filt_external", "filterstring", "filtJout", "filterout", "filt_ref", "fail_string", "fail_out", "filterexternal", "failJout", "fail_ref", "filtJref", "fail_in", "flt_Out", "flt_in", "failJstring"], "pos": ["pose", "data", "sum", "depth", "pc", "index", "ref", "vis", "neg", "rel", "alt", "len", "val", "str", "POS", "args", "src", "bl", "type", "pid", "bit", "style", "seq", "offset", "channel", "position", "obj", "block", "Pos", "rot", "lat", "fs", "pt", "pointer", "prop", "padding", "start", "vals", "part", "slot", "cache", "points", "axis", "code", "cap", "col", "po", "doc", "os", "conf", "count", "body", "port", "spec", "base"], "pkt": ["bkt", "pft", "Pct", "bft", "Packet", "pbacket", "packet", "pct", "Pft", "pbct", "bct", "backet", "pbft", "pbkt", "Pkt"], "picref": ["nicre", "icRef", "PicRef", "icreference", "licreference", "fcref", "chatref", "picREF", " picrel", "pictreference", "picalt", "picror", "picrel", "icref", "PicREF", "Picrel", "Picre", "licRef", "pcrel", "synreference", "pcalt", "cusre", "pinror", "cusreference", "fcreference", "chatreference", "picRef", "cusref", "nicreference", "Picreference", "cusREF", "licref", "pinreference", " picREF", "nicref", "chatrel", "fcrel", "pcRef", "pictREF", "icror", "icrel", "picre", "synRef", "pinref", "synref", "synrel", "pinrel", "pictalt", "chatror", "picreference", "licrel", "pcref", "pcreference", "pinalt", "fcRef", "Picref", "nicREF", "Picalt", " picreference", " picalt", "pictref"], "tb": ["atzb", "ptbm", "tbm", "atbs", "ptbs", "ttzb", "ttb", "itp", " tbl", "tzb", "tbl", "ctb", "tp", "btb", "itb", "ttbs", " tbs", " ptb", " ptbm", "atb", "atz", "ttz", "btzb", " ptbs", "tbs", "itbl", " tbm", "itbs", "ctp", "btz", "ctbs", "ctbl", " tp", "ptb", "btbs", "tz"]}}
{"project": "qemu", "commit_id": "e13e973eedba0a52b4b8b079c4b85cdc68b7b4f0", "target": 1, "func": "static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n", "idx": 6500, "substitutes": {"dev": ["av", "data", "local", "Dev", "dn", "pub", "def", "di", "de", "bus", "development", "rad", "d", "ve", "debug", "self", "game", "dom", "DEV", "app", "conn", "test", "ev", "ch", "die", "device", "ds", " device", "Device", "plug", "dd", "block", "temp", "mode", "m", "v", "engine", "home", "des", "dc", "usb", "comment", "mod", "serial", "hw", "req", "der", "info", "w", "ver", "o", "ad", "md", "dm", "pack", "grad", "dem", "conf", "serv", "gu", "driver"], "s": ["an", "sq", "e", "d", "si", "sb", "plugins", "server", "sys", "self", "p", "sync", "native", "ls", "session", "S", "h", "ps", "is", "ses", "site", "cs", "r", "gs", "service", "sf", "ds", "sets", "u", "n", "l", "states", "ss", "m", "sg", "ts", "services", "c", "v", "sym", "fs", "g", "f", "ns", "us", "a", "ssl", "settings", "south", "i", "sl", "o", "w", "its", "sv", "js", "b", "es", "su", "in", "vs", "http", "os", "conf", "qs", "rs", "spec"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n", "idx": 6507, "substitutes": {"opaque": ["Opaques", " opque", "opencache", "opcache", "Opcache", "openaques", "opacity", " opacre", " opcache", "opacre", "openaque", "opaques", "openacity", "ipque", "Opaque", "ipacre", "OPque", "OPaque", "ipaque", "OPaques", "opque", " opacity", "OPacre", "ipaques", " opaques", "Opacity"], "pob": ["tOB", "psemb", "Pub", "Poo", "pub", "pab", "poo", "ipib", "opob", "opOB", " pore", "spoo", "opab", "Pib", "Pore", "psob", " pab", "spib", "spob", "Pob", "spab", "Pab", "pore", "pemb", " pub", " pemb", "pOB", "opoo", " pOB", "POB", "psOB", "opub", "ipob", "ipore", "ipab", " pib", "opib", "tob", "tab", "psab", "tib", "Pemb", "pib"]}}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n\n{\n\n    int i, j, t, rconpointer = 0;\n\n    uint8_t tk[8][4];\n\n    int KC = key_bits >> 5;\n\n    int rounds = KC + 6;\n\n    uint8_t log8[256];\n\n    uint8_t alog8[512];\n\n\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n\n        j = 1;\n\n        for (i = 0; i < 255; i++) {\n\n            alog8[i] = alog8[i + 255] = j;\n\n            log8[j] = i;\n\n            j ^= j + j;\n\n            if (j > 255)\n\n                j ^= 0x11B;\n\n        }\n\n        for (i = 0; i < 256; i++) {\n\n            j = i ? alog8[255 - log8[i]] : 0;\n\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n\n            j = (j ^ (j >> 8) ^ 99) & 255;\n\n            inv_sbox[j] = i;\n\n            sbox[i] = j;\n\n        }\n\n        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n\n                     log8, alog8, inv_sbox);\n\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n\n                     log8, alog8, sbox);\n\n    }\n\n\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n\n        return -1;\n\n\n\n    a->rounds = rounds;\n\n\n\n    memcpy(tk, key, KC * 4);\n\n\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n\n        t += KC * 4;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n\n        tk[0][0] ^= rcon[rconpointer++];\n\n\n\n        for (j = 1; j < KC; j++) {\n\n            if (KC != 8 || j != KC >> 1)\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= tk[j - 1][i];\n\n            else\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n\n        }\n\n    }\n\n\n\n    if (decrypt) {\n\n        for (i = 1; i < rounds; i++) {\n\n            av_aes_block tmp[3];\n\n            tmp[2] = a->round_key[i];\n\n            subshift(&tmp[1], 0, sbox);\n\n            mix(tmp, dec_multbl, 1, 3);\n\n            a->round_key[i] = tmp[0];\n\n        }\n\n    } else {\n\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6509, "substitutes": {"a": ["an", "ak", "am", "aj", "au", "ab", "aka", "e", "att", "ae", "na", "ai", "ea", "A", "p", "ata", "api", "cha", "app", "ace", "img", "acs", "ack", "at", "ka", "ap", "c", "aux", "ta", "alpha", "asa", "f", "wa", "sa", "as", "qa", "sta", "ad", "ar", "ca", "ga", "aaa", "va", "la", "ac", "ama", "ia", "b", "aa", "access", "window"], "key": ["ak", "keys", "mix", "k", "seed", "text", "e", "input", "enc", "ik", "self", "p", "zip", "ce", "kw", "pair", "conn", "ace", "channel", "ki", "crypt", "sign", "ip", "temp", "ek", "entry", "mac", "cache", "w", "table", "fee", "uk", "code", "Key", "ok", "q", "ke", "row", "ee", "v"], "key_bits": ["keyingbytes", "enc_nos", "key_locks", "Key_bytes", "keydbits", "enc___nos", "key_nos", " key_values", "key_bytes", "enc_bit", "Key_bits", "Key_locks", "keydvalues", "enc_boot", "keyingbits", "key64ops", "key64bytes", "key_ops", "keydbit", "enc_flags", "key_bit", "key_values", "key_pieces", "enc___bits", "enc_bytes", "key_boot", "keydbytes", "key___boot", " key_bit", "enc___bit", " key_ops", "keyingflags", "key___bits", "key_flags", "enc___boot", "key64pieces", "keyinglocks", "enc_bits", " key_bytes", "key___bit", "key64bits", "key___nos", "Key_flags", " key_pieces"], "decrypt": ["dcrypt", "descrypt", " deccrypt", "dccrypt", " dectext", "dctext", "desccrypt", "deccrypt", " decenc", "dectext", "descenc", "decenc", "dcenc", "desctext"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "di", "e", "d", "ik", "multi", "fi", "ti", "p", "vi", "yi", "api", "mi", "ij", "phi", "qi", "ii", "u", "ji", "id", "n", "l", "ni", "ip", "ami", "m", "c", "ix", "ori", "oi", "f", "zi", "io", "g", "ri", "ini", "info", "o", "gi", "it", "x", "xi", "uri", "ci", "eni", "z", "b", "in", "iu", "ia", "ani", "I", "ai", "v", "si", "li"], "j": ["data", "note", "y", "k", "ie", "aj", "si", "d", "e", "jc", "op", "p", "bj", "h", "jit", "jl", "ij", "pr", "ii", "ch", "ji", "dj", "n", "l", "jp", "ni", "obj", "jo", "m", "g", "f", "ja", "jet", "uj", "kj", "syn", "jen", "json", "o", "w", "x", "fr", "job", "z", "js", "b", "adj", "q", "oj", "body", "v", "J", "jj", "li"], "t": ["y", "k", "e", "d", "tn", "dt", "tp", "ti", "p", "T", "h", "test", "offset", "r", "tt", "u", "tips", "bot", "at", "n", "l", "s", "temp", "m", "c", "ts", "ta", "pt", "f", "te", "tm", "o", "w", "wt", "tim", "tc", "z", "b", "qt", "ot", "time", "tf", "v", "x", "tz"], "tk": ["tg", "ak", "tile", "k", "loc", "text", "ik", "oks", "tp", "tty", "ti", "zip", "kw", "K", "sc", "kk", "kin", "tt", "ask", "obb", "ijk", "tx", "tu", "txt", "temp", "ek", "unk", "c", "ss", "ta", "dc", "tr", "tw", "kt", "tm", "mk", "kit", "tip", "dk", "it", "kn", "wt", "kr", "inch", "uk", "awk", "tc", "km", "table", "tek", "sw", "cf", "DC", "su", "sk", "qt", "tf", "cut", "window", "spec", "tz"], "log8": ["log08", "log2", "alog32", "log4", " log7", " logor", "alog84", "Log16", "LOG88", "alog0", " log2", "core8", "Log5", "LOG5", "logor", " log08", "lim08", " log32", "core6", " log88", " log0", " log5", "alog7", "LOG2", "core88", "LOG84", "alog08", " log6", "log32", "limor", "Log9", "log9", "Log8", "log16", "log84", "Log0", "Log4", " log4", "lim32", "log88", " log16", "Log32", "alog16", "lim8", "LOG6", "log0", "log5", "alogor", " log84", "log6", " log9", "log7", "LOG9", "LOG7", "LOG4", "core2", "LOG8"], "alog8": ["alog84", "alg08", "aph9", " catalogoy", "aph8", "alogoo", " analog8", "lang08", "aph84", "og8", "lang88", "ateg18", " catalog9", " catalog8", "acl88", "ologoo", "ateg88", "LOGoo", "imgoo", "ateg8", "img8", "aug18", "abc8", "olog08", "abc08", "core8", "olog8", " analog08", "alog7", " analog9", "alog08", "aug88", "alog48", "acl48", "alg8", "config8", "lang8", "alog9", "img9", "core08", "alg7", "acloo", "acl8", "LOG48", "lang9", "config08", "aug8", " catalog84", " analog88", "og4", "acl9", "core9", "aphoy", "LOG9", "aug08", "img48", "configoo", " analogoy", "og08", "ateg08", "algoo", "abc7", "abcoo", "af8", "ogoo", "config7", "core88", "alog18", "af08", "alogoy", "acl08", " analog84", "alog88", "acl18", "af4", "alog4", "olog4", "LOG8", "afoo"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n", "idx": 6519, "substitutes": {"ysrc": ["umscur", "dssrc", "umssrc", "yssrc", "dsrc", "iessrc", "umsrc", "mysrc", "iesrt", "mysrs", "iesrc", "ysource", "ysrs", "yscur", "myscur", "dsrt", "iesrs", "ysrt", "mysrt", "myssrc", "mysource", "iesource", "umsource", "iescur", "dsrs"], "usrc": [" ussrc", "ausource", "usra", "uource", " usra", "umssrc", " usource", "ausrc", "urc", "vsource", "umsrc", "ura", "umsource", "vssrc", "usource", "ussrc", "umsra", "vsra", "aussrc", "ausra"], "vsrc": ["vsrb", "vsstat", "vrc", " vrb", "ust", "vst", "fsrc", "vrb", "urc", "lsrc", " vrc", "src", "udest", "sst", "lst", "vssrc", "ssrc", "vstat", "frc", "fstat", "frb", "vdest", "lrc", "sdest", " vstat", "ldest"], "dst": ["ldsc", " dsc", "cdst", " dsts", "dsrc", "adsrc", "Dsc", "Dsrc", "ldsts", "cdsc", "ldst", "ldsrc", " dsrc", "adsc", "cdsts", "dsts", "adst", "Dst", "dsc", "adsts", "cdsrc", "Dsts"], "height": ["ty", "data", "depth", "layout", "bottom", "dist", "Height", "d", "deep", "above", "pad", "image", "img", "id", "distance", "dim", "rows", "resolution", "hd", "alpha", "gap", "density", "inches", "padding", "duration", "crop", "stroke", "size", "border", "high", "shape", "length", "align", "window", "x", "angle"], "lumStride": ["lumaStro", "lnumSTride", "lumsterve", "lumStrip", "lumEstride", "lumStyro", "lnumSTro", "lumaSTride", "lumaSTrip", "lumaStride", "lumEstrite", "lumstride", "lumEstro", "lumaSterve", "lumstrip", "lumStyride", "lnumStrite", "lumaSTerve", "lumstrite", "lumStyrip", "lumstro", "lumaSTro", "lnumSTrite", "lumStro", "lnumStride", "lnumStro", "lumStrite", "lumSTride", "lumStyerve", "lumSterve", "lumSTerve", "lumSTrip", "lumSTro", "lumSTrite", "lumaStrip"], "chromStride": ["chromstride", "chromstide", "chromStrrip", "pixelStide", "opalStide", "opalStrip", "opalStrite", "opalSTrip", "chromstrite", "chromSTide", "chromSTride", "chromstro", "chromStro", "pixelSTro", "opalSTrite", "pixelSTide", "opalSTride", "pixelStrite", "opalSTide", "chromStrip", "chromSTrite", "chromStide", "chromSTro", "chromStrrite", "pixelSTride", "chromSTrip", "chromStrite", "pixelSTrite", "pixelStro", "opalStride", "chromStrride", "pixelStride"], "dstStride": ["dstRestr", "dscSTride", "dstSTride", "dscStride", "dststr", "dostStr", "dscStro", "dstSTro", "dstStr", "dststro", "dscStrip", "dscSTro", "dstRestride", "dstStrro", "dstStrip", "dscSTrip", "dstStrride", "dscStide", "dstSTrip", "dstRestide", "dostStrr", "dstStrr", "dostStrro", "dostStri", "dscSTide", "dstStide", "dstStrri", "dostStro", "dstRestrip", "dstStri", "dststri", "dstRestri", "dststride", "dostStride", "dstSTide", "dstRestro", "dstStro", "dostStrride", "dostStrri"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);\n\n    if (drc) {\n\n        drc_index = spapr_drc_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset, false);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));\n\n    }\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 6524, "substitutes": {"cs": ["CS", "nc", "pc", "gb", "ras", "wcs", "core", "cc", "cons", "sys", "sync", "ks", "ls", "cus", "ce", "ps", "sc", "vs", "acs", "ds", "cms", "ck", "c", "css", "ctx", "ix", "fs", "ns", "ec", "cache", "cf", "ca", "cn", "ci", "lc", "cas", "sk", "ics", "ced", "vc", "ces", "qs", "cing", "spec"], "fdt": ["fdp", "fednt", "vdn", "fedp", "FDT", "fdnt", "FDts", "fedn", "gradT", "ebtt", "fedt", "ldT", "iddtt", "dfp", "ebts", "dfn", "iddt", "vdts", "ldtn", "dfts", "gradts", "ldte", "iddtn", "dfnt", "dfT", "ldts", "fxt", "fxtn", "fxtt", "fdte", "fdts", "ldt", "iddte", "fdn", "ffnt", "ffp", "fft", "gradtt", "vdT", "fdT", "vdt", "ffn", "ebt", "fdtn", "FDn", "fdtt", "ebT", "gradt", "fxte", "ldtt", "FDt", "dft"], "offset": ["operation", "pos", "outer", "layout", "index", "reset", "seed", "set", "optional", "starting", "error", "loc", "limit", "annot", "trace", "open", "sync", "Offset", "slice", "position", "off", "iso", "include", "rot", "exclusive", "online", "unknown", "address", "shift", "padding", "location", "start", "phase", "part", "slot", "initial", "parent", "axis", "o", "prefix", "origin", "timeout", "length", "alias", "addr", "append", "missing", "fp", "align", "output"], "spapr": [" spapsr", "spampR", "spampr", "spAPR", "spapsr", "spapbr", "instapr", "spaxr", "instaprs", " spapsc", "instampr", " spapsR", "spampbr", "spAPr", "spAPrs", "spaxc", "spapnr", "spappc", "instamprs", "instampR", "spaxR", "spapsnr", " spapnr", "spapsR", "spapsc", "spapc", "spaprs", "instapR", "spappR", "spAPbr", " spapc", "spappnr", " spapR", "instampbr", "spapR", "spamprs", " spapsnr", "spappbr", "spappr", "spaxnr", "instapbr", "spapprs"], "cpu": [" CPU", "nc", "vm", "pc", "np", "proxy", "lb", "pai", "proc", "frame", "loader", "gpu", "component", "core", "cc", "mem", "GPU", "clock", "socket", "conn", "processor", "nic", "config", "device", "uci", "c", "instance", "prem", "ctx", "dc", "bc", "px", "boot", "thread", "platform", "gp", "hw", "cache", "fc", "cu", "cow", "chip", "cn", "lc", "pu", "node", "process", "cmp", "cp", "unit", "linux", "CP", "CPU"], "env": ["scope", "ext", "eu", "profile", "dir", "np", "oa", "e", "skin", "enc", "exc", "equ", "export", "core", "ea", "args", "style", "energy", "ev", "config", "visor", "viron", "ef", "estate", "path", "shell", "opt", "ec", "en", "err", "esp", "gui", "eni", "exe", "desc", "conf", "environment"], "pcc": ["cpcc", "Pcc", "Pcm", "ccca", "Pcca", "cCC", "ccc", "pcca", "ccm", "PCC", "cpcca", "pCC", "cpCC", "cpcm", "pcm"], "segs": ["seg", "peg", "megs", "persegm", "meg", "pegm", "persegs", "pegments", "pegs", "segments", "segm", "persegments", "megments", "perseg", "megm"], "page_sizes_prop": ["page_size_part", "page_sizes_property", "page_size_property", "page_size_prop", "page_sizes_pro", "page_size_pro", "page_sizes_part"], "page_sizes_prop_size": ["page_sizes_by_2", "page_sizes_by_size", "page_sizes_prop_g", "page_sizes_by_g", "page_sizes_by_len", "page_sizes_prop_len", "page_sizes_prop_2"], "pft_size_prop": ["pft_sec_list", "pft_sec_prop", "pft_size__property", "pft_size__prop", "pft_size__list", "pft_size__cp", "pft_size_list", "pft_size_property", "pft_size_cp", "pft_sec_cp", "pft_sec_property"], "drc": ["sdrs", "madRC", "drs", "dssrc", "Drc", "DRC", "psrc", "madsrc", " dpc", "bdsrc", "dsrc", "sdrc", "Drec", "bdrc", "ldpc", "Dsrc", "sdRC", "sdpc", "madrc", "Drs", "ldsrc", "dRC", " dsrc", " drs", "bdRC", "dpc", "dsRC", "ldrc", "bdrec", "madrec", "ldRC", "drec", " dRC", "dspc", "Dpc", "pRC", "prc"], "drc_index": ["dfc_value", "drc_name", "drc_ini", "drc2offset", "drc_Index", "duc_length", "dfc_name", "drc_offset", "duc_id", "drc2value", "dfc_ini", "duc_index", "drc_length", "drc2index", "dfc_len", "drc2name", "drc_value", "dfc_index", "dfc_Index", "drc_id", "dfc_offset", "drc_len"], "radix_AP_encodings": ["radix_page_encoderINGS", "radix_page_ENCoding", "radix_page_encodesings", "radix_page_encodesINGS", "radix_page_encODing", "radix_page_ENCODings", "radix_page_encODings", "radix_page_encODers", "radix_page_ENCODINGS", "radix_page_encodesing", "radix_page_ENCODers", "radix_page_encodesers", "radix_page_ENCoders", "radix_page_ENCODing", "radix_page_encoding", "radix_page_encoderers", "radix_page_encODINGS", "radix_page_encodings", "radix_page_ENCodINGS", "radix_page_encoders", "radix_page_encodINGS", "radix_page_encodering", "radix_page_encoderings", "radix_page_ENCodings"], "i": ["bi", "ui", "data", "j", "e", "interface", "multi", "ti", "p", "is", "qi", "ii", "u", "id", "n", "l", "ip", "c", "f", "io", "a", "it", "z", "in", "iu", "I", "v", "si"]}}
{"project": "qemu", "commit_id": "f94d18d6c6df388fde196d3ab252f57e33843a8b", "target": 0, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        xhci_ep_free_xfer(epctx->retry);\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 6532, "substitutes": {"epctx": ["epcontext", "epchan", "ekchan", "epcb", "epconfig", "epcache", "ipcb", "mpcf", "eplc", "mpctr", "evcb", "epscontext", "epslc", "ypconfig", "ypcontext", "ekcontext", "mpcontext", "epscb", "mprc", "ppcmp", "epsconfig", "eklc", "epcmp", "epstx", "Epcf", "yptx", "ekctx", "pptx", "evtx", "mpcoll", "Epchan", "epcf", "ekcoll", "ipcontext", "mplc", "epcoll", "epsctx", "ypcb", "ppcache", "epscmp", "epsrc", "ppcontext", "ypctx", " epcontext", "eptx", "mpcb", "mpchan", "mptx", " eprc", "evctx", "ipctx", "ekcache", "ipcmp", " epcoll", "mpctx", "pplc", "mpconfig", "ppctx", "epctr", " epcmp", " epctr", "evcontext", "Epctx", "ypcmp", "mpcmp", "ppcb", "ekctr", "mpcache", "Epcontext", "ekcf", "eprc"], "streamid": ["reamid", " streamID", "streamtype", "streamID", "reamId", "streamId", "reamID", "streamname", "pooltype", " streamname", "poolID", "poolId", "reamtype", "reamname", " streamId", " streamtype", "poolname", "poolid"], "xhci": ["xhsi", "xhsdc", "yhcci", "xxhco", "xhldc", "exehci", "xehcit", "workhcit", "xhldi", "xhlc", "wxhscci", "ixhdcli", "xhloci", "workhsdc", "ixhcli", "xhcci", "xvco", "workhsdi", "xxhcci", "yehcu", "xahcci", "xhcli", "exehoci", "workhscit", "xhmcli", "xhslc", "xhscit", "xhmcycle", "xhco", "ixhcycle", "xhsco", "yehcit", "xhscm", "xehco", "xvlc", "xvcm", "workhdc", "xbhcu", "xvcit", "yhcu", "xehni", "wxhsni", "xahni", "workhlc", "xehci", "xxhcm", "ixhcin", "xmcli", "yhcit", "xhdci", "xahci", "ixhdcycle", "xxhci", "xmcycle", "ixhdci", "xahcit", "workhsni", "xrhai", "xhdcycle", "xhcu", "wxhcci", "xxhsci", "exehdi", "xrhci", "ixhdcin", "xxhsco", "wxhni", "workhci", "xhcit", "xahai", "yehcci", "xbhcit", "xhcm", "xehcu", "xvci", "xhlci", "xhdcin", "xehcci", "xmci", "xhdc", "xhsni", "xehsi", "xrhni", "wxhsco", "exhci", "xbhci", "exhsi", "xhdcli", "xhmci", "xhddi", "xhsci", "xhllc", "xmcin", "xehdi", "xhai", "workhni", "exhdi", "yehci", "xhoci", "xvdi", "wxhci", "xhmcin", "xhdi", "xbhcci", "xahco", "wxhsci", "xvdc", "xehoci", "workhsai", "workhsci", "exehsi", "workhdi", "workhai", "xhdoci", "xxhscci", "xhsdi", "xrhcit", "xhdsi", "xhni", "xxhscm", "xhsai", "workhslc", "yhci", "xehcm", "xhscci", "wxhco", "xhcycle", "xhlsi", "exhoci", "xvcci", "ixhci", "xvcu", "xhcin"], "stctx": ["crconn", "epcontext", "crcontext", "stconn", "epconf", "stconf", "crconf", "stcontext", "artconn", "artconf", "crctx", "artctx", "epconn", "artcontext"], "xfer": ["xxporter", "xmer", "fxference", "xf", "axber", "xference", "yper", "workception", "helcer", "inFER", "crossher", "workger", "fuelFER", "fuelferred", "crossferred", "hardfer", "workf", "axferred", "sexference", "hardference", "lexber", "Xtransfer", "xxtransfer", "hardfort", "crossmer", "broadcer", " xber", "helference", "xferred", " xper", "xyter", "xtransfer", "xter", "axFER", "xber", "sexfr", "axference", " xtransfer", "yclude", "fxferred", " xpire", "sexfer", "swfer", "swfr", "xper", " xf", "axmer", "yter", "crosscer", "ymor", "Xcer", "xxFER", " xher", "ypire", "broadferred", "xfar", "xpire", "axclude", "Xfer", "xpper", "fxporter", "xxference", "xyfar", "wxfr", "lexmer", "xxter", "lexfer", " xporter", "crosspire", " xference", "helfer", "axfer", "xyfer", "lexference", " xclude", "crossference", "lexher", "fuelfer", "xception", "xxception", "Xfr", "yporter", "wxpire", "sexporter", "crossFER", "yference", "xclude", "Xporter", "xxfar", "workfer", "swger", "inporter", "Xfar", "interpper", " xmor", " xpper", "axpper", "Xference", "fxfer", "xxper", "inference", "xfr", "Xher", "xxfer", "crossfr", "lexf", "Xpire", "workporter", "lexporter", "crossper", "xxpire", "yher", "xger", "interfer", "xxferred", "wxcer", "broadfer", "ytransfer", "axher", " xger", " xter", " xcer", "workfr", "workference", "axcer", "xmor", "xFER", "swper", "axper", " xfr", "fuelporter", " xFER", "wxference", "broadpper", "xxher", "xcer", "crossger", "yger", "xyference", "helpire", "axpire", "yfer", "sexfort", "interference", "fxpper", "yfort", "infer", "fxper", "fxFER", "lexfr", "interper", "wxfer", "xxger", "Xter", " xception", "hardporter", "xporter", "workcer", "crosspper", "crossporter", "xfort", "xxmor", "XFER", "xher", "yfr", "axporter", "wxf", "axfr", "crossfer"], "ring": ["root", "link", "ref", "ng", "rss", "RP", "str", "orig", "binding", "pair", "rings", "remote", "RR", "reg", "file", "rr", "ig", "path", "range", "ING", "RW", "prefix", "amp", "Ring", "rw", "chain", "rs", "spec"], "ep": ["ext", "EP", "ream", "vp", "package", "e", "enc", "exec", "p", "eq", "mp", "dep", "peer", "Ep", "channel", "ever", "ev", "imp", "dp", "sp", "pipe", "ap", "eg", "ef", "env", "ip", "plug", "yp", "eng", "dc", "gap", "pp", "pkg", "ec", "gp", "wp", "lp", "amp", "cap", "elf", "eps", "fp", "cp", "ee"], "mfindex": ["mrfid", "umvinc", "mFopen", "mdfinc", "Mfnumber", " mfopen", "mfpinc", "mfname", "mFIndex", "umfdate", "mflevel", "MFindex", "mvindex", "mvdate", "MFnumber", "umvindex", "mfnumber", "Mfindex", "mfpid", "mfinc", " mrfopen", "umflevel", "mfwname", " mrfindex", "mfplevel", " mfid", "mrfIndex", "mrfindex", "MfIndex", "mfwnumber", "mFnumber", "mfpopen", "mFindex", "mfpIndex", "mfopen", "mfpdate", "umfindex", "MFIndex", "MFname", "mfwindex", "mdfdate", "mrfopen", " mrfIndex", "mvlevel", " mfIndex", "umvdate", "umfinc", "mfIndex", " mrfid", "mFname", "mfid", "mdflevel", "mfpindex", "umvlevel", "mfwIndex", "Mfname", "mvinc", "mdfindex", "mfdate", "mFid"], "length": ["total", "loc", "Length", "len", "style", "sequence", "load", "impl", "weight", "path", "duration", "padding", "size", "match", "shape", " lengths", "count", "ptr", "ength"], "i": ["pi", "end", "e", "d", "p", "h", "is", "id", "n", "l", "ip", "s", "c", "f", "ed", "io", "or", "start", "a", "info", "o", "list", "code", "z", "b", "I"]}}
{"project": "FFmpeg", "commit_id": "b04665ac028d26747396eaf4dbf9188225a6f2a1", "target": 0, "func": "static int opt_preset(const char *opt, const char *arg)\n\n{\n\n    FILE *f=NULL;\n\n    char filename[1000], tmp[1000], tmp2[1000], line[1000];\n\n    int i;\n\n    const char *base[3]= { getenv(\"HOME\"),\n\n                           \"/usr/local/share\",\n\n                           \"/usr/share\",\n\n                         };\n\n\n\n    for(i=!base[0]; i<3 && !f; i++){\n\n        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);\n\n        f= fopen(filename, \"r\");\n\n        if(!f){\n\n            char *codec_name= *opt == 'v' ? video_codec_name :\n\n                              *opt == 'a' ? audio_codec_name :\n\n                                            subtitle_codec_name;\n\n            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i],  i ? \"\" : \".\", codec_name, arg);\n\n            f= fopen(filename, \"r\");\n\n        }\n\n    }\n\n    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n\n              is_dos_path(arg))){\n\n        snprintf(filename, sizeof(filename), arg);\n\n        f= fopen(filename, \"r\");\n\n    }\n\n\n\n    if(!f){\n\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n\n        av_exit(1);\n\n    }\n\n\n\n    while(!feof(f)){\n\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n\n        if(line[0] == '#' && !e)\n\n            continue;\n\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n\n        if(e){\n\n            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);\n\n            av_exit(1);\n\n        }\n\n        if(!strcmp(tmp, \"acodec\")){\n\n            opt_audio_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"vcodec\")){\n\n            opt_video_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"scodec\")){\n\n            opt_subtitle_codec(tmp2);\n\n        }else if(opt_default(tmp, tmp2) < 0){\n\n            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);\n\n            av_exit(1);\n\n        }\n\n    }\n\n\n\n    fclose(f);\n\n\n\n    return 0;\n\n}\n", "idx": 6535, "substitutes": {"opt": ["tag", "pos", "ext", "options", "optim", "Opt", "optional", "url", "pot", "proc", "param", "loc", "alt", "cho", "enc", "key", "fi", "op", "ott", "type", "oc", "orig", "expr", "config", "usr", "altern", "option", "obj", "temp", "init", "path", "prop", "cat", "feat", "parent", "sl", "o", "prefix", "iv", "token", "comb", "attr", "iter", "term", "oss", "prot", "format"], "arg": ["extra", "ext", "sec", "url", "target", "end", "neg", "argument", "param", "input", "loc", "name", "enc", "key", "val", "exec", "call", "op", "p", "arr", "rg", "args", "slice", "ace", "image", "inc", "use", "config", "par", "file", "option", "word", "var", "inter", "entry", "arc", " argument", "g", "ig", "pass", "path", "parse", "other", "cat", "mac", "flag", "en", "ad", "ar", "al", "amp", "match", "lc", "item", "ge", "valid", "ac", "gen", "ag", "Arg", "doc", "ax", "star"], "f": ["xf", "func", "form", "fn", "fa", "y", "j", "field", "fun", "e", "d", "bf", "fi", "fe", "p", "rf", "df", "h", "full", "F", "r", "u", "sf", "fm", "fb", "file", "l", "n", "inf", "ef", "fd", "c", "m", "t", "fen", "fs", "g", "fc", "w", "o", "cf", "info", "fr", "lf", "uf", "ff", "z", "b", "found", "tf", "q", "fp", "feed", "v", "fl", "handler"], "filename": ["nm", "msg", "fn", "frame", "folder", "sample", "lace", "name", "bf", "theme", "nil", "type", "download", "file", "kl", "addin", "location", "uri", "dll", "fp", "ln", "binary", "audio", "phrase", "package", "loader", "message", "cli", "mpeg", "whatever", "config", "sf", "txt", "nl", "path", "kn", "verb", "size", "database", "job", "rb", "upload", "font", "directory", "jpg", "archive", "profile", "url", "Filename", "skin", "document", "len", "connection", "session", "buf", "generic", "image", "password", "word", "fd", "shell", "dyl", "feat", "json", "prefix", "length", "title", "wb", "figure", "loc", "metadata", "username", "fb", "fil", "il", "which", "source", "sheet", "lvl"], "tmp": ["pos", "folder", "area", "sample", "name", "mm", "ppa", "text", "api", "slice", "mp", "img", "file", "temp", "space", "duration", "tem", "fp", "v", "output", "data", "seed", "diff", "package", "param", "cli", "mobi", "kk", "test", "config", "sp", "csv", "fake", "txt", "path", "page", "start", "mk", "appy", "rb", "upload", "time", "tab", "pre", "buf", "image", "c", "home", "perm", "prefix", "pty", "cmp", "cp", "cpp", "py", "dir", "proc", "loc", "now", "tp", "tty", "zip", "src", "metadata", "username", "fb", "cdn", "video", "obj", "buffer", "source", "stuff", "cache", "md"], "tmp2": ["mpall", "txt4", "mpTwo", "mp5", "temp8", "txt1", "txt5", "tmp4", " tmp4", " tmp8", "cppTwo", "mp8", "temp1", "fakeTwo", "address2", "fake8", "txtall", " tmpall", "temp2", " tmp1", "mpout", "mp1", "tmp8", "tmpout", "tempTwo", "temp4", "cpp1", "fake1", "addressTwo", "fake2", " tmpout", "cpp2", "tmp5", "txt2", "tmpall", " tmp5", "mp4", "tmp1", "tmpTwo", "address1", "tempout", "mp2"], "line": ["link", "pos", "frame", "url", "end", "j", "error", "name", "loc", "e", "lines", "d", "LINE", "len", "co", "row", "call", "p", "out", "ne", "r", "cell", "file", "l", "n", "block", "word", "fd", "temp", "c", "m", "run", "entry", "buffer", "nl", "ine", "range", "page", "source", "el", "err", "lin", "user", "Line", "match", "code", "lf", "lc", "time", "ln", "v"], "i": ["bi", "ui", "y", "pi", "index", "k", "ie", "j", "di", "name", "e", "d", "si", "key", "multi", "fi", "ti", "p", "yi", "slice", "type", "phi", "qi", "ii", "hi", "u", "id", "n", "l", "ni", "ip", "s", "abi", "c", "m", "t", "ix", "oi", "zi", "page", "io", "start", "a", "ri", "ini", "part", "o", "gi", "mu", "xi", "it", "uri", "ci", "b", "iu", "count", "I", "ai", "v", "x", "li"], "base": ["extra", "root", "bi", "fa", "index", "frame", "ase", "url", "area", "pre", "param", "name", "handler", "key", "core", "p", "Base", "api", "pad", "ace", "config", "id", "file", "l", "block", "absolute", "temp", "based", "home", "run", "buffer", "nb", "space", "source", "array", "start", "cat", "part", "bin", "se", "cache", "ma", "prefix", "list", "ac", "store", "b", "null", "tree", "http", "chain", "body", "v", "bas"], "codec_name": ["codec_id", "codec2type", "codec_key", "codef_type", "codef_id", "codef_name", "codec2name", "codec_anc", "codenc_key", "codenc_name", "codecsname", "codec2key", "codecskey", "codef_key", "codenc_type", "codecsanc", "codenc_anc", "codec2id", "codecstype", "codec_type"]}}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n", "idx": 6543, "substitutes": {"s": ["sq", "aws", "e", "sb", "sys", "self", "p", "spec", "ls", "S", "ps", "sc", "ses", "qs", "cs", "gs", "r", "service", "sf", "ds", "sp", "xs", "types", "n", "l", "ss", "c", "m", "ts", "t", "sg", "ctx", "services", "f", "ns", "sa", "us", "a", "ssl", "se", "sl", "w", "o", "sis", "sv", "su", "b", "es", "bs", "os", "v", "rs", "si"], "g": ["tg", "cfg", "gm", "gb", "vg", "e", "pg", "rg", "p", "gc", "org", "gg", "gs", "reg", "m", "sg", "gd", "ig", "mc", "gp", "group", "w", "al", "ga", "ge", "G", "groups", "gu"], "asf": ["nasF", "assF", "assfs", "nasf", "AsF", "assfm", " ascf", "asfs", "Asfs", "asF", "ASF", "ASfm", "Ascf", "Asf", "nascf", "assf", "ASfs", "psf", "nasfs", " asF", " asfs", "ascf", "psfm", "ASf", "asfm", "psfs", "psF"], "pb": ["py", "ub", "wb", "uc", "pc", "lb", "np", "ref", "gb", "proc", "vp", "cp", "db", "ab", "bf", "ppa", "asm", "pg", "sb", "pl", "hub", "tp", "typ", "p", "bm", "api", "mp", "metadata", "pa", "meta", "dp", "fb", "jp", "hp", "obj", "ctx", "bc", "pm", "summary", "ib", "platform", "primary", "pp", "prop", "eb", "wp", "gp", "cv", "pkg", "fc", "PB", "lp", "bh", "uf", "lc", "bp", "rb", "xb", "b", "cb", "fp", "pd", "cpp", "parser", "prot", "bps", "rob"], "i": ["bi", "ui", "index", "pi", "k", "j", "di", "e", "d", "si", "gu", "len", "multi", "fi", "ti", "p", "h", "mi", "phi", "qi", "ii", "r", "ki", "hi", "uni", "ji", "ind", "id", "n", "l", "ni", "chi", "ip", "ami", "c", "t", "oi", "f", "zi", "en", "ri", "ini", "gi", "mu", "xi", "uri", "ci", "z", "b", "in", "iu", "count", "I", "ai", "v", "x", "li"], "ret": ["data", "re", "rc", "ref", "def", "j", "result", "rep", "fun", "alt", "success", "att", "back", "error", "str", "val", "len", "mem", "bad", "bit", "RET", "r", "resp", "out", "reg", "usr", "res", "obj", "lit", "en", "flag", "info", "det", "ft", "utf", "match", "reply", "code", "job", "arg", "status", "rets", "Ret", "rt"], "name_len": ["named_ln", "passIPlen", "named___pos", "Name_val", "ni_pos", "name2pos", "passIPln", "name2val", "name___pos", "name_size", "name___length", "niJpos", "pass_len", "nameIPlen", "ni_Len", "name2len", "passIPval", "name_length", "named_len", "namevln", "ni_size", "key_len", "name_Len", "name_val", "nameIPln", "name_ln", "niJLen", "namevpos", "named___ln", "nameJsize", "key_ln", "Name_lf", "Name_length", "Name_Len", "name___ln", "name2Len", "named_length", "key_val", "nameIPval", "nameJpos", "nameIPlength", "pass_length", "Name_pos", "name_lf", "key_pos", "named___length", "nameJLen", "ni_len", "namevlen", "namevval", "pass_ln", "name___len", "name_pos", "nameJlen", "passIPlength", "Name_len", "niJlen", "named___len", "niJsize", "named_pos", "pass_val"], "type": ["py", "ty", "y", "ref", "url", "field", "pre", "value", "label", "ype", "key", "val", "typ", "none", "op", "p", "style", "order", "unit", "TYPE", "types", "id", "class", "t", "weight", "sort", "comment", "other", "part", "info", "o", "size", "pe", "like", "Type", "shape", "length", "attr", "kind", "time", "single", "null", "col", "rel", "format"], "val_len": ["val_l", "val_lin", " nameinglength", "val5span", " val_span", "Val_lan", "val5len", "val8len", "val_lan", "valinglin", "val2len", "val5lin", "val_size", " name_length", "valingl", "val_length", "valinglength", " nameinglen", " val_lin", "val_lf", "val2lin", "val2l", "val8span", " name_lin", " val_lf", " name_l", "val_span", "val5lf", "val2length", " nameinglin", "valinglen", "valnlen", "val8lin", "valnsize", "val8lf", "valnlan", "Val_len", "Val_size", " nameingl"], "name": ["data", "nm", "new", "member", "number", "def", "value", "label", "key", "val", "anc", "none", "call", "no", "image", "meta", "id", "n", "ni", "option", "Name", "word", "instance", "version", "address", "path", "description", "pass", "comment", "common", "part", "parent", "named", "info", "names", "size", "prefix", "o", "ame", "null", "NAME", "alias", "time", "missing", "x", "base"]}}
{"project": "qemu", "commit_id": "3f910692c287e1c611c00e763ebeb95ed0e017f8", "target": 1, "func": "static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n\n                          void *data, uint32_t length, uint64_t offset)\n\n{\n\n    int ret = 0;\n\n    void *buffer = NULL;\n\n    void *merged_sector = NULL;\n\n    void *data_tmp, *sector_write;\n\n    unsigned int i;\n\n    int sector_offset;\n\n    uint32_t desc_sectors, sectors, total_length;\n\n    uint32_t sectors_written = 0;\n\n    uint32_t aligned_length;\n\n    uint32_t leading_length = 0;\n\n    uint32_t trailing_length = 0;\n\n    uint32_t partial_sectors = 0;\n\n    uint32_t bytes_written = 0;\n\n    uint64_t file_offset;\n\n    VHDXHeader *header;\n\n    VHDXLogEntryHeader new_hdr;\n\n    VHDXLogDescriptor *new_desc = NULL;\n\n    VHDXLogDataSector *data_sector = NULL;\n\n    MSGUID new_guid = { 0 };\n\n\n\n    header = s->headers[s->curr_header];\n\n\n\n    /* need to have offset read data, and be on 4096 byte boundary */\n\n\n\n    if (length > header->log_length) {\n\n        /* no log present.  we could create a log here instead of failing */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    if (guid_eq(header->log_guid, zero_guid)) {\n\n        vhdx_guid_generate(&new_guid);\n\n        vhdx_update_headers(bs, s, false, &new_guid);\n\n    } else {\n\n        /* currently, we require that the log be flushed after\n\n         * every write. */\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n\n\n    /* 0 is an invalid sequence number, but may also represent the first\n\n     * log write (or a wrapped seq) */\n\n    if (s->log.sequence == 0) {\n\n        s->log.sequence = 1;\n\n    }\n\n\n\n    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n\n    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;\n\n\n\n    aligned_length = length;\n\n\n\n    /* add in the unaligned head and tail bytes */\n\n    if (sector_offset) {\n\n        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n\n        leading_length = leading_length > length ? length : leading_length;\n\n        aligned_length -= leading_length;\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;\n\n    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);\n\n    if (trailing_length) {\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors += partial_sectors;\n\n\n\n    /* sectors is now how many sectors the data itself takes, not\n\n     * including the header and descriptor metadata */\n\n\n\n    new_hdr = (VHDXLogEntryHeader) {\n\n                .signature           = VHDX_LOG_SIGNATURE,\n\n                .tail                = s->log.tail,\n\n                .sequence_number     = s->log.sequence,\n\n                .descriptor_count    = sectors,\n\n                .reserved            = 0,\n\n                .flushed_file_offset = bdrv_getlength(bs->file->bs),\n\n                .last_file_offset    = bdrv_getlength(bs->file->bs),\n\n              };\n\n\n\n    new_hdr.log_guid = header->log_guid;\n\n\n\n    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n\n\n\n    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;\n\n    new_hdr.entry_length = total_length;\n\n\n\n    vhdx_log_entry_hdr_le_export(&new_hdr);\n\n\n\n    buffer = qemu_blockalign(bs, total_length);\n\n    memcpy(buffer, &new_hdr, sizeof(new_hdr));\n\n\n\n    new_desc = buffer + sizeof(new_hdr);\n\n    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n\n    data_tmp = data;\n\n\n\n    /* All log sectors are 4KB, so for any partial sectors we must\n\n     * merge the data with preexisting data from the final file\n\n     * destination */\n\n    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n\n\n\n    for (i = 0; i < sectors; i++) {\n\n        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;\n\n        new_desc->sequence_number = s->log.sequence;\n\n        new_desc->file_offset     = file_offset;\n\n\n\n        if (i == 0 && leading_length) {\n\n            /* partial sector at the front of the buffer */\n\n            ret = bdrv_pread(bs->file, file_offset, merged_sector,\n\n                             VHDX_LOG_SECTOR_SIZE);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n\n            bytes_written = leading_length;\n\n            sector_write = merged_sector;\n\n        } else if (i == sectors - 1 && trailing_length) {\n\n            /* partial sector at the end of the buffer */\n\n            ret = bdrv_pread(bs->file,\n\n                            file_offset,\n\n                            merged_sector + trailing_length,\n\n                            VHDX_LOG_SECTOR_SIZE - trailing_length);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector, data_tmp, trailing_length);\n\n            bytes_written = trailing_length;\n\n            sector_write = merged_sector;\n\n        } else {\n\n            bytes_written = VHDX_LOG_SECTOR_SIZE;\n\n            sector_write = data_tmp;\n\n        }\n\n\n\n        /* populate the raw sector data into the proper structures,\n\n         * as well as update the descriptor, and convert to proper\n\n         * endianness */\n\n        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,\n\n                                  s->log.sequence);\n\n\n\n        data_tmp += bytes_written;\n\n        data_sector++;\n\n        new_desc++;\n\n        file_offset += VHDX_LOG_SECTOR_SIZE;\n\n    }\n\n\n\n    /* checksum covers entire entry, from the log header through the\n\n     * last data sector */\n\n    vhdx_update_checksum(buffer, total_length,\n\n                         offsetof(VHDXLogEntryHeader, checksum));\n\n\n\n    /* now write to the log */\n\n    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,\n\n                                 desc_sectors + sectors);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    if (sectors_written != desc_sectors + sectors) {\n\n        /* instead of failing, we could flush the log here */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->log.sequence++;\n\n    /* write new tail */\n\n    s->log.tail = s->log.write;\n\n\n\nexit:\n\n    qemu_vfree(buffer);\n\n    qemu_vfree(merged_sector);\n\n    return ret;\n\n}\n", "idx": 6545, "substitutes": {"bs": ["bi", "pb", "db", "sb", "bid", "bos", "blocks", "ks", "BS", "ls", "bl", "ps", "utils", "ses", "vs", "cs", "gs", "bb", "ds", "fb", "ss", "ts", "bc", "fs", "ns", "as", "us", "js", "b", "es", "ins", "os", "qs", "rs", "bas", "base"], "s": ["storage", "sq", "aws", "e", "d", "si", "sb", "comments", "server", "sys", "self", "p", "sync", "session", "S", "socket", "is", "ps", "client", "ses", "site", "qs", "cs", "sets", "gs", "r", "sf", "ds", "stat", "service", "stats", "n", "states", "ss", "sie", "c", "sg", "services", "sym", "fs", "g", "ns", "f", "space", "summary", "conf", "ssl", "settings", "sl", "manager", "sis", "state", "js", "b", "su", "sv", "status", "os", "http", "v", "rs", "spec"], "data": ["batch", "reader", "def", "DATA", "d", "message", "Data", "p", "base", "slice", "session", "buf", "config", "bytes", "response", "block", "ops", "entry", "next", "source", "partial", "size", "database", "state", "body", "dat"], "length": ["available", "depth", "url", "section", "number", "end", "total", "value", "Length", "build", "limit", "message", "len", "base", "slice", "style", "type", "full", "tail", "support", "position", "distance", "l", "block", "maximum", "load", "join", "address", "path", "range", "duration", "padding", "partial", "ph", "filename", "size", "match", "delay", "shape", "count", "specified", "ength", "lock", "angle"], "offset": ["operation", "pos", "index", "reset", "seed", "set", "end", "number", "error", "loc", "limit", "Offset", "afi", "slice", "pad", "position", "off", "iso", "online", "exclusive", "entry", "alpha", "address", "pointer", "gap", "range", "location", "padding", "start", "attribute", "phase", "part", "slot", "initial", "o", "prefix", "size", "origin", "fee", "delay", "timeout", "align", "format", "base"], "buffer": ["batch", "reader", "queue", "input", "message", "Buffer", "byte", "buf", "channel", "read", "block", "buff", "entry", "transfer", "bc", "summary", "f", "source", "uffer", "writer", "bin", "memory", "iter", "body", "binary", "window", "output"], "merged_sector": ["merged_section", "merged_component", "merger_component", "merger_section", "merged_channel", "merger_sector", "merger_channel"], "data_tmp": [" data_rb", " data_dest", "data_dest", " data_temp", "data_temp", "data_rb"], "sector_write": [" sector_set", " sector_only", "sector_data", "sector_set", "sector___data", "sector_only", " sector_data", "sector___set", "sector___only", "sector___write"], "i": ["end", "j", "e", "d", "len", "p", "type", "id", "n", "l", "f", "io", "or", "a", "info", "b", "count", "I", "x"], "sector_offset": ["sector_address", " section_Offset", "sector_no", "sector_size", "sector_area", "sector64area", "headeralarea", "sector6address", "header_offset", " section_size", "systeminglocation", "sector64address", "reader_addr", "systemingaddress", "sector6offset", "sector_addr", "sector64location", "sectoringno", "reader_offset", "sector6location", "sector___pos", "sector_Offset", "systemingoffset", "system_offset", "sector8angle", "system_no", "sector64pad", "sector8pad", "header_pad", "sector__addr", "sector8area", "sector64offset", "sectoraloffset", "sectoringoffset", "sector64no", "headeraloffset", "sector8offset", "sector___offset", "systemingno", "sector6no", "sectoringaddress", "system_address", "headeralpad", "sector_angle", "sector64angle", "sector__set", "sectoringlocation", "sectoralangle", "sector__offset", "sector_pos", " section_pos", "reader_set", "header_area", "reader_position", "system_location", "sector_set", "sectoralpad", "sector___size", "sector___Offset", "headeralangle", "header_angle", "sectoralarea", "sector__position", "sector_pad", "sector_location", "sector_position", " section_offset"], "desc_sectors": ["desc_psectors", "desc_gections", "desc_psections", "desc_pections", "desc_gegments", "desc_pegments", "desc_pectors", "desc_segment", "desc_gegment", "desc_psegment", "desc_pegment", "desc_segments", "desc_psegments", "desc_sections", "desc_gectors"], "sectors": [" segments", "pections", "pectors", "texes", "pellers", "siectors", " Severs", "sexes", "sections", "severs", "tectors", " Segments", "siegments", " sections", "psegments", " Sectors", "siections", "sellers", "psexes", "siellers", "tegments", "tections", "psections", "pegments", "pevers", " sellers", "psectors", "segments", " Sections", "psevers", " sexes"], "total_length": ["aligned_tail", "alignedaccount", "total_count", "totalacsequence", "aligned_sequence", "alignedactail", "total_tail", "totalaclength", "totalactail", "total_sequence", "aligned_count", "alignedaclength", "alignedacsequence", "totalaccount"], "aligned_length": ["aligned2length", "aped54depth", "aligned2capacity", "aligned_depth", "aligned___distance", "aligned___size", "aligned64cost", "aligned_child", "aped_part", "aligned_capacity", "joined_angle", "aligned64length", "joined_length", "aligned67angle", "leading_distance", "sized___size", "sized___duration", "alignedingdistance", "sized_duration", "aligned2distance", "aligned_cost", "aligned67distance", "aligned64depth", "aligned67child", "aligned2count", "aligned___length", "alignedinglength", "aped54part", "aligned54part", "aped54cost", "signed_angle", "signed_size", "aligned_count", "aped_length", "signed_count", "sized_size", "aligned54cost", "aped_cost", "aligned_part", "aligned67length", "aped_depth", "sized___length", "aligned_size", "aligned_duration", "leading_count", "alignedingduration", "aligned_angle", "sized_distance", "sized_length", "joined_child", "aligned54length", "leading_length", "aligned2angle", "aped54length", "signed_length", "aligned64part", "alignedingsize", "aligned___duration", "joined_distance", "aligned2size", "sized___distance", "aligned54depth", "leading_capacity", "aligned_distance"], "file_offset": ["file_off", "file___off", "file___offset", "file_order", "sector_size", "block_offset", "block_order", "file___number", "block_off", "file_loc", "file__number", "block__off", "block__offset", "file_location", "file__off", "file__offset", "file_number", "file_size", "file___order", "block_number", "sector_location", "block__number", "file__order", "sector_loc", "block__order"], "header": ["index", "reader", "section", "general", "error", "Header", "message", "document", "core", "server", "event", "connection", "metadata", "h", "client", "record", "channel", "bridge", "image", "later", "config", "headers", "meta", "head", "response", "cookie", "pillar", "her", "content", "init", "entry", "layer", "version", "summary", "description", "character", "comment", "master", "ssl", "writer", "initial", "journal", "secondary", "manager", "cover", "dr", "shadow", "definition", "parser", "driver", "final", "spec", "handler"], "new_hdr": ["new_hds", "new_thr", "new_chdr", "new_hld", "new_thld", "new_chld", "new_shds", "new_thdr", "new_hr", "new_thds", "new_shdr", "new_shr", "new_chr", "new_chds", "new_shld"], "new_desc": ["new_text", " new_text", "newamdesc", "new2desc", " new_sc", "new_sc", "newamtext", "new2text", "newamDesc", "new2sc", " new_Desc", "new2Desc", "new_Desc", "newamsc"], "data_sector": ["data_tier", "data___order", "data___section", " data_order", "data_section", " data_tier", "data___tier", "data___sector", " data_section", "data_order"], "partial_sectors": ["partial_cectors", "partial_sections", "partial_selements", "partial_gegments", "partial_psectors", "partial_gelements", "partial_celements", "partial_segments", "partial_persegments", "partial_gectors", "partial_geivers", "partial_gections", "partial_sexes", "partial_seivers", "partial_perselements", "partial_persectors", "partial_vectors", "partial_gexes", "partial_pseivers", "partial_psegments", "partial_cexes", "partial_vections", "partial_cegments", "partial_persexes", "partial_veivers", "partial_psections", "partial_vegments"], "sequence": ["note", "frame", "future", "protein", "family", "sample", "section", "scale", "queue", "element", "multiple", "component", "grade", "command", "numbered", "seq", "generic", "sequ", "position", "period", "version", "repeat", "secret", "source", "character", "duration", "serial", "ence", "prefix", "letter", "series", "append", "unit"]}}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n", "idx": 6547, "substitutes": {"s": ["an", "sec", "sq", "e", "d", "sb", "sys", "p", "sync", "spec", "ks", "session", "S", "is", "ses", "gs", "cs", "service", "ds", "states", "ss", "c", "sg", "ts", "services", "sym", "t", "fs", "ns", "f", "as", "us", "a", "ssl", "south", "settings", "i", "sl", "o", "state", "js", "es", "status", "http", "os", "qs", "rs", "si"]}}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "static int http_prepare_data(HTTPContext *c)\n\n{\n\n    int i;\n\n\n\n    switch(c->state) {\n\n    case HTTPSTATE_SEND_DATA_HEADER:\n\n        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n\n        if (c->stream->feed) {\n\n            /* open output stream by using specified codecs */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->stream->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                if (c->stream->feed == c->stream)\n\n                    memcpy(st, c->stream->streams[i], sizeof(AVStream));\n\n                else\n\n                    memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));\n\n\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        } else {\n\n            /* open output stream by using codecs in specified file */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->fmt_in->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        }\n\n        init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE,\n\n                      1, c, NULL, http_write_packet, NULL);\n\n        c->fmt_ctx.pb.is_streamed = 1;\n\n        /* prepare header */\n\n        av_write_header(&c->fmt_ctx);\n\n        c->state = HTTPSTATE_SEND_DATA;\n\n        c->last_packet_sent = 0;\n\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n\n        /* find a new packet */\n\n#if 0\n\n        fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count;\n\n        if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) {\n\n            /* overflow : resync. We suppose that wptr is at this\n\n               point a pointer to a valid packet */\n\n            c->rptr = http_fifo.wptr;\n\n            c->got_key_frame = 0;\n\n        }\n\n        \n\n        start_rptr = c->rptr;\n\n        if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0)\n\n            return 0;\n\n        payload_size = ntohs(hdr.payload_size);\n\n        payload = av_malloc(payload_size);\n\n        if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) {\n\n            /* cannot read all the payload */\n\n            av_free(payload);\n\n            c->rptr = start_rptr;\n\n            return 0;\n\n        }\n\n        \n\n        c->last_http_fifo_write_count = http_fifo_write_count - \n\n            fifo_size(&http_fifo, c->rptr);\n\n        \n\n        if (c->stream->stream_type != STREAM_TYPE_MASTER) {\n\n            /* test if the packet can be handled by this format */\n\n            ret = 0;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st = c->fmt_ctx.streams[i];\n\n                if (test_header(&hdr, &st->codec)) {\n\n                    /* only begin sending when got a key frame */\n\n                    if (st->codec.key_frame)\n\n                        c->got_key_frame |= 1 << i;\n\n                    if (c->got_key_frame & (1 << i)) {\n\n                        ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i,\n\n                                                                   payload, payload_size);\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            if (ret) {\n\n                /* must send trailer now */\n\n                c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n            }\n\n        } else {\n\n            /* master case : send everything */\n\n            char *q;\n\n            q = c->buffer;\n\n            memcpy(q, &hdr, sizeof(hdr));\n\n            q += sizeof(hdr);\n\n            memcpy(q, payload, payload_size);\n\n            q += payload_size;\n\n            c->buffer_ptr = c->buffer;\n\n            c->buffer_end = q;\n\n        }\n\n        av_free(payload);\n\n#endif\n\n        {\n\n            AVPacket pkt;\n\n\n\n            /* read a packet from the input stream */\n\n            if (c->stream->feed) {\n\n                ffm_set_write_index(c->fmt_in, \n\n                                    c->stream->feed->feed_write_index,\n\n                                    c->stream->feed->feed_size);\n\n            }\n\n            \n\n            if (av_read_packet(c->fmt_in, &pkt) < 0) {\n\n                if (c->stream->feed && c->stream->feed->feed_opened) {\n\n                    /* if coming from feed, it means we reached the end of the\n\n                       ffm file, so must wait for more data */\n\n                    c->state = HTTPSTATE_WAIT_FEED;\n\n                    return 1; /* state changed */\n\n                } else {\n\n                    /* must send trailer now because eof or error */\n\n                    c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n                }\n\n            } else {\n\n                /* send it to the appropriate stream */\n\n                if (c->stream->feed) {\n\n                    /* if coming from a feed, select the right stream */\n\n                    for(i=0;i<c->stream->nb_streams;i++) {\n\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n\n                            pkt.stream_index = i;\n\n                            if (pkt.flags & PKT_FLAG_KEY) {\n\n                                c->got_key_frame |= 1 << i;\n\n                            }\n\n                            /* See if we have all the key frames, then \n\n                             * we start to send. This logic is not quite\n\n                             * right, but it works for the case of a \n\n                             * single video stream with one or more\n\n                             * audio streams (for which every frame is \n\n                             * typically a key frame). \n\n                             */\n\n                            if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) {\n\n                                goto send_it;\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    AVCodecContext *codec;\n\n                send_it:\n\n                    /* Fudge here */\n\n                    codec = &c->fmt_ctx.streams[pkt.stream_index]->codec;\n\n\n\n                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);\n\n\n\n#ifdef PJSG\n\n                    if (codec->codec_type == CODEC_TYPE_AUDIO) {\n\n                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;\n\n                        /* printf(\"Calculated size %d, from sr %d, duration %d\\n\", codec->frame_size, codec->sample_rate, pkt.duration); */\n\n                    }\n\n#endif\n\n\n\n                    if (av_write_packet(&c->fmt_ctx, &pkt, 0))\n\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n\n\n                    codec->frame_number++;\n\n                }\n\n\n\n                av_free_packet(&pkt);\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n    case HTTPSTATE_SEND_DATA_TRAILER:\n\n        /* last packet test ? */\n\n        if (c->last_packet_sent)\n\n            return -1;\n\n        /* prepare header */\n\n        av_write_trailer(&c->fmt_ctx);\n\n        c->last_packet_sent = 1;\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6556, "substitutes": {"c": ["nc", "uc", "pc", "rc", "k", "e", "d", "enc", "coll", "co", "exec", "cc", "call", "self", "p", "ce", "oc", "h", "xc", "ct", "sc", "client", "cm", "cs", "ch", "config", "u", "cit", "l", "ic", "n", "cy", "s", "m", "content", "t", "ctx", "dc", "bc", "cur", "cr", "f", "g", "rec", "arc", "ctrl", "mc", "cl", "ec", "cv", "conf", "cache", "fc", "cu", "w", "cf", "ca", "C", "tc", "ci", "lc", "icc", "ac", "b", "com", "cb", "vc", "con", "cp", "cmp", "v", "x"], "i": ["bi", "index", "pi", "name", "d", "multi", "ti", "slice", "type", "qi", "hi", "inner", "id", "ip", "ori", "f", "zi", "my", "mu", "uri", "b", "count", "v", "li", "ui", "ie", "key", "h", "ii", "r", "u", "ji", "ix", "start", "a", "ini", "code", "lc", "iu", "ai", "p", "ski", "mi", "full", "ij", "adi", "n", "block", "oi", "g", "io", "gi", "it", "I", "x", "si", "y", "j", "di", "e", "fi", "yi", "isin", "phi", "counter", "l", "ni", "m", "ri", "info", "iv", "xi", "ci", "eni"], "st": ["ste", "uc", "storage", "sth", "stack", "push", "end", "set", "ust", "stress", "ast", "sb", "back", "str", "spect", "p", "sync", "std", "src", "bl", "style", "stop", "ost", "sc", "ct", "r", "dest", "sp", "est", "sign", "usr", "stage", "sts", "St", "ss", "sr", "sh", "rest", "t", "rd", "cr", "cur", "step", "pt", "g", "f", "sa", "nd", "put", "sn", "cl", "inst", "start", "be", "se", "sta", "sl", "ft", "fr", "la", "sw", "store", "post", "ptr", "ist", "ld", "ST"], "codec": ["codEC", "codeenc", "labec", "peddec", "dependec", "codenc", "pedec", "pedcc", "condpc", "logec", "codeect", "logenc", "dependpc", "labEC", "codcc", "codeEC", "pedpc", "labect", "dependdec", "condcc", "condec", "conddec", "labenc", "logect", "codect", "logEC", "coddec", "codeec", "codpc", "dependcc"], "frame_number": ["frame_multiple", "fram_counter", "fram_no", " frame_sn", "frameflownum", "frameflowsn", "frame_num", "frameflowmultiple", "frame_counter", "fram_num", "fram_number", "frameflownumber", " frame_num", "frame_sn", " frame_multiple", "frame_no"]}}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)\n\n{\n\n    if (!buffer->cmd) {\n\n        AVBufferRef *buf = buffer->user_data;\n\n        av_buffer_unref(&buf);\n\n    }\n\n    mmal_buffer_header_release(buffer);\n\n}\n", "idx": 6575, "substitutes": {"port": ["pos", "Port", "allow", "target", "end", "export", "p", "type", "pair", "pad", "test", "config", "air", "ip", "PORT", "address", "host", "pointer", "path", "source", "mac", "ort", " transport", "ports", "length", "post", "http", "cp"], "buffer": ["builder", "data", "pb", "context", "object", "header", "reader", "ref", "queue", "message", "Buffer", "er", "interface", "slave", "server", "container", "window", "texture", "pad", "bridge", "image", "bb", "block", "buff", "ker", "transfer", "f", "pointer", "holder", "source", "FFER", "comment", "uffer", "writer", "cache", "reference", "table", "border", "uf", "b", "null", "iter", "timeout", "ptr", "resource", "feed"], "buf": ["av", "data", "pb", "func", "rc", "ref", "bag", "db", "queue", "ab", "bf", "Buffer", "src", "img", "vec", "fb", "plug", "buff", "ob", "var", "BU", "cur", "bc", "f", "Buff", "cv", "cache", "fab", "cf", "bu", "cap", "bd", "uf", "bh", "rb", "b", "cb", "fp", "ptr", "feed"]}}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 6577, "substitutes": {"env": ["extra", "context", "cfg", "ext", "vm", "eu", "eve", "np", " environment", "db", "loader", "e", "enc", "exc", "equ", "ea", "args", "conn", "vs", "ep", "ev", "config", "viron", "dict", "obj", "net", "eng", "entry", "ctx", "next", "path", "Environment", "ah", "ec", "en", "eb", "cache", "err", "esp", "erv", "inet", "eni", "exe", "qt", "priv", "conf", "v", "environment"], "cpu": ["performance", "pb", "nc", "vm", "pc", "np", "lb", "proc", "loader", "gpu", "component", "core", "cli", "program", "GPU", "mpeg", "clock", "gc", "conn", "cm", "processor", "roc", "config", "kernel", "uci", "hp", "bench", "instance", "css", "ctx", "bc", "boot", "platform", "console", "gp", "hw", "cache", "lp", "python", "colo", "cn", "computer", "lc", "pu", "node", "process", "cmp", "fp", "cp", "cpp", "unit", "framework", "CP", "utils", "CPU"], "new_cpu": ["newjcpu", "new_clock", "old_gpu", "old_process", "new_core", " new_processor", "newKcpu", "new_gpu", "new_pu", "new_process", "newjclock", "newjcore", "old_processor", "new_cache", "newKgpu", "new__gpu", "new__cpu", "new_processor", " new_cache", "old_pu", "new__vm", "old_cpu", " new_core", "new__clock", " new_clock", "newKpu", "old_core", "newjvm", "new__processor", "new_vm", "newKprocess", " new_vm", "new__core"], "new_env": ["newfdb", "newamenv", " new_environment", "new__environment", "newfenvironment", "newfexc", " new_network", "newamcache", "newmemenv", "new_cache", "new__conn", "new__exc", "new_exc", " new_conn", " new_cache", "newmemconn", "newmemcontext", "newamnetwork", " new_context", "newmemenvironment", " new_db", "new_conn", "new__db", "new__context", "newamenvironment", "new__env", "new_network", "newfenv", " new_exc", "new_db", "new_environment", "new_context"], "bp": ["pb", "wb", "pc", "lb", "np", "vm", "bsp", "NP", "php", "vp", "cp", "bf", "pg", "sb", "tp", "cli", "p", "bb", "dp", "sp", "pn", "ap", "fb", "jp", "hp", "bc", "BP", "nb", "px", "kb", "usb", "pp", "gp", "eb", "prefix", "lp", "lc", "b", "arp", "po", "cmp", "fp", "pd", "cpp", "bps"], "wp": ["pb", "wb", "pc", "np", "bsp", "NP", "php", "vp", "pg", "wm", "tp", "p", "wx", "wn", "wordpress", "kw", "bb", "dp", "fw", "sp", "ap", "jp", "ip", "hp", "wi", "WP", "BP", "web", "px", "pp", "hop", "wu", "pkg", "hw", "gp", "iw", "w", "prefix", "xp", "lp", "python", "sw", "rw", "fp", "cp", "wk"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                               int32_t src_stride,\n\n                                               uint8_t *dst, int32_t dst_stride)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16i8 filt0, filt1, filt2;\n\n    v16u8 res0, res1, res2, res3;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = 4; loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n        AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3,\n\n                    res0, res1, res2, res3);\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 6580, "substitutes": {"src": ["low", "rc", "sth", "url", "dist", "gb", "loc", "sb", "RC", "pl", "sil", "sur", "rx", "slice", "sc", "seq", "img", "dest", "config", "ctr", "cont", "sr", "rest", "st", "cur", "gl", "bc", "bg", "sup", "tmp", "source", "ctrl", "inst", "cv", "req", "secure", "ssl", "supp", "scl", "sl", "rb", "rect", "desc", "cb", "href", "comp", "stream", "sel", "rs", "spec", "rob"], "src_stride": ["src_stided", "src_divide", "src_striider", "src_Strides", "src_arride", "src_strides", "src_Stride", "src_stide", "src_stides", "src_bride", "src_divides", "src_divider", "src_arrided", "src_strider", "src_arrider", "src_divided", "src_strided", "src_brides", "src_brided", "src_striides", "src_stider", "src_striide", "src_arrride", "src_arrides", "src_Strider", "src_brider", "src_strride", "src_Strride", "src_Strided", "src_striided"], "dst": ["dsts", "DST", "bst", "bsts", "Dst", " dsrc", "bST", " dST", "Dsrc", "dST", " dsts", "Dsts", "bsrc", "dsrc"], "dst_stride": ["dst_strride", "dst_stider", "dst_strider", "dst_strided", "dst_stide", "dst_stided", "dst_brider", "dst_brride", "dst_blider", "dst_brided", "dst_blide", "dst_bride", "dst_blided", "dst_blride"], "loop_cnt": ["loop_fcnc", "loop_account", "loop_cnc", "loop_fccount", "loop_cct", "loop_acct", "loop_fnc", "loop_fcnt", "loop_acnt", "loop_fcount", "loop_ccount", "loop_fcct", "loop_fct", "loop_acnc", "loop_fnt"], "dst0": [" dest4", "dest1", " dest1", "dast0", "dast2", "dost1", " dest2", " dest0", " dst4", "dest4", "dast1", "dost0", "dast4", "dest2", "dost2", "dost4", "dst4", "dest0"], "dst1": ["madst4", "dinst2", "dsrc4", "madst2", "madsrc2", "dost1", "madst1", "madsrc4", "madsrc0", "dsrc2", "madsrc1", "dsrc1", "madst0", "dinst1", "dinst0", "dost0", "dost2", "dost4", "dst4", "dsrc0", "dinst4"], "dst2": ["Dst2", "Dost42", "Dst4", "dst02", "dost42", "Dst02", "drc02", "dsc42", "Dost2", "Dst42", "dsc2", "Dost02", "dsc4", "drc2", "dost2", "dost4", "dost02", "dst4", "drc4", "dst42", "dsc02", "Dost4", "drc42"], "dst3": [" dsc6", " dsc2", "dcast3", "ddest3", "dcast8", "ddest8", " dsc8", "dsc2", "ddest2", "dst8", "dsc6", "dsc3", " dst8", "ddest6", " dsc3", "dcast2", "dsc8", " dst6", "dcast6", "dst6"], "src0": ["dest1", "source0", "img8", "loc4", "rc5", "rc3", "src50", "dest8", "img2", "dist5", "source1", "dest4", "loc2", "rc0", "source4", "loc0", " src50", "source2", "loc1", "dist2", "sl8", "dist8", "dest2", "sl1", "rc8", "img0", "dest50", "sl50", "rc4", "img5", "dist0", "rc1", "rc2", "sl0", "dest3", "dest0"], "src1": ["dest1", "sc3", "source0", "img8", "img01", " src01", "rc3", "sr2", "source1", "dest4", "rc0", "source2", "img4", "sc1", "src01", "sc01", "dist1", "dist8", "rc8", "dest2", "dist4", "sr3", "img1", "sr01", "sc2", "rc4", "dest01", "rc1", "rc2", "sr1", "dest3", "source01", "dist01", "dest0", "rc01"], "src2": ["rc02", "source0", "source3", "rc5", "sort5", "rc3", "source1", "dest4", "reflect02", "rc0", "source4", "sort4", "source2", " src02", "sort2", "reflect5", "sort3", "dest2", "src02", "reflect1", "rc4", "source02", "rc1", "rc2", "dest3", "reflect2", "dest0"], "src3": ["source5", "sur03", "dist53", "source3", "source0", "rc5", "reflect33", "src53", "rc3", "source03", " src53", "src23", "rc53", " src23", "rc0", "source4", "dist3", "inst23", "reflect4", "sur33", "inst3", "rc03", "dist1", "reflect03", "inst2", " src03", "dist4", "src33", "inst03", "rc23", "src03", "reflect3", "sur4", "rc4", "sur3", "rc1", "rc2", "rc33"], "src4": ["source5", "rc6", "dest1", "source44", "rc5", "source6", "img04", "source8", "src04", "img2", "source1", "dest4", "source4", "source2", "img4", "src44", "dist2", "dest2", "dist1", "rc8", "dist04", "dest5", "source04", "dist4", "dest44", "rc4", "rc04", "rc44", "rc1", "dest04", "rc2", "img6"], "src5": ["src50", "source50", "source5", "reflect4", "reflect50", "rc4", "source53", "rc50", "reflect5", "rc53", "rc5", "source4", "src53", "reflect53"], "src6": ["sc66", "loc6", "loc8", "sc8", "src66", "sc6", "src76", "loc66", " src66", "loc76", " src76", "sc76"], "src7": ["src07", "rc7", "reflect73", "reflect07", "reflect7", "source07", "rc77", "rc73", "rc07", "source73", "src73", "source77", "source7", "reflect77", "src77"], "src8": ["rc7", " src9", "rc9", "img88", "img8", "img9", " src88", "rc8", "img7", "src88", "rc88", "src9"], "src10_r": ["src10_R", "src90_r", "src8_sr", "src8_r", "src90_p", "src90_l", "src10_p", "src8_R", "src10_rf", "src8_l", "src90_rf", "src10_sr"], "src32_r": ["src21_rs", "src32_t", "src21mmrs", "src21mmright", "src32mmr", "src21_t", "src32ingt", "src32ingrs", "src21mmr", "src32ingright", "src32ingr", "src32mmrs", "src21_right", "src21mmt", "src32_rs", "src32mmt", "src32mmright", "src32_right"], "src54_r": ["src52_rs", "src52_l", "src54_rs", "src54_pr", "src52_pr", "src52_r"], "src76_r": ["src76_rs", "src74_err", "src76acerr", "src74_r", "src74_nr", "src76acrs", "src76acnr", "src76_err", "src74_rs", "src76_nr", "src76acr"], "src21_r": ["src21_rs", "src21_mr", "src21_hr", "src64_hr", "src64_mr", "src64_rs", "src64_r"], "src43_r": ["src43_pr", "src73_rr", "src43_rs", "src73_r", "src73_pr", "src73_rs", "src43_rr"], "src65_r": ["src57_sr", "src65_sr", "src57_rb", "src57_rs", "src65_rs", "src65_rb", "src57_r"], "src87_r": ["src875r", "src7_l", "src875w", "src875x", "src7_r", "src87_x", "src7_x", "src87_w", "src875l", "src7_w"], "src10_l": ["src00_l", "src10_lc", "src00_r", "src00_kl", "src10_kl", "src00_lc"], "src32_l": ["src32_lc", "src52_l", "src52_line", "src32_line", "src32ccline", "src32ccl", "src32cclc", "src52_lc", "src32ccr", "src52_r"], "src54_l": ["src52_l", "src52_m", "src54_lc", "src54_m", "src52_lc", "src52_ll", "src54_ll"], "src76_l": ["src76_lc", "src76_bl", "src56_bl", "src56_lc", "src76riptbl", "src76_ll", "src56_l", "src76riptll", "src76riptlc", "src56_ll", "src76riptl"], "src21_l": ["src43_ll", "src21_ll", "src43_lc", "src43_lp", "src21_lp", "src21_lc"], "src43_l": ["src43_n", "src73_l", "src73_r", "src73_lc", "src43_lc", "src73_n"], "src65_l": ["src73_l", "src65_lc", "src73_r", "src73_lc", "src65_b", "src73_b"], "src87_l": ["src87mmx", "src73_l", "src87mmr", "src87mmo", "src73_o", "src87_x", "src87mml", "src73_r", "src87_o", "src73_x"], "out0_r": ["out0_rb", "out0__r", "out0__d", "out0__l", "out0_d", "out0__rb"], "out1_r": ["out0_p", "out1_b", "out1_p", "out0_b"], "out2_r": ["out2_b", "out4_p", "out2_p", "out4_r", "out4_l", "out4_b"], "out3_r": ["out3_b", "out2_b", "out2_w", "out3_w"], "out0_l": ["out10_l", "out10_fl", "out10_b", "out10_L", "out0_fl", "out0_L", "out0_b"], "out1_l": ["out1_fl", "out1__d", "out1__fl", "out1__l", "out2_d", "out1_d", "out2_fl", "out1__r"], "out2_l": ["out2_b", "out0_fl", "out2_fl", "out0_b"], "out3_l": ["out3_b", "out2_b", "out3_ll", "out2_ll"], "filt0": ["filit2", "flt1", " filt3", " falt2", "filt3", "flt3", "fil0", "fil3", "falt0", " falt3", " falt0", "filit1", "falt2", "falt1", "falt6", "flt6", "Filt0", "falt3", "filt6", " falt1", "Falt1", "Filt6", "Falt6", "flt0", "fil2", "Filt2", "Filt1", "flt2", "filit0", "Falt0", "filit6", "Falt2", "fil1"], "filt1": ["flt1", " filt3", "flict2", "flict3", "firm3", "vilt4", "filt3", "fill3", "firm1", "vill3", "fill4", "flt3", "vill4", "fird2", "filt4", "vilt1", "firm2", "fird3", "vill1", "firm4", "flt4", "fill2", " filt4", "flict1", "flt2", " flt4", "fird1", "fird4", " flt2", "fill1", " flt1", "vill2", "vilt2", " flt3", "vilt3", "flict4"], "filt2": ["milt5", "fesh2", "flt1", "milt4", "felt1", "fill4", "flt5", "mill2", "filt4", "felt52", "mill4", "filt52", "filt5", "fesh1", "fil4", "fill2", "fil2", "fesh52", "milt2", "flt52", "flt2", " flt1", "mill5", "fill1", "mill1", " flt2", " filt52", "felt2", "fil5", " flt52", "fil1", "fill5", "milt1", "flt4"], "res0": ["ps2", "Res1", "ps1", "Res00", "ps0", "Res0", "res00", "ps00", "Res2", " res00"], "res1": ["pres4", "Res1", "Res4", "ras4", "pres0", "ras0", "Res0", "ras2", "Res2", "pres1", "pres2", "ras1", "res4"], "res2": ["pres4", "RES4", "Res1", "Res4", "restwo", "Restwo", "REStwo", "RES1", "Res2", "prestwo", "pres1", "pres2", "res4", "RES2"], "res3": ["Res15", "res15", "Res1", "ras15", "ras2", "Res2", "Res3", "ras1", " res15", "ras3"]}}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 6594, "substitutes": {"opaque": ["opa", "spacity", "opace", "opera", " opace", "opacity", "opac", "paque", "copa", "copaque", "opaques", "operac", "iopacity", "operaque", "iopaque", "space", "operacity", "copacity", "spaques", " opacity", "paques", "iopa", "pace", "pacity", "iopac", " opaques", "copac", "spaque"], "s": ["scope", "sec", "sq", "e", "sb", "server", "sys", "p", "sync", "spec", "S", "socket", "ses", "u", "sf", "ds", "stats", "n", "states", "ops", "ss", "c", "sg", "sym", "services", "m", "sie", "fs", "g", "ns", "f", "sa", "a", "ssl", "sl", "o", "secondary", "si"]}}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "static void ppc_prep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    char *filename;\n\n    nvram_t nvram;\n\n    M48t59State *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_prep.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_prep.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size > 0 && bios_size <= BIOS_SIZE) {\n\n        target_phys_addr_t bios_addr;\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        bios_addr = (uint32_t)(-bios_size);\n\n        cpu_register_physical_memory(bios_addr, bios_size,\n\n                                     bios_offset | IO_MEM_ROM);\n\n        bios_size = load_image_targphys(filename, bios_addr, bios_size);\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PPC PREP bios '%s'\\n\", bios_name);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    /* Hmm, prep has no pci-isa bridge ??? */\n\n    isa_bus_new(NULL);\n\n    isa_bus_irqs(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(2000, NULL);\n\n\n\n    if (serial_hds[0])\n\n        serial_isa_init(0, serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = qemu_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(\"i8042\");\n\n\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(1, cpu_exit_irq);\n\n\n\n    //    SB16_init();\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(fd);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL, DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 6605, "substitutes": {"ram_size": ["block67location", "amdallnumber", "ram67offset", "ram67length", "amdallname", "ram_number", "ram_len", "ram_position", "ram_source", "ramFsize", "block_offset", "ramallnumber", "block_location", "ram_capacity", "ram_length", "ram67len", "ramFsource", "block67offset", "amdallsize", "amdallposition", "ram67capacity", "gram_source", "gram_len", "ramslocation", "ramallposition", "ramslength", "ram_location", "block_length", "block67length", "ram_name", "amd_position", "ramFlen", "ramFcapacity", "ramallname", "block67size", "gram_size", "gram_capacity", "ramsoffset", "amd_name", "amd_number", "amd_size", "ram67location", "ramallsize", "ram67size", "ramssize", "block_size", "ram67source"], "boot_device": ["kernel_dir", "boot_dir", "kernel_dev", "boot_dev", "kernel_device", "kernel_mode", "boot_mode"], "kernel_filename": [" kernel_mode", "kernelblockmode", "kernelblockname", "cpu_fil", "cpu_filename", "cpu_name", " kernel_platform", "kernel_platform", "kernelblockplatform", "kernel_name", "kernel_fil", "kernel_file", "kernelblockfilename", "cpu_file", "kernel_mode", " kernel_name"], "kernel_cmdline": ["kernel_requestcode", "kernel_commandcode", "kernel_cmdspace", "kernel_cmdcode", "kernel_commandspace", "kernel_bindspace", "kernel_requestline", "kernel_bindline", "kernel_bindcode", "kernel_requestspace", "kernel_commandline"], "initrd_filename": ["initrt_file", "initrt_processor", "initrt_filename", "initrd_name", "initrd2filename", "initrd_file", "initrd2name", "initrd2processor", "initrd_processor", "initrd2file", "initrt_name"], "cpu_model": ["core_name", "processor_sleep", "gpu_type", "cpu_control", "core_mode", "core_serial", "processor_name", "processor_label", "cpu_label", "cpu_Model", " cpu_mode", "processor_model", "core_model", "cpu_mode", "cpu_type", "cpu_name", "cpu_serial", "gpu_spec", "gpu_model", " cpu_Model", "gpu_mode", "cpu_sleep", " cpu_control", "cpu_spec"], "env": ["stack", "np", "vel", "args", "energy", "esc", "vs", "inv", "enable", "init", "engine", "bc", "chal", "en", "el", "conf", "lock", "v", "context", "oa", " environment", "db", "enc", "exec", "ea", "app", "h", "config", "viron", "txt", "Environment", "ah", "gui", "here", "me", "qt", "environment", "ext", "profile", "eu", "cal", "export", "session", "style", "conn", "dict", "password", "ass", "eng", "entry", "shell", "console", "rev", "state", "window", "dat", "scope", "nc", "dir", "end", "e", "exc", "empty", "ev", "obj", "net", "her", "ctx", "act", "ec", "global", "err", "dev", "eni", "enh"], "filename": ["fn", "url", "Filename", "SourceFile", "name", "loader", "nil", "tty", "acl", "FIL", "download", "username", "File", "file", "application", "l", "files", "fil", "il", "summary", "f", "path", "source", "location", "prefix", "memory", "utf", "uri", "NAME", "alias", "dll", "fp", "binary", "output", "directory"], "nvram": ["vrom", "qtmem", "qtram", "qtro", "nvro", "ncmem", "qtrom", "vram", "nvmem", "ncrom", "nvrom", "ncram", "vro", "vmem", "ncro"], "m48t59": ["m28T58", "m48T58", "m48l64", "m48n58", "m48T56", "m28t59", "m28t64", "m28t56", "m48t58", "m48n59", "m48T59", "m48t64", "m48l58", "m48n56", "m48T64", "m48l56", "m28T59", "m28T56", "m48t56", "m48l59", "m48n64", "m28T64", "m28t58"], "PPC_io_memory": ["PPC_IO_memory", "PPC_IO_alloc", "PPC_IO_space", "PPC_io_alloc", "PPC_io_space", "PPC_io_mem", "PPC_IO_mem"], "linux_boot": [" linux_bit", "linux___bit", " linux_config", "linux_launch", "linux_bit", "linux___write", "linux_write", "kernel_launch", "linux___launch", "linux___boot", " linux_write", "linux_config", "kernel_boot", "linux___config", "kernel_config"], "i": ["ui", "index", "pi", "ie", "ei", "j", "di", "d", "mini", "multi", "fi", "cli", "ti", "p", "yi", "uli", "type", "h", "mi", "phi", "qi", "ii", "r", "hi", "u", "id", "n", "chi", "ni", "ip", "ami", "udi", "c", "t", "ix", "f", "io", "network", "ri", "ini", "info", "gi", "mu", "xi", "x", "uri", "ci", "eni", "in", "iu", "I", "ai", "v", "si", "li"], "nb_nics1": ["nb_nics0", "nb_nums0", "nb_nicsone", "nb_nii1", "nb_nigh5", "nb_nums1", "nb_nigh1", "nb_nuigh5", "nb_nii0", "nb_nuicsone", "nb_nuics5", "nb_nighone", "nb_nics5", "nb_nii5", "nb_niione", "nb_nuigh1", "nb_numsone", "nb_nuics0", "nb_nuics1", "nb_nuigh0", "nb_nuighone", "nb_nums5", "nb_nigh0"], "bios_size": ["bios_ize", "bios2size", "bios2ui", "bios_loc", "bins_loc", "bios2loc", "bins_ize", "bins_ui", "bins_size", "bios_ui", "bios2ize"], "ram_offset": ["ream_base", "ram_balance", "ream_offset", "ram_pointer", "mem_slot", "ream_size", " ram_balance", "ramEoffset", "ramEaddr", "ram_base", "mem_addr", "ramEslot", "ram_origin", "ram_slot", "ram_addr", "ram\u00b7offset", "ram\u00b7size", "ram\u00b7pointer", "ram\u00b7base", "mem_size", "ramEsize", "mem_offset", " ram_origin", "ream_pointer"], "bios_offset": ["bios_area", "bios_start", "bios_len", "bits_Offset", "bios_Offset", "bos_area", "bos_start", "bos_offset", "bits_size", "bits_len", "bos_size", "bits_offset"], "kernel_base": ["cpu_base", "kernel_len", "cpu_name", "cpu_size", "kernel_name", "cpu_len"], "initrd_base": ["initrt_length", "initrt_len", "initrd_len", "initrd_length", "initrt_base", "initrd_weight", "initrt_weight"], "kernel_size": ["processor_set", "kernelacsize", "processor_range", "processor_capacity", "kernelaccapacity", "kernel_capacity", "kernelacset", "kernel_range", "kernel_set", "kernelacrange", "processor_size"], "initrd_size": ["initrmssize", "initrd_len", "initrm_len", "initrdssize", "initrdscapacity", "initrm_size", "initrm_weight", "initrdsweight", "initrmslen", "initrd_weight", "initrmsweight", "initrdslen", "initrd_capacity", "initrm_capacity", "initrmscapacity"], "pci_bus": ["pci_boot", "pcm_bus", "pcm_BUS", "pci_BUS", "pci_class", "pcm_class", "pcm_boot"], "i8259": ["i48257", "i8257", "i64ka", "i48259", "m8288", "i64257", "i64288", "i8288", "m8257", "i48ka", "m8259", "i64259", "i8ka", "m8ka", "i48288"], "cpu_exit_irq": ["cpu_exit_irce", "cpu_exit_IRch", "cpu_exit_IRce", "cpu_exit_irg", "cpu_exit_pirq", "cpu_exit_IRg", "cpu_exit_pirce", "cpu_exit_IRq", "cpu_exit_pirg", "cpu_exit_pirch", "cpu_exit_irch"], "ppc_boot_device": ["ppc_bootxdevice", "ppc_boot_mode", "ppc_bootxstatus", "ppc_bootxmodel", "ppc_bootxmode", "ppc_mount_status", "ppc_mount_model", "ppc_mount_device", "ppc_boot_status", "ppc_boot_model", "ppc_mount_mode"], "hd": ["dn", "da", "vd", "di", "xd", "dh", "du", "rh", "hm", "hp", "dd", "gd", "nd", "hw", "ad", "HD", "dri", "dr", "bd", "ud", "cd", "md", "sd", "hs", "pd", "ha", "ht", "ld", "wd"], "MAX_IDE_BUS": ["MAX_IDE__USER", "MAX_IDES_BUS", "MAX_IDEADBUS", "MAX_IDEADUSER", "MAX_IDE__USB", "MAX_IDE__BUS", "MAX_IDE_USB", "MAX_IDES_USER", "MAX_IDES_USB", "MAX_IDE_USER", "MAX_IDEADUSB"], "MAX_IDE_DEVS": ["MAX_IDE_DVER", "MAX_IDE_ADVs", "MAX_IDE_DEVER", "MAX_IDE_DIVS", "MAX_IDE_DIVER", "MAX_IDE_DEVs", "MAX_IDE_ADVS", "MAX_IDE_DVS", "MAX_IDE_DIVICE", "MAX_IDE_DVs", "MAX_IDE_ADVICE", "MAX_IDE_DIVs", "MAX_IDE_ADVER", "MAX_IDE_DVICE", "MAX_IDE_DEVICE"], "fd": ["dn", "dir", "vd", "di", "db", "bf", "d", "fx", "df", "pid", "FD", "sf", "ds", "fb", "dc", "fs", "f", "dl", "fc", "dev", "cf", "fr", "bd", "sd", "b", "fp", "v", "wd", "fl"], "MAX_FD": ["MAXIDDF", "PER_DF", "MAX_HD", "PER__HD", "PER_ND", "MAXIDFD", "MAX_DF", "MAX__FD", "MAX__HD", "MAXIDHD", "PER__DF", "MAXIDND", "PER__ND", "PER_HD", "MAX__DF", "MAX_ND", "MAX__ND", "PER_FD", "PER__FD"]}}
{"project": "FFmpeg", "commit_id": "15ea222778caaec0877b3f9938140b707c931d96", "target": 0, "func": "static void copy_picture_field(InterlaceContext *s,\n\n                               AVFrame *src_frame, AVFrame *dst_frame,\n\n                               AVFilterLink *inlink, enum FieldType field_type,\n\n                               int lowpass)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n\n    int hsub = desc->log2_chroma_w;\n\n    int vsub = desc->log2_chroma_h;\n\n    int plane, j;\n\n\n\n    for (plane = 0; plane < desc->nb_components; plane++) {\n\n        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;\n\n        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;\n\n        uint8_t *dstp = dst_frame->data[plane];\n\n        const uint8_t *srcp = src_frame->data[plane];\n\n\n\n        av_assert0(cols >= 0 || lines >= 0);\n\n\n\n        lines = (lines + (field_type == FIELD_UPPER)) / 2;\n\n        if (field_type == FIELD_LOWER)\n\n            srcp += src_frame->linesize[plane];\n\n        if (field_type == FIELD_LOWER)\n\n            dstp += dst_frame->linesize[plane];\n\n        if (lowpass) {\n\n            int srcp_linesize = src_frame->linesize[plane] * 2;\n\n            int dstp_linesize = dst_frame->linesize[plane] * 2;\n\n            for (j = lines; j > 0; j--) {\n\n                const uint8_t *srcp_above = srcp - src_frame->linesize[plane];\n\n                const uint8_t *srcp_below = srcp + src_frame->linesize[plane];\n\n                if (j == lines)\n\n                    srcp_above = srcp; // there is no line above\n\n                if (j == 1)\n\n                    srcp_below = srcp; // there is no line below\n\n                s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below);\n\n                dstp += dstp_linesize;\n\n                srcp += srcp_linesize;\n\n            }\n\n        } else {\n\n            av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2,\n\n                                srcp, src_frame->linesize[plane] * 2,\n\n                                cols, lines);\n\n        }\n\n    }\n\n}\n", "idx": 6622, "substitutes": {"s": ["sq", "aws", "sys", "p", "self", "ls", "session", "S", "client", "ses", "cs", "gs", "service", "ds", "n", "ops", "rs", "c", "sg", "ts", "services", "ss", "fs", "g", "ns", "f", "space", "acks", "ssl", "sl", "js", "b", "sk", "os", "conf", "south", "utils", "spec"], "src_frame": ["srckscope", "srcgcenter", "urg_time", "sortrettydata", "src_group", "src2fram", "srcCcenter", "srckgroup", "cmp_group", "rc2frames", "urg_frame", "sort_frame", "src_image", "src_frames", "sortrettystroke", "src_layer", "src2scene", "sortrettyframe", "srcrettyelement", "srcrettyframe", "urg_panel", "srclanemachine", "urg_machine", "srcgimage", "src_scope", "urgACtime", "srcpycolour", "srcrettydata", "src_panel", "srcdingrange", "srcdingimage", "srcgframe", "src_data", "srclanetime", "rc_frame", "srcamtime", "srcamdata", "urgACpanel", "src_colour", "src2colour", "srcamstroke", "src_scene", "cmp_frame", "src_range", "srcCframe", "rc_frames", "src_element", "srcglayer", "src_fram", "srcrettygroup", "cmpkscope", "srcrettystroke", "srcpyframe", "sort_stroke", "src_center", "srcdingframes", " src_layer", "cmpkelement", "src2frame", "rc2range", "srcpyscene", "urgACframe", "srcammachine", "urgACmachine", "sort_data", "rc_range", "rc_scene", "srcackscope", "srckelement", "srcACframe", "cmpkgroup", "srcpyfram", "src2frames", "srcCimage", "src2image", "rc_colour", "srcackgroup", "srclanepanel", "rc2image", "cmp_scope", " src_center", "src_machine", "srcrettyscope", "srclaneframe", "rc_fram", "srckframe", "src_stroke", "srcClayer", "srcACpanel", " src_image", "srcampanel", "rc_image", "cmp_element", "srcACmachine", "rc2frame", "srcdingframe", "src2range", "src_time", "srcamframe", "srcACtime", "srcackelement", "cmpkframe", "srcackframe"], "dst_frame": ["ddist_image", "dstackimage", "dst_struct", "dst_cycle", "dst2struct", "drc_frame", "ddistkline", "dstackslice", "drc_fram", "dst2Frame", "dstffram", "drc_slice", "dst_fram", "ddist_frame", "dst_layout", "drc_layout", "dst_Frame", "dst_image", "dstfframe", "dstacklayout", "dst_line", "dst2image", "dstkcycle", "dst_slice", "dstfelement", "dstfimage", "ddistkcycle", "dst_element", "dstkline", "drc_struct", "dstkimage", "dstkframe", "ddist_line", "ddistkframe", "ddist_cycle", "dstackframe", "drc_Frame", "drc_image", "drc_element", "dst2frame", "ddistkimage"], "inlink": ["innlinked", "insLink", "outlink", "incline", "INlink", "incload", "insink", " inband", "outLink", "incband", " inink", "innink", "insload", "inslinked", "outload", " infer", "INLink", " inlinked", "insband", " inLink", "outline", " incomplete", "inscomplete", "insline", "inccomplete", "infer", "inband", "innlink", "INline", "inLink", "innload", "incomplete", "inlinked", "inclink", "inload", " inload", "INink", "inink", "INload", "incink", "incfer", "INfer", "inslink", "outband"], "field_type": [" field_name", " field_key", "function_tag", "field_class", "fieldgtype", "field_status", "field_index", "fieldtypename", " field_tag", " field_class", "field_format", "function_level", "function_type", "field_object", " field_status", "field_name", "fieldtypeindex", " field_index", "field_tag", "fieldgname", "fieldgstatus", "fieldgclass", "fieldtypetype", " field_object", "field_key", "function_format", "field_level"], "lowpass": ["secondpass", "lowstrip", "lowfail", "Lowswitch", "highpass", "LowPASS", "highswitch", "lowPASS", "Lowfail", "lowcross", " lowPass", "lowercross", "lowPass", " lowswitch", "secondcross", "lowswitch", "highfail", "lowerPASS", "lowerpass", "Lowstrip", "LowPass", "secondPASS", "lowerstrip", "Lowpass", "highPass", "Lowcross", " lowfail", "secondstrip"], "desc": ["ext", "uc", "dir", "sec", "dist", "def", "de", "text", "loc", "enc", "anc", "decl", "src", "dep", "org", "esc", "sc", "conn", "cod", "config", "meta", "ind", "asc", "txt", "init", "des", "dc", "rec", "summary", "description", "acc", "comment", "ec", "cv", "info", "Desc", "code", "sub", "gen", "disc", "doc", "comp"], "plane": ["pos", "note", "plot", "frame", "sample", "scale", "drive", "slice", "type", "site", "fle", "file", "f", "kat", "lin", "pe", "category", "side", "unit", "pose", "fly", "zone", "lines", "limit", "key", "grade", "rule", "module", "position", "mode", "ion", "period", "weight", "day", "page", "plate", "network", "group", "axis", "size", "code", "lane", "direction", "planes", "flo", "component", "card", "p", "connection", "flow", "style", "clip", "line", "n", "gap", "character", "qa", "den", "gate", "level", "ge", "plan", "cycle", "cell", "car", "fl", "date", "scope", "flat", "pen", "pin", "sea", "ane", "pl", "core", "charge", "drop", "force", "source", "jet", "user", "flight", "letter", "pixel", "band", "age", "port"], "j": ["bi", "pos", "note", "y", "k", "section", "aj", "e", "key", "jc", "fl", "p", "sync", "h", "jit", "jl", "ij", "position", "jam", "ali", "line", "ji", "dj", "n", "l", "jp", "jo", "c", "t", "g", "jon", "f", "range", "ja", "jet", "kj", "uj", "syn", "jen", "axis", "i", "o", "it", "x", "fr", "job", "span", "z", "js", "b", "adj", "oj", "v", "J", "jj", "li"], "dstp": ["dscnp", "dshlp", "dshP", "dshp", "slice", "img", "dostpr", "Dstfp", "dftfp", "Dostp", "dstrp", "Dstp", "dostP", " dstc", "dscpr", "dstl", "dostl", "dscp", "dschp", "dsthp", " dsthp", "dessfp", "dostp", "dostfp", "dstrpr", "Dstpr", "dftc", "dessc", "Dstnp", " dostlp", "dstP", "dstel", "dostc", "dstlp", "dscc", "dessp", " dostc", " dschp", "full", " dscc", "Dostnp", "dstfp", "Dostfp", "dstnp", "Dstl", "all", " dostp", "dstep", "_", "dosthp", " dstl", "feed", "dftP", "dftlp", " dscl", "dstrc", "Dstc", "dostnp", "dshc", "Dostc", "dostlp", "dstpr", "dstrnp", "dstc", "dscl", "dftp", "dftl", "Dostpr", " dstlp", "dstehp", "dstec", "Dostl", " dstP", "pixel", "dessl", " dostP", " dscp"], "srcp": ["syncapi", "srcpre", "rcpc", "rssr", "rcn", "srcf", "surnp", "srcpart", " srcc", "srcn", "stb", "syncn", "srcP", "serp", "rsspre", "serpe", "surp", "rcv", "stpc", "rcapi", "stc", "srcv", "ostc", " srcP", " srcf", "serP", "srcapi", "rcc", "sortp", "rcpart", "srcb", "sourcep", "srcpe", "rcpre", "rssv", " srcn", "sslpr", "rssf", "serf", "syncp", "sortc", "ostpc", "sortpr", " srcpr", "srcpr", "sslapi", "sourceP", "rcp", "surP", "rcpe", "srcc", "sslp", "sourcer", "ssln", "srcr", "srcnp", "rcr", "rcnp", "rcf", "rssp", "rsspart", "syncpr", "rcpr", "rssnp", "stp", "ostp", "rcP", "rssP", " srcpart", "sourcef", "rcb", "srcpc", " srcv", "rssn", "surpre", " srcpe", "ostb"], "srcp_above": ["srcp_bottom", "srcP_above", "srcpacupper", "srcpacbreaking", "srcP_around", "srcP_upper", "srctp_bottom", "srcp_inside", "srcp_breaking", "srcp_around", "srcpacabove", "srcpAaround", "srctp_above", "srcpAbelow", "srcpacbottom", "srctp_upper", "srcp_rising", "srctp_breaking", "srcp_upper", "srcpAabove", "srcP_below", "srcpAupper"], "srcp_below": ["srcp_bottom", "srcc_bottom", "srcP_above", "srcpacbelow", "srcpacsecondary", "srcp_sharing", "srcp_Below", "srcpacabove", "srcc_behind", "srcP_Below", "srcc_sharing", "srcp_behind", "srcpacBelow", "srcp_running", "srcP_below", "srcp_secondary", "srcP_secondary", "srcc_below"]}}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n", "idx": 6628, "substitutes": {"env": ["output", "context", "scope", "data", "ext", "vm", "np", "end", "target", "cp", "db", "e", "enc", "exc", "er", "core", "server", "ea", "event", "done", "style", "conn", "vs", "config", "ev", "viron", "et", "stage", "obj", "enable", "net", "c", "eng", "entry", "ctx", "ah", "inst", "ec", "en", "err", "iv", "manager", "cf", "erv", "code", "here", "state", "ptr", "conf", "v", "environment"]}}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n", "idx": 6635, "substitutes": {"errp": ["irp", "erP", "errr", "irpc", "Erpre", "erip", "erp", "erc", " errpc", "errP", " errip", "ercp", "aerip", "erpc", "errip", " errcp", "ErP", "errcp", "aerp", "irr", "erpre", "errpc", "aercp", " errP", "errpre", " errr", "err", " errc", " errpre", "errc", "Erp", "aerr", "irc", "Erpc"], "cs": ["CS", "pc", "rc", "ras", "wcs", "core", "cc", "sys", "cons", "sync", "ks", "ls", "cus", "ce", "ps", "sc", "conn", "ct", "acs", "ds", "cms", "ck", "c", "css", "ctx", "cells", "cr", "fs", "ns", "ec", "cases", "cache", "cf", "ca", "tc", "cn", "lc", "ac", "js", "cas", "sk", "Cs", "ics", "ced", "cks", "vc", "bs", "ces", "cb", "qs", "cing", "spec"], "cpu": [" CPU", "uu", "pc", "vm", "proxy", "np", "fps", "proc", "pai", "uo", "aco", "loader", "lb", "gpu", "core", "clus", "cli", "sync", "que", "gc", "clock", "cus", "coe", "conn", "auc", "num", "lu", "processor", "roc", "nic", "kernel", "chu", "runner", "cca", "uci", "bench", "ck", "c", "css", "ctx", "bc", "px", "uno", "platform", "console", "hw", "gp", "cache", "fc", "cu", "ca", "colo", "chip", "cn", "eni", "lc", "pu", "lan", "node", "cmp", "cp", "cpp", "unit", "computer", "uca", "CPU"]}}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n", "idx": 6641, "substitutes": {"env": ["context", "scope", "ext", "vm", "eu", "np", "oa", "db", "loader", "e", "enc", "exc", "er", "core", "export", "ea", "event", "server", "args", "style", "buf", "conn", "vs", "ep", "ev", "config", "viron", "dict", "et", "gear", "obj", "c", "her", "eng", "ctx", "nw", "console", "ec", "en", "el", "cache", "err", "dev", "code", "here", "state", "grad", "conf", "v", "environment", "dat"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter(uint8_t *src,\n\n                                                   const int step,\n\n                                                   const int stride,\n\n                                                   const int filter_p1,\n\n                                                   const int filter_q1,\n\n                                                   const int alpha,\n\n                                                   const int beta,\n\n                                                   const int lim_p0q0,\n\n                                                   const int lim_q1,\n\n                                                   const int lim_p1)\n\n{\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int i, t, u, diff;\n\n\n\n    for (i = 0; i < 4; i++, src += stride) {\n\n        int diff_p1p0 = src[-2*step] - src[-1*step];\n\n        int diff_q1q0 = src[ 1*step] - src[ 0*step];\n\n        int diff_p1p2 = src[-2*step] - src[-3*step];\n\n        int diff_q1q2 = src[ 1*step] - src[ 2*step];\n\n\n\n        t = src[0*step] - src[-1*step];\n\n        if (!t)\n\n            continue;\n\n\n\n        u = (alpha * FFABS(t)) >> 7;\n\n        if (u > 3 - (filter_p1 && filter_q1))\n\n            continue;\n\n\n\n        t <<= 2;\n\n        if (filter_p1 && filter_q1)\n\n            t += src[-2*step] - src[1*step];\n\n\n\n        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n\n        src[-1*step] = cm[src[-1*step] + diff];\n\n        src[ 0*step] = cm[src[ 0*step] - diff];\n\n\n\n        if (filter_p1 && FFABS(diff_p1p2) <= beta) {\n\n            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n\n            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n\n        }\n\n\n\n        if (filter_q1 && FFABS(diff_q1q2) <= beta) {\n\n            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n\n            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n\n        }\n\n    }\n\n}\n", "idx": 6646, "substitutes": {"src": ["fn", "stack", "conv", "dist", "text", "d", "sync", "slice", "download", "site", "img", "s", "sr", "bc", "sit", "sound", "stream", "rob", "data", "ui", "sites", "sq", "input", "view", "sb", "upp", "selected", "r", "bb", "config", "dest", "hl", "ind", "cont", "txt", "rest", "st", "inst", "cv", "secure", "size", "https", "rb", "cb", "http", "comp", "send", "pull", "reverse", "uc", "rc", "sec", "url", "gb", "rss", "sys", "gs", "lib", "go", "files", "c", "tmp", "sup", "host", "g", "console", "us", "req", "ssl", "supp", "feat", "_", "sl", "rect", "length", "transform", "spec", "sci", "scope", "proc", "loc", "gz", "sc", "support", "remote", "usr", "chrom", "impl", "gl", "ctx", "bg", "cur", "source", "sn", "fc", "iv", "pack", "attr", "sel", "obl", "stat"], "step": ["ste", "frame", "push", "set", "sample", "scale", "sleep", "name", "d", "sync", "slice", "pad", "id", "dim", "ip", "space", "trial", "grad", "lock", "batch", "depth", "form", "seed", "input", "key", "grade", "test", "config", "change", "stage", "load", "mode", "run", "layer", "dc", "weight", "path", "page", "start", "group", "part", "loop", "shape", "store", "direction", "steps", "sec", "piece", "move", "flow", "dash", "patch", "sign", "block", "repeat", "pass", "prop", "amp", "delay", "route", "length", "wait", "access", "transform", "split", "mix", "progress", "walk", "drop", "STEP", "stop", "skip", "version", "pointer", "Step", "phase", "band"], "stride": [" strince", "strange", "STRide", "striding", "slince", "stiding", "Stride", "StrIDE", "striide", "slange", " strange", "STRince", "stided", "slide", "strided", "strides", "Strided", " strides", "striided", "stide", "STRange", "Striding", "stIDE", "striiding", "slides", "striIDE", "STRides", "strIDE", "strince"], "filter_p1": ["filter_q7", "filter_p0", "filter_P2", "filter_p7", "filter_k61", "filter_q01", "filter_param50", "filter_c2", "filter_c91", "filter_q3", "filter_p3", "filter_c3", "filter_P1", "filter_param2", "filter_q2", "filter_q50", "filter_pc7", "filter_p01", "filter_k2", "filter_p2", "filter_P0", "filter_q61", "filter_q91", "filter_P3", "filter_param1", "filter_p50", "filter_p61", "filter_v7", "filter_v01", "filter_ps2", "filter_ps91", "filter_v2", "filter_pc2", "filter_pc1", "filter_c1", "filter_c0", "filter_q0", "filter_p91", "filter_v1", "filter_k1", "filter_ps0", "filter_k50", "filter_pc01", "filter_param61", "filter_ps1"], "filter_q1": ["filter_p0", "filter_q9", "filter_qa2", "filter_dqb", "filter_h9", "filter_c2", "filter_p9", "filter_q8", "filter_dq8", "filter_qa8", "filter_q3", "filter_p3", "filter_c3", "filter_h0", "filter_h2", "filter_q2", "filter_p8", "filter_v0", "filter_k2", "filter_qab", "filter_p2", "filter_dq9", "filter_dq2", "filter_v3", "filter_dq1", "filter_kone", "filter_cone", "filter_pone", "filter_dq0", "filter_k0", "filter_qb", "filter_v2", "filter_h1", "filter_c1", "filter_qa1", "filter_c0", "filter_q0", "filter_v1", "filter_pb", "filter_k1", "filter_qone"], "alpha": ["audio", "pi", "appa", "da", "area", "margin", "scale", "error", "ho", "p", "acl", "filter", "phi", "offset", "inc", "hi", "asc", "Beta", "c", "ta", "sup", "lambda", "a", "qa", "\u03b1", "ma", "mu", "x", "amp", "pha", "la", "ac", "attr", "igma", "Alpha", "aa", "si"], "beta": ["bi", "pb", "sum", "neg", "margin", "scale", "error", "\u03b2", "negative", "params", "sc", "phi", "offset", "ii", "unit", "config", "pa", "Beta", "ba", "ta", "tmp", "bc", "lambda", "gap", "acc", "bis", "qa", "mu", "eta", "tc", "pha", "ac", "b", "Alpha", "zero", "binary", "si"], "lim_p0q0": ["lim_p0dq0", "lim_p1p2", "lim_p1q2", "lim_p0Q2", "lim_p0p1", "lim_p1q10", "lim_p0p0", "lim_p1p10", "lim_p0q2", "lim_p0Qi", "lim_p0q10", "lim_p1q1", "lim_p1q6", "lim_p0p6", "lim_p0qi", "lim_p1qi", "lim_p1p0", "lim_p0Q0", "lim_p0q6", "lim_p0c1", "lim_p1p1", "lim_p0qa0", "lim_p0p2", "lim_p1p6", "lim_p1pi", "lim_p0dq1", "lim_p1q0", "lim_p0Q1", "lim_p0pi", "lim_p0dq2", "lim_p0c10", "lim_p0c6", "lim_p0q1", "lim_p0qa6", "lim_p0dqi", "lim_p0p10", "lim_p0c0", "lim_p0qa1", "lim_p0qa10"], "lim_q1": ["lim_Q1", "lim_Q01", "lim_Q0", "lim_q01", "lim_q0", "lim_p2", "lim_q2", "lim_p0", "lim_qa01", "lim_qa2", "lim_qa1", "lim_Q2", "lim_p01", "lim_qa0"], "lim_p1": ["lim_p86", "lim_n1", "lim1q0", "lim_P0", "lim_n4", "lim_q0", "lim_P2", "lim1q2", "lim_p2", "lim_P86", "lim1p1", "lim_n0", "lim1q86", "lim_qa86", "lim_q2", "lim_p0", "lim1q1", "lim_q86", "lim_qa2", "lim_q4", "lim_p4", "lim1p0", "lim_P1", "lim_qa1", "lim1p86", "lim1p2", "lim_n2", "lim_qa0", "lim_P4"], "cm": ["nm", "msg", "gm", "CM", "rc", "comm", "url", "rm", "wm", "co", "core", "cc", "cons", "acl", "bm", "sm", "gc", "client", "module", "cs", "config", "cmd", "fm", "sem", "ctr", "m", "c", "ctx", "bc", "cr", "ym", "ctrl", "mc", "cl", "tm", "conf", "rom", "cam", "fc", "iam", "cf", "ca", "im", "km", "cn", "ci", "lc", "com", "cb", "dem", "fp", "cp", "con", "asm"], "i": ["ui", "bi", "y", "index", "pi", "k", "ie", "j", "di", "e", "d", "si", "fi", "ti", "p", "li", "h", "mi", "phi", "qi", "ii", "hi", "at", "n", "l", "ni", "chi", "ip", "m", "c", "f", "zi", "io", "ini", "o", "it", "im", "xi", "mu", "ci", "b", "iu", "I", "ai", "v", "x"], "t": ["tg", "y", "j", "total", "text", "e", "d", "dt", "tp", "ti", "p", "T", "template", "port", "h", "type", "test", "r", "out", "tt", "at", "ret", "n", "l", "tu", "txt", "temp", "m", "c", "ts", "ta", "tmp", "g", "f", "pt", "te", "tr", "tw", "tm", "a", "w", "o", "it", "wt", "tc", "nt", "z", "b", "qt", "ot", "tf", "q", "v", "x"], "u": ["ui", "flat", "y", "ou", "k", "uid", "total", "nu", "e", "d", "p", "ur", "ul", "h", "up", "r", "ue", "n", "l", "ut", "tu", "U", "m", "c", "ta", "uv", "f", "o", "mu", "w", "tc", "pu", "su", "b", "q", "unit", "v", "x"], "diff": ["low", "split", "new", "form", "mix", "help", "ref", "dist", "def", "ie", "progress", "error", "fail", "e", "d", "end", "eff", " delta", "charge", "slice", "edit", "test", "changed", " difference", "change", "config", "patch", "distance", "l", "sect", "load", "temp", "add", "version", "f", "shift", "range", "comment", "qa", "conf", "part", "Diff", "err", "dev", "mu", "md", "edge", "ge", "desc", "dx", "null", "del", "different", "comp", "cmp", "iff", "update", "x"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650, "substitutes": {"xendev": ["wxenderv", "txendingr", "xendow", "xendedow", "Xenderv", "ystartoc", "xstartoc", "xendedev", "Xendev", "xenderv", "exndev", "ystartdev", "xentoc", "ystartep", "yendoc", "xendoc", " xestever", "xendedee", "xentep", "xstartep", "xEnderv", "exendever", "wxendev", " xestdev", "exenddev", "xindever", "xendingev", "xendove", "xendown", "txendingev", "exndee", " xestee", "wxentev", "xstartev", "exendee", "xendingow", "xindee", "Xenddev", "Xendedove", "xnddev", "xnderv", "exendev", "exndever", "xendsdev", "xentdev", "xstartdev", "Xendedev", "xEndev", "xestdev", "ystartev", "wxenterv", "xndever", " xendee", "xendee", "xndee", "yendev", "yenddev", "wxendown", "txendr", "txendingerv", "xendever", "xenddev", "xEndow", "xendr", "xendeddev", "exnddev", "xentown", "xndown", "xendedove", "xendedown", "xendedr", "wxentown", "txendev", " xestev", "xendederv", " xendever", "xendingr", "Xendeddev", "xendingerv", "xendsoc", "xestever", "xentever", "yendep", "xenterv", "xendep", "xendsep", "xEndr", "txendingow", "xndev", "xestee", "wxenddev", "xendsev", "xindev", "wxentdev", "xinddev", "xentev", "xentee", " xenddev", "xestev", "Xendederv", "txenderv", "xendingove", "Xendove", "xendingdev", "txendow", "xendedever", "xndove"], "con": ["an", "CON", "pen", "uc", "fa", "fn", "bn", "conv", "pin", "canon", "pc", "func", "sec", "fun", "acon", "fat", "co", "exec", "core", "cc", "cons", "ban", "open", "container", "connection", "hel", "don", "un", "client", "conn", "ann", "cm", "pan", "connect", "ocon", "c", "run", "can", "cr", "wan", "gin", "ctrl", "scan", "cat", "cl", "en", "Con", "common", "non", "cache", "fc", "ran", "ec", "syn", "cf", "ca", "cn", "close", "ac", "ain", "fac", "col", "conf"]}}
{"project": "FFmpeg", "commit_id": "8772d2511a4ac45f275eaef2b4b6b1ef132c993b", "target": 1, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n", "idx": 6670, "substitutes": {"num": ["nam", "nm", "pos", "sum", "fn", "index", "uu", "np", "split", "end", "number", "one", "on", "nu", "name", "umi", "param", "loc", "len", "multi", "typ", "dom", "ul", "no", "test", "offset", "inc", "gnu", "um", "uni", "u", "off", "nom", "id", "n", "ctr", "mn", "dim", "lim", "inf", "temp", "init", "nb", "min", "en", "max", "common", "bin", "mult", "i", "coord", "prefix", "mom", "NUM", "valid", "node", "Num", "con", "term", "zero", "unit", "hom"]}}
{"project": "qemu", "commit_id": "2e63eb2becc228232f12a1ea30a91b2aa8c5cecd", "target": 1, "func": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};", "idx": 6674, "substitutes": {"klass": ["okclass", "kcl", "kla", "skcl", "skll", "skla", "skclass", "skass", "sklass", "keclass", "cll", "okazz", "class", "kclass", " kla", "kelass", "kass", "oklass", "kazz", " kcl", " kazz", "keass", "skazz", "kela", " kclass", " kass", "okcl", "cclass", " kll", "kll", "cass"], "data": ["context", "new", "reader", "da", "def", "DATA", "result", "input", "d", "Data", "raw", "ata", "p", "params", "config", "device", "dd", "m", "ctx", "rec", "array", "parent", "i", "info", "dat"], "dc": ["nc", "da", "dir", "di", "director", "db", "deck", "d", "tk", "cc", "dt", "df", "design", "sc", "config", "ds", "cdn", "cca", "dd", "c", "enter", "bc", "acc", "draw", "mc", "ec", "dk", "writer", "fc", " DC", "cf", "tc", "ga", "dr", "lc", "cd", "DC", "ac", "desc", "disc", "doc", "dat"], "k": ["ak", "j", "kid", "e", "tk", "d", "ik", "key", "cc", "self", "p", "ks", "kw", "ko", "K", "kin", "kk", "kick", "ku", "ki", "u", "ka", "ijk", "ck", "c", "m", "g", "f", "kt", "mk", "dk", "i", "kn", "o", "kr", "uk", "ad", "it", "w", "sk", "ok", "q", "ke", "work", "wk"]}}
{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n", "idx": 6685, "substitutes": {"ohci": ["ehcu", "hc", "ihcu", " ohsci", "ohcu", "ihdi", "ehc", "hsci", "ohca", "ehlc", "ovcu", "ohcci", "ihca", " ohcu", "bhsci", "ihc", "ehca", "ehcci", "ahki", "hcci", "ihcci", "hci", "ahcu", "ehdi", "ehci", "ohlc", "ohdi", "ovci", "ahci", "ihki", "ohki", "bhcu", "hlc", "ihlc", "ovc", "ahcci", "bhlc", "ehsci", "ahc", "ehki", "ahdi", "bhci", "ovcci", "ohsci", "ihci", "ohc", " ohlc", "ahca", "hcu", "ihsci"]}}
{"project": "qemu", "commit_id": "3ac2f2f765a0bc18dfb18c38a522e6123289ffc1", "target": 1, "func": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}", "idx": 6699, "substitutes": {"func_fprintf": ["func_tfprintf", "func_tfursive", "func_fursive", "func_cprintf", "func_fprintln", "func_ufwrite", "func_ufriter", "func_sfold", "func_tfwrite", "func_sfprintln", "func_friter", "func_Fwrite", "func_cprint", "func_cold", "func_cprintln", "func_Fursive", "func_tfprintln", "func_fold", "func_ufursive", "func_Fprintf", "func_tfold", "func_ufprintf", "func_sfprint", "func_sfprintf", "func_fwrite", "func_fprint", "func_tfriter", "func_Friter", "func_tfprint"], "f": ["func", "new", "fn", "j", "e", "d", "fx", "fi", "self", "p", "df", "function", "h", "F", "u", "sf", "fm", "n", "l", "fd", "m", "c", "t", "fs", "g", "i", "o", "cf", "fr", "b", "tf", "fp", "fl", "x"], "info_spec": [" info_Spec", " info_complete", "info_parse", " info_SPEC", "info_Spec", " info_parse", "info_SPEC", "info_complete"], "obj": ["pos", "fn", "object", "oa", "url", "j", "result", "name", "eff", "coll", "str", "val", "self", "p", "arr", "bj", "api", "orig", "img", "u", "bot", "id", "n", "obb", "ob", "txt", "ass", "temp", "init", "ctx", "tmp", "boot", "g", "nb", "act", "art", "rev", "bis", "oi", "pt", "Obj", "parent", "i", "info", "w", "iv", "o", "objects", "js", "b", "Object", "adj", "cb", "po", "os", "fl", "x"], "data": ["pos", "object", "da", "j", "def", "di", "DATA", "error", "name", "d", "result", "rel", "value", "Data", "len", "val", "key", "raw", "li", "p", "ata", "api", "args", "style", "type", "image", "ds", "dict", "id", "n", "response", "dd", "class", "alpha", "array", "cache", "json", "info", "o", "media", "i", "attr", "results", "body", "dat"], "v": ["tv", "vim", "y", "vm", "conv", "k", "j", "vp", "lv", "e", "d", "view", "ve", "self", "vi", "p", "api", "function", "h", "vs", "ii", "ev", "u", "l", "m", "c", "t", "uv", "V", "g", "vol", "vt", "cv", "i", "o", "w", "iv", "ver", "verb", "va", "z", "sv", "ov", "b", "q", "vc", "gu", "vv", "x"]}}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 6708, "substitutes": {"avctx": ["afcmp", "avcontext", "evconn", "AVcoll", "avconn", " avcontext", " avcoll", "afctx", "afcontext", "afcoll", "AVconn", "afconn", "AVcontext", "evcmp", "evctx", "AVctx", "avcmp", "avcv", " avcmp", " avcv", "evcontext", "avcoll", "AVcmp", "AVcv", "afcv"], "data": ["ui", "pos", "object", "header", "da", "reader", "sample", "package", "DATA", "value", "input", "d", "name", "parts", "message", "result", "Data", "exec", "str", "first", "raw", "ata", "map", "slice", "dat", "buf", "pad", "record", "image", "empty", "inner", "device", "id", "block", "load", "content", "rec", "address", "next", "draw", "primary", "as", "start", "a", "parent", "cache", "ad", "media", "code", "append", "feed", "body", "window", "format", "base"], "got_sub_ptr": ["got_reg_desc", "got_subupointer", "got_subvalptr", "got_subqptr", "got_sub2tr", "got_sub_tr", "got_sub2rect", "got_subqtr", "got_reg_tr", "got_sub2ptr", "got_sub_length", "got_subfrect", "got_reg2tr", "got_subfptr", "got_sub_rect", "got_reg2rect", "got_subqrect", "got_subvallength", "got_sub_pointer", "got_subuchar", "got_subqdesc", "got_subvalchar", "got_reg2ptr", "got_subfdesc", "got_subulength", "got_subftr", "got_sub_desc", "got_subuptr", "got_sub_char", "got_reg2desc", "got_sub2desc", "got_reg_ptr", "got_reg_rect", "got_subvalpointer"], "avpkt": ["avbpkt", "avwpcht", "avprekt", "avpekt", "avspacket", "avspcht", "AVpkg", "AVcpacket", "avpeacket", "avfdt", "afpki", "avppdt", "avPkt", "avcpct", "avbpcht", "afpdt", "awwpacket", "avespcht", "avpdt", "avfpkg", "avpft", "avpacket", "avcpft", "avepdt", "avPcht", "avwpkt", "avpedt", "AVpacket", "avfpacket", "avcpnt", "avpnt", "avepreft", "AVcpkt", "avbpacket", "avopdt", "avPct", "avpkg", "awpcht", "avspkt", "avpcht", "avprent", "avwpck", "avfett", "avcpdt", "awpacket", "awpck", "avfkt", "awwpkt", "avespacket", "avpett", "avspdt", "aveprekt", "afpkt", "avcpck", "avcpacket", "avcpcht", "aveprent", "afpacket", "AVcpct", "avespkt", "avpeki", "avPkg", "avepnt", "avepkt", "affki", "awpkt", "afpett", "avspki", "affkt", "avepacket", "avwpacket", "avespdt", "avepcht", "avpredt", "avpct", "avspett", "avfki", "AVcpkg", "avepredt", "avepft", "avpck", "avcpkg", "avopacket", "avppkt", "avopkt", "awwpck", "AVpct", "affett", "avpreft", "avpki", "avfpkt", "awwpcht", "avfcht", "avPck", "avPacket", "affdt", "affacket", "avfpct", "avppnt", "AVpkt", "avppft", "avopett", "avfacket", "avcpkt", "avbpdt"], "sub": ["ub", "pb", "func", "builder", "uc", "rc", "member", "sec", "small", "section", "split", "form", "j", "pre", "ab", "text", "name", "pl", "super", "slice", "type", "buf", "sc", "r", "config", "sp", "per", "child", "rec", "sup", "summary", "sa", "part", "info", "sl", "match", "job", "desc", "b", "sel", "Sub"], "buffer": ["batch", "context", "builder", "header", "reader", "ref", "result", "text", "input", "queue", "message", "Buffer", "str", "row", "server", " Buffer", "byte", "window", "slice", "buf", "pad", "record", "sc", "processor", "position", "file", "read", "buff", "m", "v", "transfer", "bc", "surface", "f", "pointer", "summary", "source", "FFER", "array", "copy", "uffer", "writer", "cache", "reference", "table", "uf", "b", "null", "iter", "ptr", "stream", "fp", "parser", "binary", "seek", "base"], "size": ["pos", "sum", "from", "scale", "name", "args", "type", "esc", "uni", "any", "Size", "f", "en", "count", "unit", "ui", "form", "member", "grade", "offset", "channel", "position", "ize", "sized", "address", "page", "code", "shape", "send", "body", "year", "scene", "rc", "storage", "sec", "small", "number", "general", "len", "last", "SIZE", "use", "password", "large", "c", "g", "capacity", "original", "length", "x", "extra", "loc", "e", "core", "empty", "external", "source", "sn", "max", "cache", "ci"], "ret": ["ext", "rc", "re", "ref", "url", "def", "mt", "result", "success", "fun", "alt", "att", "db", "back", "error", "len", "val", "str", "std", "base", "no", "last", "num", "full", "RET", "r", "resp", "reg", "id", "res", "obj", "tmp", "rev", "lit", "en", "flag", "err", "det", "ft", "al", "match", "nt", "code", "reply", "rem", "valid", "arg", "rets", "Ret", "rt"], "p": ["py", "pc", "pi", "np", "j", "pre", "e", "d", "tp", "op", "api", "h", "pad", "up", "r", "pa", "u", "sp", "current", "at", "P", "per", "ap", "ip", "l", "n", "m", "c", "t", "ctx", "f", "pointer", "g", "pp", "point", "wp", "part", "i", "o", "w", "lp", "pe", "bp", "b", "post", "po", "cp", "v", "x", "port"], "s": ["context", "storage", "sec", "sq", "sb", "server", "sys", "self", "spec", "api", "S", "ps", "sc", "is", "ses", "cs", "gs", "r", "service", "sf", "ops", "ss", "c", "sg", "v", "m", "ctx", "fs", "g", "ns", "f", "space", "ssl", "sv", "su", "b", "parser", "qs", "si"]}}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n\n{\n\n    YADIFContext *s = ctx->priv;\n\n    ThreadData *td  = arg;\n\n    int refs = s->cur->linesize[td->plane];\n\n    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;\n\n    int pix_3 = 3 * df;\n\n    int slice_h = td->h / nb_jobs;\n\n    int slice_start = jobnr * slice_h;\n\n    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;\n\n    int y;\n\n\n\n    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,\n\n     * we need to call the c variant which avoids this for border pixels\n\n     */\n\n    for (y = slice_start; y < slice_end; y++) {\n\n        if ((y ^ td->parity) & 1) {\n\n            uint8_t *prev = &s->prev->data[td->plane][y * refs];\n\n            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];\n\n            uint8_t *next = &s->next->data[td->plane][y * refs];\n\n            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n\n            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;\n\n            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,\n\n                           next + pix_3, td->w - 6,\n\n                           y + 1 < td->h ? refs : -refs,\n\n                           y ? -refs : refs,\n\n                           td->parity ^ td->tff, mode);\n\n            s->filter_edges(dst, prev, cur, next, td->w,\n\n                            y + 1 < td->h ? refs : -refs,\n\n                            y ? -refs : refs,\n\n                            td->parity ^ td->tff, mode);\n\n        } else {\n\n            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n\n                   &s->cur->data[td->plane][y * refs], td->w * df);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6727, "substitutes": {"ctx": ["context", "sci", "pc", "rc", "ref", "cal", "sq", "cc", "gc", "sc", "conn", "ct", "xc", "cm", "cs", "config", "ds", "cmd", "cca", "tx", "Context", "c", "bc", "kb", "ctrl", "mc", "cv", "pkg", "fc", "cf", "ca", "tc", "ci", "lc", "cas", "cb", "cmp", "bt", "cp"], "arg": ["pc", "cand", "ref", "argument", "param", "input", "att", "enc", "exec", "val", "call", "anc", "p", "arr", "args", "arm", "ann", "ace", "ang", "Args", "obj", "inter", "arc", "g", "ig", "array", "mac", "ad", "ar", "amp", "ray", "ag", "ac", "arp", "Arg", "ai", "cell"], "jobnr": [" jobnom", "queuenw", "queuenl", "pluginnr", "Jobrn", "worknu", "queuenu", "jobnumber", "magrn", "jobnom", "casenr", "pluginnw", "Jobnumber", "jobNR", "jobnu", "bugnr", "layernl", "JobNR", "casern", "bugnu", "jobnl", " jobnu", "bugnw", "layernw", " jobnl", "jobrn", " jobnumber", "magnr", " jobnw", "queuenr", "bugNR", "layernu", "caseNR", "magnw", "pluginrn", "Jobnr", "layernr", "magnom", " jobNR", "worknr", "worknw", "workNR", "pluginnom", "jobnw", " jobrn", "casenumber"], "nb_jobs": ["nbwlines", "num_dates", "nbOfdates", "num_jobs", "nbOflines", "num_lines", "nb_dates", "np_steps", "nbwsteps", "nb_pages", "np_lines", "nbjpoints", "nb_images", "nb_steps", "np_jobs", "nr_points", "nrofpoints", "nb_pieces", "nbjpieces", "nbwblocks", "nb__lines", "nb__dates", "nbwjobs", "nb_points", "nbjimages", "nbofpieces", "nb__jobs", "nbOfpages", "nb__pages", "nb_blocks", "nrofjobs", "nbOfjobs", "nrofimages", "nbofjobs", "nbjjobs", "nr_pieces", "nbofpoints", "num_pages", "nb__blocks", "np_blocks", "nr_jobs", "nb__steps", "nr_images", "nbofimages", "nrofpieces", "nb_lines"], "s": ["sci", "sq", "ans", "sam", "si", "d", "e", "sb", "m", "so", "sys", "self", "p", "sync", "ks", "sm", "ls", "session", "S", "h", "ps", "sc", "args", "ses", "cs", "gs", "this", "service", "sf", "ds", "u", "n", "l", "ss", "c", "sg", "ts", "t", "sh", "services", "st", "fs", "g", "f", "ns", "sa", "a", "ssl", "south", "se", "i", "sl", "sis", "sv", "sd", "sk", "js", "su", "b", "bs", "os", "conf", "qs", "rs", "utils", "spec"], "td": ["dn", "pc", "od", "lv", "d", "dt", "pod", "std", "dim", "rd", "tl", "ta", "dad", "nd", "table", "ft", "bd", "zh", "ht", "south", "wd", "li", "data", "pb", "SD", "vd", "att", "sb", "dh", "typ", "lt", "tt", "elt", "ind", "direct", "ts", "t", "chart", "kt", "tm", "tif", "wp", "BT", "det", "cd", "tg", "gb", "tk", "style", "cod", "kernel", "butt", "fd", "hd", "pdf", "pt", "ctl", "ssl", "gt", "ad", "nt", "lf", "pd", "dat", "di", "th", "tn", "pl", "cz", "metadata", "dial", "ds", "dal", "cdn", "dd", "TD", "dl", "phy", "dev", "ud", "md", "span", "ff", "sd", "edd", "tf", "ld", "rt"], "y": ["py", "oy", "ty", "ys", "zy", "yd", "j", "ady", "e", "d", "ny", "yy", "yt", "icy", "key", "iy", "ey", "yi", "sky", "p", "sys", "ry", "yan", "h", "hy", "ye", "ay", "yer", "type", "ory", "ii", "sy", "ind", "id", "n", "cy", "yo", "vy", "fy", "yl", "gy", "c", "m", "t", "dy", "ym", "yu", "yn", "isy", "Y", "iny", "uy", "my", "i", "w", "ky", "yr", " Y", "idy", "python", "z", "b", "ya", "year", "wy", "x"], "prev": ["data", "reverse", "vious", "frame", "before", "header", "rc", "pub", "k", "pre", "rel", "loc", "back", "view", "vert", "self", "p", "ur", "src", "last", "h", "orig", "history", "up", "sav", "old", "r", "current", "head", "per", "jp", "inter", "rec", "f", "rev", "start", "cv", "upper", "info", "dev", "front", "original", "Prev", "gen", "b", "desc", "iter", "pres", "adj", "nav", "cmp", "post", "cp", "pred", "v", "adr", "first"], "cur": ["ub", "uc", "rc", "frame", "conv", "pub", "end", "th", "loc", "back", "enc", "coll", "ser", "Cur", "er", "vert", "open", "sur", "ur", "mid", "src", "up", "inc", "pr", "cour", "r", "ch", "head", "usr", "ind", "ctr", "per", "tur", "keep", "var", "sr", "rest", "inter", "cr", "fer", "chart", "tr", "rev", "tri", "cat", "cv", "req", "start", "cache", "der", "cer", "se", "ver", "fr", "dr", "tra", "desc", "iter", "pri", "cmp", "con", "row", "serv", "sel", "car"], "next": ["data", "pos", "new", "vious", "frame", "sec", "future", "end", "ner", "pre", "vert", "now", "open", "self", "p", "mid", "done", "last", "inc", "latest", "ne", "current", "head", "Next", "line", "follow", "child", "skip", "gov", "c", "all", "path", "rev", "nd", "other", "start", "max", "min", "non", "dev", "front", "nt", "z", "state", "gen", "desc", "post", "doc", "more", "first"], "dst": [" dsc", "vdsc", "Dest", " dost", " drc", "sdsts", "adST", " dST", "Drc", "dST", " dsts", "adrc", "drc", "Dsc", "dest", "Dost", "dost", "vdsts", "sdost", " dest", "adsc", "adost", "vdst", "dsts", "adst", "Dst", "sdest", "dsc", "adsts", "vdST", "Dsts", "sdst"]}}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n", "idx": 6753, "substitutes": {"cpu": [" CPU", "dylib", "pc", "rc", "np", "vm", "proc", "pai", "loader", "gpu", "component", "core", "cli", "GPU", "clock", "coe", "ocr", "processor", "roc", "kernel", "jp", "hp", "plug", "c", "css", "boot", "px", "platform", "mac", "hw", "gp", "cache", "pty", "colo", "chip", "cn", "lc", "pu", "process", "cmp", "cp", "cpp", "linux", "computer", "CPU"], "eaddr": ["ewDr", "aceDr", "ADDr", "eadder", "ewDR", "awrd", "eadDr", "aceder", "adddr", "ADdr", "awDR", "ADder", "addrd", "acedr", "awdr", "awDr", "abdr", "eadDR", "ewder", "eadrd", "ewdr", "abrd", "addDr", "abDr", "addDR", "abDR", "ADDR", "aceDR"], "rwx": ["rrx", "RWxs", "wrx", "rawxx", "rawf", "ewxs", "rrex", "wrlex", "rwxs", "rwxx", "ewf", "rawxs", "wrxx", "ewxx", "rwex", "rawx", "RWx", "RWf", "rrlex", "ewx", "rwf", "wrex", "RWlex", "RWxx", "rrxx", "RWex", "rwlex"], "mmu_idx": ["mmu_Idv", "mmu_ridb", "mmu_itxs", "mmu_itv", "mmu_Idx", "mmu_Idxs", "mmu_idxs", "mmu_idv", "mmu_Idb", "mmu_itx", "mmu_ridX", "mmu_IdX", "mmu_idX", "mmu_idb", "mmu_itb", "mmu_ridx", "mmu_ridv"]}}
{"project": "FFmpeg", "commit_id": "1f361124d97cf8b8ce6d3aacb10cdc53706470de", "target": 1, "func": "int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]           = { 0 }, ret[3] = { 0 };\n\n    AVIOContext *f[3]     = { NULL };\n\n    AVCodecContext *codec = s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path,\n\n                                  s->img_number) < 0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for (i = 0; i < 3; i++) {\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if (i >= 1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",\n\n                       filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i] = avio_size(f[i]);\n\n\n\n            if (!s->split_planes)\n\n                break;\n\n            filename[strlen(filename) - 1] = 'U' + i;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_NONE) {\n\n            AVProbeData pd;\n\n            AVInputFormat *ifmt;\n\n            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];\n\n            int ret;\n\n            int score = 0;\n\n\n\n            ret = avio_read(f[0], header, PROBE_BUF_MIN);\n\n            if (ret < 0)\n\n                return ret;\n\n\n            avio_skip(f[0], -ret);\n\n            pd.buf = header;\n\n            pd.buf_size = ret;\n\n            pd.filename = filename;\n\n\n\n            ifmt = av_probe_input_format3(&pd, 1, &score);\n\n            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)\n\n                codec->codec_id = ifmt->raw_codec_id;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        if (s->frame_size > 0) {\n\n            size[0] = s->frame_size;\n\n        } else {\n\n            size[0] = 4096;\n\n        }\n\n    }\n\n\n\n    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)\n\n        return AVERROR(ENOMEM);\n\n    pkt->stream_index = 0;\n\n    pkt->flags       |= AV_PKT_FLAG_KEY;\n\n    if (s->ts_from_file) {\n\n        struct stat img_stat;\n\n        if (stat(filename, &img_stat))\n\n            return AVERROR(EIO);\n\n        pkt->pts = (int64_t)img_stat.st_mtime;\n\n        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);\n\n    } else if (!s->is_pipe) {\n\n        pkt->pts      = s->pts;\n\n    }\n\n\n\n    pkt->size = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        if (f[i]) {\n\n            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if (ret[i] > 0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        s->pts++;\n\n        return 0;\n\n    }\n\n}", "idx": 6763, "substitutes": {"s1": ["cone", " s81", "c1", "fone", "ns1", "dsons", "csone", "s11", "fs1", "sone", "ns7", "sys11", "dsrc", "src", "js1", "sc11", " sfirst", "s2", "sysrc", " sons", "sc7", "js81", "sysons", "jsfirst", "c3", "f1", "sc1", "ds1", "cs2", "s7", "ns11", " s11", "eone", "f3", "fsfirst", "s81", "sons", "ds3", "e1", "e2", " s7", "c2", "s3", "dsone", "cs1", " src", "ds11", "sys1", "fs81", "sfirst"], "pkt": ["dpacket", "Pct", " pct", "Packet", "dpct", "Ppt", " ppt", "dpkt", "packet", " packet", "ppt", "dppt", "Pkt", "pct"], "s": ["d", "sync", "args", "vs", "site", "sg", "services", "fs", "sv", "b", "sk", "conf", "v", "data", "new", "sq", "sb", "h", "ses", "cs", "r", "this", "u", "ss", "ts", "t", "ns", "a", "w", "its", "es", "http", "ins", "storage", "sec", "parts", "comments", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "ims", "sets", "xs", "stats", "n", "c", "g", "us", "ssl", "qs", "rs", "si", "spec", "y", "aws", "e", "tp", "server", "is", "sc", "service", "ds", "l", "states", "sym", "m", "ctx", "ms", "as", "settings", "o", "js", "os"], "filename_bytes": ["filename2Bytes", "filename6bytes", "filename_seconds", "filename_tes", "filename2seconds", "filename2parts", "filename_Bytes", "Filename_seconds", "sound_bytes", "Filename_Bytes", "filename6length", "filename_groups", "filename_length", "filename_lines", " filename_lines", "Filename_bytes", "filename6lines", "Filename_parts", " filename_length", "filename_parts", "sound_Bytes", "filename_bits", "filename2bytes", "Filename_bits", "sound_lines", "Filename_groups", "sound_tes"], "filename": ["data", "jpg", "nm", "ename", "wb", "fn", "phrase", "sword", "url", "Filename", "final", "name", "bf", "message", "document", "nil", "src", "metadata", "slice", "gz", "download", "whatever", "username", "image", "sf", "file", "files", "sequence", "txt", "word", "fd", "sym", "content", "fil", "kl", "STDOUT", "il", "summary", "buffer", "which", "source", "sn", "suff", "feat", "json", "kn", "prefix", "utf", "uri", "sheet", "memory", "length", "subject", "status", "dll", "fp", "binary", "output", "directory"], "i": ["ui", "bi", "split", "y", "pi", "index", "ie", "j", "di", "diff", "e", "d", "mini", "len", "multi", "fi", "cli", "ti", "p", "yi", "vi", "slice", "mi", "num", "phi", "qi", "ii", "ki", "hi", "u", "inner", "id", "n", "ni", "chi", "ip", "l", "abi", "m", "c", "layer", "ix", "oi", "zi", "io", "start", "ri", "part", "ini", "it", "gi", "x", "xi", "uri", "mu", "ci", "eni", "lc", "z", "b", "iu", "count", "I", "ai", "v", "si", "li"], "size": ["extra", "data", " sizes", "sum", "form", "member", "sec", "small", "j", "name", "value", "loc", "e", "enc", "message", "fat", "si", "len", "offset", "SIZE", "unit", "empty", "ch", "file", "fd", "ize", "sized", "content", "Size", "buffer", "g", "sn", "en", "el", "code", "z", "shape", "length", "desc", "time", "status", "body", "final", "fl", "x"], "ret": ["data", "pet", "let", "ext", "fn", "rc", "re", "detail", "ref", "flat", "def", "result", "success", "fun", "alt", "rep", "enc", "back", "att", "bf", "len", "val", " Ret", "mem", "test", "RET", "offset", "resp", "out", "lt", "reg", "id", "response", "res", "txt", "error", "temp", "buffer", "opt", "lit", "sn", "cat", "en", "flag", "el", "part", "feat", "group", "info", "det", "gt", "ft", "match", "nt", "reply", "uf", "valid", "rl", "desc", "status", "rets", "final", "Ret", "rt"], "f": ["xf", "fn", "fa", "frame", "j", "def", "e", "d", "fe", "self", "p", "rf", "df", "of", "h", "full", "F", "r", "u", "sf", "fb", "file", "l", "fd", "m", "c", "t", "fen", "fs", "g", "fc", "w", "info", "cf", "fr", "lf", "z", "b", "q", "fp", "feed", "v", "fl", "x"], "codec": ["coditor", " codric", "predoc", "predef", "predEC", "codEC", "pedef", "odeca", "Codec", "labec", "calitor", " codef", "odric", "odef", "codroc", "Codoc", "pedec", "Coditor", "CodEC", "labef", "calec", "labEC", "calroc", " codeca", "odec", "codric", "laboc", "codoc", "oditor", "pedeca", "codef", "predec", "Codef", "odroc", "pedric", "codeca", "Codroc"], "pd": ["data", " parser", "d", " def", " dc", " rec", " rc", " dev", " td", " coding", " gp", " dw", " sd", " structure", " device", " da", " buff", " cd", " d", " cc", " board", " det", " obj", " ad", " dst", " dd", " enc", " din", " props"], "ifmt": ["ifvt", "iffm", " ifvt", "ifm", "itvt", "iffmt", "iffdr", "iffvt", "itdr", "itmt", "itm", " ifm", " ifdr", "ifdr"], "header": ["data", "index", "Header", "name", "document", "len", "mask", "server", "byte", "event", "df", "metadata", "type", "h", "player", "offset", "channel", "tail", "headers", "meta", "head", "block", "content", "version", "layer", "buffer", "holder", "master", "flags", "bin", "writer", "secondary", "table", "cover", "dr", "cap", "null", "body", "token", "handler"], "img_number": ["imgIPno", "img_next", "image_first", "imglnum", "imgIPclass", "image_type", "imgIdnumber", "img_numbered", "imgknext", "image_class", "imgkno", "img_first", "img_class", "imag_nom", "image_no", "image_number", "imag_num", "imgqnumber", "imgsfirst", "image_numbered", "imgsno", "imgladdress", "imgIdnum", "imgqnext", "imag_number", "image_address", "img_work", "imgsnumber", "imgqclass", "imgIPnext", "img_num", "image_next", "image_last", "imgIdnom", "imag_work", "imgIdwork", "img_address", "imgslast", "imgknumber", "img_type", "imgltype", "img_source", "imgIPnumber", "image_source", "imgknumbered", "img_no", "img_last", "imglnumber", "image_num", "img_nom", "imgqno"]}}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 6775, "substitutes": {"opaque": ["ipace", "oppque", "oppaque", "opace", "osaques", "hopque", "hopace", "opac", "operac", "opaques", "defaque", "defac", "operaque", "oppaques", "ipque", "defaques", "osaque", "ipaque", "opque", "hopaques", "ipaques", "osac", "oppace", "hopaque", "operaques"], "addr": ["data", "pos", "nc", "pc", "ref", "len", "arr", "src", "pad", "seq", "ace", "offset", "device", "reg", "tx", "ip", "add", "address", "host", "pointer", "part", "ad", "alloc", "prefix", "dr", "ac", "arg", "port"], "val": ["data", "pos", "pc", "ref", "def", "eval", "pre", "value", "alt", "len", "mem", "arr", "slice", "bl", "pid", "stat", "reg", "block", "all", "Val", "address", "buffer", "f", "pt", "pal", "vals", "el", "slot", "cache", "sl", "VAL", "al", "x", "valid", "b", "arg", "v", "ret", "base"], "bus": ["local", "Bus", "proc", "hub", "drive", "sync", "bridge", "config", "service", "lib", "plugin", "block", "plug", "c", "boot", "bc", "host", "hole", "usb", "io", "pass", "cat", "us", "mount", "cache", "o", "BUS", "loop", "board", "http", "os", "feed", "lock", "driver"], "s": ["scope", "e", "d", "parts", "sys", "sync", "spec", "ks", "args", "ls", "params", "S", "ps", "is", "ses", "gs", "cs", "r", "u", "sf", "ds", "service", "xs", "stats", "n", "l", "states", "ops", "ss", "c", "sym", "m", "services", "t", "ts", "fs", "g", "ns", "self", "space", "f", "as", "us", "ssl", "settings", "se", "i", "o", "sl", "w", "less", "state", "su", "js", "b", "es", "ins", "hs", "os", "bs", "v", "rs", "si"], "p": ["py", "data", "pat", "pb", "y", "pi", "pc", "np", "j", "pre", "cp", "e", "d", "pl", "tp", "api", "pid", "ps", "pr", "pa", "u", "sp", "at", "dp", "P", "per", "l", "ip", "n", "ap", "c", "m", "t", "f", "pointer", "point", "pp", "i", "o", "lp", "pe", "bp", "pu", "b", "po", "q", "fp", "ptr", "v", "x"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,\n\n                                                     PutBitContext *pb, const float *in, float *out,\n\n                                                     const float *scaled, int size, int scale_idx,\n\n                                                     int cb, const float lambda, const float uplim,\n\n                                                     int *bits, const float ROUNDING)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    int qc1, qc2, qc3, qc4;\n\n\n\n    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];\n\n    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];\n\n    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    abs_pow34_v(s->scoefs, in, size);\n\n    scaled = s->scoefs;\n\n    for (i = 0; i < size; i += 4) {\n\n        int curidx, curidx2;\n\n        int *in_int = (int *)&in[i];\n\n        uint8_t v_bits;\n\n        unsigned int v_codes;\n\n        int t0, t1, t2, t3, t4, t5, t6, t7;\n\n        const float *vec1, *vec2;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                      \\n\\t\"\n\n            \".set noreorder                 \\n\\t\"\n\n\n\n            \"ori    %[t4],  $zero,  4       \\n\\t\"\n\n            \"slt    %[t0],  %[t4],  %[qc1]  \\n\\t\"\n\n            \"slt    %[t1],  %[t4],  %[qc2]  \\n\\t\"\n\n            \"slt    %[t2],  %[t4],  %[qc3]  \\n\\t\"\n\n            \"slt    %[t3],  %[t4],  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t4],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t4],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t4],  %[t3]   \\n\\t\"\n\n            \"lw     %[t0],  0(%[in_int])    \\n\\t\"\n\n            \"lw     %[t1],  4(%[in_int])    \\n\\t\"\n\n            \"lw     %[t2],  8(%[in_int])    \\n\\t\"\n\n            \"lw     %[t3],  12(%[in_int])   \\n\\t\"\n\n            \"srl    %[t0],  %[t0],  31      \\n\\t\"\n\n            \"srl    %[t1],  %[t1],  31      \\n\\t\"\n\n            \"srl    %[t2],  %[t2],  31      \\n\\t\"\n\n            \"srl    %[t3],  %[t3],  31      \\n\\t\"\n\n            \"subu   %[t4],  $zero,  %[qc1]  \\n\\t\"\n\n            \"subu   %[t5],  $zero,  %[qc2]  \\n\\t\"\n\n            \"subu   %[t6],  $zero,  %[qc3]  \\n\\t\"\n\n            \"subu   %[t7],  $zero,  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n", "idx": 6778, "substitutes": {"s": ["scope", "new", "sq", "si", "sb", "sys", "p", "sync", "self", "src", "ls", "session", "S", "ps", "sc", "is", "ses", "cs", "sets", "gs", "service", "this", "stats", "ops", "ss", "c", "rs", "ts", "services", "sg", "sup", "ns", "f", "g", "sa", "sed", "a", "ssl", "settings", "sl", "sv", "su", "b", "js", "os", "conf", "v", "south", "utils", "spec"], "pb": ["pc", "rc", "gb", "proc", "PC", "pg", "sb", "pl", "bm", "mp", "kB", "fb", "abc", "pm", "bc", "pd", "pp", "wp", "cv", "PB", "lp", "amp", "bp", "rb", "bps", "cp", "cpp", "prot"], "in": ["data", "pin", "input", "circ", "din", "isin", "src", "conn", "inc", "image", "img", "nin", "win", "query", "config", "inner", "login", "id", "into", "inf", "m", "c", "init", "again", "In", "rec", "gin", "f", "inn", "source", "pass", "scan", "ini", "bin", "err", "lin", "ins", "con", "vin", "IN", "x"], "out": ["data", "new", "outs", "result", "call", "bit", "Out", "image", "inc", "r", "OUT", "at", "cmd", "external", "temp", "m", "init", "g", "f", "source", "bin", "w", "o", "b", "doc", "output"], "scaled": ["Scared", "escalled", "SCalled", "descalled", " scalled", "scared", "scaling", "Scaped", "SCured", "captaling", "escured", "escaling", " scaped", "oscaped", " scraped", "captaled", "SCaled", "oscalled", "escaped", "SCaped", "Scaled", "oscaled", "SCaling", " scaling", "descaled", "Scalled", "scalled", "descared", "scraped", "escared", "captured", "oscaling", "Scaling", "Scraped", "descaped", "scured", "SCraped", "captalled", "escaled", "scaped"], "size": ["sum", "sec", "small", "sq", "scale", "loc", "len", "co", "grade", "sc", "cm", "uni", "SIZE", "ch", "cs", "ize", "c", "sized", "Size", "ctx", "bc", "dc", "sh", "ix", "shift", "iz", "sn", "code", "z", "shape", "six", "q"], "scale_idx": ["scale_idsn", "scale_idct", "scale_ridx", "scale_mainx", "scale_idced", "scale_fdxx", "scale_sidz", "scale_sidx", "scale_sidn", "scale_headz", "scale_headx", "scale_ridX", "scale_idX", "scale_headxx", "scale_idsxx", "scale_sidg", "scale_fdz", "scale_idsced", "scale_ridp", "scale_ridct", "scale_idg", "scale_idxx", "scale_mainct", "scale_headced", "scale_mainX", "scale_idn", "scale_fdx", "scale_idp", "scale_idsg", "scale_mainp", "scale_idsz", "scale_idz", "scale_idsx", "scale_fdced"], "cb": ["nc", "abb", "wb", "callback", "gb", "cp", "db", "loc", "bf", "sb", "core", "call", "sync", "src", "buf", "seq", "kk", "cod", "cm", "bb", "cor", "lib", "fb", "ctr", "obb", "buff", "ob", "hh", "CB", "cgi", "ctx", "bc", "dc", "cr", "nb", "repeat", "ctrl", "cv", "crop", "cf", "fee", "code", "ci", "lc", "job", "cd", "ff", "rb", "desc", "com", "cmp", "conf", "cpp", "btn"], "lambda": ["func", " gamma", "nc", "da", "appa", " delta", " mu", " disp", " dim", "beta", "phi", " lam", "inv", " omega", "abc", "LA", "aux", "dc", "alpha", "bc", " sig", "qa", "mu", "DEF", "la", "igma", " la"], "uplim": ["Uplim", "uplen", "ublen", "Uclen", "Uplike", "ublim", "uclen", "ulabib", "uclike", "uclim", "Uplen", "ublike", "Uclike", "Uclib", "ulabike", "uclib", "ulabim", "Uclim", "uplike", "Uplib", "ulaben", "uplib", "ublib"], "bits": ["pos", "fps", "gb", "pins", "parts", "blocks", "details", "codes", "hours", "bit", "forces", "config", "bytes", "pieces", "rows", "cycles", "ops", "bis", "flags", "its", "jobs", "ints", "bands", "features", "bs", "bps", "ips"], "ROUNDING": ["BOUNDED", "Brounding", "RUNING", "RroundING", "BroundED", "RUNing", "BroundING", "Rround32", "ROUND32", "ROUNDing", "Rounding32", "RUNED", "RroundED", "ROUNDED", "RUN32", "RoundingING", "RoundingED", "Roundinging", "Bround32", "BOUNDING", "Rrounding", "BOUNDing", "BOUND32"], "i": ["bi", "ui", "y", "pi", "index", "k", "ie", "ei", "j", "di", "e", "mini", "key", "multi", "fi", "ti", "p", "yi", "slice", "iq", "type", "idi", "mi", "jit", "phi", "is", "qi", "ii", "ij", "inner", "ind", "id", "n", "ni", "l", "chi", "ip", "iv", "abi", "c", "ix", "oi", "f", "g", "zi", "io", "min", "a", "ini", "info", "my", "gi", "mu", "xi", "x", "uri", "it", "ci", "eni", "z", "iu", "I", "ai", "si", "li"], "qc1": ["qdc2", " qdc2", "qe11", "qdc6", "qpc6", "qf1", "qsc2", "Qdc6", "qc0", "qf2", "Qc2", "qdc0", "qc6", " qc0", "qdc5", " qdc1", "Qc5", " qdc11", "Qc6", "qpc5", "Qdc5", "qc11", "qf0", "qdc1", "qsc6", "qsc5", "qsc1", "Qdc1", "qdc11", " qdc0", "Qc1", "qe0", "qpc1", "Qdc2", "qe1", "qc5", "qe2", "qpc2", "qf11", " qc11"], "qc2": ["qdc2", "Qdc4", "qh4", "pc2", "qdc92", "ph2", "qcc92", "qc0", "ph62", "pc4", "Qc2", "pc0", "qe4", "qh62", "qc62", "Qc4", "qv2", "qc92", "Qc02", "qc02", "qcc02", "qdc4", "qdc02", "ph0", "qac4", "qv4", "qac2", "qac92", "Qdc02", "qe62", "Qdc92", "ph4", "qv0", "qh2", "qe0", "Qc92", "qac02", "Qdc2", "qcc2", "qe2", "pc62", "qcc4", "qh0", "qv62"], "qc3": ["qlc7", "qp8", " qe7", "qc8", " qc43", " qe13", "qp43", "qe13", "qlc3", " qe43", "qe8", " qe8", "qc7", "qp7", " qe4", "qe4", " qe21", "qp3", "qlc43", "qcenter13", " qc21", "qcenter8", " qc8", "qe7", "qc43", "qp13", "qe3", "qcenter21", " qe3", "qe43", "qlc4", " qc13", " qc7", "qp21", "qc13", "qcenter3", "qc21", "qe21", "qp4"], "qc4": ["qrc44", "qh4", "qcr5", "qc8", "dqc8", "qcr4", " qc5", "dqc0", "dqrc8", "dqc44", "qc7", "qc0", " qxc7", "dqrc0", "qlc44", "qf8", "qxc7", "qh6", "qc6", "qcr6", "qrc8", "qh5", "dqrc44", "qxc5", "qc44", " qxc5", "qcr7", "qf0", " qxc4", " qxc6", "qf44", "dqrc4", "dqc4", "qxc4", "qf4", "qlc0", "qlc4", "qc5", " qc6", " qc7", "qrc4", "qlc8", "qxc6", "qh7", "qrc0"], "p_bits": ["p_ints", " p_ints", "p_vals", " p_bit", " p_vals", "p_bit"], "p_codes": ["v_seq", "v_code", "p_flags", "v_flags", "p_seq", "p_code"], "p_vec": ["c_buf", "c_verts", "p_buf", "pvbuf", "c_norm", "pvvec", "p_norm", "p_verts", "pvverts", "c_vec", "pvnorm"], "curidx": ["curIDz", "curridx", "curidz", "curIDX", "CurridX", "Curridex", "curidX", "Curidx", "curridz", "curridex", "Curridz", "Curridx", "CuridX", "curIDx", "curridX", "curidex", "Curidex", "Curidz", "curIDex"], "curidx2": ["curidv1", "curidv2", "curidvii", "curidxii", "curidf2", "curIdxii", "curidf1", "curIdf1", "curidx1", "curidyii", "curidy1", "curIdx1", "curIdf2", "curidfii", "curIdx2", "curIdfii", "curidy2"], "in_int": [" in_long", "in_bit", " in_bit", "in_long", "in_ind", " in_ind"], "v_bits": ["p_bytes", "p_vals", "v__bits", "v_vals", "v__bytes", "v_bytes", "v__vals", "v__codes"], "v_codes": ["v_seq", "v_code", " v_code", " v_cats", "v_cats", " v_seq"], "t0": ["v00", "v3", "ta1", "v0", "t00", "ta00", "ta3", "ta0", " t00", "v1"], "t1": ["T2", "v3", "v7", "T1", "v1", "T3", "T7", "v2"], "t2": ["T2", "t22", "v4", " t22", "v22", "T22", "T4", "v2"], "t3": [" t03", "tthree", " tthree", "itthree", "it3", "t03", "T3", "T03", "it03", "Tthree"], "t4": ["T2", "t8", "v3", "v8", " t8", "v4", "T3", "T4", "T8", "v2"], "t5": ["T2", "v7", "T7", "v4", "v5", "T5", "T4", "v2"], "t6": [" t06", "t8", "t06", "ta6", " t8", "ta8", "ta06", "T8", "T7", "T6", "T06", "ta7"], "t7": ["at77", " t77", " t729", "t729", "t07", "at7", "ta77", "at729", "ta729", " t07", "ta07", "at07", "ta7", "t77"], "vec1": ["ven3", " vec3", "cv3", "cv1", "vec3", "ven1", "cv2", "ven2"], "vec2": ["vector4", " vec4", "vec4", "vector2", "cv1", "cv4", "vector1", "cv2"]}}
{"project": "FFmpeg", "commit_id": "eef9f06508354d1c7d5624c1c18997e7974288f1", "target": 0, "func": "static int stream_component_open(PlayerState *is, int stream_index)\n\n{\n\n    AVFormatContext *ic = is->ic;\n\n    AVCodecContext *avctx;\n\n    AVCodec *codec;\n\n    SDL_AudioSpec wanted_spec, spec;\n\n    AVDictionary *opts;\n\n    AVDictionaryEntry *t = NULL;\n\n    int ret = 0;\n\n\n\n    if (stream_index < 0 || stream_index >= ic->nb_streams)\n\n        return -1;\n\n    avctx = ic->streams[stream_index]->codec;\n\n\n\n    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);\n\n\n\n    codec = avcodec_find_decoder(avctx->codec_id);\n\n    avctx->workaround_bugs   = workaround_bugs;\n\n    avctx->idct_algo         = idct;\n\n    avctx->skip_frame        = skip_frame;\n\n    avctx->skip_idct         = skip_idct;\n\n    avctx->skip_loop_filter  = skip_loop_filter;\n\n    avctx->error_concealment = error_concealment;\n\n\n\n    if (fast)\n\n        avctx->flags2 |= AV_CODEC_FLAG2_FAST;\n\n\n\n    if (!av_dict_get(opts, \"threads\", NULL, 0))\n\n        av_dict_set(&opts, \"threads\", \"auto\", 0);\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        av_dict_set(&opts, \"refcounted_frames\", \"1\", 0);\n\n    if (!codec ||\n\n        (ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret =  AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n\n\n    /* prepare audio output */\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        is->sdl_sample_rate = avctx->sample_rate;\n\n\n\n        if (!avctx->channel_layout)\n\n            avctx->channel_layout = av_get_default_channel_layout(avctx->channels);\n\n        if (!avctx->channel_layout) {\n\n            fprintf(stderr, \"unable to guess channel layout\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n        if (avctx->channels == 1)\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_MONO;\n\n        else\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_STEREO;\n\n        is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);\n\n\n\n        wanted_spec.format = AUDIO_S16SYS;\n\n        wanted_spec.freq = is->sdl_sample_rate;\n\n        wanted_spec.channels = is->sdl_channels;\n\n        wanted_spec.silence = 0;\n\n        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;\n\n        wanted_spec.callback = sdl_audio_callback;\n\n        wanted_spec.userdata = is;\n\n        if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n\n            fprintf(stderr, \"SDL_OpenAudio: %s\\n\", SDL_GetError());\n\n            ret = AVERROR_UNKNOWN;\n\n            goto fail;\n\n        }\n\n        is->audio_hw_buf_size = spec.size;\n\n        is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;\n\n        is->resample_sample_fmt     = is->sdl_sample_fmt;\n\n        is->resample_channel_layout = avctx->channel_layout;\n\n        is->resample_sample_rate    = avctx->sample_rate;\n\n    }\n\n\n\n    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n\n    switch (avctx->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        is->audio_stream = stream_index;\n\n        is->audio_st = ic->streams[stream_index];\n\n        is->audio_buf_size  = 0;\n\n        is->audio_buf_index = 0;\n\n\n\n        /* init averaging filter */\n\n        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n\n        is->audio_diff_avg_count = 0;\n\n        /* since we do not have a precise anough audio fifo fullness,\n\n           we correct audio sync only if larger than this threshold */\n\n        is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;\n\n\n\n        memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));\n\n        packet_queue_init(&is->audioq);\n\n        SDL_PauseAudio(0);\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        is->video_stream = stream_index;\n\n        is->video_st = ic->streams[stream_index];\n\n\n\n        packet_queue_init(&is->videoq);\n\n        is->video_tid = SDL_CreateThread(video_thread, is);\n\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n        is->subtitle_stream = stream_index;\n\n        is->subtitle_st = ic->streams[stream_index];\n\n        packet_queue_init(&is->subtitleq);\n\n\n\n        is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    av_dict_free(&opts);\n\n\n\n    return ret;\n\n}\n", "idx": 6801, "substitutes": {"is": ["iss", "pi", "ais", "isl", "ik", "isc", "sil", "fi", "sys", "ish", "api", "src", "ls", "isu", "oc", "sc", "ace", "isa", "cs", "id", "iso", "ip", "s", "cms", "st", "IS", "can", "aic", "il", "act", "ib", "as", "bis", "or", "ir", "i", "info", "its", "iv", "it", "isi", "lis", "ia", "in", "ics", "bs", "os", "ist", "serv", "si"], "stream_index": ["hostOindex", "stream_level", "streamerposition", "streamingpath", "streamPposition", "streamxind", " stream_ref", "streamnameref", " streamxlevel", "streamPhandle", " stream_ind", "streamIdindex", " streamxnum", "streamsvalue", "streamsid", "steam_position", "streamOref", "stream_position", "sound_id", "streamxlevel", "stream_handle", "streamervalue", "sound_value", " streamxindex", "steam_index", "stream_value", "steamChandle", "hostOref", "stream_name", "streamerhandle", "stream_path", "streamedlevel", "streamerindex", "host_path", "hostOkey", "streamsindex", "streamIdpath", "streamednum", " streamxind", "streamChandle", "streamxnum", "streamCposition", "streamnameindex", "stream_num", "steam_handle", " stream_level", "streamingref", "sound_index", "streamedind", "steamCposition", "steamCindex", "streamsposition", "sound_position", "stream_key", "host_key", "steamCname", " stream_num", "streamerid", "streamCname", "hostOpath", "streamOindex", "steam_name", "streamnamenum", "host_index", "streamOpath", "stream_ind", "streamIdref", "stream_ref", "streamOkey", "streamIdkey", "streamPname", "streamingindex", "host_ref", "streamingkey", "streamPindex", "streamername", "streamxindex", "streamedindex", "streamCindex", "stream_id"], "ic": ["bi", "sci", "uc", "pc", "pi", "ici", "rc", "aci", "icing", "enc", "ik", "ican", "isc", "iac", "fi", "cli", "cc", "ti", "anc", "exec", "acl", "gc", "cus", "oc", "lic", "xc", "inc", "ct", "nic", "cs", "config", "voc", "cit", "abc", "c", "ck", "ctx", "icer", "aic", "ix", "bc", "pic", "cci", "IC", "cl", "ec", "i", "fc", "cu", "tc", "mic", "ci", "lc", "icc", "ac", "ia", "ics", "vc", "ai", "irc", "VC"], "avctx": [" avcas", "aveca", "avecu", " avcc", "avetx", "AVcca", " avlc", "avconfig", "afctx", "avtx", "avcmd", "AVconn", "afhw", "avca", "navctx", " avca", "AVca", "AVwcs", " avctl", "ovcmp", "akcc", "mpcf", "navconn", "avelc", "avcc", " avcu", " avcca", "abcu", "avecontext", "akconfig", "afconn", "Avctx", "afcu", "afcn", "airconn", "evctx", "AVcu", "AVctx", "navcn", "afctl", "mpctx", "aflc", "afcca", "evcontext", "akcn", "AVcmp", "aveconfig", "Avcontext", "avcontext", "aveconn", "navcontext", "abcf", "avconn", "avcca", "ovcu", "mpcontext", "avcn", "navconfig", "afcc", "aircontext", "avecmp", "avecas", "akctx", "ovcontext", "AVcontext", "abcontext", "avewcs", "abconn", " avcmd", "afcf", "avcmp", "mpcmp", "akctl", "akcu", "evcf", "AVcf", "avehw", " avcf", "avecmd", "Avcf", "avcu", "afconfig", " avcontext", "avecf", "navcf", " avconn", "avctl", "ovctx", "avcf", "Avcu", "afcontext", "avlc", " avhw", "akcontext", "avcas", "abctx", "abconfig", "avwcs", "evcmp", "airctx", "avhw", "avectx", "airtx", "aftx", "afcmd", "avecn", " avwcs", "afcas", "abcmp"], "codec": ["cedec", "cedEC", "ctec", "catoc", " coderc", "cbec", "codEC", "castrec", "odeca", "cedbc", "defec", "cedroc", "defef", "cbesc", " codef", "codroc", "oduc", "odEC", "typect", "ctesc", "typerc", "preduc", "codcf", "cbrec", "predcf", "odcf", " codoc", "codeEC", "defac", "castec", " codeca", "odec", "coduc", " coduc", "catect", " codac", "castesc", "defesc", "codoc", "codac", "predeca", "caterc", "codect", " codect", "codesc", "ctac", "typec", " codesc", "predec", " codrec", "codbc", "codef", "codeec", "typoc", "ctef", "odroc", "odbc", "codrec", "catec", "coderc", "codeca", "codebc", "coderoc", "cberc", "casterc", " codcf"], "spec": ["sci", "Spec", "custom", "sync", "params", "sc", "seq", " specs", "config", " Spec", "vec", "spe", "source", "acc", "parse", "ssl", "settings", "security", "feat", "stream", "sk", "pec", "cmp", "comp", "conf", "sel", "rs", "si"], "opts": ["opttd", "otcs", "optt", "copte", "opter", "ipTS", "optd", "props", "opTS", "opments", " opters", "hopts", "ops", "ipcs", "protd", " opgs", " opcs", "opttes", "copts", "Opments", " opt", "ipts", "coptes", "optte", "OPter", "coputs", "prots", "optuts", "optes", "oputs", "opters", "opcs", "optcs", "Optips", "optps", "hoptes", "opertd", "optgs", "OPtes", "copcs", "opte", "hoputs", " opte", "operters", "copt", "OPTS", "pros", "opt", "operps", "otter", "opps", "opertips", "opertes", "operts", "ottes", "Opts", "otts", "ipt", "optTS", "optips", "OPcs", "OPts", "opers", "operments", "hopt", "opergs", "optts", " optes", " optips", "Opters", "copter", "opgs", "opert", "OPt", " opments"], "t": ["target", "j", "total", "mt", "e", "d", "tool", "trace", "dt", "tp", "p", "template", "type", "h", "test", "r", "tt", "bot", "ret", "at", "et", "n", "ut", "txt", "c", "m", "ts", "v", "ta", "not", "tmp", "g", "f", "pt", "te", "tm", "tip", "i", "wt", "w", "o", "token", "unt", "nt", "qt", "ot", "post", "tf", "bt", "ant", "T", "rt"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void keyword_literal(void)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QObject *null;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", false));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n    QDECREF(qbool);\n\n\n\n    /* Test that non-zero values other than 1 get collapsed to true */\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", 2));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"null\", NULL);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QNULL);\n\n\n\n    null = qnull();\n\n    g_assert(null == obj);\n\n\n\n    qobject_decref(obj);\n\n    qobject_decref(null);\n\n}\n", "idx": 6816, "substitutes": {"obj": ["pos", "br", "fn", "result", "alt", "coll", "er", "sync", "api", "args", "bl", "bj", "old", "pr", "img", "inner", "art", "el", "Object", "b", "ot", "adj", "rel", "ex", "object", "oa", "ref", "ie", "val", "orig", "r", "current", "elt", "ind", "txt", "t", "st", "other", "inst", "code", "rb", "ok", "oo", "oid", "ext", "value", "eff", "so", "p", "arr", "ocr", "__", "full", "lib", "n", "bo", "block", "ass", "instance", "tmp", "pt", "opt", "original", "nt", "amp", "active", "bs", "x", "j", "fail", "now", "op", "ol", "out", "empty", "ut", "ob", "ctx", "act", "sn", "ject", "Obj", "parent", "err", "o", "iv", "dr", "js", "po", "os"], "qbool": ["questbb", "corenot", " qbel", "qaswitch", "qualbool", "qacl", "qbel", "qbytes", "qabool", "corelabel", "qualnot", "playbyte", "calbool", "ggbean", "eqnot", "qulabel", "qualswitch", "eqfail", "aybool", "sqbool", "querynot", "qoptional", "qualnumber", "requbool", "qaeger", "eqbb", "quchild", "queryloop", "eqloop", "qabo", "hbool", "quoptional", "queststring", "playlabel", "ggunit", "qunumber", "quacl", "qualbb", "qulib", "qabit", "qunot", "quobject", " qforce", "playbit", "ggbool", "queryolean", "qufail", "qfloat", "qbean", "qanote", "holean", "qrole", "qaval", "qunit", "ggolean", "eqbo", "querychild", "qubit", "qstring", "playnot", "hunit", "questctor", "qustring", "playbo", " qobject", "quctor", "quolean", "questnot", "sqnumber", "qfail", "qlabel", "quval", "qualbl", "calnot", "qforce", "kshort", "eqbool", " qrole", "ayolean", "qolean", "hbean", "qabyte", "quallabel", "queryval", "questobject", "qufloat", "calbo", "qbyte", "qbit", "qalabel", "qualnote", " qnumber", "aybean", "questlib", "eqoptional", "qobject", "qswitch", "querybb", "eqnote", "kobject", "sqlabel", "playbool", "qualfail", "qualrole", "questacl", "qabel", "qanumber", "queryoptional", "qbl", "queryelement", "sqoptional", "qualbel", "eqnumber", "qubl", "queger", "qbb", "eqbyte", "qshort", "qualval", "qualbits", "querybyte", "requbel", "querybo", "querybool", "qbo", "qctor", "queryshort", " qbytes", "corebo", "qubytes", "corebool", "qubits", " qbb", "qualchild", " qelement", "qabits", "eqlabel", "qubb", "qelement", "qabl", "qubyte", "requforce", "eqval", "qunote", "qubool", "qbits", "queryfloat", "qchild", "qanot", "qualfloat", " qnot", "qnote", "qnot", "qloop", "qarole", "quforce", "qval", "requbytes", "kbool", " qctor", "quswitch", "callabel", "queryacl", "kolean", "qnumber", "questbool", "questelement", "qubo", "quloop", "questoptional", "ayunit", "qeger", "querystring", "qubel", "qushort", " qlib", "playeger", "queryobject", "qlib", "querylabel"], "null": ["new", "object", "ref", "fail", "result", "value", "alt", "negative", "nil", "bool", "collection", "val", "none", "call", "bl", "type", "person", "seq", "empty", "lt", "id", "n", "bo", "block", "ob", "Null", "il", "array", "comment", "other", "model", "parent", "err", "o", "list", "lc", "valid", "node", "b", "ok", "status", "resource", "bs", "zero", "oid"], "str": ["pos", "br", "url", "j", "name", "text", "enc", "coll", "er", "arr", "bl", "style", "sc", "seq", "pr", "r", "Str", "out", "sp", "elt", "STR", "dict", "ctr", "inner", "n", "id", "s", "res", "txt", "ss", "sr", "c", "st", "stri", "cr", "tr", "ns", "pt", "act", "cl", "sn", "err", "sl", "fr", "code", "dr", "iter", "doc", "serv", "rs", "spec"]}}
{"project": "qemu", "commit_id": "093209cd681fe9fb65bd8a1c2ff711b8168bbfcd", "target": 0, "func": "static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;\n\n    int ide_mem_index[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.vbios\", VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000, 1);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        /* 970 gets a U3 bus */\n\n        pci_bus = pci_pmac_u3_init(pic);\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic);\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n\n\n    /* We only emulate 2 out of 3 IDE controllers for now */\n\n    ide_mem_index[0] = -1;\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    /* cuda also initialize ADB */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    /* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 6829, "substitutes": {"ram_size": ["ramlsize", "ram_type", "ram_source", " ram_bytes", "ram_length", " ram_width", "gram_length", "ramlcenter", "ramlsource", "gram_type", "gram_size", "mem_size", "ram_center", "mem_center", "gram_offset", "mem_offset", "ram_width", "ram_bytes", "mem_source", " ram_speed", "ram_speed", "ramloffset"], "boot_device": ["bootalmode", "kernel_dev", "bootalserver", "kernel_server", "bootaldevice", "bootaldev", "boot_dev", "boot_server", "kernel_device", "kernel_mode", "boot_mode"], "kernel_filename": ["kernel__filename", "kernelfusername", " kernel_file", "kernel_location", "cpu_filename", "cpu_name", "kernelffilename", "kernel__name", "kernel_username", "kernel__username", "kernel__memory", "kernelfname", "kernel_memory", "kernel_file", "kernel_name", " kernel_location", "kernelfmemory", "cpu_memory", "cpu_username", " kernel_name"], "kernel_cmdline": ["kernel_commline", "kernel_bootlink", "kernel_commandle", "kernel_commandlink", "kernel_bootline", "kernel_cmdlink", "kernel_bootle", "kernel_commle", "kernel_cmdle", "kernel_commandline", "kernel_commlink"], "initrd_filename": ["initrd_memory", "initrt_memory", "initrt_file", "initrt_filename", "initrdmfile", "initrdmmemory", "initrd_file", "initrdmfilename", "initrt_size", "initrdmsize"], "cpu_model": ["CPU_format", "cpujname", "cpu_module", "cpu__model", "cpu64model", "CPU_model", "cpu__format", "gpu_Model", "CPU_mode", " cpu_models", "cpu_field", "cpu_function", "cpu_format", "cpujmode", "cpu_rule", "gpu_rule", "processor_name", "cpu_slave", " cpu_module", "gpu_field", "cpujmodel", "cpu_Model", " cpu_mode", " cpu_slave", "cpu__device", "processor_model", "cpujfunction", "cpu_mode", " cpu_type", "cpu_device", "cpu__mode", "cpu_type", "cpu_models", "cpu_name", "cpu64mode", "cpu64format", "gpu_model", "processor_function", "processor_mode", "CPU_device", "cpu64device"], "env": ["py", "context", "scope", "output", "pect", "nc", "eu", "dir", "np", "end", "eval", "db", "loc", "e", "enc", "vel", "exc", "exec", "equ", "export", "cli", "ea", "args", "session", "style", "h", "conn", "vs", "img", "ne", "ev", "config", "inv", "viron", "dict", "et", "stage", "obj", "enable", "ass", "impl", "net", "init", "engine", "ctx", "bc", "act", "opt", "assets", "Environment", "ah", "ec", "en", "el", "ini", "cache", "global", "err", "iv", "dev", "gui", "code", "inet", "eni", "here", "state", "in", "fg", "conf", "lock", "v", "environment", "dat"], "envs": ["enfs", "ENvs", "ENv", "Environments", " enfs", "ENns", "ENums", "Enums", "Enns", "ENvironments", "ENfs", "enns", " enums", " enns", "Env", "environments", "Envs", "enums", "Enfs", " environments"], "MAX_CPUS": ["MAXNCPU", "MAX_CPUI", "MAXNCPUI", "MAX_MPUs", "MAXNcpUI", "MAX_MPU", "MAX_CFUS", "MAXNCPUs", "MAX_CFU", "MAX_CPU", "MAX_cpUI", "MAX_MPUS", "MAX_MPUI", "MAXNcpU", "MAX_CPUs", "MAX_cpUs", "MAX_cpUS", "MAXNCPUS", "MAXNcpUS", "MAX_cpU", "MAX_CFUI", "MAXNcpUs", "MAX_CFUs"], "filename": ["fn", "wav", "Filename", "name", "nil", "tty", "username", "processor", "File", "file", "files", "fd", "fil", "kl", "f", "path", "prefix", "memory", "uri", "b", "dll", "fp", "binary", "output", "directory"], "pic": ["pc", "pi", "pin", "proc", "pot", "bus", "pins", "fi", "drive", "cli", "sync", "quad", "image", "nic", "config", "lib", "ic", "cpu", "fs", "ig", "mac", "bin", "cache", "fc", "xi", "mic", "lc", "disk", "vc"], "openpic_irqs": ["openpic_rinqs", "openpic_rinq", "openpic_mirks", "openpic_irks", "openpic_rinks", "openpic_irsks", "openpic_mirqs", "openpic_mirqq", "openpic_irsqs", "openpic_mirq", "openpic_irsq", "openpic_irqq", "openpic_irsqq", "openpic_irq", "openpic_rinqq"], "unin_memory": ["cpu_base", "cpu00master", "cpualmaster", "cpualbase", "vidia_base", "vidia_memory", "cpu00memory", "cpualusage", "cpu00usage", "cpu00base", "vidia_usage", "vidia_master", "cpu_memory", "cpu_master", "cpualmemory", "cpu_usage"], "linux_boot": ["physical_Boot", "linux_run", "linux_setup", "linux_base", "physical_run", " linux_Boot", "linux68host", " linux_setup", "linux_host", "linux68Boot", "linux68setup", "physical_base", " linux_host", "linux_Boot", "physical_boot", "linux68boot"], "i": ["ui", "index", "pi", "k", "ie", "ei", "j", "di", "gu", "d", "mini", "multi", "fi", "cli", "ti", "p", "yi", "uli", "slice", "ski", "h", "mi", "phi", "image", "anti", "ii", "qi", "hi", "adi", "u", "ij", "n", "ni", "chi", "ip", "l", "ami", "udi", "m", "c", "v", "ix", "f", "io", "ri", "ini", "info", "gi", "xi", "uri", "eni", "ci", "in", "iu", "I", "ai", "linux", "si", "li"], "ram_offset": ["ream_base", "ream_offset", "gram_index", "ram67offset", "ramFindex", "ream_size", "ream_format", "ram_position", "ramFsize", "ram67position", "ram_shift", "ram_base", "ram_index", "ramlexreset", "ram_format", "ram_reset", "ramFposition", "gram_size", "gram_shift", "ram67index", "gram_position", "gram_offset", "ramFoffset", "ramlexshift", "ram67size", "ramlexsize", "ramlexoffset", "gram_reset"], "bios_offset": ["bio_offset", "bio_error", "bios_base", "bios_len", "bio_len", "bio_base", "bios_error", "bio_size"], "vga_bios_offset": ["vga_bios_index", "vga_bio_offset", "vga_bio_index", "vga_bios_position", "vga_bio_size", "vga_bio_position"], "kernel_base": ["kernel__base", " kernel_file", "kernel__range", "kernel__file", "kernel_range", " kernel_range", "kernel__size", "kernel_file"], "kernel_size": [" kernel_name", "kernel_speed", "kernel_name", " kernel_speed"], "initrd_base": ["initrt_core", "initrt_offset", "initrt_base", "initrt_size", "initrd_core", "initrd_offset"], "initrd_size": ["initrt_scale", "initrd_name", "initrt_loc", "initrd_loc", "initrt_size", "initrt_name", "initrd_scale"], "pci_bus": ["pci_boot", "pki_bus", "pci_BUS", "pki_usb", "pki_boot", "pci_usb", "pki_BUS"], "nvr": ["NVR", "nvm", "rnVR", " nmr", " nvm", "rnvm", "Nmr", "nmr", "Nvm", "nVR", "rnvr", " nVR", "rnmr", "Nvr"], "nvram_mem_index": ["nvram_ram_size", "nvram_mem_length", "nvram_memxsize", "nvram_memxindex", "nvram_mem_loc", "nvram_memxlength", "nvram_ram_length", "nvram_ram_index", "nvram_ram_loc", "nvram_mem_size", "nvram_memxloc"], "vga_bios_size": ["vga_bios_count", "vga_bio_count", "vga_bio_size", "vga_bios_loc", "vga_bio_loc"], "bios_size": ["biol_capacity", "bios_capacity", "bios6size", "bios6index", "biol6offset", "biol6capacity", "biol_index", "bios6capacity", "biol_offset", "biol_size", "biol6size", "biol6index", "bios6offset", "bios_index"], "pic_mem_index": ["pic_mempset", "pic_mempnum", "pic_mempindex", "pic_thread_size", "pic_thread_index", "pic_mem_size", "pic_thread_num", "pic_mem_num", "pic_thread_set", "pic_mempsize", "pic_mem_set"], "dbdma_mem_index": ["dbdma_mem_size", "dbdma_thread_size", "dbdma_mem_id", "dbdma_thread_index", "dbdma_thread_id"], "cuda_mem_index": ["cuda_lif_num", "cuda_memxnum", "cuda_memxalign", "cuda_memxind", "cuda_memxindex", "cuda_mem_ind", "cuda_mem_align", "cuda_lif_index", "cuda_lif_align", "cuda_lif_ind", "cuda_mem_num"], "escc_mem_index": ["escc_memgind", "escc_mem_count", "escc_memory_index", "escc_mem_ind", "escc_memgindex", "escc_memory_count", "escc_memgcount", "escc_memory_ind"], "ide_mem_index": ["ide_disk_slice", "ide_diskxindex", "ide_memxslice", "ide_memxmin", "ide_diskxslice", "ide_memxindex", "ide_disk_min", "ide_mem_slice", "ide_disk_index", "ide_diskxmin", "ide_mem_min"], "ppc_boot_device": ["ppc_bus2unit", "ppc_boot2dev", "ppc_bus2device", "ppc_boot2unit", "ppc_boot_unit", "ppc_bus_device", "ppc_bus_unit", "ppc_bus_model", "ppc_boot2device", "ppc_bus2model", "ppc_boot_model", "ppc_boot_dev", "ppc_bus2dev", "ppc_bus_dev", "ppc_boot2model"], "hd": ["da", "vd", "xd", "di", "lv", "dt", "du", "gc", "rh", "hm", "hp", "dd", "udi", "gd", "hid", "nd", "hw", "HD", "dri", "dr", "eni", "cd", "md", "hs", "pd", "ha", "ht", "ld", "wd"], "MAX_IDE_BUS": ["MAX_DI_PATH", "MAX_IDE_USE", "MAX_DIPOPATH", "MAX_IDEPOUS", "MAX_IDE_US", "MAX_IDEADUSE", "MAX_IDEPOBUS", "MAX_IDE_PATH", "MAX_IDEADBUS", "MAX_DI_US", "MAX_DIPOUS", "MAX_DIPOBUS", "MAX_DI_USE", "MAX_IDEPOPATH", "MAX_IDEPOUSE", "MAX_DI_BUS", "MAX_IDEADUS", "MAX_IDEADPATH", "MAX_DIPOUSE"], "MAX_IDE_DEVS": ["MAX_IDE_TEV", "MAX_IDE_DIVS", "MAX_IDE_DEV", "MAX_IDE_DFS", "MAX_IDE_DIFS", "MAX_IDE_TEVS", "MAX_IDE_DVS", "MAX_IDE_DIVICE", "MAX_IDE_TEFS", "MAX_IDE_DV", "MAX_IDE_DEFS", "MAX_IDE_DIV", "MAX_IDE_DVICE", "MAX_IDE_DEVICE", "MAX_IDE_TEVICE"], "fw_cfg": ["hw_cfg", "fw__config", "hw_config", "hw_cow", "fw__cfg", "fw_config", "fw__cow", "fw_cow", "hw_cf", "fw__cf", "fw_cf"], "dbdma": [" dbdpa", "dbdpa", "dbdsna", "dbnma", "dbhma", "dbdna", " dbnmm", " dbnpa", "dbhpa", "dbnna", " dbdna", "dbdspa", "dbhna", "dbnmm", "dbdsma", "dbdmm", "dbhmm", " dbdmm", "dbnpa", " dbnma", " dbnna", "dbdsmm"], "vga_bios_ptr": ["vga_bias_offset", "vga_bios_addr", "vga_bias_ptr", "vga_bios_pointer", "vga_bias_addr", "vga_bias_pointer"], "machine_arch": ["machine_brand", "usb_version", "machine_version", "machine_platform", "machine__arch", "machine__brand", "machine__platform", "usb_brand", "machine__version", "usb_arch", "usb_platform"]}}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "func": "void DMA_run(void)\n\n{\n\n    /* XXXXX */\n\n}\n", "idx": 6838, "substitutes": {}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n", "idx": 6844, "substitutes": {"a": ["an", "data", "da", "area", "ab", "value", "input", "ae", "e", "na", "ea", "A", "p", "h", "r", "pa", "u", "l", "abc", "c", "m", "aux", "ba", "alpha", "sup", "f", "sa", "as", "i", "ma", "ca", "ga", "va", "la", "ac", "b", "ia", "aa", "x"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 6852, "substitutes": {"a": ["an", "da", "area", "au", "e", "ae", "na", "ai", "ea", "af", "A", "p", "xa", "pa", "n", "s", "c", "ba", "ana", "alpha", "asa", "f", "wa", "sa", "as", "sta", "ma", "i", "ar", "ca", "aaa", "va", "la", "ac", "ra", "ama", "ia", "aa"], "b": ["bi", "pb", "wb", "y", "lb", "k", "end", "B", "ab", "db", "e", "d", "bf", "sb", "p", "r", "bb", "n", "l", "ob", "s", "buff", "ba", "f", "or", "i", "ad", "rb", "z", "xb", "cb", "bs", "v", "base"], "fa": ["da", "oa", "au", "ao", "ppa", "ae", "bf", "fat", " ba", "fi", "ea", "af", "fe", "A", "afi", "xa", "Fa", "pa", "fw", "cca", "FA", "ifa", "ba", "osa", "ta", "asa", "f", "fal", "wa", "sa", "tta", "fc", "ma", "hea", "cf", "ca", " ta", "aaa", "ga", "va", "ra", "ia", "aa", "afa", "ifi", "base"], "fb": ["xf", "BF", "wb", "pb", "lb", "ab", "db", "bf", "fx", "sb", "fi", "af", "fe", "rf", "afi", "alf", "facebook", "Fa", "bb", "fam", "deb", "fw", "BB", "FB", "abc", "buff", "fd", "fen", "raf", "bg", "fs", "f", "ib", "eb", "uff", "fab", "fc", "cf", "FH", "ff", "xb", "rb", "fg", "FF", "cb", "bs"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n", "idx": 6867, "substitutes": {"s": ["an", "sq", "e", "d", "sb", "sys", "p", "spec", "details", "args", "ls", "S", "is", "ps", "ses", "gs", "sets", "r", "u", "cs", "ds", "ions", "request", "n", "stats", "states", "ops", "ss", "m", "sym", "ts", "t", "c", "services", "v", "fs", "g", "f", "as", "or", "a", "ssl", "south", "settings", "i", "o", "sl", "its", "w", "state", "js", "b", "es", "os", "qs", "rs", "si"], "options": ["data", "object", "pre", "opens", "e", "plugins", "op", "p", "rules", "details", "args", "params", "style", "times", "ps", "full", "cs", "config", "changes", "stats", "ions", "option", "obj", "ops", "temp", "ts", "css", "ns", "Options", "io", "or", "vals", "flags", "settings", "i", "o", "steps", "its", "info", "als", "points", "js", "features", "es", "http", "groups", "os", "results", "eps", "errors", "rs", "ors", "ips"]}}
{"project": "FFmpeg", "commit_id": "7a206eb32f624171a35235f714d44ee9dec9abcb", "target": 0, "func": "static int alac_set_info(ALACContext *alac)\n\n{\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, alac->avctx->extradata,\n\n                     alac->avctx->extradata_size);\n\n\n\n    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4\n\n\n\n    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);\n\n    if (alac->max_samples_per_frame >= UINT_MAX/4){\n\n        av_log(alac->avctx, AV_LOG_ERROR,\n\n               \"max_samples_per_frame too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    bytestream2_skipu(&gb, 1);  // compatible version\n\n    alac->sample_size          = bytestream2_get_byteu(&gb);\n\n    alac->rice_history_mult    = bytestream2_get_byteu(&gb);\n\n    alac->rice_initial_history = bytestream2_get_byteu(&gb);\n\n    alac->rice_limit           = bytestream2_get_byteu(&gb);\n\n    alac->channels             = bytestream2_get_byteu(&gb);\n\n    bytestream2_get_be16u(&gb); // maxRun\n\n    bytestream2_get_be32u(&gb); // max coded frame size\n\n    bytestream2_get_be32u(&gb); // average bitrate\n\n    bytestream2_get_be32u(&gb); // samplerate\n\n\n\n    return 0;\n\n}\n", "idx": 6879, "substitutes": {"alac": ["malec", "alacs", "alanc", "aliacs", "calec", "malacs", "elanc", "elac", "malanc", "altacl", "elacs", "Alac", "allang", "alphanc", " alacs", "plmac", "AlAC", "allac", " aloc", "ALac", "paliac", "allacs", "malack", "alack", "palacc", " alack", "aloc", "elAC", "altac", "altAC", " alas", "Alacs", "alec", "alphas", "ALoc", "palacs", "ALacs", "alacl", "malacl", " alAC", "placs", " alacl", "alas", "eliac", "alfac", " alanc", "alphac", "alsAC", "calacc", "Alacc", "aliac", "altack", "alifac", "plac", "allacc", "almac", "alAC", "alang", "ALAC", "Aloc", "alsacs", "malacc", "elacc", "malAC", "alphec", "alsfac", " alec", "malas", " almac", " alang", "calac", " aliac", "malang", " alacc", "palac", "calanc", "alacc", "plAC", "aliAC", "alsmac", "malac", "alsac", " alfac"], "gb": ["tg", " rgb", "cfg", "gm", "pc", "gom", " ig", " gcc", "db", "bf", "gpu", "sb", "hub", "gow", "mb", "byte", "gae", "gam", "rg", "bm", "gn", " rc", "gc", "gz", "gg", "gs", "bb", " rg", "kg", "lib", "eg", "gram", " region", "gy", "gio", " gy", "gd", "gal", "sg", "cgi", "gl", "bc", "gin", "bg", "g", " addr", "nb", "kb", "vt", "GB", " cc", "gp", "gh", "eb", "fc", "phy", " eg", " db", "gi", " cod", "ga", " pg", "yg", "gru", "Gb", "rb", " GB", "cb", "greg", "gu", " storage"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891, "substitutes": {"s": ["d", "sync", "args", "site", "ops", "sg", "services", "fs", "f", "side", "b", "conf", "v", "private", "sq", "submit", "sb", "params", "h", "ses", "cs", "u", "sf", "ss", "ts", "t", "ns", "a", "w", "its", "es", "status", "http", "hs", "ins", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "xs", "stats", "n", "c", "g", "us", "ssl", "su", "qs", "rs", "si", "spec", "y", "aws", "e", "server", "is", "service", "ds", "l", "states", "sym", "m", "settings", "i", "secondary", "o", "js", "os"], "request": ["complete", "data", "worker", "object", "re", "sq", "xml", "argument", "result", "input", "error", "e", "submit", "message", "er", "hello", "server", "command", "report", "Request", "p", "event", "call", "question", "session", "type", "client", "test", "order", "QUEST", "query", "config", "create", "password", "application", "child", "join", "instance", "enter", "transfer", "condition", "consumer", "wa", "requ", "parse", "req", "quest", "initial", "info", "user", "reply", "subject", "status", "http", "q", "resource", "work", "method", "output"], "response": ["operation", "index", "result", "example", "hello", "api", "args", "site", "four", "Response", "res", "sequence", "description", "location", "wave", "v", "output", "data", "object", "view", "message", "get", "respons", "answer", "onse", "r", "position", "change", "current", "respond", "page", "other", "product", "successful", "database", "status", "body", "environment", "ception", "profile", "value", "received", "document", "p", "connection", "session", "image", "account", "application", "block", "model", "initial", "json", "when", "python", "resource", "complete", "error", "success", "e", "collection", "server", "report", "event", "function", "client", "resp", "service", "remote", "version", "array", "o", "reply", "subject", "update"], "rlen": [" rden", "srden", "crLen", "srren", " rLen", "llength", "Ren", "cren", "rrLen", "rlength", "llen", "blen", "hrLen", "len", "Rlen", "rrlon", "frlength", "rren", "blon", "blength", "ren", "hrlen", " rlength", " rren", "srlen", "lLen", "crlength", "frlen", " rbl", "hrren", "frden", "Rlength", "rlon", "srbl", "rrlength", " rlon", "rrlen", "bLen", "srlength", "frLen", "RLen", "hrbl", "rden", "srLen", "crlen", "rbl", "rLen"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n", "idx": 6919, "substitutes": {"ud1test": ["ud81const", "ud1train", "aud6result", "ut1testing", "utonetesting", "ud19set", "uid1case", "ud11train", "uidonecase", "ud3const", "ud1class", "ud01cross", "udonetesting", "ub1test", "ud81test", "ud91testing", "ud10est", "uc1train", "ud11test", "udonedesc", "ud11const", "udoneset", "udd21class", "uc1store", "uidoneconst", "ud91desc", "ud1config", "aud1testing", "udonematch", "ud3testing", "ud10server", "ub11test", "ub11train", "ud1set", "uidonetest", "udd1test", "ud6testing", "ud1testing", "ud21class", "ut1test", "udonetrain", "ud4class", "udoneconst", "utonetest", "ud11match", "ud6test", "udd21est", "ud6match", "ud01const", "udoneresult", "ud11desc", "ud3test", "ud1store", "ud3case", "ud91test", "ub1cross", "utonedesc", "ud86cross", "udonecase", "ud1est", "aud6match", "uc1set", "uc11store", "ud1match", "aud6test", "uc11train", "ud21est", "udd1server", "aud6testing", "uid1test", "ud21server", "ud11result", "ud1server", "ud1cross", "ud19train", "ud81case", "aud1result", "uc11set", "udd21server", "aud1test", "ud1case", "udd1class", "ud11cross", "uc11test", "udonestore", "ud86train", "ut1desc", "ud1result", "ud01train", "ub1const", "uid1testing", "ub11cross", "ud86const", "ud91config", "ud11set", "ud11store", "aud1match", "uid1const", "ub11const", "ud81testing", "udd21test", "ud86test", "udd1est", "ud19store", "ud6result", "ud4server", "ud1desc", "uc1test", "ud10class", "ud11config", "udoneconfig", "ud21test", "ud4est", "ud4test", "utoneconfig", "ud01test", "ud11testing", "ub1train", "ud19test", "uidonetesting", "ut1config", "ud1const", "udonetest", "ud10test"], "ud1a": ["ub81b", "aud10ca", "utonea", "ud0b", "ud100ada", "ud10c", "ud9ab", "ud01a", "ub81am", "udd1as", "ud1c", "aud1a", "ud2ca", "bb1b", "ud0c", "udd1a", "ud10ab", "ud9a", "ud0an", "bb1as", "ud17a", "ud81b", "ud100app", "ud11am", "aud1aa", "ud001ada", "ud1aa", "ub1am", "udd1k", "ud2as", "ud001app", "ud10k", "utonean", "ud0a", "ub81a", "ud100a", "ud5app", "bb1an", "ud11b", "ud9c", "ud001a", "ud0as", "ud01an", "ut1alpha", "ub1ca", "ud81am", "ud01b", "bb0b", "ud001aa", "ud2alpha", "ud2am", "udonesa", "ud1alpha", "ud5a", "aud1ca", "udd1sa", "ud1sa", "aud5a", "ud11alpha", "utonealpha", "bb0an", "ud100aa", "ud1as", "uddoneas", "aud5ada", "ut1an", "ud81ca", "ud17as", "ud1ab", "aud10ab", "aud1c", "ud81a", "ud2b", "ud5aa", "ud2an", "aud1ada", "ud11an", "udoneb", "ud1an", "uddonek", "ud0ab", "ud11a", "aud10c", "aud5app", "bb0as", "aud5aa", "ud1ca", "ut1a", "bb0a", "ub1a", "ud2a", "ud17sa", "udonean", "ud9ca", "ud0ca", "udoneas", "ud11ca", "ut1b", "ud10sa", "uddonesa", "ud1am", "aud1ab", "ud1k", "utoneb", "bb1a", "aud1app", "ud1app", "uddonea", "ud1ada", "ud10as", "ud17k", "udonea", "ud5ada", "ud10a", "udonealpha", "udonek", "ud10ca", "ub1b", "aud10a", "ub81ca", "ud01as"], "ud1b": ["ud11d", "ud8z", "ud0b", "ud1f", "ud81p", "ud10c", "ud5bb", "ud01a", "utonez", "ud3l", "udonez", "ud81c", "ud11n", "utonebin", "ud3ab", "ud1c", "ud10abc", "utonep", "du11b", "udd1a", "ud01c", "ud1p", "ud1abc", "uc1c", "ud1bin", "ud3be", "ud81b", "udOnez", "ud81bb", "udonen", "ud8b", "uc1b", "du1l", "du0be", "ud001b", "udonebody", "udoneab", "ud11b", "udd1c", "udd10b", "ut1bin", "ud11c", "ud8p", "udonef", "udd1abc", "ud11p", "ud3base", "udOnebin", "ud11bb", "ud1l", "du0base", "du1be", "ut1z", "uc1bb", "du0l", "ud01b", "ud11bin", "udonep", "udOnep", "ud11ab", "ud5p", "udd10a", "ud3n", "ud1d", "du1n", "ut1p", "du0b", "uc81p", "ud3f", "ud1base", "ud001l", "ud0l", "uc81b", "ud01abc", "udd1b", "ud10b", "ud1ab", "udOnedb", "du1b", "ud1z", "udoneb", "ud001base", "du1f", "ud11a", "ud001be", "du1ab", "du1base", "utoned", "udOned", "udOneb", "ud5b", "ud1bb", "udd10abc", "uc1p", "udd10c", "uc81c", "du11ab", "ud1db", "udoned", "ud0be", "uc81bb", "ut1db", "ud1be", "udOnebody", "udonebin", "ud11abc", "ut1b", "ud5c", "udonedb", "ud11f", "ud11body", "ud0base", "utoneb", "ud1n", "utonebody", "ut1d", "du11f", "ud1body", "ud3b", "ut1body", "utonedb", "du11n", "ud8db", "ud10a"], "ud1list": ["udonepl", "ud91be", "ud9string", "ud11l", "ud1f", "ud1string", "udOneList", "ud001s", "ug91be", "udd01bl", "ug001int", "uidonelist", "ud91f", "vdOnelist", "vdOneList", "ud1p", "udd01list", "upp1next", "ud3bl", "ug1list", "ug91list", "udones", "ud11string", "ug001s", "ud9bl", "ud6main", "udOnelist", "ud1int", "ud31List", "ud11bl", "udonef", "ud11int", "ud31list", "udd1l", "udd1list", "ug001list", "udonebl", "ud01list", "ud6next", "ud1l", "udronint", "ud6list", "ud001string", "udronnext", "ud2f", "ud1part", "ud6int", "uid1list", "udonep", "udOnep", "ud151list", "upp1main", "ud2l", "ud01f", "ug1int", "vdOnepart", "ud11list", "ud1List", "ud151next", "ud2bl", "ud9list", "upp1list", "upp151main", "vd1List", "ud001list", "udonelist", "ud2list", "uidonepl", "ud31p", "upp151list", "ud9s", "udd01f", "ud1next", "vd1p", "udd1bl", "ud9int", "ug91s", "ug1s", "ug1be", "vd1part", "ud151int", "udonepart", "udOnepart", "ud1pl", "ud91s", "upp1int", "ud01bl", "ud3list", "udd01l", "ud1bl", "vdOnep", "udd1f", "ud3pl", "ug1string", "ud1be", "vd1list", "ud1main", "uid1bl", "ug1f", "ud1s", "ud11f", "uidonebl", "udronlist", "ug001string", "ud9pl", "udoneList", "upp151next", "ud31part", "upp151int", "udonebe", "ud11s", "udronmain", "ud91list", "ud001int", "ud01l", "ud151main", "uid1pl", "ud11be", "ug91f"]}}
{"project": "qemu", "commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "target": 0, "func": "void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n", "idx": 6927, "substitutes": {"data": ["index", "frame", "header", "da", "sample", "final", "result", "d", "ata", "slice", "pad", "read", "ops", "bin", "mu", "missing", "output", "li", "batch", "ui", "object", "DATA", "input", "message", "val", "done", "module", "u", "change", "load", "alpha", "next", "start", "a", "size", "match", "code", "valid", "send", "body", "ee", "number", "value", "Data", "raw", "open", "p", "arr", "style", "buf", "image", "block", "pass", "memory", "post", "zero", "align", "window", "dat", "complete", "date", "split", "end", "progress", "error", "ul", "empty", "bytes", "response", "dd", "buffer", "wa", "master", "cache", "i", "info", "la", "pack", "results", "update", "first"], "length": ["end", "Length", "enc", "message", "len", "type", " len", "size", "code", "pack", " lengths"], "hlen": ["hhlf", " hLen", "uhlength", "hlan", "khlon", "hrlon", "hmin", "wlength", "hrlen", " h12", "Hval", "hsval", "phlon", "Hlon", "hden", "chlan", "hslen", "hlon", "hlimit", " hlan", "khlen", "dhden", "uhlimit", "hh12", "hmlan", "hmlf", "dhlan", "Hlin", "khlf", " hlon", " hval", "ahlength", "dhlf", "ahlen", "thlong", "phLen", "hsmin", "hhlen", "chlen", " hden", "phlen", "bhlan", "hLen", " hmin", "kh12", "plon", "hlength", "hmlon", "dhlen", "Hlen", "hrlin", "h12", "HHlon", "ahlong", "HHlen", "HHLen", "hlin", "bhlin", "Hmin", "phlength", "Hlength", "bhlon", "chden", "hlf", "bhlen", "hrlan", " hlf", "thlength", "hval", " hlength", "ahlimit", "hmlen", "HHlength", "wLen", "Hlf", "hhlon", "thlimit", "pLen", "wlen", "hslength", "thlen", "wlon", "plength", "chlf", "uhlong", "hlong", "uhlen", "Hlan"], "plen": ["clener", "pelend", "pplen", " pln", " plum", "blenth", "plenth", "blen", "palum", "plens", "pallen", " plend", "clen", "palen", "clens", "plener", " plener", "pln", "ppens", "plend", " plens", "ppn", "ppen", " plenth", "palens", "cln", "plum", "ipllen", "bllen", "iplener", "blend", "pelenth", "cllen", "iplum", "pelen", " pllen", "pellen", "iplens", "iplen", "pllen"], "proto": ["perto", "probe", "compo", "produtto", "propo", "pertto", "procbe", "perco", "procbo", " progo", "protgo", "probo", "produco", "produto", " prof", "Progo", "progo", "produocol", "pero", "prodo", " probo", "perdo", "Propo", " propo", "Proocol", "procpo", "protf", "prof", "compdo", " protto", "Probe", "compocol", "proocol", "perocol", "Proto", " probe", "protocol", "protdo", "Probo", "proo", "proco", "protto", "procto", " proco", "Prof", " proocol", "compto"], "csum_offset": ["cssum_size", "cssum_offset", "csum67offset", "csav___entry", "csumm_end", "csmission_width", "csuba_offset", "csav_entry", "csum_item", "csm_entry", "csum__end", "csav___offset", "csum_no", "csumi_order", "csav_offset", "csum_end", "csuba_count", "csum_origin", "csum_length", "csum_operation", "csum_slot", "csumi_offset", "csm_off", "csumi_layer", "csumm_offset", "csum__count", "csum__start", "csm__entry", "csum__len", "csumi_slot", "csum_entry", "csav_origin", "csm_offset", "csum__off", "csuba_operation", "csum_len", "csum_width", "csum_size", "csum__offset", "csumm_align", "cssum_off", "csum67operation", "cssum_start", "csm__off", "csum_start", "csum___offset", "csum_slice", "csum67item", "csm__offset", "csmission_offset", "csmission_operation", "csum_align", "csum__align", "csav_slice", "csum___slice", "csum_layer", "cssum_len", "csum_off", "csumm_count", "csum__length", "csm_length", "csum_count", "csav___origin", "csum_order", "csav___slice", "csum___origin", "csum__entry", "cssum_length", "csum67width", "csum___entry", "csm__length", "csuba_no", "csmission_item"], "csum": ["cums", "cfums", "ccac", "cfsum", "ccup", "csums", " cssum", " csup", "cssumb", "cssums", " csumber", "cssum", "cssup", "upsum", "cssumm", "csul", "cumb", "cfum", "cssac", "csend", "cful", " csumm", "csumm", " scums", "cssumber", "csumber", "csup", "cfend", " scumber", " csac", " csums", "cul", "cum", " scum", "csac", " csend", "csumb", " csul", " scumm", " csumb", "upsend", "cfumb", "upsumb", "ccumb", "upssum", "ccum"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void x86_cpu_parse_featurestr(const char *typename, char *features,\n\n                                     Error **errp)\n\n{\n\n    char *featurestr; /* Single 'key=value\" string being parsed */\n\n    static bool cpu_globals_initialized;\n\n    bool ambiguous = false;\n\n\n\n    if (cpu_globals_initialized) {\n\n        return;\n\n    }\n\n    cpu_globals_initialized = true;\n\n\n\n    if (!features) {\n\n        return;\n\n    }\n\n\n\n    for (featurestr = strtok(features, \",\");\n\n         featurestr;\n\n         featurestr = strtok(NULL, \",\")) {\n\n        const char *name;\n\n        const char *val = NULL;\n\n        char *eq = NULL;\n\n        char num[32];\n\n        GlobalProperty *prop;\n\n\n\n        /* Compatibility syntax: */\n\n        if (featurestr[0] == '+') {\n\n            plus_features = g_list_append(plus_features,\n\n                                          g_strdup(featurestr + 1));\n\n            continue;\n\n        } else if (featurestr[0] == '-') {\n\n            minus_features = g_list_append(minus_features,\n\n                                           g_strdup(featurestr + 1));\n\n            continue;\n\n        }\n\n\n\n        eq = strchr(featurestr, '=');\n\n        if (eq) {\n\n            *eq++ = 0;\n\n            val = eq;\n\n        } else {\n\n            val = \"on\";\n\n        }\n\n\n\n        feat2prop(featurestr);\n\n        name = featurestr;\n\n\n\n        if (g_list_find_custom(plus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n        if (g_list_find_custom(minus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n\n\n        /* Special case: */\n\n        if (!strcmp(name, \"tsc-freq\")) {\n\n            int64_t tsc_freq;\n\n\n\n            tsc_freq = qemu_strtosz_metric(val, NULL);\n\n            if (tsc_freq < 0) {\n\n                error_setg(errp, \"bad numerical value %s\", val);\n\n                return;\n\n            }\n\n            snprintf(num, sizeof(num), \"%\" PRId64, tsc_freq);\n\n            val = num;\n\n            name = \"tsc-frequency\";\n\n        }\n\n\n\n        prop = g_new0(typeof(*prop), 1);\n\n        prop->driver = typename;\n\n        prop->property = g_strdup(name);\n\n        prop->value = g_strdup(val);\n\n        prop->errp = &error_fatal;\n\n        qdev_prop_register_global(prop);\n\n    }\n\n\n\n    if (ambiguous) {\n\n        error_report(\"warning: Compatibility of ambiguous CPU model \"\n\n                     \"strings won't be kept on future QEMU versions\");\n\n    }\n\n}\n", "idx": 6935, "substitutes": {"typename": ["tyrename", "typerames", "tyonename", "sylename", "typenname", "typenef", "tyrenename", "cypename", "tylenames", "cypenames", "cypenname", "cypenename", "sypenames", "typenames", "typerame", "tyrenef", "tyrenname", "typeef", "cyonenename", "cyonename", "typerename", "sypenef", "cyonenname", "sypename", "sylenef", "typername", "typeames", "tyonenname", "typeame", "typenename", "tylenename", "sypenename", "typeename", "tyonenename", "sylenames", "sylenename", "tyrenames", "tylename", "tylenef", "cyonenames", "tyonenames"], "features": ["data", "forms", "fn", "properties", "classes", "parts", "frames", " Features", "plugins", "events", "devices", "details", "spec", "args", "params", "faces", "cs", "config", "bytes", "xs", "types", "products", "effects", "files", "s", "services", "strings", "fields", "modules", "vals", "flags", "feat", "settings", "facts", "names", "ports", "words", "tests", "bits", "objects", "series", "Features", "reports", "feature", "includes", "reads", "items", "results", "format"], "errp": ["errf", "errr", "erb", "erp", " errpc", "erpc", "errorp", " errf", "Erb", "Erf", "errpc", "errorr", " errr", "Err", "err", "erf", "errorb", "errb", "errorf", "Erp", "Erpc"], "featurestr": ["varfr", "featurestream", "resultstr", "FeatureStr", "fieldfr", " featureStr", "featst", "featStr", "sharest", "Featurebr", "featstring", " featurestring", "functionst", "attributebr", "featurefr", "vartext", " featurefr", "shareSTR", "fieldstr", "conceptfr", "functionbr", "wordst", "attributestream", "attributest", " featurener", "attributeStr", "Featurestr", "functionStr", "imagest", "varStr", "featstream", "resultStr", "conceptbr", "featstri", "imageinst", "wordstr", "wordSTR", "attributener", "featurener", "feattext", "imagestr", "featuresst", "attributestr", "featurebr", "varstr", "conceptstr", "functionstr", "functionstring", "featureSTR", " featurebr", " featurestream", "wordStr", "featurestri", "conceptstri", "featuresstr", "resultfr", "fieldstri", "wordinst", "wordstring", "Featurestring", "attributestring", "featstr", "shareinst", "resultstri", "featuresner", "fieldStr", "featurest", "featbr", "conceptStr", "concepttext", "featfr", "featureinst", " featurestri", "featuresStr", "featureStr", " featurest", "featurestring", "featuretext", "imageSTR", "sharestr"], "cpu_globals_initialized": ["cpu_globalls_enabled", "cpu_globalls_Initialized", "cpu_globalls_initialized", "cpu_globals_known", "cpu_globalls_init", "cpu_globals_Initialized", "cpu_globals_enabled", "cpu_globalls_known", "cpu_globals_init", "cpu_globalls_loaded", "cpu_globals_loaded"], "name": ["nice", "on", "text", "str", "type", "up", "old", "id", "common", "cap", "missing", "data", "new", "member", "am", "key", "call", "none", "test", "change", "start", "part", "names", "size", "code", "null", "time", "base", "nam", "url", "value", "self", "mem", "no", "search", "inc", "image", "n", "large", "option", "Name", "word", "var", "all", "action", "pass", "comment", "model", "feat", "named", "prefix", "active", "NAME", "title", "x", "scope", "field", "label", "na", "anc", "create", "version", "parent", "info", "filename", "span", "live", "desc", "node", "alias"], "val": ["pos", "index", "eval", "scale", "text", "str", "pr", "par", "id", "dim", "vol", "el", "VAL", "arg", "grad", "count", "unit", "serv", "rel", "v", "property", "data", "local", "ref", "key", "call", "test", "reg", "ind", "Value", "Val", "mod", "part", "code", "valid", "null", "doc", "comp", "util", "base", "cal", "pre", "value", "len", "mem", "p", "inc", "vec", "lib", "var", "opt", "list", "al", "pret", "col", "format", "py", "split", "def", "play", "loc", "op", "pid", "seq", "ctx", "lit", "vals", "live", "sel", "ret"], "eq": ["extra", "ext", "depth", "rc", "sum", "ref", "sq", "scale", "diff", "error", "loc", "element", "adv", "value", "enc", "fx", "exc", "co", "equ", "call", "op", "quad", "iq", "equal", "inc", "seq", "offset", "ch", "query", "change", "ne", "id", "rr", "quality", "abc", "qu", "quant", "ctx", "alpha", "act", "comment", "hop", "cl", "req", "qual", "xy", "info", "prefix", "qq", "sub", "rt", "valid", "ac", "desc", "alias", "col", "cmp", "q", "comp", "util"], "num": ["pos", " numeric", "sum", "index", "np", "end", "proc", "number", "nu", "loc", "param", "text", "umi", "na", "frac", "len", "multi", "mem", "dom", " dim", "no", "orig", "seq", "inc", " coord", " NUM", "offset", "um", "uni", "gnu", "n", "dim", "norm", "init", "nb", "cat", "max", "bin", "mult", "info", "coord", "nt", "NUM", "valid", " number", " inc", "desc", "Num", "col", "node", "gen", "count", "con", "mon", "unit"], "prop": ["data", "root", "pos", "pb", "ref", "target", "proc", "properties", "def", "field", "cp", "param", "j", "key", "op", "p", "api", "prev", "mp", "dep", "type", "ps", "test", "pr", "rop", "config", "par", "lib", "pro", "jp", "option", "obj", "class", "tmp", "Prop", "opt", "lit", "cat", "conf", "part", "feat", "parent", "dev", "project", "attr", "col", "grad", "priv", "cmp", "comp", "term", "doc", "pred", "prot", "property"], "tsc_freq": ["tsc_rotqual", "tsc_Freqs", "tsc_frez", "tsc_freeQ", "tsc_Freq", "tsc_lenp", "tsc_FreQ", "tsc_frep", "tsc_frequencyQ", "tsc_fq", "tsc_freity", "tsc_frequencyqs", "tsc_leniq", "tsc_fiq", "tsc_rotity", "tsc_Frep", "tsc_frequencyiq", "tsc_Frequality", "tsc_rotQ", "tsc_rotq", "tsc_freeqs", "tsc_req", "tsc_freiq", "tsc_perquality", "tsc_Freiq", "tsc_freqs", "tsc_lenq", "tsc_rez", "tsc_rotquality", "tsc_freeiq", "tsc_perity", "tsc_Frez", "tsc_fQ", "tsc_lenQ", "tsc_requal", "tsc_Freity", "tsc_freQ", "tsc_frequencyq", "tsc_perq", "tsc_freeq", "tsc_perQ", "tsc_rotz", "tsc_frequal", "tsc_fp", "tsc_Frequal", "tsc_frequality", "tsc_requality"]}}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n", "idx": 6946, "substitutes": {"s": ["scope", "local", "y", "storage", "sq", "e", "d", "si", "er", "server", "sys", "self", "p", "sync", "session", "S", "client", "is", "ses", "qs", "sets", "gs", "service", "u", "xs", "ds", "sym", "c", "m", "ss", "services", "sh", "t", "g", "f", "ns", "us", "ssl", "settings", "se", "i", "w", "sl", "o", "tests", "sis", "less", "z", "js", "b", "es", "http", "q", "os", "v", "south", "spec"], "vq": ["vque", "fq", "vqs", " vue", "vue", "viq", "vg", "vdq", " vg", "fue", "Viq", " vqi", "bdq", "svq", "sviq", "bq", "Vq", "bque", "vqi", "svdq", "fdq", "quqs", "qudq", "Vg", " vqs", "quq", " viq", "svg", "Vdq", " vdq", "svque", "bqi", "fqs", "quue", "svqi", " vque"], "handler": ["func", "fn", "sth", "reader", "callback", "error", "er", "controller", "self", "event", "hand", "function", "type", "h", "channel", "cher", "service", "handled", "response", "c", "ctx", "host", "f", "path", "parse", "Handler", "or", "info", "ph", "manager", "w", "wrapper", "job", "rb", "route", "gen", "handle", "cb", "parser"], "n": ["nc", "fn", "nn", "y", " N", "j", "name", "d", "p", "num", "ne", "config", "u", "l", "net", "c", "m", "t", "all", "g", "ns", "nl", "nb", "f", "sn", "en", "nr", "network", "N", "i", "o", "w", "nt", "z", "b", "in", "x"], "qbus": ["vusb", "qcat", "Qplug", "viewusb", "qBus", "qtus", "sqplug", " qusb", "qdev", "QBus", "qqboot", "sqBus", "vcat", "qus", "sqcache", "sqboot", "qtcache", "squs", "qusb", "Qcache", "qqbus", "vbus", "Qboot", "viewcat", " qdev", "Qus", "qqBus", "qtbus", " qcat", "qboot", "qtplug", "vdev", "viewbus", "qqplug", "Qbus", "sqbus", "qcache", "qplug", "viewdev"], "k": ["j", "tk", "d", "ik", "get", "self", "p", "ks", "kw", "ko", "h", "K", "kin", "ku", "ki", "u", "kernel", "ka", "ijk", "ck", "unk", "c", "m", "ctx", "g", "kb", "dk", "o", "ky", "w", "uk", "sk", "b", "ok", "q", "ke", "v"], "r": ["root", "ru", "br", "re", "ner", "result", "e", "d", "er", "str", "self", "p", "rg", "rf", "rh", "h", "hr", "pr", "u", "rr", "l", " result", "res", "lr", "sr", "mr", "m", "c", "rd", "cr", "g", "f", "rev", "or", "ro", "ri", "nr", "R", "err", "i", "w", "ar", "rar", "kr", "fr", "dr", "gr", "rus", "rb", "rw", "b", "rl", " res", "q", "v", "rs", "ret", "rt"], "rc": ["nc", "uc", "pc", "ref", "ras", "result", "error", "success", "back", "RC", "pg", "cc", "anc", "rx", "wx", "src", "ry", "rh", "sc", "xc", "auc", "inc", "ack", "roc", "RR", "rr", "rn", "abc", "ck", "rs", "cur", "bc", " RC", "rec", "dc", "arc", "cr", "ource", "fc", "err", "tc", "lc", " rac", "rb", " src", "ra", "ac", "ok", "misc", "irc", "rt"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}", "idx": 6951, "substitutes": {"queue": ["complete", "pool", "context", "set", "collection", "server", "command", "p", "que", "Queue", "question", "connection", "flow", "client", "buf", "seq", "channel", "module", "ue", "config", "lib", "file", "sequence", "entry", "forward", "menu", "buffer", "console", "qa", "group", "cache", "global", "list", "manager", "gui", "loop", "database", "route", "q", "feed", "port"], "from": ["link", "new", "form", "sec", "end", "to", "with", "about", "slave", "since", "component", "From", "ce", "who", "conn", "offset", "at", "via", "without", "c", "cur", "source", "range", "as", "or", "start", "se", "user", "cf", "origin", "fr", "pri", "resource", "after"], "packet": ["Packset", "packset", "compkt", "packette", "assacket", "compet", "packinet", "pet", "compinet", "competter", "packkt", "compacket", "compset", "asset", "packeting", "passacket", "plugel", "plugeting", "Packart", "Packacket", "compart", "packel", "passel", "plugkt", "packart", "compel", "assinet", "plugette", "plugetter", "plugett", "plugacket", "Packinet", "compett", "Packetter", "competing", "Packeting", "Packet", "plugset", "passett", "plugart", "packetter", "packacket", "packett", "passet", "compette", "pkt", "pluget", "assette", "Packette", "pette"], "next": ["EXT", "data", "new", "future", "end", "second", "ner", "error", "success", "then", "now", " Next", "open", "done", "prev", "last", "seq", " entry", "later", "line", "Next", "sequence", "again", "step", "entry", "forward", "f", "path", "page", "nd", "start", "reply", "code", "iterator", "first"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6953, "substitutes": {"session": ["batch", "sid", "input", "view", "save", "server", "open", "event", "mem", "connection", "client", "socket", "conn", "Session", "channel", "use", "config", "request", "connect", "child", "secret", "ession", "ESSION", "ssl", "parent", "cache", "bin", "gui", "database", "bind", "subject", "resource", "lock", "window", "token", "port"], "data": ["batch", "ada", "da", "DATA", "result", "input", "d", "message", "Data", "len", "server", "open", "base", "api", "slice", "done", "client", "image", "bytes", "response", "read", "content", "entry", "buffer", "next", "array", "start", "a", "cache", "size", "memory", "database", "timeout", "results", "body", "window", "dat"], "datalen": ["daclener", "dalllen", " dataln", " datalength", "davaln", "davalen", "daclen", " datalens", "dachelen", " dallength", "dalen", "dstallen", "datalener", " daclens", " dataleng", "dataln", " dalllen", "dataleng", " datallen", "dachelength", "dstaleng", " dacln", " daclener", "dalleng", "daln", "dacheleng", "dstalen", "dalener", "dstalength", "datallen", "dacln", "davalener", " datalener", "dalens", "dachellen", "davalens", "dallen", " daclen", "dallength", " dallen", "datalength", "daclens", "datalens", " dalleng"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int slice_end(AVCodecContext *avctx, AVFrame *pict)\n\n{\n\n    Mpeg1Context *s1  = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n\n\n    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)\n\n        return 0;\n\n\n\n    if (s->avctx->hwaccel) {\n\n        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)\n\n        ff_xvmc_field_end(s);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    /* end of slice reached */\n\n    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {\n\n        /* end of image */\n\n\n\n        ff_er_frame_end(&s->er);\n\n\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else {\n\n            if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n                s->picture_number++;\n\n            /* latency of 1 frame for I- and P-frames */\n\n            /* XXX: use another variable than picture_number */\n\n            if (s->last_picture_ptr != NULL) {\n\n                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);\n\n                if (ret < 0)\n\n                    return ret;\n\n                ff_print_debug_info(s, s->last_picture_ptr);\n\n            }\n\n        }\n\n\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 6956, "substitutes": {"avctx": ["avecoll", "vercam", "afcmp", "avcontext", "aphctx", "ajcmp", "AVcas", "mpcf", "ovcoll", "ovcms", "aphkw", "camcmp", " avcms", "AVcoll", "ajcas", "vercoll", "afcms", "mploc", "avloc", "aphcontext", "navcf", " avcoll", " avcontext", "aircontext", "AVloc", "camcontext", "ovctx", "afctx", "avcf", "awcmp", "avecontext", "aircmp", "afcontext", "afcp", "ajcontext", "avecmp", "avcp", "AVcp", "avecam", "afcoll", "avcas", "afkw", "ovcontext", "AVcontext", "navctx", "avkw", "navloc", "airctx", "AVctx", "awcontext", "awctx", "afcf", "avcmp", "camctx", "avcms", "mpctx", "awcf", "afcam", "aircp", "avectx", "verctx", "AVkw", "aphcmp", "camcf", "avcam", "afcas", "mpcmp", "AVcmp", "avcoll", "aveloc", "vercmp", "ajctx", "navcmp", "afloc"], "pict": ["peg", "jpg", "sci", "pas", "photos", "photo", "proc", "pai", "capt", "Pic", "fat", "phot", "fi", "cli", "game", "sys", "p", "plain", "png", "sc", "image", "img", " pic", "ch", "config", "acs", "ic", "obj", "txt", "c", "picture", "init", "ctx", "screen", "mot", "pic", "asa", "bis", "cat", "imag", "cam", "gif", "feat", "xxx", "Pict", "pty", "pres", "fig", "doc", "oss", "stat"], "s1": ["cone", "ss91", "c1", " s3", "ssone", "p1", " sone", "sa91", "sc0", " s0", "sone", "c0", "s0", "p91", "ss2", "ss3", "s91", "s2", "sONE", "saone", "ss1", "c3", "sc1", " sONE", " s2", "sc2", "pone", "c2", "s3", "cONE", "sa1", "scONE"], "s": ["comm", "d", "sync", "args", "vs", "ops", "sg", "services", "fs", "f", "b", "features", "conf", "v", "south", "an", "sq", "sb", "plugins", "params", "h", "ses", "cs", "r", "this", "u", "sf", "ss", "ts", "t", "ns", "a", "w", "its", "sis", "es", "http", "comments", "self", "sys", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "xs", "stats", "n", "c", "g", "us", "ssl", "sl", "su", "qs", "rs", "si", "spec", "y", "aws", "j", "e", "server", "details", "is", "service", "ds", "request", "l", "sym", "m", "ctx", "ms", "bis", "sim", "as", "settings", "i", "o", "js", "os"], "xvmc_acceleration": ["xvmc_accelation", "xvmc_enccelerations", "xvmc_acsellization", "xvmc_aceneration", "xvmc_acenerator", "xvmc_acsellations", "xvmc_enccelerization", "xvmc_accelerator", "xvmc_accelations", "xvmc_enccelerator", "xvmc_acenerations", "xvmc_accelerations", "xvmc_acsellation", "xvmc_accelator", "xvmc_enccelator", "xvmc_accelerization", "xvmc_enccelation", "xvmc_acsellator", "xvmc_enccelations", "xvmc_enccelization", "xvmc_encceleration", "xvmc_accelization", "xvmc_acenerization"], "picture_number": ["picture_length", "picture__length", "pictureplength", "image_length", "picture__number", "picture__num", "picturepnumber", "image_nr", "picture__nr", "image_number", "picture_nr", "picturepnr", "image_num", "picture_num", "picturepnum"]}}
{"project": "FFmpeg", "commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972, "substitutes": {"s": ["sample", "d", "sync", "site", "res", "ops", "sr", "sg", "services", "fs", "f", "space", "sv", "ges", "b", "side", "conf", "serv", "v", "re", "sq", "sb", "h", "ses", "r", "cs", "u", "sf", "ss", "ts", "t", "ns", "sa", "its", "w", "es", "http", "sec", "sche", "sys", "p", "ls", "session", "S", "ps", "gs", "sets", "c", "sup", "g", "ssl", "sl", "su", "same", "qs", "rs", "si", "aws", "e", "server", "is", "service", "ds", "states", "sym", "sie", "m", "ms", "settings", "o", "js", "os"], "block": ["batch", "Block", "frame", "re", "ref", "section", "object", "view", "coll", "blocks", "rule", "bl", "clock", "type", "bit", "un", "session", "record", "BL", "channel", "r", "box", "unit", "line", "layer", "rec", "buffer", "range", "array", "group", "bin", "cache", "list", "node", "b", "chain", "row", "lock", "base"], "n": ["nc", "nn", "k", " N", "ner", "e", "d", "len", "p", "num", "r", "ne", "l", "c", "all", "rec", "nb", "ns", "nl", "g", "en", "N", "nat", "w", "z", "b", "ln"], "level": ["low", "index", "set", "scale", "d", "build", "vel", "le", "coll", "str", "where", "type", "id", "file", "lo", "temp", "step", "f", "location", "count", "row", "unit", "lock", "local", "depth", "total", "limit", "key", "val", "call", "Level", "rule", "clean", "stage", "mode", "layer", "weight", "path", "day", "cl", "size", "loop", "code", "lc", "url", "levels", "value", "len", "full", "cost", "inc", "sol", "line", "child", "all", "pass", "model", "rol", "length", "col", "round", "fail", "loc", "ul", "ll", "sc", "wl", "l", "VEL", "roll", "ld", "global", "la", "letter", "lvl", "ell"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "di", "e", "li", "p", "yi", "ti", "slice", "is", "mi", "phi", "qi", "ii", "r", "position", "hi", "u", "uni", "ind", "id", "l", "ni", "ip", "c", "init", "layer", "ori", "f", "io", "start", "ri", "ini", "info", "o", "it", "gi", "x", "xi", "uri", "ci", "z", "b", "in", "iu", "I", "ai", "v", "si"], "j": ["pos", "br", "note", "k", "aj", "str", "jc", "op", "p", "un", "jit", "jl", "ij", "r", "ji", "ind", "dj", "l", "jp", "jo", "m", "v", "g", "ja", "jet", "kj", "uj", "syn", "el", "err", "o", "job", "z", "js", "jump", "b", "adj", "ani", "q", "rel", "jj", "J", "li"], "run": ["batch", "UN", "ru", "pos", "index", "nn", "end", "set", "fun", "name", "play", "build", "vel", "limit", "len", "val", "exec", "call", "sync", "type", "un", "runs", "num", "order", "clean", "inc", "r", "win", "config", "use", "runner", "reg", "go", "skip", "child", "step", "layer", "add", "version", "weight", "pass", "day", "min", "max", "mod", "running", "ran", "loop", "job", "Run", "round", "con", "row", "unit", "thread", "output", "update", "base"], "rl": ["ru", "rc", "lb", "ruby", "gb", "repl", "lv", "bf", "vr", "sb", "pl", "rg", "ls", "ll", "r", "rr", "l", "lr", "sr", "mr", "tl", "il", "nl", "ctrl", "ro", "dl", "el", "ssl", "rol", "fc", "sl", "lp", "fr", "lc", "rb", "rel", "sel", "rs", "fl", "rt"], "scantable": ["scactable", "Scandible", "scantsible", "scandible", "Scandable", "scantsiable", "Scantable", "Scantables", "Scantible", "Scaptiable", "Scaptables", "scandables", "scaptor", "scantsor", "scaptable", "scaptible", "Scandor", "Scandables", "scentable", "scactiable", "scentible", "scantsable", "scantsables", "scactible", "scandiable", "scaptables", "scandable", "Scantiable", "Scandiable", "scentiable", "scaptiable", "scantible", "scantor", "Scantor", "Scaptable", "scactables", "Scaptible", "scentables", "scantables", "scandor", "scantiable"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n", "idx": 6997, "substitutes": {"is": ["isc", "api", "id", "ip", "s", "ops", "init", "IS", "ar", "uri", "Is", "has", "in", "does", "ui", "are", "ie", "ais", "get", "iris", "app", "isu", "ses", "ii", "cs", "this", "config", "ic", "iso", "can", "ib", "or", "was", "its", "sis", "isi", "mis", "es", "http", "ins", "las", "iss", "isl", "parts", "self", "ish", "ls", "full", "use", "css", "us", "it", "lis", "bs", "ist", "irc", "nis", "core", "isin", "isa", "cms", "ils", "il", "ms", "act", "as", "bis", "ri", "info", "iv", "js", "esi", "ics", "ris", "os", "ois"], "vp": ["vl", "pb", "vm", "eve", "np", "fps", "lv", "vg", "ppa", "vr", "pg", "tp", "p", "nv", "api", "mp", "pps", "vs", "pr", "sp", "plugin", "jp", "vP", "pm", "tmp", "uv", "px", "pp", "vt", "wp", "gp", "cv", "pkg", "hw", "VP", "avi", "iv", "esp", "PF", "xp", "lp", "va", "uf", "qv", "bp", "sv", "ov", "vc", "fp", "pd", "v", "vv", "adr"], "i": ["bi", "ui", "pi", "rc", "k", "index", "j", "di", "e", "d", "multi", "fi", "cli", "ti", "yi", "p", "vi", "api", "h", "phi", "qi", "ii", "r", "u", "ji", "ni", "l", "ip", "s", "abi", "m", "c", "t", "ix", "oi", "g", "f", "zi", "io", "ri", "ini", "o", "gi", "mu", "xi", "x", "uri", "ci", "eni", "z", "b", "iu", "I", "ai", "v", "si", "li"]}}
{"project": "FFmpeg", "commit_id": "560b10a6c3627cccf6735170d370cf9e3d38e805", "target": 1, "func": "static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n", "idx": 6999, "substitutes": {"q": ["context", "k", "sq", "cal", "queue", "input", "d", "e", "co", "core", "charge", "call", "self", "p", "que", "question", "event", "quad", "ce", "iq", "sync", "dq", "client", "qi", "ue", "this", "query", "u", "config", "request", "l", "qu", "ck", "c", "m", "v", "t", "quant", "cur", "g", "f", "requ", "comment", "cl", "qa", "req", "Q", "quest", "cache", "qq", "cf", "x", "z", "qt", "conf", "work", "qs"], "i": ["ui", "bi", "index", "pi", "k", "ie", "j", "di", "e", "d", "multi", "fi", "ti", "p", "uli", "yi", "phi", "qi", "ii", "r", "hi", "u", "id", "chi", "ni", "l", "ip", "n", "abi", "c", "oi", "f", "zi", "io", "start", "a", "ri", "ini", "info", "o", "gi", "mu", "x", "xi", "uri", "it", "ci", "eni", "z", "b", "in", "length", "iu", "count", "I", "ai", "v", "si", "li"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004, "substitutes": {"hw": ["wy", "wb", "ou", "vp", "wm", "wx", "kw", "h", "wo", "hm", "fw", "voc", "hp", "hh", "ctx", "nw", "tw", "wa", "hop", "wu", "ow", "gp", "pkg", "we", "iw", "w", "qq", "sw", "zh", "rw", "ha", "work", "ht", "wd", "wk"], "ret": ["pat", "data", "func", "re", "pin", "ref", "Return", "def", "result", "rep", "fun", "alt", "value", "att", "len", "val", " Ret", " RET", "fi", "mem", "sil", "seq", "RET", "lib", "reg", "et", "res", "lex", "aux", "fin", "art", "pass", "ben", "vt", "det", "ft", "al", "match", "reply", "rets", "Ret", "rt"], "pa": ["lia", "pb", "pas", "audio", "fa", "pi", "opa", "appa", "pc", "oa", "pai", "sea", "au", "arta", "pre", "ppa", "apa", " PA", "na", "ampa", "p", "qua", "pr", "ua", "pn", "pan", "ka", "jp", "per", "pse", "cca", "PA", "ista", "ba", "ta", "pm", "ana", " Pa", "sa", "ja", "qa", "gp", "a", "tta", "ma", "ca", "lp", "SPA", "python", "ga", "va", "Pa", "pe", "ena", "pha", "la", "bp", "ama", "bank", "ya", "po"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_device_init(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->init) {\n\n        return sc->init(s);\n\n    }\n\n    return 0;\n\n}\n", "idx": 7017, "substitutes": {"s": ["an", "scope", "sq", "e", "d", "sb", "server", "sys", "self", "p", "sync", "spec", "args", "S", "is", "ses", "gs", "sets", "r", "cs", "service", "ds", "sie", "m", "c", "sym", "t", "services", "ts", "g", "f", "a", "ssl", "settings", "i", "o", "js", "b", "es", "os", "south", "si"], "sc": ["sci", "scope", "uc", "pc", "rc", "sq", "Sc", "core", "super", "cc", "anc", "SC", "sync", "spec", "src", "cus", "esc", "ct", "cs", "sp", "contract", "asc", "ss", "c", "cr", "bc", "dc", "acc", "cle", "cl", "osc", "ec", "se", "cer", "fc", "ca", " SC", "tc", "code", "ci", "lc", "usc", "comp", "si"]}}
{"project": "qemu", "commit_id": "aaa0eb75e2e56d483c89731a447c999985713b43", "target": 0, "func": "static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int dirty)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bs->dirty_bitmap[idx];\n\n        if (dirty) {\n\n            val |= 1 << bit;\n\n        } else {\n\n            val &= ~(1 << bit);\n\n        }\n\n        bs->dirty_bitmap[idx] = val;\n\n    }\n\n}\n", "idx": 7019, "substitutes": {"bs": ["iss", "pb", "fps", "lb", "gb", "ras", "outs", "sb", "bid", "boxes", "bos", "blocks", "ks", "BS", "ls", "ps", "utils", "lbs", "vs", "ses", "cs", "gs", "ros", "ds", "ubs", "ss", "bes", "ba", "ils", "css", "obs", "bc", "banks", "fs", "ns", "bis", "als", "bh", "bits", "js", "b", "locks", "ins", "os", "bps", "rs", "bas", "las", "asts"], "sector_num": ["sector_name", "sector_Num", " sector_sum", "sector00sum", "section_gener", "sectorxname", "sector00number", "sector00two", "sectoritynum", "sector_number", "sector_two", "sector00num", "sectorxgener", "sectoritymu", "section_name", "sector_mu", "sectoritynumber", "sectorxnum", "section_number", "sectorxnumber", "sector_gener", "sectorityNum", " sector_Num", " sector_number", " sector_two", "section_num", " sector_mu", "sector_sum"], "nb_sectors": ["nb_clectors", "nb_servers", "nb_spevers", "nb_seitors", "nb_sergments", "nb_spectors", "nb_spegments", "nb_psectors", "nb_psevisors", "nb_soctors", "nb_severs", "nb_sevisors", "nb_pseivers", "nb_clegments", "nb_psevers", "nb_soitors", "nb_psegments", "nb_pseitors", "nb_serctors", "nb_segments", "nb_cleitors", "nb_clevisors", "nb_sogments", "nb_seivers", "nb_sovisors", "nb_speivers", "nb_serivers"], "dirty": ["stable", "extra", "biased", "di", "diff", "db", "field", "ny", "negative", "pretty", "confirmed", " force", "deep", "initialized", "ish", "write", "bare", "done", "old", "bug", "fff", "remote", "want", "fake", "magic", "force", "primary", "foo", "flag", "irty", "paid", "virtual", "prefix", "quiet", "uri", "visible", "shadow", "valid", "background", "null", "fix", "zero", " strict", "know"], "start": ["pos", "index", "from", "ie", "set", "pre", "name", "try", "d", "get", "key", "grade", "p", "mid", "sync", "no", "style", "stop", "Start", "pad", "cost", "offset", "old", "last", "is", "use", "ind", "id", "rest", "init", "step", "add", "st", "boot", "ix", "force", "next", "art", "source", "check", "max", "min", "part", "info", "ad", "it", "front", "size", "like", "state", "in", "length", "count", "work", "x", "base"], "end": ["index", "k", "set", "e", "then", "eff", " End", "len", "event", "mid", "last", "stop", "offset", "use", "inner", "est", "ind", "id", "until", "ion", "rest", "run", "add", "End", "path", "range", "nd", "or", "max", "en", "min", "END", "size", "x", "ent", "edge", "ending", "ide", "ended", "length", "post", "append", "send", "update", "after"], "val": ["py", "data", "pos", " var", "ref", "cal", "fail", "eval", "gb", "pre", "value", "sel", "aval", "pl", "len", "key", "fl", "p", "bl", "pid", "buf", "pr", "pa", "change", "lib", "ind", "id", "net", "Val", "il", "pt", "vol", "prop", "ee", "pal", "vals", "el", "part", "bin", "slot", " v", "sl", "VAL", "al", "bal", "ver", "x", "valid", "live", "b", "grad", "count", " Val", "doc", "unit", "v", " data", " value", "stat", "base"], "idx": ["indc", "idc", "indxp", "Idy", "idv", "Idc", " idc", "Idx", "indf", "idxp", " idf", " idv", "indv", "indx", "Idz", " idz", " idy", "Idxp", "idz", "indy", "idy", "Idv", " idxp", "indz", "Idf", "idf"], "bit": ["tag", "pos", "index", "field", "value", "alt", "key", "byte", "op", "base", "no", "year", "quad", "type", "num", "BIT", "offset", "ct", "bug", "patch", "ind", "id", "option", "block", "word", "not", "Bit", "boot", "day", "character", "hop", "cat", "ort", "part", "bin", "slot", "parent", "it", "bits", "band", "ac", "b", "col", "fix", "count", "unit"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n\n{\n\n    size_t fetched = 0;\n\n    struct iovec *src = pkt->vec;\n\n\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n\n\n    while (fetched < pkt->virt_hdr.gso_size) {\n\n\n\n        /* no more place in fragment iov */\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n\n            break;\n\n        }\n\n\n\n        /* no more data in iovec */\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n\n            break;\n\n        }\n\n\n\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n\n            pkt->virt_hdr.gso_size - fetched);\n\n\n\n        *src_offset += dst[*dst_idx].iov_len;\n\n        fetched += dst[*dst_idx].iov_len;\n\n\n\n        if (*src_offset == src[*src_idx].iov_len) {\n\n            *src_offset = 0;\n\n            (*src_idx)++;\n\n        }\n\n\n\n        (*dst_idx)++;\n\n    }\n\n\n\n    return fetched;\n\n}\n", "idx": 7027, "substitutes": {"pkt": [" pkk", "Pck", " pct", "opkg", "Punt", " pck", "pkk", "pelt", "kkt", "opacket", "opelt", " pett", "hkt", "facket", "hett", "fkg", "Pct", "fct", "kck", "pck", " punt", "hkk", "Pelt", " pkg", "hacket", "pdu", "Pdu", "Pkg", "opkt", "pett", "spett", "packet", " packet", "punt", "spct", "pkg", "spkk", "pct", "Pkt", " pdu", "fkt", "kacket", "spacket", "spkt", "Packet", " pelt", "spunt", "kdu"], "src_idx": ["src_litz", "src_idez", "src_sidb", "src_iden", "src_idsx", "src_idsxc", "srcerlitxx", "src_idxc", "src_itercent", "src_litx", "src_iterx", "src_idsb", "src_idn", "src_itery", "src_Idz", "src_Idx", "src_iterz", "src_ideny", "srcerlitz", "src_idle", "src_aidx", "src_lity", "srceridxx", "src_idex", "src_Idxs", "src_idc", "srcerlity", "src_idy", "src_idecent", "src_idsxs", "src_idsc", "src_aidxs", "src_idey", "src_sidc", "src_Idn", "src_aidz", "src_litxx", "srceridz", "src_idcent", "src_Idy", "src_idenz", "srceridx", "src_sidxc", "srceridy", "src_idsy", "src_idz", "src_idb", "src_Idxx", "src_Idc", "src_idxx", "src_idele", "src_sidx", "src_idenx", "src_idxs", "src_idexs", "src_idenle", "srcerlitx", "src_aidn"], "src_offset": ["rc_off", " src_len", "src_layer", " src_base", " src_loc", "rc_offset", "rc_len", " src_length", "src_base", " src_layer", " src_origin", "src_loc", "src_length", "rc_limit", "src_limit", " src_off", "src_off", "rc_base", "src_len", "src_origin"], "dst": ["adstage", " drc", "edsrc", "idrc", " dbl", "dssrc", "dstage", "Drc", " dstage", "idconst", "sconst", " dsts", "adbl", "bst", "dsrc", "bsts", "edsts", " dconst", "drc", "dput", "sst", "dssts", "Dsrc", "ssrc", "dbl", "idsts", " dsrc", "dsst", "edput", "bbl", "Dput", "dsts", "adst", " dput", "idst", "bstage", "Dst", "dconst", "adsts", "ssts", "edst", "Dsts"], "dst_idx": ["dst_Idced", "dst_iterX", "dst_Idy", "dst_ridx", "dst_idl", "dst_dX", "dst_infox", "dst_idey", "dst_idced", "dst_errorx", "dst_Idc", "dst__indx", "dst_Idxb", "dst_ridg", "dst_IDx", "dst_idb", "dst_idsg", "dst_idxe", "dst_Idxs", "dst__idz", "dst__indz", "dst_idez", "dst_iterxs", "dst_indcy", "dst_Idx", "dst_aidn", "dst_idsx", "dst_indxs", "dst_idg", "dst_indX", "dst_itercy", "dst_infoz", "dst_idxb", "dst_idX", "dst_infoxe", "dst_dx", "dst_errorc", "dst_idn", "dst_indz", "dst_idxs", "dst_indc", "dst_IDn", "dst_indxb", "dst_Idl", "dst_errorxb", "dst_indced", "dst_IDb", "dst_ridc", "dst_ideX", "dst_indl", "dst__idxe", "dst_infol", "dst_IDxs", "dst_dcy", "dst__indxe", "dst_IdX", "dst_aidx", "dst_idcy", "dst_idy", "dst__indl", "dst_idz", "dst_idex", "dst_iterx", "dst_Idg", "dst_indx", "dst__idl", "dst_idec", "dst_ridxs", "dst_dxs", "dst_errorced", "dst_idsxs", "dst_idsc", "dst_idc", "dst_Idz", "dst_indxe", "dst_Idxe", "dst_aidb", "dst_aidxs", "dst__idx"], "src": ["sci", "uc", "rc", "sec", "url", "dist", "proc", "sq", "gb", "control", "rss", "loc", "sb", "RC", "btn", "upp", "sur", "sync", "sc", "seq", "kk", "support", "img", "dest", "config", "lib", "rest", "st", "ctx", "sup", "host", "source", "inst", "cv", "secure", "ssl", "supp", "feat", "rib", "sub", "rb", "upload", "attr", "desc", "usc", "cb", "grad", "sel", "spec"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n", "idx": 7033, "substitutes": {"opaque": [" opacle", "openac", "opsaque", " opca", "opifice", "opacity", "opsifice", "opsacity", " opac", "opac", "openaque", "ospifice", "openacity", "Opac", "Opaque", "ospacity", "ospaque", " opifice", "openca", " opacity", "opsacle", "opacle", "opca", "Opca", "ospacle", "Opacity"], "addr": ["data", "pos", "ext", "index", "np", "oa", "ref", "scale", "enc", "ord", "adjust", "len", "src", "adder", "slice", "amd", "pad", "ace", "offset", "site", "ack", "cmd", "mode", "layer", "ctx", "alpha", "address", "host", "pointer", "ix", "point", "hop", "padding", "nr", "part", "slot", "coord", "ad", "ar", "xp", "x", "amp", "code", "dr", "md", "edge", "shape", "node", "grad", "cmp", "ptr", "align", "work", "adr", "base"], "val": ["data", "pos", "sum", "def", "eval", "scale", "value", "sel", "aval", "len", "p", "arr", "ul", "slice", "bl", "buf", "bit", "seq", "tx", "block", "all", "Val", "vol", "vals", "el", "slot", "mult", "bin", "sl", "VAL", "al", "alloc", "va", "valid", "b", "arg", "v", "fl", "x", "base"], "size": ["data", "pos", "depth", "sum", "sec", "small", "scale", "loc", "e", "enc", "len", "p", "slice", "offset", "big", "SIZE", "bytes", " length", "large", "l", "ize", "sized", "mode", "Size", "ctx", "ix", "address", "g", "weight", " Size", "i", "fee", "z", "shape", "length", "count", "align", "v", "x"], "s": ["scope", "private", "sq", "aws", "e", "sb", "sys", "p", "sync", "slice", "session", "S", "socket", "is", "ses", "gs", "r", "service", "n", "ss", "c", "m", "sg", "sie", "services", "sym", "fs", "g", "f", "ns", "sa", "ssl", "i", "o", "sl", "secondary", "state", "b", "es", "hs", "os", "conf", "rs", "spec"], "newval": [" newv", "NEWVAL", "newvals", "nextv", " neweval", "newVal", "newVAL", "nexteval", "NewVAL", "Newv", "Newvals", "nextVal", "Newvalue", "rawvalue", "oldVal", "NEWVal", "rawval", "NEWval", "nextval", " newVAL", "neweval", "nextvalue", " newvalue", "oldvals", "nextvals", "oldval", "Newval", "oldvalue", "raweval", " newvals", "NewVal", " newVal", "newv", "newvalue"], "mask": ["allow", "sum", "depth", "hash", "scale", "field", "len", "map", "bit", "filter", "pad", "cost", "ace", "patch", "ch", "ask", "sign", "per", "skip", "sh", "weight", "comment", "max", "qa", "flag", "flags", "carry", "cap", "Mask", "delay", "shadow", "sub", "z", "shape", "sk", "pack", "fix", "q", "count", "conf", "lock", "window", "x"], "shift": ["ffff", "pos", "depth", " scale", "reverse", "push", "mix", "set", "dist", "scale", "sq", "diff", "Shift", "field", " shifted", "slice", "flow", "pad", "cost", "offset", "ace", "shr", "patch", "off", "ask", "ind", "pop", " offset", "sh", "step", "ix", "force", "sup", "hole", "hift", "start", "part", "align", "z", "shape", "pack", "length", "fix", "shake", "count", "zero", " push", "window", "pull"]}}
{"project": "FFmpeg", "commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "target": 1, "func": "static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n", "idx": 7048, "substitutes": {"s": ["y", "sec", "sq", "e", "d", "share", "si", "parts", "coll", "self", "p", "sync", "sys", "ks", "facebook", "ls", "S", "session", "ps", "is", "ses", "site", "gs", "sets", "cs", "service", "u", "ds", "r", "this", "xs", "n", "l", "ops", "ss", "c", "m", "ts", "services", "t", "ctx", "sym", "g", "f", "ns", "space", "sup", "as", "bis", "us", "a", "ssl", "se", "its", "your", "js", "es", "setup", "http", "ins", "os", "conf", "rs", "spec"], "frame": ["builder", "header", "target", "scale", "element", "fx", "coll", "hide", "slice", "iframe", "rame", "ace", "die", "flower", "file", "sequence", "f", "draw", "el", "thread", "data", "object", "zone", "view", "show", "interface", "module", "position", "fake", "plane", "layer", "kt", "part", "za", "fram", "panel", "scene", "base", "layout", "flo", "frames", "component", "document", "game", "p", "flow", "style", "full", "image", "ze", "line", "block", "fd", "c", "motion", "series", "board", "feature", "cycle", "window", "fl", "figure", "e", "fb", "video", "m", "ctx", "dy", "buffer", "source", "point", "Frame", "fab", "node", "setup", "framework", "update"], "sps": ["sPS", "wsfs", "ssps", "spa", "ppa", "Sas", "sfs", "pps", "sas", "sms", "wsas", "cspa", "ssPS", "csPS", "csms", "wsps", "pms", "Spa", "wspa", "csps", "Sfs", "sspa", "ssms", "Sps", "pPS"], "ret": ["data", "ext", "rc", "re", "ref", "end", "def", "result", "rep", "success", "alt", "att", "fun", "back", "get", "len", "val", "fi", "arr", "base", "bit", "num", "RET", "resp", "empty", "reg", "id", "inf", "res", "rot", "fin", "f", "art", "lit", "bis", "en", "flag", "det", "match", "nt", "code", "reply", "rt", "arg", "status", "rets", "Ret"], "i": ["data", "ui", "y", "pi", "index", "ie", "j", "di", "si", "e", "d", "fi", "cli", "ti", "p", "api", "h", "mi", "qi", "ii", "u", "inner", "ji", "n", "ni", "l", "ip", "ami", "m", "c", "init", "t", "ori", "ix", "oi", "f", "shift", "io", "start", "min", "ri", "ini", "info", "o", "gi", "x", "xi", "uri", "eni", "ci", "b", "in", "iu", "length", "I", "ai", "v", "li"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16u8 res0, res1, res2, res3;\n\n    v16i8 filt0, filt1, filt2;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 7066, "substitutes": {"src": ["uc", "rc", "sec", "url", "dist", "sq", "loc", "sb", "RC", "pl", "sil", "sur", "rx", "sync", "slice", "gz", "sc", "seq", "img", "dest", "config", "ctr", "sr", "st", "cur", "gl", "tmp", "sup", "source", "scene", "sit", "inst", "req", "secure", "ssl", "scl", "sl", "iv", "rib", "sub", "https", "rb", "rect", "desc", "cb", "href", "cmp", "comp", "stream", "send", "sel", "rs", "spec", "rob"], "src_stride": ["src_stided", "src_Strade", "src_drade", "src_brine", "src_Strides", "src_stine", "src_strides", "src_Stride", "src_stide", "src_stides", "src_bride", "src_drides", "src_strid", "src_Strine", "src_stid", "src_strided", "src_strade", "src_brides", "src_brided", "src_striides", "src_strine", "src_drided", "src_STRides", "src_striide", "src_STRided", "src_striid", "src_STRide", "src_brid", "src_Strided", "src_STRade", "src_striided", "src_dride"], "dst": ["ddest", "wsl", "wst", "Ddest", "dnsc", "dnsl", "Dst", "Dsc", "wsc", "dsc", "Dsl", "dndest", "wdest", "dsl", "dnst"], "dst_stride": ["dst_strride", "dst_strided", "dst_stid", "dst_stide", "dst_stided", "dst_arrid", "dst_arrided", "dst_collided", "dst_collride", "dst_arride", "dst_collid", "dst_strid", "dst_collide", "dst_arrride"], "height": ["data", "depth", "bottom", "def", "diff", "wcs", "Height", "std", "style", "img", "ctr", "dim", "block", "resolution", "bg", "dc", "repeat", "buffer", "padding", "max", "crop", "z", "shape", "length", "count", "window"], "loop_cnt": ["loop_cNT", "loop_count", "loop_CNT", "loop_ncNT", "loop_lcnt", "loop_nccount", "loop_ccount", "loop_Cnt", "loop_lcount", "loop_lccount", "loop_ncount", "loop_ncnt", "loop_lcNT", "loop_Count", "loop_Ccount"], "src0": ["source0", "const1", "img8", "source8", "img2", "source1", "rc0", "source4", "source2", "src00", "rc8", "img0", "const2", "img1", "rc4", "rc00", "rc1", " src00", "const8", "const0", "rc2", "source00"], "src1": ["source5", "source0", "source3", " src01", "rc5", "loc4", "filename5", "rc3", "obl1", "obl81", "obl5", "source1", "filename0", "loc2", " src81", "rc0", "loc0", "source4", "loc1", "src81", "src01", "loc01", "obl01", "rc4", "filename1", "rc1", "rc81", "rc2", "source01", "rc01"], "src2": ["source5", "rc62", "rc02", "dest1", "dist02", "img8", "rc5", "loc4", "src62", "source8", "rc32", "img2", "inst02", "dist62", "dest4", "loc2", "rc0", "loc0", "src32", "source2", " src02", "img4", "loc1", "dist2", "dest2", "dest02", "rc8", "inst2", "src02", "inst5", "dist4", "rc4", "inst8", " src62", "source02", "rc1", "img32", "rc2", " src32"], "src3": ["source3", "srcThree", "source0", "rc5", "src53", "rc3", "source03", "source1", " src53", "src23", "dest4", "rc53", " src23", "rc0", "source4", "dest03", "source23", "img4", "source53", "sup5", "img03", "sup2", "rc03", " src03", "rc23", "src03", "rc4", "sup3", "sup1", "destThree", "rc1", " srcThree", "rc2", "dest3", "img3", "imgThree"], "src4": ["dest54", "rc54", "source3", "dest40", "img7", " src04", "rc3", "src04", "reflect54", "img2", "src40", "source1", " src40", "dest4", "source4", "source2", "rc7", "reflect4", "img4", "img40", "rc40", "src54", "source04", "reflect1", "reflect3", "rc4", "reflect40", "rc04", "reflect7", "rc1", "rc2", "dest3", "source7"], "src5": ["src50", "source50", "source5", "rc4", "rc50", " src25", "rc25", " src50", "source25", "rc5", "source4", "src25"], "src6": ["rc6", "source66", "rc56", " src66", "rc66", "source56", "src66", "rc76", "src76", "source6", "source76", " src56", "src56", " src76"], "src7": ["rc87", "rc7", "src87", "sup87", "sup73", "source87", "sup77", "rc77", "rc73", "sup7", "source73", "src73", "source77", "source7", "src77"], "src8": ["src85", " src08", "rc85", "rc08", "src08", "source08", "source88", " src88", "rc8", "src88", "rc88", "source8", "source85", " src85"], "src10_r": ["src10_ra", "src10_ru", "src16_r", "src10_b", "src110_b", "src110_r", "src16_u", "src110_ru", "src10_rs", "src10_p", "src16_rs", "src110_p", "src16_ra", "src10_u"], "src32_r": ["src43_pr", "src32__r", "src32_pr", "src32_b", "src32_br", "src52_rg", "src43_rs", "src32_rg", "src32_rs", "src32__rs", "src52_b", "src32__l", "src32__pr", "src52_br", "src52_r"], "src54_r": ["src76_rw", "src76_rs", "src54xrw", "src54_rw", "src54_rs", "src76xr", "src76xrw", "src76xrs", "src54xl", "src76xl", "src54xr", "src54xrs"], "src76_r": ["src76_rs", "src76_t", "src75_rs", "src75_r", "src75_ra", "src75_t", "src76_ra"], "src21_r": ["src21_rs", "src31_rg", "src43_p", "src31_r", "src31_l", "src21_b", "src21_p", "src21_rg", "src43_rg", "src43_b", "src31_rs"], "src43_r": ["src73_cr", "src73_l", "src43_d", "src43_w", "src73_d", "src43_rs", "src73_w", "src73_r", "src43_cr", "src43_sr", "src73_sr", "src73_rs"], "src65_r": ["src65_ir", "src67_rs", "src65_rs", "src65_rr", "src67_r", "src67_ir", "src67_rr"], "src87_r": ["src7_l", "src7_r", "src87_ra", "src87ixra", "src87_pr", "src87ixpr", "src7_ra", "src87ixl", "src7_pr", "src87ixr"], "src10_l": ["src30_lc", "src10_lc", "src10amrl", "src30_l", "src10amurl", "src30_url", "src10_rl", "src10amlc", "src10aml", "src30_rl", "src10_url"], "src32_l": ["src32__r", "src32__u", "src31_r", "src32_u", "src31_l", "src31_u", "src32_rl", "src32__l", "src32__rl", "src31_rl"], "src54_l": ["src53_ll", "src53_l", "src53_lc", "src54_lc", "src53_r", "src54_ll"], "src76_l": ["src76_lc", "src56_r", "src76_kl", "src56_lc", "src76__lc", "src56_l", "src56_kl", "src76__r", "src76__l", "src76__kl"], "src21_l": ["src71_r", "src21_d", "src71_lc", "src71_l", "src71_d", "src21_lc"], "src43_l": ["src73_l", "src73_r", "src73_lc", "src73_lr", "src43_lc", "src43_lr"], "src65_l": ["src65_m", "src5_b", "src5_m", "src65_b", "src5_r", "src5_l"], "src87_l": ["src57_d", "src87_d", "src87_rl", "src57_l", "src57_r", "src57_rl"], "out0_r": ["out0xl", "out0_m", "out0_er", "out0xr", "out0xer", "out1_er", "out0xm", "out1_m"], "out1_r": ["out32_r", "out32_mr", "out32_l", "out1_n", "out32_n", "out1__l", "out1__mr", "out1__r", "out1__n", "out1_mr"], "out2_r": ["out3_rs", "out2_rd", "out3_rd", "out2_rs"], "out3_r": ["out1_lr", "out3_p", "out3_lr", "out1_p"], "out0_l": ["out1_v", "out1_b", "out0_v", "out0_b"], "out1_l": ["out2_b", "out2_p", "out1_b", "out1_p"], "out2_l": ["out2_b", "out1_b", "out1_sl", "out2_sl"], "out3_l": ["out3_b", "out2_f", "out2_b", "out3_f"], "res0": ["resolution4", "Res50", "Res1", "Res4", "resolution0", "resolution1", "res50", "Res0", " res4", "resolution50", "res4", " res50"], "res1": ["pt2", "ps2", "Res1", "ps1", "ps0", "pt3", "Res0", "pt0", "Res2", "Res3", "pt1", "ps3"], "res2": ["pres3", "rem3", "Res1", "rem2", "pres0", "rem0", "Res0", "Res2", "Res3", "pres1", "pres2", "rem1"], "res3": ["out03", "pres3", "res23", "resThird", "pres03", "presThird", "res03", "outThird", "vec03", "vec3", "out3", "vec23", "vecThird", "pres23", "out23"], "filt0": ["fill0", "filt150", "ifelt2", " falt2", "felt1", "falt0", " falt150", "fract1", " falt0", "falt2", "falt1", "ifelt1", "fract2", " falt1", "ifilt0", "felt0", "falt150", " filt150", "fill2", "font2", "font150", "ifelt0", "font1", "ifilt1", "fract0", "fill150", "ifilt2", "fill1", "felt2", "font0"], "filt1": [" filt3", "fail1", " falt2", " fil0", "filt3", " faltOne", "firm1", " fil3", "filt100", "fil100", "fil0", "fil3", "falt0", " filt100", " falt0", "falt2", "falt1", "faltOne", " fil100", "fail0", "firm2", "fiddle1", " filtOne", "filtOne", " falt1", "firm0", "firmOne", "fiddle3", "fail100", "fil2", "fiddle100", "fail3", " fil1", "fiddle0", "fil1", "filOne"], "filt2": ["flt1", "ffit2", "ffilter1", "ffit4", "ffit0", " fil0", "ffilter4", "fil0", "felt4", "filt4", "Filt4", " fil2", "firm2", "Filt0", "Flt0", "felt02", "firm0", "Flt1", "ffilter2", "felt0", "filt02", " fil4", "firm4", "fil4", " fil02", "flt0", "Flt4", "firm02", "ffit1", "fil2", " filt4", "Filt2", "Filt1", "flt2", "Flt2", "felt2", " filt02", "fil02", "ffilter0", "flt4"]}}
{"project": "qemu", "commit_id": "6b33f3ae8b79726ef0812597b8a83c3e82d31514", "target": 0, "func": "static int img_commit(int argc, char **argv)\n\n{\n\n    int c, ret, flags;\n\n    const char *filename, *fmt, *cache, *base;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs, *base_bs;\n\n    bool progress = false, quiet = false, drop = false;\n\n    bool writethrough;\n\n    Error *local_err = NULL;\n\n    CommonBlockJobCBInfo cbi;\n\n    bool image_opts = false;\n\n    AioContext *aio_context;\n\n\n\n    fmt = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    base = NULL;\n\n    for(;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:ht:b:dpq\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 't':\n\n            cache = optarg;\n\n            break;\n\n        case 'b':\n\n            base = optarg;\n\n            /* -b implies -d */\n\n            drop = true;\n\n            break;\n\n        case 'd':\n\n            drop = true;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                return 1;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        return 1;\n\n    }\n\n\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    qemu_progress_init(progress, 1.f);\n\n    qemu_progress_print(0.f, 100);\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, QERR_BASE_NOT_FOUND, base);\n\n            goto done;\n\n        }\n\n    } else {\n\n        /* This is different from QMP, which by default uses the deepest file in\n\n         * the backing chain (i.e., the very base); however, the traditional\n\n         * behavior of qemu-img commit is using the immediate backing file. */\n\n        base_bs = backing_bs(bs);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, \"Image does not have a backing file\");\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    cbi = (CommonBlockJobCBInfo){\n\n        .errp = &local_err,\n\n        .bs   = bs,\n\n    };\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n\n                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,\n\n                        &local_err, false);\n\n    aio_context_release(aio_context);\n\n    if (local_err) {\n\n        goto done;\n\n    }\n\n\n\n    /* When the block job completes, the BlockBackend reference will point to\n\n     * the old backing file. In order to avoid that the top image is already\n\n     * deleted, so we can still empty it afterwards, increment the reference\n\n     * counter here preemptively. */\n\n    if (!drop) {\n\n        bdrv_ref(bs);\n\n    }\n\n\n\n    run_block_job(bs->job, &local_err);\n\n    if (local_err) {\n\n        goto unref_backing;\n\n    }\n\n\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n\n        ret = bs->drv->bdrv_make_empty(bs);\n\n        if (ret) {\n\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n\n                             filename);\n\n            goto unref_backing;\n\n        }\n\n    }\n\n\n\nunref_backing:\n\n    if (!drop) {\n\n        bdrv_unref(bs);\n\n    }\n\n\n\ndone:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        return 1;\n\n    }\n\n\n\n    qprintf(quiet, \"Image committed.\\n\");\n\n    return 0;\n\n}\n", "idx": 7069, "substitutes": {"argc": ["agc", "ortcat", "argcat", "agp", "incf", "ortp", "agv", "argC", "genC", " argn", " argdc", "agcat", " argC", "numv", "argdc", "argp", "ortv", "arkn", "arkc", " argcount", "gendc", " argcat", " argf", "incv", "incc", "ortc", "arkdc", "numf", "arkC", "numcount", "argn", "numc", "genc", "argcount", "argf", " argp", "genn", "inccount"], "argv": ["argval", "agc", "Argv", "argb", " argb", "agv", "argsp", "argsv", "argV", "argsb", "argsf", "arb", "argp", "argsV", " argV", " argf", "ArgV", "arc", "Argval", "arv", "Argf", "agf", "Argc", "argf", " argval", "arp", " argp", "argsc", "agval"], "c": ["unc", "nc", "uc", "rc", "k", "e", "d", "cc", "anc", "p", " rc", "ce", "h", "sc", "ct", "xc", "cm", "cs", "r", "ch", "u", "n", "l", "cy", "s", "m", "t", "arc", "dc", "rec", "cr", "g", "f", "cur", "ctx", "ctrl", "mc", "cl", "ec", "fc", "i", "cf", "ca", "C", "code", "cn", "ci", "lc", "cd", "ac", "b", "col", "cb", "count", "con", "v", "orc"], "ret": ["fn", "re", "rc", "result", "enc", "exec", "len", "val", "fi", "gc", "ll", "lib", "fd", "rec", "bc", "fs", "buffer", "cat", "flag", "reply", "status", "count", "rets", "final", "fl"], "flags": ["options", "fps", "FLAG", "parts", "plugins", "comments", "mask", " Flags", "details", "args", "forces", "cs", "changes", "stats", "files", "ops", "fd", "ils", "fields", "fs", "Flags", "vals", "flag", "settings", "ints", "lf", "bits", "reads", "features", "locks", "fg", "status", "utils", "fl", "ips"], "filename": ["root", "unc", "wb", "options", "fn", "url", "Filename", "name", "document", "acl", "username", "aml", "config", "abl", "password", "file", "files", "txt", "fd", "tmp", "STDOUT", "il", "buffer", "f", "which", "path", "prefix", "utf", "original", "rb", "length", "rl", "dll", "fp", "binary", "output", "directory"], "fmt": ["Fmd", "fMT", "fmd", "fnt", "lfmd", "lfformat", "lfmt", "filt", "fformat", "lmt", "Ffamily", "rfMT", "Filt", "lformat", "familyMT", "familyfamily", "lmd", " ffamily", "lfilt", "ffamily", "familyformat", "lilt", "Fformat", "rfmt", "familymt", "Fmt", " fformat", "FMT", "Fnt", " fnt", "rfformat", " fMT", "rfnt"], "cache": ["pool", "local", "options", "storage", "cal", "pre", "play", "queue", "ache", "enc", "coll", "clear", "AC", "p", "sync", "acl", "bm", "session", "client", "position", "config", "lib", "file", "cdn", "cookie", "keep", "temp", "buffer", "f", "cat", "table", "ver", "prefix", "memory", "ca", "lc", "ac", "timeout", "store", "cas", "http", "cmp", "chain", "comp", "lock", "Cache"], "base": ["batch", "builder", "root", "local", "stable", "real", "layout", "extra", "stack", "object", "url", "area", "scale", "name", "queue", "build", "print", "core", "server", "sync", "bare", "Base", "api", "clean", "offset", "image", "position", "service", "lib", "file", "temp", "layer", "buffer", "shell", "source", "bat", "padding", "parent", "bin", "prefix", "database", "state", "background", "board", "b", "store", "tree", "http", "normal", "body", "bas", "format"], "blk": ["blb", "blg", "flb", "flk", " blb", "flg", "Blg", "blks", "Blks", "Blk", "Blb", " blg", "flks", " blks"], "bs": ["pb", "fps", "lb", "gb", "bid", "bos", "BS", "ls", "bl", "aos", "SB", "ps", "Bs", "cs", "ros", "ds", "ss", "rs", "ba", "css", "ils", "bc", "fs", "ns", "bal", "BC", "bas"], "base_bs": ["server_fs", "base_ds", "server_bs", "server_ds", "server_bits", "base_fs", "base_bits"], "writethrough": ["writetyill", "writetrrite", "Writetyrust", "Writetyrough", "writetrrust", "writetyrust", "writetrrough", "Writethrust", "Writetyrite", "writethill", "Writethrite", "Writetyill", "writethrust", "writetyrough", "writetrill", "writohrough", "Writethrough", "writohrust", "writetyrite", "writohill", "writethrite", "writohrite", "Writethill"], "local_err": ["local_exc", "global_errors", "global_error", "global_exc", "global_err", "local_error", "local_errors"], "cbi": ["pcfi", "lcfi", "pcbf", "cfi", "bcBI", "lcbf", "pcBI", "cbf", "pcbi", "bcfi", "lcBI", "lcbi", "cBI", "bcbi", "bcbf"], "aio_context": ["aiodconfig", "aiodctx", "aios_config", "aios_ctx", "aios_context", "aiodstorage", "aio_storage", "aio_config", "aio_ctx", "aiodcontext", "aios_storage"], "long_options": ["short_opt", "long_flags", "longcopyflags", "long_option", "short_flags", "short_config", "longcopyoptions", "long_config", "longcopyconfig", "short_options", "short_option", "long_opt", "longcopyoption"], "opts": ["OPments", "optt", "OPals", "OPcs", "OPts", "opments", " ops", "OPters", "opers", "OPs", "opals", "operments", " opters", "OPks", "ops", "operals", "optts", "optks", " opals", "opters", "opt", " opt", "opcs", " opks", " opcs", "opps", "OPps", "opks", "optcs", "optps", " opps", "OPt", "operts", "optters", " opments"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)\n\n{\n\n    unsigned long stack_base, error, size;\n\n    int i;\n\n    int * stack;\n\n    int argc, envc;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = stack_size;\n\n\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1)\n\n        qerror(\"stk mmap\");\n\n\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size;\n\n    stack = (void*)stack_base;\n\n/*\n\n *    | STRING AREA |\n\n *    +-------------+\n\n *    |      0      |\n\n*    +-------------+\n\n *    |  apple[n]   |\n\n *    +-------------+\n\n *           :\n\n *    +-------------+\n\n *    |  apple[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    |    env[n]   |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    env[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    | arg[argc-1] |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    arg[0]   |\n\n *    +-------------+\n\n *    |     argc    |\n\n *    +-------------+\n\n * sp->    |      mh     | address of where the a.out's file offset 0 is in memory\n\n *    +-------------+\n\n*/\n\n    /* Construct the stack Stack grows down */\n\n    stack--;\n\n\n\n    /* XXX: string should go up there */\n\n\n\n    *stack = 0;\n\n    stack--;\n\n\n\n    /* Push the absolute path of our executable */\n\n    DPRINTF(\"pushing apple %s (0x%x)\\n\", (char*)argv[0], (int)argv[0]);\n\n    stl(stack, (int) argv[0]);\n\n\n\n    stack--;\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get envc */\n\n    for(envc = 0; env[envc]; envc++);\n\n\n\n    for(i = envc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing env %s (0x%x)\\n\", (char*)env[i], (int)env[i]);\n\n        stl(stack, (int)env[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    /* Add on the stack the interp_prefix choosen if so */\n\n    if(interp_prefix[0])\n\n    {\n\n        char *dyld_root;\n\n        asprintf(&dyld_root, \"DYLD_ROOT_PATH=%s\", interp_prefix);\n\n        page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)dyld_root);\n\n        stack--;\n\n    }\n\n\n\n#ifdef DONT_USE_DYLD_SHARED_MAP\n\n    {\n\n        char *shared_map_mode;\n\n        asprintf(&shared_map_mode, \"DYLD_SHARED_REGION=avoid\");\n\n        page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)shared_map_mode);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n#ifdef ACTIVATE_DYLD_TRACE\n\n    char * extra_env_static[] = {\"DYLD_DEBUG_TRACE=yes\",\n\n    \"DYLD_PREBIND_DEBUG=3\", \"DYLD_UNKNOW_TRACE=yes\",\n\n    \"DYLD_PRINT_INITIALIZERS=yes\",\n\n    \"DYLD_PRINT_SEGMENTS=yes\", \"DYLD_PRINT_REBASINGS=yes\", \"DYLD_PRINT_BINDINGS=yes\", \"DYLD_PRINT_INITIALIZERS=yes\", \"DYLD_PRINT_WARNINGS=yes\" };\n\n\n\n    char ** extra_env = malloc(sizeof(extra_env_static));\n\n    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));\n\n    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);\n\n\n\n    for(i = 0; i<9; i++)\n\n    {\n\n        DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extra_env[i], (int)extra_env[i]);\n\n        stl(stack, (int) extra_env[i]);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get argc */\n\n    for(argc = 0; argv[argc]; argc++);\n\n\n\n    for(i = argc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]);\n\n        stl(stack, (int) argv[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    DPRINTF(\"pushing argc %d \\n\", argc);\n\n    stl(stack, argc);\n\n    stack--;\n\n\n\n    DPRINTF(\"pushing mh 0x%x \\n\", (int)mh);\n\n    stl(stack, (int) mh);\n\n\n\n    /* Stack points on the mh */\n\n    return (unsigned long)stack;\n\n}\n", "idx": 7099, "substitutes": {"mh": ["tmh", "mw", "mmh", "mhs", "tmhs", "mmw", "mmhs", " mH", "tmw", "mmH", "tmH", "mH", " mw", " mhs"], "argv": ["argvs", "igp", "Argv", " argl", "igf", "igvs", "argV", "axl", "axp", "argp", "Argp", " argV", "igV", "argl", "argh", " argf", "argvin", "tagvin", " argvin", "Argl", "ArgV", "tagv", "axc", "Argvs", "arv", "arvin", " argvs", "Argf", "axv", "igc", "arh", "igv", "Argc", "tagp", "argf", "arp", " argp", " argh", "tagh"], "env": ["extra", "context", "scope", "ext", "end", "target", "db", "loc", "queue", "e", "enc", "vel", "exc", "exec", "equ", "export", "vert", "server", "ea", "p", "que", "event", "args", "eq", "params", "style", "app", "esc", "conn", "vs", "inc", "img", "ne", "ev", "config", "password", "stage", "file", "txt", "net", "ss", "uv", "path", "shell", "console", "bat", "Environment", "inst", "cv", "ec", "en", "el", "json", "iv", "dev", "esp", "sl", "erv", "code", "inet", "eni", "edge", "sv", "qt", "po", "doc", "v", "environment", "dat"], "stack_base": ["stack_b", "scale_length", "stack_orig", " stack_Base", "scale_origin", "stack_length", "stack67root", "stack_root", "stack67origin", "stack67length", "stack__Base", "stack__b", "stack_Base", "Stack_base", "scale_root", "stack_origin", "stack__base", "Stack_Base", "stack67base", "scale_base", "Stack_fixed", " stack_orig", "Stack_prefix", "stack__orig", "stack_prefix", " stack_b", "stack_fixed"], "error": ["root", "ception", "warning", "object", "index", "number", "notice", "progress", "scale", "result", "success", "e", "rss", "element", "message", "exc", "back", "throw", "core", "trace", "debug", "event", "call", "grade", "catch", "no", "slice", "type", "order", "ace", "image", "offset", "bug", "ERROR", "ack", "patch", "channel", "large", "unknown", "layer", "danger", "address", "range", "comment", "or", "rage", "Error", "parent", "err", "info", "ror", "o", "original", "code", "node", "status", "errors", "count", "resource", "oid", "raise"], "size": ["complete", "sum", "storage", "form", "small", "scale", "name", "si", "loc", "fat", "len", "core", "grade", "ice", "sync", "call", "ey", "done", "args", "offset", "speed", "empty", "SIZE", "large", "ize", "sized", "c", "Size", "address", "weight", "shift", "send", "range", "capacity", "iz", "sn", "cache", "security", "global", "fee", "ci", "needed", "edge", "shape", "timeout", "time", "grow", "align", "unit"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "aci", "j", "di", "e", "mini", "multi", "fi", "cli", "ti", "p", "yi", "vi", "base", "api", "mi", "phi", "qi", "ii", "r", "hi", "u", "inner", "ji", "id", "n", "l", "ni", "ip", "chi", "abi", "c", "m", "init", "bc", "ix", "oi", "f", "g", "zi", "io", "my", "start", "ri", "ini", "err", "info", "gi", "it", "x", "xi", "uri", "iv", "ci", "eni", "lc", "in", "b", "iu", "count", "I", "ai", "v", "si", "li"], "stack": ["pos", "index", "push", "header", "set", "scale", "back", "str", "slice", "args", "ace", "site", "ack", "file", "forward", "table", "tree", "count", "stream", "thread", "batch", "context", "data", "depth", "package", "wrap", "input", "view", "trace", "cli", "call", "offset", "channel", "box", "config", "change", "stage", "load", "st", "layer", "weight", "cl", "cv", "fr", "loop", "code", "shape", "store", "null", "pull", "base", "reverse", "layout", "len", "self", "history", "inc", "line", "shift", "shell", "console", "check", "sl", "list", "wrapper", "level", "wait", "cycle", "window", "scope", "progress", "queue", "loc", "play", "ul", "function", "counter", "pop", "ctx", "buffer", "array", "roll", "cache", "tc", "pack", "Stack", "chain"], "argc": ["fileci", "argci", "envp", "argp", "filep", "envci", "argr", "filer", " argp", " argci", "envr", " argr", "filec"], "envc": ["envv", "environmentci", "environmentdc", "argrc", "espp", " envl", "argct", "envrc", "espci", "enc", "environmentrc", "envr", "environmentr", "environmentc", "ternc", " envcy", "envct", "environmentcc", "environmentn", "ecl", "argdc", "enrc", "enp", "envci", " envcc", "environmentl", "environmentv", "envdc", "environmentp", "espc", "envp", "envcc", "enci", "environmentct", " envr", "arglc", " envv", "environmentlc", "encr", "ternlc", "enn", "envcr", "ternn", "ecc", "envl", "envn", "environmentcy", "envcy", "argn", "argcr", "eccy", "enr", " envn", "ternct", "endc", "ecv", "envlc", "environmentcr", "espcr", "encc"], "dyld_root": ["dyldapproot", "dyld_home", "dyld54prefix", "dyred_prefix", "dyld00prefix", "dyll_range", "dynd_theme", "dyld_leaf", "dyldappstart", "dyld_prefix", "dyldappprefix", "dyld00root", "dyll_prefix", "dynd_home", "dyldalroots", "dynd_roots", "dyldapproots", "dyldalroot", "dyld00range", "dyll_roots", "dyll_root", "dyld_range", "dyldaltheme", "dynd_prefix", "dyld54root", "dyred_root", "dyll_start", "dyld00roots", "dyld_theme", "dyld54home", "dyldalprefix", "dyld_roots", "dyld_start", "dyld54roots", "dynd_root", "dyred_roots", "dyred_leaf"], "shared_map_mode": ["shared_map\n", "shared_maps_mode", "shared_maps\n", "shared_class\n", "shared_table\n", "shared_classget", "shared_map_type", "shared_maps_mod", "shared_maps\t", "shared_tableget", "shared_maps_settings", "shared_table\t", "shared_mapget", "shared_map\t", "shared_map_settings", "shared_class\t", "shared_maps_type", "shared_map_mod", "shared_mapsget"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status |= COM_CRC_ERROR;\n\n        rtype = sd_illegal;\n\n        goto send_response;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            rtype = sd_illegal;\n\n            goto send_response;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    if (rtype == sd_illegal) {\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n    }\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\nsend_response:\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    case sd_illegal:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 7105, "substitutes": {"sd": ["dn", "dist", "od", "sam", "d", "dt", "ti", "std", "site", "s", "sg", "nd", "ga", "bd", "dm", "sv", "sk", "south", "wd", "li", "SD", "vd", "sb", "df", "ses", "cm", "sf", "sp", "ind", "ic", "ss", "sa", "sed", "dk", "lc", "sw", "cd", "vc", "sec", "gb", "de", "sm", "ay", "conn", "cod", "lib", "fd", "gd", "hd", "dis", "ed", "sl", "ad", "su", "pd", "si", "dat", "di", "report", "sc", "sy", "service", "ds", "sem", "dd", "sie", "sh", "des", "sim", "sn", "dl", "se", "sta", "dev", "ci", "md", "esi", "td", "ld"], "req": ["ru", "worker", "ref", "sq", "proc", "def", "progress", "loader", "view", "exec", "str", "report", "required", "rx", "rf", "Request", "src", "call", "ry", "rh", "dq", "client", "org", "hr", "r", "resp", "query", "config", "sem", "request", "reg", "rr", "ctr", "pro", "cmd", "res", "sr", "ctx", "rec", "f", "requ", "range", "ro", "ri", "quest", "conf", "err", "qq", "fr", "require", "gr", "rb", "ra", "desc", "cb", "http", "q", "cmp", "resource", "serv", " request", "spec", "rt"], "response": ["data", "object", "def", "result", "success", "e", "error", "view", "message", "document", "respons", "server", "report", "api", "connection", "session", "answer", "onse", "image", "r", "resp", " responses", "Response", "service", "sp", "request", "offer", "application", "res", "respond", "given", " resp", "description", "model", "en", "err", "json", "o", "reply", "sw", "Resp", "su", "status", "resource", "serv", "v", "ret"], "rtype": ["arpy", "rrstyle", "rrpy", "rarpe", "rtypes", "rTYPE", "rartype", "rlstyle", "prvalid", "arbid", "rval", "crtype", "arclass", "artyp", " rtypes", "nrbid", "rgtype", " rstyle", "rvalue", "rpy", "crset", " rpe", "nrtyp", "rpart", "rrtyp", "nrvalid", "rsym", "rclass", "rlpe", "prbid", "rblock", "erblock", "crval", " rtyp", "rltype", "srowner", "crsym", "rvalid", "prtype", "rarowner", "lrtypes", "rgval", "rrclass", "rgset", "lrpe", "rrvalue", "rlTYPE", "erpy", "lrtype", "rtyp", "srpart", "ertype", "nrvalue", "rstyle", "nrtype", "rrbid", "rgsym", "arpe", "rrblock", "rarpart", "nrTYPE", "lrtyp", "erclass", "srpe", "srtype", "arblock", "srval", "artype", "nrpe", "rset", "srsym", " rowner", "rrvalid", "prstyle", "arvalue", "rowner", "nrstyle", " rpart", "artypes", "rbid", "rpe", "srset", " rTYPE", "rrtype"], "rsplen": ["rspln", "rspez", "rspaline", "rspalenc", "rsspline", "rsclenc", "wsspln", "wssplen", "rssplens", "rspeenn", "rspren", "rsslien", "rsbllen", "rspalen", "arsspline", "rsploen", "arsplen", "rsquenc", "rsblen", "wspleng", "rssplz", "rsspllen", "rssleng", "rscelink", "rsplenc", "rsPln", "rasplun", "rscln", "rspalun", "rsiplen", "wssplien", "rsquun", "rssperink", "rsclen", "rsquen", "rssperen", "rsPlenc", "rsPlen", "rsspleng", "rssplenc", "arssplens", "arsspllen", "rsllen", "rsplens", "rsclien", "rsperen", "rscleng", "rsproen", "wsspleng", "rsplz", "rsspln", " rsblenc", "rsperink", "raspalen", "rsperz", " rsplenc", "arssplun", "rsperenn", "rscelz", "rsprlen", "rsiplens", "rsquice", "arsplens", "rspalice", "rsPllen", "rspllen", "arspllen", "wsplien", "rscelenn", "rssln", "rspleng", "rssplenn", "rsiplun", "rscllen", "rslens", "rslun", "rspeink", "rssplink", "rssperenn", "rasplenc", "raspalenc", "rspaloen", "rasplice", "rspallen", " rsbllen", "rsbln", " rsbln", "wsplen", "rssperz", "arspline", "rsprine", "rsslen", "rslen", " rsblen", "rscelen", "raspalun", "rsplink", "rsipllen", "arssplen", "rasplen", " rspllen", "rspline", " rspln", "arsplun", "rssplun", "rssplien", "rspeen", "rssplen", "rsplun", "rsplien", "arsploen", "rssplice", "raspalice", "rssploen", "arssploen", "rsplenn", "rsplice", "wspln", "rsblenc"]}}
{"project": "qemu", "commit_id": "9646f4927faf68e8690588c2fd6dc9834c440b58", "target": 0, "func": "void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,\n\n                   uint32_t *eax, uint32_t *ebx,\n\n                   uint32_t *ecx, uint32_t *edx)\n\n{\n\n    X86CPU *cpu = x86_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t pkg_offset;\n\n\n\n    /* test if maximum index reached */\n\n    if (index & 0x80000000) {\n\n        if (index > env->cpuid_xlevel) {\n\n            if (env->cpuid_xlevel2 > 0) {\n\n                /* Handle the Centaur's CPUID instruction. */\n\n                if (index > env->cpuid_xlevel2) {\n\n                    index = env->cpuid_xlevel2;\n\n                } else if (index < 0xC0000000) {\n\n                    index = env->cpuid_xlevel;\n\n                }\n\n            } else {\n\n                /* Intel documentation states that invalid EAX input will\n\n                 * return the same information as EAX=cpuid_level\n\n                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)\n\n                 */\n\n                index =  env->cpuid_level;\n\n            }\n\n        }\n\n    } else {\n\n        if (index > env->cpuid_level)\n\n            index = env->cpuid_level;\n\n    }\n\n\n\n    switch(index) {\n\n    case 0:\n\n        *eax = env->cpuid_level;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 1:\n\n        *eax = env->cpuid_version;\n\n        *ebx = (cpu->apic_id << 24) |\n\n               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */\n\n        *ecx = env->features[FEAT_1_ECX];\n\n        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {\n\n            *ecx |= CPUID_EXT_OSXSAVE;\n\n        }\n\n        *edx = env->features[FEAT_1_EDX];\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;\n\n            *edx |= CPUID_HT;\n\n        }\n\n        break;\n\n    case 2:\n\n        /* cache info: needed for Pentium Pro compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = 1; /* Number of CPUID[EAX=2] calls required */\n\n        *ebx = 0;\n\n        if (!cpu->enable_l3_cache) {\n\n            *ecx = 0;\n\n        } else {\n\n            *ecx = L3_N_DESCRIPTOR;\n\n        }\n\n        *edx = (L1D_DESCRIPTOR << 16) | \\\n\n               (L1I_DESCRIPTOR <<  8) | \\\n\n               (L2_DESCRIPTOR);\n\n        break;\n\n    case 4:\n\n        /* cache info: needed for Core compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, count, eax, ebx, ecx, edx);\n\n            *eax &= ~0xFC000000;\n\n        } else {\n\n            *eax = 0;\n\n            switch (count) {\n\n            case 0: /* L1 dcache info */\n\n                *eax |= CPUID_4_TYPE_DCACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1D_LINE_SIZE - 1) | \\\n\n                       ((L1D_PARTITIONS - 1) << 12) | \\\n\n                       ((L1D_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1D_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 1: /* L1 icache info */\n\n                *eax |= CPUID_4_TYPE_ICACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1I_LINE_SIZE - 1) | \\\n\n                       ((L1I_PARTITIONS - 1) << 12) | \\\n\n                       ((L1I_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1I_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 2: /* L2 cache info */\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(2) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                if (cs->nr_threads > 1) {\n\n                    *eax |= (cs->nr_threads - 1) << 14;\n\n                }\n\n                *ebx = (L2_LINE_SIZE - 1) | \\\n\n                       ((L2_PARTITIONS - 1) << 12) | \\\n\n                       ((L2_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L2_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 3: /* L3 cache info */\n\n                if (!cpu->enable_l3_cache) {\n\n                    *eax = 0;\n\n                    *ebx = 0;\n\n                    *ecx = 0;\n\n                    *edx = 0;\n\n                    break;\n\n                }\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(3) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n                *eax |= ((1 << pkg_offset) - 1) << 14;\n\n                *ebx = (L3_N_LINE_SIZE - 1) | \\\n\n                       ((L3_N_PARTITIONS - 1) << 12) | \\\n\n                       ((L3_N_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L3_N_SETS - 1;\n\n                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;\n\n                break;\n\n            default: /* end of info */\n\n                *eax = 0;\n\n                *ebx = 0;\n\n                *ecx = 0;\n\n                *edx = 0;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */\n\n        if ((*eax & 31) && cs->nr_cores > 1) {\n\n            *eax |= (cs->nr_cores - 1) << 26;\n\n        }\n\n        break;\n\n    case 5:\n\n        /* mwait info: needed for Core compatibility */\n\n        *eax = 0; /* Smallest monitor-line size in bytes */\n\n        *ebx = 0; /* Largest monitor-line size in bytes */\n\n        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;\n\n        *edx = 0;\n\n        break;\n\n    case 6:\n\n        /* Thermal and Power Leaf */\n\n        *eax = env->features[FEAT_6_EAX];\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 7:\n\n        /* Structured Extended Feature Flags Enumeration Leaf */\n\n        if (count == 0) {\n\n            *eax = 0; /* Maximum ECX value for sub-leaves */\n\n            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */\n\n            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */\n\n            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {\n\n                *ecx |= CPUID_7_0_ECX_OSPKE;\n\n            }\n\n            *edx = 0; /* Reserved */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 9:\n\n        /* Direct Cache Access Information Leaf */\n\n        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xA:\n\n        /* Architectural Performance Monitoring Leaf */\n\n        if (kvm_enabled() && cpu->enable_pmu) {\n\n            KVMState *s = cs->kvm_state;\n\n\n\n            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);\n\n            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);\n\n            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);\n\n            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xB:\n\n        /* Extended Topology Enumeration Leaf */\n\n        if (!cpu->enable_cpuid_0xb) {\n\n                *eax = *ebx = *ecx = *edx = 0;\n\n                break;\n\n        }\n\n\n\n        *ecx = count & 0xff;\n\n        *edx = cpu->apic_id;\n\n\n\n        switch (count) {\n\n        case 0:\n\n            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;\n\n            break;\n\n        case 1:\n\n            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_cores * cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;\n\n            break;\n\n        default:\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;\n\n        }\n\n\n\n        assert(!(*eax & ~0x1f));\n\n        *ebx &= 0xffff; /* The count doesn't need to be reliable. */\n\n        break;\n\n    case 0xD: {\n\n        KVMState *s = cs->kvm_state;\n\n        uint64_t ena_mask;\n\n        int i;\n\n\n\n        /* Processor Extended State */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n            break;\n\n        }\n\n        if (kvm_enabled()) {\n\n            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n            ena_mask <<= 32;\n\n            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        } else {\n\n            ena_mask = -1;\n\n        }\n\n\n\n        if (count == 0) {\n\n            *ecx = 0x240;\n\n            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n                const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n                if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                    && ((ena_mask >> i) & 1) != 0) {\n\n                    if (i < 32) {\n\n                        *eax |= 1u << i;\n\n                    } else {\n\n                        *edx |= 1u << (i - 32);\n\n                    }\n\n                    *ecx = MAX(*ecx, esa->offset + esa->size);\n\n                }\n\n            }\n\n            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n            *ebx = *ecx;\n\n        } else if (count == 1) {\n\n            *eax = env->features[FEAT_XSAVE];\n\n        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {\n\n            const ExtSaveArea *esa = &x86_ext_save_areas[count];\n\n            if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                && ((ena_mask >> count) & 1) != 0) {\n\n                *eax = esa->size;\n\n                *ebx = esa->offset;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case 0x80000000:\n\n        *eax = env->cpuid_xlevel;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 0x80000001:\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = env->features[FEAT_8000_0001_ECX];\n\n        *edx = env->features[FEAT_8000_0001_EDX];\n\n\n\n        /* The Linux kernel checks for the CMPLegacy bit and\n\n         * discards multiple thread information if it is set.\n\n         * So don't set it here for Intel to make Linux guests happy.\n\n         */\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||\n\n                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||\n\n                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {\n\n                *ecx |= 1 << 1;    /* CmpLegacy bit */\n\n            }\n\n        }\n\n        break;\n\n    case 0x80000002:\n\n    case 0x80000003:\n\n    case 0x80000004:\n\n        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];\n\n        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];\n\n        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];\n\n        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];\n\n        break;\n\n    case 0x80000005:\n\n        /* cache info (L1 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \\\n\n               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);\n\n        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \\\n\n               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);\n\n        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);\n\n        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);\n\n        break;\n\n    case 0x80000006:\n\n        /* cache info (L2 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \\\n\n               (L2_DTLB_2M_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \\\n\n               (L2_ITLB_2M_ENTRIES);\n\n        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \\\n\n               (L2_DTLB_4K_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \\\n\n               (L2_ITLB_4K_ENTRIES);\n\n        *ecx = (L2_SIZE_KB_AMD << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \\\n\n               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);\n\n        if (!cpu->enable_l3_cache) {\n\n            *edx = ((L3_SIZE_KB / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);\n\n        } else {\n\n            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);\n\n        }\n\n        break;\n\n    case 0x80000007:\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_8000_0007_EDX];\n\n        break;\n\n    case 0x80000008:\n\n        /* virtual & phys address size in low 2 bytes. */\n\n        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n            /* 64 bit processor, 48 bits virtual, configurable\n\n             * physical bits.\n\n             */\n\n            *eax = 0x00003000 + cpu->phys_bits;\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n", "idx": 7109, "substitutes": {"env": ["np", "essential", "equ", "dt", "que", "args", "ce", "energy", "site", "vs", "enable", "init", "engine", "uv", "en", "el", "conf", "v", "output", "context", "vm", "oa", "zone", "db", "loader", "enc", "exec", "ea", "app", "ne", "config", "viron", "stage", "txt", "eye", "Environment", "network", "cv", "ini", "gui", "code", "inet", "het", "edge", "qt", "doc", "environment", "ench", "ext", "eve", "eu", "cal", "org", "conn", "kernel", "et", "eur", "eng", "fen", "host", "console", "manager", "scope", "nc", "end", "queue", "e", "exc", "vert", "server", "event", "ev", "external", "cdn", "obj", "net", "her", "ctx", "assets", "ec", "cache", "global", "err", "erv", "eni"], "index": ["pos", "header", "element", "example", "slice", "type", "num", "site", "id", "pattern", "engine", "condition", "localhost", "table", "fee", "timeout", "unit", "thread", "output", "context", "office", "depth", "object", "diff", "input", "key", "val", "expression", "offset", "position", "current", "ind", "address", "weight", "path", "page", "ini", "axis", "size", "match", "code", "ticket", "url", "number", "value", "len", "connection", "search", "tail", "image", "inc", "instance", "action", "host", "list", "prefix", "level", "length", "active", "find", "x", "date", "end", "error", "queue", "loc", "Index", "version", "pointer", "cache", "info", "node", "update"], "count": ["batch", "depth", "len", "core", "Count", "cc", "call", "last", "seq", "counter", "empty", "current", "head", "child", "weight", "path", "start", "max", "cache", "code", "length", "col", "found", "append", "cmp"], "eax": [" eaz", "ebase", "enax", " eaj", " eas", "ieak", " exa", "ieax", "Eax", " eAX", "ieAx", "eeix", " eAx", "eeau", "ieaz", "ieau", "eaj", "enag", " eag", "eaass", "ceaped", "eaz", "eaped", "EAX", "oeaped", " ease", "eass", "enass", "oeas", "eAX", "eaap", " eau", "eeax", "ceax", "eau", "ieAX", "eaax", "eac", "ebax", "oexa", "iease", "eAx", " eaped", "ebak", "cexa", "eak", "ieac", "eeaz", " eix", "eag", "ebAx", " eak", " eass", " eac", "ieaj", "ease", "eix", "ieix", "eaag", "Eaj", "exa", "oeax", "ceas", "eap", "eas", "enap", "Eac", " eap"], "ebx": ["ebxx", "edz", "debx", "egxx", "edb", "ecb", "ekux", "ebis", "ebb", "debux", "edax", "edex", "edf", "ecg", "ecux", " ebxx", "egy", "ekw", "ekx", "ecX", "egax", "ebw", "ecex", "ebX", "egx", "ecf", "egf", "debX", "ebux", " eby", "ebf", "edX", "ebax", "ecz", "ekz", "edw", "ecax", " ebw", "ekg", "ekX", "eby", "egX", "ebg", "ekis", "ebex", "egz", "ebz", " ebz", "egex", "ecxx", "egb", " ebis", "debg", "edy", "ecy", "edis"], "ecx": ["evg", "ebxx", "edz", "ebid", "ECx", "esclex", "esct", "eqex", "escv", "execX", "eqv", "edex", "edax", "eqt", " ect", "eqx", "egg", "ecg", " ecxx", "edid", " ecv", "ebv", "execx", "ecX", "ecex", "egx", "ebX", "eqxi", "efxx", "efx", "ecid", "edX", "eqax", "egp", "edxx", "eclex", "evp", "ecz", "efv", " eclex", " ecid", "egv", "ecax", "efz", "eqlex", " ecX", "ebg", "ebex", "execex", "execz", "ebz", "ECax", "ecxx", " ecz", "execxx", "escx", "evx", "ebp", "edxi", "ECxi", "ecv", "ect", "ECex", "ecp", "evv", "ecxi", "execv"], "edx": ["edz", "endedX", "dedz", "EDX", "aedz", "ecix", "edex", "EDn", "edax", "EDx", "nedex", "ebn", " edX", "nedX", "ecX", "evtx", "ecex", "ebX", " edex", "egx", "idx", "endedex", "edX", "edn", "idex", "nedx", "edany", "evex", "ecax", "aedex", "nedany", "dedex", "ecn", "endedx", "ecany", "egX", "edtx", "edix", "ebex", "dedx", "aedtx", " edix", "egix", "egex", "endedax", "idax", "evx", "aedx", "evz", "idX", "dedtx", " edany", "EDex"], "cpu": ["pool", "cfg", "nc", "uu", "vm", "pc", "np", "proxy", "proc", "loader", "gpu", "component", "core", "GPU", "clock", "pid", "conn", "module", "cm", "processor", "nic", "config", "intel", "kernel", "n", "obj", "net", "c", "instance", "css", "ctx", "bc", "boot", "px", "console", "hw", "cache", "fc", "python", "chip", "cn", "eni", "lc", "pu", "node", "process", "cmp", "cp", "cpp", "unit", "linux", "utils", "CPU"], "cs": ["ys", "CS", "nc", "pc", "rc", "ras", "wcs", "coll", "co", "core", "cc", "sys", "cons", "ks", "args", "ls", "cus", "ps", "sc", "conn", "vs", "qs", "acs", "ds", "stats", "ops", "c", "ils", "css", "ts", "ctx", "bc", "cells", "fs", "ns", "act", "ec", "acks", "cf", "ca", "cn", "ci", "lc", "js", "cas", "sk", "Cs", "cks", "ics", "bs", "os", "cp", "cmp", "vc", "cross", "rs", "utils", "spec", "ces"], "pkg_offset": ["pkg__num", "work2sort", "pkglsort", "work_offset", "pkg2length", "pkgloffset", "work2length", "pkg_length", "work_num", "work2num", "pkg__length", "work2offset", "pkg2offset", "pkg2sort", "pkg2num", "work_length", "pkg__sort", "pkg_sort", "pkg__offset", "pkg_num", "pkglnum", "work_sort", "pkgllength"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)\n\n{\n\n    char *argstr_flat;\n\n    wchar_t **argv_w;\n\n    int i, buffsize = 0, offset = 0;\n\n\n\n    if (win32_argv_utf8) {\n\n        *argc_ptr = win32_argc;\n\n        *argv_ptr = win32_argv_utf8;\n\n        return;\n\n    }\n\n\n\n    win32_argc = 0;\n\n    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);\n\n    if (win32_argc <= 0 || !argv_w)\n\n        return;\n\n\n\n    /* determine the UTF-8 buffer size (including NULL-termination symbols) */\n\n    for (i = 0; i < win32_argc; i++)\n\n        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                        NULL, 0, NULL, NULL);\n\n\n\n    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);\n\n    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);\n\n    if (win32_argv_utf8 == NULL) {\n\n        LocalFree(argv_w);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < win32_argc; i++) {\n\n        win32_argv_utf8[i] = &argstr_flat[offset];\n\n        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                      &argstr_flat[offset],\n\n                                      buffsize - offset, NULL, NULL);\n\n    }\n\n    win32_argv_utf8[i] = NULL;\n\n    LocalFree(argv_w);\n\n\n\n    *argc_ptr = win32_argc;\n\n    *argv_ptr = win32_argv_utf8;\n\n}\n", "idx": 7111, "substitutes": {"argc_ptr": ["argv_Ptr", "argc__dra", "argc__pointer", "argv_pointer", "argc_Ptr", "argc_tr", "argv_dra", "argv_dep", "argc__ptr", "argc_dr", "argc_ref", "argv_tr", "argc_dep", "argv_dr", "argc_dra", "argc_pointer", "argv_ref", "argc__dr"], "argv_ptr": ["argv___pt", "argv_loc", "argv_pointer", "argv_rot", "argc_priv", "argv___rot", "argc_eth", "argv___ptr", "argv_wr", "argv_pt", "argc_pt", "argv_priv", "argv___pointer", "argc_wr", "argc_loc", "argv___eth", "argv_eth", "argc_rot", "argc_pointer", "argv___wr"], "argstr_flat": ["argstr__fl", "argstr_fast", "argstr_thin", "argstr_layout", "argstr_fl", "argstr_pat", "argstr_atten", "argv_full", "argc_fl", "argc_atten", "argstr__thin", "argv_layout", "argv_flat", "argstr__fast", "argstr__layout", "argv_fast", "argv_fl", "argstr__full", "argc_flat", "argc_pat", "argstr_full", "argv_thin", "argstr__flat"], "argv_w": ["argv_W", "argc_v", "argv25ws", "argvadws", "argv_wa", "argc_wb", "argc_wx", "argv__wb", "argv_orig", "argc_y", "argv2v", "argc_r", "argv__w", "argv_hw", "argvadtw", "argv2y", "argc2w", "argc2y", "argc_hw", "argc_raw", "argv2w", "argv__W", "argv25w", "argvPws", "argc2v", "argc_wa", "argv__y", "argv2ws", "argc_wan", "argvPhw", "argc_w", "argv25wan", "argv_r", "argv25wx", "argvPwx", "argv_wan", "argc_tw", "argv__r", "argvadw", "argv_v", "argc_ws", "argvadwa", "argv__wan", "argv_wx", "argc_orig", "argv_raw", "argv_y", "argvPw", "argv25r", "argv25hw", "argc_W", "argc2ws", "argv_ws", "argv__v", "argv__ws", "argv_wb", "argv_tw"], "i": ["ui", "bi", "y", "index", "pi", "ie", "j", "di", "field", "name", "si", "d", "e", "key", "multi", "fi", "cli", "ti", "p", "yi", "slice", "h", "mi", "phi", "offset", "qi", "ii", "hi", "u", "inner", "at", "id", "n", "ni", "l", "ip", "abi", "m", "c", "init", "t", "ix", "g", "f", "oi", "source", "io", "start", "a", "ri", "ini", "part", "info", "o", "it", "gi", "xi", "uri", "ci", "lc", "z", "b", "in", "iu", "q", "I", "ai", "v", "x", "li"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 7119, "substitutes": {"op0": ["oper0", "oper1", "ip_", " op6", " op00", "ip2", "op00", "mp0", "pop0", "pop90", "oper2", " op_", "mp00", "option2", "oper00", " op2", "ip0", "hop2", "mp8", "hop1", "pop1", "op2", " op90", "hop5", "option0", "op5", "hop_", "mp6", "oc0", "op_", "pop5", "op6", "opt2", "option00", "oc8", "oc00", "ip1", " op5", "opt0", "option1", "hop00", "hop90", "op90", "oc6", "hop0", "opt1", "op8", " op8"], "op1": ["ap01", "OP2", "ip2", "OP1", " op2", "ip0", "hop2", "hop1", "op2", "op8", "ap1", "opOne", "OP8", "opt2", "ip1", "hop8", " opOne", "opt0", "ap0", "apOne", "opt8", "ip8", "ip01", "hop0", "op01", "OP0", "ipOne", "opt1", " op01", " op8"], "size": ["form", "sec", "small", "number", "scale", "loc", "name", "enc", "core", "call", "sync", "style", "type", "SIZE", "empty", "out", "use", "n", "large", "ize", "sized", "c", "Size", "address", "g", "weight", "capacity", "cache", "fee", "code", "shape", "timeout", "six", "align"]}}
{"project": "FFmpeg", "commit_id": "2f996b8397ee0e646a824f3dfcbd291a114af348", "target": 0, "func": "int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n", "idx": 7122, "substitutes": {"avctx": ["avcontext", "apca", "afcb", "accontext", " avconfig", "afconfig", "ajcca", "avcca", " avcontext", "accb", "avconfig", " avcca", "afctx", "apctx", "afcontext", "ajcontext", "ajconfig", "apcontext", "acctx", "avca", "acca", "afcca", "afca", "ajctx", "apcb", "avcb"], "frame": ["header", "sample", "scale", "family", "element", "frames", "message", "document", "fi", "game", "event", "window", "slice", "flow", "type", "iframe", "image", "channel", "position", "line", "file", "fake", "video", "dy", "buffer", "f", "source", "draw", "point", "scene", "Frame", "face", "part", "fram", "stroke", "code", "series", "board", "feature", "setup", "cycle", "time", "property", "format", "base"], "buf_size": ["queue_scale", "window_level", "queue_size", "bufingsize", "bufflen", "bufflevel", "buf_code", "window_type", "windowfsize", "bufingSIZE", "buf0scale", "bufingcode", "buf_sized", "buf_level", "buf_type", "windowflevel", "windowflen", "buf_string", "bufftype", "bufingstring", " buf_string", "buf_source", "queue_source", "buf0sized", "buf_len", "buf0source", "windowftype", " buf_SIZE", "buffsize", "buf_SIZE", " buf_code", "buf_scale", "queue_sized", "window_size", "window_len", "buf0size"], "data": ["sample", "scale", "family", "package", "DATA", "result", "e", "d", "input", "final", "message", "Data", "none", "p", "api", "done", "dat", "image", "empty", "device", "id", "video", "block", "m", "content", "buffer", "f", "next", "source", "draw", "start", "a", "partial", "parent", "cache", "xxx", "info", "media", "o", "size", "database", "board", "missing", "zero", "body", "window", "format", "base"], "s": ["an", "scope", "comm", "sec", "private", "sq", "aws", "e", "d", "parts", "enc", "sb", "sys", "p", "sync", "spec", "ls", "session", "S", "client", "ps", "sc", "is", "ses", "cs", "u", "service", "ds", "xs", "n", "ss", "c", "m", "sym", "services", "t", "ctx", "fs", "sup", "f", "ns", "space", "as", "sa", "bis", "a", "ssl", "w", "o", "js", "com", "si"], "num": ["ui", "pos", "sum", "fn", "index", "uu", "end", "number", "nu", "loc", "result", "umi", "na", "len", "val", "multi", "ul", "no", "orig", "offset", "inc", "uni", "um", "u", "off", "id", "n", "ni", "dim", "init", "f", "en", "nr", "bin", "info", "o", "mu", "NUM", "gen", "b", "Num", "iter", "su", "count", "con", "unit", "update", "x"], "i": ["ui", "pi", "index", "j", "umi", "ti", "p", "mi", "ii", "u", "inner", "ind", "id", "n", "ip", "m", "c", "init", "f", "io", "it", "ci", "b", "in", "I", "ai", "si", "li"]}}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125, "substitutes": {"s": ["storage", "sq", "e", "d", "sb", "sys", "self", "p", "sync", "spec", "sports", "ls", "session", "S", "socket", "ps", "src", "ses", "site", "r", "gs", "service", "sf", "ds", "u", "n", "l", "sie", "c", "ss", "sym", "services", "ts", "m", "t", "g", "ns", "f", "space", "usb", "sim", "ssl", "se", "i", "sl", "o", "secondary", "sis", "sv", "js", "su", "b", "es", "state", "side", "http", "os", "conf", "serv", "v", "south", "si"], "buf": ["batch", "data", "pb", "br", "wb", "uc", "rc", "header", "msg", "bag", "db", "queue", "loader", "bf", "Buffer", "que", "src", "seq", "num", "img", "bb", "config", "vec", "cmd", "fb", "lim", "buff", "fd", "ctx", "bc", "buffer", "f", "path", "prop", "req", "alloc", "coord", "cf", "prefix", "bh", "uf", "bd", "ff", "rb", "b", "cas", "cb", "cmp", "fp", "feed", "port"], "len": ["Len", "data", "pos", "fn", "end", "limit", "val", "li", "ll", "num", "seq", "offset", "lon", "lt", "line", "n", "l", "lim", "block", "all", "fin", "f", "en", "el", "cache", "lin", "size", "list", "lf", "lc", "length", "in", "lan", "count", "ln", "fl", "base"], "res": ["pos", "rc", "reset", "re", "ress", "progress", "pre", "result", "error", "rel", "ras", "rss", "e", "val", "row", "rx", "arr", "details", "no", "rh", "ps", "hr", "seq", "r", "resp", "ret", "reg", "id", "rr", "response", "block", "sr", "resh", "resolution", "css", "mr", "rest", "cr", "des", "rec", "ms", "rev", "ries", "max", "req", "err", "rar", "ver", "rez", "rem", "gr", "rus", "pres", "ris", "RES", "results", "os", "red", "Res", "nos", "rs", "x"], "counter": ["outer", "timer", "number", "total", "ner", "loader", "result", "field", "er", "trace", "server", "ounter", "arr", "prev", "clock", "order", "seq", "num", "r", "sp", "inner", "ctr", "per", "c", "entry", "race", "pointer", "page", "master", "nr", "parent", "cache", "ver", "fr", "loop", "code", "length", "iter", "Counter", "count", "cmp", "row"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_b_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status;\n\n\n\n    bitplane_decoding(&v->skip_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    if (v->mv_mode == MV_PMODE_MIXED_MV)\n\n    {\n\n        status = bitplane_decoding(&v->mv_type_mb_plane, v);\n\n        if (status < 0)\n\n            return -1;\n\n#if TRACE\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n    }\n\n\n\n    //bitplane\n\n    status = bitplane_decoding(&v->direct_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"Skip MB plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    /* FIXME: what is actually chosen for B frames ? */\n\n    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables\n\n    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];\n\n\n\n    if (v->dquant)\n\n    {\n\n        vop_dquant_decoding(v);\n\n    }\n\n\n\n    if (v->vstransform)\n\n    {\n\n        v->ttmbf = get_bits(gb, 1);\n\n        if (v->ttmbf)\n\n        {\n\n            v->ttfrm = get_bits(gb, 2);\n\n            av_log(v->s.avctx, AV_LOG_INFO, \"Transform used: %ix%i\\n\",\n\n                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);\n\n        }\n\n    }\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return 0;\n\n}\n", "idx": 7130, "substitutes": {"v": ["av", "volt", "tv", "vm", "k", "conv", "j", "vd", "vp", "lv", "value", "e", "d", "vic", "view", "vr", "gu", "vert", "ve", "server", "vi", "p", "nv", "h", "vs", "ii", "vin", "ch", "ev", "u", "inv", "r", "this", "n", "l", "video", "s", "var", "temp", "c", "m", "t", "version", "uv", "V", "f", "g", "vol", "rev", "vt", "cv", "a", "i", "iv", "w", "ver", "dev", "o", "va", "sv", "b", "ov", "vc", "q", "serv", "vv", "x"], "gb": ["py", "ui", "cfg", "abb", "gm", "pc", "rc", "storage", "lb", "vd", "gom", "lv", "db", "vg", "bf", "sb", "hub", "mb", "game", "rg", "bm", "gc", "ko", "gz", "gg", "bridge", "git", "gs", "lib", "gy", "gd", "mode", "cgi", "ctx", "bg", "bc", "uv", "g", "pm", "nb", "kb", "gin", "bis", "GB", "gp", "cv", "hw", "gh", "xy", "phy", "gt", "eb", "ga", "ci", "lc", "ge", "dm", "rb", "Gb", "b", "cb", "vc", "bps"], "status": ["msg", "used", "index", "header", "result", "name", "text", "str", "sync", "api", "type", "num", "order", "id", "s", "temp", "sr", "step", "count", "unit", "output", "ui", "data", "ex", "plugins", "val", "ity", "git", "current", "sp", "stage", "magic", "ix", "weight", "size", "score", "code", "job", "uses", "url", "xml", "Status", "gc", "style", "full", "login", "speed", "use", "stats", "content", "css", "enabled", "pass", "check", "comment", "sql", "ssl", "security", "prefix", "level", "state", "active", "wait", "si", "spec", "date", "complete", "x", "options", "progress", "error", "success", " Status", "details", "sc", "seq", "service", "days", "skip", "class", "summary", "source", "min", "settings", "err", "info", "js", "update", "stat"]}}
{"project": "FFmpeg", "commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "target": 1, "func": "static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        MXFTrack *track = s->streams[i]->priv_data;\n\n        /* SMPTE 379M 7.3 */\n\n        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n\n            return i;\n\n    }\n\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n\n    return s->nb_streams == 1 ? 0 : -1;\n\n}\n", "idx": 7150, "substitutes": {"s": ["sq", "e", "d", "si", "lines", "sb", "ows", "events", "self", "p", "ks", "src", "ls", "args", "S", "ps", "sc", "ings", "ses", "support", "cs", "gs", "service", "u", "ds", "sf", "ions", "n", "l", "rows", "ops", "ss", "c", "m", "ts", "services", "t", "ctx", "rs", "fs", "g", "f", "ns", "a", "acks", "ssl", "als", "sl", "o", "its", "less", "js", "b", "su", "es", "http", "os", "qs", "south", "spec"], "klv": ["kslf", "okwl", "klf", "Kvl", "Klv", "Klf", "Kwl", "sknv", "kslv", "cklv", "kwl", "oklv", "skLV", "gLV", "ckLV", "gnv", "ckvl", "gvl", "okvl", "kLV", "skvl", "glv", "sklv", "ksvl", "kswl", "knv", "cknv", "oklf", "kvl"], "i": ["ui", "bi", "pi", "index", "k", "ie", "j", "one", "di", "field", "e", "d", "gu", "mini", "key", "multi", "fi", "ti", "p", "slice", "h", "mi", "phi", "qi", "ii", "r", "u", "id", "n", "l", "ni", "ip", "ami", "abi", "m", "c", "t", "ix", "oi", "f", "sup", "ed", "zi", "io", "start", "ri", "a", "ini", "info", "o", "gi", "mu", "xi", "uri", "x", "it", "eni", "ci", "z", "in", "b", "iu", "I", "ai", "v", "si", "li"], "track": ["data", "form", "index", "rack", "trace", "report", "event", "call", "sync", "type", "app", "rank", "record", "test", "ack", "tt", "Track", "ck", "m", "t", "step", "rec", "tr", "acc", "draw", "sort", "roll", "check", "pp", "tm", "group", "info", "project", "match", "dr", "node", "jump", "post", "round", "cmp", "stream", "row", "transform", "tracks", "token"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_mc_1mv(VC1Context *v, int dir)\n\n{\n\n    MpegEncContext *s = &v->s;\n\n    H264ChromaContext *h264chroma = &v->h264chroma;\n\n    uint8_t *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int v_edge_pos = s->v_edge_pos >> v->field_mode;\n\n    int i;\n\n    uint8_t (*luty)[256], (*lutuv)[256];\n\n    int use_ic;\n\n\n\n    if ((!v->field_mode ||\n\n         (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) &&\n\n        !v->s.last_picture.f.data[0])\n\n        return;\n\n\n\n    mx = s->mv[dir][0][0];\n\n    my = s->mv[dir][0][1];\n\n\n\n    // store motion vectors for further use in B frames\n\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n\n        for (i = 0; i < 4; i++) {\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx;\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my;\n\n        }\n\n    }\n\n\n\n    uvmx = (mx + ((mx & 3) == 3)) >> 1;\n\n    uvmy = (my + ((my & 3) == 3)) >> 1;\n\n    v->luma_mv[s->mb_x][0] = uvmx;\n\n    v->luma_mv[s->mb_x][1] = uvmy;\n\n\n\n    if (v->field_mode &&\n\n        v->cur_field_type != v->ref_field_type[dir]) {\n\n        my   = my   - 2 + 4 * v->cur_field_type;\n\n        uvmy = uvmy - 2 + 4 * v->cur_field_type;\n\n    }\n\n\n\n    // fastuvmc shall be ignored for interlaced frame picture\n\n    if (v->fastuvmc && (v->fcm != ILACE_FRAME)) {\n\n        uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1));\n\n        uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1));\n\n    }\n\n    if (!dir) {\n\n        if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) {\n\n            srcY = s->current_picture.f.data[0];\n\n            srcU = s->current_picture.f.data[1];\n\n            srcV = s->current_picture.f.data[2];\n\n            luty  = v->curr_luty;\n\n            lutuv = v->curr_lutuv;\n\n            use_ic = v->curr_use_ic;\n\n        } else {\n\n            srcY = s->last_picture.f.data[0];\n\n            srcU = s->last_picture.f.data[1];\n\n            srcV = s->last_picture.f.data[2];\n\n            luty  = v->last_luty;\n\n            lutuv = v->last_lutuv;\n\n            use_ic = v->last_use_ic;\n\n        }\n\n    } else {\n\n        srcY = s->next_picture.f.data[0];\n\n        srcU = s->next_picture.f.data[1];\n\n        srcV = s->next_picture.f.data[2];\n\n        luty  = v->next_luty;\n\n        lutuv = v->next_lutuv;\n\n        use_ic = v->next_use_ic;\n\n    }\n\n\n\n    if (!srcY || !srcU) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Referenced frame missing.\\n\");\n\n        return;\n\n    }\n\n\n\n    src_x   = s->mb_x * 16 + (mx   >> 2);\n\n    src_y   = s->mb_y * 16 + (my   >> 2);\n\n    uvsrc_x = s->mb_x *  8 + (uvmx >> 2);\n\n    uvsrc_y = s->mb_y *  8 + (uvmy >> 2);\n\n\n\n    if (v->profile != PROFILE_ADVANCED) {\n\n        src_x   = av_clip(  src_x, -16, s->mb_width  * 16);\n\n        src_y   = av_clip(  src_y, -16, s->mb_height * 16);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->mb_width  *  8);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->mb_height *  8);\n\n    } else {\n\n        src_x   = av_clip(  src_x, -17, s->avctx->coded_width);\n\n        src_y   = av_clip(  src_y, -18, s->avctx->coded_height + 1);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->avctx->coded_width  >> 1);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->avctx->coded_height >> 1);\n\n    }\n\n\n\n    srcY += src_y   * s->linesize   + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n\n\n    if (v->field_mode && v->ref_field_type[dir]) {\n\n        srcY += s->current_picture_ptr->f.linesize[0];\n\n        srcU += s->current_picture_ptr->f.linesize[1];\n\n        srcV += s->current_picture_ptr->f.linesize[2];\n\n    }\n\n\n\n    /* for grayscale we should not try to read from unknown area */\n\n    if (s->flags & CODEC_FLAG_GRAY) {\n\n        srcU = s->edge_emu_buffer + 18 * s->linesize;\n\n        srcV = s->edge_emu_buffer + 18 * s->linesize;\n\n    }\n\n\n\n    if (v->rangeredfrm || use_ic\n\n        || s->h_edge_pos < 22 || v_edge_pos < 22\n\n        || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3\n\n        || (unsigned)(src_y - 1)        > v_edge_pos    - (my&3) - 16 - 3) {\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize;\n\n\n\n        srcY -= s->mspel * (1 + s->linesize);\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY,\n\n                                 s->linesize, s->linesize,\n\n                                 17 + s->mspel * 2, 17 + s->mspel * 2,\n\n                                 src_x - s->mspel, src_y - s->mspel,\n\n                                 s->h_edge_pos, v_edge_pos);\n\n        srcY = s->edge_emu_buffer;\n\n        s->vdsp.emulated_edge_mc(uvbuf, srcU,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        s->vdsp.emulated_edge_mc(uvbuf + 16, srcV,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n        /* if we deal with range reduction we need to scale source blocks */\n\n        if (v->rangeredfrm) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = ((src[i] - 128) >> 1) + 128;\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = ((src[i]  - 128) >> 1) + 128;\n\n                    src2[i] = ((src2[i] - 128) >> 1) + 128;\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        /* if we deal with intensity compensation we need to scale source blocks */\n\n        if (use_ic) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ;\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = luty[f][src[i]];\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1);\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = lutuv[f][src[i]];\n\n                    src2[i] = lutuv[f][src2[i]];\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        srcY += s->mspel * (1 + s->linesize);\n\n    }\n\n\n\n    if (s->mspel) {\n\n        dxy = ((my & 3) << 2) | (mx & 3);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0]    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd);\n\n        srcY += s->linesize * 8;\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd);\n\n    } else { // hpel mc - always used for luma\n\n        dxy = (my & 2) | ((mx & 2) >> 1);\n\n        if (!v->rnd)\n\n            s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n        else\n\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n    }\n\n\n\n    if (s->flags & CODEC_FLAG_GRAY) return;\n\n    /* Chroma MC always uses qpel bilinear */\n\n    uvmx = (uvmx & 3) << 1;\n\n    uvmy = (uvmy & 3) << 1;\n\n    if (!v->rnd) {\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    } else {\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    }\n\n}\n", "idx": 7168, "substitutes": {"v": ["av", "volt", "tv", "vim", "vm", "conv", "k", "vd", "vp", "lv", "vu", "vg", "e", "vic", "vert", "ve", "vi", "nv", "p", "h", "vs", "vin", "ii", "ev", "u", "service", "inv", "n", "l", "video", "m", "c", "t", "version", "uv", "V", "f", "g", "vol", "rev", "vt", "cv", "en", "iv", "o", "ver", "w", "dev", "va", "sv", "ov", "b", "vc", "vv", "x"], "dir": ["Dir", "ext", "dn", "url", "dist", "def", "di", "db", "diff", "loc", "d", "circ", "coll", "draft", "dep", "order", "img", "ii", "module", "config", "dest", "orient", "DIR", "ind", "id", "file", "iver", "lib", "dim", "block", "device", "direct", "c", "m", "dy", "dc", "rec", "cur", "f", "path", "source", "sort", "or", "ir", "req", "group", "manager", "uri", "dr", "md", "desc", "attr", "lock", "grad", "direction", "doc", "rel", "wd", "directory", "spec"], "s": ["conv", "d", "sync", "vs", "site", "services", "fs", "f", "sv", "sound", "b", "in", "conf", "serv", "sq", "submit", "sb", "ses", "cs", "r", "u", "sf", "ss", "ts", "t", "ns", "network", "a", "w", "es", "http", "storage", "share", "sys", "self", "p", "ks", "ls", "session", "S", "ps", "gs", "n", "c", "g", "sup", "us", "ssl", "sl", "series", "su", "qs", "rs", "si", "spec", "scope", "e", "ve", "server", "is", "sc", "service", "ds", "l", "sym", "m", "sh", "summary", "sim", "settings", "se", "o", "secondary", "js", "com", "os"], "h264chroma": ["h164chromi", "h264capa", "hwmcomb", "h264gena", "h264comb", "hwmcomama", "h164pixelca", "h264pixelca", "h264chromba", "h164chroman", "h264comba", "h164pixelan", "h264capb", "hwmchromba", "h264capama", "hwmchromama", "h264coma", "h264pixeli", "h264chromb", "h264genan", "h264genca", "h164pixeli", "h164pixela", "h264chromca", "h264pixela", "hwmchromb", "h264cssa", "h264chromama", "h264geni", "hwmcomba", "h164chromca", "h264chroman", "hwmcoma", "hwmchroma", "h264comama", "h264capba", "h264pixelan", "h264cssan", "h264cssi", "h164chroma", "h264cssca", "h264chromi"], "srcY": ["srcXY", "destXY", "destY", "rcY", "rcN", "srcN", "sourceXY", "sourceN", "destN", "destX", "rcXY", "sourceX", "rcX", "srcX", "sourceY"], "srcU": ["secureV", "sourceU", " srcM", "secureF", "srcF", "sourceM", "secureU", " srcF", "sourceV", "secureM", "sourceF", "srcM"], "srcV": ["locI", "srcW", "locV", "rcV", "srcI", "rcN", "srcN", " srcN", " srcI", " srcW", "locW", "rcW", "locN", "rcI"], "dxy": ["nxy", "pgb", "dwy", "pxy", "ngb", "pwy", " dwy", "dpy", " dpy", "ppy", "dgb", " dgb", "npy", "nwy"], "mx": ["py", "mos", "mie", "mine", "y", "vm", "np", "MX", "xml", "mm", "wm", "mb", "wx", "rx", "bm", "mp", "nz", "mi", "module", "cm", "yx", "ml", "sem", "dj", "fm", "mn", "tx", "mus", "m", "mr", "pm", "px", "ym", "ms", "micro", "mc", "mag", "mac", "xy", "ma", "mu", "km", "yahoo", "memory", "mic", "me", "mis", "md", "mean", "dm", "x"], "my": ["py", "ui", "mie", "mos", "mine", "y", "zy", "amy", "MY", "google", "money", "am", "sam", "ady", "mm", "ny", "mini", "mia", "custom", "med", "mem", "ey", "wx", "rx", "ody", "mi", "module", "hi", "mys", "make", "meta", "id", "mn", "gray", "cy", "My", "ami", "vy", "gy", "axy", "m", "mand", "any", "sym", "dy", "pm", "ix", "ms", "mag", "ma", "ky", "qq", "memory", "Mi", "yahoo", "mic", "ph", "me", "mis", "md", "phy", "ya", "why", "mmm", "x"], "uvmx": ["uvmh", "suvmz", "ufmpx", "uvmxx", "suvmx", "suvmw", "cucvxes", " ufmy", "uvimh", "cuvmx", "uuvw", "uvmz", "ucvx", "uvpxp", "uuvz", "sufmpx", "uvimxes", "cuvmh", "uVMxp", "ufmx", "uvmxes", "uuvx", "ufmw", " ufmwx", "cuvmxx", " ufmxp", "ufmxp", "ucvxx", "uvgxx", "uVMy", "uvimxx", "suvmpx", "uvimx", "sufmx", "uvgh", "cucvxx", "uvgx", "uvpz", "ufmwx", " uvmxp", "cucvh", " uvmwx", "uvmxp", "uvmw", "uvppx", "ufmz", "uvmwx", "uvpwx", "cucvx", "ufmy", "cuvmxes", "uvpx", "uvpw", "uuvpx", "uVMwx", "uVMx", "uvpy", "sufmw", "ucvxes", "uvmpx", " ufmx", "uvgxes", "ucvh", "sufmz"], "uvmy": ["vpmid", "imgmy", "vmmi", "csvmy", "cvmy", "vvmain", "uumn", "vmmain", "vpcy", "envmx", "csvny", "vvmm", "nvmy", "uumy", "uzmy", "lvmi", "vvmn", "uvmm", "uumi", "vvmy", "csvmon", "vmmy", "envmy", "envmi", "imgml", "vpmy", "imgny", "uuml", "uvml", "nvml", "lvmm", "uvmn", "uvmon", "uvmis", "imgmn", "vvmon", "uvmi", "imgmid", "lvmx", "lvmis", "lvml", "uzmx", "csvmn", "imgcy", "uvmain", "vpml", "uvcy", "nvmm", "uvmid", "cvmid", "vvmi", "lvmy", "uzmis", "nvmn", "uumm", "envmis", "cvml", "vvny", "uzmi", "imgmon", "uvny", "cvcy", "uumain", "vmmm", "lvmn"], "src_x": ["src_w", "src_X", " src_w", " src_X"], "src_y": [" src_Y", "src_Y"], "uvsrc_x": ["uvdest_y", "uvsrc_xy", "uvdest_x", "uvdest_id", "uvdest_xy", "uvsrc_id"], "uvsrc_y": ["uvsrc_py", "uvsrc_i", "uvsrc2y", "uvsrc2x", "uvsrc2py", "uvsrc2i"], "i": ["bi", "ui", "y", "pi", "index", "ie", "di", "e", "d", "mini", "key", "multi", "fi", "ti", "p", "yi", "mi", "phi", "qi", "ii", "hi", "u", "ji", "id", "n", "ni", "chi", "ip", "l", "ami", "abi", "m", "c", "ix", "oi", "f", "zi", "io", "ri", "ini", "info", "o", "it", "gi", "xi", "x", "uri", "ci", "eni", "z", "b", "iu", "I", "ai", "si", "li"], "luty": ["Lumen", "nlumen", "lut", "Lut", "luo", "sluo", "lumen", "Luo", "nluti", "sluti", "slumen", "nluo", "luti", "nlut", "Luti", "slut"], "lutuv": ["lutov", "lUTuv", "luvui", "luvuv", "luvov", "luvv", " lUTv", "lUTov", "lutv", "lUTui", "lutev", "luteui", "luteov", " lUTui", "lUTv", " lutv", " lUTuv", " lUTov", "lutui", "luteuv", " lutui", " lutov"], "use_ic": [" use_c", " use_ac", "usebic", "use_ac", "use_c", "use_i", " use_i", "usebi", "usebc", "usebac"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"movq (%2, %%\"REG_a\",4), %%mm2\t\\n\\t\"\n\n\t\t\"movq 8(%2, %%\"REG_a\",4), %%mm3\t\\n\\t\"\n\n\t\tPAVGB(%%mm2, %%mm0)\n\n\t\tPAVGB(%%mm3, %%mm1)\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%4, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;\n\n\t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;\n\n\t}\n\n#endif\n\n}\n", "idx": 7174, "substitutes": {"dstU": ["DSTU", " dstI", "DstF", "dstUR", "DestF", "DstA", "drcV", "drcI", "drcUV", "drcL", "dSTUR", "dstL", "drcUR", "dstdA", "dstI", " dstUR", "DstI", "dblUV", "dstF", "ddestI", "destU", "dstA", " dblUR", "dblV", "dSTI", "DestA", "DstL", "DestI", "ddestA", "dSTUV", "destA", " dblU", "dSTV", " dblI", "destF", "DSTUV", "dstdF", "dstdI", "dstdU", "dSTU", "DestU", "DSTL", "DstU", "ddestF", "ddestU", "destI", "drcU", "DSTI", "DstUV", "dblUR", "dblU", " dblV", "dstUV", "dSTL", "dblI", "dblL"], "dstV": [" dstI", "dsrcv", " dstv", "DSTN", "DstVB", "DSTU", "DSTVD", "dsrcV", "dsrcR", "dSTVB", "dSTR", "dconstN", "dspU", " dSTI", "destN", "dstI", "DstI", "dstrV", "dstav", "dconstVB", "DSTB", "dspV", "dspVD", "dSTN", "dSTI", "dSTVD", "dstVD", " dSTV", "dSTv", "DstB", "dSTV", "dconstV", "DstV", "dconstI", " dSTR", "dsrcI", "dSTU", "destV", "DstN", "dstN", "dstaI", "dstaR", " dstR", "dspB", "DSTVB", "destI", "dstR", "dstaV", "dstB", "DstVD", "DSTI", "DSTV", " dSTv", "dstVB", "dstrB", "dstrVD", "dstv", "dstrU", "dSTB", "DstU", "destVB"], "src1": ["sourceOne", "dest1", "source3", " src3", " src01", "rc3", "src3", "locOne", "source1", "inst01", "loc2", "rc0", "loc0", "source2", "loc1", "dest2", "src01", "loc3", "destOne", "inst2", "inst1", "src0", "instOne", " src0", "dest01", "rc1", "rc2", " srcOne", "srcOne", "rcOne"], "src2": ["url4", "rc02", "url2", "src4", "source0", " src3", "reflect2015", "loc4", "src2015", "rc3", " srcTwo", "src3", "url1", "sourceTwo", "loc2", "urlTwo", "loc2015", "rc0", "srcTwo", "source2", "reflect4", " src02", "loc1", " src4", "loc3", "rc2015", "locTwo", "src02", "src0", "reflect1", "rc4", " src0", "source02", "rc1", "rc2", "reflect2", "rcTwo"], "i": ["ui", "bi", "y", "pi", "index", "area", "j", "di", "e", "d", "mini", "key", "multi", "fi", "li", "vi", "p", "ti", "uli", "slice", "yi", "phi", "qi", "ii", "adi", "hi", "u", "ali", "inner", "ji", "ind", "id", "n", "ni", "chi", "ip", "line", "l", "abi", "var", "c", "init", "ix", "oi", "zi", "io", "ri", "ini", "info", "o", "gi", "mu", "xi", "x", "uri", "my", "it", "eni", "ci", "me", "lc", "z", "length", "b", "iu", "in", "ani", "I", "ai", "si"]}}
{"project": "FFmpeg", "commit_id": "ba15aab4a4a296c632bd8d3428b002055109c7d1", "target": 0, "func": "static int mtv_read_header(AVFormatContext *s)\n\n{\n\n    MTVDemuxContext *mtv = s->priv_data;\n\n    AVIOContext   *pb  = s->pb;\n\n    AVStream        *st;\n\n    unsigned int    audio_subsegments;\n\n\n\n    avio_skip(pb, 3);\n\n    mtv->file_size         = avio_rl32(pb);\n\n    mtv->segments          = avio_rl32(pb);\n\n    avio_skip(pb, 32);\n\n    mtv->audio_identifier  = avio_rl24(pb);\n\n    mtv->audio_br          = avio_rl16(pb);\n\n    mtv->img_colorfmt      = avio_rl24(pb);\n\n    mtv->img_bpp           = avio_r8(pb);\n\n    mtv->img_width         = avio_rl16(pb);\n\n    mtv->img_height        = avio_rl16(pb);\n\n    mtv->img_segment_size  = avio_rl16(pb);\n\n\n\n    /* Calculate width and height if missing from header */\n\n\n\n    if(mtv->img_bpp>>3){\n\n    if(!mtv->img_width && mtv->img_height)\n\n        mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_height;\n\n\n\n    if(!mtv->img_height && mtv->img_width)\n\n        mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_width;\n\n    }\n\n    if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){\n\n        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    audio_subsegments = avio_rl16(pb);\n\n\n\n    if (audio_subsegments == 0) {\n\n        avpriv_request_sample(s, \"MTV files without audio\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    mtv->full_segment_size =\n\n        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +\n\n        mtv->img_segment_size;\n\n    mtv->video_fps         = (mtv->audio_br / 4) / audio_subsegments;\n\n\n\n    // FIXME Add sanity check here\n\n\n\n    // all systems go! init decoders\n\n\n\n    // video - raw rgb565\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id        = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->pix_fmt         = AV_PIX_FMT_RGB565BE;\n\n    st->codec->width           = mtv->img_width;\n\n    st->codec->height          = mtv->img_height;\n\n    st->codec->sample_rate     = mtv->video_fps;\n\n    st->codec->extradata       = av_strdup(\"BottomUp\");\n\n    st->codec->extradata_size  = 9;\n\n\n\n    // audio - mp3\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n\n    st->codec->codec_id        = AV_CODEC_ID_MP3;\n\n    st->codec->bit_rate        = mtv->audio_br;\n\n    st->need_parsing           = AVSTREAM_PARSE_FULL;\n\n\n\n    // Jump over header\n\n\n\n    if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 7177, "substitutes": {"s": ["an", "sci", "storage", "sq", "e", "submit", "sb", "tp", "sys", "server", "p", "sync", "spec", "details", "sports", "ls", "session", "S", "client", "sc", "ses", "support", "cs", "gs", "r", "service", "sf", "ds", "sets", "stats", "txt", "ss", "c", "sg", "ts", "services", "t", "sym", "m", "fs", "g", "ns", "f", "self", "sa", "sim", "bis", "us", "ssl", "i", "sl", "o", "sis", "series", "sv", "su", "b", "es", "setup", "single", "os", "conf", "parser", "south", "si"], "mtv": ["umtd", " mtt", "tmuv", "imott", "immtv", "tmtd", "mesh", " mtd", "nott", "amtd", "imcf", "rott", "nov", "rov", "pmtv", "paramtk", "rtv", "mtg", "nmnt", "dimctr", "raxy", "pmtt", "omov", "gmtd", "amtw", "mood", "omott", "nmfont", "nmvent", "ymaxy", "fmtt", "mopt", "imtw", "daxy", "tmesh", "omnt", "umvalid", "umtt", "dood", "ltd", "paramtw", "gmqt", "mtxt", "lctr", " mcf", "anood", "umtv", "lov", "emtt", "mtt", "immqt", "ntd", " mvent", "gmTV", "mdtxt", "mtz", "mtk", "tmaxy", " mctr", "mfont", "emTV", "hmtxt", "tmtv", "mov", "gtv", " mtxt", "omhtml", "fmtv", "ntw", "emtv", "vnt", "hmtv", " maxy", "dtv", "lopt", "cmvent", "tmtch", "cmvalid", "imtr", "umov", "hmqt", "tmqt", "gmtr", "dimtd", "paramtv", "amtv", "omtt", "ltv", "ymtd", "mserv", "nmtv", "mdtd", "cmhtml", " mfont", "mmtg", "mmtd", "mdtv", "emtz", "imtv", " mtu", "rvalid", " mtk", "mwt", "tmtt", "nmwt", "smtt", "dimov", "bserv", "btv", " mconfig", "amconfig", "cmesh", "imaxy", " mtch", "paramcf", "nmserv", "tmtr", "mhtml", "omserv", "amtt", "hmtu", "dimtv", "emesh", "Mserv", "gmtg", "mconfig", "nmtch", " mserv", "mnt", "vserv", "gaxy", "duv", "anaxy", "emott", "omtu", "gmtv", "antv", "rctr", "omtv", "anuv", " mtw", "Mov", "umvent", " mott", "imvent", "cmcf", "imtt", "omuv", "rtd", "mctr", "fmvent", "vqt", "omtd", "dimtw", "ltg", "mdopt", "smtd", "immtu", " mtg", "btd", "mvalid", "ymtv", "emtd", "cmfont", "amctr", "dimtg", "amcf", " mTV", "cmov", "amserv", "mmconfig", "mott", "emctr", "mtd", " mopt", "mcf", " mov", "gmconfig", "nmtt", "mqt", "mtch", "tmood", "cmuv", "cmtv", "ntv", "ltxt", "omqt", "tmnt", "Mtv", "ymtu", "amov", "tmvent", "nmtd", "gtd", "mTV", " mqt", "pmtd", "amott", "imtd", "bwt", "tmtu", "imqt", "gtu", "tmhtml", " mwt", " mnt", "Mott", "fmtd", "mvent", "vtv", "ntt", "rtt", "maxy", "ntk", "gmtz", " mtz", "gmtt", "nmcf", "smvent", "mmtv", "pmov", "ymott", "smtv", "mtu", "ltw", "cmtd", "mtw", "cmtt", "lconfig", "ncf", "immtxt", "mtr", "muv"], "pb": ["ub", "wb", "pc", "lb", "gb", "vp", "cp", "db", "ab", "ppa", "bf", "lv", "pg", "sb", "pl", "hub", "tp", "p", "bm", "api", "pid", "rob", "pa", "sf", "dp", "plugin", "fb", "jp", "txt", "cpp", "pm", "bc", "summary", "pt", "ib", "platform", "eb", "cv", "pkg", "dl", "pit", "wp", "fc", "PB", "lp", "bh", "uf", "lc", "bp", "rb", "xb", "b", "cb", "rpm", "bs", "bps", "pd", "fp", "prot", "asm"], "st": ["ste", "sth", "rss", "ast", "fe", "std", "bl", "ost", "sc", "sf", "sp", "est", "sts", "St", "ss", "rest", "ts", "cr", "sa", "inst", "se", "sta", "sl", "ft", "sw", "ist", "ST", "stim"], "audio_subsegments": ["audio_partsegments", "audio_subgegment", "audio_subgegments", "audio_sublegments", "audio_subpersegments", "audio_subpegment", "audio_subpersegements", "audio_subtegements", "audio_subpersements", "audio_partseges", "audio_partbegments", "audio_subbectors", "audio_sublectors", "audio_partbegment", "audio_sublements", "audio_subpements", "audio_partsegements", "audio_subbegements", "audio_subsegements", "audio_subsectors", "audio_subtements", "audio_subbements", "audio_partsements", "audio_subpegments", "audio_subbeges", "audio_subpegements", "audio_partbements", "audio_subtegments", "audio_partbegements", "audio_subseges", "audio_subsegment", "audio_partbectors", "audio_subsements", "audio_subpectors", "audio_subgements", "audio_subgegements", "audio_subbegment", "audio_subpeges", "audio_sublegements", "audio_subpersegment", "audio_subbegments", "audio_partbeges", "audio_partsectors", "audio_partsegment", "audio_subteges"]}}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191, "substitutes": {"ht": ["mat", "att", "bf", "bm", "rh", "h", "ct", "hold", "ch", "hm", "cmd", "dict", "hp", "hh", "sh", "host", "hw", "gh", "cache", "bh", "H", "hip", "ac", "http", "hs", "bt", "ha", "hard"], "map": ["data", "link", "scope", "header", "Map", "ref", "sche", "pre", "pl", "co", "open", "self", "op", "rule", "mp", "bl", "app", "bridge", "module", "use", "config", "change", "meta", "ap", "file", "block", "m", "address", "holder", "apper", "cl", "MAP", "master", "parent", "cache", "table", "code", "cap", "node", "lock", "work", "maps"], "head": ["root", "link", "index", "header", "before", "da", "set", "end", "name", "d", "back", "view", "self", "op", "foot", "src", "hook", "h", "client", "conn", "tail", "Head", "ack", "config", "off", "dict", "id", "heads", "block", "load", "ck", "c", "run", "host", "next", "path", "holder", "check", "start", "commit", "master", "parent", "cache", "HEAD", "ad", "front", "fix", "post", "body", "first"], "p": ["pool", "pb", "pos", "pc", "before", "pin", "j", "pre", "e", "d", "pg", "tp", "pair", "h", "pad", "r", "patch", "pa", "sp", "P", "ap", "jp", "ip", "n", "m", "c", "t", "f", "pointer", "point", "pp", "ping", "padding", "o", "w", "bp", "q", "fp", "cp", "v", "port"], "hash": ["ash", "pool", "kh", "index", "header", "ump", "ref", "depth", "number", "bf", "key", "Hash", "rh", "h", "num", "image", "change", "sha", "ap", "id", "ip", "block", " h", "version", "height", "address", "pointer", "shift", "oh", "array", "prop", "pkg", "cache", "prefix", "al", "memory", "node", "cmp", "count", "ashes", "final", "ashing", "base"], "needs_resize": ["needs_resiz", "needs_hesizing", "needs_hesizer", "needs_reizing", "needs_hesize", "needs_hardiz", "needs_hardize", "needs_resetizing", "needs_hardcale", "needs_resizer", "needs_resetample", "needs_reiz", "needs_realample", "needs_realize", "needs_hesiz", "needs_normalize", "needs_realizer", "needs_resample", "needs_realcale", "needs_normalcale", "needs_rescale", "needs_normalizer", "needs_realizing", "needs_realiz", "needs_resizing", "needs_normaliz", "needs_reample", "needs_resetiz", "needs_reize", "needs_hescale", "needs_hardizing", "needs_resetize"], "b": ["bi", "pb", "abb", "br", "wb", "lb", "k", "y", "gb", "B", "ab", "db", "bf", "d", "e", "sb", "bar", "mb", "bl", "app", "h", "old", "r", "bb", "this", "lib", "orb", "fb", "n", "l", "obj", "block", "ob", "buff", "s", "m", "c", "ba", "bc", "boot", "g", "f", "nb", "next", "ib", "be", "a", "bin", "emb", "w", "o", "bu", "bd", "bh", "bp", "rb", "cb", "http", "bs", "bt", "body", "v", "base"], "prev": ["batch", "root", "pb", "reverse", "vious", "re", "before", "header", "ref", "pre", "loc", "back", "self", "op", "mp", "orig", "h", "buf", "record", "old", "r", "bb", "current", "block", "var", "cur", "rec", "next", "rev", "book", "bin", "parent", "iv", "original", "Prev", "bp", "rb", "pres", "post", "cb", "cmp", "nav", "rel", "v", "existing", "first"], "new": ["root", "re", "before", "end", "j", "diff", "name", "d", "now", "raw", "self", "base", "h", "un", "known", "old", "big", "bug", "r", "make", "New", "create", "n", "block", "c", "m", "add", "g", "next", "f", "other", "a", "fresh", "NEW", "w", "o", "valid", "gen", "node", "ew", "missing", "normal", "row", "v", "update", "first"], "i": ["bi", "ui", "y", "index", "pi", "k", "ie", "j", "di", "e", "d", "si", "multi", "fi", "ti", "base", "api", "slice", "qi", "ii", "hi", "u", "ji", "ind", "id", "n", "l", "ni", "ip", "ami", "s", "m", "c", "t", "ix", "oi", "f", "zi", "io", "start", "a", "ri", "ini", "o", "gi", "mu", "xi", "uri", "it", "ci", "eni", "z", "in", "iu", "I", "ai", "v", "x", "li"]}}
{"project": "FFmpeg", "commit_id": "6e1b1a27a4034c578018d5042b3c8228278c4cd6", "target": 1, "func": "static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)\n\n{\n\n    pkt->data      = NULL;\n\n    pkt->side_data = NULL;\n\n    if (pkt->buf) {\n\n        AVBufferRef *ref = av_buffer_ref(src->buf);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n        pkt->buf  = ref;\n\n        pkt->data = ref->data;\n\n    } else {\n\n        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);\n\n    }\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    pkt->destruct = dummy_destruct_packet;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (pkt->side_data_elems && dup)\n\n        pkt->side_data = src->side_data;\n\n    if (pkt->side_data_elems && !dup) {\n\n        return av_copy_packet_side_data(pkt, src);\n\n    }\n\n    return 0;\n\n\n\nfailed_alloc:\n\n    av_destruct_packet(pkt);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 7204, "substitutes": {"pkt": ["pke", "pet", "belt", "bnt", "fnt", "packkt", "pelt", "facket", "pent", "pait", "spait", "fck", "cpnt", "apkt", "PKT", "ppelt", "feter", "pkg", "Pet", " pke", "spacket", "dkt", "packacket", "ppait", "ppkt", "pect", " pct", "tkt", "peter", "apet", " pett", " pwk", "pk", "Pct", "Pett", "cpkt", "ppkg", "pck", " pKT", " pnt", "spelt", "sppt", "perkg", "fke", "Pkg", "Pkt", "spkt", "Packet", "Ppt", " pk", "spke", "packck", "ppacket", "pnt", "backet", "fkg", "cpet", "tpt", "peracket", "peret", "peth", "bkt", " pkg", "dct", "upacket", "Pait", "peacket", " packet", "perk", "apacket", " peth", "pct", "deth", "apnt", "dKT", "fet", "Pnt", "Peth", " pck", "tacket", " pait", "upkt", "Pwk", "ppnt", "spwk", " pet", "pwk", "ppt", " peter", "Pelt", "cpacket", "pett", "packet", "spck", "perett", "perkt", "upet", "fkt", "pekt", "telt", "upett", "pKT", "Pk", "packeter"], "src": ["data", "sci", "split", "func", "uc", "rc", "ruby", "sth", "gb", "proc", "target", "url", "loc", "sb", "RC", "super", "sys", "sync", "slice", "buf", "socket", "sc", "support", "img", "ack", "dest", "config", "plugin", "sr", "grab", "ctx", "tmp", "st", "bc", "sup", "source", "inst", "sit", "sn", "req", "pkg", "ssl", "secure", "fc", "iv", "prot", "bh", "sub", "rb", "rin", "setup", "ptr", "fp", "SOURCE", "sel", "rs", "spec", "rob"], "dup": ["dyp", "duv", "delp", "droc", "didc", "duping", "drops", "dalp", "dulp", "dupe", "duper", "udpe", "drop", "dep", "dups", "daps", "purpe", "aup", "dylp", "daper", "dyper", "auv", "purping", " dupe", "purv", "didp", "udp", "deps", "dap", "didps", "drope", "dyps", "udc", "aupe", "didpe", "duc", " duping", "deper", "auping", "udps", " duv", "purp"], "ref": ["re", "rc", "object", "index", "def", "REF", "Ref", "diff", "db", "loc", " reference", "bf", "alt", "ab", "val", "af", "self", "fe", "p", "rf", "mem", "flow", "buf", "full", "offset", "r", "bb", "aff", "lib", "ind", "id", "per", "ef", "block", "obj", "ob", "buff", "c", "rec", "buffer", "f", "rev", "req", "part", "cache", "reference", "info", "lf", "uf", "b", "fact", "col", "null", "cb", "cmp", "comp", "conf", "rel"]}}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n", "idx": 7213, "substitutes": {"obj": ["object", "j", "coll", "so", "op", "bj", "src", "api", "org", "conn", "img", "module", "config", "bot", "orb", "n", "jp", "obb", "ob", "class", "instance", "init", "tmp", "boot", "ctx", "act", "kt", "prop", "inst", "cat", "pkg", "Obj", "parent", "o", "emb", "nt", "bh", "objects", "js", "Object", "node", "b", "attr", "cb", "po", "os", "conf"], "vcrypto": ["vcprotto", "VCcrypta", "vcryptor", "vconta", "vcrypta", "vccryptio", "vcryptionor", "vcryptiono", "VCcrypto", "vcCrypta", "vcrito", "VCrypta", "vcritor", "vcproto", "VCcryptode", "VCryptos", "vcryptoa", "vcritos", "fcritos", "vccryptor", "vcryptionos", "vcritio", "vcryptode", "VCryptto", "vcCryptoa", "vcrimode", "VCryptoa", "vcrimto", "vccryptos", "fcritio", "fcritor", "vcrimos", "VCrypto", "vccryptoa", "fcryptio", "fcrito", "VCcryptos", "VCcryptoa", "vccrypto", "vcontoa", "vcrimo", "fcryptor", "fcryptos", "vcprotode", "vccryptode", "vccryptto", "fcrypto", "vconto", "vcryptionio", "vccrypta", "vcryptto", "vcontos", "VCryptode", "vcryptos", "vcCryptos", "vcprotos", "vcCrypto", "vcryptio", "VCcryptto"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,\n\n\t\t\t     int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong physical;\n\n    int prot, ret, access_type;\n\n\n\n    access_type = ACCESS_INT;\n\n    ret =\n\n\tget_physical_address(env, &physical, &prot, address, rw,\n\n\t\t\t     access_type);\n\n\n\n    if (ret != MMU_OK) {\n\n\tenv->tea = address;\n\n\tswitch (ret) {\n\n\tcase MMU_ITLB_MISS:\n\n\tcase MMU_DTLB_MISS_READ:\n\n\t    env->exception_index = 0x040;\n\n\t    break;\n\n\tcase MMU_DTLB_MULTIPLE:\n\n\tcase MMU_ITLB_MULTIPLE:\n\n\t    env->exception_index = 0x140;\n\n\t    break;\n\n\tcase MMU_ITLB_VIOLATION:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_MISS_WRITE:\n\n\t    env->exception_index = 0x060;\n\n\t    break;\n\n\tcase MMU_DTLB_INITIAL_WRITE:\n\n\t    env->exception_index = 0x080;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_READ:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_WRITE:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_IADDR_ERROR:\n\n\tcase MMU_DADDR_ERROR_READ:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_DADDR_ERROR_WRITE:\n\n\t    env->exception_index = 0x100;\n\n\t    break;\n\n\tdefault:\n\n\t    assert(0);\n\n\t}\n\n\treturn 1;\n\n    }\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    physical &= TARGET_PAGE_MASK;\n\n\n\n    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);\n\n}\n", "idx": 7222, "substitutes": {"env": ["output", "context", "extra", "nc", "ext", "eve", "eu", "np", "vm", "end", "db", "e", "enc", "exc", "exec", "equ", "export", "core", "ea", "dt", "server", "que", "event", "energy", "conn", "vs", "site", "ne", "ev", "config", "viron", "et", "ef", "enable", "txt", "net", "her", "enter", "eng", "engine", "eye", "ctx", "fen", "init", "chal", "console", "Environment", "osc", "ec", "en", "ette", "ah", "network", "err", "esm", "dev", "forge", "erv", "inet", "eni", "het", "edge", "qt", "esi", "conf", "enh", "environment"], "address": ["object", "index", "target", "number", "area", "end", "result", "e", "element", "message", "interface", "server", "event", "p", "type", "Address", "order", "ace", "image", "channel", "offset", "position", "test", "config", "remote", "service", "contact", "ip", "block", "response", "contract", "mode", "enter", "host", "buffer", "pointer", "path", "array", "location", "attribute", "network", "uration", "en", "master", "cache", "reference", "table", "size", "memory", "code", "inet", "eni", "state", "route", "shape", "addr", "resource", "port"], "rw": ["wb", "worker", "rack", "rss", "work", "raw", "rx", "wn", "rf", "src", "rh", "r", "fw", "password", "rr", "wl", "rn", "nw", "tw", "wa", "wp", "wr", "hw", "nr", "writer", "ww", "iw", "w", "RW", "working", "wh", "sw", "rb", "route", "rl", "fp", "ptr", "rou", "access"], "mmu_idx": ["mmu_midb", "mmu_idy", "mmu_aidz", "mmu_Idv", "mmu_aidb", "mmu_midf", "mmu_ideb", "mmu_idex", "mmu_Idx", "mmu_Idz", "mmu_idv", "mmu_idey", "mmu_Idb", "mmu_idz", "mmu_idef", "mmu_idf", "mmu_idb", "mmu_midx", "mmu_aidv", "mmu_aidx", "mmu_midy"], "is_softmmu": ["is_softMMus", "is_softMMU", "is_hardmmu", "is_softmlcu", "is_softMMcu", "is_softmlu", "is_softmluit", "is_softMMuit", "is_softmmU", "is_softmmcu", "is_hardmmru", "is_softmlru", "is_softmlU", "is_softmlus", "is_softmmus", "is_hardmmU", "is_softmmru", "is_softMMru", "is_hardmmuit", "is_softMMu", "is_softmmuit", "is_hardmmcu", "is_hardmmus"], "physical": ["output", "data", "index", "ref", "target", "number", "proc", "php", "text", "interface", "ocol", "server", "byte", "p", "native", "params", "intel", "config", "remote", "hard", "external", "vector", "password", "protected", "temp", "net", "boot", "cpu", "host", "pointer", "platform", "primary", "network", "serial", "reference", "secondary", "virtual", "prefix", "python", "database", "inet", "pixel", "route", "null", "single", "http", "Physical", "resource", "phys", "binary", "public", "integer", "port"], "prot": ["data", "pat", "pos", "ext", "protect", "reset", "ref", "target", "eth", "att", "len", "ocol", "server", "dt", "rf", "seq", "channel", "config", "aff", " proto", "pro", "dim", "rot", "protected", "temp", " protocols", "Prot", "pointer", "platform", "io", "prop", "primary", "reference", "secondary", "virtual", "prefix", "inet", "route", "col", " protocol", "addr", "format", "ptr", "fp", "phys", "dat"], "ret": ["data", "ash", "hash", "ext", "re", "reset", "rc", "ref", "pub", "fail", "mt", "result", "success", "input", "alt", "att", "fun", "db", "error", "len", "val", "fi", "rf", "bit", "conn", "RET", "resp", "ne", "reg", "response", "res", "net", "inter", "bc", "art", "array", "ben", "en", "flag", "part", "info", "det", "al", "ft", "match", "nt", "reply", "code", "job", "rt", "route", "rl", "format", "addr", "status", "ptr", "rets", "Ret"], "access_type": [" access_method", "access_value", "access_method", " access_value", "accessaltype", " access_types", "accessalkey", " access_level", "access_level", "accessingmethod", "access_types", "accessingtypes", "accessaltypes", " access_key", "accessingvalue", "accessalvalue", "access_key", "accessingtype"]}}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 7243, "substitutes": {"dev": ["data", "Dev", "def", "di", "de", "error", "development", "diff", "d", "gu", "rad", "debug", "p", "dom", "nov", "DEV", "app", "conn", "test", "ev", "prom", "ch", "device", "cmd", "pro", "block", "var", "mode", "sh", "dc", "mod", "req", "der", "info", "w", "ver", "err", "md", "dm", "state", "sk", "kind", "grad", "priv", "dem", "conf", "v", "driver", "spec"], "vdev": [" vDev", "vdiv", "Vdevelopment", "vw", " vdevice", "evw", "evdev", " vdevelopment", "VDev", "vdevice", "vmDev", "vmdev", "wdev", "vdevelopment", "wdiv", "evdevice", "Vprof", "Vdev", " vprof", " vw", "vprof", "ww", "evdiv", "vmdevelopment", " vdiv", "vmprof", "wdevice", "vDev"], "s": ["data", "new", "y", "storage", "sq", "e", "si", "d", "sb", "server", "self", "p", "sync", "sys", "args", "session", "S", "params", "ps", "is", "ses", "gs", "r", "cs", "service", "u", "ds", "changes", "n", "l", "ss", "m", "c", "sg", "services", "sh", "sym", "t", "fs", "g", "ns", "f", "sup", "a", "ssl", "settings", "w", "sl", "o", "js", "b", "su", "os", "v", "rs", "spec"]}}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n", "idx": 7267, "substitutes": {"obj": ["object", "oa", "j", "aj", "so", "self", "p", "api", "bj", "src", "org", "module", "img", "ev", "bot", "orb", "lib", "jp", "obb", "ob", "txt", "m", "ctx", "tmp", "boot", "nb", "oi", "act", "opt", "inst", "Obj", "xxx", "emb", "o", "nt", "code", "objects", "js", "Object", "attr", "po", "os"], "v": ["object", "vm", "k", "conv", "j", "vp", "vu", "lv", "e", "d", "val", "p", "api", "vs", "u", "n", "l", "env", "s", "class", "m", "c", "t", "uv", "V", "g", "f", "i", "w", "o", "iv", "z", "sv", "b", "vc", "q", "x"], "name": ["nam", "data", "object", "label", "key", "len", "type", "image", "n", "Name", "word", "m", "f", "path", "space", "min", "part", "info", "named", "names", "size", "prefix", "filename", "w", "o", "cap", "ame", "attr", "b", "NAME", "time", "alias", "x", "base"], "opaque": ["Opaque", "oponymous", "ipac", "opacity", "Oponymous", "ponymous", "pacity", "opac", "pac", "paque", "iponymous", "ipacity", "ipaque", "Opacity", "Opac"], "errp": ["iterfp", "errr", "erP", " errfp", "Erfp", "iterlp", "erp", "iterp", "errP", "rrr", "ErP", "erpre", "rrpre", " errP", "errpre", " errr", "errfp", "err", "errlp", " errpre", " errlp", "rrp", "Erp", "rrP", "Erlp", "iterP"], "value": ["data", "index", "member", "number", "scale", "total", "result", "message", "val", "function", "type", "flow", "values", "image", "r", "response", "Value", "VALUE", "version", "weight", "range", "array", "max", "min", "part", "json", "info", "media", "size", "score", "memory", "fee", "job", "valid", "length", "null", "feature", "unit", "format"], "mr": ["ru", "mt", "mm", "rm", "vr", "wm", "er", "rg", "rf", "mx", "bm", "rh", "hr", "pr", "shr", "r", "hm", "ml", "RR", "fm", "rr", "mn", "MR", "lr", "m", "sr", "pm", "Mr", "cr", "mor", "dc", "mc", "ir", "nr", "wr", "kr", "km", "fr", "dr", "lc", "gr", "dm", "rb", "igr", "mer", "rs", "wk", "adr", "rt"], "dimm": ["dpm", "mirm", "dirm", " dImm", " dirm", "Dim", "mpm", " dim", "Dcm", "mImm", "ddim", " damm", "dim", " dpm", "dcm", "Damm", "ddcm", " dcm", "ddimm", "dImm", "damm", "ddamm", "Dimm", "mimm"], "ddc": ["ddpc", "hdd", "ldi", " ddpc", "hdc", "uddec", "ldcc", " ddec", "gdc", " ddi", "hdcc", "ddec", "ddd", " ddb", "hdi", "gdec", "ddcc", "ddb", " ddcc", "ddi", "uddc", "ldd", "gdpc", "gdb", "ldc", "uddb", " ddd", "uddpc"]}}
{"project": "qemu", "commit_id": "821303f59b63ab832f0921f070db55e95bb21858", "target": 1, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;", "idx": 7269, "substitutes": {"spapr": ["sapR", "spraprar", "spAPrar", "spmprc", "Spapri", "spraprc", "sprapr", "sprapri", "sapsrar", "spapsr", "spaptri", "spAPrc", "saprar", "spaprc", "spaptr", "spaptrar", "Spapr", "sapsri", "spAPr", "SpAPr", "spmpri", "spappri", "spapsri", "SpAPrc", "spaptR", "spapsrar", "spapsR", "spmpr", "SpAPrar", "spappR", "sapri", "sapsR", "spmprar", "Spaprar", "spaprar", "sapr", "spapR", "Spaprc", "spapprar", "spAPri", "spapri", "sapsr", "spappr", "SpAPri"], "token": ["tag", "date", "scope", "oken", "note", "fn", "seed", "future", "target", "number", "notice", "url", "argument", "Token", "name", "element", "auth", "limit", "mini", "key", "len", "byte", "variable", "sync", "event", "rule", "api", "KEN", "type", "socket", "session", "function", "username", "offset", "channel", "column", "password", "request", "stage", "fake", "cookie", "option", "version", "secret", "path", "pass", "character", "duration", "foo", "random", "tick", "wt", "o", "prefix", "uri", "eni", "shadow", "trial", "node", "timeout", "length", "ok", "format", "year"], "nargs": ["NArgs", "narg", " nvar", "Nparams", "cargs", "nparams", "Nvar", "cArgs", "Nargs", "targs", " narg", "nvar", "carg", "tparams", "targ", "cvar", " nArgs", " nparams", "nArgs", "Narg", "tArgs"], "args": ["extra", "data", "unc", "func", "sec", "aws", "ans", "argument", "fun", "len", "arr", "params", "conn", "seq", "cs", "config", "cmd", "Args", "stats", "response", "res", "s", "var", "aux", "init", "fields", "secret", "ig", "ants", "vals", "flags", "cache", "err", "ints", "size", "reply", "arg", "results", "rs", "Ret", "ret"], "nret": ["ncat", "natRET", " ncat", " nRet", "Ncat", "natret", "lRET", " nrets", "lret", "NRet", "nRET", "nnRET", "nnreturn", "nbRet", "nbrets", "nbcat", "lresult", "nnret", "nresult", "Nrets", "lreturn", "nbret", "nnresult", "natresult", "nreturn", "nrets", "Nret", "nRet", "natreturn"], "rets": ["data", "options", "urs", "reset", "def", "ras", "alt", "ats", "auth", "events", " secrets", "details", "params", "runs", "seq", "values", "RET", "tracks", "uments", "types", "tails", "res", "urses", "rows", "files", "pillar", "rs", "aux", "des", "fs", "secret", "fields", "vt", "vals", "flags", "info", "ints", "uds", "tests", "reply", "bits", "cas", "errors", "items", "results", "red", "utils", "Ret", "ret"], "call": ["complete", "kill", "mix", "push", "cal", "eval", "play", "name", "build", "exec", "key", "throw", "self", "p", "sync", "event", "function", "client", "conn", "ack", "use", "make", "create", "n", "block", "c", "Call", "run", "can", "g", "f", "send", "pass", "parse", "roll", "cat", "max", "cache", "o", "ca", "code", "close", "ac", "null", "q", "cell", "work", "v"]}}
{"project": "qemu", "commit_id": "afa46c468acc18914c2773538f1b088c507766ee", "target": 0, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);\n\n    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n\n    int ret;\n\n\n\n    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(&r->req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (-1 == scsi_req_parse(&r->req, cmd)) {\n\n        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n    scsi_req_fixup(&r->req);\n\n\n\n    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,\n\n            r->req.cmd.xfer, cmd[0]);\n\n\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", cmd[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (r->req.cmd.xfer == 0) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buflen = 0;\n\n        r->buf = NULL;\n\n        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);\n\n        if (ret < 0) {\n\n            scsi_command_complete(r, ret);\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (r->buflen != r->req.cmd.xfer) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buf = qemu_malloc(r->req.cmd.xfer);\n\n        r->buflen = r->req.cmd.xfer;\n\n    }\n\n\n\n    memset(r->buf, 0, r->buflen);\n\n    r->len = r->req.cmd.xfer;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        r->len = 0;\n\n        return -r->req.cmd.xfer;\n\n    } else {\n\n        return r->req.cmd.xfer;\n\n    }\n\n}\n", "idx": 7315, "substitutes": {"req": ["ru", "msg", "low", "comm", "er", "str", "rx", "rf", "rh", "dq", "hr", "id", "ctr", "res", "sr", "mr", "cr", "f", "art", "requ", "pkg", "ver", "grad", "conf", "serv", "re", "reader", "ref", "sq", "loader", "input", "exec", "call", "module", "config", "crit", "reg", "urg", "run", "rec", "tr", "cl", "w", "fr", "rb", "qt", "http", "q", "comp", "pull", "ext", "pub", "xml", "p", "org", "conn", "query", "jp", "c", "rev", "ro", "ra", "cmp", "tar", "rs", "spec", "def", "progress", "queue", "e", "Request", "client", "seq", "head", "sem", "request", "pro", "rr", "cur", "ctx", "wa", "ir", "ec", "cache", "err", "dev", "require", "gr", "desc", "com", "rt"], "cmd": ["msg", "comm", "name", "d", "sync", "args", "dq", "roc", "id", "ctr", "pkg", "cf", "bind", "arg", "grad", "conf", "Cmd", "data", "input", "custom", "cli", "call", "clean", "module", "bug", "config", "crit", "ck", "mode", "path", "cl", "cat", "mac", "qq", "code", "cd", "cb", "q", "vc", "comp", "hard", "domain", "dom", "buf", "conn", "cod", "query", "dict", "chan", "cookie", "block", "c", "host", "atom", "cmp", "cp", "method", "cfg", "nc", "def", "cc", "command", "op", "gz", "client", "seq", "request", "obj", "ctx", "cur", "act", "ctrl", "parent", "md", "com"], "s": ["sci", "y", "sq", "si", "d", "sb", "server", "sys", "p", "ls", "session", "S", "search", "sc", "ses", "gs", "cs", "service", "sf", "sp", "ds", "ss", "c", "m", "sr", "t", "sym", "g", "ns", "sa", "ssl", "se", "sl", "w", "z", "sv", "su", "b", "http", "q", "os", "serv", "v", "rs", "spec"], "r": ["ru", "br", "rc", "re", "k", "j", "result", "e", "d", "er", "str", "self", "p", "rf", "rg", "ur", "rx", "rh", "h", "hr", "pr", "this", "u", "usr", "rr", "l", "res", "lr", "sr", "m", "mr", "c", "t", "cr", "g", "tr", "f", "rev", "or", "ro", "ir", "R", "nr", "wr", "err", "w", "ar", "kr", "fr", "dr", "gr", "rb", "rw", "z", "b", "q", "v", "rs", "rt"], "ret": ["pat", "ext", "rc", "re", "ref", "url", "def", "fail", "mt", "result", "fun", "success", "alt", "att", "back", "error", "str", "val", " Ret", "len", "key", "sur", "arr", "no", "last", "bit", "num", "RET", "resp", "out", "reg", "id", "res", "obj", "run", "pass", "rev", "lit", "cat", "flag", "part", "det", "ft", "match", "reply", "code", "nt", "arg", "count", "red", "rets", "Ret"], "i": ["ui", "bi", "y", "pi", "index", "k", "j", "di", "e", "si", "mini", "len", "multi", "key", "fi", "li", "ti", "p", "slice", "type", "mi", "num", "phi", "counter", "qi", "ii", "hi", "u", "inner", "ji", "ind", "id", "n", "chi", "ni", "ip", "abi", "m", "init", "ix", "oi", "zi", "start", "ri", "ini", "part", "info", "my", "gi", "mu", "xi", "uri", "code", "ci", "z", "count", "I", "ai", "v", "x"]}}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n", "idx": 7324, "substitutes": {"m": ["em", "mo", "nm", "data", "an", "gm", "y", "am", "mt", "e", "d", "mm", "message", "p", "bm", "sm", "mut", "h", "mi", "module", "cm", "r", "um", "this", "u", "hm", "fm", "n", "l", "mn", "man", "c", "mr", "t", "g", "f", "ms", "source", "mc", "tm", "mod", "a", "en", "i", "o", "mu", "im", "w", "M", "me", "md", "dm", "b", "machine", "v", "x"], "ip6": ["ipsix", "up6", "cp616", " ip3", "mp613", "mpsix", "mp3", "up612", "clip16", " ip8", "ip06", "p8", "mp36", "mp616", " ip36", "IP6", " ipse", "mp16", "IP76", " ip4", "mopse", "cp36", "opsix", "mp8", "op76", "p06", "ip36", "mop6", "cp16", "ipse", " ip06", "mopsix", "mp6", "ip613", "IPse", "IP613", "ipape", "ip616", "op6", "clip613", "ip4", "IPape", "IP8", "mp06", "IPsix", "mop16", "clip6", "IP16", "ip76", "IP3", "op612", " ipape", "p6", " ipsix", "ip8", "p16", "IP612", "mpape", "clipsix", "cp6", "ip3", "op4", "upsix", "mp4", " ip16", "ip16", "op8", "up76", "ip612", " ip616"]}}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n", "idx": 7326, "substitutes": {}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static int write_dump_pages(DumpState *s)\n\n{\n\n    int ret = 0;\n\n    DataCache page_desc, page_data;\n\n    size_t len_buf_out, size_out;\n\n#ifdef CONFIG_LZO\n\n    lzo_bytep wrkmem = NULL;\n\n#endif\n\n    uint8_t *buf_out = NULL;\n\n    off_t offset_desc, offset_data;\n\n    PageDescriptor pd, pd_zero;\n\n    uint8_t *buf;\n\n    int endian = s->dump_info.d_endian;\n\n    GuestPhysBlock *block_iter = NULL;\n\n    uint64_t pfn_iter;\n\n\n\n    /* get offset of page_desc and page_data in dump file */\n\n    offset_desc = s->offset_page;\n\n    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;\n\n\n\n    prepare_data_cache(&page_desc, s, offset_desc);\n\n    prepare_data_cache(&page_data, s, offset_data);\n\n\n\n    /* prepare buffer to store compressed data */\n\n    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);\n\n    if (len_buf_out == 0) {\n\n        dump_error(s, \"dump: failed to get length of output buffer.\\n\");\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_LZO\n\n    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);\n\n#endif\n\n\n\n    buf_out = g_malloc(len_buf_out);\n\n\n\n    /*\n\n     * init zero page's page_desc and page_data, because every zero page\n\n     * uses the same page_data\n\n     */\n\n    pd_zero.size = cpu_convert_to_target32(s->page_size, endian);\n\n    pd_zero.flags = cpu_convert_to_target32(0, endian);\n\n    pd_zero.offset = cpu_convert_to_target64(offset_data, endian);\n\n    pd_zero.page_flags = cpu_convert_to_target64(0, endian);\n\n    buf = g_malloc0(s->page_size);\n\n    ret = write_cache(&page_data, buf, s->page_size, false);\n\n    g_free(buf);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write page data(zero page).\\n\");\n\n        goto out;\n\n    }\n\n\n\n    offset_data += s->page_size;\n\n\n\n    /*\n\n     * dump memory to vmcore page by page. zero page will all be resided in the\n\n     * first page of page section\n\n     */\n\n    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {\n\n        /* check zero page */\n\n        if (is_zero_page(buf, s->page_size)) {\n\n            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),\n\n                              false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        } else {\n\n            /*\n\n             * not zero page, then:\n\n             * 1. compress the page\n\n             * 2. write the compressed page into the cache of page_data\n\n             * 3. get page desc of the compressed page and write it into the\n\n             *    cache of page_desc\n\n             *\n\n             * only one compression format will be used here, for\n\n             * s->flag_compress is set. But when compression fails to work,\n\n             * we fall back to save in plaintext.\n\n             */\n\n             size_out = len_buf_out;\n\n             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&\n\n                    (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size,\n\n                    Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#ifdef CONFIG_LZO\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&\n\n                    (lzo1x_1_compress(buf, s->page_size, buf_out,\n\n                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n#ifdef CONFIG_SNAPPY\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&\n\n                    (snappy_compress((char *)buf, s->page_size,\n\n                    (char *)buf_out, &size_out) == SNAPPY_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(\n\n                                        DUMP_DH_COMPRESSED_SNAPPY, endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n            } else {\n\n                /*\n\n                 * fall back to save in plaintext, size_out should be\n\n                 * assigned to s->page_size\n\n                 */\n\n                pd.flags = cpu_convert_to_target32(0, endian);\n\n                size_out = s->page_size;\n\n                pd.size = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf, s->page_size, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /* get and write page desc here */\n\n            pd.page_flags = cpu_convert_to_target64(0, endian);\n\n            pd.offset = cpu_convert_to_target64(offset_data, endian);\n\n            offset_data += size_out;\n\n\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_desc.\\n\");\n\n        goto out;\n\n    }\n\n    ret = write_cache(&page_data, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_data.\\n\");\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    free_data_cache(&page_desc);\n\n    free_data_cache(&page_data);\n\n\n\n#ifdef CONFIG_LZO\n\n    g_free(wrkmem);\n\n#endif\n\n\n\n    g_free(buf_out);\n\n\n\n    return ret;\n\n}\n", "idx": 7327, "substitutes": {"s": ["pos", "d", "sync", "slice", "site", "ops", "sg", "services", "fs", "f", "sv", "b", "conf", "v", "south", "an", "sites", "sq", "submit", "sb", "write", "params", "ses", "r", "cs", "sf", "ss", "t", "ns", "a", "its", "sis", "less", "es", "http", "status", "ins", "parts", "comments", "sys", "p", "ls", "session", "S", "ps", "gs", "sets", "xs", "stats", "n", "block", "c", "all", "g", "us", "ssl", "_", "series", "state", "su", "qs", "rs", "spec", "si", "y", "aws", "proc", "e", "server", "is", "service", "ds", "request", "l", "obj", "states", "sym", "sie", "m", "buffer", "settings", "se", "i", "info", "secondary", "js", "stat"], "page_desc": [" page_description", "page_des", "page_design", "page_dat", "page_Desc", "pageJdes", "pageJdesc", " page_des", " page_design", "pageJdesign", "page_description", " page_dat", " page_Desc", "pageJdat"], "page_data": ["page9memory", "page9desc", "page_content", "page_def", " page_def", "page_memory", "pagesdata", "page2data", " page_memory", "block_content", "pagessize", " page_page", "page_da", "pagealldata", "pageallpage", "page2def", "page_page", "page2desc", "block_desc", " page_da", "block_data", "pagealldesc", "page2memory", "page_size", "pagescontent", "page9def", "page9data", "pageallda", "pagesdesc", "block_size"], "len_buf_out": ["len_bufsint", "len_buf_off", "len_buf_Out", "len_buf_size", "len_buff_desc", "len_bufsdesc", "len_buf_OUT", "len_buf_desc", "len_buff_again", "len_uf_Out", "len_buff_Out", "len_buf_int", "len_uf_off", "len_buff_int", "len_bufsout", "len_uf_in", "len_buf_inner", "len_bufsinner", "len_buff_out", "len_buf_again", "len_buff_inner", "len_buf_in", "len_uf_size", "len_uf_out", "len_buff_OUT"], "size_out": ["size_in", " size_inner", " size_in", "size0inner", "size_inner", "size0desc", " size_desc", "size0out", "size0in", "size_desc"], "buf_out": ["block_cache", " buf_size", "buf_inner", "buf_cache", "block_out", "buf_output", " buf_output", " buf_in", "block_inner", "buf_size", "buf_in", "block_in"], "offset_desc": ["offset_Desc", "offset9data", " offset64description", "offset_ext", "offset_doc", "offset_page", "offset64size", "offsetNext", " offset_ext", "offsetNdesc", "offset64dec", "offsetCDesc", "offset_size", " offset_size", "offset_description", "offsetNdoc", "offset24Desc", "offset9desc", " offset_page", " offset_Desc", "offset24desc", "offset_dec", " offset64data", "offsetCdoc", "offset_sc", " offset_dec", "offset9size", "offset24description", "offset64description", "offsetCdesc", " offset_doc", "offset24page", "offset64data", "offset64sc", " offset64size", "offset64Desc", " offset_description", " offset_sc", "offsetNDesc", " offset64desc", "offset9description", "offsetCext", "offset64desc"], "offset_data": ["offset__data", "Offset_data", "position__desc", "Offset_description", "offset_start", "offsetingdata", "offsetCdata", "offset6dat", "offsetCdescription", "offsetndescription", "page_def", "offset_description", "position__length", "offset6len", "position_desc", "offset__length", "offsetingdesc", "offset_dat", "size_dat", "offsetndesc", "size_data", "page_len", "offset_def", "offsetingstart", "position_data", "offset__desc", "position__off", "offset__off", "size_desc", "offsetCdesc", "offset6def", "page_dat", "position__data", "position_length", " offset_start", "offset_off", "offset_len", "offsetCdat", "size_description", "offset_length", "position_off", "Offset_desc", "offsetndata", "offset6data"], "pd": [" backend", " std", " su", " dir", " proc", " fs", " def", " dc", " FD", " o", " disp", " rc", " layout", " param", " dim", " stats", " td", " sd", " cf", " da", " proto", " cp", " DP", " obj", " mode", " sl", " plugin", " dd", " DF"], "pd_zero": ["pdfamzero", "dp_one", "pd___error", "pd_one", "pdamfour", "dpjone", "pd_low", "pdamnegative", "pd_none", "dp_error", "pdamslice", "dc_zero", "pd_slice", "pd_small", "hd_small", "pdjone", "pd_scope", "pdamzero", "pd2zero", "pd2scale", "pd__scale", "dpjerror", "dpjscale", "pdjscale", "pd_four", "dp_scale", "dd_six", "hd_error", "dc_scope", "pd___zero", "hd_zero", "pd__slice", "hd_low", "pdjzero", "pd2one", "pd__error", "pd2error", "pd_empty", "dd_zero", "pd___small", "pd_eight", "pdf_negative", "dc_none", "pd__zero", "pd_six", "dc_eight", "pdfamnegative", "dp_zero", "pd_token", "pd_scale", "pd_error", "dpjzero", "pdjerror", "pdf_zero", "pdf_four", "pdfamslice", "pd__negative", "pdfamfour", "pd__four", "pd_negative", "pdf_slice", "dd_token", "pd___low", "pd__one", "dd_empty"], "buf": ["batch", "data", "pool", "pb", "wb", "uc", "br", "ru", "header", "context", "conv", "bag", "proc", "callback", "result", "queue", "Buffer", "fi", "mem", "src", "bl", "pad", "seq", "img", "box", "bb", "dest", "config", "vec", "cmd", "fw", "fb", "runner", "bo", "block", "buff", "fd", "c", "aux", "home", "tmp", "bc", "ctx", "buffer", "f", "func", "Buff", "cv", "cache", "alloc", "nat", "cf", "comb", "bd", "uf", "bh", "ff", "rb", "cas", "b", "cb", "fp", "output", "fl", "port"], "block_iter": ["block_info", "blockSinner", "block_it", " block_it", "block__stack", "blockSstack", "block_sort", "block2it", "block__iter", "blockSiterator", " block_sort", "block2info", "block_stack", " block_info", "block__iterator", "block2iter", "block2sort", "block__inner", "block_inner", "blockSiter", " block_inner", "block_iterator", " block_stack", " block_iterator"], "pfn_iter": ["pgn_iter", "pfn_enter", "pgn_err", "pfn_data", "pgn_inner", "pfn_err", "pfn_inner"]}}
{"project": "qemu", "commit_id": "d516f74c99b1a2c289cfba0bacf125cbc9b681e3", "target": 0, "func": "static void do_ext_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    ExtQueue *q;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_EXT)) {\n\n        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;\n\n    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;\n\n    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {\n\n        g_assert(env->ext_index >= 0);\n\n        /*\n\n         * FIXME: floating IRQs should be considered by all CPUs and\n\n         *        shuld not get cleared by CPU reset.\n\n         */\n\n        q = &env->ext_queue[env->ext_index];\n\n        lowcore->ext_int_code = cpu_to_be16(q->code);\n\n        lowcore->ext_params = cpu_to_be32(q->param);\n\n        lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);\n\n        env->ext_index--;\n\n        if (env->ext_index == -1) {\n\n            env->pending_int &= ~INTERRUPT_EXT_SERVICE;\n\n        }\n\n    } else {\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 7332, "substitutes": {"env": ["ou", "np", "er", "equ", "dt", "que", "args", "ce", "energy", "site", "enable", "init", "engine", "bc", "en", "cf", "conf", "v", "output", "context", "vm", "oa", "zone", " environment", "db", "loader", "enc", "exec", "ea", "app", "ep", "ne", "config", "viron", "stage", "Environment", "cv", "gui", "code", "here", "qv", "qt", "environment", "ench", "eve", "eu", "cal", "eq", "session", "style", "conn", "et", "ass", "press", "eng", "fen", "shell", "console", "qa", "manager", "state", "dat", "scope", "nc", "reset", "end", "queue", "e", "exc", "core", "server", "event", "ev", "gear", "cdn", "net", "her", "ec", "cache", "err", "global", "dev", "erv", "eni", "po", "enh"], "cpu": ["pool", "nc", "pc", "vm", "np", "proc", "nu", "loader", "gpu", "component", "core", "cli", "sys", "mx", "p", "clock", "pid", "conn", "processor", "roc", "hu", "bench", "net", "c", "ctx", "bc", "boot", "platform", "hw", "cache", "chip", "cn", "eni", "lc", "pu", "process", "cmp", "cp", "linux", "CPU"], "mask": ["data", "allow", "depth", "sum", "index", "header", "mark", "key", "ban", "acl", "map", "iq", "pid", "bit", "filter", "seq", "conn", "channel", "bug", "ack", "patch", "kernel", "ask", "sign", "id", "mn", "ip", "block", "skip", "pattern", "ck", "mode", "unk", "weight", "pass", "scan", "comment", "cat", "max", "mac", "qa", "flag", "group", "flags", "cache", "carry", "info", "random", "arch", "code", "Mask", "delay", "bits", "pack", "sk", "shape", "fix", "cmp", "count", "conf", "zero", "lock", "window", "spec"], "addr": ["pos", "depth", "index", "stack", "oa", "ref", "area", "url", "au", "dist", "target", "az", "alt", "len", "mx", "arr", "arm", "slice", "src", "ann", "amd", "pad", "seq", "ace", "offset", "conn", "ack", "id", "layer", "address", "host", "hop", "pkg", "nr", "mac", "part", "slot", "coord", "ad", "prefix", "amp", "arch", "dr", "code", "delay", "md", "rt", "ag", "attr", "node", "ptr", "aa", "align", "adr", "asm"], "lowcore": ["lowercomponent", "lowcache", "slowcontroller", "slowcache", "feedscore", "slowobject", "slownode", "smallcenter", "globalcache", "libcomponent", "Lowcache", "lowconn", "lowscore", "nowcenter", "Lowbase", "libcode", "lowermodel", "controlcase", "controlcore", "hardsystem", "slowcase", "ledconn", "slowsystem", "flowcore", "longcode", "lowcontroller", "Lowcode", "libcenter", "smallcp", "globalcenter", "locenter", "slowcore", " lowconn", " lowcache", "globalore", "libcore", " lowobject", "hardcenter", "nowcore", "fullcode", "ledcenter", "fullprocessor", "lowerore", "smallprocessor", "lowure", " lowcenter", "hardcase", " lowcode", "liveconn", "fullcore", "slowprocessor", "controlcenter", "lowerscore", "longcore", "feedmodel", "smallcore", "livecore", " lownode", "lowore", " lowure", "smallcode", "lowercenter", "lowerprocessor", "fullcenter", "controlsystem", "slowcomponent", "libure", "lowbase", "nowcp", "longbase", "longcenter", " lowcontroller", "locache", "longprocessor", "flowcode", "locontroller", "smallbase", "lowercore", "flowcenter", "flowsupport", "lowsystem", "smallcache", "livecenter", "lowcase", "lowobject", "lowernode", "livecode", " lowprocessor", "longsupport", "slowcenter", " lowore", "ledcode", "Lowcore", "Lowore", " lowsupport", "flowure", "lowsupport", "lowcenter", "lowcode", " lowbase", "feedore", "libscore", "feedcore", "Lowcenter", "nowprocessor", "ledcore", "globalcore", "libore", "locore", "hardcore", "lowmodel", "lowprocessor", "flowore", " lowcp", "libmodel", "lowcp", "lowerobject", "lowcomponent", "slowore", "lownode"], "q": ["k", "sq", "j", "cal", "progress", "queue", "d", "view", "cc", "p", "question", "que", "sync", "eq", "iq", "ry", "dq", "client", "seq", "qi", "ue", "ch", "query", "config", "u", "cmd", "id", "qu", "ck", "c", "sh", "v", "t", "quant", "g", "f", "requ", "qa", "req", "Q", "quest", "cache", "w", "qq", "z", "qt", "qs"], "ext_index": ["xt_Index", "ext_offset", "txt_level", "extsoffset", "dist_size", "extsindex", " ext_id", " ext_offset", "xt_ind", "txt_position", "txt_index", "ext_ind", "extsid", "ext_id", "xt_offset", "dist_ind", "ext_Index", " extsoffset", "ext_level", "ext_count", "extscount", " ext_count", "ext_size", "txt_address", "dist_index", "dist_level", "xt_index", " extsindex", "ext_address", " extscount", " extsid", "ext_position"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n", "idx": 7334, "substitutes": {"machine": ["vm", "proc", "loader", "slave", "gpu", "mem", "connection", "session", "Machine", "image", "config", "service", "device", "net", "m", "mode", "instance", "boot", "model", "mac", "cache", "manager", "M", "state", "node", "process", "linux", "computer", "base"], "cpu_model": ["cpu67location", "pixel_spec", "pixel__model", "cpu67spec", "pixel_size", "cpuablemodel", "cpu67size", "cpuablespec", "cpu_models", " cpu_mode", "cpu__location", "cpu__model", "cpuworkmode", "cpuablelocation", "cpuidspace", "gpu_model", "cpuidmode", "cpu__size", "cpu_scale", "pixel__size", "gpu_mode", "cpu_size", "pixel_location", "pixel__location", "cpu__spec", "cpuidscale", "cpu_space", "gpu_scale", "gpu_space", "cpuworkscale", "cpuablesize", "cpuworkspace", "cpuworkmodel", "pixel_model", "cpu67model", "cpuidmodel", "cpu_mode", "pixel__spec", "cpu_location", " cpu_models", "cpu_spec"], "cpu": [" CPU", "performance", "uu", "vm", "fps", "pc", "proxy", "proc", "result", "loader", "gpu", "core", "mem", "mx", "GPU", "gc", "clock", "conn", "module", "processor", "unit", "kernel", "bench", "net", "instance", "ram", "boot", "platform", "io", "copy", "hw", "cache", "memory", "chip", "eni", "lc", "pu", "ilo", "node", "process", "cmp", "cp", "linux", "computer", "CPU"], "dinfo": ["dbconfig", "binf", " dconf", " dconfig", " dinf", "ffi", "adinf", "bfo", "dInfo", "dedinfo", " dInfo", "dconf", "ldfi", "fInfo", "dbinfo", "adconfig", "binfo", "dedInfo", "adINFO", "dbINFO", "ldconf", "vdfo", "dfi", "dINFO", "pinf", "adinfo", "ldfo", " dfo", "ldinf", "vdinfo", " dfi", "finf", "ldinfo", "bconf", "dedconf", "dbinf", "vdconf", "pinfo", "pInfo", "dfo", "dedfo", "pfo", " dINFO", "finfo", "dconfig", "ffo", "vdInfo", "dinf"], "be": ["bi", "are", "allow", "replace", " Be", "scale", "de", "bf", "e", "ae", "BE", "sb", "le", "leave", "ve", "trace", "ignore", "fe", "by", "byte", "bl", "Be", "bre", "ce", "is", "stop", "ace", "ome", "fore", "ne", "use", "obe", "ze", "enable", "bes", "ba", "te", "nl", "bee", "ine", "range", "bis", "eb", "ro", "we", "se", "ble", "see", "comb", "ape", "abe", "me", "ere", "b", " BE", "ke", "ee", "ate"], "address_space_mem": ["address_space_ram", "address_range_mem", "address_system_mem", "address_system_ram", "address_space_memory", "address_space_lim", "address_range_memory", "address_system_lim", "address_range_ram"]}}
{"project": "qemu", "commit_id": "e3737b820b45e54b059656dc3f914f895ac7a88b", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n    bs->read_only = 1; // no write support yet\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;", "idx": 7347, "substitutes": {"bs": ["bi", "iss", "pb", "lb", "gb", "ab", "outs", "sb", "bos", "blocks", "ks", "BS", "ls", "bl", "org", "ps", "utils", "lbs", "ses", "vs", "cs", "bb", "gs", "ros", "bytes", "ds", "xs", "ubs", "fb", "ob", "ops", "ss", "bes", "ts", "css", "obs", "bc", "fs", "mes", "ns", "ms", "sa", "bis", "ec", "vals", "als", "bu", "bh", "bits", "js", "b", "ins", "bt", "os", "bing", "http", "qs", "rs", "bas", "hs", "las", "base"], "options": ["outs", "opens", "op", "details", "args", "params", "buf", "config", "lib", "stats", "option", "obj", "ops", "c", "ts", "fs", "f", "opt", "Options", "io", "settings", "info", "o", "bits", "q", "os"], "flags": ["opens", "parts", "ats", "mask", "details", "args", "bytes", "reg", "stats", "ents", "files", "ops", "lag", " bits", "Flags", "ants", "vals", "flag", "settings", "ints", "bits", "reads", "features", "format", "errors", "status", "ips"], "errp": ["aserp", "irp", "errpb", "erP", " errpb", "irjp", "errorjp", "errjp", " errfp", "errorpre", "irpre", "erp", "errP", "evjp", "errper", "errorp", "errorper", "evpre", "aserP", "evp", "erfp", " errP", "aserpb", "errpre", "errfp", "evper", "irper", "erpb", "aserfp"], "s": ["d", "sync", "args", "vs", "ops", "sg", "services", "fs", "f", "sv", "b", "groups", "sb", "h", "ses", "cs", "config", "ss", "ts", "t", "uns", "ns", "sa", "its", "w", "es", "ins", "hs", "http", "parts", "sys", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "n", "rows", "c", "all", "css", "obs", "g", "ssl", "_", "sl", "state", "su", "qs", "rs", "si", "spec", "aws", "proc", "e", "is", "ds", "ubs", "l", "states", "sym", "m", "ms", "bis", "settings", "als", "o", "js", "utils"], "i": ["bi", "ui", "y", "pi", "index", "k", "j", "di", "e", "d", "mini", "key", "val", "multi", "fi", "ti", "p", "li", "uli", "ski", "bit", "is", "phi", "qi", "ii", "ki", "out", "u", "inner", "ji", "id", "chi", "ni", "n", "ip", "l", "abi", "c", "m", "t", "ix", "il", "f", "zi", "io", "ri", "a", "ini", "info", "it", "gi", "xi", "mu", "x", "ci", "z", "b", "iu", "I", "ai", "v", "si"], "bochs": ["bochets", "broachds", " boChn", "bochards", "ooachts", "bochyns", "bocharps", "boochs", "wochss", "boarches", "bopathsin", "bocharides", "bochots", "bochanns", "bodefsin", "bocilss", "crocountts", "Bochs", "ouchts", "boachs", "Bochses", "bochrs", "bochtses", "boochses", "boichs", "crochs", "bochoses", "boChops", "boochts", "ouches", "bochys", "bocharts", "bopathts", "bochyses", "bochants", "bochanls", " bochts", " bochrs", "bondefs", " boichses", "boched", "Boichses", "bovertts", "bacorls", "crocountns", "boarchps", "bonchps", "bochnds", " bochses", "bonchins", "bonchs", "oupathes", "boChrs", "boachts", "bochnses", "bochss", " boichts", "cochs", "bochars", "bacords", "bopathins", " bochis", " boChops", "hochs", "bochnts", "woochss", "bocors", "boachds", "woochts", "bochyts", "oochns", "bochides", "boghs", "bocils", "boochd", "ooachds", "boarchls", "boichides", "boochss", "cochis", "hochts", "bochtss", "crochts", " boichns", "coichis", "bopaths", "bochans", "bochsin", "boichses", "bondefps", "boarchs", "bochnes", "boght", "boachrs", "oupathts", "bochan", "cocht", "oochses", "bochaops", "oochs", "bovertss", " boChrs", "boochls", "hochoses", "bochtts", "bochains", "coicht", "Boichs", "boChn", "bochns", "wochs", "bochtains", "crochns", "bocorls", "brochs", "crochls", "boichd", "bopathes", "oochls", "boichns", "bocheos", "oochts", "bochis", "bocilis", "boverts", "oupaths", "bocilts", "bochas", "bochyds", " boichds", "bocht", "woochains", "broachs", "bocountls", "bochds", "bochps", "bovertains", " boichs", "oochds", "crocountls", "boicht", "boctrs", " bochn", "boctrls", " boChs", "bondefins", "woochs", "bodefps", "bochops", "ooachs", "Bochos", "bachs", "bocountts", "bochts", "bocharins", "wochts", "boichos", " bocheis", "coichs", "bochet", " boches", " bochets", "broachps", "boches", "bondefsin", "Bochd", "boctrses", "bocheis", "oochnses", "bochins", "bochn", "boachops", "hochos", " boichides", "bochnls", "boarchds", "boichds", "bocountns", "boachps", "bodefs", "Boichos", "bachds", "bochnss", "ouchls", "bochses", "boichts", " bochns", "bonchsin", " bochss", " bochds", "bocharsin", "boarchts", "oochnls", "bochnides", "bochnns", "hochses", "Boichd", "bocheses", "boichis", "hochots", "boChs", "bacors", "oupathls", "bochd", " bochops", "ouchs", "boachn", "bodefins", "wochains", "brochds", " bochess", "bochls", "boochains", "bopathls", "bochess", "bochnis", " bochides", "boghis", "crocounts", "brochps", "bocounts", "bocords", "bachls", "bopathps", "boochos", "bochos"], "ret": ["let", "hash", "rc", "re", "ref", "end", "def", "fail", "after", "mt", "result", "success", "bf", "alt", "att", "fun", "back", "try", "error", "str", "len", "val", " RET", " Ret", "bad", "arr", "no", "bit", "num", "RET", "r", "out", "reg", "res", "sr", "t", "run", "g", "pt", "art", "pass", "f", "lit", "en", "flag", "group", "part", "feat", "err", "gt", "det", "ft", "al", "match", "nt", "reply", "code", "ag", "arg", "format", "count", "rets", "Ret", "rt"]}}
{"project": "FFmpeg", "commit_id": "3b9a913db4d303a0305a80de496b1933cba8980f", "target": 1, "func": "offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)\n\n{\n\n    offset_t offset1;\n\n    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return -EINVAL;\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else {\n\n        if (!s->seek)\n\n            return -EPIPE;\n\n\n\n#ifdef CONFIG_MUXERS\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        } else\n\n#endif //CONFIG_MUXERS\n\n        {\n\n            s->buf_end = s->buffer;\n\n        }\n\n        s->buf_ptr = s->buffer;\n\n        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)\n\n            return -EPIPE;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}\n", "idx": 7351, "substitutes": {"s": ["conv", "d", "sync", "args", "native", "site", "ops", "sg", "services", "strings", "fs", "f", "side", "b", "in", "conf", "serv", "south", "data", "new", "sq", "outs", "sb", "h", "ses", "cs", "this", "u", "ss", "ts", "t", "uns", "ns", "a", "its", "your", "less", "es", "http", "ins", "comments", "self", "sys", "p", "ls", "session", "S", "ps", "gs", "sets", "xs", "n", "c", "css", "g", "us", "ssl", "su", "qs", "rs", "spec", "si", "aws", "e", "server", "op", "socket", "is", "client", "service", "ds", "l", "sym", "m", "ms", "as", "settings", "se", "i", "o", "js", "esi", "os"], "offset": ["data", "pos", "index", "reset", "url", "area", "abyte", "optional", "set", "end", "error", "queue", "loc", "number", "limit", "adjust", "len", "p", "Offset", "acl", "api", "slice", "connection", "type", "seq", "order", "position", "bytes", "off", "current", "offer", "skip", "online", "adjusted", "aligned", "address", "buffer", "pointer", "shift", "page", "point", "padding", "location", "start", "slot", "cache", "i", "alloc", "o", "size", "fee", "origin", "timeout", "length", "alias", "addr", "count", "fp", "ptr", "align", "missing", "format", "base"], "whence": ["Whenced", "arencer", "duringcing", "arenace", "arenced", "thencing", " whenced", "foreCE", " whenCE", "Whenace", "Whences", "arences", " whencing", "duringce", "Whence", "iconced", " whencer", "whenke", "whenced", "thenke", "whencer", "arencing", "Whencing", "arence", " whenace", "forece", "Whencer", "whencing", "iconces", "thence", "iconce", "Whenke", "duringace", "foreces", " whences", "duringke", "whences", "forecer", "whenCE", "thenace", "iconcing", "whenace", "WhenCE"], "offset1": ["Offset1", " offset7", "align1", "Offset01", "offset01", "length71", " offsetX", " offset_", " offsetone", "offOne", "offset0", "offsetX", "lengthone", "offsetone", " offsetOnce", "pointer2", "adjust2", "adjustOnce", "addr1", "offset7", "Offset0", "OffsetOnce", "adjust1", "off7", "off1", "offset2", "OffsetOne", "option0", "length1", "offsetOne", "lengthOne", "offerone", "offset71", "Offset2", " offset0", " offsetOne", "align0", "offer0", "off_", "pointer1", "align7", "off2", "addr2", "Offset_", " offset01", "option1", "align2", "align01", " offset71", " offset2", "length0", "optionOne", "OffsetX", "off0", "pointerOne", "optionone", "offsetOnce", "offer71", "offer1", "addrX", "offset_", "adjustOne"]}}
{"project": "qemu", "commit_id": "18b21a2f83a26c3d6a9e7f0bdc4e8eb2b177e8f6", "target": 0, "func": "void ppc_translate_init(void)\n\n{\n\n    int i;\n\n    char* p;\n\n    size_t cpu_reg_names_size;\n\n    static int done_init = 0;\n\n\n\n    if (done_init)\n\n        return;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    p = cpu_reg_names;\n\n    cpu_reg_names_size = sizeof(cpu_reg_names);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"crf%d\", i);\n\n        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                            offsetof(CPUState, crf[i]), p);\n\n        p += 5;\n\n        cpu_reg_names_size -= 5;\n\n    }\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"r%d\", i);\n\n        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,\n\n                                        offsetof(CPUState, gpr[i]), p);\n\n        p += (i < 10) ? 3 : 4;\n\n        cpu_reg_names_size -= (i < 10) ? 3 : 4;\n\n#if !defined(TARGET_PPC64)\n\n        snprintf(p, cpu_reg_names_size, \"r%dH\", i);\n\n        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, gprh[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n#endif\n\n\n\n        snprintf(p, cpu_reg_names_size, \"fp%d\", i);\n\n        cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                            offsetof(CPUState, fpr[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dH\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#else\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dL\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#else\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n    }\n\n\n\n    cpu_nip = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, nip), \"nip\");\n\n\n\n    cpu_msr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, msr), \"msr\");\n\n\n\n    cpu_ctr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, ctr), \"ctr\");\n\n\n\n    cpu_lr = tcg_global_mem_new(TCG_AREG0,\n\n                                offsetof(CPUState, lr), \"lr\");\n\n\n\n    cpu_xer = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, xer), \"xer\");\n\n\n\n    cpu_reserve = tcg_global_mem_new(TCG_AREG0,\n\n                                     offsetof(CPUState, reserve), \"reserve\");\n\n\n\n    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                       offsetof(CPUState, fpscr), \"fpscr\");\n\n\n\n    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, access_type), \"access_type\");\n\n\n\n    /* register helpers */\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    done_init = 1;\n\n}\n", "idx": 7360, "substitutes": {"i": ["bi", "pi", "index", "d", "multi", "ti", "api", "slice", "type", "qi", "hi", "inner", "id", "ip", "init", "ori", "f", "zi", "mu", "uri", "b", "v", "li", "ui", "iii", "ie", "ei", "cli", "vi", "module", "ii", "u", "ji", "ic", "abi", "t", "ix", "ini", "fr", "code", "lc", "isi", "iu", "q", "ai", "mi", "n", "jp", "c", "oi", "g", "io", "gi", "it", "I", "x", "si", "y", "j", "di", "field", "e", "fi", "yi", "isin", "phi", "anti", "chi", "ni", "l", "m", "source", "ri", "info", "o", "xi", "ci", "eni", "z", "ia"], "p": ["br", "pi", "pc", "np", "api", "mp", "pair", "up", "dp", "per", "ip", "f", "lp", "pe", "b", "fp", "v", "private", "pb", "local", "vp", "param", "exec", "prev", "h", "r", "u", "current", "sp", "ap", "hp", "t", "path", "a", "wp", "part", "code", "q", "after", "pre", "rep", "pg", "ps", "patch", "P", "n", "jp", "c", "g", "pp", "python", "like", "bp", "post", "cp", "x", "py", "y", "j", "progress", "e", "tp", "op", "pa", "at", "l", "m", "pointer", "point", "cache", "o", "z", "po", "port"], "cpu_reg_names_size": ["cpu_reg_names_small", "cpu_reg_name_scale", "cpu_reg_names_speed", "cpu_reg_names_extra", "cpu_reg_codes_small", "cpu_reg_names_large", "cpu_reg_names_ize", "cpu_reg_name_size", "cpu_reg_name_address", "cpu_reg_codes_speed", "cpu_reg_names_capacity", "cpu_reg_name_large", "cpu_reg_codes_code", "cpu_reg_names_scale", "cpu_reg_codes_length", "cpu_reg_codes_name", "cpu_reg_name_extra", "cpu_reg_codes_size", "cpu_reg_codes_type", "cpu_reg_name_capacity", "cpu_reg_names_name", "cpu_reg_codes_capacity", "cpu_reg_namespcapacity", "cpu_reg_names_type", "cpu_reg_namespscale", "cpu_reg_namespsize", "cpu_reg_name_ize", "cpu_reg_codes_scale", "cpu_reg_names_code", "cpu_reg_name_small", "cpu_reg_namespextra", "cpu_reg_names_address", "cpu_reg_names_length", "cpu_reg_codes_address"]}}
{"project": "qemu", "commit_id": "7d08d85645def18eac2a9d672c1868a35e0bcf79", "target": 0, "func": "static void gen_mtfsfi(DisasContext *ctx)\n\n{\n\n    int bf, sh;\n\n    TCGv_i64 t0;\n\n    TCGv_i32 t1;\n\n\n\n    if (unlikely(!ctx->fpu_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_FPU);\n\n        return;\n\n    }\n\n    bf = crbD(ctx->opcode) >> 2;\n\n    sh = 7 - bf;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_reset_fpstatus();\n\n    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));\n\n    t1 = tcg_const_i32(1 << sh);\n\n    gen_helper_store_fpscr(cpu_env, t0, t1);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0)) {\n\n        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);\n\n        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);\n\n    }\n\n    /* We can raise a differed exception */\n\n    gen_helper_float_check_status(cpu_env);\n\n}\n", "idx": 7380, "substitutes": {"ctx": ["context", "sci", "cfg", "pc", "rc", "conv", "comm", "np", "loc", "gpu", "component", "exec", "anc", "cc", "cli", "sync", "que", "connection", "cus", "client", "xc", "conn", "ct", "sc", "cm", "cs", "git", "config", "fw", "cmd", "jp", "cca", "Context", "tx", "obj", "cms", "c", "cgi", "bc", "cr", "cpu", "kb", "kt", "ctrl", "cv", "cam", "pkg", "hw", "qa", "cu", "cf", "ca", "tc", "cn", "ci", "lc", "cas", "cb", "cmp", "vc", "cp", "fp", "linux", "utils"], "bf": ["xf", "BF", "pb", "ref", "gb", "sq", "sb", "fx", "len", "mb", "fe", "af", "bl", "offset", "fff", "bb", "sf", "hl", "fb", "buff", "fd", " kb", "bc", "nb", "f", "kb", "lambda", "eb", "fc", "fab", "kn", "ft", "fee", "cf", "lf", "bd", "bh", "FH", "ff", "uf", "rb", "xb", "b", "cb", "fp", "ffield", "bt", "fl", "base"], "sh": ["ffff", "kh", "sth", "small", "sq", "eth", "loc", "ssh", "sb", "SH", "sync", "bl", "hel", "h", "sc", "sch", "osh", "ush", "ch", "hl", "sp", "sha", "shi", "qu", "s", "ss", "resh", "ix", "f", "shift", "iz", "cl", "sn", "Sh", "gh", "se", "ph", "sl", "ft", "size", "bh", "wh", "sw", "ff", "zh", "sv", "sd", "sk", "q", "ht", "square"], "t0": ["t10", "te8", "p10", "ta1", " t10", "p1", "te25", "te1", "T00", "T0", " t3", "Tii", "tt1", "t00", "T1", "t50", " t50", "T3", "teii", "T8", "p0", "tt00", "te0", "T10", "t3", "tt0", "tt8", "te50", "tii", "tt25", "t8", "p3", "ta00", "tt50", "te00", "t25", "ta0", "ttii", " t25", " t00"], "t1": ["ta2", " tone", "ta1", "type61", "t01", "typeone", "T0", "otb", "v2", " t64", "T64", "Tb", "t64", "tt1", "i1", "ot64", "T1", "tt01", "ot0", "v01", "ttone", " tb", "i01", "type1", " t01", "ti2", "i64", "ti1", "ot1", "ti64", "T01", "i2", "v1", "T2", "type01", "t2", "ti01", "tone", "tt61", "tb", "ta01", "t61", " t61"]}}
{"project": "qemu", "commit_id": "1e356fc14beaa3ece6c0e961bd479af58be3198b", "target": 1, "func": "void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n", "idx": 7393, "substitutes": {"fd": ["fa", " df", "da", "dir", " dir", "db", "d", " def", " dc", "df", "fff", "FD", " sd", "sf", "ds", " da", "ef", " d", "dc", "f", " fa", "fc", " buf", "bd", "ff", " f", " fid", "handler"], "area": ["data", "storage", "dir", "sea", "section", "folder", "zone", "oa", "region", "Area", " areas", "ea", "paper", "image", "offset", "rea", "large", " Area", "aria", "ba", "alpha", "address", "space", "array", "a", "ATA", "qa", "prefix", "ca", "aaa", "va", "ra", "ia", "alias", "radius", "aa", "ha", "base"], "memory": ["complete", "data", "performance", "storage", "margin", "scale", "number", "total", "queue", "region", "mm", "message", "mini", "mem", "write", "mx", "metadata", "mi", "record", "order", "image", "external", "large", "maximum", "activity", "m", "medium", "address", "buffer", "knowledge", "space", "capacity", "array", "page", "padding", "uration", "network", "duration", "cache", "wave", "media", "size", "usage", "cover", "shape", "length", "time", "age", "count", "resource", "Memory"], "errp": ["errorpc", "errorfp", "erpc", "errr", " errpc", "errpc", " errfp", "erfp", "errorp", "erp", "errorr", " errr", "errfp", "err"], "i": ["ui", "bi", "data", "index", "pi", "j", "number", "di", "e", "mini", "multi", "ti", "p", "base", "phi", "image", "qi", "ii", "hi", "u", "ji", "id", "n", "l", "ni", "ami", "m", "c", "ix", "oi", "f", "zi", "page", "io", "start", "a", "ri", "ini", "info", "gi", "mu", "x", "xi", "uri", "ci", "eni", "z", "b", "iu", "I", "ai", "si", "li"]}}
{"project": "FFmpeg", "commit_id": "4029f05c8b0943a5446f254142d5e2bfedb50a0d", "target": 1, "func": "static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    CuvidContext *ctx = avctx->priv_data;\n\n    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data;\n\n    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;\n\n    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;\n\n    AVFrame *frame = data;\n\n    CUVIDSOURCEDATAPACKET cupkt;\n\n    AVPacket filter_packet = { 0 };\n\n    AVPacket filtered_packet = { 0 };\n\n    CUdeviceptr mapped_frame = 0;\n\n    int ret = 0, eret = 0;\n\n\n\n    if (ctx->bsf && avpkt->size) {\n\n        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_packet_ref failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_send_packet failed\\n\");\n\n            av_packet_unref(&filter_packet);\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_receive_packet failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        avpkt = &filtered_packet;\n\n    }\n\n\n\n    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));\n\n    if (ret < 0) {\n\n        av_packet_unref(&filtered_packet);\n\n        return ret;\n\n    }\n\n\n\n    memset(&cupkt, 0, sizeof(cupkt));\n\n\n\n    if (avpkt->size) {\n\n        cupkt.payload_size = avpkt->size;\n\n        cupkt.payload = avpkt->data;\n\n\n\n        if (avpkt->pts != AV_NOPTS_VALUE) {\n\n            cupkt.flags = CUVID_PKT_TIMESTAMP;\n\n            if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n                cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000});\n\n            else\n\n                cupkt.timestamp = avpkt->pts;\n\n        }\n\n    } else {\n\n        cupkt.flags = CUVID_PKT_ENDOFSTREAM;\n\n    }\n\n\n\n    ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));\n\n\n\n    av_packet_unref(&filtered_packet);\n\n\n\n    if (ret < 0) {\n\n        if (ctx->internal_error)\n\n            ret = ctx->internal_error;\n\n        goto error;\n\n    }\n\n\n\n    if (av_fifo_size(ctx->frame_queue)) {\n\n        CUVIDPARSERDISPINFO dispinfo;\n\n        CUVIDPROCPARAMS params;\n\n        unsigned int pitch = 0;\n\n        int offset = 0;\n\n        int i;\n\n\n\n        av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL);\n\n\n\n        memset(&params, 0, sizeof(params));\n\n        params.progressive_frame = dispinfo.progressive_frame;\n\n        params.second_field = 0;\n\n        params.top_field_first = dispinfo.top_field_first;\n\n\n\n        ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params));\n\n        if (ret < 0)\n\n            goto error;\n\n\n\n        if (avctx->pix_fmt == AV_PIX_FMT_CUDA) {\n\n            ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_get_buffer failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            ret = ff_decode_frame_props(avctx, frame);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_decode_frame_props failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            for (i = 0; i < 2; i++) {\n\n                CUDA_MEMCPY2D cpy = {\n\n                    .srcMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .dstMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .srcDevice     = mapped_frame,\n\n                    .dstDevice     = (CUdeviceptr)frame->data[i],\n\n                    .srcPitch      = pitch,\n\n                    .dstPitch      = frame->linesize[i],\n\n                    .srcY          = offset,\n\n                    .WidthInBytes  = FFMIN(pitch, frame->linesize[i]),\n\n                    .Height        = avctx->coded_height >> (i ? 1 : 0),\n\n                };\n\n\n\n                ret = CHECK_CU(cuMemcpy2D(&cpy));\n\n                if (ret < 0)\n\n                    goto error;\n\n\n\n                offset += avctx->coded_height;\n\n            }\n\n        } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) {\n\n            AVFrame *tmp_frame = av_frame_alloc();\n\n            if (!tmp_frame) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\");\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n\n\n            tmp_frame->format        = AV_PIX_FMT_CUDA;\n\n            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);\n\n            tmp_frame->data[0]       = (uint8_t*)mapped_frame;\n\n            tmp_frame->linesize[0]   = pitch;\n\n            tmp_frame->data[1]       = (uint8_t*)(mapped_frame + avctx->coded_height * pitch);\n\n            tmp_frame->linesize[1]   = pitch;\n\n            tmp_frame->width         = avctx->width;\n\n            tmp_frame->height        = avctx->height;\n\n\n\n            ret = ff_get_buffer(avctx, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);\n\n            if (ret) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            av_frame_free(&tmp_frame);\n\n        } else {\n\n            ret = AVERROR_BUG;\n\n            goto error;\n\n        }\n\n\n\n        frame->width = avctx->width;\n\n        frame->height = avctx->height;\n\n        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n            frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);\n\n        else\n\n            frame->pts = dispinfo.timestamp;\n\n\n\n        /* CUVIDs opaque reordering breaks the internal pkt logic.\n\n         * So set pkt_pts and clear all the other pkt_ fields.\n\n         */\n\n        frame->pkt_pts = frame->pts;\n\n        av_frame_set_pkt_pos(frame, -1);\n\n        av_frame_set_pkt_duration(frame, 0);\n\n        av_frame_set_pkt_size(frame, -1);\n\n\n\n        frame->interlaced_frame = !dispinfo.progressive_frame;\n\n\n\n        if (!dispinfo.progressive_frame)\n\n            frame->top_field_first = dispinfo.top_field_first;\n\n\n\n        *got_frame = 1;\n\n    } else {\n\n        *got_frame = 0;\n\n    }\n\n\n\nerror:\n\n    if (mapped_frame)\n\n        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));\n\n\n\n    eret = CHECK_CU(cuCtxPopCurrent(&dummy));\n\n\n\n    if (eret < 0)\n\n        return eret;\n\n    else\n\n        return ret;\n\n}\n", "idx": 7398, "substitutes": {"avctx": ["avcontext", "navcontext", "vercontext", "manctx", "avbc", "averkb", "avcca", "averbc", "avelc", "vercp", "navfw", "AVbc", "averctx", "avctl", "afctx", "avcp", "avecontext", "AVcp", "varcca", "afcp", "afcontext", "avlc", "avsync", "avecp", "Avctx", "afsync", "mancontext", "AVcontext", "Avbc", "affw", "navctx", "AVctx", "manlc", "afctl", "aflc", "manctl", "avkb", "avectx", "AVctl", "AVlc", "varfw", "afcca", "verctx", "AVkb", "Avkb", "varcontext", "avfw", "navcca", "avercontext", "versync", "avesync", "Avcontext", "varctx"], "data": ["batch", "context", "scope", "ui", "root", "new", "storage", "reader", "da", "sample", "def", "family", "package", "DATA", "value", "input", "result", "loader", "name", "message", "received", "Data", "val", "first", "raw", "open", "call", "slice", "dat", "style", "client", "buf", "record", "pad", "image", "channel", "module", "offset", "config", "device", "response", "video", "block", "read", "load", "volume", "content", "buffer", "next", "as", "start", "a", "parent", "cache", "media", "ad", "size", "database", "desc", "length", "format", "post", "addr", "missing", "body", "window", "after", "base"], "got_frame": ["filter_data", "filter_name", "filter_frame", "filter_time", "filter__time", "filter__frame", "filter__name", "filtervaldata", "filter__data", "filtervalname", "get_frame", "filtervaltime", "filtervalframe", "get_time", "get_data", "get_name"], "avpkt": [" avcpkt", "avpka", "ovpkt", "avefett", "avupce", "avjpnt", "avfpt", "avbpkt", "avbpett", "avfkh", "ajpka", "avpekt", "ajpekt", "avckg", "ovpbkt", "avbppt", "avpeacket", "avjpett", "avepck", "afpkh", "avfwk", "ovpbwk", "avepct", "aveppt", "avparamkt", "avparamiece", "avfdt", "avpbwk", "avPkt", "avpece", "afpdt", "avcpwk", "avpdt", "avpkh", "avpbqt", "avpacket", "avlpke", "avjpiece", "affkg", "avepett", "avciece", "avnpnt", "avnppt", "avpnt", " avpke", "ovpwk", "avjpkt", "afpiece", "avpkg", "ajpece", "avpeka", "ovpqt", "afpwk", "avfett", "avfka", "avcpdt", " avcpacket", "avpbkt", "avfkt", "afpkg", "avnpett", "avlpiece", " avpacket", "avpett", "avckt", "avnacket", "ajpeka", "ovpbacket", "afpkt", "avefpt", "avcpacket", "ajpacket", "avcacket", "avnqt", "affkh", "afpacket", "avlpkh", "avcompdt", "avfkg", "avPkg", "avefkt", "avparamkh", "avepnt", "avpwk", "avefct", " avcpke", "avepkt", "avbpct", "avlpkg", "avppt", "avfqt", "affkt", "avjpacket", "avPke", "aveppck", "avpct", "avpke", "avnpkt", "avfct", "avcompkt", "ajpkt", "ajpeacket", "affwk", "affiece", "aveppett", "avpck", "avcpkg", " avpkg", "avnpck", "avppkt", "ovpacket", "avupkt", "avfce", "avjpkg", "avlpacket", "avparamacket", "avppck", "aveppnt", "avcompacket", "avpbacket", "avupka", "ovpbqt", "aveppkt", "avppett", "ajpce", "avPacket", "avjpck", "avnkt", "affdt", "avpce", "affacket", " avcpkg", "avpqt", "avnpct", "avppnt", "avfiece", "avupacket", "avnwk", "avlpkt", "avpiece", "avfacket", "avcpkt", "avcompwk", "avcpke"], "ctx": ["context", "cfg", "nc", "sci", "scope", "pc", "conv", "np", "sq", "wcs", "loc", "component", "hub", "cc", "anc", "event", "sync", "connection", "kw", "cus", "client", " context", "conn", "sc", "xc", "ct", "cm", "config", "cmd", "lib", "cca", "tx", "Context", "cms", "ck", "c", "instance", "bc", "kb", "ctrl", "cv", "cam", "pkg", "hw", "conf", "qa", "mac", "concept", "cu", "cf", "ca", "prefix", "tc", "nt", "cn", "ci", "lc", "cas", "qt", "cmp", "vc", "cp", "ha", "window"], "device_ctx": ["device__conn", "device__tx", "device_context", "device_pkg", "device__loc", "device_tx", "device_conn", "dev_ctx", "dev_conn", "dev_pkg", "device__pkg", "dev_context", "dev_loc", "dev_tx", "device__context", "device_loc", "device__ctx"], "device_hwctx": ["device_bootcontext", "device_wcontext", "device_fwconfig", "device_bootconn", "device_hwcmp", "device_bootconfig", "device_fwctx", "device_hawcontext", "device_bootcmp", "device_hwconn", "device_wcmp", "device_fwconn", "device_wctx", "device_bootctx", "device_fwcmp", "device_hawconn", "device_hawctx", "device_fwcontext", "device_hwconfig", "device_hwcontext", "device_hawconfig", "device_wconfig"], "dummy": ["sao", "dnp", "summies", "ndummies", "ndao", "odummy", "ndnp", "odao", "snp", "summy", "dao", "dummies", "ndummy", "odnp", "odummies"], "frame": ["object", "family", "element", "frames", "component", "document", "shot", "event", "slice", "session", "flow", "iframe", "seq", "ace", "image", "channel", "module", "config", "block", "instance", "buffer", "point", "Frame", "part", "fram", "board", "setup", "window"], "cupkt": ["cupkid", "rupkid", "cfkt", "cupett", " cuptxt", "cmpnt", "appelt", " cupacket", "uptxt", "supacket", "rupnt", "upkt", " cupnt", "cuptxt", "appcht", "cppcht", "cfelt", "cfcht", "cfett", "cmpKT", " cupcht", "rupdt", "uptKT", "cpkt", "cupnt", "cppdt", "copcht", "rupkt", "upnt", "cpnt", "rupett", "uptacket", "supkt", "appkt", " cupkid", "supett", "copacket", "supnt", "cpacket", "copkt", "uptkt", "upacket", " cupelt", "cupdt", "cmpett", "cupacket", " cupett", "cupKT", "cppkt", "rupcht", "upttxt", " cupKT", "cupcht", "cmpkt", "copdt", "cpkid", "cupelt", "uptnt", "rupacket", "cppacket", "cmpacket", "appett"]}}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n", "idx": 7420, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)\n\n{\n\n    __asm__ volatile(\n\n        \"movdqa   0x10(%1), %%xmm1 \\n\"\n\n        \"movdqa   0x20(%1), %%xmm2 \\n\"\n\n        \"movdqa   0x30(%1), %%xmm3 \\n\"\n\n        \"movdqa   0x50(%1), %%xmm5 \\n\"\n\n        \"movdqa   0x60(%1), %%xmm6 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm7 \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)\n\n        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))\n\n        \"paddw          %4, %%xmm4 \\n\"\n\n        \"movdqa     %%xmm4, 0x00(%1) \\n\"\n\n        \"movdqa     %%xmm2, 0x40(%1) \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)\n\n        \"movdqa     %%xmm6, 0x60(%1) \\n\"\n\n        \"movdqa     %%xmm7, 0x70(%1) \\n\"\n\n        \"pxor       %%xmm7, %%xmm7 \\n\"\n\n        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)\n\n        \"lea     (%0,%2,4), %0 \\n\"\n\n        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)\n\n        \"movdqa   0x60(%1), %%xmm0 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm1 \\n\"\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)\n\n        :\"+r\"(dst)\n\n        :\"r\"(block), \"r\"((x86_reg)stride), \"r\"((x86_reg)3L*stride), \"m\"(ff_pw_32)\n\n    );\n\n}\n", "idx": 7428, "substitutes": {"dst": ["Dfe", " dsc", "fst", "Dbl", "dfe", "Dst", "Dsc", "fsc", " dfe", "dsc", "ffe", "fbl", " dbl", "dbl"], "block": ["batch", "Block", "frame", "end", "def", "pre", "name", "len", "none", "self", "blocks", "no", "prev", "type", "buf", "stop", "orig", "num", "out", "off", "device", "ip", "buffer", "w", "lock", "row", "unit"], "stride": ["estide", " strider", "estiding", "striding", "strider", "Striding", "strides", " striding", " strides", "Stride", "estider", "estides", "Strides", "Strider"]}}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n    unsigned int oldsize;\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    stw(p + 0, 0x0040);\n\n    stw(p + 1, s->cylinders); \n\n    stw(p + 3, s->heads);\n\n    stw(p + 4, 512 * s->sectors); /* sectors */\n\n    stw(p + 5, 512); /* sector size */\n\n    stw(p + 6, s->sectors); \n\n    stw(p + 20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n", "idx": 7430, "substitutes": {"s": ["comm", "ans", "d", "sync", "site", "sg", "services", "fs", "f", "sv", "b", "side", "conf", "v", "data", "sq", "lines", "sb", "params", "h", "ses", "r", "cs", "sf", "ions", "ss", "ts", "t", "ns", "sa", "a", "its", "w", "sis", "es", "ins", "hs", "parts", "sys", "ls", "session", "S", "ps", "gs", "sets", "xs", "n", "c", "g", "us", "ssl", "sl", "state", "qs", "rs", "spec", "si", "y", "aws", "j", "e", "tp", "is", "service", "ds", "l", "states", "sie", "sym", "m", "as", "settings", "i", "o", "words", "js", "os"], "p": ["br", "pi", "pc", "np", "d", "er", "api", "mp", "up", "pr", "dp", "per", "ip", "f", "lp", "pe", "b", "fp", "v", "data", "pb", "k", "vp", "prev", "r", "u", "current", "sp", "ap", "hp", "t", "page", "or", "wp", "a", "part", "q", "pat", "pre", "pg", "ps", "patch", "P", "n", "jp", "press", "c", "tmp", "g", "pp", "it", "bp", "post", "cp", "x", "y", "j", "proc", "progress", "e", "pl", "tp", "op", "pa", "pop", "at", "pro", "l", "m", "pointer", "point", "i", "o", "ph", "z", "po", "port"], "oldsize": ["prevsize", "lowsmall", "oldweight", "OLDshape", " oldloc", "OLDweight", "oldloc", "Oldsize", "OLDSIZE", " oldweight", " oldshape", "prevshape", "olderaddress", "olderweight", " oldSIZE", "OLDsmall", "OLDloc", "prevscale", "lowsize", "OLDaddress", "oldshape", "oldscale", "oldSIZE", "oldSize", " oldSize", "OLDscale", "oldersize", " oldsmall", "oldersmall", "Oldsmall", "lowloc", "OLDsize", "prevSIZE", " oldaddress", "lowaddress", "Oldaddress", "oldaddress", "oldsmall", "OLDSize", " oldscale", "OldSize"]}}
{"project": "FFmpeg", "commit_id": "7ec9c5ce8a753175244da971fed9f1e25aef7971", "target": 0, "func": "static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n\n                       const AVFrame *pict, int *got_packet)\n\n{\n\n    PNGEncContext *s = avctx->priv_data;\n\n    int ret;\n\n    int enc_row_size;\n\n    size_t max_packet_size;\n\n    APNGFctlChunk fctl_chunk = {0};\n\n\n\n    if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));\n\n\n\n        if (avctx->frame_number == 0) {\n\n            s->palette_checksum = checksum;\n\n        } else if (checksum != s->palette_checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input contains more than one unique palette. APNG does not support multiple palettes.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);\n\n    max_packet_size =\n\n        AV_INPUT_BUFFER_MIN_SIZE + // headers\n\n        avctx->height * (\n\n            enc_row_size +\n\n            (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)\n\n        );\n\n    if (max_packet_size > INT_MAX)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (avctx->frame_number == 0) {\n\n        if (!pict)\n\n            return AVERROR(EINVAL);\n\n\n\n        s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);\n\n        if (!avctx->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = encode_headers(avctx, pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avctx->extradata_size = s->bytestream - avctx->extradata;\n\n\n\n        s->last_frame_packet = av_malloc(max_packet_size);\n\n        if (!s->last_frame_packet)\n\n            return AVERROR(ENOMEM);\n\n    } else if (s->last_frame) {\n\n        ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n\n        pkt->size = s->last_frame_packet_size;\n\n        pkt->pts = pkt->dts = s->last_frame->pts;\n\n    }\n\n\n\n    if (pict) {\n\n        s->bytestream_start =\n\n        s->bytestream       = s->last_frame_packet;\n\n        s->bytestream_end   = s->bytestream + max_packet_size;\n\n\n\n        // We're encoding the frame first, so we have to do a bit of shuffling around\n\n        // to have the image data write to the correct place in the buffer\n\n        fctl_chunk.sequence_number = s->sequence_number;\n\n        ++s->sequence_number;\n\n        s->bytestream += 26 + 12;\n\n\n\n        ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        fctl_chunk.delay_num = 0; // delay filled in during muxing\n\n        fctl_chunk.delay_den = 0;\n\n    } else {\n\n        s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;\n\n    }\n\n\n\n    if (s->last_frame) {\n\n        uint8_t* last_fctl_chunk_start = pkt->data;\n\n        uint8_t buf[26];\n\n\n\n        AV_WB32(buf + 0, s->last_frame_fctl.sequence_number);\n\n        AV_WB32(buf + 4, s->last_frame_fctl.width);\n\n        AV_WB32(buf + 8, s->last_frame_fctl.height);\n\n        AV_WB32(buf + 12, s->last_frame_fctl.x_offset);\n\n        AV_WB32(buf + 16, s->last_frame_fctl.y_offset);\n\n        AV_WB16(buf + 20, s->last_frame_fctl.delay_num);\n\n        AV_WB16(buf + 22, s->last_frame_fctl.delay_den);\n\n        buf[24] = s->last_frame_fctl.dispose_op;\n\n        buf[25] = s->last_frame_fctl.blend_op;\n\n        png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);\n\n\n\n        *got_packet = 1;\n\n    }\n\n\n\n    if (pict) {\n\n        if (!s->last_frame) {\n\n            s->last_frame = av_frame_alloc();\n\n            if (!s->last_frame)\n\n                return AVERROR(ENOMEM);\n\n        } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            if (!s->prev_frame) {\n\n                s->prev_frame = av_frame_alloc();\n\n                if (!s->prev_frame)\n\n                    return AVERROR(ENOMEM);\n\n\n\n                s->prev_frame->format = pict->format;\n\n                s->prev_frame->width = pict->width;\n\n                s->prev_frame->height = pict->height;\n\n                if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n\n                    return ret;\n\n            }\n\n\n\n            // Do disposal, but not blending\n\n            memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n\n                   s->last_frame->linesize[0] * s->last_frame->height);\n\n            if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {\n\n                uint32_t y;\n\n                uint8_t bpp = (s->bits_per_pixel + 7) >> 3;\n\n                for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n\n                    size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n\n                    memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);\n\n                }\n\n            }\n\n        }\n\n\n\n        av_frame_unref(s->last_frame);\n\n        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        s->last_frame_fctl = fctl_chunk;\n\n        s->last_frame_packet_size = s->bytestream - s->bytestream_start;\n\n    } else {\n\n        av_frame_free(&s->last_frame);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7448, "substitutes": {"avctx": ["afcb", "avalcit", "verconfig", "ivcdn", "avecu", "avloc", "AVpkg", "avconfig", "averlc", "verctl", "afctx", "auconn", "navctx", "avalctx", "versci", "afcdn", "aucu", "avcoll", " avcb", "afloc", "avcb", "afcmp", "avewindow", " avsci", "aucms", "navconn", "vercoll", "avepkg", "afcit", "umctrl", "avelc", "afsci", " avcu", "ivctx", "avecontext", "avcit", "ivctrl", "avpkg", "afcoll", "afconn", "afcu", "auloc", "auctrl", "navloc", "AVctx", "avesci", "umctx", "afctl", "aflc", "umcontext", "afpkg", "afcca", "AVcmp", "avercontext", "avcontext", "navcontext", "avsci", "avconn", "avwindow", "aupkg", "afcms", "avcca", "ivcu", "averctx", "AVconfig", "aucontext", "aucf", "verpkg", "AVcontext", "avcdn", "afctrl", "avcms", "afcf", "avcmp", "AVctl", "verctx", "vercca", "ivconn", "vercmp", "averwindow", "avecoll", " avpkg", "auctx", "vercontext", "avcu", "avalcontext", "afconfig", " avcontext", "vercf", "avectrl", "avctl", "avcf", "afcontext", "avlc", "avctrl", "avalcb", "afwindow", "avecb", "navcdn", "aucca", "umcms", "avectx", "avecit", "ivcontext"], "pkt": ["jpacket", " pqt", "Pnt", "jpnt", "Packet", "packet", " packet", "jpqt", "jpkt", " pnt", "pnt", "pqt", "Pqt", "Pkt"], "pict": ["sci", "photo", "sec", "proc", "capt", "enc", "fat", "Pic", "cot", "phot", "fi", "cli", "prev", "client", "png", "conn", "ct", "image", "img", " pic", "ch", "config", "csv", "obj", "txt", "picture", "aux", "quant", "tmp", "ctx", "chart", "pic", "act", "mot", "asa", "next", "bis", "lit", "chat", "cat", "imag", "cam", "gif", "qa", "feat", "conf", " img", "scroll", "Pict", "gui", "pty", " picture", "qq", "qt", "fig", " pictures", "doc", "cp", "stat"], "got_packet": ["got_framed", "got_paramets", "got_paramet", "got_duew", "got_framets", "got_framew", "got_paramed", "got_packew", "got_duets", "got_packed", "got_paramew", "got_dued", "got_packets", "got_duet", "got_framet"], "s": ["data", "storage", "sq", "aws", "e", "d", "si", "parts", "sb", "sys", "p", "sync", "ks", "ls", "session", "S", "params", "ps", "sc", "h", "is", "ses", "cs", "gs", "sets", "service", "u", "ds", "xs", "r", "stats", "n", "l", "sym", "ops", "ss", "c", "sg", "ts", "services", "t", "css", "m", "v", "uns", "g", "f", "ns", "space", "a", "ssl", "settings", "w", "o", "your", "sv", "js", "b", "es", "hs", "conf", "qs", "rs", "utils", "spec"], "ret": ["pet", "let", "ext", "re", "rc", "ref", "def", "mt", "result", "fun", "success", "alt", "att", "bf", "back", "error", "len", " RET", "val", " Ret", "mem", "bad", "arr", "std", "last", "bit", "num", "RET", "lt", "reg", "id", "res", "ut", "sr", "t", "fin", "pass", "lit", "cat", "max", "en", "flag", "part", "feat", "gt", "det", "ft", "al", "match", "nt", "code", "reply", "arg", "format", "rets", "Ret", "rt"], "enc_row_size": ["enc_row_number", "enc_row32size", "enc_row2time", "enc_col_size", "enc_row_sum", "enc_rows_width", "enc_row32offset", "enc_row_rate", "enc_row64size", "enc_row_offset", "enc_row1size", "enc_rows_rate", "enc_col_width", "enc_row64width", "enc_row2width", "enc_row2capacity", "enc_col_time", "enc_row_width", "enc_row32number", "enc_rows_sum", "enc_rows_offset", "enc_row_shift", "enc_rows_size", "enc_row1number", "enc_col_capacity", "enc_row64capacity", "enc_row_time", "enc_row1offset", "enc_rows_shift", "enc_row_capacity", "enc_rows_number", "enc_row2size", "enc_row64time"], "max_packet_size": ["max_packet_clean", "r", "max_packacket_clean", "max_packacket_size", "max_packet_number", "max_packacket_sized", "max_packacket_length", "max_packet_length", "g", "_", "feed", "max_packacket_address", "buffer", "max_packet_scale", "max_packacket_scale", "max_packet_address", "max_packacket_number", "max_packet_sized"]}}
{"project": "qemu", "commit_id": "d62b5dea30284eacd88055bb08db7c295655945f", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                                 QEMUIOVector *qiov, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,\n\n                              cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->rd_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7449, "substitutes": {"bs": ["iss", "pb", "fps", "lb", "db", "outs", "sb", "bid", "plugins", "nas", "sys", "bos", "sync", "blocks", "ks", "BS", "ls", "is", "ps", "vs", "ses", "cs", "gs", "bytes", "ds", "ubs", "fb", "obj", "s", "ob", "abi", "bes", "ss", "ts", "css", "obs", "bc", "fs", "ns", "bis", "us", "eb", "bu", "bits", "lc", "js", "b", "ins", "os", "banks", "bing", "bps", "bas", "las", "base"], "sector_num": ["sector_name", "sector_no", "section_sum", "sector_number", " sector_name", "section_range", "section_name", "section_id", " sector_no", "sector2name", "sector2no", "sector2number", "section_number", "sector_range", "sector_id", "sector2num", " sector_number", "section_num", "sector_sum"], "qiov": [" qregor", "qiop", "riov", "diov", "adiov", "qregor", "adicho", "Qiol", " qiop", "rovi", "Qiov", "dliv", " qovi", "qovi", "adiol", "Qicho", "qiol", "qicho", "diop", "riop", "qliv", "rliv", "adregor", " qiol", "dovi", " qicho", "Qregor", " qliv"], "nb_sectors": ["nb_secgments", "nb_SEriers", "nb_vections", "nb_geriers", "nb_serves", "nb_severs", "nb_seriers", "nb_sigments", "nb_gections", "nb_gearers", "nb_serctors", "nb_sector", "nb_seors", "nb_veriers", "nb_geors", "nb_sivers", "nb_semgments", "nb_secctors", "nb_sections", "nb_spectors", "nbjsemgments", "nb_secfs", "nb_searers", "nbjsectors", "nb_serctor", "nb_spearers", "nb_sictors", "nb_secctions", "nb_vector", "nb_spections", "nbjsemvers", "nb_seves", "nb_SEctors", "nb_vearers", "nb_semves", "nb_vefs", "nbjseves", "nbjsemves", "nb_servers", "nb_pegments", "nbjsevers", "nbjsegments", "nb_veivers", "nb_semvers", "nb_segments", "nb_pector", "nb_peivers", "nb_sefs", "nb_veors", "nb_SEors", "nb_gegments", "nb_gectors", "nbjsemctors", "nb_sergments", "nb_spegments", "nb_vegments", "nb_semctors", "nb_pectors", "nb_seivers", "nb_SEgments", "nb_vectors", "nb_spefs", "nb_sives", "nb_serivers"], "cb": ["unc", "pb", "func", "nc", "fn", "pc", "abb", "callback", "library", "cfg", "db", "fun", "bf", "sb", "gc", "buf", "kk", "cod", "bb", "cmd", "orb", "fb", "obb", "abc", "ob", "CB", "c", "ctx", "bc", "cv", "eb", "ec", "fc", "cf", "lc", "cd", "rb", "xb"], "opaque": ["iopesc", "ospatile", "uppacity", "opusaques", " opque", "ospaques", " opesc", "uppaque", "opatile", "opusatile", "octesc", "octacity", "octity", "opacity", " opity", "opity", "octaque", "copaque", "copec", "opaques", "iopacity", " opec", "ospacity", "ospaque", "iopaque", "uppec", "uppque", "copacity", " opacity", "opque", "opusaque", "opesc", "opusacity", " opatile", " opaques", "iopity", "copque", "opec"], "drv": [" drk", " drc", " drf", "srv", "hrV", "Drc", "hrk", "srb", "drk", "srm", "drb", " drm", "drc", " drV", "drm", "hrm", "drV", "srk", "hrv", "Drb", "drf", "srf", "hrf", " drb", "Drv", "hrc", "hrb", "Drf", "DrV"], "ret": ["real", "data", "re", "rc", "ref", "def", "result", "fun", "bf", "alt", "att", "back", "db", "len", "val", "str", "fi", "mem", "sys", "bare", "base", "gc", "bit", "RET", "resp", "out", "bot", "reg", "res", "ut", "obj", "cur", "fire", "secret", "ig", "f", "rev", "ben", "lit", "cat", "flag", "part", "feat", "gt", "det", "secondary", "ft", "info", "utf", "match", "reply", "nt", "bd", "job", "rb", "valid", "desc", "arg", "rets", "Ret", "rt"], "rd_ops": ["rd_bytes", "rs_ops", "rs_ips", "rd_bits", "rs_bytes", "rs_bits", "rd_ips"]}}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n", "idx": 7458, "substitutes": {"who": ["woman", "Who", "ou", "from", "da", "eth", "name", "hou", "staff", "hello", "cli", "where", "que", " Who", "ko", "wo", "hi", "nick", "har", "bo", "gram", "lo", "home", " wo", "cgi", "which", "what", "wa", "gob", "foo", "gh", "someone", "gmail", "organ", "wh", "la", "san", "how", "whe", "whose", "ha", "wife", "WHO"], "value": ["data", "new", "index", "set", "end", "name", "message", "key", "val", "server", "command", "function", "type", "style", "values", "update", "change", "password", "Value", "VALUE", "place", "content", "entry", "range", "money", "w", "valid", "state", "null", "how", "time", "unit", "v", "property", "format"], "rsp": ["srp", "Rsc", "nrsc", "yrps", " rsc", " risp", "srps", "srmp", "rsl", " rp", " rst", "srisp", "Rso", "rst", "srsp", " rps", "Rsp", " rso", "rrsp", "risp", " rsl", "rso", "srsl", "yrp", "rps", "rmp", "yrsp", "rsc", "yrmp", "nrsp", "rp", "srst", "Risp", "srsc", "rrsl", "rrst", "Rp", "nrso", "nrp", " rmp"], "cmd": ["msg", "func", "cfg", "help", "name", "cli", "call", "command", "cc", "gn", "src", "args", "gz", "buf", "client", "conn", "cod", "ack", "config", "dict", "id", "ind", "cookie", "obj", "ck", "c", "ctx", "path", "draw", "ctrl", "cl", "req", "cf", "prefix", "code", "reason", "md", "cd", "bind", "attr", "arg", "grad", "cb", "addr", "col", "comp", "cp", "cmp", "method", "Cmd"]}}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "func": "target_ulong do_arm_semihosting(CPUARMState *env)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong args;\n\n    target_ulong arg0, arg1, arg2, arg3;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = cs->opaque;\n\n#else\n\n    CPUARMState *ts = env;\n\n#endif\n\n\n\n    if (is_a64(env)) {\n\n        /* Note that the syscall number is in W0, not X0 */\n\n        nr = env->xregs[0] & 0xffffffffU;\n\n        args = env->xregs[1];\n\n    } else {\n\n        nr = env->regs[0];\n\n        args = env->regs[1];\n\n    }\n\n\n\n    switch (nr) {\n\n    case TARGET_SYS_OPEN:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        s = lock_user_string(arg0);\n\n        if (!s) {\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        }\n\n        if (arg1 >= 12) {\n\n            unlock_user(s, arg0, 0);\n\n            return (uint32_t)-1;\n\n        }\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n\n            unlock_user(s, arg0, 0);\n\n            return result_fileno;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,\n\n                                  (int)arg2+1, gdb_open_modeflags[arg1]);\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n\n        }\n\n        unlock_user(s, arg0, 0);\n\n        return ret;\n\n    case TARGET_SYS_CLOSE:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);\n\n        } else {\n\n            return set_swi_errno(ts, close(arg0));\n\n        }\n\n    case TARGET_SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case TARGET_SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",\n\n                                   args, len);\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case TARGET_SYS_WRITE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_READ, arg1, len, 1);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, write(arg0, s, len));\n\n            unlock_user(s, arg1, 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READ:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_WRITE, arg1, len, 0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            do {\n\n                ret = set_swi_errno(ts, read(arg0, s, len));\n\n            } while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, arg1, len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READC:\n\n       /* XXX: Read from debug console. Not implemented.  */\n\n        return 0;\n\n    case TARGET_SYS_ISTTY:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);\n\n        } else {\n\n            return isatty(arg0);\n\n        }\n\n    case TARGET_SYS_SEEK:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",\n\n                                   arg0, arg1);\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_FLEN:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",\n\n                                   arg0, arm_flen_buf(cpu));\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(arg0, &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case TARGET_SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case TARGET_SYS_REMOVE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",\n\n                                  arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, arg0, 0);\n\n        }\n\n        return ret;\n\n    case TARGET_SYS_RENAME:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        GET_ARG(3);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",\n\n                                   arg0, (int)arg1+1, arg2, (int)arg3+1);\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(arg0);\n\n            s2 = lock_user_string(arg2);\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, arg2, 0);\n\n            if (s)\n\n                unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case TARGET_SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case TARGET_SYS_SYSTEM:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",\n\n                                   arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case TARGET_SYS_GET_CMDLINE:\n\n        {\n\n            /* Build a command-line from the original argv.\n\n             *\n\n             * The inputs are:\n\n             *     * arg0, pointer to a buffer of at least the size\n\n             *               specified in arg1.\n\n             *     * arg1, size of the buffer pointed to by arg0 in\n\n             *               bytes.\n\n             *\n\n             * The outputs are:\n\n             *     * arg0, pointer to null-terminated string of the\n\n             *               command line.\n\n             *     * arg1, length of the string pointed to by arg0.\n\n             */\n\n\n\n            char *output_buffer;\n\n            size_t input_size;\n\n            size_t output_size;\n\n            int status = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n            const char *cmdline;\n\n#endif\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n            input_size = arg1;\n\n            /* Compute the size of the output string.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            cmdline = semihosting_get_cmdline();\n\n            if (cmdline == NULL) {\n\n                cmdline = \"\"; /* Default to an empty line. */\n\n            }\n\n            output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n\n#else\n\n            unsigned int i;\n\n\n\n            output_size = ts->info->arg_end - ts->info->arg_start;\n\n            if (!output_size) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                output_size = 1;\n\n            }\n\n#endif\n\n\n\n            if (output_size > input_size) {\n\n                 /* Not enough space to store command-line arguments.  */\n\n                return -1;\n\n            }\n\n\n\n            /* Adjust the command-line length.  */\n\n            if (SET_ARG(1, output_size - 1)) {\n\n                /* Couldn't write back to argument block */\n\n                return -1;\n\n            }\n\n\n\n            /* Lock the buffer on the ARM side.  */\n\n            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);\n\n            if (!output_buffer) {\n\n                return -1;\n\n            }\n\n\n\n            /* Copy the command-line arguments.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            pstrcpy(output_buffer, output_size, cmdline);\n\n#else\n\n            if (output_size == 1) {\n\n                /* Empty command-line.  */\n\n                output_buffer[0] = '\\0';\n\n                goto out;\n\n            }\n\n\n\n            if (copy_from_user(output_buffer, ts->info->arg_start,\n\n                               output_size)) {\n\n                status = -1;\n\n                goto out;\n\n            }\n\n\n\n            /* Separate arguments by white spaces.  */\n\n            for (i = 0; i < output_size - 1; i++) {\n\n                if (output_buffer[i] == 0) {\n\n                    output_buffer[i] = ' ';\n\n                }\n\n            }\n\n        out:\n\n#endif\n\n            /* Unlock the buffer on the ARM side.  */\n\n            unlock_user(output_buffer, arg0, output_size);\n\n\n\n            return status;\n\n        }\n\n    case TARGET_SYS_HEAPINFO:\n\n        {\n\n            target_ulong retvals[4];\n\n            uint32_t limit;\n\n            int i;\n\n\n\n            GET_ARG(0);\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                abi_ulong ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret >= limit) {\n\n                        break;\n\n                    }\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            retvals[0] = ts->heap_base;\n\n            retvals[1] = ts->heap_limit;\n\n            retvals[2] = ts->stack_base;\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#else\n\n            limit = ram_size;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            retvals[0] = limit / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 7462, "substitutes": {"env": ["context", "scope", "iss", "ext", "eve", "eu", "vm", "oa", "np", "proc", "end", "db", "loader", "e", "enc", "exc", "er", "exec", "server", "ea", "event", "que", "conn", "ace", "vs", "site", "ch", "config", "ev", "ne", "dict", "et", "stage", "txt", "net", "her", "init", "eng", "ctx", "bc", "engine", "nw", "host", "opt", "shell", "console", "inst", "osc", "ec", "en", "settings", "cache", "err", "dev", "cf", "manager", "python", "code", "inet", "eni", "exe", "state", "qt", "conf", "serv", "v", "environment"], "cpu": ["nc", "pc", "vm", "np", "proc", "gpu", "core", "anc", "sys", "gc", "pid", "conn", "cm", "processor", "config", "roc", "intel", "device", "nic", "ips", "jp", "uci", "hp", "bench", "net", "ck", "css", "ctx", "bc", "cr", "px", "boot", "platform", "cat", "mac", "hw", "gp", "fc", "cu", "phy", "sta", "cow", "python", "chip", "cn", "lc", "pu", "node", "rpm", "os", "cp", "linux", "computer", "CPU"], "cs": ["CS", "nc", "pc", "cc", "sys", "sync", "ks", "ls", "cus", "sc", "conn", "vs", "gs", "acs", "ds", "ars", "ss", "css", "ctx", "bc", "ns", "ants", "TS", "ec", "tc", "ci", "cas", "Cs", "vc", "cp", "rs", "utils", "spec"], "args": ["py", "data", "extra", "ext", "pc", "sec", "ras", "outs", "name", "parts", "enc", "call", "aug", "arr", "blocks", "afi", "params", "seq", "uments", "gs", "alls", "bytes", "cmd", "Args", "stats", "obj", "ars", "ids", "all", "actions", "aux", "strings", "ns", "arms", "ig", "array", "max", "vals", "ants", "flags", "alloc", "ints", "code", "active", "arg", "ins", "count", "results", "binary", "stat", "asm"], "arg0": ["args0", "Arg11", "ax6", "val0", "argname", "Arg6", "argument4", "Arg8", "ag1", "param0", "ax1", "args1", "val1", "param1", " arg4", "ag90", "arg4", "ag0", "param2", "arg6", " arg11", "args4", "paramname", "argsname", "Arg1", "ax0", "ag2", "val11", "Arg90", "args2", " arg8", "arg8", "Arg0", "param8", "val2", "argument1", " arg90", "ax2", "argument0", "argument2", "arg90", " argname", "arg11", "Arg2", " arg6"], "arg1": ["arg01", "args0", "ar0", "argument5", " argX", " arg01", "ax1", "ag1", "param0", " arg5", "ar2", "args1", "arg5", "argX", "agX", "param1", "args3", "ag0", "param2", "Arg3", "Arg1", "Arg01", "ax0", "ag2", "ar1", "ar3", "args2", "Arg0", "ax01", "argument1", "param5", "ax2", "argsX", "argument0", "argument2", "Arg2"], "arg2": ["argument4", "args1", "argument3", " arg4", "arg4", "Arg3", "args4", "Arg1", "args2", " arg8", "argument8", "arg8", "Arg0", "args8", "argument1", "argument0", "argument2", "Arg2"], "arg3": ["argument3", "argument1", "argument63", "param3", "param1", "argument2", "arg63", " arg63", "param2", "param63"], "s": ["sid", "opens", "str", "sync", "site", "sr", "sg", "services", "strings", "fs", "f", "sv", "b", "ruby", "sq", "input", "submit", "sb", "h", "ses", "r", "u", "sf", "sp", "ss", "t", "uns", "ns", "sa", "your", "status", "hs", "ins", "sys", "p", "ks", "ls", "session", "S", "ps", "gs", "sets", "stats", "n", "g", "shell", "ssl", "sl", "su", "rs", "spec", "si", "y", "aws", "e", "server", "socket", "is", "service", "ds", "l", "states", "sie", "m", "sym", "sn", "settings", "secondary", "o", "js", "os"], "nr": [" sr", "ru", "nc", "np", "ng", "number", "ner", "nu", "loc", "result", "vr", "rx", "rf", "rg", "nz", "num", "r", "nic", "inv", "usr", " ni", "rr", "ni", "n", "rn", "lr", "sr", "mr", "nir", "nb", "nl", "next", "nw", "rev", "sn", "wr", "nor", "yr", "kr", "cn", "gr", "rb", "rin", "arin", "nar", "rl", "NR", "cb", "radius", "chain", "addr", "attr", "rel", "nos", "adr", "rob"], "ret": [" sr", "br", "sum", "re", "ref", "result", "success", " reply", "alt", "fun", "sun", "back", "value", " returns", "str", "val", " arg", "mem", "arr", "std", "num", "RET", " ar", "out", "resp", "reg", "id", " result", "res", " arr", "obj", "sr", "run", "rev", "lit", "cat", "fit", "flag", " flags", "feat", "info", "det", "reply", "nt", "job", "rb", " res", "active", "arg", "addr", "status", "rets", "Ret", "rt"], "len": ["Len", "pos", "sec", "loc", "alt", "enc", "val", "str", "mem", "arr", "lang", "seq", "resp", "bytes", "obj", "rot", "all", "rev", "flag", "bin", "gen", "length", "arg", "ln", "lock", "base"], "ts": ["scope", "options", "pc", "mt", "ats", "ets", "fts", "tp", "sys", "tty", "ks", "ls", "times", "ps", "uts", "vs", "ses", "acs", "gs", "alls", "Ts", "ds", "tt", "rets", "stats", "xs", "tx", "ars", "states", "ops", "ss", "t", "ta", "fs", "tr", "ns", "te", "ms", "as", "us", "TS", "tc", "ics", "ins", "hs", "qs", "rs", "tz"]}}
{"project": "FFmpeg", "commit_id": "1f28a991effadc64acd6915805b989ab43500f08", "target": 0, "func": "static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n\n                                         void *logctx, int size)\n\n{\n\n    uint8_t *user_data;\n\n    int e, build, i;\n\n\n\n    if (size < 16 || size >= INT_MAX - 16)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    user_data = av_malloc(16 + size + 1);\n\n    if (!user_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < size + 16; i++)\n\n        user_data[i] = get_bits(gb, 8);\n\n\n\n    user_data[i] = 0;\n\n    e = sscanf(user_data + 16, \"x264 - core %d\", &build);\n\n    if (e == 1 && build > 0)\n\n        h->x264_build = build;\n\n    if (e == 1 && build == 1 && !strncmp(user_data+16, \"x264 - core 0000\", 16))\n\n        h->x264_build = 67;\n\n\n\n    if (strlen(user_data + 16) > 0)\n\n        av_log(logctx, AV_LOG_DEBUG, \"user data:\\\"%s\\\"\\n\", user_data + 16);\n\n\n\n    av_free(user_data);\n\n    return 0;\n\n}\n", "idx": 7471, "substitutes": {"h": ["ih", "him", "hub", "self", "p", "uh", "rh", "hr", "hi", "u", "hm", "hl", "hu", "eh", "hp", "hh", "m", "c", "v", "hd", "g", "host", "f", "oh", "ah", "hw", "gh", "ph", "o", "H", "bh", "he", "b", "http", "ha", "ht"], "gb": ["py", "ui", "cfg", "abb", "gm", "uu", "pc", "storage", "db", "bf", "sb", "hub", "mb", "rg", "gam", "bm", "gc", "gg", "sc", "gs", "bb", "lib", "gram", "buff", "gd", "cgi", "gl", "bg", "gin", "bc", "g", "kb", "usb", "GB", "gp", "gi", "ga", "cb", "gu"], "logctx": [" logContext", "logconn", "signtx", "signconn", "signcontext", " logloc", "LOGcontext", "debugctx", "debugcontext", " logtx", "plugcontext", "LOGloc", "logtx", "debugconn", " logcontext", "plugContext", " logconn", "plugctx", "logloc", "plugloc", "logcontext", "LOGContext", "debugtx", "LOGctx", "signctx", "logContext"], "size": ["small", "scale", "loc", "name", "si", "len", "core", "p", "sync", "esc", "SIZE", "empty", "use", "n", "large", "s", "ize", "sized", "c", "Size", "address", "g", "capacity", "sn", "max", "en", "security", "fee", "code", "ci", "z", "shape", "length", "time", "six", "count", "year"], "user_data": ["user_dat", "user_space", "user_entry", "custom_div", " user_parent", " user_keys", " user_message", "user_DATA", "human_dat", "custom_name", "user_parent", "human_name", "user__dat", "human_data", " user_body", "user_scale", " user_entry", "user_batch", " user_batch", " user_Data", "user_image", " user_shift", "user__alpha", " user_alpha", "user_keys", "user_alpha", "user_message", "custom_config", "user_body", " user_dat", " user_scale", "user__data", "custom_data", "user_Data", "user_config", " user_image", "user_shift", "user_div", "user__DATA", " user_space", " user_DATA", "human_Data", "user_name"], "e": ["ie", "j", "d", "ae", "element", "er", "len", "ele", "ea", "fe", "p", " E", "ce", "ace", "r", "ne", "ev", "u", "ze", "n", "l", "ef", "c", "eng", "E", "g", "f", "ed", "oe", "be", "en", "ec", "el", "se", "o", "code", "pe", "ge", "edge", "anne", "b", "es", "ee", "v", "ell", "x"], "build": ["builder", "scale", "d", "rh", "built", "ace", "hold", "add", "f", "range", "ride", "pe", "b", "count", "row", "unit", "lock", "v", "enc", "get", "disable", "grade", "test", "clean", "bug", "r", "u", "ind", "run", "other", "start", "code", "shape", "pull", "style", "uild", "image", "use", "win", "Build", "n", "c", "all", "g", "ro", "building", "length", "round", "work", "replace", "fail", "loc", "core", "create", "l", "dy", "max", "se", "o", "release", "update"], "i": ["ui", "bi", "y", "index", "pi", "k", "ie", "j", "di", "d", "multi", "fi", "cli", "li", "p", "vi", "ti", "yi", "api", "mi", "phi", "qi", "ii", "adi", "r", "u", "id", "n", "l", "ni", "ip", "m", "c", "t", "ori", "oi", "f", "io", "ini", "o", "gi", "mu", "x", "xi", "uri", "it", "eni", "ci", "z", "b", "in", "iu", "I", "ai", "v", "si"]}}
{"project": "FFmpeg", "commit_id": "ae21776207e8a2bbe268e7c9e203f7599dd87ddb", "target": 0, "func": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    int i;\n\n\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_samples = dst->filter_samples))\n\n        filter_samples = avfilter_default_filter_samples;\n\n\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n\n        dst->rej_perms & samplesref->perms) {\n\n\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n\n                                                          samplesref->audio->nb_samples);\n\n        link->cur_buf->pts                = samplesref->pts;\n\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n\n\n        /* Copy actual data into new samples buffer */\n\n        for (i = 0; samplesref->data[i]; i++)\n\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n\n\n        avfilter_unref_buffer(samplesref);\n\n    } else\n\n        link->cur_buf = samplesref;\n\n\n\n    filter_samples(link, link->cur_buf);\n\n}\n", "idx": 7472, "substitutes": {"link": ["low", "msg", "frame", "set", "mm", "back", "sync", "slice", "rock", "type", "kick", "ace", "bridge", "ack", "contact", "ip", "add", "ink", "hip", "arg", "ln", "lock", "li", "local", "key", "co", "call", "channel", "bug", "load", "ck", "lag", "address", "path", "network", "group", "light", "loop", "match", "code", "Link", "mail", "url", "slave", "self", "connection", "links", "style", "flow", "image", "line", "lib", "plugin", "block", "plug", "friend", "entry", "comment", "check", "model", "ad", "list", "lf", "like", "lan", "post", "cell", "feed", "tag", "di", "play", "loc", "e", "zip", "lang", "linked", "service", "head", "l", "dd", "hack", "source", "info", "dev", "user", "ci", "band", "pack"], "samplesref": ["tampsRef", "sancesREF", "sampsrel", "damplesdiff", "samplesre", "samplepart", "sessionsref", "sizesref", "simensreference", "sacksref", "simensref", "tamplesREF", "simenspart", "sessionsob", "sizeslf", " samplesREF", "simenslf", " samplesrel", "sampleslf", "sificationsrel", "sacksreference", "sampleRef", "sessionsrel", "tampsrel", "sacksdiff", "sourcesrel", " sannelshard", " salesRef", "sampsrec", "sipsref", "sipesRef", "sourcesRef", "smodelsref", "tampslf", " sampsref", "salesref", " sagesREF", "dampsreference", "simsdiff", "sifiersRef", " sagesRef", "samplespart", "sannelshard", "sampsreference", "sacksrel", "lamplesob", "damplesRef", "damplesREF", "sessionsRef", "lampsRef", "simsRef", "dampsrel", "sourcesREF", " sannelsrel", "lamplesalt", "smodelsREF", "tamplesref", " sampsRef", "sagesref", "samplere", "sannelsref", "samplesrel", " sampsREF", "tampspart", "sifiersreference", "samplelf", "sampsdiff", "sessionsREF", "lamplesref", "sipsRef", "sipsREF", "sanceshard", "sampsalt", "samplealt", " sannelsref", "sampsob", "sampsRef", "lampsob", " sagesref", "sipsreference", "sifiersdiff", "sagesRef", "lamplesRef", "sificationsref", "smodelsRef", "sampsre", "sacksRef", "sificationsre", " samplesRef", "samplesRef", "samplesREF", "tampleslf", "sessionsreference", "sannelsrel", "sagesREF", " sampleshard", "tampsREF", " samplesreference", " saleslf", "damplesrel", "sampleshard", "sacksrec", "sampslf", "sifiersREF", "sourcesref", "sancesref", "saleslf", "tampsref", "sancesrel", "sessionsrec", " sampsreference", "sessionsalt", "sificationsreference", "damplesreference", " salesref", "samplerel", "sampspart", "samplesrec", "sifiersref", "sampleob", "tamplesrel", " sannelsREF", " sampleslf", "samplesdiff", "samplesreference", "sipesref", "sifiersrel", "damplesre", "sampsREF", "sizesRef", "sampleREF", "dampsref", "tamplesrec", "tamplesreference", "dampsREF", "smodelsrel", "sannelsREF", "tamplespart", "dampsre", "tampsrec", "sifiershard", "tamplesRef", "tampsreference", "lampsref", "samplesob", "samplereference", "dampsRef", "lampsalt", "salesRef", "sipesreference", "simsref", "simsreference", "sampleref", "samplesalt", "sampsref", "dampsdiff", "damplesref", "sipesREF"], "filter_samples": ["filter_lamples", "filter_gamps", "filter_sources", "filter_haves", "filter_tamps", "filter_tamples", "filter_sounds", "filter_vipes", "filter_vamples", "filter_servicesamps", "filter_nources", "filter_vamps", "filter_lamp", "filter_scounds", "filter_servicesamples", "filter_asamps", "filter_bamps", "filter_sample", "filter_pources", "filter_bones", "filter_namps", "filter_gages", "filter_sanguages", "filter_solutions", "filter_panguages", "filter_symample", "filter_pample", "filter_scamps", "filter_saves", "filter_lipes", "filter_golutions", "filter_asources", "filter_insamps", "filter_vones", "filter_sones", "filter_symamples", "filter_bamp", "filter_pipes", "filter_insample", "filter_lamps", "filter_sipes", "filter_scaves", "filter_asipes", "filter_pamples", "filter_hamples", "filter_tolutions", "filter_asamples", "filter_nipes", "filter_scamples", "filter_bamples", "filter_hamps", "filter_gamples", "filter_sages", "filter_tages", "filter_samp", "filter_insamples", "filter_pamps", "filter_samps", "filter_hounds", "filter_servicesages", "filter_namp", "filter_servicesolutions", "filter_namples", "filter_insanguages", "filter_nones", "filter_symanguages", "filter_symamps", "filter_paves", "filter_bipes", "filter_pounds"], "dst": [" dsc", "fdost", " dost", "Dnd", "madtd", "datct", "sdsts", " dbl", "madst", "pdST", "dnd", "sdtd", "madput", "pdsts", "dST", " dsts", " dnd", "madsts", "bst", "sdput", " dsp", "dtd", "fdst", "sdbl", "bsts", "fdft", "dput", "sdft", "Dost", "mdsts", "dbl", "dsp", "fST", "datsc", "dost", "sdct", " dct", "mdst", "adsp", "dct", "bput", "nst", "btd", "nost", "fdsc", "drbl", "nnd", "sdost", "nsts", "mdsc", "adsc", " dft", "fput", "fsts", "datst", "dsts", "adst", " dput", "fst", "pdput", "mdsp", "drct", "drst", "Dst", "dsc", "adsts", "drsts", "datput", "bST", "pdst", "Dsts", "sdst", "dft", "sdsc"], "i": ["ui", "bi", "y", "pi", "index", "k", "ie", "j", "di", "e", "d", "mini", "multi", "fi", "ti", "p", "yi", "h", "mi", "phi", "image", "qi", "ii", "hi", "u", "line", "ji", "id", "n", "l", "ni", "ip", "c", "m", "init", "t", "ix", "oi", "f", "zi", "io", "a", "ri", "ini", "info", "gi", "mu", "xi", "x", "loop", "uri", "ci", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"]}}
{"project": "qemu", "commit_id": "d85937e683f6ff4d68293cb24c780fb1f6820d2c", "target": 0, "func": "static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    qemu_irq *mpic;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    int i, j, k;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n    dev = qdev_create(NULL, \"openpic\");\n\n    qdev_prop_set_uint32(dev, \"nb_cpus\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"model\", params->mpic_version);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n\n\n    k = 0;\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_connect_irq(s, k++, irqs[i][j]);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n", "idx": 7480, "substitutes": {"params": ["data", "options", "proc", "param", "mm", "coll", "details", "api", "args", "ps", "conn", "gs", "config", "par", "ds", "ips", "pro", "Par", "res", "cms", "ops", "services", "ram", "ctx", "tmp", "ams", "mac", "cam", "master", "settings", "names", "lp", "Param", "js", "cmp", "conf", "phys", "spec"], "ccsr": ["rcsr", "nctr", "rcSR", "ccsw", "rctr", "ucSR", "pctr", "cfsr", " ccsu", " cctr", "pcsr", "cctr", "ncsu", "cfSR", "ccrs", "rcrs", " ccsw", "ncsw", "ucrs", "uctr", "ccSR", "cftr", "pcsu", "cfrs", "ucsr", "ncsr", "ccsu", "pcsw"], "irqs": ["mirqi", "ierqs", "irqi", "mirows", "irq", "mirasks", "IRows", "IRq", "irows", " irows", "mirqs", "ierq", " irasks", "mirq", " irq", "ircs", "IRcs", " irqi", "ierqi", " ircs", "irasks", "mircs", "IRqs", "ierasks"], "mpic": [" mpik", "compac", "mpric", "ompik", "pmic", "Mpric", "ompIC", " mpIC", "mbic", "mpIC", "MpIC", "ppic", "ppics", "compice", "mbice", "cmpic", " mpics", "cmpik", "ompic", "ppik", " mpric", "compic", "pmac", "Mpik", "mpics", "mpice", "pmice", "cmpics", "ompric", "mbics", "mpik", "mbac", "ompics", "cmpIC", "compics", "mpac", "pmics", "ppric", "Mpic"], "dev": ["data", "Dev", "dn", "google", "dist", "def", "od", "di", "rad", "development", "de", "gu", "d", "adv", "diff", "error", "ve", "p", "DEV", "app", "conn", "test", "bug", "ev", "prom", "ch", "device", "pro", "dd", "var", "temp", "gd", "sh", "c", "dc", "des", "g", "mod", "serial", "hw", "cam", "der", "info", "w", "ver", "ad", "nt", "md", "cd", "valid", "sd", "sk", "grad", "priv", "dem", "conf", "v", "driver", "spec"], "s": ["storage", "private", "aws", "e", "d", "sb", "server", "sys", "self", "p", "sync", "session", "S", "h", "ps", "is", "cs", "r", "gs", "u", "service", "ds", "device", "n", "ss", "m", "c", "sg", "sh", "t", "services", "fs", "g", "f", "ns", "ssl", "w", "o", "sl", "js", "sk", "b", "sd", "su", "es", "os", "conf", "v", "spec"], "i": ["ui", "bi", "y", "pi", "index", "ie", "di", "name", "e", "d", "ik", "multi", "fi", "p", "yi", "api", "h", "is", "mi", "phi", "qi", "ii", "ki", "u", "inner", "ji", "id", "n", "l", "ni", "ip", "abi", "c", "m", "init", "t", "ix", "oi", "f", "zi", "io", "ri", "a", "ini", "info", "o", "it", "gi", "x", "xi", "uri", "ci", "eni", "lc", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"], "j": ["ui", "br", "y", "ie", "aj", "name", "e", "d", "si", "key", "jc", "p", "bj", "jl", "ij", "qi", "ii", "r", "ch", "u", "ji", "dj", "je", "n", "l", "jp", "obj", "jo", "m", "c", "t", "g", "f", "ja", "jj", "uj", "kj", "jet", "err", "o", "xi", "fr", "job", "z", "js", "b", "q", "oj", "v", "J", "x", "li"], "k": ["kh", "y", "kid", "e", "ik", "key", "p", "ks", "kw", "K", "kick", "kk", "sc", "ki", "u", "id", "n", "l", "ck", "m", "c", "ek", "g", "mk", "dk", "w", "kn", "o", "km", "uk", "ky", "z", "sk", "b", "ok", "q", "ke", "work", "v", "spec"]}}
{"project": "qemu", "commit_id": "33577b47c64435fcc2a1bc01c7e82534256f1fc3", "target": 0, "func": "CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n", "idx": 7481, "substitutes": {"label": ["url", "lab", "package", "name", "text", "loc", "message", "key", "bool", "abel", "bl", "Label", "username", "position", "config", "plugin", "file", "l", "il", "summary", "f", "address", "path", "description", "concept", "prefix", "lp", "code", "desc", "alias", "col", "fp", "title", "binary", "property", "format"], "filename": ["fn", "phrase", "url", "Filename", "loader", "name", "queue", "document", "nil", "metadata", "params", "bl", "buf", "seq", "username", "sf", "fb", "file", "l", "files", "txt", "fd", "fil", "kl", "il", "f", "nl", "path", "source", "initial", "prefix", "utf", "uri", "lp", "actual", "rl", "dll", "fp", "title", "binary", "directory", "format"], "init": ["cfg", "storage", "reset", "help", "seed", "set", "sleep", "auth", "initialized", "open", "op", "sync", "cli", "done", "orig", "use", "config", "empty", "inner", "create", "stat", "id", "ic", "n", "load", "c", "ctx", "transfer", "boot", "Init", "ix", "opt", "start", "initial", "i", "info", "alloc", "it", "ci", "state", "gen", "setup", "cb", "os", "format"], "p": ["data", "pat", "pb", "pos", "pc", "np", "j", "vp", "pre", "param", "e", "tp", "op", "args", "params", "pid", "type", "pair", "ps", "r", "patch", "P", "l", "n", "ip", "jp", "c", "m", "t", "f", "pointer", "path", "primary", "pp", "array", "prop", "a", "wp", "part", "i", "o", "prefix", "lp", "pe", "bp", "b", "fp", "cp", "parser"], "chr": ["chesr", "checr", "schrb", " chrc", "gyr", " chrg", "chru", "Chr", "schr", "candr", "chsr", "cherc", "anchr", "candrr", "Chrc", "cherg", "schcr", "chrr", "chert", "CHru", "ichar", "anchru", "Chcr", "gyrt", "gyrr", "ChR", "anchrc", "cher", "CHrb", "chrt", "chrl", "cherb", "Chru", "chrg", "achcr", "cherr", "achsr", " chru", "chR", "candrt", " chrl", "CHcr", "ichru", "ichrl", "grr", "cheR", "achr", "chcr", "CHrc", "gyrc", "grar", "chrb", "candrc", "ichr", "Chrb", "schsr", "anchrg", "chrc", "achrb", "cheru", "grru", "grrl", "CHr", "CHR"], "opts": ["optt", "copcs", "cops", "iopps", " optts", "opstr", "ioptes", "optns", " opstr", "iopts", "iops", "ottr", "opns", " opters", "opttr", "ops", "optws", "optts", "optes", " optes", "optks", " optt", "coptr", "opters", "optstr", "opt", " opt", "opcs", " opcs", "opttes", " opks", " optstr", "copks", " opws", "opps", "optcs", "opks", "copts", "optr", "otns", "ppts", "copters", "ppters", "optps", "ots", " opps", " optws", "ppps", "ppcs", "copns", "opws", " ops", "optters", "otts"], "err": ["msg", "br", "ref", "finder", "error", "result", "e", "er", "str", "arr", "ler", "arm", "rh", "orig", "order", "pr", "bug", "r", "resp", "runner", "acer", "rr", "n", "ctr", "tx", "res", "rn", "fy", "lr", "mr", "magic", "cr", "g", "Er", "ir", "rage", "Error", "erer", "req", "ise", "der", "cache", "ar", "ver", "rar", "fr", "fee", "dr", "here", "gr", "iter", "aster", "cb", "ee", "rs", "raise"]}}
{"project": "qemu", "commit_id": "7873df408dd44eb92840b108211d5aa5db7db526", "target": 0, "func": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n\n                            const char *model, const char *name,\n\n                            const char *ifname, const char *script,\n\n                            const char *downscript, const char *vhostfdname,\n\n                            int vnet_hdr, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7490, "substitutes": {"tap": ["pc", "np", "ppa", "pod", "api", "mp", "num", "tu", "temp", "snap", "ta", "kat", "tip", "tim", "cap", "tin", "data", "pb", "form", "input", "att", "submit", "tool", "trace", "typ", "png", "tun", "config", "sp", "pipe", "ap", "ts", "t", "raf", "tr", "tw", "trip", "tm", "tif", "wp", "project", "oga", "TP", "xml", "tk", "p", "session", "pn", "jp", "gap", "prop", "json", "wt", "amp", "python", "apt", "bp", "cp", "pd", "window", "tar", "Tap", "opa", "pin", "php", "capt", "spl", "tp", "pa", "request", "skip", "wal", "wa", "tick", "tta", "tc", "span", "setup", "tf", "td"], "peer": ["scope", "pb", "pc", "seed", "reader", "proc", "e", "ppa", "enc", "slave", "er", "server", "tp", "sys", "p", "type", "socket", "player", "pair", "pid", "channel", "ep", "device", "pipe", "request", "pro", "mode", "friend", "address", "pointer", "pp", "gp", "ssl", "parent", "pe", "rb", "state", "node", "eps", "ptr", "port"], "model": ["scope", "reader", "xml", "package", "db", "param", "slave", "controller", "server", "models", "zip", "base", "client", "image", "module", "cm", "channel", "config", "plugin", "stage", "sym", "mode", "m", "instance", "ctx", "layer", "owner", "address", "source", "location", "ssl", "parent", "Model", "lc", "pe", "dm", "pri", "fp", "prot", "handler"], "name": ["nam", "data", "new", "profile", "family", "nice", "package", "label", "na", "mini", "key", "type", "client", "image", "vision", "id", "Name", "word", "version", "host", "action", "path", "part", "parent", "info", "named", "names", "size", "prefix", "filename", "alias", "NAME", "time", "term", "base"], "ifname": ["iftype", "ifftype", "Ifnames", " ifName", "Ifno", "switchName", " ifnames", "tifsize", "iffnames", " ifsize", "tifnames", "Ifname", "ifnames", "ifName", "IFname", "ifno", "tifName", "IFtype", "Ifsize", "IFsize", "switchnames", "IFnames", "switchname", "ifsize", "tifno", "iffsize", "iffname", " ifno", "tifname", "switchsize", "Iftype"], "script": ["data", "scope", "fn", "proxy", "sec", "control", "input", "exec", "Script", "command", "slice", "src", "esc", "sc", "test", "image", "cript", "config", "javascript", "sign", "password", "lib", "file", "tx", "ip", "secret", "source", "pass", "ssl", "writer", "media", "prefix", "scripts", "fee", "code", "sd", "timeout", "desc"], "downscript": ["downcode", "upcript", "ownstyle", "dropscripts", "uptext", "upscript", "upcode", "droptext", "subscripts", " downtext", "crossscripts", "downcript", "upScript", "upstyle", "ownscript", "downScript", "dropscript", " downcode", " downsh", "subscript", "upsh", "downscripts", " downScript", "downsh", "downtext", "ownScript", "crossscript", " downscripts", "ownscripts", " downcript", "downstyle", "crosscript", "subcode", "upscripts", " downstyle", "crosssh", "dropScript"], "vhostfdname": ["vHostdnumber", "vhostfddef", "vHostfdnumber", "vhomefdname", "vhostddName", "vhostFDName", "vhosthandlernm", "vHostdName", "vhosthandlerName", "vhostfnnames", "vhostdfName", "vHostfdName", "vhostfdName", "vhostfname", "vhostfno", "vhostdfnm", "vhostfnname", "vhomefname", "vHostfdname", "vhosthandlerdef", "vhostdfdef", "vHostdname", "vhosthandlername", "vhostdnames", "vhostfdnames", "vhostfdnumber", "vhostfnno", "vhostdnumber", "vhostdname", "vhostdfname", "vhostfnumber", "vhomefnames", "vhostdName", "vhostddnumber", "vhostddname", "vhostFDname", "vhomefno", "vhomefdno", "vhostfdnm", "vhostfdno", "vhostfnames", "vhostddnames", "vhostFDnm", "vHostdnames", "vhostFDdef", "vhostddno", "vhostfName", "vhomefdnames", "vHostfdnames"], "vnet_hdr": ["vnetxhdr", "vnet_fdr", "vnetxvst", "vnet_bhrt", "vnetxhbr", "vnet_shrt", "vnet_hicit", "vnet_wbr", "vnet_bhdr", "vnet_bhicit", "vnet_ficit", "vnet_wdr", "vnet_vbr", "vnetxvbr", "vnetxhst", "vnet_shdr", "vnet_wrt", "vnet_vdr", "vnet_hst", "vnetxvdr", "vnet_vrt", "vnet_frt", "vnetxvrt", "vnet_hrt", "vnet_hbr", "vnet_wst", "vnet_shicit", "vnetxhrt", "vnet_vst"], "fd": ["wb", "form", "fn", "fa", "dn", "dir", "cond", "db", "fun", "input", "d", "director", "fed", "fx", "handler", "fi", "af", "fe", "write", "dt", "df", "std", "connection", "function", "flow", "client", "socket", "pid", "FD", "config", "td", "sf", "fw", "ds", "pipe", "fb", "file", "fm", "dd", "temp", "fen", "fin", "dc", "fs", "nw", "f", "pointer", "nd", "dl", "writer", "ln", "fc", "cf", "bd", "stream", "ff", "sd", "cb", "fp", "pd", "feed", " fid", "fl", "format", "dat"], "s": ["sync", "native", "site", "ops", "sg", "services", "fs", "f", "sv", "b", "conf", "v", "an", "new", "sites", "sq", "submit", "sb", "h", "ses", "r", "cs", "u", "sf", "sp", "ss", "ts", "t", "ns", "sa", "tests", "your", "sw", "https", "es", "http", "comments", "fts", "sys", "self", "p", "ls", "session", "S", "ps", "gs", "sets", "n", "c", "g", "us", "ssl", "sl", "python", "su", "qs", "rs", "spec", "si", "y", "aws", "e", "server", "socket", "is", "service", "l", "sym", "m", "sn", "settings", "se", "i", "o", "secondary", "js", "os"], "vhostfd": ["vhomedraft", "vhomedl", "vpoolfd", " vhomedl", "vhomefd", " vHostFD", "vportf", "vconnectfc", " vworkfd", "vhostfe", "vhardff", "vhostdc", "vserverfd", " vhostdd", " vhostfc", " vhostd", "vhardfe", "vhardfd", " vhomefd", "vHostda", "vvisfd", "vhostpd", " vhostfp", " vhostdraft", "vhardf", "vformatfc", "vhomefc", "vworkff", "vportfe", "vhardd", "vformatdl", " vhostFD", "vhomedc", "vhomepd", "svserverfc", "vhostf", "vhostd", "vvisdd", "vformatfd", "vvisFD", "vportdc", "vworkfd", "vpoolff", "vformatdraft", "svharddc", "svhardfd", " vhostdl", "vHostdd", "vhopFD", "vfrontfd", "svhostfe", "vhostdl", "vhostda", "vHostFD", "vhostdraft", "vhopdd", "vhardfp", "vhostdd", "vhopda", "vharddc", " vhostff", "svhostfc", "vpoold", " vHostdd", "vconnectfd", "vserverpd", "svserverfx", "vhomef", "vhostFD", "vpoolfp", "svhostdc", "vfrontfx", " vworkff", "svhardf", "vworkfp", "vhomefx", "vserverfx", "vhopfd", "svhardfe", " vworkfp", " vhomefc", "vHostfd", " vHostda", "svhostpd", "vportfd", "vhomefe", "svhostf", "vhostfx", "vfrontpd", "svserverpd", "vfrontfc", "vhostfc", " vhostda", "vhostfp", "vconnectdraft", "vhostff", "vserverfc", " vHostfd", "vconnectdl", "svhostfx", "svhostfd", "vvisda", "vworkd", "svserverfd", " vhomedraft", " vworkd"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 7491, "substitutes": {"l": ["lb", "j", "loc", "e", "le", "pl", "ol", "ler", "p", "ul", "ls", "ll", "ell", "jl", "lu", "r", "u", "n", "wl", "lo", "s", "c", "all", "t", "L", "kl", "il", " L", "nl", "f", "g", "lit", "dl", "el", "i", "sl", "o", "list", "lin", "iol", "lf", "la", "lc", "rl", "b", "los", "ln", "v", "ld", "fl", "li"], "prop": ["tag", "data", "root", "pb", "pos", "np", "target", "proc", "properties", "def", "cp", "field", "loc", "j", "pot", "pl", "key", "val", "typ", "dt", "op", "p", "api", "mp", "type", "ps", "test", "pr", "rop", "this", "config", "service", "method", "unit", "plugin", "pro", "fb", "jp", "option", "obj", "ops", "class", "tmp", "ctx", "owner", "Prop", "f", "opt", "lit", "fit", "part", "feat", "parent", "info", "dev", "manager", "lp", "project", "prot", "attr", "b", "col", "arg", "priv", "role", "post", "comp", "term", "pred", "lot", "property"], "oc": ["root", "oca", "unc", "nc", "uc", "rc", "pc", "aco", "oci", "loc", "enc", "coll", "co", "anc", "cc", "op", "acl", "org", "ocr", "sc", "soc", "roc", "config", "oco", "voc", "ic", "cca", "obj", "ob", "c", "toc", "og", "bc", "cr", "OC", "oe", "acc", "mc", "om", "ec", "osc", "fc", "cu", "o", "cf", "ac", "ok", "oo", "vc", "doc", "os", "oid"], "dc": ["nc", "uc", "dn", "rc", "pc", "da", "di", "director", "db", "loc", "d", "co", "jc", "cc", "anc", "dt", "df", "design", "ct", "dp", "device", "ds", "cca", "cdn", "c", "rec", "bc", "acc", "mc", "ec", "dk", "fc", " DC", "cf", "ga", "tc", "lc", "cd", "ac", "DC", "disc", "vc", "doc", "driver"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    ESDVoiceOut *esd = (ESDVoiceOut *) hw;\n\n    audsettings_t obt_as = *as;\n\n    int esdfmt = ESD_STREAM | ESD_PLAY;\n\n    int err;\n\n    sigset_t set, old_set;\n\n\n\n    sigfillset (&set);\n\n\n\n    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        esdfmt |= ESD_BITS8;\n\n        obt_as.fmt = AUD_FMT_U8;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"Will use 16 instead of 32 bit samples\\n\");\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n    deffmt:\n\n        esdfmt |= ESD_BITS16;\n\n        obt_as.fmt = AUD_FMT_S16;\n\n        break;\n\n\n\n    default:\n\n        dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt);\n\n        goto deffmt;\n\n\n\n    }\n\n    obt_as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n", "idx": 7498, "substitutes": {"hw": ["wy", "wb", "ou", "wav", "np", "vp", "lv", "wcs", "mm", "him", "umi", "wm", "gpu", "nas", "nv", "wx", "kw", "rh", "h", "dq", "wo", "gg", "hz", "conn", "aff", "haw", "fw", "hm", " HW", "voc", "ohm", "hp", "hh", "hhh", "eng", "wan", "ctx", "wire", "nw", "tw", "wa", "usb", "wei", "hop", "ogg", "wu", "ow", "wp", "pkg", "gp", "war", "ww", "iw", "w", "cu", "gh", "cow", "sw", "zh", "rw", "aw", "vc", "ht", "wd", "wk"], "as": ["mas", "av", "an", "pos", "pas", "ase", "from", "ach", "am", "aws", "ras", "aus", "mm", "asu", "ast", "auth", "nas", "sys", "self", "session", "ay", "is", "acs", "gs", "ch", "cs", "ask", "ap", "asha", "or", "ars", "res", "ass", "asc", "As", "s", "ss", "instance", "sh", "asa", "ns", "ms", "act", "ams", "sa", "inas", "a", "us", "was", "ow", "mac", "ar", "ga", "sw", "ac", "has", "aw", "os", "conf", "AS", "rs", "bas", "asm"], "esd": ["sesd", "gesds", "opensds", "lsds", "esdb", "essdn", "zesd", "ossd", "lesds", "usds", "esspd", "essdk", "essds", "usdk", " esds", "zesds", "sesdn", "lesdb", "essd", "essdl", "lesdl", "zesdb", "owsdl", "eesdb", "etsdk", "lsd", "eesds", "asdk", "openspd", "opensd", "owsds", "lssd", "zessd", "usdb", "gesdk", "sesdk", "gesdn", "ossdk", "ossds", "esds", "eesd", "owsd", "asds", "etsd", "eesdl", "asd", "espd", "gesd", "esdk", " esdk", "esdl", "essdb", "etsds", "etspd", "lsdb", "lesd", "esssd", "usd", "asdb", "owsdk", "opensdk", "sesds", " esdb", "ossdl", "esdn"], "err": ["msg", "y", "rc", "finder", "ner", "error", "result", "loc", "e", " error", "er", "str", "wr", "call", "ler", "arr", "aer", "rh", "orig", "test", "order", "pr", "bug", "r", "resp", "fam", "die", "ind", "id", "rr", "acer", "res", "yer", "fy", "lr", "magic", "mr", "icer", "fer", "g", "f", "act", "eor", "Er", "rage", "ec", "Error", "erer", "req", "ise", "der", "ir", "nr", "ver", "kr", "fee", "yr", "ar", "dr", "rar", "fr", "gr", "attr", "found", "iter", "errors", "fg", "rag"], "set": ["reset", "sec", "end", "ets", "get", "clear", "str", "vert", "server", "write", "sync", "base", "type", "mit", "client", "sc", "dat", "sets", "update", "use", "sign", "et", "id", "Set", "read", "ut", "init", "setting", "not", "sett", "parse", "check", "SET", "start", "mod", "sort", "cast", "size", "match", "valid", "gen", "store", "setup", "zero", "send", "util", "sent"], "old_set": ["old_sets", "oldvalsc", "objvalsc", "objvalset", "obj_reset", "old_settings", "obj_sets", "objvalreset", "old_sc", "oldvalset", " old_sets", "old_reset", "objvalsets", "old_start", "obj_sc", " old_start", "obj_set", "oldvalsets", " old_settings", "oldvalreset"]}}
{"project": "qemu", "commit_id": "03a63484a6978f68caff087bbaabcd1d383563af", "target": 1, "func": "static void monitor_find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    const mon_cmd_t *cmd;\n\n    const KeyDef *key;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = next_arg_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype += 2;\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 7521, "substitutes": {"cmdline": ["mdstring", "cmdlin", "commandline", "mdline", " cmdstring", "commandstring", "commandlin", "commname", "callname", "commline", "commlines", "mdlin", "mdname", "cmdlines", " cmdLine", "commandname", "mdLine", "commle", "callline", "commandle", "cmdle", "mdle", "commlin", "callLine", "mdlines", "commandlines", "calllines", "cmdstring", "cmdLine", "commandLine"], "cmdname": ["msgnamed", "cmdnames", "cmdName", "commandline", "mdnamed", "mdnames", "mdline", "commpath", "cfname", " cmdName", "cmdno", "mdpath", "commname", "commline", "commno", "commandName", " cmdnames", "commnamed", " cmdn", "mdname", "cmdnamed", "commn", "commandname", "cfline", "cfno", " cmdnamed", "commandpath", "commandno", "msgno", "cfnames", "commName", " cmdno", "cmdn", "cfn", "cfnamed", "mdno", "msgname", "msgnames", "cmdpath"], "args": ["pos", "keys", "vs", "changes", "Args", "s", "strings", "my", "arg", "grades", "pres", "groups", " arguments", "data", "param", "input", "lines", "enc", "exec", "call", "params", "cs", "config", "alls", "arms", "ns", "parse", "mac", "ins", "doc", "limits", "xml", "parts", "p", "arr", "links", "ay", "atts", "uments", "gs", "headers", "stats", "ids", "all", "fields", "g", "ig", "ams", "items", "qs", "rs", "extra", "py", "options", "help", "aws", "argument", "values", "ds", "obj", "ars", "states", "actions", "ms", "array", "vals", "flags", "points", "words", "md", "js", "results"], "MAX_ARGS": ["MAX_WARTS", "MAX_ARTS", "MAX_RAYS", "MAX_CARTS", "MAX_WARYS", "MAX_RATS", "MAX_WARGS", "MAX_RAGS", "MAX_PARTS", "MAX_ARGV", "MAX_RAG", "MAX_WARG", "MAX_CARYS", "MAX_CARGV", "MAX_PARGS", "MAX_ARYS", "MAX_CARG", "MAX_PARGV", "MAX_CARGS", "MAX_PARG", "MAX_ARG"], "nb_args": ["num_words", "nd_args", "nb2args", "cb_params", "nb00groups", "nr_atts", "nb_axis", "nb00args", "kb_args", "nb_ds", "nd_items", "nb67atts", "nb00modules", "nb_flags", "nb__parts", "nb_keys", "nb2flags", "nb_arg", "nb_words", "nb48args", "NB_items", "nb_aux", "nb48params", "nr_flags", "nb00axis", "nb67arr", "nb00keys", "nn_axis", "nb00arr", "NB64items", "nb67keys", "nb2atts", "nn_modules", "nbXarg", "nb67ds", "nb_params", "nb67modules", "num_fields", "nb64strings", "nb67arms", "kb_arg", "nd_arms", "nb__arg", "nd67items", "cb_arg", "nbXargs", "nb67groups", "nb67items", "nb__actions", "nn67args", "NB64strings", "nb64fields", "nb_items", "nn_args", "nb64args", "nr_params", "nb_strings", "nb_plugins", "num_aux", "nb00ds", "NB_args", "nbJfields", "nb48items", "nn67axis", "nd67arms", "nb67strings", "NB64args", "nb67params", "nb_atts", "nb64arg", "nb00items", "nb_actions", "nd67args", "nr_args", "nn67ds", "nb48strings", "nb67flags", "nb00arms", "nb67args", "nn_ds", "num_arg", "nb00plugins", "wb_plugins", "wb_keys", "nbXfields", "nb2params", "nb64items", "NB64params", "nb__args", "nb_fields", "nb67arg", "cb_actions", "nn67modules", "nb_groups", "NB_params", "nb67fields", "nb67words", "nbXaux", "nb64params", "nb_arr", "nbJarg", "nb_arms", "nbJwords", "NB_strings", "nb_parts", "num_args", "kb_params", "kb_parts", "nb__params", "wb_args", "nb_modules", "nb67plugins", "nb64aux", "cb_args", "wb_arr", "nb67axis", "nd67groups", "nd_groups", "nbJargs"], "i": ["ui", "bi", "y", "index", "pi", "ie", "j", "di", "name", "e", "d", "multi", "fi", "cli", "ti", "p", "yi", "slice", "h", "mi", "phi", "qi", "ii", "uni", "hi", "u", "sp", "inner", "ind", "id", "n", "ni", "l", "ip", "ami", "c", "init", "t", "ix", "oi", "f", "zi", "io", "start", "ini", "info", "gi", "mu", "x", "uri", "it", "xi", "ci", "eni", "b", "iu", "I", "ai", "v", "si", "li"], "len": ["Len", "pos", "split", " l", "lv", "e", "le", "limit", "pl", "val", " el", "ol", "bl", "ls", "ll", "full", "num", "seq", "lon", "lt", "line", "sp", "elt", " length", "n", "ni", "l", "lim", " Len", "fin", "L", "il", "f", "inn", "min", "en", "dl", "el", "part", "non", "err", "lin", "sl", "list", "size", "nt", "lf", "lc", "z", " lang", "length", "lan", "count", "ln", "lock", "fl", "li"], "ptype": ["iptypes", "pattype", "pype", "ptypes", "prake", "plyp", " pttype", "pitopic", "cttype", "istitle", "patype", "plope", "prime", "ptickle", "pyp", "pttype", "ptick", "iptickle", "PType", "prape", "ptopic", "pectickle", "PTypes", "ntyle", "ptity", "ppyle", " ptope", "istype", "ptime", " ptick", "ntypes", "pretime", " ptitle", "portopy", "pitype", "ptope", "patape", "ntype", "istyle", "ctyp", "ptetime", " ptrace", "PTyp", "ypick", " ptike", "PTtype", "ctape", "ptoe", "iptake", " ptoe", "pittype", "xtyle", "eptype", "pptype", "iptyp", "ptiny", "ctetime", "pectopic", "iptime", "nttype", "eptick", "ppike", " ptetime", "patiny", "ppyp", "ctake", "ypope", "prtype", " ptity", "ctypes", "plime", " ptyp", "pltype", "plopy", "plype", "prype", "ypype", "porttype", "xtype", "ctyle", "iptype", "pypes", "patity", "ctype", "pprace", "patyp", "portiny", "pecttype", "istoe", "ypyp", "patetime", "pryp", "ipttype", "ppype", "ptike", "PTike", "portype", "eptope", "pliny", "PTrace", "xtoe", "pitickle", "ctope", "ptape", "ptrace", " ptyle", "iptopic", "ntyp", "ptitle", "iptetime", "PTyle", "pime", "xtitle", "pectype", "patopy", "ctime", " ptime", "eptyp", "iptity", "ptyp", "ptopy", "ptake", "ptyle"], "str": ["data", "pos", "br", "sec", "j", "text", "input", "d", "name", "enc", "exec", "sync", "arr", "bl", "style", "hr", "pr", "expr", "Str", "r", "inner", "sp", "STR", "dict", "read", "res", "st", "stri", "strings", "tr", "f", "pass", "cl", "err", "sl", "fr", "code", "dr", "iter", "doc", "ld"], "cmd": ["cfg", "msg", "uc", "comm", "header", "help", "target", "proc", "name", "domain", "cli", "command", "call", "cc", "dom", "op", "mid", "client", "oc", "buf", "conn", "num", "clean", "module", "cod", "ch", "config", "win", "pipe", "dict", "ctr", "id", "cookie", "go", "block", "c", "content", "init", "css", "magic", "ctx", "dc", "host", "f", "act", "ctrl", "cat", "cl", "pkg", "req", "mac", "mod", "bin", "w", "qq", "cf", "code", "md", "cd", "bind", "gen", "node", "grad", "cb", "vc", "cmp", "cp", "method", "Cmd"], "key": ["data", "msg", "keys", "k", "def", "value", "param", "name", "enc", "val", "call", "kw", "type", "conn", "dict", "id", "obj", "entry", "parent", "code", "gen", "Key", "arg", "row"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n", "idx": 7556, "substitutes": {"sd": ["data", "SD", "vd", "od", "sam", "db", "d", "sb", "so", "std", "sm", "sy", "td", "sf", "ds", "ind", "dd", "s", "ss", "gd", "sg", "sie", "sa", "sn", "dl", "settings", "se", "sl", "ad", "bd", "md", "cd", "sv", "sk", "state", "pd", "ld", "si"], "response": ["data", "object", "header", "index", "result", "error", "success", "value", "message", "received", "document", "respons", "server", "write", "sync", "api", "connection", "answer", "image", "site", "position", "resp", "Response", "service", "request", "application", "sequence", "content", "respond", "version", "next", "description", "page", "array", "model", "parent", "settings", "json", "wave", "match", "reply", "route", "tree", "http", "body", "output", "update"], "last_status": [" last_state", "last__date", " last_date", "last_stat", "last_date", "last__status", "last__state", " last_stat", "last_state", "last__stat"], "status": ["complete", "data", "date", "msg", "index", "xml", "progress", "result", "success", "error", "message", "received", "str", "Status", "modified", "server", "command", "sync", "session", "style", "full", "seq", "sc", "login", "speed", "site", "service", "request", "stats", "stage", "id", "s", "content", "version", "summary", "sex", "description", "source", "comment", "model", "flag", "settings", "security", "json", "prefix", "score", "match", "code", "reason", "state", "su", "active", "output", "update", "stat"]}}
{"project": "FFmpeg", "commit_id": "5674d4b0a35a34b75e3533a8580e0b5a0a8895a7", "target": 0, "func": "static int mpc8_decode_frame(AVCodecContext * avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb2, *gb = &gb2;\n\n    int i, j, k, ch, cnt, res, t;\n\n    Band *bands = c->bands;\n\n    int off;\n\n    int maxband, keyframe;\n\n    int last[2];\n\n\n\n    keyframe = c->cur_frame == 0;\n\n\n\n    if(keyframe){\n\n        memset(c->Q, 0, sizeof(c->Q));\n\n        c->last_bits_used = 0;\n\n    }\n\n    init_get_bits(gb, buf, buf_size * 8);\n\n    skip_bits(gb, c->last_bits_used & 7);\n\n\n\n    if(keyframe)\n\n        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);\n\n    else{\n\n        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);\n\n        if(maxband > 32) maxband -= 33;\n\n    }\n\n    c->last_max_band = maxband;\n\n\n\n    /* read subband indexes */\n\n    if(maxband){\n\n        last[0] = last[1] = 0;\n\n        for(i = maxband - 1; i >= 0; i--){\n\n            for(ch = 0; ch < 2; ch++){\n\n                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];\n\n                if(last[ch] > 15) last[ch] -= 17;\n\n                bands[i].res[ch] = last[ch];\n\n            }\n\n        }\n\n        if(c->MSS){\n\n            int mask;\n\n\n\n            cnt = 0;\n\n            for(i = 0; i < maxband; i++)\n\n                if(bands[i].res[0] || bands[i].res[1])\n\n                    cnt++;\n\n            t = mpc8_get_mod_golomb(gb, cnt);\n\n            mask = mpc8_get_mask(gb, cnt, t);\n\n            for(i = maxband - 1; i >= 0; i--)\n\n                if(bands[i].res[0] || bands[i].res[1]){\n\n                    bands[i].msf = mask & 1;\n\n                    mask >>= 1;\n\n                }\n\n        }\n\n    }\n\n    for(i = maxband; i < c->maxbands; i++)\n\n        bands[i].res[0] = bands[i].res[1] = 0;\n\n\n\n    if(keyframe){\n\n        for(i = 0; i < 32; i++)\n\n            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;\n\n            if(cnt >= 0){\n\n                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);\n\n                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);\n\n                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(!bands[i].res[ch]) continue;\n\n\n\n            if(c->oldDSCF[ch][i]){\n\n                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;\n\n                c->oldDSCF[ch][i] = 0;\n\n            }else{\n\n                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);\n\n                if(t == 64)\n\n                    t += get_bits(gb, 6);\n\n                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;\n\n            }\n\n            for(j = 0; j < 2; j++){\n\n                if((bands[i].scfi[ch] << j) & 2)\n\n                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];\n\n                else{\n\n                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);\n\n                    if(t == 31)\n\n                        t = 64 + get_bits(gb, 6);\n\n                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){\n\n        for(ch = 0; ch < 2; ch++){\n\n            res = bands[i].res[ch];\n\n            switch(res){\n\n            case -1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++)\n\n                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;\n\n                break;\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){\n\n                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);\n\n                    t = mpc8_get_mask(gb, 18, cnt);\n\n                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)\n\n                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;\n\n                }\n\n                break;\n\n            case 2:\n\n                cnt = 6;//2*mpc8_thres[res]\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 3){\n\n                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);\n\n                    c->Q[ch][off + j + 0] = mpc8_idx50[t];\n\n                    c->Q[ch][off + j + 1] = mpc8_idx51[t];\n\n                    c->Q[ch][off + j + 2] = mpc8_idx52[t];\n\n                    cnt = (cnt >> 1) + mpc8_huffq2[t];\n\n                }\n\n                break;\n\n            case 3:\n\n            case 4:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 2){\n\n                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];\n\n                    c->Q[ch][off + j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n", "idx": 7558, "substitutes": {"avctx": ["avcontext", "Avcli", " avcontext", "afcli", "afctx", "avcp", "afcontext", "afcp", "ajcontext", "abcv", "avpkg", "Avctx", "abctx", "abcontext", "abcp", " avcp", "avcv", "afpkg", "avcli", " avcv", "ajpkg", "ajcli", "Avpkg", "ajctx", "Avcontext", "afcv"], "data": ["batch", "frame", "da", "reader", "DATA", "result", "input", "d", "queue", "message", "Data", "val", "p", "connection", "dat", "client", "image", "channel", "config", "bytes", "read", "block", "response", "buff", "load", "m", "content", "buffer", "next", "bin", "cache", "media", "size", "memory", "code", "uf", "pack", "board", "in", "body", "window", "base"], "data_size": ["data_timeout", "dataflowgrow", "data\u00b7size", "data\u00b7timeout", "buffer_timeout", "data\u00b7grow", "dataflowlen", "dataflowsize", "data_len", "buffer_size", "buffer_len", "dataflowtimeout", "data\u00b7len", "buffer_grow", "data_grow"], "avpkt": ["avpck", "avcpkg", " avpcht", "avwpkt", "avcpck", "avcpacket", "abpacket", "avbpkt", "avfck", "avwpcht", "avcacket", " avpki", "abcpacket", " avvpki", "avfkg", "abpkt", "avfpacket", "avpki", "avcck", "avvpki", "abpck", "avfpkt", "avpkg", "avvpcht", " avvpck", "abcpct", "avcpct", "avbpcht", "abcpkt", "abcpkg", "avpcht", "avvpck", "avwpck", "avfpct", " avpck", "abpct", "avfpkg", "avfkt", "avpct", "abcpck", "avpacket", "avfct", "avcct", "avbpki", "avfacket", "avvpkt", " avvpcht", "avcpkt", "avckt", "avbpck", "avwpki", " avvpkt", "abpkg"], "buf": ["batch", "pb", "br", "uc", "rc", "bag", "queue", "raw", "mem", "p", "map", "src", "pad", "seq", "img", "box", "config", "vec", "cmd", "fb", "block", "buff", "cur", "bc", "buffer", "array", "cv", "cache", "alloc", "cf", "code", "uf", "rb", "board", "cas", "cb", "v", " buffer", "port"], "c": ["nc", "uc", "pc", "rc", "e", "d", "enc", "component", "coll", "co", "cc", "p", "sync", "ce", "client", "h", "sc", "conn", "xc", "ct", "cm", "cs", "r", "u", "config", "cit", "l", "n", "cy", "s", "m", "ctx", "bc", "dc", "cr", "g", "f", "arc", "cur", "ctrl", "mc", "cat", "ec", "conf", "cache", "fc", "cu", "cf", "ca", "C", "cn", "ci", "lc", "cd", "icc", "ac", "b", "com", "vc", "con", "cp", "cmp", "v"], "gb2": ["ggv", "pc2", "pc3", "gg2", "gg1", "pcTwo", " rc3", "cTwo", "gb3", "GB2", "gb1", "gg4", "cvv", "cv4", "gbTwo", "GBv", "cv2", " rcTwo", "c3", "GB1", "gb4", "cv1", " rc2", "c2", "GB4", "gbv"], "gb": ["py", "cfg", "gm", "pc", "storage", "rc", "db", "bf", "gu", "pg", "sb", "hub", "mb", "gam", "rg", "bm", "gz", "gg", "agg", "gs", "bb", "config", "lib", "bo", "go", "buff", "gy", "gd", "gold", "cgi", "ctx", "boot", "gin", "bc", "g", "bg", "nb", "kb", "usb", "GB", "gp", "eb", "bin", "gt", "ga", "ci", "lc", "uf", "yg", "band", "rb", "gru", "bp", "b", "cb", "banks", "binary"], "i": ["bi", "ui", "y", "pi", "ie", "ih", "di", "e", "d", "si", "ik", "multi", "fi", "ti", "p", "yi", "li", "api", "h", "mi", "phi", "qi", "ii", "r", "ki", "u", "hi", "ji", "ind", "id", "n", "l", "ni", "chi", "ip", "ami", "m", "sh", "ix", "ori", "oi", "f", "zi", "io", "ri", "ini", "info", "o", "gi", "it", "xi", "uri", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "v", "x"], "j": ["pos", "y", "ie", "d", "p", "h", "ij", "ii", "r", "u", "ji", "ind", "n", "l", "jp", "m", "g", "f", "o", "z", "b", "q", "v", "J", "si"], "k": ["y", "e", "d", "ik", "key", "p", "ks", "kw", "h", "K", "kk", "ki", "u", "n", "ck", "m", "g", "f", "o", "w", "z", "sk", "q", "ke", "v", "x"], "ch": ["hr", "och", "pr", "qi", "cor", "f", "cht", "cel", "ver", "zh", "b", "sk", "conf", "v", "batch", "che", "form", "ich", "app", "h", "channel", "cm", "change", "u", "cham", "chart", "cl", "ky", "fr", "code", "arch", "q", "CH", "pull", "try", "cho", "p", "conn", "sch", "cher", "chan", "cy", "child", "Ch", "chn", "bh", "col", "cp", "work", "x", "chy", "y", "ach", "th", "cha", "sc", "chi", "qu", "sh", "cry", "cur", "gh", "ph", "dev", "chip", "ci", "z"], "cnt": ["cnd", " count", " cno", " cct", "lcno", "ecnt", "Cct", "Count", "lcn", "acNT", "lcct", " cnc", "ecnd", "Cnt", "CNT", " cNT", "ecnc", "cno", "ecount", "ecNT", "acn", "cnc", "lcnc", "acno", "lcnt", " cnd", "cNT", "ecct", " cn", "cn", "lcNT", "cct", "Cnc", "acnt", "Cnd", "count", "Cno"], "res": ["real", "pos", "ex", "re", "reset", "ress", "def", "total", "ras", "result", "rss", "rep", "rx", "arr", "blocks", "prev", "rh", "ps", "sc", "values", "r", "resp", "remote", "sp", "ret", "reg", "response", "block", "press", "mr", "resolution", "ts", "rest", "des", "ms", "range", "rev", "max", "vals", "req", "err", "rem", "gr", "pres", "RES", "os", "results", "Res", "rs", "spec"], "t": ["y", "total", "mt", "e", "tn", "dt", "tp", "p", "template", "T", "type", "port", "r", "tt", "at", "n", "l", "ut", "m", "ts", "ta", "pt", "f", "g", "tm", "o", "wt", "it", "det", "tc", "nt", "unt", "rt", "qt", "ot", "tf", "v", "token", "tz"], "bands": ["amps", "classes", "pins", "parts", "frames", "lines", "sb", "plugins", "devices", "tops", "models", "blocks", "ks", "books", "chains", "codes", "cards", "versions", "bows", "archs", "rules", "charges", "lists", "bones", "rings", "ands", "ds", "types", "products", "pieces", "heads", "files", "cycles", "states", "bys", "ids", "orders", "ogs", "services", "cells", "rooms", "g", "modules", "players", "cats", "points", "steps", "jobs", "words", "balls", "bits", "images", "objects", "band", "bass", "bags", "b", "stores", "groups", "banks", "planes", "girls", "tracks", "pages"], "off": ["low", "Off", "reset", "def", "one", "on", "total", "error", "op", "orig", "offset", "out", "ef", "ip", "obj", " offset", "mode", "shift", "opt", "o", "loop", "ff", "ok", "offs"], "maxband": ["axline", "xBand", "taxbit", "axframe", "lastBand", "rightblock", " maxframe", " maxbit", "modbridge", "righthard", "maxboot", " maxBand", " maxboot", "MaxBand", "maxbit", "workline", "maxBand", "scaleband", "scalecell", "rightband", "modbit", "axblock", "scalegroup", "maxblock", "axbit", "axbroad", "maxframe", "totalbit", "mincell", "taxpage", "minchannel", "lastline", "maxcell", " maxline", "mingroup", "totalline", "totalband", " maxcell", "lastband", "minbit", "xbit", "xband", "workband", " maxhard", "scalebit", "taxhard", "modpage", "maxline", "taxband", "rightbit", " maxblock", "rightpage", "maxgroup", " maxgroup", "minband", "maxbroad", "Maxband", "rightbridge", "axchannel", "axbridge", " maxbroad", "lastbit", "axband", "Maxboot", "maxpage", "maxchannel", "modband", "workbit", "maxhard", "workframe", "axboot", "axpage", " maxchannel", "axBand", " maxpage", "maxbridge", "totalBand", "rightbroad", "minline"], "keyframe": ["maxframe", "maxline", " keyiframe", "keyline", "skyiframe", " keyfram", "rowfram", "keyframes", "rowcode", " keyhole", "skycode", "keyiframe", "rowframe", "keyfram", "skyframes", "rowframes", " keyline", "Keyfram", "Keycode", "keyFrame", "Keyframe", " keyFrame", " keyframes", "kframes", "keyhole", "KeyFrame", "kframe", "Keyiframe", "keycode", "skyframe", "skyfram", "Keyframes", "Keyline", "maxFrame", "maxframes", "khole", "Keyhole"], "last": ["extra", "scope", "used", "new", "push", "bottom", "end", "one", "eval", "total", "build", "always", "Last", "str", "since", "now", "self", "base", "prev", "style", "history", "full", "cost", "old", "latest", "shared", "empty", "this", "current", "use", "est", "pull", "id", "pop", "child", "any", "all", "not", "tr", "next", "best", "range", "cle", "or", "max", "master", "parent", "cache", "only", "list", "size", "code", "recent", "valid", "desc", "active", "cycle", "count", "worst", "final", "private", "first"], "mask": ["batch", "tile", "depth", "total", "th", "p", "type", "bit", "offset", "ask", "id", "m", "ts", "all", "tl", "ta", "tr", "black", " masks", "max", "qa", "info", "Mask", "bits", "sk", "count", " tr"], "cur_frame": ["latestopchannel", "curopbit", "latest_frame", "curopchannel", "cur__element", "cur__bit", "curfframe", "curfbit", "curfchannel", "latest_bit", "cur_channel", "latestopelement", "latestopbit", "latest_channel", "curopelement", "curfelement", "cur_element", "cur__frame", "cur_bit", "latest_element", "curopframe", "cur__channel", "latestopframe"]}}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "substitutes": {"bus": ["root", "local", "pos", "lab", "Bus", "db", "loc", "hub", "controller", "self", "sync", "bridge", "bug", "use", "config", "ch", "device", "lib", "plugin", "id", "plug", "block", "ass", "class", "home", "boot", "bc", "host", "f", "vol", "usb", "book", "io", "pass", "cat", "us", "serial", "mount", "parent", "cache", "se", "BUS", "loop", "state", "kind", "http", "os", "lock", "driver", "base"], "name": ["nam", "data", "new", "object", "package", "key", "str", "none", "self", "connection", "type", "device", "id", "n", "Name", "word", "unknown", "class", "version", "address", "path", "part", "parent", "named", "info", "names", "prefix", "size", "code", "ame", "null", "NAME", "alias", "base"], "dev": ["data", "local", "Dev", "pub", "dist", "def", "od", "de", "di", "development", "d", "adv", "enc", " Dev", "diff", "error", "result", "val", "ve", "fi", "debug", "self", "p", "DEV", "app", "h", "conn", "test", "bug", "ev", "ch", "die", "device", "rad", "obj", "dd", "var", "gd", "instance", "dc", "prov", "prop", "comment", "inst", "mod", "serial", "cache", "der", "err", "ad", "ver", "cd", "valid", "sd", "kind", "grad", "priv", "dem", "conf", "gu", "driver", "wd", "private"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n", "idx": 7590, "substitutes": {"obj": ["data", "pb", "fn", "object", "k", "ref", "j", "e", "val", "self", "op", "p", "src", "bot", "n", "bo", "ob", "instance", "c", "t", "ctx", "f", "Obj", "xxx", "parent", "o", "objects", "Object", "b", "po", "q", "os", "x", "base"], "v": ["av", "data", "tv", "vim", "vm", "conv", "k", "j", "lv", "value", "gu", "e", "vic", "view", "d", "vert", "val", "ve", "self", "vi", "nv", "p", "h", "vs", "ev", "u", "n", "l", "s", "var", "m", "c", "t", "version", "uv", "V", "g", "f", "vers", "vol", "rev", "cv", "i", "iv", "w", "ver", "o", "erv", "va", "qv", "sv", "ov", "b", "q", "vv", "x"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 7596, "substitutes": {"base": ["bi", "root", "scope", "y", "storage", "proxy", "k", "index", "area", "gb", "scale", "name", "e", "body", "len", "core", "server", "p", "bare", "Base", "native", "type", "bit", "support", "offset", "bytes", "u", "pa", "id", "n", "abi", "c", "v", "address", "buffer", "f", "fs", "kb", "source", "io", "as", "padding", "start", "path", "a", "bin", "cache", "i", "prefix", "size", "origin", "code", "state", "b", "length", "os", "unit", "binary", "bas", "x"], "irq": ["irp", "rinqi", "irtp", " irqs", "iperq", "earqi", "mirqi", "irqi", "mirqu", "rinq", "rinqu", "drqu", "irtqu", "arqi", "irtq", "earq", "arqs", "iperqu", "mirqs", " irqu", "earqu", "arqu", "mirq", "drp", "arq", " irp", "rinqs", "drqs", "iperqs", "drq", "irqu", "earqs", "irtqs", "iperqi", "irqs"], "nchannels": [" nchans", "nchanars", "nChans", "nChars", " nChores", "nChannels", "ncharans", "nachannels", " nchares", "numchars", "nchanannels", "narchans", "nquans", "nChords", " nchores", " nChances", "nChores", "nachans", "numarchars", "nchanores", "ncharares", " nchances", "numarchans", "nachances", "ncharannels", " nchars", " nChans", "narchords", "nchanords", "nChares", "nchares", "nquars", "nquores", "narchannels", "numchords", "nquannels", "nchords", "numchans", "nchans", "nchanans", "numarchannels", "nchores", " nChares", "nChances", " nChannels", "ncharances", "narchars", " nChars", "numchannels", "nchars", "nachares", "nchances", "numarchords"], "iomemtype": ["iomimresource", "iomhemresource", "iomearype", "iom\u00e8tag", "iomemslike", "iomemweight", "ymommap", "lynemtag", "mopeminlike", "iomomresource", "iomemlen", "ymemtypes", "iomommap", "iomhemmap", "iom\u00e8type", "iomeartag", "iomhemtypes", "iomEMweight", "iomomype", "ymemresource", "ymemtype", "lynemlen", "iom\u00e8ype", "iomearlen", "mopemlike", "iomEMlike", "iomimtype", "mopemtype", "iomemmap", "ymomtypes", "mopemweight", "iomeartype", "iomEMtype", "lynemtype", "mopemintag", "lyn\u00e8type", "iom\u00e8len", "iomemlike", "iomemype", "ymomtype", "iomeminlike", "lyn\u00e8len", "iomemstag", "iomomtag", "iomeminweight", "iomemintag", "ymemmap", "mopeminweight", "lyn\u00e8ype", "iomemtag", "iomimmap", "iomhemtype", "lyn\u00e8tag", "iomemsweight", "iomemtypes", "mopemtag", "iomomlen", "iomEMtag", "iomemstype", "lynemype", "iomemintype", "iomomtypes", "iomemresource", "mopemintype", "ymomresource", "iomomtype", "iomimtypes"], "s": ["new", "storage", "e", "d", "ows", "sb", "server", "sys", "p", "sync", "spec", "native", "ls", "session", "S", "socket", "is", "ps", "ings", "ses", "support", "r", "gs", "cs", "u", "service", "sf", "ds", "ches", "stats", "n", "l", "ips", "rows", "states", " shares", "sym", "m", "c", "ss", "t", "services", "sg", "ts", "fs", "g", "f", "ns", "us", "a", "ssl", "settings", "i", "o", "w", "sl", "x", "secondary", "its", "state", "js", "b", "es", "os", "conf", "v", "rs", "si"]}}
{"project": "FFmpeg", "commit_id": "596b5c488fa1d40f114a64d3b73e1863cab073fb", "target": 0, "func": "static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,\n\n                                  float **plevel_table, uint16_t **pint_table,\n\n                                  const CoefVLCTable *vlc_table)\n\n{\n\n    int n                        = vlc_table->n;\n\n    const uint8_t  *table_bits   = vlc_table->huffbits;\n\n    const uint32_t *table_codes  = vlc_table->huffcodes;\n\n    const uint16_t *levels_table = vlc_table->levels;\n\n    uint16_t *run_table, *level_table, *int_table;\n\n    float *flevel_table;\n\n    int i, l, j, k, level;\n\n\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);\n\n\n\n    run_table    = av_malloc(n * sizeof(uint16_t));\n\n    level_table  = av_malloc(n * sizeof(uint16_t));\n\n    flevel_table = av_malloc(n * sizeof(*flevel_table));\n\n    int_table    = av_malloc(n * sizeof(uint16_t));\n\n    i            = 2;\n\n    level        = 1;\n\n    k            = 0;\n\n    while (i < n) {\n\n        int_table[k] = i;\n\n        l            = levels_table[k++];\n\n        for (j = 0; j < l; j++) {\n\n            run_table[i]    = j;\n\n            level_table[i]  = level;\n\n            flevel_table[i] = level;\n\n            i++;\n\n        }\n\n        level++;\n\n    }\n\n    *prun_table   = run_table;\n\n    *plevel_table = flevel_table;\n\n    *pint_table   = int_table;\n\n    av_free(level_table);\n\n}\n", "idx": 7598, "substitutes": {"vlc": ["llcs", "llf", "tlv", "tlc", "wlc", "dlc", "llpc", "llv", "lllc", "wlf", "vlv", "dlpc", "tllc", "llc", "nlcs", "vlf", "llct", "vlcs", "vllc", "wlv", "tlf", "nlct", "dlct", "wllc", "vlpc", "dlcs", "nlpc", "vlct", "nlc"], "prun_table": ["prunt_code", "prun_total", "prun_cache", "prunt_TABLE", "prunalltable", "prune_TABLE", "prune_table", "prunalltotal", "prunt_table", "prun_code", "prune_total", "prune_cache", "prun_TABLE", "prunallTABLE", "prunallcache"], "plevel_table": ["plevelingtype", "plevelentable", "pleveningtype", "plevel_type", "pleven_tab", "plevel__type", "plecl_tree", "plevel_tab", "plecl_table", "plevel_code", "pleven_type", "plevelentab", "plecl_body", "pleveningtable", "plevel__tab", "plecl_code", "plevelentree", "plevel__tree", "pleveningtree", "pleven_table", "pleveningtab", "pleven_tree", "plevelingtab", "plevel_tree", "plevelentype", "plevel__table", "plevelingtree", "plevel_body", "plevelingtable"], "pint_table": ["pintalltable", "pint8tree", "pintallcount", "pint_tree", "pinner_table", "pint8code", "pintallsource", "pint_code", "pbyte_tree", "pint_source", "pint8table", "pint8interface", "pint_interface", "pbyte_code", "pbyte_table", "pinner_source", "pintallcache", "pint_count", "pint_cache", "pinner_count", "pbyte_interface", "pinner_cache"], "vlc_table": ["vlcs_TABLE", "vlc__cache", "vlc2cache", "vlc_database", "vlf_database", "vlf_TABLE", "vll_stable", "vlc2tab", "vlc2table", "vlc2database", "vlc_stable", "vlg_table", "vlc_module", "vlcs_tab", "vlc_cache", "vlc2TABLE", "vlf_cache", "vlc__TABLE", "vlf_table", "vlg_tree", "vll_table", "vlcs_module", "vlcs_table", "vlg_container", "vlc_TABLE", "vlc__table", "vlf_stable", "vlc_container", "vlc__stable", "vlg_database", "vlc__database", "vlc_tree", "vll_cache", "vlc_tab", "vll_database", "vlc2module"], "table_bits": ["tableacfields", "table_files", "table__bytes", "table_bytes", "table__codes", "tableacbits", " table_bytes", " table_fields", "table_fields", "table__files", "tableaccodes", " table_files", "tableacbytes", "table__bits"], "table_codes": ["table_items", " table_types", "table___code", "tableactypes", " table_code", "tableacbits", "table___items", "tableaccodes", "tableaccode", " table_items", "table_devices", "table___codes", " table_devices", "table___devices", "table_code", "table_types"], "levels_table": ["vals_stable", "levels_tab", "levels__tab", "levels__tree", "levels__table", "velalltree", "levels_tree", "vel_table", "vals_table", "levelsamdatabase", "velalltab", "levelsalltab", "levelsalltable", "velalltable", "vals_tree", "levelsalltree", "levelsamtree", "vals_database", "levels_code", "levelsamtable", "levels_stable", "levelsallcode", "levels__code", "vel_tree", "levelsamstable", "vel_code", "vel_tab", "levels_database", "velallcode"], "run_table": ["run_test", " runaldata", "runstable", "runertable", "run64range", "runningtype", " runaltable", "runersession", "run_type", "buildalsession", "run64buffer", "runtdata", "runttree", "runsbuffer", "runsrange", "runertype", "runningtree", "array_type", "runningbuffer", " run64table", "array_table", "buildalinterface", "runaltable", "run_range", "runttest", "build_interface", "runerinterface", "runalinterface", "runstree", "arrayertree", "array_tree", "runerbuffer", " run64tree", "build_session", "run64table", "run_session", "runaldata", "runaltest", "buildaldatabase", "run_database", "build_table", "runaltree", "runttable", " run_range", "arrayerbuffer", "runningtable", "run__table", "arrayertype", "runertree", "run__data", "run_tree", "arrayertable", " run_buffer", "run__tree", "run_interface", " runaltree", " run_data", "runaldatabase", "run_buffer", "runerdatabase", "runalbuffer", "runalrange", "array_buffer", "runalsession", "run64tree", "build_database", " run64range", " run64buffer", " run_tree", " run_test", "run__test", " runaltest", "run_data", "buildaltable"], "level_table": ["level___table", "line_code", "levelallcache", "level_stable", "level2database", "level_store", "line_tree", "bitallcourse", "level_cache", "run2tree", "run2database", "level_database", "levelallcourse", "level___tree", "levelalltab", "wl_course", "level_list", "bit_table", "wl_mode", "level_tab", "levelsstore", "line_table", "wl_table", "run_database", "level2stable", "levelptable", "run_tree", "bit_course", "bitallcache", "level_course", "levelalltable", "wl_store", "level_code", "line_list", "levelstable", "level2tree", "bit_tab", "run_stable", "bitalltable", "level___list", "bitalltab", "level_mode", "levelptree", "levelpstable", "bit_cache", "levelscourse", "run2table", "levelsmode", "levelpdatabase", "level___code", "level2table", "level_tree", "run2stable"], "int_table": ["int_tree", "int_session", "int7session", "int24database", "int_stable", "int8stable", "int8tree", "intalltab", "intltab", "int_database", " int_database", "intltable", "int_body", "int_TABLE", " int_tab", "val_module", "int_module", "val_table", "run_session", "int8session", "intalltable", "int7TABLE", "int24tab", "valalltree", "int_bottom", "intalltree", "run_bottom", "run_tree", "run_body", "int8bottom", "run_TABLE", "valalltab", "val_tree", "int24tree", "int8table", "int8TABLE", "intlmodule", "run_stable", "intallmodule", "intltree", " int_tree", "int7bottom", "val_tab", "valallmodule", "int24table", "int_tab", "int8body", "valalltable", "int7table"], "flevel_table": ["flevel2table", "flvl_rule", "flvl32window", "flevel2tab", "flvl32table", "flevel_tab", "flvlertable", "flevelslatest", "flvl_tree", "flevel_window", "flevel_bar", "flvl32code", "flvl_latest", "flvl_range", "flevelsrule", "fall_tree", "flevel_latest", "fvel_bar", "flvl_table", "flvlerlatest", "flevel_cache", "flevel_code", "flevel_rule", "fvel_tab", "flevel32table", "flvl_code", "flevelalltree", "flvl_cache", "flevelerlatest", "flevelertable", "fvel_view", "flevel32range", "flevel2mode", "flevel_tree", "fall_table", "flevelalltable", "flevel_mode", "flevel2view", "flevelertree", "fvel_table", "flevelerrule", "flevel_range", "flvl32range", "flevel2cache", "flvl_root", "flevel_view", "flevel2bar", "flevelstree", "flevelalllatest", "flvlertree", "flevel_root", "flevelallrule", "flevel32code", "flvl_window", "fall_mode", "flevelstable", "flevel32window", "flevel2root", "flvlerrule", "fall_cache", "flevel2tree"], "i": ["ui", "y", "pi", "ie", "di", "e", "d", "si", "mini", "key", "li", "p", "mi", "phi", "qi", "ii", "r", "ki", "u", "line", "ji", "ind", "id", "n", "ni", "c", "m", "t", "ori", "g", "f", "oi", "zi", "io", "a", "ri", "ini", "o", "xi", "uri", "ci", "lc", "z", "b", "iu", "q", "I", "v", "x"], "l": ["e", "d", "pl", "p", "ol", "ls", "ll", "h", "jl", "ii", "r", "lu", "u", "ji", "n", "wl", "m", "c", "L", "kl", "il", "g", "nl", "f", "dl", "el", "o", "sl", "lin", "lc", "la", "z", "b", "ln", "v", "fl", "li"], "j": ["ui", "br", "y", "ie", "aj", "e", "d", "si", "key", "jc", "fl", "p", "ol", "h", "jl", "ij", "ii", "r", "ch", "u", "line", "ji", "dj", "n", "jp", "jo", "m", "c", "g", "f", "ja", "jet", "uj", "jj", "other", "point", "el", "o", "w", "it", "fr", "job", "z", "js", "b", "q", "oj", "v", "J", "x", "li"], "k": ["ak", "y", "kid", "e", "d", "tk", "ik", "key", "p", "ks", "kw", "ko", "K", "kick", "kk", "ki", "r", "u", "ask", "n", "s", "ek", "c", "ck", "t", "unk", "kl", "f", "dk", "w", "o", "ky", "uk", "km", "z", "sk", "ok", "q", "ke", "work", "v", "x"], "level": ["local", "depth", "index", "section", "scale", "levels", "loc", "e", "d", "vel", "key", "val", "where", "p", "Level", "ul", "slice", "h", "sc", "inc", "hi", "position", "update", "line", "id", "n", "wl", "lo", "jo", "child", "temp", "layer", "L", "g", "f", "pass", "cl", "parent", "w", "gi", "list", "o", "loop", "lc", "letter", "pe", "lvl", "z", "length", "iter", "ld", "fl", "li"]}}
{"project": "FFmpeg", "commit_id": "d7b2bb5391bf55e8f9421bff7feb4c1fddfac4bf", "target": 0, "func": "static inline int parse_nal_units(AVCodecParserContext *s,\n\n                                  AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    H264ParseContext *p = s->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    H2645NAL nal = { NULL };\n\n\n\n    unsigned int pps_id;\n\n    unsigned int slice_type;\n\n    int state = -1, got_reset = 0;\n\n    int field_poc[2];\n\n    int ret;\n\n\n\n    /* set some sane default values */\n\n    s->pict_type         = AV_PICTURE_TYPE_I;\n\n    s->key_frame         = 0;\n\n    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;\n\n\n\n    ff_h264_sei_uninit(&p->sei);\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    for (;;) {\n\n        const SPS *sps;\n\n        int src_length, consumed;\n\n        buf = avpriv_find_start_code(buf, buf_end, &state);\n\n        if (buf >= buf_end)\n\n            break;\n\n        --buf;\n\n        src_length = buf_end - buf;\n\n        switch (state & 0x1f) {\n\n        case H264_NAL_SLICE:\n\n        case H264_NAL_IDR_SLICE:\n\n            // Do not walk the whole buffer just to decode slice header\n\n            if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) {\n\n                /* IDR or disposable slice\n\n                 * No need to decode many bytes because MMCOs shall not be present. */\n\n                if (src_length > 60)\n\n                    src_length = 60;\n\n            } else {\n\n                /* To decode up to MMCOs */\n\n                if (src_length > 1000)\n\n                    src_length = 1000;\n\n            }\n\n            break;\n\n        }\n\n\n\n        consumed = ff_h2645_extract_rbsp(buf, src_length, &nal);\n\n        if (consumed < 0)\n\n            break;\n\n\n\n        ret = init_get_bits(&nal.gb, nal.data, nal.size * 8);\n\n        if (ret < 0)\n\n            goto fail;\n\n        get_bits1(&nal.gb);\n\n        nal.ref_idc = get_bits(&nal.gb, 2);\n\n        nal.type    = get_bits(&nal.gb, 5);\n\n\n\n        switch (nal.type) {\n\n        case H264_NAL_SPS:\n\n            ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps);\n\n            break;\n\n        case H264_NAL_PPS:\n\n            ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps,\n\n                                                 nal.size_bits);\n\n            break;\n\n        case H264_NAL_SEI:\n\n            ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx);\n\n            break;\n\n        case H264_NAL_IDR_SLICE:\n\n            s->key_frame = 1;\n\n\n\n            p->poc.prev_frame_num        = 0;\n\n            p->poc.prev_frame_num_offset = 0;\n\n            p->poc.prev_poc_msb          =\n\n            p->poc.prev_poc_lsb          = 0;\n\n        /* fall through */\n\n        case H264_NAL_SLICE:\n\n            get_ue_golomb(&nal.gb);  // skip first_mb_in_slice\n\n            slice_type   = get_ue_golomb_31(&nal.gb);\n\n            s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5];\n\n            if (p->sei.recovery_point.recovery_frame_cnt >= 0) {\n\n                /* key frame, since recovery_frame_cnt is set */\n\n                s->key_frame = 1;\n\n            }\n\n            pps_id = get_ue_golomb(&nal.gb);\n\n            if (pps_id >= MAX_PPS_COUNT) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"pps_id %u out of range\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            if (!p->ps.pps_list[pps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing PPS %u referenced\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data;\n\n            if (!p->ps.sps_list[p->ps.pps->sps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing SPS %u referenced\\n\", p->ps.pps->sps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data;\n\n\n\n            sps = p->ps.sps;\n\n\n\n            p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num);\n\n\n\n            s->coded_width  = 16 * sps->mb_width;\n\n            s->coded_height = 16 * sps->mb_height;\n\n            s->width        = s->coded_width  - (sps->crop_right + sps->crop_left);\n\n            s->height       = s->coded_height - (sps->crop_top   + sps->crop_bottom);\n\n            if (s->width <= 0 || s->height <= 0) {\n\n                s->width  = s->coded_width;\n\n                s->height = s->coded_height;\n\n            }\n\n\n\n            switch (sps->bit_depth_luma) {\n\n            case 9:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P9;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P9;\n\n                break;\n\n            case 10:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P10;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P10;\n\n                break;\n\n            case 8:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P;\n\n                break;\n\n            default:\n\n                s->format = AV_PIX_FMT_NONE;\n\n            }\n\n\n\n            avctx->profile = ff_h264_get_profile(sps);\n\n            avctx->level   = sps->level_idc;\n\n\n\n            if (sps->frame_mbs_only_flag) {\n\n                p->picture_structure = PICT_FRAME;\n\n            } else {\n\n                if (get_bits1(&nal.gb)) { // field_pic_flag\n\n                    p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); // bottom_field_flag\n\n                } else {\n\n                    p->picture_structure = PICT_FRAME;\n\n                }\n\n            }\n\n\n\n            if (nal.type == H264_NAL_IDR_SLICE)\n\n                get_ue_golomb(&nal.gb); /* idr_pic_id */\n\n            if (sps->poc_type == 0) {\n\n                p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc_bottom = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            if (sps->poc_type == 1 &&\n\n                !sps->delta_pic_order_always_zero_flag) {\n\n                p->poc.delta_poc[0] = get_se_golomb(&nal.gb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc[1] = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            /* Decode POC of this picture.\n\n             * The prev_ values needed for decoding POC of the next picture are not set here. */\n\n            field_poc[0] = field_poc[1] = INT_MAX;\n\n            ff_h264_init_poc(field_poc, &s->output_picture_number, sps,\n\n                             &p->poc, p->picture_structure, nal.ref_idc);\n\n\n\n            /* Continue parsing to check if MMCO_RESET is present.\n\n             * FIXME: MMCO_RESET could appear in non-first slice.\n\n             *        Maybe, we should parse all undisposable non-IDR slice of this\n\n             *        picture until encountering MMCO_RESET in a slice of it. */\n\n            if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) {\n\n                got_reset = scan_mmco_reset(s, &nal.gb, avctx);\n\n                if (got_reset < 0)\n\n                    goto fail;\n\n            }\n\n\n\n            /* Set up the prev_ values for decoding POC of the next picture. */\n\n            p->poc.prev_frame_num        = got_reset ? 0 : p->poc.frame_num;\n\n            p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset;\n\n            if (nal.ref_idc != 0) {\n\n                if (!got_reset) {\n\n                    p->poc.prev_poc_msb = p->poc.poc_msb;\n\n                    p->poc.prev_poc_lsb = p->poc.poc_lsb;\n\n                } else {\n\n                    p->poc.prev_poc_msb = 0;\n\n                    p->poc.prev_poc_lsb =\n\n                        p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];\n\n                }\n\n            }\n\n\n\n            if (sps->pic_struct_present_flag) {\n\n                switch (p->sei.picture_timing.pic_struct) {\n\n                case SEI_PIC_STRUCT_TOP_FIELD:\n\n                case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n                    s->repeat_pict = 0;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME:\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    s->repeat_pict = 1;\n\n                    break;\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                    s->repeat_pict = 2;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n                    s->repeat_pict = 3;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n                    s->repeat_pict = 5;\n\n                    break;\n\n                default:\n\n                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n                    break;\n\n                }\n\n            } else {\n\n                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n            }\n\n\n\n            if (p->picture_structure == PICT_FRAME) {\n\n                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;\n\n                if (sps->pic_struct_present_flag) {\n\n                    switch (p->sei.picture_timing.pic_struct) {\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                        s->field_order = AV_FIELD_TT;\n\n                        break;\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                        s->field_order = AV_FIELD_BB;\n\n                        break;\n\n                    default:\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                        break;\n\n                    }\n\n                } else {\n\n                    if (field_poc[0] < field_poc[1])\n\n                        s->field_order = AV_FIELD_TT;\n\n                    else if (field_poc[0] > field_poc[1])\n\n                        s->field_order = AV_FIELD_BB;\n\n                    else\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                }\n\n            } else {\n\n                if (p->picture_structure == PICT_TOP_FIELD)\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;\n\n                else\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;\n\n                s->field_order = AV_FIELD_UNKNOWN;\n\n            }\n\n\n\n            av_freep(&nal.rbsp_buffer);\n\n            return 0; /* no need to evaluate the rest */\n\n        }\n\n        buf += consumed;\n\n    }\n\n    /* didn't find a picture! */\n\n    av_log(avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n\nfail:\n\n    av_freep(&nal.rbsp_buffer);\n\n    return -1;\n\n}\n", "idx": 7609, "substitutes": {"s": ["sci", "sq", "e", "d", "si", "parts", "sb", "sys", "self", "sync", "ls", "S", "ps", "sc", "ses", "qs", "cs", "gs", "sets", "service", "sf", "ds", "xs", "u", "stats", "n", "l", "ss", "c", "sg", "ts", "services", "t", "ctx", "m", "fs", "f", "ns", "space", "sa", "ssl", "se", "i", "sl", "sv", "su", "b", "js", "http", "conf", "parser", "v", "rs", "utils", "spec"], "avctx": ["avectx", "autctx", "avcontext", "autcontext", "avecmd", "autconfig", "AVcontext", "AVconfig", "avecontext", "autcmd", "aveconfig", "AVctx", "AVcmd", "avcmd", "avconfig"], "buf": ["pos", "br", "header", "text", "result", "num", "img", "off", "cmd", "buff", "bc", "f", "pkg", "cf", "front", "b", "count", "v", "batch", "data", "context", "pb", "ref", "ab", "input", "sb", "orig", "offset", "box", "dest", "config", "lim", "cv", "code", "uf", "rb", "cb", "doc", "pool", "uc", "rc", "gb", "bag", "len", "vec", "bo", "block", "fd", "home", "feat", "alloc", "bh", "length", "feed", "window", "wb", "func", "queue", "loc", "src", "seq", "auc", "fb", "ctx", "bg", "cur", "buffer", "wa", "cache", "ff", "port"], "buf_size": ["proc_size", "proc_limit", "buf_ize", "proc_ize", "buf_form", " buf_sized", "proc_start", "buf_sized", "buflexsized", "buflexsize", "buflexend", "buf_limit", "buf_start", " buf_width", "buflexwidth", " buf_form", "buf_width"], "p": ["pb", "pc", "pi", "np", "j", "vp", "pre", "e", "d", "tp", "op", "api", "mp", "h", "ps", "u", "pa", "sp", "P", "n", "ap", "l", "jp", "press", "c", "m", "t", "ctx", "g", "f", "pp", "pkg", "i", "lp", "bp", "b", "q", "fp", "parser", "v", "port"], "buf_end": ["buf_offset", "buf2start", "buf00end", "img_ent", "img00start", "buf_clean", "buf2ending", "buf00offset", "queue_stop", "buf_start", "buff_start", "buff_end", "buf00length", "uc_clean", "queue_start", "uc_start", "queue_end", "img00ent", "buf_ent", "buf00ent", "buff00ent", "buff_ent", "img00length", "buf_ended", "img00end", "queue_ending", "buff00offset", "buf2end", "buf_stop", "buf00start", "buf_length", "buff_offset", "img_length", "uc_end", "buf2stop", "uc_ended", "img_start", "buff00end", "buff00start", "img_end", "buf_ending"], "pps_id": [" seq_sid", " img_num", " seq_key", " seqessionsid", " seqessionnum", " seqessionid", " img_id", " seq_id", " img_key", " img_sid", " seqessionkey", " seq_num"], "slice_type": ["proc_width", "slice_types", "proc_type", "slice___type", "proc_types", "slice___id", "proc_id", "slice___types", "slice_id", "slice___width", "slice_width"], "field_poc": ["field_dics", "field_copics", "field_tics", "field2poc", "field_docol", "field2pics", "field2pocol", "field2div", "field_pocol", "field_piv", "field_tiv", "field_div", "field2dics", "field_toc", "field_pics", "field_copiv", "field_copocol", "field_doc", "field2docol", "field_tocol", "field2piv", "field2doc", "field_copoc"], "ret": ["data", "hash", "re", "ref", "def", "mt", "result", "fun", "rep", "alt", "success", "back", "value", "att", "bf", "len", "val", " RET", " Ret", "mem", "arr", "no", "gc", "bit", "seq", "num", "RET", "conn", "resp", "reg", "lit", "flag", "feat", "gt", "det", "ft", "match", "nt", "reply", "arg", "sat", "status", "count", "rets", "Ret", "rt"], "sps": ["spp", "spps", "Spps", "sPS", "SPS", "ssps", "sspps", "ssPS", "Sps", " sPS", " spp", " spps", "Spp", "sspp"], "src_length": ["rc_shape", "proc64full", "srcenwidth", " src_width", "proc64off", "src64off", " src_size", "src_var", "src___length", "srcsdistance", "proc_full", "srcsposition", "rc_cost", "src2width", "srcslength", "proc_width", "rc_width", "src_width", "rc_path", "src_path", "srcenpath", "srcenlength", "rc_height", "srcencost", "src00width", "src_distance", "src_position", "src___width", "src_size", "proc_length", "src_height", "src64width", "src2length", "src2size", "proc64width", "src2path", "src00height", "source_position", "src___shape", "proc_off", "src_full", "src00limit", "src___var", "srcslen", "src00length", "src64full", "rc_limit", "src_limit", "rc_length", "src_off", "source_len", "proc64length", "src_cost", "src64length", "source_distance", "source_length", "rc_var", "src_len", "src_shape", " src_path"], "consumed": ["consum", "conerved", "resumed", "conumed", "coerved", "consume", "conserved", "presum", "Consume", "coume", "resuming", "Consumed", "resumption", "consumption", " conserved", "conum", "Consuming", "Consumption", "continumption", "reserved", "continume", " consuming", "consuming", "presumed", "Conserved", "conume", "continumed", "Consum", " consumption", "coumed", "preserved", "presume", "coumption", "continerved"]}}
{"project": "FFmpeg", "commit_id": "c94326c1fc2fb5719c6f28fe1b95c0c74417998b", "target": 1, "func": "static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,\n\n                                              int log2_size, int c_idx)\n\n{\n\n#define PU(x) \\\n\n    ((x) >> s->ps.sps->log2_min_pu_size)\n\n#define MVF(x, y) \\\n\n    (s->ref->tab_mvf[(x) + (y) * min_pu_width])\n\n#define MVF_PU(x, y) \\\n\n    MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift)))\n\n#define IS_INTRA(x, y) \\\n\n    (MVF_PU(x, y).pred_flag == PF_INTRA)\n\n#define MIN_TB_ADDR_ZS(x, y) \\\n\n    s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)]\n\n#define EXTEND(ptr, val, len)         \\\n\ndo {                                  \\\n\n    pixel4 pix = PIXEL_SPLAT_X4(val); \\\n\n    for (i = 0; i < (len); i += 4)    \\\n\n        AV_WN4P(ptr + i, pix);        \\\n\n} while (0)\n\n\n\n#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(i, -1))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i+3])\n\n#define EXTEND_LEFT_CIP(ptr, start, length) \\\n\n        for (i = start; i > (start) - (length); i--) \\\n\n            if (!IS_INTRA(i - 1, -1)) \\\n\n                ptr[i - 1] = ptr[i]\n\n#define EXTEND_UP_CIP(ptr, start, length)                                      \\\n\n        for (i = (start); i > (start) - (length); i -= 4)                      \\\n\n            if (!IS_INTRA(-1, i - 3))                                          \\\n\n                AV_WN4P(&ptr[i - 3], a);                                       \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i - 3])\n\n#define EXTEND_DOWN_CIP(ptr, start, length)                                    \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(-1, i))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i + 3])\n\n\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int i;\n\n    int hshift = s->ps.sps->hshift[c_idx];\n\n    int vshift = s->ps.sps->vshift[c_idx];\n\n    int size = (1 << log2_size);\n\n    int size_in_luma_h = size << hshift;\n\n    int size_in_tbs_h  = size_in_luma_h >> s->ps.sps->log2_min_tb_size;\n\n    int size_in_luma_v = size << vshift;\n\n    int size_in_tbs_v  = size_in_luma_v >> s->ps.sps->log2_min_tb_size;\n\n    int x = x0 >> hshift;\n\n    int y = y0 >> vshift;\n\n    int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n    int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n\n\n    int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb);\n\n\n\n    ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel);\n\n    pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride;\n\n\n\n    int min_pu_width = s->ps.sps->min_pu_width;\n\n\n\n    enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c :\n\n                              lc->tu.intra_pred_mode;\n\n    pixel4 a;\n\n    pixel  left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  top_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_top_array[2 * MAX_TB_SIZE + 1];\n\n\n\n    pixel  *left          = left_array + 1;\n\n    pixel  *top           = top_array  + 1;\n\n    pixel  *filtered_left = filtered_left_array + 1;\n\n    pixel  *filtered_top  = filtered_top_array  + 1;\n\n    int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask);\n\n    int cand_left        = lc->na.cand_left;\n\n    int cand_up_left     = lc->na.cand_up_left;\n\n    int cand_up          = lc->na.cand_up;\n\n    int cand_up_right    = lc->na.cand_up_right    && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1);\n\n\n\n    int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) -\n\n                           (y0 + size_in_luma_v)) >> vshift;\n\n    int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) -\n\n                           (x0 + size_in_luma_h)) >> hshift;\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        int size_in_luma_pu_v = PU(size_in_luma_v);\n\n        int size_in_luma_pu_h = PU(size_in_luma_h);\n\n        int on_pu_edge_x    = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size);\n\n        int on_pu_edge_y    = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size);\n\n        if (!size_in_luma_pu_h)\n\n            size_in_luma_pu_h++;\n\n        if (cand_bottom_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_bottom_pu = PU(y0 + size_in_luma_v);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu);\n\n            cand_bottom_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_left_pu   = PU(y0);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu);\n\n            cand_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_left == 1) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA;\n\n        }\n\n        if (cand_up == 1 && on_pu_edge_y) {\n\n            int x_top_pu    = PU(x0);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu);\n\n            cand_up = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_right == 1 && on_pu_edge_y) {\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int x_right_pu  = PU(x0 + size_in_luma_h);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu);\n\n            cand_up_right = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        top[-1] = 128;\n\n    }\n\n    if (cand_up_left) {\n\n        left[-1] = POS(-1, -1);\n\n        top[-1]  = left[-1];\n\n    }\n\n    if (cand_up)\n\n        memcpy(top, src - stride, size * sizeof(pixel));\n\n    if (cand_up_right) {\n\n        memcpy(top + size, src - stride + size, size * sizeof(pixel));\n\n        EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1),\n\n               size - top_right_size);\n\n    }\n\n    if (cand_left)\n\n        for (i = 0; i < size; i++)\n\n            left[i] = POS(-1, i);\n\n    if (cand_bottom_left) {\n\n        for (i = size; i < size + bottom_left_size; i++)\n\n            left[i] = POS(-1, i);\n\n        EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1),\n\n               size - bottom_left_size);\n\n    }\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) {\n\n            int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ?\n\n                                    2 * size : (s->ps.sps->width - x0) >> hshift;\n\n            int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ?\n\n                                    2 * size : (s->ps.sps->height - y0) >> vshift;\n\n            int j = size + (cand_bottom_left? bottom_left_size: 0) -1;\n\n            if (!cand_up_right) {\n\n                size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ?\n\n                                                    size : (s->ps.sps->width - x0) >> hshift;\n\n            }\n\n            if (!cand_bottom_left) {\n\n                size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ?\n\n                                                     size : (s->ps.sps->height - y0) >> vshift;\n\n            }\n\n            if (cand_bottom_left || cand_left || cand_up_left) {\n\n                while (j > -1 && !IS_INTRA(-1, j))\n\n                    j--;\n\n                if (!IS_INTRA(-1, j)) {\n\n                    j = 0;\n\n                    while (j < size_max_x && !IS_INTRA(j, -1))\n\n                        j++;\n\n                    EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    left[-1] = top[-1];\n\n                }\n\n            } else {\n\n                j = 0;\n\n                while (j < size_max_x && !IS_INTRA(j, -1))\n\n                    j++;\n\n                if (j > 0)\n\n                    if (x0 > 0) {\n\n                        EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    } else {\n\n                        EXTEND_LEFT_CIP(top, j, j);\n\n                        top[-1] = top[0];\n\n                    }\n\n                left[-1] = top[-1];\n\n            }\n\n            left[-1] = top[-1];\n\n            if (cand_bottom_left || cand_left) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_DOWN_CIP(left, 0, size_max_y);\n\n            }\n\n            if (!cand_left)\n\n                EXTEND(left, left[-1], size);\n\n            if (!cand_bottom_left)\n\n                EXTEND(left + size, left[size - 1], size);\n\n            if (x0 != 0 && y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n                if (!IS_INTRA(-1, - 1))\n\n                    left[-1] = left[0];\n\n            } else if (x0 == 0) {\n\n                EXTEND(left, 0, size_max_y);\n\n            } else {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n            }\n\n            top[-1] = left[-1];\n\n            if (y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_RIGHT_CIP(top, 0, size_max_x);\n\n            }\n\n        }\n\n    }\n\n    // Infer the unavailable samples\n\n    if (!cand_bottom_left) {\n\n        if (cand_left) {\n\n            EXTEND(left + size, left[size - 1], size);\n\n        } else if (cand_up_left) {\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_left = 1;\n\n        } else if (cand_up) {\n\n            left[-1] = top[0];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else if (cand_up_right) {\n\n            EXTEND(top, top[size], size);\n\n            left[-1] = top[size];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up      = 1;\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else { // No samples available\n\n            left[-1] = (1 << (BIT_DEPTH - 1));\n\n            EXTEND(top,  left[-1], 2 * size);\n\n            EXTEND(left, left[-1], 2 * size);\n\n        }\n\n    }\n\n\n\n    if (!cand_left)\n\n        EXTEND(left, left[size], size);\n\n    if (!cand_up_left) {\n\n        left[-1] = left[0];\n\n    }\n\n    if (!cand_up)\n\n        EXTEND(top, left[-1], size);\n\n    if (!cand_up_right)\n\n        EXTEND(top + size, top[size - 1], size);\n\n\n\n    top[-1] = left[-1];\n\n\n\n    // Filtering process\n\n    if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0  || s->ps.sps->chroma_format_idc == 3)) {\n\n        if (mode != INTRA_DC && size != 4){\n\n            int intra_hor_ver_dist_thresh[] = { 7, 1, 0 };\n\n            int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)),\n\n                                          FFABS((int)(mode - 10U)));\n\n            if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) {\n\n                int threshold = 1 << (BIT_DEPTH - 5);\n\n                if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 &&\n\n                    log2_size == 5 &&\n\n                    FFABS(top[-1]  + top[63]  - 2 * top[31])  < threshold &&\n\n                    FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) {\n\n                    // We can't just overwrite values in top because it could be\n\n                    // a pointer into src\n\n                    filtered_top[-1] = top[-1];\n\n                    filtered_top[63] = top[63];\n\n                    for (i = 0; i < 63; i++)\n\n                        filtered_top[i] = ((64 - (i + 1)) * top[-1] +\n\n                                           (i + 1)  * top[63] + 32) >> 6;\n\n                    for (i = 0; i < 63; i++)\n\n                        left[i] = ((64 - (i + 1)) * left[-1] +\n\n                                   (i + 1)  * left[63] + 32) >> 6;\n\n                    top = filtered_top;\n\n                } else {\n\n                    filtered_left[2 * size - 1] = left[2 * size - 1];\n\n                    filtered_top[2 * size - 1]  = top[2 * size - 1];\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_left[i] = (left[i + 1] + 2 * left[i] +\n\n                                            left[i - 1] + 2) >> 2;\n\n                    filtered_top[-1]  =\n\n                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2;\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_top[i] = (top[i + 1] + 2 * top[i] +\n\n                                           top[i - 1] + 2) >> 2;\n\n                    left = filtered_left;\n\n                    top  = filtered_top;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (mode) {\n\n    case INTRA_PLANAR:\n\n        s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                          (uint8_t *)left, stride);\n\n        break;\n\n    case INTRA_DC:\n\n        s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top,\n\n                       (uint8_t *)left, stride, log2_size, c_idx);\n\n        break;\n\n    default:\n\n        s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                           (uint8_t *)left, stride, c_idx,\n\n                                           mode);\n\n        break;\n\n    }\n\n}\n", "idx": 7622, "substitutes": {"s": ["context", "sq", "e", "sys", "p", "ls", "session", "S", "ps", "ses", "cs", "gs", "n", "ops", "c", "m", "services", "ctx", "fs", "g", "f", "ns", "ssl", "w", "js", "b", "qs", "spec"], "x0": [" x10", "f10", "X2", "f2", " x2", "X0", "f0", "x10", "x2", "X10"], "y0": ["y2", "dy00", "x00", "y00", "Y2", "dy2", "Y00", "x2", "Y0", "dy0"], "log2_size": ["log2_depth", "log1_depth", "log2logdepth", "log1_width", "log2logsize", "log1_size", "log2logwidth", "log2_count", "log1_count", "log2logcount", "log2_width"], "c_idx": ["c_midv", "c_idv", "c_oidg", "c_midg", "c_oidy", "c_ridg", "c_oidv", "c_midy", "c_midx", "c_ridx", "c_idy", "c_ridv", "c_ridy", "c_oidx", "c_idg"], "i": ["ui", "bi", "index", "pi", "ie", "di", "e", "d", "mini", "multi", "fi", "ti", "p", "yi", "api", "slice", "mi", "phi", "qi", "ii", "anti", "hi", "adi", "inner", "id", "n", "ni", "l", "ip", "abi", "m", "init", "t", "ix", "sup", "g", "zi", "io", "start", "ri", "ini", "my", "info", "gi", "mu", "xi", "uri", "o", "ci", "eni", "me", "z", "in", "iu", "I", "ai", "si", "li"], "a": ["an", "da", "area", "ab", "e", "na", "A", "ata", "p", "ace", "xa", "pa", "c", "ba", "ta", "alpha", "sa", "as", "sta", "ad", "ar", "ca", "va", "la", "span", "ra", "b", "aa"]}}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n", "idx": 7649, "substitutes": {"ctx": ["context", "sci", "rc", "conv", "wcs", "loc", "tk", "component", "exec", "cc", "anc", "cli", "src", "cus", "client", "xc", "conn", "ct", "sc", "cm", "cs", "config", "fw", "cmd", "ctr", "cca", "tx", "Context", "obj", "ck", "c", "bc", "px", "kb", "kt", "ctrl", "cv", "cam", "pkg", "conf", "concept", "fc", "cu", "cf", "ca", "tc", "cn", "ci", "lc", "cas", "sk", "cb", "cmp", "vc", "cp"], "tile": ["context", "frame", "ie", "target", "scale", "Tile", "tk", "component", "coll", "tool", "cli", "tto", "grade", "dt", "so", "zip", "slice", "ski", "texture", "coe", "kick", "conn", "grid", "ace", "module", "image", "ne", "tt", "ctr", "file", "task", "plane", "tu", "txt", "layer", "race", "px", "oi", "kt", "oe", "tm", "plate", "tif", "late", "fit", "crop", "cache", "phy", "cu", "cf", "tc", "chip", "uri", "ci", "pixel", "lane", "ilo", "qt", "sk", "feature", "tf", "ptr", "cp", "thread", "update", "rt"], "outlink": ["outerloop", "libstyle", "outputpath", "outhide", "againload", "pointlock", " outloop", "libline", "liblinked", "inloop", "offloop", "inlock", "outLink", "againstyle", " outlinked", "apploop", "offload", "outerload", "outputstyle", "upstyle", "outload", "outloop", "uplink", "pointline", "pointLink", "pointlink", "outstyle", " outLink", "outline", "againlike", "outpath", "uploop", "offlinked", "outputlink", "inlink", "applink", "inLink", " outline", " outlock", "outputlike", "upline", "againlink", "outlinked", "offlink", " outload", "inlinked", "outlike", "applinked", "inload", " outstyle", "outlock", "uplike", "againhide", "uppath", "againpath", "upload", "outerlink", "liblink", "instyle", " outhide", "outerhide", "appload", "againloop"], "out_buf": ["outPbuffer", "out_ref", "in_buf", "outIPbuf", "outfbuf", "in_buffer", "in_buff", "out_block", "outingcache", " out_bag", "outFbuffer", "out_buff", "out_queue", "outAcbuff", "outFbuf", " outPbuf", " out_uf", "in_ref", "outingbuf", "outfref", "outfbuffer", "outFuf", "out_cb", " out_buff", "out_bag", " out_cache", "outIPblock", "out_cache", "out2cb", "outfqueue", "outdbuff", "outingbuffer", " outPbag", "out2buffer", "outdbuffer", "outAcbuffer", "outingbuff", "out2buf", "outAcbuf", " out_buffer", " outPbuffer", " out_block", " outPuf", "in_cb", "outdbuf", "in_queue", "outAccache", "out_buffer", "outPbag", "outdqueue", "outfbuff", "outIPbuff", "out_uf", "out2block", "outFbag", "out2buff", "outPuf", "outPbuf"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = &first_oformat;\n\n\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n\n\n    *p = format;\n\n    format->next = NULL;\n\n}\n", "idx": 7651, "substitutes": {"format": ["output", "data", "pat", "form", "layout", "before", "set", "xml", "after", "package", "pre", "document", "print", "pretty", "export", "op", "template", "api", "type", "style", "pair", "record", "edit", "at", "plugin", "ap", "option", "pattern", "temp", "t", "ant", "f", "primary", "array", "point", "attribute", "model", "writer", "parent", "Format", "operator", "prefix", "post", "fp", "parser", "method", "transform", "first"], "p": ["data", "pat", "pc", "pi", "np", "k", "before", "php", "j", "after", "pre", "e", "d", "tp", "op", "template", "ps", "pr", "patch", "pa", "u", "P", "n", "l", "jp", "ap", "c", "m", "t", "g", "f", "point", "a", "part", "parent", "i", "o", "lp", "python", "pe", "bp", "b", "q", "fp", "cp", "parser", "v", "port"]}}
{"project": "qemu", "commit_id": "d5de7839d78b08c7bd14b03dac0413699b90da67", "target": 1, "func": "static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int op1;\n\n    int32_t r1, r2, r3;\n\n    int32_t address, const16;\n\n    int8_t b, const4;\n\n    int32_t bpos;\n\n    TCGv temp, temp2, temp3;\n\n\n\n    op1 = MASK_OP_MAJOR(ctx->opcode);\n\n\n\n    /* handle JNZ.T opcode only being 7 bit long */\n\n    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {\n\n        op1 = OPCM_32_BRN_JTT;\n\n    }\n\n\n\n    switch (op1) {\n\n/* ABS-format */\n\n    case OPCM_32_ABS_LDW:\n\n        decode_abs_ldw(env, ctx);\n\n\n    case OPCM_32_ABS_LDB:\n\n        decode_abs_ldb(env, ctx);\n\n\n    case OPCM_32_ABS_LDMST_SWAP:\n\n        decode_abs_ldst_swap(env, ctx);\n\n\n    case OPCM_32_ABS_LDST_CONTEXT:\n\n        decode_abs_ldst_context(env, ctx);\n\n\n    case OPCM_32_ABS_STORE:\n\n        decode_abs_store(env, ctx);\n\n\n    case OPCM_32_ABS_STOREB_H:\n\n        decode_abs_storeb_h(env, ctx);\n\n\n    case OPC1_32_ABS_STOREQ:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_LEUW);\n\n\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LD_Q:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUW);\n\n        tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16);\n\n\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LEA:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address));\n\n\n/* ABSB-format */\n\n    case OPC1_32_ABSB_ST_T:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        b = MASK_OP_ABSB_B(ctx->opcode);\n\n        bpos = MASK_OP_ABSB_BPOS(ctx->opcode);\n\n\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_qemu_ld_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos));\n\n        tcg_gen_ori_tl(temp2, temp2, (b << bpos));\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n\n/* B-format */\n\n    case OPC1_32_B_CALL:\n\n    case OPC1_32_B_CALLA:\n\n    case OPC1_32_B_J:\n\n    case OPC1_32_B_JA:\n\n    case OPC1_32_B_JL:\n\n    case OPC1_32_B_JLA:\n\n        address = MASK_OP_B_DISP24(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, 0, 0, 0, address);\n\n\n/* Bit-format */\n\n    case OPCM_32_BIT_ANDACC:\n\n        decode_bit_andacc(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T1:\n\n        decode_bit_logical_t(env, ctx);\n\n\n    case OPCM_32_BIT_INSERT:\n\n        decode_bit_insert(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T2:\n\n        decode_bit_logical_t2(env, ctx);\n\n\n    case OPCM_32_BIT_ORAND:\n\n        decode_bit_orand(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC1:\n\n        decode_bit_sh_logic1(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC2:\n\n        decode_bit_sh_logic2(env, ctx);\n\n\n    /* BO Format */\n\n    case OPCM_32_BO_ADDRMODE_POST_PRE_BASE:\n\n        decode_bo_addrmode_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE:\n\n        decode_bo_addrmode_ld_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ld_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE:\n\n        decode_bo_addrmode_stctx_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ldmst_bitreverse_circular(env, ctx);\n\n\n/* BOL-format */\n\n    case OPC1_32_BOL_LD_A_LONGOFF:\n\n    case OPC1_32_BOL_LD_W_LONGOFF:\n\n    case OPC1_32_BOL_LEA_LONGOFF:\n\n    case OPC1_32_BOL_ST_W_LONGOFF:\n\n    case OPC1_32_BOL_ST_A_LONGOFF:\n\n        decode_bol_opc(env, ctx, op1);\n\n\n/* BRC Format */\n\n    case OPCM_32_BRC_EQ_NEQ:\n\n    case OPCM_32_BRC_GE:\n\n    case OPCM_32_BRC_JLT:\n\n    case OPCM_32_BRC_JNE:\n\n        const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode);\n\n        address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRC_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, const4, address);\n\n\n/* BRN Format */\n\n    case OPCM_32_BRN_JTT:\n\n        address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRN_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, 0, address);\n\n\n/* BRR Format */\n\n    case OPCM_32_BRR_EQ_NEQ:\n\n    case OPCM_32_BRR_ADDR_EQ_NEQ:\n\n    case OPCM_32_BRR_GE:\n\n    case OPCM_32_BRR_JLT:\n\n    case OPCM_32_BRR_JNE:\n\n    case OPCM_32_BRR_JNZ:\n\n    case OPCM_32_BRR_LOOP:\n\n        address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode);\n\n        r2 = MASK_OP_BRR_S2(ctx->opcode);\n\n        r1 = MASK_OP_BRR_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, r2, 0, address);\n\n\n/* RC Format */\n\n    case OPCM_32_RC_LOGICAL_SHIFT:\n\n        decode_rc_logical_shift(env, ctx);\n\n\n    case OPCM_32_RC_ACCUMULATOR:\n\n        decode_rc_accumulator(env, ctx);\n\n\n    case OPCM_32_RC_SERVICEROUTINE:\n\n        decode_rc_serviceroutine(env, ctx);\n\n\n    case OPCM_32_RC_MUL:\n\n        decode_rc_mul(env, ctx);\n\n\n/* RCPW Format */\n\n    case OPCM_32_RCPW_MASK_INSERT:\n\n        decode_rcpw_insert(env, ctx);\n\n\n/* RCRR Format */\n\n    case OPC1_32_RCRR_INSERT:\n\n        r1 = MASK_OP_RCRR_S1(ctx->opcode);\n\n        r2 = MASK_OP_RCRR_S3(ctx->opcode);\n\n        r3 = MASK_OP_RCRR_D(ctx->opcode);\n\n        const16 = MASK_OP_RCRR_CONST4(ctx->opcode);\n\n        temp = tcg_const_i32(const16);\n\n        temp2 = tcg_temp_new(); /* width*/\n\n        temp3 = tcg_temp_new(); /* pos */\n\n\n\n        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);\n\n        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);\n\n\n\n        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp3);\n\n\n/* RCRW Format */\n\n    case OPCM_32_RCRW_MASK_INSERT:\n\n        decode_rcrw_insert(env, ctx);\n\n\n/* RCR Format */\n\n    case OPCM_32_RCR_COND_SELECT:\n\n        decode_rcr_cond_select(env, ctx);\n\n\n    case OPCM_32_RCR_MADD:\n\n        decode_rcr_madd(env, ctx);\n\n\n    case OPCM_32_RCR_MSUB:\n\n        decode_rcr_msub(env, ctx);\n\n\n/* RLC Format */\n\n    case OPC1_32_RLC_ADDI:\n\n    case OPC1_32_RLC_ADDIH:\n\n    case OPC1_32_RLC_ADDIH_A:\n\n    case OPC1_32_RLC_MFCR:\n\n    case OPC1_32_RLC_MOV:\n\n    case OPC1_32_RLC_MOV_64:\n\n    case OPC1_32_RLC_MOV_U:\n\n    case OPC1_32_RLC_MOV_H:\n\n    case OPC1_32_RLC_MOVH_A:\n\n    case OPC1_32_RLC_MTCR:\n\n        decode_rlc_opc(env, ctx, op1);\n\n\n\n\n\n\n    }\n\n}", "idx": 7654, "substitutes": {"env": ["context", "iss", "scope", "rc", "eu", "np", "db", "loc", "enh", "loader", "enc", "exc", "fi", "cli", "event", "ea", "que", "src", "buf", "conn", "vs", "ev", "config", "inv", "viron", "tx", "cdn", "txt", "impl", "chev", "c", "init", "entry", "cur", "nw", "inst", "ec", "en", "cv", "req", "pkg", "err", "kn", "cf", "erv", "eni", "qt", "esi", "cb", "priv", "vc", "v", "environment"], "ctx": ["pc", "conv", "np", "sync", "rx", "ce", "cor", "cmd", "bc", "pkg", "hw", "cases", "concept", "cu", "cf", "ca", "fp", "conf", "linux", "context", " cx", "sq", "exec", "cli", "kw", "cm", "cs", "git", "config", "fw", "txt", "ck", "cl", "cv", "kn", "cn", "lc", "cb", "vc", "ha", "util", "rc", "sys", "wx", "history", "xc", "conn", "jp", "cca", "tx", "c", "kb", "qa", "cmp", "cp", "handler", "sci", "cfg", "nc", "scope", "wcs", "loc", "exc", "anc", "cc", "event", "client", " context", "sc", "ch", "Context", "obj", "ctrl", "tc", "ci", "cas", "utils"], "op1": ["op3", "ops2", "oper1", "compOne", "comp1", "copn", "optOne", "op0", "OP2", "mod3", " op3", "opt3", "OP1", "mod8", "opern", "oct01", " op2", "op2", "operOne", "octone", "opOne", "ops1", "oper81", "cop1", " op01", "opt2", "operone", "mod2", "opt81", " op0", "ip1", "octn", "op81", "oper01", " opOne", "OPone", "opn", "opt8", "ip01", "comp01", "oct1", "opsone", "mod1", " opone", "op01", "copone", "cop01", "ipOne", "opone", "opt1", "op8", " op81", "OP0", "ops0", " op8"], "r1": ["p1", "p8", "sr8", "rr3", "sr2", " r5", "R2", "r5", "p2", "rr2", "sr3", "r8", "R3", "R5", "R8", "sr1", "R1", "rr1", "rr5"], "r2": ["p2", " r02", "p1", "p4", " r4", "R4", "r02", "R02", "R1", "p02", "r4", "R2"], "r3": ["R03", "R3", "rar3", "rar4", " r4", "R4", "r15", "R15", " r15", "rar15", "rar03", " r03", "r03", "r4"], "address": ["index", "header", "ress", "target", "number", "cp", "argument", "error", "element", "slave", "message", "interface", "byte", "grade", "map", "pair", "h", "Address", "type", "order", "ace", "offset", "channel", "cm", "position", "balance", "config", "resource", "service", "device", "ACE", "password", "r", "ip", "block", "contract", "activity", "m", "mode", "layer", "dc", "host", "repeat", "path", "pointer", "source", "array", "location", "capacity", "attribute", "network", "account", "i", "reference", "size", "tc", "code", "uri", " Address", "image", "route", "shape", "length", "state", "addr", "ptr", "ai", "port", "output", "x", "base"], "const16": [" const32", "float32", " const18", "esc32", "float33", "const32", "float18", "float16", "esc18", "esc33", "esc16", " const33", "const33", "const18"], "b": ["bi", "wb", "br", "lb", "k", "B", "bf", "sb", "mb", "p", "bm", "bl", "h", "buf", "r", "bb", "n", "c", "ba", "nb", "f", "ib", "be", "a", "bd", "xb", "cb", "v", "base"], "const4": ["const40", "contract4", "contract8", "const10", "con10", " const10", " const8", "const8", "contract40", "contract10", " const40", "con40", "con4", "con8"], "bpos": ["bbindex", "bindex", "bcol", "bval", "blval", "lbpos", "lbcol", "lbindex", "bbcol", "lbval", "bbval", "blpos", "blindex", "blcol", "bbpos"], "temp": ["stable", "context", "data", "flat", "local", "form", "ex", "seed", "bag", "result", "loc", "wrap", "input", "get", "mini", "now", "emp", "mem", "template", "zip", "session", "style", "test", "empty", "config", "Temp", "current", "wl", "fake", "txt", "tmp", "buffer", "pt", "pointer", "ctrl", "tm", "cel", "model", "cache", "tem", "tc", "comb", "lc", "wrapper", "store", "timeout", "iter", "col", "adj", "wait", "cp", "v", "output", "base"], "temp2": ["wrap4", "result4", "tem2", " temp5", " temp1", "result2", "TempTwo", "tem1", " temp4", "resultTwo", "temp1", "fakeTwo", "Temp5", "tem4", "Temp1", "wrap5", "Temp3", "buff2", "tem200", "Temp4", "temp4", "fake1", "wrap1", "temp5", "result1", " tempTwo", "fake2", "buff3", "Temp2", "temp200", "Temp200", "wrap2", "tempTwo", "buff1", " temp200"], "temp3": ["current23", "current6", " temp6", "temp1", "tem23", " temp23", "temp23", "tem3", "current1", " temp1", "temp6", "tem6", "current3", "tem1"]}}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n", "idx": 7659, "substitutes": {"frame": ["data", "layout", "object", "figure", "scale", "ground", "element", "e", "frames", "view", "build", "component", "coll", "row", "game", "fe", "slice", "flow", "style", "filter", "iframe", "rame", "image", "module", "position", "update", "config", "line", "flower", "file", "fb", "plane", "video", "motion", "property", "buffer", "draw", "scene", "point", "parse", "Frame", "model", "el", "part", "feat", "za", "fram", "filename", "cf", "fr", "series", "state", "live", "node", "feature", "setup", "feed", "framework", "window", "panel", "base"], "perms": [" permissions", "arfs", "Permissions", " perps", "Perm", "PERmm", "arm", " percs", "Percs", "PERcs", " perfs", "perfs", "permissions", "percs", " permm", "perm", "Permm", "Perps", "Perfs", "arms", " perm", "arps", "PERms", "Perms", "permm", "perps", "PERmissions"], "picref": ["icRef", "fcdef", "icreference", "pcdef", "icdef", "picval", "fcref", "lcval", "icref", " picbf", "lcref", "lcreference", " picRef", "fcreference", " picval", "picRef", " picdef", "camref", "lcRef", "pcRef", "picdef", "icurl", "fcbf", " picurl", "camreference", "fcurl", "picreference", "camRef", "pcref", "pcreference", "fcRef", "fcval", "picurl", " picreference", "cambf", "picbf"]}}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n", "idx": 7662, "substitutes": {"ptr": ["py", "pos", "ffff", "br", "pc", "ext", "push", "ref", "pre", "loc", "uint", "len", "tty", "call", "xt", "p", "slice", "src", "mp", "type", "esc", "offset", "ctr", "dim", "Ptr", "temp", "c", "sh", "inter", "tmp", "transfer", "bc", "address", "tr", "buffer", "pointer", "shift", "cur", "point", "inst", "req", "parent", "err", "i", "alloc", "code", "dr", "ci", "shape", "length", "attr", "addr", "priv", "cp", "cmp"], "size": ["new", "sec", "small", "scale", "name", "loc", "adjust", "len", "now", "self", "fe", "p", "call", "sync", "args", "type", "last", "esc", "offset", "cs", "empty", "SIZE", "n", "large", "ize", "c", "sized", "Size", "address", "pointer", "shift", "capacity", "sn", "fee", "code", "here", "z", "shape", "length", "six", "zero", "si"], "old_size": ["old_capacity", "old_length", " old_address", " old_capacity", "old_address", " old_ptr", " old_length", "old_ize", " old_ize", " old_scale", "old_width", " old_width", "old_ptr", "old_scale"], "copy": ["py", "pos", "new", "replace", "rc", "cop", "scale", "clone", "le", "coll", "co", "hide", "core", "ignore", "call", "write", "sync", "slice", "move", "ce", "type", "clip", "test", "offset", "empty", "use", "delete", "create", "skip", "ck", "ize", "lex", "transfer", "repeat", "buffer", "shift", "Copy", "opy", "oe", "min", "parent", "i", "code", "cap", "pe", "like", "ge", "null", "cmp", "cp"], "new_ptr": ["new__size", "old_addr", "old_length", "new_addr", "new__pointer", "new_alloc", " new_addr", "new__ptr", " new_handle", "new_size", "new_pointer", "old_pointer", " new_size", " new_alloc", "new_handle", "new__addr", "old_ptr", " new_pointer", "new_length"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n", "idx": 7666, "substitutes": {"o": ["options", "O", "ou", "k", "oa", "oci", "od", "e", "d", "oper", "ocol", "so", "op", "p", "ko", "r", "oco", "n", "ob", "s", "ops", "c", "m", "t", "og", "oi", "f", "OC", "io", "or", "ow", "ot", "oo", "po", "os", "oid"], "oc": ["oca", "unc", "uc", "pc", "rc", "oci", "ict", "loc", "ocl", "enc", "cot", "co", "isc", "oper", "ocol", "anc", "cc", "op", "org", "ocr", "ct", "soc", "inc", "roc", "config", "oco", "voc", "ic", "asc", "c", "toc", "bc", "dc", "OC", "mc", "ogg", "osc", "ec", "fc", "cu", "iv", "mic", "ci", "lc", "ac", "os", "oid", "irc"], "st": ["ste", "uc", "storage", "sth", "stack", "od", "ust", "loc", "ast", "sb", "str", "fe", "std", "src", "sc", "ct", "stop", "sp", "est", "sign", "et", "stage", "sts", "ut", "St", "ob", "ss", "c", "rest", "step", "cr", "pt", "art", "kt", "nd", "put", "inst", "sn", "osc", "cl", "start", "sta", "sl", "ft", "stream", "sw", "store", "os", "ist", "ptr", "ld", "ST", "stim"], "ost": ["pos", "object", "sth", "od", "ado", "ust", "ast", "omm", "ood", "oper", "ocol", "so", "tto", "op", "pod", "fe", "ott", "src", "org", "ocr", "oop", "oster", "bb", "tt", "est", "ob", "rest", "tmp", "host", "art", "opt", "rost", "oh", "or", "inst", "osc", "om", "ort", "\u00f3", "sta", "iol", "osi", "nt", "sw", "stream", "ot", "omp", "post", "osta", "os", "ist", "oss", "oid", "ld", "rog", "OST"], "audio_enc": ["audio__rec", "media_enc", "picture_rec", "audio_config", "media_eng", "audioappec", "audio_sys", "audioappenz", "video_anc", "audio__inc", "audio__conn", "audio_inc", "audioappenc", "audio__ec", "audio_enz", "audioaccoll", "picture_config", "picture_enc", "audioacec", "video_enz", "picture_anc", "video_coll", "audio_ec", "audioappdec", "video_enc", "audio_conn", "video_conn", "video_dec", "video_rec", "audio_dec", "audio_rec", "audio_eng", "video_sys", "audio_coll", "video_ec", "media_ec", "audio__enc", "audio__eng", "audioacsys", "audioacenc", "audio_anc", "media_inc"], "sample_fmt": ["sample_gmt", "sample_vrt", "sample_rfformat", "sample_cfarm", "sample_formrt", "sample_rfmt", "sample_fct", "sample_rfmd", "sample_ptm", "sample_fmma", "sample_pformat", "sample_fformat", "sample_cfmt", "sample64fmmd", "sample_fmm", "sample_formMT", "sample_ftm", "sample_pmt", "sample64fmnd", "sample_cfm", "sample_forarm", "sample_Fformat", "sample_dnd", "sample_gMT", "sample_formmt", "sample_varm", "sample_formformat", "sample_fxtm", "sample_sfmt", "sample_dformat", "sample_Ftm", "sample_rfnd", "sample_Fld", "sample64fformat", "sample_fmd", "sample_vMT", "sample_sfrt", "sample_FMT", "sample_fmarm", "sample_gnt", "sample_form", "sample_frt", "sample_fxmt", "sample_vct", "sample_dmt", "sample_forformat", "sample64fnd", "sample_sfct", "sample_sfMT", "sample_garm", "sample_fm", "sample_cfformat", "sample_Fmt", "sample_formt", "sample_fxformat", "sample64fmformat", "sample_fnd", "sample_rfMT", "sample_vmt", "sample_fld", "sample_fxld", "sample64fmt", "sample_fnt", "sample_Fnt", "sample_rfma", "sample_fmMT", "sample64fmmt", "sample_vnt", "sample_fmmd", "sample_Farm", "sample_farm", "sample_fmnd", "sample_fMT", "sample_fmformat", "sample_fma", "sample_formct", "sample_formma", "sample_fmmt", "sample64fmd", "sample_pld", "sample_dmd"]}}
{"project": "FFmpeg", "commit_id": "221402c1c88b9d12130c6f5834029b535ee0e0c5", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    AVFrame *const p   = data;\n    int compressed, xmin, ymin, xmax, ymax;\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n                 bytes_per_scanline;\n    uint8_t *ptr;\n    const uint8_t *buf_end = buf + buf_size;\n    const uint8_t *bufstart = buf;\n    uint8_t *scanline;\n    int ret = -1;\n    if (buf[0] != 0x0a || buf[1] > 5) {\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n    compressed = buf[2];\n    xmin       = AV_RL16(buf + 4);\n    ymin       = AV_RL16(buf + 6);\n    xmax       = AV_RL16(buf + 8);\n    ymax       = AV_RL16(buf + 10);\n    if (xmax < xmin || ymax < ymin) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n    w = xmax - xmin + 1;\n    h = ymax - ymin + 1;\n    bits_per_pixel     = buf[3];\n    bytes_per_line     = AV_RL16(buf + 66);\n    nplanes            = buf[65];\n    bytes_per_scanline = nplanes * bytes_per_line;\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||\n        (!compressed && bytes_per_scanline > buf_size / h)) {\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n    switch ((nplanes << 8) + bits_per_pixel) {\n    case 0x0308:\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 0x0108:\n    case 0x0104:\n    case 0x0102:\n    case 0x0101:\n    case 0x0401:\n    case 0x0301:\n    case 0x0201:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n    buf += 128;\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!scanline)\n        return AVERROR(ENOMEM);\n    if (nplanes == 3 && bits_per_pixel == 8) {\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                ptr[3 * x]     = scanline[x];\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n            ptr += stride;\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n        const uint8_t *palstart = bufstart + buf_size - 769;\n        if (buf_size < 769) {\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n        for (y = 0; y < h; y++, ptr += stride) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            memcpy(ptr, scanline, w);\n        if (buf != palstart) {\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n            buf = palstart;\n        if (*buf++ != 12) {\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n        GetBitContext s;\n        for (y = 0; y < h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n    } else {    /* planar, 4, 8 or 16 colors */\n        int i;\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                int m = 0x80 >> (x & 7), v = 0;\n                for (i = nplanes - 1; i >= 0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n                ptr[x] = v;\n            ptr += stride;\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart + 16;\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n    *got_frame = 1;\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;", "idx": 7670, "substitutes": {"avctx": ["afcmp", "avcontext", "aircmp", "navcontext", "avalcontext", "vercontext", "avconn", " avcontext", "avcca", "AVcca", "AVctrl", "vercp", " avconn", "averctl", "aircontext", "averctx", "avctl", "afctx", "avcp", "AVcp", "afcontext", "afcp", "avlc", "avctrl", "AVqa", "AVconn", "AVcontext", "navctx", "afctrl", "avalctx", "averconn", "avalctrl", "avallc", "airctx", "AVctx", "avcmp", "airctl", "afctl", "aflc", "afqa", "AVctl", " avctl", "AVlc", "afcca", "verctx", "avqa", "AVcmp", "navcca", "avercontext", "verqa", "navcmp"], "data": ["batch", "pos", "frame", "reader", "da", "sample", "proc", "DATA", "value", "input", "result", "d", "queue", "Data", "val", "raw", "open", "write", "map", "dat", "pad", "image", "config", "bytes", "read", "block", "video", "buff", "load", "content", "tmp", "buffer", "f", "next", "array", "start", "a", "parent", "cache", "bin", "media", "ad", "size", "memory", "database", "stream", "body", "window", "base"], "got_frame": ["av_frame", "av_image", "af_range", "avroimage", "avroframe", "af_frame", "av_block", "avrorange", "avroblock", "af_block", "af_image", "av_range"], "avpkt": ["avPeth", "avcpkg", " avpkg", "avcpacket", "avppkt", "afpft", "avcacket", "afpacket", "avcpeth", "avckg", "avfkg", " avppct", "avPkg", "avppkg", "affct", "avppct", "avPct", "avpkg", " avpct", "avppeth", "avPkt", "affkt", "avPacket", "avcpct", " avppkt", "affft", " avppkg", "affacket", "afpct", "avfkt", "afpkg", "avpct", " avpeth", "avpft", "avpacket", "avfct", "avcct", "avfacket", "avcpkt", "affkg", "avcpft", "avckt", "avcft", "avfft", " avppeth", "avpeth", "afpkt"], "buf": ["ru", "br", "header", "conv", "text", "uint", "Buffer", "uber", "pad", "num", "img", "cmd", "buff", "aux", "grab", "bc", "uv", "Buff", "pkg", "nat", "cf", "cap", "b", "fp", "batch", "context", "pb", "ab", "begin", "box", "config", "dest", "fam", "cat", "cv", "uf", "rb", "cb", "pool", "uc", "rc", "pub", "bag", "vec", "block", "plug", "fd", "home", "tmp", "prop", "feat", "alloc", "utf", "bp", "window", "wb", "func", "wav", "proc", "queue", "loc", "aka", "exc", "src", "seq", "usr", "fb", "chrom", "ctx", "cur", "buffer", "coord", "bu", "cas", "brace", "port"], "p": ["py", "pc", "e", "d", "ps", "r", "u", "n", "l", "file", "P", "m", "c", "t", "g", "f", "pt", "array", "a", "o", "b", "q", "fp", "v", "port"], "compressed": ["compressor", "recressed", " decompacted", " compacted", "Compressed", "extoded", "recoded", "compoded", " decompressed", " compression", "suppressor", "reciled", "compiled", "compression", " uncompression", "compress", "expression", " uncompressed", "suppoded", "Compression", "expressor", " uncompacted", "express", "extression", "extiled", " uncompiled", "expressed", "extressed", " decompression", " compiled", "suppress", "suppiled", "suppressed", "recression", "Compressor", " decompiled", "Compress", "compacted", "suppression"], "xmin": ["Xin", "yskip", "ymini", "ixskip", "Xmax", "yinit", "wmax", "xxstart", "XMin", "xxmax", " xin", "ayinit", "yMin", "ymed", "wmed", "xMin", "xmed", "aymed", " xmini", "Xmin", "xinit", "ixmin", "Xskip", "Xstart", "ixmax", "xskip", " xMin", "Xmini", " xstart", "wmin", "aymin", "xxmin", "xin", "xstart", "winit", "xmini", "aymax", "xxin"], "ymin": [" ystep", "yskip", "ymini", "wmax", "zymin", "wpri", "symin", "zymini", "yMin", " ypri", "sy1", "xpri", "xMin", " ymini", "ystep", "x1", "Ymin", "ypri", "xversion", "wversion", "sypos", "xpos", "ypos", " y1", "zyskip", "xstep", "y1", "xskip", " yMin", " yskip", "Ystep", "YMin", "zymax", " ypos", " yversion", "Ymax", "wmin", "symax", "yversion", "xmini"], "xmax": [" xMax", "Xmax", "lexmax", "xMAX", " xmed", "wmax", "lexmed", "rxmin", "Xax", "yMAX", "yend", "xlast", "ymed", "axmax", "xmed", "xax", " xax", "xMax", "lexmin", "axmin", "xend", "axax", "axend", "wend", "Xmin", "rxend", "rxMAX", "yMax", "Xlast", " xMAX", " xlast", "Xend", " xend", "lexMax", "wmin", "wlast", "rxmax"], "ymax": ["yrail", "ypame", "ammake", "ymass", "symak", "pmension", "yahak", "tmax", "tmazon", "tmak", "ymmax", "pmmax", "ymame", "ammaxy", "pmax", "yanmax", "ymaxy", "ymension", "symail", "ypake", "ammame", "ymak", "tmoe", "yahax", "ymoe", "yanass", "yanension", "yahazon", "pmass", "ymmake", "ypaxy", "ymmail", "ymmmax", "ymmak", "ymmame", "ymake", "ymmaxy", "ymazon", "ypax", "ymmass", "yrak", "yanax", "symoe", "symazon", "yrax", "yrake", "yahoe", "symake", "ymmension", "ymail", "symax", "ammax"], "w": ["end", "d", "wn", "wx", "W", "kw", " W", "r", "win", "u", "fw", "n", "l", "c", "m", "wal", "weight", "g", "f", "wa", "max", "ow", "hw", "wp", "we", "wave", "wt", "wh", "sw", "z", "b", "q", "work", "v", "window", "wd"], "h": ["j", "ih", "th", "e", "d", "dh", "ul", "rh", "r", "hi", "ch", "u", "hm", "n", "l", "hh", "m", "c", "ht", "t", "height", "sh", "g", "f", "shift", "max", "hw", "gh", "o", "ph", "H", "z", "b", "q", "hs", "ha", "v"], "bits_per_pixel": ["bits_per\u00b7pixel", "bits_per\u00b7nice", "bits_per_character", "bits_per_byte", "bits_per_second", "bits_per_bit", "bits_per\u00b7channel", "bits_per_channel", "bits_per_line", "bits_per_nice"], "bytes_per_line": ["bytes_per_slice", "bytes_per_cell", "bytes_per24pixel", "bytes_perjpixel", "bytes_perjline", "bytes_per24slice", "bytes_perjlin", "bytes_per_lin", "bytes_per_byte", "bytes_per_word", "bytes_per24lines", "bytes_per24line", "bytes_per_pixel", "bytes_perjword", "bytes_per_lines"], "nplanes": [" nlines", "nrows", "numframes", "nblines", "nliners", "numplanes", "dlines", "nlines", "nbpages", "numbands", "nframes", " nflows", "nbplanes", "dplanes", " nframes", "npages", "Nlines", "numpages", " nliners", "Nliners", " npages", "nflows", "Nbands", "nbands", "Nrows", "numliners", "nbbands", "nbframes", "numflows", "Nplanes", "dframes", "Nframes", "nbliners", "dbands", "Npages", "numlines", " nbands", " nrows", "numrows", "nbflows"], "stride": ["trider", "slide", "arrision", "strider", "trision", "arride", "arrides", "strides", "trides", "slision", "slides", "tride", "slider", "strision", "arrider"], "y": ["pos", "d", "yy", "yt", "ey", "type", "lon", "n", "l", "cy", "vy", "m", "c", "height", "t", "dy", "f", "padding", "start", "min", "Y", "z", "b"], "x": ["ex", "index", "d", "xx", "xc", "image", "win", "n", "l", "c", "t", "height", "step", "weight", "g", "f", "max", "z", "b", "time", "v", "X"], "bytes_per_scanline": ["bytes_per_winl", "bytes_per_Scanline", "bytes_per_canner", "bytes_per_scanment", "bytes_per_scancase", "bytes_per_canl", "bytes_per_readment", "bytes_per_verner", "bytes_per_readlin", "bytes_per_pixelner", "bytes_per_pixellin", "bytes_per_Scanner", "bytes_per_imagel", "bytes_per_verline", "bytes_per_Scanl", "bytes_per_readline", "bytes_per_imageline", "bytes_per_verl", "bytes_per_pixelline", "bytes_per_winline", "bytes_per_binlin", "bytes_per_scanlines", "bytes_per_scanband", "bytes_per_imageband", "bytes_per_pixell", "bytes_per_pixellines", "bytes_per_pixelcase", "bytes_per_readner", "bytes_per_pixelment", "bytes_per_imagement", "bytes_per_binline", "bytes_per_canline", "bytes_per_Scancase", "bytes_per_pixelband", "bytes_per_verlines", "bytes_per_scanlin", "bytes_per_winband", "bytes_per_binment", "bytes_per_cancase", "bytes_per_scanl", "bytes_per_binner", "bytes_per_winment", "bytes_per_scanner"], "ptr": ["br", "proc", "loc", "fi", "trace", "fe", "src", "seq", "vec", "ctr", "obj", "buff", "fd", "tmp", "pt", "tr", "pointer", "alloc", "xp", "pty", "code", "dr", "bd", "ff", "rw", "addr", "fl", "port"], "buf_end": ["buf_ad", "buf__len", "buffer_ad", "buffer_start", "buffer_end", "buf__start", "buf__end", "buf_len", "buffer_len", "buf_start", "buf__ad"], "bufstart": ["ufpos", "buffstart", "cvstart", "cvfrom", "bufid", "ufid", "buffid", "buffpos", "uffrom", "buffrom", "cvid", "bufpos", "bufffrom", "cvpos", "ufstart"], "scanline": ["readframe", "synframe", "macframe", "scanframe", "maccode", "scanpos", "synpos", "synline", "syncode", "macline", "readline", "readcode", "scancode", "readpos", "macpos"]}}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIQXLDevice *d = opaque;\n\n    uint32_t io_port = addr - d->io_base;\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_RESET:\n\n    case QXL_IO_SET_MODE:\n\n    case QXL_IO_MEMSLOT_ADD:\n\n    case QXL_IO_MEMSLOT_DEL:\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        break;\n\n    default:\n\n        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)\n\n            break;\n\n        dprint(d, 1, \"%s: unexpected port 0x%x in vga mode\\n\", __FUNCTION__, io_port);\n\n        return;\n\n    }\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_UPDATE_AREA:\n\n    {\n\n        QXLRect update = d->ram->update_area;\n\n        qemu_mutex_unlock_iothread();\n\n        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,\n\n                                   &update, NULL, 0, 0);\n\n        qemu_mutex_lock_iothread();\n\n        break;\n\n    }\n\n    case QXL_IO_NOTIFY_CMD:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_NOTIFY_CURSOR:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_UPDATE_IRQ:\n\n        qxl_set_irq(d);\n\n        break;\n\n    case QXL_IO_NOTIFY_OOM:\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        pthread_yield();\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        d->oom_running = 1;\n\n        d->ssd.worker->oom(d->ssd.worker);\n\n        d->oom_running = 0;\n\n        break;\n\n    case QXL_IO_SET_MODE:\n\n        dprint(d, 1, \"QXL_SET_MODE %d\\n\", val);\n\n        qxl_set_mode(d, val, 0);\n\n        break;\n\n    case QXL_IO_LOG:\n\n        if (d->guestdebug) {\n\n            fprintf(stderr, \"qxl/guest: %s\", d->ram->log_buf);\n\n        }\n\n        break;\n\n    case QXL_IO_RESET:\n\n        dprint(d, 1, \"QXL_IO_RESET\\n\");\n\n        qxl_hard_reset(d, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_ADD:\n\n        PANIC_ON(val >= NUM_MEMSLOTS);\n\n        PANIC_ON(d->guest_slots[val].active);\n\n        d->guest_slots[val].slot = d->ram->mem_slot;\n\n        qxl_add_memslot(d, val, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_DEL:\n\n        qxl_del_memslot(d, val);\n\n        break;\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_CREATE_PRIMARY\\n\");\n\n        d->guest_primary.surface = d->ram->create_surface;\n\n        qxl_create_guest_primary(d, 0);\n\n        break;\n\n    case QXL_IO_DESTROY_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_DESTROY_PRIMARY\\n\");\n\n        qxl_destroy_primary(d);\n\n        break;\n\n    case QXL_IO_DESTROY_SURFACE_WAIT:\n\n        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);\n\n        break;\n\n    case QXL_IO_DESTROY_ALL_SURFACES:\n\n        d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", __FUNCTION__, io_port);\n\n        abort();\n\n    }\n\n}\n", "idx": 7696, "substitutes": {"opaque": ["OPac", "ospacs", "OPec", "opacs", "operonymous", "Oponymous", "Opacs", "opacity", "operec", "opac", "OPonymous", "Opec", "operac", "Opac", "operaque", "Opaque", "oponymous", "ospacity", "ospaque", "OPaque", "operacs", "operacity", "osponymous", "Opacity", "opec"], "addr": ["data", "pos", "rc", "da", "ref", "oa", "od", "xd", "eth", "ord", "ea", "p", "src", "amd", "pad", "conn", "ace", "offset", "config", "device", "ip", "dd", "add", "ix", "address", "host", "pointer", "coord", "ad", "alloc", "prefix", "ar", "xp", "sta", "dr", "cap", "node", "lan", "ptr", "align", "adr", "rt"], "val": ["data", "func", "ref", "def", "eval", "value", "sel", "alt", "len", "nil", "exec", "key", "mem", "rx", "arr", "bit", "num", "expr", "reg", "dim", "res", "rot", "buffer", "opt", "vals", "mac", "slot", "VAL", "al", "x", "valid", "arg", "grad", "unit", "v", "ret"], "d": ["data", "dn", "y", "da", "k", "vd", "od", "di", "xd", "db", "j", "e", "de", "dh", "did", "dt", "du", "p", "dom", "sync", "std", "done", "h", "D", "module", "dos", "u", "die", "ds", "mad", "dj", "id", "l", "n", "ind", "dim", "dd", "cmd", "dict", "fd", "s", "m", "c", "gd", "t", "rd", "dc", "g", "f", "dad", "draw", "nd", "dl", "i", "ad", "o", "dr", "bd", "ud", "td", "md", "cd", "z", "sd", "b", "del", "pd", "ld", "wd", "plugin", "dat"]}}
{"project": "FFmpeg", "commit_id": "4cec43a9eeb58eb9e581a2d9d25f78e5bfbb0960", "target": 0, "func": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    unsigned int first_mb_in_slice;\n\n    unsigned int pps_id;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int last_pic_structure, last_pic_droppable;\n\n    int needs_reinit = 0;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    first_mb_in_slice = get_ue_golomb(&sl->gb);\n\n\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, first_mb_in_slice);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (h->nal_unit_type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    pps_id = get_ue_golomb(&sl->gb);\n\n    if (pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;\n\n    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!h->ps.sps_list[h->ps.pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\",\n\n               h->ps.pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {\n\n        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;\n\n\n\n        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||\n\n            h->chroma_format_idc != h->ps.sps->chroma_format_idc)\n\n            needs_reinit         = 1;\n\n    }\n\n\n\n    pps = h->ps.pps;\n\n    sps = h->ps.sps;\n\n\n\n    if (!h->setup_finished) {\n\n        h->avctx->profile = ff_h264_get_profile(sps);\n\n        h->avctx->level   = sps->level_idc;\n\n        h->avctx->refs    = sps->ref_frame_count;\n\n\n\n        if (h->mb_width  != sps->mb_width ||\n\n            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))\n\n            needs_reinit = 1;\n\n\n\n        h->mb_width  = sps->mb_width;\n\n        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);\n\n        h->mb_num    = h->mb_width * h->mb_height;\n\n        h->mb_stride = h->mb_width + 1;\n\n\n\n        h->b_stride = h->mb_width * 4;\n\n\n\n        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p\n\n\n\n        h->width  = 16 * h->mb_width;\n\n        h->height = 16 * h->mb_height;\n\n\n\n        ret = init_dimensions(h);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (sps->video_signal_type_present_flag) {\n\n            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG\n\n                : AVCOL_RANGE_MPEG;\n\n            if (sps->colour_description_present_flag) {\n\n                if (h->avctx->colorspace != sps->colorspace)\n\n                    needs_reinit = 1;\n\n                h->avctx->color_primaries = sps->color_primaries;\n\n                h->avctx->color_trc       = sps->color_trc;\n\n                h->avctx->colorspace      = sps->colorspace;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (h->context_initialized && needs_reinit) {\n\n        h->context_initialized = 0;\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"changing width %d -> %d / height %d -> %d on \"\n\n                   \"slice %d\\n\",\n\n                   h->width, h->avctx->coded_width,\n\n                   h->height, h->avctx->coded_height,\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        ff_h264_flush_change(h);\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n\n               \"pix_fmt: %d\\n\", h->width, h->height, h->avctx->pix_fmt);\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    if (!h->context_initialized) {\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    last_pic_structure = h->picture_structure;\n\n    last_pic_droppable = h->droppable;\n\n\n\n    droppable = h->nal_ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->droppable         = droppable;\n\n        h->picture_structure = picture_structure;\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (last_pic_structure != picture_structure ||\n\n            last_pic_droppable != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   last_pic_structure, h->picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        /* Shorten frame num gaps so we don't have to allocate reference\n\n         * frames just to throw them away */\n\n        if (h->poc.frame_num != h->poc.prev_frame_num) {\n\n            int unwrap_prev_frame_num = h->poc.prev_frame_num;\n\n            int max_frame_num         = 1 << sps->log2_max_frame_num;\n\n\n\n            if (unwrap_prev_frame_num > h->poc.frame_num)\n\n                unwrap_prev_frame_num -= max_frame_num;\n\n\n\n            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {\n\n                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;\n\n                if (unwrap_prev_frame_num < 0)\n\n                    unwrap_prev_frame_num += max_frame_num;\n\n\n\n                h->poc.prev_frame_num = unwrap_prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * Here, we're using that to see if we should mark previously\n\n         * decode frames as \"finished\".\n\n         * We have to do that before the \"dummy\" in-between frame allocation,\n\n         * since that can modify s->current_picture_ptr. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                              last_pic_structure == PICT_TOP_FIELD);\n\n                }\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and previous field were reference, but had\n\n                     * different frame_nums. Consider this field first in\n\n                     * pair. Throw away previous field except for reference\n\n                     * purposes. */\n\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                                  last_pic_structure == PICT_TOP_FIELD);\n\n                    }\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n\n                           h->picture_structure == PICT_TOP_FIELD))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"Invalid field mode combination %d/%d\\n\",\n\n                               last_pic_structure, h->picture_structure);\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_INVALIDDATA;\n\n                    } else if (last_pic_droppable != h->droppable) {\n\n                        avpriv_request_sample(h->avctx,\n\n                                              \"Found reference and non-reference fields in the same frame, which\");\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_PATCHWELCOME;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        while (h->poc.frame_num != h->poc.prev_frame_num &&\n\n               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {\n\n            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n\n                   h->poc.frame_num, h->poc.prev_frame_num);\n\n            ret = initialize_cur_frame(h);\n\n            if (ret < 0) {\n\n                h->first_field = 0;\n\n                return ret;\n\n            }\n\n\n\n            h->poc.prev_frame_num++;\n\n            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;\n\n            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            /* Error concealment: If a ref is missing, copy the previous ref\n\n             * in its place.\n\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n\n             * many assumptions about there being no actual duplicates.\n\n             * FIXME: This does not copy padding for out-of-frame motion\n\n             * vectors.  Given we are concealing a lost frame, this probably\n\n             * is not noticeable by comparison, but it should be fixed. */\n\n            if (h->short_ref_count) {\n\n                if (prev &&\n\n                    h->short_ref[0]->f->width == prev->f->width &&\n\n                    h->short_ref[0]->f->height == prev->f->height &&\n\n                    h->short_ref[0]->f->format == prev->f->format) {\n\n                    av_image_copy(h->short_ref[0]->f->data,\n\n                                  h->short_ref[0]->f->linesize,\n\n                                  (const uint8_t **)prev->f->data,\n\n                                  prev->f->linesize,\n\n                                  prev->f->format,\n\n                                  h->mb_width  * 16,\n\n                                  h->mb_height * 16);\n\n                    h->short_ref[0]->poc = prev->poc + 2;\n\n                }\n\n                h->short_ref[0]->frame_num = h->poc.prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * We're using that to see whether to continue decoding in that\n\n         * frame, or to allocate a new one. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                h->cur_pic_ptr = NULL;\n\n                h->first_field = FIELD_PICTURE(h);\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and the previous field had different frame_nums.\n\n                     * Consider this field first in pair. Throw away previous\n\n                     * one except for reference purposes. */\n\n                    h->first_field = 1;\n\n                    h->cur_pic_ptr = NULL;\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    h->first_field = 0;\n\n                }\n\n            }\n\n        } else {\n\n            /* Frame or first field in a potentially complementary pair */\n\n            h->first_field = FIELD_PICTURE(h);\n\n        }\n\n\n\n        if (!FIELD_PICTURE(h) || h->first_field) {\n\n            if (h264_frame_start(h) < 0) {\n\n                h->first_field = 0;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            release_unused_pictures(h, 0);\n\n        }\n\n    }\n\n\n\n    assert(h->mb_num == h->mb_width * h->mb_height);\n\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n\n        first_mb_in_slice >= h->mb_num) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;\n\n    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<\n\n                                 FIELD_OR_MBAFF_PICTURE(h);\n\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n\n        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;\n\n    assert(sl->mb_y < h->mb_height);\n\n\n\n    if (h->picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); /* idr_pic_id */\n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (!h->setup_finished)\n\n        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,\n\n                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  h->picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n\n    // further down the line. This may break decoding if the first slice is\n\n    // corrupt, thus we only do this if frame-mt is enabled.\n\n    if (h->nal_ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,\n\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                                             h->current_slice == 0);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7716, "substitutes": {"h": ["hash", "header", "k", "j", "ih", "e", "ssh", "self", "p", "uh", "hel", "hr", "rh", "html", "history", "image", "img", "hi", "ch", "u", "hl", "hm", "hist", "this", "n", "l", "eh", "hp", "s", "hh", "m", "c", "sh", "t", "ctx", "hd", "v", "hhh", "g", "host", "f", "home", "oh", "ah", "adh", "en", "hw", "gh", "ph", "w", "H", "FH", "he", "bh", "zh", "b", "http", "hs", "q", "ha", "work", "ht"], "sl": ["sth", "gb", "lv", "loc", "isl", "sb", "pl", "kel", "val", "sil", "api", "spec", "ul", "slice", "ls", "bl", "ll", "ell", "sc", "acl", "sm", "Sl", "SL", "service", "hl", "ml", "sp", "sf", "lib", "l", "s", "lr", "her", "sh", "gl", "ctx", "kl", "tl", "il", "chal", "g", "sa", "sn", "cl", "dl", "cel", "el", "ssl", "se", "ph", "al", "fr", "lc", "sw", "zh", "la", "ess", "sv", "rl", "sk", "su", "serv", "sel", "ld", "fl", "si", "li"], "sps": ["spps", "psps", "Spps", "sPS", "sds", "SPS", "psPS", "pspps", "psds", " sds", "Sps", " sPS", " spps", "Sds"], "pps": ["pb", "hops", "amps", "fps", "ups", "ppa", "pg", "drops", "ppers", "mp", "params", "ps", "forces", "PP", "xs", "ops", "cpp", "px", "pp", "wp", "pkg", "ssl", "lp", "eps", "hs", "bps", "cp", "ppy", "ips"], "first_mb_in_slice": ["first_mb_inside_slot", "first_mb_in64source", "first_mb_inside_sequence", "first_mb_in64slice", "first_mb_inside_slice", "first_mb_in_video", "first_mb_inside_video", "first_mb_in_image", "first_mb_in64video", "first_mb_in_layer", "first_mb_inside_ice", "first_mb_in64ice", "first_mb_inside_layer", "first_mb_in_sequence", "first_mb_inside_image", "first_mb_in_ice", "first_mb_in_slot", "first_mb_in_source"], "pps_id": ["ps_bit", "pps_ids", "pps_sid", "ps_ids", "pps_bit", "ps_sid", "ps_id"], "ret": ["batch", "complete", "rc", "proc", "def", "result", "rep", "success", "alt", "val", "mem", "details", "mi", "seq", "RET", "resp", "res", "skip", "rev", "bis", "info", "quiet", "match", "nt", "rets", "Ret"], "slice_type": ["slice__type", "slice67length", "slice_shape", "slice_day", "sliceingpy", "slice_val", "slice67unit", "slice_unit", "slice7level", "image_type", "slice67address", "slicextype", " slice_types", "slicealno", "slice8source", " slice_source", "slice_py", "split_day", "slice7type", "slicefblock", "image_name", "slice8type", "cell67unit", "cell_type", "cell_length", "slice_block", "single_width", "slice__size", "cell67address", " slice8key", "sectioningshape", "sliceTypekind", "slicealunit", "slice64level", "slice64index", "sectioningblock", "single_index", "slice_no", "slice_address", "section_py", "slice_types", "split_type", " slice8unit", "slice__ty", "slice64type", "sliceingtype", " slice_like", " slice_index", "sliceTypelevel", "slicealformat", "slice64ty", "slicexlength", "slice_like", "sliceTypeblock", "slice_index", "slice_source", "slicealtype", " slice_block", " slice8source", "sliceFtype", "slicefkind", "sectioningpy", "slice_width", "cell67type", "sectioningtype", "sliceFlength", "slice_Type", "image_style", "slice_info", "sliceftype", "slice_style", "slice__types", "slice_kind", "sliceTypetype", "slice7index", "image_info", "slicexlike", "split_val", " slice_size", "slice_size", "slice_name", "slicealwidth", "cell67length", "slice_level", "slice_length", "slice_ty", " slice_kind", "slicealindex", "slicealkey", "sliceFunit", "slice67type", "slice_class", "cell_address", "sliceflevel", "single_type", " slice_unit", "slice_key", "single_format", "sliceFaddress", "sliceingblock", " slice8type", "split_format", " slice_class", "section_shape", "section_block", " slice_ty", "slice_format", "slice7ty", "section_type", " slice_level", "slicexType", "cell_unit", " slice_length", "slice8unit", "sliceingshape", "slicealtypes", " slice_key", " slice_no", " slice_Type", "slice8key", "slicealsource", "slicealclass"], "tmp": ["proc", "mm", "zip", "src", "mp", "params", "slice", "kk", "img", "ii", "config", "meta", "ip", "obj", "txt", "temp", "sup", "source", "pp", "cache", "amp", "pixel", "rb", "cb", "cmp", "fp", "cp", "cpp"], "i": ["ui", "pi", "index", "oci", "di", "mini", "cli", "ti", "p", "mi", "phi", "ii", "ki", "inner", "ni", "ip", "init", "ori", "io", "ini", "info", "it", "ci", "iu", "I", "ai", "si", "li"], "last_pic_structure": ["last_pic_sturation", "last_pic_restructure", "last_pic_resturation", "last_pic_insturation", "last_pic_estitute", "last_pic_instruction", "last_pic_restruction", "last_pic_esturation", "last_pic_restitute", "last_pic_struction", "last_pic_instructure", "last_pic_estructure", "last_pic_institute", "last_pic_estruction", "last_pic_stitute"], "last_pic_droppable": ["last_pic_droptible", "last_pic_croppables", "last_pic_droplables", "last_pic_droappables", "last_pic_droappible", "last_pic_droplable", "last_pic_croppable", "last_pic_droappability", "last_pic_droplible", "last_pic_droppables", "last_pic_droplability", "last_pic_droptable", "last_pic_droppability", "last_pic_croplables", "last_pic_croplable", "last_pic_croplability", "last_pic_croppability", "last_pic_droptables", "last_pic_croplible", "last_pic_droppible", "last_pic_croppible", "last_pic_droptability", "last_pic_droappable"], "field_pic_flag": ["field_pic_count", "field_pic0count", "field_pic0flag", "field_pic0mode", "field_picture_flags", "field_picture_mode", "field_picture_flag", "field_picture_count", "field_pic_mode", "field_pic_flags", "field_pic0flags"], "bottom_field_flag": ["bottom_line_count", "bottom_field_flags", "bottom_line_class", "bottom_line_flag", "bottom_line_flags", "bottom_field_class", "bottom_field_count"], "frame_num": ["frame_seq", " frame_seq", " frame_nb", "frame_nb", " frame_number", "frame_number"], "droppable": ["droipper", " droppiable", "croppable", "droippables", "droppsable", "droposability", "dropped", "croapper", "droappable", "droppser", " droppables", " droposable", "droppables", "droppiable", "croppables", "droppsed", "droposables", "droappables", " droposables", "croapped", "droappability", " droposability", "droperables", "cropper", "droppability", "croappable", "croappables", "droipped", " droposiable", "droposiable", "dropper", "droppsables", "cropped", "droposable", "droperable", " droppability", "droperiable", "droapped", "droappiable", "droperability", "droippable", "droapper"], "picture_structure": ["picture_contruction", "picture_gestruction", "picture_gestribution", "picture_destruction", "picture_destructure", "picture_estatter", "picture_destatter", "picture_destribution", "picture_structatter", "picture_esture", "picture_estribution", "picture_contructure", "picture_sture", "picture_stribution", "picture_structribution", "picture_estruction", "picture_structruction", "picture_structructure", "picture_contribution", "picture_statter", "picture_estructure", "picture_gesture", "picture_conture", "picture_struction", "picture_gestructure"]}}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_shutdown(URLContext *h, int flags)\n\n{\n\n    if (!h->prot->url_shutdown)\n\n        return AVERROR(EINVAL);\n\n    return h->prot->url_shutdown(h, flags);\n\n}\n", "idx": 7729, "substitutes": {"h": ["context", "help", "beh", "php", "ih", "ssh", "e", "d", "enh", "uh", "p", "rh", "hr", "r", "hi", "ch", "u", "hm", "hl", "l", "eh", "hp", "hh", "c", "sh", "m", "t", "ctx", "hd", "v", "host", "f", "g", "oh", "ah", "hw", "gh", "ph", "H", "bh", "he", "FH", "http", "hs", "ha", "ht"], "flags": ["pect", "options", "fps", "FLAG", "fun", "opens", "fx", "mask", "fo", " Flags", "args", "faces", "atts", "forces", "vs", "alls", "stats", "types", "ents", "files", "friends", "fd", "ss", "lag", "magic", "ils", "ts", "ags", "fields", "Flags", "fs", "ants", "vals", "flag", "settings", "lf", "bits", "features", "fg", "linux", "fl", "styles"]}}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n", "idx": 7732, "substitutes": {"dev": ["data", "Dev", "def", "bus", "rad", "de", "d", "ve", "self", "p", "dom", "app", "conn", "bug", "ev", "prom", "die", "device", "ds", "ch", "pro", "gd", "des", "dc", "g", "f", "mod", "serial", "cam", "req", "hw", "der", "info", "w", "ver", "grad", "priv", "dem", "conf", "serv", "spec"], "s": ["sq", "e", "d", "si", "parts", "sb", "server", "sys", "p", "sync", "args", "ls", "session", "S", "ps", "sc", "is", "ses", "gs", "cs", "r", "service", "sf", "ds", "u", "out", "stats", "n", "l", "ss", "c", "sg", "init", "services", "t", "fs", "g", "f", "ns", "sa", "bis", "ssl", "settings", "south", "i", "sl", "w", "o", "its", "state", "sv", "b", "su", "in", "js", "sd", "os", "conf", "v", "rs", "spec"], "isabus": ["areabus", "risabi", "isiabus", "Isabs", "risabo", "areabs", "areibus", "issabus", "isiabi", "isalis", "itsacs", "iabus", "lisabus", " isacs", "idabo", "isubs", "hopabi", "itab", "lisabi", " isab", "isabi", "servabi", "risubs", "servab", "isiab", "Isabus", "risabus", "hopabus", "issalis", "risab", "isab", "iabal", "ialog", "issabal", "risabs", "itabus", "issalog", " isalis", "servabus", "lisabal", "misabus", "itsabus", "itabs", "isiabs", "idabi", "misab", "idabus", "iabi", "itsabs", "areacs", "isibus", "hopabo", "isalog", " isabi", "isacs", "isabs", "isabo", "hopubs", "issabi", "misabi", " isibus", "lisalog", "itsibus", " isabs", "misabs", "Isab", "Isabi", "idubs", "isabal", "servalis", "itabi", "issab"], "pit": ["pet", "pc", "np", "pin", "pai", "pot", "piece", "sb", "cot", "pl", "val", "sil", "p", "ct", "pa", "sp", "at", "plugin", "bot", "jp", "cit", "ut", "net", "t", "bc", "nit", "pt", "sa", "lit", "kat", "sit", "kit", "fit", "sn", "bet", "bis", "nat", "sl", "itter", "it", "its", "lp", "bp", "qt", "sat", "itty", "bt", "serv", "prot", "rt"], "out0_irq": ["out0_ironq", "out0_mirquest", "out0_iraqq", "out0_iraqs", "out0_mirp", "out0_IRq", "out0_mirqq", "out0_mirq", "out0_IRQ", "out0_irqq", "out0_irp", "out0_IRqs", "out0_irQ", "out0_IRp", "out0_pirqq", "out0_irep", "out0_ironqs", "out0_iraQ", "out0_iraq", "out0_mirQ", "out0_irquest", "out0_mirqs", "out0_IRquest", "out0_ironQ", "out0_ireqs", "out0_pirqs", "out0_ireQ", "out0_irqs", "out0_pirq", "out0_ireq", "out0_pirQ", "out0_ironquest"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int ncpu;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    /* FIXME: obey smp_cpus.  */\n\n    if (strcmp(cpu_model, \"arm11mpcore\") == 0) {\n\n        ncpu = 4;\n\n    } else {\n\n        ncpu = 1;\n\n    }\n\n\n\n    for (n = 0; n < ncpu; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        pic = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\n\n        if (n > 0) {\n\n            /* Set entry point for secondary CPUs.  This assumes we're using\n\n               the init code from arm_boot.c.  Real hardware resets all CPUs\n\n               the same.  */\n\n            env->regs[15] = 0x80000000;\n\n        }\n\n    }\n\n\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0xc1400400);\n\n\n\n    if (ncpu == 1) {\n\n        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n\n           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n\n           GIC1 to be nIRQ and ignores all the others, so do that for now.  */\n\n        pic = realview_gic_init(0x10040000, cpu_irq[0]);\n\n    } else {\n\n        pic = mpcore_irq_init(cpu_irq);\n\n    }\n\n\n\n    pl050_init(0x10006000, pic[20], 0);\n\n    pl050_init(0x10007000, pic[21], 1);\n\n\n\n    pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    pl080_init(0x10030000, pic[24], 2);\n\n\n\n    sp804_init(0x10011000, pic[4]);\n\n    sp804_init(0x10012000, pic[5]);\n\n\n\n    pl110_init(ds, 0x10020000, pic[23], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\n\n\n\n    pl031_init(0x10017000, pic[10]);\n\n\n\n    pci_bus = pci_vpb_init(pic, 48, 1);\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x4e000000, pic[28]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /*  0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD.  */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /* 0x10016000 Reserved.  */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1.  */\n\n    /* 0x10050000 GIC2.  */\n\n    /* 0x10060000 GIC3.  */\n\n    /* 0x10070000 GIC4.  */\n\n    /*  0x10080000 SMC.  */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n\n}\n", "idx": 7749, "substitutes": {"ram_size": ["ramingsize", "ram1mode", "ramsingscale", "ramingshape", "ram64mode", "rams_size", "ram_mode", "ram64shape", "ram2scale", "ram2size", "ram_scale", "ram2address", "ram1address", "ramsingsize", "cpu_scale", "ram64scale", "ramsingshape", "ram2shape", "rams_scale", "ram_address", "cpu_address", "ram64size", "ramingaddress", "ramsingaddress", "ram1size", "cpu_size", "ram_shape", "ram64address", "ram1scale", "rams_address", "cpu_mode", "rams_shape", "ramingscale"], "vga_ram_size": ["vga_machinebmode", "vga_ram64weight", "vga_ram_capacity", "vga_rambcapacity", "vga_rambmode", "vga_machine_size", "vga_rambweight", "vga_ram64capacity", "vga_ram_weight", "vga_machine_mode", "vga_machine_capacity", "vga_ram_mode", "vga_machine_weight", "vga_machinebweight", "vga_rambsize", "vga_machinebsize", "vga_ram64mode", "vga_machinebcapacity", "vga_ram64size"], "boot_device": ["bootersystem", "bootalmode", "bootermode", "kernel_address", "bootalsystem", "bootaldevice", "boot_system", "boot_address", "kernel_device", "booterdevice", "booteraddress", "kernel_system", "kernel_mode", "bootaladdress", "boot_mode"], "ds": ["iss", "ys", "da", "db", "dh", "nas", "dt", "df", "ks", "ded", "ls", "ps", "ye", "vs", "cs", "cdn", "tx", "dd", "DS", "ss", "rs", "ils", "des", "fs", "dds", "der", "dm", "pd", "ld"], "kernel_filename": ["config_filename", "config_file", "kernel__fn", "kernel__filename", "config_fn", "kernel_fn", "config_files", "kernel__file", "kernel_file", "kernel_files", "kernel__files"], "kernel_cmdline": ["kernel_programline", "kernel_cmdname", "kernel_cmdl", "kernel_cmdrule", "kernel_pathl", "kernel_commandrule", "kernel_commandname", "kernel_pathrule", "kernel_commandl", "kernel_pathname", "kernel_programl", "kernel_programrule", "kernel_pathline", "kernel_programname", "kernel_commandline"], "initrd_filename": ["initrdoctitle", "initrd1fp", "initrd1filename", "initstruct_fp", "initrd_title", "initrd1message", "initstruct_title", "initrd_fp", "initrd1title", "initrdocfilename", "initrd_message", "initrdocmessage", "initstruct_filename", "initrdocfp", "initstruct_message"], "cpu_model": [" cpu_file", "cpu_block", "cpuamline", "CPU_model", "cpuamclass", "CPU_mode", "processor_size", " cpu_models", "cpu_service", "machine_line", " cpu_path", "cpu_path", "machine_Model", "machine_class", "processor_block", "machine_model", "cpu_Model", " cpu_mode", "cpu_class", "cpu67service", "cpu67mode", "cpu67name", "cpu_size", " cpu_location", "processor_model", "cpuamModel", "cpu_mode", " cpu_type", "cpu_file", "CPU_service", "cpu_type", "cpu_models", "cpu_name", "cpu_line", "processor_models", "cpu67model", "cpuammodel", "cpu_location", "CPU_name"], "env": ["context", "scope", "iss", "nc", "ext", "eu", "np", "ner", "db", "loader", "e", "enc", "exc", "equ", "export", "sys", "anc", "ea", "fe", "args", "session", "style", "conn", "vs", "img", "ne", "config", "ev", "obj", "enable", "txt", "net", "her", "init", "fen", "ctx", "bc", "nw", "ig", "console", "Environment", "osc", "ec", "en", "network", "ah", "ini", "cache", "err", "el", "kn", "dev", "cf", "eni", "pe", "qv", "qt", "pec", "fg", "cycle", "priv", "doc", "conf", "lock", "v", "environment"], "pic": ["py", "sci", "pick", "pc", "pi", "pin", "sec", "proc", "pot", "capt", "play", "pins", "loc", "Pic", "enc", "fat", "mini", "piece", "jc", "fi", "cli", "sys", "typ", "cons", "sync", "cus", "pid", "oc", "style", "kin", "seq", "ku", "pict", "nic", "qi", "config", "img", "pa", "lib", "plugin", "ic", "jp", "pse", "txt", "picture", "init", "bc", "cci", "study", "action", "ig", "mot", "parse", "mc", "chat", "kit", "feat", "cache", "fc", "tick", "lin", "product", "xi", "gui", "mic", "lc", "pres", "fig", "cycle", "vc", "doc", "feature", "pull"], "scsi_hba": ["scsi_pbi", "scsi_bba", "scsi_bca", "scsi_pca", "scsi_psa", "scsi_phba", "scsi_hca", "scsi_bsa", "scsi_hsa", "scsi_phsa", "scsi_bbi", "scsi_pba", "scsi_hbi", "scsi_phbi", "scsi_phca"], "pci_bus": ["pci_boot", "pdi_boot", "pci2boot", "pci_BUS", "pci2bus", "pci_usb", "pci2usb", "pdi_usb", "pdi_bus", "pci2BUS", "pdi_BUS"], "nd": ["nm", "nc", "dn", "nn", "NV", "ng", "vd", "NG", "nu", "na", "NN", "nv", "ann", "nz", "ind", "nih", "ni", "dd", "fd", "gd", "nb", "inn", "nw", "nl", "nt", "ani", "ln", "ND", "ld"], "n": ["nc", "fn", "nn", "dn", "y", "j", "ng", "k", "number", "nu", "name", "e", "d", "len", "p", "no", "un", "num", "conn", "r", "ne", "pn", "ni", "mn", "l", "rn", "net", "m", "c", "init", "t", "not", "nit", "nb", "nl", "ns", "f", "nw", "inn", "g", "sn", "network", "nor", "en", "N", "i", "nat", "o", "nt", "cn", "b", "adj", "v", "x"], "cpu_irq": ["cpu_IRp", "cpu_ireQ", "cpu_mirq", "cpu_rinQ", "cpu_irQ", "cpu_irqu", "cpu_pirquest", "cpu_rinp", "cpu_IRqu", "cpu_pirQ", "cpu_rinqs", "cpu_arq", "cpu_iriquest", "cpu_ironQ", "cpu_pirqs", "cpu_iperqu", "cpu_ironp", "cpu_mirqs", "cpu_IRQ", "cpu_arqs", "cpu_ironq", "cpu_pirq", "cpu_iriQ", "cpu_iperqs", "cpu_iperQ", "cpu_ireqs", "cpu_rinq", "cpu_mirp", "cpu_ireq", "cpu_IRqs", "cpu_irquest", "cpu_iriqs", "cpu_arQ", "cpu_arqu", "cpu_irqs", "cpu_ironqs", "cpu_IRq", "cpu_iriq", "cpu_irequest", "cpu_irp", "cpu_iperq", "cpu_mirQ"], "ncpu": ["ccpu", " nuda", "dcpc", "ncpc", "scpu", "uncpc", "dccore", "cuda", "ntpc", "uncroc", "mcpc", "nccore", " ngpu", "npc", "ncgpu", "cgpu", "mcpu", "uncpu", "ntgpu", "sccpu", "npu", "dcroc", "scuda", "cpu", "ntpu", " npu", "ncroc", "lcpc", "mccpu", "lcroc", "cpc", "scgpu", "dcpu", "ngpu", "dcgpu", "dccpu", "ncuda", "lccpu", "mccore", "nccpu", "ccore", "unccpu", "lcpu", "ntcpu"], "index": ["pos", "nc", "nn", "ng", "name", "si", "na", "len", "fe", "sync", "no", "num", "position", "Index", "pn", "ind", "net", "run", "nb", "sn", "network", "i", "loop", "nt", "node", "count", "ln", "x"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n", "idx": 7754, "substitutes": {"str": ["pos", "br", "ext", "sec", "text", "name", "enc", "er", "exec", "arr", "prev", "r", "Str", "ch", "inner", "est", "STR", "ind", "ctr", "id", "st", "stri", "cr", "cur", "tr", "step", "next", "max", "err", "fr", "in", "iter", "x"], "start": ["pos", "from", "ie", "set", "starting", "pre", "name", "begin", "d", "first", "p", "stop", "Start", "pad", "offset", "r", "ind", "id", "read", "c", "rest", "init", "st", "step", "next", "art", "range", "source", "shift", "min", "max", "part", "se", "i", "size", "origin", "started", "in", "count", "x", "base"], "end": ["pos", " extend", "index", "from", "set", "begin", "e", "limit", "len", "p", "last", "stop", "offset", "line", "id", "n", "ind", "ize", "rest", "c", "End", "range", "nd", "max", "en", "i", "END", "size", "bound", "ending", "ended", "length", "append", "ension", "send", "after"], "qstring": ["reqfile", "sqstr", "qstr", "sqslice", "questarray", " qring", "viewring", "reqstring", "sqstrings", "reqstr", "viewstream", "qarray", "eqfile", "qastr", "sqfilename", "aystr", "quickclass", "quiterator", "quesource", "qfunction", "queststring", "qaslice", "qastrings", "sqsource", "queslice", "sqdatabase", "qaresource", "reqservice", " qbinary", "quefile", "qaclass", "sqbinary", "eqslice", "sqobject", "eqdate", " qclass", "queryarray", " qsource", "chstr", "queservice", "chstring", "qustring", "quickstr", "qsource", "eqdatabase", " qobject", "eqsource", "sqstream", "aystring", "sqnumber", "sqfile", "quicksource", "quering", "eqring", " qarray", "sqvalue", "qstrings", "eqduration", "qaarray", "sqarray", "eqservice", "viewstring", "sqfunction", "qfile", "eqfunction", "eqstring", " qnumber", "quvalue", "qustr", "qobject", " qslice", "qservice", "qqiterator", "qdate", "qstream", "qqstring", "qfilename", "sqring", "qadate", "qastring", "eqarray", "eqclass", "qanumber", "questr", "qslice", "qaobject", "eqnumber", "eqstream", "viewarray", "eqfilename", "questdate", "quickfile", "qiterator", "quickstring", "chring", "qqslice", "querynumber", "sqservice", "qduration", "sqiterator", "qaring", " qresource", "qclass", "qresource", "qabinary", "questring", "eqiterator", "ayduration", "chduration", "quefilename", "qqstr", "qvalue", "qdatabase", " qstream", "qufunction", "sqstring", "querysource", "quslice", " qstrings", "quedatabase", "qnumber", "sqresource", "ayring", "querystring", "qring", "qbinary", "quickring", "eqstr", "eqvalue", "qastream"]}}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 7761, "substitutes": {}}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n", "idx": 7762, "substitutes": {"top": ["root", "TOP", "new", "bottom", "pre", "tops", "super", "above", "first", "higher", "p", "prev", "client", "Top", "up", "site", "support", "current", "bot", "file", "block", "next", "best", "path", "space", "primary", "as", "start", "master", "upper", "part", "parent", "initial", "front", "prefix", "central", "job", "high", "state", "null", "http"], "base": ["extra", "root", "stable", "local", "basic", "stack", "bottom", "area", "pre", "super", "core", "bare", "Base", "full", "site", "old", "change", "inner", "bot", "fake", "init", "based", "layer", "source", "start", "max", "copy", "part", "parent", "cache", "prefix", "front", "state", "b", "status", "ite", "http", "bas"], "sector_num": ["sector_name", "sector_no", " sector_sum", "sector_four", "section_four", "sector_prefix", "sector_number", " sector_prefix", " sector_name", "section_no", "section_number", " sector_ident", "sector_ident", " sector_number", "section_num", "sector_sum"], "nb_sectors": ["nb_tegments", "nb_gegments", "nb_vections", "nb_spevers", "nb_gectors", "nb_vesec", "nb_sections", "nb_pserets", "nb_sesec", "nb_tesections", "nb_desvers", "nb_specgments", "nb_specsec", "nb_spectors", "nb_spegments", "nb_psectors", "nb_tections", "nb_vegments", "nb_desctors", "nb_severs", "nb_tectors", "nb_psevers", "nb_sesections", "nb_psegments", "nb_veivers", "nb_serets", "nb_sperets", "nb_desgments", "nb_specctors", "nb_gections", "nb_segments", "nb_desrets", "nb_gesections", "nb_specivers", "nb_vesections", "nb_vectors", "nb_speivers", "nb_seivers", "nb_spesec"], "pnum": ["pcuman", "rnumption", "snumb", "snuc", "pnuman", "rnumb", "atanenum", "snumi", "panumi", "pinumi", "panumb", "pnumb", "snenum", "panum", "rnum", "pcum", "panuc", "rnman", "pinuman", "pnumm", "pronumm", "pinumption", "pcumb", "panman", "pnumi", "pronum", "panenum", "pnman", "atanum", "snumm", "pnumption", "pinuc", "pnuc", "pronenum", "pinumer", "rnenum", "pcumption", "pinum", "pronman", "pnenum", "panumer", "snum", "atanumm", "pronumb", "atanumb", "snumer", "pinumb", "pnumer", "rnuman"], "intermediate": ["overior", "indruction", "itervious", "investmediately", "INTERporal", "exmediate", "extference", "intvious", "explementation", "investiguous", "adior", "internmediate", "iterior", "interior", "INTERiguous", "INTERmediate", "promporal", "imior", "instmediate", "interfinal", "internparent", "interiguous", "promruction", "INTERplementation", "intmedi", "overmediate", "adparent", "interplementation", "instiguous", "prommediate", "internior", "intervious", "extplementation", "intersmedi", "transference", "interparent", "overparent", "INTERruction", "indior", "transplementation", " interior", "extmediate", "INTERior", "internmedi", "admedi", "immediate", "intersior", "itermediate", "overmedi", " interfinal", "extior", "intersvious", "exference", "transior", "INTERfinal", " interplementation", "interruction", "intersmediate", "promior", "intior", "investmediate", "indmediate", "exior", "INTERmediately", "intmediate", "imfinal", "interporal", "itermedi", "interference", "intermediately", "indporal", "admediate", "investior", "transmediate", "implementation", "intermedi", "instior", "instmediately"], "ret": ["nm", "br", "fn", "result", "bf", "alt", "back", "rf", "num", "id", "mn", "res", "init", "art", "nat", "ft", "arg", "re", "ref", "ner", "fun", "att", "val", "ne", "reg", "rot", "inter", "t", "run", "tr", "nl", "cat", "flag", "part", "det", "match", "code", "iter", "status", "rets", "hard", "ext", "rc", "pre", "value", "len", "mem", "ry", "RET", "opt", "pass", "rev", "req", "gt", "al", "nt", "active", "Ret", "py", "real", "reset", "def", "repl", "error", "success", "bit", "out", "obj", "fin", "err", "fab", "reply", "rl", "rt"], "n": ["nm", "nc", "new", "dn", "nn", "y", "j", "number", "ng", "e", "d", "na", "len", "none", "p", "no", "un", "num", "conn", "r", "ne", "out", "pn", "ni", "l", "mn", "rn", "s", "net", "m", "c", "t", "nb", "ns", "f", "nl", "sn", "en", "nr", "nor", "N", "network", "non", "i", "nat", "o", "nt", "cn", "b", "node", "adj", "v", "x"], "pnum_inter": ["pnuma_ext", "pnum_ref", "pnumer_inter", "pnum_pointer", "pnum_inf", "pnum_inc", "pnum_cur", "pnum_ext", "pnumm_inter", "pnum_iter", "pnum_pre", "pnUM_inc", "pnUM_inter", "pnUM_pre", "pnuma_rev", "pnumm_ar", "pnum_ar", "pnum_Inter", "pnumer_cur", "pnuma_ref", "pnum__cur", "pnuma_inf", "pnum__inc", "pnuma_pointer", "pnum_INTER", "pnum_rev", "pnumer_iter", "pnumer_ext", "pnumm_Inter", "pnuma_inter", "pnUM_cur", "pnumm_INTER", "pnum__pre", "pnum__inter"]}}
{"project": "qemu", "commit_id": "c6bf0f7ffa90c720377eb6bddd27037041acbc5b", "target": 0, "func": "static DisplayType select_display(const char *p)\n\n{\n\n    Error *err = NULL;\n\n    const char *opts;\n\n    DisplayType display = DT_DEFAULT;\n\n\n\n    if (strstart(p, \"sdl\", &opts)) {\n\n#ifdef CONFIG_SDL\n\n        display = DT_SDL;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",frame=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_frame = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_frame = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",alt_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    alt_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    alt_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",ctrl_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    ctrl_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    ctrl_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",window_close=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_quit = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_quit = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else {\n\n            invalid_sdl_args:\n\n                fprintf(stderr, \"Invalid SDL option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"SDL support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"vnc\", &opts)) {\n\n#ifdef CONFIG_VNC\n\n        if (*opts == '=') {\n\n            if (vnc_parse(opts + 1, &err) == NULL) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr, \"VNC support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"curses\", &opts)) {\n\n#ifdef CONFIG_CURSES\n\n        display = DT_CURSES;\n\n#else\n\n        fprintf(stderr, \"Curses support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"gtk\", &opts)) {\n\n#ifdef CONFIG_GTK\n\n        display = DT_GTK;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    grab_on_hover = true;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    grab_on_hover = false;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else {\n\n            invalid_gtk_args:\n\n                fprintf(stderr, \"Invalid GTK option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"GTK support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"none\", &opts)) {\n\n        display = DT_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Unknown display type: %s\\n\", p);\n\n        exit(1);\n\n    }\n\n\n\n    return display;\n\n}\n", "idx": 7766, "substitutes": {"p": ["py", "data", "pat", "pb", "pc", "np", "proc", "j", "vp", "e", "d", "pl", "tp", "op", "ps", "pr", "r", "sp", "P", "jp", "n", "s", "m", "c", "t", "g", "f", "path", "pp", "wp", "i", "o", "bp", "b", "fp", "cp", "parser"], "err": ["msg", "proc", "error", "e", "er", "str", "sys", "rh", "pr", "resp", "ch", "r", "usr", "rr", "tx", "go", "cr", " Err", "Er", "req", "Error", "der", "gr", "iter", "cb", "fg", "rs"], "opts": ["optt", " copplets", "opter", "exputs", "Opsts", "opTS", "expts", "OPrs", "opments", "promtons", "optls", "OPtips", "optons", "opplets", "poptics", " opters", "atuts", "optsts", "hopts", "promt", " copters", "OPouts", "OPtons", "iopws", "itts", "ioputs", "popt", "setted", " opcs", "opttes", "copts", " optr", "oprs", "optics", "OPtr", "operls", "expertips", "opercs", "Opments", " coputs", "opersts", "ipts", "hoplets", "catps", "expter", "OPter", "itps", "ropters", "catts", "OPtics", "operuts", "atns", "copTS", "offuts", "experts", "expt", "optuts", "catters", "OPters", "hopters", "expertics", "OPted", "itte", "setsts", "hopns", "OPls", "optes", "setters", "oputs", "setts", "opters", "catt", "opcs", "otps", "roputs", "poprs", "ipns", "latts", "OPps", "optcs", "optr", "roptips", "opertr", " oputs", "optps", "opertons", "catte", "OPtes", "opths", "Opted", "opsts", "opte", "OPsts", "hopplets", "hoputs", "iopters", "popts", "ipps", "offted", "apptr", "operter", "apputs", "itters", "operters", "copt", "OPTS", "appts", "offt", "OPte", "atts", "iopts", "lattr", "iplets", "offts", "ropments", "latTS", "opouts", "exptics", "atlets", "operted", "OPths", "opted", "latuts", "expert", "opt", "operws", "appters", "opps", "cattips", "opls", "expters", "iputs", "operTS", "hopTS", " opps", "promts", "opws", "opertes", "operts", "Opts", "otts", "otters", "OPws", "OPments", "optTS", "promths", "optips", "optments", " opTS", "OPcs", "optrs", " copts", "ipters", "optplets", "OPts", "catls", "OPuts", "exptips", "Opouts", "otments", "catuts", "hoptr", "opns", "ropouts", "optts", "oplets", "setuts", "sett", "operths", "ropts", "Opters", "copters", "opert", "opttics", "OPt", "optters", " opments"], "nextopt": [" nextpot", "serverop", "decopt", "Nextoptim", "lastoct", "mainoption", "prevoption", "newopt", "nowoptim", "forwardalt", "dotOpt", "moreopt", "moreoct", "nextalt", "frontalt", "lastopt", " nextoff", "primaryoct", "firstoptim", "openoptim", "workingoption", "serveroption", "newopted", "headopt", "goingoption", "moreoptim", "newoff", "Nextopt", "goingOpt", "frontopted", "decoff", "nowort", "newoption", "prevOpt", "newOpt", " nexttemp", "nextloop", "successoption", " nextopted", " nextOpt", " nextalt", "prevalt", "goingopt", "goingloop", "serveropt", "seenopt", "Nextpot", " nexthop", "nextoct", "workingOpt", "lastOpt", " nextoptim", "nextpot", "headoptim", "futureoptim", "nowoption", "serveroptim", "changeoption", "primaryoption", "changeopt", "forwardopt", "nowop", "NextOpt", "primaryhop", " nextoption", "mainOpt", "firstoption", "nowopt", "nextopted", "mainop", "otheroption", "headtemp", "newloop", "forwardoption", "otheropt", "Nextoption", "openopt", "otherOpt", "otheralt", "changeop", " nextop", "dottemp", "otheroptim", "decoption", "workingopt", "nexttemp", "openoption", "primaryopt", "mainopt", "newoptim", "headoption", "nextoptim", "futureOpt", "dotoption", "styleoptim", "mainoptim", "nextop", "nextort", "newort", "decoptim", "morehop", "nextOpt", "successop", "firstopt", "stylealt", "mainopted", "forwardopted", "firstop", "nexthop", "frontoption", "moreop", " nextloop", "styleopt", "nextoff", "prevopt", "seenOpt", " nextort", "lastoption", "seenoption", "successopt", "dotalt", "styleoption", "workingoptim", "changeoptim", "futureopt", "dotopt", "moreoption", "successoptim", "newoct", "seenpot", "Nextort", "nextoption", "frontopt", "dotoptim", "openalt", " nextoct", "futureoption"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)\n\n{\n\n    int64_t start, size, last_size;\n\n    start= url_ftell(bc) - prefix_length;\n\n\n\n    if(start != nut->packet_start + nut->written_packet_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"get_packetheader called at weird position\\n\");\n\n        return -1;\n\n    }\n\n    \n\n    if(calculate_checksum)\n\n        init_checksum(bc, update_adler32, 0);\n\n\n\n    size= get_v(bc);\n\n    last_size= get_v(bc);\n\n    if(nut->written_packet_size != last_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->written_packet_size, last_size, start);\n\n        return -1;\n\n    }\n\n\n\n    nut->last_packet_start = nut->packet_start;\n\n    nut->packet_start = start;\n\n    nut->written_packet_size= size;\n\n\n\n    return size;\n\n}\n", "idx": 7777, "substitutes": {"nut": ["note", "ou", "np", "dist", "od", "text", "cot", "dt", "nov", "stone", "ctr", "contract", "nw", "art", "nuts", "nat", "oren", "ft", "bd", "category", "ot", "nav", "missing", "root", "gat", "pot", "config", "orb", "rot", "dc", "nit", "kt", "winner", "bolt", "cat", "fit", "utt", "cn", "cb", "nova", "Nut", "ext", "piece", "fat", "nv", "ocr", "conn", "cod", "lib", "n", "creator", "transfer", "oven", "gob", "feat", "gt", "cro", "nt", "cut", "adr", "ox", "error", "core", "aug", "uts", "ct", "orn", "cit", "cdn", "ut", "obj", "cart", "boot", "knife", "node", "bt", "ore", "rt"], "bc": ["BBC", "context", "nc", "uc", "pc", "CBC", "rc", "bitcoin", "gb", "db", "loc", "bf", "cot", "exec", "anc", "gc", "src", "org", "oc", "ocr", "sc", "ct", "soc", "cm", "config", "lib", "orb", "fb", "cca", "cms", "c", "cgi", "ctx", "dc", "cr", "mc", "ucc", "cl", "ec", "mac", "fc", "tc", "bd", "lc", "rb", "com", "cb", "bt", "BC"], "prefix_length": ["prefixallength", "prefix_size", "prefixaloffset", "prefix_offset", "padding_length", "prefix_len", " prefix_len", "prefixlenlen", "prefixalrequired", "prefixallen", "padding_offset", "padding_required", "prefix_required", " prefix_size", "prefixlensize", "padding_len", "prefixlenlength"], "calculate_checksum": ["calculate_cssum", "calculate_checksums", "calculate_hsup", "calculate_csums", "calculate_cksam", "calculate_checkssum", "calculate_csam", "calculate_checksup", "calculate_hsum", "calculate_cksup", "calculate_checksam", "calculate_ckssum", "calculate_cksums", "calculate_hsam", "calculate_hssum", "calculate_csum", "calculate_cksum"], "start": ["pos", "sum", "index", "from", "seed", "ie", "set", "end", "scale", "starting", "error", "name", "try", "get", "len", "open", "grade", "p", "base", "slice", "ce", "type", "style", "Start", "pad", "ace", "offset", "stop", "use", "config", "change", "ind", "id", "read", "load", "skip", "c", "init", "add", "st", "step", "address", "art", "shift", "source", "parse", "check", "min", "part", "se", "i", "info", "ad", "it", "started", "state", "store", "length", "count", "send", "ate"], "size": ["extra", "data", "new", "sum", "storage", "give", "sec", "small", "end", "set", "scale", "ie", "from", "number", "name", "loc", "ny", "len", "false", "ice", "sync", "ey", "last", "full", "clean", "offset", "form", "speed", "SIZE", "use", "bytes", "empty", "n", "large", "ize", "sized", "Size", "address", "source", "capacity", "range", "day", "en", "se", "i", "fee", "code", "shape", "length", "time", "grow", "count", "send", "unit", "si"], "last_size": ["last_start", "last24start", " last_length", "last24address", " last_scale", "last24size", "last_sized", "last_scale", "last_address", " last_address", "last_len", " last_start", " last_len", "last_length", " last_sized", "last24length"]}}
{"project": "qemu", "commit_id": "75f19f8c3006970632303b49043b075dc4fe922e", "target": 0, "func": "static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n", "idx": 7779, "substitutes": {"s": ["comm", "sq", "aws", "e", "d", "sb", "server", "sys", "spec", "ks", "args", "ls", "params", "S", "client", "ps", "ses", "cs", "gs", "service", "sf", "ds", "ips", "states", "rs", "c", "sg", "m", "services", "t", "ctx", "sym", "ss", "fs", "g", "ns", "f", "a", "ssl", "settings", "secondary", "o", "b", "es", "os", "conf", "phys", "qs", "south", "si"], "cmd": ["msg", "cfg", "comm", "target", "input", "d", "pg", "cc", "command", "call", "cli", "op", "gn", "acl", "gz", "buf", "client", "h", "conn", "ct", "clean", "cod", "cs", "cm", "config", "gs", "ds", "id", "ck", "c", "m", "content", "sg", "ctx", "dc", "g", "host", "send", "draw", "ctrl", "cl", "cat", "pkg", "mac", "req", "cf", "code", "dr", "md", "cd", "cb", "vc", "cp", "cpp", "method", "ctl", "Cmd"], "p": ["py", "pi", "pc", "np", "vp", "e", "d", "tp", "op", "api", "ps", "r", "sp", "P", "ap", "jp", "ip", "hp", "n", "c", "m", "t", "g", "f", "pd", "pointer", "pp", "wp", "gp", "a", "i", "o", "lp", "pe", "bp", "b", "po", "fp", "cp", "v"]}}
{"project": "qemu", "commit_id": "02cb7f3a256517cbf3136caff2863fbafc57b540", "target": 0, "func": "int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 7780, "substitutes": {"s": ["storage", "sq", "aws", "e", "d", "sb", "server", "sys", "self", "p", "spec", "session", "S", "ps", "is", "ses", "gs", "sets", "cs", "service", "ds", "stats", "n", "ops", "sie", "c", "m", "ts", "services", "sg", "ss", "rs", "t", "fs", "g", "ns", "f", "ssl", "i", "sl", "o", "sv", "js", "su", "es", "b", "os", "south", "si"], "fidp": ["fpidl", "foidp", "ffdl", "fedP", "fidsP", " fidsps", "ffdr", "fidsf", "fydP", "fidsb", "fidb", "fippad", "foidd", "affedpad", "fydf", "fydp", "fidr", "fitpre", " fidf", "fidpre", "fidf", " fidb", "frodpre", " fidps", "fitb", "fidsps", "fIdp", "fydps", "fidpy", "fydpad", "fidsp", "fydpy", "frodf", "frodb", "fidspre", "fidP", "affidpy", "fedpy", "fidps", " fitp", "fippy", "fipP", " fidsf", "affidpad", "affidP", "fedpad", "foidl", "fpidr", "frodp", " ffdl", " fidpre", "fpidd", "fitp", "affedP", "fidpad", "affedpy", " fidd", "ffdd", "foidr", "fIdps", " fitf", " ffdr", "fedp", "ffdp", " fitb", "fidl", "fIdf", " fidr", " fidP", "fipp", " fidsp", "affidp", " fitpre", "fIdP", "affedp", " fidl", " ffdp", "fitf", " fidsP", "fpidp", "fidd", " ffdd"], "fullname": ["longname", "realnames", " fullName", "fullypath", "fullyName", "shortName", "fulllabel", "shortlabel", " fullnames", " fullpath", " fulllabel", "fullylabel", "shortpath", "shortname", "longName", "realname", "fullpath", "longnames", "fullName", "realName", "fullyname", "fullnames"], "gid": ["gID", "genid", "sgtype", " gID", "genname", " gname", "sgID", "gname", "pid", "igname", "igid", "gids", "igids", "gtype", "sgip", "sgid", "pID", "genids", "uuip", " gids", "pip", "uuid", "uuID", "gip", "igID", "ptype", "uutype", "genID"], "flags": ["options", "fun", "lines", "len", "mask", "acl", "args", "bit", "missions", "bytes", "ds", "stats", "types", "files", "ops", "fd", "lag", " bits", "fs", "Flags", "ms", "mac", "flag", "settings", "feat", "mods", "fee", "lf", "bits", "lvl", "reads", "features", "locks", "format", "groups", "status", "ips"], "mode": ["ffff", "func", "Mode", "uid", "sid", "fun", "name", "slave", "mask", "mem", "command", "none", "acl", "type", "missions", "device", "cmd", " modes", "id", "MODE", "ward", "fd", "m", "dc", "perm", "owner", "force", " perm", "path", "mod", "mac", "flag", "size", "user", "code", "md", " magic", "node", "kind", "role", "time", "own", "status", "mission", "driver", "format", "base"], "err": ["msg", "y", "rc", "ie", "ner", "error", "result", "loc", "e", "er", "str", "val", "nil", "fi", "call", "fe", "arr", "rh", "type", "orig", "order", "ace", "bug", "r", "resp", "inner", "runner", "ind", "id", "rr", "ctr", "var", "lr", "fy", "c", "mr", "init", "dy", " Err", "cr", "Er", "rage", "req", "Error", "ir", "nr", "ise", "der", "i", "ar", "code", "dr", "gr", "attr", "iter", "ok", "cb", "count", "status", "rag", "raise"], "cred": ["crib", "rcrd", " credits", "lcredit", "rcred", "fcredit", "crowd", "gredit", "acrypt", "gred", "rcredit", " ecrd", "encrypt", " acredit", "ccredit", "encred", "rcrib", "fcrd", "ecrib", "lcrib", " acred", "Crypt", "encredit", "crypt", "grypt", "ecredit", " credit", "Crib", " ecredit", "gram", "credit", "fcrowd", " acrowd", "Cred", " acrd", "credits", " crypt", "cram", "Credit", "ccred", "acram", "lcred", "acrowd", "encrowd", "cRED", "Credits", "ecrd", "ccrib", "crd", " ecred", "Crd", " ecrowd", "ecred", "ccRED", "dcred", "acred", "lcRED", "acredit", " crowd", "fcred", "dcredit", "dcrib", "acredits", "dcRED", " cram"], "total_open_fd": ["total_close_dd", "total_close_FD", "total_close_dc", "total_open64FD", "total_open64fc", "total_close_fd", "total_open_FD", "total_open_dc", "total_close_fc", "total_open_fc", "total_open64fd", "total_open64dc", "total_open64dd", "total_open_dd"]}}
{"project": "qemu", "commit_id": "bbe2f399b222f1f2fcf5cd2ea78e4f5c9a66c64e", "target": 0, "func": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7782, "substitutes": {"n": ["an", "nm", "nc", "dn", "nn", "fn", "np", "j", "ng", "nu", "e", "d", "na", "enc", "none", "p", "nv", "un", "conn", "num", "ne", "u", "pn", "l", "mn", "rn", "s", "net", "m", "c", "t", "nb", "ns", "nl", "g", "yn", "f", "nw", "sn", "en", "network", "nor", "N", "non", "nat", "o", "nt", "cn", "z", "b", "in", "node", "adj", "ln", "v"], "buf": ["pool", "data", "pb", "rc", "ref", "eth", "ab", "queue", "Buffer", "mem", "p", "src", "pad", "seq", "offset", "vec", "buff", "fd", "ctx", "bc", "buffer", "tr", "f", "cv", "alloc", "nt", "cap", "uf", "rb", "b", "cb", "fp", "v", "port"], "size": ["pos", "nc", "rc", "sec", "small", "end", "scale", "name", "loc", "e", "enc", "len", "offset", "SIZE", "empty", "s", "ize", "c", "Size", "address", "g", "max", "z", "shape", "desc"], "bcast": ["vcasts", "bast", "mcast", "fcast", " bcasting", "rbcast", "rbace", "faddr", " bast", "mcasting", "rbcasting", "bace", "rbCAST", "bcasts", "pcasting", "pcast", "fpad", "fcasting", " bace", "maddr", " baddr", "mpad", "pCAST", "abast", "vcast", "vast", "baddr", "face", " bpad", " bcasts", "abcasts", "bcasting", "vace", "abace", "bCAST", "bpad", "pace", "abcast", "fCAST"], "vlan": ["VLAN", " vLAN", "hlan", " vrn", "svda", "glan", "plc", "vrlc", "vda", "vrlan", "gnic", "vann", "pnic", "vla", "vrann", "hrn", " vla", " vann", "gla", " vnic", "pla", " vda", "vrda", "svann", "svlan", " vlen", "Vlen", "glc", "vlen", "hlen", "Vlan", "Vrn", "hLAN", "plan", "vLAN", "vrn", "svlc", " vlc", "vlc", "vnic"], "ptr": ["pos", "br", "pc", "push", "str", "slice", "pair", "pad", "ctr", "eger", "buff", "bc", "hw", "grad", "fp", "prot", "context", "data", "ref", "trace", "offset", "r", "sp", "rot", "inter", "address", "tr", "inst", "cv", "mount", "wr", "code", "addr", "rc", "p", "arr", "Ptr", "plug", "fd", "tmp", "pt", "shift", "prop", "pp", "req", "alloc", "pty", "nt", "length", "cmp", "adr", "dat", "sth", "end", "proc", "loc", "tty", "src", "ch", "ev", "ctx", "cur", "buffer", "pointer", "iv", "dr", "attr", "pri", "priv", "td", "port"], "i": ["ui", "bi", "y", "pi", "index", "k", "j", "di", "e", "d", "fi", "ti", "p", "yi", "uli", "mi", "phi", "qi", "ii", "r", "hi", "adi", "u", "ji", "vid", "id", "l", "ni", "ip", "ami", "c", "ix", "oi", "f", "zi", "io", "a", "ri", "ini", "info", "o", "gi", "mu", "xi", "uri", "x", "ci", "eni", "z", "b", "in", "iu", "I", "ai", "v", "si", "li"]}}
{"project": "FFmpeg", "commit_id": "4bb0b31f762c422ad15bee68da7bcf76940cc9fa", "target": 0, "func": "static int output_packet(InputStream *ist, int ist_index,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    AVFormatContext *os;\n\n    OutputStream *ost;\n\n    int ret, i;\n\n    int got_output;\n\n    void *buffer_to_free = NULL;\n\n    static unsigned int samples_size= 0;\n\n    AVSubtitle subtitle, *subtitle_to_free;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n#if CONFIG_AVFILTER\n\n    int frame_available;\n\n#endif\n\n    float quality;\n\n\n\n    AVPacket avpkt;\n\n    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);\n\n\n\n    if(ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts= ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if(pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    //while we have more to decode or while the decoder did output something on EOF\n\n    while (avpkt.size > 0 || (!pkt && got_output)) {\n\n        uint8_t *data_buf, *decoded_data_buf;\n\n        int data_size, decoded_data_size;\n\n        AVFrame *decoded_frame, *filtered_frame;\n\n    handle_eof:\n\n        ist->pts= ist->next_pts;\n\n\n\n        if(avpkt.size && avpkt.size != pkt->size)\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning=1;\n\n\n\n        /* decode the packet if needed */\n\n        decoded_frame    = filtered_frame = NULL;\n\n        decoded_data_buf = NULL; /* fail safe */\n\n        decoded_data_size= 0;\n\n        data_buf  = avpkt.data;\n\n        data_size = avpkt.size;\n\n        subtitle_to_free = NULL;\n\n        if (ist->decoding_needed) {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:{\n\n                if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) {\n\n                    samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE);\n\n                    av_free(samples);\n\n                    samples= av_malloc(samples_size);\n\n                }\n\n                decoded_data_size= samples_size;\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size,\n\n                                            &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                avpkt.data += ret;\n\n                avpkt.size -= ret;\n\n                data_size   = ret;\n\n                got_output  = decoded_data_size > 0;\n\n                /* Some bug in mpeg audio decoder gives */\n\n                /* decoded_data_size < 0, it seems they are overflows */\n\n                if (!got_output) {\n\n                    /* no audio frame */\n\n                    continue;\n\n                }\n\n                decoded_data_buf = (uint8_t *)samples;\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) /\n\n                    (ist->st->codec->sample_rate * ist->st->codec->channels);\n\n                break;}\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                    decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2;\n\n                    if (!(decoded_frame = avcodec_alloc_frame()))\n\n                        return AVERROR(ENOMEM);\n\n                    avpkt.pts = pkt_pts;\n\n                    avpkt.dts = ist->pts;\n\n                    pkt_pts = AV_NOPTS_VALUE;\n\n\n\n                    ret = avcodec_decode_video2(ist->st->codec,\n\n                                                decoded_frame, &got_output, &avpkt);\n\n                    quality = same_quant ? decoded_frame->quality : 0;\n\n                    if (ret < 0)\n\n                        goto fail;\n\n                    if (!got_output) {\n\n                        /* no picture yet */\n\n                        av_freep(&decoded_frame);\n\n                        goto discard_packet;\n\n                    }\n\n                    ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts,\n\n                                                                 decoded_frame->pkt_dts);\n\n                    if (ist->st->codec->time_base.num != 0) {\n\n                        int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                        ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                          ist->st->codec->time_base.num * ticks) /\n\n                            ist->st->codec->time_base.den;\n\n                    }\n\n                    avpkt.size = 0;\n\n                    buffer_to_free = NULL;\n\n                    pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free);\n\n                    break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ret = avcodec_decode_subtitle2(ist->st->codec,\n\n                                               &subtitle, &got_output, &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                if (!got_output) {\n\n                    goto discard_packet;\n\n                }\n\n                subtitle_to_free = &subtitle;\n\n                avpkt.size = 0;\n\n                break;\n\n            default:\n\n                return -1;\n\n            }\n\n        } else {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                    ist->st->codec->sample_rate;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (ist->st->codec->time_base.num != 0) {\n\n                    int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                    ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                      ist->st->codec->time_base.num * ticks) /\n\n                        ist->st->codec->time_base.den;\n\n                }\n\n                break;\n\n            }\n\n            avpkt.size = 0;\n\n        }\n\n\n\n        // preprocess audio (volume)\n\n        if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_volume != 256) {\n\n                switch (ist->st->codec->sample_fmt) {\n\n                case AV_SAMPLE_FMT_U8:\n\n                {\n\n                    uint8_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128;\n\n                        *volp++ = av_clip_uint8(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_S16:\n\n                {\n\n                short *volp;\n\n                volp = samples;\n\n                for(i=0;i<(decoded_data_size / sizeof(short));i++) {\n\n                    int v = ((*volp) * audio_volume + 128) >> 8;\n\n                    *volp++ = av_clip_int16(v);\n\n                }\n\n                break;\n\n                }\n\n                case AV_SAMPLE_FMT_S32:\n\n                {\n\n                    int32_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8);\n\n                        *volp++ = av_clipl_int32(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_FLT:\n\n                {\n\n                    float *volp = samples;\n\n                    float scale = audio_volume / 256.f;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_DBL:\n\n                {\n\n                    double *volp = samples;\n\n                    double scale = audio_volume / 256.;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL,\n\n                           \"Audio volume adjustment on sample format %s is not supported.\\n\",\n\n                           av_get_sample_fmt_name(ist->st->codec->sample_fmt));\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* frame rate emulation */\n\n        if (input_files[ist->file_index].rate_emu) {\n\n            int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE);\n\n            int64_t now = av_gettime() - ist->start;\n\n            if (pts > now)\n\n                usleep(pts - now);\n\n        }\n\n        /* if output time reached then transcode raw format,\n\n           encode packets and output them */\n\n        for (i = 0; i < nb_ostreams; i++) {\n\n            OutputFile *of = &output_files[ost_table[i].file_index];\n\n            int frame_size;\n\n\n\n            ost = &ost_table[i];\n\n            if (ost->source_index != ist_index)\n\n                continue;\n\n\n\n            if (of->start_time && ist->pts < of->start_time)\n\n                continue;\n\n\n\n            if (of->recording_time != INT64_MAX &&\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time,\n\n                              (AVRational){1, 1000000}) >= 0) {\n\n                ost->is_past_recording_time = 1;\n\n                continue;\n\n            }\n\n\n\n#if CONFIG_AVFILTER\n\n            if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                ost->input_video_filter) {\n\n                AVRational sar;\n\n                if (ist->st->sample_aspect_ratio.num)\n\n                    sar = ist->st->sample_aspect_ratio;\n\n                else\n\n                    sar = ist->st->codec->sample_aspect_ratio;\n\n                av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar);\n\n                if (!(filtered_frame = avcodec_alloc_frame())) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto fail;\n\n                }\n\n            }\n\n            frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||\n\n                !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n            while (frame_available) {\n\n                AVRational ist_pts_tb;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter)\n\n                    get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb);\n\n                if (ost->picref)\n\n                    ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q);\n\n#else\n\n                filtered_frame = decoded_frame;\n\n#endif\n\n                os = output_files[ost->file_index].ctx;\n\n\n\n                /* set the input output pts pairs */\n\n                //ost->sync_ipts = (double)(ist->pts + input_files[ist->file_index].ts_offset - start_time)/ AV_TIME_BASE;\n\n\n\n                if (ost->encoding_needed) {\n\n                    av_assert0(ist->decoding_needed);\n\n                    switch(ost->st->codec->codec_type) {\n\n                    case AVMEDIA_TYPE_AUDIO:\n\n                        do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_VIDEO:\n\n#if CONFIG_AVFILTER\n\n                        if (ost->picref->video && !ost->frame_aspect_ratio)\n\n                            ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect;\n\n#endif\n\n                        do_video_out(os, ost, ist, filtered_frame, &frame_size,\n\n                                     same_quant ? quality : ost->st->codec->global_quality);\n\n                        if (vstats_filename && frame_size)\n\n                            do_video_stats(os, ost, frame_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_SUBTITLE:\n\n                        do_subtitle_out(os, ost, ist, &subtitle,\n\n                                        pkt->pts);\n\n                        break;\n\n                    default:\n\n                        abort();\n\n                    }\n\n                } else {\n\n                    AVPacket opkt;\n\n                    int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);\n\n\n\n                    av_init_packet(&opkt);\n\n\n\n                    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes)\n\n#if !CONFIG_AVFILTER\n\n                        continue;\n\n#else\n\n                        goto cont;\n\n#endif\n\n\n\n                    /* no reencoding needed : output the packet directly */\n\n                    /* force the input stream PTS */\n\n\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                        audio_size += data_size;\n\n                    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                        video_size += data_size;\n\n                        ost->sync_opts++;\n\n                    }\n\n\n\n                    opkt.stream_index= ost->index;\n\n                    if(pkt->pts != AV_NOPTS_VALUE)\n\n                        opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;\n\n                    else\n\n                        opkt.pts= AV_NOPTS_VALUE;\n\n\n\n                    if (pkt->dts == AV_NOPTS_VALUE)\n\n                        opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base);\n\n                    else\n\n                        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);\n\n                    opkt.dts -= ost_tb_start_time;\n\n\n\n                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n\n                    opkt.flags= pkt->flags;\n\n\n\n                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n\n                    if(   ost->st->codec->codec_id != CODEC_ID_H264\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO\n\n                       ) {\n\n                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))\n\n                            opkt.destruct= av_destruct_packet;\n\n                    } else {\n\n                        opkt.data = data_buf;\n\n                        opkt.size = data_size;\n\n                    }\n\n\n\n                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);\n\n                    ost->st->codec->frame_number++;\n\n                    ost->frame_number++;\n\n                    av_free_packet(&opkt);\n\n                }\n\n#if CONFIG_AVFILTER\n\n                cont:\n\n                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n\n                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n                if (ost->picref)\n\n                    avfilter_unref_buffer(ost->picref);\n\n            }\n\n            av_freep(&filtered_frame);\n\n#endif\n\n            }\n\n\n\nfail:\n\n        av_free(buffer_to_free);\n\n        /* XXX: allocate the subtitles in the codec ? */\n\n        if (subtitle_to_free) {\n\n            avsubtitle_free(subtitle_to_free);\n\n            subtitle_to_free = NULL;\n\n        }\n\n        av_freep(&decoded_frame);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n discard_packet:\n\n\n\n    return 0;\n\n}\n", "idx": 7808, "substitutes": {"ist": ["dist", "set", "ict", "lda", "er", "adder", "empt", "ace", "add", "dit", "art", "nd", "ft", "IST", "ht", "wd", "pect", "att", "ast", "tt", "ind", "ic", "rest", "ick", "mot", "kt", "inst", "start", "part", "isi", "ess", "istor", "pick", "ext", "rss", "aint", "xt", "ski", "irst", "edit", "ush", "et", "gd", "pt", "artist", "imet", "feat", "ad", "it", "osi", "nt", "work", "ant", "irc", "isd", "alist", "gest", "sth", "ard", "ists", "uss", "pop", "est", "at", "ctx", "ait", "act", "sett", "iste", "sta", "dr", "ism", "ld"], "ist_index": ["est_address", "est_index", "est_type", "ist_Index", "ist_type", "est_Index", "ist_address"], "ost_table": ["ast_cache", "ost_cache", "ost_db", "ost_stream", "ast_stream", "ast_db", "ast_table"], "nb_ostreams": ["nb_oststreams", "nb_ostreamb", "nb_octstreamses", "nb_oststreamses", "nb_ostucses", "nb_ostucd", "nb_ostucb", "nb_ostields", "nb_ostreamd", "nb_ostieldb", "nb_octreamd", "nb_octreamb", "nb_oststreamb", "nb_ostreamses", "nb_octstreamd", "nb_ostucs", "nb_oststreamd", "nb_octreams", "nb_ostieldses", "nb_octstreams", "nb_octstreamb", "nb_ostieldd", "nb_octreamses"], "pkt": ["tpkt", "fcht", "fnt", "pelt", "compacket", "opnt", "Pqt", "facket", "mkt", "dpkt", "apkt", "punct", "fwk", "pcht", "spacket", "compqt", "Pcht", "dpcht", " pct", "dpct", "cpunct", " pwk", "Pct", "cpkt", "fct", "compcht", " pnt", "cpelt", "spelt", "npnt", "npacket", "Pkt", "spkt", "Packet", " pelt", "opdt", "mnt", "npkt", "tpcht", "pnt", "feth", "tpacket", " pqt", "peth", "apunct", "apeth", " packet", "apacket", "opcht", " peth", "npcht", "pct", "pernt", "apnt", " pdt", "perdt", "Pnt", "compkt", "percht", "spqt", "mcht", "fqt", "Pwk", "dpacket", "pwk", "apelt", "Pelt", "tpnt", "pdt", " pcht", "spnt", "cpacket", "packet", "spct", "pqt", "perkt", "fkt", " punct", "macket", "apcht"], "os": ["pos", "ox", "pc", "sys", "op", "ol", "bos", "ocr", "is", "cs", "acs", "ds", "oS", "ops", "fs", "ms", "io", "OS", "as", "us", "osc", "o", "oos", "osi", "ot", "oss", "oid"], "ost": ["sth", "proc", "od", "mt", "ast", "oper", "osp", "op", "ott", "org", "oc", "irst", "tt", "ont", "mot", "opt", "aud", "osi", "nt", "ot", "oss", "oid", "opp", "OST"], "ret": ["nc", "rc", "mt", "fun", "rep", "success", "result", "val", " RET", "mem", "gc", "seq", "RET", "resp", "stat", "reg", "res", "sent", "fin", " resp", "flag", "reply", "cb", "final", "Ret"], "i": ["ui", "index", "ei", "j", "cli", "ti", "p", "slice", "mi", "qi", "ii", "inner", "id", "n", "ni", "ip", "abi", "c", "f", "ini", "info", "it", "ci", "b", "iu", "I", "si", "li"], "got_output": ["gotamoutput", "sent_input", "got_image", " got_information", "got_video", "gotayoutput", "gotayinformation", "gotaminformation", "got_information", "sent_image", "gotamvideo", "sent_output", "gotayvideo", "got_input", " got_video"], "buffer_to_free": ["buffer_from_zero", "buffer_from_used", "buffer_to_zero", "buffer_to_size", "buffer_from_free", "buffer_from_size", "buffer_to_used"], "subtitle": ["Subscript", " subscriptiontitle", " subscriptionscript", "subscript", "SubTitle", "Subtitle", "subTitle", " subscript", " subscriptionTitle", " subTitle"], "subtitle_to_free": ["subtitle_from_free", "subtitle_from_used", "subtitle_to_used", "subtitle_to_Free", "subtitle_from_Free"], "frame_available": [" frame_supported", "frame_supported", "frame_info", " frame_info", "frame__supported", "frame__length", "frame_length", " frame_length", "frame__info", "frame__available"], "quality": [" gamma", " scale", "fps", " quiet", " quota", " qual", "scale", " fps", " compression", " seq", " error", "len", " disp", " clip", " rc", " gain", " Quality", " resolution", " fl", "f", " resp", "Quality", " reliability", "qa", " fa", "q", " progress"], "avpkt": ["afpce", "avfsk", "avpekt", "avfte", "avipkt", "avtpkat", "avpunch", "AVpkg", "avppacket", " avtpqt", "avnpcht", "avcpkat", " avppunch", "avPkt", "avbct", "avipsk", "avPiece", "AVPct", "avpacket", "afpnt", "avpeiece", "afpte", "avpunt", "avecpnt", "avpdr", "affce", "AVpunt", " avpcht", "avipte", "AVpacket", "avnpnt", "avPunt", "avopdr", "avgkt", "avcpce", "avcpnt", "avpnt", "avppsk", "avpekg", "avtpkt", "avPct", "avpkg", "avfunch", "avtpcht", "avppunch", "avpcht", "afpsk", "avecpacket", "avtpqt", "avfkt", "avpte", "AVpiece", "avpkat", " avpacket", "avfunt", "avnacket", "avnnt", "afpkt", " avtpcht", "avfdr", "avipacket", "avcpacket", "avcpcht", "afpacket", " avtpkt", "avPkg", " avppnt", " avppacket", "avepnt", " avpunch", "avepkt", "affcht", "avgnt", "affte", "affkt", "avnpacket", "avepacket", "avlpct", "avlpunt", "avopcht", "avcpdr", " avtpkat", "avppte", "avpct", "avepdr", " avpnt", "avnpkt", "avfct", "afpcht", "affsk", "avbiece", "affnt", "avopacket", "avppkt", "avopkt", "AVPkt", "avopqt", "AVPkg", "avnpce", "avfce", "AVpct", "avlpacket", "avecpdr", "avpsk", "avbkt", "avfnt", "avopnt", " avpqt", "avbkg", "avfcht", "avPacket", " avpkat", "AVPiece", " avppkt", "avnkt", "avpce", "affacket", "avpqt", "AVPunt", "avppnt", "avecpkt", "avcpqt", "AVpkt", "avlpkt", "avpiece", "AVPacket", "avfacket", "avcpkt", "avgunch", "avncht", "avopkat", "avpect", "avgacket"], "data_buf": [" data_length", " data_buff", "datasbuffer", "datasbuff", " data_buffer", "data_length", "dataslength", "data_buffer", "datasbuf", "data_buff"], "decoded_data_buf": ["decoded_data_uf", "decoded_data_buff", "decoded_data_buffer"], "data_size": ["data__sized", "data__sent", "data_small", "parent__size", "parent_sent", "data96sized", "parent__sized", "data__size", "data96sent", "data96size", "parent__small", "data_sent", "data96small", "parent__sent", "parent_small", "data__small", "data_sized", "parent_sized", "parent_size"], "decoded_data_size": ["decoded_window_size", "decoded_data_type", "decoded_data_len", "decoded_window_len", "decoded_window_type"], "decoded_frame": ["decoded_position", "decoded___position", "decoded___fram", "decoded_fram", "decrypted_position", "decrypted_fram", "decoded___frame", "decrypted_frame"], "filtered_frame": ["filoded_live", "filoded_frame", "filteredbychannel", "filteredbyframes", "filtered_live", "filtered_channel", "filoded_frames", "filteredbylive", "filtered_frames", "filoded_channel", "filteredbyframe"], "st": ["ste", "gest", "stack", "set", "ust", "stress", "ast", "str", "spect", "stem", "std", "sm", "src", "ce", "irst", "sc", "ct", "stand", "est", "stage", "sts", "St", "rest", "step", "stri", "nd", "put", "start", "inst", "sty", "cl", "sta", "sl", "fr", "dr", "sd", "store", "stream", "ld", "ST", "stim"], "codec": ["Coddc", "predec", "preddc", "codocol", "predocol", "Codocol", "codeec", "predEC", "codedc", "codEC", "CodEC", "Codec", "codeEC", "coddc", "codeocol"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        int l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 7814, "substitutes": {"ctx": ["context", "sci", "cfg", "nc", "pc", "rc", "conv", "wcs", "loc", "input", "gpu", "component", "exec", "cc", "anc", "cli", "sync", "gc", "connection", "kw", "ocr", "client", "cus", "sc", "conn", "xc", "ct", "cm", "cs", "git", "config", "crit", "cmd", "jp", "cca", "tx", "Context", "cms", "ck", "c", "cpp", "cgi", "bc", "dc", "kb", "kt", "ctrl", "cl", "cv", "cam", "qa", "pkg", "mac", "concept", "fc", "cu", "hw", "req", "cf", "ca", "tc", "cn", "ci", "la", "gru", "cas", "qt", "cb", "vc", "cmp", "cp", "fp"], "t0": ["tf2", "tf1", "p1", "t1", "T00", " tZero", "T0", "T4", "i0", "tZero", " T1", "t00", "i1", "tfZero", "l4", "type0", "T1", "ti0", "i00", "type00", "tf0", "l0", "ti00", " t4", "type1", "p0", " t8", "p2", "ti1", "T6", " t6", "T2", "i8", "t8", "TZero", " T00", "p6", " t00", "ti8", "t2", "l2", " t1", "t4", "l1", "t6", " t2", " T0"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n", "idx": 7828, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)\n\n{\n\n    int i;\n\n    uint32_t state= pc->state;\n\n\n\n    /* EOF considered as end of frame */\n\n    if (buf_size == 0)\n\n        return 0;\n\n\n\n/*\n\n 0  frame start         -> 1/4\n\n 1  first_SEQEXT        -> 0/2\n\n 2  first field start   -> 3/0\n\n 3  second_SEQEXT       -> 2/0\n\n 4  searching end\n\n*/\n\n\n\n    for(i=0; i<buf_size; i++){\n\n        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);\n\n        if(pc->frame_start_found&1){\n\n            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n\n                pc->frame_start_found--;\n\n            else if(state == EXT_START_CODE+2){\n\n                if((buf[i]&3) == 3) pc->frame_start_found= 0;\n\n                else                pc->frame_start_found= (pc->frame_start_found+1)&3;\n\n            }\n\n            state++;\n\n        }else{\n\n            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;\n\n            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n\n                i++;\n\n                pc->frame_start_found=4;\n\n            }\n\n            if(state == SEQ_END_CODE){\n\n                pc->state=-1;\n\n                return i+1;\n\n            }\n\n            if(pc->frame_start_found==2 && state == SEQ_START_CODE)\n\n                pc->frame_start_found= 0;\n\n            if(pc->frame_start_found<4 && state == EXT_START_CODE)\n\n                pc->frame_start_found++;\n\n            if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n\n                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 7834, "substitutes": {"pc": ["PC", "sync", "api", "mp", "roc", "bc", "cr", "mc", "cu", "cf", "ca", "pb", "enc", "co", "cus", "cs", "config", "ic", "ck", "can", "dc", "parse", "cl", "mac", "wp", "lc", "icc", "ac", "vc", "comp", "uc", "rc", "sec", "gb", "jc", "sys", "p", "xc", "conn", "inc", "cod", "plugin", "cca", "c", "arc", "amp", "bp", "post", "con", "pd", "cp", "spec", "py", "nc", "func", "proc", "pl", "anc", "cc", "server", "cz", "client", "sc", "ct", "cms", "pm", "ctx", "cur", "px", "ec", "cam", "cache", "fc", "tc", "pac"], "buf": ["batch", "context", "data", "pb", "pool", "br", "uc", "rc", "frame", "conv", "header", "bag", "proc", "gb", "ab", "queue", "loc", "text", "pos", "len", "fi", "que", "map", "src", "base", "seq", "num", "offset", "img", "box", "config", "off", "vec", "cmd", "head", "fb", "block", "buff", "fd", "grab", "ctx", "bc", "buffer", "f", "Buff", "ucc", "cv", "feat", "alloc", "cf", "border", "bh", "uf", "ff", "rb", "b", "length", "cb", "bi", "feed", "v", "port"], "buf_size": ["buf_offset", "bufxcode", "uf_sized", "bufxlen", "buflenoffset", "buflenlen", "buf8size", "bufxsize", "uf_size", "flowlenoffset", "uf_scale", "bufqscale", "buf_scale", "flowlenlen", "buflencode", "buf_width", "buflensize", "buf_code", "buffer_ize", "buffer_size", "uf_loc", "flow_size", "bufqsize", "flowlensize", "bufqshape", "bufxoffset", "bufallize", "bufallwidth", "buf8shape", "bufallsize", "buf_sized", "buffer_shape", "buffer_scale", "buf_len", "buf_loc", "flow_code", "flowlencode", "buf_ize", "flow_offset", "buf_shape", "buf8scale", "buf8ize", " buf_width", " buf_ize", "bufqize", "flow_len"], "i": ["ui", "bi", "pi", "index", "ie", "j", "di", "e", "si", "multi", "fi", "cli", "ti", "p", "yi", "slice", "h", "is", "mi", "phi", "qi", "ii", "hi", "u", "inner", "ind", "id", "n", "ni", "l", "ip", "chi", "ami", "abi", "m", "c", "ix", "f", "zi", "io", "start", "ri", "ini", "info", "o", "gi", "it", "xi", "uri", "ci", "eni", "b", "esi", "iu", "I", "ai", "v", "x", "li"], "frame_start_found": ["frame_base_found", "frame_end_loaded", "frame_end_bound", "frame_start__finder", "frame_start_called", "frame_startFfound", "frame_sizeFFound", "frame_startxfound", "frame_start___old", "frame_starterto", "frame_startMgiven", "frame_start_sent", "frame_start_loaded", "frame_startedbuilt", "frame_end_found", "frame_size_find", "frame_scaleernew", "frame_end_find", "frame_start_given", "frame_start_length", "frame_end_given", "frame_start_find", "frame_start___Found", "frame_startenfound", "frame_startPloaded", "frame_startAllfound", "frame_start_matched", "frame_start_Found", "frame_end_available", "frame_start_finding", "frame_sizeFbroken", "frame_start__new", "frame_end_old", "frame_end_used", "frame_base_printed", "frame_start_left", "frame_scale_to", "frame_scaleerfound", "frame_start_available", "frame_startxFound", "frame_startMfound", "frame_end_sent", "frame_base_called", "frame_scale_new", "frame_end_finished", "frame_starting_matched", "frame_baseenprinted", "frame_startedfound", "frame_scale_used", "frame_baseencalled", "frame_startingFof", "frame_end_built", "frame_starternew", "frame_startAcof", "frame_startAllmissing", "frame_starterfound", "frame_end_length", "frame_start_printed", "frame_start_to", "frame_startscreated", "frame_startPFound", "frame_start_new", "frame_sizeFfound", "frame_startFof", "frame_start__left", "frame_startNlength", "frame_start_created", "frame_starting_found", "frame_startedused", "frame_start___loaded", "frame_startFFound", "frame_size_Found", "frame_scale_found", "frame_size_broken", "frame_startFmatched", "frame_startAcfound", "frame_startqfound", "frame_end_finder", "frame_end_finding", "frame_start_finished", "frame_startPold", "frame_startsfound", "frame_start__used", "frame_startNfind", "frame_startingFmatched", "frame_scaleerused", "frame_start_old", "frame_startingFfound", "frame_sizeFfind", "frame_startPfinding", "frame_startencalled", "frame_baseenfinder", "frame_start_used", "frame_startFbroken", "frame_startAcmatched", "frame_start_missing", "frame_start___found", "frame_startNfound", "frame_size_found", "frame_end_matched", "frame_start_built", "frame_baseenfound", "frame_startenfinder", "frame_start_bound", "frame_startqfinding", "frame_startenprinted", "frame_base_finder", "frame_start_broken", "frame_end_left", "frame_end_missing", "frame_end_Found", "frame_starterused", "frame_startFfind", "frame_scaleerto", "frame_start__to", "frame_starting_of", "frame_startNFound", "frame_startxmatched", "frame_start_of", "frame_startqgiven", "frame_startsFound", "frame_startMfinding", "frame_start__found", "frame_startPfound", "frame_start_finder", "frame_startPbound", "frame_startAllFound"], "state": ["pos", "index", "pi", "area", "set", "scale", "name", "back", "str", "sync", "slice", "type", "un", "order", "ace", "old", "pr", "inner", "id", "STATE", "State", "any", "statement", "step", "range", "pe", "shadow", "in", "count", "unit", "private", "pose", "new", "seed", "region", "sb", "message", "key", "val", "trace", "call", "none", "grade", "rule", "position", "r", "config", "current", "ind", "reg", "via", "mode", "st", "run", "address", "next", "start", "part", "size", "code", "me", "shape", "handle", "direction", "status", "addr", "body", "ate", "rc", "cal", "value", "self", "p", "session", "style", "patch", "use", "c", "instance", "g", "see", "length", "resource", "si", "spec", "tag", "scope", "j", "error", "loc", "e", "ct", "ch", "head", "l", "states", "version", "cur", "force", "wa", "source", "parent", "cache", "err", "o", "ci", "color", "update", "stat", "port"]}}
{"project": "FFmpeg", "commit_id": "0f8d3d8a462c0152ac489dbb013f6df027edd6c4", "target": 0, "func": "static av_cold int encode_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    int i, j, k, m, ret;\n\n\n\n    if ((ret = ff_ffv1_common_init(avctx)) < 0)\n\n        return ret;\n\n\n\n    s->version = 0;\n\n\n\n    if ((avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||\n\n        avctx->slices > 1)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability\n\n    if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    if (avctx->level <= 0 && s->version == 2) {\n\n        s->version = 3;\n\n    }\n\n    if (avctx->level >= 0 && avctx->level <= 4) {\n\n        if (avctx->level < s->version) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Version %d needed for requested features but %d requested\\n\", s->version, avctx->level);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        s->version = avctx->level;\n\n    }\n\n\n\n    if (s->ec < 0) {\n\n        s->ec = (s->version >= 3);\n\n    }\n\n\n\n    if ((s->version == 2 || s->version>3) && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n#if FF_API_CODER_TYPE\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->coder_type != -1)\n\n        s->ac = avctx->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE;\n\n    else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (s->ac == 1) // Compatbility with common command line usage\n\n        s->ac = AC_RANGE_CUSTOM_TAB;\n\n    else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE)\n\n        s->ac = AC_RANGE_DEFAULT_TAB;\n\n\n\n    s->plane_count = 3;\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV420P9:\n\n    case AV_PIX_FMT_YUVA444P9:\n\n    case AV_PIX_FMT_YUVA422P9:\n\n    case AV_PIX_FMT_YUVA420P9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GRAY10:\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n    case AV_PIX_FMT_YUVA444P10:\n\n    case AV_PIX_FMT_YUVA422P10:\n\n    case AV_PIX_FMT_YUVA420P10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GRAY12:\n\n    case AV_PIX_FMT_YUV444P12:\n\n    case AV_PIX_FMT_YUV420P12:\n\n    case AV_PIX_FMT_YUV422P12:\n\n        s->packed_at_lsb = 1;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n    case AV_PIX_FMT_YUVA444P16:\n\n    case AV_PIX_FMT_YUVA422P16:\n\n    case AV_PIX_FMT_YUVA420P16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = 16;\n\n        } else if (!s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        }\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YA8:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV410P:\n\n    case AV_PIX_FMT_YUVA444P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;\n\n        s->colorspace = 0;\n\n        s->transparency = desc->nb_components == 4 || desc->nb_components == 2;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB32:\n\n        s->colorspace = 1;\n\n        s->transparency = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB48:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 16;\n\n        s->use32bit = 1;\n\n        s->version = FFMAX(s->version, 1);\n\n        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n            av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n    case AV_PIX_FMT_0RGB32:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_GBRP9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GBRP10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GBRP12:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GBRP14:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 14;\n\n    case AV_PIX_FMT_GBRP16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 16;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        if (s->bits_per_raw_sample >= 16) {\n\n            s->use32bit = 1;\n\n            if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n                av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n    av_assert0(s->bits_per_raw_sample >= 8);\n\n\n\n    if (s->bits_per_raw_sample > 8) {\n\n        if (s->ac == AC_GOLOMB_RICE) {\n\n            av_log(avctx, AV_LOG_INFO,\n\n                    \"bits_per_raw_sample > 8, forcing range coder\\n\");\n\n            s->ac = AC_RANGE_CUSTOM_TAB;\n\n        }\n\n    }\n\n    if (s->transparency) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");\n\n    }\n\n#if FF_API_PRIVATE_OPT\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->context_model)\n\n        s->context_model = avctx->context_model;\n\n    if (avctx->context_model > 1U) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->context_model);\n\n        return AVERROR(EINVAL);\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (s->ac == AC_RANGE_CUSTOM_TAB) {\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = ver2_state[i];\n\n    } else {\n\n        RangeCoder c;\n\n        ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8);\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = c.one_state[i];\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        s->quant_table_count = 2;\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            s->quant_tables[0][0][i]=           quant11[i];\n\n            s->quant_tables[0][1][i]=        11*quant11[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant11[i];\n\n            s->quant_tables[1][0][i]=           quant11[i];\n\n            s->quant_tables[1][1][i]=        11*quant11[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5 [i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5 [i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];\n\n        } else {\n\n            s->quant_tables[0][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[0][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];\n\n            s->quant_tables[1][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[1][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];\n\n        }\n\n    }\n\n    s->context_count[0] = (11 * 11 * 11        + 1) / 2;\n\n    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;\n\n    memcpy(s->quant_table, s->quant_tables[s->context_model],\n\n           sizeof(s->quant_table));\n\n\n\n    for (i = 0; i < s->plane_count; i++) {\n\n        PlaneContext *const p = &s->plane[i];\n\n\n\n        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));\n\n        p->quant_table_index = s->context_model;\n\n        p->context_count     = s->context_count[p->quant_table_index];\n\n    }\n\n\n\n    if ((ret = ff_ffv1_allocate_initial_states(s)) < 0)\n\n        return ret;\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (!s->transparency)\n\n        s->plane_count = 2;\n\n    if (!s->chroma_planes && s->version > 3)\n\n        s->plane_count--;\n\n\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);\n\n    s->picture_number = 0;\n\n\n\n    if (avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) {\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            s->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                        sizeof(*s->rc_stat2[i]));\n\n            if (!s->rc_stat2[i])\n\n                return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    if (avctx->stats_in) {\n\n        char *p = avctx->stats_in;\n\n        uint8_t (*best_state)[256] = av_malloc_array(256, 256);\n\n        int gob_count = 0;\n\n        char *next;\n\n        if (!best_state)\n\n            return AVERROR(ENOMEM);\n\n\n\n        av_assert0(s->version >= 2);\n\n\n\n        for (;;) {\n\n            for (j = 0; j < 256; j++)\n\n                for (i = 0; i < 2; i++) {\n\n                    s->rc_stat[j][i] = strtol(p, &next, 0);\n\n                    if (next == p) {\n\n                        av_log(avctx, AV_LOG_ERROR,\n\n                               \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);\n\n                        av_freep(&best_state);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    p = next;\n\n                }\n\n            for (i = 0; i < s->quant_table_count; i++)\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    for (k = 0; k < 32; k++)\n\n                        for (m = 0; m < 2; m++) {\n\n                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);\n\n                            if (next == p) {\n\n                                av_log(avctx, AV_LOG_ERROR,\n\n                                       \"2Pass file invalid at %d %d %d %d [%s]\\n\",\n\n                                       i, j, k, m, p);\n\n                                av_freep(&best_state);\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            p = next;\n\n                        }\n\n                }\n\n            gob_count = strtol(p, &next, 0);\n\n            if (next == p || gob_count <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");\n\n                av_freep(&best_state);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            p = next;\n\n            while (*p == '\\n' || *p == ' ')\n\n                p++;\n\n            if (p[0] == 0)\n\n                break;\n\n        }\n\n        if (s->ac == AC_RANGE_CUSTOM_TAB)\n\n            sort_stt(s, s->state_transition);\n\n\n\n        find_best_state(best_state, s->state_transition);\n\n\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            for (k = 0; k < 32; k++) {\n\n                double a=0, b=0;\n\n                int jp = 0;\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    double p = 128;\n\n                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) {\n\n                        if (a+b)\n\n                            p = 256.0 * b / (a + b);\n\n                        s->initial_states[i][jp][k] =\n\n                            best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                        for(jp++; jp<j; jp++)\n\n                            s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k];\n\n                        a=b=0;\n\n                    }\n\n                    a += s->rc_stat2[i][j][k][0];\n\n                    b += s->rc_stat2[i][j][k][1];\n\n                    if (a+b) {\n\n                        p = 256.0 * b / (a + b);\n\n                    }\n\n                    s->initial_states[i][j][k] =\n\n                        best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                }\n\n            }\n\n        }\n\n        av_freep(&best_state);\n\n    }\n\n\n\n    if (s->version > 1) {\n\n        int plane_count = 1 + 2*s->chroma_planes + s->transparency;\n\n        s->num_v_slices = (avctx->width > 352 || avctx->height > 288 || !avctx->slices) ? 2 : 1;\n\n\n\n        if (avctx->height < 5)\n\n            s->num_v_slices = 1;\n\n\n\n        for (; s->num_v_slices < 32; s->num_v_slices++) {\n\n            for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {\n\n                int maxw = (avctx->width  + s->num_h_slices - 1) / s->num_h_slices;\n\n                int maxh = (avctx->height + s->num_v_slices - 1) / s->num_v_slices;\n\n                if (s->num_h_slices > avctx->width || s->num_v_slices > avctx->height)\n\n                    continue;\n\n                if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24)\n\n                    continue;\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= MAX_SLICES || !avctx->slices)\n\n                    goto slices_ok;\n\n            }\n\n        }\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        if ((ret = write_extradata(s)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if ((ret = ff_ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    s->slice_count = s->max_slice_count;\n\n    if ((ret = ff_ffv1_init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & AV_CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        if (!avctx->stats_out)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->max_slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7852, "substitutes": {"avctx": [" avcas", "ajdc", "calcu", "afcup", "aveca", "avecu", "calpkg", " avlc", "avconfig", "verctl", "afctx", "avdc", "ajcontext", "avsync", "ajctl", "avalctl", "afsync", "avca", "navctx", "afbc", "avalctx", " avca", "Avctl", "calcontext", "avalcu", "navsync", "afcmp", "navconn", "avbc", "varlc", "avepkg", "avelc", "abcu", " avcu", "afvoc", "avecontext", "avpkg", "navcu", "afconn", "Avctx", "afcu", "avecache", "AVctx", "afctl", "aflc", "afpkg", "AVlc", "ajca", "avevoc", "aveconfig", "AVcmp", "avercontext", "Avcontext", "varctx", "calcal", " avcup", "avcontext", "avectl", "aveconn", "navcontext", "abcf", "avcci", "avalvoc", "avconn", "varcas", "calca", "averbc", "avcal", "averctx", "avecmp", "avecas", "ajconn", "verconn", "AVcontext", "abcontext", "avecci", " avcci", "afcf", "avcmp", "verctx", " avcache", "varcontext", "vercmp", " avcf", "avalconn", "afcci", "avcup", "avalcontext", "vercontext", "avcu", " avconfig", "ajcas", "afconfig", "avecup", " avcontext", "afdc", "avecf", "navcf", "avedc", "averctl", "afcache", "avctl", "navctl", "ajcu", "avalbc", "avcf", "calctx", "Avcu", "afcontext", "afcal", "avlc", "vercu", "avcas", "abctx", "avecal", "varpkg", "avectx", "avvoc", "afca", "afcas", "varcu", "avcache", "avesync", "ajctx"], "s": ["d", "sync", "args", "site", "ops", "sg", "services", "fs", "f", "b", "v", "new", "sites", "sq", "sb", "ses", "cs", "u", "ss", "ts", "t", "ns", "sa", "w", "its", "less", "es", "ins", "hs", "storage", "sys", "self", "ls", "session", "S", "ps", "full", "gs", "sets", "ims", "stats", "n", "css", "g", "sup", "us", "ssl", "sl", "su", "qs", "rs", "si", "spec", "y", "aws", "e", "details", "is", "sc", "service", "ds", "l", "sym", "ms", "bis", "settings", "o", "secondary", "js", "os"], "desc": ["sec", "dir", "def", "de", "text", "name", "enc", "esc", "sc", "meta", "asc", "des", "rec", "dc", "summary", "path", "description", "acc", "en", "info", "Desc", " description", " Desc", "ca", "sub", "md", "doc"], "i": ["pi", "index", "d", "is", "mi", "ii", "r", "id", "n", "ni", "l", "f", "a", "info", "x", "ci", "z", "b", "I", "ai", "v", "si"], "j": ["pos", "y", "ie", "d", "h", "ij", "ii", "r", "n", "l", "g", "f", "kj", "uj", "o", "im", "z", "b", "q", "v", "J", "si"], "k": ["ak", "y", "e", "ik", "key", "ks", "kw", "h", "K", "kk", "ki", "u", "n", "f", "dk", "o", "w", "km", "z", "sk", "q", "ke", "v"], "m": ["gm", "y", "mt", "mm", "d", "e", "mp", "h", "mi", "cm", "r", "u", "fm", "n", "l", "mr", "t", "g", "f", "ms", "mc", "o", "M", "md", "dm", "v"], "ret": ["re", "rc", "ref", "def", "mt", "result", "success", "fun", "alt", "att", "back", "value", "len", "val", " RET", " Ret", "mem", "bad", "arr", "no", "bit", "mi", "num", "RET", "r", "reg", "id", "obj", "res", "aux", "t", "cur", "rec", "tr", "f", "lit", "cat", "det", "al", "utf", "match", "nt", "dr", "reply", "arg", "red", "rets", "Ret"], "coder_type": ["coder_count", "coderingcount", "coder_pe", "coderingid", "coderingtype", "coder_id", "coding_pe", "coder_format", "coding_count", "coderingkind", "coder_kind", "coding_kind", "coding_format", "coding_type", "coding_id"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARNINGDS", "FF_ENABLE_DEPRECATION_WARES", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_WARDS", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNINGES", "FF_ENABLE_DEPRECATION_WARNs", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_WARNS", "FF_ENABLE_DEPRECATION_WARNES", "FF_ENABLE_DEPRECATION_WARNDS"]}}
{"project": "FFmpeg", "commit_id": "d85aa76115214183e7e3b7d65e950da61474959a", "target": 0, "func": "static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)\n\n{\n\n    const uint8_t *data = nal->data;\n\n    int length          = nal->size;\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int64_t offset;\n\n    int startheader, cmpt = 0;\n\n    int i, j, res = 0;\n\n\n\n    if (!ret || !arg) {\n\n        av_free(ret);\n\n        av_free(arg);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n\n\n    if (!s->sList[1]) {\n\n        ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);\n\n\n\n\n\n        for (i = 1; i < s->threads_number; i++) {\n\n            s->sList[i] = av_malloc(sizeof(HEVCContext));\n\n            memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));\n\n            s->sList[i]->HEVClc = s->HEVClcList[i];\n\n        }\n\n    }\n\n\n\n    offset = (lc->gb.index >> 3);\n\n\n\n    for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) {\n\n        if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n            startheader--;\n\n            cmpt++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < s->sh.num_entry_point_offsets; i++) {\n\n        offset += (s->sh.entry_point_offset[i - 1] - cmpt);\n\n        for (j = 0, cmpt = 0, startheader = offset\n\n             + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) {\n\n            if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n                startheader--;\n\n                cmpt++;\n\n            }\n\n        }\n\n        s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt;\n\n        s->sh.offset[i - 1] = offset;\n\n\n\n    }\n\n    if (s->sh.num_entry_point_offsets != 0) {\n\n        offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;\n\n        if (length < offset) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"entry_point_offset table is corrupted\\n\");\n\n            res = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;\n\n        s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;\n\n\n\n    }\n\n    s->data = data;\n\n\n\n    for (i = 1; i < s->threads_number; i++) {\n\n        s->sList[i]->HEVClc->first_qp_group = 1;\n\n        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;\n\n        memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n        s->sList[i]->HEVClc = s->HEVClcList[i];\n\n    }\n\n\n\n    avpriv_atomic_int_set(&s->wpp_err, 0);\n\n    ff_reset_entries(s->avctx);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {\n\n        arg[i] = i;\n\n        ret[i] = 0;\n\n    }\n\n\n\n    if (s->ps.pps->entropy_coding_sync_enabled_flag)\n\n        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++)\n\n        res += ret[i];\n\nerror:\n\n    av_free(ret);\n\n    av_free(arg);\n\n    return res;\n\n}\n", "idx": 7854, "substitutes": {"s": ["d", "sync", "site", "ops", "sr", "sg", "services", "strings", "fs", "f", "sv", "b", "in", "conf", "v", "south", "an", "sites", "sq", "outs", "sb", "nas", "h", "ses", "cs", "this", "r", "u", "sf", "ions", "ss", "ts", "t", "ns", "sa", "a", "its", "w", "size", "sis", "https", "es", "ins", "parts", "comments", "self", "sys", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "sets", "xs", "stats", "c", "g", "us", "ssl", "sl", "su", "bs", "qs", "rs", "si", "spec", "sci", "aws", "e", "server", "is", "sc", "service", "ds", "l", "states", "sie", "m", "sym", "sh", "ctx", "settings", "o", "js", "os"], "nal": [" nAL", "wals", "signal", "nali", " nals", "Nul", " naf", "signAL", "unal", "Nal", "Neal", "nale", "signals", "anul", "anal", "nul", "neal", "Naler", "naneal", "anals", "naler", "nanals", "nals", "nanal", "unali", "wAL", " naler", "nAL", "wal", "Nali", "Naf", "analer", "signali", "NAL", "nanul", "Nale", " nale", " nali", "signul", "unale", "unals", "Nals", "waf", " neal", "naf", " nul"], "data": ["batch", "pos", "new", "sum", "index", "frame", "da", "result", "DATA", "input", "d", "queue", "Data", "len", "val", "mem", "p", "arr", "map", "buf", "image", "bytes", "device", "block", "buff", "ops", "m", "content", "all", "rec", "address", "buffer", "next", "f", "pointer", "wa", "capacity", "array", "padding", "start", "a", "cache", "info", "memory", "length", "results", "body", "window", "dat"], "lc": ["nc", "pc", "lb", "gb", "lv", "sb", "jc", "cli", "sys", "acl", "LC", "ls", "cus", "lic", "sc", "lu", "cm", "cs", "lib", "wl", "l", "c", "ctx", "kl", "bc", "dc", "sa", "ctrl", "mc", "cl", "fc", "cow", "lp", "lf", "ci", "la", "lan", "ln", "si"], "ret": ["ext", "re", "rc", "ref", "pub", "def", "result", "fun", "bf", "alt", "att", "success", "len", "val", "fi", "af", "mem", "arr", "rf", "args", "seq", "RET", "r", "reg", "res", "obj", "tr", "art", "rev", "lit", "cat", "req", "flag", "part", "feat", "info", "det", "ft", "nt", "reply", "valid", "length", "desc", "red", "rets", "Ret", "rt"], "arg": ["sec", "ref", "target", "au", "argument", "loc", "param", "error", "enc", "len", "val", "aug", "arr", "args", "arm", "ann", "bit", "conn", "ace", "inc", "bug", "ack", "config", "par", "reg", "var", "arc", "weight", "g", "art", "pass", "cat", "mac", "flag", "feat", "ad", "ar", "ark", "amp", "ray", "ac", "ag", "b", "addr", "Arg", "doc", "ax"], "offset": ["pos", "index", "header", "set", "section", "area", "Offset", "api", "slice", "type", "off", "online", "f", "range", "location", "timeout", "count", "row", "ref", "margin", "limit", "val", "position", "alpha", "address", "start", "a", "part", "axis", "size", "addr", "offs", "ptr", "base", "url", "value", "len", "byte", "image", "uple", "entry", "shift", "gap", "padding", "slot", "length", "align", "reset", "end", "optional", "error", "loc", "skip", "pointer", "array", "info", "o", "olerance", "elta", "office"], "startheader": [" startvector", "openmessage", " startHeader", "startingheader", "openheaders", "startoffset", " startmessage", "setpadding", "openlayer", "startHeader", "Startvector", "midmargin", " startlayer", "startvector", "startlayer", "startpadding", "endmargin", "setheader", "middlelayer", "openheader", "endlayer", "endmessage", "midheaders", "Startheaders", "endpadding", "startingchannel", "startingmargin", "Startheader", "startmargin", "setoffset", "startingoffset", " startpadding", "middlevector", "midlayer", "StartHeader", "startheaders", "endchannel", "endheader", "middleHeader", " startoffset", " startmaster", "endheaders", "Startlayer", "midmaster", "middleheader", "midheader", "startmaster", "endoffset", "midoffset", "midchannel", "setheaders", "Startmaster", "startmessage", " startheaders", "startchannel"], "i": ["ui", "bi", "y", "index", "pi", "ie", "di", "e", "d", "multi", "fi", "cli", "li", "p", "yi", "ti", "api", "jit", "mi", "is", "phi", "qi", "ii", "r", "u", "inner", "ji", "ind", "id", "n", "l", "ni", "ip", "ami", "c", "ix", "ori", "oi", "f", "g", "zi", "io", "start", "ri", "ini", "info", "my", "gi", "iv", "x", "xi", "uri", "it", "o", "ci", "eni", "z", "b", "in", "iu", "ani", "I", "ai", "v", "si"], "j": ["pos", "note", "y", "index", "k", "ie", "aj", "e", "d", "key", "jc", "p", "bj", "jit", "jl", "ij", "ii", "r", "ch", "ji", "ind", "je", "n", "l", "jp", "dj", "jo", "m", "g", "f", "ja", "jet", "uj", "kj", "el", "jen", "o", "it", "x", "job", "ju", "z", "js", "b", "jump", "adj", "q", "v", "J", "jj", "li"], "cmpt": [" cmnt", "qupt", "cmpx", "ympp", "cmnt", "CMptr", "qupx", "fmpp", " cmpc", "fmnt", "kmpr", "mmpx", "ympt", "kmpl", "pmpt", "mmpt", "qupton", " cmptr", " cmpp", "CMnt", "mmnt", "cmpr", "ympc", " cmpl", "umpc", " cmpr", "CMpp", " cmpton", "CMpt", "kmpt", "fmpt", "cmpp", "umnt", "pmnt", "fmpl", "cmpton", "pmpp", "qunt", "fmpr", "cmptr", "umpt", "kmnt", "cmpc", " cmpx", "pmptr", "cmpl", "umpp", "ymnt", "umpr", "mmpton"]}}
{"project": "qemu", "commit_id": "c1076c3e13a86140cc2ba29866512df8460cc7c2", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n", "idx": 7866, "substitutes": {"s": ["d", "sync", "sports", "args", "site", "sg", "services", "fs", "f", "sv", "b", "conf", "v", "new", "sites", "sq", "sb", "params", "h", "ses", "cs", "this", "r", "u", "sf", "ss", "ts", "t", "uns", "ns", "a", "its", "es", "status", "ins", "storage", "comments", "sys", "self", "p", "ls", "session", "S", "ps", "gs", "sets", "ims", "xs", "n", "c", "g", "us", "ssl", "sl", "state", "su", "qs", "rs", "si", "spec", "y", "aws", "e", "details", "is", "service", "ds", "l", "states", "sie", "m", "sym", "ms", "sim", "as", "settings", "se", "i", "js", "os", "results"], "addr": ["data", "nm", "pos", "nc", "rc", "ref", "url", "proc", "sid", "name", "e", "sb", "len", "src", "Address", "pad", "conn", "ace", "offset", "r", "ip", "res", "mode", "add", "layer", "address", "host", "hop", "start", "a", "nr", "mac", "sta", "ad", "ar", "amp", "dr", "gen", "attr", "ptr", "rs", "x", "base"], "miny": ["posx", "miney", "rainx", "lateY", "usep", "minY", "Miny", "posY", "usey", "Minx", "usex", "minw", "rainey", "maxY", "latex", "maxp", "latey", " miney", "minx", "Minw", " minp", "posw", "MinY", "minp", "posy", "lateey", " minw", "rainy", " minx", "maxx", "rainY", " minY", "useY"], "maxy": ["paxy", "daja", "smaga", "lagic", "maja", "Maxy", "Mium", "dagic", "smagic", "meth", "paga", "peth", "laga", "smeth", "daxy", "magic", " maja", "Maja", " mium", "mium", "smaxy", "maga", "pagic", " magic", "laxy", "dium", "leth", "Magic"], "surface": ["func", "storage", "vas", "skin", "sb", "ser", "core", "sys", "sur", "fe", "sm", "slice", "src", "client", "faces", "sc", "sf", "pse", "sym", "m", "sr", "ils", "layer", "buffer", "shell", "source", "console", "draw", "sim", "prof", "face", "cel", "ssl", "sta", "sl", "wrapper", "rect", "su", "node", "setup", "aster", "ptr"], "src_width": ["srcacfall", "src\u00b7length", "dest_work", "src\u00b7width", "src_weight", "srcacsize", "srcacflow", "dest_flow", "src_radius", "src\u00b7height", " src_length", "dest_height", "src_size", "src_height", "src__weight", "src_fall", "dest_weight", "src__width", "src__work", "dest_radius", "src_area", "dest_fall", "src_length", "dest_size", "srcacwidth", "dest_length", " src_weight", "src_work", "srcacheight", "src\u00b7radius", "srcaclength", " src_area", "srcacweight", "src_flow"], "dest_width": ["destingheight", "src_strength", "src_weight", "destingwidth", "destingweight", "dest_flow", " src_length", "dest_strength", " src_wide", "dest_height", "src_height", "destinglength", "dest_wide", "dest__length", "dest_weight", "dest_depth", "dest__width", "src_length", "dest_length", "src_depth", "src_flow", "dest__strength", "dest__flow"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dmar_q35(GArray *table_data, GArray *linker)\n\n{\n\n    int dmar_start = table_data->len;\n\n\n\n    AcpiTableDmar *dmar;\n\n    AcpiDmarHardwareUnit *drhd;\n\n\n\n    dmar = acpi_data_push(table_data, sizeof(*dmar));\n\n    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;\n\n    dmar->flags = 0;    /* No intr_remap for now */\n\n\n\n    /* DMAR Remapping Hardware Unit Definition structure */\n\n    drhd = acpi_data_push(table_data, sizeof(*drhd));\n\n    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);\n\n    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */\n\n    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;\n\n    drhd->pci_segment = cpu_to_le16(0);\n\n    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);\n\n\n\n    build_header(linker, table_data, (void *)(table_data->data + dmar_start),\n\n                 \"DMAR\", table_data->len - dmar_start, 1, NULL);\n\n}\n", "idx": 7869, "substitutes": {"dmar": ["admor", " dmor", "ldamar", "pdmar", "damar", "sdgar", "admar", " dmer", "dmor", "nmar", "dpar", "sdpar", "sdmr", " dma", "pdaml", "Dmer", " dpar", "pdmer", "adamar", "daml", " dgar", "dgar", "sdmer", "adara", "ldmer", "adpar", " damar", " daml", "Dmar", "Dmr", "dma", "pdamar", "adaml", "dmr", "Dma", "dmer", "namar", " dmr", "nmer", "ldpar", "sdmar", "dara", " dara", "sdamar", "sdma", "pdpar", "nara", "admer", "pdmor", "ldmar", "adgar"], "drhd": ["srgd", "sradh", "drxd", " drhid", "arrhd", "dradh", "adrhid", "DRrh", "yrhd", "rrmd", "hrrh", "fradh", " drrh", "gradh", "drvd", " drdd", "DRvd", "rrxd", "DRhd", "srcd", "DRadh", "frgd", "dervd", "rrbd", " drmd", "hrpd", " dradh", "rddd", "drcd", "drrh", "frhd", "drhard", "adrhd", "rdhd", "rdxd", "grcd", "grhd", " drbd", "hrhard", "hrhd", "adrdd", "hrdd", "derxd", "rdcd", "drpd", "rrhard", "drmd", "arrdd", "grgd", "srhd", "rradh", "hradh", "derdd", " drxd", "yrvd", "drdd", "rrhd", "drhid", "DRcd", "hrbd", "derhard", "yrdd", "drbd", "yrpd", "arrxd", "deradh", " drpd", "rdvd", "adrxd", "derhd", " drcd", "rrvd", "hrcd", "drgd", "rrcd", "arrhid", "hrmd", "hrvd", " drvd", "frcd", "hrxd", "DRdd"]}}
{"project": "qemu", "commit_id": "db1da1f2b5f3a2383030438553988f0734a97dbe", "target": 0, "func": "static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)\n\n{\n\n    GtkWidget *machine_menu;\n\n    GtkWidget *separator;\n\n\n\n    machine_menu = gtk_menu_new();\n\n    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);\n\n\n\n    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(\"_Pause\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->reset_item = gtk_menu_item_new_with_mnemonic(_(\"_Reset\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);\n\n\n\n    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(\"Power _Down\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->quit_item = gtk_menu_item_new_with_mnemonic(_(\"_Quit\"));\n\n    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),\n\n                                 \"<QEMU>/Machine/Quit\");\n\n    gtk_accel_map_add_entry(\"<QEMU>/Machine/Quit\",\n\n                            GDK_KEY_q, GDK_CONTROL_MASK);\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);\n\n\n\n    return machine_menu;\n\n}\n", "idx": 7873, "substitutes": {"s": ["y", "private", "e", "d", "sb", "comments", "sys", "p", "spec", "ks", "args", "ls", "session", "S", "h", "ps", "is", "details", "ses", "cs", "sets", "r", "service", "sf", "ds", "gs", "xs", "l", "states", "ops", "ss", "c", "sie", "ts", "services", "sg", "rs", "v", "sym", "fs", "g", "f", "ns", "t", "as", "us", "a", "ssl", "settings", "se", "i", "sl", "secondary", "its", "o", "sis", "ess", "sv", "js", "b", "es", "ins", "hs", "os", "conf", "qs", "south", "si"], "accel_group": ["accelsgroup", "accellssize", "accelamname", "accelamcap", "acption_cap", "accelscap", "accellsname", "accell_size", "accel_cap", "accel_g", "acptionamg", "accelersize", "acptionamname", "acptionamgroup", "accellsgroup", "acption_g", "acption_group", "accell_manager", "accelername", "accelssize", "accelergroup", "acptionamcap", "accel_size", "accelsname", "accel_manager", "accelsmanager", "accelamg", "accellsmanager", "accell_group", "accelsg", "accel_name", "acption_name", "accelermanager", "accelamgroup", "accell_name"], "machine_menu": ["machine\u00b7ui", "mobile_menu", " machine_image", "mobile_family", "machine_mode", "machinekmouse", "machine_size", "machine_team", "theme_sequence", " machine_view", "machineacteam", "machinekmenu", "menu_group", "machine_group", "machineacsize", "machineacsequence", "mobile_consumer", "machine_bar", "model_size", "machineacui", "machine_mu", "machine_consumer", "machine_item", "machine__cache", "machine\u00b7menu", "elementacmode", "machine__block", "machine_ui", "machineacmenu", " machine_cache", "machine\u00b7server", "machineADgroup", "model_ui", "menu_item", " machine_ui", "machineacrule", "machinekfamily", "element_mode", "machine_cache", "element_ui", "element_menu", "machinekteam", " machine__menu", "elementacui", "machine_sequence", "machine__menu", "theme_menu", "machinekchain", "menu_menu", "machine_view", "menu_license", "machinekmode", "element_rule", " machine_block", "elementacrule", "machineacchain", "menu_ui", "menu_mu", "model_item", "theme_chain", "machine_chain", "machinekrule", "machine_family", "machineacitem", "machinekui", "machineADui", " machine_server", "machine_image", "machinekconsumer", " machine__block", "machineksequence", "machine_block", "machineADmenu", "machine_rule", "mobile_sequence", "model_menu", "machine_server", "machineADitem", " machine__cache", "machine_license", "elementacmenu", " machine__bar", "machine_mouse", "menu_mouse", " machine_bar", "menu_query", "machine\u00b7image", "theme_team", "machineacmode", "machine__bar", "machine_query", "machinekquery"], "separator": [" separatter", " separation", "celerner", " separner", "terminer", " separrator", "terminulator", "celeratter", "terminner", "separatter", "percer", "alternation", "alternater", "perater", "separation", "perrator", "terminater", "iteraser", " separulator", " separcer", "terminator", "iterer", " separaser", "separcer", "perinator", "iterrator", " separinator", "separaser", "separater", "separulator", "perator", "termininator", "celerator", "alterncer", "separner", " separer", "terminaser", "terminatter", "terminrator", "alternator", "separinator", "separer", "perner", "termincer", "iterator", "perulator", "celerinator", "separrator", " separater", "termination"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n", "idx": 7874, "substitutes": {"opaque": ["ospatile", "ospaques", "osphalf", "opatile", "ophalf", "opacity", "opthole", "osphole", "opaques", "ophole", "operaque", "ospacity", "ospaque", "hopacity", "hophalf", "optaques", "operhalf", "operacity", "hopaques", " opatile", " opaques", "optaque", "optatile", "hopaque", "operaques", " ophole"], "offset": ["data", "operation", "pos", "index", "reset", "target", "set", "error", "len", "sync", "Offset", "slice", "position", "off", "rot", "entry", "address", "pointer", "range", "padding", "location", "attribute", "start", "parent", "slot", "reference", "o", "secondary", "prefix", "origin", "bound", "length", "timeout", "alias", "addr", "fp", "seek", "align", "ptr", "port"], "value": ["data", "index", "set", "number", "scale", "name", "message", "key", "val", "server", "type", "flow", "values", "image", "service", "block", "child", "Value", "VALUE", "entry", "address", "buffer", "range", "array", "padding", "max", "slot", "w", "fee", "memory", "timeout", "length", "unit", "v", "property", "update", "format", "port"], "size": ["data", "set", "name", "len", "type", "SIZE", "bytes", " length", "ize", "Size", "address", "buffer", "f", " address", " mode", "fee", "timeout", "length", "count"], "s": ["scope", "sq", "e", "submit", "sb", "slave", "sys", "p", "sync", "spec", "session", "S", "socket", "h", "ses", "r", "service", "u", "n", "ops", "ss", "c", "m", "sg", "instance", "sym", "t", "g", "f", "a", "ssl", "i", "sl", "o", "secondary", "b", "status", "si"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n", "idx": 7881, "substitutes": {"opaque": ["oacity", "popque", " opque", " opaqu", "popaqu", "opaqu", "opsaque", "hopque", "opacity", "opsacity", "opsque", "oaque", "operque", "opaques", "operaque", "oque", "opsaques", "oaques", "hopaqu", "operacity", "popaque", "opque", "hopaques", "popaques", " opaques", "hopaque", "operaques"], "rfile": ["srfile", "krfile", "erfile", "rchannel", "erFile", "krFile", "roname", " rname", "rama", "rFile", "srbook", "robook", "srname", "rofile", "rbook", "roama", " rfiles", " rbook", "rname", "krfiles", " rchannel", "erchannel", "krchannel", "rfiles", "srama", " rFile", "erfiles", " rama"], "rdma": ["udpa", "rdme", "rdra", "drma", "rhra", "rnma", "rhwa", "ldme", "rdmas", "rcfa", "rhma", "rdca", "ldm", "rdwa", "ratmas", "drm", "ldma", "rcra", "rtpa", "rdfa", "ratma", "rdm", "ratme", "drme", "ratca", "rtma", "rdpa", "rhfa", "rtha", "rnfa", "ratha", "ratpa", "rnwa", "ldca", "rdha", "udha", "udmas", "rtmas", "rnra", "drca", "udma", "rcwa", "rcma", "ratm"]}}
{"project": "qemu", "commit_id": "323ad19bcc601d3ec9cb6f0f5b4d67b602fc519e", "target": 1, "func": "static void dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    const char *p, *q;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;\n\n                            opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            /* Special hack to properly dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7882, "substitutes": {"env": ["context", "data", "scope", "ext", "header", "dir", "profile", "end", "def", "package", "db", "queue", "e", "loader", "enc", "exc", "er", "exec", "export", "server", "event", "ea", "que", "args", "style", "conn", "vs", "ev", "config", "viron", "dict", "stage", "ef", "obj", "her", "enter", "engine", "address", "host", "console", "ec", "en", "el", "err", "operator", "dev", "manager", "code", "eni", "conf", "environment"], "table": ["stable", "root", "che", "object", "index", "section", "package", "db", "queue", "error", "body", "view", "bar", "interface", "show", "key", "Table", "server", "event", "the", "where", "container", "rule", "base", "connection", "session", "type", "player", "style", "function", "test", "thin", "module", "fore", "query", "cher", "file", "stage", "block", "child", "can", "entity", "tmp", "TABLE", "buffer", "address", "f", "tr", "source", "array", "point", "model", "master", "part", "parent", "cache", "list", "see", "code", "database", "state", "store", "how", "col", "tree", "tab", "normal", "row", "machine", "v", "port", "transform"], "handler": ["callback", "target", "name", "api", "slice", "type", "processor", "inner", "file", "pattern", "f", "location", "uri", "definition", "object", "reader", "package", "loader", "message", "widget", "hand", "rule", "player", "h", "filter", "channel", "position", "change", "handled", "magic", "based", "layer", "address", "path", "parse", "Handler", "or", "management", "code", "handle", "machine", "driver", "worker", "control", "controller", "connection", "hook", "patch", "cher", "lib", "password", "plugin", "cookie", "child", "fd", "menu", "host", "model", "manager", "delay", "wrapper", "item", "route", "format", "end", "field", "error", "queue", "server", "command", "event", "function", "client", "service", "response", "man", "ctx", "pointer", "phase", "master", "writer", "parent", "ph", "parser"], "p": ["pc", "np", "d", "api", "type", "pr", "dp", "per", "ip", "s", "f", "Q", "lp", "pe", "b", "v", "k", "vp", "h", "r", "u", "sp", "ap", "t", "wp", "w", "code", "http", "pre", "ps", "P", "n", "jp", "c", "all", "g", "pp", "qa", "_", "python", "bp", "post", "cp", "x", "py", "func", "y", "php", "j", "proc", "e", "tp", "op", "pa", "l", "m", "i", "o", "user", "po"], "q": ["form", "y", "k", "sq", "queue", "text", "d", "str", "question", "eq", "iq", "h", "dq", "qi", "r", "patch", "query", "ch", "u", "request", "id", "ip", "qu", "c", "m", "v", "t", "sh", "quant", "g", "f", "check", "qa", "Q", "quest", "req", "i", "w", "o", "qq", "x", "z", "qt", "b", "complex", "qs"], "opc1": ["opk2", "opdc1", " opc0", "hopc3", "ipc5", "optf1", "hopc2", "opdc3", "opdc0", "opppc0", "opcu81", "opf4", "opsc3", " oprc1", "opn2", "hoplc1", "opcuOne", " oplcOne", "opsc2", "operf3", " oplc1", "opf1", "opc81", "optrc4", "optc1", "opk5", "oppc5", "opn4", "opppc5", "opf0", "oprc0", " opc4", "optlc4", "opcu9", "hopc4", "opn1", "operf2", "hopsc3", "ipc3", "opf5", "opcu71", "oppc1", "hoplc2", "oplc2", "oplc9", "oplc71", "opcu2", "opf3", "ipc2", "ipf2", "oppc4", "optrc0", "ipc1", " opc9", "oppc0", "oplc4", "operf1", "operc11", "hoplc3", "optc0", "opcu3", "hopsc2", "opc4", "optf0", "optlc3", " oplc71", "opcOne", "optc3", "optlc2", "optc5", "opac2", "oplc1", "opdc5", " opc71", "optc4", "opdc2", "operc3", "opcu0", "operc1", "oppc9", "optc2", " oprc0", "ipf5", "opc5", "opppc4", "opc71", "oppcOne", "hopc81", "optf5", "operf11", "opf81", "opn3", "opac5", "oppc71", "opppc1", "optrc1", "oplc3", "opsc81", "opf11", "oprc1", "opf2", "opac81", "optrc3", " oprc2", "oplc0", "hopsc81", "ipf3", "opsc1", "opac1", " opc81", "opsc11", "opac4", "opc11", "oprc5", "hopsc1", "oprc2", " oplc9", "ipf1", "operc2", "optf3", "opk1", "oprc3", "opac3", " opcOne", "oprc4", "opc0", "oplcOne", "opac11", "oprc81", "opcu5", "opdc4", "opc9", "opcu1", "opk3", " oprc81", "opdc81", "oplc5", "optlc1", "hoplc4", "hopc1"], "opc2": ["opdc1", "opdc22", "optf1", "hoprc22", "hopc2", "opcr2", "opdc3", "opl2", "opf4", "opsc4", "opsc3", " opc6", "opl4", "opn2", "opsc2", "opercr02", "opf1", "opcrSecond", "oprcTwo", "opvc4", "operc02", "ipfTwo", "optrc4", "optc1", "operdc2", "opf6", "opn4", "copc5", " opcSecond", " opc4", "opcTwo", " opc22", "hoprc4", "opf22", "oprc9", "hopc4", " opcTwo", "opvc9", " oprcSecond", "opn1", "coplc3", "opc6", "oplcTwo", "opcr22", "opercr2", "opci2", "opercr4", "opcr02", "copac4", "opl12", "opvc1", "oplc2", "opcr4", "coplc1", "oplc9", "copac10", "opf3", "opf32", "oprc12", "ipc2", "ipf2", "opnTwo", "ipc1", "operdc12", " oprcTwo", "opc10", "oplc4", "coplc9", "opl5", "operdc1", "opc4", "optf2", "copac5", "ipf4", "oprc32", "hoprc2", "optc3", "copac2", "opdc32", " oplc3", "optc5", "opac2", "oplc1", "opdc5", "oprc22", "optc4", "opdc2", " oprc22", "operc3", "hopc22", "operc1", "opac10", "copc4", "optc2", "operc12", "opdc12", "opc22", "oplc6", "opc5", "opac02", "operc4", "copc2", "opercr12", "opdc10", "opsc5", "opci6", "opcr12", "ipc4", "opac12", "opac5", "optc6", "oplc3", "hopc32", "opf2", "oprc1", "opci1", "opl02", "optrc3", " oprc2", "optf6", "operdc3", "copc9", "opac1", "opac4", "ipcTwo", "opfSecond", "oprc6", "oprc5", "copc1", "oprc2", "optrc5", "oplc12", "opci3", "ipf1", "copc3", "operc2", "opvc2", "opcSecond", "optf3", "oprc3", "opac3", "opcrTwo", "oprc4", "optrc2", "copc10", "coplc4", "opl10", "opc32", "opc02", "hoprc32", " oplc2", "opdc4", " oplc6", "opc9", "coplc2", " oplc4", "oplc5", "oprcSecond", "opfTwo", "opc12"], "opc3": ["oprc53", "opc03", "copl3", "OPc6", "opk2", "opdc1", "uppc03", "hopc3", "opdc3", "expc13", "opsc4", "opsc3", "expc3", "uppc48", "opk15", "opf4", "opl4", "opl1", "opsc2", "copc8", " oplc1", "opsc03", " opl53", "opcache4", " opc30", "opf48", "copf53", " opl4", "opk5", "optrc4", "oppcThird", "opsc7", "opf6", "exppcThird", "OPlc6", "hopf3", "copc5", "expc03", "oppc3", "opcacheThird", "opc15", "opct39", "oprc0", " opc4", "operk0", "oplc7", "opersc2", "oprc03", "hopc4", "uppcin03", "opscThird", "opc8", "exppc3", "hopc5", "opct3", "copf03", "opc6", "uppc3", "copf39", "oplc03", "uppcin48", "operc7", "opct03", "opdc39", "opf5", "opf7", " oplc30", " opl3", "opf39", "oplc2", "opf3", " opc15", "OPlc2", "oppc13", "oprcThird", "opl3", "OPc4", "uppcin2", "oplc4", "optcThird", "opl5", "opc4", "oprc13", "opdc8", "opk53", "copc53", "optc3", "opcThird", "copl8", "opf03", "opersc3", "OPc3", " oplc3", " opl03", "opersc6", "copf3", "opsc0", "copc39", "operk3", "oplc1", "oplc30", " oplc15", "opdc5", "oplcThird", "optc4", "operc0", "oplc8", "opl03", "operc3", "opc48", "opcache3", "optc2", " opc53", "operc6", "opc39", "oplc6", "opc5", " opc03", "exppc13", "oppc03", "opsc5", "opc7", "oplc15", "opdc53", "OPlc3", "opc13", "opcin03", "uppc2", "opk0", "hopc53", "operk5", "oplc3", "exppc03", "oplc53", "operk2", "copl5", "opcin48", "opk4", "hopf4", "oprc1", "opf2", "optrc3", "opdc03", "opk30", "expcThird", "opl53", "oprc6", "copc03", "oprc5", "copc1", "oprc2", "opcin3", "copl1", "oprc30", "copc3", "operc2", "opk1", "oprc3", "opct53", "opc53", "oprc15", "opc30", "oprc4", "opsc6", "optrc2", "opc0", "uppcin3", "OPc2", "optrcThird", "opsc13", "hopf53", "opersc7", "opcin2", "opk3", "opl8", "opcache2", "oplc5", "opf53", "oprc48", "opsc53", "OPlc4", "hopf5", "operc5"]}}
{"project": "FFmpeg", "commit_id": "bf2cba453244a74331238a472fe0e309f116f4d9", "target": 1, "func": "yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        int A1, A2;\n\n        const void *r =  c->table_rV[V],\n\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n\n                   *b =  c->table_bU[U];\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n\n        }\n\n\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                      r, g, b, y, target, hasAlpha);\n\n    }\n\n}\n", "idx": 7885, "substitutes": {"buf0": ["buff00", " buf00", "buffer50", "uf1", "buf3", "buf50", " buf3", " buf50", "buff0", "buffer0", "buf00", "uf50", "uf0", "uf3", "uf00", "buff3", "buffer1", "buff50", "buff1"], "buf1": ["buffOne", "bufferOne", "buf3", "uf1", "bufferone", "buf2", " bufOne", " buf3", "queue1", "buff0", "aux2", "buff2", "bufone", "bufOne", "auxOne", "ufOne", " buf2", "uf0", "uf3", "buff3", "queueone", "queue3", "buffer1", "buffer3", "buffone", "aux1", "queueOne", "buff1"], "ubuf0": ["abuf10", "ubbuf10", "ubbuff1", "ubbuf00", "abuff1", "ubimg25", "ubuf2", "ubbuf0", "ubimg2", "ubbuff0", "ubbuff25", "abuff00", "abbuff25", "abbuff0", "ubbuff2", "ubuf10", "ubimg0", "abuf2", "ubuff0", "ubuf25", "abuff10", "ubuf00", "ubuff10", "ubbuf2", "ubimg1", "ubuff00", "ubbuf1", "ubbuf25", "abuff0", "abuf00", "ubbuff00", "ubuff1", "abuf25", "ubbuff10", "abbuff2", "abbuff1"], "ubuf1": ["abbuf1", "ubf101", "ubbuff1", "ubuf01", "rubef101", "abbuf0", "ubbf1", "ubuf101", "ubum0", "ubuf2", "ubbuf0", "rubuf101", "abbuf01", "ubbuff0", "ubbuff2", "ubum1", "ubbf101", "rubuf1", "abuf01", "ubbf01", "ubef101", "ubf1", "ubbuf01", "ubef1", "abuf2", "rubuf01", "ubbuff01", "abbuf2", "ubbuf2", "ubum2", "ubbuf1", "ubef01", "ubf01", "rubef01", "ubum01", "rubef1"], "vbuf0": ["vbuffer2", "vbuff1", "vuf1", "lbufeu", "lbufee", "vbuffio", "lbuffio", "luf1", "vbuff2", "vbuffer1", "lbuf8", "vbufee", "vbuffee", "lbuffee", "vvecio", "vbufio", "vbuffeu", "luf8", "lbuf0", "vfamio", "vbuffer0", "vbufeu", "vfameu", "lbuffeu", "lbuff0", "luf0", "luf2", "vbuff8", "vuf0", "vfam0", "vfamee", "vbuf8", "vbuffer8", "vvecee", "vbuf2", "vuf8", "vbuff0", "vvec0", "vuf2", "vveceu", "lbuf2", "lbufio", "lbuf1"], "vbuf1": ["vbufOne", "vbuff1", "vbuffer2", "vuf1", "vufOne", "hbufOne", "vconfig1", "hbuf2", "vbuff2", "hbuf1", "vbuffer1", "hbuff1", "hbuff2", "vbuffer0", "ubufOne", "vbuffOne", "ubuffOne", "vuf0", "hbuff0", "hbuf0", "vbuf2", "hbuffOne", "vbufferOne", "vconfigOne", "vbuff0", "vuf2", "ubuff1"], "abuf0": ["abbuf1", "absuff00", "abuc2", "abimg8", "absbuff1", "absuff0", "abimg0", "absuff1", "absuf00", "abbuf8", "abuc1", "abbuf0", "abuff1", "bbuf1", "absuf0", "buf2", "abuff4", "absuf2", "absbuff2", "abuff00", "abbuff0", "bbuf0", "abbuff4", "absbuff8", "abbuf00", "bbuf2", "abuc0", "abuff2", "abbuff8", "absuf8", "abuf2", "absuff2", "abbuf2", "buf4", "bbuf4", "absuf1", "abuf8", "abimg1", "abuc00", "abimg2", "absbuff0", "abuff0", "abuf00", "abbuf4", "abuf4", "abbuff2", "abbuff1"], "abuf1": ["abef1", "abcf0", "abbuf1", "abbufOne", "abcf1", "fabufOne", "ubbuff1", "fabuf01", "abef3", "abuc1", "fabbuf0", "abbuf0", "abuff1", "abbuff1", "tabuc3", "abuffOne", "ubuf2", "abbuf01", "ubbuff11", "ubbuff0", "abuf3", "abbuff0", "ubbuff2", "fabuf0", "abefOne", "abuc3", "abuu1", "abef0", "abucOne", "abuf01", "tabuc0", "abuc0", "abuu2", "abuf2", "abbuf11", "fabuf1", "ubuf11", "abbuf2", "abuu0", "tabuf3", "abcf01", "tabufOne", "abbuf3", "tabucOne", "abuf11", "fabbuf1", "fabbuf01", "tabuc1", "abuff01", "tabuf1", "abuff0", "tabuf0", "fabbufOne", "abuu11", "abcfOne", "abufOne", "abbuff2", "abbuff11"], "i": ["bi", "index", "pi", "d", "multi", "ti", "api", "slice", "qi", "id", "ip", "f", "zi", "my", "mu", "uri", "in", "v", "li", "ui", "k", "ie", "mini", "key", "\u0438", "cli", "ii", "u", "ind", "t", "ix", "page", "start", "a", "ini", "isi", "iu", "ai", "uli", "p", "mi", "ij", "n", "c", "oi", "io", "it", "gi", "I", "x", "si", "y", "j", "di", "e", "fi", "yi", "idi", "is", "phi", "anti", "chi", "l", "ni", "ami", "m", "ri", "info", "iv", "err", "xi", "ci", "eni", "z"], "A1": ["a2", "AAone", " A001", "AA001", "AAOne", "AA1", "aOne", "a001", " A4", "A001", "AOne", "a1", "Aone", " AOne", "AA2", " Aone", "AA4", "YOne", "Y1", "A4", "Yone", "Y4"], "A2": ["APIsecond", "AUTwo", "a2", "atwo", "AASecond", "AUSecond", "AU2", "APITwo", "LA2", "API2", "AUsecond", "AATwo", "LAtwo", "Asecond", " Atwo", "Atwo", "AAsecond", "AA2", "ATwo", "a0", "APISecond", "LA0", "A0", "ASecond", " A0"], "r": ["ru", "br", "rc", "re", "k", "e", "d", "er", "p", "rg", "h", "n", "l", "m", "sr", "t", "f", "R", "o", "w", "rb", "z", "rl", "q", "rs"], "g": ["y", "k", "gb", "e", "d", "p", "h", "gs", "u", "n", "l", "go", "s", "m", "c", "t", "gl", "f", "group", "w", "ga", "z", "ac", "G", "q", "v", "x"], "b": ["y", "k", "B", "e", "d", "sb", "p", "h", "u", "n", "l", "s", "ob", "t", "boot", "f", "ib", "be", "a", "w", "o", "z", "rb", "v", "x"]}}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n", "idx": 7892, "substitutes": {"s": ["sq", "gb", "e", "d", "parts", "sb", "self", "p", "sync", "spec", "ls", "session", "S", "h", "client", "sc", "ses", "site", "cs", "gs", "sets", "service", "sf", "xs", "ds", "u", "stats", "n", "l", "ops", "ss", "c", "sg", "ts", "services", "t", "m", "v", "sym", "rs", "g", "ns", "f", "space", "sup", "us", "a", "ssl", "settings", "i", "o", "sv", "js", "sk", "es", "b", "com", "same", "http", "os", "conf", "qs", "south", "si"], "slice_x": ["slice08y", "slice_z", " slice_z", "slice08u", "sliceameex", "slice11x", " slice_d", "sliceIdy", "slice08fx", "sliceIDx", "slice_fx", "sliceamed", " slice_xs", "sliceamex", "sliceingy", "sliceIDfx", " slice_fx", "slice6xs", "slice11y", "sliceingx", "slice_ey", "slice_xs", "sliceIdd", " slice_xy", "slice_xp", "sliceIdex", "slice6x", "sliceingz", " slice_ex", " slice_u", "sliceIDu", "sliceingxp", "slice_d", " slice_xp", "slice_ex", "sliceIdx", "slice6y", "sliceamey", " slice_ey", "slice_u", "sliceIDy", "slice11ey", "slice6ey", "slice08x", "slice11xy", "slice_xy"], "slice_y": ["slice08y", "slice_sy", "slice_z", "scale_asy", " slice_z", "slice_ya", "slice_wy", "sliceJy", "player_y", "player08y", "sliceIdy", "scale_n", "scale_x", "slice08sy", " slice_ya", "slice_ye", "player_wy", " slice_vy", " slice_ye", "slice_asy", "sliceDn", "slice08wy", "player08ny", "player_sy", "scale_y", "player_ny", "sliceDasy", "slicePy", "slicePny", "sliceJya", "player08sy", "sliceIdady", " slice_ny", "slice_n", " slice_ady", "slice_vy", "slice08ny", "slicePwy", "sliceJady", "sliceDx", "sliceIdny", "sliceIdya", "player08wy", "sliceJny", "slice_ady", "slicePsy", "sliceDy", "slice_ny"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n", "idx": 7893, "substitutes": {"opaque": ["ospaques", "octacity", "opsaque", "openec", "openaques", "opacity", "opsacity", "octaque", "paque", "openaque", "opaques", "opsec", "ospula", "openacity", " opec", "ospacity", "ospaque", "opsaques", "pula", "opula", " opacity", "octula", "paques", "pacity", " opaques", "octaques", "opec"], "data": ["new", "layout", "ada", "da", "reader", "DATA", "result", "input", "handler", "Data", "exec", "open", "event", "ata", "api", "client", "image", "config", "empty", "change", "inner", "this", "cookie", "init", "entry", "alpha", "buffer", "next", "draw", "start", "a", "writer", "cache", "info", "ad", "media", "o", "code", "valid", "missing", "aa", "parser", "window", "dat"]}}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 7916, "substitutes": {"opaque": ["opbuffer", "compaco", "oacity", "obaque", "opga", "uppacity", "oppaque", "compaque", "opaco", "iopaques", "uppaque", "operaques", " opacle", "opaca", "uppaques", "ipaco", "compacity", "spac", "Opga", " opaca", "opacity", "opplane", "iopca", " opac", "ipsec", "opac", "ipsca", "paque", "oaque", "opaques", "compbuffer", " opya", "ipsaques", "operaque", "opya", "splane", "Opaque", "operacle", "Opya", "obaques", "obuffer", " oplane", "iopaque", "operacity", "ipaque", "ipsaque", "spaca", "obec", " opacity", "uppacle", "opacle", "oaco", "iopec", " opga", "pacity", "obca", "opca", "oppaca", " opaques", "ipacity", "oplane", "oppac", "pga", "spaque", "Opacity", "opec", "ipbuffer", "pya"], "ret": ["pat", "let", "re", "rc", "ref", "def", "mt", "result", "fun", "success", "alt", "att", "back", "get", "len", " RET", " Ret", "val", "nil", "mem", "gc", "no", "bit", "seq", "num", "RET", "reg", "res", "ut", "rot", "lit", "cat", "part", "feat", "gt", "det", "ft", "match", "reply", "nt", "job", "rt", "valid", "desc", "arg", "sat", "red", "prot", "rets", "final", "Ret", "hard"], "acb": ["ecgb", "ocway", "ecbf", "Acb", "ecmb", " acbase", "agb", "ocl", "acll", "akb", " acurl", "aclrb", "ACbb", "acl", "Acba", "ackbd", "acway", "accbf", "ancsb", "maca", "ocfb", "icb", "acsbb", "icf", "acbc", "ACba", "macbd", "agbase", "accl", " acrb", "aclxb", "acmb", "aclf", " acgb", "acxb", "accbb", "accfb", "akbb", "acbr", "axbar", "accbar", " acfb", "icbf", "acbd", "ucf", "agl", "acbase", " acf", "ecl", "maclb", "accB", "ACsb", "ocxb", "ackb", "ecwb", "AcB", "aclb", "agbf", "ACl", " acl", "ocb", "aksb", "acclb", "agbb", "accbase", "ucgb", "aclurl", "ecfb", "icurl", "ucb", "accf", "acbf", "acgb", "macb", "ACb", "ancbb", " acbb", "macway", "ucbb", "ocba", "akfb", "ucbf", "accba", "accsb", "acwb", "ancbot", "acfb", "akba", "ancb", "aclbc", "ackfb", "ecsb", " aca", "aclfb", "ecf", "acsbot", "acllb", " acsb", "acssb", "acbb", "acbot", " aclb", "acbar", "icbb", " acwb", "iclb", "agf", "macf", "axb", "acca", "akemb", "accemb", "acsb", "ecbd", "axbb", "akrb", "aca", "ocsb", "ecb", "accwb", "ACbot", "aclob", "akl", "accrb", "ocbase", "accb", "Acsb", "axf", "ecrb", "ackmb", "acurl", "ocob", "aclbf", "ACB", "accbr", "akbr", "agbc", "acba", "aclway", "macsb", "accgb", "ocf", "ucfb", "acf", "ancob", "icbc", "aclemb", "aclbb", "macfb", "acob", "macmb", "macbb", "acB", "ancxb", "ecbb", "ecbr", "icl", "akf", "acemb", " acbar", "aclbase", "ocbb", "akgb", "acrb"], "bs": ["bi", "iss", "pb", "wb", "lb", "gb", "ab", "db", "sb", "bid", "sys", "bos", "bm", "blocks", "BS", "bl", "ls", "aos", "buf", "Bs", "ses", "account", "cs", "bb", "bytes", "ds", "ubs", "fb", "bo", "abc", "ob", "ops", "ss", "bes", "ba", "obs", "bc", "fs", "ns", "platform", "as", "bis", "eb", "ec", "acks", "bal", "bh", "bits", "rb", "b", "cas", "cb", "os", "bas", "las", "base"], "s": ["new", "sq", "si", "parts", "e", "d", "sb", "multi", "server", "sys", "p", "sync", "details", "self", "args", "ls", "session", "S", "params", "is", "ps", "sc", "full", "ses", "cs", "gs", "sets", "service", "sf", "ds", "stat", "r", "stats", "n", "l", "states", "ss", "c", "sg", "sym", "services", "t", "ts", "m", "g", "f", "ns", "sa", "bis", "a", "ssl", "settings", "i", "sl", "secondary", "o", "sub", "state", "js", "b", "http", "os", "blocks", "v", "rs", "spec"], "index_in_cluster": ["index_in_scloser", "index_in_chica", "index_in_Clorer", "index_in_CLuster", "index_in_Closion", "index_in_CLusters", "index_in_Closer", "index_in_Cluster", "index_in_cedrome", "index_in_bluster", "index_in_sclica", "index_in_exploser", "index_in_chusters", "index_in_chuster", "index_in_choser", "index_in_clica", "index_in_closer", "index_in_sclusters", "index_in_CLrome", "index_in_clorer", "index_in_scuster", "index_in_clrome", "index_in_blusters", "index_in_ceduster", "index_in_scluster", "index_in_cedusters", "index_in_closion", "index_in_scusters", "index_in_bloser", "index_in_explusters", "index_in_clusters", "index_in_blosion", "index_in_Clrome", "index_in_Clica", "index_in_explosion", "index_in_Clusters", "index_in_CLorer", "index_in_expluster", "index_in_scorer"], "cluster_offset": ["cluster\u00b7num", "cluster_width", "cluster\u00b7offset", "clusterfoffset", "clusterFsize", "clusterfdata", "clust2position", "cluster_data", "cluster_size", "claco_offset", "clacofend", "clusters_location", "cluster\u00b7location", "clust2offset", "cliskFsize", "clust_data", "cluster2offset", "cliskFset", "clacofdata", "clust_limit", "clacofrot", "clusters_num", "cluster_rot", "cliskFoffset", "cluster_num", "cliskFwidth", "cluster_len", "cluster\u00b7len", "cluster_position", "clisk_size", "clusterFwidth", "clisk_width", "clust2limit", "claco_rot", "clusters_len", "clust_offset", "clusterFoffset", "clacofoffset", "clusters_offset", "claco_data", "claco_end", "clusterfrot", "clust2data", "clust_position", "cluster_limit", "clisk_set", "cluster_end", "cluster2limit", "clisk_offset", "cluster2position", "clusterFset", "clusterfend", "cluster_set", "cluster2data", "cluster_location"], "src_buf": [" src_buff", " src_buffer", " src_mem", "src_buff", "src2buffer", "src2mem", "src2buff", "src_mem", "src2buf", "src_buffer"], "n_end": [" n_open", "num_post", "nJEND", "n00enter", "rn__ended", "n64start", "num00set", "n_ends", "num_end", "num00end", "nworkpost", "numworkend", "numworkended", "rn_open", "rn__open", "n__ended", "n67end", "n_set", "n64post", "nJend", "numworkpost", " n_ends", "n64end", "nworkend", "rn_start", "rn_ended", "num_ended", "num00enter", "nJset", "n_open", "num_enter", "numworkstart", "n00end", "n00set", "n_dev", "num_END", "n_ended", "n67ended", "n00open", "n_post", "n00END", "n_start", "n__open", "num_start", "nJenter", "n_enter", "nworkended", " n_ending", "num_set", "rn__start", " n_dev", "rn_end", "rn__end", "nworkstart", "num00END", "n_END", " n_END", "n67start", "n64ended", "n_ending", "n67open", "n__end", "n00ending", "n__start"]}}
{"project": "FFmpeg", "commit_id": "08d2cee49c323715b66df0e4ff45ec0e07aaea7b", "target": 0, "func": "static int opt_input_file(const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret, rfps, rfps_base;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (last_asked_format) {\n\n        if (!(file_iformat = av_find_input_format(last_asked_format))) {\n\n            fprintf(stderr, \"Unknown input format: '%s'\\n\", last_asked_format);\n\n            ffmpeg_exit(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        ffmpeg_exit(1);\n\n    }\n\n    if (audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_sample_rate);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_channels);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (frame_rate.num) {\n\n        snprintf(buf, sizeof(buf), \"%d/%d\", frame_rate.num, frame_rate.den);\n\n        av_dict_set(&format_opts, \"framerate\", buf, 0);\n\n    }\n\n    if (frame_width && frame_height) {\n\n        snprintf(buf, sizeof(buf), \"%dx%d\", frame_width, frame_height);\n\n        av_dict_set(&format_opts, \"video_size\", buf, 0);\n\n    }\n\n    if (frame_pix_fmt != PIX_FMT_NONE)\n\n        av_dict_set(&format_opts, \"pixel_format\", av_get_pix_fmt_name(frame_pix_fmt), 0);\n\n\n\n    ic->video_codec_id   =\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);\n\n    ic->audio_codec_id   =\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);\n\n    ic->subtitle_codec_id=\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* open the input file with generic libav function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        ffmpeg_exit(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    if(opt_programid) {\n\n        int i, j;\n\n        int found=0;\n\n        for(i=0; i<ic->nb_streams; i++){\n\n            ic->streams[i]->discard= AVDISCARD_ALL;\n\n        }\n\n        for(i=0; i<ic->nb_programs; i++){\n\n            AVProgram *p= ic->programs[i];\n\n            if(p->id != opt_programid){\n\n                p->discard = AVDISCARD_ALL;\n\n            }else{\n\n                found=1;\n\n                for(j=0; j<p->nb_stream_indexes; j++){\n\n                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n\n                }\n\n            }\n\n        }\n\n        if(!found){\n\n            fprintf(stderr, \"Specified program id not found\\n\");\n\n            ffmpeg_exit(1);\n\n        }\n\n        opt_programid=0;\n\n    }\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0 && verbose >= 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    timestamp = start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n        /* reset seek info */\n\n        start_time = 0;\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st = ic->streams[i];\n\n        AVCodecContext *dec = st->codec;\n\n        InputStream *ist;\n\n\n\n        dec->thread_count = thread_count;\n\n\n\n        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);\n\n        ist = &input_streams[nb_input_streams - 1];\n\n        ist->st = st;\n\n        ist->file_index = nb_input_files;\n\n        ist->discard = 1;\n\n        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);\n\n\n\n        if (i < nb_ts_scale)\n\n            ist->ts_scale = ts_scale[i];\n\n\n\n        switch (dec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(audio_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ist->dec= avcodec_find_decoder_by_name(video_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            rfps      = ic->streams[i]->r_frame_rate.num;\n\n            rfps_base = ic->streams[i]->r_frame_rate.den;\n\n            if (dec->lowres) {\n\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n\n            }\n\n            if(me_threshold)\n\n                dec->debug |= FF_DEBUG_MV;\n\n\n\n            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n\n\n\n                if (verbose >= 0)\n\n                    fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\",\n\n                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n\n\n\n                    (float)rfps / rfps_base, rfps, rfps_base);\n\n            }\n\n\n\n            if(video_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            else if(video_discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n\n\n    top_field_first = -1;\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_pix_fmt = PIX_FMT_NONE;\n\n    frame_height = 0;\n\n    frame_width  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    av_freep(&ts_scale);\n\n    nb_ts_scale = 0;\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n    uninit_opts();\n\n    init_opts();\n\n    return 0;\n\n}\n", "idx": 7925, "substitutes": {"opt": ["options", "ext", "fn", "wav", "Opt", "url", "text", "loc", "open", "command", "op", "oc", "expr", "config", "cmd", "option", "obj", "temp", "path", "prop", "cat", "feat", "alloc", "prefix", "attr", "timeout", "term"], "filename": ["jpg", "msg", "ename", "fn", "wav", "phrase", "url", "Filename", "lua", "name", "fax", "println", "binary", "document", "nil", "mpeg", "src", "blast", "whatever", "png", "download", "username", "nuclear", "login", "microsoft", "config", "sf", "password", "abl", "file", "files", "txt", "fd", "fil", "tmp", "kl", "addin", "il", "f", "path", "source", "description", "location", "provided", "json", "kn", "prefix", "utf", "python", "sheet", "uri", "length", "subject", "dll", "href", "fp", "title", "method", "output", "directory", "format"], "ic": ["pc", "CI", "ici", "aci", "au", "icing", "ik", "ican", "isc", "iac", "fi", "cc", "oc", "lic", "xc", "inc", "ct", "cm", "nic", "voc", "cit", "abc", "c", "icer", "aic", "bc", "pic", "ig", "IC", "mc", "ec", "cu", "fc", "mic", "ci", "lc", "icc", "ac", "ics", "vc", "ai"], "file_iformat": ["file_iplart", "file_iformac", "file_iplat", "file_iolt", "file_ionicac", "file_iolat", "file_icolt", "file_ionicar", "file_ilac", "file_iolart", "file_ilt", "file_ilart", "file_icolac", "file_iplac", "file_iformar", "file_ilat", "file_iformt", "file_ionict", "file_icolar", "file_iformart", "file_iolac", "file_iolar", "file_ionicat", "file_iplt", "file_icolat"], "err": ["header", "reader", "proc", "progress", "error", "loc", "e", " error", "er", "str", "seq", "r", "out", "resp", "rr", "var", "all", "req", "info", "ver", "attr", "iter", "ptr", "ln", "output", "stat"], "i": ["ui", "pi", "cli", "ati", "h", "ii", "ind", "id", "n", "ni", "ip", "abi", "c", "init", "t", "f", "io", "ir", "ini", "info", "it", "b", "attr", "iu", "I", "ai"], "ret": ["rc", "progress", "result", "alt", "back", "len", "exec", "val", "fi", "mem", "gc", "out", "res", "temp", "aux", "buffer", "ib", "info", "nt", "timeout", "cb", "status", "q", "I", "rs", "rt"], "rfps": ["nframes", "rdframes", "nbps", "rdbps", "rframes", "rbits", "Rframes", "rbps", "nbits", "Rbits", "rdfps", "Rfps", "rdbits", "Rbps", "nfps"], "rfps_base": ["rfps_buffer", "rfps6buffer", "rips_length", "rips_buffer", "rfps_length", "rips_bit", "rfps6bit", "rfps6length", "rips_base", "rfps_bit", "rfps6base"], "timestamp": ["timeline", "stimest", "timeend", "imend", "imest", "timest", "imeline", "timeeline", "stimeline", "stimestamp", "imestamp", "timeestamp", "timend", "timeest", "stimend"], "buf": ["br", "header", "conv", "result", "text", "bf", "Buffer", "pad", "img", "cmd", "file", "buff", "aux", "grab", "bc", "Buff", "pkg", "cap", "bd", "b", "fp", "output", "batch", "context", "pb", "bn", "bus", "ab", "db", "box", "bb", "config", "fam", "raf", "cat", "cv", "uf", "rb", "cb", "font", "doc", "pool", "uc", "rc", "bag", "raw", "mem", "vec", "bo", "block", "fd", "tmp", "prop", "prof", "feat", "alloc", "comb", "bh", "bed", "window", "extra", "wb", "func", "wav", "lb", "proc", "queue", "loc", "src", "seq", "auc", "ux", "usr", "fb", "ctx", "bg", "buffer", "fab", "la", "ff", "desc", "bt", "port"], "opts": ["optes", "operns", "optiontes", " opttes", "opters", " optns", "optionns", "optionts", "opertes", "opns", "operts", "optionters", "operters", " optts", " optters"], "orig_nb_streams": [" orig_nb_inputed", " orig_nb_inputd", " orig_nb_rawpoints", " orig_nb_streampoints", " orig_nb_rawd", " orig_nb_streamed", " orig_nb_threadpoints", " orig_nb_inputs", " orig_nb_streamd", " orig_nb_inputpoints", " orig_nb_rawed", " orig_nb_threadd", " orig_nb_raws", " orig_nb_threads", " orig_nb_threaded"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        return ret;\n\n    }\n\n\n\n    switch(request) {\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == 0 && index != 0x81) { /* clear ep halt */\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceRequest | USB_REQ_GET_INTERFACE:\n\n        data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\n        ret = 0;\n\n        break;\n\n        /* usb specific requests */\n\n    case GetHubStatus:\n\n        data[0] = 0;\n\n        data[1] = 0;\n\n        data[2] = 0;\n\n        data[3] = 0;\n\n        ret = 4;\n\n        break;\n\n    case GetPortStatus:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            data[0] = port->wPortStatus;\n\n            data[1] = port->wPortStatus >> 8;\n\n            data[2] = port->wPortChange;\n\n            data[3] = port->wPortChange >> 8;\n\n            ret = 4;\n\n        }\n\n        break;\n\n    case SetHubFeature:\n\n    case ClearHubFeature:\n\n        if (value == 0 || value == 1) {\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case SetPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            USBDevice *dev;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            dev = port->port.dev;\n\n            switch(value) {\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus |= PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_RESET:\n\n                if (dev) {\n\n                    usb_send_msg(dev, USB_MSG_RESET);\n\n                    port->wPortChange |= PORT_STAT_C_RESET;\n\n                    /* set enable bit */\n\n                    port->wPortStatus |= PORT_STAT_ENABLE;\n\n                }\n\n                break;\n\n            case PORT_POWER:\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case ClearPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            switch(value) {\n\n            case PORT_ENABLE:\n\n                port->wPortStatus &= ~PORT_STAT_ENABLE;\n\n                break;\n\n            case PORT_C_ENABLE:\n\n                port->wPortChange &= ~PORT_STAT_C_ENABLE;\n\n                break;\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus &= ~PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_C_SUSPEND:\n\n                port->wPortChange &= ~PORT_STAT_C_SUSPEND;\n\n                break;\n\n            case PORT_C_CONNECTION:\n\n                port->wPortChange &= ~PORT_STAT_C_CONNECTION;\n\n                break;\n\n            case PORT_C_OVERCURRENT:\n\n                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;\n\n                break;\n\n            case PORT_C_RESET:\n\n                port->wPortChange &= ~PORT_STAT_C_RESET;\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case GetHubDescriptor:\n\n        {\n\n            unsigned int n, limit, var_hub_size = 0;\n\n            memcpy(data, qemu_hub_hub_descriptor,\n\n                   sizeof(qemu_hub_hub_descriptor));\n\n            data[2] = NUM_PORTS;\n\n\n\n            /* fill DeviceRemovable bits */\n\n            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;\n\n            for (n = 7; n < limit; n++) {\n\n                data[n] = 0x00;\n\n                var_hub_size++;\n\n            }\n\n\n\n            /* fill PortPwrCtrlMask bits */\n\n            limit = limit + ((NUM_PORTS + 7) / 8);\n\n            for (;n < limit; n++) {\n\n                data[n] = 0xff;\n\n                var_hub_size++;\n\n            }\n\n\n\n            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;\n\n            data[0] = ret;\n\n            break;\n\n        }\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7936, "substitutes": {"dev": ["br", "Dev", "dn", "dist", "od", "d", "debug", "mid", "api", "pad", "die", "device", "off", "temp", "engine", "hw", "ver", "pu", "normal", "conf", "private", "bus", "diff", "DEV", "app", "test", "bug", " device", "reg", "mod", "w", "valid", "driver", "pub", "rad", "de", "dom", "connection", "conn", "prom", "plug", "block", "var", "home", "comment", "ad", "end", "proc", "def", "di", "development", "error", "ve", "server", "client", "ch", "ev", "pro", "dd", "m", "sh", "serial", "cam", "info", "o", "user", "md", "sd", "pack", "priv", "gu"], "p": ["py", "pb", "pc", "pi", "np", "vp", "e", "d", "tp", "h", "r", "pa", "P", "jp", "ip", "m", "c", "t", "g", "f", "pp", "wp", "i", "o", "w", "pe", "b", "po", "q", "fp", "cp", "v"], "request": ["complete", "re", "header", "frame", "xml", "result", "queue", "input", "param", "name", "message", "key", "raw", "command", "report", "Request", "rf", "rx", "du", "event", "pair", "type", "order", "r", "query", "config", "current", "device", "id", "response", "effect", "mode", "rest", "version", "address", "buffer", "condition", "requ", "array", "attribute", "model", "req", "reference", "time", "direction", "q", "resource", "method", "pull"], "value": ["set", "number", "end", "scale", "result", "name", "input", "view", "message", "show", "key", "val", "server", "write", "event", "command", "none", "search", "type", "expression", "style", "function", "values", "test", "balance", "position", "update", "query", "change", "off", "device", "service", "id", "response", "option", "Value", "content", "VALUE", "version", "mode", "address", "start", "max", "size", "fee", "valid", "null", "feature", "age", "unit", "v", "driver", "format"], "index": ["operation", "pos", "name", "element", "sync", "slice", "type", "num", "column", "id", "connect", "dim", "in", "timeout", "context", "object", "diff", "input", "view", "key", "val", "expression", "test", "offset", "position", "current", "ind", "ion", "alpha", "address", "weight", "path", "start", "network", "part", "ini", "axis", "match", "valid", "shape", "body", "number", "open", "connection", "image", "inc", "tail", "option", "height", "action", "initial", "prefix", "list", "level", "token", "x", "end", "Index", "response", "version", "array", "i", "info", "insert", "node", "update"], "length": ["library", "depth", "end", "number", "section", "loc", "Length", "build", "view", "len", "val", "slice", "type", "offset", "tail", "position", "id", "l", "sequence", "duration", "padding", "part", "info", "size", "level", "shape", "count", "row", "pull"], "data": ["pos", "sum", "keys", "final", "result", "d", "ata", "api", "args", "type", "pad", "device", "id", "ops", "bin", "timeout", "output", "batch", "ui", "new", "object", "DATA", "input", "message", "key", "val", "none", "map", "done", "params", "config", "change", "alpha", "next", "start", "a", "part", "size", "status", "body", "Data", "len", "last", "buf", "style", "image", "block", "ad", "it", "list", "memory", "state", "zero", "resource", "window", "format", "dat", "options", "end", "fail", "di", "error", "na", "response", "actions", "buffer", "wa", "array", "cache", "i", "info", "o", "results", "first"], "s": ["private", "e", "d", "si", "server", "sys", "self", "sync", "session", "S", "h", "is", "ps", "ses", "r", "gs", "cs", "service", "this", "sp", "ds", "stats", "ss", "c", "sg", "m", "services", "t", "fs", "g", "f", "ns", "usb", "sa", "ssl", "i", "sl", "o", "w", "state", "js", "b", "http", "v", "spec"], "ret": ["pat", "let", "re", "rc", "ref", "def", "mt", "result", "success", "fun", "alt", "att", "back", "bf", "error", "len", "val", " Ret", "bad", "arr", "last", "bit", "num", "RET", "full", "resp", "reg", "id", "usr", "res", "obj", "rot", "run", "cur", "fin", "art", "opt", "rev", "lit", "pass", "cat", "fit", "flag", "feat", "gt", "det", "al", "ft", "match", "reply", "nt", "valid", "arg", "status", "count", "rets", "Ret", "rt"], "port": ["pi", "target", "od", "pod", "api", "slice", "pair", "type", "pad", "device", "id", "ip", "contract", "ort", "nat", "table", "ver", "ported", "serv", "v", "proxy", "object", "key", "rule", "app", "test", "tun", "module", "config", "pipe", "plane", "rest", "ion", "t", "address", "mod", "mount", "group", "part", "ports", "project", "match", "select", "machine", "driver", "pool", "component", "import", "document", "export", "connection", "session", "image", "patch", "plugin", "option", "child", "pt", "host", "model", "manager", "state", "post", "cp", "public", "tag", "Port", "pin", "end", "pl", "ve", "server", "report", "pid", "client", "service", "PORT", "class", "m", "source", "point", "parent", "user", "rib", "band"], "n": ["nc", "br", "y", "nn", "k", "fn", "j", "on", "name", "e", "d", "len", "none", "sync", "no", "un", "num", "conn", "r", "ne", "out", "u", "current", "ind", "l", "net", "c", "m", "all", "t", "init", "not", "g", "ns", "f", "nb", "sn", "min", "en", "network", "N", "i", "o", "nt", "z", "b", "node", "in", "ln", "v", "x"]}}
{"project": "FFmpeg", "commit_id": "7684a36113fa12c88ba80b5498f05849a6b58632", "target": 0, "func": "static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st = s->streams[pkt->stream_index];\n\n    MXFStreamContext *sc = st->priv_data;\n\n    MXFIndexEntry ie = {0};\n\n\n\n    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {\n\n        mxf->index_entries = av_realloc(mxf->index_entries,\n\n            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));\n\n        if (!mxf->index_entries) {\n\n            av_log(s, AV_LOG_ERROR, \"could not allocate index entries\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) {\n\n            av_log(s, AV_LOG_ERROR, \"could not get mpeg2 profile and level\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (!mxf->header_written) {\n\n        if (mxf->edit_unit_byte_count) {\n\n            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        } else {\n\n            mxf_write_partition(s, 0, 0, header_open_partition_key, 1);\n\n        }\n\n        mxf->header_written = 1;\n\n    }\n\n\n\n    if (st->index == 0) {\n\n        if (!mxf->edit_unit_byte_count &&\n\n            (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) &&\n\n            !(ie.flags & 0x33)) { // I frame, Gop start\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_partition(s, 1, 2, body_partition_key, 0);\n\n\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        }\n\n\n\n        mxf_write_klv_fill(s);\n\n        mxf_write_system_item(s);\n\n\n\n        if (!mxf->edit_unit_byte_count) {\n\n            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;\n\n            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;\n\n            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;\n\n            mxf->body_offset += KAG_SIZE; // size of system element\n\n        }\n\n        mxf->edit_units_count++;\n\n    } else if (!mxf->edit_unit_byte_count && st->index == 1) {\n\n        mxf->index_entries[mxf->edit_units_count-1].slice_offset =\n\n            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;\n\n    }\n\n\n\n    mxf_write_klv_fill(s);\n\n    avio_write(pb, sc->track_essence_element_key, 16); // write key\n\n    if (s->oformat == &ff_mxf_d10_muxer) {\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            mxf_write_d10_video_packet(s, st, pkt);\n\n        else\n\n            mxf_write_d10_audio_packet(s, st, pkt);\n\n    } else {\n\n        klv_encode_ber4_length(pb, pkt->size); // write length\n\n        avio_write(pb, pkt->data, pkt->size);\n\n        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);\n\n    }\n\n\n\n    avio_flush(pb);\n\n\n\n    return 0;\n\n}\n", "idx": 7967, "substitutes": {"s": ["set", "opens", "d", "sync", "slice", "native", "site", "ops", "sg", "services", "fs", "f", "space", "sv", "b", "conf", "v", "an", "sq", "sb", "plugins", "h", "ses", "cs", "r", "ss", "ts", "t", "ns", "sa", "a", "w", "tests", "less", "es", "http", "status", "storage", "comments", "sys", "self", "p", "ls", "session", "S", "ps", "gs", "sets", "stats", "n", "c", "g", "us", "ssl", "sl", "su", "qs", "rs", "spec", "si", "aws", "e", "server", "details", "client", "is", "support", "service", "ds", "request", "l", "states", "sie", "m", "sym", "bis", "as", "settings", "o", "js", "os", "stat"], "pkt": ["Peth", " pct", "tkt", "tacket", "tkg", " pwk", "Pwk", "facket", "pk", "Pct", "fct", "fk", "spwk", "pwk", "peth", "teth", " pkg", "Pkg", "packet", " packet", "spct", "pkg", " peth", "Pkt", "pct", "fkt", "spacket", "spkt", "Packet", " pk", "Pk"], "mxf": ["Mxe", "gxc", "tmxd", "fmcf", "nxa", " mxd", "pcf", "Mxc", "dcf", "cmxa", "fmxa", "Mxf", "mxd", "cmfc", "pxd", "mffe", "Mcf", "tmxf", "fmxe", "cmxd", "Mffe", "nxd", " mfc", "nfc", "cmcf", "fmxd", "Mxd", "pmxa", "mfc", " mxc", "dxc", "fmxc", "cmxf", "mxb", "mxc", "Mxa", "pmxf", "cmxc", "pmxe", "fmxf", "nxc", "tmcf", "gfc", "tmxe", " mffe", "pmxc", "ncf", "pxc", "dxa", "fmxb", " mcf", "pxe", "Mxb", "gxf", " mxb", "mxa", "gxd", "cmxb", "cmxe", "pxf", "mcf", "Mfc", "cmffe", " mxa", "nxf", " mxe", "mxe", "pxb", "dxf"], "pb": ["ub", "pool", "wb", "pc", "gb", "vp", "db", "ppa", "pg", "sb", "pl", "hub", "typ", "tp", "stab", "mp", "buf", "soc", "pa", "fb", "ctx", "bc", "pm", "summary", "platform", "wp", "cv", "fc", "PB", "lp", "amp", "tc", "uf", "bp", "rb", "cb", "fp", "cp", "cpp", "prot", "utils", "rob"], "st": ["ste", "pc", "sth", "ie", "set", "e", "d", "ast", "sb", "str", "typ", "p", "std", "src", "stab", "style", "ost", "ct", "ace", "td", "service", "sp", "est", "stage", "sts", "c", "rest", "ts", "sh", "t", "step", "pt", "f", "sa", "pp", "nd", "inst", "sn", "start", "se", "sta", "sl", "ft", "fr", "sw", "sd", "sk", "store", "ist", "ST", "si"], "sc": ["sci", "uc", "rc", "pc", "sq", "capt", "cc", "anc", "SC", "src", "cus", "esc", "soc", "cs", "ch", "sp", "ss", "cr", "bc", "sa", "mc", "cl", "osc", "cv", "cer", "ca", "lc", "sw"], "edit_units_count": ["edit_units_sum", "edit_units2code", "edit_unit_total", "edit_units_code", "edit_units_field", "edit_units_content", "edit_units_length", "edit_units2field", "edit_unit_number", "edit_units_part", "edit_unitsdaycount", "edit_unit_content", "edit_unit_code", "edit_unit_count", "edit_units2count", "edit_units2number", "edit_unit_length", "edit_unit_field", "edit_unitsdaycontent", "edit_unit_sum", "edit_units_number", "edit_unitsdaysum", "edit_units_total"]}}
{"project": "qemu", "commit_id": "3ad493fc5ea38c005670adc5933058a28ccabdd4", "target": 0, "func": "int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,\n\n                              int access_type, int mmu_idx, int is_softmmu)\n\n{\n\n    uint32_t phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,\n\n                        &page_size);\n\n    if (ret == 0) {\n\n        /* Map a single [sub]page.  */\n\n        phys_addr &= ~(uint32_t)0x3ff;\n\n        address &= ~(uint32_t)0x3ff;\n\n        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,\n\n                      page_size);\n\n        return 0;\n\n    }\n\n\n\n    if (access_type == 2) {\n\n        env->cp15.c5_insn = ret;\n\n        env->cp15.c6_insn = address;\n\n        env->exception_index = EXCP_PREFETCH_ABORT;\n\n    } else {\n\n        env->cp15.c5_data = ret;\n\n        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))\n\n            env->cp15.c5_data |= (1 << 11);\n\n        env->cp15.c6_data = address;\n\n        env->exception_index = EXCP_DATA_ABORT;\n\n    }\n\n    return 1;\n\n}\n", "idx": 7972, "substitutes": {"env": ["np", "er", "equ", "que", "ce", "energy", "ace", "site", "inv", "enable", "engine", "vt", "en", "el", "conf", "output", "context", "vm", " environment", "db", "loader", "enc", "exec", "ea", "ne", "config", "viron", "txt", "ah", "osc", "cv", "Environment", "inet", "edge", "qt", "environment", "iss", "ext", "eve", "eu", "export", "session", "conn", "etr", "et", "ef", "eng", "estate", "host", "console", "qa", "manager", "state", "extra", "nc", "end", "proc", "e", "exc", "server", "event", "ev", "net", "enter", "ctx", "ec", "err", "global", "dev", "forge", "erv", "eni", "esi", "po"], "address": ["data", "context", "phrase", "index", "object", "ress", "url", "target", "number", "area", "end", "asm", "error", "name", "ref", "ast", "message", "interface", "server", "event", "connection", "type", "socket", "Address", "email", "order", "ace", "image", "site", "offset", "test", "config", "device", "at", "password", "ip", "keep", "mode", "enter", "entry", "host", "buffer", "pointer", "path", "holder", "array", "location", "attribute", "network", "en", "reference", "size", "memory", "uri", "code", "inet", "eni", "database", "state", "route", "alias", "addr", "resource", "output", "port"], "access_type": ["accessalstate", " accessalinfo", "access_format", " access_name", " accessalsize", "accessalinfo", " accessalformat", "accessaltype", "access_py", " access_py", "accessOstate", "ace_code", " access_info", " access_types", "accessOcode", "accessOinfo", "access_size", "accessalpy", "access_types", "ace_info", "accessalsize", "access_code", "accessaltypes", "ace_state", " access_size", "access_state", " access_format", "accessalname", " access_state", " accessaltype", "ace_type", "access_info", "accessOtype", "access_name", "accessalformat", "accessalcode"], "mmu_idx": ["mmu__namect", "mmu_namex", "mmu__namez", "mmu_idg", "mmu_IDg", "mmu_Idc", "mmu__idct", "mmu_iqxes", "mmu_Idn", "mmu_inv", "mmu_ing", "mmu_ipz", "mmu_inx", "mmu_IDx", "mmu_namect", "mmu_idc", "mmu_IDc", "mmu_Idx", "mmu_idex", "mmu__namexes", "mmu_idn", "mmu_idv", "mmu_namez", "mmu__idxes", "mmu_iqct", "mmu_idct", "mmu_idec", "mmu_ipx", "mmu_ipxes", "mmu_IDn", "mmu_idz", "mmu_namexes", "mmu_ideg", "mmu__idx", "mmu_idev", "mmu_iqz", "mmu_ipct", "mmu_Idg", "mmu_idxes", "mmu__idz", "mmu__namex", "mmu_inc", "mmu_iqx"], "is_softmmu": ["is_hardmmtu", "is_hardmmu", "is_softMMcu", "is_softmmi", "is_softmmtu", "is_softmmcu", "is_hardmmi", "is_softmmmi", "is_softMMi", "is_softmmmcu", "is_softmmmtu", "is_softMMu", "is_softMMtu", "is_hardmmcu", "is_softmmmu"], "phys_addr": ["phys_add", "physfalign", "physnaddress", "phys2amp", "physical_data", "phys_info", "physfaddress", "physical_info", "phys_align", "phys2address", "phys_amp", "physfack", "phys_ack", "physnamp", "physical_align", "phys2work", "physical_amp", "physical_add", "physical_ad", "phys_address", "phys_data", "physnaddr", "phys_ad", "physfaddr", "phys2addr", "physical_address", "physical_ack", "physical_work", "phys_work", "physnwork", "physical_addr"], "page_size": [" page_pos", "page_content", "server___size", "page___size", "row_scale", "page1count", "server_size", "page_address", "row1count", "page1limit", "page_count", "server___type", "row_size", "page1scale", "server_type", "page___type", "page_type", " page_content", "row1size", "page_scale", "row_count", "page___address", "server_address", "server___address", "page_limit", "row_limit", "row1scale", "page_pos", "page1size", "row1limit"], "prot": ["pat", "pos", "policy", "ext", "reset", "cert", "ref", "dist", "proc", "def", "eth", "pre", "fun", "rep", "att", "len", "server", "cli", "rf", "afi", "type", "seq", "conn", "offset", "test", "config", "stat", "pro", "password", "dim", "rot", "pattern", "mode", "notes", "layer", "Prot", "pointer", "platform", "primary", "prop", "padding", "lit", "prefix", "token", "col", "addr", "status", "format"], "ret": ["pat", "data", "pet", "ext", "phrase", "re", "reset", "rc", "ref", "def", "fail", "result", "fun", "rep", "alt", "success", "att", "error", "len", "val", "mem", "arr", "std", "bit", "RET", "resp", "out", "hard", "reg", "et", "res", "obj", "txt", "inter", "art", "rev", "lit", "ben", "flag", "feat", "err", "nat", "det", "ft", "match", "nt", "reply", "code", "valid", "rl", "arg", "addr", "rets", "Ret", "rt"], "is_user": ["is___ver", "is___use", "isaluser", "is__user", " is__use", "isrettyuse", "is_owner", "isalusr", "isrettyowner", "is__ver", "is__owner", " is_users", " is__owner", "is_ver", "isalusers", "is__use", "is___user", "is__users", "is_users", " is__users", "is_usr", " is_ver", "isaluse", "isrettyuser", " is_usr", "is___users", " is_owner", " is_use", " is__user", "isrettyusers", "is_use"]}}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n\n    return h->pps.chroma_qp_table[t][qscale];\n\n}\n", "idx": 7977, "substitutes": {"h": ["context", "php", "ih", "him", "ahi", "self", "p", "rh", "hr", "image", "img", "hm", "hl", "n", "eh", "hp", "hh", "temp", "m", "c", "hhh", "ctx", "hd", "cpp", "v", "oh", "mc", "ah", "hw", "gh", "cache", "i", "ph", "w", "H", "bh", "he", "b", "http", "hs", "q", "ha", "ht"], "t": ["k", "target", "j", "total", "name", "e", "d", "dt", "tp", "ti", "p", "window", "type", "ct", "test", "offset", "out", "tt", "u", "at", "n", " T", "c", "m", "ts", "v", "ta", "g", "f", "pointer", "pt", "tif", "axis", "i", "wt", "o", "title", "ot", "tf", "ant", "T", "transform", "tz"], "qscale": ["Qphase", "wphase", "ctsize", " qcale", "quickscale", " qrate", "krate", "Qrate", " qgrade", "ctscale", "kgrade", "qcale", "Qscale", "kscale", "Qsize", "wscale", "qgrade", "qrate", "quickcale", "kcale", "wsize", "qphase", "quickgrade", "qsize", "wrate", "quickrate", "ctphase", "ctrate"]}}
{"project": "FFmpeg", "commit_id": "fd92dafaff8844b5fedf94679b93d953939a7f7b", "target": 0, "func": "static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,\n\n                              int plane_idx, int is_key, int is_chroma)\n\n{\n\n    int blk, ret;\n\n    int i, j, bx, by;\n\n    uint8_t *dst, *ref, *ref_start, *ref_end;\n\n    int v, col[2];\n\n    const uint8_t *scan;\n\n    int xoff, yoff;\n\n    LOCAL_ALIGNED_16(int16_t, block, [64]);\n\n    LOCAL_ALIGNED_16(int32_t, dctblock, [64]);\n\n    int coordmap[64];\n\n    int ybias = is_key ? -15 : 0;\n\n    int qp;\n\n\n\n    const int stride = frame->linesize[plane_idx];\n\n    int bw = is_chroma ? (c->avctx->width  + 15) >> 4 : (c->avctx->width  + 7) >> 3;\n\n    int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3;\n\n\n\n    binkb_init_bundles(c);\n\n    ref_start = frame->data[plane_idx];\n\n    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;\n\n\n\n    for (i = 0; i < 64; i++)\n\n        coordmap[i] = (i & 7) + (i >> 3) * stride;\n\n\n\n    for (by = 0; by < bh; by++) {\n\n        for (i = 0; i < BINKB_NB_SRC; i++) {\n\n            if ((ret = binkb_read_bundle(c, bc, i)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        dst  = frame->data[plane_idx]  + 8*by*stride;\n\n        for (bx = 0; bx < bw; bx++, dst += 8) {\n\n            blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES);\n\n            switch (blk) {\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                scan = bink_patterns[bitstream_read(bc, 4)];\n\n                i = 0;\n\n                do {\n\n                    int mode = bitstream_read_bit(bc);\n\n                    int run  = bitstream_read(bc, binkb_runbits[i]) + 1;\n\n\n\n                    i += run;\n\n                    if (i > 64) {\n\n                        av_log(c->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    if (mode) {\n\n                        v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = v;\n\n                    } else {\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                    }\n\n                } while (i < 63);\n\n                if (i == 63)\n\n                    dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                break;\n\n            case 2:\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTRA_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp);\n\n                c->binkdsp.idct_put(dst, stride, dctblock);\n\n                break;\n\n            case 3:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8*stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                c->bdsp.clear_block(block);\n\n                v = binkb_get_value(c, BINKB_SRC_INTER_COEFS);\n\n                read_residue(bc, block, v);\n\n                c->binkdsp.add_pixels8(dst, block, stride);\n\n                break;\n\n            case 4:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTER_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp);\n\n                c->binkdsp.idct_add(dst, stride, dctblock);\n\n                break;\n\n            case 5:\n\n                v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                c->bdsp.fill_block_tab[1](dst, v, stride, 8);\n\n                break;\n\n            case 6:\n\n                for (i = 0; i < 2; i++)\n\n                    col[i] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                for (i = 0; i < 8; i++) {\n\n                    v = binkb_get_value(c, BINKB_SRC_PATTERN);\n\n                    for (j = 0; j < 8; j++, v >>= 1)\n\n                        dst[i*stride + j] = col[v & 1];\n\n                }\n\n                break;\n\n            case 7:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                break;\n\n            case 8:\n\n                for (i = 0; i < 8; i++)\n\n                    memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);\n\n                c->bundle[BINKB_SRC_COLORS].cur_ptr += 64;\n\n                break;\n\n            default:\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Unknown block type %d\\n\", blk);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (bitstream_tell(bc) & 0x1F) // next plane data starts at 32-bit boundary\n\n        bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F));\n\n\n\n    return 0;\n\n}\n", "idx": 7980, "substitutes": {"c": ["context", "nc", "uc", "pc", "rc", "k", "e", "d", "coll", "co", "cc", "self", "p", "ce", "ct", "cm", "cs", "ch", "config", "u", "r", "cit", "l", "cy", "m", "t", "ctx", "dc", "arc", "cur", "f", "g", "cr", "ctrl", "mc", "cl", "cat", "ec", "cache", "cu", "cf", "ca", "C", "tc", "code", "ci", "lc", "cd", "ac", "center", "b", "com", "cb", "vc", "con", "cp"], "frame": ["context", "scope", "object", "zone", "set", "scale", "db", "e", "d", "frames", "element", "component", "coll", "document", "core", "game", "p", "que", "df", "slice", "ce", "flow", "image", "module", "cm", "position", "bug", "config", "service", "ze", "flower", "file", "plane", "block", "sequence", "load", "m", "ctx", "force", "f", "range", "draw", "scene", "parse", "Frame", "model", "fram", "cf", "fr", "code", "series", "state", "b", "feature", "setup", "cycle", "q", "cell", "lock", "framework", "panel", "base"], "bc": ["context", "nc", "uc", "rc", "CBC", "pc", "db", "cc", "anc", "gc", "oc", "sc", "xc", "cm", "cs", "config", "lib", "cca", "cms", "ctx", "dc", "cr", "mc", "cl", "mac", "ec", "fc", "cf", "ca", "tc", "lc", "ac", "cb", "vc", "con", "BC"], "plane_idx": ["plane_timex", "plane_Idxe", "plane_minxes", "plane_ridced", "plane_aidxes", "plane_idexes", "plane_ridxe", "plane_idente", "plane_aidy", "plane_idxes", "plane_Idxx", "plane_ide", "plane_kidz", "plane_timey", "plane___indxe", "plane_ipx", "plane_idpe", "plane_miny", "plane_ipxe", "plane_ende", "plane___idx", "plane_kidX", "plane_pidz", "plane___indx", "plane_endxe", "plane_ipz", "plane_Idx", "plane_identx", "plane_kidx", "plane_Idv", "plane_idxe", "plane_adv", "plane___indh", "plane___inde", "plane_adz", "plane_Idc", "plane_idxx", "plane___ide", "plane_endx", "plane_minx", "plane_idec", "plane___idh", "plane_adc", "plane_idy", "plane_ideX", "plane_aidpe", "plane_timexe", "plane_timeced", "plane_endh", "plane_indxe", "plane_ridx", "plane_ipxx", "plane_pidxe", "plane_adx", "plane_identh", "plane_indx", "plane_pidxx", "plane_identxe", "plane_idev", "plane_indh", "plane_idX", "plane_idc", "plane_ridy", "plane_idv", "plane_idh", "plane_idz", "plane_aidx", "plane_Idz", "plane_pidx", "plane_minpe", "plane_idex", "plane_idez", "plane_inde", "plane___idxe", "plane_kidxes", "plane_idced"], "is_key": ["isLogroot", "is_row", " is_root", "IS_key", "IS_char", "ispubrow", "is_loop", "is2char", "IS__char", "ispubloop", "IS_switch", "IS__key", "IS__switch", "is__switch", "is_root", "is__key", "IS__keys", "IS_keys", " is_loop", "ispubkey", "is2keys", "isLogloop", "is_char", "is__char", "isLogkey", "is_switch", " is_row", "isLogrow", "is_keys", "ispubroot", "is2switch", "is2key", "is__keys"], "is_chroma": ["is_porta", "is_chromaa", "is_operaf", "is_romA", "is_chromo", "is_portaa", "is_cyclA", "is_servA", "is_cyclaf", "is_porto", "is_rela", "is_operA", "is_relb", "is_chromb", "is_romaa", "is_romb", "is_romas", "is_chromas", "is_servas", "is_roma", "is_cycla", "is_portA", "is_servb", "is_romo", "is_serva", "is_chromaf", "is_opersa", "is_chromsa", "is_opera", "is_relA", "is_relas", "is_cyclsa", "is_chromA"], "blk": ["blch", "plck", "plks", "BLks", "silk", "blak", " blok", "plok", "blkk", "blck", "silok", "Blks", "Blk", "plak", "BLck", "plk", "silch", "brok", "Blck", "blks", "brk", "plkk", "BLok", "brak", " blks", "Blok", " blkk", " blck", "silak", "blok", "BLk", "Blkk", "plch", "brch"], "ret": ["data", "ru", "replace", "miss", "re", "pin", "def", "fail", "result", "success", "fun", "alt", "error", "value", "sb", "get", "mini", "len", "val", "fi", "mem", "arr", "bl", "mi", "RET", "r", "out", "reg", "res", "txt", "fin", "pass", "rev", "lit", "vt", "flag", "feat", "cache", "err", "info", "det", "match", "reply", "nt", "job", "status", "rets", "Ret", "rt"], "i": ["ui", "bi", "y", "index", "pi", "ie", "di", "si", "d", "e", "ik", "mini", "multi", "fi", "li", "p", "ti", "yi", "api", "slice", "h", "is", "mi", "jit", "phi", "qi", "ii", "ki", "hi", "u", "ji", "id", "n", "l", "ni", "ip", "chi", "ami", "abi", "m", "ix", "ori", "oi", "f", "zi", "io", "start", "ri", "ini", "info", "it", "im", "xi", "gi", "uri", "ci", "eni", "b", "iu", "I", "ai", "x"], "j": ["py", "pos", "note", "y", "k", "key", "jc", "p", "ij", "r", "ch", "ji", "ind", "je", "n", "jp", "ni", "m", "g", "it", "xi", "span", "z", "jump", "ot", "adj", "J", "si"], "bx": ["py", "dbz", "fx", "bv", "pw", " bz", "dbx", "dbw", "fw", "bw", "dw", "dX", " bw", "fy", "dby", "dy", "pX", "fz", "px", "dz", " bX", "dbv", "dv", "bz", "bX", "dx", " bv", "dbX"], "by": ["bi", "br", "y", "re", "from", "index", "before", "to", "By", "rel", "with", "about", "db", "browser", "key", "report", "the", "no", "ry", "type", "app", "of", "mi", "byn", "BY", "r", "use", "query", "service", "u", "device", "at", "reg", "per", "via", "s", "bys", "not", "ly", "g", "range", "acc", "or", "io", "be", "ri", "us", "bin", "it", "x", "ray", "b", "in", "how", "ber", "count", "row", "serv", "si", "port"], "dst": [" dsc", "dnd", " dbl", "pdsts", "adbl", " dnd", " dsts", "bst", "idbl", " dx", "bsts", "pdx", "dbl", "adnd", " dct", "gst", "dct", "dedsts", "idsts", "adsc", "bct", "drest", "gnd", "idct", "bbl", "idst", "dsts", "adst", "dedx", "gsc", " drest", "dedst", "gbl", "dx", "pdrest", "dsc", "dedrest", "pdst"], "ref": ["pos", "index", "re", "Ref", "def", "diff", "loc", "val", "mem", "src", "offset", "config", "reg", "ind", "block", "rec", "buffer", "f", "range", "source", "cache", "reference", "count", "rel", "x", "base"], "ref_start": ["reference_end", "ref_step", "ref_change", "reference_start", "REF_start", "ref_stop", "REF_end", "ref_first", "reference_stop", "reference_step", "REF_change", "REF_first"], "ref_end": ["reflexend", "ref_max", "reflexset", "cachelexstart", "reference_end", "reference_until", "refsmax", "refxuntil", "reflexmax", "cachelexset", "refxend", "reference_start", "reflexstart", "cache_set", "cache_end", "cache_start", "cache_max", "cachelexend", "refsstart", "ref_set", "refsend", "refxstart", "cachelexmax", "refsset", "ref_until"], "v": ["y", "conv", "lv", "vert", "val", "vi", "p", "h", "vs", "u", "n", "l", "m", "uv", "V", "f", "g", "vt", "cv", "w", "z", "sv", "b", "vc", "q"], "col": ["pos", "Col", "loc", "coll", "co", "val", "key", "row", "ann", "bit", "seq", "channel", "column", "ch", "win", "reg", "dim", "rot", "sect", "cat", "cl", "el", "con", "cp", "cell", "unit", "fl"], "scan": ["batch", "split", "index", "loc", "Scan", "mask", "ignore", "call", "row", "sync", "slice", "search", "ann", "sc", "test", "query", "config", "reg", "chan", "read", "block", "skip", "look", "can", "path", "range", "parse", "cat", "sn", "syn", "bin", "cache", "info", " scanner", "ver", "match", "span", "gen", "find", "conf", "align", "stat"], "xoff": ["XOff", "exOff", "Xoff", "xOFF", "XOFF", "xOff", "exoff", " xOff", " xOFF", "exOFF"], "yoff": ["yOff", "yshift", " yshift", "vyshift", "vyOff", " yOff", " yOFF", "vyOFF", "vyoff", "Yoff", "YOff", "YOFF", "yOFF", "Yshift"], "coordmap": ["pixelmaps", "ordmap", "pixelblock", "catMap", "ordgroup", "coordmaps", "coordMap", " coordgroup", "coordgroup", "ordblock", "catmaps", "pixelmap", "coordblock", " coordblock", "ordMap", "pixelgroup", "pixelMap", "ordmaps", "catmap", "catblock"], "qp": ["Qp", "ql", " qP", " ql", "iql", "Ql", "QP", "iqp", "iqP", "qP"]}}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7982, "substitutes": {"f": ["fa", "fn", "ref", "e", "d", "bf", "fx", "fi", "fe", "p", "df", "h", "F", "sf", "fw", "fm", "file", "l", "buff", "fd", "c", "m", "t", "fs", "g", "io", "fc", "i", "fr", "elf", "b", "fac", "tf", "fp", "v"], "opaque": [" opxc", "ospaques", "ocaques", "ocque", "ocaque", "opquire", "ipxc", "ospque", "ospec", "ipec", "oaque", "ocula", "opaques", "ospula", " opec", "oque", "ospaque", "oaques", " opquire", "ipquire", "oula", "ipaque", "ospquire", "opula", "opque", "ospxc", "opxc", "opec"], "size": ["data", "pos", "sec", "eval", "value", "enc", "len", "val", "fi", "empty", "Size", "ctx", "g", "vals", "_", "alloc", "iv", "code", "z", "unit"], "cpu": ["pool", "vm", "pc", "np", "proc", "loader", "gpu", "fat", "val", "core", "fi", "p", "clock", "fork", "socket", "conn", "auc", "processor", "config", "kernel", "net", "c", "instance", "boot", "platform", "ec", "hw", "cache", "fc", "cow", "pty", "eni", "pu", "node", "cp", "linux", "CPU"], "env": ["np", "essential", "eval", "vel", "equ", "que", "args", "energy", "vs", "engine", "bc", "uv", "chal", "en", "el", "cf", "exe", "fg", "conf", "v", "context", "vm", "oa", "loader", "enc", "exec", "ea", "cli", "agent", "ne", "config", "viron", "stage", "ah", "Environment", "inst", "cv", "inet", "edge", "rb", "environment", "eu", "skin", "export", "style", "buf", "conn", "et", "ef", "cookie", "eng", "estate", "fen", "console", "eb", "scope", "proc", "e", "exc", "core", "fi", "fe", "ev", "est", "fb", "obj", "net", "ctx", "assets", "ec", "cache", "err", "global", "iv", "dev", "erv", "eni", "attr", "priv"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_handle_byte(int ch)\n\n{\n\n    switch(term_esc_state) {\n\n    case IS_NORM:\n\n        switch(ch) {\n\n        case 1:\n\n            term_bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n", "idx": 7992, "substitutes": {"ch": ["che", "power", "y", "k", "ach", "ich", "cp", "th", "ech", "cho", "text", "enc", "tch", "command", "p", "cha", "quote", "prev", "last", "h", "och", "sch", "channel", "kick", "cod", "cher", "cor", "u", "chu", "cmd", "change", "chan", "chi", "cell", "Char", "qu", "cy", "Ch", "c", "sh", "cur", "cr", "ctx", "chn", "character", "range", "cl", "cht", "i", "inch", "utf", "code", "zh", "state", "length", "col", "quit", "q", "count", "CH", "chin"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)\n\n{\n\n    struct omap_l4_s *bus = g_malloc0(\n\n                    sizeof(*bus) + ta_num * sizeof(*bus->ta));\n\n\n\n    bus->ta_num = ta_num;\n\n    bus->base = base;\n\n\n\n#ifdef L4_MUX_HACK\n\n    omap_l4_io_entries = 1;\n\n    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));\n\n\n\n    omap_cpu_io_entry =\n\n            cpu_register_io_memory(omap_l4_io_readfn,\n\n                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);\n\n# define L4_PAGES\t(0xb4000 / TARGET_PAGE_SIZE)\n\n    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);\n\n#endif\n\n\n\n    return bus;\n\n}\n", "idx": 8010, "substitutes": {"base": ["stable", "bi", "extra", "ase", "ada", "index", "pi", "ref", "area", "gb", "scale", "db", "name", "bf", "byte", "p", "Base", "type", "beta", "pad", "offset", "balance", "out", "pa", "ases", "id", "block", "home", "entry", "boot", "address", "buffer", "array", "padding", "start", "kit", "cache", "axis", "ma", "rate", "size", "prefix", "ca", "la", "null", "b", "alias", "length", "addr", "status", "count", "zero", "store", "unit", "bas"], "ta_num": ["tta_number", " ta_con", "ta_id", "tta2len", "ta_tun", "taNtun", "ta_fn", " ta_id", "taNsum", "ta__len", "ta_number", "ta1id", "tta2Num", "tta2number", "sa_number", "tta_len", "taNnum", "ta1len", "ta__number", "ta1num", "ta2num", "tta_Num", "ta_pos", "ta_nom", "ta1con", "taNpos", "ta2len", " ta_sum", "sa_num", " ta_tun", "ta2Num", " ta_fn", "sa_n", "ta1number", "tta2num", "ta2number", "sa_nom", "ta_con", "ta1fn", " ta_pos", "ta_len", "ta_Num", "ta__num", "tta_num", "ta_n", "ta1Num", "ta__Num", "ta_sum"], "bus": ["data", "object", "proxy", "Bus", "proc", "def", "result", "queue", "input", "gpu", "back", "str", "hub", "controller", "fi", "sync", "connection", "clock", "bit", "buf", "bridge", "bug", "use", "config", "service", "device", "out", "lib", "plugin", "block", "plug", "obj", "abi", "class", "boot", "cpu", "bc", "usb", "io", "pass", "us", "serial", "mount", "cache", "i", "BUS", "prefix", "dev", "machine", "bits", "route", "pack", "length", "board", "b", "http", "os", "select", "feed", "phys", "driver", "las", "port"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n", "idx": 8018, "substitutes": {"dev": ["data", "oy", "Dev", "da", "pub", "dist", "def", "od", "bus", "kid", "diff", "development", "di", "d", "adv", "enc", "rad", "debug", "self", "dom", "app", "client", "conn", "test", "ev", "ch", "die", "device", "lib", "plug", "dd", "obj", "block", "engine", "dc", "comment", "mod", "model", "der", "info", "ad", "ver", "user", "w", "nt", "md", "cd", "sd", "desc", "node", "grad", "priv", "dem", "ani", "conf", "gu", "wd"], "dest": ["Dest", "pos", "dir", "seed", "dist", "target", "end", "text", "loc", "trans", "decl", "src", "done", "buf", "seq", "test", "die", "ds", "head", "pipe", "dim", "temp", "home", "des", "dc", "sup", "opt", "source", "lit", "prop", "wd", "suff", "feat", "coord", "front", "wh", "gen", "desc", "iter", "append", "priv", "del", "disabled"], "len": ["Len", "pos", "fn", "fail", "pre", "fun", "alt", "enc", "fat", "pl", "val", "str", "ls", "ll", "ann", "un", "seq", "lon", "win", "line", "lib", "vec", " length", "sp", "fin", "ix", "lit", "min", "en", "syn", "el", "part", "non", "err", "lin", "size", "nt", "lf", "lc", "la", "span", "length", "in", "count", "ln", "body", "ell", "li"], "child": ["root", "data", "local", "new", "end", "kid", "build", "slave", "enc", "server", "draft", "boy", "app", "client", "last", "ch", "current", "device", "lib", "inner", "id", "l", "block", "fd", "friend", "add", "children", "cur", "f", "Child", "comment", "parent", "sl", "feed", "code", "sub", "plus", "desc", "node", "count", "row", "sel", "ell", "leaf"], "sep": ["peg", "pepr", " seg", "lept", "lep", "psepa", " sepr", " sepa", "psem", "lepa", " sept", "sem", "pem", " sepc", "sempc", "sepa", "seg", "semp", "psep", "pepa", " sem", "pep", "sepr", "semm", "psepr", "pseg", "sepc", "sempr", "lepr", "sept", "pepc", "psept"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    direntry_t* direntry;\n\n    const char* dirname = mapping->path;\n\n    int first_cluster = mapping->begin;\n\n    int parent_index = mapping->info.dir.parent_mapping_index;\n\n    mapping_t* parent_mapping = (mapping_t*)\n\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n\n\n\n    DIR* dir=opendir(dirname);\n\n    struct dirent* entry;\n\n    int i;\n\n\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n\n\n    if(!dir) {\n\n        mapping->end = mapping->begin;\n\n        return -1;\n\n    }\n\n\n\n    i = mapping->info.dir.first_dir_index =\n\n            first_cluster == 0 ? 0 : s->directory.next;\n\n\n\n    if (first_cluster != 0) {\n\n        /* create the top entries of a subdirectory */\n\n        (void)create_short_and_long_name(s, i, \".\", 1);\n\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n\n    }\n\n\n\n    /* actually read the directory, and allocate the mappings */\n\n    while((entry=readdir(dir))) {\n\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n\n        char* buffer;\n\n        direntry_t* direntry;\n\n        struct stat st;\n\n        int is_dot=!strcmp(entry->d_name,\".\");\n\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n\n\n\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n\n            continue;\n\n\n\n        buffer = g_malloc(length);\n\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n\n\n\n        if(stat(buffer,&st)<0) {\n\n            g_free(buffer);\n\n            continue;\n\n        }\n\n\n\n        /* create directory entry for this file */\n\n        if (!is_dot && !is_dotdot) {\n\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n\n        } else {\n\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n\n        }\n\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n\n        direntry->reserved[0]=direntry->reserved[1]=0;\n\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n\n        direntry->adate=fat_datetime(st.st_atime,0);\n\n        direntry->begin_hi=0;\n\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n\n        if(is_dotdot)\n\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n\n        else if(is_dot)\n\n            set_begin_of_direntry(direntry, first_cluster);\n\n        else\n\n            direntry->begin=0; /* do that later */\n\n        if (st.st_size > 0x7fffffff) {\n\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n\n            g_free(buffer);\n\n            closedir(dir);\n\n            return -2;\n\n        }\n\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n\n\n\n        /* create mapping for this file */\n\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n\n            s->current_mapping = array_get_next(&(s->mapping));\n\n            s->current_mapping->begin=0;\n\n            s->current_mapping->end=st.st_size;\n\n            /*\n\n             * we get the direntry of the most recent direntry, which\n\n             * contains the short name and all the relevant information.\n\n             */\n\n            s->current_mapping->dir_index=s->directory.next-1;\n\n            s->current_mapping->first_mapping_index = -1;\n\n            if (S_ISDIR(st.st_mode)) {\n\n                s->current_mapping->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n", "idx": 8021, "substitutes": {"s": ["y", "storage", "sq", "e", "d", "sb", "server", "sys", "self", "sync", "p", "spec", "ls", "S", "is", "ses", "site", "gs", "sets", "r", "service", "sf", "ds", "u", "stats", "states", "ss", "m", "sym", "c", "services", "t", "strings", "fs", "g", "f", "ns", "space", "source", "sa", "address", "us", "ssl", "south", "settings", "secondary", "o", "your", "sv", "state", "b", "es", "side", "su", "single", "http", "status", "os", "serv", "rs", "si"], "mapping_index": ["mapping_Index", "mappingAweight", "mappingIDindex", "mapping_id", "mapping_weight", "mappingAindex", "mappingIDname", "mapping_name", "mappingIDweight", "matching_weight", "matching_index", "mappingIDi", "mappingAi", "matching_Index", "mapping_i", "matching_i", "matching_id", "matching_name", "mappingAname"], "mapping": ["daming", "tmapping", "tmappings", "amapping", "mashing", "mappings", "amapper", "mmappings", "Map", "Mapped", "Mappings", " map", "amappings", "papping", "Mapper", "finding", "natching", "pappings", "fapper", "faming", "papper", "lapper", "mapper", "migration", "matching", "smapper", "Mouting", "Maming", "ymigration", "map", "Mutation", "dinding", "minding", "Mashing", "tmigration", "nigration", "Matching", "mutation", " mapper", "Migration", "smatching", "dapper", "napping", " mappings", "mmapping", "mouting", "papped", "dapping", "smapped", "louting", "smouting", "smapping", "mmashing", "lappings", "ymapper", "datching", "mapped", "lapping", "maming", "Mapping", "smappings", "ymutation", "pap", "tmutation", "tmatching", "fapping", "smashing", "digration", "ymapping", "napper", "Minding", "tmapper", "amapped", "mmapped"], "direntry": ["direntrie", "direndRY", "direndrys", "dpirentry", "direrentri", "dpirerentri", "dIREntries", "dIREncry", "diregentries", "dorerentrys", "dpirentri", "directrys", "diregentri", "dIREntry", "dorerentrie", "dorentrie", "dorerentries", "dIREncRY", "dIREncrys", "direndries", "direrentr", "direntri", "diregentr", "direncries", "direndry", "direndri", "direntRY", "direntrys", "dpirentries", "dorentry", "directry", "directrie", "dIREntrys", "dpirerentry", "diregentry", "direncry", "direncrys", "direndr", "dpirentr", "directRY", "direrentry", "dIREncries", "direrentrie", "dpirerentries", "dorentrys", "direrentrys", "directries", "direndrie", "direncRY", "dIREntRY", "dorentries", "direrentries", "direntr", "dorerentry", "dpirerentr", "direntries"], "dirname": [" directoryresource", "filepart", " directorypath", "dirpath", "dbpath", "dirfile", "directorynm", "dirnm", "directionpath", " directoryfile", "fileName", "modulepart", "folderName", " dirpath", " dirfile", " dirpart", "dbname", "filetype", "modulepath", " directoryname", "filenm", "dirtype", "directionname", "directorytype", "foldername", "directoryname", "dirpart", "directorypath", "folderpath", "filepath", "dirName", "dbresource", " dirresource", "filename", "foldernm", "directoryName", "directiontype", "dirresource", "directionName", "dbfile", "modulename"], "parent_mapping": ["parent_mmapper", "parent_mashing", "parent_amapped", "parent_Mapped", "parent_mapper", "parent_amashing", "parent__mapping", "parent_mapped", "parent_smapping", "parent_Mapper", "parent_Mapping", "parent_mmapped", "parent__smapper", "parent__smapping", "parent_amapper", "parent_dapper", "parent_papping", "parent_smashing", "parent__smashing", "parent_dapped", "parent_smaming", "parent__smapped", "parent_Maming", "parent_smapped", "parent_pashing", "parent_mmashing", "parent_maming", "parent__mashing", "parent__mapped", "parent_smapper", "parent_papped", "parent__mapper", "parent_mmapping", "parent_Mashing", "parent_dapping", "parent_daming", "parent_papper", "parent_amapping"], "dir": ["dn", "da", "folder", "dist", "name", "d", "inner", "DIR", "id", "file", "init", "f", "sub", "tree", "rel", "wd", "data", "root", "finder", "diff", "db", "draft", "map", "module", "r", "config", "dest", "ind", "direct", "mode", "rec", "dc", "path", "group", "match", "iter", "direction", "doc", "directory", "director", "inc", "lib", "dict", "block", "c", "home", "io", "req", "sl", "manager", "work", " directory", "Dir", "di", "loc", "zip", "record", "service", "m", "dy", "cur", "source", "sort", "ir", "parent", "cache", "info", "global", "dr", "attr", "desc", "alias"], "entry": ["data", "archive", "index", "object", "reader", "ie", "end", "j", "ner", "result", "error", "element", "d", "e", "ident", "try", "import", "view", "key", "si", "server", "event", "connection", "no", "ry", "record", "inc", "image", "escape", "service", "line", "cell", "inner", "id", "her", "enter", "inter", "add", "engine", "action", "source", "parse", "or", "ries", "comment", "start", "se", "info", "sl", "insert", "uri", "match", "ent", "feed", "ga", "dr", "ge", "letter", "item", "post", "row", "directory", "Entry"], "i": ["ui", "bi", "pi", "index", "ie", "j", "di", "e", "d", "mini", "multi", "fi", "ti", "p", "yi", "phi", "qi", "ii", "hi", "inner", "ind", "id", "ni", "l", "ip", "abi", "c", "m", "oi", "io", "ri", "ini", "info", "gi", "it", "xi", "uri", "x", "ci", "eni", "iu", "I", "ai", "si", "li"], "buffer": ["data", "header", "reader", "url", "stack", "result", "queue", "input", "text", "value", "message", "Buffer", "document", "row", "server", "byte", "buf", "pad", "channel", "position", "bb", "line", "fb", "file", "read", "block", "buff", "transfer", "address", "f", "shell", "source", "capacity", "array", "comment", "copy", "uffer", "writer", "cache", "reference", "table", "size", "memory", "fr", "uf", "stream", "b", "length", "iter", "null", "flash", "count", "ptr", "resource", "feed", "binary", "window", "output", "base"], "st": ["ste", "storage", "sth", "stack", " r", "e", "d", "sb", "str", "fe", "std", "stop", "sc", "ct", "ace", "r", "est", "STR", "sts", " str", "St", "rest", "t", "step", "cr", "put", "nd", "inst", "start", "se", "sl", "b", "store", "ptr", "stream", "ST"]}}
{"project": "FFmpeg", "commit_id": "dc5d1515681b57a257443ba72bb81fb3e6e6621b", "target": 0, "func": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n\n{\n\n    const char *p;\n\n    char *q, buf1[20], c;\n\n    int nd, len, addchar_count;\n\n    int found_count = 0;\n\n\n\n    q = buf;\n\n    p = filename;\n\n    for (;;) {\n\n        c = *p;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '%' && *(p+1) == '%')  // %%\n\n            addchar_count = 2;\n\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n\n            nd = 0;\n\n            addchar_count = 1;\n\n            while (av_isdigit(*(p + addchar_count))) {\n\n                nd = nd * 10 + *(p + addchar_count) - '0';\n\n                addchar_count++;\n\n            }\n\n\n\n            if (*(p + addchar_count) == placeholder) {\n\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n\n                if (len < 1)  // returned error or empty buf1\n\n                    goto fail;\n\n                if ((q - buf + len) > buf_size - 1)\n\n                    goto fail;\n\n                memcpy(q, buf1, len);\n\n                q += len;\n\n                p += (addchar_count + 1);\n\n                addchar_count = 0;\n\n                found_count++;\n\n            }\n\n\n\n        } else\n\n            addchar_count = 1;\n\n\n\n        while (addchar_count--)\n\n            if ((q - buf) < buf_size - 1)\n\n                *q++ = *p++;\n\n            else\n\n                goto fail;\n\n    }\n\n    *q = '\\0';\n\n    return found_count;\n\nfail:\n\n    *q = '\\0';\n\n    return -1;\n\n}\n", "idx": 8046, "substitutes": {"buf": ["data", "pool", "pb", "wb", "uc", "br", "context", "header", "rc", "ref", "bag", "ru", "uu", "queue", "text", "loc", "back", "Buffer", "fi", "que", "h", "seq", "box", "config", "vec", "cmd", "fb", "file", "buff", "aux", "ctx", "bc", "buffer", "f", "array", "lit", "cv", "cache", "prefix", "front", "bu", "cf", "qq", "uf", "ff", "rb", "b", "length", "cas", "cb", "fp", "cp", "port"], "buf_size": ["buf6number", "bag6number", "bag_sized", "uf_rate", "bag6size", " buf_scale", "bag6sized", "buf_sized", "uf_size", "buf_rate", "buf6size", "buf_number", "bag_number", " buf_SIZE", "uf_scale", "buf_SIZE", "buf_scale", "bag_size", "buf6sized"], "filename": ["nc", "fn", "phrase", "np", "Filename", "queue", "bf", "seq", "r", "config", "sf", "file", "l", "files", "buff", "txt", "fd", "m", "fil", "ctx", "kl", "il", "buffer", "f", "path", "source", "initial", "fc", "w", "prefix", "xp", "original", "uf", "bp", "b", "fp", "binary", "directory"], "placeholder": ["placesholder", "placeholders", "Placeolder", "Placepoint", " placeparent", "placehold", "hideholders", "fallholders", " placeholders", "paceholder", "pacehold", "placeshold", "replacehold", "hideolder", "fallholder", "Placeparent", "hideholder", " placeolder", "Placeholders", "paceholders", "placeolder", "placeparent", "replaceholders", "placepoint", "Placeholder", "placesholders", "Placehold", " placehold", "fallpoint", "pacepoint", "fallhold", "hideparent", "replaceholder"], "number": ["data", "nc", "note", "fn", "object", "nn", "one", "result", "value", "name", "even", "e", "digit", "umeric", "byte", "numbered", "no", "umber", "function", "num", "inc", "position", "umbers", "change", "r", "pn", "external", "id", "n", "line", "class", "not", "day", "sn", "en", "nr", "N", "non", "i", "reference", "z", "Number", "length", "null", "b", " Number", "count", "zero", "ln", "year", "v", "final", "x"], "p": ["py", "pat", "pos", "pb", "y", "pc", "pi", "np", "pin", "k", "j", "dp", "vp", "pre", "param", "e", "d", "pg", "pl", "tp", "op", "api", "pid", "h", "ps", "up", "pr", "r", "pa", "u", "sp", "pn", "pipe", "P", "n", "jp", "ip", "l", "ap", "s", "m", "t", "g", "f", "pt", "pp", "point", "wp", "a", "part", "parent", "i", "o", "ph", "lp", "pe", "bp", "b", "post", "po", "fp", "cp", "v", "x", "port"], "q": ["y", "k", "sq", "queue", "e", "d", "back", "que", "question", "iq", "dq", "h", "qi", "qs", "r", "ch", "query", "u", "ue", "id", "n", "qu", "s", "buff", "m", "quick", "t", "sh", "ctx", "cur", "ix", "quant", "g", "f", "buffer", "comment", "cl", "qa", "Q", "req", "quest", "cache", "i", "w", "qq", "x", "code", "pe", "z", "b", "qt", "count", "cp", "v", "port", "fl"], "buf1": ["bufn", "buffer2", "bag1", "buf0", " buf0", "ufb", "uf1", "buffn", "bufb", " bufone", "buf2", "bagone", "buff0", "buff2", "buffer0", "uf2", " bufb", "bufone", "bufferb", " buf2", "uf0", "buffern", "bag2", "buffer1", "bag0", "buffone", "ufone", "ufn", "buff1"], "c": ["unc", "nc", "uc", "k", "e", "d", "enc", "exc", "coll", "cc", "ce", "xc", "ct", "sc", "cs", "ch", "r", "u", "n", "l", "cy", "s", "t", "ctx", "cr", "dc", "g", "f", "comment", "mc", "ec", "i", "cu", "w", "o", "cf", "C", "code", "cn", "ci", "lc", "cd", "z", "ac", "b", "col", "count", "cp", "con", "vc", "v"], "nd": ["nc", "dn", "nn", "yd", "np", "da", "ng", "od", "odd", "nu", " gn", "d", " delta", "wn", "gn", "std", "nz", " nu", "inc", "old", "ne", " ne", "pn", "ind", "n", "rn", "dd", " d", "gd", "rd", " en", "nb", "nl", "inn", "unn", "nw", "pd", "pp", "sn", "nr", "dk", "ad", "dev", "nt", "bd", " ad", "md", "cd", "z", "sd", " ng", "edd", "und", " dd", "td", "ln", "ND", "ld"], "len": ["Len", "pos", "nc", "nn", "ie", "ner", "e", "le", "limit", "coll", "val", "ler", "no", "lang", "ls", "ll", "num", "lon", "lu", "lt", "line", "sp", "ind", "lib", "n", "l", "lim", "led", "fin", "L", "nb", "f", "lit", "sn", "min", "en", "dl", "el", "err", "lin", "kn", "size", "sl", "nt", "lf", "lc", "la", "z", "length", "b", "rl", "lan", "count", "ln", "v", "ld", "fl", "li"], "addchar_count": ["addchar__ref", "addcharacter_count", "addChar_count", "addcharacter_cache", "addchar_cache", "addcharacter_Count", "addChar_c", "addchar_length", "addchar__size", "addChar_size", "addchar_name", "addchar_ref", "addChar_Count", "addcharacter_length", "addbyte_offset", "addcharacter_size", "addcharacter_ref", "addbyte_count", "addcharacter_limit", "addchar_size", "addchar__count", "addchar\u00b7size", "addchar_code", "addchar_offset", "addchar\u00b7ref", "addchar\u00b7count", "addcharacter_code", "addchar_Count", "addbyte_c", "addchar_c", "addcharacter_c", "addchar_limit"], "found_count": ["foundancecount", "found\u00b7info", "found\u00b7counter", "foundoutcode", " found_total", "foundianparent", "found_total", "found_number", "found\u00b7count", " found_counter", " found_number", "found_parent", "foundoutnumber", "found_code", "foundancetotal", " found_parent", "found_info", "foundiancount", " found_info", " found_code", "found_counter", "foundanceparent", "foundiantotal", "foundoutcount"]}}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "func": "static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n", "idx": 8049, "substitutes": {"args": ["py", "ages", "np", "aws", "am", "xml", "ras", "parts", "enc", "arr", "ks", "lang", "params", "conn", "atts", "cs", "gs", "config", "alls", "ds", "Args", "ass", "states", "ids", "sg", "init", "ts", "actions", "fs", "fields", "arms", "ns", "ig", "g", "ms", "ams", "parse", "ants", "flags", "GS", "words", "gr", "js", "same", "arg", "pres", "limits", "Arg", "ins", "conf", "parser", "qs", "spec", "asm"], "s": ["y", "sq", "aws", "e", "d", "sb", "so", "sys", "p", "sync", "spec", "ks", "ls", "session", "S", "h", "is", "ps", "ses", "cs", "gs", "r", "service", "sf", "ds", "u", "stats", "n", "states", "ss", "c", "m", "ts", "services", "t", "sg", "v", "uns", "fs", "g", "ns", "f", "sup", "ssl", "south", "i", "sl", "o", "state", "su", "js", "b", "hs", "conf", "serv", "qs", "rs", "si"], "err": ["msg", "y", "error", "result", "e", "good", "er", "pl", "str", "fi", "sys", "ler", "arr", "rh", "orig", "h", "conn", "pr", "bug", "r", "resp", "ev", "ind", "rr", "tx", "res", "rn", "txt", "var", "lr", "mr", "magic", "cr", "f", "Er", "ah", "ir", "rage", "Error", "req", "ise", "der", "ar", "dev", "kr", "fr", "aaa", "code", "dr", "lc", "gr", "aster", "fg", "cb", "doc", "rs"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n", "idx": 8071, "substitutes": {"espaddr": ["lpaddr", "spAddress", " espreq", "lpAddress", "ospaddress", "spreq", "sparm", "ispaddress", "lparm", "spconfig", "spaddr", "espaddress", "espAddress", " espconfig", "esparm", "osparm", "ispconfig", "ospaddr", "espconfig", "ispreq", "spaddress", "ospAddress", "ispaddr", "espreq", "lpaddress", " espaddress"], "it_shift": ["it1dist", "itfshift", "it2dist", "it__size", "itwset", "it_offset", "it_length", "it__length", "itfwrite", "lit_dist", "itwshift", "it2offset", "lit_offset", "itfset", "lit_shift", "itfpush", "it_write", "itwpush", "it2size", "it__count", "itwwrite", "its_shift", "it_push", "it2shift", "lit_size", "it1offset", "it1size", "it_count", "it1shift", "it__shift", "its_write", "its_push", "bit_shift", "it_set", "it_dist", "bit_size", "it_size", "bit_count", "its_set", "bit_length"], "dma_memory_read": ["dma_memoryingwrite", "dma_mem_write", "dma_mem_add", "dma_memory_update", "dma_memory_load", "dma_memoryxwrite", "dma_memoryxend", "dma_memoryingupdate", "dma_memory_add", "dma_mem_load", "dma_mem_read", "dma_memoryxload", "dma_memoryingread", "dma_mem_end", "dma_memory_end", "dma_memoryxread", "dma_mem_update", "dma_memoryingload"], "dma_memory_write": ["dma_memory2write", "dma_memory2writer", "dma_memory_writer", "dma_mem_write", "dma_memoryqvalue", "dma_memory_send", "dma_memory\u00b7only", "dma_memoryqsend", "dma_mem_writer", "dma_memory\u00b7send", "dma_memory\u00b7write", "dma_memoryqread", "dma_memory\u00b7value", "dma_memoryqwrite", "dma_mem_send", "dma_mem_only", "dma_mem_read", "dma_mem_value", "dma_memory2read", "dma_memory_only", "dma_memory_value", "dma_memory\u00b7read"], "dma_opaque": ["dma_operaque", "dma_copgate", "dma_ipgate", "dma_ospac", "dma_topause", "dma_copacity", "dma_ipause", "dma_topacity", "dma_opgate", "dma_copaque", "dma_ospacity", "dma_topaque", "dma_opac", "dma_topity", "dma_ipacity", "dma_operaco", "dma_operac", "dma_ipity", "dma_ospaque", "dma_copause", "dma_ipaque", "dma_opause", "dma_compaco", "dma_compac", "dma_opacity", "dma_ipac", "dma_compaque", "dma_copity", "dma_ipaco", "dma_opaco", "dma_ospgate", "dma_operacity", "dma_opity", "dma_compacity", "dma_copac"], "irq": ["irp", " irqs", "iperq", "irk", "ierqs", "pirw", " irquest", "ierk", " irw", " irk", "irw", "ierq", "rk", "pirq", " irp", "rp", "iperqs", "ierquest", "rw", "pirk", "rq", "iperk", "irquest", "iperquest", "pirp", "irqs"], "reset": ["kill", "pos", "protect", "index", "push", "set", "sleep", "clear", "nil", "disable", "none", "sync", "base", "destroy", "clock", "type", "stop", "pad", "apply", "offset", "at", "et", "response", "res", "rot", "init", "destruct", "primary", "start", "master", "req", "initial", "det", "prefix", "token", "timeout", "setup", "zero", "unit", "prot", "format", "hard"], "dma_enable": ["dma___update", "dga_adjust", "dma___enable", "dma_online", "dma_update", "dma__enabled", "dga_online", "dga_enabled", "dma_enabled", "dga_enable", "dma__adjust", "dma_adjust", "dma__enable", "dma__online", "dga_update", "dma___enabled"], "dev": ["data", "Dev", "dist", "def", "od", "bus", "rad", "diff", "di", "de", "d", " Dev", "vd", "development", "error", "ve", "fo", "devices", "debug", "self", "dom", "DEV", "app", "conn", "bug", "ev", "ch", "device", " device", "ds", "cmd", "pro", "dd", "temp", "gd", "sh", "v", "engine", "m", "dc", "c", "prov", "g", "f", "comment", "mod", "serial", "hw", "req", "der", "ad", "ver", "w", "md", "cd", "dm", "DC", "sd", "sk", "kind", "grad", "priv", "dem", " dd", "conf", "gu", "driver", "spec"], "s": ["e", "d", "ssh", "sb", "sys", "self", "p", "sync", "spec", "ls", "S", "ps", "sc", "vs", "ses", "cs", "gs", "r", "service", "sf", "sp", "ds", "u", "stats", "n", "ss", "c", "sg", "sh", "services", "sym", "rs", "t", "m", "fs", "g", "ns", "f", "sup", "ssl", "se", "w", "sl", "o", "tests", "sd", "su", "es", "js", "sk", "os", "serv", "v", "south", "si"], "sysbus": [" sysself", "ysBus", "systemself", "darself", "ysbit", "systemusb", " sysboot", "sysBus", "ysstate", "sysstate", "systemdef", "systemBus", " sysBus", "darusb", "sysboot", "systemboot", "Sysboot", " sysusb", "sysdef", "sysself", "Sysdef", "systembus", "darbus", "sysbit", "ysbus", "Sysbus", "systemstate", " sysbit", "sysusb", " sysstate", "systembit", " sysdef", "darboot", "SysBus", "ysboot"], "esp": ["py", "sci", "cfg", "eve", "np", "eval", "asp", "vp", "lv", "ssh", "eff", "fi", "eph", "tp", "cli", "p", "isp", "sync", "esh", "adr", "api", "ps", "ace", "vs", "soc", "ep", "resp", "ev", "imp", "sp", "ef", "env", "jp", "hp", "news", "ss", "sg", "sup", "pp", "sn", "eb", "gp", "wp", "ssl", "ipes", "esm", "PF", "lp", "amp", "pe", "ess", "elf", "ez", "sk", "es", "esi", "addr", "eps", "rpm", "ptr", "cp", "cpp", "ee", "v", "si"]}}
{"project": "FFmpeg", "commit_id": "aa6aa2ef091818c2669c48051286ce361401f31b", "target": 0, "func": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    float **audio      = (float **) frame->extended_data;\n\n    int len            = frame->nb_samples;\n\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n\n    int ch;\n\n    const float *win   = s->windows[window_index];\n\n    int window_len     = 1 << s->block_len_bits;\n\n    float n            = 2.0 * 32768.0 / window_len;\n\n\n\n    for (ch = 0; ch < avctx->channels; ch++) {\n\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n\n                                    win, len);\n\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n\n    }\n\n}\n", "idx": 8085, "substitutes": {"avctx": ["avcontext", "afcb", " avcf", " avcal", "Avconn", "avconn", "ajcca", "avcca", " avcontext", "avecf", "avcal", "afctx", "avcf", "avecontext", "afcontext", "afcal", "ajcontext", "afconn", "ajconn", "Avctx", "AVcontext", "avecb", "AVctx", "afcf", "AVcb", "avectx", "afcca", "AVcal", "Avcca", "ajctx", "Avcontext", "AVcf", "avcb"], "frame": ["data", "object", "j", "e", "d", "frames", "document", "fi", "call", "p", "fe", "game", "slice", "flow", "iframe", "rame", "image", "config", "sf", "request", "file", "video", "sequence", "m", "motion", "c", "ctx", "f", "Frame", "i", "fram", "w", "cf", "fr", "z", "state", "series", "board", "b", "setup", "fp", "voice", "window"], "s": ["conv", "sample", "d", "sync", "slice", "native", "site", "vs", "sg", "services", "fs", "f", "sv", "b", "side", "conf", "v", "data", "sq", "sb", "h", "ses", "r", "cs", "this", "u", "sf", "ss", "ts", "t", "uns", "ns", "a", "w", "your", "es", "hs", "self", "sys", "p", "ks", "ls", "session", "S", "ps", "full", "gs", "xs", "n", "c", "g", "us", "ssl", "sl", "series", "su", "qs", "rs", "spec", "si", "scope", "y", "aws", "e", "is", "support", "service", "ds", "l", "sym", "m", "ctx", "as", "sim", "settings", "se", "i", "o", "secondary", "js", "os", "stat"], "audio": ["data", "library", "archive", "wav", "ada", "area", "input", "mpeg", "api", "image", "channel", "cm", "config", "analysis", "application", "video", "volume", "picture", "alpha", "address", "buffer", "io", "array", "mac", "a", "wave", "avi", "media", "aud", "ca", "memory", "ac", "sound", "ai", "voice", "binary", "window", "Audio"], "mdct": ["mdect", "MDCT", "mpCT", "hdect", "mdcf", "mpcf", "mdnt", "mmcf", "hdc", "MDct", "hdcf", "mmct", "mpant", "mandect", "mpct", " mdcf", " mdect", "hdct", "mmnt", "mect", " mdCT", "mandcf", "MDant", "mdc", "MDect", "mandct", "mct", "MDc", "MDcf", " mdnt", "mmect", "mc", "mdCT", "mandnt", "mdant", "mcf", " mdant"], "ch": ["br", " col", "ech", " chunk", "coll", "och", "pr", "cor", "f", "cht", "cel", "el", "ver", " Ch", "zh", "sk", "b", "conf", "batch", "che", "k", "ich", "enc", "h", "channel", "chu", "change", "mot", "chart", "cl", " cs", "fr", "code", "arch", "q", "vc", "CH", "oy", " chip", " channel", "cho", "tch", "p", "conn", "sch", "cher", "chan", "cy", "child", "Ch", "c", "chn", "nt", "bh", "col", "cp", "work", "y", "ach", "j", "th", "pl", "cha", "chi", "chrom", "qu", "sh", "cur", "gh", "i", "ph", "chip", "z"], "win": ["data", "y", "nn", "k", "margin", "enc", "len", "widget", "p", "won", "gn", "ll", "client", "conn", "image", "vin", "n", "net", "windows", "c", "wan", "rec", "screen", "Win", "nan", "inn", "wa", "scan", "sn", "max", "en", "bin", "wave", "w", "gui", "nt", "gen", "in", "col", "con", "ln", "work", "v", "window", "x"]}}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,\n\n                                const uint8_t *s2, int stride)\n\n{\n\n    int i;\n\n    vec_u8 perm1 = vec_lvsl(0, s1);\n\n    vec_u8 perm2 = vec_lvsl(0, s2);\n\n    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);\n\n    vec_s16 shorts1, shorts2;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        vec_u8 pixl  = vec_ld(0,  s1);\n\n        vec_u8 pixr  = vec_ld(15, s1);\n\n        vec_u8 bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n", "idx": 8103, "substitutes": {"block": ["batch", "pos", "Block", "frame", "header", "section", "number", "error", "name", "label", "len", "mask", "byte", "none", "sync", "blocks", "bl", "clock", "type", "bit", "style", "full", "num", "image", "channel", "offset", "clean", "position", "inv", "off", "line", "device", "large", "ip", "word", "broad", "all", "version", "buffer", "range", "page", "check", "cl", "copy", "random", "blocking", "bin", "cache", "size", "user", "level", "pixel", "pack", "length", "lock", "time", "col", "row", "unit", "window", "square", "base"], "s1": ["S15", " sA", "ss91", "fone", "sesA", "sp1", "s11", "ks101", "sp15", "ss127", "s91", " s01", "s5", "S127", "f1", "ps2", "f4", "rs1", "s101", "ss11", "s4", "p1", "ssone", "site1", "sone", "sesONE", "ss2", "sinONE", "p4", "s001", "gs001", "S4", "ss4", "S11", " s5", "s15", "f001", "ps101", "sin001", "ses1", "f101", " s15", "site11", "fONE", "ses2", "sONE", "s127", "rs01", "ss1", "sin1", "p2", "gs4", "S001", " s11", "s81", "S2", "ks1", "ss01", "ks2", "site81", "SA", "ps1", "f2", "S81", "rs91", "sp5", "gs2", " s91", "S5", "rs2", "site127", "ps001", "ks001", "ses001", "s01", "ses11", "ss81", "pone", "sp2", "sin2", "gs1", "sA", "S1"], "s2": ["d22", "S02", "d1", "f0", "ksTwo", " s20", "fTwo", "p5", "s5", "c5", "f1", "Svec", "svec", " s\n", "f20", "south92", "stwo", "c4", "cs22", "f7", " s22", "s4", "p1", "s56", " s0", "s22", "size7", " s02", " stwo", "p4", "s92", " s72", "sTwo", "size0", " s5", "s62", "ctwo", "S\n", " s14", "in56", "p62", "size2", " svec", "d2", "S62", "size82", "f82", " s92", "d92", "s14", "p02", "s0", " sTwo", "gs\n", "p2", "in02", "south2", "s20", "S2", "ks1", "ks2", "c2", " s7", " s56", "cs1", " s4", "d14", "f2", " sII", "in2", "cs72", "south14", "s02", " s62", "ks20", "gs2", "s72", " s82", "cs2", "s7", "south1", "s82", "d72", "s\n", "ptwo", "gsvec", "inII", "sII", "S1"], "stride": ["privise", "bride", "divide", "striding", "arrince", "arride", "STRide", "strip", "dride", " striding", "drite", " stridi", "brance", "sprince", "drance", "dividing", " strise", " strance", "STRidi", "STRip", " strite", "shride", "brite", "divise", "brided", "brince", "shridi", "privides", "strite", "sprided", "strided", "stridi", "strider", "briding", "shrip", "strides", " strides", "shrider", "privide", "strance", " strided", " strider", "prividing", "arriding", "spriding", "drided", "strise", "arrided", " strip", "divides", "STRider", "strince", "spride"], "i": ["bi", "ui", "pos", "index", "pi", "k", "ie", "j", "di", "e", "si", "d", "fi", "cli", "ti", "p", "yi", "mi", "phi", "qi", "ii", "uni", "hi", "adi", "u", "ji", "n", "l", "chi", "ip", "ni", "ami", "abi", "c", "ori", "oi", "f", "zi", "io", "wei", "a", "ri", "ini", "info", "o", "gi", "mu", "xi", "uri", "ci", "eni", "b", "iu", "I", "ai", "v", "x", "li"], "shorts1": [" shorters4", "shportsone", "phapes2", "shports100", "shorters0", "ghapes1", "shocks1", "phorts2", "hortOne", "shores81", "horts81", "shorter2", "shorts81", "clorts01", "shports0", "shocks2", " shorters1", "shortOne", "clortsOnce", "howorters1", "shifts31", "shorter1", "shiftsOnce", "howorters2", "shifts01", "shessionsOnce", "shapes2", "short9", "shores1", "horts2", "phorts1", "howorters4", " shorts4", "shessions1", "shapes0", "shorterone", "shresses100", " shorts100", "hort2", "shocks81", "short1", " shorts31", "shports01", "phapes1", "ghorts2", "horts0", "hints1", "shresses31", "shifts1", "shorts31", "ghapesone", "ghapes9", "shorters1", "shortsOnce", "short2", "hints2", "ghapes2", "shports2", "shorters2", "shints2", "ghorts9", "shortsOne", "horts1", "shorts9", "hort0", "shortone", "hortsone", "shports31", "ghorts1", "clorts1", "shorts100", "howorts1", "shorts01", "hortsOne", "phapes0", "shportsOnce", "shorter9", " shports100", "shapesone", "short0", "shocksOne", "shifts100", " shports1", "shresses1", "shapes1", "shortsone", "short81", "shoresOne", "shports1", " shports31", "shorters4", "shorts0", "shapes9", "shores2", "phorts0", "hintsone", "clifts01", "howorts4", "clifts1", "shints1", "short4", "ghortsone", "hort1", " shorters2", "shessions01", "hort81", "howorts2", "shorts4", "cliftsOnce", "shports4", "shintsone"], "shorts2": ["short6", " shortsTwo", "shops4", "shops1", "shorts02", "chports4", "hort4", "shirtsTwo", "shorter2", "shapes4", "shports0", "chorts2", "chorts4", "shorter1", "chports2", "sworts52", "shifts2", "shortTwo", "shapes2", "swirts4", "chorts6", " short2", "horts2", "chports0", "shorterTwo", "sworts2", "shresses2", "shorts22", "shirts4", "shapes0", "shops02", "shortsTwo", "hort2", "short1", " shortstwo", "shifts1", "shortstwo", "chports6", "shorttwo", "shportsTwo", "shorters1", "shresses0", "short2", "shports2", "shorters2", "shports52", "horts1", "shortertwo", "shordsTwo", "shords4", "shiftstwo", "shirts52", "shords2", "hort02", "swirts2", "shorts52", "shresses4", "shresses22", "shports02", "shports6", " short1", "short02", "horts4", "chports1", "shports1", "shops2", "shorters4", "horts02", "shorts0", "chorts0", "shords52", "swortsTwo", "shports22", "short4", "sworts4", "swirts52", "shorters6", "hort1", " shortTwo", "chorts1", "swirtsTwo", "shorts6", "chports22", "shorts4", "shiftsTwo", "shirts2", "shports4", "shapes22", "chorts22", " shorttwo"]}}
{"project": "FFmpeg", "commit_id": "199d4478de102ca7987adb97f2e66a1820a98ebd", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n", "idx": 8105, "substitutes": {"avctx": ["evconn", "ajconv", "avalcomponent", "avecu", "avetx", "avconfig", "maccf", "afctx", "avalscope", "afci", "ajcontext", "avtx", "afcomponent", "AVconn", "ajctl", "navctx", "avalctx", "avecomponent", "avsc", "avescope", "navsc", "afcmp", "aveqa", "avelc", "afconv", "avecontext", "afsc", "afscope", "navcu", "ajqa", "afconn", "afcn", "afcu", "avcomponent", "aveci", "evctx", "AVcu", " avsc", "AVctx", "navcn", "afctl", "aflc", "evcontext", "avci", "AVcmp", "aveconfig", "navcmp", "avcontext", "avectl", "aveconn", "navcontext", "abcf", "avconn", "vertx", "avcn", "avsys", "maccontext", "avecmp", "aucontext", "auci", "attcf", "ajconfig", "avxc", "ajconn", " avcn", "AVcontext", "abcontext", "auxc", "avalcmp", "afcf", "avcmp", "attcontext", "aveconv", "afqa", "verctx", "attctx", "avconv", "afsys", "avqa", "AVcf", "avalconn", "avscope", "verxc", "auctx", "avalcontext", "avcu", "vercontext", "aulc", "afconfig", " avcontext", "avecf", "navcf", "afxc", "avctl", "ajcu", "avcf", "ausys", "macconn", "afcontext", "avlc", "attcmp", "autx", "abctx", "evcmp", "avesys", "macctx", "avectx", "aftx", "ajctx", "abcmp"], "f": ["form", "fn", "fa", "frame", "k", "ref", "j", "e", "bf", "d", "fx", "fi", "fe", "rf", "df", "flow", "h", "F", "framework", "u", "sf", "fw", "fb", "file", "l", "n", "per", "fd", "m", "c", "t", "fen", "fs", "g", "parent", "i", "fc", "info", "cf", "fr", "lf", "ff", "z", "b", "fac", "tf", "q", "fp", "conf", "feed", "v", "fl", "x"], "p": ["py", "pb", "br", "y", "pi", "pc", "np", "k", "php", "proc", "pre", "j", "vp", "e", "d", "param", "exec", "tp", "op", "api", "client", "h", "up", "r", "patch", "this", "u", "pa", "sp", "plugin", "P", "per", "jp", "n", "ip", "l", "ap", "s", "c", "m", "t", "ctx", "pm", "g", "pp", "point", "wp", "a", "part", "parent", "cache", "i", "o", "lp", "pe", "bp", "b", "post", "q", "fp", "cp", "v", "port"], "progress": ["complete", "data", "scope", "depth", "push", "callback", "dist", "area", "scale", "diff", "error", "success", "queue", "result", "exec", "track", "cli", "grade", "debug", "done", "move", "flow", "history", "order", "resource", "imp", "patch", "resp", "id", "stage", "dim", "asc", "press", "activity", "mode", "content", "step", "next", "act", "path", "range", "max", "qa", "feat", "cache", "parent", "xp", "recent", "gr", "desc", "Progress", "process", "status", "wait", "cmp", "update"], "err": ["msg", "br", "y", "rc", "diff", "error", "result", "pre", "e", "bar", "exc", " error", "er", "str", "nil", "grade", "arr", "orig", "rh", "h", "ace", "test", "order", "bug", "phi", "resp", "ch", "r", "out", "inner", "runner", "acer", "ind", "rr", "ctr", "l", "n", "res", "id", "var", "lr", "c", "mr", "all", "cr", "comment", "or", "rage", "req", "Error", "cache", "i", "dev", "fee", "fr", "code", "dr", "gr", "attr", "in", "iter", "cb", "errors", "status", "count", "raise"]}}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "substitutes": {"task": ["tag", "complete", "scope", "worker", "tile", "object", "target", "result", "theme", "error", "Task", "slave", "message", "exec", "tty", "command", "event", "call", "game", "rule", "type", "app", "kick", "test", "clean", "module", "ack", "patch", "config", "this", "empty", "device", "ask", "tx", "contract", "load", "instance", "content", "source", "master", "parent", "project", "item", "level", "pack", "asks", "process", "resource", "work", "thread"], "errp": ["irp", "erP", "erp", "resultps", "errP", "resultP", "ercp", " errvp", "erps", "errps", " errcp", "errcp", "resultcp", "rps", "rP", "irps", "rp", " errP", "errvp", "rvp", "resultp", "irvp", "irP", " errps"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n", "idx": 8112, "substitutes": {"s": ["sq", "e", "sb", "sys", "p", "spec", "ks", "ls", "S", "is", "ps", "sc", "ses", "qs", "cs", "sets", "gs", "ds", "xs", "n", "l", "ops", "ss", "sg", "ts", "services", "t", "ctx", "sym", "css", "fs", "f", "ns", "ssl", "o", "sis", "js", "su", "es", "b", "bs", "v", "rs", "si"], "c": ["uc", "pc", "k", "e", "d", "co", "cc", "p", "ce", "oc", "h", "conn", "cm", "cs", "ch", "acs", "u", "config", "n", "ic", "l", "t", "ctx", "dc", "cr", "bc", "g", "f", "mc", "cl", "ec", "cu", "o", "cf", "ca", "C", "tc", "ci", "lc", "cd", "ac", "b", "vc", "con", "cp"], "i": ["ui", "bi", "y", "index", "pi", "k", "di", "e", "d", "si", "ik", "ti", "p", "yi", "h", "mi", "qi", "ii", "r", "hi", "ki", "u", "ji", "ind", "id", "n", "l", "ni", "ip", "ori", "ix", "oi", "f", "zi", "io", "ri", "ini", "info", "o", "gi", "it", "xi", "eni", "ci", "z", "b", "iu", "I", "ai", "v", "x", "li"], "j": ["bi", "br", "y", "k", "aj", "e", "d", "key", "jc", "p", "bj", "jl", "ij", "qi", "pr", "ii", "u", "off", "ji", "dj", "je", "n", "jp", "l", "jo", "m", "t", "dy", "g", "f", "ja", "kj", "jet", "uj", "a", "el", "jen", "json", "o", "it", "err", "xi", "x", "fr", "w", "job", "z", "js", "b", "adj", "q", "oj", "v", "J", "jj", "li"], "os": ["mos", "pos", "options", "ou", "object", "oa", "ans", "rss", "e", "oses", "so", "Os", "op", "bos", "p", "sys", "ks", "aos", "ol", "ls", "of", "oc", "is", "org", "vs", "oes", "cs", "dos", "acs", "ros", "u", "ds", "et", "oS", "iso", "obj", "ops", "nos", "osa", "css", "obs", "des", "fs", "oi", "ns", "mot", "io", "as", "OS", "or", "us", "ow", "o", "oos", "ols", "osi", "js", "es", "ot", "ok", "los", "po", "bs", "oss", "oid"]}}
{"project": "FFmpeg", "commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "target": 1, "func": "yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n", "idx": 8124, "substitutes": {"buf0": ["ufk", "bag1", "uf1", "buf50", "buf2", "bufk", " buf50", "buff0", "buff250", " bufk", "buff2", "uf2", "bag250", " buf2", "uf0", "uf50", "buf250", "buff50", "buffk", "bag0", "uf250", "buff1"], "buf1": ["bufn", "aucn", "auc11", "buf11", "uf1", "buffn", "auc1", "buf2", " bufOne", "auc0", "cfOne", "cf1", "buff0", "uf2", "bufOne", "ufOne", " buf2", "uf0", "cf2", "uf11", "ufn", "buff11", "buff1"], "abuf0": ["abef1", "abbuff3", "abbuf1", "abef3", "abbuff2", "abbuf0", "fabef3", "abuff1", "abbuf5", "bbuf1", "abuf5", "buf2", "abuf3", "abbuff0", "bbuf0", "fabuf0", "abef0", "bbuf2", "fabuf3", "abuff2", "abuf2", "fabuf1", "abbuf2", "abuff5", "abbuf3", "bbuf5", "fabef1", "buf5", "abuff0", "fabef0", "abbuff5", "abbuff1"], "abuf1": ["abbuf1", "buf100", "abbufn", "ebbuff0", "abbuf0", "ebbuffn", "abuff1", "abuch100", "bbuf100", "abaf0", "bbuf1", "buf2", "abbuff0", "bbuf0", "abuf100", "abafn", "bbuf2", "abuff2", "abuch0", "abbuf100", "abuch1", "abuf2", "abbuf2", "ebuf1", "abbuffn", "ebbuff1", "abufn", "abaf1", "abuff0", "abuff100", "ebuf0", "abuch2", "ebufn", "abbuff1"], "i": ["bi", "index", "pi", "d", "multi", "ti", "slice", "type", "qi", "inner", "id", "ip", "init", "f", "zi", "my", "mu", "uri", "b", "in", "v", "li", "ui", "k", "ie", "\u0438", "key", "cli", "h", "module", "ii", "r", "u", "t", "ix", "start", "a", "ini", "part", "w", "isi", "iu", "ai", "p", "mi", "adi", "line", "n", "c", "oi", "g", "io", "it", "gi", "I", "si", "x", "y", "j", "di", "field", "e", "fi", "is", "phi", "anti", "chi", "l", "ni", "m", "source", "info", "o", "xi", "eni", "ci", "z"], "A": ["SA", "O", "B", "AA", "TA", "Ang", "AC", "NA", "Ac", "Offset", "An", "AM", "BA", "AP", "W", "S", "D", "K", "Am", "F", "AY", "P", "LA", "MA", "As", "AI", "U", "CA", "Z", "E", "alpha", "HA", "V", "L", "IA", "mA", "API", "Y", "a", "Q", "N", "R", "GA", "Ca", "C", "M", "H", "G", "ACA", "Alpha", "I", "AF", "AS", "T", "X"]}}
{"project": "qemu", "commit_id": "f7b879e072ae6839b1b1d1312f48fa7f256397e2", "target": 1, "func": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n", "idx": 8130, "substitutes": {"obj": ["data", "pos", "ex", "object", "j", "db", "att", "coll", "self", "dom", "api", "org", "conn", "module", "bot", "cmd", "id", "jp", "bo", "ob", "ops", "instance", "ctx", "tmp", "boot", "nb", "pt", "act", "prop", "inst", "Obj", "parent", "cache", "o", "nt", "objects", "js", "node", "b", "cb", "po", "os", "conf"], "dev": ["dn", "Dev", "dist", "od", "d", "debug", "kick", "die", "device", "off", "id", "prov", "hw", "der", "ver", "dm", "conf", "v", "wd", "data", "new", "object", "diff", "db", "DEV", "app", "test", "bug", " device", "dc", "mod", "w", "cd", "valid", "driver", "av", "oy", "pub", "de", "rad", "self", "dom", "conn", "plug", "block", "child", "var", "gd", "g", "comment", "ad", "del", "end", "def", "fail", "di", "error", "adv", "ve", "event", "client", "ch", "ev", "ds", "dd", "gh", "err", "info", "user", "md", "sd", "node", "priv", "dem", "gu"], "bus": ["object", "dir", "Bus", "proc", "db", "coll", "hub", "controller", "val", "stick", "sync", "session", "usa", "bridge", "bug", "ch", "unit", "lib", "id", "tx", "plug", "block", "ass", "child", "home", "cart", "boot", "bc", "host", "f", "usb", "book", "io", "pass", "cat", "us", "serial", "mount", "parent", "cache", "BUS", "front", "state", "board", "store", "bs", "lock", "driver", "pull", "base"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n", "idx": 8134, "substitutes": {"value": ["data", "depth", "object", "index", "number", "scale", "end", "error", "name", "element", "result", "message", "key", "val", "variable", "rule", "function", "type", "bit", "style", "values", "image", "option", "block", "word", "Value", "VALUE", "mode", "weight", "enabled", "source", "comment", "start", "parent", "reference", "media", "w", "size", "prefix", "fee", "job", "valid", "state", "null", "b", "feature", "unit", "v", "base"], "qb": ["qabase", " qbb", "sqfb", "iqxb", "Qf", "dqba", "Qbb", "qlb", "iqba", " qB", "Qrb", "qubb", " qrb", "qxb", "iqbb", "eqb", "sqbs", "qB", "qbe", "sqB", "Qb", " qbs", "qulb", " qcb", " qfb", " qbe", "iqb", "qcb", "sqb", "dqb", "qacb", "sqbb", " qlb", "QB", "qbs", "querybe", "eqbi", "qabe", "qubi", "quf", " qf", "quba", " qbi", "eqbb", "queryb", "qfb", "qub", "qbb", "dqbb", "qufb", "qbi", "querybase", "sqrb", "qbase", "quxb", "Qbs", "qab", "eqlb", "dqxb", "qrb", "qf", "querycb", "qba", " qbase", "Qfb"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n", "idx": 8145, "substitutes": {"usig": ["usiger", " usigs", "usesigh", "usigen", "usesiger", " usigen", "rusig", " usigma", "versigs", "usesigs", "rusigh", "versiger", " usigh", "rusigen", " usiger", "usigs", "versigma", "usesig", "usigh", "usesigen", "rusiger", "usesigma", "usigma", "versig"], "ka": ["context", "che", "ada", "da", "oa", "sea", "au", "aka", "ae", "na", "ea", "KA", "ko", "sc", "qua", "ku", "channel", "ki", "ua", "jam", "config", "market", "ker", "ba", "ctx", "ta", "kee", "ema", "wa", "sa", "ja", "java", "a", "qa", "en", "ma", "fram", "ca", "ga", "eni", "la", "ket", "ra", "ia", "oka", "ama", "ok", "ya", "ke", "ai", "ha"], "info": ["py", "ui", " inf", "index", "area", "diff", "error", "loc", "name", "si", "fo", "fi", "where", "api", "isu", "mi", "conn", "isf", "image", "ii", "hi", "config", "information", "INFO", "stat", "id", "Info", "iso", "inf", "abi", "txt", "init", "inter", "raf", "summary", "f", "start", "ir", "conf", "ini", "i", "uri", "code", "ci", "desc", "alias", "setup", "http", "ai", "util", "ret"], "set": ["context", "ex", "reset", "end", "section", "sche", "e", "build", "get", "clear", "vert", "exec", "export", "call", "sys", "base", "is", "sc", "site", "ne", "config", "use", "sets", "ch", "stat", "ind", "et", "sem", "Set", "ut", "block", "c", "sh", "init", "setting", "net", " en", "not", "run", "act", "parse", "start", "kit", "en", "SET", "ec", "settings", "se", "see", "match", "state", "gen", "setup", "chain", "send", "sel", "update", "spec", "dat"], "env": ["context", "scope", "ext", "vm", "eu", "np", "end", "ner", "db", "e", "enc", "exc", "vert", "equ", "core", "export", "ea", "ey", "dt", "que", "server", "org", "conn", "inc", "ep", "ne", "ev", "config", "viron", "dict", "et", "ind", "ef", "obj", "enable", "net", "her", "eng", "init", "fen", " en", "ctx", "act", "chn", "Environment", "osc", "ec", "en", "req", "ini", "el", "ette", "cv", "dev", "manager", "inet", "eni", "me", "state", "qt", "esi", "ect", "enos", "conf", "v", "environment", "dat"], "frame": ["sample", "scale", "result", "element", "build", "que", "slice", "coe", "iframe", "processor", "runner", "file", "sequence", "init", "fire", "f", "el", "cast", "cf", "row", "lock", "thread", "raise", "context", "data", "object", "zone", "db", "view", "show", "message", "trace", "call", "channel", "module", "position", "config", "ind", "fake", "plane", "load", "run", "layer", "parse", "part", "ise", "za", "fram", "fr", "code", "role", "driver", "base", "flo", "profile", "sche", "frames", "component", "game", "connection", "session", "flow", "style", "image", "ze", "line", "block", "motion", "cpu", "state", "fact", "feature", "ke", "scope", "cfg", "figure", "error", "e", "core", "fi", "fe", "event", "function", "fb", "class", "version", "ctx", "boot", "force", "point", "Frame", "invoke", "fc", "err", "node", "setup", "framework", "update"]}}
{"project": "qemu", "commit_id": "25e6a11832bcd0715068f0cc24fb46ec03de676e", "target": 1, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio,\n\n                                hwaddr *mmio32, hwaddr *mmio64,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    /*\n\n     * New-style PHB window placement.\n\n     *\n\n     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window\n\n     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO\n\n     * windows.\n\n     *\n\n     * Some guest kernels can't work with MMIO windows above 1<<46\n\n     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB\n\n     *\n\n     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each\n\n     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the\n\n     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the\n\n     * 1TiB 64-bit MMIO windows for each PHB.\n\n     */\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const int max_phbs =\n\n        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;\n\n    int i;\n\n\n\n    /* Sanity check natural alignments */\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);\n\n    /* Sanity check bounds */\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);\n\n\n\n    if (index >= max_phbs) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_phbs - 1);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;\n\n    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;\n\n    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;\n\n}\n", "idx": 8154, "substitutes": {"spapr": ["spampr", "Spapro", "spAPrc", "spapsr", "spamprc", "spampro", "spaprc", "spapsrc", "spAPro", "Spapr", "spapsro", "spAPr", "spAPrs", "SpAPro", "SpAPr", "SpAPrc", "spapsrs", "Spaprs", "spaprs", "SpAPrs", "spapro", "spamprs", "Spaprc"], "index": ["batch", "context", "header", "end", "number", "diff", "name", "input", "value", "example", "key", "xxxx", "multi", "connection", "slice", "expression", "style", "search", "type", "num", "bridge", "image", "offset", "position", "inc", "Index", "config", "old", "fff", "inner", "ind", "id", "pattern", "ion", "all", "version", "weight", "address", "condition", "pointer", "path", "alpha", "ix", "f", "action", "start", "partial", "cache", "prefix", "x", "match", "original", "size", "length", "append", "find", "integer", "base"], "buid": ["basid", "buID", "bufids", "basID", "uuId", "bufID", " buID", "buids", "basids", "uuids", "uuid", "uuID", " buids", "bufid", "buId", "bufId", " buId"], "pio": [" pIO", "Pios", "lpio", "Pci", "mpix", "cpIO", "PIO", "mpio", "lpios", " pios", "pci", "cpio", "cpios", "pios", "Pio", "lpIO", "mpios", "cpci", " pix", "pIO", "lpci", "cpix", "pix", "mpIO"], "mmio32": ["mmtu40", "mmtu64", "mmdi32", "mmdi64", "mmdi40", "mlui82", "mmui40", "mmdi82", "mlio40", "mmio40", "mlio82", "mlui32", "mmui82", "mmui64", "mlio32", "mlui64", "mlio64", "mmui32", "mmio82", "mmtu82", "mlui40", "mmtu32"], "mmio64": ["mpui32", "mmui864", "mmIO32", "mmios128", "mmIO64", "mpio32", "mpio864", "mmio128", "mmios864", "mmio864", "mpui864", "mpio64", "mmui64", "mmios64", "mmIO864", "mmui32", "mmIO128", "mpio128", "mmui128", "mpui64", "mpui128", "mmios32"], "n_dma": ["n_dla", "n_Dmas", "n_lta", "n_dsta", "n_lmas", "n_Dma", "n_sdda", "n_dda", "n_Dda", "n_dsla", "n_dsmas", "n_sdwa", "n_sdma", "n_dsma", "n_Dwa", "n_lma", "n_lla", "n_sdmas", "n_dmas", "n_dwa", "n_dta"], "liobns": ["liibn", "liabcs", "cliobn", "cliobnames", "liObnames", "liobnas", "liabNs", "lobns", "liObns", "liobnames", "liabnas", "liabns", "liObn", "liOBns", "liobNs", "liOBn", "liObNs", "cliObns", "liOBcs", "liobn", "liibcs", "liOBnames", "lObnas", "lobnas", "liobcs", "liOBNs", "liObcs", "lObcs", "cliObn", "lObNs", "lobcs", "cliObcs", "liOBnas", "liibns", "lobNs", "cliobns", "cliObnames", "liObnas", "cliobcs", "liibnames", "lObns"], "errp": ["errf", "aerP", "errpb", "erP", " errpb", " errfp", "Erfp", "erp", "errP", "ErP", "Erf", "aerpb", "aerp", "aerfp", "erfp", " errP", "errfp", "erf", "erpb", "Erp", " errf"], "i": ["bi", "ui", "split", "y", "pi", "end", "j", "di", "si", "d", "e", "mini", "multi", "fi", "ti", "p", "yi", "uli", "slice", "mi", "phi", "qi", "ii", "u", "ji", "ind", "id", "n", "ni", "l", "ip", "c", "init", "ix", "f", "zi", "start", "ri", "ini", "info", "o", "gi", "mu", "xi", "it", "uri", "ci", "eni", "z", "iu", "count", "I", "ai", "v", "x", "li"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)\n\n{\n\n    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;\n\n    uint32_t UART0_clk, UART1_clk;\n\n    uint64_t VCO_out, PLL_out;\n\n    int M, D;\n\n\n\n    VCO_out = 0;\n\n    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {\n\n        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FBMUL %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 20) & 0xF, M);\n\n#endif\n\n        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FWDA %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 16) & 0x7, D);\n\n#endif\n\n        VCO_out = cpc->sysclk * M * D;\n\n        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {\n\n            /* Error - unlock the PLL */\n\n            printf(\"VCO out of range %\" PRIu64 \"\\n\", VCO_out);\n\n#if 0\n\n            cpc->pllmr[1] &= ~0x80000000;\n\n            goto pll_bypass;\n\n#endif\n\n        }\n\n        PLL_out = VCO_out / D;\n\n        /* Pretend the PLL is locked */\n\n        cpc->boot |= 0x00000001;\n\n    } else {\n\n#if 0\n\n    pll_bypass:\n\n#endif\n\n        PLL_out = cpc->sysclk;\n\n        if (cpc->pllmr[1] & 0x40000000) {\n\n            /* Pretend the PLL is not locked */\n\n            cpc->boot &= ~0x00000001;\n\n        }\n\n    }\n\n    /* Now, compute all other clocks */\n\n    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CCDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 20) & 0x3, D);\n\n#endif\n\n    CPU_clk = PLL_out / D;\n\n    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CBDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 16) & 0x3, D);\n\n#endif\n\n    PLB_clk = CPU_clk / D;\n\n    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"OPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 12) & 0x3, D);\n\n#endif\n\n    OPB_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"EPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 8) & 0x3, D);\n\n#endif\n\n    EBC_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"MPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 4) & 0x3, D);\n\n#endif\n\n    MAL_clk = PLB_clk / D;\n\n    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"PPDV %01\" PRIx32 \" %d\\n\", cpc->pllmr[0] & 0x3, D);\n\n#endif\n\n    PCI_clk = PLB_clk / D;\n\n    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U0DIV %01\" PRIx32 \" %d\\n\", cpc->ucr & 0x7F, D);\n\n#endif\n\n    UART0_clk = PLL_out / D;\n\n    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U1DIV %01\" PRIx32 \" %d\\n\", (cpc->ucr >> 8) & 0x7F, D);\n\n#endif\n\n    UART1_clk = PLL_out / D;\n\n#ifdef DEBUG_CLOCKS\n\n    printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64\n\n           \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCO_out, PLL_out);\n\n    printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32\n\n           \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32\n\n           \" UART1 %\" PRIu32 \"\\n\",\n\n           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,\n\n           UART0_clk, UART1_clk);\n\n#endif\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);\n\n    /* Setup MAL clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);\n\n    /* Setup PCI clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);\n\n    /* Setup UART0 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);\n\n    /* Setup UART1 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);\n\n}\n", "idx": 8155, "substitutes": {"cpc": ["cppsc", "CPrc", "cpm", "ppct", "pc", "hopxc", "tpl", "cppcc", "ppxc", "pkgbc", "mpc", "CPc", "wpk", " cpcs", "pgcs", "eppc", " cpl", "pkgci", "cpcr", "ppce", "skm", "copm", "copc", "hope", "pgbc", "cpsc", "gpc", "ppm", "tpf", "arprc", "pgcr", "pgrec", "cpcf", "tpnc", "ppx", "pkgconfig", "psl", "pkgc", "cppec", "ppb", "skdc", "cppcf", "cmpe", "pprc", "skb", "cppx", "pb", "cpfc", "ppl", "CPfc", "wpc", "pkgl", "gpcc", "cpce", "cpbc", "mprc", "appdc", "mpct", "arprec", "pgpc", "ppnc", "skec", "arpfc", "privcf", "cmpxc", "ppsc", "skc", "wpcs", "cpcc", "cpci", "cmpc", "ppci", "cppdc", "cmpct", "ppcs", "cpf", "cpcs", "pkgcf", "cpe", "copcs", "privx", "pkgcs", "cpct", "pgc", "cppl", "ppf", "hopc", "pkgrec", "cpk", "hopct", "pgconfig", "tpc", "cppcache", " cpbc", "pkgct", "cpspec", "CPrec", "epcs", "epce", "pkgrc", "sksc", " cpnc", "ppcc", "copsc", " cpci", "pgcf", "pprec", "ppcf", "cpb", "psbc", "mpci", "cpx", "arpc", "mpl", "copcr", "pgl", "appec", "copl", "cpec", "pppc", "mpcs", "ppbc", "gpcache", "psc", "pscs", "pgce", "ppe", "cpnc", "pce", " cpf", "cprc", "pgspec", " cprc", "cprec", "epc", "pgk", "appsc", "copk", "ppc", "pgci", "skce", "pkgfc", "cppm", " cpconfig", "privc", "cpcache", "cpl", "gpspec", "pgcache", "pm", "appc", "wpcr", "pgcc", "cppc", "cppspec", "privcc", "cpconfig", "cpxc", "cpdc"], "CPU_clk": ["CPU_clck", "CPU_logks", "CPU_plkt", "CPU_logk", "CPU_clkt", "CPU_plk", "CPU_logkt", "CPU_logck", "CPU_CLks", "CPU_plck", "CPU_CLkt", "CPU_CLk", "CPU_plks", "CPU_clks", "CPU_CLck"], "PLB_clk": ["PLB_CLck", "PLB_clck", "PLB_plks", "PLB_CLk", "PLB_wlks", "PLB_clause", "PLB_plck", "PLB_wlk", "PLB_plk", "PLB_CLks", "PLB_wlck", "PLB_CLause", "PLB_clks", "PLB_wlause", "PLB_plause"], "OPB_clk": ["OPB_clck", "OPB_plk", "OPB_colk", "OPB_plq", "OPB_Clk", "OPB_Clq", "OPB_Clck", "OPB_colck", "OPB_colq", "OPB_clq", "OPB_clf", "OPB_plck", "OPB_plf", "OPB_colf", "OPB_Clf"], "EBC_clk": ["EBC_plk", "EBC_clky", "EBC_licK", "EBC_rlky", "EBC_clck", "EBC_plck", "EBC_lick", "EBC_rlK", "EBC_plK", "EBC_clK", "EBC_licck", "EBC_plky", "EBC_licky", "EBC_rlk", "EBC_rlck"], "MAL_clk": ["AMD_clk", "AMD_plk", "AMD_licck", "AMD_blk", "AMD_plok", "AMD_clck", "AMD_blok", "AMD_clke", "AMD_blck", "AMD_licke", "AMD_plck", "AMD_plke", "AMD_licok", "AMD_clok", "AMD_blke", "AMD_lick"], "PCI_clk": ["PCI_clker", "PCI_plker", "PCI_hlker", "PCI_clok", "PCI_clck", "PCI_blck", "PCI_blok", "PCI_blk", "PCI_blker", "PCI_hlok", "PCI_hlck", "PCI_plck", "PCI_hlk", "PCI_plk", "PCI_plok"], "UART0_clk": ["UART0_blok", "UART0_blks", "UART0_CLks", "UART0_plok", "UART0_CLck", "UART0_CLok", "UART0_plk", "UART0_plks", "UART0_blck", "UART0_CLk", "UART0_plck", "UART0_blk", "UART0_clck", "UART0_clks", "UART0_clok"], "UART1_clk": ["UART1_allK", "UART1_clks", "UART1_plks", "UART1_blks", "UART1_blk", "UART1_plK", "UART1_plok", "UART1_allk", "UART1_plk", "UART1_blK", "UART1_clK", "UART1_clok", "UART1_allok", "UART1_blok", "UART1_allks"], "VCO_out": ["VCO64new", "VCO_output", "VGO_m", "VGO_new", "VCE_id", "VCO_OUT", "VCL_copy", "VCO_id", "VCO_result", "VCO_Out", "VCE_out", "VCOLogin", "VCL_out", "VCL_again", "VGO_Out", "VCO__in", "VCO_new", "VCOLogresult", "VCOLogout", "VCO64OUT", "VGO_n", "VCO__out", "VCO_size", "VGO_OUT", "VCE_output", "VGO_error", "VCO__id", "VCO64out", "VCO_error", "VCL_in", "VCE_OUT", "VCE_size", "VCO_again", "VCO__output", "VCO_m", "VCO_copy", "VCOLogerror", "VCO_n", "VGO_result", "VCOxin", "VCOxn", "VCOxm", "VGO_out", "VCE_in", "VCOxout", "VCO_in", "VCO64in", "VGO_in"], "PLL_out": ["PCL_version", "PLS_out", "PCL_out", "PLLFileOut", "PLL_OUT", "PLL_version", "PCL_in", "PLL_error", "PLLFileboot", "PCL_Out", "PCL_boot", "PLS_in", "PLL_Out", "PLLFileout", "PLL_in", "PLL_boot", "PLS_error", "PLS_OUT"], "M": ["LM", "O", "MN", "MX", "B", "A", "DM", "T", "W", "MU", "MON", "S", "K", "MT", "F", "MM", "P", "MA", "U", "MI", "m", "ID", "Z", "L", "E", "V", "Y", "R", "Q", "N", "DI", "C", "H", "NM", "MF", "G", "RM", "I", "MD", "J", "X"], "D": ["DH", "O", "JD", "B", "d", "A", "DM", "T", "W", "DOM", "S", "K", "LD", "F", "DB", "ENT", "DIR", "P", "DT", "DD", "DA", "DS", "U", "Do", "DL", "Z", "E", "L", "V", "DO", "Y", "Q", "R", "N", "DI", "DX", "C", "H", "DF", "DC", "G", "Ds", "I", "MD", "J", "X"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "av_cold void ff_wmv2_common_init(Wmv2Context * w){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);\n\n}\n", "idx": 8157, "substitutes": {"w": ["wb", "k", "wcs", "e", "d", "self", "p", "W", "kw", "wo", "u", "fw", "n", "temp", "c", "m", "wal", "eng", "wan", "ctx", "t", "web", "g", "f", "tw", "wa", "wu", "cl", "ow", "wp", "hw", "a", "writer", "we", "iw", "wt", "o", "ww", "wh", "sw", "rw", "ew", "aw", "work", "v", "window", "west"], "s": ["an", "scope", "ages", "y", "sq", "aws", "e", "d", "share", "submit", "sb", "erences", "server", "sys", "p", "sync", "self", "session", "S", "h", "client", "ses", "support", "gs", "service", "sf", "ions", "stats", "n", "request", "ops", "ss", "c", "m", "ts", "t", "services", "sym", "fs", "g", "f", "sup", "ances", "address", "ns", "opt", "a", "ssl", "settings", "i", "sl", "words", "secondary", "sw", "js", "b", "es", "groups", "conf", "south", "si"]}}
{"project": "qemu", "commit_id": "2e50326c44c802ca9b9d591341085e49208927be", "target": 1, "func": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));", "idx": 8158, "substitutes": {"fd": ["func", "form", "fn", "flo", "dir", "proc", "cond", "db", "director", "d", "fed", "fat", "fx", "exec", "fi", "tty", "dt", "draft", "df", "flow", "pid", "FD", "sf", "fw", "pipe", "fb", "file", "temp", "c", "dc", "fs", "f", "pd", "dl", "fc", "lf", "bd", "ff", "md", "sd", "cb", "fp", "stream", "feed", "ctl", "wd", "handler"], "csum": ["chesum", "arssum", "tsume", "chesume", "gsum", "scUM", "cssum", "rsUM", "chesUM", "scum", "rssum", "csumption", "scumb", "tsumption", "rsumb", "csUM", "csume", "csumb", "tsUM", "scsum", "rsum", "arsum", "arsumb", "tsum", "gsumption", "chesumption", "gsUM", "gsume", "arsUM"], "tso4": ["tsa4", "fbo4", "Tso16", "tpo6", "Tsa16", "tso8", "tSo4", "fsc4", "tto16", "Tso8", "tsc16", "Tsa6", "fso16", "tse4", "tse16", "tpo16", "tsa8", "fbo84", "tsc04", "tse04", "tbo4", "fsc04", "tpo8", "Tso4", "tso84", "tbofour", "Tsa8", "fscfour", "ttofour", "fsofour", "tSo84", "tso16", "tsa6", "tsc8", "fso04", "tsefour", "tsc6", "tso04", "tbo84", "tto04", "tto84", "fsc16", "Tsa4", "tpo4", "tsc4", "tsofour", "tscfour", "tSofour", "tto4", "tsa16", "fso4", "fbofour", "fso84", "Tso6"], "tso6": ["tsa4", "tsa76", "tco7", "Tco7", "tbi4", "xto60", "tco4", "tsa3", " tso76", "Tso613", "tao4", "tla4", "xto6", "tbi3", " tla76", "tao7", " tla6", "xso3", "Tco4", "tbo60", " tla4", "tbo4", "Tco6", "tbo3", "Tso4", "tco613", "tsh7", "tao613", "tto3", "tso613", "xso6", "tla6", " tso3", "tsh6", "tsh613", "tto6", "tbi76", "tsa6", "tbi6", "tbo6", "tso60", "xto4", " tla3", "xso4", "tso7", "tla3", "xto3", "tco3", "tco60", "tso76", "tao6", "Tso7", "tso3", "tco6", "tto4", "tto60", "Tco613", "tla76", "xso60", "tsh4", "Tso6"], "ecn": ["escc", "ecb", "ecN", " ecc", "ECl", " ecN", "ecl", "escN", "ECN", "ECn", "ECb", "EcN", "escb", "Ecn", "Ecb", "ecc", "ECc", " ecb", "escn", " ecl", "Ecl"], "ufo": ["ffon", "umo", "ufO", "efos", "ffO", "umO", "ufos", "uppoo", "umos", "ufoo", "ufon", "uppo", "efoo", "ufd", "uppO", "uchos", "ffoo", "uppon", "uchd", "efon", "efO", "uchO", "ucho", "umd", "efd", "ffo", "efo"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_mpeg1_encode_init(MpegEncContext *s)\n\n{\n\n    static int done=0;\n\n\n\n    common_init(s);\n\n\n\n    if(!done){\n\n        int f_code;\n\n        int mv;\n\n\tint i;\n\n\n\n        done=1;\n\n        init_rl(&rl_mpeg1);\n\n\n\n\tfor(i=0; i<64; i++)\n\n\t{\n\n\t\tmpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];\n\n\t\tmpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];\n\n\t}\n\n        \n\n        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);\n\n\n\n\t/* build unified dc encoding tables */\n\n\tfor(i=-255; i<256; i++)\n\n\t{\n\n\t\tint adiff, index;\n\n\t\tint bits, code;\n\n\t\tint diff=i;\n\n\n\n\t\tadiff = ABS(diff);\n\n\t\tif(diff<0) diff--;\n\n\t\tindex = av_log2(2*adiff);\n\n\n\n\t\tbits= vlc_dc_lum_bits[index] + index;\n\n\t\tcode= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_lum_dc_uni[i+255]= bits + (code<<8);\n\n\t\t\n\n\t\tbits= vlc_dc_chroma_bits[index] + index;\n\n\t\tcode= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_chr_dc_uni[i+255]= bits + (code<<8);\n\n\t}\n\n\n\n        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );\n\n\n\n        for(f_code=1; f_code<=MAX_FCODE; f_code++){\n\n            for(mv=-MAX_MV; mv<=MAX_MV; mv++){\n\n                int len;\n\n\n\n                if(mv==0) len= mbMotionVectorTable[0][1];\n\n                else{\n\n                    int val, bit_size, range, code;\n\n\n\n                    bit_size = f_code - 1;\n\n                    range = 1 << bit_size;\n\n\n\n                    val=mv;\n\n                    if (val < 0) \n\n                        val = -val;\n\n                    val--;\n\n                    code = (val >> bit_size) + 1;\n\n                    if(code<17){\n\n                        len= mbMotionVectorTable[code][1] + 1 + bit_size;\n\n                    }else{\n\n                        len= mbMotionVectorTable[16][1] + 2 + bit_size;\n\n                    }\n\n                }\n\n\n\n                mv_penalty[f_code][mv+MAX_MV]= len;\n\n            }\n\n        }\n\n        \n\n\n\n        for(f_code=MAX_FCODE; f_code>0; f_code--){\n\n            for(mv=-(8<<f_code); mv<(8<<f_code); mv++){\n\n                fcode_tab[mv+MAX_MV]= f_code;\n\n            }\n\n        }\n\n    }\n\n    s->me.mv_penalty= mv_penalty;\n\n    s->fcode_tab= fcode_tab;\n\n    if(s->codec_id == CODEC_ID_MPEG1VIDEO){\n\n        s->min_qcoeff=-255;\n\n        s->max_qcoeff= 255;\n\n    }else{\n\n        s->min_qcoeff=-2047;\n\n        s->max_qcoeff= 2047;\n\n    }\n\n    s->intra_ac_vlc_length=\n\n    s->inter_ac_vlc_length=\n\n    s->intra_ac_vlc_last_length=\n\n    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;\n\n}\n", "idx": 8169, "substitutes": {"s": ["sq", "caps", "opens", "e", "comments", "sys", "p", "ks", "sports", "ses", "cs", "gs", "sets", "u", "sf", "ds", "ions", "ops", "ss", "c", "sg", "ts", "services", "m", "ns", "ms", "ssl", "settings", "o", "js", "es", "os", "qs", "rs", "si"], "f_code": ["f__code", "df_key", "fckcreate", " f_Code", "f_Code", "fckkey", "f_co", "f_count", " f__Code", "g_cc", "g_mode", "df_zone", "f_codes", "flockcode", "fJcode", "f_key", " f_codes", "df_code", "fckzone", " f_use", "fIPname", "fJuse", "fJCode", "dflockzone", "f__use", "dflockcode", "fIPcodes", "df_create", "fIPcount", "f_name", "dflockcreate", " f__code", "f_zone", "g_code", "f__co", "flockzone", "fJco", "f_create", " f__co", "g_size", "fckcode", "dflockkey", "f__Code", "f_cc", "flockkey", "f_use", "f_size", "fIPcode", "f_mode", "flockcreate", " f__use", " f_name", " f_count", " f_co"], "mv": ["wmf", " mvi", "pb", "mf", "pc", " mV", " mh", "pv", "Mh", "bmv", "Mb", "mb", "Mvc", "dva", "MV", "df", "mva", "mV", "Mf", "wmv", "pf", "bmf", "pvc", "mvi", "bmc", " mb", "Mc", "mc", "dv", "Mva", " mf", "mvc", " mva", "Mv", "dV", "mh", "bmvi", "wmh", " mvc", "wmV", " mc", "Mvi"], "i": ["bi", "pi", "name", "d", "multi", "ti", "api", "slice", "type", "site", "qi", "hi", "inner", "id", "ip", "dim", "init", "ori", "f", "zi", "mu", "uri", "b", "in", "v", "li", "ui", "ie", "mini", "key", "cli", "h", "ii", "u", "current", "ji", "ind", "ix", "ini", "iu", "ai", "p", "mi", "image", "ki", "adi", "n", "c", "oi", "io", "it", "gi", "list", "I", "si", "x", "y", "j", "di", "e", "fi", "yi", "is", "phi", "anti", "chi", "l", "ni", "m", "ri", "info", "xi", "ci", "eni", "z", "attr"], "adiff": ["eddx", "madisk", "madiff", "Adiffs", "eddef", " adx", "adIFF", "adison", "madise", "AdIFF", "eddison", "Adiff", "madison", "diffs", "adip", " adise", "ddiff", "adisk", "eddise", "ddiffs", " adison", " adef", "dip", "adx", "eddisk", "madx", "eddiff", "adef", "madef", "dIFF", "adise", "Adip", "adiffs", "ddip", "ddIFF", " adisk"], "index": ["bi", "pos", "area", "name", "element", "example", "mask", "multi", "sync", "slice", "type", "num", "site", "inner", "id", "connect", "init", "draw", "bin", "fix", "count", "unit", "batch", "ref", "input", "key", "none", "design", "offset", "module", "bug", "position", "config", "change", "current", "ind", "ion", "ix", "weight", "page", "start", "ini", "part", "loop", "match", "edge", "pull", "value", "open", "byte", "search", "style", "full", "inc", "patch", "lib", "eight", "inf", "block", "action", "pass", "comment", "qa", "initial", "prefix", "list", "level", "length", "active", "find", "zero", "x", "end", "error", "loc", "e", "success", "fe", "bit", "Index", "version", "source", "cache", "info", "coord", "insert", "ci", "update"], "bits": ["batch", "pins", "classes", "parts", "lines", "frames", "fixes", "amples", "blocks", "details", "ls", "codes", "bit", "bug", "config", "bytes", "lib", "changes", "pieces", "files", "issues", "ops", " bugs", "notes", "cells", "fields", "planes", "checks", "bis", "vals", "cats", "settings", "flags", "points", "its", "words", "ints", "bands", "features", "board", "errors", "bs", "ins", "limits", "lins", "items", "groups", "bugs", "utils", "ips"], "code": ["low", "pos", "text", "name", "example", "hide", "sync", "type", "id", "init", "description", "fix", "count", "message", "co", "key", "call", "test", "bug", "r", "config", "change", "layer", "address", "size", "score", "status", "comp", "url", "value", "component", "codes", "cod", "patch", "use", "line", "block", "content", "all", "g", "comment", "check", "_", "comb", "length", "complete", "error", "loc", "core", "charge", "zip", "bit", "seq", "bytes", "create", "version", "Code", "cache", "info", "ci", "desc"], "diff": ["extra", "data", "pos", "split", "low", "new", "mix", "ref", "dist", "def", "fail", "progress", "error", "scale", "d", "show", "frac", "multi", "hide", "ignore", "none", "changed", "inc", "bug", " difference", " differences", "change", "config", "changes", "patch", "id", "distance", "version", "alpha", "f", "shift", "comment", "qa", "conf", "part", "Diff", "err", "info", "between", "dev", "dust", "desc", "length", "fix", "cmp", "comp", "different", "missing", "count", "iff", "update", "spec"], "len": ["Len", "data", "split", "pre", "loc", "vert", "str", "li", "slice", "lang", "bl", "ann", "seq", "lon", "elt", "lib", "line", "lim", "l", "dim", "dy", "rev", "lit", "en", "el", "bin", "err", "lin", "sl", "la", "span", "valid", "live", "length", "lan", "count", "ln"], "val": ["data", "pos", "split", "conv", "def", "eval", "value", "str", "bl", "seq", "elt", "reg", "dim", "Val", "vol", "rev", "vals", "bin", "VAL", "al", "live", "valid", "sel", "base"], "bit_size": ["bit64count", "bit64size", "bit_scale", "int_size", "bit_sized", "int_count", "bit64sized", "int_scale", "bit64scale", "int_sized", "bit_count"], "range": ["pos", "frame", "end", "scale", "loc", "label", "str", "mask", "arr", "slice", "orig", "seq", "num", "r", "line", "lim", "block", "gap", "rev", "vals", "bin", "err", "feat", "unit", "base"]}}
{"project": "FFmpeg", "commit_id": "c9f6eab184cac379c7a44d5899979165798d45d4", "target": 1, "func": "static av_cold int ac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    AC3DecodeContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    ff_ac3_common_init();\n\n    ac3_tables_init();\n\n    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);\n\n    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);\n\n    ff_kbd_window_init(s->window, 5.0, 256);\n\n    dsputil_init(&s->dsp, avctx);\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    av_lfg_init(&s->dith_state, 0);\n\n\n\n    /* set scale value for float to int16 conversion */\n\n    s->mul_bias = 32767.0f;\n\n\n\n    /* allow downmixing to stereo or mono */\n\n    if (avctx->channels > 0 && avctx->request_channels > 0 &&\n\n            avctx->request_channels < avctx->channels &&\n\n            avctx->request_channels <= 2) {\n\n        avctx->channels = avctx->request_channels;\n\n    }\n\n    s->downmixed = 1;\n\n\n\n    /* allocate context input buffer */\n\n    if (avctx->error_recognition >= FF_ER_CAREFUL) {\n\n        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!s->input_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n    return 0;\n\n}\n", "idx": 8171, "substitutes": {"avctx": ["vercit", "ajcmp", "devctx", "aveca", "avecu", "devcf", "avconfig", "evtx", "verctl", "afctx", "ajvoc", "ajcontext", "avtx", "evcu", "avcmd", "AVconn", "avca", "avalctx", "avalcoll", " avctl", "ajcv", "ajcli", "avcoll", "afcmp", " avsci", " avctr", "afcit", "afsci", "abcu", "afvoc", " avcu", "avecontext", "avcit", "afcoll", "afconn", "Avctx", " avcit", "afcu", "evctx", "AVcu", "AVctx", "akcit", "awctx", "awcontext", "avesci", "afctl", "evcontext", "ajca", " avcv", "avevoc", "AVcmp", "aveconfig", "Avcontext", "akxc", "avcontext", "aveconn", "Avconn", "devcontext", "avsci", "avconn", "ajcit", "ovcu", "abcli", "avecmp", "akctx", "avxc", "ovcontext", "AVcontext", "abcontext", "ajcf", "avalcmp", "afcf", "avcmp", "AVcmd", "AVctl", "verctx", "avcli", "afctr", "afcv", "avecoll", " avcf", "avalconn", "ovtx", "vercontext", "avcu", "afconfig", "vercf", " avcontext", "avecf", "afcli", "avctr", "afxc", "avctl", "ajcu", "ovctx", "avcf", "awcmp", "Avcu", "ajcmd", "afcontext", "vercu", "akcontext", "ajctr", "abctx", "abconfig", "devconfig", "avcv", "awctl", "ajxc", "avectx", "aftx", "afcmd", "avvoc", "afca", "ajctx", "abcmp"], "s": ["data", "storage", "sec", "sq", "aws", "e", "d", "si", "sb", "so", "sys", "self", "p", "sync", "ks", "args", "ls", "session", "S", "h", "ps", "sc", "is", "ses", "qs", "cs", "gs", "this", "u", "service", "ds", "sf", "xs", "sets", "n", "l", "states", "ops", "ss", "c", "sg", "ts", "services", "sym", "ctx", "t", "fs", "g", "f", "ns", "sup", "sa", "a", "ssl", "se", "i", "w", "o", "js", "b", "su", "es", "os", "v", "rs", "utils", "spec"]}}
