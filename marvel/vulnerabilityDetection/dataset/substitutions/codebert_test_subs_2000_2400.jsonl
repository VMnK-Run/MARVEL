{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         void **refcount_table,\n\n                         int64_t *refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k, refcount;\n\n    int ret;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= *refcount_table_size) {\n\n            ret = realloc_refcount_array(s, refcount_table,\n\n                                         refcount_table_size, k + 1);\n\n            if (ret < 0) {\n\n                res->check_errors++;\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        refcount = s->get_refcount(*refcount_table, k);\n\n        if (refcount == s->refcount_max) {\n\n            fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n            fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \"\n\n                    \"width or qemu-img convert to create a clean copy if the \"\n\n                    \"image cannot be opened for writing\\n\");\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n        s->set_refcount(*refcount_table, k, refcount + 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20248, "substitutes": {"bs": ["ins", "abi", "rs", "iss", "aws", "css", "als", "bis", "ds", "ses", "fs", "bl", "b", "ss", "ts", "BS", "ps", "cb", "sb", "bits", "bos", "cs", "ils", "blocks", "bytes", "pb", "qs", "es", "outs", "bc", "gs", "gb", "os", "vs", "ns", "ls", "ms", "js"], "res": ["req", "gr", "def", "resp", "rs", "css", "ex", "Res", "rss", "ras", "rev", "results", "response", "rows", "fs", "ress", "pers", "ros", "ares", "RES", "err", "ps", "cs", "r", "args", "result", "vals", "rem", "rez", "des", "re", "resolution", "obj", "rc", "nos", "ers", "sys", "os", "conf", "rus", "cons", "spec", "ms", "pres", "js"], "refcount_table": ["refcheck_count", "refCount_array", "refcheck_course", "refcount2course", "refCount_TABLE", "refcheck_table", "refCount_range", "refcount2list", "refcount2count", "refcount_list", "refcount_state", "refCount_table", "refCount_total", "refcount_TABLE", "refCount2TABLE", "refcount__TABLE", "refcheck2table", "refcheck_list", "refCount2total", "refCount2array", "refcount_count", "refcheck2count", "refcheck2course", "refcount__total", "refcountPstable", "refcomp_table", "refcount_range", "refcountPrange", "refcount_total", "refcountPtable", "refcount2TABLE", "refcount_stable", "refcount_array", "refcountPTABLE", "refCount_stable", "refcount2table", "refcount2array", "refcount64course", "refcount2total", "refcomp_Table", "refcount64count", "refcheck2list", "refcount_Table", "refcount64table", "refcount__table", "refCount2table", "refcomp_TABLE", "refcount_course", "refcount__array", "refcount64list", "refcomp_state"], "refcount_table_size": ["refcount_window_last", "refcount_table_SIZE", "refcount_cache_max", "refcount_window_capacity", "refcount_table_capacity", "refcount_cache_size", "refcount_table_last", "refcount_table_scale", "refcount_window_size", "refcount_table_max", "refcount_cache_capacity", "refcount_table_small", "refcount_cache_SIZE", "refcount_cache_small", "refcount_cache_scale"], "offset": ["first", "part", "ace", "timeout", "element", "origin", "reset", "starting", "zero", "started", "site", "location", "pointer", "loc", "initialized", "address", "length", "Offset", "extra", "online", "len", "align", "index", "padding", "next", "position", "base", "o", "slot", "entry", "error", "range", "alias", "activity", "limit", "ref", "end", "off", "initial", "pos", "shift", "iterator", "number", "slice", "addr", "edge", "set", "prefix"], "size": ["ey", "timeout", "capacity", "ish", "empty", "p", "en", "sync", "code", "use", "se", "name", "loc", "ce", "address", "length", "extra", "max", "Size", "second", "len", "n", "scale", "SIZE", "c", "send", "storage", "from", "sum", "range", "e", "any", "args", "ize", "value", "grow", "small", "end", "member", "count", "sized", "shift", "form", "score", "sec", "set"], "s": ["south", "p", "less", "us", "se", "f", "si", "a", "sb", "cs", "u", "ops", "tests", "gs", "i", "conf", "plugins", "spec", "sv", "iss", "sa", "ds", "ses", "xs", "is", "b", "ts", "ps", "e", "ing", "blocks", "services", "parts", "ans", "outs", "comments", "os", "rates", "states", "S", "ks", "sym", "bis", "stat", "ions", "stats", "its", "state", "c", "qs", "es", "sys", "server", "sl", "g", "settings", "sets", "sq", "rs", "sync", "http", "fs", "ss", "o", "d", "ssl", "self", "ns", "ls", "js"], "start": ["first", "part", "st", "ace", "ish", "empty", "step", "starting", "p", "sync", "se", "type", "info", "address", "length", "max", "art", "init", "next", "index", "back", "scale", "base", "range", "from", "error", "ind", "old", "min", "pre", "end", "off", "pos", "count", "mid", "shift", "id", "ad", "Start", "work", "grade", "skip", "open", "stop", "set", "op"], "last": ["nd", "first", "full", "st", "ace", "close", "empty", "se", "loc", "low", "j", "length", "ort", "cost", "max", "cur", "so", "next", "scale", "latest", "parent", "base", "range", "from", "since", "ast", "old", "style", "cycle", "prev", "final", "end", "needed", "ending", "small", "bottom", "after", "before", "est", "scope", "count", "total", "no"], "cluster_offset": ["clanch_offset", "clion_location", "clusteringoffset", "clust_offset", "cluster___offset", "clust_slice", "clanch_size", "cluster_slot", "clorumlexpost", "cluster2entry", "clanch___offset", "clusterlexentry", "clusteringsize", "cluster_location", "clust_address", "cluster_name", "cler_offset", "cluster67location", "clusterlexoption", "cluster67slice", "cler_off", "cluster_error", "cluster_slice", "cluster_address", "cluster_off", "cluster_option", "clion67offset", "clusteringslot", "clion67location", "clion67slice", "clusterlexerror", "cler_error", "cluster___size", "clorum_offset", "clorumlexentry", "clause_option", "cluster2name", "clust_index", "cluster67off", "clause_start", "cluster_entry", "clanch___size", "clusterlexoffset", "cluster2offset", "clorum_entry", "clause_error", "clorum_name", "clion67off", "cluster___location", "clusteringlocation", "clanch___location", "cluster2post", "cluster67offset", "cler_start", "clorumlexname", "cluster_start", "clion_offset", "clorumlexoffset", "clanch_slot", "clusterlexstart", "clanch_location", "clusterlexpost", "cluster_size", "cluster___slot", "clion_off", "clion_slice", "cluster_post", "clanch___slot", "clause_offset", "cluster_index", "clusterlexname", "clorum_post"], "k": ["kt", "ok", "ek", "kid", "ks", "x", "p", "j", "f", "max", "q", "ku", "ack", "b", "v", "ki", "kw", "n", "c", "uk", "ke", "ck", "o", "y", "r", "sk", "key", "u", "end", "ka", "d", "kick", "kk", "i", "ik", "id", "m", "work", "kn", "mk", "ko", "g", "z", "K", "it", "wk"], "refcount": ["affsum", " refsum", "affcount", "colcode", "referencecount", "reldepth", " refcheck", "affount", "relCount", "refount", " refref", "compount", " reflen", " refount", "relsum", "arcref", "relcount", "refsum", "colref", "refcheck", "afftype", "refcode", "affCount", "referenceref", " refcode", " refCount", "arccount", "affcheck", "referencecode", "reftype", "compcheck", " refdepth", "refCount", " reftype", "affdepth", "colcount", "compcount", "reflen", "affref", "afflen", "arctype", "refdepth", "refref", "complen"], "ret": ["bit", "part", "att", "iter", "def", "rets", "reset", "en", "lit", "num", "cat", "val", "complete", "rev", " Ret", "length", "f", "det", "fail", "info", "bf", "pass", "RET", "len", "red", "reg", "fun", "cb", "error", "err", "result", "nt", "ref", "ber", "bad", "hard", "url", "rc", "re", "data", "count", "flag", "job", "rf", "obj", "alt", "arg", "rt", "success", "total", "Ret", "pet", "rl", "ext"], "check_errors": ["checking_issues", "checking_errors", "check2issues", "checkuperror", "checkupissues", "checking_details", "checkingupdetails", "check2error", "check2details", "checkingupissues", "checking_error", "check_details", "check_issues", "checkuperrors", "check_error", "checkinguperror", "checkupdetails", "check2errors", "checkinguperrors"], "corruptions": ["corconnectuations", "corruptionions", "corredions", "corredance", "corruption", "corruptionuations", "corconnections", "corruptance", "orruptionion", "orruptance", "corredion", "orruptionions", "orruptionance", "corruptionion", "orruption", "corconnection", "corruptionance", "orruptionuations", "corruptuations", "corconnectance", "orruptions", "orruptuations", "correduations"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n", "idx": 20257, "substitutes": {"opaque": ["ospaque", " opca", "OPaque", "opque", " opque", "opacity", "opca", "oppque", " opace", "Opace", "OPace", "ospque", " opacity", "oppaque", " opaques", "ospca", "opace", "oppca", "OPaques", "Opacity", "OPacity", "Opaque", "Opaques", "opaques"], "addr": ["ace", "x", " address", "src", "p", "host", "pointer", "offset", "ord", "val", "address", "mode", "md", "cmd", "device", "vr", "index", "slot", "alias", "nr", "fd", "ref", "point", "oid", "inter", "port", "layer", "pos", "attr", "rc", "data", "target", "ptr", "id", "dr", "pad", "ad", "mid", "sid", "Address", "node", "ip"], "value": ["values", "write", "image", "version", "reference", "Value", "val", "buffer", "offset", "address", "type", "VALUE", "name", "length", "valid", "wa", "v", "fee", "index", "buf", "scale", "age", "range", "message", "flow", "format", "function", "port", "target", "data", "memory", "id", "number", "array", "server", "set"], "size": ["capacity", "shape", " bytes", "class", "w", "mem", " buffer", "offset", "name", "type", "address", "length", "Size", "len", "SIZE", " length", "fd", "args", "ize", "data", " mem", "bytes"], "backref": ["frontef", "Backref", "Backreference", "backreference", "baseref", "baseREF", "BackRef", " backef", "buffRef", "backef", "backpointer", " backRef", " backpointer", "baseRef", "frontreference", "basepointer", "Backpointer", "frontRef", "buffef", "backREF", " backREF", "frontpointer", "buffref", "backRef", " backreference", "frontref", "BackREF", "buffreference"], "s": ["settings", "states", "S", "sq", "w", "secondary", "src", "p", "h", "sym", "sync", "ses", "f", "is", "b", "ss", "si", "a", "state", "c", "spec", "o", "sb", "e", "r", "l", "session", "u", "source", "d", "ops", "side", "ssl", "ips", "scope", "i", "m", "os", "t", "sf", "socket", "g", "sl", "ns"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "substitutes": {"addr": ["adr", "ace", "kt", "mx", "x", " address", "src", "p", "host", "cpu", "offset", "pointer", "rt", "address", "config", "pc", "device", "align", "index", "ar", "base", "slot", "amd", "ref", "point", "inter", "layer", "target", "attr", "pos", "data", "ptr", "eth", "ad", "arg", "slice", "node", "ld"], "val": ["VAL", "x", "eval", "al", "p", "test", "pid", "mem", "el", "db", "loc", "fail", "valid", "aval", "b", "v", "len", "index", "vol", "bin", "base", "slot", "fl", "pt", "ind", "tx", "py", "pre", "cal", "key", "ee", "vals", "value", "cond", "sel", "ref", "data", "count", "arr", "unit", "arg", "Val", "grad", "lib", "sl", "all"]}}
{"project": "qemu", "commit_id": "9f2130f58d5dd4e1fcb435cca08bf77e7c32e6c6", "target": 0, "func": "static int fb_initialise(struct XenDevice *xendev)\n\n{\n\n    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);\n\n    struct xenfb_page *fb_page;\n\n    int videoram;\n\n    int rc;\n\n\n\n    if (xenstore_read_fe_int(xendev, \"videoram\", &videoram) == -1)\n\n\tvideoram = 0;\n\n\n\n    rc = common_bind(&fb->c);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    fb_page = fb->c.page;\n\n    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,\n\n\t\t\t    fb_page->width, fb_page->height, fb_page->depth,\n\n\t\t\t    fb_page->mem_length, 0, fb_page->line_length);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    rc = xenfb_map_fb(fb);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n#if 0  /* handled in xen_init_display() for now */\n\n    if (!fb->have_console) {\n\n        fb->c.ds = graphic_console_init(xenfb_update,\n\n                                        xenfb_invalidate,\n\n                                        NULL,\n\n                                        NULL,\n\n                                        fb);\n\n        fb->have_console = 1;\n\n    }\n\n#endif\n\n\n\n    if (xenstore_read_fe_int(xendev, \"feature-update\", &fb->feature_update) == -1)\n\n\tfb->feature_update = 0;\n\n    if (fb->feature_update)\n\n\txenstore_write_be_int(xendev, \"request-update\", 1);\n\n\n\n    xen_pv_printf(xendev, 1, \"feature-update=%d, videoram=%d\\n\",\n\n\t\t  fb->feature_update, videoram);\n\n    return 0;\n\n}\n", "idx": 20283, "substitutes": {"xendev": ["xendeva", "xendedov", "inenddev", "exenddev", "xndev", "Xendown", "xendedeva", "xendevice", "xideev", "xentdev", "exndev", "xENDev", "xnddev", "exndem", "xendee", "wxendev", " xendeva", "xstartruction", "xendsdevice", "Xendever", "exendect", "xstarttr", "xstarteva", "xndee", "xENDtr", "xndect", "xideown", " xendedeva", "xendem", "xstartov", "xENDect", "exnddev", "rxenddev", "rxenev", "xstartev", "inENDdev", "wxendevice", "xenderv", "inENDarget", "xenarget", "inENDee", "xendedever", "xopenov", "wxenev", "exendem", "exendev", "wxendew", "xenown", "xstartdev", "xendeddev", "rxendev", "xENDarget", "xendown", "rxenown", "Xestown", "inendee", "xendsev", "xopendev", " xendov", "xideerv", "xendov", "xentown", "xendeddevice", "inENDev", " xendruction", "xentev", "xopenev", "xendedtr", "xendsew", "xenddevice", "exndect", "xenedect", "xENDem", " xendedtr", "Xestev", "xndem", "xenee", "inendev", "Xendev", "xendedown", "xendruction", "xendedew", "xendederv", "xestever", "xendew", "wxenddev", "xenew", "xeneddev", "xenterv", "Xenderv", "xendsdev", "xesterv", " xenddev", "xendarget", "xestown", "xendect", "xENDruction", "xenedem", "xenedev", "xendedruction", " xendedov", "xenev", "xendtr", "wxenew", "wxenddevice", "rxenderv", "xendever", "xestev", " xendedruction", "Xestever", "xendedev", " xendtr", "xenerv", " xendeddev", " xendedev", "xndarget", "Xesterv", "rxendown", "inendarget", "xENDdev", "xopeneva", "rxenerv", "xenddev", "xideever", "xENDee"], "fb": ["lb", "af", "FB", "wb", "bb", "fe", "uber", "buff", "db", "fab", "deb", "xb", "f", "bg", "blog", "fs", "bf", "tf", "b", "fc", "lab", "df", "buf", "fw", "c", "cb", "sb", "bj", "fen", "ab", "mb", "fa", "fd", "tmp", "fp", "pb", "fi", "ff", "raf", "bc", "rf", "kk", "usb", "fx", "abc", "fg", "fn", "facebook", "bs", "eb", "wp", "rb", "fm"], "fb_page": ["fbkedge", "debapppage", "fbidlarge", "fb_site", "facebook_edge", "fb_write", "fbpubview", "fbdbsession", "fbdbco", "fd_config", "fb_account", "fbkpage", "fbidaverage", "deb_session", "fb_pool", "debappstep", "fbdbpage", "fbappco", "fb_edge", "fb_view", "fbapppage", "fb_center", "fbappwrite", "fbpubpool", "fb_average", "facebook_average", "fbappsession", "fb_inc", "facebook_center", "facebook_write", "fbksite", "fab_site", "fbappsite", "fb_step", "fbpubpage", "fb_load", "deb_step", "fb_line", "debappco", "deb_co", "fb_large", "debappsession", "fbdbstep", "facebook_site", "facebook_page", "fbidpage", "fbpubconfig", "fd_page", "fbappstep", "fab_inc", "facebook_load", "fd_pool", "fb_co", "fc_line", "fc_site", "fb_session", "fb_config", "fab_page", "fd_view", "fbkload", "deb_page", "fc_page", "fbidsite", "facebook_large", "fab_account", "fbappcenter"], "videoram": ["videsoriAM", "videaramy", "vendorsab", "vendorsAM", "vantodAM", "videorsAM", "videostama", "vridearample", "vendorAM", "videostample", "videorrab", "vrideorram", "videoream", "videorum", "vendorsam", "videoorample", "vrideorama", "vantoram", "videorableum", "viderorample", "vridearama", "videourac", "videouramd", "videodAM", "videsoriam", "videraram", "vridearam", "videourum", "videorableamd", "videorsam", "viderarample", "videorab", "videsorram", "videoramy", "videostamy", "vantodum", "vrideoram", "videorama", "videorAM", "videooram", "videsorAM", "vantorum", "videodam", "videoreac", "videorrAM", "videoreama", "videaram", "vantorAM", "vantoramd", "vrideorample", "videostam", "videsoram", "videorrac", "videorsab", "vendoram", "videoriram", "videourAM", "videorac", "videarample", "videooramy", "videarram", "videoriac", "videraramy", "vendorsac", "videoorama", "videoriAM", "vantodamd", "vantodam", "videorsac", "videorrama", "videsorac", "videorample", "videoriam", "videorram", "videorrample", "videouram", "videsoriram", "vendorab", "videorsram", "videodamd", "viderarama", "videoreAM", "videoreram", "vendorac", "videorrram", "videourram", "videoreab", "videroram", "videarama", "vridearram", "videsoriac", "videorableam", "videodum", "videorableAM", "videroramy", "videoreample", "videoramd", "viderorama"], "rc": ["dc", "RC", " RC", " sc", "rs", "gc", "src", "hl", "lc", "irm", "ra", "sync", "cc", "core", "co", "ac", "rt", "isc", "ras", "loc", "roc", " rec", "risk", "cur", "pc", "cr", "rx", "irc", "uc", "rh", "sc", "ack", "anc", "ry", "ct", "rb", "gd", "fc", " src", "c", "ck", "cb", "err", "reg", "error", "rr", "sr", "result", "ride", "auc", "rac", "rd", "coll", "rn", "bc", "id", "vc", "dr", "ci", "rw", "sys", "abc", " r", "success", "nc", "ror", "rl", "rec", "rg", "ann"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_exts(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8s_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16s_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32s_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20299, "substitutes": {"ot": ["ocl", "oting", "dt", "rt", "yt", "oy", "ort", "oi", "cot", "art", "pot", "ut", "oc", "ots", "otype", "gt", "oter", "iot", "rot", "pol", "o", "pt", "prot", "nt", "boot", "opt", "dot", "et", "bot", "ote", "ott", "lot", "OT", "t", "ant", "oted", "mot", "op", "ol"], "reg": ["gre", "debug", "gr", "gc", "res", "mem", "val", "core", "num", "region", "go", "Reg", "loc", "ret", "ort", "proc", "config", "stat", "eng", "ram", "roc", "valid", "eg", "REG", "mn", "disc", "pred", "ro", "aug", "lex", "mor", "greg", "rest", "thread", "mod", "err", "fun", "conn", "run", "pre", "dist", "rem", "leg", "port", "rc", "data", "re", "ig", "obj", "comb", "dr", "org", "form", "arg", "abc", "grad", "rig", "tag", "exec", "sec", "rec", "comment", "rg"]}}
{"project": "qemu", "commit_id": "c0462f6d75fa481f7660c15a5ca3a60205aa4eca", "target": 0, "func": "bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n", "idx": 20301, "substitutes": {"param": ["channel", "comment", "part", "params", "item", "image", "property", "prop", "arm", "single", "num", "pair", "reference", "buffer", "name", "par", "type", "address", "option", "pm", "config", "prom", "ram", "request", "Parameter", "temp", "c", "parent", "path", "error", "meter", "ref", "cm", "aram", "member", "ctx", "keep", "m", "arg", "number", "am", "array", "package", "prefix", "Param"], "buf": ["cap", "br", "text", "cv", "uf", "prop", "h", "queue", "que", "buff", "buffer", "loc", "proc", "f", "config", "cur", "uc", "func", "cmd", "b", "v", "bh", "temp", "c", "cb", "cas", "vec", "bp", "ab", "tmp", "fd", "fp", "result", "batch", "ref", "pb", "brace", "bag", "fi", "port", "bc", "ff", "cp", "foo", "rc", "data", "ctx", "fb", "array", "context", "front", "rb", "prefix"], "p": ["po", "part", "params", "x", "w", "pe", "pa", "jp", "pr", "prop", "pid", "pointer", "par", "j", "f", "q", "pc", "pat", "b", "v", "a", "pi", "n", "c", "ps", "o", "bp", "e", "pt", "patch", "r", "P", "l", "y", "fp", "u", "pre", "vp", "point", "value", "tp", "d", "np", "pos", "cp", "data", "k", "i", "sp", "m", "t", "dp", "ap", "g", "z", "op"]}}
{"project": "FFmpeg", "commit_id": "099d6813c27faf95257a529aa2c65dfde816a487", "target": 1, "func": "int ff_h264_alloc_tables(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int big_mb_num= s->mb_stride * (s->mb_height+1);\n\n    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;\n\n    int x,y;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)\n\n\n\n    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n\n    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);\n\n    for(y=0; y<s->mb_height; y++){\n\n        for(x=0; x<s->mb_width; x++){\n\n            const int mb_xy= x + y*s->mb_stride;\n\n            const int b_xy = 4*x + 4*y*h->b_stride;\n\n\n\n            h->mb2b_xy [mb_xy]= b_xy;\n\n            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));\n\n        }\n\n    }\n\n\n\n    s->obmc_scratchpad = NULL;\n\n\n\n    if(!h->dequant4_coeff[0])\n\n        init_dequant_tables(h);\n\n\n\n    return 0;\n\nfail:\n\n    free_tables(h, 1);\n\n    return -1;\n\n}\n", "idx": 20305, "substitutes": {"h": ["auth", "hd", "kh", "p", "f", "q", "rh", "oh", "H", "u", "adh", "hash", "k", "i", "all", "ha", "th", "en", "gh", "_", "j", "zh", "ho", "he", "b", "dh", "header", "hs", "e", "hr", "end", "history", "uh", "host", "hist", "v", "hh", "html", "c", "l", "hw", "ch", "ph", "sh", "hi", "m", "t", "g", "eh", "han", "hp", "ht", "hl", "hy", "http", "ih", "ah", "bh", "o", "d", "hm"], "s": ["res", "secondary", "p", "ls", "us", "f", "si", "sb", "storage", "side", "share", "gs", "i", "conf", "spec", "support", "aws", "ds", "cli", "ses", "is", "b", "sc", "n", "hs", "ps", "e", "screen", "ess", "services", "sup", "S", "w", "site", "sci", "stats", "v", "c", "submit", "l", "r", "service", "qs", "sh", "es", "shared", "m", "sys", "t", "server", "sl", "g", "sq", "rs", "sync", "http", "fs", "ss", "o", "session", "d", "in", "port", "ssl", "su", "self", "sf", "ns", "this", "sg", "sports", "js"], "x": ["w", "ix", "p", "row", "X", "num", "j", "dim", "f", "rx", "b", "v", "n", "index", "c", "l", "col", "d", "k", "i", "m", "t", "g", "z"], "y": ["ii", "cy", "w", "p", "j", "type", "f", "b", "a", "n", "height", "c", "o", "e", "l", "col", "d", "vy", "k", "i", "yy", "m", "t", "dy", "Y", "z"]}}
{"project": "FFmpeg", "commit_id": "3583eb93410a73cac8ddf291baa405005ff4c405", "target": 0, "func": "static inline CopyRet copy_frame(AVCodecContext *avctx,\n\n                                 BC_DTS_PROC_OUT *output,\n\n                                 void *data, int *data_size,\n\n                                 uint8_t second_field)\n\n{\n\n    BC_STATUS ret;\n\n    BC_DTS_STATUS decoder_status;\n\n    uint8_t is_paff;\n\n    uint8_t next_frame_same;\n\n    uint8_t interlaced;\n\n\n\n    CHDContext *priv = avctx->priv_data;\n\n\n\n    uint8_t bottom_field = (output->PicInfo.flags & VDEC_FLAG_BOTTOMFIELD) ==\n\n                           VDEC_FLAG_BOTTOMFIELD;\n\n    uint8_t bottom_first = !!(output->PicInfo.flags & VDEC_FLAG_BOTTOM_FIRST);\n\n\n\n    int width    = output->PicInfo.width;\n\n    int height   = output->PicInfo.height;\n\n    int bwidth;\n\n    uint8_t *src = output->Ybuff;\n\n    int sStride;\n\n    uint8_t *dst;\n\n    int dStride;\n\n\n\n    ret = DtsGetDriverStatus(priv->dev, &decoder_status);\n\n    if (ret != BC_STS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"CrystalHD: GetDriverStatus failed: %u\\n\", ret);\n\n       return RET_ERROR;\n\n    }\n\n\n\n    is_paff           = ASSUME_PAFF_OVER_MBAFF ||\n\n                        !(output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC);\n\n    next_frame_same   = output->PicInfo.picture_number ==\n\n                        (decoder_status.picNumFlags & ~0x40000000);\n\n    interlaced        = ((output->PicInfo.flags &\n\n                          VDEC_FLAG_INTERLACED_SRC) && is_paff) ||\n\n                         next_frame_same || bottom_field || second_field;\n\n\n\n    av_log(avctx, AV_LOG_VERBOSE, \"CrystalHD: next_frame_same: %u | %u | %u\\n\",\n\n           next_frame_same, output->PicInfo.picture_number,\n\n           decoder_status.picNumFlags & ~0x40000000);\n\n\n\n    if (priv->pic.data[0] && !priv->need_second_field)\n\n        avctx->release_buffer(avctx, &priv->pic);\n\n\n\n    priv->need_second_field = interlaced && !priv->need_second_field;\n\n\n\n    priv->pic.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE |\n\n                             FF_BUFFER_HINTS_REUSABLE;\n\n    if (!priv->pic.data[0]) {\n\n        if (avctx->get_buffer(avctx, &priv->pic) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return RET_ERROR;\n\n        }\n\n    }\n\n\n\n    bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n\n    if (priv->is_70012) {\n\n        int pStride;\n\n\n\n        if (width <= 720)\n\n            pStride = 720;\n\n        else if (width <= 1280)\n\n            pStride = 1280;\n\n        else if (width <= 1080)\n\n            pStride = 1080;\n\n        sStride = av_image_get_linesize(avctx->pix_fmt, pStride, 0);\n\n    } else {\n\n        sStride = bwidth;\n\n    }\n\n\n\n    dStride = priv->pic.linesize[0];\n\n    dst     = priv->pic.data[0];\n\n\n\n    av_log(priv->avctx, AV_LOG_VERBOSE, \"CrystalHD: Copying out frame\\n\");\n\n\n\n    if (interlaced) {\n\n        int dY = 0;\n\n        int sY = 0;\n\n\n\n        height /= 2;\n\n        if (bottom_field) {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: bottom field\\n\");\n\n            dY = 1;\n\n        } else {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: top field\\n\");\n\n            dY = 0;\n\n        }\n\n\n\n        for (sY = 0; sY < height; dY++, sY++) {\n\n            memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);\n\n            if (interlaced)\n\n                dY++;\n\n        }\n\n    } else {\n\n        av_image_copy_plane(dst, dStride, src, sStride, bwidth, height);\n\n    }\n\n\n\n    priv->pic.interlaced_frame = interlaced;\n\n    if (interlaced)\n\n        priv->pic.top_field_first = !bottom_first;\n\n\n\n    if (output->PicInfo.timeStamp != 0) {\n\n        priv->pic.pkt_pts = opaque_list_pop(priv, output->PicInfo.timeStamp);\n\n        av_log(avctx, AV_LOG_VERBOSE, \"output \\\"pts\\\": %\"PRIu64\"\\n\",\n\n               priv->pic.pkt_pts);\n\n    }\n\n\n\n    if (!priv->need_second_field) {\n\n        *data_size       = sizeof(AVFrame);\n\n        *(AVFrame *)data = priv->pic;\n\n    }\n\n\n\n    if (ASSUME_TWO_INPUTS_ONE_OUTPUT &&\n\n        output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) {\n\n        av_log(priv->avctx, AV_LOG_VERBOSE, \"Fieldpair from two packets.\\n\");\n\n        return RET_SKIP_NEXT_COPY;\n\n    }\n\n\n\n    return RET_OK;\n\n}\n", "idx": 20320, "substitutes": {"avctx": ["versc", "evcf", "avalcontext", "afcmp", "Avconn", "avesc", " avna", "avalconn", "avctrl", "avloc", "avalctx", "AVcf", "airctx", "Avloc", "aircf", "akcf", "versync", "avcontext", "verctx", "avecontext", "avena", "avconn", "afna", "AVloc", "avectx", "AVctx", "akctx", "akcontext", "avalloc", "afconn", "evconn", "evctx", "AVcontext", "avectrl", "vercontext", "AVctrl", "Avctx", "avcmp", "aircmp", " avctrl", "afsc", "AVconn", "avsync", " avcontext", "afcf", "aircontext", "avna", "avsc", "akconn", " avconn", "avesync", "afctx", "avcf", "afsync", "evcontext", "aveconn", "AVcmp", "Avcontext", "afcontext"], "output": ["generation", "write", "Output", "update", "image", "console", "stage", "PUT", "version", "oe", "event", "current", "production", "application", "reference", "name", "date", "type", "address", "public", "option", "config", "response", "object", "document", "io", "information", "control", "parent", "protected", "o", "error", "export", "conn", "page", "ou", "module", "result", "run", "connection", "outer", "oper", "generated", "source", "external", "summary", "profile", "after", "target", "model", "input", "product", "environment", "OU", "unit", "fn", "client", "sort", "note", "context", "exec", "resource", "operation"], "data": ["channel", "ui", "image", "cache", "DATA", "block", "buffer", "buff", "results", "background", "config", "response", "extra", "start", "body", "media", "fee", "next", "bin", "picture", "align", "parent", "da", "dat", "style", "message", "tmp", "batch", "result", "window", "source", "value", "size", "read", "video", "input", "memory", "done", "Data", "open", "slice", "binary", "resource"], "data_size": ["window_SIZE", "data_needed", "data_SIZE", "window_capacity", "window_needed", "window_size", "data_capacity"], "second_field": ["secondfullfield", "second_fields", "first_margin", "secondfulldiff", "second_margin", "secondfullmatch", "first_field", "second_match", "first_diff", "secondOffmargin", "secondOffdiff", "secondOfffields", "first_fields", " second_diff", "secondfullfields", " second_fields", "second_diff", "secondOfffield", " second_match"], "ret": ["att", "def", "res", "rs", "rets", "lit", "mem", "code", "cat", "rt", "val", "db", "rev", "fail", "status", "info", "stat", "valid", "det", "ft", "cur", "mt", "bf", "ut", "RET", "len", "back", "detail", "feat", "red", "sb", "reg", "fun", "err", "r", "nt", "result", "ref", "final", "std", "fi", "tr", "bot", " RET", "reply", "rc", "re", "flag", "hash", "rf", "alt", "fin", "success", "Ret", "rep", "no", "ext"], "decoder_status": ["decoderallmagic", "decryption_stat", "decoderfresult", "decoder_result", "decoder_sum", "decoderingsum", "decoded_status", "decoderallstat", "decode_data", "decoded_Status", "decoder_state", "decoder_Status", "decoder_options", "decoderfsum", "decoderingresult", "decensoringsum", "decensoringstatus", "decoder_magic", "decoderfstate", "decoderallstatus", "decoder_date", "decoderalldate", "decryptionallmagic", "decoder_stat", "decryptionalldate", "decryption_date", "decensor_result", "decryptionallstat", "decryption_status", "decensor_state", "decensoringstate", "decoder_data", "decensor_sum", "decryptionallstatus", "decode_status", "decoderingstatus", "decode_stat", "decoderingstate", "decoded_options", "decryption_magic", "decoderfstatus", "decensoringresult", "decensor_status"], "is_paff": ["is__Pff", "is_preaff", "is_bAff", "is_ruff", "is__paf", "is___raff", "is___ruff", "is_preff", "is___puff", "is_baf", "is_paf", "is_paux", "is_paaux", "is_npaff", "is__pff", "is_pAff", "is_apaff", "is_Paux", "is_puff", "is_npaf", "is__paff", "is_rff", "is_pff", "is__pAff", "is___raf", "is_npff", "is_baff", "is_pauff", "is_raff", "is__PAff", "is_bff", "is_paaff", "is__Paff", "is___pff", "is___rff", "is__Paf", "is_apaf", "is_PAff", "is_preuff", "is___paff", "is_apaux", "is___paf", "is_Pff", "is_paaf", "is_npAff", "is_preaf", "is_apff", "is_Paff", "is_Paf", "is_raf"], "next_frame_same": ["next_line_different", "next_frame_both", "next_frame\u00b7square", "next_frame__less", "next_frame_shared", "next_frame__different", "next_frame_equal", "next_frame\u00b7same", "next_frame_present", "next_line_less", "next_frame__equal", "next_frame_square", "next_frame_different", "next_frame_less", "next_frame\u00b7equal", "next_line_equal", "next_frame\u00b7both", "next_line_same", "next_frame_one", "next_frame__same"], "interlaced": [" interflaid", "interflaced", "Interlacer", "interracial", "interplacer", " interflaced", "Interplacer", "Interplaced", "interlacial", " interflanged", "interolacing", " interlanded", "interflanged", "interlaid", " interlanged", "interlanged", "interLaced", "interrated", " interrated", "interpolaced", "interlacing", "interlated", "interolated", "interLacial", "interlace", "interracing", "interplaid", "interflaid", "interLace", "interLacer", "interpolacer", " interraced", " interracing", "Interplaid", "interolanded", "interlacer", "interraced", "interLanged", "interlanded", " interlated", "Interplace", "interraid", " interlacial", "Interlace", "interslacing", "interslated", "interplaced", "interranded", "interslanded", "interpolaid", "interflacial", "interslaced", " interlacing", "interpolace", "interplace", " interlaid", "interranged", " interflacial", "Interlaced", "interolaced", "Interlaid", "interLaid", " interranded"], "priv": ["auth", "req", "cache", "proc", "info", "anc", "utils", "dev", "storage", "pri", "dest", "mini", "progress", "bc", "gb", "org", "conf", "lib", "spec", "ec", "inner", "contract", "public", "config", "ocr", "cert", "fee", "pro", "prof", "env", "cookie", "fac", "private", "riv", "usa", "api", "rc", "input", "resource", "rec", "text", "access", "enc", "mem", "stat", "prom", "ie", "uc", "temp", "state", "err", "pdf", "tmp", "prot", "ch", "service", "li", "ptr", "Priv", "client", "pub", "typ", "reg", "conn", "password", "rib", "ee", "str", "cp", "attr", "impl", "obj", "reader", "txt", "exec", "sec"], "bwidth": ["nlength", "lwidth", "blength", "lWidth", "bWidth", "nwidth", " bWidth", "nWidth", "llength", " blength"], "src": ["desc", "image", "origin", "img", "pic", "loc", "config", "bg", "sc", "uri", "stream", "buf", "view", "sub", "cb", "tmp", "filename", "crop", "dest", "dist", "source", "url", "rc", "attr", "slice", "scene", "sl", "rb"], "sStride": ["sVerrip", "sUrip", "sUride", "sVerride", "sVerridden", "sSTrip", "mVerride", "sSTrow", "mVerridden", "sStridden", "sVerrow", "sStrow", "sSTride", "mStride", "mStrip", "sSTridden", "mVerrip", "sStrip", "sUridden", "mStrow", "sUrow", "mStridden", "mVerrow"], "dst": ["pbl", "hst", " dcr", "hbl", "dbl", " dste", "dste", "pst", "pste", " dbl", "pcr", "hste", "dcr", "hcr"], "dStride": ["dStflow", "dStrite", "dScrite", "dShrite", "dScri", "fStrite", "fRestri", "fRestrite", "dShride", "fRestride", "dRestflow", "dShri", "dScride", "dShflow", "dRestri", "fRestflow", "fStflow", "fStride", "dRestrite", "dStri", "fStri", "dScflow", "dRestride"]}}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n", "idx": 20327, "substitutes": {"nc": ["dc", "mc", "nd", "cf", "cms", "kt", "nm", "cv", "lc", "enc", "sync", "cc", "config", "cus", "pc", "anc", "sc", "fc", "ct", "n", "c", "NC", "sb", "nr", "cs", "e", "conn", "ng", "nt", "nw", "cm", "rn", "ne", "bc", "unc", "rc", "nec", "cdn", "ctx", "ci", "cn", "ns", "g", "node", "ec", "sn"], "s": ["settings", "states", "S", "sq", "south", "ks", "rs", "w", "src", "p", "sym", "ls", "enc", "sync", "core", "se", "bis", "ses", "an", "f", "ds", "xs", "sec", "sr", "request", "fs", "is", "sc", "ts", "ss", "si", "its", "n", "c", "ys", "spec", "hs", "send", "o", "sb", "sie", "e", "cs", "args", "service", "session", "u", "qs", "services", "es", "d", "ops", "ssl", "gs", "su", "m", "sys", "conf", "t", "os", "sf", "sl", "ns", "sg", "your", "g", "new", "sn", "js"]}}
{"project": "qemu", "commit_id": "79d5ca5617cfc9be13a4f314ed800fca1267d903", "target": 1, "func": "static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 20328, "substitutes": {"fd": ["nd", "du", " fid", "pd", "fe", "pid", "cd", "draft", "lf", "name", "ln", "ds", "length", "f", "dl", "FD", "func", "fs", "xf", "fc", "dir", "fee", "len", "df", "fw", "fun", "fff", "fen", "fl", "hid", "pipe", "handler", "fed", "fa", "fp", "filename", "rd", "size", "fi", "d", "ffff", "weight", "lvl", "fx", "fin", "fn", "dn", "fb", " FD", "sf", "dy", "wd", "wat", "frequency"], "node": ["empty", "tree", "event", "host", "core", "route", "local", "num", "name", "load", "nn", "type", "f", "object", "valid", "nav", "document", "none", "content", "native", "n", "ode", "uri", "parent", "new", "path", "error", "e", "leaf", "handler", "root", "result", "ref", "source", "anch", "post", "value", "inner", "gen", "instance", "slave", "child", "one", "Node", "cdn", "missing", "id", "self", "null", "live", "fn", "card", "add", "edge", "od", "open", "component", "this", "dom", "op", "remote"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,\n\n                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    int i;\n\n#if COMPILE_TEMPLATE_MMX\n\n    if(!(c->flags & SWS_BITEXACT)) {\n\n        long p= 4;\n\n        const int16_t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW};\n\n        uint8_t *dst[4]= {aDest, dest, uDest, vDest};\n\n        x86_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};\n\n\n\n        if (c->flags & SWS_ACCURATE_RND) {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121_ACCURATE\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        }\n\n        return;\n\n    }\n\n#endif\n\n    for (i=0; i<dstW; i++) {\n\n        int val= (lumSrc[i]+64)>>7;\n\n\n\n        if (val&256) {\n\n            if (val<0) val=0;\n\n            else       val=255;\n\n        }\n\n\n\n        dest[i]= val;\n\n    }\n\n\n\n    if (uDest)\n\n        for (i=0; i<chrDstW; i++) {\n\n            int u=(chrSrc[i       ]+64)>>7;\n\n            int v=(chrSrc[i + VOFW]+64)>>7;\n\n\n\n            if ((u|v)&256) {\n\n                if (u<0)        u=0;\n\n                else if (u>255) u=255;\n\n                if (v<0)        v=0;\n\n                else if (v>255) v=255;\n\n            }\n\n\n\n            uDest[i]= u;\n\n            vDest[i]= v;\n\n        }\n\n\n\n    if (CONFIG_SWSCALE_ALPHA && aDest)\n\n        for (i=0; i<dstW; i++) {\n\n            int val= (alpSrc[i]+64)>>7;\n\n            aDest[i]= av_clip_uint8(val);\n\n        }\n\n}\n", "idx": 20338, "substitutes": {"c": ["C", "mc", "dc", "cy", "w", "cit", "xc", "lc", "cu", "enc", "cd", "cc", "ac", "ce", "f", "config", "s", "cur", "pc", "coll", "oc", "b", "sc", "ct", "n", "con", "e", "cs", "l", "conn", "r", "ch", "u", "cm", "d", "bc", "cp", "ctx", "vc", "m", "ci", "conf", "t", "ctrl", "cn", "g", "ec", "comp"], "lumSrc": ["lumSloc", "lumPsdc", "lumEsdc", "lnumAsdc", "lumSRC", "lumEsRC", "lumSdc", "lumEsloc", "lumaAsr", "lpEssrc", "lumAsloc", "lumAsRC", "lumAssrc", "lumEsdr", "lumaAsdc", "lnumSRC", "lumEsr", "lumaAsrc", "lumaSrc", "lpEsrc", "lpEsdr", "lpSrc", "lnumAsloc", "lumaSr", "lnumSdc", "lpEsRC", "lumAsrc", "lumAsr", "lumSr", "lumAsdc", "lumPsloc", "lumaAsRC", "lumPsrc", "lnumAsRC", "lumaSdc", "lumaSRC", "lpSsrc", "lnumSloc", "lumPsRC", "lumAsdr", "lpSdr", "lumSdr", "lumSsrc", "lumEsrc", "lnumSrc", "lnumAsrc", "lpSRC", "lumEssrc"], "chrSrc": ["chrEsirc", "chrrSumRC", "chrGource", "chrIsrc", "chrDource", "chrGrc", "chrtSrc", "chrPsirc", "chrSdr", "chrPsrt", "chranIsource", "chpPsrt", "chrAsrec", "chrSRC", "chrInsrc", "chrEsdr", "chpSrt", "chrSgd", "chrrSumirc", "chrSource", "chrSri", "chpPsRC", "chrInsource", "chrIsource", "chrtSetuc", "chrrSRC", "chrtSetst", "chrIsst", "chrSrt", "chrPsrc", "chrEsource", "chrSumri", "chpDrt", "chrtSuc", "chpSrc", "chpPsrc", "chpSrec", "chrEsri", "chpSRC", "chrPsrec", "chrAsource", "chrSumirc", "chrAsuc", "chranIsdr", "chrtSst", "chrAsrt", "chrSetuc", "chrAsdr", "chrSst", "chrIsRC", "chrSetst", "chrGrt", "chrSrec", "chpSource", "chrSumrc", "chrrSri", "chrAsRC", "chpSgd", "chrrSrc", "chrSumRC", "chrEsRC", "chrAsrc", "chrEsrc", "chrrSumri", "chrSetRC", "chranIsrc", "chranSource", "chrSuc", "chrGgd", "chpDgd", "chranSdr", "chrIsuc", "chrtSetRC", "chrDrt", "chranSrc", "chrSetrc", "chrrSirc", "chrAsst", "chrDrc", "chrtSetrc", "chrDRC", "chrSirc", "chrInsrt", "chpPsrec", "chrPsri", "chrIsdr", "chrtSRC", "chrrSumrc", "chrPsRC", "chrInsgd", "chranIsRC", "chrDgd", "chpDrc", "chranSRC", "chpDource", "chrDrec"], "alpSrc": ["alcAsRC", "alcAsdr", "alcSRC", "alrSRC", "alpAsRC", "alrNdr", "alcSdr", "alrSrc", "alpNRC", "alcSrc", "alrNrc", "alrNsrc", "alcAsgd", "alpAsgd", "alpAssrc", "alcSgd", "alcAsrc", "alpSdr", "alrNRC", "alpSgd", "alpSRC", "alpSsrc", "alpNdr", "alrSsrc", "alpNsrc", "alpNrc", "alrSdr", "alpAsdr", "alpAsrc"], "dest": ["dc", "desc", "cont", "wb", "prop", "img", "route", "loc", "dim", "config", "decl", "uc", " destination", "sc", "rest", "transform", "flat", "send", "path", "dev", "dat", "dist", "output", "source", "opt", "usr", "gen", " Dest", "target", "coord", "diff", "data", "comb", "Dest", "dep", "destroy", "cdn", "orig", "done", "sort", "trans", "asc", "de"], "uDest": ["uDesc", "nDist", "oDist", "vDesc", "oSource", "uNeg", "UDist", "UDesc", "UDest", "vSource", "ndest", "nDesc", "aDesc", " uDesc", "aNeg", "aSource", "uSource", "UNeg", "odest", "vdest", "aDist", " uNeg", "udest", "adest", " uDist", "vDist", "Udest", "uDist", "nDest", "oDest"], "vDest": ["uDesc", " vDist", "bTrans", "vDesc", "hDest", " vTrans", "cDep", "vTrans", "cDesc", "hDep", "uTrans", "cDest", "vDep", "cDist", "hDist", "vDist", "hDesc", "uDist", "bDest", "uDep", "bDist"], "aDest": ["aSc", "ASc", "sDest", "aDesc", "bSource", "aSource", "saDist", "ADesc", "ASource", " aSc", "aDist", " aSource", "saDesc", "sDist", "ADist", "bSc", " aDist", "saDest", "ADest", "sDesc", "bDest", "bDist"], "dstW": ["destM", "drcV", "DestV", "dstsw", "destU", "dSTH", "Dstw", "dSTR", "dstL", "destG", "dostV", "drcC", "dSTM", "DestH", "DstU", "dstH", "DstC", "dastV", "dstU", "DSTM", "destW", "dSTL", "dstsVW", "dSTU", "DSTW", "dostH", "DndW", "dstw", "dastH", "destVW", "dStW", "dstsG", "dstVW", "DSTL", "dndV", "dstaL", "destV", "dstsV", "dndL", "dndC", "destR", "drcH", "dostW", "DstH", "dstV", "dndW", "DestWe", "dSTG", "dStL", "DstWe", "DstG", "DSTR", "Destw", "dSTC", "dstWe", "destWe", "dstsH", "dndWe", "dndH", "DndV", "DestM", "destL", "destC", "dndM", "drcW", "DestC", "destw", "dstR", "DndH", "dSTW", "dstaM", "DstV", "dostM", "DstW", "dStWe", "dstsU", "dostw", "DndC", "DstM", "DestL", "DstL", "dstsW", "DstR", "destH", "dstaR", "DestU", "dstC", "dStM", "dstG", "dastW", "dostC", "DestVW", "dstaW", "dostVW", "DestW", "dastC", "dstM", "DestG", "DstVW"], "chrDstW": ["chrSestV", "chrDstaW", "chrDntW", "chrDsstM", "chrDSTL", "chrDstaX", "chrDstGW", "chrDsnL", "chrDntL", "chrDntM", "chrDstM", "chrSestL", "chrDntGW", "chrInntH", "chrDSTM", "chrSstW", "chrInntGW", "chrDSTF", "chrDrcC", "chrDrcW", "chrSstV", "chrDntH", "chrDstX", "chrDssnW", "chrDrcH", "chrdntL", "chrDstL", "chrNstC", "chrDrcV", "chrInstV", "chrdstM", "chrSstL", "chrDstaC", "chrDdrH", "chrDsnM", "chrDSTH", "chrSstH", "chrDstC", "chrDrcX", "chrDestM", "chrDstH", "chrDsstW", "chrDStF", "chrdstV", "chrDdrW", "chrDdrGW", "chrDssnL", "chrDSTX", "chrDsstY", "chrDestC", "chrdstW", "chrInstGW", "chrDStC", "chrdstaW", "chrDestF", "chrNSTM", "chrInntV", "chrdntW", "chrDsnW", "chrDestV", "chrDstY", "chrdntM", "chrInstW", "chrInstH", "chrDestW", "chrDsnY", "chrNSTW", "chrNSTC", "chrdntV", "chrDrcL", "chrDestY", "chrDntV", "chrDestL", "chrDStW", "chrDSTY", "chrDstF", "chrSestH", "chrDdrV", "chrNstM", "chrDstaH", "chrDestH", "chrNSTF", "chrdstaH", "chrDsstL", "chrdstH", "chrSestW", "chrDstV", "chrDssnY", "chrDSTGW", "chrDrcM", "chrNstW", "chrDSTV", "chrDssnM", "chrdstC", "chrDSTW", "chrdstL", "chrdstaC", "chrDStM", "chrdstX", "chrdstaX", "chrDSTC", "chrNstF", "chrInntW"], "i": ["ti", "ii", "ui", "abi", "qi", "x", "I", "ix", "jp", "eni", "phi", "di", "ri", "j", "type", "f", "ai", "info", "ini", "ie", "ni", "oi", "is", "si", "b", "io", "v", "init", "a", "pi", "n", "index", "uri", "ali", "uli", "e", "y", "l", "P", "xi", "u", "yi", "inner", "fi", "li", "d", "iu", "pos", "in", "data", "k", "id", "m", "mi", "t", "ci", "multi", "gi", "ori", "z", "mu", "bi", "it", "ip"], "src": ["dc", "desc", "inst", "req", "img", "loc", "proc", "config", "uc", "sc", "gl", "bin", "buf", "stream", "sub", "cb", "source", "opt", "sur", "url", "rc", "gb", "rl", "sec", "rb", "comp", "rec"], "dst": ["Dst", "sst", "DST", " dsp", "idst", "idST", "dsp", "Dsc", "idsc", "ssp", "idsp", "fsp", "Dsts", "sST", " dsc", "fst", "Dsp", "dsc", " dST", "dST", "fsc", "dsts", "fsts", "idsts", " dsts", "ssts"], "counter": ["trace", "desc", "inst", "alog", "class", "cache", "mem", "buffer", "name", "processor", "names", "proc", "mask", "seq", "uments", "table", "entry", "ger", "tr", "obj", "count", "arr", "array", "list", "currency", "record", "map", "loader", "comp"], "p": ["po", "part", "br", "pe", "pa", "jp", "pr", "h", "current", "pid", "pointer", " P", "j", "f", "pm", "q", "pc", "pat", "body", "b", "v", "a", "pi", "n", "pp", "per", "parent", "ps", "lp", "o", "bp", "e", "patch", "l", "P", "r", "ph", "pn", "u", "pb", "pre", "point", "post", "tp", "port", "np", "api", "progress", "pu", "sp", "m", "t", "ap", "g", "hp", "wp", "op", "ip"]}}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n            env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        } else if (n < CPU_NB_REGS32) {\n\n            n = gpr_map32[n];\n\n            env->regs[n] &= ~0xffffffffUL;\n\n            env->regs[n] |= (uint32_t)ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        if (n < CPU_NB_REGS32 ||\n\n            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {\n\n            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n            return 16;\n\n        }\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n                env->eip = ldq_p(mem_buf);\n\n                return 8;\n\n            } else {\n\n                env->eip &= ~0xffffffffUL;\n\n                env->eip |= (uint32_t)ldl_p(mem_buf);\n\n                return 4;\n\n            }\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 20345, "substitutes": {"cs": ["cfg", "cf", "ks", "rs", "ix", "lc", "css", "cc", "core", "ds", "cus", "pc", "fs", "sc", "acs", "c", "CS", "ps", "ck", "conn", "sk", "qs", "ips", "cp", "rc", "ctx", "gs", "sys", "ci", "vs", "nc", "cn", "ns", "ls", "spec", "cons", "ec", "js"], "mem_buf": ["memlexuf", "mem_batch", "Mem_uf", "memllbur", "mem_bur", "memlexqueue", "memllbuffer", "memllbatch", "mem_uf", "Mem_comb", "ram_queue", "process_batch", "access_home", "mem64buf", "memlexseq", "memlluf", "memfbuffer", "Mem_buf", "mem_home", "mem2buf", "memllbuff", "ram_bur", "mem_buff", "access64pub", "mem2bur", "access_pub", "access64buf", "mem2queue", "Mem_buffer", "mem_comb", "memfuf", "mem_buffer", "memllbuf", "access_buf", "ram_buf", "mem_seq", "Mem_buff", "mem2uf", "mem_pub", "mem64home", "ram_seq", "memlexbuf", "mem2buff", "mem_queue", "ram_uf", "process_uf", "process_buffer", "ram_buff", "access64home", "mem64pub", "memxbuf", "memfbuf", "memfqueue", "process_buf", "memxbuff", "Mem_queue", "memxcomb", "memxuf"], "n": ["z", "nor", "br", "x", "nm", "p", "en", "current", "num", "name", "nn", "j", "f", "s", "net", "no", "ni", "nb", "none", "not", "mn", "b", "init", "v", "native", "len", "a", " N", "c", "adj", "o", "e", "nr", "y", "nat", "conn", "l", "min", "ng", "nt", "r", "N", "pn", "u", "rn", "ne", "d", "np", "in", "k", "i", "m", "t", "fn", "dn", "number", "un", "yn", "nc", "nu", "network", "g", "ns", "node", "cn", "all", "sn", "non"], "cpu": ["cfg", "cf", "CPU", "cache", "lc", "eni", "ea", "platform", "mem", "core", "num", "nn", "processor", "clock", "proc", "gpu", "net", "pc", "vm", "c", "python", "conn", "pn", "cal", "cm", "rn", "np", "cp", "instance", "pu", "ctx", "socket", "nc", "cn", "g", "bench", "node", "ec", " cp"], "env": ["inet", "cv", "cache", "eng", "equ", "utils", "eff", "enable", " environments", "et", "oa", "org", "conf", "vs", "ec", "ext", "desc", "global", "ev", "stack", "event", "en", "ea", "core", "her", "db", "cli", "ef", "config", "uv", "e", "args", "kernel", "end", "viron", "Environment", "np", "environment", "cdn", "eu", "esp", "cfg", "console", "esi", "gui", "enc", "site", "el", "dict", "net", "eur", "err", "export", "cal", "output", "ne", "scope", "ctx", "fg", "server", "assets", "energy", "settings", "cf", "eni", "code", "que", "extra", "exc", " environment", "fen", "estate", "engine", "conn", "session", "erv", "obj", "nc", "context", "loader", "exec"], "tmp": [" dst", " len", "cache", " buf", " dest", "img", "_", "proc", " ff", "max", "nb", "mp", "v", "temp", " c", " src", " args", "buf", " v", " proc", " p", "np", "cp", " np", " temp", " result"]}}
{"project": "FFmpeg", "commit_id": "70b1dcef2d859ae6b3e21d61de928c3dd0cf1aa4", "target": 0, "func": "int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n\n                                     H264ParamSets *ps)\n\n{\n\n    AVBufferRef *sps_buf;\n\n    int profile_idc, level_idc, constraint_set_flags = 0;\n\n    unsigned int sps_id;\n\n    int i, log2_max_frame_num_minus4;\n\n    SPS *sps;\n\n\n\n    profile_idc           = get_bits(gb, 8);\n\n    constraint_set_flags |= get_bits1(gb) << 0;   // constraint_set0_flag\n\n    constraint_set_flags |= get_bits1(gb) << 1;   // constraint_set1_flag\n\n    constraint_set_flags |= get_bits1(gb) << 2;   // constraint_set2_flag\n\n    constraint_set_flags |= get_bits1(gb) << 3;   // constraint_set3_flag\n\n    constraint_set_flags |= get_bits1(gb) << 4;   // constraint_set4_flag\n\n    constraint_set_flags |= get_bits1(gb) << 5;   // constraint_set5_flag\n\n    skip_bits(gb, 2);                             // reserved_zero_2bits\n\n    level_idc = get_bits(gb, 8);\n\n    sps_id    = get_ue_golomb_31(gb);\n\n\n\n    if (sps_id >= MAX_SPS_COUNT) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sps_buf = av_buffer_allocz(sizeof(*sps));\n\n    if (!sps_buf)\n\n        return AVERROR(ENOMEM);\n\n    sps = (SPS*)sps_buf->data;\n\n\n\n    sps->sps_id               = sps_id;\n\n    sps->time_offset_length   = 24;\n\n    sps->profile_idc          = profile_idc;\n\n    sps->constraint_set_flags = constraint_set_flags;\n\n    sps->level_idc            = level_idc;\n\n\n\n    memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n\n    memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n\n    sps->scaling_matrix_present = 0;\n\n\n\n    if (sps->profile_idc == 100 ||  // High profile\n\n        sps->profile_idc == 110 ||  // High10 profile\n\n        sps->profile_idc == 122 ||  // High422 profile\n\n        sps->profile_idc == 244 ||  // High444 Predictive profile\n\n        sps->profile_idc ==  44 ||  // Cavlc444 profile\n\n        sps->profile_idc ==  83 ||  // Scalable Constrained High profile (SVC)\n\n        sps->profile_idc ==  86 ||  // Scalable High Intra profile (SVC)\n\n        sps->profile_idc == 118 ||  // Stereo High profile (MVC)\n\n        sps->profile_idc == 128 ||  // Multiview High profile (MVC)\n\n        sps->profile_idc == 138 ||  // Multiview Depth High profile (MVCD)\n\n        sps->profile_idc == 144) {  // old High444 profile\n\n        sps->chroma_format_idc = get_ue_golomb_31(gb);\n\n        if (sps->chroma_format_idc > 3) {\n\n            avpriv_request_sample(avctx, \"chroma_format_idc %u\",\n\n                                  sps->chroma_format_idc);\n\n            goto fail;\n\n        } else if (sps->chroma_format_idc == 3) {\n\n            sps->residual_color_transform_flag = get_bits1(gb);\n\n        }\n\n        sps->bit_depth_luma   = get_ue_golomb(gb) + 8;\n\n        sps->bit_depth_chroma = get_ue_golomb(gb) + 8;\n\n        if (sps->bit_depth_chroma != sps->bit_depth_luma) {\n\n            avpriv_request_sample(avctx,\n\n                                  \"Different chroma and luma bit depth\");\n\n            goto fail;\n\n        }\n\n        sps->transform_bypass = get_bits1(gb);\n\n        decode_scaling_matrices(gb, sps, NULL, 1,\n\n                                sps->scaling_matrix4, sps->scaling_matrix8);\n\n    } else {\n\n        sps->chroma_format_idc = 1;\n\n        sps->bit_depth_luma    = 8;\n\n        sps->bit_depth_chroma  = 8;\n\n    }\n\n\n\n    log2_max_frame_num_minus4 = get_ue_golomb(gb);\n\n    if (log2_max_frame_num_minus4 < MIN_LOG2_MAX_FRAME_NUM - 4 ||\n\n        log2_max_frame_num_minus4 > MAX_LOG2_MAX_FRAME_NUM - 4) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"log2_max_frame_num_minus4 out of range (0-12): %d\\n\",\n\n               log2_max_frame_num_minus4);\n\n        goto fail;\n\n    }\n\n    sps->log2_max_frame_num = log2_max_frame_num_minus4 + 4;\n\n\n\n    sps->poc_type = get_ue_golomb_31(gb);\n\n\n\n    if (sps->poc_type == 0) { // FIXME #define\n\n        sps->log2_max_poc_lsb = get_ue_golomb(gb) + 4;\n\n    } else if (sps->poc_type == 1) { // FIXME #define\n\n        sps->delta_pic_order_always_zero_flag = get_bits1(gb);\n\n        sps->offset_for_non_ref_pic           = get_se_golomb(gb);\n\n        sps->offset_for_top_to_bottom_field   = get_se_golomb(gb);\n\n        sps->poc_cycle_length                 = get_ue_golomb(gb);\n\n\n\n        if ((unsigned)sps->poc_cycle_length >=\n\n            FF_ARRAY_ELEMS(sps->offset_for_ref_frame)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"poc_cycle_length overflow %d\\n\", sps->poc_cycle_length);\n\n            goto fail;\n\n        }\n\n\n\n        for (i = 0; i < sps->poc_cycle_length; i++)\n\n            sps->offset_for_ref_frame[i] = get_se_golomb(gb);\n\n    } else if (sps->poc_type != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"illegal POC type %d\\n\", sps->poc_type);\n\n        goto fail;\n\n    }\n\n\n\n    sps->ref_frame_count = get_ue_golomb_31(gb);\n\n    if (sps->ref_frame_count > H264_MAX_PICTURE_COUNT - 2 ||\n\n        sps->ref_frame_count >= 32U) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"too many reference frames %d\\n\", sps->ref_frame_count);\n\n        goto fail;\n\n    }\n\n    sps->gaps_in_frame_num_allowed_flag = get_bits1(gb);\n\n    sps->mb_width                       = get_ue_golomb(gb) + 1;\n\n    sps->mb_height                      = get_ue_golomb(gb) + 1;\n\n    if ((unsigned)sps->mb_width  >= INT_MAX / 16 ||\n\n        (unsigned)sps->mb_height >= INT_MAX / 16 ||\n\n        av_image_check_size(16 * sps->mb_width,\n\n                            16 * sps->mb_height, 0, avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"mb_width/height overflow\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    sps->frame_mbs_only_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag)\n\n        sps->mb_aff = get_bits1(gb);\n\n    else\n\n        sps->mb_aff = 0;\n\n\n\n    sps->direct_8x8_inference_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag && !sps->direct_8x8_inference_flag) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n\n        goto fail;\n\n    }\n\n\n\n#ifndef ALLOW_INTERLACE\n\n    if (sps->mb_aff)\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MBAFF support not included; enable it at compile-time.\\n\");\n\n#endif\n\n    sps->crop = get_bits1(gb);\n\n    if (sps->crop) {\n\n        unsigned int crop_left   = get_ue_golomb(gb);\n\n        unsigned int crop_right  = get_ue_golomb(gb);\n\n        unsigned int crop_top    = get_ue_golomb(gb);\n\n        unsigned int crop_bottom = get_ue_golomb(gb);\n\n\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP) {\n\n            av_log(avctx, AV_LOG_DEBUG, \"discarding sps cropping, original \"\n\n                                           \"values are l:%d r:%d t:%d b:%d\\n\",\n\n                   crop_left, crop_right, crop_top, crop_bottom);\n\n\n\n            sps->crop_left   =\n\n            sps->crop_right  =\n\n            sps->crop_top    =\n\n            sps->crop_bottom = 0;\n\n        } else {\n\n            int vsub   = (sps->chroma_format_idc == 1) ? 1 : 0;\n\n            int hsub   = (sps->chroma_format_idc == 1 ||\n\n                          sps->chroma_format_idc == 2) ? 1 : 0;\n\n            int step_x = 1 << hsub;\n\n            int step_y = (2 - sps->frame_mbs_only_flag) << vsub;\n\n\n\n            if (crop_left & (0x1F >> (sps->bit_depth_luma > 8)) &&\n\n                !(avctx->flags & AV_CODEC_FLAG_UNALIGNED)) {\n\n                crop_left &= ~(0x1F >> (sps->bit_depth_luma > 8));\n\n                av_log(avctx, AV_LOG_WARNING,\n\n                       \"Reducing left cropping to %d \"\n\n                       \"chroma samples to preserve alignment.\\n\",\n\n                       crop_left);\n\n            }\n\n\n\n            if (INT_MAX / step_x             <= crop_left               ||\n\n                INT_MAX / step_x - crop_left <= crop_right              ||\n\n                16 * sps->mb_width <= step_x * (crop_left + crop_right) ||\n\n                INT_MAX / step_y             <= crop_top                ||\n\n                INT_MAX / step_y - crop_top  <= crop_bottom             ||\n\n                16 * sps->mb_height <= step_y * (crop_top + crop_bottom)) {\n\n                av_log(avctx, AV_LOG_WARNING, \"Invalid crop parameters\\n\");\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    goto fail;\n\n                crop_left = crop_right = crop_top = crop_bottom = 0;\n\n            }\n\n\n\n            sps->crop_left   = crop_left   * step_x;\n\n            sps->crop_right  = crop_right  * step_x;\n\n            sps->crop_top    = crop_top    * step_y;\n\n            sps->crop_bottom = crop_bottom * step_y;\n\n        }\n\n    } else {\n\n        sps->crop_left   =\n\n        sps->crop_right  =\n\n        sps->crop_top    =\n\n        sps->crop_bottom =\n\n        sps->crop        = 0;\n\n    }\n\n\n\n    sps->vui_parameters_present_flag = get_bits1(gb);\n\n    if (sps->vui_parameters_present_flag) {\n\n        int ret = decode_vui_parameters(gb, avctx, sps);\n\n        if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE)\n\n            goto fail;\n\n    }\n\n\n\n    /* if the maximum delay is not stored in the SPS, derive it based on the\n\n     * level */\n\n    if (!sps->bitstream_restriction_flag &&\n\n        (sps->ref_frame_count || avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT)) {\n\n        sps->num_reorder_frames = MAX_DELAYED_PIC_COUNT - 1;\n\n        for (i = 0; i < FF_ARRAY_ELEMS(level_max_dpb_mbs); i++) {\n\n            if (level_max_dpb_mbs[i][0] == sps->level_idc) {\n\n                sps->num_reorder_frames = FFMIN(level_max_dpb_mbs[i][1] / (sps->mb_width * sps->mb_height),\n\n                                                sps->num_reorder_frames);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!sps->sar.den)\n\n        sps->sar.den = 1;\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n\n        static const char csp[4][5] = { \"Gray\", \"420\", \"422\", \"444\" };\n\n        av_log(avctx, AV_LOG_DEBUG,\n\n               \"sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %\"PRId32\"/%\"PRId32\"\\n\",\n\n               sps_id, sps->profile_idc, sps->level_idc,\n\n               sps->poc_type,\n\n               sps->ref_frame_count,\n\n               sps->mb_width, sps->mb_height,\n\n               sps->frame_mbs_only_flag ? \"FRM\" : (sps->mb_aff ? \"MB-AFF\" : \"PIC-AFF\"),\n\n               sps->direct_8x8_inference_flag ? \"8B8\" : \"\",\n\n               sps->crop_left, sps->crop_right,\n\n               sps->crop_top, sps->crop_bottom,\n\n               sps->vui_parameters_present_flag ? \"VUI\" : \"\",\n\n               csp[sps->chroma_format_idc],\n\n               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,\n\n               sps->timing_info_present_flag ? sps->time_scale : 0);\n\n    }\n\n\n\n    /* check if this is a repeat of an already parsed SPS, then keep the\n\n     * original one.\n\n     * otherwise drop all PPSes that depend on it */\n\n    if (ps->sps_list[sps_id] &&\n\n        !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n\n        av_buffer_unref(&sps_buf);\n\n    } else {\n\n        remove_sps(ps, sps_id);\n\n        ps->sps_list[sps_id] = sps_buf;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&sps_buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 20352, "substitutes": {"gb": ["bm", "lb", "cfg", "gg", "gom", "du", "tg", "gp", "hd", "wb", "gc", "gm", "src", "bb", "gy", "bridge", "bo", "gh", "tm", "gam", "ge", "db", "buff", "gnu", "gpu", "bg", "pc", "gal", "bf", "gd", "git", "che", "gin", "ges", "b", "gram", "gt", "game", "GB", "ga", "cb", "sb", "storage", "bp", "mb", "cgi", "kb", "hub", "boot", "agg", "gn", "bc", "phy", "gs", "abb", "usb", "cca", "gz", "vg", "lib", "ko", "eb", "g", "sl", "rb", "rg"], "avctx": ["avalcontext", "avalcli", "avconfig", "avalctx", "AVcli", "avercli", "avcontext", "verctx", "camcontext", "verconn", "camconfig", "avconn", "AVctx", "AVcas", "avcli", "averctx", "afconn", "AVcontext", "vercontext", "camctx", "afconfig", "avcas", "camconn", "afctx", "avalcas", "avercas", "avercontext", "verconfig", "afcontext"], "ps": ["params", "aps", "pe", "pa", "p", "pr", "pps", "pse", "PS", "ds", "pers", "mp", "pp", "bps", "pt", "cs", "ams", "ars", "eps", "ops", "ips", "cp", "sp", "ppa", "Ps", "ap", "ns", "ms"], "sps_buf": ["sps__buffer", "spe_buf", "sps_cf", "sps__bag", "sps_opt", "sips_buff", "spps_opt", "sps_buff", "sps___uf", "sps___bag", "spe_cf", "sps___buf", "sips_buf", "sPS_bag", "sps__uf", "spe_buff", "sPS_uf", "sps_uf", "sips_bag", "sips_buffer", "spps_buf", "sps_fw", "sps_bag", "sps_queue", "sps___fw", "sps__buff", "sps__fw", "sPS_fw", "sPS_buf", "sps__buf", "sps_buffer", "spps_queue"], "profile_idc": ["profile__idp", "profile__idx", "profile_idso", "profileOido", "profile_numc", "profileOnume", "profile_iddc", "profile_lengthe", "profile_lengthc", "profile_idce", "profile_ide", "profile_idp", "profile_identc", "profile_indc", "profileObitb", "profile_identb", "profile_idn", "profileObitdc", "profileOidb", "profile_duk", "profile_idcode", "profile_nume", "profile_numcode", "profile_Idn", "profile_duc", "profile_numo", "profile_idb", "profile_ipn", "profileOnumc", "profile__idc", "profileOide", "profile_ipb", "profileObitn", "profile_bitdc", "profile__idex", "profile_bitc", "profile_bitb", "profileObitc", "profile_idx", "profile__idece", "profile_dun", "profileOnumcode", "profile_Idc", "profile_Idx", "profile_lengtho", "profile_ipdc", "profile_identn", "profile_lengthcode", "profileOnumo", "profile_idk", "profile__idec", "profile_indx", "profile_idsc", "profile_indce", "profile_idse", "profile_identdc", "profile_idep", "profile__idce", "profileOidcode", "profile_dux", "profileOiddc", "profile_idscode", "profile_indp", "profile_idece", "profile_idex", "profile_ido", "profile_Idk", "profileOidn", "profile__idep", "profile_ipc", "profileOidc", "profile_bitn", "profile_idec"], "level_idc": ["level_idp", "levelalide", "level_idl", "levelallidxc", "levelalindexc", "level_ipp", "level_intw", "level_idz", "level_inty", "level_IDl", "level_lenc", "level_Idl", "level_IDy", "level_idec", "level_lenz", "level_uidc", "level_idep", "level_intc", "level_uidxc", "levelvinty", "levelvidw", "level_idcs", "level_idscs", "level_idsd", "levelallidc", "level_andc", "level_andce", "levelvidl", "levelvidc", "level_idsc", "levelvidy", "levelallindexce", "levelalidc", "level_lencs", "level_typez", "levelvintw", "levelalindexp", "level_indexp", "level_id2", "level_ide2", "level_andxc", "level_indexc", "level_typed", "level_Idc", "level_indexxc", "level_IDw", "levelvintl", "level_typecs", "level_idcm", "level_idd", "level_idce", "levelallindexc", "level_idxc", "level_index2", "levelalid2", "levelallindexxc", "level_uidce", "level_idy", "levelalindexe", "level_typec", "level_ip2", "level_Idy", "level_andcm", "level_idsz", "level_IDc", "levelalidp", "level_intl", "level_uidcm", "level_idee", "levelallidcm", "level_indexcm", "level_indexce", "levelvintc", "level_ipe", "levelallindexcm", "level_ipc", "level_indexe", "levelallidce", "level_Idw", "level_ide", "levelalindex2", "level_lend", "level_idw"], "sps_id": ["sps_mid", "spps_id", "sps_ref", "sps_set", "spsappnum", "spps_ids", "spps_set", "smsappnum", "spsappmid", "spsappid", "sss_ID", "smsappmid", "sss_id", "sms_id", "sPS_ids", "sms_name", "sps_ID", "sps2num", "sms_num", "sPS_hash", "spsappID", "sPS_ref", "spsOset", "sss_version", "spspoids", "sps_name", "sPS_mid", "spspotype", "sps_hash", "spsusermid", "spsuserid", "sps_ids", "sps_num", "spspoid", "sps2id", "sps_version", "spsappdb", "sms_mid", "smsappid", "smsappname", "sss_db", "sPS_id", "sps_type", "spsappversion", "spsappname", "sPS_type", "spsOid", "spsOids", "sps2ref", "sps_db", "spspohash", "spsuserids", "sPS_num"], "i": ["ii", "ui", "I", "p", "h", "ed", "j", "f", "is", "si", "b", "v", "a", "pi", "n", "c", "o", "e", "l", "r", "u", "d", "iu", "k", "ci", "ip"], "log2_max_frame_num_minus4": ["log2_max_frame_num_mod4", "log2_max_frame_num_mod1", "log2_max_frame_num_minus6", "log2_max_frame_num_plus4", "log2_max_frame_num_plus1", "log2_max_frame_num_minus2", "log2_max_frame_num_minus1", "log2_max_frame_num_mod6", "log2_max_frame_num_plus6", "log2_max_frame_num_mod2", "log2_max_frame_num_plus2"], "sps": ["nsPS", "isports", "gpps", "samps", "esips", "sinamples", "Spps", " sls", "spr", "nseps", "spos", "Sps", "ispa", " spes", "sinps", "wsps", "asops", "dpr", " sips", "gps", " sbs", "scheeps", " spe", "isips", " sple", "sips", "sbs", "esamples", "sinple", "tsps", "Sops", "sples", "yple", " spr", " sops", "isvs", "yamples", "scheps", "spes", "asls", "cspr", "dps", "tsples", "esops", "pips", "asvs", "eseps", "asPS", "anseps", "csps", "dPS", "ispe", "yps", "tsips", "sple", "gamps", "ispr", "asrs", "wsples", "spe", "esps", " seps", "peps", "sPS", "scheips", "pPS", "rPS", "pops", "tsbs", " spa", "nsps", "sops", "aspos", "isamps", "wsips", "esPS", "dips", " srs", "sinops", "aspa", "cspes", "isrs", " svs", "reps", "isPS", "asps", "inPS", "gspps", "pple", "esple", "isls", "SPS", "gsops", "svs", "ineps", "isps", "wsbs", "seps", "nsops", "inips", "schepos", "csPS", "samples", "gPS", "asamps", "isops", " sPS", "rips", "gsPS", "pps", "aseps", "ansps", "rps", " spps", "spps", "gsps", "asips", "srs", "aspe", "asports", "anspos", " sples", "yops", "inps", "sls", "spa", " samps", "ansips", "sports", " sports"]}}
{"project": "qemu", "commit_id": "424ad8388f89f4202a7836d003273f23ebe04b09", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t oldval, newval;\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 20365, "substitutes": {"opaque": ["opac", "OPcoe", "ospaque", "oplcoe", "OPaque", "oplrice", "copac", "opque", "ospacity", "copace", "opcoe", "osprice", "opacity", "copque", "ospcoe", " opque", " opace", "oplacity", "copaque", " opac", "operac", "operque", "opace", "oplaque", "OPacity", "oprice", "operaque", "operace", "OPrice"], "addr": ["channel", "ace", "x", "src", "p", "host", "code", "acl", "pointer", "name", "frame", "type", "address", "mode", "offset", "config", "ord", "xff", "cmd", "device", "ino", "mac", "hop", "len", "asm", "align", "cb", "slot", "r", "fd", "ref", "rc", "data", "ptr", "eth", "ctx", "dr", "pad", "ad", "socket", "cmp", "sid", "ext"], "val": ["part", "update", "item", "VAL", "doc", "eval", "x", "al", "alloc", "p", "pal", "lit", "pid", "block", "local", "el", "loc", "db", "fail", "dim", "ret", "elt", "valid", "sol", "bl", "aval", "ival", "v", "rel", "len", "trial", "index", "vol", "rot", "fee", "base", "reg", "slot", "fl", "ind", "serv", "ref", "cal", "sel", "vals", "value", "cond", "pl", "ann", "split", "pos", "data", "arr", "count", "unit", "arg", "Val", "grad", "alt", "slice", "sl", "exec", "all", "ol"], "size": [" slot", " len", " bytes", "mem", "type", " arg", "length", " error", "Size", "v", "len", "buf", "SIZE", " num", " length", " n", "data", "ctx", "unit", " res", " data", " mem", "bytes"], "s": ["settings", "states", "sets", "S", "sq", "south", "rs", "secondary", "p", "sym", "ls", "aws", "h", "site", "sync", "us", "ses", "ds", "f", "fs", "is", "si", "b", "ss", "ts", "state", "n", "c", "sie", "ps", "o", "sb", "e", "l", "service", "session", "u", "services", "qs", "sup", "es", "d", "ops", "side", "ssl", "gs", "su", "m", "sys", "conf", "t", "os", "sf", "socket", "server", "self", "sl", "g", "sg", "ns", "js"], "oldval": ["newVAL", "olderVal", " oldvalid", "origVal", "oldvalid", "origvalue", "lowval", "newvalid", " oldeval", "lowVal", "newvalue", "oldervalue", " oldvalue", " oldVAL", "origeval", "newVal", "oldvalue", "oldVal", "oldeval", "olderval", "lowvalue", "oldVAL", "neweval", "olderVAL", " oldVal", "lowvalid", "origval"], "newval": ["Newvals", "freshvalue", "NEWvalid", "oldvalid", "freshval", "longvalue", "fresheval", " newpol", "longval", "fval", "fvalue", "newvals", "fVal", "NEWvalue", " neweval", " newvalue", "Newpol", "newvalid", "currentvalue", "newpol", "newvalue", " newfb", "nextvals", "NewVal", "nexteval", "nextvalue", "nextvalid", "newfb", "nextpol", "oldvals", "newVal", "rawvalid", "currentfb", "currentVal", "longVal", "Newvalue", "NEWeval", "Neweval", "Newval", "currentval", "longeval", "longvalid", "rawvalue", "Newvalid", "raweval", "freshfb", "oldVal", "NEWval", " newVal", "nextval", "oldeval", "nextVal", "currenteval", "currentvalid", "neweval", "rawval", "fvals", "oldvalue", " newvals"], "i": ["ti", "ii", "ui", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "cli", "f", "ai", "info", "ini", "ie", "ni", "si", "io", "b", "v", "a", "pi", "n", "index", "uri", "c", "isin", "uli", "o", "e", "y", "l", "vi", "adi", "xi", "u", "yi", "fi", "li", "mini", "iu", "child", "hi", "id", "m", "zi", "ci", "multi", "slice", "udi", "gi", "anti", "bi", "it", "ip"], "cpu": ["nic", "chip", " CPU", "machine", "lb", "gp", "CPU", "cache", "pai", "p", "eni", "lc", "uci", "platform", "css", "host", "core", "linux", "uca", "pse", "clock", "processor", "process", "frame", "proc", "proxy", "dim", "config", "consumer", "gpu", "net", "computer", "pc", "roc", "ram", "vm", "device", "GPU", "fc", "intel", "prem", "c", "module", "auc", "pit", "lu", "node", "cm", "np", "cp", "ips", "pu", "memory", "phy", "ci", "cmp", "component", "currency", "nc", "program", "px", "cn", "bench", "monitor", "hp", "ilo", "uu", "comp"], "cs": ["cf", "cms", "ks", "cache", "lc", "css", "sync", "cc", "core", "cases", "ac", "ds", "cus", "pc", "cers", "fs", "sc", "ss", "acs", "c", "CS", "ps", "cas", "cks", "cells", "conn", "ics", "qs", "cing", "bc", "ips", "cp", "rc", "ctx", "gs", "gb", "ci", "sys", "codes", "bs", "vs", "cons", "ns", "ls", "ces", "cn", "ec"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset,\n\n        uint64_t val, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (reg_n > 1) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n        hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                TARGET_FMT_plx \"offset\\n\", offset);\n\n    }\n\n    s->reg_set[offset >> 2] = val;\n\n\n\n    switch (reg_n) {\n\n    /* IIESR */\n\n    case 0:\n\n        /* FIXME: what if irq is pending, allowed by mask, and we allow it\n\n         * again. Interrupt will rise again! */\n\n\n\n        DPRINTF(\"%s enable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Enable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask |= val & 0xFF;\n\n        s->group[grp_quad_base_n + 1].src_mask |= (val & 0xFF00) >> 8;\n\n        s->group[grp_quad_base_n + 2].src_mask |= (val & 0xFF0000) >> 16;\n\n        s->group[grp_quad_base_n + 3].src_mask |= (val & 0xFF000000) >> 24;\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n        /* IIECR */\n\n    case 1:\n\n        DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Disable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask &= ~(val & 0xFF);\n\n        s->group[grp_quad_base_n + 1].src_mask &= ~((val & 0xFF00) >> 8);\n\n        s->group[grp_quad_base_n + 2].src_mask &= ~((val & 0xFF0000) >> 16);\n\n        s->group[grp_quad_base_n + 3].src_mask &= ~((val & 0xFF000000) >> 24);\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n    default:\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n", "idx": 20368, "substitutes": {"opaque": ["opac", "opbuf", "OPbuf", "opec", "OPaque", "OPatile", "opacity", "opatile", " opatile", "OPec", " opac", "openacity", "openaque", "openatile", "Opac", " opacity", " opbuf", "OPacity", "Opacity", "Opaque", "OPac", "openec", " opec", "Opbuf"], "offset": ["bound", "delay", "p", "f", "order", "seq", "rot", "seed", "base", "range", "ref", "et", "pos", "optional", "null", "addr", "phase", "part", "timeout", "reset", "loc", "address", "fee", "len", "align", "index", "parent", "entry", "filename", "end", "initial", "id", "shift", "alt", "slice", "set", "prefix", "ip", "axis", "location", "reference", "option", "length", "online", "error", "style", "iso", "limit", "enabled", "value", "url", "server", "skip", "operation", "image", "origin", "layout", "attribute", "alloc", "pointer", "Offset", "start", "disabled", "next", "padding", "position", "o", "slot", "alias", "alpha", "off", "layer"], "val": ["ul", "il", "VAL", "def", "eval", "x", "al", "pr", "lit", "pal", "local", "all", "bit", "Value", "el", "loc", "ret", "elt", "stat", "valid", "sol", "bl", "aval", "ut", "v", "len", "seq", "vol", "rot", "pol", "base", "reg", "slot", "fl", "pt", "serv", "ref", "cal", "sel", "vals", "value", "pl", "data", "arr", "oval", "alt", "Val", "util", "addr", "sl", "ival", "ol"], "size": ["mem", "length", "f", " sizes", "Size", "v", "fee", "len", "SIZE", "e", " length", "ize", "value", "data", "count", "g", "sec", " mem", "bytes"], "s": ["settings", "states", "sets", "S", "sq", "south", "w", "rs", "secondary", "p", "sym", "aws", "sync", "site", "sg", "us", "se", "ses", "ds", "f", "info", "status", "stats", "is", "fs", "b", "ss", "ts", "si", "a", "n", "c", "spec", "ps", "o", "sb", "e", "cs", "r", "l", "service", "session", "u", "services", "private", "details", "es", "d", "ssl", "gs", "i", "su", "m", "sys", "conf", "t", "self", "sf", "socket", "os", "sid", "server", "sl", "ls", "g", "ns", "sv", "js"], "req_quad_base_n": ["req_quad_base2p", "req_quad_base_N", "req_quad_bas_l", "req_quad_bas_n", "req_quad_base_c", "req_quad_base_t", "req_quad_base2l", "req_quad_base_p", "req_quad_base2N", "req_quad_base2n", "req_quad_base_l", "req_quad_bas_t", "req_quad_bas_c", "req_quad_bas_p", "req_quad_bas_N", "req_quad_base_num", "req_quad_base_k"], "grp_quad_base_n": ["grp_quad_base67nn", "grp_quad_Base_n", "grp_quad_base2n", "grp_quad_base67en", "grp_quad_baseqp", "grp_quad_base_nb", "grp_quad_base00n", "grp_quad_base_1", "grp_quad_base00sn", "grp_quad_Base_N", "grp_quad_part_N", "grp_quad_base__p", "grp_quad_baseqN", "grp_quad_base2name", "grp_quad_part_c", "grp_quad_base_init", "grp_quad_base001", "grp_quad_base23en", "grp_quad_base_dn", "grp_quad_part_n", "grp_quad_base_p", "grp_quad_base00p", "grp_quad_Base_c", "grp_quad_base_4", "grp_quad_base__m", "grp_quad_base67c", "grp_quad_base23c", "grp_quad_baseqn", "grp_quad_base2m", "grp_quad_type_nb", "grp_quad_base_sn", "grp_quad_base_m", "grp_quad_base_N", "grp_quad_base67init", "grp_quad_base_num", "grp_quad_base67n", "grp_quad_part_nn", "grp_quad_part_en", "grp_quad_base23n", "grp_quad_type_N", "grp_quad_base_nn", "grp_quad_base2p", "grp_quad_base_d", "grp_quad_part_p", "grp_quad_base_name", "grp_quad_base67dn", "grp_quad_base_c", "grp_quad_base_t", "grp_quad_base23nn", "grp_quad_baseqen", "grp_quad_base_en", "grp_quad_type_n", "grp_quad_base__n", "grp_quad_part_part", "grp_quad_part_num", "grp_quad_type_4", "grp_quad_base_part"], "reg_n": ["rec_t", "reg___nr", "reg_1", "reg_num", "reg_d", "Reg_nr", "reg1d", "register_fn", "res_d", "reg___o", "reg___n", "rec_num", "Reg_n", "reg1sn", "Reg_k", "reg1n", "rec_1", "reg_nr", "res_size", "Reg_o", "rec_n", "reg_k", "reg_o", "reg_sn", "register_n", "register_number", "reg_size", "res_n", "register_ns", "reg_ns", "reg1size", "reg_fn", "reg___k", "res_sn", "reg_t", "reg_number"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_submit_acl(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t handle;\n\n    int datalen, flags;\n\n    struct bt_link_s *link;\n\n\n\n    if (length < HCI_ACL_HDR_SIZE) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        return;\n\n    }\n\n\n\n    handle = acl_handle((data[1] << 8) | data[0]);\n\n    flags = acl_flags((data[1] << 8) | data[0]);\n\n    datalen = (data[3] << 8) | data[2];\n\n    data += HCI_ACL_HDR_SIZE;\n\n    length -= HCI_ACL_HDR_SIZE;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid ACL handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        /* TODO: signal an error */\n\n        return;\n\n    }\n\n    handle &= ~HCI_HANDLE_OFFSET;\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    link = hci->lm.handle[handle].link;\n\n\n\n    if ((flags & ~3) == ACL_ACTIVE_BCAST) {\n\n        if (!hci->asb_handle)\n\n            hci->asb_handle = handle;\n\n        else if (handle != hci->asb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    if ((flags & ~3) == ACL_PICO_BCAST) {\n\n        if (!hci->psb_handle)\n\n            hci->psb_handle = handle;\n\n        else if (handle != hci->psb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS */\n\n    bt_hci_event_num_comp_pkts(hci, handle | HCI_HANDLE_OFFSET, 1);\n\n\n\n    /* Do this last as it can trigger further events even in this HCI */\n\n    hci->lm.handle[handle].lmp_acl_data(link, data,\n\n                    (flags & 3) == ACL_START, length);\n\n}\n", "idx": 20370, "substitutes": {"info": ["home", "thin", "image", "def", "INFO", "about", "inf", "linux", "http", "bis", "type", "f", "config", "start", "family", "io", "init", "bug", "state", "ami", "index", "base", "from", "error", "Info", "handler", "fa", "iso", "source", "fo", "raf", "api", "afi", "id", "i", "conf"], "data": ["delay", "cache", "p", "buffer", "offset", "valid", "content", "a", "database", "base", "window", "key", "i", "pad", "multi", "open", "bytes", "version", "options", "name", "fail", "address", "results", "xxx", "len", "index", "parent", "entry", "args", "batch", "end", "size", "api", "memory", "input", "id", "shift", "Data", "array", "slice", "resource", "ip", "ui", "update", "text", "DATA", "pass", "media", "sha", "error", "dat", "style", "draw", "tail", "limit", "value", "li", "url", "missing", "zip", "image", "block", "code", "di", "load", "complete", "type", "extra", "response", "object", "start", "body", "raw", "next", "padding", "da", "message", "result", "d", "in", "one", "field", "number", "last"], "length": ["zip", "loop", "full", "part", "delay", "shape", "capacity", "line", "match", "text", "th", "section", "block", "Length", "se", "buffer", "offset", "load", "type", "address", "head", "loc", "xxx", "lock", "body", "len", "padding", "position", "library", "path", "build", "sequence", "duration", "style", "l", "message", "tail", "filename", "limit", "ph", "result", "end", "value", "size", "split", "url", "child", "count", "number", "total", "slice", "level", "angle", "ength"], "hci": ["ihii", "hlcci", "rhki", "Hcin", " hcin", "hsii", " hai", "shani", "rhcci", " hcci", " hii", "affcci", "ahcci", "hlc", "htcu", "htcci", "hcu", "hce", "rhii", " hcu", "rhini", "hc", "hcci", "ahuci", "Hcci", "hscu", "Hai", "shii", "hlcit", "fki", "hance", "fci", "hsci", "ehsi", "hcit", "hlco", "Hco", "Hcu", "hanci", "pci", "lsi", "hancu", "ehci", " hce", "hsi", "htcin", "ahcu", "hki", "rhci", "huci", "hdi", "affci", "ihci", "affuci", "ihcit", "ahii", "hancin", "hct", " hki", "hsdi", "hii", "hlcin", "hlcu", "hlii", "lci", "ahci", "hlci", "hai", "htci", "fani", "pdi", "hani", "affcin", " hdi", "hini", "rhco", " hani", "lcit", " hsi", "ihc", "hluci", "hco", "hlai", "hlini", "ehdi", "fii", "ahcin", "hcin", " hct", " hini", "ehcit", "Hci", "rhct", " hcit", " hc", "shcu", "pcu", " hco", "pii", "ldi", "hlki", "hlct", "shci", "rhcu", "shce", "shcin", "shki"], "handle": ["delay", " Handle", "write", "match", "line", "close", "carry", "use", "offset", " carry", "ignore", "hide", "device", "detail", "future", "base", "range", "old", "module", "key", "side", "hold", "pull", "share", "hash", "mount", "component", "add", "addr", "open", "term", "note", "support", "area", "name", "fail", "address", "status", "len", "align", "index", "header", "handled", "help", "ind", "hip", "end", "anch", "size", "target", "child", "memory", "id", "transfer", "group", "update", "hand", "h", "label", "host", "bridge", "mem", "force", "folder", "mode", "pass", "bind", "thread", "store", "build", "error", "handler", "style", "draw", "download", "tail", "service", "connection", "ink", "li", "url", "wrapper", "socket", "edge", "sync", "code", "route", "load", "process", "type", "object", "start", "lock", "body", "scale", "send", "path", "Handle", "alias", "conn", "result", "session", "show", "post", "port", "append", "follow"], "datalen": ["datalens", "dstalener", "dachelue", "Datalue", " dalisten", "datalener", "datalan", "Datalen", "Davalan", "dallener", " dalistened", "dalistens", "dalency", "dalength", "dallan", "dstalon", "dalisten", " datalon", "daldened", "dalon", " dalistens", "Datalan", "dachelength", "dotalen", "Davalue", "Dalen", "dmalon", "dalden", "dmalen", " datalener", "Davalen", "datalon", "dalistength", "dalens", "Dalener", "dotalency", " dstalener", " datalency", "dmalength", "daldength", "Dalon", "dalened", "davalue", " dalistength", "dallength", "dstalency", "davalan", "Davalength", "dalener", "dotalener", "davalen", "dallue", "dmalener", "dalistened", "Datalener", " datalens", " datalength", "Datalon", "davalength", "datalency", " dstalen", "daldens", "dstalen", "datalened", " datalened", "dalen", "dotalon", "datalength", "Datalength", "dallen", "dachelen", "datalue", "dallon", " dstalon", " dstalency", "dachelan", "Dalength"], "flags": ["fixes", "settings", "delay", "states", "tails", "dates", "lines", "options", "heads", "reads", "type", "status", "f", "ds", "allows", "planes", "stats", "types", "ants", "fs", "mask", "links", "strings", "members", "len", "files", "mods", "utils", "opens", "styles", "lag", "bits", "checks", "rules", "style", "ils", "Flags", "args", "tail", "fd", "groups", "ports", "kind", "vals", "details", "features", "atts", "ips", "requires", "flag", "count", "FLAG", "les", "posts", "relations", "plugins", "fields", "skip", "ags", "properties", "alls"], "link": ["delay", "write", "image", "line", "match", "light", "label", "call", "location", "local", "di", "offset", "route", "loc", "load", "type", "address", "name", "stat", "head", "Link", "lock", "hide", "bug", "links", "rel", "linked", "len", "uri", "index", "parent", "base", "path", "error", "hip", "ind", "handler", "style", "download", "l", "session", "ref", "sh", "source", "ink", "li", "read", "url", "reply", "child", "id", "field", "follow", "skip", "lib", "comment", "ip"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_flush(&s->client);\n\n}\n", "idx": 20398, "substitutes": {"bs": ["ks", "iss", "bb", "bid", "bis", "ds", "ses", "as", "fs", "bl", "b", "ss", "bh", "state", "Bs", "BS", "ps", "sb", "bits", "bos", "cs", "blocks", "fps", "pb", "es", "bc", "gs", "gb", "os", "fb", "vs", "ns", "ls", "ms", "rb", "obs", "ba"], "s": ["ins", "states", "S", "sq", "ks", "iss", "p", "sa", "ses", "ds", "stats", "is", "fs", "ss", "si", "b", "its", "a", "state", "n", "c", "ps", "sb", "o", "e", "cs", "services", "ssl", "os", "m", "vs", "sl", "ls", "ns", "sv", "js"]}}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 20410, "substitutes": {"qiov": ["Qrolet", "qwav", " qwav", "hilo", "qurolet", "qir", "Qir", "kiov", "kwav", " qilo", "kilo", " qrons", "qqiov", "hrons", "Qiov", "quiov", "hiov", "qliv", "qqliv", "kio", "qio", "quir", "qrolet", " qrolet", " qir", "Qilo", "qqrons", "qilo", "quilo", "quwav", " qliv", "hliv", "quio", " qio", "qqilo", "qrons"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "p", "h", "phi", "di", "ri", "j", "info", "f", "ai", "ie", "ini", "oi", "start", "si", "io", "b", "v", "a", "pi", "uri", "index", "c", "o", "e", "l", "xi", "u", "chi", "yi", "fi", "li", "d", "iu", "count", "k", "m", "ci", "zi", "t", "multi", "slice", "gi", "z", "mu", "bi", "it", "ip"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20422, "substitutes": {"avctx": [" avsc", "auctx", "ajctx", "avclient", "aveca", "afcmp", "apctx", "avesc", "avbc", " avcit", "avecmp", "aucmp", "aucontext", "AVca", "afclient", "afca", "avcontext", "avecontext", "afcu", "apcmp", "avectx", "avcu", "AVctx", "apcontext", "AVclient", "AVcontext", "avcmp", "avcit", "afsc", "afbc", "abctx", " avcas", " avcontext", "ajcas", "auclient", "ajcontext", "ajbc", "avcas", "avsc", "afcas", "afctx", " avbc", "avca", "abcu", "AVcmp", "apcu", "afcit", "abcontext", "avecit", "abcmp", "afcontext"], "data": ["image", "def", "cache", "uf", "DATA", "queue", "block", "code", "buff", "buffer", "frame", "val", "load", "address", "f", "length", "config", "response", "info", "func", "ata", "start", "body", "feed", "media", "len", "parent", "base", "vec", "dat", "flow", "message", "batch", "result", "meta", "source", "size", "li", "read", "progress", "video", "input", "memory", "obj", "reader", "la", "Data", "slice", "record", "bytes"], "data_size": ["data\u00b7scale", "data_scale", "batch_small", "data_small", "data_fee", "batch_time", " data_scale", "batch_source", "data\u00b7fee", "data_source", " data_fee", "batch_size", "data_time", "data\u00b7size"], "avpkt": ["avlpcht", "afPct", "abfconn", "abfkt", "afPacket", "avpecht", "avfconn", "avvpacket", "avvpconn", "avvpkt", "avppka", "avpct", "avlpconn", "abfkn", "avpconn", "afPka", "avppct", "avPkt", "avppkt", "avpcht", " avpcht", " avpeft", " avpft", " avpecht", "abpkn", "avfct", "abpkt", "afpkt", "afpacket", "avPct", "abfacket", "avlpctx", "afpka", "avPacket", " avpectx", "avfkt", "avlpacket", "avlpkt", "avfka", "avlpkn", "avppacket", " avpekt", "avfpcht", "avPka", "avpft", " avpctx", "afPkt", "abpconn", "avpkn", "avlpft", "afpct", "avfpkt", "avpka", "avvpkn", "avpctx", "avpeft", "avfkn", "avpectx", "avfpctx", "avpacket", "avfpft", "avpekt", "avfacket", "abpacket"], "buf": ["cap", "br", "cf", "wb", "cache", "uf", "alloc", "bb", "queue", "block", "img", "buff", "buffer", "val", "proc", "f", "config", "uc", "b", "feat", "base", "cb", "vec", "cas", "flow", "fd", "batch", "ref", "pb", "bag", "bc", "rc", "pad", "la", "fb", "array", "rb", "pool"], "seq": ["zip", "req", "sq", "clus", "cl", "iter", "cv", "cache", "jp", "lc", "iq", "queue", "que", "code", "cc", "pse", "val", "frame", "rev", "buff", "cli", "wave", "config", "sequ", "q", "coll", "sci", "uc", "xxx", "cmd", "feed", "lex", "sub", "feat", "cas", "vec", "sequence", "acc", "aux", "select", "ref", "sel", "fam", "fi", "qa", "bc", "job", "ctx", "sem", "pkg", "la", "ctrl", "cmp", "slice", "context", "exec", "sec", "ec", "comp"]}}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static ssize_t imx_fec_receive(NetClientState *nc, const uint8_t *buf,\n\n                               size_t len)\n\n{\n\n    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));\n\n    IMXFECBufDesc bd;\n\n    uint32_t flags = 0;\n\n    uint32_t addr;\n\n    uint32_t crc;\n\n    uint32_t buf_addr;\n\n    uint8_t *crc_ptr;\n\n    unsigned int buf_len;\n\n    size_t size = len;\n\n\n\n    FEC_PRINTF(\"len %d\\n\", (int)size);\n\n\n\n    if (!s->regs[ENET_RDAR]) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Unexpected packet\\n\",\n\n                      TYPE_IMX_FEC, __func__);\n\n        return 0;\n\n    }\n\n\n\n    /* 4 bytes for the CRC.  */\n\n    size += 4;\n\n    crc = cpu_to_be32(crc32(~0, buf, size));\n\n    crc_ptr = (uint8_t *) &crc;\n\n\n\n    /* Huge frames are truncated.  */\n\n    if (size > ENET_MAX_FRAME_SIZE) {\n\n        size = ENET_MAX_FRAME_SIZE;\n\n        flags |= ENET_BD_TR | ENET_BD_LG;\n\n    }\n\n\n\n    /* Frames larger than the user limit just set error flags.  */\n\n    if (size > (s->regs[ENET_RCR] >> 16)) {\n\n        flags |= ENET_BD_LG;\n\n    }\n\n\n\n    addr = s->rx_descriptor;\n\n    while (size > 0) {\n\n        imx_fec_read_bd(&bd, addr);\n\n        if ((bd.flags & ENET_BD_E) == 0) {\n\n            /* No descriptors available.  Bail out.  */\n\n            /*\n\n             * FIXME: This is wrong. We should probably either\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n        } else {\n\n            s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n        }\n\n        imx_fec_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n", "idx": 20425, "substitutes": {"nc": ["dc", "nic", "mc", "nd", "kt", "cms", "gc", "nm", "lc", "cc", "nn", "roc", "pc", "uc", "irc", "anc", "sc", "ct", "fc", "n", "c", "NC", "cs", "conn", "nt", "nw", "rn", "ne", "bc", "rc", "nec", "cdn", "ctx", "org", "ci", "cn", "ns", "ec"], "buf": ["cap", "br", "cf", "doc", "box", "wb", "cv", "uf", "alloc", "src", "prop", "queue", "mem", "bb", "buff", "buffer", "db", "config", "uc", "bf", "cmd", "b", "bl", "raw", "seq", "cb", "cas", "vec", "fd", "pb", "ff", "fi", "port", "bc", "rc", "data", "ctx", "gb", "fb", "rb"], "len": ["full", "line", "lc", "en", "enc", "Len", "block", "lf", "num", "lim", "el", "val", "ln", "offset", "low", "length", "lan", "loc", "bl", "seq", "bin", "n", "SIZE", "fl", "l", "conn", "args", "limit", "str", "size", "gen", "pos", "data", "count", "alt", "lib", "z", "all"], "s": ["sts", "states", "S", "sq", "south", "rs", "iss", "secondary", "p", "sym", "ls", "site", "sync", "sa", "rss", "ses", "status", "f", "stat", "sec", "is", "fs", "si", "sc", "b", "ts", "ss", "state", "n", "c", "spec", "hs", "ps", "sb", "o", "serv", "cs", "e", "r", "service", "session", "services", "qs", "uns", "d", "es", "ssl", "gs", "self", "m", "sys", "conf", "t", "sf", "sl", "ns", "sg", "g", "js"], "bd": ["nd", "dc", "bm", "hd", "pd", "wb", "nm", "bb", " kb", "cd", "ib", "dt", "db", "ds", " b", "td", "md", "bg", "nb", "bf", "bl", "b", "gd", "bt", "sth", "board", "cb", "sb", "da", "kb", "fd", "pb", "obb", "dd", "d", "bc", "data", "sd", "gb", "ad", "bn", "BD", "fb", "bs", "od", "vd", "ld", "rb", "ba"], "addr": ["adr", "ace", "cap", "origin", " address", "nm", "src", "alloc", "bb", "host", "area", "code", "acl", "route", "ac", "offset", "rt", "loc", "db", "ord", "address", "el", "config", "md", "ip", "func", "ack", "cmd", "seq", "align", "index", "amp", "cb", "da", "nl", "conn", "fd", "amd", "dist", "dd", "size", "layer", "np", "pos", "coord", "rc", "data", "attr", "ptr", "url", "dr", "gb", "ad", "cmp", "er", "node", "rg", "ext", "ann"], "crc": ["lcsc", "crs", "circ", "lcloc", "cloc", "Cpc", "lcpc", "lcfc", " cbc", "cfc", "Cloc", " cloc", "csc", " crs", "fbc", "cpc", "Crs", "Csc", "cbc", "frs", " cpc", "fpc", " circ", "lcbc", "Crc", " csc", "frc", "lcrc", "lcrs", "firc", " cfc", "ffc", "Circ"], "buf_addr": [" buf_data", "buf_data", "buf4ptr", " buf_pos", "buf4pointer", "buf_pos", "buf_length", "cb_pointer", "buf_pointer", "buf2addr", "uf_pos", "buf4length", "buf2len", "cb_addr", "uf_len", "buf2pos", "buf_dr", "cb_length", "buf4addr", "buf_ptr", "cb_ptr", "uf_addr", "uf_dr", "buf2data"], "crc_ptr": ["cpc_len", "cpc2ctr", "cpc_ptr", "crc2ctr", "crc_len", "crc2str", "crc2len", "crc2ptr", "cpc2addr", "crc_str", "crc_addr", "crc2addr", "cRC_str", "cpc_addr", "cRC_ptr", "crc_offset", "cRC_offset", "cpc2ptr", "crc_ctr", "cRC_addr", "cpc_ctr", "crc2offset", "cpc2len"], "buf_len": ["buffer_len", "bufPgen", "buffer_lf", "blockssize", "buf2size", "tmp_val", "buf_lin", "block_len", "tmpJlin", "bufGsize", "bufJlen", "bufsln", "buf_lf", "block_size", "bufsval", "bufspos", "buf_limit", "bufGcount", "tmpJval", "tmp_lin", "buf_size", "buff_pos", "blockscount", "buffer_Len", "bufssize", "bufslen", "buffer_block", "buffsln", "buff_ln", "buf_ln", "bufnval", "buf2count", "buffer_val", "uf_len", "block_pos", "bufJlf", "bufJgen", "buffslen", "buf_count", "bufnlen", "buffer_length", "blockslen", "uf_limit", "bufGlen", "tmpJgen", "buf_block", "bufJval", "buff_len", "buffspos", "buf2len", "bufPval", "buf_val", "bufJlin", "tmp_gen", "bufscount", "bufslength", "uf_line", "uf_val", "blockspos", "buf_line", "block_count", "buf_gen", "bufPlin", "tmp_len", "buf_pos", "buf_length", "bufPlen", "buf_Len", "buf2pos", "bufnlf", "tmpJlen", "bufGpos", "bufnblock", "bufsLen", "bufJblock"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n", "idx": 20433, "substitutes": {"env": ["req", "cv", "cache", "app", "eng", "ep", "dev", "enable", "oa", "org", "conf", "vs", "act", "ec", "ext", "global", "stage", "ev", "jp", "event", "en", "ea", "forge", "core", "her", "db", "config", "entry", "e", "ng", "manager", "advert", "viron", "qa", "Environment", "np", "environment", "eu", "erg", "console", "esi", "eve", "gui", "enc", "site", "net", "vm", "v", "export", "nw", "output", "ne", "scope", "ctx", "server", "eni", "code", "que", "dt", "ah", "exc", "here", "engine", "conn", "erv", "vp", "plugin", "enos", "obj", "er", "nc", "context", "exec", "network", "loader"], "bp": ["po", "lb", "bm", "BIP", "br", "gp", "pd", "pa", "jp", "p", "bb", "lc", "cpu", "BP", "pg", "bg", "pc", "bf", "vm", "b", "pp", "adj", "lp", "sb", "bps", "cb", "conn", "kb", "xp", "fp", "pb", "vp", "bsp", "tp", "bc", "np", "cp", "sp", "cpp", "gb", "esp", "fb", "ap", "eb", "hp", "wp", "rb"]}}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "substitutes": {"widget": ["ui", "console", "w", "gui", "ac", "cli", "poll", "q", "win", "owl", "wx", "view", "fw", "pipe", "fl", "draw", "ou", "ch", "window", "plugin", "Widget", "input", "ogg", "client", "util", "lib", "wp"], "button": ["class", "p", "pin", "focus", "module", "key", "icon", "bc", "pull", "data", "down", "fb", "component", "open", "comment", "loop", "timeout", "event", "current", "config", "touch", "callback", "action", "page", "api", "target", "flag", "input", "category", "shift", "cell", "channel", "element", "ui", "att", "title", "text", "gui", "label", "option", "bug", "html", "Button", "submit", "toggle", "error", "patch", "style", "press", "select", "or", "connection", "url", "atom", "skip", "attribute", "color", "code", "type", "click", "object", "document", "lock", "trigger", "next", "password", "span", "plugin", "off", "command", "bot", "editor", "field", "number", "ctrl", "feature", "delete"], "opaque": ["opac", "OPaqu", " opchid", "OPaque", "Opaqu", "opchid", "opacity", "obaque", "Opchid", " opaqu", " opacity", "OPchid", "opaqu", "oppaque", "obac", "OPaques", "Opacity", "OPacity", "oppaques", "Opaque", "OPac", "opaques", "obaques", "oppac"], "vc": ["dc", "cf", "gc", "cv", "nv", "cu", "lc", "gui", "bb", "ac", "wl", "cli", "vv", "pc", "oc", "win", "wx", "c", "fw", "cs", "VC", "conn", "vt", "hw", "service", "ch", "vp", "wp", "bc", "ic", "vim", "rc", "iw", "ogg", "tc", "input", "ctx", "gb", "sys", "ci", "ctrl", "vg", "util", "nc", "voc", "qt", "serv"], "s": ["settings", "states", "S", "south", "w", "secondary", "p", "h", "less", "site", "sync", "sg", "ses", "status", "f", "xs", "stats", "is", "fs", "ss", "si", "b", "sis", "state", "c", "sie", "o", "sb", "storage", "e", "cs", "space", "screen", "args", "session", "services", "qs", "es", "d", "ssl", "scope", "i", "self", "m", "sys", "os", "sf", "server", "sl", "ns", "spec", "g", "sv", "js"], "btn": ["dc", "typ", "kt", "bolt", "colour", "wb", "yout", "jp", "src", "bb", "lc", "gui", "butt", "dt", "nn", "cli", "config", "bg", "click", "touch", "cmd", "b", "focus", "fc", "ct", "callback", "bug", "wx", "bt", "Button", "c", "affle", "cb", "sb", "tick", "toggle", "fl", "bp", "ou", "fp", "token", "batch", "wt", "bc", "bot", "qa", "tn", "input", "lvl", "kk", "t", "txt", "fb", "ctrl", "ctl", "kn", "nc", "ko", "rl", "mot", "tag", "cn", "wp", "qt"]}}
{"project": "FFmpeg", "commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "target": 1, "func": "static void * attribute_align_arg worker(void *v){\n\n    AVCodecContext *avctx = v;\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    AVPacket *pkt = NULL;\n\n\n\n    while(!c->exit){\n\n        int got_packet, ret;\n\n        AVFrame *frame;\n\n        Task task;\n\n\n\n        if(!pkt) pkt= av_mallocz(sizeof(*pkt));\n\n        if(!pkt) continue;\n\n        av_init_packet(pkt);\n\n\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {\n\n            if(c->exit){\n\n                pthread_mutex_unlock(&c->task_fifo_mutex);\n\n                goto end;\n\n            }\n\n            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);\n\n        }\n\n        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n        frame = task.indata;\n\n\n\n        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);\n\n        pthread_mutex_lock(&c->buffer_mutex);\n\n        av_frame_unref(frame);\n\n        pthread_mutex_unlock(&c->buffer_mutex);\n\n        av_frame_free(&frame);\n\n        if(got_packet) {\n\n            int ret2 = av_dup_packet(pkt);\n\n            if (ret >= 0 && ret2 < 0)\n\n                ret = ret2;\n\n        } else {\n\n            pkt->data = NULL;\n\n            pkt->size = 0;\n\n        }\n\n        pthread_mutex_lock(&c->finished_task_mutex);\n\n        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;\n\n        c->finished_tasks[task.index].return_code = ret;\n\n        pthread_cond_signal(&c->finished_task_cond);\n\n        pthread_mutex_unlock(&c->finished_task_mutex);\n\n    }\n\nend:\n\n    av_free(pkt);\n\n    pthread_mutex_lock(&c->buffer_mutex);\n\n    avcodec_close(avctx);\n\n    pthread_mutex_unlock(&c->buffer_mutex);\n\n    av_freep(&avctx);\n\n    return NULL;\n\n}\n", "idx": 20457, "substitutes": {"v": ["ve", "cv", "p", "nv", "h", "f", "uv", "vv", "vm", "b", "n", "vol", "VC", "r", "l", "vt", "va", "u", "vp", "V", "conv", "vim", "lv", "k", "vc", "m", "t", "vs", "util", "vd", "g", "sv"], "avctx": ["awlc", "avlc", "awcontext", "avcontext", "AVci", "afcli", "avecontext", "afcu", "avconn", "avcu", "avectx", "AVctx", "avcli", "afconn", "AVcontext", "awcu", "AVconn", " avcontext", "avecli", " avcli", "avci", "afci", "avelc", " avconn", "afctx", "avecu", "aveconn", "aveci", "aflc", "awctx", "afcontext"], "c": ["C", "dc", "mc", "cf", "cy", "cl", "xc", "cache", "cv", "p", "lc", "cu", "h", "call", "cd", "core", "cc", "co", "ac", "ce", "f", "s", "coll", "pc", "cr", "uc", "cur", "anc", "oc", "b", "sc", "fc", "ct", "n", "con", "ca", "e", "cs", "l", "conn", "r", "ch", "chain", "u", "can", "cm", "arc", "d", "unc", "bc", "cp", "ic", "tc", "rc", "ctx", "vc", "k", "m", "ci", "conf", "t", "abc", "ctrl", "nc", "cn", "g", "rec", "ec", "icc"], "pkt": ["wpacket", " packet", "tcht", "spkt", "Pcht", "wet", "jpkt", "paet", "melt", "welt", " pkg", "pft", "packet", "pekt", "tet", "wpkt", "mkg", "mnt", " pct", "pakt", "telt", "pkg", "pct", " pnt", "pnt", "pett", "tkid", "bet", "Pqt", "paelt", " pft", "pacht", "Pkid", "bkg", "wpet", "tpkt", "Packet", "tpct", "peft", "fnt", "Pet", "pkid", "pet", "tett", "pelt", "Pelt", "Pdt", " pkid", "wpcht", "feth", "jpct", "mkt", "bcht", "Peth", "spet", "tqt", "padt", " pcht", "tft", "fet", "jpet", "mdt", " pdt", " pett", "spacket", "macket", "bkt", "peett", "spelt", "tacket", "Pkg", " pet", "wcht", "tpelt", "tpdt", "Pct", "peth", "bnt", "Pkt", "wkt", "fkt", "pqt", "pdt", " peth", "pact", "facket", "tkt", "bqt", "peqt", "backet", "belt", "jpacket", "tct", "Pnt", "pcht", "felt", " pqt", " pelt"], "got_packet": ["got_packET", "got_fixacket", "got_packageets", "got_compet", "got_compacket", "got_capET", "got_packeline", "got_capacket", "got_codeline", "got_packseline", "got_packsET", "got_codel", "got_packageel", "got_packageacket", "got_packageeter", "got_packel", "got_packete", "got_packsacket", "got_packsel", "got_packageet", "got_compete", "got_capet", "got_packacket", "got_codacket", "got_fixet", "got_packageete", "got_fixeter", "got_packageeline", "got_packsets", "got_capets", "got_fixete", "got_packageET", "got_competer", "got_packets", "got_codet", "got_packeter", "got_packset"], "ret": ["desc", "att", "match", "def", "res", "rets", "en", "lit", "code", "num", "cat", "bit", "val", "rt", "rev", "db", "det", "ft", "status", "valid", "lt", "sr", "mt", "bf", "ut", "RET", "rb", "len", "gt", "rot", "feat", "fun", "reg", "nt", "result", "ref", "opt", "reply", "url", "re", "flag", "obj", "rc", "arg", "fin", "alt", "success", "Ret", "sec", "let", "ext"], "frame": ["channel", "part", "kt", "element", "image", "iframe", "setup", "flake", "jo", "figure", "fe", "rame", "code", "plane", "nn", "fab", "j", " Frame", "f", "za", "el", "object", "fr", "body", "b", "bug", "html", "game", "view", "thread", "position", "feat", "framework", "e", "style", "Frame", "flow", "hole", "module", "session", "ze", "point", "fi", "layer", "worker", "target", "video", "data", "frames", "fake", "face", "fb", "slice", "component", "feature", "fram", "camera", "qt", "wk"], "task": ["channel", "ace", "time", "item", "shape", "image", "class", "event", "ask", "test", "call", "sync", "block", "code", "co", "name", "process", "type", "pack", "proc", "complete", "config", "load", "object", "word", "func", "course", "ack", "tf", "week", "device", "game", "thread", "feat", "ck", "table", "ork", "patch", "tx", "message", "module", "service", "result", "session", "j", "layer", "instance", "target", "Task", "worker", "obj", "tc", "container", "job", "kk", "unit", "t", "work", "component", "slice", "exec", "tag", "node", "project", "piece", "remote"]}}
{"project": "qemu", "commit_id": "86865c5ff16bd1a2ef2b9ce217a7bb8f39e2126c", "target": 1, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n    /* This code tries to make movcal emulation sufficiently\n\n       accurate for Linux purposes.  This instruction writes\n\n       memory, and prior to that, always allocates a cache line.\n\n       It is used in two contexts:\n\n       - in memcpy, where data is copied in blocks, the first write\n\n       of to a block uses movca.l for performance.\n\n       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used\n\n       to flush the cache. Here, the data written by movcal.l is never\n\n       written to memory, and the data written is just bogus.\n\n\n\n       To simulate this, we simulate movcal.l, we store the value to memory,\n\n       but we also remember the previous content. If we see ocbi, we check\n\n       if movcal.l for that address was done previously. If so, the write should\n\n       not have hit the memory, so we restore the previous content.\n\n       When we see an instruction that is neither movca.l\n\n       nor ocbi, the previous content is discarded.\n\n\n\n       To optimize, we only try to flush stores when we're at the start of\n\n       TB, or if we already saw movca.l in this TB and did not flush stores\n\n       yet.  */\n\n    if (ctx->has_movcal)\n\n\t{\n\n\t  int opcode = ctx->opcode & 0xf0ff;\n\n\t  if (opcode != 0x0093 /* ocbi */\n\n\t      && opcode != 0x00c3 /* movca.l */)\n\n\t      {\n\n\t\t  gen_helper_discard_movcal_backup ();\n\n\t\t  ctx->has_movcal = 0;\n\n\t      }\n\n\t}\n\n\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\t\t\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(low, REG(B7_4));\n\n\t    tcg_gen_bswap16_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, addr, 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n#define LD(reg,ldnum,ldpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\n\n#define ST(reg,stnum,stpnum,prechk)\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_gen_mov_i32(REG(B11_8), addr);\t\t\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n\tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\\n\n\tST(reg,stnum,stpnum,prechk)\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)\n\n\tLD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n        {\n\n            TCGv val = tcg_temp_new();\n\n            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);\n\n            gen_helper_movcal (REG(B11_8), val);            \n\n            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n        }\n\n        ctx->has_movcal = 1;\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    gen_helper_ocbi (REG(B11_8));\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 20467, "substitutes": {"ctx": ["dc", "cv", "cu", "lc", "css", "gpu", "anc", "utils", "ca", "cas", "cs", "bc", "gs", "conf", "pkg", "la", "grad", "component", "wp", "support", "crit", "xc", "jp", "cc", "loc", "cli", "config", "Context", "cmd", "sc", "fw", "hs", "cgi", "std", "cm", "qa", "np", "rc", "mc", "cfg", "console", "parse", "na", "sci", "git", "wx", "c", "hw", "fp", "connection", "conv", "tc", "scope", "cca", "cpp", "ci", "client", "cam", "cf", "gc", "sync", "fc", "ct", "ck", "cb", "tx", "conn", "kb", "wcs", "cp", "vc", "ctrl", "cmp", "nc", "context", "cn", "exec"], "CHECK_NOT_DELAY_SLOT": ["CHECK_NOT_DELAY_BLAT", "CHECK_NOT_DELAYEDSLOST", "CHECK_NOT_DELAYEDLOTS", "CHECK_NOT_DELAY_SlOTS", "CHECK_NOT_DELAY_SlORT", "CHECK_NOT_DELAY_LOST", "CHECK_NOT_DELAY_ALLORT", "CHECK_NOT_DELAYEDSLOTS", "CHECK_NOT_DELAY_SlOT", "CHECK_NOT_DELAYEDLORT", "CHECK_NOT_DELAY_SLOTS", "CHECK_NOT_DELAYEDLOST", "CHECK_NOT_DELAY_BLOT", "CHECK_NOT_DELAY_ALLOTS", "CHECK_NOT_DELAY_SlOST", "CHECK_NOT_DELAYEDSLORT", "CHECK_NOT_DELAY_LOT", "CHECK_NOT_DELAY_SLOST", "CHECK_NOT_DELAY_LOTS", "CHECK_NOT_DELAY_ALLOST", "CHECK_NOT_DELAYEDSLOT", "CHECK_NOT_DELAY_LAT", "CHECK_NOT_DELAY_BLOTS", "CHECK_NOT_DELAY_LORT", "CHECK_NOT_DELAY_Lot", "CHECK_NOT_DELAY_BLot", "CHECK_NOT_DELAY_SLAT", "CHECK_NOT_DELAYEDLOT", "CHECK_NOT_DELAY_SLot", "CHECK_NOT_DELAY_SLORT", "CHECK_NOT_DELAY_ALLOT"], "delayed_pc": ["delaying_path", "delaying_pc", "delayedThePC", "delayedThepid", "delayed_PC", "delayed_mc", "delaying_mc", "delayedThepath", "delayedThepc", "delaying_pid", "delayed_pid", "delayed_path", "delaying_PC"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471, "substitutes": {"opaque": ["oifice", "ospaque", "opifice", "ospacity", "opesc", "ospaques", "opacity", "octaques", "oacity", "octaque", "octacity", "octifice", " opacity", " opaques", "oaques", "ospesc", "Opacity", "Opaque", "Opaques", "Opesc", "oaque", " opifice", " opesc", "opaques"], "hz": ["cz", "loop", "delay", "kh", "MHz", "sync", "depth", "clock", "cpu", "broad", "GHz", "length", "wave", "xxx", "rh", "ss", "hh", "fee", "len", "height", "padding", "scale", "cb", "Hz", "hw", "hello", "fps", "kHz", "tz", "size", "icity", "hash", "count", "phy", "eth", "conf", "abc", "bass", "dy", "az", "frequency", "z", "density"], "s": ["settings", "sets", "S", "sq", "south", "secondary", "p", "sym", "sync", "ses", "an", "f", "is", "fs", "b", "ss", "ts", "v", "native", "a", "n", "padding", "c", "opens", "spec", "sb", "o", "submit", "ruby", "e", "r", "l", "session", "u", "services", "es", "d", "features", "ops", "ssl", "i", "m", "t", "plugins", "socket", "g", "sl", "ns", "new", "js"]}}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_dma_write(BlockBackend *blk,\n\n                         int64_t sector_num, int nb_sectors,\n\n                         void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    dma_addr_t dma_addr, dma_len;\n\n    void *mem;\n\n    int nsector, remainder;\n\n    int extra = 0;\n\n\n\n    qemu_iovec_destroy(&io->iov);\n\n    qemu_iovec_init(&io->iov, io->len / MACIO_PAGE_SIZE + 1);\n\n\n\n    if (io->remainder_len > 0) {\n\n        /* Return remainder of request */\n\n        int transfer = MIN(io->remainder_len, io->len);\n\n\n\n        MACIO_DPRINTF(\"--- processing write remainder %x\\n\", transfer);\n\n        cpu_physical_memory_read(io->addr,\n\n                                 &io->remainder + (0x200 - transfer),\n\n                                 transfer);\n\n\n\n        io->remainder_len -= transfer;\n\n        io->len -= transfer;\n\n        io->addr += transfer;\n\n\n\n        s->io_buffer_index += transfer;\n\n        s->io_buffer_size -= transfer;\n\n\n\n        if (io->remainder_len != 0) {\n\n            /* Still waiting for remainder */\n\n            return;\n\n        }\n\n\n\n        MACIO_DPRINTF(\"--> prepending bounce buffer with size 0x200\\n\");\n\n\n\n        /* Sector transfer complete - prepend to request */\n\n        qemu_iovec_add(&io->iov, &io->remainder, 0x200);\n\n        extra = 1;\n\n    }\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        sector_num = (int64_t)(s->lba << 2) + (s->io_buffer_index >> 9);\n\n    } else {\n\n        sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    }\n\n\n\n    nsector = (io->len >> 9);\n\n    remainder = io->len - (nsector << 9);\n\n\n\n    MACIO_DPRINTF(\"--- DMA write transfer - addr: %\" HWADDR_PRIx \" len: %x\\n\",\n\n                  io->addr, io->len);\n\n    MACIO_DPRINTF(\"xxx remainder: %x\\n\", remainder);\n\n    MACIO_DPRINTF(\"xxx sector_num: %\"PRIx64\"   nsector: %x\\n\",\n\n                  sector_num, nsector);\n\n\n\n    dma_addr = io->addr;\n\n    dma_len = io->len;\n\n    mem = dma_memory_map(&address_space_memory, dma_addr, &dma_len,\n\n                         DMA_DIRECTION_TO_DEVICE);\n\n\n\n    if (!remainder) {\n\n        MACIO_DPRINTF(\"--- DMA write aligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, io->len);\n\n        qemu_iovec_add(&io->iov, mem, io->len);\n\n    } else {\n\n        /* Write up to last complete sector */\n\n        MACIO_DPRINTF(\"--- DMA write unaligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, (nsector << 9));\n\n        qemu_iovec_add(&io->iov, mem, (nsector << 9));\n\n\n\n        MACIO_DPRINTF(\"--- DMA write read    - bounce addr: %p \"\n\n                      \"remainder_len: %x\\n\", &io->remainder, remainder);\n\n        cpu_physical_memory_read(io->addr + (nsector << 9), &io->remainder,\n\n                                 remainder);\n\n\n\n        io->remainder_len = 0x200 - remainder;\n\n\n\n        MACIO_DPRINTF(\"xxx remainder_len: %x\\n\", io->remainder_len);\n\n    }\n\n\n\n    s->io_buffer_size -= ((nsector + extra) << 9);\n\n    s->io_buffer_index += ((nsector + extra) << 9);\n\n\n\n    io->len = 0;\n\n\n\n    MACIO_DPRINTF(\"--- Block write transfer   - sector_num: %\"PRIx64\"  \"\n\n                  \"nsector: %x\\n\", sector_num, nsector + extra);\n\n\n\n    m->aiocb = blk_aio_writev(blk, sector_num, &io->iov, nsector + extra, cb,\n\n                              io);\n\n}\n", "idx": 20480, "substitutes": {"blk": ["plk", " blks", "Blks", "blK", " blK", "blkt", "blks", "plK", "plks", "Blk", "plkt", "BlK", "Blkt", " blkt"], "sector_num": ["sectorFoffset", "sector__n", "sector_offset", "section_offset", " sector_n", "sectorFsum", "sectorFnumber", " sector_index", "sector_orig", "section_number", "sector_name", " sector_name", "sector__num", "sectorFnum", "sector_index", " sector_orig", "sector__number", "sector_n", "sector__orig", "sector_sum", " sector_number", "sector_number", "section_sum", "section_num"], "nb_sectors": ["nb_vegments", "nb_vecs", "nb_seccs", "nb_psegment", "nb_secs", "nb_segments", "nb_secgment", "nb_vectors", "nb_secgments", "nb_vegment", "nb_secctors", "nb_segment", "nb_psectors", "nb_psegments", "nb_psecs"], "cb": ["dc", "cv", "orb", "sync", "core", "buff", "proc", "func", "CB", "callback", "seq", "buf", "fun", "ync", "aux", "fp", "ref", "ctr", "cm", "ob", "unc", "bc", "cp", "ctx", "ctrl", "cmp", "lib", "exec", "rb"], "opaque": ["opac", "compacity", "obque", "offaque", " opca", "OPaque", "copac", "opque", "OPca", "opacity", " opque", "opca", "copacity", "obaque", "copaque", "operaques", "compca", " opac", "opacs", "operac", "operca", "compac", "copaques", " opacity", "obca", "preac", " opaques", "obac", "operacity", "operaque", " opacs", "preaque", "preacity", "OPac", "OPque", "operacs", "offacity", "compaque", "opaques", "offac", "preca", "offacs"], "io": ["interface", "cache", "p", "use", "co", "ex", "info", "f", "ro", "si", "device", "storage", "source", "fo", "i", "multi", "IO", "office", "lib", "no", "po", "global", "timeout", "area", "bit", "ri", "mo", "go", "cli", "to", "config", "ki", "rio", "entry", "cgi", "flow", "hub", "api", "input", "ao", "ip", "ui", "w", "bo", "mode", "option", "ie", "net", "error", "service", "hw", "connection", "output", "copy", "ne", "cho", "wrapper", "client", "server", "gio", "op", "zip", "image", "ion", "sync", "iol", "di", "http", "object", "so", "audio", "o", "engine", "boot", "out", "obj", "su", "lo", "ilo", "exec"], "m": ["dm", "mc", "machine", "bm", "mx", "gm", "wm", "p", "h", "tm", "M", "mode", "f", "an", "im", "b", "mm", "media", "v", "n", "c", "sm", "e", "y", "r", "l", "module", "manager", "meta", "cm", "d", "om", "mi", "em", "g", "ms", "fm", "mu"], "s": ["settings", "ins", "sets", "S", "sq", "ks", "rs", "p", "sym", "ls", "sync", "us", "http", "ses", "sim", "f", "ds", "ions", "xs", "is", "fs", "si", "sc", "so", "v", "b", "ss", "ts", "a", "its", "c", "ps", "sie", "o", "sm", "storage", "sb", "e", "cs", "serv", "r", "l", "service", "session", "services", "qs", "source", "es", "d", "ops", "uns", "ssl", "in", "gs", "sp", "i", "os", "sys", "su", "t", "server", "sl", "g", "spec", "ns", "sv", "js"], "dma_addr": ["dna_addr", "dma_host", "dna_len", "dna_host", "dna_address", "dma_address"], "dma_len": ["dma_ln", "dva_ln", "dma__ln", "dma__Len", "dva_len", "dma__den", "dma_Len", "dva_Len", "dma__len", "dva_den", "dma_den"], "mem": ["mx", "cache", "alloc", "lim", "mo", "mode", "info", "mop", "ro", "ram", "vm", "mm", "mp", "temp", "mod", "Mem", "mb", "tmp", "meta", "sh", "rem", "copy", "memory", "ctx", "mi", "server", "mon", "serv"], "nsector": [" Nsection", "unconnection", "nnsection", "Nsection", "Nchannel", " Nsector", "numconnection", "nconnection", "Nconnection", "nsection", "numsector", "nplayer", "numchannel", " naxis", " nplayer", "unchannel", "narea", "nnsector", " narea", "unsection", "numsection", "nchannel", "unsector", " Nplayer", " Naxis", "naxis", "Nsector", "numarea", "Narea", "nnplayer", " nsection", "nnaxis"], "remainder": ["remainsner", "remireder", " remainter", " remrainden", "remainedter", "remainter", "remainingDER", "remainingcer", "remiverder", "REMainter", "remrainner", "remrainden", "remivercer", " remraincer", " remainingner", "remraincer", "remiverden", "remainsder", "remainster", "remaindr", " remainingter", "remiverner", "remirener", " remainden", "remainingner", " remainedder", "retaindr", "retainner", "remainden", " remrainder", " remainner", "remainsDER", " remainDER", "retainsdr", " remaineddr", "remainingdr", "retainter", " remaincer", " remrainner", "remainsdr", "REMainedDER", "retainsner", "REMainner", "remainedder", "remainscer", "remaincer", " remaindr", "remainner", " remainingDER", "remainingder", "retainster", "remireter", "remainedden", "REMainder", "REMainedter", "REMainDER", "remainedner", "retainsder", " remainingder", " remainedner", "retainder", "REMainedder", "remireDER", "REMainedner", "remainedDER", "remainDER", "remainedcer", "remaineddr", " remainedcer", "remrainder", "remainingter"]}}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n", "idx": 20485, "substitutes": {"bs": ["lb", "ins", "ks", "rs", "iss", "bb", "css", "als", "sync", "bid", "db", "bis", "ds", "ses", "banks", "bas", "xs", "fs", "bl", "b", "ss", "bh", "Bs", "BS", "ps", "base", "bits", "sb", "bps", "bos", "cb", "cs", "blocks", "bes", "lbs", "pb", "es", "ops", "bc", "outs", "obj", "bing", "gs", "gb", "os", "fb", "vs", "las", "ubs", "ns", "ls", "obs", "ba", "js"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 20495, "substitutes": {"iommu_mr": ["iommuit_rr", "iommur_mr", "iommu__mi", "iommu_rs", "iommuit__rr", "iommu_mid", "iommuit__mi", "iommu_vr", "iommuit_mr", "iommuit_mid", "iommu_rr", "iommu__rr", "iommu_br", "iommur_rs", "iommur_br", "iommu__mid", "iommur_vr", "iommu__mr", "iommuit__mr", "iommu_mi", "iommuit_mi", "iommuit__mid"], "n": ["x", "w", "nm", "p", "h", "num", "nn", "j", "f", "net", "nb", "b", "v", "a", "c", "o", "e", "y", "r", "l", "nat", "nt", "N", "u", "d", "ne", "k", "i", "self", "m", "t", "fn", "dn", "nc", "network", "ns", "g", "node", "sn"], "vtd_as": ["vdd_ac", "vtdikat", "vdtikcache", "vdt_as", "vdd_as", "vdat_las", "vtd7state", "vtdocknas", "vtdockwith", "vtd_ac", "vpc_ms", "vtdockras", "vdat_ws", "vdd_state", "vtd_As", "vdtikAs", "vtd_ws", "vtdockan", "vpd_with", "vdd_ras", "vtdappas", "vcd_as", "vtd__AS", "vtdows", "vtdOCKac", "vtd__As", "vtdappasin", "vtd_with", "vtd_bas", "vpc__ras", "vtd__at", "vtd___asin", "vtdOCKas", "vtd__an", "vtd7ras", "vtdocat", "vtd___asse", "vdd_AS", "vtd__ws", "vtdOCKAs", "vtd__ms", "vtd_nas", "vtdikwith", "vtdobas", "vpd_as", "vdtikat", "vtdappAs", "vtd_ms", "vdt_at", "vpc__an", "vtd__a", "vtdiklas", "vtdappan", "vpd_nas", "vdat_at", "vtdikcache", "vtdikvia", "vtdockas", "vtd__ras", "vtdocbas", "vtd_ras", "vcd_an", "vtd__cache", "vdd_As", "vtd__ac", "vcd_asin", "vdt_cache", "vtdOCKAS", "vdat_a", "vcd_asse", "vtd_a", "vdtikas", "vtd___as", "vtd_via", "vtd7as", "vtdikAs", "vtd_asse", "vtd_state", "vdat_bas", "vtd_AS", "vtdikas", "vtd_las", "vtd_asin", "vtdockms", "vdt_As", "vtdappat", "vtdikws", "vtdika", "vpc_as", "vtdocws", "vdat_as", "vpc__as", "vpd_via", "vtdiknas", "vtdocas", "vtd__las", "vpc__ms", "vtdappcache", "vtd_at", "vtd_cache", "vtd___an", "vtdappasse", "vtd_an", "vtd__as", "vtdockvia", "vdd_at", "vtdoat", "vtdoas", "vpc_an", "vpc_ras"], "s": ["states", "S", "south", "p", "sync", "sa", "ses", "ds", "f", "is", "ss", "ts", "b", "v", "sis", "a", "state", "c", "ps", "o", "sb", "e", "cs", "r", "session", "u", "services", "ops", "side", "ssl", "scope", "gs", "i", "os", "sys", "m", "t", "sl", "ns", "spec", "js"], "ce": [" ke", "ace", "cf", "ate", "du", "coe", "ue", "cy", "SE", "pe", "ve", "oe", "ix", "fe", " ace", "cc", "code", "se", "co", "ge", "te", "za", "le", "ide", "cess", "que", "ie", "cur", "ance", "none", "ice", "che", "see", "CE", "ae", "ct", "cer", "ade", " pe", "cod", "ke", "ck", "ca", "ine", "e", "ind", "GE", "ced", "ze", "cal", "ee", " ge", "cast", "cing", "ne", " ne", "cca", "cle", "dr", "ci", "face", "client", " CE", "cue", "cel", "ince", "nce", "ette", "ces", "ste", "cell", "core"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n", "idx": 20507, "substitutes": {"sd": ["inst", "sq", "hd", "pd", "sa", "se", "di", "bd", "db", "ds", "td", "dl", "md", "gd", "si", "ss", "sb", "sm", "sed", "dev", "cs", "fd", " td", "sk", "std", "rd", "sh", "dd", "d", "dk", "gb", "ad", "sf", "SD", "od", "vd", "sl", "sg", "ld", "sv", "sam"], "addr": ["adr", "ha", "ace", "kt", "hd", "x", "src", "host", "route", "ac", "pointer", "offset", "rt", "ord", "address", "rm", "pc", "rx", "mt", "mac", "state", "align", "ar", "adder", "cb", "alias", "nr", "ref", "dd", "size", "attr", "rc", "data", "ptr", "hash", "id", "dr", "pad", "ad", "od", "wd", "node", "ld", "ext"]}}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_handle_escape(QemuConsole *s)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i<s->nb_esc_params; i++) {\n\n        switch (s->esc_params[i]) {\n\n            case 0: /* reset all console attributes to default */\n\n                s->t_attrib = s->t_attrib_default;\n\n                break;\n\n            case 1:\n\n                s->t_attrib.bold = 1;\n\n                break;\n\n            case 4:\n\n                s->t_attrib.uline = 1;\n\n                break;\n\n            case 5:\n\n                s->t_attrib.blink = 1;\n\n                break;\n\n            case 7:\n\n                s->t_attrib.invers = 1;\n\n                break;\n\n            case 8:\n\n                s->t_attrib.unvisible = 1;\n\n                break;\n\n            case 22:\n\n                s->t_attrib.bold = 0;\n\n                break;\n\n            case 24:\n\n                s->t_attrib.uline = 0;\n\n                break;\n\n            case 25:\n\n                s->t_attrib.blink = 0;\n\n                break;\n\n            case 27:\n\n                s->t_attrib.invers = 0;\n\n                break;\n\n            case 28:\n\n                s->t_attrib.unvisible = 0;\n\n                break;\n\n            /* set foreground color */\n\n            case 30:\n\n                s->t_attrib.fgcol=COLOR_BLACK;\n\n                break;\n\n            case 31:\n\n                s->t_attrib.fgcol=COLOR_RED;\n\n                break;\n\n            case 32:\n\n                s->t_attrib.fgcol=COLOR_GREEN;\n\n                break;\n\n            case 33:\n\n                s->t_attrib.fgcol=COLOR_YELLOW;\n\n                break;\n\n            case 34:\n\n                s->t_attrib.fgcol=COLOR_BLUE;\n\n                break;\n\n            case 35:\n\n                s->t_attrib.fgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 36:\n\n                s->t_attrib.fgcol=COLOR_CYAN;\n\n                break;\n\n            case 37:\n\n                s->t_attrib.fgcol=COLOR_WHITE;\n\n                break;\n\n            /* set background color */\n\n            case 40:\n\n                s->t_attrib.bgcol=COLOR_BLACK;\n\n                break;\n\n            case 41:\n\n                s->t_attrib.bgcol=COLOR_RED;\n\n                break;\n\n            case 42:\n\n                s->t_attrib.bgcol=COLOR_GREEN;\n\n                break;\n\n            case 43:\n\n                s->t_attrib.bgcol=COLOR_YELLOW;\n\n                break;\n\n            case 44:\n\n                s->t_attrib.bgcol=COLOR_BLUE;\n\n                break;\n\n            case 45:\n\n                s->t_attrib.bgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 46:\n\n                s->t_attrib.bgcol=COLOR_CYAN;\n\n                break;\n\n            case 47:\n\n                s->t_attrib.bgcol=COLOR_WHITE;\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 20518, "substitutes": {"s": ["z", "S", "rs", "p", "h", "site", "us", "se", "ses", "ds", "f", "an", "is", "fs", "si", "ss", "ts", "b", "its", "sis", "v", "a", "n", "k", "c", "ps", "hs", "sb", "o", "e", "cs", "y", "l", "r", "service", "session", "u", "services", "qs", "es", "d", "tp", "ssl", "gs", "su", "m", "sys", "os", "t", "self", "sf", "conf", "server", "this", "ns", "ls", "sg", "sl", "sv", "g", "ms", "js"], "i": ["ti", "ii", "ji", "ui", "qi", "x", "I", "p", "h", "eni", "phi", "di", "ri", "j", "type", "f", "ai", "cli", "ini", "oi", "ni", "dim", "info", "si", "b", "io", "v", "a", "pi", "n", "index", "uri", "c", "o", "e", "ind", "r", "l", "xi", "u", "chi", "yi", "fi", "li", "d", "iu", "hi", "k", "mi", "zi", "m", "ci", "multi", "t", "gi", "mu", "bi", "ip"]}}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 20520, "substitutes": {"s": ["sets", "S", "sq", "w", "secondary", "p", "h", "sync", "ses", "f", "fs", "ss", "b", "sc", "v", "n", "c", "e", "session", "services", "ssl", "scope", "m", "t", "sf", "sec", "js"], "tcg_src": ["tcgi_rin", "tcg_inst", "tcgi_sb", "tcerg_enc", "tcerg_src", "tcg_sur", "tcg__src", "tcg__rc", "tcg7rc", "tcg7src", "tcg_rin", "tcg_rs", "tcgi_sel", "tcg_enc", "tcG_enc", "tcG_sb", "tcG_src", "tcgi_src", "tcG_rs", "tcG_sur", "tcerg_sb", "tcg_sb", "tcg__inst", "tcG_inst", "tcg_sel", "tcg_rc", "tcg7enc", "tcg7sb", "tcerg_rc", "tcg__sur", "tcG_rc"], "destidx": ["srcIdz", "destIdxc", "destinc", "srcidz", " destinx", " destinxc", "destidxc", "destindxc", "destIdc", "destinxc", "srcIdX", " destidc", "destidz", "destinx", "srcIdxc", "destinz", " destinz", "destidc", "destindz", " destidz", "destIdx", " destinc", "srcidX", "destIdz", "destidX", " destidxc", "destindx", "destIdX", "srcidx", "srcIdx", "srcidxc", "destindX"], "element": ["item", "attribute", "event", "section", "offset", "el", "address", "length", "mode", "option", "object", "device", "lements", "uri", "dimension", "index", "seed", "entry", "e", "style", "token", "key", "present", "ee", "lement", "layer", "Element", "member", "append", "data", "input", "ele", "child", "unit", "field", "iterator", "array", "number", "node"], "memop": ["Memoop", "mmOp", "memo", "limop", "mmopt", "emaOp", "mmoop", "emaoop", "mmoper", "moro", "Memop", "emaoper", "remopt", "mmopus", "ramop", "remop", "MemOp", "mmop", "morhop", "emaop", "memopus", "limopus", "limoper", "remoper", "limopt", "morop", "memopt", "moroper", "memoop", "ramoper", "remopus", "Memhop", "ramo", "memhop", "Memo", "ramhop", "memOp", "Memoper", "memoper"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),\n\n                                    int ra, int rb, int rc,\n\n                                    int islit, uint8_t lit)\n\n{\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    if (ra != 31) {\n\n        if (islit) {\n\n            if (lit != 0)\n\n                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));\n\n            else\n\n                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);\n\n        } else {\n\n            TCGv tmp1, tmp2;\n\n            tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);\n\n            tcg_gen_shli_i64(tmp1, tmp1, 3);\n\n            tmp2 = tcg_const_i64(64);\n\n            tcg_gen_sub_i64(tmp1, tmp2, tmp1);\n\n            tcg_temp_free(tmp2);\n\n            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);\n\n            tcg_temp_free(tmp1);\n\n        }\n\n        if (tcg_gen_ext_i64)\n\n            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);\n\n    } else\n\n        tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n}\n", "idx": 20531, "substitutes": {"tcg_gen_ext_i64": ["tcg_gen_ext_ii16", "tcg_gen_ext_ui64", "tcg_gen_ext_f16", "tcg_gen_ext_ii6", "tcg_gen_ext_ii24", "tcg_gen_ext_ii64", "tcg_gen_ext_I16", "tcg_gen_ext_i24", "tcg_gen_ext_I24", "tcg_gen_ext_i32", "tcg_gen_ext_ui6", "tcg_gen_ext_ui24", "tcg_gen_ext_f32", "tcg_gen_ext_f24", "tcg_gen_ext_i16", "tcg_gen_ext_ui32", "tcg_gen_ext_I64", "tcg_gen_ext_I32", "tcg_gen_ext_f64", "tcg_gen_ext_i6", "tcg_gen_ext_I6", "tcg_gen_ext_ui16"], "ra": ["ran", "ring", "RC", "ha", "ria", "po", "ur", "RA", "src", "area", "sa", "Ra", "rar", "rss", "rt", "ri", "ras", "rog", "ta", "loc", "ma", "year", "star", "ro", "cr", "ru", "sr", "ir", "up", "dir", "a", "ar", "ia", "sha", "ca", "da", "rr", "alpha", "r", "va", "ref", "rac", "rd", "arc", "ara", "raf", "sur", "ica", "ka", "dra", "rf", "la", "spec", "asc", "rap", "rad"], "rb": ["lb", "wb", "src", "reb", "rar", "db", "ri", "rt", "RB", "rm", "ro", "ru", "sr", "b", "vr", "cb", "ruby", "sb", "rr", "r", "ref", "pb", "rd", "rn", "raf", "attr", "rf", "gb", "lr", "rl", "ril", "rg", "rad"], "rc": ["dc", "ran", "RC", "desc", "ur", "rank", "rs", "rin", "cv", "src", "hl", "lc", "row", "rar", "ac", "rt", "name", "loc", "rog", "ras", "ri", "config", "ro", "cr", "ru", "roc", "cur", "irc", "uc", "sr", "sc", "fc", " src", "c", "cb", "ruby", "path", "rr", "alpha", "r", "kr", "hr", "rib", "ref", "rac", "rd", "arc", "sur", "rn", "bc", "qa", "ica", "ource", "rf", "dra", "ann", "dr", "ci", "rect", "cmp", "lr", "rl", "asc", "inc", "rg", "rad", "rec"], "islit": ["ssli", "islite", "islited", "rlited", "sslitted", "islitted", "sslit", "slitt", "isli", "isalitting", "sslited", "isalitted", "isalit", "slite", "sslite", "rlitt", "slitting", "slited", "sslitting", "islitting", "slit", "isali", "sslitt", "slitted", "rlit", "sli", "rlite", "islitt"], "lit": ["lambda", "late", "iter", "cl", "eval", "lin", "lc", "inf", "lim", "val", "loc", "info", "stat", "lt", "bl", "init", "rel", "len", "lab", "lat", "rot", "l", "nat", "lang", "pit", "lic", "sel", "ident", "fi", "lam", "pl", " literal", "split", "lif", "lot", "alt", "sil", "la", "lite", "lib", "util", "sl", "spec", "it"], "tmp1": [" tmp3", "temp2", "buf3", "cp3", "cpp1", "mp1", "cp1", "cppl", "tempone", "tmp4", " tmp4", "tmp64", "txt3", " tmp64", "txt2", "cp2", "txtone", "cpp3", "cpp64", "mp8", "tmpl", "buf64", "tmp3", "mp2", "mp3", "temp8", "mpl", "tmpone", "buf1", "mp4", " tmpl", "tmp8", " tmp8", "mpone", "bufl", "temp4", "temp1", "templ", "cpl", "cpp2", "temp3", "txt1", " tmpone"], "tmp2": [" tmp3", "temp2", "temp32", " tmp32", "mp1", "tempb", "tmp4", " tmp4", "txt2", "mp3", "mp2", "tmp3", "txt4", "txtb", "mp4", "mpb", "tmpb", "temp4", "mp32", "temp1", "tmp32", "temp3", "txt1"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_dequant_tables(H264Context *h)\n\n{\n\n    int i, x;\n\n    init_dequant4_coeff_table(h);\n\n    if (h->pps.transform_8x8_mode)\n\n        init_dequant8_coeff_table(h);\n\n    if (h->sps.transform_bypass) {\n\n        for (i = 0; i < 6; i++)\n\n            for (x = 0; x < 16; x++)\n\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n\n        if (h->pps.transform_8x8_mode)\n\n            for (i = 0; i < 6; i++)\n\n                for (x = 0; x < 64; x++)\n\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n\n    }\n\n}\n", "idx": 20534, "substitutes": {"h": ["ha", "php", "hd", "w", "kh", "p", "ht", "hl", "host", "gh", "th", "http", "di", "ih", "f", "s", "hum", "hist", "rh", "he", "b", "beh", "ah", "v", "html", "bh", "oh", "hh", "c", "hs", "H", "e", "hr", "ch", "hw", "ph", "hhh", "u", "sh", "history", "uh", "hm", "hi", "ctx", "k", "m", "t", "context", "g", "eh", "sl", "hp"], "i": ["ti", "ii", "ui", "my", "qi", "I", "ix", "p", "lc", "phi", "di", "ri", "j", "info", "f", "ai", "s", "ie", "ini", "ni", "oi", "start", "is", "si", "io", "b", "v", "init", "a", "pi", "index", "ei", "c", "o", "ind", "e", "y", "l", "xi", "u", "key", "yi", "fi", "d", "li", "iu", "mini", "ik", "id", "m", "ci", "zi", "mi", "multi", "slice", "gi", "mu", "bi", "it", "ip"], "x": ["php", "time", "full", "image", "rex", "xy", "xc", "ix", "cl", "p", "yx", "cross", "code", "X", "ex", "plus", "xb", "name", "j", "ax", "f", "na", "xs", "xxx", "rx", "xe", "is", "xf", "b", "wa", "v", "lex", "xx", "ux", "wx", "index", "c", "sw", "any", "e", "y", "tx", "dx", "xp", "ya", "xi", "u", "xa", "id", "m", "fx", "t", "zi", "work", "sex", "orig", "mix", "px", "g", "z"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int g722_encode_init(AVCodecContext * avctx)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono tracks are allowed.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    c->band[0].scale_factor = 8;\n\n    c->band[1].scale_factor = 2;\n\n    c->prev_samples_pos = 22;\n\n\n\n    if (avctx->trellis) {\n\n        int frontier = 1 << avctx->trellis;\n\n        int max_paths = frontier * FREEZE_INTERVAL;\n\n        int i;\n\n        for (i = 0; i < 2; i++) {\n\n            c->paths[i] = av_mallocz(max_paths * sizeof(**c->paths));\n\n            c->node_buf[i] = av_mallocz(2 * frontier * sizeof(**c->node_buf));\n\n            c->nodep_buf[i] = av_mallocz(2 * frontier * sizeof(**c->nodep_buf));\n\n            if (!c->paths[i] || !c->node_buf[i] || !c->nodep_buf[i]) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (avctx->frame_size) {\n\n        /* validate frame size */\n\n        if (avctx->frame_size & 1 || avctx->frame_size > MAX_FRAME_SIZE) {\n\n            int new_frame_size;\n\n\n\n            if (avctx->frame_size == 1)\n\n                new_frame_size = 2;\n\n            else if (avctx->frame_size > MAX_FRAME_SIZE)\n\n                new_frame_size = MAX_FRAME_SIZE;\n\n            else\n\n                new_frame_size = avctx->frame_size - 1;\n\n\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested frame size is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_frame_size,\n\n                   avctx->frame_size);\n\n            avctx->frame_size = new_frame_size;\n\n        }\n\n    } else {\n\n        /* This is arbitrary. We use 320 because it's 20ms @ 16kHz, which is\n\n           a common packet size for VoIP applications */\n\n        avctx->frame_size = 320;\n\n    }\n\n    avctx->delay = 22;\n\n\n\n    if (avctx->trellis) {\n\n        /* validate trellis */\n\n        if (avctx->trellis < MIN_TRELLIS || avctx->trellis > MAX_TRELLIS) {\n\n            int new_trellis = av_clip(avctx->trellis, MIN_TRELLIS, MAX_TRELLIS);\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested trellis value is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_trellis,\n\n                   avctx->trellis);\n\n            avctx->trellis = new_trellis;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    g722_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 20541, "substitutes": {"avctx": ["abcf", "svcmp", "avalconf", "avalctx", "avcup", "vercal", "awcontext", " avhw", "ajcup", " avpkg", "navcmp", "avectx", "avconf", "afhw", "avalsys", "avalhw", "avctl", "AVcontext", "awctl", "afconf", "varcmd", "avecu", "avsys", "navctx", "abcmp", "navcf", "avalpkg", "avalcontext", "avcn", " avcp", "awcf", "avalcu", "avecmp", "vercu", "avalcmd", "avalconn", "avctrl", "AVpkg", "afctl", "navpkg", "navcu", "avcontext", "afcca", "varctx", "ajconn", "varcontext", "avalcal", "vercontext", "navctl", "ajcontext", "avecmd", "verconf", " avconn", " avc", "navcup", "abcontext", "awctx", "avalcca", "afcup", "afcontext", "ajctx", "afsys", "avcal", "AVcf", "afctrl", "avecontext", " avctl", "svcf", "avcu", "AVcp", "afconn", "AVctrl", "avcmp", "avhw", "svctx", "afcf", "avcmd", "varsys", "AVcmp", "vercn", "afcn", "avcp", "avalctrl", "afcal", "vercf", "afcmp", "varctrl", "navcontext", "afpkg", "avalc", "avalctl", "avecf", "ajcp", "avalcf", "afcmd", "verctx", "avpkg", "avalcmp", "afcu", "avconn", "AVctx", "afc", "avc", "AVconn", "abctx", " avcontext", "ajcf", "svcontext", "avalcn", "afctx", "avcf", "avcca", "aveconn", "varcca"], "c": ["C", "mc", "dc", "cf", "cy", "cl", "w", "xc", "cache", "p", "lc", "cu", "h", "enc", "cc", "co", "ac", "ce", "f", "config", "s", "coll", "pc", "cur", "cr", "uc", "sc", "b", "v", "ct", "n", "con", "ca", "o", "com", "e", "cs", "l", "conn", "ch", "u", "cm", "arc", "d", "cp", "ic", "tc", "ctx", "vc", "k", "m", "ci", "conf", "t", "ctrl", "this", "context", "g", "cn", "ec"], "ret": ["match", "def", "res", "resp", "rets", "lit", "cat", "bit", "rt", "val", " Ret", "det", "mt", "ut", "RET", "back", "feat", "fun", "reg", "aux", "result", "nt", "ref", " RET", "reply", "re", "job", "alt", "arg", "mel", "success", "Ret", "util", "pet"], "i": ["ti", "ii", "ui", "abi", "part", "qi", "ji", "x", "I", "ix", "isi", "p", "h", "eni", "lc", "phi", "di", "ri", "j", "info", "f", "ai", "cli", "s", "ini", "oi", "ni", "ie", "si", "b", "io", "v", "pi", "n", "index", "uri", "isin", "type", "e", "y", "l", "r", "xi", "u", "chi", "yi", "fi", "d", "li", "in", "iu", "mini", "api", "hi", "id", "zi", "ci", "mi", "multi", "t", "slice", "gi", "g", "mu", "bi", "it", "ip"], "new_frame_size": ["new_line_len", "new_frame_style", "new_frame_len", "new_frame\u00b7start", "new_frame_rate", "new_frame64unit", "new_frame_send", "new_frame_name", "new_line_name", "new_line_cycle", "new_line_level", "new_frame64size", "new_line_unit", "new_frame\u00b7rate", "new_frame_level", "new_line_size", "new_framelexsize", "new_frame_cycle", "new_framelexsend", "new_framexsend", "new_frame\u00b7size", "new_framexstyle", "new_framexsize", "new_line_style", "new_frame_unit", "new_line_send", "new_framelexstyle", "new_frame_start", "new_frame_scale", "new_frame64len"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n", "idx": 20548, "substitutes": {"opaque": ["opac", "opsaque", "opec", "OPaque", "opque", "opacity", " opque", "opaco", "OPaco", " opac", "opsac", "ipopaques", "iopec", "ipopaque", "ipopacity", " opaco", " opacity", "iopque", "opsec", "iopac", " opaques", "OPaques", "OPacity", "ipopaco", " opec", "opaques", "iopaque", "opsque"], "addr": ["dc", "adr", "ace", "x", " address", "p", "host", "arm", "pointer", "offset", "ord", "ada", "address", "mode", "config", "pc", "device", "asm", "mac", "state", "padding", "adder", "da", "alias", "nr", "args", "amd", "byte", "port", "pos", "data", "obj", "ptr", "oa", "pad", "ad", "dr", "grad", "slice", "Address", "node"], "size": ["capacity", "x", " Size", "block", "offset", "name", "type", "mode", "length", "address", "Size", " sizes", "len", "c", "SIZE", "from", " length", "args", "or", "ize", "rc", "data", "large", "bytes"], "s": ["settings", "params", "states", "S", "sq", "w", "secondary", "p", "sym", "sync", "ses", "ds", "f", "fs", "is", "b", "ss", "a", "state", "n", "c", "opens", "spec", "o", "sb", "e", "r", "session", "u", "d", "ops", "ssl", "i", "m", "os", "t", "sf", "socket", "sl", "g"]}}
{"project": "qemu", "commit_id": "465f2fedd262cbdcbfc92c181660cf85e5029515", "target": 0, "func": "static int cryptodev_builtin_create_cipher_session(\n\n                    CryptoDevBackendBuiltin *builtin,\n\n                    CryptoDevBackendSymSessionInfo *sess_info,\n\n                    Error **errp)\n\n{\n\n    int algo;\n\n    int mode;\n\n    QCryptoCipher *cipher;\n\n    int index;\n\n    CryptoDevBackendBuiltinSession *sess;\n\n\n\n    if (sess_info->op_type != VIRTIO_CRYPTO_SYM_OP_CIPHER) {\n\n        error_setg(errp, \"Unsupported optype :%u\", sess_info->op_type);\n\n        return -1;\n\n    }\n\n\n\n    index = cryptodev_builtin_get_unused_session_index(builtin);\n\n    if (index < 0) {\n\n        error_setg(errp, \"Total number of sessions created exceeds %u\",\n\n                  MAX_NUM_SESSIONS);\n\n        return -1;\n\n    }\n\n\n\n    switch (sess_info->cipher_alg) {\n\n    case VIRTIO_CRYPTO_CIPHER_AES_ECB:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CBC:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CBC;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CTR:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CTR;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_DES_ECB:\n\n        algo = QCRYPTO_CIPHER_ALG_DES_RFB;\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher alg :%u\",\n\n                   sess_info->cipher_alg);\n\n        return -1;\n\n    }\n\n\n\n    cipher = qcrypto_cipher_new(algo, mode,\n\n                               sess_info->cipher_key,\n\n                               sess_info->key_len,\n\n                               errp);\n\n    if (!cipher) {\n\n        return -1;\n\n    }\n\n\n\n    sess = g_new0(CryptoDevBackendBuiltinSession, 1);\n\n    sess->cipher = cipher;\n\n    sess->direction = sess_info->direction;\n\n    sess->type = sess_info->op_type;\n\n\n\n    builtin->sessions[index] = sess;\n\n\n\n    return index;\n\n}\n", "idx": 20549, "substitutes": {"builtin": ["boundIN", "boundini", " builtIN", "boundin", "buildout", "builtIN", " Builtin", " builtout", " builtins", "buildin", " Builtout", "builtini", "buildIN", "buildins", "builtout", " builtini", "boundins", " BuiltIN", "builtins", "buildini"], "sess_info": ["sess_label", "sessrinformation", "sess_information", "sop_info", "sessghandle", "ssession_handle", "sessropt", "sesslinfo", "sesspolabel", "ssession_information", "sess_inf", "sesslinformation", "sess_opt", "sop_inf", "ssession_object", "sess_handle", "ssession_label", "sesssinfo", "sessallhandle", "sesspoinformation", "sop_information", "sesserinfo", "sesserobject", "sess_manager", "siz_class", "sessjinformation", "session_manager", "ssession_INFO", "sess_INFO", "siz_info", "ssession_name", "ssession_info", "sessllabel", "sessjinfo", "sessername", "session_inf", "sessallINFO", "sessallinfo", "sessjclass", "siz_information", "sessrinfo", "sessgINFO", "ssession_opt", "sesssinf", "sess_object", "session_info", "sess_class", "sess_name", "sessginfo", "sesspoinfo", "sesssmanager"], "errp": ["drpre", "gerpress", "errping", "errfp", "irp", "erP", "irP", "errorip", "erfp", "moref", "errorp", "morep", "gerpre", "arrfp", "ferp", "errip", "eerp", "gerip", "oderpa", " errpin", "nerfp", "grP", "oderp", "orderpc", "errorpre", "errP", "orderpre", "moreping", "drip", " errpre", "arrp", " errping", "ererip", "grpre", "orderp", "errpa", "errorpress", " errpc", "orderip", "erp", "moreip", "oderpin", "errpin", "errpre", "ererf", "erpc", "erpre", "errf", " errP", "ferip", " errip", "errpc", "arrpa", "drp", "nerpc", "gerp", "ererping", "grfp", "eerip", " errpa", "eerpre", "errpress", "grp", " errf", "nerp", "oderfp", "drpress", " errfp", "irpc", "arrpin", "ferpre", "nerP", "ererp", "ferpc", "irfp"], "algo": ["palgorithm", "calgorithm", "allgo", "chalgorithm", "palgin", "isalgo", "elga", "calgo", "allgorithm", "calbo", "palgo", "palga", "isalga", " alho", " algn", "algone", "chalga", "ALgo", "ALgin", "calga", " albo", "Algn", "Algorithm", "adgin", "Algo", "Algin", "Alga", " alpo", "adgo", "alpo", "adgone", " algorithm", "allga", " alga", "elgone", "algan", "allgin", "albo", "chalgo", "elho", "isalgorithm", "Alpo", "adga", "algn", "alga", "algin", "algorithm", "elgorithm", "isalho", " algan", " algone", "elgo", "elbo", "ALga", "ALpo", "ALgn", " algin", "chalgan", "ALgorithm", "alho", "elgan", "elgin"], "mode": ["element", "stage", "layout", "step", "mission", "access", " modes", "guide", "route", "name", "type", "dim", "shell", "config", "md", "driver", "language", "lane", "device", "mask", "view", "scale", "parent", "mod", "path", "range", "ward", "error", "style", "engine", "module", "session", " module", "key", "kind", "source", "command", "model", "member", "slave", "direction", "role", "grade", "mid", "id", "mi", "gone", "multi", "vel", "Mode", "sid", "slice", "MODE", "method", "disable", "phase", "node"], "cipher": ["chip", " cip", "acip", "acmp", " cortex", "chortex", "cmp", "chmp", " cmp", "cortex", "acortex", "acipher", "chipher", "cip"], "index": ["loop", "element", "part", "timeout", "update", "match", "x", "ion", "version", "cache", "section", "sync", "num", "depth", "route", "pointer", "loc", "name", "offset", "dim", "length", "address", "option", "ini", "len", "position", "path", "action", "error", "search", "ind", "page", "find", "connection", "end", "value", "size", "weight", "instance", "pos", "member", "append", "input", "count", "i", "number", "list", "Index", "slice", "level", "method", "array", "inc", "prefix"], "sess": ["sessession", " sys", "ssession", "sys", " ssession", "sesess", "sesys", "sessl", " ssl", "ssl"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n", "idx": 20553, "substitutes": {"entry": ["zip", "element", "part", "try", "ev", "row", "section", "lc", "link", "code", "route", "ge", "se", "cat", "her", "je", "option", "ie", "feed", "si", " Entry", "ry", "next", "index", "base", "search", "e", "ew", "error", "ger", "entity", "nt", "or", "service", "letter", "key", "connection", "end", "member", "archive", "obj", "slave", "child", "data", "id", "reader", "Entry", "ell", "server", "record", "card", "list", "ent", "enter", "cell", "comment", "inner"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 20562, "substitutes": {"ahci": ["amcium", "aphcin", "yahcu", "earci", "accu", "aphci", "aphcia", "AHcu", "ahcci", "lahcci", "ahcium", "amc", "akrc", "ahcin", "aphcu", "ehcin", "akcu", "yahrc", "amci", "yahcin", "earcium", "lahcin", "ahc", "ehcu", "avecium", "lahci", "ehci", "akci", "amcu", "acc", "ehcci", "earcu", "akcin", "ehrc", "ahrc", "akcium", "accium", "acci", "AHcin", "ahcu", "lahcium", "yahcci", "avec", "lahcu", "ahcia", "AHci", "AHcia", "earcci", "avecu", "akcci", "aveci", "lahcia", "yahci"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static int writev_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector qiov;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&writev_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_writev(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}", "idx": 20576, "substitutes": {"argc": ["argumentv", "axc", "axv", "argumentdc", " argdc", "axp", "Argv", "argumentl", "argumentc", " argf", " argp", "Argl", " argl", "agc", "axlc", "axf", "argn", "aglc", "argumentlc", "argp", "argl", "agf", " argn", "agp", "axl", "argf", "argumentf", "agl", "Argf", "arglc", "argumentn", "Argn", " arglc", "argdc", "Arglc", "agv", "Argdc", "Argc"], "argv": ["argumentv", "argvs", "argb", "parv", "Argw", "Argv", "argsb", " argval", "argw", "argumentc", " argf", "argsv", " argp", " argu", "execc", "parvs", "agc", "agw", "execv", "argsc", "execb", "argsval", " argvs", "argp", "execu", "argumentp", "parc", "agf", "agp", "argf", "argumentf", "argsp", " argb", "agval", "parf", "argu", "argsu", "agv", "Argc", "argsvs", " argw", "Argp", "argval", "argsf"], "t1": ["t9", "p2", "ttb", "T1", " t4", "T0", "T3", "tt0", "tb", "pt9", "p4", "p1", "Tb", "T4", "pt1", " t0", "pt3", "f1", "t4", "p0", " tb", "t3", "pt2", "f3", "T9", "t0", "tt1", "f2", "tt2", "f9", "T2"], "t2": ["int4", "int0", "temp2", " t3", "p2", "T1", "int2", " t4", "tmp1", "T0", "T3", "ttwo", "tmp4", "f4", "int1", "p4", "p1", "T4", " t0", " tTwo", "tmpTwo", "f1", "t4", "tmp2", "p0", "tTwo", "t3", "TTwo", "temptwo", "f3", "t0", "temp3", "temp1", " ttwo", "f2", "Ttwo", "T2"], "c": ["C", "dc", "comment", "cf", "mc", "channel", "cy", "xc", "cache", "p", "lc", "enc", "call", "code", "cc", "ac", "loc", "f", "config", "s", "cr", "start", "sc", "b", "v", "ct", "n", "con", "cod", "cb", "o", "e", "l", "r", "col", "ch", "end", "opt", "d", "cp", "count", "k", "i", "ctx", "m", "ci", "t", "nc", "cn", "ec"], "cnt": ["Count", "rcnd", "ecct", " cint", "ecnt", "Cnd", "ccint", "pcct", "nant", "pcnt", "ecno", "nnt", "CNT", "cNT", "cant", "pcnn", "ecnc", "Cnc", "nount", "Cnt", "cnc", "Cct", "Cnn", "Cint", "rcnt", " cno", " cnd", "ccno", "rcno", " cant", "pcno", " count", "count", "cnn", "cct", " cNT", "cint", " cnn", " cnc", "Cant", "rcNT", "nNT", "ccnt", " cct", "cnd", "cno", "Cno", "ccNT"], "buf": ["Buffer", "home", "cf", "br", "runner", "box", "text", "cv", "wb", "uf", "alloc", "lit", "prop", "queue", "mem", "block", "img", "buff", "buffer", "Buff", "bd", "proc", "config", "uc", "func", "cmd", "b", "seq", "aka", "fw", "cb", "cas", "vec", "bus", "ab", "nat", "tmp", "fd", "fp", "aux", "ref", "fam", "ff", "bag", "port", "bc", "fi", "np", "rc", "data", "obj", "ctx", "pad", "fb", "socket", "rb", "bed", "pool"], "offset": ["inet", "part", "timeout", "origin", "layout", "p", "reset", "location", "num", "pointer", "loc", "type", "info", "length", "Offset", "config", "address", "option", "online", "offs", "start", "gap", "len", "seq", "index", "align", "padding", "position", "rot", "base", "o", "entry", "slot", "error", "range", "alpha", "usage", "nt", "fp", "format", "ref", "set", "output", "enabled", "end", "size", "off", "et", "np", "pos", "coord", "append", "data", "url", "count", "i", "shift", "number", "total", "slice", "addr", "prefix", "sn", "ip"], "nr_iov": ["nerqnr", "nr_eni", "usr_iov", "nrJio", "ner_nox", "nr_rolet", "nrJiov", "yrqilo", "nrqvideos", "yrqrolet", "yrqiov", "nrJnr", "usr_liv", "yrqvideos", "yr_iov", "nr_nr", "nr_ilo", "nrjnox", "nrqrolet", "nrpilo", "nerqiov", "yr_rolet", "nrpiov", "ner_iov", "usr_dyl", "nrpvideos", "nrJnox", "nrqiov", "nr_videos", "nerqeni", "nr_liv", "nrJdyl", "nrJeni", "nrjnr", "nrqnox", "nrqeni", "nrprolet", "nr_io", "usr_io", "nerqnox", "nrqilo", "yr_videos", "yr_ilo", "ner_eni", "nrqnr", "nr_dyl", "nrjiov", "nrJliv", "ner_nr", "nrjeni", "nr_nox"], "qiov": ["iqilo", "questilo", "iqrolet", "sqiov", "questnox", "questiov", "Qnox", "iqivari", "wliv", "iqiov", "qurolet", "Qovi", "qqivari", "idiov", "sqiris", "qnox", " qilo", "qiop", "quovi", "wiov", "questovi", "Qliv", "sqovi", "dqiop", "qqiov", "idliv", "dqilo", " qiop", "quivari", "Qiov", "dqiov", "Qiop", "quiov", "qivari", "dqliv", "qliv", "wiris", "idiris", "idovi", "qrolet", "qunox", "Qilo", "sqliv", "qilo", "quilo", "qovi", " qliv", "qqilo", "wovi", "qiris", "qqrolet"], "optind": ["optionid", "optimind", "optin", "parentinn", "infoinst", "roport", " optpos", "destinc", "parentInd", "destInd", "Optind", "varind", "optionint", "opinst", "optionind", "optint", "ropInd", "optid", "varInd", "Optinn", "ropin", "optpos", "opInd", "opint", "opinc", "optionInd", "optionpos", "optimin", "infoInd", "destinn", "varinc", "optort", "opind", "optInd", "Optid", "optionin", "optioninc", "OptInd", "varinst", "optioninn", "optinn", "optionort", "parentinc", "Optpos", "destint", "destind", "infoinc", "optinc", "ropind", " optid", "optimInd", "parentind", " optinn", "optinst", " optInd", "optimort", "infoind"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++) {\n\n        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n    }\n\n}\n", "idx": 20581, "substitutes": {"dst": ["Ddest", "sst", "Dst", "ldstr", "datsts", " dsp", "dsp", " dbl", " dsrc", "rdput", "ldput", "sdput", "ddest", "adst", "adsl", "dsrc", "dstr", "adsp", "sdstr", "sdbl", "datset", "fdsts", "dbl", "Dsts", "ldbl", "adput", "datput", "sdest", "nsrc", "ssrc", "ldst", "fdst", "nstr", "rdsrc", "fdput", "rdst", "nsl", "dsts", "adsrc", "rdsp", " ddest", "dput", "nst", "dsl", "fdset", "datst", " dstr", " dsl", "adstr", "dset", " dsts", "ssts", " dput", "Dsrc", "sdst"], "i": ["ti", "ii", "ui", "abi", "qi", "x", "I", "ix", "p", "h", "eni", "lc", "phi", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ni", "b", "si", "io", "v", "init", "a", "pi", "uri", "index", "iii", "c", "uli", "o", "e", "ind", "l", "adi", "xi", "u", "yi", "source", "sup", "fi", "uni", "d", "li", "in", "iu", "api", "hi", "id", "zi", "ci", "t", "m", "multi", "list", "slice", "gi", "z", "bi", "mu"]}}
{"project": "FFmpeg", "commit_id": "6fd00e9dd94ac3aecf4fa14ca6fa23c395215ac9", "target": 1, "func": "static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n\n                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],\n\n                      GetBitContext *gb)\n\n{\n\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;\n\n    int comment_len;\n\n\n\n    skip_bits(gb, 2);  // object_type\n\n\n\n    sampling_index = get_bits(gb, 4);\n\n    if (m4ac->sampling_index != sampling_index)\n\n        av_log(avctx, AV_LOG_WARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n\n\n\n    align_get_bits(gb);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n\n\n\n    skip_bits_long(gb, comment_len);\n\n    return 0;\n", "idx": 20600, "substitutes": {"avctx": ["Avcot", "navconnection", "groundctx", "afcv", "navcontext", "avctrl", "afctrl", "groundctrl", "avconnection", "avcontext", "Avconnection", "afcot", "groundcontext", "averctx", "groundcv", "Avctx", "navcot", "avcv", "afconnection", "averctrl", "afctx", "avercontext", "avcot", "navctx", "Avcontext", "avercv", "afcontext"], "m4ac": ["cm4ac", " m04ac", "mfourmac", "mfouracc", "cmfouracc", " m4AC", "cmfourmac", "cmfouracs", "m4acs", "cm4acs", "m4mac", "m8mac", "m04jac", "m104ac", "cmfourac", " m04fac", "m4fac", " m4jac", "mfouracs", "mfourfac", "m4AC", "m04fac", "m04acs", "cm4acc", "m4acc", " m4fac", "m04AC", "m8acc", "m04ac", "m104AC", "m04mac", "m8acs", "m104jac", "m104fac", "mfourac", "m04acc", " m04jac", "mfourjac", "cm4mac", "m8ac", "m4jac", " m04AC", "mfourAC"], "new_che_pos": ["new_che_val", "new_che_po", "new_che___vis", "new_che__vis", "new_che_trans", "old_\n", "new_pe_os", "new_che_set", "new_che_tag", "new_ch_cos", "new_cheadloc", "new_onge_vis", "new_ch_ass", "new_che_neg", "new_ch_loc", "new_che_pose", "new_che__pos", "new_\n", "new_chy_pos", "new_ch_val", "new_ch_pos", "new_sche_pos", "new_che_pid", "new_ch_position", "new_sche_pose", "new_onge_pose", "new_pe_pos", "new_ch_neg", "new_chy_loc", "new_onge_pos", "new_che_vis", "new_pe_pid", "new_ch_trans", "new_che__neg", "new_ch_pose", "new_che_position", "new_sche_po", "new_che_os", "new_cheadpos", "new_pe_pose", "new_che_ass", "new_cheadpo", "new_chy_po", "new_onge_neg", "new_che___neg", "new_che_loc", "new_che___pose", "new_che___pos", "new_che_cos", "new_sche_set", "new_cheadtag", "new_chy_tag", "new_che__pose"], "gb": ["bm", "lb", "ui", "gg", "gow", "cfg", "tg", "gp", "gc", "hd", "wb", "gm", "binary", "bb", "gy", "bridge", "bo", "gh", "ge", "gam", "db", "go", "pg", "gnu", "gpu", "bg", "nb", "pc", "gal", "bf", "gd", "b", "gin", "gu", "gram", "gt", "gl", "GB", "ga", "sb", "gru", "storage", "mb", "cgi", "gae", "kb", "yg", "hub", "boot", "agg", "bc", "ogg", "phy", "gs", "abb", "usb", "bn", "og", "gz", "ged", "Gb", "lib", "gio", "ko", "eb", "g", "sg", "gi", "rb", "rg"], "num_front": ["num__back", "num64back", "sum_back", "sum_behind", "num64behind", "num_fore", "sum_fore", " num_board", "num__behind", "dim_behind", "dim_back", "num_board", "num_forward", "num64front", "dim_fore", "sum_front", " num_forward", "num64fore", "num_behind", "num__front", "num__fore", "dim_front"], "num_side": ["num_server", "num__back", "num2back", "sum_back", "num\u00b7front", "num2center", "num__server", "sum_sided", "num_center", "num2sided", "num__side", "num2side", "num\u00b7back", " num_server", " num__front", "num\u00b7side", "sum_side", " num__back", " num__side", "num_board", " num__server", "sum_center", "sum_front", "num\u00b7server", "sum_board", "num_sided", "num__front"], "num_back": ["num67front", "num68side", "numjside", "sum_bottom", "num_before", "sum_back", "numedback", "n67front", "n_back", "numjback", "n_side", "sum_cross", "n67back", "num68before", "num68bottom", "numedbridge", "num_bottom", "numjcross", "sum_bridge", "numedbottom", "sum_side", "num_bridge", "numjfront", "n_before", "n67side", "num67side", "num68bridge", "sum_front", "num68front", "n_front", "num67before", "num68back", "num67back", "numedfront", "n67before", "num_cross"], "num_lfe": ["num_afde", "num_laee", "num_seqeb", "num_seqoe", "num_afea", "num_lffe", "num_lae", "num_afc", "num_seqee", "num_efe", "num_afe", "num_ffieldea", "num_alfee", "num_lfc", "num_lale", "num_affleee", "num_alffe", "num_alfeb", "num_lafe", "num_efea", "num_alfe", "num_seqe", "num_lfoe", "num_lfee", "num_ffielde", "num_afle", "num_ffieldc", "num_afee", "num_alfle", "num_alfoe", "num_efc", "num_affleeb", "num_lfde", "num_affleoe", "num_affe", "num_efde", "num_lfea", "num_lfle", "num_lfeb", "num_afflee", "num_ffieldde"], "num_assoc_data": ["num_assoc_dat", "num_association_Data", "num_assoc2cache", "num_associ2cache", "num_associ_devices", "num_associ2devices", "num_assocalcache", "num_assvoc_len", "num_assoc_only", "num_assocwonly", "num_assoc2data", "num_assvoc2len", "num_assoc2dat", "num_assocwdata", "num_associ2data", "num_assoc2len", "num_assoc_cache", "num_assocaldevices", "num_assoc_len", "num_assocaldata", "num_association_data", "num_assoc_devices", "num_assoc2devices", "num_assocaldat", "num_associ2dat", "num_assoc_Data", "num_associ_dat", "num_assvoc_only", "num_assocwlen", "num_associ_data", "num_assvoc2data", "num_assoc2only", "num_association_len", "num_assvoc_data", "num_assvoc2only", "num_associ_cache"], "num_cc": [" num_ff", "num_cs", "num67ce", " num_ck", "num_ff", " num_rc", " num_cs", "num67ff", "num67rc", "num_ck", "num54cc", " num_cca", " num67cc", " num67ce", " num67ff", "num54ce", "num_rc", "num54rc", "num54ff", " num67rc", " num_ce", "num_cca", "num_ce", "num67cc"], "sampling_index": ["sampling67base", "sampling67token", "sampling67size", "sampling_ind", "sampled_ind", "sampling_list", "sampling_Index", "sampling67ind", "sampling_token", "sampping_ind", "sampling_size", "sampled_index", "sampling_id", "sampling67field", "sampler_Index", "sampled_list", "sampling_base", "sampler_field", "sampping_id", "sampler_index", "sampling67Index", "sampler_size", "sampling67index", "sampled_Index", "sampling_field", "sampping_index"], "comment_len": [" byte_val", " recordaclength", " byteaclength", " record_len", " recordaclong", " byteacval", " record_val", " byteaclong", " recordacval", " byte_length", " byte_long", " byteaclen", " record_long", " recordaclen", " record_length", " byte_len"]}}
{"project": "FFmpeg", "commit_id": "5257743aee0c3982f0079e6553aabc6aa39401d2", "target": 1, "func": "static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,\n\n                               int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    WSSndContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n\n\n    int in_size, out_size, ret;\n\n    int sample = 128;\n\n    uint8_t *samples;\n\n    uint8_t *samples_end;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    out_size = AV_RL16(&buf[0]);\n\n    in_size  = AV_RL16(&buf[2]);\n\n    buf += 4;\n\n\n\n    if (in_size > buf_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame data is larger than input buffer\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* get output buffer */\n\n    s->frame.nb_samples = out_size;\n\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples     = s->frame.data[0];\n\n    samples_end = samples + out_size;\n\n\n\n    if (in_size == out_size) {\n\n        memcpy(samples, buf, out_size);\n\n        *got_frame_ptr   = 1;\n\n        *(AVFrame *)data = s->frame;\n\n        return buf_size;\n\n    }\n\n\n\n    while (samples < samples_end && buf - avpkt->data < buf_size) {\n\n        int code, smp, size;\n\n        uint8_t count;\n\n        code  = *buf >> 6;\n\n        count = *buf & 0x3F;\n\n        buf++;\n\n\n\n        /* make sure we don't write past the output buffer */\n\n        switch (code) {\n\n        case 0:  smp = 4;                              break;\n\n        case 1:  smp = 2;                              break;\n\n        case 2:  smp = (count & 0x20) ? 1 : count + 1; break;\n\n        default: smp = count + 1;                      break;\n\n        }\n\n        if (samples_end - samples < smp)\n\n            break;\n\n\n\n        /* make sure we don't read past the input buffer */\n\n        size = ((code == 2 && (count & 0x20)) || code == 3) ? 0 : count + 1;\n\n        if ((buf - avpkt->data) + size > buf_size)\n\n            break;\n\n\n\n        switch (code) {\n\n        case 0: /* ADPCM 2-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ( code       & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 2) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 4) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample +=  (code >> 6)        - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 1: /* ADPCM 4-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ws_adpcm_4bit[code & 0xF];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ws_adpcm_4bit[code >> 4];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 2: /* no compression */\n\n            if (count & 0x20) { /* big delta */\n\n                int8_t t;\n\n                t = count;\n\n                t <<= 3;\n\n                sample += t >> 3;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            } else { /* copy */\n\n                memcpy(samples, buf, smp);\n\n                samples += smp;\n\n                buf     += smp;\n\n                sample = buf[-1];\n\n            }\n\n            break;\n\n        default: /* run */\n\n            memset(samples, sample, smp);\n\n            samples += smp;\n\n        }\n\n    }\n\n\n\n    s->frame.nb_samples = samples - s->frame.data[0];\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = s->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20606, "substitutes": {"avctx": [" avnp", "auctx", "avalctrl", "abcf", "avalcontext", "afcmp", "avconfig", "aupkg", "navcontext", "AVcf", "avalctx", "afnp", "afctrl", "avctrl", "rafcot", "avcup", "avecf", "avalcca", "avlc", "afpkg", "avalcf", "aucontext", "avalcup", "rafcontext", "avcontext", "Avconfig", " avconfig", "rafctx", "afcca", "avecontext", " avcmp", "avpkg", " avpkg", "avectx", "AVctx", "avnp", "afcot", "akctx", " avci", "akcontext", "akctrl", "auctrl", "AVcontext", "Avctx", "navcot", "avcmp", "afconfig", " avctrl", "abcup", "abctx", " avcontext", "afcf", "navcca", "avelc", "avci", "afci", "AVlc", "afctx", "avcf", "akcca", "Avci", "avcca", "rafcca", "avcot", "aflc", "AVcmp", "AVnp", "abcontext", "navctx", "Avcontext", "afcup", "afcontext"], "data": ["channel", "shape", "image", "def", "w", "empty", "version", "cache", "reset", "p", "DATA", "queue", "call", "block", "buffer", "buff", "frame", "offset", "info", "f", "head", "config", "extra", "to", "response", "ata", "start", "wa", "devices", "body", "media", "device", "v", "content", "a", "next", "bin", "header", "parent", "da", "dat", "message", "module", "batch", "result", "window", "blocks", "meta", "final", "connection", "output", "d", "bc", "split", "video", "input", "memory", "reader", "m", "Data", "list", "slice", "open", "map", "last", "rec", "bytes"], "got_frame_ptr": ["got_frames_tr", "got_frame_tr", "got_frame_addr", "got_frames_addr", "got_frame_len", "got_frame_pointer", "got_frames_ptr", "got_frames_pointer", "got_frame_buf"], "avpkt": ["avvpkt", "affeth", "abcct", "affiece", "affkt", "affacket", "avvpeth", "avcpacket", "abcut", "afpkt", "affKT", "avPct", "avpiece", "avcacket", "avPiece", "avpeth", "abpKT", "avfKT", "avtopka", "avpka", "avhut", "avpent", "abcacket", "avpeka", "abvpnt", "avfut", "avfacket", "abpacket", "abckt", "avvpka", "abvpka", "avhacket", "avPkt", "avcct", "afpiece", "abpkt", "avvpnt", "afpKT", "affct", "avpeKT", "avpnt", "avput", "abput", "avpekt", "avppkt", "abpka", "avpKT", "avhct", "avcpct", "avfiece", "avfct", "afpeth", "avckt", "avppKT", "avvpKT", "avppacket", "abvpKT", "avtopkt", "avcut", "avpacket", "avtopnt", "avfkt", "avtopKT", "avvpacket", "avpct", "avppeth", "abpct", "avcpiece", "afpacket", "avcpkt", "avhkt", "avPacket", "abpnt", "afpct", "abvpkt", "avfeth"], "s": ["ins", "S", "sq", "ks", "rs", "src", "p", "sym", "h", "aws", "sync", "sa", "sg", "bis", "ses", "ds", "f", "as", "is", "fs", "b", "ts", "si", "v", "its", "a", "c", "ps", "e", "cs", "space", "l", "args", "service", "session", "services", "qs", "es", "d", "ops", "in", "ssl", "gs", "i", "su", "m", "sys", "conf", "os", "bs", "g", "ls", "spec", "ns", "js"], "buf": ["br", "box", "cv", "cache", "p", "prop", "buffer", "lim", "proc", "f", "cur", "border", "seq", "feat", "cas", "ab", "window", "pb", "ff", "bc", "pos", "pad", "fb", "ha", "loop", "src", "row", "img", "cat", "num", "ef", "wave", "cmd", "b", "callback", "len", "header", "vec", "fd", "batch", "auc", "bu", "rc", "cap", "wb", "h", "bb", "bo", "buff", "length", "func", "uc", "ru", "v", "tmp", "aux", "brace", "bag", "fi", "tc", "comb", "ctx", "cube", "rb", "bi", "pool", "cf", "uf", "alloc", "queue", "block", "que", "bd", "frame", "bh", "raw", "cb", "result", "ctr", "fam", "off", "port", "band", "coord"], "in_size": ["in33Size", "in_ize", "vin_size", "in64size", "in64Size", " in_ize", "vin_large", "in64offset", " in64ize", "inqsize", " in64size", "buf_size", "vin_loc", "in_range", "in64scale", "in_offset", "vin_ize", "in67Size", "in_storage", " in_member", " in_Size", "in33size", " in_range", "in67member", "in67range", "buf_scale", " in_storage", "in33scale", "buf_Size", "in_large", "in67size", "in_loc", "in_Size", "in64storage", " in64storage", "inqstorage", "in33offset", "in_scale", "in64ize", "buf_offset", "in_member", "inqize"], "out_size": ["outmaxsize", "boxlextime", "outkdata", " inmaxsize", "out_scale", "configkdata", "outkcount", "outlexlarge", "out_channel", " in_shape", "configksmall", "box_large", "box_size", "boxlexscale", "outksmall", "out_count", "buf_size", "out_len", "config_data", " inmaxchannel", " out_storage", "buf_storage", "outlexscale", "out_large", " out_len", "config_size", "out_core", " out_capacity", "config_count", "out_capacity", "boxlexsize", "boxlexlarge", " inmaxshape", "out_data", "outmaxshape", "out_time", "outksize", " out_scale", "outmaxchannel", "buf_scale", "out_storage", "configkcount", "out_small", "out_shape", "outmaxtime", "config_small", " inmaxtime", " out_core", "configksize", "buf_pos", "box_time", "outlextime", "outlexsize", "box_scale", " in_channel", " in_time", "out_pos"], "ret": ["match", "iter", "def", "res", "resp", "rets", "lit", "en", "mem", "rt", "val", "rev", "status", "det", "info", "valid", "f", "cur", "ru", "RET", "len", "temp", "err", "reg", "fun", "red", "error", "r", "tmp", "nt", "result", "ref", "out", "value", "bad", "reply", "rc", "flag", "re", "arr", "obj", "alt", "fin", "success", "Ret", "rep", "rec", "ext"], "samples": ["ssamples", "outsamples", "usamps", "outsamps", "samps", "Sample", "gages", "seample", "Sannels", "semp", "usums", "specamples", "ssamps", "outsources", "specimages", "Smp", "sample", "gamples", "simages", "pages", "ssmp", "Samples", "usamples", "usages", "Samps", "Sources", "sums", "seamples", "seamps", "nannels", "specims", "namples", "seannels", "Sages", "namps", "nample", "ssources", "sims", "specamps", " sums", "pamps", "outsample", "gamps", "sources", "Sums", "ssample", "ssimages", "sages", "pamples", " sages", "ssims", "sannels", " samps"], "samples_end": ["samps_ends", "samples___end", "samps_end", "sample_end", "sipes_end", "samp_end", "samples___ends", "samples_max", "samps_start", "samp_ended", "samples_start", "samples___start", "sample_limit", "samples_length", "samples_ends", "sipes_ends", "sipes_max", "sample_start", "samp_start", "sample_length", "samples_limit", "sipes_start", "samples_ended"], "code": ["desc", "zip", "co", "line", "catch", "cache", "test", "call", "cc", "num", "que", "cat", "name", "ce", "type", "status", "length", "mode", "f", "loc", "change", "state", "seq", "cod", "c", "index", "err", "cb", "error", "cycle", "message", "key", "Code", "flag", "id", "charge", "codes", "number", "cmp", "tag", "comp"], "smp": ["gsrape", " smm", " sme", " sdc", "smb", "somew", "Smb", " supp", "pdc", "cape", "usamp", "sesmp", " syp", "Smm", "Supp", " samp", "sesamp", "Smp", "gsmp", "cmb", " somew", "sape", " sMP", " spp", "Syp", "pmp", "sme", "sMP", " sps", "SMP", " sape", "spp", "usmp", "pamp", "srape", "gsps", " srape", "sesyp", "usomew", "samp", "supp", " smb", "uspp", "sesMP", "pMP", "smm", "cmp", "sps", "sdc", "Samp", "syp", "cme", "gsmb"], "size": ["channel", "time", "cap", "global", "capacity", "shape", "empty", "cache", "en", "area", "sea", "offset", "name", "buffer", "type", "address", "length", "mode", "extra", "loc", "max", "body", "si", "Size", "content", "len", "scale", "SIZE", "c", "send", "age", "sum", "storage", "engine", "ize", "end", "small", "esc", "weight", "sized", "unit", "shift", "gz", "speed", "large", "g", "sec"], "count": ["Count", "zip", "cat", "match", "catch", "class", "empty", "cache", "test", " counts", "current", "call", "cc", "num", "depth", "buffer", "val", "name", "process", "type", "length", "f", "counter", "loc", "low", "max", "coll", "cur", "start", "content", "len", "seq", "index", "c", "parent", "cod", "age", "base", "sum", "error", "found", "col", "cond", "weight", "child", "flag", "id", "number", "list", "last", "map", "large", "info", "all", "comment", "comp"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n\n                                     const int16_t *hLumFilter,\n\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n\n                                     uint8_t *formatConvBuffer,\n\n                                     uint32_t *pal, int isAlpha)\n\n{\n\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n\n\n\n    if (toYV12) {\n\n        toYV12(formatConvBuffer, src, srcW, pal);\n\n        src= formatConvBuffer;\n\n    } else if (c->readLumPlanar && !isAlpha) {\n\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n\n        src = formatConvBuffer;\n\n    }\n\n\n\n    if (!c->hyscale_fast) {\n\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n\n    }\n\n\n\n    if (convertRange)\n\n        convertRange(dst, dstWidth);\n\n}\n", "idx": 20613, "substitutes": {"c": ["C", "dc", "mc", "cf", "cy", "cl", "w", "gc", "xc", "cit", "p", "h", "lc", "cu", "enc", "call", "cc", "core", "co", "ac", "ce", "f", "config", "s", "cr", "pc", "uc", "cur", "coll", "oc", "sc", "b", "v", "fc", "ct", "n", "con", "ca", "com", "e", "cs", "l", "conn", "r", "ch", "u", "can", "cm", "d", "bc", "unc", "cp", "ic", "tc", "rc", "ctx", "k", "vc", "m", "cpp", "ci", "t", "conf", "ctrl", "nc", "context", "g", "this", "ec", "comp"], "dst": ["Dst", "tdsrc", "ldda", "isdsc", "isdST", "idst", " dsrc", " dest", "tdsth", "sdST", "isdsth", "idsc", "idest", "adst", "adsts", "dsrc", "dsth", "bdsl", "Dsts", "Dsth", "sdsth", " dsc", "ldst", "dsc", " dST", "dST", "adsc", "dest", " dsth", "isdst", "dsts", "adest", "dda", "dsl", "tdst", "bdst", "ldsl", " dda", " dsl", "idsts", " dsts", "ldsc", "sdsc", "tdsts", "Dsrc", "sdst", "bdda", "bdsc"], "dstWidth": ["drcWidth", "dSTHeight", "drcHeight", "dirstWidth", " dscExp", "dstsHeight", "dgestWidth", "dirstHeight", "dgestwidth", "dSTPath", " dstPath", "DSTWidth", " dSTWidth", "dscWidth", " dSTHeight", " dscHeight", "dstPath", "dstsWidth", " dSTLength", "drcwidth", "destHeight", "dirstwidth", "dscHeight", "destWidth", "dStwidth", " dstwidth", " dstHeight", " dscWidth", "dscPath", "destwidth", " dstLength", "DstHeight", "dirstExp", "drcLength", " dSTwidth", "dSTLength", "dSTwidth", "Dstwidth", "DstWidth", "dscExp", "DSTHeight", "DSTwidth", "dStHeight", "dStWidth", "dstsLength", "destLength", "dgestHeight", "dscwidth", "dstswidth", "DSTLength", "dgestPath", "dstwidth", "dStLength", " dstExp", "dstLength", "DstLength", " dscPath", "dSTWidth", "dstHeight", "dSTExp", "dstExp", " dscwidth"], "src_in": ["loc_inn", "src_again", " src_out", "src_out", " src_inc", "rc_again", "rc_in", "src2inc", "loc_ins", "src_inc", "loc_out", "src_ins", "src_inn", "src2in", "src2out", "loc_in", "rc_ins"], "srcW": ["sourceL", "srcw", " srcw", "instV", "rcL", "locW", "instW", "rcWidth", "rcH", "sourceW", "locV", "rcw", "srcL", "sourcew", " srcWidth", " srcV", "srcH", "srcWidth", "locWidth", " srcH", "sourceV", " srcL", "instw", "instH", "rcV", "srcV", "instL", "rcW", "locw"], "xInc": [" xINC", " xIncre", "xAdd", "xiINC", "xinc", "XAdd", "XInc", "xINC", "XINC", "xiInc", "Xinc", " xAdd", "xaINC", " xinc", "xiinc", "XIncre", "xaInc", "xaIncre", "xIncre", "xainc", "xiAdd"], "hLumFilter": ["hPlumTarget", "hLumTarget", "hPlumF", "hLumMask", "hLamFrame", "hElUMMask", "hLamFilter", "hLumberF", "hLUMFilter", "hPlumFilter", "hElUMFrame", "hElUMFilter", "hLUMTarget", "hLamMask", "hLumFrame", "hLoughLayer", "hLUMFrame", "hLoughFilter", "hLumberFilter", "hElumFilter", "hPlumMask", "hLumF", "hLumLayer", "hPlUMMask", "hPlUMFilter", "hLumberMask", "hElumFrame", "hLumberTarget", "hLUMMask", "hElumMask", "hLUMF", "hLUMLayer", "hLamLayer", "hPlUMF", "hElumLayer", "hPlUMTarget", "hElUMLayer", "hLamTarget", "hLamF", "hLoughMask", "hLoughFrame"], "hLumFilterPos": ["hLUMFRel", "hLumBufferSize", "hLumFilePos", "hLumFileDef", "hLumGroupRel", "hLumGroupPosition", "hLUMFilterRel", "hLumbFSize", "hLumFPosition", "hLumbFPosition", "hLumFilePosition", "hLumBufferRes", "hLumbFilterPos", "hLUMFRes", "hLUMFPosition", "hLumbFDef", "hLumBufferPos", "hLumFilterPosition", "hLumFRes", "hLumbFilterSize", "hLumGroupRes", "hLUMFilterPos", "hLumFilterRel", "hLUMFilterPosition", "hLumFileSize", "hLumFRel", "hLumFPos", "hLumbFilterDef", "hLUMFPos", "hLumFilterDef", "hLumGroupPos", "hLUMFilterRes", "hLumBufferRel", "hLumBufferDef", "hLumFSize", "hLumbFilterPosition", "hLumFDef", "hLumBufferPosition", "hLumFilterRes", "hLumbFPos"], "hLumFilterSize": ["hLumMaskCount", "hLUMFOffset", "hLumBufferOffset", "hLumBufferSize", "hLumbFilterCount", "hLumFilterLen", "hLumMaskSize", "hLumFilterStyle", "hLumBufferStyle", "hLumBufferLen", "hLumBlockSize", "hLumLimitSize", "hLumFilterCount", "hLumBufferCount", "hLumMaskPos", "hLumbFilterLen", "hLumbFilterPos", "hLUMFStyle", "hLumBufferPos", "hLumbBufferLen", "hLumbBufferPos", "hLumFOffset", "hLumLimitPos", "hLumbFilterSize", "hLumLimitOffset", "hLUMFilterPos", "hLumLimitStyle", "hLumFPos", "hLumFStyle", "hLUMFPos", "hLUMFilterStyle", "hLumBlockPos", "hLumFilterOffset", "hLumbBufferCount", "hLUMFSize", "hLumBlockCount", "hLumFSize", "hLumBlockLen", "hLUMFilterSize", "hLumbBufferSize", "hLUMFilterOffset", "hLumMaskLen"], "formatConvBuffer": ["formatConvertBuff", "formatConvFile", "formatConvbuffer", "formatEnfFile", "formatConvtBuffer", "formatConvtBuff", "formatConuvBegin", "formatEnvSource", "formatConfBegin", "formatConvertBar", "formatConVCache", "formatConvtFile", "formatConfBuffer", "formatConVBuffer", "formatEnfSource", "formatConvBuff", "formatEnVPtr", "formatConuvPtr", "formatConfBuff", "formatEnvBegin", "formatConuvBuff", "formatConventionBuffer", "formatConvpBar", "formatConVBegin", "formatConVBar", "formatEnvBuffer", "formatConvpBuffer", "formatEnVBuff", "formatEnfBuff", "formatEnvReader", "formatConventionbuffer", "formatConvertbuffer", "formatConventionBuff", "formatConventionReader", "formatConvertReader", "formatConvpBuff", "formatConVbuffer", "formatConVPtr", "formatConvertSource", "formatEnvbuffer", "formatConfFile", "formatConvpCache", "formatEnvBuff", "formatEnVbuffer", "formatConvReader", "formatConvBar", "formatEnVCache", "formatEnvFile", "formatEnfBuffer", "formatConuvBuffer", "formatEnVBegin", "formatConfbuffer", "formatConVFile", "formatConvertBuffer", "formatConvCache", "formatConvBegin", "formatConvSource", "formatEnvCache", "formatConfCache", "formatEnfbuffer", "formatEnvPtr", "formatConfBar", "formatConVBuff", "formatConVSource", "formatConvPtr", "formatConfSource", "formatEnVBar", "formatConvtbuffer", "formatConfPtr", "formatEnVBuffer", "formatEnVReader", "formatEnfBar", "formatConVReader", "formatEnvBar"], "pal": ["real", "ace", "al", "cache", "p", "opal", "local", "val", "cale", "pack", "plan", "app", "as", "bl", "rel", "pixel", "pp", "align", "bin", "scale", "ar", "alias", "alpha", "ab", "cal", "ass", "pl", "li", " Pal", "Pal", "isal", "pad", "conf", "face", "cell"], "isAlpha": ["hasalpha", "arealpha", "areAlias", "areFace", "ISAlpha", " isAlias", "isRa", " isRa", "IsDelta", "hasAlpha", "ISBeta", "areRa", "hasBeta", "isaalpha", " isalpha", " isFace", "isaAlpha", " isBeta", "isDelta", "ISFace", "isalpha", "ISalpha", "IsBeta", "isaRa", "Isalpha", "isAlias", "areAlpha", "isFace", "isBeta", "ISAlias", " isDelta", "hasDelta", "IsAlpha", "IsAlias", "isaAlias"], "toYV12": ["toYV14", "toYGV13", "toYYV15", "toYv52", "toYV13", "toYN11", "toYM14", "toYYH15", "toYV6", "toXV20", "toYX12", "toYYV52", "toXv12", "toXv20", "toXv6", "toYYV12", "toYN14", "toYF20", "toYM11", "toYGV6", "toYX13", "toYGV12", "toYN13", "toYV52", "toXv11", "toYv20", "toYV20", "toYH13", "toYv12", "toYv14", "toYM13", "toYYH13", "toYF12", "toYv11", "toXV13", "toXV12", "toYGV20", "toYH52", "toXV6", "toYV11", "toYF13", "toXV11", "toYYH52", "toYV15", "toYM12", "toYH15", "toYv15", "toYv6", "toYX15", "toYH12", "toXv14", "toYYV13", "toYYH12", "toYN12", "toYX52", "toYF6", "toXv13", "toYv13", "toXV14"], "convertRange": ["converRange", "conversionrange", "conpectrange", "conversionRegion", "convertingResource", "conpectRange", "ConverRing", "ConvertRange", "ConvertRing", "ConversionRGB", "Conversionrange", "conpectRGB", "Converrange", "convertedrange", "pervertedFrame", "convertingRGB", "pervertrange", "convertrange", "ConvertRGB", "ConversionRange", "ConverRange", "conformatrange", "pervertedRange", "convertFrame", "convertRegion", "pervertRange", "pervertedRegion", "converrange", "conversionRGB", "converResource", "Convertrange", "convertedRegion", "convertResource", "conversionRange", "conformatRange", "convertedFrame", "convertingrange", "ConvertResource", "convertRing", "convertRGB", "conformatRegion", "convertingRing", "conversionFrame", "converRing", "pervertedrange", "convertingRange", "conformatFrame", "convertedRange", "ConverResource", "pervertFrame", "pervertRegion"], "src": ["support", "inst", "st", "sit", "sq", "secure", "rin", "rs", "sync", "img", "rss", "loc", "proc", "config", "stat", "func", "sr", "uc", "sc", "fc", "scl", "uri", "stream", "gl", "asc", "sub", "feat", "cb", "sb", "dest", "sel", "usr", "source", "sup", "sur", "bc", "supp", "url", "rc", "attr", "impl", "rob", "ssl", "ctx", "gb", "sys", "rect", "href", "sid", "lib", "rl", "sl", "rg", "rb", "comp", "sn"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */\n\n                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n", "idx": 20617, "substitutes": {"av_flatten": ["av_fatten", "av_ffatt", "av2fratten", "av2flatten", "av2fratt", "av_fip", "av2fl_", "av_flip", "av2frip", "av_fratten", "av_ff_", "av_fatt", "av2fr_", "av_fratt", "av2flatt", "av_ffip", "av_fl_", "av2flip", "av_f_", "av_fr_", "av_flatt", "av_frip", "av_ffatten"], "pix": [" pirm", "tixels", "pIX", "fixels", "picks", "npix", "ipix", "vlex", "tius", "perix", "Pip", "ipx", "pixels", "perinch", " pixel", "pius", " pius", "bip", "cIX", " pIX", "cixels", "bix", "Pixel", "Pox", "plex", "ipinch", " picks", "fox", "Pixels", "vix", "iplex", "vip", " pixels", "pixel", "ipip", "pox", "spirm", "PIX", "tix", "cox", " plex", "bixel", "fixel", "spius", "spip", "spox", "spixel", "fix", "fius", " pip", " pinch", "bixels", "npip", "pip", "tirm", "ipicks", "pinch", "npox", "spixels", "spix", "pericks", "perx", "spIX", " px", "fIX", "pirm", "vx", "px", " pox", "npixel", "cix", "Pix"], "xstride": ["xStrid", "xptide", "xcollider", "xStrides", "ystide", "xSTRide", "xdivided", "xStrider", "XStride", "Xstride", "XStrides", "xstided", "ystrice", "ystrided", "xSTRride", "xdecider", "XStrider", "ystided", "ystider", "xStride", "ystrid", "xstrided", "xdivide", "Xstrider", "xstice", "ystrider", "Xstrided", "xStrice", "xptride", "ystice", "xstide", "xdecide", "xstrides", "xstid", "xbrides", "xbrride", "xcollide", "xstrid", "xSTRided", "ystrride", "xStrided", "xstrice", "xdivides", "xptice", "xstrride", "XStrided", "xstider", "xstrider", "xptided", "xbride", "xdecided", "xbrided", "xdecride", "xdivider", "xbrider", "xcollride", "ystid", "xStrride", "xcollided", "Xstrides", "xSTRid"], "ystride": ["ystide", "yetride", "xstided", "ydride", "ystrided", "ydrided", "ycollride", "ystided", "ystider", "ystapse", "xstides", "xstrided", "ystaided", "yetrider", "yStrider", "yStrides", "yvariide", "yvariapse", "yetrides", "ystrider", "xstide", "ycollapse", "xstrides", "ydrides", "yetrided", "ystrides", "ystrride", "ydrider", "ystaider", "ycollide", "ystides", "xstrride", "xstider", "ystaides", "xstrider", "yStrided", "xstrapse", "ycollider", "ystaide", "xstapse", "yStride", "yvariride", "yvariider", "ystrapse"], "alpha": ["lambda", "abi", "aa", "igma", "zero", "p", "area", "phi", "acl", "ac", "offset", "ta", "ma", "as", "si", "b", "\u03b1", "a", "audio", "filter", "amp", "scale", "ca", "sum", "r", "acc", "Alpha", "u", "size", "A", "rc", "la", "ima", "Beta", "phase", "asc", "inc", "mu"], "beta": ["lambda", "ii", "abi", "aa", "x", "\u03b2", "igma", "pa", "zero", "bb", "phi", "ac", "offset", "ta", "margin", "b", "si", "\u03b1", "a", "scale", "base", "ca", "da", "sum", "error", "acc", "appa", "budget", "radius", "Alpha", "negative", "size", "A", "bc", "qa", "tc", "pad", "la", "phase", "Beta", "pha", "ba", "mu"], "tc0": ["lc6", "lc0", "TC2", "tc6", "TC6", "uc8", "cu8", "tc2", "ec0", "lc2", "TC0", "cu0", "ec8", "cu2", "cu6", "lc8", "tc8", "TC8", "uc0"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "p", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ni", "ie", "is", "b", "si", "io", "v", "pi", "n", "index", "c", "o", "e", "y", "l", "r", "vi", "xi", "u", "chi", "yi", "fi", "li", "iu", "k", "id", "m", "ci", "mi", "zi", "gi", "mu", "bi", "it", "ip"], "d": ["dm", "dc", "nd", "du", "x", "w", "p", "cd", "dt", "bd", "ds", "dim", "f", "j", "md", "dl", "s", "D", "b", "dh", "dq", "ct", "v", "n", "df", "c", "da", "e", "dat", "ind", "dx", "l", "fd", "u", "dd", "dom", "diff", "data", "k", "id", "m", "ad", "t", "dn", "dy", "dp", "g", "z", "ld"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "int ff_mpeg4_decode_picture_header(MpegEncContext * s, GetBitContext *gb)\n\n{\n\n    int startcode, v;\n\n\n\n    /* search next start code */\n\n    align_get_bits(gb);\n\n    startcode = 0xff;\n\n    for(;;) {\n\n        v = get_bits(gb, 8);\n\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        \n\n        if(get_bits_count(gb) >= gb->size*8){\n\n            if(gb->size==1 && s->divx_version){\n\n                printf(\"frame skip %d\\n\", gb->size);\n\n                return FRAME_SKIPED; //divx bug\n\n            }else\n\n                return -1; //end of stream\n\n        }\n\n\n\n        if((startcode&0xFFFFFF00) != 0x100)\n\n            continue; //no startcode\n\n        \n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            printf(\"startcode: %3X \", startcode);\n\n            if     (startcode<=0x11F) printf(\"Video Object Start\");\n\n            else if(startcode<=0x12F) printf(\"Video Object Layer Start\");\n\n            else if(startcode<=0x13F) printf(\"Reserved\");\n\n            else if(startcode<=0x15F) printf(\"FGS bp start\");\n\n            else if(startcode<=0x1AF) printf(\"Reserved\");\n\n            else if(startcode==0x1B0) printf(\"Visual Object Seq Start\");\n\n            else if(startcode==0x1B1) printf(\"Visual Object Seq End\");\n\n            else if(startcode==0x1B2) printf(\"User Data\");\n\n            else if(startcode==0x1B3) printf(\"Group of VOP start\");\n\n            else if(startcode==0x1B4) printf(\"Video Session Error\");\n\n            else if(startcode==0x1B5) printf(\"Visual Object Start\");\n\n            else if(startcode==0x1B6) printf(\"Video Object Plane start\");\n\n            else if(startcode==0x1B7) printf(\"slice start\");\n\n            else if(startcode==0x1B8) printf(\"extension start\");\n\n            else if(startcode==0x1B9) printf(\"fgs start\");\n\n            else if(startcode==0x1BA) printf(\"FBA Object start\");\n\n            else if(startcode==0x1BB) printf(\"FBA Object Plane start\");\n\n            else if(startcode==0x1BC) printf(\"Mesh Object start\");\n\n            else if(startcode==0x1BD) printf(\"Mesh Object Plane start\");\n\n            else if(startcode==0x1BE) printf(\"Still Textutre Object start\");\n\n            else if(startcode==0x1BF) printf(\"Textutre Spatial Layer start\");\n\n            else if(startcode==0x1C0) printf(\"Textutre SNR Layer start\");\n\n            else if(startcode==0x1C1) printf(\"Textutre Tile start\");\n\n            else if(startcode==0x1C2) printf(\"Textutre Shape Layer start\");\n\n            else if(startcode==0x1C3) printf(\"stuffing start\");\n\n            else if(startcode<=0x1C5) printf(\"reserved\");\n\n            else if(startcode<=0x1FF) printf(\"System start\");\n\n            printf(\" at %d\\n\", get_bits_count(gb));\n\n        }\n\n\n\n        switch(startcode){\n\n        case 0x120:\n\n            decode_vol_header(s, gb);\n\n            break;\n\n        case USER_DATA_STARTCODE:\n\n            decode_user_data(s, gb);\n\n            break;\n\n        case GOP_STARTCODE:\n\n            mpeg4_decode_gop_header(s, gb);\n\n            break;\n\n        case VOP_STARTCODE:\n\n            return decode_vop_header(s, gb);\n\n        default:\n\n            break;\n\n        }\n\n\n\n        align_get_bits(gb);\n\n        startcode = 0xff;\n\n    }\n\n}\n", "idx": 20618, "substitutes": {"s": ["rates", "sq", "S", "ks", "aws", "sync", "sa", "sg", "http", "se", "ses", "ds", "f", "sim", "ions", "sci", "fs", "b", "sc", "ss", "si", "so", "ts", "n", "c", "ps", "sb", "storage", "sm", "e", "cs", "space", "service", "session", "qs", "ops", "d", "ssl", "ctx", "gs", "self", "os", "sys", "conf", "su", "sf", "m", "server", "ns", "g", "spec", "sl", "sv", "js"], "gb": ["bm", "ui", "cfg", "gg", "tg", "gp", "gc", "gm", "src", "bb", "gy", "bridge", "img", "gam", "ge", "buff", "db", "buffer", "pg", "bg", "pc", "nb", "bf", "gd", "b", "gin", "ges", "cod", "GB", "ga", "cb", "sb", "storage", "bp", "mb", "cgi", "jpg", "kb", "hub", "py", "pb", "bc", "usb", "gs", "ctx", "abb", "fx", "gz", "bn", "fb", "gio", "gi", "g", "eb", "sg", "sl", "rb", "rg"], "startcode": ["launchcod", "initcod", "initerror", "startcodes", "initcode", " startback", "addstart", "launchcreate", "startstate", " startdesc", "lookcode", "addback", "startpage", "lookdesc", "openCode", "frontframe", " startcall", "typecode", " startcheck", "gradecode", "startcount", "startstart", "stopcod", "idcod", "artcode", "frontcode", "startingcode", "usecode", "opencod", "startcheck", "gradeCode", "gradecase", "startCode", "stepscore", "pickcod", "startcue", "artcell", "cellcell", "playback", "pickstart", "bootstate", "bootCode", "idcount", "startcatch", "frontcod", "stopcode", "frontcreate", "checkcell", "startfore", "stopsequence", "gradehide", "skycod", " startcoded", "checkce", "pickerror", "pickval", "fillcodes", "skyframe", "opencue", "initcount", " startsequence", "startce", " startCode", "startframe", "endcod", "idback", "startingcolor", " startcodes", "idval", "startdesc", "frontstate", "bootc", "trycheck", "startcomplete", "startcoded", "stopclass", " startcell", "endcode", "trycod", "writestart", "fillcount", "endCode", " starterror", "cellcode", "pickcreate", "workfore", " startcase", "fillcode", "stopcoded", "artCode", "usecod", "idstart", " startcomp", "starterror", "stepCode", "initcoded", "newback", "endscore", "bootval", "pickCode", "launchstate", "pickcode", "startscore", "usecue", "typestate", "startcase", "showfore", "stepstart", "addcode", "artcod", "frontcomp", "newcolor", "idCode", "initstart", "startcall", "stepcod", "pickpage", " startscore", "startcolor", "stepcode", "addcomplete", "cellcomplete", "checkcall", "idcodes", "stopcomp", "startsequence", "startval", "launchcode", "stopstart", "stopc", "startcomp", "pickcodes", "pickstate", " startce", "lookcod", "lookfe", " startstart", "starthide", "artstart", "stopCode", "startclass", "writecode", "arthide", "startcreate", "playcod", "addcod", "bootcode", "stopstate", " startc", " startstate", "stopcall", "statcod", "newcode", "useCode", " startclass", "typeframe", "typestart", "endcodes", " startcomplete", "useclass", "workcatch", "frontstart", "addcall", "fillcod", "stepcue", "skystate", "openstate", "idcode", "opencode", "showcod", "writecod", "startcod", "frontclass", "lookstart", "initpage", "stepcell", " startfe", " startcod", "startc", "showcatch", "showcode", " startcatch", "stopce", "frontdesc", " startcount", "endcount", "cellcall", "statfe", "lookframe", "startcell", "startingcod", "stopframe", "workcod", "writecheck", "playcode", "initCode", "lookcall", " starthide", " startframe", "addcell", "workcode", "startingback", "startback", "trystart", "skycode", "playcolor", "usestart", "bootsequence", "statcode", "frontCode", "statcall", "stepcount", "stopcell", "openframe", " startpage", "newcod", "artcase", "checkcode", " startfore", "trycode", "bootcodes", "startfe"], "v": ["x", "w", "ve", "version", "p", "h", "tv", "val", "j", "f", "uv", "q", "vv", "b", "n", "o", "e", "l", "r", "vt", "vi", "va", "u", "vp", "value", "V", "d", "count", "lv", "k", "i", "m", "t", "vs", "vg", "g", "vd", "z", "sv"]}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n    const uint8_t *buf_start= buf;\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1) * 2;\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        s->repeat_pict = 1;\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 5;\n\n                                else\n\n                                    s->repeat_pict = 3;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 2;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}\n", "idx": 20620, "substitutes": {"s": ["sets", "sq", "S", "ks", "rs", "p", "h", "ls", "aws", "sync", "sa", "http", "bis", "ses", "sim", "f", "sec", "stats", "sc", "b", "ss", "ts", "v", "si", "acs", "c", "spec", "ps", "parser", "sb", "hs", "e", "cs", "r", "service", "session", "u", "services", "private", "qs", "ssl", "ctx", "gs", "self", "su", "sys", "conf", "t", "os", "m", "client", "server", "socket", "g", "sl", "sg", "sv", "js"], "avctx": ["auctx", " avkb", "avalcontext", "aveca", "avbc", "avalmac", " avca", "avloc", "navcontext", "capcontext", "avalctx", "avalconn", "avkb", "aucontext", "AVca", "auutils", " avutils", "averkb", "awutils", "awcontext", "avmac", "afca", "awca", "avcontext", "afcmd", "avecontext", "avecas", "capconn", "avconn", "avectx", "AVctx", "AVutils", "awcas", "AVcas", "afutils", "akctx", "akcontext", "averctx", "navcmd", "afconn", "AVcontext", "awbc", "afloc", "avutils", "AVkb", "akloc", "afbc", " avcontext", "capctx", "akcmd", "afmac", "navctx", "avcmd", "capmac", "avcas", " avconn", "afctx", "navloc", "averutils", "avercontext", "aubc", "avca", "aveconn", "awctx", "afcontext"], "buf": ["br", "box", "cv", "uber", "buffer", "offset", "lim", "f", "cur", "border", "seq", "feat", "cas", "begin", "ab", "pb", "ff", "bc", "pos", "data", "count", "gb", "bn", "BU", "fb", "uu", "binary", "ha", "loop", "src", "img", "num", "db", "Buff", "xff", "loc", "config", "bf", "cmd", "b", "len", "header", "fw", "vec", "fd", "batch", "auc", "bu", "hub", "end", "rc", "Buffer", "home", "cap", "text", "wb", "bb", "bo", "buff", "length", "func", "uc", "v", "aux", "fp", "usr", "bag", "conv", "ffff", "comb", "ctx", "orig", "rb", "cf", "uf", "alloc", "queue", "block", "bd", "fab", "max", "grab", "bh", "exc", "cb", "ctr", "fam", "off", "port", "coord", "su", "ba"], "buf_size": ["bufallsize", "buflexsize", "buffer_size", "buf_sh", "bufallnum", "bufdsize", "bufdnum", "buflexscale", " buf_scale", "buf_scale", "bufdend", "bufallsh", "bufdsh", "buf_num", "bufallend", "buflexsource", "buffer_sh", "buf_source", "buffer_end", " buf_source", "buffer_num", "buflexend"], "pc": ["mc", "dc", "cz", "inc", "cms", "aa", "cl", "pac", "pd", "pa", "cache", "xc", "p", "lc", "cu", "enc", "cc", "acl", "pic", "ac", "co", "proc", "pg", "pm", "cus", "uc", "anc", "jc", "oc", "sc", "fc", "toc", "ct", "amp", "c", "ca", "lp", "PC", "bp", "pt", "cs", "py", "pb", "arc", "bc", "cp", "rc", "tc", "ctx", "vc", "gb", "sys", "client", "nc", "px", "cam", "wp", "ec"], "buf_end": ["buf00end", "buf00start", "buf_range", "cmd_range", "uc_end", "buf67size", "buf_est", "buf00stop", "uc_set", "cmd67size", "buffer_start", "buf67end", "buffer_end", "buffer_length", "buf67length", "cmd67end", "cmd67range", "cmd67End", "uf_offset", "cmd_end", "buf__est", "uf_start", "buf_stop", "cmd_size", "buf67start", "buffer_size", "uf_stop", "uc_est", "buf00pos", "buf_End", "uc_offset", "buf67End", "uf_set", "buf67range", "buf_pos", "buf_length", "buf00offset", "cmd_End", "buf__set", "buf00set", "uf_pos", "buf_set", "buf__offset", "buf__end", "uf_end", "buf_offset"], "buf_start": ["buf00info", "buf_info", "bufamend", "queue_start", "seq_end", "bufMsource", "bufMstart", "bufamlast", "buf00end", "buf00start", "seq_source", "bufMend", "seq_id", "buf00last", "seqMstart", "seq_start", "queue_end", "seqMsource", "queue_last", "buf_last", "seqMid", "bufaminfo", "seqMend", "queue_info", "buf_id", "bufMid", "buf_source", "bufamstart"], "start_code": ["start64codes", "startingxnumber", "part64codes", "startlenmode", "end_code", "start_number", "startlensize", "startencode", "start_length", "starting_code", "end_ce", "startingxcode", "start64code", "start_codes", "startlencode", "start67order", "start_ce", "part64code", "startxCode", "start_mode", "startingxCode", "start64func", "start67Code", "start_count", "start64number", "startaclength", "part_func", "end_order", "startlencount", "startingxlength", "part_number", "startacnumber", "starting_Code", "start67code", "part_codes", "start_size", " start_size", "part64number", "starting_length", "startensize", "startxnumber", "startacCode", "starting_number", "startxlength", " start_mode", "end_Code", "start67ce", "part_code", " start_count", "startencount", "start_order", "startxcode", "startenmode", "part64func", "start_func", "start_Code", "startaccode"], "frame_rate_index": ["frame_score_left", "frame_rate_key", "frame_scoreactype", "frame_rideackey", "frame_rate_prefix", "frame_rate_loc", "frame_scoreaclead", "frame_rate_id", "frame_rateaclead", "frame_rateackey", "frame_rateactype", "frame_rideaccount", "frame_rideacindex", "frame_rate2type", "frame_rate_ind", "frame_rate_type", "frame_rateacloc", "frame_rate_lead", "frame_score_lead", "frame_rate_offset", "frame_rate_count", "frame_rate2left", "frame_ride_key", "frame_rateacleft", "frame_rate2index", "frame_rate_left", "frame_ride_index", "frame_rateaccount", "frame_ride_loc", "frame_ride_count", "frame_scoreacindex", "frame_rateacindex", "frame_rate_condition", "frame_rate2lead", "frame_score_type", "frame_scoreacleft", "frame_score_index", "frame_rideacloc"], "ext_type": ["frame_type", "extlstyle", "ext_style", "frame_position", "extltype", "extlposition", "ext_typ", "ext_position", "extltyp", "frame_typ", "frame_style"], "bytes_left": ["bytes___right", "lines_shift", "bytes___width", "bytes___bottom", "seconds_leave", "lines_left", "seconds_left", "bytes_size", "bytes_bottom", " bytes___found", "bytes64left", "bytes2bottom", "bytes_found", "bytes64right", "seconds_bottom", " bytes_right", "bytesxlimited", " bytes___right", "bytes64needed", "bytes64shift", "lines_needed", "seconds_right", " bytes___width", "lines_size", "bytes_width", "bytes_needed", "bytes___found", "bytesxright", "bytes2right", "lines_right", "bytesxsize", "bytes2left", " bytes_width", "bytes_leave", " bytes___left", "lines_limited", "bytes_shift", "bytes_right", "bytes2leave", " bytes_found", "bytes_limited", "bytesxleft", "bytes___left", "bytes___leave"], "frame_rate_ext_n": ["frame_rate_xt_num", "frame_rate_xt_n", "frame_rate_xt_d", "frame_rate_ext_num", "frame_rate_xt_pos", "frame_rate_ext_pos"], "frame_rate_ext_d": ["frame_rate_ext_min", "frame_rate_xt_dim", "frame_rate_xt_n", "frame_rate_xt_d", "frame_rate_ext_dim", "frame_rate_xt_min"], "picture_structure": ["picture_restyle", "picture_estitute", "picture_estruction", "picture_distitute", "picture_restitute", "picture_estyle", "picture_restructure", "picture_restruction", "picture_distyle", "picture_stitute", "picture_style", "picture_distructure", "picture_struction", "picture_estructure", "picture_distruction"], "top_field_first": ["top_field_prev", "top_field_count", "top_field_last", "top_line_count", "top_line_first", "top_line_last", "top_line_prev"], "repeat_first_field": ["repeat_first___field", "repeat_max_block", "repeat_max___window", "repeat_max___frame", "repeat_first___frame", "repeat_max_window", "repeat_max___field", "repeat_first_window", "repeat_firstalfield", "repeat_firstalblock", "repeat_firstalframe", "repeat_max_field", "repeat_first___block", "repeat_firstalwindow", "repeat_max___block", "repeat_first___window", "repeat_first_frame", "repeat_max_frame", "repeat_first_block"], "progressive_frame": ["progressiveacmedia", "progressive_media", "proitive_media", "proitiveacmedia", "progressivelywindow", "proitive_window", "progressiveacframe", "progressivelysize", "proitiveacwindow", "proitive_size", "progressiveablesize", "progressiveacwindow", "progressivelymedia", "progressiveablewindow", "proitiveacframe", "progressiveableframe", "progressivelyframe", "proitive_frame", "progressiveacsize", "progressive_size", "proitiveacsize", "progressive_window", "progressiveablemedia"], "horiz_size_ext": ["horiz_size_sec", "horiz_ize_EXT", "horiz_ize_sec", "horiz_ize_ext", "horiz_size_EXT", "horiz_size_xt", "horiz_ize_xt"], "vert_size_ext": ["vert_sizeetcomplete", "vert_dataedcomplete", "vert_sizeeddownload", "vert_sizeetdownload", "vert_size1ext", "vert_data_complete", "vert_data_aux", "vert_sizeetaux", "vert_size1download", "vert_size_download", "vert_data_download", "vert_size_aux", "vert_sizeedext", "vert_dataedaux", "vert_data_ext", "vert_size_complete", "vert_sizeetext", "vert_size1aux", "vert_sizeedaux", "vert_size1complete", "vert_sizeedcomplete", "vert_dataedext", "vert_dataeddownload"], "bit_rate_ext": ["bit_rate_txt", "bit_size_xt", "bit_rate_xt", "bit_size_ext", "bit_size_x", "bit_size_txt", "bit_rate_x"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int set_chroma_format(AVCodecContext *avctx)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx) {\n\n        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {\n\n            p_schro_params->format->chroma_format =\n\n                            schro_pixel_format_map[idx].schro_pix_fmt;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR,\n\n           \"This codec currently only supports planar YUV 4:2:0, 4:2:2\"\n\n           \" and 4:4:4 formats.\\n\");\n\n\n\n    return -1;\n\n}\n", "idx": 20623, "substitutes": {"avctx": ["AVxc", "ajctx", "abcv", "afcmp", "ajcam", "afcv", "afxc", "akcmp", "avcontext", " avcmp", "avconn", "AVctx", " avcam", "akctx", " avxc", "akcontext", "afconn", "AVcontext", " avcv", "avcmp", "avxc", "avcam", "avcv", "AVconn", " avcas", "abctx", " avcontext", "ajcas", "ajcontext", "avcas", "afcam", "akconn", "afcas", "afctx", "AVcmp", "abcontext", "abcmp", "afcontext"], "idx": ["idv", "idb", "ipxc", "idei", " idp", "idex", "IdX", " idux", "ipix", "sidux", "kidy", "idxc", "sidex", "indX", "idy", "ipx", "indb", "ideix", "idi", "pidx", "IDx", " idy", "Idx", " idxs", "pidp", "ideb", "index", "ipz", "idp", "idey", "sidx", "idX", "ipb", "ipi", "indx", "kidix", "midz", "IDy", " idX", "kidx", "midx", "idxs", "IDxs", "Idxs", "indp", "idux", "midxc", "pidX", "IDX", " idex", "pidy", "idz", "indi", "midp", "Idy", "sidy", "idix", " idxc", "ipp", " idv", "kidv", " idz", "indux", "indix", "idev", " idix", "indy"], "p_schro_params": ["p_schro_param", "p_schropparams", "p_schropmanager", "p_schro_nas", "p_schlo_params", "p_schaco_ams", "p_schropams", "p_schro_manager", "p_schropparam", "p_schlo_param", "p_schaco_nas", "p_schaco_args", "p_schlo_ams", "p_schlo_manager", "p_schro_args", "p_schro_ams", "p_schaco_params"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 20631, "substitutes": {"ctx": ["dc", "mc", "cf", "cv", "xc", "src", "cu", "linux", "cc", "cci", "loc", "cli", "config", "pc", "irc", "anc", "Context", "sc", "jc", "kw", "c", "ga", " cx", "cb", "cas", "ca", "ck", "tx", "conn", "kb", "cm", "conv", " context", "bc", "qa", "cp", "tc", "cca", "ci", "pkg", "cmp", "context", "exec", "comp"], "rb": ["lb", "wb", "src", "bb", "lc", "ra", "rt", "db", "RB", "xb", "rm", "cr", "sr", "ru", "rx", "bf", "b", "vr", "cb", "sb", "r", "pb", "rd", "bc", "rf", "rw", "gb", "abc", "fb", "ctrl", "lr", "rl", "rg"], "rc": ["dc", "RC", "inst", "rs", "cv", "src", "inf", "lc", "ra", "cc", "rt", "config", "cur", "pc", "cr", "uc", "irc", "ru", "roc", "sc", "sr", "rx", "anc", "fc", "c", "cb", "entry", "error", "rr", "r", "rib", "result", "auc", "ref", "rn", "bc", "tc", "rf", "input", "gb", "rect", "nc", "context", "rl", "ource", "rg", "rec"], "fn11": ["ln14", "fn12", "FN12", "sn12", "FN14", "fn2011", " fn15", "ln31", "dn11", "fn14", "sn15", "sn11", "ln12", " fn12", "hn11", " fn2011", "ln11", "hn14", " fn31", " fn14", "ln9", "lf2011", "lf11", "tn2011", "dn31", "FN9", "tn15", "fn9", "lf15", " fn9", "FN31", "fn15", "sn14", "hn12", "fn31", "tn11", "hn15", "FN11", "dn12"], "vb": ["ivb", "svv", " vbas", "jp", "vidb", "Vf", "Va", "ivcb", "ivba", "svba", "varip", "nvcb", "Vc", "svp", "varidb", " vcb", "vv", "jc", "vip", "Vp", "varib", "ivc", "vdb", " vdb", "jb", "svcb", "nvb", "sva", "ivf", " vv", "Vb", "ivp", "va", "vf", "Vv", "vba", "jf", " vf", "vp", "vib", "vbas", "vibas", "svb", "nva", "nvf", "vcb", " vp", "varibas", " vba", "svf", " va"], "vc": ["dc", "cf", "gg", "voc", "gc", "cv", "xc", "src", "nv", "lc", "bb", "cu", "cc", "cci", "qv", "cli", "vv", "pc", "gd", "vm", "fc", "vr", "wx", "c", "fw", "ga", "cb", "gru", "VC", "vt", "fp", "hw", "service", "vp", "wcs", "qa", "ic", "iw", "lv", "dk", "ci", "pkg", "ctrl", "client", "vg", "wd", "lib", "context", "vd", "sv"]}}
{"project": "qemu", "commit_id": "0e86c13fe2058adb8c792ebb7c51a6a7ca9d3d55", "target": 1, "func": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 20643, "substitutes": {"dev": ["req", "def", "ev", "w", "Dev", "test", "p", "priv", "db", "info", "app", "md", "prom", "driver", "gd", "device", "gu", "der", "v", "temp", "bug", "pro", "mod", "err", "ver", "serial", "user", "conn", "hw", "ch", "private", "dd", "d", "data", "obj", "sd", "self", "ad", "development", "conf", "grad", "er", "server", "dem", "wd", "cam", "spec", "dom", "comment", "rad", "var"], "vser": ["nvse", "gsl", "lser", "vserv", "gsc", "fster", "evserv", "mster", "nvster", "evster", " vster", "svseller", "gserver", "svster", "wse", "nvserver", "sse", "gser", "Vser", " vsc", "svser", "kser", "mse", "sser", "devster", "wserv", "wster", " vsl", "vse", " vserv", "lserver", "lse", " vsel", "kserver", "Vsl", "lster", "wserver", "devsel", "vserver", "gserv", "Vserv", "vster", "evser", "lserv", "vsel", "sster", "Vsc", "vsc", "nvser", "devser", "evserver", "wseller", "wser", "fserv", " vserver", "sserver", "vsl", "svserver", "fserver", "vseller", "evse", "fse", "fser", "fsel", "mserver", "kseller", "svserv", "gse", "mser", "devserver", "kster"], "vdev": ["Vdef", " vdd", "vdd", "gdiv", "gconn", "lconn", "vserv", "gdev", "verdef", "ldev", " vdef", "svconn", "Vdd", "verdd", "gserv", "lserv", "Vrent", "svdev", "verdev", "vrent", "verrent", " vrent", "svdiv", "Vdev", "vdiv", "vdef", "svserv", "vconn"]}}
{"project": "qemu", "commit_id": "5666ca4ae06d20497f887241151278e266947087", "target": 1, "func": "int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n", "idx": 20644, "substitutes": {"cenv": ["cenvironment", "cenc", "fEnvironment", "qdb", "pcEnvironment", "cdb", " cdata", " cconf", "fdata", "cdev", "catenv", "catenvironment", "rcenv", "rcconf", " center", "rcserver", "rcdata", "fdev", "pcenter", "catdev", "fenvironment", "cserver", "fenter", " cenvironment", " cserver", "center", "qenc", "pcenvironment", "qconf", "rcdb", " cenc", "fserver", "rcenvironment", " cdb", "fenv", "pcenv", "rcenc", " cdev", "cconf", "qenv", "cEnvironment", " cEnvironment", "cdata"], "sregs": ["msregs", " sgrmap", "sreme", "srege", "Sregcs", "sdefps", " sregp", "sregds", "sregistermap", "sgrs", "msrege", "sgrmap", "sgrns", "Sregs", "SREGps", "sregisterns", "sservds", "msreggs", "sREGcs", "sregns", "sdefcs", "sreggs", " sgrns", " sregns", "msservds", "SREGcs", "sREGp", "sregp", "sREGns", "msservgs", "sredcs", "SREGs", "sregmap", "sservgs", "sregps", "sreds", "sservs", "sredps", "sREGps", "Sregps", "msservs", "sremds", "sgrp", "sdefs", "msregds", " sgrp", "sREGs", "sserve", "sREGmap", "sregisterp", " sregmap", "msserve", "sremgs", "srems", "sregcs", "sregisters", " sgrs"]}}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647, "substitutes": {"vq": ["voltQ", "vreq", "evquest", " viq", "avque", "sviq", "vue", "viq", "svqa", "verque", "evque", "verdev", "verqa", "voltreq", "vquery", "Vqq", "evqa", "vque", "svreq", "Viq", "fquest", "fue", "uvqu", "VQ", "evqq", " vque", "viciq", "vciq", "fq", " vqa", "vicque", "avq", "Vqa", "avquery", "lq", "svQ", "svqq", "flque", "evqu", "evQ", "vcself", " vQ", "svue", "flq", "vcq", "flqu", "vcqa", "varquery", "flqa", "svq", "vquest", "Vque", "avck", "lreq", " vquest", "svself", " vquery", "voltque", "vcQ", "fiq", "vQ", "uvqa", " vck", "vqq", "vcque", "varck", "evq", "varque", " vself", "voltq", "eviq", "Vq", "vicqq", "svquest", "vcquest", "vck", "vself", "varq", "uvq", "vicq", "uvque", "svdev", "vqa", "lQ", "lque", " vqq", "evue", "svque", "verq", "vqu"], "vdev": ["vdpriv", "wdevice", "gad", "svdem", "vdd", "wdc", " vdd", "evpriv", "vreq", "gdev", " vdevice", "Vdevice", "Vq", "vpriv", "tvdevice", "vsdev", "vdc", "evdevice", "svdevice", "evdev", "pdevice", "tvdev", "svd", "wdev", "vad", " vdem", "vsdd", "ppu", "svdc", "vpu", "svmod", "vmod", "nvdev", "vdq", " vd", "preq", "wDev", "svdev", "nvmod", "vdem", "vsd", " vDev", "wpu", "wreq", "Vpriv", "vddevice", "nvdevice", "vdevice", "Vdev", "pdev", "svad", "tvreq", "gmod", "vddev", "nvad", "svDev", "vsdem", "svdd", "vd", "gdevice", "evq", "tvpu", " vdc", "vDev"]}}
{"project": "FFmpeg", "commit_id": "8728360b5664ef9db31137d8d3104cac33b9a911", "target": 1, "func": "static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}", "idx": 20659, "substitutes": {"avctx": ["ivctx", "AVcms", "aviactx", " avpkg", "aveobj", "ovcf", "avectx", " avcu", "avcli", "ivcu", "mediacf", "groundpkg", "AVcontext", "verc", "afconfig", "abobj", "avecu", "afcb", "avobj", "avcm", "groundctx", "aviacmp", "ovcontext", " avcp", " avca", "avecmp", "vercu", "AVc", "AVcli", "avcontext", " avcmp", "verconn", "ajscope", "ajconn", "ovcli", "groundcontext", "vercb", "AVtx", "vercontext", "ajcontext", " avc", "avca", "abcontext", "afcontext", "ajcdn", "ajctx", " avcm", "afscope", " avtx", "afobj", "avconfig", "AVcf", "mediacontext", "avcdn", "AVca", "aviacms", "AVcu", "avecontext", "afcdn", "Avca", "avcu", "AVcdn", "aveconfig", "ivcm", "ivcontext", "afconn", "ovctx", "avcmp", "afcf", "vercmp", "ajcli", "afcms", "afcp", "AVcmp", "avcb", "Avtx", " avcdn", "avcp", "mediactx", "afcmp", "avecb", "avecp", "afpkg", "avecf", "avtx", "aviacontext", "verctx", "avpkg", "afcu", "avconn", "groundcdn", "AVctx", "mediacms", "ovscope", "avc", "avecms", "Avctx", "afcm", "AVconn", "abconfig", "abctx", " avcontext", "ajcf", "avcms", "afctx", "avcf", "avscope", "Avcontext"], "mp": ["mc", "cap", "MP", "gg", "omp", "mic", "match", "gp", "cv", "capt", "jp", "p", "gm", "bb", "rup", "tm", "lim", "mo", "par", "msg", "pg", "pm", "md", "app", "ep", "mt", "mm", "media", "mac", "pp", "amp", "ps", "mod", "lp", "me", "mb", "tmp", "fp", "ph", "av", "Mp", "pb", "manager", "agg", "cm", "pl", "bc", "cp", "craft", "peer", "mpeg", "ctx", "ppa", "cop", "lv", "sp", "pkg", "cmp", "mom", "ap", "cam", "context", "ms", "wp", "op", "comp", "fm", "ip"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n", "idx": 20662, "substitutes": {"s": ["support", "settings", "sq", "S", "lines", "rs", "setup", "p", "aws", "sa", "ses", "ds", "f", "fs", "si", "sc", "b", "v", "ss", "c", "utils", "spec", "ps", "sb", "storage", "e", "cs", "l", "service", "services", "qs", "sup", "ops", "ssl", "gs", "su", "m", "os", "t", "sf", "bs", "sl", "ls", "sg", "ns", "sv", "g", "sam", "js"], "stream": ["channel", "loop", "iv", "image", "stage", "event", "src", "row", "forward", "draft", "frame", "valid", "object", "coll", "document", "ream", "feed", "content", "gram", "audio", "view", "transform", "sw", "thread", "path", "message", "sel", "source", "post", "upload", "read", "model", "ssl", "video", "data", "input", "progress", "child", "reader", "Stream", "form", "client", "slice", "context", "sl", "pool"], "presentation_time": ["presenting_cost", "presentationpttimes", "presenting_times", "presentationpturl", "presentation64cost", "presentation64Time", "presentation36times", "presentation36cost", "presenting_time", "presentation64time", "presenting_Time", "presentation36time", "presentation64times", "presentation_speed", "presentationptspeed", "presenting_url", "presentation_times", "presentation_cost", "presentation_Time", "presentation36Time", "presenting_speed", "presentationpttime", "presentation_url"], "m_obj_size": ["m_object_size", "m_obj\u00b7member", "m_obj\u00b7offset", "m_obj__size", "m_obj_address", "m_obj_time", "m_obj0size", "m_obj_len", "m_obj\u00b7address", "m_obj__num", "m_block_member", "m_block_size", "m_object_len", "m_obj0time", "m_obj_num", "m_block_offset", "m_object_time", "m_obj_member", "m_obj0num", "m_obj2address", "m_obj__time", "m_obj0len", "m_obj__len", "m_obj2size", "m_object_num", "m_obj2offset", "m_block_address", "m_obj\u00b7size", "m_obj2member"], "m_obj_offset": ["m_object_size", "m_object_header", "m_obj_seq", "m_object_off", "m_object_pos", "m_object_seq", "m_obj_off", "m_object_offset", "m_obj_header", "m_obj_pos"], "payload_len": ["payload2len", "payflow_val", "payload64number", "payflow2len", "payload64length", "payflow_len", "payload33len", "payload2size", "payload_size", "payload_length", "payload2Len", "payload_Len", "payflow_length", "payflow_number", "payload33val", "payload2length", "payflow2length", "payload64val", "payload33number", "payflow_size", "payflow2Len", "payflow2size", "payload_number", "payload64len", "payflow_Len", "payload33length", "payload_val"], "asf": ["rasfs", "ASfc", "ASf", " asfs", "lasf", "lasfs", "csf", "Asdf", "rasdf", "asF", "csF", "assfs", "lasfc", "AsF", "csfo", " asfo", "rasf", "masF", "asfc", "assF", "csfs", "masdf", "AScf", "Asfs", " ascf", " asfc", "rasF", "asdf", "asfs", "ascf", "Asf", "ASfs", "masf", "asfo", "masfs", "assfo", " asF", "assf", "lascf"], "pb": ["typ", "lb", "bm", "gp", "pd", "pa", "wb", "jp", "p", "cv", "lc", "prop", "platform", "ib", "db", "xb", "proc", "pg", "pm", "dl", "pc", "nb", "bf", "b", "alist", "mp", "bh", "fc", "lab", "ub", "bj", "lp", "sb", "bp", "cb", "bps", "mb", "ab", "bos", "kb", "prot", "fp", "hub", "obb", "vp", "plugin", "bsp", "summary", "ob", "bc", "login", "PB", "cp", "emb", "rob", "kk", "ctx", "ppa", "gb", "cpp", "abc", "pkg", "fb", "bs", "dp", "eb", "wp", "rb"], "val": ["part", "il", "VAL", "x", "eval", "al", "prop", "lit", "enc", "pid", "num", "el", "loc", "offset", "bit", "length", "year", "valid", "aval", "win", "v", "fee", "len", "xx", "seq", "index", "vol", "base", "slot", "fl", "ind", "pt", "tx", "col", "byte", "key", "py", "ref", "sel", "ee", "vals", "value", "cond", "bc", "split", "pos", "count", "lv", "ctx", "unit", "vc", "Val", "slice", "sl", "sec", "ival", "ol"]}}
{"project": "FFmpeg", "commit_id": "0eaec10550bd9a0682db9f7920ed0d86f1450f4b", "target": 1, "func": "static int pcm_encode_frame(AVCodecContext *avctx,\n\n\t\t\t    unsigned char *frame, int buf_size, void *data)\n\n{\n\n    int n, sample_size, v;\n\n    short *samples;\n\n    unsigned char *dst;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n    case CODEC_ID_PCM_S16BE:\n\n    case CODEC_ID_PCM_U16LE:\n\n    case CODEC_ID_PCM_U16BE:\n\n        sample_size = 2;\n\n        break;\n\n    default:\n\n        sample_size = 1;\n\n        break;\n\n    }\n\n    n = buf_size / sample_size;\n\n    samples = data;\n\n    dst = frame;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = (v + 128) >> 8;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = ((v + 128) >> 8) + 128;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_alaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_ulaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    avctx->key_frame = 1;\n\n    //avctx->frame_size = (dst - frame) / (sample_size * avctx->channels);\n\n\n\n    return dst - frame;\n\n}\n", "idx": 20697, "substitutes": {"avctx": ["abcf", "evcf", "apctx", "avconfig", "evcca", "airctrl", "avctrl", "AVcf", "capcontext", "AVconfig", "airctx", "abcca", "avcontext", " avconfig", "avconn", "apconfig", "apconn", "AVctx", "apcontext", "afconn", "evctx", "AVcontext", "AVctrl", "capctrl", "afconfig", "abctx", "AVcca", " avcontext", "capctx", "aircontext", "airconfig", " avconn", "afctx", "avcf", "evcontext", "avcca", "capconfig", "abcontext", "afcontext"], "frame": ["channel", "first", "element", "cf", "image", "line", "iframe", "series", "code", "buffer", "buff", "val", "f", "sample", "document", "body", "state", "next", "header", "buf", "board", "base", "sequence", "Frame", "message", "window", "filename", "format", "source", "value", "fi", "video", "input", "frames", "fake", "file", "fram"], "buf_size": ["queue_size", "queue_start", " buf_strength", "buf64size", "buf_len", "buf2start", "buf2sized", "buf_ize", "buf_start", "buf2size", "queue_len", "buf_sized", " buf_ize", "buf2len", "buf_strength", "buf64strength", "buf___ize", "buf___strength", "buf___size", "buf64ize", "queue_sized"], "data": ["first", "image", "empty", "zero", "DATA", "block", "buffer", "results", "f", "config", "sample", "start", "body", "media", "len", "a", "next", "raw", "buf", "scale", "database", "base", "dat", "draw", "message", "window", "format", "size", "d", "memory", "input", "one", "shift", "pad", "multi", "Data", "array", "record", "new", "bytes"], "n": ["z", "nor", "x", "p", "en", "nan", "num", "nn", "ln", "j", "an", "f", "s", "net", "na", "no", "nb", "none", "mn", "not", "b", "init", "len", " N", "c", "o", "nl", "y", "l", "conn", "min", "ng", "nt", "nin", "N", "nw", "u", "span", "pn", "size", "rn", "d", "ne", "in", "gn", "syn", "inn", "np", "after", "k", "i", "m", "t", "fn", "dn", "un", "yn", "nc", "network", "ns", "g", "nu", "cn", "all", "sn", "non"], "sample_size": ["sample\u00b7size", "sample\u00b7set", "ample_range", "ample\u00b7slice", "ample\u00b7range", "sample_set", "sample_scale", "sampleacslice", "sampleacrange", "ample_slice", "ample_size", "sample_sec", "scale_size", "sample_number", "sample_slice", "scale_sized", " sample_shape", "sample_range", "sample\u00b7shape", "ample\u00b7size", "sampleacsize", "sample_shape", "sample_sized", "scale_scale", "sample\u00b7range", " sample_sec", "scale_number", "sample\u00b7slice", " sample_set"], "v": ["iv", "ul", "x", "w", "ve", "ev", "version", "cv", "p", "nv", "en", "h", "tv", "vert", "qv", "val", "rev", "j", "f", "uv", "s", "q", "vv", "virtual", "ov", "b", "view", "vol", "c", "volt", "dev", "o", "e", "ver", "y", "l", "vt", "vi", "va", "ch", "av", "u", "vp", "value", "V", "conv", "d", "api", "video", "lv", "k", "i", "vo", "m", "t", "vs", "vg", "g", "z", "sv", "var"], "samples": ["samps", "smodels", "specamples", "testspackages", "ssamps", "statesocks", "Samples", "testsplays", "Samps", "inscriptions", "instones", "specocks", "dourses", "statesacters", "specamps", "insamples", " sacters", "sources", "dacters", "statescriptions", "unsessions", " splays", "gallpackages", "testsamples", "splays", "sacters", " sessions", " sumps", "servicesamps", "dsteps", "sample", "insimens", "gallplays", "scriptions", " sources", "stones", "statestones", "sumps", "Sumps", "sessions", "ssources", "socks", "Socks", "dimens", "damples", "ssamples", "servicesourses", "ssteps", "sourses", "unsources", "unsamples", "statesimens", " spackages", "statesamples", "statesamps", "unsamps", "insources", "testsages", "specample", "servicesamples", "damps", "servicesmodels", "ssessions", "Sample", " ssteps", "spackages", "simens", "statesample", "statesources", "dmodels", " sourses", "insamps", "statessteps", "gallamples", "dources", " smodels", "Smodels", "sages", " sages", "gallages", " samps"], "dst": ["Dst", "duost", " dstack", " drest", "dsn", "ldsn", "fdstore", "bdST", "madstore", "fdsts", "dsstr", "dsst", "didst", "sdsts", "Dstore", "datost", "dasts", "wdste", "madsp", "rdst", " dsn", "dost", "wdsn", "isdst", "wdsts", "dput", "dsbl", "isdstop", "dsstack", "sdste", " dset", "ldsc", " dput", "didstore", "DST", "drest", " dste", "djst", "vdstage", "dsp", " dbl", "dstep", "dstore", "fost", "sdrest", "didost", "datdest", "dust", "fst", "madsts", "daste", "dST", "idrest", "fste", "idste", "datstage", "bdstd", "datst", " dstr", "Dstep", "idsts", " dsts", "ldstr", "vdost", "dsost", "dustage", "bdsc", "dstack", "sdput", "idsc", "ddest", "rdset", "dstop", "sdstop", "sdost", " dost", "dstr", "dbl", " dstore", "djste", " dsc", "Drest", "djsts", " dstop", "ldsts", "dsc", "bdsts", "sdstore", "dsts", " dstage", "ldste", " ddest", "fdste", "bdst", "rdsc", "vdste", "fsts", "dsST", "dastore", "dset", "sdst", "isdost", "dast", " dsp", "idst", "dste", " dstep", "bdset", "sdST", " dstd", "Dstage", "Dste", "madst", "dstage", "rdsts", "Dsts", "dstd", "ldbl", "sdsp", "ldrest", "ldst", "vdst", "dsstore", " dST", "wdst", "isdput", "didstack", "djstep", "sdstd", "dudest", "fdst", "Dost", "dssts"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {\n\n  register int i;\n\n  int __attribute__ ((aligned (16))) tempo[4];\n\n\n\n  if (filterSize % 4) {\n\n    for(i=0; i<dstW; i++) {\n\n      register int j;\n\n      register int srcPos = filterPos[i];\n\n      register int val = 0;\n\n      for(j=0; j<filterSize; j++) {\n\n\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n      }\n\n      dst[i] = av_clip(val>>7, 0, (1<<15)-1);\n\n    }\n\n  }\n\n  else\n\n  switch (filterSize) {\n\n  case 4:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_vEven, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 12) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\t// now put our elements in the even slots\n\n\tsrc_v = vec_mergeh(src_v, (vector signed short)vzero);\n\n\n\n\tfilter_v = vec_ld(i << 3, filter);\n\n        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)\n\n\n\n        // the neat trick : we only care for half the elements,\n\n        // high or low depending on (i<<3)%16 (it's 0 or 8 here),\n\n        // and we're going to use vec_mule, so we chose\n\n        // carefully how to \"unpack\" the elements into the even slots\n\n\tif ((i << 3) % 16)\n\n\t  filter_v = vec_mergel(filter_v,(vector signed short)vzero);\n\n\telse\n\n\t  filter_v = vec_mergeh(filter_v,(vector signed short)vzero);\n\n\n\n\tval_vEven = vec_mule(src_v, filter_v);\n\n\tval_s = vec_sums(val_vEven, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 8:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_v, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 8) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tfilter_v = vec_ld(i << 4, filter);\n\n        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)\n\n\n\n\tval_v = vec_msums(src_v, filter_v, (vector signed int)vzero);\n\n\tval_s = vec_sums(val_v, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 16:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1 = vec_ld(srcPos + 16, src);\n\n\tvector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tvector signed short src_vA = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tvector signed short src_vB = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n\tvector signed short filter_v0 = vec_ld(i << 5, filter);\n\n       \tvector signed short filter_v1 = vec_ld((i << 5) + 16, filter);\n\n        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)\n\n\n\n\tvector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);\n\n\tvector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n\tvector signed int val_s = vec_sums(val_v, vzero);\n\n\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  default:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int j;\n\n\tregister int srcPos = filterPos[i];\n\n\n\n        vector signed int val_s, val_v = (vector signed int)vzero;\n\n\tvector signed short filter_v0R = vec_ld(i * 2 * filterSize, filter);\n\n        vector unsigned char permF = vec_lvsl((i * 2 * filterSize), filter);\n\n\n\n        vector unsigned char src_v0 = vec_ld(srcPos, src);\n\n        vector unsigned char permS = vec_lvsl(srcPos, src);\n\n\n\n        for (j = 0 ; j < filterSize - 15; j += 16) {\n\n          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);\n\n          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          vector signed short src_vA = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          vector signed short src_vB = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n          vector signed short filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          vector signed short filter_v2R = vec_ld((i * 2 * filterSize) + (j * 2) + 32, filter);\n\n          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);\n\n          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);\n\n\n\n          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);\n\n          val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n          filter_v0R = filter_v2R;\n\n          src_v0 = src_v1;\n\n        }\n\n\n\n        if (j < (filterSize-7)) {\n\n          // loading src_v0 is useless, it's already done above\n\n          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);\n\n          vector unsigned char src_v1, src_vF;\n\n          vector signed short src_v, filter_v1R, filter_v;\n\n          if ((((int)src + srcPos)% 16) > 8) {\n\n            src_v1 = vec_ld(srcPos + j + 16, src);\n\n          }\n\n          src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          src_v = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          // loading filter_v0R is useless, it's already done above\n\n          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);\n\n          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          filter_v = vec_perm(filter_v0R, filter_v1R, permF);\n\n\n\n          val_v = vec_msums(src_v, filter_v, val_v);\n\n        }\n\n\n\n        val_s = vec_sums(val_v, vzero);\n\n\n\n        vec_st(val_s, 0, tempo);\n\n        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n\n\n    }\n\n  }\n\n}\n", "idx": 20698, "substitutes": {"dst": ["Dst", "sst", "DST", " dsrc", "Dsc", "dsrc", "Dsts", " drc", " dsc", "cdsrc", "cdST", "cdsts", "dsc", " dST", "dST", "dsts", "cdst", "ssc", "Drc", "drc", " dsts", "ssts", "Dsrc"], "dstW": ["drcWidth", "dsrcH", " drcWidth", "dstP", "dstsW", " drcC", "dstsw", "dscWidth", " drcH", "dstsC", "dSTH", "dstWidth", "DscP", "dstw", "Dstw", "dstsH", "DscW", "dsrcw", " dstH", "dstC", "dsrcWidth", "drcw", " drcW", "Dscw", "dscH", "drcW", " dstC", " dstWidth", "drcC", "DstP", "drcP", "DscH", "dscW", "dstH", "dscw", "dSTW", " drcw", "drcH", "dSTP", "DstW", " dstw", "DstH", "dscC", "dscP", "dsrcW", "dSTw"], "src": ["RC", "support", "inst", "iv", "req", "sq", "image", "secure", "rin", "reflect", "sync", "lower", "core", "img", "rss", "nil", "loc", "low", "go", "config", "sci", "cur", "uc", "sr", "sc", "scl", "uri", "surface", "transform", "control", "sub", "stream", "gl", "sb", "cb", "spec", "reverse", "feat", "acc", "tmp", "rib", "filename", "crop", "dest", "sel", "dist", "source", "ctr", "sup", "sur", "connect", "conv", "target", "ssl", "rc", "rob", "url", "input", "seed", "gz", "cmp", "slice", "include", "front", "sec", "asc", "resource", "rb", "sn"], "srcW": [" srcWidth", "rcW", "distWidth", "rcWidth", "srcWidth", "rcU", " srcU", "srcU", "srcw", "distW", "distw", " srcw", "rcw", "distU"], "xInc": ["xEnc", "xArg", "exinc", "uxEnc", "exEnc", "uxSec", "xSec", "wxSec", "wxinc", "uxinc", "exSec", "wxEnc", "uxArg", "wxArg", "exArg", "xinc"], "filter": ["channel", "support", "condition", "cover", "match", "version", "test", "block", "ac", "offset", "force", "buffer", "f", "wave", "config", "Filter", "mask", "v", "header", "transform", "control", "sub", "c", "flat", "search", "alpha", "fl", "fil", "patch", "ind", "batch", "limit", "format", "source", "end", "rule", "conv", "layer", "target", "flag", "id", "fn", "sort", "protect", "feature", "map", "frequency", "spec"], "filterPos": [" filterPtr", "controlSize", "controlRes", "filterLen", "maskPos", "filterPtr", "controlPtr", "sortPtr", "sortPosition", "filterRes", " filterStart", "maskStart", "sortPos", "maskSize", "maskPtr", "filLen", "filStart", "sortSize", "filterPosition", "controlStart", "filterStart", "filPos", "controlPos", "filRes", "controlLen", " filterRes", "controlPosition", " filterLen", " filterPosition"], "filterSize": ["flatLen", "flatPos", "filterLen", "maskPos", "FilterCount", "filterMode", "filterSection", "filterExp", "masksize", "formatLen", "filterCount", "configsize", "formatSection", "featureSize", "configSize", "filsize", "FilterCode", "maskSize", "featureExp", "configLen", "flatSize", "filtersize", "filterCode", "filMode", "FilterMode", "filSize", "filLen", "maskExp", "configSection", "FilterSize", "sortSize", "flatsize", "filPos", "featuresize", " filtersize", "sortCode", " filterMode", " filterCount", "formatSize", " filterExp", "filCount", "featureLen", "maskLen", " filterSection", " filterLen", "maskCode", "FilterLen", "formatsize", "sortLen"], "i": ["ji", "ii", "ui", "ti", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "info", "f", "ai", "cli", "ini", "ie", "ni", "start", "is", "si", "b", "io", "v", "init", "a", "pi", "n", "index", "uri", "c", "ei", "o", "e", "wei", "y", "l", "xi", "u", "yi", "chi", "inner", "sup", "fi", "li", "d", "iu", "mini", "k", "id", "zi", "ci", "mi", "t", "m", "multi", "anti", "gi", "ori", "g", "z", "mu", "bi", "it", "ip"], "tempo": ["dimbo", "dimpr", "tybo", "empo", "temporal", "emporal", "tempr", "tembo", "empr", "dimporal", "dimpo", "typoral", "typo", "typr", "embo"], "j": ["ji", "ui", "ii", "br", "jit", "dj", "x", "ix", "jp", "p", "pr", "jo", "all", "el", "jet", "f", "ja", "ie", "q", "ni", "fr", "jc", "b", "v", "uj", "n", "index", "adj", "bj", "o", "jj", "e", "pt", "y", "l", "r", "ij", "ch", "u", "key", "pre", "out", "oj", "li", "obj", "J", "ik", "k", "m", "t", "aj", "g", "z", "jl", "bi", "js"], "src_v1": ["src_sv2", "src_V6", "src_h1", "src_sv0", "src_h2", "src_sv1", "src_fF", "src_hF", "src_f1", "src_V0", "src_f6", "src_v0", "src_hN", "src_V1", "src_vN", "src_f0", "src_VN", "src_VF", "src_sv6", "src_v6", "src_V2", "src_h0", "src_v2", "src_fN", "src_f2"], "src_vF": ["src_VD", "src_mF", "src_fP", "src_vgf", "src_hf", "src_m1", "src_vgF", "src_vD", "src_VFi", "src_fF", "src_hF", "src_m0", "src_hD", "src_f1", "src_V0", "src_svE", "src_vgFi", "src_v0", "src_vP", "src_svf", "src_vf", "src_svF", "src_V1", "src_Vf", "src_vFi", "src_vgD", "src_f0", "src_hE", "src_VF", "src_vE", "src_mP", "src_ff", "src_fD", "src_VP", "src_svD", "src_VE", "src_fFi"], "src_v": ["rc_t", " src_f", "src_l", "src_ver", "src_c", " src_V", "src_h", " src_vp", "srcJver", "rc_f", "rc_ver", "src_s", "srcJs", " src_h", "src_f", "srcJv", "src_V", "rc_l", "src_vp", " src_s", "rc_h", "srcJh", "rc_c", "rc_s", "src_t", "rc_v"], "filter_v": [" filter_V", "filter_s", "fil__h", "filter_conv", "var_rev", "url_conv", "filterures", "filter__V", "filterurerev", "fil__v", "filteriansv", "var_s", "fil_h", " filter_f", "filter__c", " filter_s", " filter_p", "url_h", "filter__h", "fil_vs", "filterurev", "filter_m", "filter__v", "filteriandev", "fil_v", "url_c", "fil__vs", "filter_h", "url_v", "filter_l", "filter_vs", "reflect_dev", "filter_nv", "var_v", "filter_dev", "filter__m", "reflect_v", " filter_h", " filter_c", "filteriannv", " filter_l", "filter_f", " filter_m", "reflect_nv", "filter_rev", "var_dev", "filter_p", "filter_c", "filter_V", "filterianv", "reflect_sv", "filter_sv", "filter__vs", "fil__c", "filteruredev", "fil_c", "filter__f"], "val_vEven": ["val_uEven", "val_sveven", "val_VLong", "val_vEx", "val_svLong", "val_ueven", "val_svA", "val_ivEx", "val_feven", "val_fA", "val_lLong", "val_iv0", "val_vA", "val_vLong", "val_\n", "filter_0", "val_lEven", "val_fEven", "val_veven", "val_VEx", "val_svEven", "val_uLong", "val_fLong", "val_ivLong", "val_0", "val_v0", "val_lEx", "filter_\n", "val_l0", "val_VEven", "val_V0", "val_ivEven", "val_uA"], "val_s": ["val2d", "val2s", " val2d", "val2v", "val_r", "eval_s", " val_r", "val_h", "val2r", " val2v", "val_d", " val_d", "eval_h", " val2s", "eval_b", "eval_v", "val_b", " val2r"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n", "idx": 20716, "substitutes": {"env": ["settings", "iv", "console", "ev", "en", "enc", "code", "buffer", "status", "proc", "config", "dict", "init", "device", "buf", "err", "dev", "result", "cal", "fi", "np", "obj", "data", "environment", "txt", "addr", "set", "ec"], "value": ["element", "values", "create", "image", "beta", "property", "version", "attribute", "current", "block", "code", "use", "buffer", "name", "val", "reference", "Value", "status", "complete", "VALUE", "response", "type", "object", "address", "description", "document", "definition", "device", "fee", "scale", "parent", "variable", "reg", "entry", "range", "error", "begin", "the", "message", "hello", "result", "token", "format", "key", "function", "end", "size", "source", "command", "member", "data", "child", "expression", "one", "id", "vector", "lua", "number", "server", "total", "program", "feature", "package", "resource", "set", "comment", "get", "non"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n", "idx": 20722, "substitutes": {"obj": ["po", "inst", "iv", "x", "orb", "src", "p", "bo", "val", "rev", "j", "f", "object", "xxx", "func", "b", "Obj", "buf", "parent", "o", "env", "tmp", "ref", "opt", "op", "ob", "api", "emb", "ctx", "self", "m", "os", "objects", "t", "rb", "Object"], "v": ["iv", "ev", "w", "p", "tv", "val", "j", "f", "uv", "object", "inv", "s", "vv", "b", "vm", "c", "o", "e", "env", "l", "vt", "u", "vp", "vu", "V", "ob", "d", "api", "lv", "m", "t", "vs", "z", "sv", "op"], "opaque": ["paque", "ipec", "opec", "ipaque", "paco", "Opaco", "opacity", " opace", "ipace", "ipacity", "opaco", "Opace", "Opec", " opacity", "coaque", "opace", "Opacity", "coaques", "coaco", "Opaque", "Opaques", "paques", " opec", "pacity", "coacity", "opaques"], "name": ["comment", "desc", "part", "cap", "time", "property", "label", "code", "NAME", "word", "type", "names", "none", "n", "parent", "base", "path", "error", "alias", "style", "clean", "key", "size", "str", "member", "data", "missing", "null", "nice", "no", "ns", "named", "prefix", "new", "Name"], "errp": ["rrpc", " errlp", "grpc", "rrpre", "grp", " errcp", " errpp", " errps", "errpre", "errlp", "irp", "rrp", "resultP", "errpi", "errP", "refp", "errcp", " errpi", " errP", " errpre", "refpi", "errpc", "rrcp", "resultpp", "ircp", "irpc", "ierpp", "ierp", "errps", "resultps", "errpp", "reflp", "ierP", "refpc", "grpi", " errpc", "grlp", "ierps", "irpre", "resultp"], "prop": ["po", "typ", "part", "property", "jp", "lc", "lit", "p", "priv", "pointer", "val", "type", "proc", "info", "option", "properties", "nb", "pred", "mp", "buf", "pro", "feat", "cb", "prot", "tmp", "key", "Prop", "pb", "ref", "opt", "fi", "np", "api", "cp", "attr", "data", "pos", "fb", "cmp", "term", "rb", "op", "owner"], "value": ["element", "values", "create", "image", "property", "current", "reference", "Value", "val", "type", "option", "length", "VALUE", "object", "valid", "native", "index", "parent", "message", "result", "format", "key", "ref", "function", "size", "model", "member", "data", "id", "null", "field", "number", "array", "total", "comment"]}}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n", "idx": 20728, "substitutes": {"path": ["full", "part", "image", "match", "text", "PATH", "p", "test", "cross", "enc", "host", "code", "core", "pointer", "name", "loc", "word", "config", "object", "pattern", "request", "anc", "pass", "then", "dir", "ath", "temp", "next", "index", "c", "transform", "parent", "entry", "root", "col", "or", "key", "end", "value", "port", "url", "broken", "Path", "data", "child", "sign", "self", "open", "file", "method", "node", "prefix", "ith"]}}
{"project": "qemu", "commit_id": "1466cef32dd5e7ef3c6477e96d85d92302ad02e3", "target": 0, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 20738, "substitutes": {"d": ["dm", "dc", "du", "dj", "p", "cd", "dt", "bd", "db", "ds", "dose", "f", "dim", "dl", "did", "D", "b", "dh", "c", "da", "ind", "dat", "e", "dx", "l", "fd", "connection", "dd", "dad", "dr", "m", "ad", "sd", "t", "ded", "dy", "dos", "ld"], "i": ["ti", "ui", "ii", "abi", "ji", "qi", "x", "I", "ix", "p", "phi", "j", "cli", "f", "ni", "si", "io", "b", "v", "a", "pi", "n", "index", "c", "o", "e", "l", "r", "xi", "bi", "u", "span", "mini", "iu", "li", "child", "count", "hi", "k", "id", "zi", "multi", "t", "slice", "gi", "z", "inner", "ip"], "mch": ["pcha", "pich", "fmchan", "mtch", "pcher", "mzh", "mich", "ymch", "mancher", "gmtch", "omach", "mcach", "omcha", "umach", " mth", "mccht", "pch", "cmcht", "hich", " mcht", "bmcher", " muth", "cmzh", "manich", "dmche", "mrcher", "rmch", "manch", "gmcht", "nmch", "imich", "Mach", "Mich", " mce", "manach", "gmcha", " mzh", "imach", "fmach", "pmche", "Mcha", "nmach", "cmcha", "mmch", "mmche", "mmcha", "moch", "pach", "Mcher", "imch", "smtch", "pchid", "pmcht", "wmcha", "hche", " mchid", "umich", "omuth", "mcha", "Mce", " mche", "cmoch", "hch", "ymich", "mcher", "mrcha", "muth", "mche", "smcht", "wmich", "amche", "Mgh", "Mchan", "mth", "omcher", "imcht", "smch", "bmch", "amcht", "amich", "omich", "mmich", "wmch", "mce", "dmich", "pche", "umcha", "March", "cmth", "pchan", " march", "mancha", "mrch", "mrich", "dmcha", "ymche", "Mche", "cmcher", "bmarch", "gmich", " mich", "fmich", "dmch", "cmche", " mtch", "wmche", "imcha", "rmcher", "manche", "omoch", "cmgh", "gmcher", "umcher", "pmach", "rmche", "pmcha", " mcha", "mchid", "smach", "parch", "gmach", "pmich", "umche", "imche", "Mch", "fmchid", "amch", "cmich", "Mzh", "Mchid", "gmch", "mcht", "march", "gmche", " mach", "mgh", "cmach", "pzh", "mchan", "dmcher", " mcher", "omche", "bmich", "rmcha", "Mcht", "Moch", "cmch", "Mth", "Muth", "rmich", "cmce", "gmzh", "mcch", "mccha", "umch", "rmcht", "fmch", "pmch", "amcha", "ymth", "omch", "nmche", "nmich", " mgh", "hcha", "dmcht", "mach"]}}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static int h261_find_frame_end(ParseContext *pc, AVCodecContext* avctx, const uint8_t *buf, int buf_size){\n\n    int vop_found, i, j, bits_left, last_bits;\n\n    uint32_t state;\n\n\n\n    H261Context *h = avctx->priv_data;\n\n\n\n    if(h){\n\n        bits_left = h->bits_left;\n\n        last_bits = h->last_bits;\n\n    }\n\n    else{\n\n        bits_left = 0;\n\n        last_bits = 0;\n\n    }\n\n\n\n    vop_found= pc->frame_start_found;\n\n    state= pc->state;\n\n    if(bits_left!=0 && !vop_found)\n\n        state = state << (8-bits_left) | last_bits;\n\n    i=0;\n\n    if(!vop_found){\n\n        for(i=0; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    i++;\n\n                    vop_found=1;\n\n                    break;\n\n                }\n\n            }\n\n            if(vop_found)\n\n                    break;    \n\n        }\n\n    }\n\n    if(vop_found){\n\n        for(; i<buf_size; i++){\n\n            if(avctx->flags & CODEC_FLAG_TRUNCATED)//XXX ffplay workaround, someone a better solution?\n\n                state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pc->frame_start_found= vop_found;\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 20741, "substitutes": {"pc": ["cz", "po", "mc", "cms", "pac", "pd", "pa", "cv", "xc", "p", "pr", "lc", "enc", "gc", "cc", "co", "ac", "proc", "pg", "pm", "cus", "uc", "anc", "jc", "oc", "sc", "fc", "mac", "ct", "con", "amp", "c", "ck", "ca", "cb", "PC", "bp", "pt", "conn", "pre", "pb", "py", "BC", "can", "wp", "post", "arc", "pl", "bc", "cp", "api", "tc", "rc", "cca", "ctx", "vc", "cpp", "gb", "ci", "sys", "client", "nc", "px", "exec", "inc"], "avctx": ["auctx", "ajpkg", "ajctx", "avloc", "afpkg", "AVpkg", "afxc", "aucontext", "avconnection", "Avloc", " avloc", "avcontext", "avpkg", "avconn", "Avconnection", "ajconn", "AVctx", "aucas", " avconnection", " avxc", "afconn", "AVcontext", "afloc", "Avctx", "avxc", "afconnection", " avcas", "AVconn", " avcontext", "ajcontext", "avcas", "afcas", "afctx", "Avcontext", "auxc", "afcontext"], "buf": ["home", "cf", "br", "box", "wb", "cv", "cache", "uf", "alloc", "src", "queue", "bo", "block", "que", "img", "buff", "buffer", "Buff", "db", "loc", "proc", "config", "uc", "grab", "cmd", "b", "border", "seq", "bin", "cb", "cas", "vec", "bus", "ab", "batch", "auc", "bu", "pb", "fam", "bag", "raf", "bc", "port", "ob", "rc", "comb", "ctx", "gb", "fb", "array", "map", "pub", "context", "rb", "ba", "pool"], "buf_size": ["queue_size", "buf_Size", "buf_SIZE", "bufMsource", "buf_ize", "queue_scale", "buf_scale", "queue_source", "bufMsize", "buf_sized", "buf_loc", "bufMscale", "queue_ize", "bufMloc", "queue_Size", "queue_loc", "queue_SIZE", "queue_sized", "buf_source"], "vop_found": ["vop_err", "vapper_finished", "vopallfind", "vop_left", "vot_error", "vopkfound", "vop0find", "voup_given", "vop_error", "vopalreceived", "vot__bound", "vopallfound", "vant_find", "vop__bound", "vapperayfinished", "vapperaymatched", "vop_tested", "vopkfind", "vop_finding", "vop__finished", "voup_full", "vompallfind", "vop__found", "vopkfinding", "vop_find", "vop6matched", "vop_valid", "vap_changed", "vant_received", "vhop_found", "vomp_found", "vop0tested", "vopffound", "vapper_found", "vap_Found", "vopaymatched", "vop64found", "vop_matched", "vomp_find", "vapper_matched", "vapperayfound", "vopalfound", "vompallleft", "vantkfinding", "vop64find", "vopalfull", "vopalgiven", "vop6given", "vot__error", "vopalfind", "vop_added", "vopenerror", "vop_given", "vop0found", "vant_found", "vopalerr", "vopkreceived", "vop6found", "vopffind", "vopAfound", "voup_err", "vompallfound", "vop__given", "vopayfinished", "vop64changed", "vop__error", "vantkreceived", "vot_bound", "vopaygiven", "vopAbound", "vapper_given", "vopt_find", "vopenfound", "vopt_valid", "vantkfind", "vap_found", "vop_Found", "vop_bound", "vot__found", "vopfadded", "vopallleft", "voup_found", "vomp_left", "vop_changed", "vop_finished", "vopt_tested", "vap_find", "vop_received", "vant_finding", "vopt_found", "vopayfound", "vopAerror", "vapperaygiven", "vop__matched", "vopferr", "vop6finished", "vop64Found", "vopalfinding", "vhop_find", "vantkfound", "vop0valid", "vhop_err", "vot_found", "vopenbound", "vop_full", "vhop_added"], "i": ["ii", "my", "qi", "ix", "p", "phi", "info", "f", "im", "si", "io", "a", "pi", "u", "count", "ik", "mi", "ori", "ti", "ji", "iv", "I", "isi", "ri", "cli", "ni", "is", "ski", "b", "ki", "n", "uri", "index", "e", "ind", "y", "xi", "api", "id", "slice", "gi", "ip", "ui", "ie", "oi", "init", "v", "c", "l", "yi", "value", "fi", "li", "hi", "zi", "ci", "g", "z", "bi", "it", "x", "eni", "di", "ai", "ini", "start", "ei", "o", "d", "in", "iu"], "j": ["ii", "br", "qi", "p", "f", "ja", "q", "im", "u", "key", "pos", "k", "em", "note", "all", "ji", "jp", "jet", "fr", "b", "jc", "n", "e", "jj", "ind", "y", "ij", "dy", "ip", "ui", "jen", "w", "pr", "jo", "jay", "el", "ie", "v", "uj", "pt", "l", "ch", "oj", "li", "ne", "J", "m", "g", "z", "jl", "it", "jit", "dj", "x", "di", "je", "adj", "o", "off", "d", "obj", "job", "er", "aj", "js"], "bits_left": ["its_right", "bits_size", "stringsSflo", "bits_found", "bits_lost", "bits_pl", "strings_joined", "bits64found", "its_pl", "blocks_diff", "bits48right", "bitsESSleft", "bits0needed", "bitsESSfound", "bits_Left", " bits_Left", "bits0size", "bitsSjoined", "strings_left", "bitsSflo", "bits64left", "bitsESSflo", "blocks_wrong", "bitsSfound", "bits64flo", "blocks_left", "bits_wrong", "stringsSleft", " bits_last", "bits_low", "blocks_low", " bits_found", "bits_last", "bitsSleft", "stringsSfound", "bits_flo", "bits_diff", "strings_flo", "stringsSjoined", "bits48lic", "its_needed", "its_size", "bits_needed", "bits_joined", "bits0left", "bits48pl", "bits_lic", "bitsESSjoined", "bits48left", "its_left", "bits_right", " bits_lost", "bits64joined", "bits0right", "strings_found", "its_lic", " bits_right"], "last_bits": ["last__planes", "worst_pieces", "last__bytes", "last__bits", " last__planes", "lastaybytes", "first64bit", " last_bytes", " last_pieces", "last_bytes", "last_ints", "last__locks", "last__ints", "last_locks", "first_bit", "first_bits", "lastaybits", " last_ints", "first64bits", "lastaypieces", "first_locks", " last_planes", "last36ints", "lastaypoints", "last64bit", "lastemfps", "last36bits", "last_planes", "worst_bits", "lastembits", "last_nets", "last36bit", "last__bit", "last64locks", "first64locks", "first_bytes", " last_points", "worst_nets", "last_points", "last_bit", " last__bit", "last64bytes", "last_fps", "first64bytes", "lastembit", " last__ints", "last67ints", "last67planes", "lastembytes", "last64bits", " last_fps", " last__bits", "last67bits", "last_pieces", "worst_bytes", "last67bit", "last36planes", " last_bit"], "state": [" sc", "line", "class", "cache", "p", "step", "use", "STATE", "se", "date", "f", "cur", "si", "are", "seed", "ke", "sb", "shadow", "range", "rate", "key", "source", " self", "bc", "print", "data", "un", "open", "note", "comment", "part", "ate", "pe", "al", "current", "call", "area", "name", "loc", "val", "status", "address", "config", "none", "is", " c", "back", "power", "parent", "we", "e", "private", "point", "rule", "State", "grade", "id", "param", "slice", "resource", "update", "states", " State", "cause", "region", "mode", "length", "stat", "func", "wa", "err", "store", "error", "style", "patch", "ch", "cal", "sh", "value", "ne", "instance", "scope", " rc", "ctx", " config", "m", "g", "ace", "statement", "st", "sync", "block", "code", "frame", "type", "start", "body", "ct", "sth", "scale", "o", "conn", "message", "session", "span", "d", "port", "self", "last", "context", "tag"], "h": ["ha", "auth", "hd", "w", "kh", "p", "ht", "hl", "gh", "http", "ih", "f", "s", "q", "rh", "he", "ssh", "b", "ah", "bh", "v", "oh", "n", "c", "hs", "o", "H", "e", "r", "l", "hr", "ch", "ph", "u", "adh", "sh", "d", "uh", "hm", "ctx", "m", "han", "eh", "hp", "ec"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_write(AddressSpace *as, target_phys_addr_t addr,\n\n                         const uint8_t *buf, int len)\n\n{\n\n    address_space_rw(as, addr, (uint8_t *)buf, len, true);\n\n}\n", "idx": 20743, "substitutes": {"as": ["res", "al", "p", "aws", "sa", "us", "ac", "ras", "ack", "is", "asm", "a", "asu", "mac", "acs", "ar", "ag", "cas", "from", "nas", "ast", "r", "or", "inas", "As", "ach", "at", "os", "sys", "pas", "las", "bs", "ap", "has", "AS", "var"], "addr": ["adr", "ace", " address", "src", "host", "pair", "offset", "pointer", "loc", "rt", "address", "config", "func", "a", "align", "amp", "ar", "base", "alias", "ast", " af", "ref", "holder", "port", "layer", "pos", "attr", "coord", "data", "ptr", "ctx", "eth", "pad", "ad", "wd", "Address", "node"], "buf": ["lb", "cap", "uf", "alloc", "src", "queue", "lim", "buff", "buffer", "offset", "length", "uc", "func", "cur", "cmd", "b", "bh", "seq", "cb", "vec", "ab", "fd", "aux", "byte", "ref", "pb", "off", "bc", "rc", "ptr", "ctx", "null", "gb", "pad", "rb"], "len": ["cap", "line", "en", "enc", "Len", "lit", "lf", "num", "offset", "lim", "val", "ln", "name", "el", "length", "f", "lan", "bl", "n", "seq", "base", "fl", "l", " length", "fd", "nt", "limit", "size", "off", "li", "pos", "data", "count", "fin", "la", "lon"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_run_capture (AudioState *s)\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        int live, rpos, captured;\n\n        HWVoiceOut *hw = &cap->hw;\n\n        SWVoiceOut *sw;\n\n\n\n        captured = live = audio_pcm_hw_get_live_out (hw);\n\n        rpos = hw->rpos;\n\n        while (live) {\n\n            int left = hw->samples - rpos;\n\n            int to_capture = audio_MIN (live, left);\n\n            st_sample_t *src;\n\n            struct capture_callback *cb;\n\n\n\n            src = hw->mix_buf + rpos;\n\n            hw->clip (cap->buf, src, to_capture);\n\n            mixeng_clear (src, to_capture);\n\n\n\n            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n                cb->ops.capture (cb->opaque, cap->buf,\n\n                                 to_capture << hw->info.shift);\n\n            }\n\n            rpos = (rpos + to_capture) % hw->samples;\n\n            live -= to_capture;\n\n        }\n\n        hw->rpos = rpos;\n\n\n\n        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {\n\n            if (!sw->active && sw->empty) {\n\n                continue;\n\n            }\n\n\n\n            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {\n\n                dolog (\"captured=%d sw->total_hw_samples_mixed=%d\\n\",\n\n                       captured, sw->total_hw_samples_mixed);\n\n                captured = sw->total_hw_samples_mixed;\n\n            }\n\n\n\n            sw->total_hw_samples_mixed -= captured;\n\n            sw->empty = sw->total_hw_samples_mixed == 0;\n\n        }\n\n    }\n\n}\n", "idx": 20751, "substitutes": {"s": ["S", "sq", "south", "w", "rs", "sym", "p", "sync", "sa", "se", "ses", "ds", "an", "sim", "ssh", "ss", "si", "v", "a", "n", "c", "spec", "sie", "sb", "space", "service", "session", "sound", "ssl", "su", "sys", "sf", "csv", "sl", "ls", "sg", "ns", "sv", "sam", "serv"], "cap": ["snap", "capacity", "cv", "p", "cu", "lc", "lim", "app", "hop", "ape", "ca", "com", "cs", "ab", "sk", "oper", "caps", "bc", "conf", "clip", "sv", "rap", "wp", "ha", "chip", "cl", "pe", "gp", "en", "call", "cc", "ce", "config", "cr", "pc", "sc", "mp", "scl", "amp", "av", "can", "cm", "cup", "ipp", "ip", "mc", "cfg", "w", "capt", "host", "acl", "ac", "uc", "comm", "v", "cod", "c", "ch", "sh", "copy", "cop", "cpp", "ap", "cam", "op", "cf", "aps", "af", "sq", "pac", "code", "fab", "grab", "up", "mac", "acc", "Cap", "cp", "vc", "su", "cmp", "CAP", "rip"], "live": ["line", "irm", "lc", "lim", "wl", "le", "low", "roll", "game", "seq", "old", "source", "liv", "la", "lib", "loop", "lb", "Live", "stage", "cl", "core", "lf", "val", "loc", "shell", "cli", "wave", "lan", "len", "fl", "active", "sel", "lu", "pl", "life", "rc", "slice", "lr", "large", "comp", "home", "il", "dri", "lin", "local", "mode", "length", "online", "ive", "dl", "win", "l", "lic", "won", "slave", "hi", "vel", "file", "living", "sl", "lived", "full", "player", "load", "lane", "vol", "nl", "play", "how", "split", "mid", "lo", "rl"], "rpos": ["crpose", "fposition", "rlposition", "rfpose", "fpo", "rdpt", "ppo", "rcpo", " rval", "ppos", "fpos", "srposition", "rneg", "srpo", "rpt", "rlpt", "rfpos", "rpush", "rposition", " rneg", "wpo", "wpos", "rrpo", "rcpos", "rpid", "lpose", "srpos", "lposition", "crposition", "rhpos", "rpo", " rpose", "rrpos", "pposition", "rval", "rloc", " rlen", "rclen", "rdposition", "fval", "wposition", "crneg", "Rpush", "rdpos", "rdpo", "rlpo", "lpos", "rlpos", "rhposition", "rfposition", "wpid", "ploc", "lval", "lpo", "srlen", "Rpose", " rposition", "rcposition", "rpose", " rpo", "rrposition", "Rposition", "crpos", "rhpose", " rloc", " rpush", "srloc", "rlen", "rfpush", "ppt", " rpid", "rrpid", "crpo", "rcpose", "wpose", "rhneg", "Rpos"], "captured": ["Captured", "Capture", "aptressed", "accured", "snapured", "apturer", "ctrypted", "missored", "scuring", " captressed", "cthed", " Capturing", "capthed", "capture", "scure", "snapurer", "apthed", " capture", "capturred", " Capturred", "ctuted", "ctored", "snapuring", "captressed", "accected", "missurer", "captuted", " captrypted", "capturer", " capturer", "snapected", "accurer", " capturing", "accuted", " Captured", "Capturing", "scured", " Capture", "ctressed", "scurred", "apturing", "captored", "capturing", "aptored", "aptured", "Capturred", "apturred", "apture", " capturred", "accrypted", "missured", " capthed", "cturer", "ctured", " captuted", "captrypted", "cturing", "captected", "missuring", " captected", "accuring"], "hw": ["ww", "w", "wb", "cv", "xc", "wav", "ht", "wm", "h", "hl", "nv", "wi", "host", "cu", "wy", "wl", "aw", "zh", "rh", "vm", "mm", "cow", "own", "hh", "wn", "hop", "wx", "kw", "avi", "fw", "drm", "conn", "him", "how", "nw", "hhh", "sh", "vp", "web", "haw", "ll", "wcs", "gew", "uh", "iw", "lv", "hm", "craft", "ctx", "rw", "vc", "vo", "ow", "rew", "cmp", "wow", "wd", "wo", "wu", "hp", "wp", "rack"], "sw": ["ha", "ww", "sq", "www", "w", "cv", "wb", "flo", "wy", "sync", "tw", "aw", "go", "mo", "nn", "pg", "now", " SW", "cr", "fr", "coll", "wa", "rh", "ho", "SW", "sc", "so", "own", "wan", "wn", "hop", "wx", "wr", "stream", "fw", "kw", "wh", "ga", "sb", "sm", "who", "fl", "ew", "nw", "sk", "sh", "sel", "web", "oss", "wt", "syn", "iw", "rw", "su", "sem", "ow", "work", "sf", "push", "sex", "rew", "wow", "wo", "sl", "Sw", "wp", "new", "sn", "serv"], "src": ["support", "inst", "st", "sit", "sq", "cl", "secure", "bb", "sync", "img", "rss", "loc", "pack", "coll", "sr", "uc", "sec", "irc", "sc", "fc", "scl", "gl", "buf", "sub", "feat", "sb", "ruby", "cro", "hub", "dest", "sel", "source", "sup", "bc", "supp", "url", "rc", "rob", "ssl", "comb", "ctx", "gb", "sys", "cmp", "sl", "spec", "rb", "sn"], "cb": ["cf", "wb", "cv", "bb", "call", "cd", "sync", "code", "core", "cc", "co", "db", "buff", "cur", "grab", "uc", "nb", "bf", "cmd", "sc", "b", "CB", "fc", "callback", "cod", "ub", "buf", "c", "ck", "ca", "sb", "ab", "cgi", "hub", "obb", "pb", "ctr", "ref", "ob", "bc", "cp", "rc", "cdn", "kk", "ctx", "abb", "gb", "conf", "cpp", "fn", "fb", "ctrl", "cmp", "cue", "eb", "rb", "cor"]}}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "substitutes": {"chr": ["chlr", "chru", "Chr", "echru", " chlr", "ichr", "ichrc", "Chlr", "corrb", "chrr", " chrs", " chrc", "corlr", "corr", "echr", " chrb", "echrr", " chrr", "ichrr", "chrb", " chru", "echrc", "ichru", "chrs", "Chrs", "Chrb", "chrc", "corrs"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n", "idx": 20766, "substitutes": {"base": ["req", "part", "Base", "beta", "ix", "cache", "zero", "p", "area", "block", "core", "kit", "buffer", "offset", "frame", "ada", "type", "address", "name", "f", "bas", "start", "bf", "b", "temp", "seq", "bin", "scale", "parent", "root", "byte", "ase", "boot", "format", "ref", "pre", "size", "stable", "port", "target", "model", "api", "count", "unit", "id", "i", "server", "addr", "no", "set", "prefix", "bi", "ip"], "irq": ["irqu", "IRq", " irp", "irtp", "irisqu", "irqs", "irp", "iraq", "irisq", " irquest", "irisqs", "irz", "IRz", "irtquest", "irve", "IRquest", " irz", "IRp", "irtz", "iraqs", "irisve", " irqu", "iraqu", "irquest", "irtq", "irave", " irqs", " irve"], "version": ["channel", "support", "update", "generation", "release", "stage", "ion", "class", "vision", "step", "section", "current", "platform", "vert", "Version", "VERSION", "type", "option", "length", "versions", "secret", "supported", "v", "index", "scale", "parent", "position", "python", "action", "ver", "serial", "patch", "format", "connection", "value", "model", "ant", "number", "server", "component", "level", "feature", "ception"], "dev": ["dc", "req", "debug", "def", "w", "ev", "ve", "Dev", "p", "priv", "prop", "enc", "di", "f", "app", "driver", "prom", "valid", "device", "v", "der", "gu", "temp", "n", "ga", "pro", "err", "adv", "error", "e", "ver", "mod", "serial", "r", "conn", "ch", "result", "av", "u", "sh", "dd", "d", "data", "k", "sd", "m", "conf", "ad", "grad", "dem", "od", "cam", "g", "DEV", "spec", "dom", "de", "rad", "var"], "s": ["S", "ks", "south", "w", "rs", "p", "sym", "ls", "sync", "us", "ses", "ds", "f", "fs", "is", "si", "ss", "device", "v", "b", "n", "c", "spec", "ps", "o", "sb", "e", "cs", "r", "service", "session", "sk", "u", "services", "sup", "d", "ops", "ssl", "gs", "k", "sd", "os", "sys", "su", "self", "m", "server", "ns", "sl", "sg", "g", "sv", "js"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 20797, "substitutes": {"cpu": ["nic", "loop", "chip", "lb", "CP", "machine", "console", "CPU", "gc", "cache", "jp", "p", "lc", "eni", "uci", "platform", "linux", "GPU", "core", "PF", "que", "clock", "processor", "cli", "proc", "config", "ocr", "gpu", "net", "computer", "pc", "roc", "consumer", "vm", "mac", "c", "ck", "python", "performance", "conn", "cycle", "fp", "hw", "kernel", "boot", "np", "cp", "progress", "pu", "ctx", "sys", "pkg", "cmp", "component", "nc", "ilo", "cn", "loader", "uu", "node", "hp", "pool"], "r1": ["er2", "r4", "r31", "fr1", "r8", "R3", "ar2", "R4", "rc1", "rone", "R1", "sr4", "rcone", " rone", "er3", "Rone", "R2", "R31", "R8", "R5", "rc3", " r4", "r5", "sr1", " r2", "fr31", " r8", "sr3", "fr2", "er1", "ar1", "sr8", "ar31", "ar5", "rc2", "fr5", "r2", "sr2"], "r3": ["r4", "er2", "rr2", "ar4", "ar6", "R3", "R4", "er11", "ar3", "R1", "rr5", "er3", " r11", "p4", "p1", "r11", "rr11", "rr3", "r5", "er5", " r2", "p3", " r5", "r6", "ar1", "p6", "R6", "r2"], "gaddr": ["wdb", "whost", "_host", "waddress", "_address", "_db", "waddr", "mgdb", "mghost", "gdb", "ghost", "gaddress", "mgaddr", "mgaddress", "_addr"], "ar": ["cap", "aa", "att", "al", "sa", "acl", "rar", "ac", "au", "ai", "art", "ag", "AR", "err", "args", "amd", "ars", "arp", "ard", "arc", "ara", "xa", "arr", "ad", "arg", "array", "ap", "rg", "ann"], "env": ["inet", "req", "cv", "cache", "chal", "eng", "python", "uni", "lv", "oa", "conf", "vs", "ec", "ext", "po", "global", "iv", "stage", "ev", "event", "stack", "en", "ea", "forge", "core", "db", "ce", "cli", "shell", "config", "prov", "e", "args", "kernel", "end", "qa", "np", "Environment", "environment", "cdn", "eu", "esp", "cfg", "console", "esi", "gui", "enc", "site", "el", "net", "enh", "vm", "init", "v", "agent", "state", "err", "dat", "osc", "ou", "cal", "ass", "profile", "ne", "scope", "ctx", "server", "energy", "qt", "cf", "eni", "code", "que", "dt", "ini", "exc", "fen", "estate", "engine", "conn", "session", "zone", "kn", "nc", "context", "cn", "loader", "exec", "skin"], "pbdev": ["xbdev", "lpdevice", "lpDEV", "PBDEV", "ppdev", "cbserial", "pbdef", "PBdiv", "pcconf", "rbdev", "pbdiv", "pbserial", "pcdev", "xbdriver", "cbdriver", "lpdriver", "jpdevice", "fbdevice", "cbdevice", "pbDEV", "xbdevice", "fbconf", "pcdiv", "sbdev", "pprent", "lprent", "pdevice", "sbserial", "pbdevice", "pdiv", "rbdriver", "pbrent", "sbdevice", "pcdevice", "pbDev", "pcDEV", "rbdevice", "jpdriver", "lpdiv", "sbdriver", "cberror", "jpdef", "PBDev", "jpdev", "PBdev", "pbdriver", "pbconf", "fbdev", "cbdev", "lperror", "pberror", "fbdiv", "pcDev", "pdev", "lpdev", "ppdiv", "xbserial", "ppdevice", "lpDev", "lpdef", "cbdiv", "fbrent", "rbdef", "lpconf"], "mr": ["adr", "dm", "bm", "MR", "mc", "br", "bro", "gr", "rs", "gm", "wm", "pr", "bridge", "mer", "rm", "fr", "Mr", "sr", "mn", "mt", "rx", "vm", "yr", "vr", "wr", "LR", "err", "rpm", "igr", "rr", "r", "kr", "hr", "module", "wk", "km", "attr", "mmm", "arr", "hm", "dr", "m", "gb", "er", "lr", "shr", "ml"], "i": ["ti", "ii", "I", "p", "j", "type", "f", "s", "is", "b", "io", "v", "a", "pi", "n", "c", "e", "l", "r", "or", "d", "count", "id", "ci", "z", "ip"], "fh": ["fH", " fht", "lfh", "fgh", "fht", "cfhp", "Fhs", " fah", "fph", "Fq", "dfhp", "lfhs", "gh", "cfh", "cfw", "rfhr", "dfsh", " fw", " fhp", "fbh", "tfhs", "fhs", "dfhs", "fah", "ggh", "lfbh", "fhp", "dfgh", " fbh", "fhr", "fq", "tfah", "fsh", "rfhs", " fsh", "fw", "dfq", "dfah", "Fgh", "cfsh", "gq", "Fh", "dfht", " fH", "tfht", "lfH", "lfhr", "rfbh", "lfph", "dfh", " fph", "fbph", " fhr", "tfh", "dfw", " fhs", "ghs", "fbH", "rfh", "fbhs"], "pcias": ["pqiasi", "pciAs", "Pdiase", "pdiase", "pqias", "pcmAS", "cociAS", "pidias", "pkias", "piliAS", "piiac", "cbiAs", "pdiac", "cociac", "pciasing", "piliase", "cbiasi", "pidiac", "PdiAS", "pidiasing", "cciAs", "pbias", "pociasi", "pcmasi", "pqiAS", "cbias", "Pcias", "pcmAs", "cciasi", "pdiAS", "pilias", "cciac", "pdias", "pbiasi", "pciasi", "piiase", "cciAS", "pqiAs", "cbiAS", "Pciac", "Pdiasi", "pociac", "pciac", "cocias", "pdiasi", "piiAS", "pkiAS", "cociasing", "Pdias", "cciasing", "piliac", "pbiAS", "pbiac", "ccias", "Pciasi", "PciAS", "pociAS", "pidiAS", "pocias", "pcmas", "pkiac", "pbiAs", "pkiasing", "pciase", "pociasing", "pciAS", "Pdiac", "piias", "Pciase"], "len": ["part", "cap", "ler", "lin", "lc", "en", "Len", "mem", "code", "acl", "lf", "depth", "lim", "val", "ln", "rev", "el", "den", "length", "le", "lan", "loc", "dl", "lt", "body", "bl", "rel", "seq", "bin", "fun", "fl", "min", "l", "conn", "offset", "limit", "span", "str", "size", "gen", "li", "layer", "pos", "split", "data", "count", "vel", "live", "fin", "fn", "cmp", "dy", "lib", "lon", "sl", "ann"], "buffer": ["Buffer", "cap", "shape", "empty", "alloc", "bb", "row", "block", "buff", "info", "extra", "uffer", "raw", "bin", "buf", "batch", "blocks", "read", "data", "arr", "null", "transfer", "array", "binary", "ba", "bytes"]}}
{"project": "qemu", "commit_id": "293d2a0014a0e849477413f55aaa05f2743b2e04", "target": 0, "func": "static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n\n                                  void *opaque)\n\n{\n\n    monitor_flush(opaque);\n\n    return FALSE;\n\n}\n", "idx": 20802, "substitutes": {"chan": ["channel", "circ", "scan", "nan", "cat", "an", "app", "Chan", "irc", "anim", "wan", "bin", "con", "ca", "path", "reg", "conn", "ch", "can", "chron", "gen", "ann", "cn", "han", "anon", "qt", "cor"], "cond": ["condition", "crit", " latch", "resp", "Cond", " Cond", "ac", "bit", "val", " whence", "proc", " interrupt", "func", "rupt", "cmd", " conditional", "parent", "cb", "pipe", " parent", "tx", " func", " pri", " proc", "bc", " pipe", "sec", "comp"], "opaque": ["paque", "pause", "OPaqu", "paqu", " ophole", "OPaque", "opque", "pque", "opacity", " opque", "OPause", "ophole", "operhole", "iopause", " opacity", "operque", "opaqu", "opause", "operacity", "operaque", "OPacity", "phole", "pacity", "iopaqu", "iopaque", "iopacity"]}}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_store_spr(int reg, TCGv t)\n\n{\n\n    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n", "idx": 20803, "substitutes": {"reg": [" REG", "mem", "num", "rol", "name", "loc", "Reg", "type", "proc", "region", "ret", "stat", "eng", "registered", "eg", "REG", "pred", "aug", "rel", "index", "feat", "fun", "mod", " Reg", "ind", "conn", "acc", "ref", "pre", "run", "rem", "rule", "port", "data", "re", "ig", "org", "orig", "addr", "tag", "sec", "rec", "rg"], "t": ["T", "tt", "p", "ht", "rt", "te", "type", "f", "mt", "tf", "ut", "ts", "b", "v", "tower", "a", "n", "c", "o", "pt", "e", " T", "tx", "y", "l", "vt", "r", "nt", "u", "out", "et", "d", "at", "port", "target", "tc", "i", "m", "tty", "ant", "ot", "unt", "ent", "g", "qt", "it"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n", "idx": 20811, "substitutes": {"bs": ["ins", "iss", "rs", "als", "bid", "bis", "ses", "banks", "bas", "fs", "is", "b", "ss", "BS", "Bs", "ps", "bps", "sb", "bits", "bos", "cs", "boxes", "bi", "blocks", "bes", "pb", "vals", "ops", "bc", "bing", "gs", "null", "os", "fb", "vs", "ubs", "ns", "ls", "ba", "bytes"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n", "idx": 20812, "substitutes": {"opaque": ["opac", "placo", "ospaque", "plaque", "placle", "ospacity", "operonymous", "opacity", "opacle", "opaco", "placity", "ospac", "operac", "Opac", " opaco", " opacity", "osponymous", "Oponymous", "Opacity", "operacity", "operaque", "Opaque", "oponymous", "ospaco", "ospacle", " opacle"], "addr": ["ace", "x", "src", "p", "alloc", "enc", "host", "pointer", "ord", "offset", "loc", "address", "config", "ack", "cmd", "device", "align", "index", "buf", "base", "alias", "tx", "ref", "layer", "pos", "attr", "coord", "data", "obj", "ptr", "target", "eth", "id", "pad", "alt", "ad", "grad", "node"], "val": ["ul", "VAL", "x", "eval", "def", "al", "block", "el", "buffer", "loc", "valid", "bl", "v", "len", "bin", "vol", "base", "slot", "tx", "byte", "fat", "ref", "sel", "vals", "value", "pos", "data", "count", "arr", "unit", "alt", "Val", "grad", "slice", "exec", "sl"], "size": ["capacity", "shape", "class", "empty", "en", "offset", "name", "loc", "address", "length", "s", "max", "sec", "Size", "fee", "len", "c", "SIZE", "scale", "send", "sum", "from", "e", "message", "ize", "value", "small", "esc", "pos", "count", "sized", "unit", "large", "g", "z"], "b": ["lb", "br", "w", "orb", "p", "h", "B", "buffer", "bd", "db", "f", "a", "bin", "c", "buf", "base", "o", "sb", "e", "ab", "r", "l", "hub", "pb", "be", "ob", "d", "emb", "abb", "i", "m", "gb", "fb", "lib", "g", "binary", "rb"]}}
{"project": "qemu", "commit_id": "54ca9095f046dfa03c3d093cc55f6d76b61864e1", "target": 0, "func": "void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    unsigned long pc;\n\n    CPUX86State *saved_env;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);\n\n    if (ret) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc, NULL);\n\n            }\n\n        }\n\n        if (retaddr)\n\n            raise_exception_err(EXCP0E_PAGE, env->error_code);\n\n        else\n\n            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);\n\n    }\n\n    env = saved_env;\n\n}\n", "idx": 20831, "substitutes": {"addr": ["channel", "adr", "ace", "src", "eni", "host", "code", "arch", "offset", "ord", "name", "pointer", "type", "address", "mode", "proxy", "config", "net", "device", "mac", "len", "index", "amp", "ar", "base", "alias", "nr", "conn", "amd", "ref", "layer", "url", "rc", "data", "ptr", "oa", "pad", "ad", "pkg", "socket", "server", "sid", "node", "ext", "ip"], "is_write": ["is__server", "is_read", "is1read", "is1write", "is1log", " is_server", "is__write", "is_server", "is1writer", "is_log", " is_log", " is_writer", " is_read", "is2log", "is__user", "is__writer", "is2write", "is2read", "is_writer", "is2writer"], "is_user": [" is_master", "is67user", "islandwrite", "islanduser", " is_use", "is_use", " is_touch", "islandadmin", "islanduse", "is_touch", "is67touch", "is67write", " is_admin", "is_admin", "is67master", "is_master"], "retaddr": ["returnaddr", "pretroute", " retadr", "pretaddress", "refconn", "retfunc", " retfunc", "retconn", "retadr", "refarg", "pretadr", "revaddress", "pretfunc", "returnconn", "retaddress", " retnode", "revconn", "retnode", "pretaddr", "revadr", "revroute", "revfunc", "revaddr", "returnaddress", "refaddr", "reflayer", "retlayer", "pretlayer", "pretconn", "retarg", " retaddress", "retroute", " retconn", "refaddress", " retarg", "returnlayer", "revnode", "pretnode", " retroute", "returnarg"], "tb": ["ttbh", "atpb", "ttb", "ctbt", "ftb", "ftbt", "ctb", " tba", "tbh", " tfb", "tbt", "ftfb", "rlb", "tlb", "tpb", "ttpb", "rpb", " tbb", "untbd", "tbb", " tbs", "rp", "ctbs", "untbs", "ttbb", " tbh", "atbh", " tlb", "ctfb", "atp", "ttba", "atb", "ftbs", "ttbd", "tp", "atlb", "untb", "atbb", " tp", " tpb", "tfb", "tbs", "ttbs", " tbt", "tbd", "tba", "rb", " tbd", "untba"], "ret": ["full", "att", "match", "def", "res", "al", "lit", "code", "cat", "rt", "val", "bit", "rev", "det", "ft", "pat", "art", "mt", "bl", "RET", "len", "back", "ar", "lag", "fun", "reg", "pt", "conn", "result", "nt", "ref", "run", "et", "tr", "inter", " RET", "reply", "flag", "re", "alt", "arg", "Ret", "pub", "pet", "rl", "sec", "ext"], "pc": ["mc", "dc", " dc", "pac", "pa", "xc", "p", "lc", "enc", "pid", "code", "cc", "cpu", "ac", "val", "pointer", "type", "proc", "cr", "uc", " lac", "sc", " CPC", "fc", "ct", "amp", "index", "c", "lp", "PC", "bp", "pt", "cs", " PC", " pointer", " func", " protocol", "pb", "ref", "point", " plat", "arc", "port", "bc", "attr", "tc", "rc", "ig", " rc", " cc", "vc", "ctx", " RPC", "nc", "inc", "ec"], "saved_env": ["save_env", "saved__state", "save_environment", "saved2environment", "saved__stage", "saved__env", "saving_env", "saved_environment", "saved__environment", "save_stage", "saved_stage", "saving_state", "saved2env", "saved2state", "saving_environment", "saved_state", "save_state"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835, "substitutes": {"d": ["dc", "nd", "dm", "x", "w", "pd", " dd", "p", "h", "cd", "dt", "di", "db", "bd", "ed", "ds", "j", "f", "dict", "dl", "s", "q", "md", "driver", "did", "D", "gd", "b", "cmd", "dh", "n", "c", "mod", "da", "o", "mad", "e", "dat", "ind", "dx", "l", "draw", "fd", "module", "u", "ard", "rd", "dd", "dom", "xd", "in", "dad", "data", "k", "id", "sd", "i", "ad", "m", "t", "dr", "done", "self", "ded", "dy", "dos", "od", "wd", "g", "vd", "z", "ld", "de"], "val": ["part", "il", "VAL", "x", "eval", "al", "fe", "all", "el", "elt", "rt", "bit", "fail", "stat", "valid", "bl", "aval", "ut", "v", "len", "seq", "vol", "rot", "base", "dev", "err", "slot", "reg", "pt", "ind", "args", "ref", "pre", "cal", "sel", "vals", "value", "end", "cond", "split", "data", "unit", "alt", "arg", "live", "Val", "Ret", "sl", "sec", "ival", "ol"], "ret": ["part", "match", "res", "eval", "rets", "aud", "lit", "vert", "pin", "bit", "rt", "rev", " arg", "ft", "det", "valid", "ben", "pat", "lt", "ut", "RET", "len", "gt", "rot", "sat", "reg", "ind", "nt", "result", "pit", "out", "sel", "value", "et", " alt", " RET", "rc", "re", "flag", "xt", "arg", "fin", "alt", "Ret", "rep", " result", "let"]}}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n", "idx": 20840, "substitutes": {"format": ["channel", "settings", "prefix", "title", "class", "layout", "version", "brand", "template", "package", "options", "attribute", "text", "host", "platform", "cat", "name", "pretty", "region", "type", "option", "f", "mode", "config", "status", "object", "language", "magic", "pattern", "qt", "mt", "atter", "transform", "feat", "base", "path", "Format", "style", "fd", "fp", "filename", "letter", "function", "output", "source", "str", "plugin", "size", "command", "value", "at", "target", "model", "api", "data", "unit", "id", "form", "fn", "ant", "sort", "feature", "method", "term", "file", "spec", "act", "op"], "QemuOpts": ["QCryptuOpto", "QCryptuLibo", "QCryptoOptts", "QCryptuOpts", "QCryptuLibts", "QCryptoCls", "QCryptoClSpec", "QCryptoClo", "QCryptuConfigs", "QCryptuCls", "QCryptuConfigts", "QCryptuLibs", "QCryptuConfigo", "QCryptuClts", "QCryptuLibSpec", "QCryptuOptSpec", "QCryptoOpts", "QCryptuClo", "QCryptoOptSpec", "QCryptuClSpec", "QCryptoClts", "QCryptuOptts", "QCryptoOpto", "QCryptuConfigSpec"], "ov": ["adr", "ovan", "iv", "ur", "gr", "voc", "ev", "rov", "cv", "over", "vers", "oven", "OV", "oy", "ever", "ef", "ocr", "ood", "ove", "uv", "oc", "own", "ovi", "oo", "vr", "oh", "ovo", "oyer", "o", "ova", "ork", "ou", "av", "erv", "boot", "obb", "opp", "kov", "fo", "oid", "orf", "off", "ob", "nov", "oto", "rf", "ott", "oval", "vo", "eu", "oa", "ow", "lov", "obile", "ko", "sv", "gov"], "ret": ["auth", "req", "full", "att", "gr", "def", "match", "res", "eval", "rets", "rs", "uf", "fit", "lit", "al", "mem", "cat", "rt", "val", "fab", "rev", "j", "det", "f", "ft", "status", "cur", "pass", "ut", "RET", "v", "vr", "gt", "len", "pro", "fun", "reg", "cb", "Return", "r", "conn", "vt", "nt", "result", "session", "ref", "boot", "py", "out", "opt", "fi", "tr", "reply", "rc", "obj", "re", "ig", "job", "arr", "os", "alt", "sys", "t", "arg", "success", "fin", "Ret", " result", "ext"], "local_err": [" local_log", " local_result", "localableorig", "localalmessage", "externalalerr", "local_orig", "externalalnr", "local_exc", "localWrisk", "local_result", "localablesys", "local67orig", "localallrisk", "localapperr", "localalnr", "localLogerror", "remote_error", "localableerr", "external_err", "externalalmessage", "local67err", "local_er", "localWerror", "localapperror", "local67message", "localLogexc", "localLoger", "local_rr", "local_sys", "localWerr", "localableerror", "local67risk", " local_risk", "localappresult", "external_risk", "local67nr", "local_error", "remote_err", "local_risk", "localalerr", "local_message", "local_ler", " local_ler", " local_error", " local_rr", "externalalrisk", "localWlog", " local_sys", "localallerr", "localalrisk", "remote_er", "local67error", "external_nr", "external_message", "remote_exc", "localallmessage", "localLogerr", " local_er", " local_orig", "localallnr", "local67sys", "localapper", "local_nr", "local_log"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 20856, "substitutes": {"c": ["C", "dc", "mc", "cl", "w", "cit", "cache", "xc", "p", "lc", "h", "cc", "ac", "f", "config", "s", "cur", "pc", "oc", "b", "v", "ct", "a", "con", "e", "l", "r", "u", "cm", "d", "tc", "ctx", "vc", "m", "cpp", "ci", "t", "ctrl", "context", "g", "ec", "icc"], "lumFilter": ["lumFile", "lUMFilter", "LumbRef", "LumRef", "lumbFile", "lumbRef", "lumRef", "lucFilter", "LumbFilter", "lUMRef", "LumbFile", "lumbFilter", "LumFilter", "lucFile", "lucRef", "lUMFile", "LumFile"], "lumSrc": ["lumaSsrc", "lumVSuc", "lumaAssrc", "lumCuc", "lumSRC", "lumSuc", "lumVSRC", "lumAsRC", "lumCrc", "lumAssrc", "lumaAsrc", "lumaSrc", "lumCRC", "lumaAsuc", "lumAsrc", "lumCsrc", "lumVSsrc", "lumVSrc", "lumaAsRC", "lumAsuc", "lumaSRC", "lumaSuc", "lumSsrc"], "lumFilterSize": ["lumContextSize", "lulFlC", "lumContextC", "lulFilterStyle", "lumContextSIZE", "lumFileC", "lulFlSIZE", "lumFilterStyle", "lumFlStyle", "lumContextStyle", "lulFilterSIZE", "lumFilterC", "lumFlC", "lulFlSize", "lumFileStyle", "lumFilterSIZE", "lumFlSIZE", "lulFlStyle", "lulFilterC", "lumFlSize", "lulFilterSize", "lumFileSIZE", "lumFileSize"], "chrFilter": ["echreHeader", "echreLimit", "chreHeader", "chrgLimit", "chreLimit", "chcLimit", "chcHeader", "chrHeader", "echrHeader", "echreFilter", "chrgHeader", "chrLimit", "chrgFilter", "echrFilter", "echrLimit", "chcFilter", "chreFilter"], "chrUSrc": ["chrKSRC", "chrKSrc", "chrSsrc", "chrsUSci", "chrSSsrc", "chrSSRC", "chrsUSRC", "chrUSsrc", "chrsUSsrc", "chrSRC", "chrSSci", "chrKSci", "chrUSRC", "chrSSrc", "chrSrc", "chrUSci", "chrsSrc", "chrKSsrc", "chrsSsrc", "chrsUSrc", "chrsSci", "chrsSRC", "chrSci"], "chrVSrc": ["chrgVSource", "chrCSrc", "chrSSource", "chrSSsrc", "chrgVSsrc", "chrgSSuc", "chrNsuc", "chrgSSrc", "chrVSsrc", "chrVSuc", "chrgSSource", "chrNsource", "chrgVSrc", "chrNssrc", "chrCSuc", "chrNsrc", "chrgVSuc", "chrgSSsrc", "chrSSuc", "chrSSrc", "chrCSsrc", "chrVSource", "chrCSource"], "chrFilterSize": ["chrbBlockLen", "chrfilterLen", "chrbFilterLen", "chrBlockSize", "chrFlSIZE", "chrFilterSIZE", "chrBlockSIZE", "chrBlockLen", "chrbFilterSize", "chrfilterSIZE", "chrFlSize", "chrbFilterSIZE", "chrbBlockSIZE", "chrfilterSize", "chrbBlockSize", "chrFlLen", "chrFilterLen"], "alpSrc": ["alcAsRC", "alpOSsrc", "alcAsdr", "alcSsrc", "alcSRC", "alpOSdr", "alpAsRC", "alcAssrc", "alcSdr", "alpSSdr", "alcSrc", "alpSSrc", "alpOSrc", "alpAssrc", "alcAsrc", "alpSdr", "alpSRC", "alpOSRC", "alpSsrc", "alpSSsrc", "alpSSRC", "alpAsdr", "alpAsrc"], "dest": ["dc", "desc", "home", "du", "match", "cont", "wb", "src", "prop", "img", "route", "name", "loc", "mode", "config", "md", "uc", "sc", "transform", "feat", "cb", "path", "dev", "da", "dat", "tmp", "dist", "source", "d", " Dest", "target", "data", "Dest", "dep", "destroy", "shift", "orig", "done", "asc", "de"], "uDest": [" uHome", "UExt", "iDest", "uDesc", "iOrig", "uOrig", "vDesc", "pSource", "uDir", "vDir", "UDest", "vSource", "uExt", " uDir", "UDir", "aSource", "pDest", "iSource", "uSource", " uDep", "USource", "vDep", "vdest", "adest", "udest", "vOrig", "aExt", "uHome", "UHome", "vHome", "iDesc", "pDesc", "Udest", "UDep", "vExt", "pOrig", "uDep"], "vDest": ["pDep", "uDesc", " vDist", "uOrig", "vDesc", "hDest", " vOrig", "uOrd", "fOrig", "hDep", "pDest", "pDist", "fDest", "fDist", "vDep", "fOrd", "vOrig", "hDist", " vOrd", "vDist", "hDesc", "pDesc", "vOrd", "uDist", "uDep"], "aDest": ["aSc", "sadest", "ASc", " aDesc", " adest", "apiOrig", "aOrig", "aDesc", "apiEnt", "vaDest", "saDist", " aOrig", " aSc", "aaDest", "AEnt", "AOrig", " aEnt", "vaDesc", "aEnt", "aDist", "adest", "apiSc", "aaDesc", " aDist", "apiDest", "saDest", "vaOrig", "ADest", "aaOrig", "bDest", "bdest", "bDist"], "dstW": ["drcWS", "dstWS", "drestH", "DstM", "dndB", "drestWS", "dptM", "dptW", "dstB", "dostH", "DndW", "dstFW", "dndH", "drestM", "dptWS", "DscW", "DstB", "dndW", "dscFW", "DptH", "DscFW", "dostB", "dscH", "DstWS", "dndM", "DndB", "drestW", "drcW", "dptH", "drcB", "DscH", "dscW", "DndH", "dstH", "DptW", "drcH", "dstM", "dscM", "DptWS", "dostM", "DstW", "DndM", "DscM", "DstFW", "drestFW", "dostW", "DstH", "drcM", "drcFW", "DptM"], "chrDstW": ["chrdstW", "chrDrdL", "chrDntW", "chrDrdGW", "chrDSTL", "chrDSTGW", "chrDrcGW", "chrLstM", "chrDrcM", "chrDblw", "chrSrcM", "chrSstD", "chrDblGW", "chrDstGW", "chrLestW", "chrDstL", "chrSrcN", "chrSrcD", "chrDrcD", "chrDntM", "chrDntN", "chrDstM", "chrLstW", "chrDscH", "chrDscGW", "chrDestW", "chrdSTW", "chrdstGW", "chrSrcW", "chrLstGW", "chrdSTGW", "chrDblM", "chrLestM", "chrDestw", "chrDSTH", "chrDscL", "chrSstW", "chrLstw", "chrDSTW", "chrDestM", "chrdstL", "chrDscD", "chrSstM", "chrDrcw", "chrLestGW", "chrDstN", "chrDrcN", "chrDstH", "chrDscW", "chrDrdW", "chrLestw", "chrDstw", "chrDestGW", "chrDrcW", "chrDblW", "chrdSTL", "chrDrdH", "chrdSTH", "chrSstN", "chrDntD", "chrdstH", "chrDstD", "chrDscM", "chrDscN"]}}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n", "idx": 20902, "substitutes": {"key": ["ace", "image", "pe", "alloc", "row", "access", "call", "link", "core", "code", "ac", "name", "type", "app", "object", "ro", "fee", "mac", "index", "parent", "ke", "path", "Key", "entry", "keys", "conn", "root", "pri", "byte", "KEY", "connection", "ee", "value", "size", "copy", "fork", "child", "hash", "peer", "k", "id", "ip"], "opaque": ["opsaque", " opca", " ophole", "ipaque", "opsaques", "ipca", "opacity", "opsca", "opca", " opace", "apphole", "ipace", "ipacity", "ophole", "opshole", "operca", "appca", " opacity", " opaques", "opace", "operacity", "operaque", "appaque", "appaques", "operace", "opaques"], "cpu": ["nic", "chip", " CPU", "ace", "lb", "capacity", "gp", "CPU", "gc", "cache", "lc", "eni", "GPU", "cu", "linux", "sync", "core", "css", "platform", "processor", "cli", "proxy", "proc", "consumer", "cus", "gpu", "roc", "pc", "vm", "mac", "intel", "uri", "winner", "conn", "cycle", "hw", "pex", "kernel", "auc", "boot", "lu", "copy", "fi", "np", "cp", "instance", "pu", "uno", "ctx", "gb", "cmp", "component", "ilo", "nc", "loader", "px", "cn", "node", "piece", "pool"], "regidx": ["regidz", "regidxy", "recIdx", "blockidxs", "rigidy", "regIDX", "regsidx", "blockidz", "regidexi", "blockidxes", "regindx", "blockIdxi", "recIdX", "blockIdX", "regpidx", "rigindxy", "regpidxy", "regideX", "regIDxs", "regindxc", "blockIdx", "regidX", "regindn", "blockIdxs", "regIdX", "regidxc", "regpidn", "recidxs", "recIdxs", "recidx", "regIdxi", "rigidxy", "regenz", "regidexs", "regIdz", "regIdx", "regindy", "blockidxi", "regIDxi", "rigindy", "blockidx", "regenX", "regindxy", "regidxes", "blockidX", "regenxs", "regidxs", "regenx", "rigindn", "recIdz", "rigidx", "regsidy", "blockidxc", "regindxes", "recidX", "regIdxes", "regidex", "regIdxs", "rigindx", "regidy", "regsidxy", "blockIdxes", "regpidy", "blockIdxc", "regidxi", "recidz", "regIdxc", "regindz", "blockIdz", "regsidn", "regIDx", "rigidn", "regidn"], "ri": ["adr", "ti", "ii", "ani", "rin", "eni", "ra", "co", "di", "rt", "ai", "ris", "ini", "ni", "ro", "si", "ati", "io", "ry", "ki", "pi", "uri", "rio", "adi", "xi", "iri", "rid", "rd", "arin", "li", "RI", "i", "mi", "ci", "zi", "gi", "ori", "stri", "bi"], "cpreg_array_len": ["cpreg_array_base", "cpreg_string_base", "cpreg_array_val", "cpreg_arrayspos", "cpreg_array_pos", "cpreg_string_pos", "cpreg_string_val", "cpreg_arrayscount", "cpreg_arrayslen", "cpreg_arrayslength", "cpreg_array_count", "cpreg_string_len", "cpreg_array_length", "cpreg_string_count", "cpreg_string_length"]}}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_huffman_decode(unsigned char *dest, unsigned char *src)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    int counter = 0;\n\n\n\n    unsigned char bits = *ptr++;\n\n\n\n    while ( val != 0x16 ) {\n\n        if ( (1 << counter) & bits )\n\n            val = src[byte + val - 0x17];\n\n        else\n\n            val = src[val - 0x17];\n\n\n\n        if ( val < 0x16 ) {\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n\n\n        if (counter++ == 7) {\n\n            counter = 0;\n\n            bits = *ptr++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20903, "substitutes": {"dest": ["dc", "desc", "neg", "st", "inst", "cont", "wb", "class", "test", "prop", "route", "loc", "proc", "address", "config", "uv", "bin", "rest", "buf", "parent", "reverse", "dev", "store", "tmp", "dist", "ctr", "source", "end", "d", "target", "data", "Dest", "dep", "txt", "push", "slice", "trans", "ext"], "src": ["support", "inst", "st", "ul", "iv", "cont", "rs", "text", "stack", "lit", "img", "val", "loc", "proc", "config", "uv", "cur", "sr", "start", "sec", "sc", "b", "sth", "stream", "buf", "sub", "cb", "sb", "tmp", "rib", "byte", "sel", "ctr", "source", "bc", "impl", "url", "rc", "data", "attr", "split", "ctx", "uint", "gb", "socket", "slice", "sid", "addr", "sl", "rl", "rb", "comp", "bytes"], "ptr": ["inst", "iv", "br", "req", "eger", "eval", "priv", "fe", "inters", "pend", "pair", "offset", "buffer", "loc", "pointer", "val", "address", "dim", "proc", "cur", "pc", "pert", "vr", "len", "seq", "sth", "buf", "quad", "Ptr", "vec", "pt", "prot", "fp", "ref", "ctr", "spl", "tr", "inter", "pos", "impl", "pull", "data", "xt", "uint", "plug", "shift", "pad", "sp", "dr", "grad", "slice", "addr", "comp", "ext"], "counter": ["loop", "contin", "cover", "cache", "step", "fe", "current", "code", "num", "buffer", "pointer", "bit", "offset", "info", "ter", "processor", "clock", "cur", "comp", "controller", "coll", "mask", "per", "pixel", "seq", "index", "c", "parent", "entry", "vec", "ver", "ab", "r", "result", "chain", "prev", "limit", "ctr", "value", "Counter", "inter", "bc", "instance", "url", "child", "count", "field", "number", "cmp", "currency", "card", "lr", "cube", "race", "repeat", "stop", "comment", "ext", "var"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)\n\n{\n\n    return t && t->rearm;\n\n}\n", "idx": 20908, "substitutes": {"t": ["T", "time", "att", "tt", "tg", "template", "p", "test", "h", "reset", "dt", "rt", "yt", "f", "start", "tf", "b", "ts", "v", "tower", "timer", "temp", "a", "n", "c", "tick", "o", "e", " T", "r", "l", "y", "u", "tif", "tp", "d", "at", "tn", "tc", "k", "i", "m", "tty", "txt", "tim", "g", "this", "qt", "it"]}}
{"project": "FFmpeg", "commit_id": "3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba", "target": 1, "func": "static int iff_read_header(AVFormatContext *s)\n\n{\n\n    IffDemuxContext *iff = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    uint8_t *buf;\n\n    uint32_t chunk_id, data_size;\n\n    uint32_t screenmode = 0, num, den;\n\n    unsigned transparency = 0;\n\n    unsigned masking = 0; // no mask\n\n    uint8_t fmt[16];\n\n    int fmt_size;\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codec->channels = 1;\n\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n    avio_skip(pb, 8);\n\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n\n    st->codec->codec_tag = avio_rl32(pb);\n\n    iff->bitmap_compression = -1;\n\n    iff->svx8_compression = -1;\n\n    iff->maud_bits = -1;\n\n    iff->maud_compression = -1;\n\n\n\n    while(!url_feof(pb)) {\n\n        uint64_t orig_pos;\n\n        int res;\n\n        const char *metadata_tag = NULL;\n\n        chunk_id = avio_rl32(pb);\n\n        data_size = avio_rb32(pb);\n\n        orig_pos = avio_tell(pb);\n\n\n\n        switch(chunk_id) {\n\n        case ID_VHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 14)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 12);\n\n            st->codec->sample_rate = avio_rb16(pb);\n\n            if (data_size >= 16) {\n\n                avio_skip(pb, 1);\n\n                iff->svx8_compression = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_MHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 32)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 4);\n\n            iff->maud_bits = avio_rb16(pb);\n\n            avio_skip(pb, 2);\n\n            num = avio_rb32(pb);\n\n            den = avio_rb16(pb);\n\n            if (!den)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 2);\n\n            st->codec->sample_rate = num / den;\n\n            st->codec->channels = avio_rb16(pb);\n\n            iff->maud_compression = avio_rb16(pb);\n\n            if (st->codec->channels == 1)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            else if (st->codec->channels == 2)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            break;\n\n\n\n        case ID_ABIT:\n\n        case ID_BODY:\n\n        case ID_DBOD:\n\n        case ID_MDAT:\n\n            iff->body_pos = avio_tell(pb);\n\n            iff->body_end = iff->body_pos + data_size;\n\n            iff->body_size = data_size;\n\n            break;\n\n\n\n        case ID_CHAN:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            if (avio_rb32(pb) < 6) {\n\n                st->codec->channels       = 1;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            } else {\n\n                st->codec->channels       = 2;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            }\n\n            break;\n\n\n\n        case ID_CAMG:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            screenmode                = avio_rb32(pb);\n\n            break;\n\n\n\n        case ID_CMAP:\n\n            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case ID_BMHD:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size <= 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            avio_skip(pb, 4); // x, y offset\n\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n\n            if (data_size >= 10)\n\n                masking                      = avio_r8(pb);\n\n            if (data_size >= 11)\n\n                iff->bitmap_compression      = avio_r8(pb);\n\n            if (data_size >= 14) {\n\n                avio_skip(pb, 1); // padding\n\n                transparency                 = avio_rb16(pb);\n\n            }\n\n            if (data_size >= 16) {\n\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_DPEL:\n\n            if (data_size < 4 || (data_size & 3))\n\n                return AVERROR_INVALIDDATA;\n\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n\n                return fmt_size;\n\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n\n            else {\n\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            break;\n\n\n\n        case ID_DGBL:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size < 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            iff->bitmap_compression          = avio_rb16(pb);\n\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n\n            st->codec->bits_per_coded_sample = 24;\n\n            break;\n\n\n\n        case ID_DLOC:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width  = avio_rb16(pb);\n\n            st->codec->height = avio_rb16(pb);\n\n            break;\n\n\n\n        case ID_TVDC:\n\n            if (data_size < sizeof(iff->tvdc))\n\n                return AVERROR_INVALIDDATA;\n\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n\n            if (res < 0)\n\n                return res;\n\n            break;\n\n\n\n        case ID_ANNO:\n\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n\n        case ID_NAME:      metadata_tag = \"title\";     break;\n\n        }\n\n\n\n        if (metadata_tag) {\n\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n\n                return res;\n\n            }\n\n        }\n\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n\n    }\n\n\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n\n\n    switch(st->codec->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n\n\n        if (st->codec->codec_tag == ID_16SV)\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n\n        else if (st->codec->codec_tag == ID_MAUD) {\n\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n\n            } else {\n\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            st->codec->bits_per_coded_sample =\n\n                av_get_bits_per_sample(st->codec->codec_id);\n\n\n\n            st->codec->block_align =\n\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n\n        } else {\n\n        switch (iff->svx8_compression) {\n\n        case COMP_NONE:\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n\n            break;\n\n        case COMP_FIB:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n\n            break;\n\n        case COMP_EXP:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n\n            return -1;\n\n        }\n\n        }\n\n\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        iff->bpp          = st->codec->bits_per_coded_sample;\n\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n\n            st->codec->bits_per_coded_sample = 24;\n\n        }\n\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n\n        iff->masking      = masking;\n\n        iff->transparency = transparency;\n\n\n\n        if (!st->codec->extradata) {\n\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n\n        buf = st->codec->extradata;\n\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n\n        bytestream_put_byte(&buf, iff->bpp);\n\n        bytestream_put_byte(&buf, iff->ham);\n\n        bytestream_put_byte(&buf, iff->flags);\n\n        bytestream_put_be16(&buf, iff->transparency);\n\n        bytestream_put_byte(&buf, iff->masking);\n\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 20917, "substitutes": {"s": ["settings", "sq", "ks", "south", "S", "src", "p", "sym", "ls", "sync", "sa", "se", "ses", "ds", "f", "sim", "fs", "ss", "si", "sc", "ts", "b", "v", "c", "spec", "ps", "sb", "storage", "e", "cs", "qs", "services", "sup", "es", "ops", "ssl", "gs", "sp", "su", "os", "sys", "t", "sf", "bs", "slice", "sl", "ns", "sg", "sv", "js"], "iff": ["IFF", "ii", "def", "pe", "fig", "uf", "img", "lf", "http", "buff", "co", "iol", "f", "ef", "sci", "coll", "aff", "tf", "xf", "feed", "bl", "ss", "gif", "fc", "ipl", "intel", "lab", "pp", "fw", "eff", "lp", "fl", "ind", "fp", "ref", "tif", "dist", "sup", "fi", "ff", "iffs", "pl", "qa", "pull", "diff", "imp", "upp", "ist", "ctx", "fx", "FF", "gz", "sf", "ctrl", "fb", "slice", "cmp", "lib", "cel", "work", "eb", "exec", "inc", "comp", "ext"], "pb": ["typ", "lb", "bm", "pd", "pa", "wb", "cv", "p", "prop", "bb", "jp", "platform", "verb", "queue", "ib", "uf", "lc", "db", "xb", "phrase", "cli", "proc", "pg", "pm", "parser", "dl", "pc", "uc", "bf", "b", "bh", "fc", "pp", "lab", "asm", "ub", "lp", "sb", "cb", "bp", "bps", "pt", "mb", "ab", " eb", "bos", "prot", "fp", "hub", "plugin", "pl", "summary", "ob", "bc", "bot", "PB", "rob", "api", "ctx", "ppa", "abb", "cpp", "gb", "pkg", "txt", "fb", "bs", "lib", "dp", "eb", "wp", "rb"], "st": ["nd", "inst", "sts", "kt", "part", "stage", "cl", "pe", "src", "lc", "fe", "sa", "se", "ft", "td", "ST", "cr", "fr", "start", "usc", "art", "St", "ss", "sc", "bl", "ct", "sth", "bt", "sw", "rest", "c", "stop", "sb", "ast", "pt", "l", "tmp", "sta", "nt", "std", "rd", "end", "str", "irst", "et", "est", "ist", "obj", "stab", "ost", "ust", "sp", "sd", "self", "t", "sf", "sl", "ld", "ste", "set", "sn"], "buf": ["wb", "cv", "alloc", "uf", "src", "queue", "block", "img", "buff", "buffer", "proc", "cmd", "len", "seq", "cb", "vec", "fd", "batch", "fp", "dest", "opt", "conv", "port", "cp", "rc", "ctx", "pool"], "chunk_id": ["chunk_sid", "chunks_sid", "chunk_name", "chunk_tag", "chunks_type", "chunkertag", "choy_info", "chunkerid", "chunks_ids", "choy_type", "chunkername", "chunkertype", "choy_id", "chunks_id", "chunk_type", "chunk_ids", "chunk_info"], "data_size": ["dataqlength", "dataqsize", "load_speed", "Data_size", "Data_speed", "load_weight", "message_offset", "messageqsize", "sample_data", "data_range", "messageqoffset", "data_address", "data___offset", " data_range", "data_loc", "data_offset", "dataqoffset", "data_scale", "sample_size", "data_weight", "messageqrate", "Data_scale", " data_name", "Data_length", "data_length", "data___size", "load_size", "message_length", "message_rate", "dataqrate", "data_speed", "data___length", "sample_scale", "sample_address", "data_data", "load_loc", "data___rate", "data_name", "messageqlength", "message_size", "data_rate"], "num": ["en", "lit", "mem", "block", "img", "bit", "name", "loc", "ord", "dim", "um", "nb", "mn", "len", "Num", "seq", "n", "con", "index", "bin", "mod", "sum", "nom", "tu", "col", "NUM", "uni", "off", "gen", "split", "data", "om", "id", "unit", "cmp", "un", "nu", "no", "inc", "umi"], "den": ["nd", "desc", " len", "def", "en", "nan", "val", "dim", "mode", "none", "mask", "len", "con", "err", "dev", "sum", "error", "ind", "ne", "diff", "done", "orig", "dy", "nc", "Den"], "fmt": ["fnt", " fflags", "frflags", "xfnt", "frmt", "frver", "frnt", " fnt", "xfver", "xfflags", "fver", " fver", "xfmt", "fflags"], "fmt_size": ["fformat_size", "fformat_len", "fmt_len", "fmt_capacity", "fformat_capacity", "fformat_scale", "fmt_scale"], "orig_pos": ["orig_post", "Orig_position", " orig_position", " orig_loc", " orig_len", "Orig_len", "orig_position", "Orig_post", "Orig_pos", "orig_len", "orig_loc"], "res": ["req", " rs", " rem", "Res", "val", " val", "Num", " seq", "seq", "con", "len", "RES", "reg", "ver", "r", "nt", "N", "rem", "NUM", "off", "gen", "rc", " rc", " vers", " ret", "no", " mem"], "metadata_tag": ["metadata_type", "metadata__tag", "metadata_loc", "meta_type", "meta_pos", "metadata__type", "metadata__loc", "metadata_pos", "meta_tag", "metadata__pos", "meta_loc"]}}
{"project": "FFmpeg", "commit_id": "f3ace37a3b8c93218630a37b7df4dc195f1215a9", "target": 1, "func": "static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n\n{\n\n    int err, i, dash = 0, result = 0, code_found = 0;\n\n    char buf[CONTROL_BUFFER_SIZE];\n\n    AVBPrint line_buffer;\n\n\n\n    if (line)\n\n        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    while (!code_found || dash) {\n\n        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n\n            av_bprint_finalize(&line_buffer, NULL);\n\n            return err;\n\n        }\n\n\n\n        av_log(s, AV_LOG_DEBUG, \"%s\\n\", buf);\n\n\n\n        if (strlen(buf) < 4)\n\n            continue;\n\n\n\n        err = 0;\n\n        for (i = 0; i < 3; ++i) {\n\n            if (buf[i] < '0' || buf[i] > '9')\n\n                continue;\n\n            err *= 10;\n\n            err += buf[i] - '0';\n\n        }\n\n        dash = !!(buf[3] == '-');\n\n\n\n        for (i = 0; response_codes[i]; ++i) {\n\n            if (err == response_codes[i]) {\n\n                if (line)\n\n                    av_bprintf(&line_buffer, \"%s\", buf);\n\n                code_found = 1;\n\n                result = err;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (line)\n\n        av_bprint_finalize(&line_buffer, line);\n\n    return result;\n\n}\n", "idx": 20918, "substitutes": {"s": ["sq", "south", "ks", "p", "sync", "sg", "se", "http", "us", "ses", "ds", "cli", "f", "ssh", "fs", "ss", "ts", "b", "sc", "v", "a", "c", "spec", "sb", "o", "e", "cs", "l", "r", "service", "session", "u", "sk", "qs", "es", "d", "ssl", "gs", "ctx", "m", "os", "t", "client", "sl", "ls", "ns", "g", "sv", "js"], "line": ["lines", "liner", "cl", "text", "parse", "lin", "row", "lc", "call", "sync", "LINE", "code", "link", "block", "buffer", "name", "frame", "db", "cli", "status", "force", "fail", "valid", "bug", "v", "len", "header", "base", "entry", "ine", "error", "nl", "lined", "e", "notice", "l", "user", "page", "result", "limit", "source", "str", "Line", "d", "url", "data", "id", "server", "file", " result", "cell", "comment"], "response_codes": ["responseXlines", "response_code", " response_items", "responseClines", "response_levels", "responseClevels", "responseercode", "response_items", "responseXlevels", "responseercells", " response_code", " response_strings", "responseercodes", " response_cells", "response_cells", "responseCitems", "responseXcodes", "response_errors", " response_values", "response_lines", "responseervalues", " response_levels", "response_strings", "responseXitems", " response_lines", "response_values", "responseererrors", "responseCcodes", " response_errors", "responseerstrings"], "err": ["req", "acer", "br", "ler", "ner", "ise", "gr", "runner", "doc", "mr", "iter", "fe", "phi", "code", "die", "type", "status", "msg", "extra", "md", "rage", "ie", "fr", "cr", "cur", "order", "rh", "ir", "sr", "init", "bug", "der", "next", "error", "rr", "Error", "ver", "style", "r", "ger", "message", "e", "ind", "nr", "result", "l", "kr", "str", "progress", "attr", "diff", "arr", "Er", "grade", "dr", "orig", "er", "lr", "dy", "spec", " Err", "comment", "inner", "var"], "i": ["ti", "ii", "ui", "ji", "qi", "iter", "x", "ix", "I", "p", "eni", "lc", "phi", "code", "di", "ri", "j", "info", "f", "ai", "cli", "ini", "oi", "ni", "ie", "si", "io", "b", "v", "a", "pi", "uri", "index", "n", "c", "o", "e", "y", "r", "l", "result", "xi", "u", "yi", "inner", "uni", "fi", "d", "li", "iu", "diff", "id", "m", "ci", "zi", "mi", "multi", "t", "gi", "z", "mu", "bi", "ip"], "buf": ["br", "box", "cv", "buffer", "proc", "seq", "cas", "ab", "pb", "ff", "bc", "data", "null", "pad", "fb", "bytes", "desc", " buffers", "doc", "src", "db", "Buff", "loc", "msg", "config", "bf", "cmd", "b", "header", "vec", "fd", "batch", "rc", "input", "map", "Buffer", "lines", "text", "wb", "font", "enc", "bo", "bb", "buff", "func", "uc", "ru", "output", "bag", "conv", "ctx", "rb", "cf", "uf", "queue", "block", " buffer", "code", "bd", "grab", "bh", "cb", "path", "result", "str", "port", "txt", "context"], "line_buffer": ["LINECdata", "link_reference", "link_writer", "lineAbuffer", "block_queue", "line_buff", "line___handler", "lin_header", "block_buff", "link_buff", "line___buffer", "line_length", "line_window", "block_buffer", "inline_length", "line_queue", "inline_reader", "line_reader", "line_buf", "line_writer", "lineCbuffer", "linkAbuff", "line_data", "lineacbuffer", "inline_buffer", "LINECresource", "lineacwindow", "line64data", "lineChandler", "lin_window", "lineAreference", "lineCwriter", "lineAbuff", "lineCresource", "block_buf", "line64handler", "line___data", "line___resource", "line_resource", "linkAreference", "LINE_data", "lineAwriter", "LINEChandler", "lineCreference", "line64buffer", "LINE_handler", "line_reference", "inline_queue", "link_buffer", "line64resource", "LINE_resource", "LINECbuffer", "linkAbuffer", "lin_cache", "lin_buffer", "LINE_buffer", "linkAwriter", "line_handler", "lineacheader", "lineCdata", "line_cache", "lineaccache", "lineCbuff", "line_header"]}}
{"project": "qemu", "commit_id": "26e92f65525ef4446a500d85e185cf78835922aa", "target": 0, "func": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)\n\n{\n\n    arm_sysctl_state *s = (arm_sysctl_state *)opaque;\n\n\n\n    switch (offset) {\n\n    case 0x00: /* ID */\n\n        return s->sys_id;\n\n    case 0x04: /* SW */\n\n        /* General purpose hardware switches.\n\n           We don't have a useful way of exposing these to the user.  */\n\n        return 0;\n\n    case 0x08: /* LED */\n\n        return s->leds;\n\n    case 0x20: /* LOCK */\n\n        return s->lockval;\n\n    case 0x0c: /* OSC0 */\n\n    case 0x10: /* OSC1 */\n\n    case 0x14: /* OSC2 */\n\n    case 0x18: /* OSC3 */\n\n    case 0x1c: /* OSC4 */\n\n    case 0x24: /* 100HZ */\n\n        /* ??? Implement these.  */\n\n        return 0;\n\n    case 0x28: /* CFGDATA1 */\n\n        return s->cfgdata1;\n\n    case 0x2c: /* CFGDATA2 */\n\n        return s->cfgdata2;\n\n    case 0x30: /* FLAGS */\n\n        return s->flags;\n\n    case 0x38: /* NVFLAGS */\n\n        return s->nvflags;\n\n    case 0x40: /* RESETCTL */\n\n        return s->resetlevel;\n\n    case 0x44: /* PCICTL */\n\n        return 1;\n\n    case 0x48: /* MCI */\n\n        return 0;\n\n    case 0x4c: /* FLASH */\n\n        return 0;\n\n    case 0x50: /* CLCD */\n\n        return 0x1000;\n\n    case 0x54: /* CLCDSER */\n\n        return 0;\n\n    case 0x58: /* BOOTCS */\n\n        return 0;\n\n    case 0x5c: /* 24MHz */\n\n        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());\n\n    case 0x60: /* MISC */\n\n        return 0;\n\n    case 0x84: /* PROCID0 */\n\n        /* ??? Don't know what the proper value for the core tile ID is.  */\n\n        return 0x02000000;\n\n    case 0x88: /* PROCID1 */\n\n        return 0xff000000;\n\n    case 0x64: /* DMAPSR0 */\n\n    case 0x68: /* DMAPSR1 */\n\n    case 0x6c: /* DMAPSR2 */\n\n    case 0x70: /* IOSEL */\n\n    case 0x74: /* PLDCTL */\n\n    case 0x80: /* BUSID */\n\n    case 0x8c: /* OSCRESET0 */\n\n    case 0x90: /* OSCRESET1 */\n\n    case 0x94: /* OSCRESET2 */\n\n    case 0x98: /* OSCRESET3 */\n\n    case 0x9c: /* OSCRESET4 */\n\n    case 0xc0: /* SYS_TEST_OSC0 */\n\n    case 0xc4: /* SYS_TEST_OSC1 */\n\n    case 0xc8: /* SYS_TEST_OSC2 */\n\n    case 0xcc: /* SYS_TEST_OSC3 */\n\n    case 0xd0: /* SYS_TEST_OSC4 */\n\n        return 0;\n\n    default:\n\n        printf (\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 20938, "substitutes": {"opaque": ["ipque", "plaque", "OPaque", "ipaque", "opque", "opacity", " opque", "opaco", "OPaco", "operaques", "ipaco", " opaco", " opacity", "operaco", " opaques", "ipaques", "OPaques", "OPacity", "operacity", "operaque", "plque", "plaques", "opaques", "placo"], "offset": ["timeout", "delay", "empty", "zero", "alloc", "reset", "sync", "location", "pointer", "buffer", "type", "address", "length", "Offset", "loc", "mode", "start", "len", "align", "index", "padding", "seed", "position", "base", "o", "slot", "entry", "error", "range", "alias", "fp", "ref", "size", "off", "port", "pos", "data", "seek", "ptr", "i", "null", "pad", "shift", "array", "number", "addr", "set", "prefix", "operation"], "s": ["ins", "states", "sets", "S", "sq", "lines", "w", "p", "sym", "ims", "sync", "als", "ors", "ed", "ows", "ments", "ses", "status", "f", "ds", "ches", "ions", "irs", "words", "ants", "fs", "ings", "ss", "ts", "its", "b", "a", "n", "c", "ps", "ances", "o", "sb", "e", "ing", "cs", "r", "l", "erences", "ports", "or", "session", "ies", "qs", "services", "es", "d", "ips", "instance", "ops", "outs", "ands", "scope", "itions", "gs", "i", "ers", "m", "os", "er", "eds", "ls"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_is_self(cpu)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    wi.free = false;\n\n    if (cpu->queued_work_first == NULL) {\n\n        cpu->queued_work_first = &wi;\n\n    } else {\n\n        cpu->queued_work_last->next = &wi;\n\n    }\n\n    cpu->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(cpu);\n\n    while (!wi.done) {\n\n        CPUState *self_cpu = current_cpu;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        current_cpu = self_cpu;\n\n    }\n\n}\n", "idx": 20945, "substitutes": {"cpu": ["nic", "chip", "cfg", "CPU", "gc", "cache", "pai", "lc", "cu", "current", "uci", "linux", "eni", "core", "css", "clock", "processor", "process", "cli", "proc", "config", "gpu", "roc", "pc", "computer", "vm", "cow", "fc", "mac", "osi", "c", "winner", "gru", "wei", "conn", "cycle", "fp", "hw", "auc", "lu", "fi", "np", "cp", "instance", "pu", "tc", "ctx", "cpp", "ci", "pkg", "cmp", "component", "custom", "nc", "loader", "node"], "func": ["mc", "loop", "task", "lambda", "cf", "full", "doc", "alloc", "src", "lc", "sync", "code", "cc", "co", "val", "name", "go", "word", "proc", "f", "apply", "pc", "cmd", "b", "fc", "mac", "callback", "seq", "c", "cb", "fun", "reg", "mod", "conn", "module", "fp", "super", "auc", "function", "wrap", "value", "conv", "unc", "worker", "bc", "wrapper", "job", "ctx", "sys", "work", "fn", "pkg", "fb", "custom", "nc", "exec", "package", "comp"], "data": ["ui", "lambda", "write", "du", "partial", "cache", "current", "DATA", "call", "block", "di", "val", "processor", "fail", "buffer", "proc", "results", "config", "na", "none", "start", "wa", "paid", "body", "media", "device", "fee", "callback", "next", "buf", "future", "parent", "base", "da", "dat", "wei", "draw", "args", "result", "key", "function", "lu", "value", "fi", "foo", "worker", "progress", "pos", "missing", "input", "one", "api", "ctx", "reader", "self", "multi", "work", "done", "Data", "last", "exec", "this", "new", "mu"], "wi": ["wic", " pci", "ti", "ui", "cfg", "wake", "ani", "wig", "wife", "Wi", "w", "wm", "gui", "eni", "di", "wl", "wiki", "ini", "wine", "ni", "wa", "wal", "ski", "hei", "fee", "wan", "ki", "kw", "wx", "WI", "lp", "wei", " wo", "wk", "hw", "xi", "iri", "nw", "yi", "lu", "ee", "fi", "iw", "hi", "mi", "ci", "wit", " wifi", "wid", "wo", "gi", "wu", "wy", "wp", " Wi", "bi", "mu"], "self_cpu": ["self__processor", "self_gpu", "self_clock", "self__cpu", " self_clock", "self_pu", " self_processor", " self_gpu", "self_processor", "self_lc", "self__gpu", "self__pu", " self_lc", " self_pu"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "double avpriv_strtod(char *restrict nptr, char **restrict endptr)\n\n{\n\n    char *end;\n\n    double res;\n\n\n\n    /* Skip leading spaces */\n\n    while (isspace(*nptr))\n\n        nptr++;\n\n\n\n    if (!av_strncasecmp(nptr, \"infinity\", 8)) {\n\n        end = nptr + 8;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"inf\", 3)) {\n\n        end = nptr + 3;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"nan\", 3)) {\n\n        end = check_nan_suffix(nptr + 3);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"+nan\", 4) ||\n\n               !av_strncasecmp(nptr, \"-nan\", 4)) {\n\n        end = check_nan_suffix(nptr + 4);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"0x\", 2) ||\n\n               !av_strncasecmp(nptr, \"-0x\", 3) ||\n\n               !av_strncasecmp(nptr, \"+0x\", 3)) {\n\n        /* FIXME this doesn't handle exponents, non-integers (float/double)\n\n         * and numbers too large for long long */\n\n        res = strtoll(nptr, &end, 16);\n\n    } else {\n\n        res = strtod(nptr, &end);\n\n    }\n\n\n\n    if (endptr)\n\n        *endptr = end;\n\n\n\n    return res;\n\n}\n", "idx": 20958, "substitutes": {"nptr": ["Nproc", "npeer", "necert", " ntr", "insth", "enproc", "ensth", "Nsth", "nojug", "inport", "nplug", "onpert", "npointer", "anpointer", "noproc", " nport", "nepert", "onstruct", "nnaddr", "nonptr", "nonstruct", "inpointer", "lpointer", "ntr", "Nwr", "uneger", " neger", "nefer", "ltr", "Npeer", "Npad", "nfp", "csth", "cptr", "naddr", "anplug", "lptr", "noprot", "lcert", "nport", "nctr", " naddr", "unpert", "unproc", "enpeer", "nejug", "nnctr", "nreq", " npointer", "naneger", "onptr", "inrust", " njug", "cpointer", "nrust", "Ndr", "unjug", "enplug", "inpad", "anpert", "neplug", "unprot", "unpad", " nproc", "noptr", "lpert", "npert", "nwr", "neger", " nwr", "Npert", " nctr", "nepointer", "inpert", "nanptr", "nnfp", "enPtr", "unport", "inplug", " nreq", "ncert", "Nplug", "njug", "cprot", "nanproc", "cstruct", "onwr", "enpad", "norust", "nonpointer", "nerust", "anptr", "onpointer", "enpert", "lreq", " nfp", "unptr", "nstruct", "unpointer", "onsth", "nopointer", "enreq", "unfer", "neproc", "unpeer", "enpointer", "ondr", "injug", "Naddr", "cpert", "nfer", "lpad", "nproc", "nonpert", "Npointer", "enstruct", "inptr", "nanpert", "npad", "nectr", " ndr", " nfer", " nPtr", "enptr", "nnptr", " npert", " nplug", "nsth", "nonsth", "noplug", "Nfp", "nPtr", " npeer", "cproc", "lproc", "nocert", "Nctr", "unPtr", "nostruct", "nnpointer", "nopert", "entr", "nprot", "unplug", " npad", "unstruct", "Nptr", " nstruct", "ndr", "neptr"], "endptr": ["endtr", "endproc", "adtr", "alltr", " endpointer", " endtr", "allpointer", "npointer", " endPtr", "endaddr", "startpointer", "startptr", "nPtr", "adpointer", "naddr", "adptr", "startPtr", "startproc", "endPtr", "adPtr", "endpointer", "allptr", "nproc", "startaddr", " endproc", " endaddr", "allPtr"], "end": ["END", "shape", "close", "p", "use", "End", "offset", "order", "eff", "range", "sum", "begin", "enable", "ff", "pos", "best", "add", "all", "inner", "ext", "get", "nd", "row", "en", "core", "address", "is", "n", "index", "rest", "e", "final", "size", "api", "id", "ad", "work", " End", "enter", "set", "update", "eval", "enc", "ac", "region", "ort", "pass", "init", "win", "ended", "c", "error", "r", "find", "run", "value", "ending", "es", "after", "est", "url", "edge", "stop", "it", "x", "ion", "and", "head", "max", "start", "next", "send", "result", "post", "append", "obj", "one", "mid", "last", "ent"], "res": [" Res", "req", "real", "gr", "x", "resp", "rs", "reset", "row", "css", "Res", "rss", "val", "ras", "rev", "region", "ret", "results", "max", "rx", "rh", "pass", "ress", "rows", "rel", "len", "rest", "feat", "RES", "err", "reg", "range", "sum", "cs", "ver", "resh", "r", "reed", "args", "result", "final", "out", "vals", "details", "str", "rez", "des", "re", "resolution", "arr", "scope", "obj", "os", "rus", "ms", "resource", "rec", "pres", "js"]}}
{"project": "FFmpeg", "commit_id": "b2a8850969b89151677253be4d99e0ba29212749", "target": 0, "func": "static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {\n\n    double time = av_gettime() / 1000000.0;\n\n    /* update current video pts */\n\n    is->video_current_pts = pts;\n\n    is->video_current_pts_drift = is->video_current_pts - time;\n\n    is->video_current_pos = pos;\n\n    is->frame_last_pts = pts;\n\n    check_external_clock_sync(is, is->video_current_pts);\n\n}\n", "idx": 20961, "substitutes": {"is": ["pick", "ii", "ui", "cms", "ins", "image", "iss", "isi", "css", "que", "us", "kit", "mis", "isc", "ri", "http", "ses", "info", "bis", "ai", "app", "s", "ie", "as", "Is", "fs", "ss", "init", "its", "sis", "lis", "state", "ar", "get", "serv", "cs", "was", "iris", "ics", "iso", "boot", "parts", "can", "ais", "IS", "es", "ops", "isu", "ic", "in", "isl", "i", "id", "os", "self", "js", "sys", "bs", "ois", "it", "ls", "has", "obs", "isa", "ip"], "pts": ["ntp", "ppp", "emptds", "ctd", "pst", "prt", "prs", "pps", "nttimes", "psd", "PTsets", "pgp", "ptds", "pgd", "PTs", "prd", "pptimes", "ptd", "pgtimes", "cts", "PTds", "emptsets", "ptsets", "ppd", "ntd", "pttimes", "ptp", "ntds", "pss", "nts", "ptt", "ntsets", "ctt", "empts", "pgs"], "pos": ["po", "neg", "time", "src", "pr", "pose", "pid", "block", "offset", "name", "loc", "val", "clock", "proc", "pc", "start", "pass", "oc", "up", "len", "seq", "position", "base", "pt", "min", "pres", "tz", "str", "cond", "port", "diff", "obj", "data", "Pos", "sp", "unit", "os", "sec", "op"], "serial": [" len", " port", " code", " sleep", " def", " dest", " dev", " disp", " packed", " cond", " vel", " error", " seq", " pack", " mode", " date", " prop", " cur", " alt", "port", " trans", " tag", "Pos", " z", " ref", " end", " neg", " ver"]}}
{"project": "qemu", "commit_id": "a659979328fb6d4d6100d398f5bd9a2310c3e169", "target": 0, "func": "open_f(int argc, char **argv)\n\n{\n\n\tint flags = 0;\n\n\tint readonly = 0;\n\n\tint growable = 0;\n\n\tint c;\n\n\n\n\twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 's':\n\n\t\t\tflags |= BDRV_O_SNAPSHOT;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\n\t\t\tflags |= BDRV_O_NOCACHE;\n\n\t\t\tbreak;\n\n\t\tcase 'r':\n\n\t\t\treadonly = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'g':\n\n\t\t\tgrowable = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&open_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (!readonly) {\n\n            flags |= BDRV_O_RDWR;\n\n        }\n\n\n\n\tif (optind != argc - 1)\n\n\t\treturn command_usage(&open_cmd);\n\n\n\n\treturn openfile(argv[optind], flags, growable);\n\n}\n", "idx": 20970, "substitutes": {"argv": ["argvs", " argvp", "docc", "argc", "genf", " argf", "argsv", " argp", "agc", "agvs", "incv", "incV", "argsc", " argc", "argp", " argvs", "docvp", "genp", "agp", "argf", "argV", "argsp", " argV", "docV", "incvp", "docv", "agv", "genv", "argsvs", "genvs", "argvp", "incc", "argsf"], "c": ["C", "mc", "dc", "cf", "cy", "x", "cl", "w", "xc", "p", "lc", "h", "enc", "cd", "code", "cc", "ac", "ce", "type", "f", "s", "cr", "pc", "cmd", "b", "v", "ct", "fc", "a", "n", "o", "e", "cs", "l", "r", "or", "ch", "opt", "arc", "d", "cp", "rc", " rc", "k", "i", "m", "ci", "t", "nc", "g", "z", "ec"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n", "idx": 20975, "substitutes": {"s": ["settings", "states", "S", "sq", "ks", "south", "rs", "secondary", "series", "p", "sym", "h", "sync", "site", "se", "ses", "ds", "f", "is", "fs", "ss", "si", "b", "sis", "ts", "its", "a", "state", "n", "c", "spec", "hs", "sie", "o", "sb", "ps", "e", "cs", "l", "service", "u", "services", "private", "es", "d", "ops", "ssl", "gs", "i", "self", "m", "sys", "os", "t", "conf", "su", "sl", "ls", "ns", "ms", "sv", "g", "sports", "js"], "buf": ["Buffer", "cf", "br", "cap", "text", "box", "cv", "cache", "uf", "alloc", "src", "queue", "bo", "block", "img", "cat", "bd", "buff", "fab", "buffer", "db", "config", "uc", "func", "cmd", "b", "bh", "seq", "bin", "cb", "cas", "vec", "ab", "fd", "aux", "fp", "result", "batch", "pb", "output", "cast", "bag", "ff", "port", "bc", "rc", "data", "ptr", "ctx", "pad", "fb", "array", "map", "context", "rb"], "event_code": ["event_size", "eventopcode", "eventercod", "resource_codes", "event_cycle", "resource_code", "eventalcod", " event_status", "resourcealsize", "event_key", "eventopstatus", "eventoptype", "event_count", "eventalcode", "event_status", "eventopcount", "eventalsize", "eventopcycle", "event_score", "eventalkey", "event_case", "event_type", "resourcealcodes", "resource_cod", " event_case", "eventercodes", "resourcealcode", "event_cod", "resource_size", "eventalstatus", "eventercode", "media_cycle", " event_count", "resourcealcod", "media_key", "event_codes", "eventalcodes", "eventalcount", "media_code", "eventopscore", "eventopcase", "media_score", "eventersize", "media_count", " event_type"], "media_status": ["photoalstats", "photo_status", "photo_rate", "resource_code", "image_speed", "media_stat", "photo_stats", "photo_stat", "mediaalstatus", "media_stats", "event_status", "image_status", "image_type", "photoalrate", "media_source", "mediaacstats", "media_result", "media_rate", "audio_settings", "mediafstat", "resource_stat", "event_type", "mediaacstat", "photoalstatus", "media_num", "event_stat", "mediafsettings", "event_stats", "audio_stat", "resource_result", "mediaalstat", "mediaalrate", "photoalstat", "mediafnum", "audio_status", "mediafstatus", "media_type", "media_settings", "media_code", "media_speed", "event_num", "mediaalstats", "image_source", "mediaacnum", "audio_sync", "media_sync", "resource_status", "mediafsync", "mediaacstatus", "mediafstats"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n", "idx": 20994, "substitutes": {"hotplug_dev": ["hotplug_conn", "hotplug_ev", "hotpack_div", "hotplug_conf", "hotlog_conf", "hotlog_def", "hotplug_def", "hotlog_ev", "hotplug_div", "hotpack_dev", "hotlog_dev", "hotplug_device", "hotpack_conn", "hotpack_device"], "dev": ["dm", "req", " device", "def", "ev", "w", "Dev", "p", "priv", " def", "di", "dim", "f", "info", "md", "driver", "DEV", "prom", " d", " dom", "device", "v", "der", "state", "err", "mod", "adv", "error", "ver", "engine", "conn", "ch", "sk", "dd", "d", "nov", "diff", "data", " Dev", "self", "conf", "development", "ow", " dw", "grad", "dem", "wd", "vd", "dom", "rad"], "errp": ["rrpre", "corp", "errr", "errpre", " errsp", "errlp", "rrp", "erP", "errorsp", "erpre", "errP", "rrP", "errorr", "errorP", " errP", "corP", "corr", "arypre", "rrlp", "errorp", "arylp", "erlp", "errsp", "corsp", "aryp", " errr", "erp", "aryP"], "vdev": ["wdevice", "lsd", "Vdiff", "vmdev", "nvdef", "Vdevice", " vdevice", "ldev", " vdiff", " vsd", "fde", " vdef", "ldevice", "fdevice", "wdev", "vdiff", "ldef", " vvar", "fdev", "nvdev", "Vvar", "vde", "wde", "vsd", "nvdevice", "vdevice", "Vdev", "Vde", "nvsd", "vmdiff", "vmdevice", "vdef", "vmvar", "vvar"], "s": ["S", "ks", "south", "sq", "w", "p", "ls", "sync", "i", "sa", "se", "ds", "ses", "f", "si", "ss", "b", "v", "n", "c", "spec", "ps", "sb", "o", "storage", "e", "cs", "r", "l", "service", "sk", "services", "sh", "es", "d", "ssl", "gs", "sp", "su", "os", "m", "t", "sys", "self", "server", "conf", "ns", "sl", "sg", "g", "sv", "sn", "js"], "sd": ["hd", "pd", "sam", "cd", "sa", "se", "di", "bd", "ed", "ds", "td", "dl", "md", "gd", "si", "ss", "sc", "dh", "df", "sb", "cs", "fd", "sk", "std", "sh", "dd", "d", "ci", "ad", "sf", "SD", "od", "vd", "sl", "sg", "ld", "sv", "sn"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,\n\n                                    SocketAddress *addr,\n\n                                    Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_connect_sync(ioc, addr);\n\n    fd = socket_connect(addr, NULL, NULL, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_connect_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_connect_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20996, "substitutes": {"ioc": ["uiOC", "iaoc", "tiocation", "iroc", "tioc", "iocation", "iooc", "uioc", "xiocl", "ciocl", "iiorp", "ioocol", "piorp", "atiocol", "uiocl", "tiocl", "iaocation", "iOC", "ioorp", "yioci", "uiroc", "sioc", "yioc", "iioc", "airoc", " iocl", "ciocation", "pioc", "atiroc", "piocation", "iocl", "piec", "siocation", "iocol", "iiocol", "atiocl", "ioci", "atiocation", "iorp", "xioc", "aiOC", "ciroc", "siec", "ioroc", "tiroc", "ioOC", "iiocl", "atiorp", " ioci", "aioc", "cioc", "ioocl", "iaec", "xioci", "yiocl", "iec", "siorp", "atioc", "aiocl", "iaorp"], "addr": ["adr", "ace", "kt", "alloc", "ea", "host", "arm", "ock", "ac", "rt", "ord", "offset", "address", "md", "ack", "start", "amp", "osi", "ar", "ast", "rr", "r", "conn", "amd", "ref", "rn", "ann", "layer", "attr", "url", "ptr", "afi", "eth", "dr", "oa", "ad", "pkg", "socket", "server", "add", "od", "wd", "Address", "ip"], "errp": ["corp", "errr", " errcp", "errc", " errps", "corcp", "errfp", "erP", "rP", "errP", "rfp", "rp", "errcp", "erfp", " errP", " errfp", "Erc", "err", "corfp", "Erp", "rr", "errorcp", "errq", "morer", "errorfp", "errps", "errorp", "errorq", "morec", " errc", "morep", "Erps", "Err", "corq", "moreps", " errr", "erp", " errq"], "fd": ["dc", "nd", "cf", "du", "hd", " fid", "pd", "fe", "flo", "pid", "cd", "draft", "dt", "lf", "bd", "db", "ln", "ds", "fail", "f", "md", "dl", "FD", "td", "fs", "bf", "gd", "fc", "fee", "len", "ct", "temp", "df", "c", "fw", "buf", "fun", "fff", "fen", "fl", "pipe", "handler", "fed", "conn", "fa", "fp", "connection", "dd", "cond", "fi", "xd", "d", "ff", "ffff", "sd", "fx", "fin", "fn", "dn", "sf", "fb", "socket", "dy", "wd", "vd", "ld", "fm"]}}
{"project": "FFmpeg", "commit_id": "e30b068ef79f604ff439418da07f7e2efd01d4ea", "target": 1, "func": "static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    /** when the frame data does not need to be concatenated, the input buffer\n        is resetted and additional bits from the previous frame are copyed\n        and skipped later so that a fast byte copy is possible */\n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);", "idx": 21007, "substitutes": {"s": ["ins", "p", "us", "se", "f", "si", "sb", "cs", "ops", "tests", "gs", "i", "vs", "this", "your", "sv", "aws", "core", "ses", "ds", "xs", "is", "b", "ts", "n", "ps", "hs", "sites", "e", "y", "args", "services", "os", "S", "ks", "w", "sym", "h", "its", "c", "l", "service", "qs", "es", "ctx", "m", "sys", "sl", "g", "new", "settings", "sets", "sq", "rs", "sync", "as", "fs", "ss", "o", "session", "uns", "in", "ssl", "su", "self", "ns", "ls", "sg", "ms", "js"], "gb": ["ym", "bm", "cfg", "lb", "gg", "ui", "tg", "gp", "gc", "gm", "uf", "bb", "gy", "bridge", "gam", "db", "buff", "buffer", "gnu", "bg", "gpu", "nb", "pc", "gal", "bf", "gd", "si", "b", "gin", "ges", "git", "gram", "game", "gt", "bin", "GB", "ga", "ub", "lab", "cb", "sb", "storage", "bp", "gru", "bps", "mb", "cgi", "kb", "hub", "pb", "boot", "py", "bc", "phy", "gs", "usb", "ctx", "abb", "og", "ged", "Gb", "fb", "gio", "g", "eb", "sg", "binary", "rb", "rg"], "len": ["il", "line", "lin", "lc", "en", "hl", "Len", "lit", "lf", "el", "lim", "ln", "val", "elt", "le", "length", "f", "lan", "dl", "ie", "lt", "bl", "lock", "rel", "n", "bin", "align", "lp", "base", "fun", "fl", "l", "conn", "offset", "limit", "span", "lang", "lu", "end", "size", "ll", "li", "pos", "data", "count", "lif", "ig", "fin", "ell", "la", "alt", "un", "dy", "lib", "lon", "sl", "ls", "z", "ld", "all"], "append": ["element", "update", "write", "att", "true", "text", "escape", "pend", "vert", "force", "fail", "nn", "app", "insert", "extra", "apply", "none", "flower", "callback", "ended", "next", "except", "adj", "send", "odd", "enable", "atten", "advert", "opp", "end", "post", "ending", "obj", "optional", "ppa", "pad", "replace", "push", "fake", "open", "add", "repeat", "all", "op"], "buflen": ["bufln", "buflender", "bufratten", " bullend", "buflened", "buwlen", "darblent", "bufrent", "darflener", " bullen", "bucessender", "bucessatten", " buflenn", "bullen", "buclenn", "buflend", "darflent", "bufrener", "bublent", "bublened", "buvelened", "darblener", "darflen", "bufrn", "Buflatten", "bublen", "bufren", "buflatten", "bucln", "Bufrn", "darblen", "darflened", "Buflen", "bucessn", "buflener", "bufrened", "buvelener", "buflenn", "bulln", "bullender", "buclen", "bufrender", " bulln", "buflent", "buwlend", "buclend", "bullatten", "bullend", "bucessen", "Bufrender", "Bufren", " bullenn", "buvelen", "bullenn", "Bufratten", "Bufln", "bublener", "buwln", "buwlenn", "buvelent", "darblened", "Buflender", " buflend", " bufln"]}}
{"project": "FFmpeg", "commit_id": "a55692a96099c40aabb25e1443890be99f9c845c", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012, "substitutes": {"w": ["writer", "wb", "wav", "tw", "aw", "wa", "RW", "wr", "temp", "kw", "wx", "sw", "fw", "we", "r", "hw", "window", "wrap", "wcs", "iw", "rw", "m", "ow", "cam", "g", "W", "wp"], "fmt_ctx": ["fmtfloc", "fmtfctx", "fMT_ctx", "fMT_loc", "fmt_cu", "fmt_coll", "frt_sci", "fmtfrx", "fMT_rx", "frt_ctx", "frt_cmp", "fmtfcontext", "fmt2cmp", "fmt_sci", "fmt2context", "frt_coll", "frt_context", "fMT_context", "fmt_cmp", "fmt_reader", "frt_reader", "fmt2sci", "fmt_loc", "fmt_context", "frt_cu", "fmt_rx", "fmt2ctx"], "interval": ["nerpol", "currupt", "interpoint", "curpoint", "intvals", "interv", "waral", "interver", "perv", "iterrupt", "interref", "intersrule", "INTERpol", "insever", "iterpol", "extpoint", " interrule", "intcol", "INTERval", "oververt", "irvals", "warval", "iterVAL", "perval", "Intercel", "extpol", "intersval", "extcal", "interpol", "perVAL", "overVAL", "interpre", "interrule", "INTERsection", "interscel", "pervert", " interal", "extVAL", "intervol", " interver", "overval", "intcel", "iterchange", " intercol", "intercel", "sural", "intercal", "infver", "intval", "infvol", "INTERv", "warpol", "intervals", "overpol", "nerval", "insesection", "intervert", "Interrule", " interpol", "Intervals", "warruction", " intercel", "interal", "intersection", " interpre", "intercol", "extchange", "INTERcal", "infpol", "INTERVAL", "nerVAL", " interruction", "interchange", "ircol", "Interval", "iterpre", "infval", "extvert", "extrupt", "ircel", "extsection", "iterver", "itervol", "iterval", " intervals", "curval", "surpol", "INTERpre", " interref", "INTERver", "interVAL", "irval", "perref", "inseVAL", "nerver", "surruction", "inseval", "insecal", "surval", "INTERref", "insepre", "extval", " intervol", " interv", "iterpoint", "interruction", "curchange", "perpol", "interrupt", "intersvals", "perpre"], "cur_ts": ["cur_times", "curLtimes", "cur_values", " cur_qs", " cur_uts", "rc\n", "cur_qs", "cur_ats", "cur_steps", " cur_values", "cur_ds", "cur_TS", "Cur\n", " cur_TS", " cur\n", "cur8ts", " cur_times", "cur8TS", "Cur_ts", "cur2ts", "Cur_TS", "curLvalues", "curGtimes", "cur8times", " cur_ds", " cur_ats", "cur2times", "curGqs", "curGats", "curGts", "cur2TS", "cur2steps", "Cur_steps", "curLts", "cur\n", "curLds", "Cur_times", "cur_uts", "cur8uts"], "pkt": ["bct", "Pqt", " packet", "pelt", " pet", "Pelt", "Pwk", " pwk", "opkt", "promkt", "opmt", "opct", "packet", "Pct", "Pmt", "Pkt", "celt", "ckt", "fkt", "pqt", "cpct", "cpkt", "cpacket", "cpmt", "Pett", "facket", "fet", "pmt", "Packet", " pett", " pct", "Psth", "cpsth", "backet", "fct", "opacket", "bsth", "psth", "cpet", "cacket", "Pet", "promett", "bkt", "pct", "cwk", "promct", "promacket", "fqt", "pet", "pwk", " pqt", "pett", " pelt"], "pkt1": [" pqt1", "pct2", "packet2", "pqt2", "packet1", "pkt2", " pqt2", "pct1", "pqt1", " pkt2"], "frame": ["trace", "part", "ace", "image", "parse", "event", "p", "call", "block", "buffer", "val", "ret", "f", "object", "fr", "lock", "state", "seq", "view", "thread", "parent", "feat", "range", "sequence", "e", "Frame", "flow", "result", "window", "session", "fat", "boot", "point", "fi", "data", "dr", "live", "slice", "feature", "fram"], "target": ["global", "timeout", "match", "iter", " offset", "reset", "test", "current", " next", "ault", "core", "arget", "cat", "offset", "date", "pointer", "buffer", "ret", "address", "valid", "net", "object", "expected", "ARGET", "start", "gap", "pattern", "goal", "rel", "blank", "gt", "next", "transform", "parent", "feat", "base", "path", "range", "conn", " Target", "root", "nt", "result", "window", "session", "format", "limit", "output", "dest", "source", "value", "end", "point", "port", "qa", "weight", "data", "ctx", "alt", "arg", "top", " ret", "token", "client", "Target", "tag", " result", "master", "project", "ip"], "frame_count": ["block___counter", "block_count", "block___id", "block_id", "block___count", "frame2count", "block_counter", "block___weight", "frame_weight", "frame___id", "block_weight", "frame___counter", "frame2counter", "frame2id", "frame___weight", "frame2weight", "frame_id", "frame_counter", "frame___count"], "i": ["ti", "ii", "timeout", "I", "p", "num", "j", "info", "f", "ai", "ni", "si", "io", "len", "index", "c", "ind", "fi", "at", "id", "mi", "ci", "multi", "t", "slice", "it", "ip"], "stream_index": ["stream_number", "streamityint", "streamityposition", "streamingconfig", "wave_index", "streamishupdate", "wave_position", "streamishposition", "stream_int", "stream_config", " stream_config", " streamingindex", "streamitycondition", "streamalcondition", "streamingnumber", " streamingint", "streamitynumber", "streamingindex", "stream_update", "wavealcondition", "streamalposition", " stream_int", "stream_condition", "wavealindex", " streamingnumber", "wavealupdate", "streamityupdate", "streamingint", "streamalindex", "streamityconfig", "wave_condition", " streamingconfig", " stream_number", "streamishindex", "streamityindex", "streamalupdate", "streamishcondition", "wave_update", "wavealposition", "stream_position"]}}
{"project": "FFmpeg", "commit_id": "d32547a24a3fcc8286b318353f43805838b84775", "target": 1, "func": "int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx,\n                                             uint8_t *buf, int buf_size,\n                                             const short *samples)\n{\n    AVPacket pkt;\n    AVFrame *frame;\n    int ret, samples_size, got_packet;\n    av_init_packet(&pkt);\n    pkt.data = buf;\n    pkt.size = buf_size;\n    if (samples) {\n        frame = av_frame_alloc();\n        if (!frame)\n            return AVERROR(ENOMEM);\n        if (avctx->frame_size) {\n            frame->nb_samples = avctx->frame_size;\n        } else {\n            /* if frame_size is not set, the number of samples must be\n             * calculated from the buffer size */\n            int64_t nb_samples;\n            if (!av_get_bits_per_sample(avctx->codec_id)) {\n                av_log(avctx, AV_LOG_ERROR, \"avcodec_encode_audio() does not \"\n                                            \"support this codec\\n\");\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            nb_samples = (int64_t)buf_size * 8 /\n                         (av_get_bits_per_sample(avctx->codec_id) *\n                          avctx->channels);\n            if (nb_samples >= INT_MAX) {\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            frame->nb_samples = nb_samples;\n        }\n        /* it is assumed that the samples buffer is large enough based on the\n         * relevant parameters */\n        samples_size = av_samples_get_buffer_size(NULL, avctx->channels,\n                                                  frame->nb_samples,\n                                                  avctx->sample_fmt, 1);\n        if ((ret = avcodec_fill_audio_frame(frame, avctx->channels,\n                                            avctx->sample_fmt,\n                                            (const uint8_t *)samples,\n                                            samples_size, 1)) < 0) {\n            av_frame_free(&frame);\n            return ret;\n        }\n        /* fabricate frame pts from sample count.\n         * this is needed because the avcodec_encode_audio() API does not have\n         * a way for the user to provide pts */\n        if (avctx->sample_rate && avctx->time_base.num)\n            frame->pts = ff_samples_to_time_base(avctx,\n                                                 avctx->internal->sample_count);\n        else\n            frame->pts = AV_NOPTS_VALUE;\n        avctx->internal->sample_count += frame->nb_samples;\n    } else {\n        frame = NULL;\n    }\n    got_packet = 0;\n    ret = avcodec_encode_audio2(avctx, &pkt, frame, &got_packet);\n    if (!ret && got_packet && avctx->coded_frame) {\n        avctx->coded_frame->pts       = pkt.pts;\n        avctx->coded_frame->key_frame = !!(pkt.flags & AV_PKT_FLAG_KEY);\n    }\n    /* free any side data since we cannot return it */\n    av_packet_free_side_data(&pkt);\n    if (frame && frame->extended_data != frame->data)\n        av_freep(&frame->extended_data);\n    av_frame_free(&frame);\n    return ret ? ret : pkt.size;\n}", "idx": 21030, "substitutes": {"avctx": ["avalctx", "avalcomponent", "airctx", "evcmp", " avpkg", "navcmp", "avectx", "avekb", "afhw", " avcu", "avalsys", " avcf", "airxc", "navcn", "alcontext", "afconfig", "afcci", "avecu", "avsupport", "avsys", "navctx", "avetx", "abcmp", "avalcontext", "avcn", "alcu", "avecmp", "vercu", "avalconn", "avctrl", "avcontext", "afcca", " avcmp", "verconn", "varctx", "afct", " avct", "afcomponent", "varcontext", "avevoc", "vercontext", "avvoc", "afkb", "navhw", "aircontext", " avsys", "evcontext", "abcontext", "avalcca", "afcontext", "verxc", "avecn", "afsys", "avepkg", "avconfig", "afctrl", "aftx", "avkb", "afxc", "avbuff", "avecontext", "altx", "avcu", "aveconfig", " avcci", " avxc", "afconn", " avcca", "avcmp", "avhw", "avxc", "avehw", "afvoc", "avect", "afsupport", "afcf", "avcomponent", "avalkb", "evcomponent", "afcp", "avct", "avalconfig", "afcn", "avecci", "avcp", "vercf", "airsupport", "afcmp", "avalxc", "navcontext", "afpkg", "avecf", "avtx", "verctrl", "avebuff", "verctx", "varbuff", "avalvoc", "avalcmp", "avpkg", "afcu", "avconn", "avalsupport", "avcci", "evctx", "alctx", "abcp", "afbuff", "navcp", " avctrl", "abctx", " avcontext", "avecca", "afctx", "avcf", "avexc", "avcca", "aveconn", "varcca", "verconfig"], "buf": ["Buffer", "br", "cv", "uf", "alloc", "src", "wav", "queue", "mem", "block", "img", "bd", "buff", "buffer", "Buff", "config", "bf", "cmd", "b", "seq", "cb", "base", "vec", "fd", "tmp", "batch", "fp", "window", "pb", "bag", "conv", "bc", "rc", "data", "ctx", "pad", "fb", "array", "pool"], "buf_size": ["bufallsize", "buflexsize", "cmd_count", "window_sized", "uf_count", "cmd_start", "buf_number", "bufallstart", "window_cap", "windowlexsized", "buf_start", "buflexsized", "cmd_address", "bufallcount", "windowlexnumber", "buf_scale", "uf_scale", "window_number", "buf128size", "buf_cap", "buf_address", "buflexcap", "buf_sized", "uf_size", "buf128count", "buflexnumber", "cmd_size", "window_size", "windowlexsize", "buf128scale", "buf_count", "bufalladdress", "windowlexcap"], "samples": ["Siblings", "samps", "solutions", "famps", "Sample", "psample", "fample", "gsamp", "insiblings", "servicesamps", "gsamples", "sample", "pspaces", "Sessions", "Spaces", "psiblings", "Samples", "namp", "famp", "psamples", "Samps", "siblings", "namples", "gsamps", "insample", "namps", "sessions", "servicesessions", "nample", "spaces", "inspaces", "samp", "insamples", "Solutions", "servicesamples", "famples", "gsample", "servicesolutions"], "pkt": [" pck", "cpck", "Pkg", " packet", " pet", "PKT", " pkg", "apKT", "packet", "Pct", " pKT", "Pkt", "Pck", "cpkt", "cpct", "apck", "cpacket", "apacket", "apet", "Packet", " pct", "apkg", "Pet", "pkg", "pct", "pet", "apkt", "pck", "pKT"], "frame": ["line", "interface", "class", "figure", "buffer", "f", "hide", "game", "hop", "view", "feat", "base", "range", "cycle", "module", "window", "ze", "function", "data", "fb", "component", "part", "setup", "event", "row", "section", "call", "rame", "loc", "ce", "config", "fr", "parent", "framework", "flow", "point", "qa", "model", "target", "fake", "slice", "dy", "element", "update", "property", "parse", "fe", "flo", "host", "pse", "za", "feed", "bug", "html", "state", "df", "thread", "build", "style", "Frame", "fi", "fx", "live", "file", "flower", "fram", "node", "zip", "ace", "cf", "image", "iframe", "block", "code", "fab", "load", "object", "coll", "document", "request", "body", "lock", "motion", "up", "scale", "position", "tick", "fen", "play", "session", "boot", "fam", "layer", "video", "frames", "feature", "scene"], "ret": ["desc", "part", "att", "match", "def", "resp", "res", "class", "rets", "al", "lit", "en", "cat", "rt", "val", "bit", "buffer", "ft", "info", "det", "valid", "RET", "len", "back", "fun", "reg", "result", "nt", "ref", "final", "std", "reply", "rc", "flag", "re", "data", "id", "alt", "fin", "arg", "success", "Ret", "sid", "addr", "rep", "let", "it"], "samples_size": ["samples_ize", "samples_value", "samples_min", "samples_length", "samples_speed", "samples_scale", "samples_needed"], "got_packet": ["got_compet", "got_compacket", "got_sexacket", "buffer", "_", "length", "func", "got_bucket", "feed", "got_sexett", "got_buckacket", "seq", "c", "got_compets", "got_packacket", "got_sexet", "function", "got_buckett", "got_packets", "got_buckets", "got_compett", "got_packett", "array", "got_sexets", "this", "all", "bytes"], "nb_samples": ["nb_compills", "nb_examples", "nb_sqamples", "nb__seamples", "nb_svims", "nb_samps", "nb_eventsents", "nb_dsamples", "nb_usizes", "nb_assumes", "nb_psones", "nb67siblings", "nb_svocks", "nb_jsents", "nb_sesourses", "nb_servicesamples", "nb_seources", "nb67samples", "nb_csances", "nb_exores", "nb_suamples", "nb_inamples", "nb67servicesamps", "nb_compamples", "nb_csamples", "nb_namps", "nb67samps", "nb_sances", "nb_suounds", "nb_ssizes", "nb_psances", "nb_inients", "nb__seents", "nb_jsources", "nb64psores", "nb67servicesamples", "nb67servicesiblings", "nb_sucks", "nb_sesamps", "nb_sists", "nb_dsucks", "nb_csumes", "nb_servicesamps", "nb_simocks", "nb67sourses", "nb__siblings", "nb64psamples", "nb67servicesourses", "nb_sims", "nb_sills", "nb_jsiblings", "nb_sesiblings", "nb_usills", "nb_assists", "nb_seamples", "nb_usounds", "nb_sients", "nb_svucks", "nb_seiblings", "nb_sesamples", "nb_eventsiblings", "nb_nances", "nb_nones", "nb_exones", "nb_ssamples", "nb_examps", "nb_sones", "nb_sources", "nb_assamples", "nb_sizes", "nb64samples", "nb_siblings", "nb_assances", "nb_namples", "nb_simamples", "nb_eventsources", "nb_socks", "nb__sents", "nb_damples", "nb_eventsamples", "nb_jsamples", "nb__seiblings", "nb_sqizes", "nb_sents", "nb_psamples", "nb_seents", "nb64samps", "nb_sounds", "nb_donents", "nb_psists", "nb_simucks", "nb_nores", "nb_sqamps", "nb64sones", "nb_nients", "nb_servicesiblings", "nb_compounds", "nb__seources", "nb__sources", "nb64sores", "nb_servicesourses", "nb_simims", "nb64psones", "nb_ssonents", "nb_compizes", "nb_suances", "nb_ssourses", "nb_inances", "nb_usamples", "nb_ssiblings", "nb_dsims", "nb_sqonents", "nb_suills", "nb_suients", "nb_psamps", "nb64psamps", "nb_ssamps", "nb_psumes", "nb_damps", "nb_dizes", "nb_dsocks", "nb_sourses", "nb_sonents", "nb_svamples", "nb_suizes", "nb_sumes", "nb_csists", "nb_sores", "nb_psores", "nb__samples"]}}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n", "idx": 21034, "substitutes": {"function": ["class", "version", "section", "call", "code", "name", "word", "variable", "f", "length", "object", "func", "document", "family", "Function", "math", "parent", "library", "fun", "python", "handler", "cycle", "module", "filename", "format", "letter", "value", "size", "functional", "command", "unc", "expression", "unit", "fn", "array", "number", "program", "file", "feature", "package", "resource", "operation"], "count": ["Count", "loop", "time", "cache", "test", "call", "code", "use", "num", "depth", "name", "val", "process", "type", "length", "f", "counter", "config", "max", "coll", "start", "len", "fold", "seq", "index", "c", "base", "error", "cycle", "col", "size", "child", "id", "score", "number", "array", "file", "context", "repeat"], "eax": ["eaz", "eap", "peas", " eap", "peax", "eeaz", "ead", "eae", "Eau", "fae", "ebad", " eaz", "peae", "ieaz", " ease", "eau", "ebap", "Eae", "Ead", " ead", "Eex", "eix", "eeax", "eease", "Eap", "ieax", " eix", "ebax", "iease", "peau", "fax", "fau", "eas", "eeix", "fas", "ebex", "Eas", "ease", "eex", " eex", "ieix", "Eax"], "ebx": ["efc", "ibb", "ecid", "evy", "efX", "eedc", "eedX", "ecy", "evz", "ebz", "egid", "ibX", "egX", "eedx", "ebb", "ecz", "ibp", "ebp", "egx", "ebX", "ecc", "efx", "ecb", "efax", "iby", "eedax", "evx", "ecX", "evb", "ebid", "ibid", "ibx", "eby", "ecp", "ebax", "ecax", "ibz", "ebc", "egp"], "ecx": ["efc", "ecf", "ecy", "ec", "eqx", "ebxx", "ebe", "ex", "ebb", "ef", "egx", "egf", "ecxx", "ep", "exxx", "ebX", "ecc", "eff", "efx", "ecb", "efb", "efp", "exe", "eqX", "eqe", "ecX", "emc", "exx", "emy", "emb", "efy", "eby", "egc", "emx", "ece", "eqxx", "ecp", "ebc", "exX", "egp"], "edx": ["edax", "aedex", "aedz", "edp", "nedc", "aidz", "odex", "gedp", "edy", " edy", "pedx", "nedex", "aidy", "nedax", "gedc", "pedz", "gedx", "sdp", "odx", "aidex", "endedax", "edc", "edex", "sdz", "nedx", "endedx", "odax", "aidx", "pedp", "sdx", " edz", "pedc", "gedz", "aedx", " edex", "endedex", "sdc", "endedc", "aedy", "edz", "odc"], "vec": ["script", "time", "expr", "req", "xy", "nv", "lc", "buffer", "proc", "vr", "seq", "cer", "feat", "winner", "fun", "cs", "cycle", "window", "opt", "vals", "bc", "soc", "data", "uint", "score", "term", "binary", "sv", "ec", "var", "bytes", "kt", "crit", "iv", "version", "depth", "val", "name", "ef", "uv", "index", "flat", "entry", "filename", "life", "arr", "id", "array", "voc", "digit", "serv", "contin", "factor", "text", "vert", "word", "length", "func", "chrom", "v", "cod", "later", "nec", "ctx", "unit", "vector", "cube", "file", "op", "cf", "fit", "vor", "zero", "verb", "pointer", "variable", "frame", "coll", "buf", "sequence", "ver", "prev", "ctr", "vp", "str", "json", "video", "coord", "editor", "vc", "fn", "list", "vre", "feature", "context", "this", "js"]}}
{"project": "FFmpeg", "commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "target": 1, "func": "static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,\n\n                           int flags)\n\n{\n\n    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n", "idx": 21037, "substitutes": {"ctx": ["support", "kt", "cms", "cf", "sq", "setup", "cv", "xc", "lc", "cc", "loc", "cli", "config", "sci", "anc", "cmd", "sc", "kw", "wx", "utils", "c", "fw", "ck", "cb", "cas", "ca", "cs", "tx", "conn", "kb", "fp", "cm", "conv", "wcs", "qa", "bc", "cp", "rc", "cca", "vc", "ci", "pkg", "txt", "cmp", "ctrl", "client", "nc", "context", "cn", "cam", "ann"], "dst": ["Dst", "Dist", " dstack", "pst", " drest", "Dust", "adst", "wust", "dsst", "pdsts", "sdsts", "pdsc", "adost", "dnstream", "dost", "dput", "nist", "sdste", "nste", "DST", "drest", " dste", "dsp", "fdsc", "wst", "dust", "dST", "adST", "idste", "nst", "pdstack", "psc", "idsts", " dsts", "sdsc", "pdst", "fdstream", "dsost", "dnst", "Dsc", "dstack", "Dstack", "Dput", " dost", "nsts", "dnsts", " dstream", " dsc", "Drest", "dsc", "idput", "dnsc", "dist", "dsts", "fdsp", "dnsp", "wput", "dsST", "dssc", "sdst", "pST", "idist", " dsp", "idst", "dste", "dstream", "Dste", "dnost", "Dsts", "dnrest", " dST", "adsc", "idust", "post", "wsts", "fdst", "Dost"], "src": ["RC", "inst", "st", "support", "req", "sq", "rin", "setup", "cv", "reflect", "sync", "img", "loc", "proc", "roc", "sr", "cur", "uc", "func", "sc", "scl", "sth", "stream", "buf", "sub", "cb", "sb", "storage", "pb", "dest", "sel", "source", "sup", "sur", "conv", "bc", "impl", "rob", "rc", "ssl", "ptr", "gb", "bs", "sl", "rl", "scene", "rb", "sn"], "flags": ["settings", "lines", "limits", "options", "ats", "lf", "xs", "planes", "types", "stats", "ants", "fs", "faces", "mask", "links", "files", "utils", "styles", "lag", "bits", "fl", "nl", "Flags", "args", "locks", "fd", "ports", "fps", "format", "vals", "details", "fi", "features", "ops", "atts", "ips", "flag", "FLAG", "frames", "fields", "ns", "ints", "properties", "alls"], "surface": ["desc", "cover", "ample", "FACE", "sym", "reflect", "area", "sea", "sa", "aster", "sample", "sr", "cur", "sc", "faces", "sheet", "material", "metadata", "tile", "sta", "filename", "source", "sur", "port", "layer", "dra", "data", "slave", "ptr", "texture", "pad", "face", "rect", " Surface", "sf", "ser", "slice", "scene", "package", "master", "skin", "save"], "map": ["zip", "bm", "cap", "shape", "cover", "image", "match", "create", "cache", "test", "bridge", "mem", "block", "code", "img", "ge", "co", "plane", "mage", "address", "pack", "app", "wave", "msg", "tool", "aster", "apper", "lock", "mask", "mp", "move", "change", "per", "scale", "ape", "tile", "module", "sh", "rule", "Map", "pl", "port", "data", "scope", "arr", "m", "pad", "replace", "maps", "work", "mi", "ap", "file", "addr", "node", "master", "mg", "save", "MAP"], "surfaceDesc": ["surfaceStruct", "faceDes", "sourceDes", "sourceDescription", "sourceDesc", "sourcedesc", "faceDescription", "surfaceInfo", "faceInfo", " SurfaceDescription", " SurfaceStruct", " surfaceDescription", "facedesc", "surfaceDes", " SurfaceDesc", "surfacedesc", " Surfacedesc", " surfacedesc", " surfaceStruct", "faceDesc", " SurfaceInfo", "surfaceDescription", "sourceStruct", " surfaceInfo", " surfaceDes"], "LockedRect": [" LockedRECT", "LockRECT", "LockerRECT", "LockerText", "LlockedRect", "BlockedRECT", "LockingText", " Lockedrect", "Lockingrect", "LockerRect", "LockedText", "LockingRECT", "LockedBox", "BlockingRECT", "IlotedRECT", "IlotedText", "IlockedBox", "LlockedRECT", "SlockingRECT", "Lockrect", "LiedRect", "SlockedRect", "LockingRect", "LotedBox", "LockedRECT", " LockingRECT", "IlockedText", "LrictedBox", "LrictedText", "Slockedrect", "Llockedrect", "Blockingrect", "LotedText", "Lockerrect", "LotedRECT", "IlockedRect", "Blockedrect", "SlockingRect", "Lippedrect", "LlockedText", " LockingText", "Slockingrect", "Liedrect", "LrictedRECT", "LrictedRect", " Lockingrect", "LockRect", "LotedRect", " LockingRect", "IlotedBox", "BlockingRect", "BlockedRect", "IlotedRect", "LockingBox", "LiedRECT", "SlockedRECT", "LippedRect", "LippedRECT", "Lockedrect", " LockedText", "IlockedRECT"], "hr": ["req", "br", "HR", "gr", "rs", "mr", "rin", "cv", "h", "p", "fe", "hl", "pr", "code", "img", "her", "ih", "f", "ocr", "s", "fr", "sr", "rx", "rh", "ir", "roc", "cr", "RR", "hei", "yr", "vr", "a", "wr", "ar", "e", "rr", "resh", "r", "kr", "hour", "ride", "ref", "ctr", "rd", "str", "tr", "pull", "rc", "ig", "arr", "dr", "er", "lr", "shr", "g", "sl", "rec", "ec", "rg"], "i": ["ti", "ii", "ui", "ani", "qi", "line", "x", "I", "ix", "p", "eni", "h", "phi", "code", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ni", "ie", "start", "io", "si", "b", "v", "pi", "n", "index", "uri", "c", "uli", "ind", "e", "y", "r", "l", "adi", "xi", "u", "fi", "d", "layer", "iu", "li", "ik", "id", "zi", "ci", "mi", "multi", "t", "k", "gi", "ori", "it", "ip"], "err": ["req", "try", "delay", "ler", "br", "ner", "gr", "iter", "mr", "resp", "cache", "test", "arm", "code", "rar", "loc", "rage", "magic", "fr", "sr", "rh", "ir", "init", "bug", "yr", "der", "len", "ar", "cb", "error", "ind", "ver", "rr", "nr", "min", "r", "kr", "user", "or", "ctr", "str", "fi", "attr", "arr", "Er", "dr", "er", "dy", "act", "inner"], "nb_planes": ["ln_levels", "lnOflevels", "nb_liners", "npxframes", "nb_bands", "nb__planes", "npxplates", "ln_bands", "nb_rows", "num_bands", "nb_views", "nbxframes", "nballplanes", "nbxplates", "np_rows", "ln_planes", "nballplates", "nbOfbands", "nb_levels", "ln_views", "lnOfplanes", "nbOfplanes", "lnOfbands", "nballframes", "np_frames", "npxplanes", "nb__plates", "nbxviews", "lnOfviews", "nb__rows", "nballrows", "nb__frames", "nbOflevels", "nb_frames", "nbOfviews", "nbxbands", "num_liners", "nb_plates", "num_frames", "nbxlevels", "np_planes", "np_plates", "nbxrows", "npxrows", "nbxplanes", "num_planes"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n", "idx": 21050, "substitutes": {"prog": ["pue", "proG", "proe", " proge", "puge", " proG", " progs", " proe", "proc", "progen", "pregs", " progen", "prec", "Progs", "pregg", "progg", "ProG", "Proge", " proc", "preG", "Proe", "Progg", "pug", "preg", "Prog", " progg", "Proc", "pugen", "proge", "progs", "Progen"], "po": ["aco", "PO", "aa", "pe", "pa", "oe", "p", "pr", "jo", "flo", "bo", "co", "mo", "obo", "go", "pc", "io", "so", "oo", "pp", "pi", "oda", "ps", "o", "da", "ppo", "pri", "Po", "va", "zone", "py", "pre", "ee", "li", "qa", "pos", "obj", "cho", "ote", "vo", "ppa", "apo", "oa", "ao", "os", "lo", "la", "wo", "ko", "odo", "no", "yo", "op"], "i": ["ti", "ii", "ui", "qi", "x", "I", "ix", "p", "phi", "di", "ri", "j", "cli", "f", "ai", "type", "info", "ini", "oi", "ni", "ie", "si", "hei", "b", "io", "v", "a", "pi", "n", "index", "uri", "c", "o", "e", "l", "xi", "u", "yi", "fi", "d", "li", "in", "pos", "iu", "api", "split", "mini", "hi", "id", "zi", "ci", "mi", "multi", "slice", "gi", "ori", "z", "bi", "it", "ip"], "expert": ["expvert", "exparent", "expect", "EXpert", "exester", "xert", "auxpert", "xconfig", "extpect", " exparent", "sexpect", "Exconfig", " exert", "EXvert", "sexvert", "extpert", "EXtern", "Expert", " exconfig", "xester", "auxpret", "Exparent", "exvert", "sexpret", "expret", "extvert", "Exert", "exert", "extpret", "xparent", "sexpert", "auxpect", "auxvert", "EXester", "xpert", "exptern", "exppert", "xvert", "expester", "xtern", "exconfig"], "buf": ["ha", "Buffer", "desc", "home", "cap", "br", "cf", "text", "wb", "cv", "box", "uf", "alloc", "font", "src", "queue", "lit", "block", " buffer", "img", "cat", "buff", "buffer", "Buff", "fab", "bd", "proc", "loc", "uc", "cmd", "b", "border", "seq", "fw", "feat", "cb", "path", "vec", "begin", "cas", "fd", "aux", "fp", "auc", "str", "bag", "fi", "bc", "rc", "ctx", "la", "fb", "binary", "rb", "prefix", "pool", "utf"]}}
{"project": "FFmpeg", "commit_id": "b8a2331a70b720e83e1be243f7d17941c8952ef2", "target": 1, "func": "av_cold int ffv1_common_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    if (!avctx->width || !avctx->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    s->avctx = avctx;\n\n    s->flags = avctx->flags;\n\n\n\n    s->picture.f = avcodec_alloc_frame();\n\n    s->last_picture.f = av_frame_alloc();\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width  = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    // defaults\n\n    s->num_h_slices = 1;\n\n    s->num_v_slices = 1;\n\n\n\n    return 0;\n\n}", "idx": 21061, "substitutes": {"avctx": ["evcf", "groundctl", "avalctx", "aucontext", "afcoll", "avectx", " avcu", "evconn", "avctl", "AVcontext", "afloc", "ajcca", "afcci", "afcb", "avetx", "abcmp", "groundctx", "avalcontext", " avcb", "avecmp", " avvoc", "autx", "afctl", "avcontext", "afcca", "ajconn", "avevoc", "groundcontext", "groundcf", "avvoc", "ajcontext", "ajcci", " avc", "evcontext", "abcontext", "afcontext", "avecoll", "ajctx", " avtx", "avloc", "aftx", " avloc", "AVcu", "avecontext", "avcu", "AVloc", "avcoll", "afconn", "avcmp", "afvoc", "aucoll", "afcf", "AVcmp", "avcb", "avecci", "auctx", "afcmp", "avecb", "avalctl", "avecf", "avtx", "avalcf", "ajcmp", "afcu", "avconn", "AVctx", "avcci", "evctx", "afc", "avc", "abctx", " avcontext", "avec", "avecca", "afctx", "avcf", "avcca", "abcu", "aveconn"], "s": ["full", "settings", "ins", "sets", "S", "sq", "lines", "rs", "w", "p", "sync", "sa", "http", "ses", "ds", "f", "as", "sec", "fs", "is", "ss", "ts", "si", "b", "v", "its", "n", "c", "ps", "sb", "o", "e", "cs", "l", "args", "service", "session", "u", "private", "ans", "services", "qs", "parts", "sup", "es", "ops", "d", "ssl", "data", "gs", "i", "su", "os", "sys", "conf", "self", "m", "sf", "vs", "g", "ls", "sg", "ns", "sv", "js"]}}
{"project": "FFmpeg", "commit_id": "c776531aef9b546ca576d4c8e3ec14a513394618", "target": 0, "func": "static int vqa_decode_chunk(VqaContext *s)\n\n{\n\n    unsigned int chunk_type;\n\n    unsigned int chunk_size;\n\n    int byte_skip;\n\n    unsigned int index = 0;\n\n    int i;\n\n    unsigned char r, g, b;\n\n    int index_shift;\n\n    int res;\n\n\n\n    int cbf0_chunk = -1;\n\n    int cbfz_chunk = -1;\n\n    int cbp0_chunk = -1;\n\n    int cbpz_chunk = -1;\n\n    int cpl0_chunk = -1;\n\n    int cplz_chunk = -1;\n\n    int vptz_chunk = -1;\n\n\n\n    int x, y;\n\n    int lines = 0;\n\n    int pixel_ptr;\n\n    int vector_index = 0;\n\n    int lobyte = 0;\n\n    int hibyte = 0;\n\n    int lobytes = 0;\n\n    int hibytes = s->decode_buffer_size / 2;\n\n\n\n    /* first, traverse through the frame and find the subchunks */\n\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n\n        index      = bytestream2_tell(&s->gb);\n\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case CBF0_TAG:\n\n            cbf0_chunk = index;\n\n            break;\n\n\n\n        case CBFZ_TAG:\n\n            cbfz_chunk = index;\n\n            break;\n\n\n\n        case CBP0_TAG:\n\n            cbp0_chunk = index;\n\n            break;\n\n\n\n        case CBPZ_TAG:\n\n            cbpz_chunk = index;\n\n            break;\n\n\n\n        case CPL0_TAG:\n\n            cpl0_chunk = index;\n\n            break;\n\n\n\n        case CPLZ_TAG:\n\n            cplz_chunk = index;\n\n            break;\n\n\n\n        case VPTZ_TAG:\n\n            vptz_chunk = index;\n\n            break;\n\n\n\n        default:\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: Found unknown chunk type: %c%c%c%c (%08X)\\n\",\n\n            (chunk_type >> 24) & 0xFF,\n\n            (chunk_type >> 16) & 0xFF,\n\n            (chunk_type >>  8) & 0xFF,\n\n            (chunk_type >>  0) & 0xFF,\n\n            chunk_type);\n\n            break;\n\n        }\n\n\n\n        byte_skip = chunk_size & 0x01;\n\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n\n    }\n\n\n\n    /* next, deal with the palette */\n\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CPL0 and CPLZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the palette chunk */\n\n    if (cplz_chunk != -1) {\n\n\n\n/* yet to be handled */\n\n\n\n    }\n\n\n\n    /* convert the RGB palette into the machine's endian format */\n\n    if (cpl0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the palette size */\n\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found a palette chunk with %d colors\\n\",\n\n                chunk_size / 3);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        for (i = 0; i < chunk_size / 3; i++) {\n\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n\n            r = bytestream2_get_byteu(&s->gb) * 4;\n\n            g = bytestream2_get_byteu(&s->gb) * 4;\n\n            b = bytestream2_get_byteu(&s->gb) * 4;\n\n            s->palette[i] = (r << 16) | (g << 8) | (b);\n\n        }\n\n    }\n\n\n\n    /* next, look for a full codebook */\n\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBF0 and CBFZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the full codebook chunk */\n\n    if (cbfz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if ((res = decode_format80(&s->gb, chunk_size, s->codebook,\n\n                                   s->codebook_size, 0)) < 0)\n\n            return res;\n\n    }\n\n\n\n    /* copy a full codebook */\n\n    if (cbf0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the full codebook size */\n\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: CBF0 chunk too large (0x%X bytes)\\n\",\n\n                chunk_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n\n    }\n\n\n\n    /* decode the frame */\n\n    if (vptz_chunk == -1) {\n\n\n\n        /* something is wrong if there is no VPTZ chunk */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: no VPTZ chunk found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n\n    chunk_size = bytestream2_get_be32(&s->gb);\n\n    if ((res = decode_format80(&s->gb, chunk_size,\n\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n\n        return res;\n\n\n\n    /* render the final PAL8 frame */\n\n    if (s->vector_height == 4)\n\n        index_shift = 4;\n\n    else\n\n        index_shift = 3;\n\n    for (y = 0; y < s->frame.linesize[0] * s->height;\n\n        y += s->frame.linesize[0] * s->vector_height) {\n\n\n\n        for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) {\n\n            pixel_ptr = x;\n\n\n\n            /* get the vector index, the method for which varies according to\n\n             * VQA file version */\n\n            switch (s->vqa_version) {\n\n\n\n            case 1:\n\n                lobyte = s->decode_buffer[lobytes * 2];\n\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                /* uniform color fill - a quick hack */\n\n                if (hibyte == 0xFF) {\n\n                    while (lines--) {\n\n                        s->frame.data[0][pixel_ptr + 0] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 1] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 2] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 3] = 255 - lobyte;\n\n                        pixel_ptr += s->frame.linesize[0];\n\n                    }\n\n                    lines=0;\n\n                }\n\n                break;\n\n\n\n            case 2:\n\n                lobyte = s->decode_buffer[lobytes];\n\n                hibyte = s->decode_buffer[hibytes];\n\n                vector_index = (hibyte << 8) | lobyte;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                break;\n\n\n\n            case 3:\n\n/* not implemented yet */\n\n                lines = 0;\n\n                break;\n\n            }\n\n\n\n            while (lines--) {\n\n                s->frame.data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n\n                pixel_ptr += s->frame.linesize[0];\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle partial codebook */\n\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBP0 and CBPZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (cbp0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n\n\n            /* time to replace codebook */\n\n            memcpy(s->codebook, s->next_codebook_buffer,\n\n                s->next_codebook_buffer_index);\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    if (cbpz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n            GetByteContext gb;\n\n\n\n            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n\n            /* decompress codebook */\n\n            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,\n\n                                       s->codebook, s->codebook_size, 0)) < 0)\n\n                return res;\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21070, "substitutes": {"s": ["settings", "sets", "S", "sq", "ks", "rs", "p", "sym", "sync", "site", "sa", "se", "bis", "ses", "ds", "f", "sci", "stats", "fs", "is", "ss", "si", "ts", "v", "its", "a", "c", "spec", "sie", "o", "sb", "e", "cs", "service", "session", "u", "services", "qs", "parts", "sup", "es", "ssl", "gs", "su", "self", "sys", "conf", "js", "t", "sf", "server", "ns", "ls", "sg", "sv", "your", "serv"], "chunk_type": ["chunker_size", "chunk_num", "chump_types", "chunk_offset", "chunktypeoffset", "chunker_types", "chunkingsize", "chacket_length", "chunk_id", "chunkertypes", "chunktypetype", "chump_level", "chump_size", "chunker_info", "chunk_style", "chunk_TYPE", "chunkertype", "chunk_level", "chunk_length", "chunktypesize", "chunkinglength", "chacket_type", "chacket_TYPE", "chunk_info", "chunkersize", "chunkingtype", "chunker_type", "chump_type", "chunk_types", "chacket_size", "chunkingTYPE", "chunkerinfo"], "chunk_size": ["chacket_handle", "chunker_name", "chunker_size", "chunk_name", "chunks_size", "chunk64address", "chunker_sized", "chunk64length", "chunkingsized", "chunks_len", "chunk64sized", "chacket_name", "chunk_length", "chacket_size", "chunk_len", "chunkingsize", "chunk_handle", "chunk_sized", "chunk_Size", "chunk64size", "chunkinglength", "chunk64len", "chunks_Size", "chacket_type", "chunk64name", "chunk_address", "chunker_length", "chunkingname", "chunks_address", "chunk64Size"], "byte_skip": ["byte___skip", "byte___seek", "byte_seek", "byte___offset", "bytexsize", "byte_start", "Byte_skip", " byte_seek", "bytexoffset", "byte_size", "byte_offset", " byte_offset", "Byte_size", "bytexskip", "byte___size", "bytexstart", "Byte_offset", "Byte_start", " byte_size"], "i": ["ii", "ui", "I", "p", "h", "phi", "di", "j", "info", "f", "is", "si", "io", "pi", "n", "index", "bin", "c", "li", "m", "ci", "slice", "z", "bi"], "r": ["w", "rs", "h", "p", "row", "pair", "f", "v", "n", "c", "err", "R", "range", "e", "l", "end", "d", "rc", "re", "rw", "m", "er", "lr", "rl", "rb", "rg"], "g": ["gg", "gp", "w", "h", "p", "f", "pg", "bg", "q", "gl", "n", "ga", "c", "G", "e", "l", "u", "d", "gn", "k", "gs", "m", "gz", "rg"], "b": ["lb", "wb", "p", "bb", "B", "buffer", "f", "nb", "v", "bin", "c", "buf", "cb", "sb", "bp", "e", "l", "bc", "fb", "bs", "eb", "rb", "bi"], "index_shift": ["index_map", "index_skip", " index_map", "index_offset", " index_skip", " index_offset"], "res": ["req", "reset", "row", "Res", "rev", "results", "planes", "rx", "runs", "rows", "files", "seq", "ps", "err", "base", "bits", "error", "col", "blocks", "vals", "rem", "details", "es", "pos", "resolution", "obj", " rows", "rep"], "x": ["w", "xc", "p", "h", "en", "X", "ex", "_", "ax", "f", "xs", "pixel", "xx", "n", "index", "c", "o", "e", "l", "d", "m", "px", "z", "ip"], "y": ["ey", "ym", "cy", "w", "p", "h", "yt", "ye", "type", "f", "n", "c", "o", "e", "l", "ya", "d", "vy", "yy", "m", "t", "dy", "Y", "z"], "pixel_ptr": ["vector_pos", "vectoralpos", "pixelalskip", "pixel_skip", "vectoraloffset", "vector_offset", "vector_skip", "pixelalptr", "pixel_pos", "vectoralskip", "pixelalpos", "pixelaloffset", "vector_ptr", "vectoralptr", "pixel_offset"], "lobytes": ["lodyTE", "loyges", "lodytes", "lodyte", "locytes", "locyTE", "Locyte", "lobyte", "lobyges", "locyges", "loyTE", "Lobytes", "Lobyte", "LobyTE", "loytes", "Locyges", "loyte", "locyte", "lobyTE", "lodyges", "LocyTE", "Locytes", "Lobyges"], "hibytes": ["hibyts", "hibeyte", "hibYts", "obeyts", "obeytes", "hibitmits", "obeyte", "hibeyts", "hibitte", "hibitts", "hibymits", "hibittes", "hibYte", "obymits", "hibeymits", "obyts", "obeymits", "hibYmits", "obyte", "hibYtes", "hibyte", "hibeytes", "obytes"], "lines": ["ii", "line", "flags", "lin", "bands", "code", "planes", "pages", "rows", "breaks", "links", "len", "files", "points", "bits", "cells", "blocks", "vals", "ips", "pos", "count", "m", "frames", "codes", "total", "ls", "bytes"], "gb": ["bm", "cfg", "ui", "gg", "gom", "home", "gc", "xy", "gm", "src", "gy", "gam", "ge", "db", "uv", "gpu", "bg", "pc", "gal", "gd", "gin", "gram", "gt", "gl", "game", "GB", "ga", "gly", "cb", "sb", "storage", "gru", "cgi", "jpg", "yg", "hub", "gold", "rc", "usb", "gz", "vg", "lib", "binary", "rb", "rg"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_mmio_map(PCIDevice *d, int region_num,\n\n                              pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    int mmio_io_addr;\n\n\n\n    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,\n\n                                                 DEVICE_NATIVE_ENDIAN);\n\n\n\n    cpu_register_physical_memory(addr, size, mmio_io_addr);\n\n}\n", "idx": 21092, "substitutes": {"d": ["dm", "dc", "du", " dd", "cd", "ds", "f", "md", "dl", "driver", "did", "D", "gd", "b", "dll", "c", "da", "e", "fd", "dd", "xd", "data", "m", "ad", "dp", " D", "ld", "de"], "region_num": [" module_NUM", " module_num", "region_nr", "region_NUM", " module_number", " module_nr", "region_number"], "addr": ["adr", "ace", "alloc", "src", "access", "host", "call", "arm", "ock", "db", "offset", "loc", "ord", "pointer", "address", "mode", "rt", "name", "ange", "start", "rx", "mac", "len", "align", "index", "amp", "seq", "uri", "base", "alias", "nr", "args", "ref", "port", "pos", "rc", "ptr", "oa", "ad", "alt", "la", "ip"], "size": ["ui", "cap", "capacity", "empty", "code", "offset", "name", "address", "mode", "pack", "si", "Size", "len", "scale", "SIZE", "store", "storage", "args", "ize", "cm", "small", "gn", "weight", "data", "count", "sized", "oa", "ci", "speed", "g"], "type": ["shape", "pe", " offset", " kind", " format", "offset", "name", "loc", "info", "address", "config", "TYPE", "ype", "types", "len", " mode", " TYPE", " name", "fd", "format", "kind", "port", " typ", "rc", "data", "Type", "ptr", "id"], "mmio_io_addr": ["mmio_io_device", "mmio_io2ref", "mmio_lib_addr", "mmio_lo_base", "mmio_io_base", "mmio_lib_ref", "mmio_io2base", "mmio_lib_address", "mmio_io2address", "mmio_io_ord", "mmio_lo_ord", "mmio_lib_base", "mmio_lo_addr", "mmio_io_add", "mmio_lib_add", "mmio_io_address", "mmio_io2addr", "mmio_lib_device", "mmio_io_ref", "mmio_lo_add"]}}
{"project": "qemu", "commit_id": "ac4b0d0c4feb291643c0e8a07a92e449e13881b5", "target": 0, "func": "static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t/* NOP */\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  */\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        /* TODO: */\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            /* No length check */;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        /* Filters are not implemented */\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            /* TODO: ordering? */\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        /* TODO */\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        /* TODO: check that the remaining bits are all 0 */\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command */\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command */\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n", "idx": 21100, "substitutes": {"info": ["home", "thin", "image", "def", "INFO", "about", "inf", "linux", "http", "type", "f", "config", "stat", "start", "family", "init", "a", "state", "index", "information", "base", "from", "error", "Info", "fa", "conn", "iso", "meta", "ref", "source", "fo", "fi", "api", "ctx", "id", "conf"], "data": ["ui", "params", "image", "cache", "zero", "p", "DATA", "code", "buffer", "offset", "complete", "type", "results", "config", "response", "valid", "start", "request", "body", "media", "len", "next", "index", "header", "buf", "parent", "help", "database", "base", "da", "dat", "draw", "message", "args", "batch", "result", "window", "limit", "output", "value", "size", "command", "d", "api", "pos", "input", "memory", "missing", "shift", "pad", "multi", "ad", "done", "Data", "array", "slice", "number", "exec", "resource", "bytes"], "length": ["time", "full", "delay", "shape", "line", "match", "partial", "p", "section", "th", "Length", "offset", "type", "f", "lock", "body", "len", "padding", "position", "path", "range", "sequence", "duration", "style", "l", "message", "tail", "filename", "limit", "ph", "result", "maximum", "function", "end", "value", "size", "url", "input", "count", "L", "id", "number", "total", "array", "angle", "ength"], "hci": ["hlcci", "hldi", "rhki", "khCI", " hcin", " hai", "phcu", "rhcci", "hlbi", " hcci", " hii", "ahcci", "hcu", "hscci", "hbc", " hsync", "rhii", "phii", " hadi", " hcu", "shdi", "phdi", "hcci", "hscin", "Hcci", "hscu", "hCI", "hbi", "hsci", "hsync", "Hcu", "hlsync", "rhdi", "shxc", "hladi", "ahcu", "hki", "rhci", "phci", "hdi", "hlxc", "bhci", "ahii", "shai", "phki", "bhdi", " hki", "phadi", "shbi", " hCI", "hii", " hbc", "hxc", "hlcin", "hlcu", "khdi", "hlii", "ahci", "hlci", "hai", "Hki", "khcin", "khci", "bhbc", "hlbc", " hdi", "shcci", "shsync", "hadi", "bhii", "hlai", " hxc", "hcin", "Hci", "hlki", "shci", " hbi", "hlCI", "rhcu"], "cmd": ["channel", "dc", "req", "params", "cfg", "cf", "setup", "src", " payload", "cd", "code", "cc", "cat", "name", "cli", "type", "msg", "proc", "md", "config", "mode", "head", "func", " chunk", "chrom", "comm", "mac", "seq", "cod", "header", "buf", "c", "ck", "cb", "pipe", "conn", "module", "cookie", "Cmd", "ctr", "kind", "cm", "domain", "command", "cp", "ctx", "vc", "param", " command", "cpp", "pkg", "client", "cmp", "ctrl", "method", "cn", "dom", "op"], "paramlen": ["requestlen", "paramln", "paramslen", "parpos", "parlength", " parampos", "paramstr", "paramslin", "parLen", "arampos", "aramstr", "aramLen", "nameid", "parlen", "paramLen", "requestpos", "requestLen", "requestlength", "paramlin", "parstr", "paramid", "namelen", "aramlin", "aramid", "nameln", "paramsln", " paramLen", "paramlength", "paramsid", "aramln", "namelin", "parampos", " paramlength", "aramlen", " paramstr"], "i": ["ii", "abi", "I", "p", "num", "j", "cli", "ai", "io", "umi", "a", "n", "index", "uri", "c", "ind", "uni", "li", "input", "id", "m", "array", "slice", "binary", "inner", "ip"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n", "idx": 21102, "substitutes": {"fs": ["settings", "cf", "states", "ks", "flags", "linux", "http", "f", "irs", "flows", "bf", "feed", "fc", "files", "df", "fw", "acs", "farm", "cs", "fa", "fd", "fp", "Fs", "fps", "qs", "FS", "fi", "features", "raf", "ips", "ids", "fits", "os", "sys", "fb", "vs", "ls"], "id": ["desc", "auth", "kid", "p", "pid", "cd", "code", "bid", "name", "bit", "offset", "type", "info", "address", "Id", "wire", "uid", "aid", "start", "init", "mask", "uri", "seq", "index", "parent", "path", "error", "ID", "root", "rid", "ref", "key", "ident", "oid", "vid", "ids", "url", "mid", "i", "ad", "sid", "ip"], "isc": ["wic", "mc", "ui", "iv", "mic", "iss", "isi", "alloc", "lc", "uci", "enc", "ib", "cc", "ac", "loc", "ih", "isp", "pc", "uc", "disc", "ISC", "usc", "irc", "sc", "oc", "is", "fc", "isco", "ics", "lic", "ich", "fi", "esc", "misc", "bc", "small", "ic", "soc", "isu", "ig", "rc", "isl", "eth", "ci", "sil", "oci", "custom", "asc", "inc", "ec", "icc", "isa"], "swap": ["wash", "flap", "wapped", "shap", "swash", "Swaps", "flaps", "wapping", "flash", "swrap", "swaps", "flrap", "wap", "Swash", "shapping", "swapped", " swapped", "Swapped", "waps", "wrap", "shaps", " swapping", "Swap", " swash", "swapping", "flapping", " swaps", "shrap"], "is_maskable": ["is_fixible", "is_weightible", "is_signed", "is_fixabled", "is_passless", "is_askless", "is_passed", "is_signabled", "is_asked", "is_fixable", "is_weighted", "is_signable", "is_passible", "is_weightless", "is_masked", "is_passable", "is_askable", "is_maskabled", "is_weightable", "is_signible", "is_askible", "is_askabled", "is_fixed", "is_maskless", "is_maskible"], "flic": ["flux", " flin", "Flict", "clux", "eflu", " flict", "Flic", "flict", "clic", "eflin", "clict", " flux", "Flu", "flu", "efring", " flu", "Fring", "clu", "flin", "Flin", "Flux", "eflic", " fring", "fring"], "r": ["ur", "gr", "mr", "rs", "res", "w", "p", "rar", "ter", "j", "f", " arr", "cr", "sr", "art", "rx", "ru", "ir", "rh", "b", "v", "n", "ar", "c", "err", "R", "error", "rr", "e", "nr", "l", "hr", "result", "u", "ribute", "str", "rn", "d", "attr", "rc", "rf", "re", "i", "m", "t", "er", "lr", "rb", "rg", "rec"], "ret": ["match", "def", "mr", "res", "rs", "resp", "rt", "val", "j", "det", "cur", "sr", "b", "RET", "rel", "len", "back", "err", "reg", "entry", "fun", "red", "rr", "nt", "result", "ref", "run", "usr", "out", "str", "reply", "rc", "re", "obj", "arr", "data", "dr", "alt", "Ret", "rl", "rb"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                int lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                int lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_ff1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_fl1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 21106, "substitutes": {"dc": ["mc", "dm", "xc", "lc", "cd", "cc", "ac", "isc", "DC", "di", "roc", "pc", "jc", "oc", "sc", "fc", "ct", "c", "da", "bc", "rc", "tc", "cdn", "oci", "nc", "ec", "icc"], "insn": ["insna", "lsd", "ainsc", "ainssn", "intsp", "intsn", "lsf", "linsconn", "inl", "kinconn", "inf", "kinn", "insc", "intsne", "lsb", "inna", "pexc", "insd", "linf", "incf", "insb", "incd", "pexn", "insl", "linsnot", "inssn", "linn", "incn", "kinna", "insnc", "outsnc", "insne", "inp", "inconn", "intsl", "ind", "inne", " insp", "pexnot", "incb", "ainsn", "linsc", "linb", "linc", "pexconn", "insf", "incna", "ink", "lsk", "insnot", "insk", "lsc", "insconn", "inn", " insl", "inck", "innc", "incconn", "kinc", " insne", "inb", "outssn", "linsn", "outsc", "outsn", "lsn", "innot", "ainsnc", "insp", "inc", "incc"], "op0": ["hop2", "op4", "oper2", " op6", "OP3", "oper0", " op3", "hop4", "opt1", "op19", "rop2", " op19", "rop0", "opt0", "hop19", "op6", "rop4", "oper6", "hop0", "OP2", "OP6", "opt3", " op4", "OP0", "oper1", "rop19", "OP1", "op3"], "op1": ["op4", "oper2", "op01", "OP3", " op3", "cop3", "OP01", "cop2", " op01", "OP2", "oper3", " op4", "cop4", "cop01", "cop1", "oper1", "OP1", "oper01", "op3", "OP4"], "op2": ["op32", "oper32", "op4", "hop2", "oper2", "OP3", "oper0", "hop4", " op3", "cop3", "oper4", "cop2", "hop0", "OP2", " op32", " op4", "cop4", "cop1", "OP1", "op3", "OP4", "hop32"], "ra": ["ria", "ran", "po", "rs", "RA", "area", "sa", "Ra", "rar", "rt", "ri", "ras", "ada", "ta", "ma", "au", "na", "ro", "gra", "ru", "sr", "wa", "cr", "tra", "up", "a", "ar", "ia", "ca", "da", "from", "rr", "alpha", "min", "r", "ira", "va", "stra", "ka", "ara", "ina", "dra", "rc", "rf", "oa", "dr", "la", "rg", "ba", "rad"], "rb": ["adr", "lb", "erb", "rs", "wb", "reb", "rar", "rt", "RB", "db", "ri", "rm", "rab", "cr", "ru", "sr", "rx", "rh", "bf", "nb", "b", "vr", "cb", "ruby", "sb", "rr", "nr", "ab", "r", "rid", "pb", "usr", "raf", "rob", "rf", "rc", "rw", "gb", "fb", "lr", "rl", "rg"], "rd": ["adr", "rs", "rar", "rss", "rt", "ri", "ras", "rog", "rm", "cr", "ru", "sr", "rx", "rh", "RD", "RR", "rod", "vr", "ruby", "rr", "nr", "RF", "r", "fd", "hr", "rid", "dd", "rn", "d", "dra", "rf", "rob", "rc", "RM", "rw", "dr", "lr", "rl", "ld", "rg"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n", "idx": 21110, "substitutes": {"timer_list": ["loader_type", "timerlisttype", "timerlisttable", "timer_queue", " timer_base", "timer2type", "timer2base", "timerpretype", "timerprelist", "timer_table", "timerpretable", "timer_part", " timer_type", "timerprequeue", "timer_type", "timer2list", "loader_table", "loader_queue", "loader_list", "timer2part", "timerlistlist", "timerlistqueue", "timer_base", " timer_part"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n", "idx": 21118, "substitutes": {"src": ["desc", "ins", "inst", "iv", "resources", "st", "rs", "inf", "bb", "stack", "sync", "img", "loc", "config", "cur", "types", "start", "chrom", "b", "sc", "front", "bl", "rest", "gl", "sub", "cb", "sb", "dest", "dist", "sel", "source", "sur", "bc", "split", "url", "rc", "gb", "slice", "lib", "sl", "ints", "sec", "rb"], "dst": ["dsost", "dedsrc", "dysrc", "dyst", "dedst", " dsrc", "dedsts", "ddest", "adst", "dyST", "dsrc", " dost", "adsts", "dsst", "dsdest", "dedST", "adost", " dST", "dST", "dost", "dsts", " ddest", "dysts", " dsts", "addest", "dssts"], "num_pixels": ["num_pannels", "num_horts", "num_camples", "num_picks", "num_Pannels", "num_Pixels", "num_apels", "num_ports", "num_preels", "num_hixels", "num_apicks", "num_preamples", "num_Picks", "num_hannels", "num_pels", "num_Ports", "num_cels", "num_corts", "num_aports", "num_cixels", "num_pamples", "num_apixels", "num_hicks", "num_preixels", "num_apamples", "num_preorts", "num_apannels"], "palette": ["blii", "blettes", "alii", "palettes", "assite", "annii", "assettes", "annette", "blette", "palge", " palettes", "palii", "alite", "annignment", "palite", "alge", "annettes", " palite", "alettes", "alignment", "alette", "assette", " palge", "palignment", "blignment", "assge"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "p", "h", "phi", "di", "pointer", "ri", "j", "info", "f", "ai", "length", "ini", "oi", "start", "si", "b", "io", "v", "a", "pi", "uri", "index", "n", "c", "o", "e", "wei", "l", "xi", "u", "key", "li", "d", "hi", "id", "m", "ci", "t", "zi", "multi", "mi", "gi", "z", "mu", "bi", "it", "ip"]}}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n", "idx": 21135, "substitutes": {"obj": ["po", "class", "orb", "src", "jp", "ock", "j", "object", "coll", "nb", "cmd", "init", "so", "bh", "n", "Obj", "buf", "bj", "o", "sb", "cb", "pt", "conn", "tmp", "nt", "boot", "opt", "op", "ops", "ob", "emb", "data", "ctx", "self", "os", "org", "objects", "Object"], "ioc": ["hocl", "iroc", "piroc", "uOC", "iOC", "uiroc", "ieroc", "piocol", "dioc", "uisc", "uocom", " iOC", "giocon", "ioco", "giocl", "oocom", "giOC", "abiocol", "uoc", "ciisc", "aocl", "hroc", "abiocom", "uiocal", "idroc", "piocon", "abioca", "iocom", "iocl", "aoca", "iocol", "ciocol", "giocol", "piOC", "piocl", "ioca", "inisc", "riOC", "uocl", "ciocal", "riocl", "riroc", "aroc", "ciOC", "ieocal", "cioco", " ioca", "pioc", "diroc", "diocl", "iisc", "gioca", "ooc", "abioc", "idocal", "idoc", "uioco", "rioc", "aoc", "idocl", "ciroc", "uiocom", "ieoc", "cioca", "cioc", "pioca", "inoc", "giisc", "ciocom", "dioca", "hoc", "ciocon", "uioc", "gioc", "ciocl", "inac", "uiocl", "uac", " iisc", "iocal", "inocom", "uroc", "piocom", "oac", "ieoco", "iac", "hocal", "iocon", "oisc"]}}
{"project": "FFmpeg", "commit_id": "028cc42a1638e6f93a857f11c2568d1c3a51e612", "target": 1, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n\n    if (!strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data+5) == 2) {\n\n        uint8_t desc[256];\n\n        int score = AVPROBE_SCORE_MAX / 2, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 21155, "substitutes": {"st": ["nd", "inst", "kt", "sts", "ace", "stage", "src", "test", "station", "th", "fe", "sa", "dt", "ft", "td", "stat", "ST", "art", "start", "St", "sc", "ts", "ss", "bl", "ct", "state", "sth", "rest", "sw", "sb", "pt", "sta", "nt", "std", "str", "d", "est", "ist", "ost", "ust", "sp", "sd", "t", "sf", "client", "ld", "ste"], "pkt": ["tacket", "Pkg", "pcp", " packet", "Pcp", " pcp", " pet", "bk", " pkg", "packet", "Pct", " pnt", "tcp", "peth", "bkg", "bnt", "Pkt", "Peth", "tet", "placket", " peth", "apct", "apacket", "pka", "Pk", "tkt", "Packet", " pct", "plkt", "apkg", "pk", "Pka", "backet", " pk", "plkg", "Pnt", "beth", "Pet", "bkt", "pkg", " pka", "pct", "pet", "apkt", "plka", "pnt"], "desc": ["dc", "req", "def", "doc", "text", "cont", "src", "lc", "code", "name", "rev", "info", "extra", "config", "td", "description", "Desc", "uc", "sc", "dir", "seq", "cod", "buf", "sub", "cb", "result", "meta", "dest", "dist", "esc", "summary", "bc", "des", "data", "rc", "dep", "null", "txt", "cmp", "pub", "asc", "rec", "ext"], "ret": ["att", "match", "def", "res", "resp", "rets", "test", "en", "lit", "mem", "code", "num", "cat", "val", "status", "det", "max", "cur", "RET", "nz", "len", "gt", "seq", "back", "feat", "fun", "reg", "nt", "result", "std", "opt", "reply", "rc", "flag", "data", "count", "job", "url", "re", "id", "xt", "best", "alt", "score", "success", "Ret", "des", "no", "sec", "rec", "ext"], "ast": ["nd", "ace", "part", "inst", "att", "af", "hd", "Ast", "asts", "AST", "p", "test", "host", "asted", "sa", "aste", "ac", "el", "aw", "ta", "aster", "an", "ft", "pc", "art", "aid", "mast", "anc", "ct", "asm", "sth", "rest", "amp", "ape", "ab", "pt", "old", "tx", "conn", "ess", "amd", "nt", "sta", "ard", "std", "ref", "end", "cast", "post", "api", "est", "ist", "tta", "ost", "ctx", "sd", "best", "ad", "alt", "asting", "esp", "am", "add", "act", "ap", "od", "node", "ld", "op"], "sub_demuxer": ["sub_demxer", "sub_demployeri", "sub_Democera", "sub_demlexers", "sub_demxera", "sub_promxers", "sub_demxER", "sub_demlexER", "sub_Demuxera", "sub_demluxers", "sub_democer", "sub_promxler", "sub_Demuxer", "sub_demirecters", "sub_Demuxester", "sub_demluxer", "sub_demlexeri", "sub_demuxER", "sub_promuxER", "sub_demuxester", "sub_demirectER", "sub_demuxler", "sub_demxler", "sub_promuxer", "sub_demxester", "sub_demployler", "sub_demlexer", "sub_Democers", "sub_democers", "sub_promuxeri", "sub_demployers", "sub_Democester", "sub_demluxester", "sub_demuxeri", "sub_promuxler", "sub_demirecter", "sub_democester", "sub_democler", "sub_promxer", "sub_Democer", "sub_demployer", "sub_demuxers", "sub_demuxera", "sub_Demuxers", "sub_democeri", "sub_promxeri", "sub_demluxera", "sub_demirecteri", "sub_demxeri", "sub_promxER", "sub_promuxers", "sub_demxers", "sub_democera"], "time_base": ["time_item", "time_bas", "timealbased", "timealinfo", "time_based", " time_data", "time2base", "timealdata", " time_item", "Time_base", " time_bas", "timeinginfo", "timeingdata", "time_info", "timeprefile", "event_stable", "timeprebase", "timenbas", "time_file", "event_file", "timeprestable", "timeingbase", "time2unit", " time_info", "timenbase", "timeingbased", "Time_based", "time_data", "timenitem", "timealbase", "event_base", "time_unit", "time2based", "time_stable", "Time_unit", " time_based"], "pb": ["typ", "lb", "bm", "pa", "wb", "jp", "p", "uf", "lc", "bb", "platform", "cv", "db", "xb", "phrase", "pg", "pm", "dl", "pc", "bf", "b", "mp", "bh", "fc", "lab", "ub", "buf", "sub", "lp", "sb", "cb", "bp", "bps", "ab", "mb", "tmp", "fp", "hub", "pit", "vp", "cm", "plugin", "pl", "summary", "ob", "bc", "np", "PB", "cp", "rob", "api", "tc", "bot", "primary", "ctx", "ppa", "gb", "cpp", "pkg", "txt", "fb", "dp", "eb", "wp", "rb", "ba"], "pd": [" prot", "po", " ta", "hd", " dc", "pe", " dd", "pa", "p", "jp", "cd", " disp", "dt", "bd", "ds", "pg", "pm", "td", "dl", "edd", "ud", "pc", " ep", "gd", " da", "pp", " DP", "sth", " db", "lp", "parser", " cmd", "cb", "sb", " df", " std", " parser", "fd", " td", "fp", "pod", "py", " sd", "dd", "xd", "tp", "d", "np", "cp", "PB", " prod", "dra", " rc", " DD", "ppa", "sd", "PD", " np", " FD", " cd", " cad", "dp", "vd", "wp", " cp", " ad"]}}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)\n\n{\n\n    int ret;\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    if (o_out)\n\n        *o_out = o;\n\n    if (!o)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n    if (!val || o->offset<=0)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (o->type == FF_OPT_TYPE_BINARY) {\n\n        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);\n\n        int *lendst = (int *)(dst + 1);\n\n        uint8_t *bin, *ptr;\n\n        int len = strlen(val);\n\n        av_freep(dst);\n\n        *lendst = 0;\n\n        if (len & 1) return AVERROR(EINVAL);\n\n        len /= 2;\n\n        ptr = bin = av_malloc(len);\n\n        while (*val) {\n\n            int a = hexchar2int(*val++);\n\n            int b = hexchar2int(*val++);\n\n            if (a < 0 || b < 0) {\n\n                av_free(bin);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            *ptr++ = (a << 4) | b;\n\n        }\n\n        *dst = bin;\n\n        *lendst = len;\n\n        return 0;\n\n    }\n\n    if (o->type != FF_OPT_TYPE_STRING) {\n\n        int notfirst=0;\n\n        for (;;) {\n\n            int i;\n\n            char buf[256];\n\n            int cmd=0;\n\n            double d;\n\n\n\n            if (*val == '+' || *val == '-')\n\n                cmd= *(val++);\n\n\n\n            for (i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++)\n\n                buf[i]= val[i];\n\n            buf[i]=0;\n\n\n\n            {\n\n                const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n\n                if (o_named && o_named->type == FF_OPT_TYPE_CONST)\n\n                    d= o_named->default_val.dbl;\n\n                else if (!strcmp(buf, \"default\")) d= o->default_val.dbl;\n\n                else if (!strcmp(buf, \"max\"    )) d= o->max;\n\n                else if (!strcmp(buf, \"min\"    )) d= o->min;\n\n                else if (!strcmp(buf, \"none\"   )) d= 0;\n\n                else if (!strcmp(buf, \"all\"    )) d= ~0;\n\n                else {\n\n                    int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n\n                    if (res < 0) {\n\n                        av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val);\n\n                        return res;\n\n                    }\n\n                }\n\n            }\n\n            if (o->type == FF_OPT_TYPE_FLAGS) {\n\n                if      (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;\n\n                else if (cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;\n\n            } else {\n\n                if      (cmd=='+') d= notfirst*av_get_double(obj, name, NULL) + d;\n\n                else if (cmd=='-') d= notfirst*av_get_double(obj, name, NULL) - d;\n\n            }\n\n\n\n            if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n\n                return ret;\n\n            val+= i;\n\n            if (!*val)\n\n                return 0;\n\n            notfirst=1;\n\n        }\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (alloc) {\n\n        av_free(*(void**)(((uint8_t*)obj) + o->offset));\n\n        val= av_strdup(val);\n\n    }\n\n\n\n    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));\n\n    return 0;\n\n}\n", "idx": 21166, "substitutes": {"obj": ["po", "bm", "inst", "prefix", "abi", "att", "typ", "image", "wb", "xy", "orb", "src", "bo", "img", "num", "buff", "loc", "j", "object", "func", "coll", "start", "lock", "io", "init", "n", "Obj", "rot", "adj", "cb", "eff", "pt", "ab", "conn", "xp", "tmp", "nt", "ref", "out", "opt", "oid", "str", "off", "ob", "bot", "pos", "attr", "data", "arr", "cdn", "ctx", "self", "os", "org", "objects", "orig", "fn", "ant", "act", "lib", "op", "sn", "js"], "name": ["part", "x", "nm", "label", "NAME", "word", "type", "names", "option", "na", "nam", "family", "anc", "pass", "v", "len", "a", "n", "parent", "base", "path", "alias", "style", "old", "filename", "key", "out", "value", "size", "data", "prefix", "Name"], "val": ["expr", "br", "def", "VAL", "xy", "p", "lit", "offset", "Value", "elt", "valid", "seq", "rot", "base", "vi", "ref", "key", "vals", "pos", "data", "count", "lib", "sv", "all", "var", "part", "doc", "al", "test", "call", "loc", "msg", "cmd", "b", "len", "index", "vec", "fl", "ind", "fat", "sel", "end", "pl", "vet", "arr", "arg", "alt", "prefix", "serv", "eval", "text", "vert", "el", "aval", "win", "v", "pt", "byte", "value", "fi", "li", "ctx", "unit", "live", "sl", "it", "ul", "x", "block", "bl", "vol", "pol", "slot", "ver", "tx", "boot", "split", "Val", "exec", "ol"], "alloc": ["ok", "VAL", "eval", "empty", "cache", "mem", "ac", "nil", "loc", "ef", "valid", "func", "oc", "init", "vol", "c", "reg", "slot", "aux", "nt", "final", "opt", "unc", "ctx", "orig", "all"], "o_out": ["o_bit", "o_copy", "O_OUT", "o_Out", "O_again", " o_bit", " o_OUT", "O_out", " o_in", "o_OUT", " o_Out", "O_in", " o_copy", "o_in", "o_again"], "ret": ["def", "res", "resp", "Len", "mem", "code", "cat", "num", "max", "RET", "fun", "reg", "vec", "nt", "result", "ref", "rc", "re", "flag", "arr", "data", "Ret", "rep", " result", "var"], "o": ["po", "image", "oe", "p", "bo", "co", "mo", "go", "option", "f", "to", "object", "oi", "none", "ov", "io", "b", "so", "v", "O", "oo", "oc", "n", "c", "e", "y", "l", "or", "iso", "u", "out", "oid", "fo", "off", "ob", "one", "k", "oa", "os", "m", "vo", "t", "lo", "yo", "ko", "od", "no", "op", "ol"], "dst": ["Dst", "bst", "lste", " dsp", "bdr", " dste", "idst", "lsp", "dsp", "dste", " dbl", "ldr", " ddr", " dest", "Dsc", "rdest", "idest", "Dste", "rdsts", "dstr", "lest", "dbl", "sdsp", " dsc", "sdest", "lst", "ddr", "rdstr", "Dbl", "bbl", "dsc", "rdst", "dest", "lbl", "dsts", "lsc", "bste", " dstr", "idstr", "idsts", " dsts", "sdsc", "sdst"], "lendst": ["lizsts", "lendsst", "blendSt", "lendost", "loudst", "lENDst", "lendirst", "lendsost", "blendsta", "lndrest", "bloudSt", "ladSt", "lizest", "loudsta", "loudsc", "lendsts", "lndsp", "lendSt", "lendedost", "lendssp", "bloudsc", " lendost", "ladsc", "lendedsp", "ladst", "ladsta", " lndsp", " lendirst", "bloudst", "lendrest", "loudSt", "lENDsc", "lendsp", " lendsts", " lndost", "lndest", "bloudsta", " lndirst", "lendedst", "lendsta", "blendst", "lendsirst", "blendsc", "lndsts", " lendest", "lendsc", "lndirst", " lendrest", "lENDSt", "lndost", "lENDsta", "lndst", "lendest", " lndst", "lizrest", "lizst", " lendsp", "lendedirst"], "bin": ["part", "abi", "br", "rin", "lin", "bb", "sync", "pin", "num", "bit", "buffer", "ln", "nn", "bis", "db", "ac", "loc", "pc", "bl", "win", "border", "gin", "len", "index", "local", "base", "spin", "root", "byte", "bi", "offset", "obin", "bc", "in", "split", "bot", "vin", "gb", "bn", "fin", "socket", "bar", "sid", "lib", "binary", "inner"], "ptr": ["inst", "abi", "br", "src", "fe", "butt", "code", "lf", "offset", "pointer", "loc", "buffer", "proc", "dim", "length", "rev", "pc", "start", "bl", "vr", "len", "rot", "Ptr", "err", "pt", "ind", "fd", "ref", "str", "tr", "pos", "attr", "arr", "sp", "dr", "pad", "slice", "addr", "var"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "p", "h", "phi", "di", "j", "info", "f", "ai", "cli", "s", "ini", "oi", "ni", "ie", "start", "io", "si", "v", "pi", "n", "index", "uri", "c", "e", "y", "l", "xi", "u", "chi", "yi", "fi", "in", "iu", "li", "mini", "hi", "k", "id", "m", "ci", "t", "multi", "mi", "anti", "gi", "g", "z", "mu", "bi", "it", "ip"], "buf": ["cap", "br", "box", "text", "cv", "uf", "stack", "src", "queue", "bo", "block", "img", "cat", "buff", "buffer", "loc", "bd", "proc", "config", "uc", "cmd", "seq", "header", "cb", "cas", "vec", "pt", "fd", "batch", "window", "out", "output", "bag", "conv", "port", "ff", "bc", "rc", "data", "ctx", "bn", "fb", "map", "rb", "bed", "pool"], "d": [" comp", " dd", " def", " init", " dev", " disp", " vec", " chunk", " img", " exec", " c", " digest", " diff", " std", " df", " bc", "Cmd", " pad", " cur", " count", " prod", " delta", " data", " grad", " dw", " r", " cd", " stride"], "o_named": ["o___placed", "n__name", "o__ned", "o_ned", "o___ned", "n_amed", "oo___name", "o___named", "o__placed", "n_named", "oo___placed", "oaJamed", "oaJaligned", "o___specified", "oJamed", "o___amed", "oo___specified", "n_name", "o__name", "oa_built", "o__specified", "oo_placed", "n_ned", "o_placed", "oa_aligned", "oo_name", "o_built", "oaJnamed", "o__amed", "n__ned", "o_aligned", "o_amed", "o_specified", "oJbuilt", "oo___named", "oJaligned", "n__amed", "oa_named", "o_name", "oo_specified", "o___name", "oo_named", "oJnamed", "oa_amed", "o__named", "n__named", "oaJbuilt"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,\n\n                                    int alpha, int beta, int8_t *tc)\n\n{\n\n    uint8_t bs0 = 1;\n\n    uint8_t bs1 = 1;\n\n    uint8_t bs2 = 1;\n\n    uint8_t bs3 = 1;\n\n\n\n    if (tc[0] < 0)\n\n        bs0 = 0;\n\n    if (tc[1] < 0)\n\n        bs1 = 0;\n\n    if (tc[2] < 0)\n\n        bs2 = 0;\n\n    if (tc[3] < 0)\n\n        bs3 = 0;\n\n\n\n    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,\n\n                                               bs0, bs1, bs2, bs3,\n\n                                               tc[0], tc[1], tc[2], tc[3],\n\n                                               alpha, beta,\n\n                                               img_width);\n\n}\n", "idx": 21168, "substitutes": {"data": ["image", "cache", "test", "DATA", "block", "buffer", "db", "load", "ada", "results", "config", "valid", "ata", "device", "next", "scale", "parent", "database", "base", "da", "dat", "tmp", "batch", "result", "window", "end", "dd", "d", "api", "memory", "input", "reader", "ad", "la", "Data", "map", "new"], "img_width": ["img_length", "imgwheight", "img_name", " img_weight", " img_length", "imgwwidth", " img_size", "img_size", "imgwweight", "img_weight", "imgwname", " img_height", " img_name", "img_height"], "alpha": ["lambda", "aa", "igma", "ity", "ra", "area", "uca", "sa", "acl", "ac", "ana", "ta", "ma", "extra", "na", "as", "si", "\u03b1", "a", "audio", "average", "amp", "asc", "scale", "filter", "ca", "da", "alias", "Alpha", "size", "sup", "A", "qa", "i", "la", "Beta", "angle", "inc", "pha"], "beta": ["lambda", "abi", "\u03b2", "pa", "wb", "phi", "uca", "gam", "db", "offset", "ta", "mega", " Beta", "b", "si", "fee", "a", "ga", "cb", "error", "appa", "meta", "negative", "bc", "bot", "uma", "abc", "la", "eta", "Beta", "asc", "ba", "mu"], "tc": ["mc", "dc", "ui", "cl", "cache", "test", "lc", "cu", "bb", "tm", "cc", "cases", "ac", "co", "loc", "ta", "config", "cus", "types", "uc", "pc", "tf", "sc", "ts", "oc", "fc", "toc", "temp", "c", "cb", "ca", "com", "cas", "cs", "tx", "acc", "tmp", "tu", "col", "pb", "ctr", "cm", "TC", "tr", "bc", "ic", "tn", "rc", "cp", "ctx", "k", "gb", "ci", "txt", "tim", "ctrl", "nc", "term", "spec", "ec", "icc"]}}
{"project": "qemu", "commit_id": "f37343197708d90f119007ce5ecc2503be9c04c1", "target": 0, "func": "void slirp_select_poll(fd_set *readfds, fd_set *writefds, fd_set *xfds,\n\n                       int select_error)\n\n{\n\n    Slirp *slirp;\n\n    struct socket *so, *so_next;\n\n    int ret;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_instances)) {\n\n        return;\n\n    }\n\n\n\n    global_readfds = readfds;\n\n    global_writefds = writefds;\n\n    global_xfds = xfds;\n\n\n\n    curtime = qemu_get_clock_ms(rt_clock);\n\n\n\n    QTAILQ_FOREACH(slirp, &slirp_instances, entry) {\n\n\t/*\n\n\t * See if anything has timed out\n\n\t */\n\n\t\tif (time_fasttimo && ((curtime - time_fasttimo) >= 2)) {\n\n\t\t\ttcp_fasttimo(slirp);\n\n\t\t\ttime_fasttimo = 0;\n\n\t\t}\n\n\t\tif (do_slowtimo && ((curtime - last_slowtimo) >= 499)) {\n\n\t\t\tip_slowtimo(slirp);\n\n\t\t\ttcp_slowtimo(slirp);\n\n\t\t\tlast_slowtimo = curtime;\n\n\t\t}\n\n\n\n\t/*\n\n\t * Check sockets\n\n\t */\n\n\tif (!select_error) {\n\n\t\t/*\n\n\t\t * Check TCP sockets\n\n\t\t */\n\n\t\tfor (so = slirp->tcb.so_next; so != &slirp->tcb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\t/*\n\n\t\t\t * FD_ISSET is meaningless on these sockets\n\n\t\t\t * (and they can crash the program)\n\n\t\t\t */\n\n\t\t\tif (so->so_state & SS_NOFDREF || so->s == -1)\n\n\t\t\t   continue;\n\n\n\n\t\t\t/*\n\n\t\t\t * Check for URG data\n\n\t\t\t * This will soread as well, so no need to\n\n\t\t\t * test for readfds below if this succeeds\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, xfds))\n\n\t\t\t   sorecvoob(so);\n\n\t\t\t/*\n\n\t\t\t * Check sockets for reading\n\n\t\t\t */\n\n\t\t\telse if (FD_ISSET(so->s, readfds)) {\n\n\t\t\t\t/*\n\n\t\t\t\t * Check for incoming connections\n\n\t\t\t\t */\n\n\t\t\t\tif (so->so_state & SS_FACCEPTCONN) {\n\n\t\t\t\t\ttcp_connect(so);\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} /* else */\n\n\t\t\t\tret = soread(so);\n\n\n\n\t\t\t\t/* Output it if we read something */\n\n\t\t\t\tif (ret > 0)\n\n\t\t\t\t   tcp_output(sototcpcb(so));\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Check sockets for writing\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, writefds)) {\n\n\t\t\t  /*\n\n\t\t\t   * Check for non-blocking, still-connecting sockets\n\n\t\t\t   */\n\n\t\t\t  if (so->so_state & SS_ISFCONNECTING) {\n\n\t\t\t    /* Connected */\n\n\t\t\t    so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t    ret = send(so->s, (const void *) &ret, 0, 0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXXXX Must fix, zero bytes is a NOP */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    }\n\n\t\t\t    /* else so->so_state &= ~SS_ISFCONNECTING; */\n\n\n\n\t\t\t    /*\n\n\t\t\t     * Continue tcp_input\n\n\t\t\t     */\n\n\t\t\t    tcp_input((struct mbuf *)NULL, sizeof(struct ip), so);\n\n\t\t\t    /* continue; */\n\n\t\t\t  } else\n\n\t\t\t    ret = sowrite(so);\n\n\t\t\t  /*\n\n\t\t\t   * XXXXX If we wrote something (a lot), there\n\n\t\t\t   * could be a need for a window update.\n\n\t\t\t   * In the worst case, the remote will send\n\n\t\t\t   * a window probe to get things going again\n\n\t\t\t   */\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Probe a still-connecting, non-blocking socket\n\n\t\t\t * to check if it's still alive\n\n\t \t \t */\n\n#ifdef PROBE_CONN\n\n\t\t\tif (so->so_state & SS_ISFCONNECTING) {\n\n                          ret = qemu_recv(so->s, &ret, 0,0);\n\n\n\n\t\t\t  if (ret < 0) {\n\n\t\t\t    /* XXX */\n\n\t\t\t    if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\terrno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t      continue; /* Still connecting, continue */\n\n\n\n\t\t\t    /* else failed */\n\n\t\t\t    so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t    so->so_state |= SS_NOFDREF;\n\n\n\n\t\t\t    /* tcp_input will take care of it */\n\n\t\t\t  } else {\n\n\t\t\t    ret = send(so->s, &ret, 0,0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXX */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    } else\n\n\t\t\t      so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t  }\n\n\t\t\t  tcp_input((struct mbuf *)NULL, sizeof(struct ip),so);\n\n\t\t\t} /* SS_ISFCONNECTING */\n\n#endif\n\n\t\t}\n\n\n\n\t\t/*\n\n\t\t * Now UDP sockets.\n\n\t\t * Incoming packets are sent straight away, they're not buffered.\n\n\t\t * Incoming UDP data isn't buffered either.\n\n\t\t */\n\n\t\tfor (so = slirp->udb.so_next; so != &slirp->udb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\tif (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                            sorecvfrom(so);\n\n                        }\n\n\t\t}\n\n\n\n                /*\n\n                 * Check incoming ICMP relies.\n\n                 */\n\n                for (so = slirp->icmp.so_next; so != &slirp->icmp;\n\n                     so = so_next) {\n\n                     so_next = so->so_next;\n\n\n\n                    if (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                        icmp_receive(so);\n\n                    }\n\n                }\n\n\t}\n\n\n\n\t/*\n\n\t * See if we can start outputting\n\n\t */\n\n\tif (slirp->if_queued) {\n\n\t    if_start(slirp);\n\n\t}\n\n    }\n\n\n\n\t/* clear global file descriptor sets.\n\n\t * these reside on the stack in vl.c\n\n\t * so they're unusable if we're not in\n\n\t * slirp_select_fill or slirp_select_poll.\n\n\t */\n\n\t global_readfds = NULL;\n\n\t global_writefds = NULL;\n\n\t global_xfds = NULL;\n\n}\n", "idx": 21202, "substitutes": {"readfds": ["readfordds", "readifks", "readldds", "readgps", "readinfps", "readinfns", "writefords", "readrfns", "writerfns", "readrfps", "readrfds", "readfns", "readvdd", "readgds", "readfps", "readvns", "readlds", "writefordd", "readinfdds", "readvdds", " readfns", "readifdds", "writerfps", "readfdds", "readlns", "readforks", "readdds", "readfks", "writeforks", "readfdd", "writefdds", "writefns", "readinfds", "readfords", "readifds", "readgns", "readdks", "readvds", " readfdds", "readldd", " readfdd", "readrfdds", "writefdd", "writefks", "readifdd", "readddd", "writefps", "readgdds", "readddds", "writerfdds", "readfordd", "writefordds", "writerfds"], "writefds": ["sendfdd", "writeofords", "writefcros", "writefords", "sendfsts", "writefros", " writefdds", " writeofds", "writefsds", "writeofsts", "writetfds", " writefros", " writeofsts", "writecords", "sendfssts", "sendfds", "writeofdds", "writerfdd", "writetfords", "writefda", "writerfros", "sendfsd", "sendfd", "writefcds", "writefcd", " writefsd", " writefsds", " writefsros", "writecds", "writefdds", "writefd", "writefssts", "writefcda", "writefsda", " writefsts", "sendfsds", "writerfsts", "writerfda", " writeofdds", " writefords", "writecdds", "writefsts", "writefdd", " writeofords", " writefsda", " writefda", "writefsros", "sendfsdd", " writefd", "writeofds", "writetfsts", "writetfdds", "writecsts", "writefsdd", "writefsd", "writerfd", "writerfds"], "xfds": ["xfdds", "efdd", "efded", "xfades", "xcd", "sfds", "fxks", "efd", "efds", "sfda", "sfded", "fxds", "sfks", "xfks", "fcda", "fcades", "xcda", "sfdd", "sfd", "xcdd", "cfades", "fcdds", "xfd", "xfdd", "cfda", "xcks", "fcds", "fxades", "xfded", "xfda", "fxd", "fxdds", "fxda", "cfds", "cfdds", "xcded", "xcds"], "select_error": ["select2ror", "selectableError", "connect_Error", "connect_ror", "select_ror", "select2error", "selectableerror", "selectjror", "select2err", " select_err", "select_Error", "selectjcommand", "connect_err", "selectjerr", "select_err", " select_ror", "selectableror", "select2Error", "select_command", " select_command", "selectableerr", "connect_error", "selectjerror"], "slirp": ["plirpc", "sliverp", "slireping", "shirc", "slierP", "slmirp", "slyrpe", "slirtpa", " slirpe", "plirtf", "slierr", "slierping", "slpirper", "silirper", "plirpe", "silirp", "slirc", "slearpc", " slirepo", "slurp", "slrrcp", "slirpa", "shirp", "plirp", "slirtp", "slirtpo", "slearp", "slirpe", "slirepe", "silwerpc", "slurping", "shierp", "slpirpc", "slirep", "shierr", "slirepc", "plirtpa", "plirtpc", "slrispc", "sliperp", "shyrp", "slirtpc", "silirpc", "plirtpo", "shirping", "slpirp", "slmirpe", "slearpa", "slrrv", "sliperpc", "slwerper", "slrrp", "sliverpo", " slirepe", "slpirf", "slirer", "sliverpc", "slurr", "shirpc", "slwerpc", "shyrpc", "slearpe", "slearf", "slrispe", " slirpc", "shirtcp", "slyrpc", "plirtp", "silirpe", "slirtv", "shyrpe", "slrrpc", "shirr", "shirv", "slmirpc", "slirping", "silwerper", "shierP", "shirpe", "slirpo", "slirtf", "slircp", "slierp", "slipercp", "shirtp", "slwerp", "slearc", "slmirpo", "shierping", "shirtv", "slirper", "shyrc", "slirv", "slirf", "slirepo", "plirtpe", "slirP", " slirep", "slyrp", "slpirpe", "slirpc", "slpirpa", "sliperv", "slireP", "slwerpe", "sliverpe", "slirr", "slrisper", "slearpo", "silwerpe", " slirepc", "slirtcp", "shirP", "silwerp", "slyrc", "slyrpo", "shircp", "plirpa", "slirec", "plirpo", " slirpo", "slirtpe", "shirtpc", "slrisp", "slurP", "plirf"], "so": ["se", "co", "te", "SO", "s", "ku", "si", "oh", "sb", "sm", "sk", "fo", "la", "no", "zo", "po", "isi", "sa", "ge", "go", "mo", "cli", "ce", "to", "zh", "ni", "ho", "ski", "sc", "ki", "osi", "who", "from", "sel", "So", "model", "os", "ao", "ko", "oe", "flo", "bo", "thro", "ie", "oi", "style", "ou", "va", "or", "sh", "ico", "oss", "sp", "ci", "client", "osa", "sl", "sn", "sq", "oso", "sync", "kee", "shi", "plus", "sw", "o", "olo", "ssl", "obj", "su", "lo", "sing", "ilo", "coe"], "so_next": ["fo_next", "o_next", "so__future", "fo_sequence", "fo_state", "sw_string", "so_last", "so__string", "fo_current", "fo_string", "so_cookie", "so_link", "o_new", "so_new", "so_current", "sw_last", "so_future", "o_last", "so__last", "sw_next", "so_prev", "fo_last", "fo_cookie", "so_sequence", "so__next", "so_state", "sw_future", "fo_prev", "so_string", "o_link"], "ret": ["att", "match", "def", "res", "resp", "rets", "lit", "mem", "code", "num", "cat", "bit", "val", "rt", "db", " Ret", "status", "ft", "det", "lt", "mt", "bf", "pass", "ut", "RET", "ry", "ct", "rb", "len", "gt", "back", "fun", "reg", "sat", "pt", "nt", "result", "ref", "py", "out", "usr", "opt", "str", " RET", "reply", "rc", "data", "re", "arr", "obj", "flag", "id", "alt", "fin", "arg", "Ret", "pet", "no", "let", "ext"]}}
{"project": "qemu", "commit_id": "970d622e8ab1de8fdf5762e23e92a2dea9d7d36c", "target": 0, "func": "uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n", "idx": 21218, "substitutes": {"op1": ["op01", "hopb", " op8", "hop1", "ops01", "opsb", "operb", " op01", "ipb", "ops1", "op8", "ip01", "ipa", "hop01", "oper8", "ip1", "oper1", "ops8", "oper01", "hopa"], "op2": ["oper2", "ropII", "operII", "ip0", "OpII", "opII", "rop2", " op0", "ip2", "cop2", "opertwo", "op0", "ipb", "op8", "rop8", "cop0", "copb", "optwo", "Optwo", "oper8", "Op2", "roptwo", "Op8"], "opa": ["po", "aco", "aa", "phony", "pa", "pai", "jp", "jo", "opal", "abo", "azi", "di", "rog", "obo", "opus", "na", "ja", "so", "osi", "oda", "oka", "apa", "ca", "pol", "appy", "o", "ppo", "cro", "appa", "asi", "pre", "elo", "ara", "api", "data", "cho", "oga", "vo", "ppa", "cop", "apo", "oa", "osa", "ori", "ollo", "ona", "pha", "op", "asa", "ip"], "opb": ["optlb", "roplb", "OPa", "hopba", "hopb", "OPba", "apbb", "operab", "optb", "ropbb", "apab", "ropb", " oplb", "OPb", " opba", "operb", "optba", " opbb", "opba", "optbb", "opbb", "hopbb", "apb", "opab", " opab", "OPbb", "ropba", "oplb", "hopa", "operbb"], "res": ["gre", "req", "rates", "gr", "resp", "rs", "css", "Res", "rap", "val", "ras", "rev", "rss", "ret", "results", "response", "ris", "rx", "rh", "ress", "rel", "seq", "rest", "ares", "ps", "err", "reg", "RES", "resh", "r", "reed", "result", "rem", "details", "rez", "changes", "features", "re", "resolution", "arr", "os", "Rs", "success", "rep", "rus", "ries", "ms", "rec", "pres"], "i": ["ti", "ii", "ui", "my", "abi", "qi", "part", "x", "I", "ix", "p", "eni", "di", "ri", "j", "info", "f", "ai", "s", "ie", "oi", "ni", "ini", "start", "is", "si", "b", "io", "v", "a", "pi", "index", "c", "uli", "o", "e", "l", "r", "xi", "u", "chi", "fi", "li", "d", "hi", "k", "id", "zi", "ci", "m", "mi", "t", "multi", "slice", "gi", "z", "bi", "ip"]}}
{"project": "qemu", "commit_id": "7b527b86eb3560d68f41218cec0cdf3d60a38323", "target": 0, "func": "static int s390_ipl_init(SysBusDevice *dev)\n\n{\n\n    S390IPLState *ipl = S390_IPL(dev);\n\n    uint64_t pentry = KERN_IMAGE_START;\n\n    int kernel_size;\n\n\n\n    int bios_size;\n\n    char *bios_filename;\n\n\n\n    /*\n\n     * Always load the bios if it was enforced,\n\n     * even if an external kernel has been defined.\n\n     */\n\n    if (!ipl->kernel || ipl->enforce_bios) {\n\n        uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;\n\n\n\n        if (bios_name == NULL) {\n\n            bios_name = ipl->firmware;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (bios_filename == NULL) {\n\n            hw_error(\"could not find stage1 bootloader\\n\");\n\n        }\n\n\n\n        bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,\n\n                             &ipl->bios_start_addr, NULL, NULL, 1,\n\n                             ELF_MACHINE, 0);\n\n        if (bios_size > 0) {\n\n            /* Adjust ELF start address to final location */\n\n            ipl->bios_start_addr += fwbase;\n\n        } else {\n\n            /* Try to load non-ELF file (e.g. s390-zipl.rom) */\n\n            bios_size = load_image_targphys(bios_filename, ZIPL_IMAGE_START,\n\n                                            4096);\n\n            ipl->bios_start_addr = ZIPL_IMAGE_START;\n\n            if (bios_size > 4096) {\n\n                hw_error(\"stage1 bootloader is > 4k\\n\");\n\n            }\n\n        }\n\n        g_free(bios_filename);\n\n\n\n        if (bios_size == -1) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        /* default boot target is the bios */\n\n        ipl->start_addr = ipl->bios_start_addr;\n\n    }\n\n\n\n    if (ipl->kernel) {\n\n        kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n\n                               NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n\n         * kernel parameters here as well. Note: For old kernels (up to 3.2)\n\n         * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n\n         * loader) and it won't work. For this case we force it to 0x10000, too.\n\n         */\n\n        if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n\n            ipl->start_addr = KERN_IMAGE_START;\n\n            /* Overwrite parameters in the kernel image, which are \"rom\" */\n\n            strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n\n        } else {\n\n            ipl->start_addr = pentry;\n\n        }\n\n\n\n        if (ipl->initrd) {\n\n            ram_addr_t initrd_offset;\n\n            int initrd_size;\n\n\n\n            initrd_offset = INITRD_START;\n\n            while (kernel_size + 0x100000 > initrd_offset) {\n\n                initrd_offset += 0x100000;\n\n            }\n\n            initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n            if (initrd_size == -1) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        ipl->initrd);\n\n                exit(1);\n\n            }\n\n\n\n            /*\n\n             * we have to overwrite values in the kernel image,\n\n             * which are \"rom\"\n\n             */\n\n            stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n\n            stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 21219, "substitutes": {"dev": ["dm", "ev", "Dev", "priv", "die", "di", "proc", "DEV", "devices", "gd", "device", "gu", "temp", "pro", "mod", "reg", "bus", "serial", "ver", "Device", "conn", "ch", "d", "pu", "data", "plug", "eth", "sd", "grad", "dem", "pub", "cam", "od", "dom", "de", "rad"], "ipl": ["inet", "multipl", "intel", "pp", "ipper", "abul", "utils", "eff", "ppo", "ffield", "iop", "pull", "lv", "abb", "sil", "mult", "lip", "expl", "Impl", "chip", "compl", "cli", "repl", "scl", "phil", "ELF", "elf", "fl", "iper", "tif", "spl", "pl", "ips", "imp", "isl", "plug", "obl", "ipp", " pl", "inst", "il", "ipping", "owl", "ippers", "fp", "hw", "bitcoin", "iw", "ctl", "sl", "ul", "inf", "hl", "iol", "ibl", "qq", "dll", "opl", "inyl", "control", "PL", "operator", "vp", "ffe", "impl", "ssl", "upp", "sf", "ctrl", "cel", "util", "ilo", "rl", "inc", "ril"], "kernel_size": ["kernel_name", "kernel_fee", "kernel_count", "kernel67count", "family5width", "family_size", "kernel67fee", " kernel_time", "kernel67ize", "kernel_width", "kernel5size", " kernel_number", "pixel_size", "kernel64sized", "kernel67time", "kernel67large", "kernel67size", "pixel_offset", "thread_score", "kernel64size", "family5size", "family_sized", "kernel_ize", "thread_fee", "kernel67number", "kernel_number", "thread_count", "family5sized", "kernel67score", "kernel128size", "kernel_offset", "kernel_large", "family_width", "kernel5width", "kernel5sized", "thread_size", "kernel_sized", "kernel64width", " kernel_ize", "kernel128number", "kernel_score", "pixel_name", "kernel_time", "kernel128ize", " kernel_large"], "bios_size": ["bios_SIZE", "bios_sized", "bits_capacity", "bits_size", "bios_ize", "bias_sized", "bias_ize", "bios_loc", "bins_area", "bios_use", "bio_scale", "bias_size", "bips_speed", "bins_number", "bios_speed", "bios_name", "bios_load", "botes_ize", "bips_size", "bios_capacity", "bio_name", "bios_scale", "bio_size", "botes_SIZE", "bits_width", "bips_load", "bips_use", "botes_size", "bits_number", "bins_name", "bios_number", "bios_width", "bios_area", "bias_width", "bins_size", "bio_loc"], "bios_filename": ["bios__filename", "bias_fp", "bios__name", "bio_file", "bio_filename", "bos_filename", "bias_path", "bias_username", "bios_fp", "bixels__name", "bios_username", "bixels_filename", "bixels_name", "bios_Filename", "bios_file", "bios_location", "bos_file", "bios__fp", "bios_name", "bios__location", "bias_Filename", "bixels_Filename", "bios_path", "bias_filename", "bixels_path", "bos_size", "bios_fn", "bos_name", "bio_name", "bias_fn", "bio_size", "bixels__fp", "bias_file", "bixels_fil", "bios_fil", "bixels_fp", "bixels_location", "bixels__location", "bixels__filename"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 21250, "substitutes": {"devname": ["deviceName", "devnm", "divname", "devName", " devnames", "divnames", "devicenm", "Devname", "DevName", "Devnm", " devnm", "devnames", " devno", "evName", "evno", "deviceno", "divName", "devno", "evnames", "devicename", "evname", " devName"], "device": ["dc", "task", "machine", "ev", "attribute", "host", "disk", "di", "buffer", "cpu", "mode", "option", "address", "config", "gpu", "driver", "object", "devices", "DA", "parent", "dev", "path", "serial", "Device", "conn", "module", "pod", "connection", "node", "d", "model", "target", "data", "product", "mount", "display", "unit", "server", "custom", "component", "package", "de", "project"], "label": ["brand", "info", " Label", "border", "hide", "abel", "module", "ride", "key", "ref", "diff", "data", "tex", "null", "note", "comment", "desc", "test", "call", "val", "loc", "name", "address", "config", "driver", "len", "lab", "align", "ind", "summary", "model", "group", "cell", "prefix", "channel", "title", "console", "text", "bridge", "el", "length", "dl", "description", "bind", "err", "error", "style", "output", "Label", "value", "li", "unit", "node", "new", "layout", "block", "link", "code", "frame", "load", "bl", " labels", "path", "alias", "col", "session", "display", "field", "mark"], "bus_opts": ["bus_optte", "bus_opttd", "bus_cht", "bus___opt", "bus_OPte", "bus_optpt", "bus_opments", "bus_ops", "bus_oppt", "bus_optts", "bus___opts", "bus_OPments", "bus_operments", "bus_chtd", "bus_OPt", "bus_opers", "bus___optd", "bus_opert", "bus_opt", "bus_chpt", "bus_optd", "bus___oppt", "bus_OPts", "bus_optt", "bus_operts", "bus_operte", "bus_opte", "bus_opents", "bus_OPents", "bus_OPs", "bus_optents", "bus_chts", "bus_optments"], "dev_opts": ["dev_OPtr", "dev_optr", "dev_OPter", "dev_copt", "dev_OPps", "dev_hoptes", "dev_poptr", "dev_popps", "dev_imcs", "dev_OPtes", "dev_apptes", "dev_opt", "dev_hopts", "dev_optts", "dev_optt", "dev_operts", "dev_ops", "dev_appt", "dev_opTS", "dev_optter", "dev_imts", "dev_hopTS", "dev_OPcs", "dev_popt", "dev_hopt", "dev_ims", "dev_opert", "dev_opps", "dev_opers", "dev_optes", "dev_optcs", "dev_imt", "dev_OPs", "dev_popts", "dev_appTS", "dev_opcs", "dev_copps", "dev_operter", "dev_appts", "dev_OPt", "dev_opter", "dev_copts", "dev_coptr", "dev_OPts", "dev_OPTS"], "index": ["loop", "condition", "part", "prefix", "element", "update", "match", "image", "x", "axis", "ion", "ix", "test", "version", "section", "current", "code", "num", "route", "pointer", "offset", "loc", "name", "type", "address", "length", "option", "config", "insert", "valid", "ini", "pattern", "body", "len", "position", "action", "search", "ind", "error", "page", "localhost", "find", "key", "connection", "output", "point", "value", "size", "end", "date", "ticket", "instance", "pos", "diff", "append", "input", "count", "i", "form", "number", "column", "Index", "level", "slice", "inc", "comment"]}}
{"project": "qemu", "commit_id": "6cff3e8594cd974a507d531da09455d1c7aeb30d", "target": 0, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n", "idx": 21256, "substitutes": {"mon": ["mc", "dm", "bro", "my", "man", "mun", "Mon", "bo", "pid", "block", "don", "num", "http", "mo", "kin", "an", "pm", "config", "mos", "mn", "mm", "prem", "mor", "n", "con", "emon", "sm", "meter", "conn", "mag", "module", "non", "manager", "connection", "mut", "MON", "dom", "on", "ann", "member", "mand", "om", "atom", "m", "mi", "param", "am", "un", "mons", "monitor", "amon", "mu"], "str": ["dc", "st", "br", "ner", "iter", "cl", "lc", "enc", "cli", "stri", "fr", "cr", "sr", "cur", "pass", "sc", "strings", "err", "r", "or", "STR", "chain", "ctr", "inner", "cm", "Str", "tr", "arc", "arr", "sp", "dr", "exec"], "c": ["C", "dc", "mc", "comment", "cf", "cy", "cl", "x", "xc", "p", "lc", "cu", "enc", "h", "cc", "code", "ac", "ce", "f", "cr", "uc", "sc", "b", "v", "fc", "ct", "exc", "e", "cs", "y", "l", "r", "ch", "chain", "u", "cm", "esc", "arc", "d", "bc", "unc", "tc", "i", "m", "ci", "t", "nc", "g", "ec"]}}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n", "idx": 21261, "substitutes": {"s": ["settings", "states", "sets", "S", "ks", "sq", "w", "p", "sym", "less", "ls", "h", "sync", "sg", "us", "ses", "ds", "f", "sim", "sec", "stats", "is", "ss", "ts", "b", "si", "a", "n", "c", "ps", "hs", "o", "sb", "e", "cs", "r", "l", "args", "service", "session", "u", "services", "qs", "es", "d", "ssl", "ctx", "gs", "i", "os", "sys", "su", "t", "self", "sf", "m", "conf", "ns", "g", "spec", "sl", "js"], "seg_reg": ["sega_run", "seG_Reg", "seg__reg", "sega_reg", "sereg_ret", "segpreg", "segptag", "seG_reg", "seg_rec", "seg_rule", "segpREG", "segn_rec", "seg_run", "seg_Reg", "segprun", "seg__num", "seg_min", "sega_tag", "seg_ret", "sereg_min", "seig_reg", "sega_REG", "seig_rule", "sereg_num", "seig_min", "seg_num", "seG_num", "segn_register", "seG_rec", "seg_tag", "seig_rec", "seg__rec", "seg__Reg", "sereg_REG", "sereg_tag", "segn_reg", "seg_register", "sereg_reg", "seg_REG"]}}
{"project": "qemu", "commit_id": "5d98bf8f38c17a348ab6e8af196088cd4953acd0", "target": 0, "func": "void gen_intermediate_code_a64(ARMCPU *cpu, TranslationBlock *tb)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    target_ulong next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n\n\n    dc->aarch64 = 1;\n\n    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then\n\n     * there is no secure EL1, so we route exceptions to EL3.\n\n     */\n\n    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&\n\n                               !arm_el_is_aa64(env, 3);\n\n    dc->thumb = 0;\n\n    dc->bswap_code = 0;\n\n    dc->condexec_mask = 0;\n\n    dc->condexec_cond = 0;\n\n    dc->mmu_idx = ARM_TBFLAG_MMUIDX(tb->flags);\n\n    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (dc->current_el == 0);\n\n#endif\n\n    dc->fp_excp_el = ARM_TBFLAG_FPEXC_EL(tb->flags);\n\n    dc->vec_len = 0;\n\n    dc->vec_stride = 0;\n\n    dc->cp_regs = cpu->cp_regs;\n\n    dc->features = env->features;\n\n\n\n    /* Single step state. The code-generation logic here is:\n\n     *  SS_ACTIVE == 0:\n\n     *   generate code with no special handling for single-stepping (except\n\n     *   that anything that can make us go to SS_ACTIVE == 1 must end the TB;\n\n     *   this happens anyway because those changes are all system register or\n\n     *   PSTATE writes).\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 1: (active-not-pending)\n\n     *   emit code for one insn\n\n     *   emit code to clear PSTATE.SS\n\n     *   emit code to generate software step exception for completed step\n\n     *   end TB (as usual for having generated an exception)\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 0: (active-pending)\n\n     *   emit code to generate a software step exception\n\n     *   end the TB\n\n     */\n\n    dc->ss_active = ARM_TBFLAG_SS_ACTIVE(tb->flags);\n\n    dc->pstate_ss = ARM_TBFLAG_PSTATE_SS(tb->flags);\n\n    dc->is_ldex = false;\n\n    dc->ss_same_el = (arm_debug_target_el(env) == dc->current_el);\n\n\n\n    init_tmp_a64_array(dc);\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    tcg_clear_temp_count();\n\n\n\n    do {\n\n        tcg_gen_insn_start(dc->pc, 0);\n\n        num_insns++;\n\n\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    gen_exception_internal_insn(dc, 0, EXCP_DEBUG);\n\n                    /* Advance PC so that clearing the breakpoint will\n\n                       invalidate this TB.  */\n\n                    dc->pc += 2;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc->ss_active && !dc->pstate_ss) {\n\n            /* Singlestep state is Active-pending.\n\n             * If we're in this state at the start of a TB then either\n\n             *  a) we just took an exception to an EL which is being debugged\n\n             *     and this is the first insn in the exception handler\n\n             *  b) debug exceptions were masked and we just unmasked them\n\n             *     without changing EL (eg by clearing PSTATE.D)\n\n             * In either case we're going to take a swstep exception in the\n\n             * \"did not step an insn\" case, and so the syndrome ISV and EX\n\n             * bits should be zero.\n\n             */\n\n            assert(num_insns == 1);\n\n            gen_exception(EXCP_UDEF, syn_swstep(dc->ss_same_el, 0, 0),\n\n                          default_exception_el(dc));\n\n            dc->is_jmp = DISAS_EXC;\n\n            break;\n\n        }\n\n\n\n        disas_a64_insn(env, dc);\n\n\n\n        if (tcg_check_temp_count()) {\n\n            fprintf(stderr, \"TCG temporary leak before \"TARGET_FMT_lx\"\\n\",\n\n                    dc->pc);\n\n        }\n\n\n\n        /* Translation stops when a conditional branch is encountered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefetch aborts occur at the right place.\n\n         */\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             !dc->ss_active &&\n\n             dc->pc < next_page_start &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(cs->singlestep_enabled || dc->ss_active)\n\n        && dc->is_jmp != DISAS_EXC) {\n\n        /* Note that this means single stepping WFI doesn't halt the CPU.\n\n         * For conditional branch insns this is harmless unreachable code as\n\n         * gen_goto_tb() has already handled emitting the debug exception\n\n         * (and thus a tb-jump is not possible when singlestepping).\n\n         */\n\n        assert(dc->is_jmp != DISAS_TB_JUMP);\n\n        if (dc->is_jmp != DISAS_JUMP) {\n\n            gen_a64_set_pc_im(dc->pc);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            gen_exception_internal(EXCP_DEBUG);\n\n        } else {\n\n            gen_step_complete_exception(dc);\n\n        }\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_UPDATE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            /* fall through */\n\n        case DISAS_JUMP:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n        case DISAS_EXC:\n\n        case DISAS_SWI:\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_WFI:\n\n            /* This is a special case because we don't want to just halt the CPU\n\n             * if trying to debug across a WFI.\n\n             */\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         4 | (dc->bswap_code << 1));\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 21267, "substitutes": {"cpu": ["mc", "lb", "chip", "cfg", "gp", "CPU", "gc", "cache", "lc", "uci", "linux", "core", "processor", "process", "frame", "proc", "config", "gpu", "net", "roc", "pc", "uc", "vm", "device", "fc", "c", "spec", "conn", "hw", "auc", "boot", "bc", "np", "cp", "pu", "rc", "cca", "ctx", "cpp", "sys", "cmp", "nc", "cn", "node", "hp"], "tb": ["ptb", "tsk", "ttang", " tbase", "tf", "pp", "ptbb", "ptang", " temb", " tk", "tsa", "ktbi", "Tnb", "pb", "tz", "pf", "tsbar", "ttbs", "ptbs", "ttb", "ktbs", "tapp", "ptbi", "tememb", "teb", " tbb", "ptsb", "temb", "tsbl", " tbar", " tbs", "Tapp", "ptbase", "ttbl", "temeb", "tbi", "pbs", " tbi", "tembi", "otsb", "tbl", "tsnb", "otbase", "ttz", "ktf", "tk", "otbs", "otemb", "tteb", "tsbs", "otbl", "tsemb", "ttapp", "ttf", "Tb", "tsb", "ttp", "ktb", "ptp", "pang", "ttbar", " tsb", "tbs", "otbb", "otb", " tz", " teb", "tang", "ta", "pz", "tbb", "ttbi", "tbase", "tsapp", "ttnb", "Ta", "ptf", "tp", "tbar", "pk", "tta", "ttk", " tf", "ttemb", "tnb"], "cs": ["mc", "cf", "Cs", "cms", "ks", "rs", "ec", "lc", "css", "sync", "cc", "ras", "ds", "cus", "pc", "fs", "sc", "acs", "c", "utils", "CS", "ps", "ck", "cas", "conn", "sk", "qs", "wcs", "bc", "cp", "rc", "tc", "ctx", "sys", "bs", "vs", "nc", "ns", "ls", "spec"], "env": ["req", "cv", "cache", "proc", "eng", "equ", "anc", "dev", "exe", "dest", "conf", "spec", "ec", "ext", "desc", "machine", "stage", "ev", "en", "ea", "core", "db", "cli", "ef", "config", "uv", "cmd", "e", "args", "kernel", "end", "viron", "np", "Environment", "rc", "environment", "eu", "cfg", "console", "eve", "gui", "enc", "host", "dict", "net", "enh", "vm", "agent", "err", "dat", "style", "ne", "scope", "ctx", "energy", "qt", "cf", "eni", "que", "dt", "extra", "exc", "cb", "path", "estate", "engine", "conn", "session", "impl", "txt", "er", "context", "loader", "skin"], "dc1": ["vc2", "mc8", "ncone", "cf0", "mc1", "vc1", "mc2", "nc0", "dc2", "cfone", "fc0", "nc1", " dc8", "dc8", "cf1", " dc2", "fcone", "fc1", "dcone", "dc0", "vc8"], "dc": ["dm", "mc", "desc", "cf", "cfg", "de", "du", "doc", "gc", "lc", "ea", "cd", "cc", "acl", "dt", "di", "db", "ac", "DC", "loc", "die", "ds", "config", "dl", "pc", "uc", "disc", "controller", "cmd", "jc", "sc", "device", "fc", "mac", "ct", "dir", "df", "c", "ga", " DC", "da", "dat", "conn", "acc", "fd", "col", "auc", "dest", "cm", "d", "bc", "tc", "design", "rc", "input", "cdn", "data", "dk", "vc", "dr", "abc", "ctrl", "nc", "dp", "enter", "inc", "ec"], "pc_start": ["pc_end", "pc67pos", "page_pos", "pc67start", "pc_size", "cp_start", "cp_pos", "pc67block", "pc__start", "cp__end", "pageamstart", "pcampos", "PC_count", "PC_end", "pc__block", "pc_started", "pc67started", "channel_start", "pc67count", "pc__end", "channel_size", "page_add", "cp__pos", "pc__size", "pageampos", "pageamend", "pc_add", "pc_count", "page_end", "PC_start", "pc67end", "pc_pos", "pc__pos", "pcamstart", "pc_block", "page_start", "pcamadd", "PC_started", "channel_end", "cp__start", "channel_pos", "cp_block", "cp__block", "cp_end", "pcamend", "pageamadd", "pc67add"], "next_page_start": ["next_page__started", "next_page___end", "next_page2use", "next_page_count", "next_page___start", "next_page__end", "next_page_started", "next_page2start", "next_page_stop", "next_page___started", "next_page2count", "next_page__start", "next_page__stop", "next_page_end", "next_page2end", "next_page___stop", "next_page_use"], "num_insns": ["num_winn", "num_winvs", "num_incns", "num_invs", "num__insqs", "num_incqs", "num_incs", "num_ginvs", "num_intsn", "num__inscs", "num_intsns", "num_insqs", "num__insns", "num_inn", "num_ginn", "num_inns", "num__incqs", "num_winns", "num_inscs", "num_insn", "num_insvs", "num_inqs", "num__inccs", "num_ginns", "num_incn", "num__insn", "num_gincs", "num_inccs", "num__incns", "num_intscs", "num__incn", "num_wincs", "num_intsqs"], "max_insns": ["max_gescs", "max_inns", "maximthis", "max_gesns", "max_gesks", "max_incnas", "max_inks", "max_inscs", "max_incns", "max_insnas", "max_this", " max_\n", "maxim\n", "max_insks", "max_innas", "max_inccs", "max_\n", "max_gesnas", "max_incs", "max_incks", " max_this"]}}
{"project": "FFmpeg", "commit_id": "2ac00d2d1d51047c6ce69d5fbe1a08392d142658", "target": 0, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {\n\n            sc->stsc_data[i].id = 0;\n\n            if (c->fc->error_recognition & AV_EF_EXPLODE) {\n\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 21281, "substitutes": {"c": ["C", "dc", "mc", "cf", "cy", "cl", "w", "cv", "xc", "cache", "p", "lc", "cu", "enc", "cc", "co", "ac", "ce", "f", "config", "cus", "coll", "pc", "uc", "cur", "cr", "b", "v", "fc", "ct", "n", "con", "ca", "com", "cs", "l", "cycle", "ch", "u", "cm", "arc", "bc", "ic", "cp", "tc", "rc", "ctx", "vc", "k", "m", "ci", "conf", "t", "ctrl", "nc", "g", "cell", "ec", "icc"], "pb": ["typ", "lb", "bm", "pd", "wb", "cv", "pa", "p", "lc", "jp", "bb", "platform", "db", "xb", "phrase", "pg", "pm", "pc", "uc", "bf", "b", "mp", "fc", "bh", "pp", "lab", "ub", "pro", "cb", "lp", "sb", "bp", "bps", "ab", "prot", "fp", "py", "hub", "ref", "pl", "tp", "summary", "bc", "np", "cp", "PB", "rob", "rc", "tc", "bot", "ctx", "ppa", "cpp", "gb", "pkg", "fb", "dp", "eb", "wp", "rb"], "atom": [" ax", " acc", "orb", " orb", " am", " arr", " com", " ap", " ac", " subp", " mom", " slab", "com", " parent", "cm", " plat", " Atom", " adm", "bc", " program", " form", "abc", " app", "am", "mom", " ab", " om", " atoms"], "st": ["inst", "sts", "cl", "cv", "src", "p", "lc", "fe", "sync", "sa", "se", "ft", "s", "ST", "pc", "cr", "uc", "sci", "St", "ss", "ct", "sth", "sw", "sb", "pt", "osc", "r", "sta", "ch", "std", "str", "bc", "ost", "sp", "sd", "t", "SC", "sl", "sec", "ste", "sn"], "sc": ["dc", "match", "cont", "cv", "cache", "lc", "co", "cur", "anc", "sche", "cer", "ca", "sb", "Sc", "cs", "bc", "soc", "spec", "ec", "desc", "crit", "cl", "src", "contract", "cc", "core", "sa", "loc", "go", "cli", "pg", "config", "cr", "pc", "ced", "rc", "sd", "SC", "mc", "capt", "enc", "sci", "uc", "ga", "osc", "ch", "esc", "tc", "scope", "cca", "ctx", "sp", "client", "cam", "asc", "icc", "cf", "sq", "sync", "isc", "cus", "usc", "ss", "ct", "fc", "sw", "sub", "acc", "ctrl", "nc", "exec", "sec", "inc"], "i": ["ii", "qi", "ix", "p", "phi", "info", "f", "s", "si", "pi", "u", "mini", "data", "count", "k", "mi", "multi", "inner", "ti", "ji", "iv", "I", "ri", "cli", "j", "ni", "ski", "b", "n", "uri", "index", "entry", "e", "y", "xi", "id", "slice", "gi", "ip", "ui", "esi", "h", "ie", "oi", "init", "v", "l", "r", "limit", "fi", "li", "hi", "zi", "ci", "m", "t", "g", "z", "bi", "it", "abi", "x", "eni", "code", "di", "type", "ai", "ini", "start", "ei", "o", "d", "in", "iu", "field", "mu"], "entries": ["ENTrys", "gentrations", "entried", "entrs", "distrys", "estry", "entorts", "attrys", "etrys", "Entresses", "entents", "nturies", "centrys", "entresses", "ntried", "centries", "ientues", "enturies", "ntrics", "estried", "entsencies", "etures", "gentry", "attries", "entues", "centrics", "etrics", "gentorts", "ntry", "gentents", "entry", "genturies", "centures", "gentrys", "ientry", "centry", "ENTrows", "ntrows", "gentrows", "ntries", "extencies", "ENTries", "entures", "ENTrs", "distries", "extures", "entrys", "ENTues", "gentried", "ientries", "attents", "estries", "ntures", "Entrs", "entsries", "extries", "Entrys", "gentries", "ientrys", "estrations", "entencies", "ENTresses", "ntrys", "gentures", "entsures", "entrics", "etries", "ntents", "entrations", "distresses", "distrs", "gentencies", "entrows", "ENTry", "entsorts", "extorts", "Entries", "centues", "ntrations", "atturies"]}}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n", "idx": 21284, "substitutes": {"frame": ["channel", "zip", "image", "line", "iframe", "host", "rame", "block", "code", "buffer", "force", " Frame", "type", "f", "config", "fr", "family", "base", "cb", "range", "Frame", "cycle", "flow", "window", "ref", "source", "target", "frames", "fake", "live", "slice", "file", "scene", "fram"], "height": ["shape", "hd", "w", "windows", "h", "row", "gh", "img", "depth", "ows", "upper", "length", "head", "driver", "max", "rows", "rh", "Height", "dir", "images", "padding", "fw", "build", "style", "y", "window", "crop", "end", "hang", "size", "ops", "bottom", "pull", "resolution", "direction", "container", "pad", "work", "stroke", "ip"], "src": ["channel", "desc", "inst", "image", "origin", "rs", "inf", "sync", "core", "img", "rss", "offset", "buffer", "loc", "low", "head", "length", "start", "len", "stream", "scale", "buf", "send", "sb", "cb", "rib", "filename", "ref", "crop", "dest", "dist", "ctr", "source", "sel", "target", "url", "rc", "rob", "attr", "split", "ssl", "ptr", "ctx", "gb", "slice", "lib", "scene", "sl", "rb", "comp"], "src_end": [" src_start", "src_start", "source_id", " src_id", "source_start", "source_end", "src_id"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n", "idx": 21296, "substitutes": {"n": ["z", "x", "w", "nm", "p", "en", "num", "name", "nn", "j", "f", "config", "s", "na", "net", "nb", "mn", "b", "v", "c", "o", "e", "y", "l", "conn", "r", "nt", "N", "u", "d", "ne", "np", "k", "i", "self", "m", "t", "dn", "fn", "client", "yn", "un", "nc", "nu", "network", "cn", "node", "g", "sn"], "cmd": ["dc", "cfg", "cf", "def", "cl", "w", "resp", "h", "prop", "cd", "cc", "code", "num", "cli", "msg", "head", "mode", "md", "qt", "qq", "q", "cr", "config", "request", "ack", "xml", "init", "comm", "mac", "cod", "c", "bind", "ck", "cb", "conn", "args", "module", "nt", "cookie", "Cmd", "ctr", "command", "gen", "d", "cp", "obj", "input", "ctx", "id", "vc", "m", "dr", "pkg", "grad", "cmp", "ctrl", "client", "cn", "node", "dom", "op"], "req": ["crit", "ok", "gr", "def", "res", "resp", "w", "require", "cache", "row", "call", "required", "http", "rt", "proc", "ret", "md", "qq", "response", "q", "cr", "cur", "request", "rx", "ru", "ry", "rb", " request", "seq", "pro", "cb", "reg", "err", "rr", "user", "r", "cook", "ref", "requ", "ctr", "str", "progress", "pull", "rf", "ctx", "rw", "conf", "orig", "grad", "client", "method", "rec", "get"], "ns": ["mc", "sts", "ks", "lines", "nets", "w", "ims", "sync", "names", "ds", "na", "s", "xs", "net", "nav", "coll", "fs", "xml", "ss", "si", "c", "ys", "ps", "nas", "cs", "conn", "nt", "nw", "sk", "qs", "outs", "ips", "ne", "NS", "syn", "nos", "gs", "sp", "ctx", "os", "Ns", "sys", "bs", "vs", "nc", "cn", "ls", "ms", "ains", "sn"]}}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n", "idx": 21302, "substitutes": {"link": ["ace", "image", "line", "match", "parse", "cross", "lc", "call", "sync", "block", "local", "http", "di", "name", "loc", "load", "type", "like", "pack", "friend", "info", "f", "Link", "lock", "feed", "bug", "linked", "links", "filter", "a", "parent", "ck", "base", "mail", "action", "hip", "e", "style", "play", "l", "user", "module", "service", "message", "key", "lang", "connection", "install", "dd", "source", "plugin", "ink", "check", "li", "pull", "url", "model", "child", "hack", "plug", "id", "list", "lib", "file", "group", "tag", "comment"], "i": ["ti", "ui", "ii", "abi", "ji", "qi", "x", "I", "ix", "p", "phi", "di", "ri", "name", "j", "info", "f", "ai", "type", "ini", "oi", "ni", "si", "io", "b", "v", "pi", "uri", "index", "ami", "base", "o", "e", "wei", "y", "l", "xi", "key", "u", "chi", "yi", "fi", "li", "d", "iu", "hi", "m", "multi", "zi", "ci", "mi", "gi", "mu", "bi", "ip"], "picref": ["nicreference", "Picblock", "pinflow", "icreference", "pcRef", " picblock", "pcref", "icref", "pinreference", "Picrel", "pictreference", " picdef", "pictref", "docref", "pcrel", "pinRef", "PicRef", "Picreference", "nicref", "pcdef", "pinref", "pictRef", "Picdef", "picdef", "pinblock", "docflow", "picblock", "pinrel", "picflow", "nicrel", " picreference", "icRef", "pcflow", "Picref", "pcreference", " picRef", "picreference", "docrel", "nicRef", "icrel", "docreference", "picrel", "pictrel", "picRef"]}}
{"project": "qemu", "commit_id": "375cb560295484b88898262ebf400eff9a011206", "target": 0, "func": "static uint64_t pl110_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl110_state *s = (pl110_state *)opaque;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return idregs[s->version][(offset - 0xfe0) >> 2];\n\n    }\n\n    if (offset >= 0x200 && offset < 0x400) {\n\n        return s->raw_palette[(offset - 0x200) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* LCDTiming0 */\n\n        return s->timing[0];\n\n    case 1: /* LCDTiming1 */\n\n        return s->timing[1];\n\n    case 2: /* LCDTiming2 */\n\n        return s->timing[2];\n\n    case 3: /* LCDTiming3 */\n\n        return s->timing[3];\n\n    case 4: /* LCDUPBASE */\n\n        return s->upbase;\n\n    case 5: /* LCDLPBASE */\n\n        return s->lpbase;\n\n    case 6: /* LCDIMSC */\n\n        if (s->version != PL110) {\n\n            return s->cr;\n\n        }\n\n        return s->int_mask;\n\n    case 7: /* LCDControl */\n\n        if (s->version != PL110) {\n\n            return s->int_mask;\n\n        }\n\n        return s->cr;\n\n    case 8: /* LCDRIS */\n\n        return s->int_status;\n\n    case 9: /* LCDMIS */\n\n        return s->int_status & s->int_mask;\n\n    case 11: /* LCDUPCURR */\n\n        /* TODO: Implement vertical refresh.  */\n\n        return s->upbase;\n\n    case 12: /* LCDLPCURR */\n\n        return s->lpbase;\n\n    default:\n\n        hw_error(\"pl110_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 21306, "substitutes": {"opaque": ["ospaque", " opula", " opa", " opbuffer", "opque", "operbuffer", "opera", "opacity", " opque", "operae", "ospae", "opbuffer", "opae", "opusacity", "opusbuffer", "ospque", "opa", "operula", " opacity", "opula", "operque", "ospa", "operacity", "operaque", "opusaque", " opae", "opusula"], "offset": ["always", "part", "timeout", "operation", "image", "origin", "layout", "attribute", "p", "reset", "row", "sync", "location", "route", "pointer", "loc", "address", "length", "Offset", "online", "object", "start", "fee", "len", "next", "index", "padding", "align", "seed", "position", "base", "o", "slot", "entry", "alias", "range", "error", "style", "page", "usage", "limit", "outer", "oid", "off", "et", "api", "url", "pos", "data", "ptr", "optional", "oa", "shift", "id", "i", "office", "number", "server", "skip", "addr", "phase", "notation", "set", "prefix", "offer", "bytes"], "size": ["timeout", " bytes", " address", "izes", "address", "length", "start", " error", "Size", " sizes", "fee", "len", "scale", "SIZE", "from", " length", "ize", "data", "count", "sized", " data", "set", "bytes"], "s": ["ins", "south", "secondary", " errors", "p", "ows", "ed", "f", "words", "si", "ists", "a", "sb", "cs", "erences", " settings", "ports", "ops", "itions", "gs", "i", "ers", "conf", " values", "ees", "spec", " results", "aws", "ds", "ses", "results", "rows", "is", "b", "ts", "ps", "e", "ing", "y", "ies", "services", "changes", "outs", "ips", "comments", "os", "ries", "alls", "resses", "states", "S", "lines", "sym", "h", "site", "ors", "ments", "ions", "ings", "its", "c", "l", "service", "or", "times", "es", "ands", "sys", "t", "socket", "server", "eds", "sl", "g", "has", "ations", "new", "sets", "sq", "rs", "sync", "als", "irs", "fs", "ss", "ances", "o", "session", "d", "ssl", "self", "sf", "er", "ients", "ns", "ls", "sg", "ures", "js"]}}
{"project": "FFmpeg", "commit_id": "eb38d8fe926bdce8110fa4be4fddf6598a079a20", "target": 0, "func": "static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,\n\n                sb_int8_array coding_method, int nb_channels,\n\n                int c, int superblocktype_2_3, int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    // This should never happen\n\n    if (nb_channels <= 0)\n\n        return;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 21311, "substitutes": {"tone_level_idx": ["tone_level_infoxx", "tone_level_namev", "tone_level_namexc", "tone_level_namex", "tone_level_infoxs", "tone_level_endz", "tone_level_endxs", "tone_level_inxs", "tone_level_its", "tone_level_idsx", "tone_level_countw", "tone_level_itx", "tone_level_endy", "tone_level_idy", "tone_level_namez", "tone_level_Idx", "tone_level_idsxes", "tone_level_Idxs", "tone_level_idxx", "tone_level_onexc", "tone_level_infoX", "tone_level_inz", "tone_level_counts", "tone_level_idsv", "tone_level_IdX", "tone_level_inx", "tone_level_idw", "tone_level_Idy", "tone_level_idv", "tone_level_idxc", "tone_level_idxs", "tone_level_countx", "tone_level_itxs", "tone_level_onexes", "tone_level_idsz", "tone_level_inxx", "tone_level_idsxc", "tone_level_onez", "tone_level_itw", "tone_level_infoz", "tone_level_ids", "tone_level_idX", "tone_level_onex", "tone_level_idz", "tone_level_Idz", "tone_level_countxs", "tone_level_infox", "tone_level_endx", "tone_level_idxes"], "tone_level_idx_temp": ["tone_level_idz_Temp", "tone_level_idf_temp", "tone_level_idx_default", "tone_level_idx_current", "tone_level_idx_source", "tone_level_idx_level", "tone_level_idf_cache", "tone_level_idg_temp", "tone_level_idx_buffer", "tone_level_idz_temp", "tone_level_idx_Temp", "tone_level_idf_clean", "tone_level_idg_source", "tone_level_idg_default", "tone_level_idx_tmp", "tone_level_idf_current", "tone_level_idg_level", "tone_level_idz_tmp", "tone_level_idz_method", "tone_level_idx_method", "tone_level_idx_cache", "tone_level_idz_buffer", "tone_level_idx_clean"], "coding_method": ["coder_type", "coder_temp", "coding2method", "coder_method", "coding2temp", "coding2type", "coding_temp", "coding_type", "coder_function", "coding_function", "coding2function"], "nb_channels": ["nb__compars", "nb_chairs", "nbofchanchannel", "nb_chords", "nb_hairs", "nb_cannels", "nb_cbands", "nb_colchannel", "nbofchanunks", "nb__channels", "nb_colords", "nb_bannels", "nb_colunks", "nb_hars", "nb__compairs", "nb_bars", "nb_vannels", "nbofchannels", "nb_vchannel", "nb_chears", "nb__compannels", "nb_hbands", "nb_chunks", "nb_chanannels", "nb_chanunks", "nb_cars", "nb_vords", "nb_compairs", "nb__chords", "nb_vunks", "nbofchanords", "nb_chanords", "nb_compords", "nb_hchannel", "nb_chars", "nb__compords", "nbofchchannel", "nb_chbands", "nb_bbands", "nb_cheairs", "nb__chars", "nb_cchannel", "nb_colannels", "nb_chchannel", "nbofchunks", "nb_hords", "nb_hannels", "nb_compannels", "nbofchords", "nb_cheords", "nbofchanannels", "nb_bchannel", "nb_cheannels", "nb__chairs", "nb_chanchannel", "nb_compars"], "c": ["C", "mc", "dc", "cl", "w", "xc", "cache", "p", "lc", "enc", "cc", "ac", "f", "b", "ct", "n", "con", "cod", "cb", "e", "conv", "cp", "count", "m", "ci", "cpp", "cmp", "nc"], "superblocktype_2_3": ["superblocktype_1_53", "superblocktype_1_3", "superblocktype_1_7", "superblocktype_2_three", "superblocktype_1_03", "superblocktype_2_03", "superblocktype_1_three", "superblocktype_2A03", "superblocktype_2A3", "superblocktype_2_53", "superblocktype_2A53", "superblocktype_2Athree", "superblocktype_2_7"], "cm_table_select": ["cm_table_use", "cm_interface_seq", "cm_table1use", "cm_table_list", "cm_table1select", "cm_table_seq", "cm_interface_list", "cm_table1seq", "cm_interface_select", "cm_table1list", "cm_interface_use"], "ch": ["cy", "p", "lc", "cd", "co", "f", "app", "s", "q", "eff", "com", "ky", "sk", "sch", "count", "k", "i", "conf", "all", " cs", "cor", "chart", "cl", "th", "gh", "_", "loc", "ce", "zh", "fr", "cher", "b", "chi", "ich", "cm", "rc", "chu", "cell", "channel", "Ch", "h", "bb", "buff", "qu", "CH", "v", "hw", "ph", "sh", "ach", "cho", "ctx", "cpp", "ci", "g", "uch", "cf", "ht", "code", "che", "bh", "ct", "chn", "cb", "och", "conn", "chan", "col", "session", "cp", "vc", "cmp", "number", "cel", "cha", "cht"], "sb": ["bm", "sit", "lc", "ib", "s", "si", "sm", "bp", "sk", "pb", "ff", "bc", "i", "abb", "gb", "fb", "bs", "sv", "lb", "src", "jp", "sa", "sy", "num", "db", "nn", "zh", "bf", "b", "sc", "jc", "n", "jj", "mb", "obb", "sel", "ll", "sup", "sd", "lr", "dy", "shop", "wb", "bb", "length", "dl", "bg", "sci", "nb", "btn", "cod", "SB", "yi", "sh", "sp", "sl", "g", "java", "rb", "sn", "sq", "sync", "bl", "ss", "bh", "sth", "sub", "sie", "cb", "bj", "conn", "kb", "syn", "split", "stab", "usb", "sf", "ctrl", "cel", "cn", "eb", "sg", "ann"], "j": ["ji", "jen", "jon", "br", "jit", "dj", "x", "pa", "jp", "p", "jo", "pr", "jam", "el", "jet", "je", "f", "ja", "ie", "q", "fr", "b", "jc", "si", "v", "uj", "kj", "ju", "n", "adj", "bj", "o", "jj", "ind", "pt", "y", "l", "r", "ij", "u", "li", "pos", "obj", "J", "job", "k", "i", "sp", "m", "er", "sn", "it", "aj", "note", "g", "jan", "z", "jl"], "tmp": ["zip", "stuff", "beta", "tt", "resp", "cache", "jp", "p", "bb", "src", "test", "area", "yy", "img", "offset", "elt", "proc", "Temp", "app", "config", "extra", "xxx", "nb", "vv", "pot", "bf", "diff", "mm", "mp", "v", "temp", "wx", "amp", "buf", "seed", "adj", "cb", "alpha", "jj", "vt", "pre", "output", "sup", "ff", "tp", "np", "cp", "attr", "api", "tc", "obj", "ptr", "rc", "tem", "ctx", "sp", "emp", "pad", "kk", "fake", "txt", "fb", "cmp", "xxxx", "rb", "prefix"], "acc": ["att", "circ", "aa", "cont", "cache", "test", "cc", "img", "ac", "app", "config", "ai", "amp", "seed", "adj", "eff", "ind", "alpha", "cond", "attr", "input", "emp", "ad", "abc", "cmp", "add", "rec", "op"], "esp_40": ["esp_len", "esp_layer", "asm_len", "asm_layer", "asm_buffer", "esp_buffer", "asm_40"], "comp": ["circ", "omp", "cache", "bb", "code", "co", "loc", "proc", "config", "cur", "seq", "amp", "quad", "mod", "com", "ctr", "cond", "frac", "pos", "cp", "comb", "conf", "cmp", "component", "lib", "rec", "op"], "add1": ["added16", "added2", "ad4", "added3", "added8", "dd2", "load2", "added7", " add16", "Add2", "adOne", "add8", "ad16", "Add1", " add8", "AddOne", " addOne", "addOne", "ad1", "load99", "ad2", "add99", "Add3", "Add7", "dd1", "load1", " add99", "add7", "ad8", "Add4", "added1", "dd99", "add16", "added4", " add7", "dd4"], "add2": ["added2", "call4", "added8", "addedsecond", " add62", "ad4", "inc1", "added62", " add56", " addTwo", "add14", "add56", "addedTwo", "add62", "add8", "send4", "Add2", "added22", "sendTwo", " add8", "Add1", " add22", "address2", "ad22", "add22", "address92", "Add14", "call2", "ad2", "send2", "sendsecond", "addsecond", "address4", "apply2", "add92", " add82", "inc56", "inc92", "call92", "add82", "apply8", "address56", "Add4", "call82", "inc4", "apply4", "address82", "inc2", "added4", "apply62", "inc14", "addTwo", " addsecond", " add92", " add14"], "add3": ["apply3", "push3", "add15", "add6", "add123", "call3", "add13", "inc83", "ad1", "applythree", "dd1", " addThree", "inc44", "do6", "addThree", "dd4", "inc39", "ad4", "extra1", "add236", "ddthree", "inc43", "extra83", "added43", "callIII", "apply03", "extra3", "extraThree", "app236", "join3", "plusThree", "extrathree", "add39", "push6", "add44", "app44", "dd3", "add43", "applyThree", " add43", "inc236", "join236", "Add03", "addthree", "extra15", "inc13", "Addthree", "Add3", "add83", "plus15", "plus3", "do3", "plus83", "AddThree", "do123", " addthree", "ad3", " add03", "incThree", "add03", "app3", "doIII", "extra4", "added3", "adthree", "added13", "inc3", "inc15", "app39", "call6", " add13", "addIII", "join39", "join44", "push123", "pushIII", "inc4", "call123", "added4"], "add4": ["added2", "ad4", " add94", "add6", "append4", "added24", " add6", "added44", "Add2", " addfour", " add22", " add47", "address22", " add44", "inc47", "address2", "append94", "Add6", "append2", "inc22", "add24", "Add64", "add22", "apply94", "ad2", "inc24", "append22", " add24", "add47", "read2", "inc44", "add5", "addfour", "added6", "addedfour", "address4", "apply2", "address47", "adfour", "Add4", "added5", "inc64", "inc4", "inc5", "apply4", "inc2", "apply22", "add94", "add44", "add64", "added4", " add64", "Addfour", "inc6", "readfour", " add5", "read4"], "multres": ["ractrice", "addrice", "ractre", "emptre", "ractreed", "emptreed", "emptres", "ractres", "requres", "emptrice", "requrice", "addres", "requreed", "addreed", "requre", "addre"]}}
{"project": "qemu", "commit_id": "1e577cc7cffd3de14dbd321de5c3ef191c6ab07f", "target": 0, "func": "void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                        int flags)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    int i;\n\n\n\n    if (is_a64(env)) {\n\n        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);\n\n        return;\n\n    }\n\n\n\n    for(i=0;i<16;i++) {\n\n        cpu_fprintf(f, \"R%02d=%08x\", i, env->regs[i]);\n\n        if ((i % 4) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n        else\n\n            cpu_fprintf(f, \" \");\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t xpsr = xpsr_read(env);\n\n        const char *mode;\n\n\n\n        if (xpsr & XPSR_EXCP) {\n\n            mode = \"handler\";\n\n        } else {\n\n            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {\n\n                mode = \"unpriv-thread\";\n\n            } else {\n\n                mode = \"priv-thread\";\n\n            }\n\n        }\n\n\n\n        cpu_fprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\",\n\n                    xpsr,\n\n                    xpsr & XPSR_N ? 'N' : '-',\n\n                    xpsr & XPSR_Z ? 'Z' : '-',\n\n                    xpsr & XPSR_C ? 'C' : '-',\n\n                    xpsr & XPSR_V ? 'V' : '-',\n\n                    xpsr & XPSR_T ? 'T' : 'A',\n\n                    mode);\n\n    } else {\n\n        uint32_t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n", "idx": 21324, "substitutes": {"cs": ["ace", "cf", "Cs", "ks", "rs", "ix", "cache", "ec", "lc", "css", "sync", "cc", "ses", "ds", "s", "pc", "fs", "sc", "si", "acs", "c", "ys", "CS", "ca", "ps", "cas", "conn", "args", "ics", "sk", "qs", "wcs", "rc", "ctx", "gs", "sys", "ci", "bs", "vs", "nc", "cons", "ns", "ls", "spec"], "f": ["cf", "af", "w", "p", "h", "fe", "lf", "buff", "j", "s", "fr", "func", "fs", "tf", "xf", "b", "feed", "bf", "v", "fc", "files", "df", "F", "c", "fw", "fun", "cb", "o", "fen", "framework", "e", "l", "fa", "r", "fd", "fp", "filename", "function", "fo", "fi", "ff", "d", "rf", "m", "fx", "form", "fn", "fb", "sf", "file", "exec", "g", "of", "fm"], "cpu_fprintf": ["cpu_cfprintln", "cpu_fxformat", "cpu_fxprintln", "cpu_fprintln", "cpu_bappend", "cpu_Frite", "cpu_cprintln", "cpu_flt", "cpu_sflt", "cpu_bprint", "cpu_bmt", "cpu_fxlt", "cpu_dmt", "cpu_fappend", "cpu_rfdump", "cpu_cfprintf", "cpu_efprint", "cpu_rfprintln", "cpu_fxprintf", "cpu_fprint", "cpu_rfprint", "cpu_cformat", "cpu_cdump", "cpu_fdump", "cpu_rfprintf", "cpu_cprintf", "cpu_Fprintf", "cpu_bprintf", "cpu_lfprintln", "cpu_bprintln", "cpu_efprintf", "cpu_rfmt", "cpu_frite", "cpu_Fprintln", "cpu_sfprint", "cpu_efdump", "cpu_bformat", "cpu_dappend", "cpu_rfrite", "cpu_dprintf", "cpu_Fformat", "cpu_sfprintf", "cpu_bdump", "cpu_fxprint", "cpu_frint", "cpu_cfformat", "cpu_cprint", "cpu_fxrite", "cpu_efformat", "cpu_lfrint", "cpu_rfformat", "cpu_lfmt", "cpu_dprint", "cpu_fmt", "cpu_fformat", "cpu_lfprintf", "cpu_cmt", "cpu_cfmt", "cpu_brint"], "flags": ["settings", "forces", "lf", "reads", " Flags", "fish", "func", "stats", "ants", "fs", "faces", "fee", "files", "utils", "lag", "bits", "fun", "nl", "ils", "items", "Flags", "fd", "fps", "vals", "details", "includes", "fi", "features", "ffff", "ops", "ips", "flag", "FLAG", "acks", "plugins", "fields", "sf", "ints", "ags", "alls"], "cpu": ["mc", "cf", "CPU", "cv", "cache", "lc", "uci", "platform", "uca", "core", "clock", "processor", "cli", "proc", "gpu", "roc", "pc", "computer", "anc", "vm", "fc", "n", "c", "utils", "python", "conn", "cal", "cm", "fi", "bc", "np", "cp", "pu", "uno", "ctx", "nc", "cn", "loader", "bench", " cp"], "env": ["cv", "cache", "proc", "eng", "equ", "anc", "si", "enable", "exe", "et", "bc", "oa", "conf", "intern", "vs", "em", "spec", "ec", "ext", "desc", "stage", "ev", "iss", "en", "ea", "forge", "core", "db", "ce", "cli", "shell", "config", "e", "args", "viron", "Environment", "np", "environment", "eu", "param", "esp", "cfg", "inst", "console", "gui", "enc", "site", "el", "net", "enh", "vm", "v", "state", "c", "err", "style", "osc", "cal", "ass", "fi", "ne", "scope", "server", "assets", "energy", "qt", "settings", "eni", "code", "que", "dt", "lock", "exc", "fen", "engine", "conn", "esm", "sf", "kn", "er", "nc", "context", "exec", "loader", "skin"], "i": ["ti", "ui", "ii", "abi", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "name", "j", "ai", "counter", "oi", "ni", "start", "si", "io", "b", "v", "pi", "uri", "index", "n", "c", "uli", "o", "ind", "e", "wei", "min", "l", "col", "xi", "u", "key", "fi", "li", "in", "iu", "d", "child", "count", "hi", "k", "id", "zi", "ci", "multi", "m", "t", "slice", "gi", "mu", "bi", "it", "ip"], "mode": ["ace", "time", "line", "stage", "version", "mission", "access", "code", "route", "date", "bit", "name", "phrase", "type", "status", "option", "shell", "maybe", "language", "dim", "md", "driver", "chrom", "mm", "device", "lane", "mask", "mac", "track", "state", "view", "theme", "scale", "mod", "range", "ward", "day", "style", "password", "normal", "module", "key", "kind", "plugin", "size", "command", "model", "member", "slave", "direction", "strip", "role", "scope", "id", "m", "Mode", "MODE", "disable", "program", "phase", "tag", "no", "project"], "ns_status": ["css_num", "net_status", "ns__num", "ns__score", "ns_level", "ns_magic", "ns__status", "net_level", "ns_score", "ns__magic", "ns_num", "css_status", "ns__level", "css_magic", "net_score"]}}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n    int ret = 0;\n\n\n\n    trace_vmstate_load_state(vmsd->name, version_id);\n\n    if (version_id > vmsd->version_id) {\n\n        error_report(\"%s: incoming version_id %d is too new \"\n\n                     \"for local version_id %d\",\n\n                     vmsd->name, version_id, vmsd->version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        if (vmsd->load_state_old &&\n\n            version_id >= vmsd->minimum_version_id_old) {\n\n            ret = vmsd->load_state_old(f, opaque, version_id);\n\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n\n            return ret;\n\n        }\n\n        error_report(\"%s: incoming version_id %d is too old \"\n\n                     \"for local minimum version_id  %d\",\n\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if (vmsd->pre_load) {\n\n        int ret = vmsd->pre_load(opaque);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n    while (field->name) {\n\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n\n        if ((field->field_exists &&\n\n             field->field_exists(opaque, version_id)) ||\n\n            (!field->field_exists &&\n\n             field->version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n", "idx": 21335, "substitutes": {"f": ["af", "p", "inf", "h", "lf", "buff", "proc", "info", "fr", "fs", "tf", "xf", "b", "feed", "v", "files", "F", "c", "elf", "df", "o", "arf", "fen", "e", "fed", "l", "fa", "fd", "fp", "fac", "fo", "m", "form", "fx", "t", "fn", "fb", "sf", "file", "g", "exec"], "vmsd": ["vmsdal", "attimsu", "vMSdd", "vdsde", "vmsdie", "fcsde", "vasd", "vmsdl", "vapsdt", "promorsd", "vcsz", "varsdr", "vansd", "vmesdie", "vMSl", "lmesd", " vimsda", "vmwsd", "vvsu", "valsdl", "vimsu", "lmesmd", "vidsdd", "vbsdata", "vsdl", "vatsds", "gumsdat", "vamesdat", "ventsdat", "vssd", "vvscd", "vemsd", "vwsds", "svmsD", "vssds", "vvsdd", "vrsz", "vrsd", "vimsbd", " vbsgd", "memsdd", "vatsdal", "vmmsd", "vmsid", "vapsdat", "vmwsdie", "vimsds", " vansdl", "vvsdal", "vmsda", "lmsmd", "gudsdal", " vmsdl", " vmssd", " vansd", "varmsd", "gudsd", "svvsds", "varsd", "fmsd", "vmasmd", "vapsd", "vatsu", "vmesdat", "vdsd", "vansdr", "vdscd", "vacsd", "hmsd", "ventsgd", "attimsbd", "vdsgd", "attmsbd", "vmmsdk", "fmsdl", "vasdad", "gudsdat", "gudsdl", "fmsp", "vsd", "mmsdd", "tvidsconfig", "vmsds", "memsdad", " vumsdt", "vimsdat", "ventscd", " vimsd", "vmesdy", "vacsdal", "vamesdie", "vvsbd", "fmesd", "varsdad", "vimsda", "lmesdt", "vmesp", "lmsd", "vmsD", "vMSconfig", "vmsdk", "lmsdt", "vimsdl", "vasdd", " vbsdl", "vmsdr", "vdsdal", "fmsds", "vdsds", "vmesdl", "fcsz", "vmasdl", "varsdat", "hmsds", "mmsb", "vansid", "vemsdad", " vumsdr", " vimsds", "fmsz", "mmsdad", "ventsdk", "fcsd", "tvmsdd", "vansdat", "attimsd", "vmasda", "svmsdy", " vbsdata", "fcsds", "vumsdat", "vmsl", "valsdad", "attmsu", " vmsgd", "fmesp", "vmesds", "attmsd", "vemsdd", "vumsdr", "varmsbd", "vamesds", "vmmsbd", " vmsdad", "gumsdl", "vmsu", "vumsd", "vmsp", "vmsbd", "vwsdat", "vmssd", "vimsdal", " vumsd", "prommsdd", "tvidsds", "lmsdat", "hmesl", "vmsdd", "vatsmd", "vdsad", "vorsdd", "vMSD", "gumsdal", "vmasdal", "vmmdd", "vasb", "vemsb", "vwsd", "vmmd", "vmsdt", "vsds", "vdsdl", "vssdt", "valsd", "vvsD", "vimsd", " vmsdt", "vvsd", "vmesD", "varmsdk", "valsid", "vmsb", "tvmsd", "vmasds", "vidsd", "vmentscd", "vansdal", "vanssd", "memsb", "vMSds", "hmsl", " vimsdt", "vorsad", "vmsdad", "varsdl", " vmsid", "vcsd", "lmsds", "vcsds", "vdsdd", "vmmsds", " ventssd", "vmesd", "promorsad", "ventsd", "vdsconfig", "vmsde", "prommscd", "vmesl", "hmesds", "vmentsd", "varsdt", "svvsdy", " vbsd", "ventsdal", " vumsdat", "vmsmd", "attmsdal", "tvidsd", "varmssd", "vwsdie", "vdsdat", "tvmsds", "vbsdl", "vatsd", "vrsds", "hmsD", "vdsdata", "hmesD", "vidsconfig", "vcsde", "vansdl", "vorsd", "vbsgd", "svvsD", "lmesds", "vmsdata", "vorscd", "vmsad", "fmesds", "mmsd", " vmsdal", " vmsda", "fmesdl", "vmasd", " ventsdat", "vmasdt", " vmsdata", "varmscd", "svmsd", "vmsconfig", "vmmscd", "vrsde", "vMSd", "vmmsdat", " vmsdr", "vatsbd", "vmsdat", "vimsp", "vumsdt", "vimsdt", "promorsdd", " ventsdal", "vmmdad", "vmesmd", "promorscd", "vmsz", "vidsds", "attimsdal", "vacsdat", "vapsds", "memsd", "tvidsdd", " vmsds", "vacsdl", "vmscd", "varmsdal", " vansdad", "vmesdt", "tvmsconfig", "vvsdk", "vmentsdk", "vansdt", "vmsgd", "ventsbd", "prommsd", "ventssd", "hmesd", "vssda", "vansdad", "vmmsdie", "ventsdata", "svmsds", "ventsdl", "vmwsds", "vbsd", "lmesdat", "vsp", " vansid", "svvsd", "vamesd", "vvsds", " ventsd", "vssD", "vssl", "vssdy", "vatsdat", "vvsdy", " vmsdat", "gumsd", "fmsde", "vmasdat", "vmmb", "vdsz", "varmsdat", "vvsad", "varsid", "vmentsbd", "vmwsdat", "vmsdy", "prommsad"], "opaque": ["opac", "opity", "hopaques", "compacity", "operatile", "ospaque", "obque", "ipque", "ipaque", "ospula", "openaques", "opque", "ospacity", "octque", "ospaques", "opacity", " opque", "octity", "opatile", "ipacity", "opaco", "obaque", "octaque", "operaques", " opatile", " opac", "openaque", "openacity", "octacity", "hopaque", "openatile", "Opque", "operac", "ipaco", "operula", " opacity", " opaco", "opula", "hopity", "operaco", "operque", "compula", " opaques", " opity", "ipaques", "ipac", "operacity", "operaque", "Opacity", "hopacity", "obacity", "Opaque", "Opaques", "compaque", "opaques", "operity", "obaques", "compaques"], "version_id": ["position_name", "ver_number", "field_name", "versionalvid", "version9number", "version8uri", "position_ids", "versionCname", "version_i", " versionCkey", "version_part", "versionIdId", "versionalids", " versionCname", "version_ident", "versioningvid", "package_name", "version_number", " version_sid", "feature_depth", "version_name", "version_ids", "version9ide", "version8id", " version_ID", "version_key", "generationalid", " version_ident", "versionerid", "versioningid", "version33ids", " versionCids", "package_id", "version64Id", "versionername", "feature_ids", "package_start", "versionIdid", "versionalhead", "versionCkey", "versionCids", "feature_id", "generation_vid", "package_type", " version_uri", "version64desc", "versionaldepth", "version_type", "version33sid", " version_i", "version_uri", "feature_head", "version_vid", "version_head", "ver_ide", "versionCid", "version_desc", " version_key", "ver_id", "position_ide", "version_ad", "version8part", "version_ide", " version_part", "field_desc", "version33name", "generationalvid", "versioningdepth", "vision_id", " version_Id", "generationaldepth", "version_Id", "version64it", "versioningname", "versionerdesc", " version_ad", "version64name", "versionIdpath", " version_ids", "field_key", "generation_depth", "generationalname", "versioningids", "version9name", "versionerkey", "version33id", "version64ID", "versionalnumber", "vision_day", "version_ID", "version64ids", "version_path", "versioninghead", "version_it", "version64ident", "version_sid", "vision_Id", "version9id", "versionIdday", "version64id", "field_id", "versionalname", " version_it", "vision_path", "versionalide", "ver_name", "position_id", "version_day", " versionCid", " version_name", "version_depth", "generation_name", "version_start", "version64key", "version8i", "versionalid", "generation_id"], "field": ["machine", "element", "man", "update", "FIELD", "line", "match", "player", "box", "attribute", "cache", "package", "event", "lc", "label", "p", "queue", "lf", "force", "type", "option", "object", "um", "document", "lock", "parent", "handler", "user", "play", "style", "message", "file", "service", "manager", "fix", "key", "function", "end", "value", "plugin", "rule", "post", "holder", "layer", "after", "diff", "child", "flag", "input", "data", "form", "m", "list", "record", "add", "feature", "group", "term", "lib", "node", "slice", "open", "cell", "comment", "inner", "Field"], "first_elem": ["first_aelem", "first_eleleg", "first_eelement", "first_eeleg", "first_eelements", "first_nelements", "first_elements", "first_elelement", "first_aelements", "first_selements", "first_elelements", "first_elelegate", "first_elegate", "first_eleg", "first_ele", "first_eele", "first_selement", "first_elele", "first_aelement", "first_selegate", "first_aelegate", "first_nele", "first_selem", "first_nelem", "first_eelem", "first_element", "first_seleg", "first_elelem", "first_nelement"], "i": ["ii", "ui", "x", "I", "p", "num", "di", "j", "type", "info", "si", "b", "init", "v", "a", "len", "n", "index", "c", "base", "e", "li", "in", "k", "id", "slice", "z", "ip"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n\n                          int128_get64(section->size));\n\n}\n", "idx": 21348, "substitutes": {"listener": ["listening", "preend", "listeners", "preeners", "lateners", "listoder", "hipend", "newening", "linener", "preoder", "linend", "hipener", "lineners", "linoder", "neweners", "newen", "olden", "laten", "hipeners", "oldeners", "oldener", "latener", "listend", "preener", "newener", "oldening", "hipoder", "listen", "latening"], "section": ["channel", "writer", "part", "element", "sections", "stage", "ion", "secondary", "vision", "event", "sect", "area", "core", "region", "Section", "address", "option", "length", "definition", "object", "setting", "sector", "sub", "parent", "parser", "shadow", "entry", "storage", "patch", "character", "service", "journal", "connection", "plugin", "size", "port", "layer", "data", "container", "environment", "server", "component", "slice", "division", "sec"], "state": ["ace", "settings", "part", "states", "cache", "event", "area", "sync", "STATE", "region", "type", "address", "info", "j", "config", "stat", "length", "as", "object", "start", "back", "parent", "style", "patch", "session", "manager", "cal", "rule", "ass", "port", "instance", "data", "scope", "State", "id", "list", "slice", "context", "tag", "resource"]}}
{"project": "FFmpeg", "commit_id": "d59591fb02c29b41e5b8d611160971a4493394c2", "target": 1, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 4;\n\n                                else\n\n                                    s->repeat_pict = 2;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}", "idx": 21374, "substitutes": {"s": ["settings", "sets", "sq", "S", "south", "rs", "p", "ls", "aws", "sync", "sg", "sa", "http", "bis", "ses", "ds", "f", "sec", "stats", "fs", "sc", "ss", "ts", "v", "si", "b", "acs", "c", "utils", "ps", "parser", "sb", "e", "cs", "r", "service", "session", "u", "services", "private", "qs", "sup", "es", "soc", "ssl", "ctx", "gs", "self", "os", "sys", "su", "t", "conf", "m", "client", "socket", "server", "sl", "g", "spec", "sv", "sam"], "avctx": ["afgb", " avkb", "aveca", "afcmp", "Avconn", " avca", "avconfig", "avecmp", "avgb", "AVcf", "AVconfig", "avkb", "airctx", "avcmp", "afcontext", "AVca", " avhw", "avcontext", "afcca", "avecontext", " avcmp", "afcu", "avconn", "avcu", "avectx", "Avcms", "abxc", "AVctx", "AVhw", " avxc", " avcf", "airxc", "afconn", "evconn", "evctx", "AVcontext", " avcca", "svcms", "avecms", "Avctx", "AVkb", "avxc", "evcms", "afkb", "avhw", "Avcf", "svctx", "abconfig", "abctx", " avcontext", "avehw", " avgb", "svcontext", "aircontext", "avecca", "airconfig", "avcms", "avcf", "avecu", "afcms", "afctx", "svcu", "Avxc", "evcontext", "AVgb", "avca", "avcca", "abcontext", "Avcontext", "AVxc"], "buf": ["br", "box", "cv", "uber", "buffer", "offset", "lim", "proc", "f", "cur", "seq", "feat", "cas", "begin", "ab", "pb", "ff", "bc", "pos", "data", "count", "mount", "gb", "bn", "fb", "ha", "loop", "src", "img", "num", "db", "Buff", "xff", "loc", "config", "bf", "cmd", "b", "len", "header", "fw", "vec", "mb", "fd", "batch", "filename", "auc", "bu", "av", "end", "rc", "home", "cap", "text", "wb", "bb", "bo", "buff", "length", "func", "uc", "v", "c", "aux", "fp", "ph", "usr", "bag", "conv", "ctx", "orig", "rb", "cf", "uf", "alloc", "queue", "block", "que", "bd", "max", "grab", "bh", "exc", "bt", "cb", "ctr", "fam", "off", "port", "band", "coord", "usb", "su", "txt", "context", "ba"], "buf_size": ["bufallsize", "buffer_address", "buffer_size", "bufallstart", "buf_start", " buf_scale", "buf_scale", "buf_sum", "buf_address", "buffer_sum", "bufallend", "bufallsum", " buf_engine", "buf_engine", "buffer_start", "bufallengine", "bufalladdress", "bufallscale"], "pc": ["dc", "mc", "cz", "inc", "cms", "aa", "pac", "pd", "pa", "xc", "cache", "p", "lc", "cu", "enc", "cc", "pic", "ac", "co", "proc", "pm", "uc", "anc", "jc", "sc", "oc", "fc", "toc", "mac", "amp", "con", "c", "ca", "PC", "bp", "pt", "cs", "conn", "py", "pb", "can", "arc", "wcs", "bc", "cp", "api", "rc", "tc", "ctx", "vc", "gb", "sys", "client", "nc", "cam", "px", "wp", "ec"], "buf_end": ["buff0start", "img_offset", "bufacoff", "bufacid", "buff0id", "bu_get", "uf_id", "cap_ent", "bufacend", "buf_clean", "buf67get", "bufenindex", "buf0index", "bu_clean", "bufenoffset", "bufJend", "buff0end", "buf_index", "buff_end", "bufjoffset", "img_end", "buJEnd", "buf0off", "bufpindex", "buf0end", "imgjoffset", "cap_ended", "bufJEnd", "cap_start", "buf67end", "bu_End", "bufjsize", "buff_index", "buf_ent", "buff_start", "bufacstart", "bufenend", "buf67clean", "uf_off", "bufensize", "uf_start", "img_index", "cap_end", "buf_id", "bufJclean", "buJend", "bufjindex", "buf0id", "buf_get", "buf_End", "buf67End", "bufjend", "bufpend", "buf_start", "bufJget", "buJclean", "imgjindex", "bufpid", "buf_off", "buff_id", "imgjsize", "imgjend", "bufpstart", "img_size", "bu_end", "buff0index", "buJget", "uf_end", "buf_ended", "buf_offset", "buf0start"], "start_code": ["start_header", "startacconst", "startfCode", "start_number", "end_code", " start_header", "start64code", "start_codes", "start_buffer", "stop_code", " start_codes", "end_codes", "end_type", "start_coded", "startfbuffer", "startfcoded", "end_buffer", "startpreheader", "start67code", "startprecode", "start67header", "startPtype", " start_number", "start_size", "startPcode", "start64coded", "startfcode", "startprecodes", "startprenumber", "startactype", "start64Code", "start_const", "end_coded", "start64buffer", "end_Code", "start_type", "stop_size", "stop_type", "startPCode", "stop_const", "startacsize", "start67number", "startPcodes", "start67codes", "start_Code", "startaccode"], "frame_rate_index": ["frame_rate_key", "frame_rating_key", "frame_rating_index", "frame_rates_entry", "frame_rates_element", "frame_rates_key", "frame_rate___key", "frame_rate_ind", "frame_rate_slice", "frame_rates_index", "frame_rate_width", "frame_ratexkey", "frame_rate___index", "frame_rate_count", "frame_rate_len", "frame_rating_len", "frame_ratexwidth", "frame_rating_width", "frame_rate_entry", "frame_rate___entry", "frame_rate_size", "frame_ratexlen", "frame_ratexindex", "frame_rate___element", "frame_rate_element"], "ext_type": ["proc_type", "ext_style", "procitytype", "ext_format", "proc_style", "extityformat", "extalnum", "procityformat", "procitynum", "extitytype", "proc_format", "extalstyle", "ext_num", "extitynum", "procitystyle", "extaltype", "extalformat", "proc_num", "extitystyle"], "bytes_left": ["lines_length", "bytes___end", "bytes_diff", "bytes___right", "lines_right", "bytesenright", "bits_right", "bytes_two", "bytes_right", "bits_offset", "bytes___offset", "bits_left", "bytesenlength", "lines_left", "lines_old", "lines_two", "bytes_old", "bits_end", "bytesentwo", "bytes_joined", "bits_joined", "bytesenleft", "bytes_offset", "bytes___left", "bytes_length", "lines_diff", "bytes_end"], "frame_rate_ext_n": ["frame_rate_ext_N", "frame_rate_xt_n", "frame_rate_xt_d", "frame_rate_ext_nc", "frame_rate_xt_nc", "frame_rate_xt_N"], "frame_rate_ext_d": ["frame_rate_ext16d", "frame_rate_ext16x", "frame_rate_ext5n", "frame_rate_xt_n", "frame_rate_ext5x", "frame_rate_xt_d", "frame_rate_ext5pos", "frame_rate_ext16n", "frame_rate_ext16pos", "frame_rate_xt_pos", "frame_rate_ext_x", "frame_rate_xt_x", "frame_rate_ext_pos", "frame_rate_ext5d"], "picture_structure": ["picture_astolerance", "picture_stolerance", "picture_astruction", "picture_asturation", "picture_strructure", "picture_strruction", "picture_Stolerance", "picture_strolerance", "picture_Struction", "picture_Sturation", "picture_struration", "picture_struction", "picture_astructure", "picture_Structure", "picture_sturation"], "top_field_first": ["top_fieldalbottom", "top_fieldalfirst", "top_fieldallast", "top_line_left", "top_fielddfirst", "top_field_last", "top_fieldalleft", "top_line_first", "top_field_left", "top_fielddlast", "top_fielddleft", "top_line_last", "top_field_bottom", "top_fielddbottom", "top_line_bottom"], "repeat_first_field": ["repeat_firstsline", "repeat_firstsfield", "repeat_firstsframe", "repeat_first_line", "repeat_last_line", "repeat_last_bit", "repeat_last_frame", "repeat_first_bit", "repeat_last_field", "repeat_firstsbit", "repeat_first_frame"], "progressive_frame": ["progressivealframe", "progressive_seq", "progressivealimage", "progressive67seq", "progressive2frame", "progressive_edge", "progressivealseq", "proicientalimage", "proicient_image", "progressive2seq", "proicient_edge", "proicient_frame", "proicientaledge", "proicientalseq", "progressive67frame", "proicientalframe", "progressivealedge", "progressive67edge", "proicient_seq", "progressive2image", "progressive67image", "progressive2edge", "progressive_image"], "horiz_size_ext": ["horiz_size_sec", "horiz_size_complete", "horiz_leningsec", "horiz_sizexsec", "horiz_sizexext", "horiz_size_ex", "horiz_len_ext", "horiz_sizeingsec", "horiz_leningcomplete", "horiz_sizexex", "horiz_len_ex", "horiz_leningext", "horiz_sizeingex", "horiz_sizeingcomplete", "horiz_leningex", "horiz_len_sec", "horiz_len_complete", "horiz_sizexcomplete", "horiz_sizeingext"], "vert_size_ext": ["vert_size_ex", "vert_scale_ext", "vert_size__txt", "vert_size__desc", "vert_size_desc", "vert_scale__desc", "vert_size_txt", "vert_scale__ex", "vert_size__ex", "vert_scale_desc", "vert_scale__txt", "vert_scale_ex", "vert_scale_txt", "vert_size__ext", "vert_scale__ext"], "bit_rate_ext": ["bit_rate_xt", "bit_rate_Ext", "bit_rate_EXT"]}}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "func": "static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n", "idx": 21383, "substitutes": {"data": ["writer", "def", "cache", "p", "test", "DATA", "block", "code", "di", "buffer", "val", "ds", "info", "object", "valid", "wa", "device", "index", "board", "parent", "base", "database", "o", "da", "error", "dat", "storage", "style", "result", "window", "d", "li", "memory", "input", "reader", "self", "pad", "ad", "la", "Data", "g", "new"], "off": ["br", "close", "def", "offset", "valid", "not", "ack", "a", "eff", "ref", "opp", "ff", "pos", "down", "oa", "open", "addr", "no", "all", "empty", "test", "num", "bit", "name", "ord", "fail", "now", "address", "none", "Off", "index", "end", "size", "check", "id", "shift", "alt", "set", "offer", "ip", "unknown", "length", "online", "offs", "own", "error", "style", "value", "after", "before", "front", "op", "new", "block", "code", "load", "type", "pack", "head", "OFF", "start", "o", "out", "command", "on", "port", "obj", "one", "remote", "non"], "sig": ["ssarg", "opensigh", "Sig", "psarg", "gsigs", "dsigma", "dsiger", "psign", "dsigs", "opensig", "wsig", "ssigs", " sigma", "ssig", "sarg", "sigma", "psigs", "wsigma", "psig", "Sigs", " sec", " sib", "SIG", "gsiger", " sigs", " sign", " sarg", "sigs", "Siger", "ssign", "opensIG", "wsIG", "dsIG", "ssec", "ssib", "ssIG", "gsIG", "ssigma", "wsigh", "sigh", " sIG", "gsig", "opensigma", "siger", "dsig", "Sib", "sign", "gsigma", "Sec", "sec", "sIG", " sigh", "sib"], "i": ["ti", "ii", "ui", "abi", "qi", "x", "I", "ix", "p", "phi", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ie", "start", "si", "io", "b", "v", "init", "a", "pi", "n", "index", "c", "o", "e", "ind", "min", "l", "xi", "u", "fi", "li", "d", "mini", "iu", "in", "k", "id", "m", "ci", "t", "multi", "mi", "slice", "gi", "z", "mu", "bi", "ip"]}}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385, "substitutes": {"sc": ["dc", "desc", "cf", "cms", "cl", "cv", "src", "lc", "enc", "cc", "loc", "sci", "cr", "cur", "uc", "pc", "usc", "fc", "sche", "cer", "c", "ca", "Sc", "cs", "osc", "sk", "esc", "bc", "soc", "rc", "tc", "scope", "ctx", "cmp", "SC", "context", "cam", "spec", "asc", "ec"], "duration": ["time", "pause", "timeout", "delay", "stage", "doc", "attribute", "event", "series", "date", "depth", "distance", "length", "tube", "document", "gap", "device", "audio", "uri", "dimension", "database", "range", "sequence", "uration", "window", "span", "end", "d", "port", "lasting", "sleep", "video", "design", "data", "direction", "Duration", "unit", "period", "pad", "number", "component", "feature", "context", "repeat", "frequency", "resource", "until"]}}
{"project": "FFmpeg", "commit_id": "1197c04896423c6c7db65f69da8bc3865b26bb50", "target": 1, "func": "static void fft_calc_c(FFTContext *s, FFTComplex *z) {\n\n\n\n    int nbits, i, n, num_transforms, offset, step;\n\n    int n4, n2, n34;\n\n    FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;\n\n    FFTComplex *tmpz;\n\n    const int fft_size = (1 << s->nbits);\n\n    int64_t accu;\n\n\n\n    num_transforms = (0x2aab >> (16 - s->nbits)) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 2;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[0].re + tmpz[1].re;\n\n        tmp5 = tmpz[2].re + tmpz[3].re;\n\n        tmp2 = tmpz[0].im + tmpz[1].im;\n\n        tmp6 = tmpz[2].im + tmpz[3].im;\n\n        tmp3 = tmpz[0].re - tmpz[1].re;\n\n        tmp8 = tmpz[2].im - tmpz[3].im;\n\n        tmp4 = tmpz[0].im - tmpz[1].im;\n\n        tmp7 = tmpz[2].re - tmpz[3].re;\n\n\n\n        tmpz[0].re = tmp1 + tmp5;\n\n        tmpz[2].re = tmp1 - tmp5;\n\n        tmpz[0].im = tmp2 + tmp6;\n\n        tmpz[2].im = tmp2 - tmp6;\n\n        tmpz[1].re = tmp3 + tmp8;\n\n        tmpz[3].re = tmp3 - tmp8;\n\n        tmpz[1].im = tmp4 - tmp7;\n\n        tmpz[3].im = tmp4 + tmp7;\n\n    }\n\n\n\n    if (fft_size < 8)\n\n        return;\n\n\n\n    num_transforms = (num_transforms >> 1) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 3;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[4].re + tmpz[5].re;\n\n        tmp3 = tmpz[6].re + tmpz[7].re;\n\n        tmp2 = tmpz[4].im + tmpz[5].im;\n\n        tmp4 = tmpz[6].im + tmpz[7].im;\n\n        tmp5 = tmp1 + tmp3;\n\n        tmp7 = tmp1 - tmp3;\n\n        tmp6 = tmp2 + tmp4;\n\n        tmp8 = tmp2 - tmp4;\n\n\n\n        tmp1 = tmpz[4].re - tmpz[5].re;\n\n        tmp2 = tmpz[4].im - tmpz[5].im;\n\n        tmp3 = tmpz[6].re - tmpz[7].re;\n\n        tmp4 = tmpz[6].im - tmpz[7].im;\n\n\n\n        tmpz[4].re = tmpz[0].re - tmp5;\n\n        tmpz[0].re = tmpz[0].re + tmp5;\n\n        tmpz[4].im = tmpz[0].im - tmp6;\n\n        tmpz[0].im = tmpz[0].im + tmp6;\n\n        tmpz[6].re = tmpz[2].re - tmp8;\n\n        tmpz[2].re = tmpz[2].re + tmp8;\n\n        tmpz[6].im = tmpz[2].im + tmp7;\n\n        tmpz[2].im = tmpz[2].im - tmp7;\n\n\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp1 + tmp2);\n\n        tmp5 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 - tmp4);\n\n        tmp7 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp2 - tmp1);\n\n        tmp6 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 + tmp4);\n\n        tmp8 = (int32_t)((accu + 0x40000000) >> 31);\n\n        tmp1 = tmp5 + tmp7;\n\n        tmp3 = tmp5 - tmp7;\n\n        tmp2 = tmp6 + tmp8;\n\n        tmp4 = tmp6 - tmp8;\n\n\n\n        tmpz[5].re = tmpz[1].re - tmp1;\n\n        tmpz[1].re = tmpz[1].re + tmp1;\n\n        tmpz[5].im = tmpz[1].im - tmp2;\n\n        tmpz[1].im = tmpz[1].im + tmp2;\n\n        tmpz[7].re = tmpz[3].re - tmp4;\n\n        tmpz[3].re = tmpz[3].re + tmp4;\n\n        tmpz[7].im = tmpz[3].im + tmp3;\n\n        tmpz[3].im = tmpz[3].im - tmp3;\n\n    }\n\n\n\n    step = 1 << ((MAX_LOG2_NFFT-4) - 4);\n\n    n4 = 4;\n\n\n\n    for (nbits=4; nbits<=s->nbits; nbits++){\n\n        n2  = 2*n4;\n\n        n34 = 3*n4;\n\n        num_transforms = (num_transforms >> 1) | 1;\n\n\n\n        for (n=0; n<num_transforms; n++){\n\n            const FFTSample *w_re_ptr = ff_w_tab_sr + step;\n\n            const FFTSample *w_im_ptr = ff_w_tab_sr + MAX_FFT_SIZE/(4*16) - step;\n\n            offset = ff_fft_offsets_lut[n] << nbits;\n\n            tmpz = z + offset;\n\n\n\n            tmp5 = tmpz[ n2].re + tmpz[n34].re;\n\n            tmp1 = tmpz[ n2].re - tmpz[n34].re;\n\n            tmp6 = tmpz[ n2].im + tmpz[n34].im;\n\n            tmp2 = tmpz[ n2].im - tmpz[n34].im;\n\n\n\n            tmpz[ n2].re = tmpz[ 0].re - tmp5;\n\n            tmpz[  0].re = tmpz[ 0].re + tmp5;\n\n            tmpz[ n2].im = tmpz[ 0].im - tmp6;\n\n            tmpz[  0].im = tmpz[ 0].im + tmp6;\n\n            tmpz[n34].re = tmpz[n4].re - tmp2;\n\n            tmpz[ n4].re = tmpz[n4].re + tmp2;\n\n            tmpz[n34].im = tmpz[n4].im + tmp1;\n\n            tmpz[ n4].im = tmpz[n4].im - tmp1;\n\n\n\n            for (i=1; i<n4; i++){\n\n                FFTSample w_re = w_re_ptr[0];\n\n                FFTSample w_im = w_im_ptr[0];\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].re;\n\n                accu += (int64_t)w_im*tmpz[ n2+i].im;\n\n                tmp1 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].im;\n\n                accu -= (int64_t)w_im*tmpz[ n2+i].re;\n\n                tmp2 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].re;\n\n                accu -= (int64_t)w_im*tmpz[n34+i].im;\n\n                tmp3 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].im;\n\n                accu += (int64_t)w_im*tmpz[n34+i].re;\n\n                tmp4 = (int32_t)((accu + 0x40000000) >> 31);\n\n\n\n                tmp5 = tmp1 + tmp3;\n\n                tmp1 = tmp1 - tmp3;\n\n                tmp6 = tmp2 + tmp4;\n\n                tmp2 = tmp2 - tmp4;\n\n\n\n                tmpz[ n2+i].re = tmpz[   i].re - tmp5;\n\n                tmpz[    i].re = tmpz[   i].re + tmp5;\n\n                tmpz[ n2+i].im = tmpz[   i].im - tmp6;\n\n                tmpz[    i].im = tmpz[   i].im + tmp6;\n\n                tmpz[n34+i].re = tmpz[n4+i].re - tmp2;\n\n                tmpz[ n4+i].re = tmpz[n4+i].re + tmp2;\n\n                tmpz[n34+i].im = tmpz[n4+i].im + tmp1;\n\n                tmpz[ n4+i].im = tmpz[n4+i].im - tmp1;\n\n\n\n                w_re_ptr += step;\n\n                w_im_ptr -= step;\n\n            }\n\n        }\n\n        step >>= 1;\n\n        n4   <<= 1;\n\n    }\n\n}\n", "idx": 21386, "substitutes": {"s": ["settings", "sets", "S", "sq", "south", "p", "sym", "sync", "site", "ses", "j", "f", "ds", "sample", "si", "ss", "sc", "b", "c", "spec", "ps", "sb", "o", "sites", "e", "cs", "space", "service", "u", "qs", "services", "size", "sup", "outs", "in", "d", "gs", "su", "m", "t", "sf", "ns", "g", "sec", "sn", "js"], "z": ["Z", "zip", "cz", "x", "w", "p", "j", "za", "ez", "f", "zh", "qq", "zx", "q", "zon", "config", "hz", "v", "nz", "temp", "zen", "c", "iz", "e", "y", "l", "zone", "ze", "tz", "cm", "uz", "zz", "d", "zn", "ctx", "zi", "m", "gz", "t", "slice", "zy", "az", "ld", "cell", "zo"], "nbits": ["Nints", " nframes", "nnbit", " nints", "nbytes", "Nframes", " nbit", "nbit", "numbytes", "nnrows", " nlines", "numints", " nbytes", "numframes", "nlines", "nbbits", "nframes", "lenbit", "nbrows", "numbits", "lenbytes", "nrows", "lenbits", "numbit", "numlines", "Nbits", "lenlines", " nrows", "nbbit", "nnbits", "Nbytes", "nints"], "i": ["ti", "ii", "I", "p", "ib", "j", "f", "ini", "ni", "si", "io", "b", "pi", "index", "c", "ind", "xi", "li", "d", "iu", "in", "m", "ci", "mi", "bi", "it", "ip"], "n": ["nor", "br", "x", "w", "p", "en", "num", "nn", "name", "j", "an", "f", "net", "na", "ni", "nb", "none", "mn", "no", "not", "b", "init", "v", "len", "a", "c", "adj", "o", "nr", "e", "y", "l", "conn", "r", "ng", "nt", "N", "pn", "d", "ne", "in", "syn", "inn", "on", "ann", "k", "m", "t", "dn", "fn", "un", "nc", "nu", "cn", "ns", "g", "network", "all", "inner", "sn", "non"], "num_transforms": ["num_ransflows", "num__transmits", "num__shockforms", "num_ransactions", "num_transformed", "num_tratransform", "num_constsections", "num_shocksts", "num2tratransform", "num_transmits", "num__transforms", "num_transplays", "num__transsts", "num2transforms", "num_transceptions", "num__shockmits", "num_surform", "num__transractions", "num_transferflows", "num_transform", "num_parttransform", "num_transformer", "num_comractions", "num_partactions", "num_transferactions", "numalltranssections", "num2transtransform", "num_transtransform", "num2transactions", "num_conforms", "num_transferframes", "num_transfertransform", "num_shocksections", "num_nonversions", "num_surmissions", "num_ransmissions", "num_ransformed", "numallshocksections", "num_transferversions", "num_traformed", "num_transferforms", "num_shockmits", "num_comsts", "num_nonflows", "num_ransformer", "num_conractions", "num_transversions", "num_surforms", "numalltransforms", "num_ransform", "num_ransceptions", "num_firstforms", "numalltransractions", "num__shockractions", "num_traforms", "num_transactions", "num_transflows", "num2traactions", "num_constractions", "num_transsts", "num_transsections", "num2transframes", "num_transframes", "num__shocksts", "num_performs", "num_shockractions", "num_comforms", "num_transractions", "num_ransforms", "num2traframes", "num_firstsections", "num2traforms", "num_conmits", "num_traframes", "num_constplays", "num_partframes", "num_shockplays", "num_firstractions", "num_traceptions", "num_perceptions", "numalltransplays", "num_shockforms", "num_commits", "num_peractions", "numallshockractions", "num_transmissions", "num_surformed", "num_firstplays", "num_nonforms", "numallshockplays", "num_performed", "numallshockforms", "num_partforms", "num_traactions", "num_nonformer", "num_consts", "num_ransversions", "num_transferformer", "num_constforms"], "offset": ["part", "bound", "timeout", "delay", "item", "image", "af", "axis", "attribute", "reset", "area", "location", "loc", "address", "f", "Offset", "option", "online", "length", "nb", "start", "order", "len", "hop", "align", "index", "padding", "scale", "seed", "position", "amp", "parent", "o", "range", "slot", "adjust", "alpha", "error", "action", "alias", "entry", "limit", "ref", "output", "end", "size", "off", "initial", "layer", "pos", "url", "append", "shift", "optional", "alt", "unit", "skip", "slice", "addr", "phase", "frequency", "notation", "stop", "set", "adjusted"], "step": ["dc", "loop", "delay", "timeout", "stage", "w", "version", "sync", "dim", "ai", "start", "Step", "init", "ct", "trial", "index", "scale", "seed", "steps", "sb", "min", "batch", "weight", "sleep", "shift", "skip", "sec", "ip"], "n4": ["m3", " n3", "m4", "m5", "n5", "num5", "n3", "num3", " n5", "num4", "num2", "m2"], "n2": ["num42", "n32", "g2", "g42", "n5", " n42", "g32", " n32", "n42", "g5", " n5", "num5", "num32", "num2"], "n34": ["inn39", "N35", "nan34", "na34", "inn54", "N34", "N39", "na39", "na35", "na54", "inn35", "inn34", "nan54", "nan39", "nan35", "N54"], "tmp1": ["cmp3", "temp2", "tmpnum", "cmp2", "cmp8", "mp1", " tmpnum", "tmp01", "dest2", "dest4", "dest3", "tem01", "cmp1", "tem5", "mp01", "tempnum", "tem1", "dest1", "cmpnum", "tem2", "mp2", "mp3", "temp5", "temp8", "mp4", "mp5", "temp4", "temp1", "cmp4", " tmp01", "temp3"], "tmp2": ["txt02", "temp2", "mp1", "tmp02", "txt2", "temp02", "mp3", "mp2", "txt4", "temp5", "mp02", "mp4", "temp6", "temp4", "mp5", "mp6", "temp1", "temp3", "txt1"], "tmp3": ["temp53", "temp2", "sup4", "sup1", "mp1", " tmp03", "tmp53", "mpThree", "mp53", "mp03", " tmpThree", "mp3", "tmpThree", "mp2", "temp5", " tmp53", "mp4", "sup3", "temp6", "tmp03", "mp5", "temp4", "mp6", "temp1", "tempThree", "temp03", "sup2", "temp3"], "tmp4": ["temp2", "np04", "temp04", "mp1", "np40", "tmp40", "temp40", "temp7", "mp7", "mp2", " tmp40", "np4", " tmp04", "temp5", "mp4", "temp6", "temp4", "mp5", "mp6", "tmp04", "temp1", "np2"], "tmp5": ["appy5", "appy4", "temp2", "mp25", "sup4", "cmp8", "appy6", "temp50", "cmp5", "tmp25", " tmp55", "appy2", "sup6", " tmp05", "tmp50", "cmp05", "mp50", " tmp50", "tmp55", "temp5", "sup05", " tmp25", "sup8", "appy1", "temp6", "sup5", "mp5", "temp55", "temp4", "temp25", "temp1", "sup2", "tmp05", "mp55", "cmp4"], "tmp6": ["appy5", "appy4", "sup4", "appy6", "mp16", "fake5", "appy8", "mp8", "temp5", "temp8", "fake6", "temp16", "fake4", "sup8", "mp4", "temp6", "sup5", "temp60", "mp5", "mp6", "temp4", " tmp16", "tmp60", " tmp60", "tmp16", "mp60", "sup6", "fake8"], "tmp7": [" tmp70", "tp07", "temp70", "temp07", "tmp07", "tmp57", "api4", "zip5", " tmp07", "api7", "api9", "package5", "temp7", "tp7", "mp7", "tp70", "package7", "temp57", "mp8", "api5", "zip6", "zip4", "zip7", "package9", "zip8", "temp5", "temp8", "zip9", "mp4", "tp57", "temp6", "tmp70", "mp5", "temp4", "mp6", " tmp57", "package4", "tmp9"], "tmp8": ["temp2", "appy4", "appy6", "zip5", "mp08", "tmp08", "appy08", "temp7", "mp7", "appy8", "mp8", "zip6", "zip7", "mp2", "zip8", "temp5", "temp8", "mp4", "temp6", "temp4", "mp5", "mp6", "temp08"], "tmpz": [" tmpx", "vmz", "videoz", "tempz", "currentl", "tempzone", "tmpy", "tmpZ", "topaz", "cropw", "ppZ", "cvz", "txtz", "tpzz", "tmzi", "temc", "bby", "optZ", "tmpzo", "tempzz", "tempcz", "tempzip", "tempzen", "mpw", "supw", "mpx", "mpzen", "tmpzip", "cachey", " tmpzn", "oppz", "tempw", "mpgz", "temZ", "apiy", "tpzi", "tmpx", "tempZ", "tempzl", "mpz", "mpzz", "appyy", "currentw", "tmpcz", "apizen", "tempf", "apix", "tvzip", "tmzl", "txtw", " tmpw", "vmle", "optzone", " tmpZ", "tempzn", " tmpzi", "cropz", "tmx", "fakec", "appyiz", "ppz", "tempiz", "tempc", "fakezen", "cropoz", " tmpaz", "tpcz", "tpz", "tmpiz", "tmw", "cachez", " tmpcz", "optiz", "crople", "txtx", "tmpoz", "temz", " tmpy", "tvz", "tmpl", "tmy", "mpl", "cvZ", "tmpza", "apiz", "topc", "tempgz", "mp5", "etcza", "supx", "fakez", "tmpaz", "tmpzz", "tpc", "tpx", "etcw", "temx", "etcz", "tvy", " tmpiz", "temy", "temza", "cropy", "videox", "tmpgz", "appyz", "ppzone", "ppiz", "tempoz", " tmpza", "tmpzen", "optz", "currentzip", "tmple", " tmpoz", "tmpzone", "tempx", "appyw", "tmpw", "mpzl", "cachezo", "topz", "currentz", "tempzi", "temp5", "mpy", "supzip", "tmpzl", " tmpl", "mpzi", "oppf", "templd", "cropzl", "mpc", "templ", "mpzip", "oppw", "bb5", "cviz", "fakex", "bbx", "mpzo", "mpiz", "txtld", "tmzn", "tmpzi", "tmiz", "videogz", "tempzo", "tvw", "tmpld", "etcc", "bbz", "tempy", "cvc", "vmy", "tmpzn", "tmz", " tmpf", "topzip", "oppiz", "videoy", "mpza", " tmpc", " tmpzip", "tempaz", "tmpc", "tempza", "tmpf", "supz", "vmzl", "cachex", "mpld", "tpy", "temple"], "accu": ["circuu", "sku", "asmu", "accU", "skuu", "asmul", "circul", "skul", "circU", "asmU", "accul", "asmuu", "accuu", "skU", "circu"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                             int mmu_idx)\n\n{\n\n    mmu_ctx_t ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    env->error_code = 1 << 18;\n\n                    env->spr[SPR_IMISS] = address;\n\n                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;\n\n                    goto tlb_miss;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    goto tlb_miss_74xx;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    env->error_code = 0x40000000;\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    return -1;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_ESR] = 0x00000000;\n\n                }\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    /* XXX: this might be incorrect */\n\n                    env->error_code = 0x40000000;\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_ISEG;\n\n                    env->error_code = 0;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                        env->error_code = 1 << 16;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                        env->error_code = 0;\n\n                    }\n\n                    env->spr[SPR_DMISS] = address;\n\n                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;\n\n                tlb_miss:\n\n                    env->error_code |= ctx.key << 19;\n\n                    env->spr[SPR_HASH1] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[0], HASH_PTE_SIZE_32);\n\n                    env->spr[SPR_HASH2] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[1], HASH_PTE_SIZE_32);\n\n                    break;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                    }\n\n                tlb_miss_74xx:\n\n                    /* Implement LRU algorithm */\n\n                    env->error_code = ctx.key << 19;\n\n                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |\n\n                        ((env->last_way + 1) & (env->nb_ways - 1));\n\n                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;\n\n                    break;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] = 0x00800000;\n\n                    } else {\n\n                        env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                    return -1;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                if (env->mmu_model == POWERPC_MMU_SOFT_4xx\n\n                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] |= 0x00800000;\n\n                    }\n\n                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                } else {\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x0A000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x08000000;\n\n                    }\n\n                }\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or stwcx. */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    /* XXX: this might be incorrect */\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_DSEG;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 21387, "substitutes": {"env": ["inet", "req", "cv", "cache", "proc", "chal", "eng", "equ", "dev", "sb", "enable", "et", "pos", "org", "conf", "vs", "ec", "gov", "ext", "po", "stage", "ev", "en", "ea", "forge", "core", "db", "config", "ench", "header", "e", "args", "manager", "end", "viron", "np", "Environment", "environment", "cdn", "eu", "foundation", "console", "esi", "gui", "enc", "site", "el", "rev", "dict", "net", "vm", "init", "err", "dat", "export", "osc", "style", "ou", "nw", "cal", "output", "ass", "ne", "scope", "fg", "client", "server", "assets", "qt", "settings", "eni", "queue", "que", "dt", "extra", "ah", "exc", "cb", "engine", "conn", "esm", "session", "erv", "json", "txt", "nc", "context", "inc"], "address": ["channel", "ace", "element", "shape", "image", "interface", "attribute", "cache", "event", "test", "eni", "host", "area", "block", "code", "location", "route", "pair", "pointer", "reference", "offset", "ACE", "type", "config", "object", "request", "asm", "state", "uri", "index", "position", "alias", "error", "instead", "password", "message", "localhost", "service", "connection", "node", "point", "output", "size", "port", "instance", "target", "url", "ptr", "number", "server", "array", "addr", "context", "Address", "enter", "network", "master", "resource", "prefix", "ip"], "rw": ["writer", "ww", "w", "wb", "resp", "row", "tw", "rss", "rt", "wl", "mode", "length", "sr", "rx", "rh", "wa", "RW", "wr", "wn", "kw", "wx", "raw", "fw", "sw", "wh", "rr", "ew", "r", "wk", "hw", "nw", "usr", "rn", "wcs", "worker", "rf", "rc", "iw", "work", "rew", "lr", "wd", "rl", "wp", "rb", "rack"], "mmu_idx": ["mmu_sidg", "mmu_sidxc", "mmu_Idx", "mmu_idg", "mmu_Idc", "mmu_idc", "mmu_idf", "mmu_sidf", "mmu_midX", "mmu_idy", "mmu_midy", "mmu_sidy", "mmu_idxc", "mmu_midf", "mmu_sidx", "mmu_sidX", "mmu_midx", "mmu_idX", "mmu_Idxc", "mmu_Idg", "mmu_sidc"], "ctx": ["dc", "cfg", "cf", "sq", "xc", "cv", "alloc", "jp", "cu", "event", "lc", "sync", "cc", "acl", "loc", "cli", "config", "qq", "Context", "git", "cmd", "ct", " c", "fw", "cb", "cas", "ca", "tx", "conn", "tmp", "fp", "hw", "session", "hub", "ref", "std", "connection", "cm", "conv", " context", "bc", "qa", "cp", "wcs", "rc", "obj", "tc", "cca", "vc", "ci", "pkg", "ctrl", "client", "cmp", "nc", "context", "cn", "ann"], "access_type": [" access_level", "access_format", "cache_name", "access_length", "accessablecode", "accessingname", "accessingkey", "accessabletype", "accessallevel", "accessingsize", "accessingcode", " access_types", "access_level", "access_key", "access_id", "accessionunit", "accessinglevel", "accessitycode", "accessingtype", " access_length", " access_unit", "access_unit", " access_code", "cache_key", "accessingtypes", "accessfulunit", " access_key", " access_format", "cache_type", "accessitytype", "accessitylength", "accessfulcolor", "cache_types", " access_id", "accessiontype", "accessalsize", "access_types", "accessfulkey", "access_code", "accessingid", "access_color", "accessaltype", "accessfultype", "accessionkey", "accessalkey", "accessablekey", " access_color", "accessableid", " access_size", "accessioncolor", "access_size", "access_name"]}}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392, "substitutes": {"ds": ["dm", "dc", "settings", "sts", "states", "ks", "rs", "pd", "sync", "uds", "dt", "di", "db", "bd", "dim", "ses", "md", "dl", "xs", "fs", "gd", "ss", "dh", "der", "state", "df", "ys", "ps", "cb", "da", "dat", "cs", "fd", "services", "dist", "std", "dd", "rd", "d", "des", "data", "Ds", "gs", "sd", "gb", "plays", "vs", "ded", "DS", "dy", "dos", "ns", "ld", "dds"]}}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n", "idx": 21411, "substitutes": {"bs": ["lb", "iss", "rs", "css", "bis", "ds", "ses", "banks", "bas", "as", "fs", "b", "ss", "bh", "BS", "ps", "sb", "bps", "bos", "cs", "bi", "fps", "bes", "lbs", "pb", "outs", "bc", "gb", "os", "fb", "vs", "ubs", "ns", "ls", "rb", "obs", "ba", "js"], "sector_num": ["sector___con", " sector_off", "sector___ident", "sector_name", " sector_name", "sector___num", "sector_off", " sector_con", "sector_con", " sector_number", "sector___number", " sector_ident", "sector_number", "sector_ident"], "nb_sectors": ["nb_pegments", "nb_pectors", "nb_vegments", "nb_serctions", "nb_secsections", "nb_sefs", "nb_sesections", "nb_vesections", "nb_segments", "nb_vections", "nb_spefs", "nb_spegments", "nb_sector", "nb_serctors", "nb_vectors", "nb_vector", "nb_spectors", "nb_spesections", "nb_secgments", "nb_secctors", "nb_sections", "nb_secfs", "nb_vefs", "nb_pections", "nb_sergments", "nb_pector", "nb_serctor"], "pnum": ["cnenum", "rnom", "panUM", "rnum", "rnumb", "pnume", "snnum", "pnnum", "pnumer", "natum", "rnumber", "cnom", "bnnum", "rnUM", "bnenum", "panum", "PNenum", "natumer", "snum", "cnnum", "bnume", "panumb", "snenum", "rnumer", "cnum", "PNnum", "pronenum", "pronumer", "pnUM", "gnenum", "natenum", "panumin", "cnUM", "gnnum", "pnenum", "rnnum", "pnumb", "pronum", "pnumin", "cnumin", "snume", "PNom", "pnumber", "cnumb", "rnenum", "gnume", "PNum", "gnum", "pronumber", "natumber", "bnum", "pnom", "rnumin"], "cluster_offset": ["cluster6error", "cluster_type", "cluster6number", "cluster_number", "cluster6type", "cloff6type", "cluster_error", "cloff_offset", "cluster_size", "cloff_type", "cluster6offset", "cloff_error", "cloff_number", "cluster_part", "clusterstype", "clustersoffset", "cloff6number", "cloff6offset", "cloff6error", "cluster_entry", "clustersentry"], "ret": ["part", "br", "att", "match", "iter", "res", "rets", "lit", "mem", "cat", "rt", "val", "bit", " Ret", "det", "info", "ft", "cur", "sr", "art", "mt", "bf", "RET", "rb", "len", "rot", "fun", "reg", "pt", "nat", "nt", "result", "pre", "ref", "opt", "data", "re", "flag", "arr", "obj", "alt", "arg", "success", "Ret", "rl", "let"]}}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_test_apply(MigrateSetParameters *params,\n\n                                      MigrationParameters *dest)\n\n{\n\n    *dest = migrate_get_current()->parameters;\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        dest->compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        dest->compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        dest->decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        dest->cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        dest->cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        dest->tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        dest->tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        dest->max_bandwidth = params->max_bandwidth;\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        dest->downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        dest->x_checkpoint_delay = params->x_checkpoint_delay;\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        dest->block_incremental = params->block_incremental;\n\n    }\n\n}\n", "idx": 21413, "substitutes": {"params": ["shape", "p", "css", "proc", "s", "words", "points", "lp", "pre", "source", "details", "ops", "pos", "gs", "same", "plugins", "vs", "mes", "spec", "master", "part", "global", "models", "phys", "src", "test", "options", "ras", "ds", "results", "pm", "config", "mos", "types", "mp", "asm", "ps", "args", "manager", "services", "parts", "changes", "target", "api", "comments", "param", "las", "prefix", "Param", "resources", "parse", "sym", "vm", "media", "rel", "apps", "rules", "nas", "ams", "es", "masters", "scope", "afi", "ctx", "sp", "sys", "server", "settings", "cms", "rs", "sync", "http", "par", "names", "pins", "mm", "prem", "members", "mac", "maker", "parser", "alias", "conn", "result", "session", "plugin", "gas", "includes", "cmp", "list", "ls", "pres", "remote"], "dest": ["shape", "true", "class", "cont", "prop", "proc", "miss", "kw", "feat", "ident", "source", "opt", "gen", "best", "replace", "master", "foreign", "desc", "global", "src", "test", "options", "name", "public", "config", "blast", "rest", "parent", "private", "sup", "target", "dep", "transfer", "slice", "home", "text", "wb", "die", "option", "temp", "err", "store", "build", "style", "later", "service", "output", "dist", "usr", "copy", "external", "comb", "Dest", "orig", "done", "sort", "node", "new", "route", "path", "result", "session", "outer", "plugin", "attr", "coord", "txt", "trans", "this", "delete", "remote"]}}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "void cpu_state_reset(CPUMIPSState *env)\n\n{\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", env->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n\n    tlb_flush(env, 1);\n\n\n\n    /* Reset registers to their default values */\n\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n\n                                 << env->cpu_model->CP0_LLAddr_shift;\n\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n\n    env->CCRes = env->cpu_model->CCRes;\n\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = env->cpu_model->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = env->cpu_model->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n\n    env->insn_flags = env->cpu_model->insn_flags;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->hflags = MIPS_HFLAG_UM;\n\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n\n       hardware registers.  */\n\n    env->CP0_HWREna |= 0x0000000F;\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n#ifdef TARGET_MIPS64\n\n    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n#endif\n\n#else\n\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n\n        /* If the exception was raised from a delay slot,\n\n           come back to the jump.  */\n\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n\n    } else {\n\n        env->CP0_ErrorEPC = env->active_tc.PC;\n\n    }\n\n    env->active_tc.PC = (int32_t)0xBFC00000;\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n    env->CP0_Wired = 0;\n\n    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);\n\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n\n    /* vectored interrupts not implemented, timer on int 7,\n\n       no performance counters. */\n\n    env->CP0_IntCtl = 0xe0000000;\n\n    {\n\n        int i;\n\n\n\n        for (i = 0; i < 7; i++) {\n\n            env->CP0_WatchLo[i] = 0;\n\n            env->CP0_WatchHi[i] = 0x80000000;\n\n        }\n\n        env->CP0_WatchLo[7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n", "idx": 21427, "substitutes": {"env": ["req", "inet", "example", "cv", "cache", "app", "eng", "equ", "dev", "enable", " Environment", " en", "module", "gear", "py", " environments", "et", "pos", "emb", "data", "oa", "org", "conf", "vs", "ec", "ext", "En", "global", "stage", "iter", "ev", "event", "en", "ea", "core", "img", "her", "db", "qv", "config", "ench", "header", "e", "args", "manager", "end", "viron", "Environment", "np", "environment", "cdn", "eu", "console", "esi", "gui", "h", "enc", "site", "el", "rev", "dict", "inv", "net", "vm", "init", "v", "err", "dat", "export", "token", "output", "ass", "ne", "vel", "fg", "client", "server", "NV", "edge", "assets", "qt", "het", "eni", "que", "code", "dt", "agen", "extra", "ini", "ah", "exc", "here", " environment", "fen", "engine", "conn", "session", "erv", "obj", "self", "er", "nc", "context", "exec", "this", "inc"]}}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 21430, "substitutes": {"bs": ["lb", "ins", "iss", "rs", "bb", "bid", "db", "bis", "ds", "ses", "banks", "bas", "fs", "bl", "b", "ss", "BS", "ps", "base", "sb", "bps", "bits", "bos", "cs", "blocks", "bes", "lbs", "pb", "bytes", "ops", "bc", "outs", "bot", "obj", "bing", "gs", "os", "fb", "vs", "las", "ubs", "ns", "ls", "rb", "obs", "ba", "js"], "op": ["typ", "loop", "ok", "doc", "x", "ocl", "prop", "p", "step", "ask", "block", "code", "vert", "http", "bit", "name", "rol", "type", "option", "info", "ip", "opus", "app", "f", "ype", "ep", "comp", "io", "oc", "mp", "pp", "hop", "mod", "o", " cop", "root", "OP", "key", "prev", "ipop", "pre", "opp", "opt", "oper", "pop", "off", "post", "ops", "Op", "ic", "obj", "id", "sp", "cop", "top", "cmp", "open", "ap", "node", "oop", "rop", "ext", "operation"], "errp": ["rrpc", " errlp", "erpa", "errr", "ryp", "erps", "prop", " errcp", " errps", "ern", "rylp", "prpa", "errlp", "rrp", "erP", "erpc", "ercp", "asterper", "rycp", "errP", "prpc", "rrP", "rrop", "ryr", "errcp", " errP", "errpc", "ryper", " errn", "errper", "errps", "errop", "errpa", " errper", "ryn", "rrps", "asterr", " errpc", "prp", "asterlp", " errr", "rrpa", " errop", " errpa", "erp", "rypa", "asterp", "errn"], "blocker": ["banter", " blockers", "Blockiner", "boxiner", "Blockers", " blockiner", "blockers", "boxer", "Blocker", " blockter", " blockler", "baner", "blockter", "Blockacer", "locker", "baners", "Blockler", "banner", "blockner", "Blockner", "lockner", "lockler", " blockacer", "blockiner", "lockers", "lockter", "blockacer", "boxacer", "blockler", " blockner"]}}
{"project": "qemu", "commit_id": "3ddf3efefa364505ee44582873612dd8f6abb838", "target": 0, "func": "static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21435, "substitutes": {"device": ["task", "android", "attribute", "mobile", "prop", "block", "code", " dev", "disk", "name", "type", "address", "dim", "mode", "driver", "gpu", "definition", "devices", "virt", "path", "dev", "serial", "user", "Device", "engine", "password", "VICE", "module", "service", "plugin", "d", "port", "target", "model", "data", "product", "phy", "unit", "feature", "network", "tag", "de", "ip"], "aio_context": ["aios_spec", "aio_document", "aio___context", "aio_socket", "aios_socket", "aios_condition", "aio___queue", "aios_concept", "aio_network", "aio___ctx", "aio_collection", "aio_session", "aios_ctx", "aio_support", "aio_spec", "aioopcontext", "aios_document", "aio_center", "aios_session", "aioopdocument", "aios_support", "aio___socket", "aio_queue", "aio_config", "aios_queue", "aios_config", "aioopctx", "aios_collection", "aio_concept", "aio_ctx", "aio_condition", "aios_center", "aioopsession", "aios_network", "aios_context"], "errp": ["iterc", "eorr", "erb", "errr", "rrc", " errb", "erps", "errc", "eorb", " errps", "iterps", "rrp", "erP", "errP", "rrP", "erc", "eorp", "iterP", "err", "errb", "eorps", "iterp", "errps", "rrps", " errr", "erp"], "blk": [" blb", "Blks", "blK", "oblks", " blK", "blkt", "BLk", "oblsk", "BLks", "BLK", " blkt", "llk", "oblker", "dlunk", "BLb", "plk", "Blck", "silks", "plker", "blb", "blker", "silker", "blks", "oblkt", " blsk", "plK", "dlker", "llker", "dlk", "BLck", "plck", "bleks", "oblk", "silsk", "blunk", "silk", "plks", "plkt", " blker", "plb", "Blk", "blck", "Blb", " blks", "llunk", "llks", " blck", "blsk", "dlkt", " blunk", "bleunk", "oblunk", "bleker", "blek", "Blkt", "plunk"], "bs": ["ins", "android", "iss", "rs", "bb", "css", "db", "bid", "bis", "ds", "bas", "as", "fs", "is", "bl", "b", "ss", "ros", "its", "bin", "BS", "Bs", "ps", "base", "sb", "cb", "bits", "bos", "bp", "cs", "ab", "boxes", "bi", "blocks", "bes", "bytes", "pb", "lbs", "ob", "bc", "outs", "obj", "gs", "gb", "os", "abc", "fb", "vs", "las", "lib", "ubs", "ns", "ls", "eb", "obs", "ba", "js"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n", "idx": 21450, "substitutes": {"str": ["st", "br", "iter", "text", "w", "enc", "code", "buffer", "name", "f", "dict", "fr", "sr", "cr", "cur", "pass", "strings", "wr", "err", "r", "kr", "STR", "ctr", "Str", "tr", "read", "arr", "ptr", "dr", "txt", "exec"], "hci": [" hni", "hco", "Hcit", "hhcit", " hcin", "vcin", "handcu", "ihcu", "hhci", " hai", "hhoci", " hcci", "ihcin", " hii", "affcci", "cc", "hcit", "cci", "hlc", "khai", "hdii", "affni", "hcin", "hcu", "hii", "hdcin", "handcin", "ccu", "hni", "hdco", "handcci", "Hoci", "Hci", "hhcci", "hlcu", "hlii", "rhii", "pci", "rhcin", " hcit", "ihai", " hc", "hlci", "hai", "khcin", " hcu", "pcu", " hco", "khci", "pcin", " hoci", "khcu", "hdci", "rhci", "pcci", "vci", "hc", "vni", "affcin", "cii", "hcci", "handci", "vcci", "affci", "Hcci", "hoci", "rhco", "ihci"], "bdaddr": ["godplayer", "dbadr", "dbaddress", "ndptr", "bdpart", "cbptr", "ndplayer", "bbpart", "ndadr", "bdattr", "BDno", "ndorig", "cbadr", "bdplayer", "bbaddress", "ndattr", "nbaddress", "ndwork", "nbnode", "godaddr", "BDattr", "cbaddr", "bbnode", "fdaddress", "dbaddr", "godpart", "fdptr", "bdorder", "bbaddr", "BDadr", "bbattr", "bdaddress", "bdnode", "BDaddr", "dborder", "godattr", "bbadr", "ndorder", "cbaddress", "nbpart", "bdadr", "nbaddr", "hdaddress", "ndaddr", "BDorig", "hdaddr", "dbplayer", "pdowner", "pdaddress", "pdorder", "fdwork", "ndowner", "godnode", "ndaddress", "dbattr", "cbwork", "bdorig", "bdwork", "bdptr", "ndno", "cbattr", "bdno", "bdowner", "dbowner", "pdaddr", "godaddress", "fdaddr", "BDaddress", "hdorig", "hdno"]}}
{"project": "qemu", "commit_id": "58aebb946acff82c62383f350cab593e55cc13dc", "target": 0, "func": "static int cris_mmu_translate_page(struct cris_mmu_result *res,\n\n\t\t\t\t   CPUState *env, uint32_t vaddr,\n\n\t\t\t\t   int rw, int usermode, int debug)\n\n{\n\n\tunsigned int vpage;\n\n\tunsigned int idx;\n\n\tuint32_t pid, lo, hi;\n\n\tuint32_t tlb_vpn, tlb_pfn = 0;\n\n\tint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\n\n\tint cfg_v, cfg_k, cfg_w, cfg_x;\t\n\n\tint set, match = 0;\n\n\tuint32_t r_cause;\n\n\tuint32_t r_cfg;\n\n\tint rwcause;\n\n\tint mmu = 1; /* Data mmu is default.  */\n\n\tint vect_base;\n\n\n\n\tr_cause = env->sregs[SFR_R_MM_CAUSE];\n\n\tr_cfg = env->sregs[SFR_RW_MM_CFG];\n\n\tpid = env->pregs[PR_PID] & 0xff;\n\n\n\n\tswitch (rw) {\n\n\t\tcase 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;\n\n\t\tcase 1: rwcause = CRIS_MMU_ERR_WRITE; break;\n\n\t\tdefault:\n\n\t\tcase 0: rwcause = CRIS_MMU_ERR_READ; break;\n\n\t}\n\n\n\n\t/* I exception vectors 4 - 7, D 8 - 11.  */\n\n\tvect_base = (mmu + 1) * 4;\n\n\n\n\tvpage = vaddr >> 13;\n\n\n\n\t/* We know the index which to check on each set.\n\n\t   Scan both I and D.  */\n\n#if 0\n\n\tfor (set = 0; set < 4; set++) {\n\n\t\tfor (idx = 0; idx < 16; idx++) {\n\n\t\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\t\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \n\n\t\t\t\t\tset, idx, hi, lo, tlb_vpn, tlb_pfn);\n\n\t\t}\n\n\t}\n\n#endif\n\n\n\n\tidx = vpage & 15;\n\n\tfor (set = 0; set < 4; set++)\n\n\t{\n\n\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\n\n\t\ttlb_vpn = hi >> 13;\n\n\t\ttlb_pid = EXTRACT_FIELD(hi, 0, 7);\n\n\t\ttlb_g  = EXTRACT_FIELD(lo, 4, 4);\n\n\n\n\t\tD_LOG(\"TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\\n\", \n\n\t\t\t mmu, set, idx, tlb_vpn, vpage, lo, hi);\n\n\t\tif ((tlb_g || (tlb_pid == pid))\n\n\t\t    && tlb_vpn == vpage) {\n\n\t\t\tmatch = 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\n\n\tres->bf_vec = vect_base;\n\n\tif (match) {\n\n\t\tcfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);\n\n\t\tcfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);\n\n\t\tcfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);\n\n\t\tcfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);\n\n\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\t\ttlb_v = EXTRACT_FIELD(lo, 3, 3);\n\n\t\ttlb_k = EXTRACT_FIELD(lo, 2, 2);\n\n\t\ttlb_w = EXTRACT_FIELD(lo, 1, 1);\n\n\t\ttlb_x = EXTRACT_FIELD(lo, 0, 0);\n\n\n\n\t\t/*\n\n\t\tset_exception_vector(0x04, i_mmu_refill);\n\n\t\tset_exception_vector(0x05, i_mmu_invalid);\n\n\t\tset_exception_vector(0x06, i_mmu_access);\n\n\t\tset_exception_vector(0x07, i_mmu_execute);\n\n\t\tset_exception_vector(0x08, d_mmu_refill);\n\n\t\tset_exception_vector(0x09, d_mmu_invalid);\n\n\t\tset_exception_vector(0x0a, d_mmu_access);\n\n\t\tset_exception_vector(0x0b, d_mmu_write);\n\n\t\t*/\n\n\t\tif (cfg_k && tlb_k && usermode) {\n\n\t\t\tD(printf (\"tlb: kernel protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 2;\n\n\t\t} else if (rw == 1 && cfg_w && !tlb_w) {\n\n\t\t\tD(printf (\"tlb: write protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\t/* write accesses never go through the I mmu.  */\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (rw == 2 && cfg_x && !tlb_x) {\n\n\t\t\tD(printf (\"tlb: exec protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (cfg_v && !tlb_v) {\n\n\t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 1;\n\n\t\t}\n\n\n\n\t\tres->prot = 0;\n\n\t\tif (match) {\n\n\t\t\tres->prot |= PAGE_READ;\n\n\t\t\tif (tlb_w)\n\n\t\t\t\tres->prot |= PAGE_WRITE;\n\n\t\t\tif (tlb_x)\n\n\t\t\t\tres->prot |= PAGE_EXEC;\n\n\t\t}\n\n\t\telse\n\n\t\t\tD(dump_tlb(env, mmu));\n\n\t} else {\n\n\t\t/* If refill, provide a randomized set.  */\n\n\t\tset = env->mmu_rand_lfsr & 3;\n\n\t}\n\n\n\n\tif (!match && !debug) {\n\n\t\tcris_mmu_update_rand_lfsr(env);\n\n\n\n\t\t/* Compute index.  */\n\n\t\tidx = vpage & 15;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, pid, 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  pid,\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->phy = tlb_pfn << TARGET_PAGE_BITS;\n\n\treturn !match;\n\n}\n", "idx": 21459, "substitutes": {"res": ["req", "gr", "def", "resp", "ex", "Res", "ras", "rev", "ret", "results", "proc", "response", "rh", "pers", "RES", "err", "reg", "result", "rem", "des", "re", "rc", "arr", "sys", "resource", "rec", "pres"], "env": ["En", "global", "console", "ev", "iss", "het", "esi", "eve", "event", "eni", "en", "enc", "ea", "site", "forge", "que", "core", "her", "dt", "qv", "db", "shell", "ef", "config", "eng", "inv", "equ", "init", "exc", "dir", "err", "dat", "export", "e", "engine", "conn", "esm", "manager", "erv", "end", "ens", "viron", "ne", "np", "Environment", "profile", "pos", "obj", "scope", "environment", "eu", "conf", "txt", "esp", "nc", "context", "enter", "assets", "qt", "exec", "energy", "ec", "ext"], "vaddr": ["evaddress", "fhost", "vaddress", "vhost", "nvaddr", " vaddress", "evhost", "lvaddr", "lvhost", "vcall", " vhost", "svaddr", "vadd", "svhost", "lvaddress", "evaddr", "nvaddress", "svadd", "lvcall", "evcall", "svaddress", "nvcall", "faddr", "faddress", " vadd", "nvhost", "fadd"], "rw": ["dc", "ww", "mr", "w", "wb", "tw", "rss", "proc", "ro", "ru", "rx", "rh", "wa", "RW", "wr", "raw", "wx", "fw", "sw", "wh", "rr", "nr", "hw", "ride", "nw", "rd", "usr", "worker", "rc", "rf", "iw", "rew", "nc", "rl", "rb", "rg"], "usermode": ["userid", "usrlevel", "winlevel", "usrid", "winmode", " userid", " userlevel", "userlevel", "winid", "usrmode"], "debug": ["dc", "trace", "write", "cache", "depth", "cli", "proc", "info", "config", "bug", "scale", "fun", "mod", "dev", "err", "error", "reg", "run", "web", "progress", "rc", "Debug", "rec", "DEBUG"], "vpage": ["Vrecord", "Vpg", "svPage", "vpg", "lpage", "fpl", " vpg", "vpl", " vpp", "fpage", "lcenter", "Vpage", "vcenter", "lpages", "VPage", " vpages", "vpp", "vPage", "svpage", "svpp", "vrecord", "valpg", "vpages", "Vpp", "valpages", "Vpages", "valpage", "valrecord", " vcenter", "lpl", " vrecord", " vPage", "fpages", "fcenter", " vpl"], "idx": ["ridx", "idex", "Idi", "midy", "idexx", " idxx", " idu", "iden", "Idxc", " idy", "Idx", "idey", "idez", "idw", "aidv", "IDy", " idX", "midx", "Idxs", "indz", " idv", " idz", "idu", "ridxi", "IdX", "Idwx", "idy", "idxi", "aidy", " idxs", "midX", "oidX", "idX", " idwx", "IDX", "idz", "ridz", " idxc", "indxi", "idn", "indy", "idv", "midw", " idn", "ridX", "aidz", "indX", "oidwx", "IDxx", "ndu", "aidX", "indx", "Idv", "idxx", "oidxc", "idxs", "aidx", "idwx", "indi", "Idy", " idi", "idxc", "IDz", "idi", "IDx", "oidx", "IDw", "ndX", "ndx", "ndy", "ideX", "Idu", "IDxs", " idxi", "aidn", " idw"], "pid": ["nic", "po", "pd", "pa", "p", "prop", "phi", "pin", "cpu", "pointer", "offset", "proc", "mode", "pm", "net", "uid", "pc", "pins", "pp", "pi", "uri", "rot", "pt", "conn", "page", "pri", "py", "port", "vid", "pos", "pu", "pty", "id", "mi", "mid", "ci", "i", "sid", "prefix"], "lo": ["ha", "po", "loop", "line", "cl", "lin", "lc", "bo", "que", "co", "local", "lim", "mo", "loc", "low", "le", "ln", "go", "LO", "cli", "ini", "ro", "Hi", "lt", "hei", "so", "ino", "len", "who", "rio", "los", "o", "base", "min", "l", "old", "olo", "pri", "iso", "lu", "elo", "fo", "pl", "li", "pos", "cho", "mid", "ci", "lie", "la", "mi", "las", "Lo", "lite", "ilo", "lon", "ko", "no", "lib", "zo"], "hi": ["ha", "po", "ii", "full", "home", "ul", "hu", "h", "hl", "high", "flo", "gh", "phi", "hel", "lim", "loc", "low", "cli", "info", "go", "LO", "ini", "Hi", "ni", "wa", "ho", "hei", "hide", "win", "hh", "pi", "index", "tick", "base", "cgi", "l", "hello", "ph", "limit", "show", "end", "li", "mini", "api", "pos", "big", "mid", "id", "mi", "ci", "la", "i", "Lo", "ko", "HI"], "tlb_vpn": ["tlb_vrn", "tlb_psn", "tlb_fsn", "tlb_nvpn", "tlb_nvfn", "tlb_lfn", "tlb_rpn", "tlb_fpn", "tlb_fpc", "tlb_ppc", "tlb_nvrn", "tlb_svfn", "tlb_ffn", "tlb_lsn", "tlb_vsn", "tlb_avfn", "tlb_svpn", "tlb_avnp", "tlb_renn", "tlb_lrn", "tlb_pcn", "tlb_vcn", "tlb_penn", "tlb_lpc", "tlb_venn", "tlb_vnp", "tlb_nvnp", "tlb_lnp", "tlb_svcn", "tlb_svenn", "tlb_rfn", "tlb_pfn", "tlb_ppn", "tlb_vfn", "tlb_avrn", "tlb_avpn", "tlb_lpn", "tlb_vpc", "tlb_rcn"], "tlb_pid": ["tlb_p", "tlb_pin", "tla_pid", "tla_vid", "tlb_vid", "tla_pin", "tla_p"], "tlb_g": ["tla_g", "tla_gn", "tla_ga", "tlb_gn", "tlb_ga", "tla_w"], "tlb_v": ["tlb_h", "tlb__v", "tlb__y", "tlb__h", "tlb_y", "tlb__w"], "tlb_k": ["tbl_n", "tlb_q", "tbl_k", "tbl_w", "tbl_q", "tlb_n"], "tlb_w": ["tbl_wa", "tbl_y", "tlb_wa", "tbl_w", "tlb_y", "tbl_k"], "tlb_x": ["tlb_h", "tla_xes", "tlb_xes", "tla_h", "tla_x", "tla_w"], "cfg_v": ["config_vy", "config_g", "config_v", "cfg_f", "cfg_vy", "config_f", "cfg_g"], "cfg_k": ["cfg_z", "config_k", "config_v", "cfg_q", "config_z", "config_q"], "cfg_w": ["cfg_wa", "conf_ws", "conf_d", "conf_wa", "cfg_ws", "conf_w", "cfg_d"], "cfg_x": ["config_ex", "config_w", "cfg_y", "config_y", "config_x", "cfg_ex"], "set": ["write", "match", "use", "se", "kit", "offset", "see", "Set", "sche", "base", "et", "pos", "open", "add", "no", "spec", "ment", "get", "ha", "setup", "reset", "test", "row", "section", "en", "num", "name", "loc", "config", "sc", "index", "mod", "ind", "nat", "end", "size", "check", "rc", "id", "shift", "parse", "site", "vert", "net", "init", "c", "error", "dat", "draw", "value", "slave", "unit", "done", "server", "sort", "stop", "it", "settings", "create", "zero", "sync", "type", "start", "setting", "scale", "send", "col", "SET", "post", "sec", "inc"], "r_cause": ["r_case", "rl_cause", "rl_src", "racdesc", " racCause", "r__desc", "racCause", "rl_case", " racca", "raccause", "r__Cause", " r_Cause", "racca", "rl_Cause", " r_ca", "r_desc", " raccause", "r_ca", " r_desc", "r_src", "r__ca", "r__cause", "r_Cause", " racdesc"], "r_cfg": ["r__config", "p__cf", "r__cfg", "r2cfg", "p__fg", "p_config", "r_conf", "r__fg", "r_config", " r_cf", "p__cfg", "p_fg", "r2conf", "r_cf", "p_cfg", "p_cf", "r__cf", "r_gc", " r_conf", " r_gc", "r2gc", "r_fg", "r2cf", "p__config"], "rwcause": ["wxsequence", "rfcedes", "rhreason", "rxsource", "wlCause", "RWcause", "wrcause", "rwraise", "wldue", "RWreason", "rxcedes", "swscope", "rfreason", "rwsequence", "wrsequence", "rwscope", "rhsequence", "rwreason", "rwcedes", "rxcause", "rhcause", "rfraise", "rftype", "wxdue", "RWdue", "rhscope", "wxCause", "rhcedes", "rfcause", "wxcause", "rxraise", "rwdue", "rfsource", "RWCause", "rwCause", "wrsource", "rwsource", "swreason", "rhsource", "RWsource", "swtype", "wlcause", "rfscope", "wrreason", "rhtype", "rwtype", "swcause", "wlsequence", "RWsequence", "rhraise"], "vect_base": ["vex_bas", "vex_bin", "vex_base", "vect2bin", "vect2base", "vect2Base", "vect_Base", "vect_bas", "vect_name", "vect_bin", "vex_Base", "vect2name", "vex_name"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n", "idx": 21466, "substitutes": {"ctx": ["cf", "crit", "cms", "gc", "cv", "xc", "src", "jp", "lc", "cc", "loc", "config", "sci", "pc", "Context", "anc", "sc", "ct", "fc", "mac", "c", "ca", "tx", "conn", "kb", "fp", "hw", "cm", "conv", "qa", "np", "tc", "obj", "scope", "rc", "cca", "vc", "cpp", "ci", "txt", "pkg", "cmp", "ctrl", "component", "nc", "context", "exec", "cn", "node"]}}
{"project": "qemu", "commit_id": "96193c22ab39ea24f81e386ad7883260ff24f5fd", "target": 0, "func": "static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n", "idx": 21473, "substitutes": {"cpu": ["chip", "mx", "CPU", "xc", "cache", "lc", "eni", "uci", "platform", "linux", "uca", "core", "processor", "cli", "proc", "gpu", "pc", "uc", "anc", "vm", "cow", "fc", "intel", "c", "conn", "hw", "kernel", "np", "cp", "instance", "pu", "ctx", "nc", "bench", "node", "ec"], "env": ["desc", "settings", "cfg", "inst", "global", "console", "stage", "ev", "cache", "armor", "stack", "eni", "en", "enc", "ea", "site", "core", "code", "que", "el", "disk", "cli", "extra", "config", "eng", "ini", "net", "anc", "vm", "agent", "exc", "c", "err", "path", " environment", "e", "export", "style", "engine", "conn", "args", "kernel", "zone", "opt", "end", "et", "profile", "viron", "ne", "np", "Environment", "scope", "environment", "ctx", "eu", "oa", "conf", "fg", "esp", "vs", "server", "nc", "context", "loader", "bench", "exec", "energy", "ec", "skin", "ext"], "i": ["ti", "ii", "ui", "abi", "qi", "x", "I", "esi", "p", "eni", "h", "phi", "di", "ri", "name", "j", "f", "ai", "ini", "oi", "ni", "ski", "io", "si", "b", "v", "a", "pi", "n", "index", "ami", "c", "uri", "ei", "o", "e", "l", "adi", "xi", "u", "key", "yi", "fi", "li", "d", "iu", "k", "id", "m", "ci", "multi", "t", "zi", "mi", "gi", "z", "mu", "bi", "ip"], "esa": ["ti", "ace", "iera", "anse", "pa", "esi", "isi", "ea", "sea", "sa", "aga", "se", "uca", "pse", "ada", "za", "ma", "ESA", "ses", "iza", "si", "ozo", "osi", "ista", "ia", "ca", "era", "edi", "ya", "nette", "asi", "esse", "ette", "es", "ega", "tta", "essa", "esta", "sem", "zi", "ci", "la", "anza", "issa", "ede", "isa", "una"], "s": ["settings", "states", "S", "south", "sq", "w", "src", "p", "sym", "sync", "sa", "se", "http", "ses", "status", "f", "shell", "sr", "b", "sc", "v", "state", "n", "c", "sie", "o", "sb", "e", "y", "r", "l", "service", "session", "u", "sk", "services", "d", "in", "ssl", "su", "m", "sys", "os", "t", "sf", "server", "g", "sl", "spec", "js"]}}
{"project": "qemu", "commit_id": "2bcf018340cbf233f7145e643fc1bb367f23fd90", "target": 0, "func": "int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n", "idx": 21487, "substitutes": {"env": ["console", "eni", "en", "enc", "priv", "ea", "que", "proc", "config", "eng", "equ", "inv", "net", "init", "exc", "buf", "err", "estate", "export", "enable", "engine", "exe", "e", "conn", "manager", "erv", "esc", "viron", "np", "emb", "scope", "ptr", "environment", "eu", "txt", "er", "context", "energy", "ec"], "raddr": ["padd", "rconfig", "wptr", "wadd", " radd", "Raddress", "pptr", " raddress", "waddr", "paddress", "wconfig", "Rconfig", "Raddr", "raddress", "rptr", "waddress", "radd", "paddr", " rptr", " rconfig", "Rptr"], "rw": ["ran", "ww", "w", "wb", "mode", "rx", "rh", " w", "RW", "wr", "wx", "sw", "wh", "rr", " wo", "nw", " ro", "worker", " wid", "rc", "slave", "lr", "wo", "rl", "W", "wp", "rb"], "addr": ["adr", "ace", "rs", "en", "host", "route", "offset", "ord", "pointer", "address", "mode", "func", "callback", "align", "amp", "seq", "ar", "lag", "nr", "r", "fd", "args", "amd", "size", "inter", "layer", "attr", "coord", "data", "ptr", "arr", "oa", "pad", "ad", "grad", "lr", "add", "edge", "node"], "flags": ["settings", "ins", "options", "forces", "reads", "cycles", "planes", "types", "pages", "stats", "fs", "mask", "files", "lag", "bits", "weights", "rules", "Flags", "args", "orts", "ports", "locks", "fps", "parts", "vals", "includes", "ops", "features", "ips", "caps", "flag", "FLAG", "workers", "fields", "plugins", "ages", "ints", "ags", "bytes"]}}
{"project": "qemu", "commit_id": "6cded3a43ad0044d9831590795d9c6cf0dc2d2ee", "target": 0, "func": "static void nic_selective_reset(EEPRO100State * s)\n\n{\n\n    size_t i;\n\n    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n\n    //~ eeprom93xx_reset(s->eeprom);\n\n    memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n\n    eeprom_contents[0xa] = 0x4000;\n\n    if (s->device == i82557B || s->device == i82557C)\n\n        eeprom_contents[5] = 0x0100;\n\n    uint16_t sum = 0;\n\n    for (i = 0; i < EEPROM_SIZE - 1; i++) {\n\n        sum += eeprom_contents[i];\n\n    }\n\n    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;\n\n    TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eeprom_contents[EEPROM_SIZE - 1]));\n\n\n\n    memset(s->mem, 0, sizeof(s->mem));\n\n    uint32_t val = BIT(21);\n\n    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n\n\n\n    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));\n\n    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));\n\n}\n", "idx": 21492, "substitutes": {"s": ["ins", "states", "sets", "S", "south", "sq", "w", "rs", "secondary", "ks", "p", "sym", "aws", "sync", "http", "ses", "ds", "f", "xs", "stats", "is", "fs", "b", "ss", "si", "ts", "a", "state", "n", "c", "spec", "ps", "sb", "o", "sites", "e", "cs", "l", "r", "args", "service", "u", "services", "qs", "es", "d", "in", "tests", "uns", "ssl", "gs", "self", "m", "t", "sf", "ns", "ls", "sg", "g", "your", "new", "js"], "i": ["ti", "ii", "ui", "ji", "abi", "qi", "x", "I", "ix", "p", "phi", "di", "ri", "j", "type", "f", "ai", "info", "ini", "oi", "ni", "q", "is", "si", "b", "io", "v", "a", "pi", "n", "index", "uri", "c", "me", "base", "o", "e", "y", "l", "r", "xi", "u", "pre", "key", "fi", "li", "d", "data", "count", "k", "id", "m", "ci", "t", "mi", "zi", "multi", "slice", "gi", "z", "mu", "bi", "it", "ip"], "eeprom_contents": ["eeprom_scens", "eeprom_constences", "eeprom_compenses", "eeprom_contentences", "eeprom_constent", "eeprom_constenses", "eeprom_constENTS", "eeprom_compences", "eeprom_CONTents", "eeprom_contentenses", "eeprom_compents", "eeprom_macens", "eeprom_contentainers", "eeprom_contentens", "eeprom_CONTences", "eeprom_condent", "eeprom_macENTS", "eeprom_CONTants", "eeprom_contants", "eeprom_extences", "eeprom_scainers", "eeprom_contENTS", "eeprom_CONTENTS", "eeprom_compent", "eeprom_macents", "eeprom_extents", "eeprom_contences", "eeprom_compants", "eeprom_descents", "eeprom_compENTS", "eeprom_condENTS", "eeprom_contentENTS", "eeprom_descences", "eeprom_scents", "eeprom_extants", "eeprom_contentent", "eeprom_descens", "eeprom_extent", "eeprom_contenses", "eeprom_condences", "eeprom_constens", "eeprom_contens", "eeprom_condents", "eeprom_macants", "eeprom_CONTens", "eeprom_contentents", "eeprom_content", "eeprom_compens", "eeprom_scences", "eeprom_condens", "eeprom_descent", "eeprom_constents", "eeprom_containers", "eeprom_contentants", "eeprom_CONTainers"]}}
{"project": "qemu", "commit_id": "0208def1cadd4f72f862e62548c2af268a543b20", "target": 1, "func": "void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n", "idx": 21508, "substitutes": {"dev": ["debug", "def", "ev", "w", "Dev", "priv", "bridge", "block", "info", "app", "driver", "DEV", "device", "bug", "v", "pro", "mod", "reg", "bus", "serial", "ver", "conn", "module", "ch", "ref", "end", "d", "diff", "plug", "self", "pad", "param", "ad", "pub", "cam", "dom", "de", "rad", "var"], "conf": ["def", "cache", "prop", "lc", "co", "info", "f", "app", "cur", "sche", "con", "ca", "sum", "ref", "py", "ff", "bc", "count", "spec", "comment", "cl", "cc", "loc", "config", "um", "aff", "cert", "fac", "rc", "param", "cfg", "cap", "enc", "ac", "dict", "uc", "pass", "init", "bug", "v", "gu", "c", "err", "ch", "ph", "cal", "conv", "fi", "comb", "ctx", "Conf", "client", "pub", "cf", "inf", "sync", "block", "fab", "coll", "vol", "cb", "conn", "col", "fam", "cmp", "cn", "sec", "inc", "ang"]}}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n", "idx": 21511, "substitutes": {"client": ["global", "cache", "contract", "local", "http", "cli", "public", "config", "pc", "Client", "con", "c", "parent", "conn", "connection", "command", "port", "api", "cell", "child", "self", "server", "util", "node", "resource", "project", "remote", "ip"], "start_addr": ["start_off", "end_hop", "end_name", "start_name", "startedhop", "start00addr", "start00address", "startedaddress", "start_address", "start00off", "end_address", "end_range", "start_hop", "start_range", "startedaddr", "end_off", "start00name", "startedrange"], "end_addr": ["end_arm", "end64address", "end_hop", "start_address", "start_arm", "end_address", "start_hop", "end64addr", "end64arm", "end64hop"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 21513, "substitutes": {"opaque": ["opec", "OPaque", "optaque", "opque", " opque", "optaques", "OPsa", "opsa", "OPec", " opsa", "Opec", "Opque", "Opsa", " opaques", "OPaques", "Opaque", "OPque", " opec", "opaques", "optque"], "addr": ["adr", "ace", "x", " address", "src", "alloc", "ea", "host", "arm", "code", "route", "offset", "pointer", "rt", "ord", "address", "mode", "start", "rx", "mt", "asm", "len", "seq", "amp", "align", "ar", "base", "slot", "alias", "nr", "r", "conn", "xp", "args", "amd", "ref", "point", "size", "port", "pos", "rc", "data", "ptr", "afi", "ctx", "dr", "pad", "alt", "ad", "arg", "oa", "grad", "cmp", "sid", "slice", "node", "ip"], "s": ["ins", "states", "sets", "S", "sq", "resses", "sym", "p", "als", "ows", "ses", "status", "ds", "ions", "rows", "fs", "ss", "ts", "a", "opens", "c", "hs", "ps", "o", "sb", "e", "aces", "cs", "r", "session", "ies", "es", "port", "ips", "outs", "ssl", "gs", " streams", "m", "conf", "os", "sys", "ays", "g", "ls", "sg", "acks", "ums"], "saddr": ["psrc", " saddress", "fsrc", "isaddr", "fhost", "pha", "bptr", "taddr", " snode", " slayer", "isnode", "baddress", " scall", "rint", "phost", "southaddress", "asptr", "ascall", " sha", "tnode", "slayer", "pcall", "islayer", "asaddress", "raddr", "sint", "sha", "pptr", "southaddr", "baddr", "ssrc", "pint", "paddress", "southhost", "shost", "asaddr", "isaddress", " sptr", "faddr", "snode", " sint", "tlayer", "faddress", "scall", "paddr", "saddress", "taddress", "rha", "sptr", "southsrc", "raddress"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    int i;\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    qemu_irq dma_irqs[6];\n\n    DriveInfo *dinfo;\n\n    SysBusDevice *busdev;\n\n\n\n    if (!core)\n\n        core = \"ti925t\";\n\n\n\n    /* Core */\n\n    s->mpu_model = omap310;\n\n    s->cpu = cpu_arm_init(core);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP15XX_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    memory_region_init_ram(&s->emiff_ram, NULL, \"omap1.dram\", s->sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->emiff_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_EMIFF_BASE, &s->emiff_ram);\n\n    memory_region_init_ram(&s->imif_ram, NULL, \"omap1.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->imif_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_IMIF_BASE, &s->imif_ram);\n\n\n\n    omap_clkm_init(system_memory, 0xfffece00, 0xe1008000, s);\n\n\n\n    s->ih[0] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[0], \"size\", 0x100);\n\n    qdev_prop_set_ptr(s->ih[0], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0xfffecb00);\n\n    s->ih[1] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[1], \"size\", 0x800);\n\n    qdev_prop_set_ptr(s->ih[1], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[1]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_15XX_IH2_IRQ));\n\n    /* The second interrupt controller's FIQ output is not wired up */\n\n    sysbus_mmio_map(busdev, 0, 0xfffe0000);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap1_dma_irq_map[i].ih],\n\n                                       omap1_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma_init(0xfffed800, dma_irqs, system_memory,\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_DMA_LCD),\n\n                           s, omap_findclk(s, \"dma_ck\"), omap_dma_3_1);\n\n\n\n    s->port[emiff    ].addr_valid = omap_validate_emiff_addr;\n\n    s->port[emifs    ].addr_valid = omap_validate_emifs_addr;\n\n    s->port[imif     ].addr_valid = omap_validate_imif_addr;\n\n    s->port[tipb     ].addr_valid = omap_validate_tipb_addr;\n\n    s->port[local    ].addr_valid = omap_validate_local_addr;\n\n    s->port[tipb_mpui].addr_valid = omap_validate_tipb_mpui_addr;\n\n\n\n    /* Register SDRAM and SRAM DMA ports for fast transfers.  */\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->emiff_ram),\n\n                         OMAP_EMIFF_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->imif_ram),\n\n                         OMAP_IMIF_BASE, s->sram_size);\n\n\n\n    s->timer[0] = omap_mpu_timer_init(system_memory, 0xfffec500,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER1),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[1] = omap_mpu_timer_init(system_memory, 0xfffec600,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER2),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[2] = omap_mpu_timer_init(system_memory, 0xfffec700,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER3),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n\n\n    s->wdt = omap_wd_timer_init(system_memory, 0xfffec800,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_WD_TIMER),\n\n                    omap_findclk(s, \"armwdt_ck\"));\n\n\n\n    s->os_timer = omap_os_timer_init(system_memory, 0xfffb9000,\n\n                    qdev_get_gpio_in(s->ih[1], OMAP_INT_OS_TIMER),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->lcd = omap_lcdc_init(system_memory, 0xfffec000,\n\n                            qdev_get_gpio_in(s->ih[0], OMAP_INT_LCD_CTRL),\n\n                            omap_dma_get_lcdch(s->dma),\n\n                            omap_findclk(s, \"lcd_ck\"));\n\n\n\n    omap_ulpd_pm_init(system_memory, 0xfffe0800, s);\n\n    omap_pin_cfg_init(system_memory, 0xfffe1000, s);\n\n    omap_id_init(system_memory, s);\n\n\n\n    omap_mpui_init(system_memory, 0xfffec900, s);\n\n\n\n    s->private_tipb = omap_tipb_bridge_init(system_memory, 0xfffeca00,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PRIV),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n    s->public_tipb = omap_tipb_bridge_init(system_memory, 0xfffed300,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PUB),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n\n\n    omap_tcmi_init(system_memory, 0xfffecc00, s);\n\n\n\n    s->uart[0] = omap_uart_init(0xfffb0000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART1),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    s->drq[OMAP_DMA_UART1_TX], s->drq[OMAP_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap_uart_init(0xfffb0800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART2),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    s->drq[OMAP_DMA_UART2_TX], s->drq[OMAP_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap_uart_init(0xfffb9800,\n\n                                qdev_get_gpio_in(s->ih[0], OMAP_INT_UART3),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    s->drq[OMAP_DMA_UART3_TX], s->drq[OMAP_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->dpll[0] = omap_dpll_init(system_memory, 0xfffecf00,\n\n                                omap_findclk(s, \"dpll1\"));\n\n    s->dpll[1] = omap_dpll_init(system_memory, 0xfffed000,\n\n                                omap_findclk(s, \"dpll2\"));\n\n    s->dpll[2] = omap_dpll_init(system_memory, 0xfffed100,\n\n                                omap_findclk(s, \"dpll3\"));\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap_mmc_init(0xfffb7800, system_memory,\n\n                           blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_OQN),\n\n                           &s->drq[OMAP_DMA_MMC_TX],\n\n                    omap_findclk(s, \"mmc_ck\"));\n\n\n\n    s->mpuio = omap_mpuio_init(system_memory, 0xfffb5000,\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_KEYBOARD),\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_MPUIO),\n\n                               s->wakeup, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"clk\", omap_findclk(s, \"arm_gpio_ck\"));\n\n    qdev_init_nofail(s->gpio);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->gpio), 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_GPIO_BANK1));\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s->gpio), 0, 0xfffce000);\n\n\n\n    s->microwire = omap_uwire_init(system_memory, 0xfffb3000,\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireTX),\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireRX),\n\n                    s->drq[OMAP_DMA_UWIRE_TX], omap_findclk(s, \"mpuper_ck\"));\n\n\n\n    s->pwl = omap_pwl_init(system_memory, 0xfffb5800,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n    s->pwt = omap_pwt_init(system_memory, 0xfffb6000,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x11);\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"mpuper_ck\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(s->ih[1], OMAP_INT_I2C));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP_DMA_I2C_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP_DMA_I2C_RX]);\n\n    sysbus_mmio_map(busdev, 0, 0xfffb3800);\n\n\n\n    s->rtc = omap_rtc_init(system_memory, 0xfffb4800,\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_TIMER),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_ALARM),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->mcbsp1 = omap_mcbsp_init(system_memory, 0xfffb1800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1RX),\n\n                    &s->drq[OMAP_DMA_MCBSP1_TX], omap_findclk(s, \"dspxor_ck\"));\n\n    s->mcbsp2 = omap_mcbsp_init(system_memory, 0xfffb1000,\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_TX),\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_RX),\n\n                    &s->drq[OMAP_DMA_MCBSP2_TX], omap_findclk(s, \"mpuper_ck\"));\n\n    s->mcbsp3 = omap_mcbsp_init(system_memory, 0xfffb7000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3RX),\n\n                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, \"dspxor_ck\"));\n\n\n\n    s->led[0] = omap_lpg_init(system_memory,\n\n                              0xfffbd000, omap_findclk(s, \"clk32-kHz\"));\n\n    s->led[1] = omap_lpg_init(system_memory,\n\n                              0xfffbd800, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    /* Register mappings not currenlty implemented:\n\n     * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310)\n\n     * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310)\n\n     * USB W2FC\t\tfffb4000 - fffb47ff\n\n     * Camera Interface\tfffb6800 - fffb6fff\n\n     * USB Host\t\tfffba000 - fffba7ff\n\n     * FAC\t\tfffba800 - fffbafff\n\n     * HDQ/1-Wire\tfffbc000 - fffbc7ff\n\n     * TIPB switches\tfffbc800 - fffbcfff\n\n     * Mailbox\t\tfffcf000 - fffcf7ff\n\n     * Local bus IF\tfffec100 - fffec1ff\n\n     * Local bus MMU\tfffec200 - fffec2ff\n\n     * DSP MMU\t\tfffed200 - fffed2ff\n\n     */\n\n\n\n    omap_setup_dsp_mapping(system_memory, omap15xx_dsp_mm);\n\n    omap_setup_mpui_io(system_memory, s);\n\n\n\n    qemu_register_reset(omap1_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 21538, "substitutes": {"system_memory": ["system_program", "native_modules", "get_memory", "system_network", "sys_memory", "system_message", "native_program", "sys_reference", "system_machine", "system_mem", "get_audio", "native_memory", "system_modules", "get_queue", "get_storage", "system_reference", " system_message", " system_machine", "sys_mem", "system_queue", "native_machine", "system_storage", "sys_network", " system_mem", "system_audio"], "sdram_size": ["sdram_len", "sdram2size", "sdcam2size", "sdmem_name", "sdram2Size", "sdcam_size", "sdramsmode", "sdram2len", "sdramssize", "sdmem_weight", "sdram_address", "sdmem_mode", "sdcam_name", "sdmem_size", "sdgram_size", "sdram_mode", "sdcam_Size", "sdram_ui", "sdram_scale", "sdram_Size", "sdcam_address", "sdram_sized", "sdgram_scale", "sdram2name", "sdgram_mode", "sdram_weight", "sdcam2Size", "sdramsscale", "sdram_name", "sdcam2len", "sdcam_ui", "sdcam_sized", "sdcam_len", "sdcam2name"], "core": [" Core", "chip", "support", "ore", "cy", "cache", "lc", "sync", "arch", "cat", "cpu", "code", "force", "processor", "ce", "type", "mode", "name", "year", "ignore", "ro", "cr", "respect", "con", "rest", "c", "ores", "base", "path", "python", "wheel", "framework", "ync", "cycle", "col", "fine", "common", "function", "cm", "six", "functional", "cp", " cores", "rc", "chrome", "category", "primary", "scope", "Core", "score", "custom", "component", "feature", "cn", "node", "binary", "ext", "cor"], "i": ["ii", "I", "p", "j", "type", "f", "counter", "is", "si", "b", "io", "a", "pi", "n", "index", "c", "base", "e", "l", "r", "xi", "d", "rc", "count", "k", "id", "z", "ip"], "s": ["south", "secondary", "p", "us", "se", "f", "si", "a", "sb", "storage", "cs", "u", "details", "gs", "conf", "this", "spec", "options", "aws", "sa", "ses", "ds", "j", "xs", "sample", "is", "b", "ts", "sc", "n", "ps", "e", "y", "args", "services", "os", "params", "states", "S", "ks", "w", "sym", "site", "stats", "its", "state", "c", "l", "r", "service", "qs", "es", "scope", "m", "sys", "t", "server", "g", "sl", "new", "settings", "sets", "sq", "rs", "sync", "fs", "security", "ss", "native", "o", "session", "uns", "d", "ssl", "su", "self", "sf", "ns", "ls", "sg", "js"], "dma_irqs": ["dma_irq", "dma_rinqq", "dma_rinqs", "dma_irqq", "dma_irecs", "dma_rincs", "dma_ircs", "dma_ireqq", "dma_ireqs", "dma_mirqs", "dma_mircs", "dma_ireq", "dma_rinq", "dma_mirqq", "dma_mirq"], "dinfo": [" dfo", " dfi", "vdfi", "bdfo", "bdinfo", "dfo", "vdinfo", "did", "dfi", "vdid", "vdfo", "bdid", " did", "bdfi"], "busdev": ["busDev", "ckcam", " busDev", "Buscam", "buscam", "ckDev", "busdevice", "ckdevice", " busdevice", " buscam", "Busdev", "BusDev", "Busdevice", "ckdev"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_client_close(NBDClient *client)\n\n{\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    client->closing = true;\n\n\n\n    /* Force requests to finish.  They will drop their own references,\n\n     * then we'll close the socket and free the NBDClient.\n\n     */\n\n    shutdown(client->sock, 2);\n\n\n\n    /* Also tell the client, so that they release their reference.  */\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n}\n", "idx": 21549, "substitutes": {"client": ["channel", "php", "image", "close", "secure", "cl", "cache", "event", "contract", "call", "host", "current", "core", "local", "http", "name", "ce", "cli", "public", "app", "consumer", "friend", "object", "config", "pc", "request", "Client", "cmd", "content", "cod", "con", "c", "protected", "parent", "handler", "patch", "conn", "service", "session", "clean", "project", "manager", "cookie", "connection", "google", "end", "cm", "plugin", "command", "connect", "port", "api", "ssl", "cp", "child", "product", "container", "null", "self", "server", "open", "custom", "socket", "lib", "node", "resource", "cell", "remote"]}}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,\n\n                             bool *again, ram_addr_t *ram_addr_abs)\n\n{\n\n    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,\n\n                                              ram_addr_abs);\n\n    if (pss->complete_round && pss->block == rs->last_seen_block &&\n\n        pss->offset >= rs->last_offset) {\n\n        /*\n\n         * We've been once around the RAM and haven't found anything.\n\n         * Give up.\n\n         */\n\n        *again = false;\n\n        return false;\n\n    }\n\n    if (pss->offset >= pss->block->used_length) {\n\n        /* Didn't find anything in this RAM Block */\n\n        pss->offset = 0;\n\n        pss->block = QLIST_NEXT_RCU(pss->block, next);\n\n        if (!pss->block) {\n\n            /* Hit the end of the list */\n\n            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n            /* Flag that we've looped */\n\n            pss->complete_round = true;\n\n            rs->ram_bulk_stage = false;\n\n            if (migrate_use_xbzrle()) {\n\n                /* If xbzrle is on, stop using the data compression at this\n\n                 * point. In theory, xbzrle can do better than compression.\n\n                 */\n\n                flush_compressed_data(rs);\n\n            }\n\n        }\n\n        /* Didn't find anything this time, but try again on the new block */\n\n        *again = true;\n\n        return false;\n\n    } else {\n\n        /* Can go around again, but... */\n\n        *again = true;\n\n        /* We've found something so probably don't need to */\n\n        return true;\n\n    }\n\n}\n", "idx": 21567, "substitutes": {"rs": ["rates", "ins", "params", "ks", "mr", "res", "rics", "src", "ims", "vers", "arch", "rss", "rt", "ras", "ds", "s", "ris", "xs", "sr", "ack", "rows", "stats", "ss", "ros", "ts", "ges", "ares", "ys", "ps", "nas", "cs", "r", "args", "hr", "ars", "qs", "rd", "rc", "rys", "RS", "gs", "dr", "sys", "acks", "Rs", "vs", "sl", "ls", "spec", "ns", "rb", "pres", "rg"], "pss": ["pess", "psl", "fss", "pose", "jpcss", "wpcss", "dss", "Piss", "jpss", "wpSS", " pds", "jsc", "Pess", "opess", "pts", "opws", "foss", "jds", " pws", "opds", "psose", "dds", "copcss", "dSS", "Pcss", "cpass", "wpiss", " psc", "mts", "joss", "wpss", "apds", "mrs", "apss", "fess", "fcss", " pose", "psc", "Poss", "opcss", "cpcss", "pcss", "cpds", "pssl", " psl", " pass", "prs", "piss", "rss", "jpess", "Pds", "copss", " pcss", "copds", "pass", " poss", "ress", "psss", "opiss", "pws", " pts", "jss", "dws", "dcss", "pds", "jcss", "pSS", "wpds", " pess", "poss", "Pts", "fiss", "Prs", "apcss", "jiss", "apass", " piss", "copess", "mds", "wpess", "jposs", "cpess", "Psc", "Pss", "jpds", "frs", " prs", "cpss", "Pose", "opss", "rass", "Psl", "rds", "psiss", " pSS", "mss", "psoss"], "again": ["Again", "confirmed", "always", "into", "ain", "each", "outside", "every", "standard", "option", "only", "account", "extra", "an", "second", "blank", "asm", "average", "except", "great", "addon", "stay", "since", "stall", "nin", "later", "ains", "advert", "out", "inas", "size", "external", "outs", "unc", "login", "say", "member", "after", "away", "ahead", "destroy", "another", "though", "also", "abc", "success", "this", "asc", "inc", "anon", "even", "new", "until", "illegal"], "ram_addr_abs": ["ram_addr_rel", "ram_address_tab", "ram_address_ab", "ram_address_ref", "ram_address_abs", "ram_addr_tab", "ram_addr_ab", "ram_address_rel", "ram_address_int", "ram_addr_ref", "ram_addr_int"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n", "idx": 21569, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)\n\n{\n\n    Wmv2Context *const w = (Wmv2Context *) s;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (w->j_type_bit)\n\n            w->j_type = get_bits1(&s->gb);\n\n        else\n\n            w->j_type = 0; // FIXME check\n\n\n\n        if (!w->j_type) {\n\n            if (w->per_mb_rl_bit)\n\n                s->per_mb_rl_table = get_bits1(&s->gb);\n\n            else\n\n                s->per_mb_rl_table = 0;\n\n\n\n            if (!s->per_mb_rl_table) {\n\n                s->rl_chroma_table_index = decode012(&s->gb);\n\n                s->rl_table_index        = decode012(&s->gb);\n\n            }\n\n\n\n            s->dc_table_index = get_bits1(&s->gb);\n\n        }\n\n        s->inter_intra_pred = 0;\n\n        s->no_rounding      = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \\n\",\n\n                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,\n\n                   s->dc_table_index, s->per_mb_rl_table, w->j_type);\n\n        }\n\n    } else {\n\n        int cbp_index;\n\n        w->j_type = 0;\n\n\n\n        parse_mb_skip(w);\n\n        cbp_index = decode012(&s->gb);\n\n        if (s->qscale <= 10) {\n\n            int map[3]         = { 0, 2, 1 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else if (s->qscale <= 20) {\n\n            int map[3]         = { 1, 0, 2 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else {\n\n            int map[3]         = {2,1,0};\n\n            w->cbp_table_index = map[cbp_index];\n\n        }\n\n\n\n        if (w->mspel_bit)\n\n            s->mspel = get_bits1(&s->gb);\n\n        else\n\n            s->mspel = 0; // FIXME check\n\n\n\n        if (w->abt_flag) {\n\n            w->per_mb_abt = get_bits1(&s->gb) ^ 1;\n\n            if (!w->per_mb_abt)\n\n                w->abt_type = decode012(&s->gb);\n\n        }\n\n\n\n        if (w->per_mb_rl_bit)\n\n            s->per_mb_rl_table = get_bits1(&s->gb);\n\n        else\n\n            s->per_mb_rl_table = 0;\n\n\n\n        if (!s->per_mb_rl_table) {\n\n            s->rl_table_index        = decode012(&s->gb);\n\n            s->rl_chroma_table_index = s->rl_table_index;\n\n        }\n\n\n\n        s->dc_table_index   = get_bits1(&s->gb);\n\n        s->mv_table_index   = get_bits1(&s->gb);\n\n\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n\n        s->no_rounding     ^= 1;\n\n\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n\n                   s->rl_table_index, s->rl_chroma_table_index,\n\n                   s->dc_table_index, s->mv_table_index,\n\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n\n                   s->inter_intra_pred);\n\n        }\n\n    }\n\n    s->esc3_level_length = 0;\n\n    s->esc3_run_length   = 0;\n\n    s->picture_number++; // FIXME ?\n\n\n\n    if (w->j_type) {\n\n        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);\n\n\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21576, "substitutes": {"s": ["ins", "south", "p", "ls", "us", "se", "f", "words", "si", "sb", "storage", "cs", "u", "ops", "gs", "i", "k", "conf", "spec", "aws", "ims", "ses", "ds", "xs", "is", "b", "ts", "sc", "n", "ps", "e", "y", "args", "services", "parts", "comments", "os", "params", "S", "ks", "h", "sym", "site", "stats", "its", "v", "c", "r", "l", "service", "qs", "es", "m", "sys", "t", "sl", "g", "new", "settings", "sets", "sq", "rs", "sync", "http", "as", "request", "fs", "ss", "native", "sw", "o", "session", "d", "features", "ssl", "self", "sf", "ns", "this", "sg", "ms", "js"], "w": ["war", "p", "WS", "tw", "wl", "f", "words", "q", "wan", "wr", "kw", "a", "wh", "window", "u", "data", "gs", "k", "conf", "wp", "writer", "cl", "aws", "wave", "wal", "b", "n", "fw", "we", " W", "e", "y", "ess", "web", "rw", "os", "work", "wo", "ww", "wb", "h", "way", "aw", "word", "wa", "win", "v", "wx", "c", "l", "hw", "nw", "sh", "es", "iw", "m", "ow", "t", "g", "z", "new", "x", "as", "fs", "sw", "o", "wcs", "d", "wt", "self", "ns", "W", "ms"], "cbp_index": ["cbp_input", "cbp_type", "cbn_id", "cbpdbweight", "cbp_id", "cbpdbindex", "cbp67weight", "cbc_address", "cbpdbaddress", "cbp_weight", "cbP_ind", "cbc_weight", "cbp67input", "cbp67Index", "cbp_Index", "cbc_Index", "cbP_id", "cbp64length", "cbc_index", "cbp64slice", "cbpdbid", "cbp_slice", "cbc_id", "cbp_address", "cbp_length", "cbc_input", "cbp_key", "cbn_index", "cbp64point", "cbp64index", "cbp67index", "cbp_ind", "cbP_index", "cbn_key", "cbn_type", "cbp_point", "cbP_Index"], "map": ["cap", "shape", "cover", "image", "match", "cache", "mem", "block", "use", "pair", "complete", "pack", "address", "wave", "dict", "config", "app", "msg", "lock", "mask", "view", "stream", "wise", "table", "store", "module", "batch", "pre", "copy", "size", "Map", "gen", "grid", "model", "share", "comb", "scope", "arr", "hash", "one", "shared", "m", "pad", "maps", "array", "list", "open", "group", "file", "ap", "master", "set", "MAP"]}}
{"project": "FFmpeg", "commit_id": "a494792961a08f9f0e47e7eeed65e609178ff436", "target": 1, "func": "static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n", "idx": 21583, "substitutes": {"table": ["element", "image", "TABLE", "interface", "tree", "cache", "test", "round", "section", "tab", "block", "code", "buffer", "address", "object", "body", "view", "index", "Table", "page", "query", "col", "result", "window", "module", "pre", "out", "source", "rule", "stable", "model", "input", "count", "column", "array", "bar", "file", "binary", "comment"], "elemsize": ["eleapsized", "Elemmizes", "elemmized", "Elemmize", "elemesize", "Elemsizing", "elemerssize", "elemssize", "elemesizes", "elekesize", "elemersizes", "elemmize", "elemersize", "eleapsizing", "elmsIZE", "elemsiz", "elmesIZE", "elemmiz", "eleapsize", "elkssize", "elmsizes", "elemessize", "Elemsize", "elmsize", "eleksizes", "elksiz", "elemersiz", "elekssize", "elemesIZE", "elksizes", "elmssize", "elekesizes", "elemsIZE", "elemsizes", "elemmIZE", "Elemsizes", "Elemmizing", "elemsized", "Elemmized", "eleksiz", "elemmsize", "elemmizes", "elemmizing", "elksize", "elmessize", "eleksIZE", "elmsiz", "elmesiz", "Elemsized", "elmesize", "eleapsizes", "elekesizing", "elekesized", "elemesiz", "elemsizing", "eleksize"], "inc": ["dc", "mc", "ins", "ii", "shape", "iter", "inf", "enc", "pin", "cc", "ac", "margin", "length", "extra", "config", "ini", "amin", "fr", "INC", "pc", "up", "fc", "seq", "index", "c", "incre", "ind", "alpha", "acc", "page", "frac", "in", "bc", "pull", "Inc", "rc", "imp", "input", "inn", "abc", "include", "level", "nc", "rec", "ec"], "y_tab": ["y_bag", "y__table", "y__struct", "my_struct", "my_table", "y__tab", "my_bag", "y__bag", "y_lab", "my_lab", "my_tab", "y_struct"], "i": ["ti", "ii", "ui", "ji", "abi", "qi", "x", "I", "ix", "jp", "p", "h", "phi", "di", "ri", "j", "f", "ai", "s", "ini", "oi", "ni", "start", "b", "si", "io", "v", "a", "pi", "n", "index", "uri", "c", "o", "e", "l", "xi", "u", "key", "li", "mini", "iu", "in", "k", "id", "m", "ci", "zi", "mi", "t", "multi", "gi", "z", "mu", "bi", "it", "ip"], "y_table": ["yacfile", "y___table", " y_session", "my_count", "my_table", "y6table", "y___db", "y6tab", "y_db", "my_file", "y___tab", "y6session", "my_tab", "yactab", "yacdb", "my_db", "y_file", "y_session", "y6db", " y_db", "y___session", "y_TABLE", "my_TABLE", "yactable", "y_count"]}}
{"project": "FFmpeg", "commit_id": "f3e5a7844bbf13620ca4b6a5e19aa087c9141b15", "target": 0, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 21584, "substitutes": {"alac": ["alacl", "alsacc", "alic", "elacc", "aliacc", " alAC", " alacc", "plAC", " alacs", "ALacs", "calacc", "alsc", "elec", "malc", "pluc", "elmac", " alax", "altac", "alacs", "ilanc", "palmac", "elunc", "almac", "belac", "alacc", "malunc", "elacl", "belmac", " alacl", "calanc", "palAC", "aluc", "allc", " alanc", "elAC", "elax", " alec", "calacs", "eloc", "alsac", "aliac", "alsacs", "alunc", "plac", "belax", "malac", "maloc", "altacc", "alanc", "aliec", " alunc", "elacs", "calac", "ALoc", "altc", "alc", "altacl", "paliac", "ploc", "elc", "aloc", "allacs", " alc", "elac", "alax", "ilac", "alloc", "placs", "ilacs", "ilacc", "allac", "maluc", "pliac", "alec", " almac", "alAC", "plmac", " aliac", "palac", "ALac", "allAC", " aloc", "beloc", "ALAC", "allacc", "eluc", "malacs"], "ch": ["channel", "chip", "cy", "gr", "x", "ech", "cl", "Ch", "jp", "h", "p", "enc", "gh", "code", "arch", "el", "oy", "j", "length", "f", "zh", "q", "CH", "cher", "cur", "comp", "che", "chrom", "b", "ct", "change", "bh", "hop", "c", "pol", "chn", "err", "och", "ver", "y", "l", "conn", "chan", "col", "batch", "sk", "chi", "ach", "ich", "anch", "cm", "sch", "cp", "child", "cho", "count", "cham", "k", "i", "ctx", "conf", "work", "client", "cha", "mot", "cht", "cry", "cor"]}}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static int put_cod(Jpeg2000EncoderContext *s)\n\n{\n\n    Jpeg2000CodingStyle *codsty = &s->codsty;\n\n\n\n    if (s->buf_end - s->buf < 14)\n\n        return -1;\n\n\n\n    bytestream_put_be16(&s->buf, JPEG2000_COD);\n\n    bytestream_put_be16(&s->buf, 12); // Lcod\n\n    bytestream_put_byte(&s->buf, 0);  // Scod\n\n    // SGcod\n\n    bytestream_put_byte(&s->buf, 0); // progression level\n\n    bytestream_put_be16(&s->buf, 1); // num of layers\n\n    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){\n\n        bytestream_put_byte(&s->buf, 2); // ICT\n\n    }else{\n\n        bytestream_put_byte(&s->buf, 0); // unspecified\n\n    }\n\n    // SPcod\n\n    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height\n\n    bytestream_put_byte(&s->buf, 0); // cblk style\n\n    bytestream_put_byte(&s->buf, codsty->transform); // transformation\n\n    return 0;\n\n}\n", "idx": 21585, "substitutes": {"s": ["settings", "sets", "S", "sq", "ks", "rs", "x", "p", "sym", "aws", "sync", "als", "site", "us", "ses", "ds", "f", "xs", "as", "is", "fs", "si", "ss", "ts", "b", "its", "v", "a", "c", "spec", "ps", "new", "sb", "o", "e", "cs", "ads", "l", "args", "service", "session", "u", "qs", "services", "sup", "es", "d", "in", "side", "ssl", "gs", "i", "su", "os", "sys", "conf", "t", "m", "sf", "self", "vs", "has", "this", "ns", "ls", "sg", "g", "sv", "ms", "js"], "codsty": ["ancst", "codstyle", "codrt", "cmdrt", "codestyle", "ldstyle", "codesty", "cdsty", "camsty", "codty", "codest", "czty", "typsta", "czety", "codsta", "codost", " codgly", "cdgy", "ancsty", " codsta", "cdsy", " codsy", "cmdost", "cdpty", "codpty", "czsty", "odsty", "camost", "czst", " codty", " codstyle", "codsy", "odty", "Codost", " codst", "typsty", "odstyle", "odgly", "typstyle", "typgly", "odsy", "pedsty", "codgy", "Codrt", "codst", "pedty", "Codty", "odgy", "camrt", "Codsty", "ldty", "codegy", "ancty", " codgy", "pedety", "camty", " codpty", "odpty", "codgly", "ldsty", "Codety", "odsta", "codety", "cmdsty", "codesy", "ancsy", "cmdty", "Codst", "pedst", "ldgy"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "substitutes": {"mr": ["adr", "mc", "bm", "MR", "req", "br", "rs", "tm", "rar", "rt", "rm", "fr", "Mr", "sr", "mn", "rh", "ir", "cr", "vm", "pc", "ru", "yr", "vr", "err", "rpm", "rr", "nr", "r", "kr", "hr", "manager", "usr", "tr", "rc", "rf", "dr", "reader", "m", "er", "lr", "rl", "rb", "rg", "fm"], "addr": ["adr", "part", "ace", "kt", "x", "src", "enc", "host", "offset", "ord", "rt", "val", "address", "mode", "mac", "hop", "align", "index", "amp", "base", "nr", "conn", "ref", "inter", "layer", "url", "attr", "ptr", "id", "oa", "dr", "slice", "wd", "edge", "node", "prefix", "ext", "ip"], "size": ["shape", "ish", "empty", "eni", "en", "use", "offset", "name", "address", "max", "sec", "security", "si", "Size", "len", "scale", "SIZE", "storage", "from", "iz", "style", "ize", "grow", "six", "esc", "small", "count", "sized", "gz", "z"], "client": ["global", "close", "box", "cache", "local", "ian", "buffer", "ce", "cli", "public", "standard", "sim", "config", "pc", "Client", "mac", "parent", "conn", "window", "clean", "connection", "cm", "external", "progress", "worker", "wrapper", "child", "ctx", "self", "null", "server", "ients", "util", "lib", "this", "resource", "cell", "remote", "gray"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n    int ret;\n\n\n\n    ret = bdrv_get_info(bs, &bdi);\n\n    if (ret < 0 || bdi.cluster_size == 0) {\n\n        return bs->request_alignment;\n\n    } else {\n\n        return bdi.cluster_size;\n\n    }\n\n}\n", "idx": 21622, "substitutes": {"bs": ["lb", "ins", "ks", "iss", "rs", "bb", "als", "css", "bid", "db", "bis", "ses", "ds", "banks", "s", "bas", "xs", "fs", "b", "ss", "ts", "its", "state", "BS", "Bs", "ps", "base", "sb", "bps", "bos", "cs", "blocks", "bes", "pb", "bc", "gs", "os", "fb", "vs", "las", "ubs", "ns", "ls", "rb", "js"], "bdi": ["obdi", "bbdi", " bni", "abti", " bda", "pdc", " bDI", "bbDI", "brda", "brsi", "bbda", "bti", "bbci", "bda", "bbni", "bdc", "pni", "bsi", "abdc", "brci", " bdc", "obci", "pci", " badi", "abdi", "badi", "abci", "bDI", "brdi", " bci", "obadi", " bti", "pdi", "obti", "bci", "bni", "abni", " bsi", "bbti", "abDI", "bbsi", "abadi"], "ret": ["desc", "att", "match", "iter", "af", "res", "rets", "code", "num", "cat", "bit", "val", "rt", " Ret", "det", "ft", "j", "ben", "sr", "pat", "mt", "pass", "RET", "ct", "len", "gt", "back", "fun", "pt", "nat", "nt", "result", "ref", "std", "out", "ber", "opt", "end", "et", "flag", "obj", "re", "xt", "alt", "success", "Ret", "rl", "no", "ext"]}}
{"project": "FFmpeg", "commit_id": "40cf1bbacc6220a0aa6bed5c331871d43f9ce370", "target": 0, "func": "static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                        const AVFrame *frame, int *got_packet)\n\n{\n\n    int enc_size = 0;\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroEncoder *encoder = p_schro_params->encoder;\n\n    struct FFSchroEncodedFrame *p_frame_output = NULL;\n\n    int go = 1;\n\n    SchroBuffer *enc_buf;\n\n    int presentation_frame;\n\n    int parse_code;\n\n    int last_frame_in_sequence = 0;\n\n    int pkt_size, ret;\n\n\n\n    if (!frame) {\n\n        /* Push end of sequence if not already signalled. */\n\n        if (!p_schro_params->eos_signalled) {\n\n            schro_encoder_end_of_stream(encoder);\n\n            p_schro_params->eos_signalled = 1;\n\n        }\n\n    } else {\n\n        /* Allocate frame data to schro input buffer. */\n\n        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);\n\n        if (!in_frame)\n\n            return AVERROR(ENOMEM);\n\n        /* Load next frame. */\n\n        schro_encoder_push_frame(encoder, in_frame);\n\n    }\n\n\n\n    if (p_schro_params->eos_pulled)\n\n        go = 0;\n\n\n\n    /* Now check to see if we have any output from the encoder. */\n\n    while (go) {\n\n        int err;\n\n        SchroStateEnum state;\n\n        state = schro_encoder_wait(encoder);\n\n        switch (state) {\n\n        case SCHRO_STATE_HAVE_BUFFER:\n\n        case SCHRO_STATE_END_OF_STREAM:\n\n            enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n\n            if (enc_buf->length <= 0)\n\n                return AVERROR_BUG;\n\n            parse_code = enc_buf->data[4];\n\n\n\n            /* All non-frame data is prepended to actual frame data to\n\n             * be able to set the pts correctly. So we don't write data\n\n             * to the frame output queue until we actually have a frame\n\n             */\n\n            if ((err = av_reallocp(&p_schro_params->enc_buf,\n\n                                   p_schro_params->enc_buf_size +\n\n                                   enc_buf->length)) < 0) {\n\n                p_schro_params->enc_buf_size = 0;\n\n                return err;\n\n            }\n\n\n\n            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n\n                   enc_buf->data, enc_buf->length);\n\n            p_schro_params->enc_buf_size += enc_buf->length;\n\n\n\n\n\n            if (state == SCHRO_STATE_END_OF_STREAM) {\n\n                p_schro_params->eos_pulled = 1;\n\n                go = 0;\n\n            }\n\n\n\n            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {\n\n                schro_buffer_unref(enc_buf);\n\n                break;\n\n            }\n\n\n\n            /* Create output frame. */\n\n            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));\n\n            if (!p_frame_output)\n\n                return AVERROR(ENOMEM);\n\n            /* Set output data. */\n\n            p_frame_output->size     = p_schro_params->enc_buf_size;\n\n            p_frame_output->p_encbuf = p_schro_params->enc_buf;\n\n            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&\n\n                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))\n\n                p_frame_output->key_frame = 1;\n\n\n\n            /* Parse the coded frame number from the bitstream. Bytes 14\n\n             * through 17 represesent the frame number. */\n\n            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n\n\n\n            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,\n\n                                     p_frame_output);\n\n            p_schro_params->enc_buf_size = 0;\n\n            p_schro_params->enc_buf      = NULL;\n\n\n\n            schro_buffer_unref(enc_buf);\n\n\n\n            break;\n\n\n\n        case SCHRO_STATE_NEED_FRAME:\n\n            go = 0;\n\n            break;\n\n\n\n        case SCHRO_STATE_AGAIN:\n\n            break;\n\n\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown Schro Encoder state\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* Copy 'next' frame in queue. */\n\n\n\n    if (p_schro_params->enc_frame_queue.size == 1 &&\n\n        p_schro_params->eos_pulled)\n\n        last_frame_in_sequence = 1;\n\n\n\n    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);\n\n\n\n    if (!p_frame_output)\n\n        return 0;\n\n\n\n    pkt_size = p_frame_output->size;\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n\n        pkt_size += p_schro_params->enc_buf_size;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", pkt_size);\n\n        goto error;\n\n    }\n\n\n\n    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n\n    avctx->coded_frame->key_frame = p_frame_output->key_frame;\n\n    /* Use the frame number of the encoded frame as the pts. It is OK to\n\n     * do so since Dirac is a constant frame rate codec. It expects input\n\n     * to be of constant frame rate. */\n\n    pkt->pts =\n\n    avctx->coded_frame->pts = p_frame_output->frame_num;\n\n    pkt->dts = p_schro_params->dts++;\n\n    enc_size = p_frame_output->size;\n\n\n\n    /* Append the end of sequence information to the last frame in the\n\n     * sequence. */\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n\n        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n\n               p_schro_params->enc_buf_size);\n\n        enc_size += p_schro_params->enc_buf_size;\n\n        av_freep(&p_schro_params->enc_buf);\n\n        p_schro_params->enc_buf_size = 0;\n\n    }\n\n\n\n    if (p_frame_output->key_frame)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nerror:\n\n    /* free frame */\n\n    libschroedinger_free_frame(p_frame_output);\n\n    return ret;\n\n}\n", "idx": 21641, "substitutes": {"avctx": ["avecoll", "avecam", "afcfg", "avcfg", "awcontext", "afcoll", "avcontext", "afcca", "avecontext", "afcmd", "avconn", "avectx", "awcmd", " avcoll", "AVctx", " avcam", "AVcmd", "avcoll", "afconn", "AVcontext", "avcam", "AVconn", " avcontext", "avecca", "afcam", "avcmd", "awcca", "afctx", "awcfg", "avcca", "awconn", "avecfg", "awctx", "afcontext"], "pkt": ["cpkt", "cpct", " packet", "Pet", " pet", "cpacket", "cpet", "packet", "Pct", "pct", "Packet", "pet", "Pkt", " pct"], "frame": ["channel", "zip", "element", "kt", "part", "cfg", "image", "iframe", "setup", "event", "row", "fe", "call", "rame", "block", "code", "buffer", "process", " Frame", "f", "config", "object", "fr", "none", "document", "motion", "game", "seq", "position", "base", "range", "framework", "e", "Frame", "flow", "module", "window", "function", "fi", "data", "frames", "fake", "fb", "component", "slice", "feature", "file", "fram", "node", "dom"], "got_packet": ["got_packET", "got_compET", "got_octeter", "got2packET", "got2compacket", "got_compacket", "got_compet", "got_octacket", "got2packacket", "got_packseter", "got_packsET", "got2competer", "got_octet", "got_octET", "got2compET", "got2packet", "got_packsacket", "got_packacket", "got2compet", "got_competer", "got2packeter", "got_packeter", "got_packset"], "p_schro_params": ["p_schro2manager", "p_schros_args", "p_schrosresources", "p_schroappparams", "p_schroappmanager", "p_sche\n", "p_schrob_manager", "p_schro_data", "p_schrotmanager", "p_schroPDrequest", "p_schro__params", "p_schroappphys", "p_schrob_data", "p_schro_phys", "p_schro__param", "p_ch\n", "p_schrotparam", "p_schroPDmanager", "p_schro_remote", "p_schrossettings", "p_sch\n", "p_schros_changes", "p_schros_params", "p_schrosparam", "p_schroappremote", "p_schroappchanges", "p_schoreappphys", "p_schro_args", "p_schro5args", "p_schros_param", "p_schroappsource", "p_schro2ams", "p_schroapprequest", "p_schore_source", "p_schroPDparams", "p_schore_params", "p_schro_param", "p_schro5resources", "p_schrosparams", "p_schro2params", "p_schro_settings", "p_schroPDchanges", "p_Sch\n", "p_schro_resources", "p_schros_manager", "p_schro_manager", "p_schro2param", "p_schros_connection", "p_schro_changes", "p_schoreappparam", "p_schroappparam", "p_schro_source", "p_schro_connection", "p_schore_param", "p_schros_settings", "p_schrotparams", "p_schrob_remote", "p_schro_request", "p_schro__settings", "p_schrob_param", "p_schrob_resources", "p_schoreappparams", "p_schros_request", "p_schore_phys", "p_schrotconnection", "p_schrob_ams", "p_schro5manager", "p_schrob_params", "p_schoreappsource", "p_schro_ams", "p_schro5params", "p_schro__manager", "p_schros_resources"], "encoder": ["decoding", "engater", "encryption", "enater", "engoded", "engode", "engryption", "engader", " encator", "ecler", " encode", "encator", "decode", "enoser", "engoder", "enode", "ecoder", " encoded", " encoding", " encryption", "decoder", "enoding", "incoser", "decader", "engoster", "decator", "encoding", "incoder", "decoster", "ecoded", "encater", "engoding", "enoder", "enator", "decoded", "encoded", "encader", "enader", "ecator", "decler", "enryption", "encode", "ecoser", "encoster", " encater", "encoser", " encoster", "incoding", "enler", "enoded", "incator", "ecoding", "encler", "ecode"], "p_frame_output": ["p_frame_full", "p_fram_data", "p_frame_input", "p_frame_data", "p_fram_input", "p_fram_output", "p_fram_full"], "enc_buf": ["enc_db", "encsvec", "enc__bag", "enc__buf", "pc_window", "enc_data", "enc_cb", "enc__buff", "enc2cb", "ec_buffer", "enc2uf", "ec_bag", " enc_bag", "enc_bag", "en_cb", "enc2buf", "pc_vec", "enc2buff", " enc_uf", " enc_buff", "enc__uf", "enc_func", "enc_uf", " enc_data", "ec_buf", "en_buff", "encJbuf", " enc_config", "ec_queue", "enc_vec", " enc_buffer", "enc_buffer", "encJdata", "enc_window", "en_uf", " enc_box", "encJheader", "encxbuf", "encxdata", "enc_box", "ec_header", "encswindow", "pc_buf", "ec_data", "pc_cb", "enc__data", "encxconfig", "enc_buff", "en_buf", "enc_config", "enc__buffer", "enc_header", " enc_db", "encscb", " enc_func", "encxbuff", " enc_cb", "enc_queue", "encsbuf", "encJqueue"], "presentation_frame": ["presentational_sequence", "presentation_Frame", "presentational_Frame", "presentationamnode", "presentational_frame", "presentation_fram", "presentational_node", "presentational_fram", "presentationamframe", "presentational_frames", "presentationamFrame", "presentation_node", "presentation_sequence", "presentationamframes", "presentation_frames"], "parse_code": ["parse___code", "parseablequeue", "parseableinfo", " parse2data", "parse2data", "parse_info", " parse2tag", "parseablecode", " parse_tag", "parser_count", "parser_queue", " parse_data", " parse2code", " parse2codes", "parserablequeue", " parse_codes", "parse_data", "parse_count", "parser_code", "parser_info", "parse___queue", "parseablecount", "parse_tag", "parserableinfo", "parse2tag", "parse_codes", "parserablecode", "parse___count", "parse2codes", "parse_queue", "parse___info", "parse2code", "parserablecount"], "pkt_size": ["pkt_name", "pet_size", "pet_len", "pkt_len", "pet_name"], "ret": ["def", "res", "resp", "val", "proc", "status", "msg", "rx", "RET", "seq", "fun", "reg", "result", "run", "std", "fi", "progress", "reply", "rc", "arr", "lo", "fin", "orig", "success", "rec"], "in_frame": ["in_motion", "in_window", " in_motion", "in_fram", "inamframe", " in_story", " in_fram", " in_message", "in__fram", " in_sample", " in_window", "in_point", "inammessage", "in__story", "in_sample", "in_story", "in__window", "inammotion", "in_message", " in_point", "in__frame"], "err": ["req", "ner", "ise", "gr", "mr", "h", "fe", "arm", "code", "num", "val", "loc", "type", "status", "msg", "mode", "rage", "risk", "magic", "f", "order", "rh", "init", "bug", "der", "asm", "error", "rr", "Error", "ind", "e", "r", "result", "usr", "out", "opt", "str", "rule", "attr", "rc", "arr", "count", "Er", "id", "dr", "conf", "orig", "er", "act", "addr", "erg", " Err", "op", "var"], "state": ["part", "states", "stage", "class", "event", "step", "sync", "code", "STATE", " State", "use", "val", "go", "type", "status", "mode", "name", "config", "stat", " STATE", "next", "are", "reg", "action", "error", "e", "style", "session", "key", "run", "kind", "str", "rule", "instance", "scope", "State", "work", "open", "act", "this", "tag", "resource", "set", "comment", "new"]}}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int fill_default_ref_list(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n    int smallest_poc_greater_than_current = -1;\n\n    int structure_sel;\n\n    Picture sorted_short_ref[32];\n\n    Picture field_entry_list[2][32];\n\n    Picture *frame_list[2];\n\n\n\n    if (FIELD_PICTURE) {\n\n        structure_sel = PICT_FRAME;\n\n        frame_list[0] = field_entry_list[0];\n\n        frame_list[1] = field_entry_list[1];\n\n    } else {\n\n        structure_sel = 0;\n\n        frame_list[0] = h->default_ref_list[0];\n\n        frame_list[1] = h->default_ref_list[1];\n\n    }\n\n\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        int list;\n\n        int len[2];\n\n        int short_len[2];\n\n        int out_i;\n\n        int limit= INT_MIN;\n\n\n\n        /* sort frame according to POC in B slice */\n\n        for(out_i=0; out_i<h->short_ref_count; out_i++){\n\n            int best_i=INT_MIN;\n\n            int best_poc=INT_MAX;\n\n\n\n            for(i=0; i<h->short_ref_count; i++){\n\n                const int poc= h->short_ref[i]->poc;\n\n                if(poc > limit && poc < best_poc){\n\n                    best_poc= poc;\n\n                    best_i= i;\n\n                }\n\n            }\n\n\n\n            assert(best_i != INT_MIN);\n\n\n\n            limit= best_poc;\n\n            sorted_short_ref[out_i]= *h->short_ref[best_i];\n\n            tprintf(h->s.avctx, \"sorted poc: %d->%d poc:%d fn:%d\\n\", best_i, out_i, sorted_short_ref[out_i].poc, sorted_short_ref[out_i].frame_num);\n\n            if (-1 == smallest_poc_greater_than_current) {\n\n                if (h->short_ref[best_i]->poc >= s->current_picture_ptr->poc) {\n\n                    smallest_poc_greater_than_current = out_i;\n\n                }\n\n            }\n\n        }\n\n\n\n        tprintf(h->s.avctx, \"current poc: %d, smallest_poc_greater_than_current: %d\\n\", s->current_picture_ptr->poc, smallest_poc_greater_than_current);\n\n\n\n        // find the largest POC\n\n        for(list=0; list<2; list++){\n\n            int index = 0;\n\n            int j= -99;\n\n            int step= list ? -1 : 1;\n\n\n\n            for(i=0; i<h->short_ref_count && index < h->ref_count[list]; i++, j+=step) {\n\n                int sel;\n\n                while(j<0 || j>= h->short_ref_count){\n\n                    if(j != -99 && step == (list ? -1 : 1))\n\n                        return -1;\n\n                    step = -step;\n\n                    j= smallest_poc_greater_than_current + (step>>1);\n\n                }\n\n                sel = sorted_short_ref[j].reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n                frame_list[list][index  ]= sorted_short_ref[j];\n\n                frame_list[list][index++].pic_id= sorted_short_ref[j].frame_num;\n\n            }\n\n            short_len[list] = index;\n\n\n\n            for(i = 0; i < 16 && index < h->ref_count[ list ]; i++){\n\n                int sel;\n\n                if(h->long_ref[i] == NULL) continue;\n\n                sel = h->long_ref[i]->reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n\n\n                frame_list[ list ][index  ]= *h->long_ref[i];\n\n                frame_list[ list ][index++].pic_id= i;\n\n            }\n\n            len[list] = index;\n\n        }\n\n\n\n        for(list=0; list<2; list++){\n\n            if (FIELD_PICTURE)\n\n                len[list] = split_field_ref_list(h->default_ref_list[list],\n\n                                                 h->ref_count[list],\n\n                                                 frame_list[list],\n\n                                                 len[list],\n\n                                                 s->picture_structure,\n\n                                                 short_len[list]);\n\n\n\n            // swap the two first elements of L1 when L0 and L1 are identical\n\n            if(list && len[0] > 1 && len[0] == len[1])\n\n                for(i=0; h->default_ref_list[0][i].data[0] == h->default_ref_list[1][i].data[0]; i++)\n\n                    if(i == len[0]){\n\n                        FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n                        break;\n\n                    }\n\n\n\n            if(len[list] < h->ref_count[ list ])\n\n                memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));\n\n        }\n\n\n\n\n\n    }else{\n\n        int index=0;\n\n        int short_len;\n\n        for(i=0; i<h->short_ref_count; i++){\n\n            int sel;\n\n            sel = h->short_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->short_ref[i];\n\n            frame_list[0][index++].pic_id= h->short_ref[i]->frame_num;\n\n        }\n\n        short_len = index;\n\n        for(i = 0; i < 16; i++){\n\n            int sel;\n\n            if(h->long_ref[i] == NULL) continue;\n\n            sel = h->long_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->long_ref[i];\n\n            frame_list[0][index++].pic_id= i;\n\n        }\n\n\n\n        if (FIELD_PICTURE)\n\n            index = split_field_ref_list(h->default_ref_list[0],\n\n                                         h->ref_count[0], frame_list[0],\n\n                                         index, s->picture_structure,\n\n                                         short_len);\n\n\n\n        if(index < h->ref_count[0])\n\n            memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));\n\n    }\n\n#ifdef TRACE\n\n    for (i=0; i<h->ref_count[0]; i++) {\n\n        tprintf(h->s.avctx, \"List0: %s fn:%d 0x%p\\n\", (h->default_ref_list[0][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[0][i].pic_id, h->default_ref_list[0][i].data[0]);\n\n    }\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        for (i=0; i<h->ref_count[1]; i++) {\n\n            tprintf(h->s.avctx, \"List1: %s fn:%d 0x%p\\n\", (h->default_ref_list[1][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 21665, "substitutes": {"h": ["ha", "home", "image", "hd", "w", "p", "ht", "hl", "host", "gh", "img", "http", "ih", "j", "f", "q", "enh", "hist", "rh", "he", "b", "ah", "v", "hh", "bh", "oh", "n", "html", "header", "c", "hs", "o", "H", "e", "r", "l", "hr", "hw", "him", "ph", "ch", "ref", "u", "adh", "sh", "end", "d", "uh", "hash", "hm", "hi", "self", "m", "t", "g", "eh", "hp"], "s": ["p", "f", "si", "a", "sb", "storage", "erences", "u", "opt", "ops", "share", "gs", "ubs", "spec", "support", "setup", "sa", "ds", "is", "b", "n", "hs", "ps", "e", "ils", "y", "screen", "services", "sup", "ides", "serv", "S", "w", "ats", "site", "ions", "stats", "v", "c", "r", "l", "service", "qs", "sh", "es", "m", "sys", "t", "client", "server", "ages", "g", "sl", "ains", "settings", "sq", "sync", "http", "as", "fs", "ss", "ances", "o", "session", "d", "in", "port", "ssl", "self", "sf", "network", "ns", "ls", "ures", "js"], "i": ["ti", "ii", "ui", "abi", "my", "qi", "image", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "cli", "f", "ai", "info", "ini", "ni", "start", "si", "io", "pi", "n", "index", "ami", "c", "uri", "o", "e", "y", "l", "adi", "xi", "limit", "u", "chi", "yi", "fi", "li", "mini", "iu", "api", "count", "id", "mi", "ci", "multi", "ori", "gi", "z", "mu", "bi", "it", "ip"], "structure_sel": ["structuressell", "sture_sl", "structure_isl", "sture_Sel", "struction_cel", "structure_fail", "structure_sl", "struction_sell", "structuressels", "structure_sell", "struction_isl", "structuressol", "struction_sol", "sture_fail", "structure_Sel", "sture_sel", "struction_sels", "structure_sels", "structure_cel", "struction_sel", "structuressel", "structure_sol"], "sorted_short_ref": ["sorted_short64ref", "sorted_long_reference", "sorted_short64diff", "sorted_short64list", "sorted_long_ref", "sorted_small_diff", "sorted_long_def", "sorted_short2Ref", "sorted_small_info", "sorted_small_ref", "sorted_small_list", "sorted_small_reference", "sorted_short_def", "sorted_short_diff", "sorted_short2def", "sorted_long_rec", "sorted_short2ref", "sorted_small_Ref", "sorted_short_Ref", "sorted_short_info", "sorted_short64reference", "sorted_long_Ref", "sorted_short64def", "sorted_short64Ref", "sorted_short_reference", "sorted_short_rec", "sorted_short2reference", "sorted_short_list"], "field_entry_list": ["field_def_pair", "field_entrydlock", "field_filedlist", "field_filedlists", "field_filedset", "field_entrydset", "field_entryingset", "field_entry_all", "field_entryinglist", "field_image_set", "field_def_all", "field_image_record", "field_entry_part", "field_entry_lists", "field_entry0list", "field_image_part", "field_entryingpair", "field_image_list", "field_entry0set", "field_entry0lock", "field_entry_lock", "field_filedlock", "field_entry_pair", "field_def_list", "field_file_lock", "field_file_set", "field_def_set", "field_entryingall", "field_entry_set", "field_entry0lists", "field_entrydlist", "field_entrydlists", "field_entry_record", "field_file_lists", "field_file_list"], "frame_list": ["frame_array", " frame_type", "frame_lists", "frameacsystem", "frame2set", "theme_test", "frameallist", "frame_diff", "fram_detail", "frame_result", "feature_list", "framealtest", "fram_object", "frameacarray", "framegarray", "fram_list", "feature_lists", "frame_type", "frame_test", "frameglists", "frameaclists", "frameesdetail", "element_list", "frame2type", "themeallist", "frameacresult", "themealsize", " frame_set", "elementaclist", "theme_entry", "framegresult", "frame_set", "frameeslists", "frameaclist", "element_lists", " frame_diff", "elementaclists", "frameeslist", "themealentry", "feature_set", "theme_size", "framealsize", "frame2diff", "frame_system", "theme_list", "themealtest", "frameesobject", "elementacresult", "frame_object", "frame2list", "fram_lists", "frame_detail", "element_result", "element_array", "frame_size", "framealentry", "frameacset", "frameglist", "elementacarray", "feature_system", "frame_entry"], "list": ["loop", "cache", "List", "lists", "p", "block", "code", "all", "val", "seq", "l", "batch", "li", "data", "arr", "L", "null", "array", "file", "map", "set", "pool"], "len": ["part", "line", "lin", "en", "Len", "depth", "lim", "val", "ln", "length", "body", "lock", "seq", "n", "bin", "min", "fat", "limit", "ref", "lang", "split", "pos", "data", "count", "cmp"], "short_len": ["short_list", "short__ref", "short_ref", "short_sum", " short_ref", "short__len", "short__list", "short__sum", " short_list", " short_sum"], "out_i": ["outXit", "outXo", "out24i", "outCo", "outputLiu", "outOsite", "outLi", "outDi", "outPEyi", "outEndi", "in_li", "outxj", "outxli", "outPEsite", "outCsi", "out_iu", "out_ei", "out_yi", "out64i", "work_ei", "outXabi", "out_ie", "outClio", "outXsi", "work_ini", "outPEmulti", "outputLie", "outputLmulti", "out24abi", "outDie", "in_i", "work_di", "OUT_si", "OUTXo", "outXi", "work_abi", "outJdi", "outOyi", "remotePEi", "outlexio", "output_i", "OUTXsi", " out_I", "outLiu", "outxi", "out_abi", "outLie", "outClI", "out24it", "output_iu", "out_zi", "outLogzi", "outDiu", "outCti", " out_uri", "outJini", "out_j", "workJi", "outEndzi", "out_o", "outJei", "out_di", "remote_yi", "out_multi", "out_si", " out_zi", "out_uri", "workJini", "outlexit", "outXci", "out24ci", "output_ie", "outEndmulti", "out_u", "OUT_i", "outPdi", "in_j", "outOi", "out64di", "outxti", " out_io", "out_it", "out64ini", "OUTXi", "output_multi", "outLmulti", "out64ei", " out_li", " out_u", "outCli", "outlexI", "outCi", "outPi", "workJei", "outOmulti", "remote_site", "remotePEsite", "outJi", "out_ci", "OUT_o", "outPini", "outLogi", "outPEi", "outLogu", "outLoguri", "out_ti", "work_i", "out_ini", " out_si", "out_I", "remote_i", " out_it", "outXti", "remotePEyi", "outEndiu", "outDmulti", "out_li", "outEnduri", "out_io", "outEndie", "in_ti", "OUT_ti", "work_ci", "remote_multi", "outlexi", "outPei", "outputLi", "work_it", "OUTXti", "workJdi", "remotePEmulti", "outClit", "out_site", "outEndu"]}}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "substitutes": {"f": ["cf", "update", "write", "af", "x", "parse", "p", "h", "fe", "inf", "code", "lf", "_", "j", "config", "s", "q", "fr", "fs", "tf", "bf", "b", "feed", "v", "fc", "df", "F", "c", "fen", "e", "l", "fa", "fd", "fp", "u", "fo", "fi", "d", "ops", "rf", "k", "m", "fx", "form", "t", "fn", "sf", "fb", "file", "g", "this", "z", "new"], "vmdesc": ["mmandocument", "gmdesc", "vcmdsc", "vmandef", "vmddec", "vmddesc", " vcmdec", "vamddec", "mmddec", " vcmdsc", "vcmdisc", "vcmddesc", "vddasc", "vamdsc", " vmdrec", "vmaosc", "vmaser", "gmmasc", "vMDesc", "vamdasc", " vmdasc", "mmanderella", "vamdef", "mmddesc", " vmaesc", " vmdex", "vddisc", " vmdsc", "vmoddesc", "vmodosc", " vmdoc", "vmnesc", "vcmdest", "vcmdasc", "vmondsc", "vmtocument", "vmandoc", "vmadest", " vmddesc", " vmdest", " vcmdrec", "vcmdex", "vmondisc", " vmdosc", " vmaosc", " vcmdest", "vcmdoc", "vamdesc", "vmdec", "vcmdrec", "vndesc", "vmmasc", "vmasc", "vmnex", "mmandoc", "vmtesc", "vMDect", "vmdsc", "vnddesc", "vmsc", " vMDisc", " vmdec", "mmdoc", " vcmdesc", "mmanddesc", "mmderella", "vmmisc", "vmdser", "mmdocument", "gmmect", " vMDsc", "vmdoc", "vmadesc", " vMDdesc", "vcmdef", " vmdser", " vcmddesc", "vmandest", "vmondoc", "mmandesc", "vmandrec", " vmaser", " vmdef", "vMDec", "vddect", "vmandocument", "vamdocument", "mmdest", "vmec", " vcmdex", "vmaesc", "gmdasc", " vmdisc", " vcmdasc", "vmondest", "vmtest", "vmdrec", "gmdect", "vmanddesc", "vmmesc", " vcmdef", "vmef", "vmdex", "vmnrec", "vMDdesc", "vMDest", "vMDsc", "vamderella", "vmest", "vmmect", "mmanddec", "vmonddesc", "vmanderella", "vcmdesc", "vmdect", "vMDisc", "vmdef", "vMDasc", "vddesc", "vnddec", "vmondesc", "gmmesc", " vmadesc", "mmdesc", "vmanddec", "vamdosc", "vmandex", "gmdisc", "vmesc", "vmdasc", "vmadoc", "gmmisc", "vndoc", "mmandest", "vmodesc", "vmadasc", "vmdest", " vMDesc", " vcmdoc", "vamdser", "vamddesc", "vmderella", "vamdest", "vcmdec", "vmdocument", "vmdisc", "vmodser", "vmdosc", "vamdoc", "vmondasc", "vmandesc", "vmnef", "vmterella"], "vmdesc_len": ["vmdsc_len", "vmdesc_length", "vmdsc_length", "vmdsc_Len", "vmdesc_Len", "vmdsc_long", "vmdesc_long"], "se": ["de", "st", "ese", "SE", "ue", "pe", "ve", "parse", "site", "sea", "sa", "sync", "ge", "pse", "te", "ce", "ses", "le", "loc", "el", "s", "ie", "pack", "he", "si", "sc", "so", "see", "lex", "ae", "sle", "sche", "ade", "Se", "ke", "spec", "entry", "sed", "ine", "e", "ite", "service", "ch", "ze", "sk", "ase", "sel", "sh", "be", "del", "ee", "esse", "oss", "es", "ne", "sp", "sem", "su", "cle", "ser", "sing", "spe", "sl", "sec", "ste", "serv"], "ret": ["att", "match", "def", "res", "rets", "al", "en", "lit", "code", "num", "cat", "rt", "val", "bit", "rev", " Ret", "status", "ft", "det", "valid", "msg", "cur", "lt", "art", "sr", "mt", "repl", "bl", "RET", "len", "gt", "back", "fun", "reg", "err", "error", "pt", "r", "result", "nt", "ref", "sur", "bc", " RET", "reply", "rc", "re", "flag", "data", "xt", "rf", "alt", "arg", "ext", "success", "fin", "Ret", "last", "no", "let", "get"]}}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void mvp_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));\n\n\n\n    /* MVPConf1 implemented, TLB sharable, no gating storage support,\n\n       programmable cache partitioning implemented, number of allocatable\n\n       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs\n\n       implemented, 5 TCs implemented. */\n\n    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |\n\n                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |\n\n// TODO: actually do 2 VPEs.\n\n//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |\n\n//                             (0x04 << CP0MVPC0_PTC);\n\n                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |\n\n                             (0x00 << CP0MVPC0_PTC);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Usermode has no TLB support */\n\n    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);\n\n#endif\n\n\n\n    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,\n\n       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */\n\n    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |\n\n                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |\n\n                             (0x1 << CP0MVPC1_PCP1);\n\n}\n", "idx": 21694, "substitutes": {"env": ["cfg", "cf", "global", "ner", "console", "ev", "eval", "cv", "cache", "event", "gui", "eve", "en", "enc", "ea", "code", "core", "dt", "db", "el", "dict", "eng", "config", "net", "init", "v", "exc", "err", "dev", "entry", "e", "export", "enable", "engine", "conn", "vt", "window", "manager", "session", "end", "ass", "et", "external", "viron", "ne", "np", "Environment", "obj", "environment", "eu", "self", "conf", "fg", "txt", "server", "nc", "context", "exec", "loader", "ec", "ext"], "def": ["Def", "req", "eval", "test", "block", "local", "val", "proc", "ef", "config", "definition", "decl", "init", "DEF", "dev", "entry", "tx", "defined", "ref", "define", "obj", "conf", "push", "exec"]}}
{"project": "FFmpeg", "commit_id": "ae3da0ae5550053583a6f281ea7fd940497ea0d1", "target": 1, "func": "static int decode_band(IVI45DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2, pos;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    if (!band->buf) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return result;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i * 2];\n\n        idx2 = band->corr[i * 2 + 1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    pos = get_bits_count(&ctx->gb);\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        if (tile->mb_size != band->mb_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n\n                   band->mb_size, tile->mb_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n", "idx": 21708, "substitutes": {"ctx": ["support", "bm", "cf", "kt", "cms", "crit", "gc", "cv", "xc", "lc", "cu", "sync", "cc", "cci", "buff", "loc", "config", "gpu", "sci", "coll", "anc", "cmd", "sc", "media", "scl", "kw", "c", "utils", "fw", "ck", "cb", "cas", "ca", "buf", "tx", "conn", "kb", "hw", "cal", "ref", "connection", "cm", "conv", "bc", "qa", "cp", "np", "rc", "bank", "wcs", "cca", "vc", "concept", "cpp", "ci", "conf", "pkg", "la", "grad", "cmp", "ctrl", "client", "gb", "nc", "component", "context", "cam", "cn", "voc", "ann"], "plane_num": [" sheet_num", " frame_no", " frame_num", " frame_name", " sheet_name", " sheet_no", " sheet_sum", " frame_sum"], "band": ["line", "match", "brand", "lc", "co", "low", "app", "not", "device", "filter", "pp", "board", "Band", "range", "dB", "function", "gen", "leg", "data", "product", "gb", "fb", "bass", "component", "act", "phase", "ld", "nd", "support", "part", "kt", "stage", "event", "guide", "cat", "db", "broad", "bit", "config", "cmd", "b", "back", "amp", "library", "bus", "flow", "batch", "hub", "point", "cm", "rule", "model", "target", "bank", "plug", "work", "slice", "map", "group", "cell", "project", "channel", "bb", "bridge", "bo", "plane", "word", "ground", "tool", "feed", "style", "service", "output", "cast", "grid", "card", "front", "full", "player", "image", "station", "block", "link", "bd", "frame", "object", "grab", "unk", "day", "boot", "plugin", "layer", "d", "obj", "kk", "field", "list", "feature", "tag", "piece", "ann"], "avctx": ["ivctx", "svcmp", "aveca", "afcmp", "verkb", " avca", "AVctl", "averctl", "avkb", "airctx", "AVca", "AVcli", "avercli", "afctl", "airkb", "svconn", "avcontext", "verctx", "avecontext", " avctl", "svctl", "verconn", "avconn", "airconn", "avectx", "AVctx", "ivcontext", "svcb", "ivconn", "avcli", "avcci", "averctx", "avctl", "afconn", "AVcontext", "vercb", "vercontext", "avcmp", "afkb", "vercci", "svctx", "AVconn", " avcontext", "svcontext", "aircontext", " avcli", " avconn", "afcci", "afctx", "afcb", "avercontext", "AVcmp", "avca", "aveconn", "ivcci", "avcb", "afcontext"], "result": ["match", "compl", "catch", "res", "event", "test", "current", "answer", "ge", "date", "die", "val", "mer", "type", "ret", "results", "response", "length", "valid", "status", "info", "order", "effect", "pass", "other", "df", "Result", "future", "mate", "err", "entry", "error", "duration", "ver", "rate", "message", "root", "found", "acc", "page", "final", "dest", "value", "there", "diff", "rc", "data", "count", "product", "arr", "grade", "attr", "su", "work", "done", "score", "number", "total", "success", "record", "feature", "term", "card", "inc", "comment"], "i": ["ti", "ii", "ui", "part", "my", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "name", "j", "type", "f", "ai", "info", "ini", "ie", "ni", "start", "is", "si", "io", "b", "v", "ki", "pi", "n", "index", "uri", "c", "ind", "e", "y", "l", "xi", "u", "key", "yi", "size", "sup", "fi", "d", "in", "iu", "li", "hi", "k", "id", "m", "ci", "mi", "multi", "slice", "gi", "bi", "ip"], "t": ["T", "task", "ti", "time", "tt", "x", "w", "p", "test", "h", "num", "offset", "dt", "te", "type", "j", "f", "ta", "to", "s", "tf", "b", "ts", "v", "a", "n", "c", "o", "pt", "e", "the", "y", "l", "token", "u", "tz", "d", "at", "port", "target", "k", "m", "tim", "ot", "g", "z", "qt"], "idx1": ["iddx2", "idxc0", "idnt1", "idxc81", "idxc1", "idxBack", " idxcBack", "idy2", "idww81", " idXOne", "idnt2", "iddxJ", "idxf1", "idX1", " idx81", "idww2", "iddxBack", "idntBack", " idxBack", "idxone", "idnOne", "idxf81", " idxc2", "idxJ", "idX4", "idxcJ", "idntJ", "idn1", " idX2", "idn2", "idx0", "idy1", " idxcone", "idww1", "idwwone", "idX0", " idX1", "idx4", "idxc4", "idxcBack", "idxOne", "idy4", "idy0", " idxc0", "idxf2", " idx4", "iddx1", "idXOne", "idxc2", " idxc1", " idxone", " idX0", " idxOne", " idxJ", " idxcJ", "idxcone", " idx0", " idxc4", "idyOne", "idx81", "idn0", "idxfone", " idxc81", "idX2"], "idx2": ["idxi22", "idxi62", "sidx2", "indcy2", "idxi1", "idX1", "indxFL", "idxc22", "indcyFL", "idxi2", "idxf02", "idXTwo", "idcy02", "idX0", "idx4", " idxc22", " idxc1", "idx62", "idt2", "idxe2", " idxc4", "indx2", "idt02", "idxc62", "indxTwo", "idxi4", "sidx02", "idX62", "idxi0", "idx0", "idy1", "idxc4", "idxfTwo", " idxc0", "idxf2", "idt1", " idx0", "indx02", "idxc0", "idxFL", "sidt2", "idx22", "idxe22", "sidt02", "sidt1", " idx22", "idx02", "indcy02", "idcyFL", " idx4", "idxfFL", "indcyTwo", "idxc1", " idxc62", "idy2", "idcy2", "idxTwo", "sidx1", "idxe4", "idy02", " idxc2", "idXFL", "idxc2", "idX02", "idxe1", " idx62", "idcyTwo", "idX2"], "pos": ["po", "neg", "part", "def", "cache", "p", "prop", "pid", "offset", "val", "loc", "POS", "j", "type", "pc", "rel", "len", "pi", "n", "index", "pro", "position", "o", "slot", "pt", "min", "col", "pres", "ref", "end", "post", "pl", "port", "obj", "Pos", "sp", "os", "conf", "trans", "no", "spec", "op"], "tile": ["task", "zip", "chip", "kt", "item", "image", "late", "Tile", "line", "oe", "flo", "bridge", "tab", "ge", "cat", "plane", "nn", "route", "co", "tool", "stone", "coll", "cand", "tf", "so", "tle", "mask", "pixel", "sheet", "hop", "scale", "flat", "table", "ole", "style", "entity", "col", "pod", "token", "zone", "service", "tif", "fo", "plugin", "rule", "layer", "port", "split", "target", "coord", "grid", "ele", "unit", "texture", "transfer", "cube", "slice", "component", "feature", "file", "tag", "node", "cell", "plate"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723, "substitutes": {"dev": ["dc", "req", "def", "p", "cd", "info", "f", "app", "valid", "cur", "device", "user", "module", "diff", "data", "conf", "dem", "DEV", "comment", "rad", "var", "debug", "ev", "test", "priv", "gh", "md", "driver", "gd", "pro", "mod", "serial", "end", "nov", "model", "id", "sd", "ad", "dom", "w", "die", "dim", "bug", "gu", "der", "v", "err", "error", "ch", "dist", "dd", "client", "server", "pub", "cam", "Dev", "block", "dt", "di", "pack", "raw", "adv", "ver", "engine", "conn", "d", "self", "development", "wd", "exec", "de", "non"], "vdev": ["qdev", "vdd", "frad", "pd", "Vdevice", " vdevice", "fdiv", "ldev", "vrad", "Vdiv", "vvdevice", "ldevice", "vvdiv", "fdevice", "pdevice", "qrad", "drad", "Vd", "pdiv", "vvrad", "fdev", "qdd", "nvdev", "nvrad", "ldd", "lrad", " vd", "ddev", " vdiv", "vdevice", "Vdev", "nvdevice", "vdiv", "pdev", "ddiv", "ddevice", "vvdev", "nvdd", "vd", "qdevice"], "bus": ["loop", "home", "Bus", "BUS", "def", "class", "cache", "lc", "bridge", "host", "block", "sync", "us", "cat", "use", "db", "http", "local", "val", "pack", "cart", "proc", "config", "pass", "lock", "feed", "io", "bug", "b", "device", "dir", "lab", "back", "buf", "board", "base", "path", "build", "user", "ch", "nt", "session", "hub", "boot", "show", "pl", "band", "bc", "pull", "obj", "disk", "mount", "usb", "plug", "os", "conf", "bs", "lib", "pub", "comment"], "dev_len": ["patchenlin", "dev_base", " dev_length", "ev_lon", "dev_Len", "patch_fin", " dev_val", "priv_lon", "dev_lin", "dev6fin", "dev5len", "dev5lin", "ev_val", "priv_lin", "patchenlabel", "dev64len", "dev6label", "priv7len", "priv_lan", "dev7lon", "devenlabel", "devenlin", "dev_lon", " dev_Len", "dev7len", "dev_lit", "av_len", "dev5lan", "dev_lim", "ev_base", "dev5lon", "dev_length", "dev_label", "dev_val", "ev_la", "dev6len", "ev_len", "dev6lin", "dev_lan", "priv_len", "patchenfin", "dev64lon", "patch_lin", "devenfin", "priv7lan", "patch_len", "devenlen", "av_lon", "dev_la", "dev64lit", "dev_den", "priv7lin", "av_lit", "priv7lon", "dev7lan", "patchenlen", "dev7lin", "ev_den", "av_lim", "patch_label", "dev_fin", "dev64lim"], "cpu": ["machine", "chip", " CPU", "gp", "CPU", "cache", "GPU", "pid", "mem", "platform", "linux", "css", "disk", "clock", "processor", "process", "proc", "consumer", "gpu", "net", "computer", "pc", "vm", "device", "rpm", "performance", "sta", "xi", "fps", "np", "cp", "pu", "pkg", "component", "ilo", "cn", "px", "bench", "node", "loader", "pool"]}}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n", "idx": 21731, "substitutes": {"size": ["time", "timeout", "capacity", "shape", "empty", "ix", "cache", "zero", "enc", "sync", "core", "use", "code", "offset", "name", "loc", "address", "length", "mode", "max", "security", "si", "Size", "content", "fee", "len", "scale", "SIZE", "position", "base", "storage", "any", "sum", "range", "password", "root", "sh", "ize", "source", "six", "small", "weight", "count", "sized", "unit", "i", "speed", "server", "slice", "large", "g", "sec", "bytes"], "max_size": ["maxlensize", "max_number", "max64offset", "last_sized", "maxlenuse", "max48offset", "min_address", "min_shape", "default_length", "maxFsize", "maxlennumber", "maxxsized", "last64size", "max_offset", "max00size", "max48size", "max_use", "maxfullnumber", "max_capacity", "max_sized", " max_capacity", "max64use", "last64offset", "last_size", " max_sized", "last64sized", "max48sized", "default64number", "max00offset", "default64length", " max_offset", "max64capacity", "maxfulluse", "min_size", "maxxlength", " max_length", "max_shape", "maxxsize", "maxfulllength", " max_ize", "default_size", "max64ize", "default64use", "maxFaddress", "max_ize", "maxxoffset", "max64length", "maxFshape", "maxlenlength", "default_use", "default64size", "max00sized", "default_number", "max64number", "max_address", "max64sized", "max_length", "last_offset", "maxfullsize", "max48length", "max64size"], "resized": ["realized", "resize", " resizes", " resizable", "presizes", "realolved", "resizing", "Resizes", "realored", "Resized", "desored", "desolved", "preserved", "presizing", "resizable", "reserved", " resored", "realizing", "presized", "realerved", " resolved", "realizable", " resize", "presize", "greized", "greizable", "desized", "Resize", "greizing", "presizable", "Resizable", "greerved", "resizes", "resored", "resolved", "desizable"], "host": ["loop", "condition", "full", "home", "shape", "capacity", "image", "ctor", "cache", "h", "block", "location", "arch", "bit", "name", "loc", "frame", "type", "address", "length", "mode", "proxy", "config", "driver", "object", "comp", "oc", "device", "mac", "native", "Host", "raw", "index", "header", "scale", "hop", "parent", "base", "path", "error", "localhost", "root", "format", "chain", "hub", "connection", "source", "domain", "port", "target", "hard", "pos", "url", "container", "mount", "hack", "compatible", "server", "component", "addr", "large", "context", "ghost", "node", "prefix", "remote", "pool", "ip"], "resizeable": [" resizables", "resizeabled", "resizableability", "resizeables", "resizationables", " resizable", "resizability", "resizingables", "rsizeables", "resizele", " resizle", " resizeables", "resizables", "resizationle", "rsizable", "resizable", "resizeability", "resizablele", "rsizables", " resizele", "resizabled", "rsizeable", " resizble", "rsizeabled", "resizableabled", "rsizabled", "resizble", " resizeble", "resizingabled", "resizableables", "rsizeability", "resizingability", "rsizability", "resizableble", "resizationable", "resizle", "resizingable", "resizationble", "resizeble", "resizableable"], "mr": ["mc", "adr", "bm", "MR", "dm", "br", "nor", "mx", "gr", "wm", "lc", "rar", "pm", "rm", "md", "Mr", "sr", "mn", "mt", "rh", "ru", "vm", "RR", "mm", "mor", "vr", "bh", "mac", "err", "rpm", "igr", "rr", "nr", "drm", "r", "kr", "hr", "module", "manager", "usr", "attr", "mmm", "hm", "mid", "dr", "m", "gb", "er", "lr", "mk", "shr", "rl", "master", "rb", "rg", "fm", "ml"], "errp": ["eorr", "errr", "eorpc", "erpb", "errpre", "erP", "errorpre", "erpc", "erpre", "errP", "errorP", "eorp", "errorpc", " errP", " errpre", "errpc", "err", "eorpb", "errorp", "errpb", " errpc", " errpb", " errr", "erp"], "new_block": ["new_flow", "newAcclock", "extraacnetwork", "new___chain", "extraacblock", "old_case", "new_bin", "newfnode", "new___lock", "newlywork", "new_unit", "newAcblock", "newxobject", "existing_coll", "newacchain", "extra_frame", "new_object", "old_device", "new___ban", "newedbin", "newJjoin", "new67bin", "new_clean", "old_ban", "newlydevice", "newfban", "New_block", " new_row", "newPblock", "plus_block", "new_row", "newjblock", "unique_node", "new_link", " new_link", "unique_chain", "NEW_lock", "plus_unit", "newfblock", "uniquefblock", "unique_block", "newlylock", "plusJjoin", "unique_ban", "new___frame", "new__block", " new_chain", "uniquefnode", "old_lock", "newAcsync", "New_lock", "newacframe", "new___network", "new_coll", "newacunit", "new_lock", " new_lock", "uniquefban", "newPclock", "news_chain", "news_work", "NEW_block", " new_flow", "new__lock", "extra_network", "old_block", "new_panel", "plus_join", "existing_def", "plusJunit", "new_frame", "newedcoll", "NEW_panel", "newAcbase", "new_case", "new67def", " new_bro", "plusJblock", "new_blocks", "newJlock", "newacban", "plusJlock", "newlychain", "newxblock", "newjlock", "new_def", "new_clock", "newjrow", "newacblock", "existing_block", "newJblock", "newacjoin", "New_sync", "new_join", "new_node", "newfchain", "new_device", "new_ban", "newJunit", "new__row", "new_sync", "new_work", " new_blocks", "new67block", "newxdevice", "newPnode", " new_clock", "extra_block", "uniquefchain", "new___node", "new67coll", " new_clean", "newlyblock", "newjbro", "extraacframe", "newAclock", "new_bro", "new_base", "new_chain", "plus_lock", "news_lock", "extraaclock", "new___block", "new__blocks", "news_block", "existing_bin", "old_object", "extra_lock", "newPlock", "newaclock", " new_node", "newxlock", "neweddef", "NEW_device", "newacnode", "newacnetwork", "newedblock", "New_base", "new_network", "newlypanel", "newAcnode"], "local_err": ["localwerr", "global_error", "local_risk", "global_er", "local_er", "global_err", "global_gr", " local_error", "global_result", " local_risk", "local_gr", " local_er", "localwer", "local_result", "local_error", "localwresult", "localwerror"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n", "idx": 21739, "substitutes": {"s": ["S", "sq", "south", "w", "secondary", "p", "sym", "h", "sync", "site", "sg", "http", "ses", "info", "f", "types", "request", "stats", "is", "b", "n", "c", "spec", "sb", "python", "e", "cs", "r", "groups", "session", "u", "services", "private", "ops", "d", "ssl", "scope", "ctx", "i", "self", "m", "os", "sys", "t", "gs", "sf", "conf", "server", "ns", "g", "sec", "your", "js"], "type": ["typ", "ty", "def", "pe", "class", "val", "name", "TYPE", "ype", "types", "reg", "path", "style", "y", "py", "pb", "str", "target", "obj", "re", "Type", "id", "param", "t", "spec", "op"], "ret": ["att", "match", "x", "res", "resp", "rets", "en", "lit", "mem", "bit", "val", "rt", " Ret", "det", "rev", "Arg", "info", "ft", "f", "sr", "valid", "mt", "b", "bis", "RET", "v", "len", "gt", "back", "feat", "fun", "reg", "red", "r", "nt", "result", "ref", "opt", "str", "reply", "flag", "re", "xt", "alt", "t", "er", "success", "Ret", "addr", "sec", "ext"], "arg": ["match", "res", "p", "prop", "arm", "use", "date", "info", "f", "art", "ar", "feat", "ref", "opt", "gen", "bad", "data", "count", "i", "grad", "addr", "act", "ext", "var", "item", "doc", "empty", "en", "call", "num", "bit", "val", "name", "loc", "msg", "config", "Arg", "cmd", "asm", "len", "amp", "ag", "lag", "args", "target", "flag", "arr", "id", "param", "alt", "ad", "parse", "enc", "ac", "word", "option", "func", "pass", "v", "argument", "err", "r", "byte", "arc", "ig", "g", "op", "ace", "code", "magic", "max", "other", "mac", "next", "reg", "result", "str", "er", "tag", "sec", "inc", "ang"]}}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740, "substitutes": {"luks": ["fluke", "laks", "lick", "LUcs", "licks", "like", "luck", "LUke", "lics", "fluck", "flucs", "liKS", "LUks", "LUKS", "lack", "lacks", "fluks", "luke", "fluKS", "luKS", "flucks", "lucks", "liks", "lacs", "lucs"], "luks_opts": ["luks_cpouts", "luks_OPps", "luks_optte", "luks_alss", "luks_adouts", "luks_OPts", "luks_proters", "luks_opte", "luks_obters", "luks_optters", "luks_ot", "luks_copts", "luks_opss", "luks_OPns", "luks_cpts", "luks_hopte", "luks_opms", "luks_opbs", "luks_copters", "luks_OPters", "luks_adts", "luks_cattes", "luks_copks", "luks_pcs", "luks_okt", "luks_alns", "luks_opals", "luks_optted", "luks_OPted", "luks_OPs", "luks_opents", "luks_obts", "luks_openters", "luks_hopters", "luks_opcs", "luks_ryts", "luks_alt", "luks_alts", "luks_optt", "luks_copths", "luks_cats", "luks_catters", "luks_optes", "luks_obls", "luks_defte", "luks_opted", "luks_opks", "luks_prots", "luks_optms", "luks_ryths", "luks_adbs", "luks_lockters", "luks_cpters", "luks_opouts", "luks_ops", "luks_opsts", "luks_opls", "luks_pts", "luks_rybs", "luks_Ops", "luks_Opts", "luks_defths", "luks_OPte", "luks_opps", "luks_ott", "luks_prosts", "luks_optls", "luks_openments", "luks_okts", "luks_okters", "luks_Opcs", "luks_opns", "luks_hopts", "luks_OPbs", "luks_opens", "luks_otts", "luks_hopted", "luks_OPt", "luks_ryt", "luks_proths", "luks_okns", "luks_catts", "luks_lockts", "luks_opments", "luks_opths", "luks_defts", "luks_pt", "luks_hopals", "luks_alters", "luks_adters", "luks_Opt", "luks_openls", "luks_hopt", "luks_os", "luks_copss", "luks_opentes", "luks_ots", "luks_lockt", "luks_optments", "luks_alks", "luks_OPths", "luks_optals", "luks_otcs", "luks_adths", "luks_optcs", "luks_adns", "luks_OPtes", "luks_optts", "luks_locktes", "luks_obments", "luks_optps", "luks_opt", "luks_copsts", "luks_opters", "luks_OPcs", "luks_oktes", "luks_deft", "luks_OPms", "luks_ocs", "luks_cpns", "luks_otms", "luks_hopps", "luks_adt", "luks_pters"], "local_err": ["local__bug", "local___er", "shared_ver", "local_bug", "local_ver", "shared_bug", "local_er", "local__ver", "local__er", "shared_er", "local__err", "local___bug", "local___err", "local___ver", "shared_err"], "masterkey": ["primaryname", "parentblock", "publickey", "publicblock", "masterKey", "parentname", "publicKey", "parentKey", "primaryblock", "parentkey", "masterblock", "mastername", "primaryKey", "publicname", "primarykey"], "slotkey": ["slicename", "bitkey", "slotKey", "offsetkey", "slotname", "slicekey", "sliceid", "bitKey", "bitname", "offsetid", "sliceKey", "slotid", "bitid", "offsetname", "offsetKey"], "splitkey": ["slicekeys", "sessionblock", "sessionkey", "sessionKey", "sharedblock", "slicekey", "sharedkeys", "sharedKey", "splitkeys", "sliceKey", "sharedkey", "sliceblock", "sessionkeys", "splitblock", "splitKey"], "i": ["ii", "abi", "I", "p", "s", "is", "b", "a", "n", "c", "l", "fi", "data", "shared", "k", "multi", "t", "array", "ip"], "cipher": ["Cursor", "acairo", "acipher", "crypt", "cairo", "Cipher", "Cairo", "scursor", "scipher", "scrypt", "acursor", "scairo", "Crypt", "cursor", "acrypt"], "ivgen": [" ivdec", "vmap", "IVmap", "IVgener", "ivgener", "vdec", "IVgen", "ivdec", "vgen", "IVdec", " ivmap", " ivgener", "vgener", "ivmap"], "password": ["comment", "auth", "params", "text", "w", "enc", "word", "phrase", "wallet", "words", "security", "pass", "secret", "mask", "mac", "Password", "padding", "path", "alias", "user", "RAW", "sword", "token", "session", "rw", "username", "random", "prefix"], "cipher_alg": ["cipher_round", "cryption_method", "cryption_orig", "cipher_orig", "cryption_mag", "cipher_mag", "cryption_round", "cryption_alg", "cipher_erg", "cipher_method", "cryption_mode", "cryption_erg"], "cipher_mode": ["cipher\u00b7type", "cipheringmode", "cipheringalg", "cursor_def", "cipheringmodule", "crypt_mode", "crypt_style", "cipher\u00b7mode", "cipher\u00b7level", "cipher\u00b7def", "cipheringstyle", "cursor_type", "cipher_style", "crypt_alg", "cipher_def", "cursor_level", "crypt_module", "cipher_module", "cipher_level", "cipher_type", "cursor_mode"], "ivgen_alg": ["ivgetingagg", "ivgetingrg", "ivgn_mode", "ivgn_generation", "ivgn_lass", "ivgen_mode", "ivgen_agg", "ivget_mode", "ivgen_lass", "ivgen_alt", "ivget_alg", "ivgn_alg", "ivget_agg", "ivgeningalg", "ivget_rg", "ivgn_alt", "ivgetingmode", "ivgeningagg", "ivgen_generation", "ivgetingalg", "ivgen_rg", "ivgeningrg", "ivgeningmode", "ivgn_rg"], "ivgen_hash_alg": ["ivgen_hash_lim", "ivgen_hash_mode", "ivgen_hash_mag"], "hash_alg": ["hashablealg", "hash67alg", "hash_dec", " hash_gen", "hash___mode", " hash_arch", "hash_gen", "hash67mode", " hash_spec", "hashablearch", " hash_mode", "hash___alg", "hash_spec", "hashablemode", "hash___arch", "hashabledec", "hash67spec", "hash_mode", " hash_dec", "hash___dec", "hash67gen", "hash_arch"], "cipher_mode_spec": ["cipher_mod_mode", "cipher_mode_mode", "cipher_mod_SPEC", "cipher_mode_SPEC", "cipher_mod_spec", "cipher_mode_len", "cipher_mod_len"], "iters": ["integer", "litered", "ifers", "liters", "itered", "ifered", "iter", "itering", "integered", "integering", "litering", "ifering", "liter", "ifer", "integers"]}}
{"project": "FFmpeg", "commit_id": "17269bdfcdb79679f6b92024d1228e876b799a63", "target": 1, "func": "static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n", "idx": 21750, "substitutes": {"s": ["settings", "sets", "sq", "south", "S", "ks", "rs", "w", "p", "sym", "ls", "aws", "site", "sync", "sa", "us", "bis", "ses", "ds", "f", "an", "xs", "types", "fs", "is", "b", "ts", "ss", "v", "si", "a", "n", "c", "spec", "ps", "parser", "sb", "storage", "submit", "o", "e", "cs", "l", "r", "args", "service", "u", "qs", "services", "sup", "es", "d", "ops", "ssl", "gs", "ctx", "os", "su", "sys", "t", "conf", "bs", "g", "sl", "sg", "ns", "sv", "sports", "js"], "swf": ["srv", "twfr", "swtf", "wwfs", "SWfx", "twfs", "wwf", "twtf", "slf", "wwfp", "Swrf", "srfx", "SWv", "slfs", "svtf", "wwrf", "srf", "svfs", "Swfs", "sltf", "swfx", "swfr", "SWfs", "surfs", "srfs", "swv", "surrf", "SWf", " swfx", "Swf", "surf", " swv", "svfr", "swfp", "Swfp", "slfr", "svf", " swfs", "surfp", "swfs", "twf", "swrf"], "pb": ["lb", "bm", "pd", "pa", "wb", "jp", "p", "cv", "orb", "uf", "platform", "verb", "bb", "ib", "db", "xb", "phrase", "pg", "pm", "dl", "um", "pc", "bf", "b", "mp", "bh", "fc", "lab", "ub", "pro", "lp", "sb", "bps", "bp", "prototype", "parser", "ab", "mb", "prot", "tmp", "fp", "hub", "ref", "vp", "plugin", "pl", "summary", "ob", "bc", "tp", "PB", "rob", "url", "tc", "api", "ctx", "ppa", "plug", "gb", "cpp", "abc", "pkg", "fb", "dp", "eb", "binary", "rb", "fm"], "enc": ["dc", "inst", "iv", "voc", "ENC", "oder", "ev", "lc", "en", "ea", "code", "acl", "img", "ac", "cat", "loc", "ocr", "eng", "equ", "coll", "pc", "uc", "rh", "anc", "oc", "sc", "ct", "cod", "c", "e", "env", "conn", "ch", "lang", "esc", "bc", "unc", "ic", "impl", "rc", "nec", "ig", "emb", "obj", "ctx", "eu", "vc", "cel", "nc", "Enc", "ent", "sl", "g", "sec", "act", "inc", "ec", "ext"], "video_enc": ["video4enc", "video67encrypted", "video_dec", " video_encrypted", "video64ec", "videoalimpl", "videoaldec", "video_ent", "videoIPenc", "videoalenc", "player_engine", "video64enc", "video_engine", "video_Enc", " video_ec", "videoIPfc", "video_impl", "video64en", "player_enc", "video4ent", "video_en", "video_end", "player_en", "videoIPent", "videoalec", "video67end", "videoalencrypted", "video4fc", "video_fc", " video_Enc", "audio_ec", " video_ent", " video_fc", "video67Enc", "player_ec", "video_ec", "videoIPec", "audio_impl", "video64engine", "video67enc", "videoalEnc", "video4ec", "audio_dec", " video_end", "video_encrypted", "audio_enc"], "file_size": [" file64sum", "filenamelexsum", "filelexsize", "filenamelexsize", "file_number", "file___speed", "filelexsum", "filexsum", "filename_sum", "file_count", "filenamelexexternal", " file_speed", "file_sum", "file_time", "file64size", " file_count", "filexspeed", "file___size", "filexsize", "file___count", "filextime", "filenamelexspeed", "file64time", "file_speed", "filexnumber", " file_number", " file_sum", "filename_size", "filelexexternal", "file64number", "file_external", " file64number", "filexcount", "file___number", "filename_external", "filelexspeed", " file64size", " file64time", "file64sum", " file_time", "filename_speed"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "p", "eni", "lc", "phi", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ni", "ie", "si", "io", "v", "pi", "uri", "index", "c", "o", "ind", "e", "l", "vi", "xi", "key", "u", "yi", "inner", "fi", "li", "in", "iu", "hi", "k", "id", "mi", "ci", "zi", "m", "t", "multi", "gi", "ori", "mu", "bi", "ip"]}}
{"project": "FFmpeg", "commit_id": "fbfbd97be25c4da0562ef61e2f27192d1ec4d276", "target": 1, "func": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    XPMDecContext *x = avctx->priv_data;\n\n    AVFrame *p=data;\n\n    const uint8_t *end, *ptr = avpkt->data;\n\n    int ncolors, cpp, ret, i, j;\n\n    int64_t size;\n\n    uint32_t *dst;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n\n\n    end = avpkt->data + avpkt->size;\n\n    while (memcmp(ptr, \"/* XPM */\\n\", 10) && ptr < end - 10)\n\n        ptr++;\n\n\n\n    if (ptr >= end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n\n        return ret;\n\n\n\n    if (cpp <= 0 || cpp >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size = 1;\n\n    for (i = 0; i < cpp; i++)\n\n        size *= 94;\n\n\n\n    if (ncolors <= 0 || ncolors > size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size *= 4;\n\n\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n\n    if (!x->pixels)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n\n    for (i = 0; i < ncolors; i++) {\n\n        const uint8_t *index;\n\n        int len;\n\n\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        if (ptr + cpp > end)\n\n            return AVERROR_INVALIDDATA;\n\n        index = ptr;\n\n        ptr += cpp;\n\n\n\n        ptr = strstr(ptr, \"c \");\n\n        if (ptr) {\n\n            ptr += 2;\n\n        } else {\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        len = strcspn(ptr, \"\\\" \");\n\n\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n\n            return ret;\n\n\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n\n\n        for (j = 0; j < avctx->width; j++) {\n\n            if (ptr + cpp > end)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n\n                return ret;\n\n\n\n            *dst++ = x->pixels[ret];\n\n            ptr += cpp;\n\n        }\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    p->key_frame = 1;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 21762, "substitutes": {"avctx": ["ajpkg", "abcf", "navcci", "evcmd", "avalctx", "avcup", "ajctl", "avlc", "versync", "avalcup", "afcoll", "ajcup", " avpkg", "ajcu", "avectx", " avcu", "evconn", "avctl", "AVcontext", "ajcca", "afconfig", "avsync", "avesync", "afcci", "avecu", "avesci", "avercup", "avecup", "navctx", "vercp", "navcf", "avalcontext", "vercu", "avalconn", "ajconfig", "afctl", "avcontext", "afcca", "ajconn", "vercontext", "ajcontext", "avelc", "ajcoll", "ajcci", "evcontext", "aflc", "afcit", "abcontext", "ajcmd", "afcup", "afcontext", "avecoll", "ajctx", "avconfig", "ajcit", "avsci", "avalsci", "afsci", "avecontext", "avcu", " avcci", "avcoll", "afconn", "averctx", "aimctx", "aimcot", "ablc", "avcmp", "afcf", "avcmd", "avalcot", "afcp", "AVcmp", "AVcup", "avecit", "avercot", "avalcms", "avecci", "avcp", "avercms", "afcmp", "avecp", "navcontext", "afpkg", "avecf", "verctl", "afcmd", " avconfig", "verctx", "aimcms", "avpkg", "avalcmp", "afcu", "avconn", "AVctx", "avcci", "evctx", "avcit", "abctx", " avcontext", "ajcf", "vercca", "avcms", "aimcup", "afctx", "avcf", "afsync", "avcca", "ajsync", "avcot", "aveconn"], "data": ["nd", "delay", "image", "empty", "cache", "DATA", "call", "block", "code", "date", "buffer", "val", "frame", "offset", "name", "f", "length", "config", "sample", "start", "gap", "body", "feed", "media", "next", "align", "buf", "header", "parent", "base", "da", "dat", "alpha", "draw", "result", "window", "final", "dd", "off", "value", "d", "read", "api", "pos", "video", "input", "primary", "ctx", "reader", "pad", "ad", "id", "done", "Data", "open", "package", "master"], "got_frame": ["max_buffer", "datafullframes", "datafullfram", "max_frame", "max_fram", "data_frame", "datafullframe", "data_frames", "data_fram", "datafullbuffer", "max_frames", "data_buffer"], "avpkt": ["avpk", "avfft", "avepke", "avpatch", " avpft", "avppkg", "avlpct", "avebkt", "affacket", "affkt", "afpkt", "avPct", "avpett", "avppk", "avbvt", "avfatch", "afpft", "avpft", "avprkt", "avlpft", "avpeft", "avplvt", "avfacket", "avebvt", "avecpkt", "avppke", "avpvt", "affatch", "avPkt", "avepkt", "avfett", "avcpk", "avbkt", " avpct", "avplett", "avepvt", "avplkt", "avpeatch", " avlpft", "avecpke", "avecpkg", "avlpacket", "avpekt", "avppkt", "avepkg", "avpke", "avfvt", "avnpkt", "avfct", "avnpk", "avpeacket", "avnpkg", "avbacket", "avPft", "avcpkg", "avebacket", "afpatch", "avecpk", "avepk", " avlpkt", "avpacket", "avfkt", "avebett", "avpratch", "avpct", " avlpacket", "avnpke", "afpacket", "avpkg", " avlpct", "avcpkt", "avepett", "avPacket", "avlpkt", "avbett", "avcpke", "affft", "avepacket", "avpracket", "avplacket", "avprft", " avpacket"], "x": ["nex", "image", "w", "rex", "ix", "xc", "xy", "cross", "X", "ex", "ax", "f", "config", "s", "xxx", "xs", "rx", "xml", "xf", "v", "lex", "xx", "ux", "wx", "c", "python", "e", "xes", "y", "dx", "r", "xp", "l", "tx", "xi", "d", "xa", "ic", "m", "fx", "sex", "work", "t", "px", "z", "ext"], "p": ["pe", "pa", "cache", "jp", "buffer", "pointer", "f", "pc", "b", "v", "pp", "pi", "n", "c", "lp", "bp", "pt", "e", "y", "r", "P", "fp", "pre", "pb", "vp", "tp", "d", "np", "cp", "api", "ctx", "sp", "m", "t", "wp"], "end": ["END", "nd", "close", "pe", "event", "h", "en", "enc", "pend", "End", "offset", "address", "length", "f", "max", "ender", "start", "ep", "v", "ended", "c", "con", "send", "begin", "e", "tail", "ending", "post", "d", "after", "pos", "est", "append", "id", "ad", "fin", "last", "edge", "ent", "enter", "z", "stop", "set", "ext"], "ptr": ["req", "br", "prop", "offset", "buffer", "elt", "rt", "proc", "cur", "wr", "Ptr", "ref", "dest", "tr", "ff", "pos", "pull", "dr", "pad", "grad", "addr", "pointers", "ext", "adr", "trace", "desc", "stage", "src", "jp", "lf", "loc", "address", "fr", "fd", "tip", "pl", "rc", "plug", "rw", "shift", "lr", "dy", "slice", "inst", "oe", "pr", "fe", "pend", "buff", "length", "pt", "dat", "tmp", "fp", "ctx", "push", "ace", "code", "pointer", "type", "ft", "td", "start", "next", "sth", "buf", "ctr", "str", "tp", "port", "attr", "coord", "xt", "cmp"], "ncolors": [" nCollections", "nColnames", "ncollections", "nfillections", "nolors", "ncolrons", "nicolrons", "nfiloring", "ncolorores", "noloring", " ncolorori", "nfilours", "nselectnames", "ccolors", "nColores", "ncolners", "ncolnames", " nColnames", "nColters", " nColors", "nCOLores", "nCOLrons", "ngenerors", "cicolores", "ncolours", "nselectores", " nColners", "ncalors", "ncolor", "nColners", "nCollections", "ncolores", "ccolores", " nicolors", "cicollections", " ncoloror", " nColores", "ncallections", " ncolores", "ncolorori", "nCOLors", " nicolours", "ncolters", "nselectors", "nfilters", "ncalores", "ncoloring", " ncolnames", " nicoloring", " ncolners", "ncolorors", "nicolor", "nicollections", "nfilors", "ngenerores", "ncoloror", "ngenernames", "nicolours", "nicoloring", "nfilor", " nicolor", "ncalori", " ncolori", " ncolorors", "nCOLlections", "ncalters", " ncollections", "nfilrons", "nolor", "ncolori", "cicolrons", "nColors", "ccolrons", "ccollections", " ncolours", "nfilores", "ncalor", " ncolorores", "nolours", "nicolores", " ncolters", "cicolors", "nselectners", " ncolor", "ngenerners", "nicolori", "nicolors", " ncoloring", " nColters"], "cpp": ["dc", "zip", "chip", "cf", "cap", "gp", "xc", "cv", "src", "jp", "cc", "pps", "cpu", "ce", "length", "uv", "qq", "ep", "cmd", "pp", "xx", "height", "cod", "c", "cb", "bp", "ppo", "dx", "prot", "tmp", "fp", "pb", "crop", "vp", "cm", "sup", "ff", "tp", "cup", "eps", "np", "cp", "upp", "ffff", "kk", "ctx", "ppa", "vc", "ci", "pkg", "esp", "sf", "cmp", "fb", "nc", "hp", "wp"], "ret": ["desc", "req", "att", "match", "def", "res", "resp", "rets", "reset", "mem", "rt", "val", "buffer", "rev", "offset", "ft", "status", "det", "f", "proc", "cur", "info", "RET", "back", "get", "buf", "fun", "err", "reg", "r", "prot", "nt", "result", "ref", "dist", "value", "fi", "bad", "mini", "reply", "rc", "re", "rf", "obj", "flag", "count", "id", "alt", "fail", "replace", "success", "Ret", "rep", "pet", "ext", "utf"], "i": ["ti", "ii", "ui", "ji", "jit", "ani", "qi", "I", "h", "eni", "phi", "di", "ri", "ai", "ini", "ie", "ni", "start", "si", "b", "io", "pi", "uri", "ami", "c", "ind", "vi", "xi", "chi", "fi", "li", "in", "iu", "hi", "k", "id", "mi", "ci", "zi", "gi", "inner", "it", "ip"], "j": ["ji", "ii", "ny", "ok", "jp", "h", "jump", "loc", "je", "pg", "ie", "ni", "b", "jc", "v", "n", "adj", "bp", "y", "ij", "pos", "k", "sp", "g", "z", "js"], "size": ["ii", "shape", "capacity", "offset", "si", "Size", "content", "SIZE", "storage", "sum", "mini", "count", "form", "bytes", "empty", "en", "core", "loc", "name", "address", "fee", "white", "ize", "cm", "weight", "sized", "large", "channel", "ui", "cap", "fe", "mode", "length", "c", "six", "small", "member", "unit", "sp", "ci", "g", "z", "sn", "ny", "sync", "code", "max", "start", "body", "scale", "send", "iz", "cp", "nice", "speed", "number", "sec"], "dst": [" dcr", "frc", "fst", "dncr", "fsts", "dnst", "dnrc", "dnsts", "fcr", " dsts", "dsts", " drc", "dcr", "drc"]}}
{"project": "FFmpeg", "commit_id": "452ac2aaecf7210a2912d9156869c6314142a794", "target": 0, "func": "static void ripemd160_transform(uint32_t *state, const uint8_t buffer[64], int ext)\n\n{\n\n    uint32_t a, b, c, d, e, f, g, h, i, j;\n\n    uint32_t block[16];\n\n    int n;\n\n\n\n    if (ext) {\n\n        a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4];\n\n        f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9];\n\n    } else {\n\n        a = f = state[0];\n\n        b = g = state[1];\n\n        c = h = state[2];\n\n        d = i = state[3];\n\n        e = j = state[4];\n\n    }\n\n\n\n    for (n = 0; n < 16; n++)\n\n        block[n] = AV_RL32(buffer + 4 * n);\n\n\n\n    for (n = 0; n < 16 - 1;) {\n\n        ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_0_TO_15(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_0_TO_15(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_0_TO_15(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);\n\n    }\n\n    ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n    SWAP(a,f)\n\n\n\n    for (; n < 32 - 1;) {\n\n        ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_16_TO_31(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_16_TO_31(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_16_TO_31(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_16_TO_31(a,b,c,d,e,f,g,h,i,j);\n\n    }\n\n    ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n    SWAP(b,g)\n\n\n\n    for (; n < 48 - 1;) {\n\n        ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_32_TO_47(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_32_TO_47(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_32_TO_47(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_32_TO_47(e,a,b,c,d,j,f,g,h,i);\n\n    }\n\n    ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n    SWAP(c,h)\n\n\n\n    for (; n < 64 - 1;) {\n\n        ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_48_TO_63(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_48_TO_63(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_48_TO_63(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_48_TO_63(d,e,a,b,c,i,j,f,g,h);\n\n    }\n\n    ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n    SWAP(d,i)\n\n\n\n    for (; n < 75;) {\n\n        ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_64_TO_79(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_64_TO_79(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_64_TO_79(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_64_TO_79(c,d,e,a,b,h,i,j,f,g);\n\n    }\n\n    ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n    SWAP(e,j)\n\n\n\n    if (ext) {\n\n        state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e;\n\n        state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j;\n\n    } else {\n\n        i += c + state[1];\n\n        state[1] = state[2] + d + j;\n\n        state[2] = state[3] + e + f;\n\n        state[3] = state[4] + a + g;\n\n        state[4] = state[0] + b + h;\n\n        state[0] = i;\n\n    }\n\n}\n", "idx": 21766, "substitutes": {"state": ["shape", "class", "p", "use", "se", "info", "order", "view", "seed", "range", "key", "oper", "data", "down", "form", "part", "pe", "event", "area", "address", "config", "back", "index", "power", "manager", "private", "point", "rule", "size", "model", "memory", "State", "transfer", "work", "slice", "map", "group", "resource", "element", "states", "mode", "length", "stat", "store", "style", "r", "space", "patch", "scope", "m", "statement", "sync", "code", "pair", "type", "object", "start", "body", "position", "o", "reg", "ver", "conn", "message", "handle", "post", "port", "layer", "list", "context"], "buffer": ["channel", "Buffer", "timeout", "shape", "image", "iter", "bb", "queue", "code", "num", "buff", "offset", "length", "counter", "uffer", "v", "len", "bin", "header", "buf", "seed", "position", "cb", "table", "message", "batch", "byte", "window", "source", "size", "append", "memory", "count", "null", "transfer", "number", "bar", "record", "program"], "ext": ["desc", "req", "br", "text", "empty", "secondary", "enc", "sync", "vert", "code", "ex", "rev", "extra", "sec", "temp", "seq", "flat", "cb", "xp", "prot", "aux", "fp", "ctr", "end", "str", "flex", "tr", "external", "esc", " extend", "append", "EXT", "xt", "transfer", "txt", "cut", "gz", "nc", "Ext", "z", "expl"], "a": ["ace", "aa", "af", "x", "w", "p", "ea", "area", "sa", "ac", "aw", "an", "ai", "s", "as", "v", "ah", "ae", "ar", "ia", "ca", "base", "o", "action", "da", "alpha", "ab", "y", "l", "fa", "r", "va", "u", "A", "at", "m", "ad", "t", "am", "z", "ba", "aaa"], "b": ["aa", "x", "w", "wb", "p", "bb", "ac", "db", "bd", "an", "s", "as", "q", "bf", "v", "bh", "cb", "sb", "ca", "o", "ab", "y", "r", "l", "ch", "u", "be", "bc", "k", "m", "ad", "t", "fb", "bs", "eb", "z", "ba"], "c": ["C", "dc", "cf", "cy", "x", "w", "p", "cd", "cat", "ac", "ce", "s", "q", "v", "con", "ca", "o", "cs", "y", "l", "r", "col", "ch", "u", "k", "m", "ci", "t", "cn", "z", "ec"], "d": ["dc", "nd", "x", "w", "p", "cd", "dt", "di", "db", "ds", "md", "s", "q", "D", "v", "dh", "df", "da", "o", "y", "r", "l", "u", "dd", "k", "id", "m", "ad", "t", "dy", "z"], "e": ["element", "x", "w", "oe", "p", "fe", "en", "ge", "se", "el", "ed", "ce", "ef", "s", "ie", "E", "v", "ae", "ei", "o", "y", "l", "r", "u", "ee", "be", "es", "ne", "k", "m", "t", "er", "em", "z", "ec"], "f": ["cf", "af", "x", "w", "p", "fe", "inf", "el", "s", "q", "fr", "fs", "bf", "v", "fc", "F", "df", "o", "fl", "y", "l", "r", "fa", "fd", "ph", "u", "fi", "ff", "k", "m", "t", "fb", "sf", "z"], "g": ["gg", "x", "w", "gm", "p", "en", "gh", "ge", "di", "go", "pg", "s", "q", "he", "v", "err", "o", "G", "y", "l", "r", "ch", "u", "sh", "gen", "in", "ig", "big", "k", "gs", "m", "t", "er", "group", "gi", "z"], "h": ["ha", "ul", "x", "w", "kh", "p", "hl", "en", "gh", "ht", "th", "ih", "s", "q", "rh", "he", "v", "html", "ah", "oh", "hh", "bh", "wh", "hs", "o", "err", "H", "y", "l", "r", "hr", "ch", "ph", "u", "sh", "uh", "hi", "k", "id", "m", "t", "eh", "z", "it"], "i": ["ii", "x", "w", "I", "p", "phi", "di", "ai", "s", "ie", "q", "is", "si", "io", "v", "pi", "o", "y", "l", "r", "u", "sh", "fi", "li", "in", "ic", "k", "id", "m", "ci", "t", "gi", "z", "bi", "it"], "j": ["ji", "ii", "x", "w", "jp", "p", "jo", "el", "je", "s", "ie", "q", "si", "jc", "v", "io", "uj", "o", "y", "l", "r", "ij", "ch", "u", "key", "sh", "li", "obj", "J", "k", "m", "t", "it", "aj", "z", "js"], "block": ["channel", "image", "row", "num", "bit", "frame", "offset", "type", "length", "pack", "object", "lock", "bl", "bin", "header", "position", "base", "page", "batch", "byte", "blocks", "output", "out", " Block", "unit", "null", "Block", "number", "array", "slice", "group", "node", "BL", "ip"], "n": ["x", "w", "nm", "p", "en", "num", "nn", "name", "an", "na", "net", "no", "ni", "nb", "s", "mn", "not", "v", "len", "adj", "o", "nr", "y", "l", "r", "conn", "nt", "N", "pn", "u", "node", "size", "ne", "count", "k", "m", "t", "dn", "fn", "number", "un", "nc", "nu", "network", "ns", "z", "sn"]}}
{"project": "FFmpeg", "commit_id": "bc7eb330e3d42f6cff3f95432da999bd4538e2e1", "target": 0, "func": "static void opt_frame_size(const char *arg)\n\n{\n\n    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n\n        fprintf(stderr, \"Incorrect frame size\\n\");\n\n        av_exit(1);\n\n    }\n\n    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n\n        fprintf(stderr, \"Frame size must be a multiple of 2\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n", "idx": 21767, "substitutes": {"arg": ["ace", "empty", "axis", "enc", "arm", "use", "cat", "ang", "ac", "val", "par", "ma", "ax", "Arg", "valid", "as", "other", "mor", "mac", "ag", "ar", "argument", "age", "play", "args", "lang", "arc", "inter", "gen", "flag", "ig", "arr", "param", "ad", "g", "sec", "ay", "inc", "new", "var"]}}
{"project": "FFmpeg", "commit_id": "20fe316e47fedb28787e77e77a7011133f3d4e73", "target": 1, "func": "static int sdl_write_trailer(AVFormatContext *s)\n\n{\n\n    SDLContext *sdl = s->priv_data;\n\n\n\n    sdl->quit = 1;\n\n\n\n    if (sdl->overlay)\n\n        SDL_FreeYUVOverlay(sdl->overlay);\n\n\n    if (sdl->event_thread)\n\n        SDL_WaitThread(sdl->event_thread, NULL);\n\n\n    if (sdl->mutex)\n\n        SDL_DestroyMutex(sdl->mutex);\n\n\n    if (sdl->init_cond)\n\n        SDL_DestroyCond(sdl->init_cond);\n\n\n\n\n    if (!sdl->sdl_was_already_inited)\n\n        SDL_Quit();\n\n\n\n    return 0;\n\n}", "idx": 21776, "substitutes": {"s": ["sq", "south", "w", "p", "ls", "ses", "ds", "f", "sc", "b", "ss", "v", "si", "a", "n", "c", "spec", "sb", "storage", "o", "e", "cs", "l", "services", "d", "ssl", "ctx", "i", "gs", "m", "sys", "su", "t", "sl", "ns", "sg", "g", "sv", "js"], "sdl": ["sdpl", "ddla", "svpl", "dsn", "dsel", "tdl", "svl", "gdll", "ddL", "sdlp", "dddl", "dlsl", "sdlc", "sdsl", "ddle", "tdle", " sdL", "gdld", "eddli", "ldel", "tdll", "dlL", "SDli", "wdL", "ddpl", "eddL", "dsL", "dsla", "ddll", "eddl", "dslc", "sdL", "SDsl", "sdla", "ddl", "ddli", "gdsl", "SDll", "svlc", "dlll", "lddl", "ldlp", "ldll", "sdn", "SDld", "dsl", "ddn", "ddel", "gdr", "wdl", "svn", "gdlc", "ldn", "sdli", "ldL", "ldlc", "dsll", "gdel", "sdle", " sdle", "tdlc", " sdlc", "ddlp", "SDlc", "ldle", "ldld", "sdls", "ldla", " sdel", "gdls", "sddl", "SDL", "wdsl", " sdr", "SDl", "sdll", " sddl", "ddsl", "dll", "SDpl", "SDn", " sdll", "ddr", "sdel", "ldl", "ddls", "sdld", "ddlc", "wdll", "eddll", " sdls", "ldsl", "sdr", "dslp", "gdl"]}}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "void MPV_decode_mb(MpegEncContext *s, DCTELEM block[6][64])\n\n{\n\n    int mb_x, mb_y;\n\n    int dct_linesize, dct_offset;\n\n    op_pixels_func *op_pix;\n\n    qpel_mc_func *op_qpix;\n\n\n\n    mb_x = s->mb_x;\n\n    mb_y = s->mb_y;\n\n\n\n#ifdef FF_POSTPROCESS\n\n    quant_store[mb_y][mb_x]=s->qscale;\n\n    //printf(\"[%02d][%02d] %d\\n\",mb_x,mb_y,s->qscale);\n\n#endif\n\n\n\n    /* update DC predictors for P macroblocks */\n\n    if (!s->mb_intra) {\n\n        if (s->h263_pred || s->h263_aic) {\n\n          if(s->mbintra_table[mb_x + mb_y*s->mb_width])\n\n          {\n\n            int wrap, xy, v;\n\n            s->mbintra_table[mb_x + mb_y*s->mb_width]=0;\n\n            wrap = 2 * s->mb_width + 2;\n\n            xy = 2 * mb_x + 1 +  (2 * mb_y + 1) * wrap;\n\n            v = 1024;\n\n            \n\n            s->dc_val[0][xy] = v;\n\n            s->dc_val[0][xy + 1] = v;\n\n            s->dc_val[0][xy + wrap] = v;\n\n            s->dc_val[0][xy + 1 + wrap] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[0][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + wrap], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1 + wrap], 0, 16 * sizeof(INT16));\n\n            if (s->h263_msmpeg4) {\n\n                s->coded_block[xy] = 0;\n\n                s->coded_block[xy + 1] = 0;\n\n                s->coded_block[xy + wrap] = 0;\n\n                s->coded_block[xy + 1 + wrap] = 0;\n\n            }\n\n            /* chroma */\n\n            wrap = s->mb_width + 2;\n\n            xy = mb_x + 1 + (mb_y + 1) * wrap;\n\n            s->dc_val[1][xy] = v;\n\n            s->dc_val[2][xy] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[1][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[2][xy], 0, 16 * sizeof(INT16));\n\n          }\n\n        } else {\n\n            s->last_dc[0] = 128 << s->intra_dc_precision;\n\n            s->last_dc[1] = 128 << s->intra_dc_precision;\n\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n\n        }\n\n    }\n\n    else if (s->h263_pred || s->h263_aic)\n\n        s->mbintra_table[mb_x + mb_y*s->mb_width]=1;\n\n\n\n    /* update motion predictor, not for B-frames as they need the motion_val from the last P/S-Frame */\n\n    if (s->out_format == FMT_H263) { //FIXME move into h263.c if possible, format specific stuff shouldnt be here\n\n      if(s->pict_type!=B_TYPE){\n\n        int xy, wrap, motion_x, motion_y;\n\n        \n\n        wrap = 2 * s->mb_width + 2;\n\n        xy = 2 * mb_x + 1 + (2 * mb_y + 1) * wrap;\n\n        if (s->mb_intra) {\n\n            motion_x = 0;\n\n            motion_y = 0;\n\n            goto motion_init;\n\n        } else if (s->mv_type == MV_TYPE_16X16) {\n\n            motion_x = s->mv[0][0][0];\n\n            motion_y = s->mv[0][0][1];\n\n        motion_init:\n\n            /* no update if 8X8 because it has been done during parsing */\n\n            s->motion_val[xy][0] = motion_x;\n\n            s->motion_val[xy][1] = motion_y;\n\n            s->motion_val[xy + 1][0] = motion_x;\n\n            s->motion_val[xy + 1][1] = motion_y;\n\n            s->motion_val[xy + wrap][0] = motion_x;\n\n            s->motion_val[xy + wrap][1] = motion_y;\n\n            s->motion_val[xy + 1 + wrap][0] = motion_x;\n\n            s->motion_val[xy + 1 + wrap][1] = motion_y;\n\n        }\n\n      }\n\n    }\n\n    \n\n    if (!(s->encoding && (s->intra_only || s->pict_type==B_TYPE))) {\n\n        UINT8 *dest_y, *dest_cb, *dest_cr;\n\n        UINT8 *mbskip_ptr;\n\n\n\n        /* avoid copy if macroblock skipped in last frame too \n\n           dont touch it for B-frames as they need the skip info from the next p-frame */\n\n        if (s->pict_type != B_TYPE) {\n\n            mbskip_ptr = &s->mbskip_table[s->mb_y * s->mb_width + s->mb_x];\n\n            if (s->mb_skiped) {\n\n                s->mb_skiped = 0;\n\n                /* if previous was skipped too, then nothing to do ! \n\n                   skip only during decoding as we might trash the buffers during encoding a bit */\n\n                if (*mbskip_ptr != 0 && !s->encoding) \n\n                    goto the_end;\n\n                *mbskip_ptr = 1; /* indicate that this time we skiped it */\n\n            } else {\n\n                *mbskip_ptr = 0; /* not skipped */\n\n            }\n\n        }\n\n\n\n        dest_y = s->current_picture[0] + (mb_y * 16 * s->linesize) + mb_x * 16;\n\n        dest_cb = s->current_picture[1] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n        dest_cr = s->current_picture[2] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n\n\n        if (s->interlaced_dct) {\n\n            dct_linesize = s->linesize * 2;\n\n            dct_offset = s->linesize;\n\n        } else {\n\n            dct_linesize = s->linesize;\n\n            dct_offset = s->linesize * 8;\n\n        }\n\n\n\n        if (!s->mb_intra) {\n\n            /* motion handling */\n\n            if((s->flags&CODEC_FLAG_HQ) || (!s->encoding)){\n\n                if ((!s->no_rounding) || s->pict_type==B_TYPE){                \n\n                    op_pix = put_pixels_tab;\n\n                    op_qpix= qpel_mc_rnd_tab;\n\n                }else{\n\n                    op_pix = put_no_rnd_pixels_tab;\n\n                    op_qpix= qpel_mc_no_rnd_tab;\n\n                }\n\n\n\n                if (s->mv_dir & MV_DIR_FORWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture, op_pix, op_qpix);\n\n                    if ((!s->no_rounding) || s->pict_type==B_TYPE)\n\n                        op_pix = avg_pixels_tab;\n\n                    else\n\n                        op_pix = avg_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* add dct residue */\n\n            add_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            add_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            add_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            add_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            add_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            add_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        } else {\n\n            /* dct only in intra block */\n\n            put_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            put_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            put_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            put_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            put_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            put_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        }\n\n    }\n\n the_end:\n\n    emms_c(); //FIXME remove\n\n}\n", "idx": 21779, "substitutes": {"s": ["ins", "p", "us", "se", "f", "si", "a", "sb", "cs", "ops", "side", "gs", "i", "conf", "vs", "spec", "sv", "aws", "ses", "ds", "an", "xs", "is", "b", "ts", "n", "ps", "sites", "e", "y", "services", "parts", "ans", "sup", "comments", "os", "states", "S", "ks", "w", "sym", "h", "enc", "site", "bis", "ions", "stats", "its", "sis", "c", "space", "l", "service", "qs", "es", "m", "sys", "t", "client", "g", "settings", "full", "sets", "sq", "x", "rs", "sync", "http", "sim", "fs", "ss", "o", "session", "ssl", "su", "self", "sf", "ns", "ls", "sg", "ms", "js"], "block": ["image", " bl", "mem", "buffer", "frame", "type", " arr", " chunk", "bl", "buf", "byte", "blocks", " blocks", "output", "out", "size", " Block", "bc", " BL", "obj", "data", "arr", "Block", "record", "MODE", "BL"], "mb_x": ["mb_z", "mbxy", "mb00base", "mp_on", "amp00y", "mb33xs", "mb00y", "mb_ey", "eb_x", "mb00ey", "lim_x", "mb00name", "eb_y", "mb67z", "mb_X", "mbamexs", "eb_wx", "eb_height", "amp_size", "mb00x", "amp00x", "mb_size", "limameey", "mp_wy", "mp_x", "MB_X", "mb_tx", "mb_wx", "mb33name", "mb_wy", "MB_x", "lim_xs", "limamename", "mb00xs", "lim_name", "mb67y", "mp_tx", "limamex", "mb33x", "mb00size", "lim_ey", "mp_z", "mb67wy", "amp00size", "mp_w", "amp_y", "mb_on", "amp_base", "limamexs", "mbxxx", "mb_w", "mbameey", "mb_width", "mp_y", "amp_x", "mb67x", "mb_xs", "mb_height", "MB_xx", "mbxX", "mb_xx", "mbamename", "mb_name", "mb_base", "mbxx", "mbamex", "mp_width", "mb33ey", "amp00base", "MB_y"], "mb_y": ["mb_z", "mb___yo", "mb08yd", "mb_yi", "mn_y", "mb_ey", "mm_x", "kb_i", "sm_iy", "mn_yd", "sm67yd", "mb___sy", "mb___x", "kb_sy", "sm67Y", "mb08Y", "mp_ya", "mb__y", "mb_i", "sm67iy", "mb_dy", "mp_x", "mb67yd", "sm_Y", "mn_x", "sm_y", "kb_ey", "mb_yd", "mm_sy", "mb___y", "mm_y", "mb_yl", "mb67iy", "mp_yl", "mb_Y", "mp_vy", "mb67y", "mb67Y", "mb_ya", "sm67y", "mb__x", "mb__vy", "amb_dy", "mp_z", "mb_yo", "sm_yd", "amb_yo", "mb08iy", "mb_sy", "amb_yi", "mm_yo", "kb_y", "mb__yl", "mb_vy", "mp_y", "amb_y", "mn_z", "mb08y", "mb_iy"], "dct_linesize": ["dct_codesizes", "dct_codesize", "dct_filesize", "dct_linesiz", "dct_codessize", "dct_filesizes", "dct_pagesize", "dct_pagesiz", "dct_pagesizes", "dct_pagessize", "dct_linesizes", "dct_filessize", "dct_filesiz", "dct_linessize", "dct_codesiz"], "dct_offset": ["dCT_offset", "dCT_auto", "dct_padding", "dCT_pos", "dCT_padding", "dctppos", "dctpoffset", "dct_auto", "dctppadding", "dctpauto", "dct_pos"], "op_pix": ["op_cpik", "op_fpik", "op_fpix", "op_fpixel", "op_vpow", "op_vpix", "op_pik", "op_cpow", "op_vpixel", "op_cpix", "op_vpik", "op_pixel", "op_cpixel", "op_pow", "op_fpow"], "op_qpix": ["op_sqwpius", "op_sqwpx", "op_sqpx", "op_qpx", "op_qnpixels", "op_sqpixels", "op_sqwpix", "op_qwpixels", "op_qpixels", "op_qpius", "op_sqpix", "op_qwpx", "op_qnpix", "op_qvpixels", "op_qvpix", "op_qwpix", "op_qvpx", "op_sqwpixels", "op_sqpius", "op_qnpius", "op_qvpius", "op_qnpx", "op_qwpius"], "wrap": ["write", "late", "close", "box", "step", "use", "rx", "window", "count", "pad", "xxxx", "replace", "cut", "rap", "cover", "wave", "xxx", "lace", "fold", "align", "fw", "format", "grow", "end", "weight", "rw", "shift", "work", "wy", "cap", "w", "wb", "force", "word", "length", "margin", "wa", "win", "move", "html", "wx", "quad", "space", "style", "patch", "run", "grid", "wrapper", "comb", "sp", "live", "edge", "wait", "zip", "quote", "scroll", "wind", "code", "wra", "max", "start", "lock", "sw", "play", "crop", "span", "read", "split", "coord", "strip"], "xy": ["kid", "step", "tw", "offset", "lim", "yt", "f", "rx", "xe", "rh", "hide", "exe", "mie", "py", "key", "opt", "fo", "pos", "axy", "yy", "gb", "xxxx", "biz", "yo", "px", "note", "no", "try", "pie", "xxxxxxxx", "iter", "gy", "num", "cat", "val", "loc", "zx", "zh", "uv", "xxx", "index", "flat", "pipe", "cgi", "y", "xp", "tiny", "phy", "dy", "lite", "dom", "wy", "home", "w", "wb", "die", "xb", "dim", "proxy", "ie", "quick", "xf", "html", "wx", "lat", "quad", "tmp", "comb", "ele", "gone", "live", "tight", "zip", "dj", "x", "layout", "fit", "code", "route", "xx", "slot", "photo", "gay", "vp", "coord", "mid", "lo", "cue", "XY"], "v": ["iv", "cover", "x", "w", "ve", "cv", "h", "p", "ev", "vert", "tv", "val", "f", "uv", "vv", "b", "vr", "n", "c", "o", "e", "ver", "y", "l", "vi", "vt", "va", "u", "vp", "value", "size", "V", "lv", "k", "i", "m", "t", "vs", "g", "z", "sv", "var"]}}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n", "idx": 21794, "substitutes": {"ram_addr": ["ram2addr", "gram_hop", "ram2ad", "gram_host", "ram64offset", "gram_ref", " ramacaddr", "gram_attr", "ramfaddr", "ramacaddress", "ram_ad", "ram_host", " ramacsize", " ram_size", "gram_addr", "ramfhop", "ram64addr", "ram__hop", "ram_offset", "ram64address", "gram_address", "ram_nr", "ramfaddress", "ram2ref", "ram__addr", "ram_ref", "ram__host", "gram_ad", "ram_attr", "ramacoffset", "ram_hop", " ram_address", " ramacoffset", "gram_align", "ramxaddress", " ramacaddress", "ramamaddr", "ramacsize", "ramamaddress", "rampaddress", "rampaddr", "ramxalign", "ram_size", "ram64size", "ram2address", "rampad", "ram_address", "ram__address", "rampref", "ramxnr", "ramfhost", "ramamnr", "gram_nr", "ram_align", " ram_offset", "ramxaddr", "ramamattr", "ramacaddr"], "page": ["write", "item", "image", "collection", "line", "x", "www", "layout", "pe", "cache", "gp", "p", "row", "section", "current", "site", "block", "core", "ge", "plus", "load", "Page", "pg", "blog", "document", "pc", "order", "feed", "content", "see", "ae", "per", "pp", "next", "view", "index", "c", "parent", "age", "lp", "entry", "e", "module", "result", " Page", "pb", "pl", "instance", "model", "child", "data", "peer", "list", "server", "record", "large", "group", "skip", "node", "inc", "comment", "new", "pool"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int decode_i_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n    return 0;\n\n}\n", "idx": 21796, "substitutes": {"v": ["iv", "w", "version", "ve", "ev", "cv", "p", "nv", "h", "lc", "tv", "vert", "val", "rev", "j", "var", "f", "s", "uv", "q", "inv", "vv", "ov", "vm", "b", "gu", "n", "volt", "c", "vol", "vic", "o", "dev", "ver", "l", "vt", "vi", "va", "ou", "av", "u", "vp", "vu", "value", "V", "conv", "d", "video", "vim", "lv", "k", "i", "vc", "m", "t", "vs", "vd", "g", "sv", "serv"], "gb": ["bm", "cfg", "ui", "gg", "gom", "gp", "gc", "gm", "wm", "gui", "bb", "gy", "bo", "gh", "tm", "gam", "ge", "db", "buff", "cli", "pm", "gnu", "bg", "gpu", "pc", "nb", "bf", "gd", "b", "gin", "gu", "kw", "GB", "ga", "cb", "sb", "storage", "gru", "mb", "cgi", "gae", "kb", "hub", "agg", "bc", "cca", "usb", "gs", "abb", "ci", "ctx", "gz", "bn", "Gb", "ged", "vg", "gio", "lib", "gi", "g", "sg", "rb", "rg"], "pqindex": ["pchnum", "pvdesign", "pchsize", "Pqindex", "pqlindex", "pqasearch", "pqlpage", "pqaindex", "ppcount", "ppqlpage", "piqdate", "pqoffset", "pqldate", "jpqsearch", "pqucount", "pqlnumber", "pkaddress", "Pqaddress", "pqcount", "jpquindex", "piqnumber", "pqadesign", "ppindex", "pqaddress", "pqusearch", "ppqlindex", "pqaoffset", "PkIndex", "Pkaddress", " pqoffset", "pqlevel", "jpquoffset", "pckindex", "pqudesign", " pQoffset", "jpqudesign", "jpqindex", "ppqnumber", "pipdate", "dqcount", "pqpage", "pipnumber", "pvindex", "ppqlnumber", "Pkindex", "ppqldate", "pchindex", "pdqindex", "pplevel", "dquindex", " pQsize", "pqdesign", "PqIndex", "pdqoffset", "dqucount", "pckcount", "pqsize", "pcklevel", "ppqindex", "pquIndex", "dqlevel", "jpqoffset", "jpqusearch", "pipindex", "pquindex", "pdqsize", "pkIndex", "pqnumber", " pQindex", "pquaddress", "pqsearch", "pkindex", "piqpage", "pqIndex", "pqdate", "pvoffset", "jpqdesign", "ppqpage", "pippage", "pquoffset", "dqindex", "pvsearch", "pqnum", "pQnum", "pchoffset", "piqindex", "pQoffset", " pqsize", "pQindex", "pdqnum", " pQnum", "ppqdate", "pqulevel", "dqulevel", "pQsize", " pqnum"]}}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n", "idx": 21820, "substitutes": {"s": ["sets", "S", "south", "rs", "phys", "p", "sym", "sync", "http", "bis", "ses", "ds", "f", "ssh", "is", "ss", "si", "b", "c", "sb", "o", "e", "r", "service", "services", "es", "ops", "ssl", "i", "m", "os", "t", "ns", "g", "js"], "mmcfg_addr": ["mmconfig_ad", "mmcfg_ord", "mmcfgIPoffset", "mmconfig_ord", "mmcfg_src", "mmcfg67addr", "mmconfig_src", "mmcfg67ord", "mmcfg_ad", "mmconfig_address", "mmcfgIPaddr", "mmcfgIPad", "mmcfg_offset", "mmconfig_offset", "mmcfg67address", "mmcfgIPaddress", "mmconfig_addr", "mmcfg67src", "mmcfg_address"], "val": ["VAL", "def", "eval", "x", "al", "enc", "mem", "local", "el", "elt", "ret", "valid", "bl", "b", "aval", "v", "seq", "bin", "vol", "base", "slot", "pt", "ind", "fat", "ref", "key", "sel", "vals", "value", "split", "data", "arr", "count", "Val", "sl", "ld", "all"], "len": ["line", "lin", "lc", "en", "Len", "lf", "num", "lim", "ln", "le", "el", "elt", "length", "f", "lan", "v", "n", "seq", "fl", "l", "end", "size", "li", "pos", "split", "data", "lif", "count", "L", "id", "lo", "fin", "lon", "ls", "z", "ld"], "pci_dev": ["pci__dev", "pci0device", "pciacdata", "pci0dev", "pki_ev", "pcinacdevice", "pki_dev", "pci0debug", "pki_device", "pcinacdev", "pci0rad", "pci_Dev", "pcinacdef", "pci_def", "pcin_dev", "pai_rad", "pcinacdata", "pci__def", "pci_debug", "pai_dev", "pci_device", "pai_device", "pciacdef", "pci__Dev", "pcin_data", "pci_rad", "pci2dev", "pci2ev", "pci_ev", "pci_data", "pai_debug", "pki_def", "pci__ev", "pci2Dev", "pki_Dev", "pcin_device", "pciacdev", "pciacdevice", "pcin_def", "pci2def"]}}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n", "idx": 21822, "substitutes": {"s": ["settings", "ins", "sets", "sq", "ks", "S", "x", "rs", "lines", "p", "sym", "less", "aws", "ims", "site", "sync", "us", "se", "ats", "css", "als", "ses", "ds", "f", "words", "xs", "as", "ions", "is", "fs", "ss", "ts", "b", "v", "si", "a", "c", "spec", "ps", "hs", "o", "sb", "e", "cs", "ads", "l", "args", "services", "qs", "ans", "parts", "es", "outs", "ops", "features", "ssl", "gs", "i", "self", "m", "sys", "conf", "t", "os", "ns", "ls", "g", "ms", "sv", "js"], "n": ["nor", "x", "w", "p", "h", "en", "num", "nn", "j", "f", "ni", "nb", "b", "len", " N", "c", "o", "nl", "nr", "e", "min", "l", "r", "conn", "y", "nt", "N", "u", "node", "ne", "d", "nos", "k", "i", "m", "t", "nc", "ns", "g", "z", "all", "sn"], "bit_index": ["boot_range", "bit_Index", "bitzend", "dataklength", "byte_index", "bit_ind", "bits_index", " bit_Index", "boot_index", "byte_len", "bitzindex", "data_index", "bit_limit", "bit_width", " bit_ind", "bitzind", "bitkindex", "byte_width", "bit_length", "bit_range", "bitklength", "bit_position", "data_position", "datakposition", "bits_limit", "bitflen", "bitfwidth", "data_length", "bit_value", " bit_width", "bitfvalue", "bit_num", "bit_end", "bits_length", "boot_ind", "boot_end", "bitfindex", "bitzrange", "bit_len", "dataknum", "bits_width", "byte_value", "bitknum", "bitkposition", "datakindex", "data_num"], "buf": ["desc", "home", "cap", "br", "cf", "doc", "box", "wb", "cv", "cache", "uf", "src", "alloc", "queue", "img", "buff", "buffer", "loc", "cur", "uc", "func", "cmd", "feed", "len", "raw", "seq", "header", "parent", "cb", "cas", "vec", "path", "ab", "fd", "batch", "av", "bu", "dest", "brace", "ctr", "fam", "off", "bag", "conv", "bc", "rc", "data", "comb", "ctx", "rb", "pool"]}}
{"project": "FFmpeg", "commit_id": "bf252f7f6fa9c79743242f3efdd30827c97407b4", "target": 0, "func": "static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    char *str = NULL;\n\n    int size;\n\n    uint16_t str_size;\n\n\n\n    if (c->itunes_metadata) {\n\n        int data_size = get_be32(pb);\n\n        int tag = get_le32(pb);\n\n        if (tag == MKTAG('d','a','t','a')) {\n\n            get_be32(pb); // type\n\n            get_be32(pb); // unknown\n\n            str_size = data_size - 16;\n\n        } else return 0;\n\n    } else {\n\n        str_size = get_be16(pb); // string length\n\n        get_be16(pb); // language\n\n    }\n\n    switch (atom.type) {\n\n    case MKTAG(0xa9,'n','a','m'):\n\n        str = c->fc->title; size = sizeof(c->fc->title); break;\n\n    case MKTAG(0xa9,'A','R','T'):\n\n    case MKTAG(0xa9,'w','r','t'):\n\n        str = c->fc->author; size = sizeof(c->fc->author); break;\n\n    case MKTAG(0xa9,'c','p','y'):\n\n        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;\n\n    case MKTAG(0xa9,'c','m','t'):\n\n    case MKTAG(0xa9,'i','n','f'):\n\n        str = c->fc->comment; size = sizeof(c->fc->comment); break;\n\n    case MKTAG(0xa9,'a','l','b'):\n\n        str = c->fc->album; size = sizeof(c->fc->album); break;\n\n    }\n\n    if (!str)\n\n        return 0;\n\n    get_buffer(pb, str, FFMIN(size, str_size));\n\n    dprintf(c->fc, \"%.4s %s\\n\", (char*)&atom.type, str);\n\n    return 0;\n\n}\n", "idx": 21828, "substitutes": {"c": ["C", "dc", "mc", "cf", "cy", "cl", "cit", "cv", "xc", "p", "lc", "cu", "enc", "cache", "cd", "current", "cc", "co", "ac", "ce", "f", "config", "cus", "s", "cr", "pc", "coll", "uc", "cur", "anc", "b", "sc", "ct", "fc", "cod", "con", "com", "e", "cs", "l", "ch", "u", "cm", "d", "bc", "ic", "cp", "tc", "rc", "cell", "ctx", "vc", "k", "m", "ci", "t", "cmp", "nc", "cn", "context", "g", "z", "rec", "ec", "icc"], "pb": ["lb", "bm", "pd", "pa", "wb", "jp", "p", "lc", "platform", "ib", "db", "xb", "proc", "pg", "plain", "pc", "uc", "bf", "mp", "bh", "fc", "pp", "lab", "pro", "lp", "sb", "bps", "bp", "cb", "ab", "prot", "fp", "py", "plugin", "pl", "tp", "bc", "PB", "rob", "cp", "api", "tc", "ctx", "abb", "cpp", "gb", "fb", "bs", "dp", "eb", "wp", "rb"], "atom": ["typ", "element", "item", "doc", "orb", "prop", "bb", "mol", "sym", "tm", "num", "ac", "http", "kat", " com", "config", "article", "object", "carbon", " ac", "xml", "chem", "chrom", "comm", "html", "temp", "orbit", "com", "acc", "entity", "mag", "module", "atomic", "operator", " bom", "cm", "tom", " Atom", "bc", "instance", "car", "attr", "tc", "obj", "om", "url", "species", "container", "m", "param", "abc", "mom", "component", "term", "tag", "canon", "node", " atoms", "cell", "op"], "str": ["st", "inst", "br", "expr", "gr", "iter", "doc", "text", " Str", "empty", "lc", "enc", "code", "buffer", "name", "status", "ini", "fr", "cr", "sr", "coll", "bl", "init", "strings", "len", "uri", "temp", "ar", "spec", "err", "e", "style", "r", "hr", "STR", "u", "key", "ctr", "Str", "tr", "read", "pos", "url", "data", "obj", "arr", "input", "ptr", "strip", "unit", "dr", "i", "txt", "orig", "sp", "stri", "exec", "g", "sl", "inner", "ext", "bytes"], "size": ["time", "shape", "capacity", "use", "si", "Size", "SIZE", "sum", "storage", "pos", "count", "score", "empty", "en", "name", "loc", "go", "address", "len", "index", "e", "args", "ize", "weight", "sized", "grade", "shift", "large", "ui", "enc", "word", "length", "err", "style", "small", "esc", "external", "unit", "ci", "g", "z", "sn", "full", "x", "sync", "code", "strength", "complete", "type", "max", "scale", "send", "password", "handle", "speed"], "str_size": ["data_width", "str_set", "data_sized", "data_SIZE", " str_name", " str_set", "str_SIZE", " str_width", " str_length", "data_length", "data_size", "str_length", "str_sized", "data_len", "str_width", "str_name", "str_len", " str_len"]}}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n", "idx": 21836, "substitutes": {"ctx": ["dc", "mc", "support", "cfg", "cf", "cms", "console", "cl", "gc", "cv", "xc", "p", "cu", "lc", "css", "cc", "co", "loc", "ce", "cli", "config", "cus", "cr", "pc", "Context", "anc", "cmd", "sc", "git", "ct", "mac", "c", "fw", "ck", "ca", "cas", "cb", "cs", "tx", "conn", "hw", "cal", "connection", "cm", "wcs", "qa", "bc", "cp", "tc", "rc", "cca", "vc", "cpp", "ci", "pkg", "ctrl", "cmp", "nc", "context", "exec", "cn", "comp"], "errp": ["Erp", "erpc", "Err", " errpc", "errr", " errr", "Erfp", "errfp", "erfp", "erp", " errfp", "errpc", "Erpc", "err"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n\n                                        int buf_size, AVSubtitle *sub)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n\n\n    DVBSubRegion *region;\n\n    DVBSubRegionDisplay *display;\n\n    AVSubtitleRect *rect;\n\n    DVBSubCLUT *clut;\n\n    uint32_t *clut_table;\n\n    int i;\n\n    int offset_x=0, offset_y=0;\n\n\n\n    sub->rects = NULL;\n\n    sub->start_display_time = 0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    sub->format = 0;\n\n\n\n    if (display_def) {\n\n        offset_x = display_def->x;\n\n        offset_y = display_def->y;\n\n    }\n\n\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects <= 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,\n\n                                  sizeof(*sub->rects));\n\n    if (!sub->rects)\n\n        return AVERROR(ENOMEM);\n\n\n\n    i = 0;\n\n\n\n    for (display = ctx->display_list; display; display = display->next) {\n\n        region = get_region(ctx, display->region_id);\n\n        rect = sub->rects[i];\n\n\n\n        if (!region)\n\n            continue;\n\n\n\n        rect->x = display->x_pos + offset_x;\n\n        rect->y = display->y_pos + offset_y;\n\n        rect->w = region->width;\n\n        rect->h = region->height;\n\n        rect->nb_colors = 16;\n\n        rect->type      = SUBTITLE_BITMAP;\n\n        rect->pict.linesize[0] = region->width;\n\n\n\n        clut = get_clut(ctx, region->clut);\n\n\n\n        if (!clut)\n\n            clut = &default_clut;\n\n\n\n        switch (region->depth) {\n\n        case 2:\n\n            clut_table = clut->clut4;\n\n            break;\n\n        case 8:\n\n            clut_table = clut->clut256;\n\n            break;\n\n        case 4:\n\n        default:\n\n            clut_table = clut->clut16;\n\n            break;\n\n        }\n\n\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n        if (!rect->pict.data[1]) {\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n\n        if (!rect->pict.data[0]) {\n\n            av_free(rect->pict.data[1]);\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n\n\n        i++;\n\n    }\n\n\n\n    sub->num_rects = i;\n\n\n\n#ifdef DEBUG\n\n    save_display_set(ctx);\n\n#endif\n\n\n\n    return 1;\n\n}\n", "idx": 21841, "substitutes": {"avctx": ["avalctrl", "avalcontext", "avalcli", "amcli", "avctrl", "avalctx", "AVcli", "verctrl", "avcontext", "verctx", "amctx", "evctrl", "verconn", "avconn", "amcontext", "AVctx", "avcli", "evconn", "evctx", "AVcontext", "vercontext", "AVctrl", "amctrl", "AVconn", "evcontext"], "buf": ["br", "box", "cv", "cache", "uf", "alloc", "src", "queue", "mem", "block", "img", "buff", "buffer", "proc", "cmd", "seq", "cb", "vec", "batch", "ref", "conv", "port", "rc", "conf", "map", "rb", "pool"], "buf_size": ["buf_small", "buf_len", "buf8size", "buf8len", " buffer8size", " buffer_size", " buffer8small", " buffer8len", " buffer_len", " buffer_small", "buf8small"], "sub": ["shape", "match", "app", "hide", "sb", "sum", "ab", "user", "pre", "pb", "py", "ref", "conf", "form", "lib", "ubs", "comment", "ext", "desc", "part", "src", "section", "loc", "public", "address", "config", "um", "sc", "b", "hub", "sel", "builder", "sup", "pl", "summary", "child", "input", "abc", "slice", "project", "home", "rub", "children", "text", "dim", "func", "uc", "feed", "ub", "submit", "build", "small", "client", "server", "pub", "new", "full", "image", "Sub", "queue", "block", "http", "type", "sim", "reg", "search", "super", "plugin", "split", "rob", "job", "sing", "trans", "exec", "this", "sec", "remote"], "ctx": ["ha", "cfg", "cf", "cms", "sq", "cl", "cv", "xc", "src", "lc", "cu", "sync", "cc", "que", "buff", "loc", "cli", "config", "ocr", "sci", "uc", "Context", "anc", "cmd", "sc", "git", "media", "fc", "mac", "kw", "c", "utils", "ck", "ca", "cas", "cb", "storage", "fw", "cs", "tx", "conn", "kb", "chan", "fp", "hub", "cm", "wcs", "bc", "qa", "cp", "progress", "rc", "data", "cca", "concept", "ci", "pkg", "ctrl", "cmp", "client", "lib", "pub", "context", "cam", "cn", "exec", "comp"], "display_def": ["screenerdefinition", "displayaldef", "display_name", "display_define", "displayaddef", "region_def", "win_define", "displayacdefine", "displayitymanager", "regionaddel", "screen_conf", "displayWname", "screenerdef", "processWmanager", "displayabledist", "process_manager", "display_config", "displayaldesign", "displayJdesign", "displayerconf", "display_dist", "displayitydef", "displayWDef", "displayerdefault", "displayername", "displayabledef", "displayalconfig", "displayacdefault", "win_default", "displayADdev", "region_config", "displayaldel", "process_def", "display_Def", "winADdefault", "displayerdefinition", "displayaddesign", "regionadconfig", "process_name", "displayalconf", "displayADdefault", "display_del", "displayJdel", "process_Def", "processWname", "winADdev", "screenerdist", "winADdefine", "displayableconf", "displayaldist", "region_del", "displayabledefinition", "regionaddef", "win_dev", "processWDef", "winADdef", "displayaddel", "display_default", "processWdef", "screenerconf", "displayJdef", "displayityDef", "displayacdef", "displayerdefine", "screen_def", "displayJconfig", "displayerdist", "region_design", "displayWdef", "displayerdev", "display_design", "displayityname", "displayacdev", "display_dev", "screen_definition", "win_def", "regionaddesign", "displayerDef", "display_definition", "displayermanager", "displayerdef", "displayADdefine", "displayaldefinition", "screen_dist", "display_manager", "displayadconfig", "displayWmanager", "display_conf", "displayADdef"], "region": ["desc", "script", "update", "shape", "image", "stage", "cache", "gallery", "section", "contract", "production", "area", "location", "route", "local", "loc", "dim", "address", "config", "definition", "description", "pattern", "gap", "REG", "content", "report", "view", "theme", "feat", "reg", "range", "shadow", "Region", "module", "zone", "manager", "radius", "format", "output", "dist", "recent", "plugin", "rule", "summary", "port", "layer", "progress", "memory", "scope", "texture", "transfer", "country", "component", "slice", "feature", "record", "large", "division", "tag", "artist", "resource", "project", "remote"], "display": ["script", "full", "update", "debug", "image", "match", "console", "player", "stage", "cache", "gui", "section", "fe", "host", "production", "block", "use", "date", "process", "dim", "public", "address", "config", "description", "ini", "app", "disc", "REG", "feed", "hide", "device", "mor", "report", "view", "rest", "index", "bin", "position", "orn", "reg", "shadow", "render", "draw", "screen", "play", "service", "roy", "run", "present", "dist", "show", "output", "rem", "domain", "be", "summary", "profile", "role", "destroy", "browser", "record", "component", "feature", "large", "remote", "Display"], "rect": ["shape", "thin", "image", "att", "box", "round", "test", "section", "contract", "butt", "font", "block", "area", "rt", "loc", "dim", "config", "object", "nav", "coll", "init", "device", "dir", "view", "lat", "feat", "pt", "draw", "patch", "tile", "col", "tri", "format", "ref", "crop", "point", "str", "post", "tr", "port", "layer", "progress", "Rect", "coord", "rc", "attr", "pull", "input", "ptr", "dr", "texture", "client", "RECT", "slice", "record", "large", "feature", "act", "tag", "map", "spec", "dom", "project", "remote", "ext"], "clut": ["clunt", "clur", "klutt", "decut", "klunt", " clutor", " cluton", "plute", "klot", "window", "slute", "cluto", "lcaut", "celutor", " clur", "celur", "celut", " clunt", "all", "clute", "bytes", "Clur", "clob", "plaut", "slant", "cluton", "clutor", "img", "Clott", "_", "Clut", "flut", "acluto", "lcuto", "flatur", "aclut", "decuton", "slutt", "aclaut", "klut", " clob", "flaut", "plur", "Clutor", " clatur", "flant", "slaut", " cluto", " cluts", "klob", "kluton", "fluts", "plunt", "plot", "cluts", "clott", "slur", "clatur", " claut", "slunt", "flob", "decuto", "g", "celott", "flunt", "aclutt", "plut", "klatur", "type", "lcut", "pluto", " clant", "clant", " clute", "claut", "slut", "clot", "clutt", "kluts", " clot", "obj", "kluto", " clutt", " clott", "plutt", "this", "decatur", "lcutt"], "clut_table": ["clut_db", "clut_level", "clut2index", "cluts_type", "clut2tree", "clutttype", "cluts_table", "clutt_level", "clit2index", "clute_tab", "clut_stable", "clut_index", "clut___tab", "clute_table", "cluts_cache", "clut_type", "clit2table", "clut___stable", "cluttlevel", "clute_family", "clut___family", "clit_tree", "clit_index", "cluts_db", "clut2list", "clut_tree", "clut_list", "clutt_cache", "clut_tab", "clutt_table", "clit_table", "clut___table", "clit_list", "clute_stable", "clutt_type", "clut2table", "clut_cache", "cluttcache", "clutttable", "clut_family", "clit2tree", "clit2list"], "i": ["ti", "ii", "ui", "abi", "qi", "x", "I", "p", "phi", "num", "di", "ri", "j", "f", "ai", "ini", "ni", "start", "si", "b", "pi", "n", "index", "c", "ind", "y", "l", "vi", "xi", "u", "connection", "uni", "fi", "li", "d", "iu", "mini", "hi", "mi", "ci", "ori", "gi", "bi", "ip"]}}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "static QUANT_FN(pvq_encode_band)\n\n{\n\n    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,\n\n                               lowband_out, level, gain, lowband_scratch, fill, 1);\n\n}\n", "idx": 21851, "substitutes": {}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n\n\t\t\t     ram_addr_t size,\n\n\t\t\t     ram_addr_t phys_offset)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - nothing to be done. */\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 21863, "substitutes": {"start_addr": ["start_pad", "start67oa", "end_attr", "end_pad", "startPattr", "start_attr", "startjaddr", "end_loc", "end_adr", "startingaddr", "start00addr", "start_point", "start__adr", "startjattr", "start__range", "end_point", "start6address", "start_offset", "end_range", "startameaddr", "startqaddress", "start___attr", "start6addr", "start_coord", "end_off", "start64address", "end_device", "start6pad", "start_offer", "startjcoord", "start67address", "end_sta", "startingaddress", "start_ptr", "end_hop", "end_ord", "start6md", "start6align", "start_oa", "end_ptr", "start_host", "start___addr", "end_dr", "start_address", "end_oa", "start67addr", "start58point", "startjaddress", "startxaddr", "start_range", "start_device", "startPaddress", "startqafi", "start_md", "startfuloffset", "start_afi", "end_nr", "start___address", "start00offer", "start_dr", "startxoa", "end_offer", "end_conn", "end_align", "start6nr", "startjhost", "start__address", "start00address", "start_loc", "end_node", "startamedevice", "start58address", "startamenode", "startqdevice", "start64conn", "end_coord", "startameaddress", "startxaddress", "start64device", "startfulsta", "start67off", "start_sta", "end_host", "startfuladdr", "startjhop", "start_nr", "start_off", "end_offset", "start_work", "startPpad", "end_work", "start67work", "startxoff", "start67offer", "start58addr", "startqaddr", "end_addr", "start_node", "startqnode", "start_adr", "end_afi", "end_md", "start_ord", "start_align", "startfuladdress", "end_address", "startPaddr", "startPloc", "start00work", "startingadr", "start_hop", "start58offer", "startPoffset", "startqattr", "start64addr", "start64ptr", "startingrange", "start___loc", "start__addr", "startqptr", "start_conn"], "size": ["time", "z", "ny", "capacity", "shape", "timeout", "ui", "full", "x", "empty", "izes", "zero", "en", "code", "use", "core", "offset", "name", "loc", "address", "length", "mode", "now", "eng", "max", "start", "security", "body", "si", "Size", "fee", "len", "uri", "scale", "SIZE", "parent", "c", "storage", "sum", "iz", "activity", "sh", "ize", "grow", "six", "small", "esc", "mini", "member", "rc", "memory", "data", "count", "sized", "unit", "shift", "i", "ci", "speed", "large", "g", "sec", "sn"], "phys_offset": ["phys_padding", "physical_slot", "memory_size", "phys64size", "memory_length", "mem_position", "physical_size", "memory_format", "hyper_alt", "phys64slot", "phys67pos", "memory_address", "mem_alias", "phys_alias", "phys64offset", "phys_length", "mem_addr", "physical_addr", "phys_set", "memory_error", "physacerror", "phys_slot", "pg_offset", "phys_error", "hyper67location", "phys67balance", "phys1addr", "pg_balance", "mem_off", "phys1offset", "hyper67offset", "phys_format", "phys67offset", "phys64length", "phys_address", "physacalt", "phys67off", "phys_pos", "phys_balance", "phys1size", "phys67alt", "hyper_location", "physacsize", "physlformat", "phys67length", "hyper_offset", "pg_size", "physladdress", "physacset", "pg_pos", "phys_off", "phys67size", "physaclength", "memory_offset", "phys1slot", "phys67position", "phys_addr", "physaclocation", "phys67location", "hyper67alt", "memory_set", "phys_position", "physloffset", "physlsize", "phys_location", "mem_size", "memory_slot", "mem_offset", "hyper67length", "phys_size", "physacoffset", "phys_alt", "physical_offset", "mem_padding", "hyper_length"], "s": ["settings", "states", "sets", "S", "sq", "south", "w", "secondary", "p", "sym", "ls", "current", "sync", "site", "ses", "ds", "f", "sim", "stat", "an", "xs", "request", "is", "fs", "b", "ts", "si", "v", "ss", "state", "n", "c", "utils", "spec", "sie", "ps", "o", "sb", "e", "serv", "space", "r", "args", "service", "session", "services", "sh", "es", "d", "changes", "ssl", "gs", "i", "self", "m", "sys", "os", "t", "conf", "sf", "server", "this", "g", "ns", "sg", "set", "new", "js"], "mem": ["lay", "ym", "bm", "my", "man", "mat", "cache", "ib", "lim", "app", "rm", "im", "fun", "com", "sm", "Mem", "sum", "ref", "py", "gen", "ame", "mi", "gb", "dem", "em", "lib", "ha", "imm", "cl", "ge", "num", "mo", "loc", "go", "msg", "pm", "md", "um", "cmd", "mp", "mor", "mod", "mb", "cm", "rem", "memory", "child", "alt", "am", "mom", "large", "serv", "mc", "cfg", "home", "thin", "gm", "access", "tab", "tm", "buff", "dim", "wa", "vm", "own", "win", "move", "gram", "temp", "hw", "ph", "gem", "small", "ne", "member", "tem", "ctx", "m", "program", "g", "mon", "me", "new", "pool", "image", "nm", "ram", "bl", "mm", "mac", "bin", "reg", "slot", "conn", "session", "lam", "ann"], "old": ["full", "update", "item", "ore", "il", "thin", "home", "event", "p", "current", "original", "img", "num", "local", "buff", "val", "low", "j", "an", "f", "now", "and", "other", "Old", "init", "own", "rest", "new", "mod", "from", "build", "ind", "any", "style", "or", "handle", "prev", "pre", "py", "recent", "post", "small", "gen", "ne", "li", "initial", "hard", "diff", "hold", "obj", "past", "after", "in", "shared", "arg", "ext", "orig", "older", "cmp", "last", "slice", "lib", "add", "ori", "file", "ld", "OLD", "set", "inner", "get"], "err": ["req", "br", "ner", "res", " errors", "arm", "more", "aster", "f", "valid", "order", "rh", "wr", "ar", "dev", "kr", "py", "count", "dr", "conf", "act", "all", "inner", "var", "nor", "ler", "iter", "doc", "ev", "mr", "val", "loc", "go", "msg", "ef", "fer", "fr", "cr", " error", "len", "e", "ind", "arr", "Er", " er", "erg", "acer", "gr", "eor", "pr", "fe", "rar", "ln", "bug", "yr", "der", "error", "rr", "Error", "style", "later", "sys", "orig", "gz", "g", " Err", "new", "ise", "resp", "rage", "magic", "ir", "yer", "ah", "aaa", "ver", "conn", "found", "ee", "str", "self", "er", "last", "cry"]}}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889, "substitutes": {"opaque": ["opacity", "OPacity", "iopacle", "OPacle", "opatile", " opacle", "opacle", "OPatile", " opacity", "iopatile", "OPaque", " opatile", "iopaque", "iopacity"], "addr": ["part", "x", "src", "alloc", "pointer", "name", "offset", "ord", "type", "address", "mode", "start", "len", "fd", "amd", "ref", "off", "inter", "pos", "data", "ptr", "ost", "eth", "pad", "ad", "add", "Address"], "val": ["ul", "VAL", "x", "cl", "al", "alloc", "enc", "block", "valid", "bl", "b", "v", "len", "bin", "base", "reg", "slot", "tx", "byte", "vals", "value", "str", "data", "arr", "unit", "Val", "all"], "size": ["desc", "timeout", "empty", "izes", "block", "offset", "name", "type", "address", "length", "Size", " sizes", "len", "c", "SIZE", "from", " length", "ize", "small", "rc", "data", "unit", "large", "sec", "bytes"]}}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}", "idx": 21899, "substitutes": {"s": ["support", "settings", "S", "sq", "ks", "south", "rs", "p", "sym", "sync", "site", "sa", "se", "us", "ses", "ds", "sim", "f", "j", "sci", "fs", "is", "ss", "si", "ts", "native", "a", "n", "c", "spec", "ps", "sb", "e", "cs", "space", "l", "service", "session", "services", "qs", "sup", "es", "ssl", "gs", "i", "su", "os", "conf", "sys", "t", "sf", "sl", "ls", "sg", "ns", "sv", "g", "js"], "height": ["shape", "rank", "image", "x", "w", "layout", "h", "row", "high", "block", "depth", "distance", "length", "volume", "max", "gap", "Height", "view", "index", "padding", "align", "arrow", "build", "alpha", "y", "style", "window", "crop", "end", "hang", "size", "bottom", "pull", "resolution", "data", "pad", "top", "level", "angle", "stroke"]}}
{"project": "FFmpeg", "commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "target": 1, "func": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n", "idx": 21919, "substitutes": {"c": ["C", "mc", "dc", "cf", "cy", "cl", "gc", "x", "cit", "xc", "cache", "p", "lc", "cu", "enc", "cc", "co", "ac", "ce", "f", "config", "s", "coll", "pc", "cr", "uc", "cur", "sc", "b", "oc", "v", "ct", "fc", "n", "con", "o", "e", "cs", "l", "ch", "u", "cm", "d", "ic", "cp", "rc", "tc", "ctx", "vc", "self", "m", "ci", "t", "nc", "g", "z", "ec"], "buf": ["home", "cf", "br", "text", "cv", "cache", "uf", "alloc", "src", "queue", "tab", "block", "que", "bridge", "num", "buff", "buffer", "offset", "loc", "f", "config", "max", "uc", "cur", "cmd", "b", "v", "seq", "bin", "cb", "vec", "ab", "fd", "aux", "batch", "fp", "tmp", "pb", "end", "port", "bc", "ffff", "rc", "data", "count", "ctx", "uint", "gb", "fb", "cmp", "pub", "context", "rb", "pool"], "buf_size": ["queue_size", "buf_count", "buf_len", "buf_length", "queue_count", "queue_len", " buf_length", " buf_len"]}}
{"project": "FFmpeg", "commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "target": 1, "func": "static int hls_read_header(AVFormatContext *s)\n\n{\n\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n\n    HLSContext *c = s->priv_data;\n\n    int ret = 0, i;\n\n    int highest_cur_seq_no = 0;\n\n\n\n    c->ctx                = s;\n\n    c->interrupt_callback = &s->interrupt_callback;\n\n    c->strict_std_compliance = s->strict_std_compliance;\n\n\n\n    c->first_packet = 1;\n\n    c->first_timestamp = AV_NOPTS_VALUE;\n\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n\n\n    if (u) {\n\n        // get the previous user agent & set back to null if string size is zero\n\n        update_options(&c->user_agent, \"user-agent\", u);\n\n\n\n        // get the previous cookies & set back to null if string size is zero\n\n        update_options(&c->cookies, \"cookies\", u);\n\n\n\n        // get the previous headers & set back to null if string size is zero\n\n        update_options(&c->headers, \"headers\", u);\n\n\n\n        // get the previous http proxt & set back to null if string size is zero\n\n        update_options(&c->http_proxy, \"http_proxy\", u);\n\n    }\n\n\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = save_avio_options(s)) < 0)\n\n        goto fail;\n\n\n\n    /* Some HLS servers don't like being sent the range header */\n\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n\n\n    if (c->n_variants == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n    /* If the playlist only contained playlists (Master Playlist),\n\n     * parse each individual playlist. */\n\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n\n        for (i = 0; i < c->n_playlists; i++) {\n\n            struct playlist *pls = c->playlists[i];\n\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n\n                goto fail;\n\n        }\n\n    }\n\n\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n\n\n    /* If this isn't a live stream, calculate the total duration of the\n\n     * stream. */\n\n    if (c->variants[0]->playlists[0]->finished) {\n\n        int64_t duration = 0;\n\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n\n        s->duration = duration;\n\n    }\n\n\n\n    /* Associate renditions with variants */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *var = c->variants[i];\n\n\n\n        if (var->audio_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n\n        if (var->video_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n\n        if (var->subtitles_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n\n    }\n\n\n\n    /* Create a program for each variant */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *v = c->variants[i];\n\n        AVProgram *program;\n\n\n\n        program = av_new_program(s, i);\n\n        if (!program)\n\n            goto fail;\n\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n\n    }\n\n\n\n    /* Select the starting segments */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n\n    }\n\n\n\n    /* Open the demuxer for each playlist */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        AVInputFormat *in_fmt = NULL;\n\n\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->index  = i;\n\n        pls->needed = 1;\n\n        pls->parent = s;\n\n\n\n        /*\n\n         * If this is a live stream and this playlist looks like it is one segment\n\n         * behind, try to sync it up so that every substream starts at the same\n\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n\n         * all active streams within the first few seconds). This is not very generic,\n\n         * though, as the sequence numbers are technically independent.\n\n         */\n\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n\n            pls->cur_seq_no = highest_cur_seq_no;\n\n        }\n\n\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n\n        if (!pls->read_buffer){\n\n            ret = AVERROR(ENOMEM);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n\n                          read_data, NULL, NULL);\n\n        pls->pb.seekable = 0;\n\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n\n                                    NULL, 0, 0);\n\n        if (ret < 0) {\n\n            /* Free the ctx - it isn't initialized properly at this point,\n\n             * so avformat_close_input shouldn't be called. If\n\n             * avformat_open_input fails below, it frees and zeros the\n\n             * context, so it doesn't need any special treatment like this. */\n\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        pls->ctx->pb       = &pls->pb;\n\n        pls->ctx->io_open  = nested_io_open;\n\n\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n\n            goto fail;\n\n\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n\n            avformat_queue_attached_pictures(pls->ctx);\n\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n\n            pls->id3_deferred_extra = NULL;\n\n        }\n\n\n\n        if (pls->is_id3_timestamped == -1)\n\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n\n\n        /*\n\n         * For ID3 timestamped raw audio streams we need to detect the packet\n\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n\n         * on us if they want to.\n\n         */\n\n        if (pls->is_id3_timestamped) {\n\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n\n\n        /* Create new AVStreams for each stream in this playlist */\n\n        ret = update_streams_from_subdemuxer(s, pls);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n\n    }\n\n\n\n    update_noheader_flag(s);\n\n\n\n    return 0;\n\nfail:\n\n    free_playlist_list(c);\n\n    free_variant_list(c);\n\n    free_rendition_list(c);\n\n    return ret;\n\n}\n", "idx": 21925, "substitutes": {"s": ["settings", "sets", "S", "sq", "ks", "rs", "p", "sym", "aws", "sync", "site", "se", "ses", "ds", "f", "sec", "fs", "is", "ss", "ts", "si", "sc", "b", "a", "n", "spec", "sb", "o", "e", "cs", "y", "r", "l", "args", "service", "services", "qs", "sup", "es", "d", "ops", "ssl", "comments", "ctx", "gs", "m", "su", "os", "t", "sys", "sf", "conf", "server", "sl", "ns", "sg", "g", "sv", "js"], "u": ["ui", "ul", "ur", "ue", "hu", "uf", "p", "cu", "h", "uci", "us", "cli", "f", "gnu", "uv", "uid", "q", "uc", "ru", "b", "ut", "up", "a", "uri", "U", "o", "you", "e", "user", "l", "tu", "ou", "lu", "iu", "api", "tc", "uno", "eu", "su", "m", "null", "t", "client", "un", "util", "nu", "uu", "g", "universal", "mu"], "c": ["C", "dc", "mc", "cf", "cy", "cl", "xc", "cache", "p", "cu", "lc", "enc", "h", "cc", "co", "ac", "cat", "ce", "f", "cr", "pc", "coll", "uc", "cur", "sc", "b", "ct", "fc", "n", "con", "ca", "o", "com", "cb", "e", "cs", "l", "conn", "r", "col", "ch", "cm", "arc", "d", "bc", "cp", "ic", "ctx", "vc", "k", "ci", "conf", "t", "m", "client", "nc", "cn", "g", "this", "sec", "rec", "ec"], "i": ["ti", "ii", "ui", "my", "qi", "x", "I", "ix", "p", "h", "eni", "phi", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ni", "ie", "b", "si", "io", "pi", "n", "index", "uri", "o", "e", "y", "xi", "bi", "yi", "fi", "li", "mini", "iu", "in", "d", "hi", "id", "m", "ci", "t", "mi", "multi", "gi", "g", "z", "mu", "inner", "ip"], "pls": ["cols", "pln", " plp", "coli", "PLi", " Plz", " Plp", "plgs", "plp", " cli", "coln", " Pls", "pli", "PLn", " clz", "PLb", " clgs", " Pli", "plz", " pln", " plz", " cls", " pli", " Plgs", " Plb", "PLs", "plb", " plgs", " plb", "PLp"]}}
{"project": "FFmpeg", "commit_id": "8a9641a652ed1546fedfda22584f79d3d423096e", "target": 0, "func": "AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n\n{\n\n    AVBitStreamFilter *bsf = first_bitstream_filter;\n\n\n\n    while (bsf) {\n\n        if (!strcmp(name, bsf->name)) {\n\n            AVBitStreamFilterContext *bsfc =\n\n                av_mallocz(sizeof(AVBitStreamFilterContext));\n\n            bsfc->filter    = bsf;\n\n            bsfc->priv_data =\n\n                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n\n            return bsfc;\n\n        }\n\n        bsf = bsf->next;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21938, "substitutes": {"name": ["part", "time", "cap", "image", "x", "version", "label", "call", "block", "NAME", "word", "type", "names", "address", "none", "anc", "mask", "filter", "n", "parent", "base", "path", "alias", "search", "action", "space", "normal", "filename", "key", "value", "size", "layer", "data", "child", "scope", "ame", "id", "ext", "group", "package", "named", "prefix", "new", "Name"], "bsf": ["bscf", "besfac", "lsfac", "bisfe", "basfe", "csscf", "csf", "dsinf", "ksf", "resfac", "outsfs", "besfs", "bisf", "psf", "besrf", "alsfo", "csfc", "cssfac", "ssc", "lsc", "basf", "bsfac", "lsrf", "resfs", "dsfr", "ubsfr", "alsf", "outscf", "bsrf", "resf", "outsfac", "nsrf", "ubsf", "dsf", "bsc", "bsfo", "bisfr", "lsfr", "nsfp", "lsf", "lsfp", "basfx", "resfo", "nsfs", "bsfs", "opsf", "nsc", "lsfc", "opsinf", "lsfx", "cssf", "nsfr", "psfp", "bsfp", "lscf", "dsfe", "opsfe", "sscf", "lsfe", "ksfs", "ssf", "lsfs", "besfp", "bsfe", "ubsfc", "opsfr", "bsfr", "csfx", "bisinf", "psfs", "cssfs", "ksfp", "besfo", "outsf", "nsf", "alsfs", "cssfp", "nsfc", "bescf", "csfe", "bsfx", "alsfac", "kscf", "besf", "nscf", "pscf", "ssfs", "bsinf", "ubscf", "basfc"], "bsfc": ["alsfc", "bscf", "alscf", "rascf", "dsfe", "asfd", "sscf", "bfi", "usfc", "gsfc", "basfl", "bsfe", "bingfl", "bsfd", "asfe", "ssFC", "rasfi", "usFC", "ssfc", "bingcf", "rasFC", "asfc", "gsfe", "usfi", "basfi", "bcf", "dsfx", "uscf", "bsFC", "bfl", "bascf", "rasfc", "gsfp", "bsfi", "psfx", "alsfd", "ssfi", "dsfp", "ascf", "dsfc", "bsfx", "psfd", "psfc", "bingfc", "bingfi", "bsfl", "pscf", "bfc", "alsfe", "psfe", "psfp", "bsfp", "basfc", "gsfx"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957, "substitutes": {}}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n", "idx": 21958, "substitutes": {"bdrv": ["bdrw", "bdrib", " bdrV", "bstrv", "bgrv", "bders", "bdrV", "bderb", "bdriv", "bDRf", "bdc", "bdrif", "bgrc", " bdrs", " bdc", "bderf", "bdv", "bDRV", "bDRw", "bderv", "bDRc", "bgrw", "bDRb", "bstrf", "bstrV", "bdb", "bdris", " bdv", " bdrf", "bdrc", "bdrb", "bstrc", "bdw", " bdrb", "bdrs", "bgrb", " bdrw", "bdrf", "bDRv", " bdrc", " bdw", " bdb"], "index": ["comment", "loop", "element", "update", "condition", "part", "image", "match", "degree", "x", "row", "original", "sync", "site", "num", "date", "pointer", "val", "name", "info", "f", "length", "address", "option", "object", "xxx", "coll", "xx", "thread", "position", "path", "search", "ind", "e", "style", "page", "localhost", "module", "active", "key", "letter", "edit", "output", "connection", "point", "value", "ticket", "in", "weight", "instance", "diff", "append", "data", "input", "count", "i", "id", "unit", "number", "column", "Index", "level", "list", "slice", "success", "add", "node", "inc", "prefix"]}}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962, "substitutes": {"obj": ["po", "inst", "class", "orb", "src", "jp", "Object", "img", "elt", "j", "object", "init", "n", "next", "Obj", "adj", "bj", "o", "cb", "conn", "args", "tmp", "module", "active", "boot", "obb", "ref", "inter", "ob", "ops", "api", "bot", "ctx", "oa", "self", "os", "objects", "fn", "aj", "node", "op", "ext", "js"], "nf": ["nfx", "yncf", "ynfc", "Nfs", "cnfs", "cnf", "snfe", "Nfx", "ncf", "nnfx", "snfc", "unfe", "nfe", "cnfe", "ynf", "nnfs", "Nfc", "Nfe", "nfs", "nncf", "ync", "Nf", "cnc", " nfs", " ncf", "snfs", "Ncf", " nfx", "unc", "unf", " nfe", "cnfc", "uncf", "cncf", " nc", "snf", "nnf", "nc", "ynfe", "unfc"], "nfc": ["yncf", "ynfc", "Nfs", "ncf", "unfe", "nfe", "ynf", "Nfc", "Nfe", "nfs", "ync", "Nf", " nfs", " ncf", "Ncf", "unfs", "Nc", " nfe", "uncf", " nc", "nc", "ynfe", "unfc", "ynfs"]}}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 21967, "substitutes": {"args": ["params", "ks", "flags", "empty", "parse", "alloc", "options", "host", "call", "ac", "arms", "ras", "ds", "f", "config", "func", "stats", "init", "asm", "mac", "Args", "parser", "cs", "ams", "ports", "py", "lang", "parts", "ass", "arr", "gs", "ctx", "self", "arg", "sys", "conf", "array", "g"]}}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969, "substitutes": {"dev": ["dc", "req", "home", "debug", "br", "def", "ev", "w", "ve", "Dev", "test", "priv", "block", "dt", "di", "die", "disk", "fail", "name", "info", "proc", "app", "md", "driver", "valid", "device", "gu", "der", "state", "prov", "pro", "mod", "error", "prof", "ver", "serial", "user", "adv", "conn", "ch", "hw", "av", "sk", "boot", "kind", "sh", "dist", "dd", "d", "progress", "diff", "des", "sys", "conf", "development", "grad", "dem", "spec", "de", "comment", "rad", "serv"], "err": ["req", "acer", "nor", "ner", "gr", "mr", "rs", "cache", "irm", "test", "nil", "proc", "valid", "fr", "sr", "cr", "rh", "ir", " error", "ry", "der", "asm", "fee", " nil", "cer", "ar", "cb", "error", "rr", "Error", "r", "ch", "result", "ctr", "usr", "errors", "str", "fi", "progress", "Er", "arr", "phy", "dr", "sys", "conf", "er", "server", "lib", "spec", "rb", "aaa"], "s": ["south", "p", "less", "us", "se", "f", "si", "device", "a", "sb", "storage", "cs", "u", "gs", "i", "conf", "addr", "spec", "sv", "bytes", "_", "ses", "ds", "an", "none", "is", "b", "ts", "n", "ps", "hs", "e", "y", "args", "services", "parts", "os", "states", "S", "ks", "w", "sym", "h", "site", "func", "v", "state", "c", "r", "l", "service", "qs", "es", "m", "sys", "t", "server", "sl", "g", "z", "settings", "sets", "sq", "rs", "sync", "http", "request", "fs", "ss", "o", "session", "str", "uns", "d", "in", "ssl", "su", "self", "sf", "er", "ns", "ls", "sg", "js"], "x86_iommu": ["x86_uiommu", "x86_uiommui", "x86_kormus", "x86_iommur", "x86_uiormu", "x86_iompui", "x86_iommi", "x86_iomso", "x86_iomui", "x86_kommi", "x86_uiormo", "x86_iommui", "x86_iomsi", "x86_kommus", "x86_iompu", "x86_iormui", "x86_uiormui", "x86_iomur", "x86_iomsu", "x86_iomi", "x86_iormus", "x86_iommus", "x86_iomu", "x86_iommo", "x86_uiommur", "x86_kormi", "x86_iormu", "x86_kormo", "x86_kommu", "x86_iormur", "x86_iormi", "x86_iompo", "x86_iomo", "x86_kormu", "x86_iompur", "x86_uiommo", "x86_kommo", "x86_uiormur", "x86_iormo", "x86_iomus", "x86_iomsus"], "bus": ["machine", "Bus", "BUS", "class", "cache", "p", "bridge", "host", "block", "sync", "us", "di", "bit", "http", "bis", "ds", "proc", "f", "config", "driver", "devices", "fs", "pass", "b", "io", "device", "v", "bug", "c", "board", "base", "o", "serial", "l", "hw", "nt", "session", "service", "boot", "hub", "u", "connection", "fi", "port", "bc", "mount", "usb", "i", "self", "os", "conf", "bs", "lib", "this"]}}
{"project": "FFmpeg", "commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "target": 1, "func": "int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)\n\n{\n\n    DynBuffer *d = s->opaque;\n\n    int size;\n\n    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};\n\n    int padding = 0;\n\n\n\n    if (!s) {\n\n        *pbuffer = NULL;\n\n        return 0;\n\n    }\n\n\n\n    /* don't attempt to pad fixed-size packet buffers */\n\n    if (!s->max_packet_size) {\n\n        avio_write(s, padbuf, sizeof(padbuf));\n\n        padding = FF_INPUT_BUFFER_PADDING_SIZE;\n\n    }\n\n\n\n    avio_flush(s);\n\n\n\n    *pbuffer = d->buffer;\n\n    size = d->size;\n\n    av_free(d);\n\n    av_free(s);\n\n    return size - padding;\n\n}\n", "idx": 21971, "substitutes": {"s": ["settings", "sets", "S", "sq", "south", "secure", "rs", "w", "ks", "seconds", "p", "h", "sync", "se", "http", "ses", "ds", "f", "an", "ions", "stats", "fs", "is", "ss", "b", "si", "ts", "v", "a", "n", "c", "opens", "uploads", "spec", "sb", "o", "ps", "storage", "e", "cs", "space", "r", "l", "service", "session", "u", "services", "es", "ops", "ssl", "comments", "gs", "i", "ctx", "m", "os", "conf", "t", "self", "sf", "client", "server", "ns", "g", "sg", "sl", "js"], "pbuffer": ["cpheader", "pcap", " pheader", " pbuf", "cpbase", " puffer", "preheader", "bbuffer", "precap", "Pheader", "Pbuffer", "puffer", "Pqueue", " pqueue", " pcap", "pbase", "paduffer", "prebuffer", "cpbuffer", " pbase", "bbuf", "Pbase", "pbuf", "pheader", "preuffer", "bheader", "padbuffer", "padcap", "bcap", "cpqueue", "pqueue", "prebuf"], "d": ["dm", "nd", "dc", "w", "p", "cd", "sync", "dt", "db", "ds", "f", "md", "dl", "driver", "did", "D", "gd", "b", "cmd", "dh", "n", "c", "o", "da", "e", "dat", "dx", "l", "draw", "fd", "u", "del", "dom", "dad", "data", "i", "sd", "m", "ad", "id", "t", "dn", "grad", "dr", "done", "dy", "dos", "z", "ld"], "size": ["channel", "write", "shape", "capacity", "timeout", "x", "empty", "p", "en", "sync", "code", "use", "offset", "name", "buffer", "type", "address", "now", "mode", "length", "pointer", "body", "Size", "content", "fee", "len", "n", "padding", "scale", "SIZE", "c", "position", "send", "storage", "from", "style", "l", "page", "connection", "ize", "value", "external", "small", "pos", "data", "sized", "unit", "i", "speed", "number", "large", "z"], "padbuf": [" padbuff", "prebuff", "padcb", "adbuf", "adbuff", "padbr", " padbuffer", "capuf", " padbr", "prebuffer", "capbuf", " paddbuffer", "padbuff", "paddingbuffer", "paddingbr", " paddbuf", "capcb", " padcb", "paddingbuf", "aduf", "capbuff", "pbuf", "prebuf", "pbuff", "preuf", "padbuffer", "adbuffer", "paduf", "paddingcb", "capbuffer", " paddbr", "pcb", " paddcb"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995, "substitutes": {"queue": ["channel", "loop", "menu", "update", "collection", "ue", "stage", "console", "cache", "event", "stack", "gui", "que", "core", "buffer", "type", "status", "q", "feed", "priority", "seq", "header", "parent", "database", "entry", "sequence", "module", "flow", "manager", "connection", "plugin", "command", "port", "qa", "client", "server", "list", "Queue", "group", "context", "prefix", "pool"], "sender": ["nsorter", "nserver", "nsener", "sidender", "resener", "reserver", "nsend", "sidensor", "Sink", "pend", "Sensor", "pener", "sidend", "sensor", "nsender", "nsenders", "Send", "pink", " send", "send", "resender", "penders", "nsink", "resenders", "pender", "sink", " senders", "sidenders", "porter", "senders", "server", "sorter", "sener", "Senders", "perver", "Sender", "Sorter", " sensor"], "flags": ["settings", "states", "tails", "version", "options", "ats", "offset", " Flags", "status", "length", "config", "stats", "types", "ants", "fs", "mask", "fee", "len", "files", "feat", "lag", "bits", "fun", "weights", "fl", "nl", "cs", "ils", "Flags", "orts", "args", "fd", "fps", "filename", "parts", "enabled", "ents", "ops", "features", "ips", "weight", "flag", "data", "FLAG", "fx", "workers", "fields", "vs", "addr", "prefix", "bytes"], "buf": ["box", "wb", "cv", "uf", "alloc", "src", "prop", "offset", "buff", "loc", "buffer", "msg", "length", "config", "func", "cmd", "b", "len", "callback", "seq", "raw", "cb", "path", "vec", "env", "flow", "fd", "args", "fp", "window", "ref", "bag", "bc", "rc", "data", "flag", "count", "ctx", "addr", "rb", "pool"], "size": ["time", "capacity", "shape", "ix", "cache", "use", "offset", "eng", "io", "Size", "content", "SIZE", "storage", "source", "pos", "data", "count", "form", "bytes", "empty", "en", "name", "loc", "address", "fee", "len", "parent", "page", "args", "ize", "end", "weight", "large", "ui", "izes", "mode", "length", "c", "store", "limit", "small", "unit", "ci", "live", "g", "z", "new", "x", "code", "body", "scale", "position", "iz", "sec"], "sent_cb": [" sent_nc", "sentablecor", "sentfCallback", "sent_callback", "sent_fn", "sent_cd", " sent_code", "sentablecd", "sent_Callback", "sentfnc", "sent_rb", "sentfcb", "sentitycd", " sent_Callback", "sentablecallback", "sent_data", "sentitycor", "sent_nc", "sentitycb", "sentitycallback", "sentablecb", "sent_code", " sent_fn", " sent_rb", " sent_cd", "sent_cor", " sent_cor", " sent_callback", "sentfcallback", " sent_data"], "packet": ["asset", "assacket", " Packet", "payett", "compend", "pacacket", "compad", "paceting", "payeter", " packat", "compart", "packart", "hooketer", "pad", "packageend", "packageant", "ppet", "packant", "compacker", "payet", "packett", " packart", "compset", "pacet", "packacket", " packct", " Packpt", "ppacket", "packageet", "compant", "compett", "ppset", "packpt", "compct", "packageart", "compec", "pet", " packant", "packacker", "passacket", "packeter", "comppt", "packeting", "asseting", "competer", "packec", "packageec", "packset", "ppeter", "passett", " packset", "packct", " packec", " packacket", " packeter", "payacket", "hookct", "compat", "packageacket", "compet", "hooket", " Packart", " packpt", "pat", "packend", "pacacker", " packad", "passeter", " Packacket", " packend", "assacker", "hookacket", "passet", "competing", "compacket", "packat", "packad"]}}
{"project": "FFmpeg", "commit_id": "02591641f88097aec2a573f0ae384c8b87bcfe3b", "target": 1, "func": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n", "idx": 22003, "substitutes": {"s": ["settings", "states", "sets", "sq", "S", "ks", "p", "sym", "ls", "sync", "site", "ses", "ds", "f", "xs", "fs", "is", "b", "ts", "si", "ss", "v", "a", "n", "c", "spec", "ps", "sb", "o", "e", "cs", "l", "args", "service", "session", "u", "services", "qs", "es", "d", "side", "ssl", "ctx", "self", "m", "sys", "gb", "su", "t", "sf", "gs", "os", "conf", "server", "context", "ns", "g", "sg", "js"], "channel": ["version", "axis", "row", "section", "queue", "block", "core", "code", "cat", "name", "frame", "type", "mode", "config", "course", "gap", "sc", "fc", "wan", "pixel", "uri", "scale", "sector", "c", "base", "cb", "range", "path", "character", "chan", "prot", "ch", "byte", "col", "Channel", "connection", "source", "cm", "chron", "sch", "qa", "video", "category", "unit", "column", "server", "component", "nc", "phase", "context", "network"], "residual_size": ["residinal_len", "residual_len", "residual1count", "residual_count", "residual_scale", "residual1size", "residUAL_name", "residinal_count", "residual_name", "residUAL_scale", "residUAL_size", "residinal_size", "residual1len"], "pred_order": ["pred_row", " pred_orders", "orig_size", "pred_ORD", " pred_asc", "orig_orders", "pred67orig", "predingord", "predingorder", "pred67order", "predsord", " pred_ORD", "predsORD", "pred_asc", " pred_ord", "predingorders", " pred_row", "orig_orig", "predsorders", "pred67asc", "predsorder", "pred67size", "orig_order", "pred_orig", " pred_orig", "pred_ord", " pred_size", "pred_orders", "pred_size", "predingORD"], "sum": ["ul", "Sum", "beta", "p", "use", "num", "ge", "offset", "val", "us", "sim", "f", "info", "cost", "max", "um", "cum", "pass", "b", "si", "v", "fee", "up", "gram", "average", "n", "vol", "scale", "sub", "alpha", "e", "user", "min", "style", "l", "fat", "av", "u", "cal", "sk", "out", "sh", "value", "size", "ass", "summary", "weight", "diff", "mean", "count", "used", "hash", "sign", "su", "total", "am", "add", "loss", "mix", "g", "all"], "i": ["ji", "ii", "ui", "qi", "x", "I", "ix", "p", "eni", "h", "di", "ri", "f", "ai", "ini", "oi", "ni", "ie", "start", "is", "im", "si", "b", "io", "v", "ki", "pi", "n", "ami", "index", "uri", "c", "a", "ei", "o", "ind", "e", "y", "l", "adi", "xi", "u", "fi", "li", "d", "iu", "api", "ik", "k", "m", "ci", "id", "mi", "multi", "zi", "ori", "gi", "z", "bi", "it", "ip"], "j": ["ji", "ii", "jit", "qi", "ani", "x", "ix", "jp", "p", "h", "jo", "je", "f", "ja", "ie", "fr", "b", "si", "jc", "v", "n", "index", "c", "adj", "o", "jj", "e", "y", "r", "l", "ij", "ch", "u", "key", "oj", "li", "d", "syn", "J", "job", "k", "m", "ci", "it", "aj", "g", "z", "jl", "js"], "coeffs": ["coefficientsi", "coffs", "coefficientss", "coefficients", "cocostes", "coeffi", "coefficientsp", " coffs", " coeffes", "coefments", " coffes", "coffe", "cocosts", "coeffes", "coefficientsd", " coffd", "coefs", "coffes", "coefp", "coEFFp", "coffi", "coefficientes", " coffe", "cocosti", " coffi", "coEFFs", " coefp", " coeffd", "coefficientse", "coEFFments", " coeffe", " coeffi", "coeffments", " coeffp", "coffp", " coefs", " coefments", "coeffd", "coefficientp", " coeffments", "coffd", "cocoste", " coefi", "coeffe", "coefficientsments", "coEFFi", "coefficientd", "coeffp", "coefi", "coefficientses", " coffp"]}}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006, "substitutes": {"timer_list": ["timer_List", "er_pair", "timerdList", "tick_queue", "meterappget", "timeridleft", "theme_test", "theme0list", "timerAtable", "timer_test", "timeridlist", "timerdlist", "timer0get", "timerAlist", " timer_diff", "timerallget", "timer_get", "timer2log", "timer_pair", "timer_stack", "timer_type", "timerlisttest", "timerxrecord", "timerappget", "timer_diff", "theme_stack", "timer6get", "ticklistlist", "timerlistget", "timer_count", "timeralllog", "theme6list", "timerlisttree", "timerappconfig", "timer5list", "timerxList", "tick_list", "timer5LIST", "er_List", "later_batch", "timer_tree", "ticklistqueue", "timerlistlist", "tick_List", "timerklist", "theme0detail", "timer2config", "timerlistdetail", "timer_add", "timer_LIST", "er_record", "meter_log", "timerllist", "later_add", "timer5stack", "er_list", "timer_left", "timer5get", "timer_queue", "theme_detail", "timerdrecord", "timerAdiff", "meter_config", "timerallconfig", " timer_count", "timer0test", "timer_table", "lateridadd", "theme0test", "theme_list", "theme0get", "timer_log", "er_lock", "timerktable", "timer_record", "theme6LIST", "later_left", "later_list", "ticklistList", "timeridadd", "timer_lock", "er_type", "timer_batch", "timerlqueue", "lateridleft", "tick_tree", "timer6LIST", "theme_LIST", "ticklisttree", "timerdpair", "timerkcount", "timerkdiff", "timerxpair", "timer_config", "timerxlist", "timerltree", "lateridlist", "meter_list", "timerlList", "lateridbatch", "timerappstack", "timeridbatch", "theme6stack", "timerapplog", " timer_table", "theme_get", "meterapplog", "timer6list", "meter_get", "meterappconfig", "timer2list", "timerapplist", "theme6get", "timer0detail", "timerlistList", "timerlistqueue", "timer2get", "timerAcount", "timer6stack", "timeralllist", "timerappLIST", "meterapplist", "er_batch", "timer_detail", "timer0list"], "expire_time": ["expire___count", "exake___time", "expire_timeout", "expirefmoney", "expire__money", "expireyhour", "expire64start", "expire__timeout", "expirefmode", "exire_time", "expire64count", "exake_time", "expire64money", "expire_count", "expirexmode", "expire_hour", "expire64timeout", "exire_money", "expire___start", "exire_mode", "expire_start", "expirexmoney", "expire___time", "exake___hour", "exire_Time", "expireytime", "expirextime", "exake___count", "expiration_money", "exake_count", "expire64hour", "expireftime", "expiration_time", "expire64time", "exire_count", "expire_Time", "expireycount", "expiration_timeout", "exake_start", "expire___hour", "exake___start", "expire__time", "exake_hour", "expire_mode", "expire_money", "expireystart"]}}
{"project": "FFmpeg", "commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "target": 1, "func": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n\n                            int compressed_size, int uncompressed_size,\n\n                            EXRThreadData *td)\n\n{\n\n    unsigned long dest_len, expected_len = 0;\n\n    const uint8_t *in = td->tmp;\n\n    uint8_t *out;\n\n    int c, i, j;\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n\n            expected_len += (td->xsize * td->ysize * 2);\n\n        } else {//UINT 32\n\n            expected_len += (td->xsize * td->ysize * 4);\n\n        }\n\n    }\n\n\n\n    dest_len = expected_len;\n\n\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (dest_len != expected_len) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    out = td->uncompressed_data;\n\n    for (i = 0; i < td->ysize; i++)\n\n        for (c = 0; c < s->nb_channels; c++) {\n\n            EXRChannel *channel = &s->channels[c];\n\n            const uint8_t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22009, "substitutes": {"s": ["support", "rates", "settings", "sts", "sq", "S", "ks", "south", "p", "sym", "sync", "sa", "ses", "ds", "f", "fs", "si", "ss", "ts", "b", "sc", "spec", "ps", "sb", "sm", "e", "cs", "space", "l", "service", "session", "sk", "u", "services", "sh", "parts", "d", "side", "ssl", "hm", "gs", "sd", "m", "sys", "su", "t", "self", "sf", "bs", "this", "sl", "ls", "sg", "ns", "sv", "g", "js"], "src": ["inst", "st", "secure", "setup", "rin", "rs", "img", "loc", "proc", "config", "sr", "sc", "ipl", "fc", "scl", "stream", "sub", "cb", "sb", "tmp", "filename", "dest", "sel", "source", "url", "rc", "attr", "input", "ssl", "ctx", "gb", "slice", "rl", "sl", "rb"], "compressed_size": ["compressed67area", "comppped_data", "compressed_sum", "compached_scale", "compached_size", "compressed67size", "compressed_len", "compressed2sum", "compressed_offset", "compached_sum", "compressed67offset", "compressed64scale", "compached_len", "compressed64len", "compressed2size", "compressed64size", "comppped_area", "compressed_area", "compressed_data", "compressed_scale", "compressed67data", "comppped_size", "compressed64sum", "compressed2len", "comppped_offset", "compressed2scale"], "uncompressed_size": ["uncompressedrwidth", "uncompressed64width", "uncompured_ize", "uncompressedrize", "uncompressed_ize", "uncompressed64size", "uncompressedrsize", "uncompured_source", "uncompured64size", "uncompured_size", "uncompured_width", "uncompressed64ize", "uncompured64width", "uncompressed64source", "uncompured64source", "uncompressedrsource", "uncompressed_source", "uncompressed_width", "uncompured64ize"], "td": ["cz", "nd", "ti", "dc", "kt", "att", "thin", "hd", "pd", "ht", "butt", "cd", "tm", "dt", "lf", "bd", "elt", "db", "ta", "dal", "det", "ds", "dl", "md", "ud", "uc", "pc", "tf", "cmd", "ts", "dll", "dh", "cod", "header", "amp", "sb", "table", "dat", "pt", "ind", "conn", "tmp", "fd", "nt", "prot", "TD", "pb", "tif", "rd", "std", "dd", "xd", "tp", "d", "layer", "li", "tn", "tc", "data", "ssl", "input", "lv", "sd", "gb", "t", "dn", "txt", "ctl", "wd", "od", "vd", "ld", "standard", "edd"], "dest_len": ["dest64len", "dest_Len", " dest_size", " dest_count", "dest2lock", "dest_ler", "dest9lin", "dest_count", "dest___len", "rest_length", "expected_Len", "dest__count", "dest___val", "dest_lon", "dest_limit", "dest2limit", "rest_len", "dest9ler", "gest___ler", "gest___len", "gest___val", "dest_length", "gest___lin", "dest_lin", "dest64l", "dest__len", "dest_lock", "dest9val", "dest___ler", "dest_l", "expected64lon", "dest__val", "dest_size", "expected_len", " dest_val", "gest_ler", "gest_lin", "expected_l", "expected64Len", "gest_val", "dest___lin", "expected_lon", "rest_limit", "expected64len", "dest__size", "expected64l", "rest_lock", "dest2len", "dest64Len", "dest9len", "dest_val", "dest64lon", "dest2length", "gest_len"], "in": ["dc", "ins", "ii", "inst", "att", "part", "image", "rin", "into", "p", "pin", "img", "val", "proc", "In", "address", "config", "pc", "din", "inch", "gin", "win", "resource", "bin", "index", "isin", "err", "again", "ind", "min", "r", "conn", "connection", "source", "d", "impl", "ssl", "rc", "data", "input", "inn", "inside", "pull", "ctx", "id", "IN", "ci", "m", "socket", "inc", "rec", "inner"], "out": ["part", "att", "image", "version", "p", "call", "sync", "img", "bit", "name", "buffer", "process", "proc", "config", "other", "cmd", "io", "gin", "device", "v", "temp", "bin", "parent", "Out", "again", "err", "OUT", "sum", "error", "conn", "password", "result", "token", "window", "dest", "output", "opt", "copy", "source", "outs", "at", "attr", "data", "m", "client", "server", "exec", "new", "ext"], "c": ["C", "cy", "x", "cache", "p", "lc", "cu", "h", "call", "enc", "co", "ac", "ce", "f", "pc", "uc", "sc", "b", "v", "n", "con", "e", "cs", "y", "l", "r", "col", "ch", "u", "d", "cp", "rc", "count", " rc", "k", "vc", "m", "ci", "t", "nc", "cn", "g", "z"], "i": ["ti", "ii", "ui", "my", "qi", "x", "ix", "I", "p", "h", "eni", "lc", "phi", "di", "ri", "info", "f", "ai", "ini", "oi", "ni", "ie", "q", "start", "is", "im", "b", "si", "io", "v", "init", "ki", "pi", "n", "index", "uri", "iii", "ami", "o", "e", "y", "l", "xi", "bi", "u", "yi", "chi", "fi", "d", "li", "iu", "mini", "k", "id", "m", "ci", "mi", "multi", "gi", "inner", "it", "ip"], "j": ["ji", "ii", "x", "jp", "p", "h", "jo", "num", "el", "je", "f", "ja", "q", "other", "b", "jc", "v", "n", "o", "fl", "e", "ind", "y", "l", "ij", "ch", "u", "key", "oj", "d", "li", "ne", "pos", "obj", "J", "k", "m", "t", "aj", "g", "z", "jl", "js"], "channel": ["chip", "player", "cv", "attribute", "row", "call", "queue", "core", "type", "config", "course", "pc", "sc", "wan", "pixel", "parent", "slot", "handler", "conn", "character", "chan", "page", "ch", "service", "window", "Channel", "connection", "can", "cm", "plugin", "cup", "chron", "layer", "member", "container", "socket", "client", "component", "server", "group", "camera"], "ptr": ["desc", "inst", "st", "att", "iter", "stage", "pe", "p", "pr", "code", "img", "np", "pair", "pointer", "elt", "loc", "offset", "buffer", "proc", "address", "ft", "uv", "pl", "fr", "pc", "start", "wr", "pp", "Ptr", "err", "pt", "dat", "patch", "prot", "fd", "nt", "fp", "ch", "tmp", "ref", "ctr", "dest", "point", "str", "buff", "tr", "tp", "inter", "port", "pos", "attr", "cp", "data", "pull", "arr", "ctx", "dr", "pad", "pty", "sp", "rect", "rt", "grad", "slice", "addr", "pointers", "ext"]}}
{"project": "FFmpeg", "commit_id": "caa7a3914f499f74b3ee346f26d598ebdc0ec210", "target": 1, "func": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    int64_t total_size = 0;\n\n    MOVAtom a;\n\n    int i;\n\n\n\n    if (atom.size < 0)\n\n        atom.size = INT64_MAX;\n\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n\n        a.size = atom.size;\n\n        a.type=0;\n\n        if (atom.size >= 8) {\n\n            a.size = avio_rb32(pb);\n\n            a.type = avio_rl32(pb);\n\n            if (a.type == MKTAG('f','r','e','e') &&\n\n                a.size >= 8 &&\n\n                c->moov_retry) {\n\n                uint8_t buf[8];\n\n                uint32_t *type = (uint32_t *)buf + 1;\n\n                avio_read(pb, buf, 8);\n\n                avio_seek(pb, -8, SEEK_CUR);\n\n                if (*type == MKTAG('m','v','h','d') ||\n\n                    *type == MKTAG('c','m','o','v')) {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n\n                    a.type = MKTAG('m','o','o','v');\n\n                }\n\n            }\n\n            if (atom.type != MKTAG('r','o','o','t') &&\n\n                atom.type != MKTAG('m','o','o','v'))\n\n            {\n\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n\n                {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n\n                    avio_skip(pb, -8);\n\n                    return 0;\n\n                }\n\n            }\n\n            total_size += 8;\n\n            if (a.size == 1) { /* 64 bit extended size */\n\n                a.size = avio_rb64(pb) - 8;\n\n                total_size += 8;\n\n            }\n\n        }\n\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n\n        if (a.size == 0) {\n\n            a.size = atom.size - total_size + 8;\n\n        }\n\n        a.size -= 8;\n\n        if (a.size < 0)\n\n            break;\n\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n\n            if (mov_default_parse_table[i].type == a.type) {\n\n                parse = mov_default_parse_table[i].parse;\n\n                break;\n\n            }\n\n\n\n        // container is user data\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n\n                       atom.type == MKTAG('i','l','s','t')))\n\n            parse = mov_read_udta_string;\n\n\n\n        if (!parse) { /* skip leaf atoms data */\n\n            avio_skip(pb, a.size);\n\n        } else {\n\n            int64_t start_pos = avio_tell(pb);\n\n            int64_t left;\n\n            int err = parse(c, pb, a);\n\n            if (err < 0)\n\n                return err;\n\n            if (c->found_moov && c->found_mdat &&\n\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n\n                 start_pos + a.size == avio_size(pb))) {\n\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n\n                    c->next_root_atom = start_pos + a.size;\n\n                return 0;\n\n            }\n\n            left = a.size - avio_tell(pb) + start_pos;\n\n            if (left > 0) /* skip garbage at atom end */\n\n                avio_skip(pb, left);\n\n            else if (left < 0) {\n\n                av_log(c->fc, AV_LOG_WARNING,\n\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n\n                       (char*)&a.type, -left);\n\n                avio_seek(pb, left, SEEK_CUR);\n\n            }\n\n        }\n\n\n\n        total_size += a.size;\n\n    }\n\n\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n\n        avio_skip(pb, atom.size - total_size);\n\n\n\n    return 0;\n\n}\n", "idx": 22013, "substitutes": {"c": ["C", "dc", "mc", "cf", "cy", "cv", "xc", "cache", "p", "lc", "cu", "cd", "cc", "ce", "f", "coll", "pc", "uc", "cr", "cur", "b", "sc", "jc", "fc", "ct", "cod", "con", "ca", "e", "cs", "l", "conn", "ch", "cm", "d", "bc", "cp", "tc", "rc", "cca", "ctx", "vc", "k", "m", "ci", "conf", "ctrl", "nc", "context", "cn", "g", "icc"], "pb": ["lb", "bm", "wb", "pa", "pd", "jp", "p", "uf", "platform", "db", "xb", "fab", "proc", "pg", "pm", "pc", "bf", "b", "bh", "fc", "lab", "apy", "lp", "sb", "bps", "bp", "cb", "ab", "mb", "tmp", "fp", "hub", "plugin", "pl", "tp", "bc", "PB", "rob", "api", "tc", "cp", "ctx", "ppa", "cpp", "gb", "pkg", "fb", "dp", "pub", "eb", "wp", "rb"], "atom": ["aa", "cache", "p", "prop", "buffer", "f", "app", "xml", "ar", "base", "com", "ab", "atomic", "at", "bc", "data", "fb", "term", "spec", "perm", "item", "orb", "num", "cat", "an", "config", "b", "asm", "cm", "A", "api", "input", "container", "abc", "array", "mom", "map", "anon", "element", "att", "bb", "acl", "ac", "article", "na", "ak", "temp", "ga", "tmp", "root", "mag", "meta", "arc", "instance", "tc", "om", "m", "t", "g", "node", "op", "ace", "x", "fab", "ta", "object", "as", "document", "mA", "fc", "aka", "parser", "o", "alpha", "acc", "operator", "tom", "attr", "obj"], "a": ["ace", "aa", "af", "pa", "p", "ea", "area", "sa", "ac", "http", "fab", "ada", "an", "ma", "ai", "f", "na", "au", "as", "ata", "art", "app", "s", "wa", "ack", "b", "mA", "ba", "ae", "ar", "ga", "parent", "ca", "parser", "da", "o", "alpha", "ast", "ab", "l", "e", "aux", "va", "sta", "meta", " ca", "A", "ka", "ama", "qa", "at", "api", "input", "tta", "ad", "la", "t", "eta", "am", "asa", "aaa"], "i": ["ii", "ui", "I", "p", "ac", "j", "f", "ai", "ie", "is", "b", "n", "index", "ia", "o", "e", "l", "d", "at", "li", "iu", "data", "count", "id", "z", "it", "ip"], "parse": ["dc", "aa", "scan", "cat", "pair", "buffer", "val", "pack", "proc", "config", "func", "pc", "init", "seq", "parent", "send", "parser", "cb", "r", "P", "byte", "format", "ci", "abc", "cmp", "array", "util"], "type": ["time", "shape", "match", "class", "p", "cross", "offset", "buffer", "like", "info", "valid", "key", "py", "ref", "data", "count", "role", "comment", "get", "part", "cl", "pe", "call", "num", "broad", "name", "val", "loc", "types", "index", "parent", "action", "y", "page", "format", "size", "rule", "pl", "weight", "target", "model", "Type", "id", "set", "title", "label", "location", "length", "description", "ype", "media", "rel", "v", "state", "error", "style", "r", "token", "byte", "kind", "value", "copy", "url", "unit", "t", "op", "typ", "ty", "image", "x", "template", "block", "code", "link", "color", "TYPE", "lock", "body", "scale", "day", "message", "col", "post", "port", "split", "attr", "field", "speed", "list", "tag"], "buf": ["Buffer", "cap", "br", "wb", "cv", "uf", "alloc", "src", "queue", "mem", "block", "bb", "img", "num", "buff", "buffer", "xff", "loc", "config", "func", "cur", "uc", "len", "seq", "bin", "header", "cb", "cas", "ab", "tmp", "fd", "batch", "fp", "window", "ref", "end", "off", "ff", "port", "bc", "ffff", "pos", "rc", "data", "comb", "count", "uint", "ctx", "shift", "pad", "orig", "fb", "binary", "rb", "pool"]}}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 22016, "substitutes": {"ad": ["dc", "att", "al", "p", "aud", "cat", "ac", "db", "http", "bd", "ada", "Ad", "ax", "ud", "an", "md", "as", "pc", "art", "b", "ld", "a", "ag", "quad", "c", "ca", "ady", "da", "dev", "mad", "dat", "mod", "ads", "conn", "pod", "adh", "dd", "end", "ass", "post", "d", "at", "data", "AD", "id", "pad", "admin", "sd", "ant", "add", "wd", "ap", "od", "jad", "exec", "addr", "ay", "rad", "ang"], "sglist": [" sglists", "sgelist", "sglister", "sglists", "sgelists", "sgnists", "sgnister", " sgelist", "siglists", " sgelists", " sglister", "sgelister", "siglister", " sgelest", " sglest", "sglest", "sgnist", " sgelister", "siglist", "sgelest", "siglest", "sgnest"], "cmd": ["dc", "req", "cf", "cfg", "def", "MD", "host", "cd", "code", "cat", "msg", "mode", "proc", "md", "config", "dict", "comm", "cod", "df", "c", "bind", "cb", "conn", "args", "Cmd", "command", "d", "cp", "data", "obj", "ctx", "atom", "dr", "pad", "conf", "pkg", "grad", "client", "ctl", "ctrl", "cmp", "addr", "dom", "op", "rad"], "limit": ["delay", "timeout", "iter", "cache", "block", "required", "acl", "lim", "length", "lock", "seq", "position", "base", "min", "page", "Limit", "end", "pos", "url", "count", "afi", "shift", "alt", "skip", "limits", "ip"], "offset": ["timeout", "reset", "p", "zero", "location", "num", "loc", "address", "option", "Offset", "length", "f", "start", "len", "seq", "index", "padding", "align", "position", "base", "o", "slot", "entry", "range", "amount", "alpha", "error", "sum", "boot", "ref", "outer", "end", "size", "off", "summary", "initial", "pos", "url", "shift", "sort", "skip", "slice", "set"], "prdt": ["prdm", "prt", "promdm", " prtd", " prqt", "trdt", "brqt", "PRtd", "promta", "PRtt", "brtd", "sprtt", "sprdt", "PRt", "prqt", "prtz", "prtd", "Prqt", "prtt", "Prdm", " prtz", "brdt", "brtz", " prdm", "trtz", "sprtd", "trtd", "sprt", "Prta", " prt", "promqt", " prtt", "prta", "trqt", "Prdt", " prta", "PRdt", "promdt"], "i": ["ji", "ii", "ui", "ti", "abi", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "j", "info", "f", "ai", "ini", "ie", "ni", "oi", "b", "si", "io", "v", "gu", "ki", "pi", "n", "index", "ami", "c", "uri", "a", "uli", "o", "e", "y", "r", "l", "xi", "u", "chi", "yi", "fi", "d", "li", "iu", "pos", "in", "count", "hi", "k", "m", "ci", "mi", "multi", "t", "zi", "anti", "gi", "z", "mu", "bi", "it", "ip"], "tbl_entry_size": ["tbl_entry___code", "tbl_no64length", "tbl_entry___count", "tbl_part_size", "tbl_part2pos", "tbl_entry2size", "tbl_entry___size", "tbl_part_pos", "tbl_entry2Size", "tbl_ent_scale", "tbl_ent_Size", "tbl_entry_speed", "tbl_entry_code", "tbl_part2size", "tbl_entry64sum", "tbl_no_size", "tbl_row_number", "tbl_entry2pos", "tbl_no_length", "tbl_entry_number", "tbl_entry64size", "tbl_no_sum", "tbl_entry64length", "tbl_entry64loc", "tbl_no64loc", "tbl_entry_sum", "tbl_row_count", "tbl_part_Size", "tbl_entry2loc", "tbl_entry_scale", "tbl_entry_loc", "tbl_entry___number", "tbl_part2Size", "tbl_row_size", "tbl_entry_count", "tbl_ent_size", "tbl_entry_pos", "tbl_no_loc", "tbl_no64size", "tbl_ent_speed", "tbl_entry_length", "tbl_entry_Size", "tbl_entry2sum", "tbl_row_code", "tbl_no64sum", "tbl_entry2length"], "bus": ["Bus", "brid", "BUS", "class", "cache", "p", "h", "bridge", "block", "way", "us", "cat", "se", "db", "proxy", "config", "b", "io", "bug", " buses", "feed", "state", "back", "ux", "c", "board", "dev", "ou", "ch", "service", "session", "boot", "hub", "connection", "ass", "port", "bc", "usb", "plug", "os"], "qbus": ["qdev", "sqboot", "sqdev", "sqBUS", "QBUS", " qdev", "qboot", " qBUS", "Qdev", "Qboot", " qboot", "sqbus", "Qbus", "qBUS"], "tbl": ["pbl", "tbo", "tBL", "ktbt", "tbt", " tpl", "ktbl", "ppl", "tybl", "pBL", "pml", "tpl", "btbl", " tBL", "typl", " tll", "ktbo", "ktll", "btbo", "btbt", " tbo", "btll", "tll", " tbt", "tyml", " tml", "tyBL", "tml"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void dwt_encode97_int(DWTContext *s, int *t)\n\n{\n\n    int lev,\n\n        w = s->linelen[s->ndeclevels-1][0];\n\n    int *line = s->i_linebuf;\n\n    line += 5;\n\n\n\n    for (lev = s->ndeclevels-1; lev >= 0; lev--){\n\n        int lh = s->linelen[lev][0],\n\n            lv = s->linelen[lev][1],\n\n            mh = s->mod[lev][0],\n\n            mv = s->mod[lev][1],\n\n            lp;\n\n        int *l;\n\n\n\n        // VER_SD\n\n        l = line + mv;\n\n        for (lp = 0; lp < lh; lp++) {\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lv; i++)\n\n                l[i] = t[w*i + lp];\n\n\n\n            sd_1d97_int(line, mv, mv + lv);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n        // HOR_SD\n\n        l = line + mh;\n\n        for (lp = 0; lp < lv; lp++){\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lh; i++)\n\n                l[i] = t[w*lp + i];\n\n\n\n            sd_1d97_int(line, mh, mh + lh);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n    }\n\n}\n", "idx": 22034, "substitutes": {"s": ["support", "settings", "S", "south", "sq", "rs", "w", "p", "sym", "sky", "site", "sync", "se", "bis", "ses", "ds", "f", "an", "sr", "fs", "is", "ss", "ts", "si", "v", "b", "a", "n", "c", "spec", "sb", "sites", "e", "cs", "space", "service", "session", "u", "services", "sup", "es", "d", "in", "ssl", "gs", "su", "os", "sys", "conf", "self", "sf", "m", "server", "sl", "ns", "sg", "g", "sv", "js"], "t": ["T", "st", "att", "tt", "x", "w", "p", "test", "tm", "dt", "rt", "yt", "elt", "te", "type", "f", "ta", "ret", "tool", "tf", "b", "ts", "ut", "v", "ct", "n", "bt", "c", "flat", "o", "table", "e", "pt", "y", "r", "tu", "nt", "out", "opt", "tp", "d", "at", "tn", "m", "ant", "total", "unt", "z", "set", "qt", "it"], "lev": ["ii", "light", "lc", "orient", "lim", "wl", "low", "le", "hor", "escal", "min", "sk", "u", "liv", "leg", "lv", "lvl", "count", "fall", "lie", "la", "ld", "sv", "compl", "ev", "depth", "loc", "cli", "uv", "len", "ag", "fl", "av", "land", "lu", "ll", "grade", "dy", "level", "lad", "lin", "sea", "vert", "el", "dim", "hum", "vv", "ov", "v", "lex", "lat", "age", "lez", "mag", "atten", "vel", "zi", "ell", "lov", "sl", "vl", "du", "lem", "coll", "up", "vol", "scale", "coord", "cel"], "line": ["lay", "time", "light", "co", "se", "lim", "wl", "le", "base", "range", "source", "lv", "kl", "la", "no", "ld", "cl", "row", "ge", "lf", "loc", "fr", "b", "len", "n", "entry", "e", "end", "rule", "model", "slice", "level", "cell", "lines", "liner", "lin", "ln", "length", "margin", "c", "style", "li", "ne", "ell", "edge", "sl", "g", "zip", "sync", "link", "block", "LINE", "code", "frame", "coll", "lock", "lane", "mm", "vol", "scale", "o", "ine", "lined", "Line", "d", "layer", "lo", "cle"], "lp": ["ii", "p", "lc", "wl", "f", "lla", "si", "pp", "pi", "bp", "py", "pb", "ql", "lv", "lvl", "kl", "lie", "la", "wp", "tall", "lb", "ji", "gp", "jp", "lf", "pm", "pc", "b", "mp", "dh", "len", "amp", "hip", "lu", "ll", "pl", "bsp", "np", "api", "lr", "dp", "il", "pd", "lin", "el", "ln", "dl", "v", "lis", "fp", "li", "sp", "ell", "LP", "atl", "hp", "jl", "ml", "vl", "pa", "hl", "aml", "lt", "ijk", "pn", "vp", "tp", "layer", "iu", "cp", "ilk", "rl", "ls"], "l": ["lb", "ul", "il", "w", "p", "lc", "h", "lin", "ls", "hl", "lf", "ol", "el", "ln", "le", "f", "dl", "q", "b", "v", "n", "c", "o", "fl", "e", "nl", "r", "u", "lu", "ll", "pl", "li", "d", "url", "lv", "kl", "L", "k", "m", "ell", "la", "list", "g", "sl", "z", "rl", "all", "ml"], "i": ["ii", "my", "qi", "ix", "p", "phi", "info", "f", "io", "si", "a", "pi", "vi", "\u0438", "u", "key", "at", "k", "ik", "mi", "ori", "ji", "ti", "iv", "I", "isi", "jp", "ri", "cli", "ni", "is", "b", "ki", "n", "uri", "e", "y", "xi", "api", "id", "gi", "ip", "ui", "il", "w", "h", "ie", "oi", "v", "iii", "c", "uli", "adi", "yi", "fi", "li", "iw", "m", "ci", "zi", "g", "z", "bi", "it", "abi", "x", "eni", "code", "di", "ai", "ini", "ir", "ei", "o", "d", "in", "iu", "mu"], "j": ["ji", "ii", "jon", "br", "jit", "qi", "jen", "dj", "ui", "x", "jp", "p", "h", "jo", "en", "el", "je", "f", "jet", "ja", "qt", "q", "ni", "ijk", "bl", "b", "jc", "si", "v", "uj", "kj", "pi", "n", "adj", "bj", "o", "jj", "e", "y", "ij", "vi", "xi", "u", "sh", "ll", "oj", "li", "d", "json", "api", "J", "lv", "k", "m", "er", "dy", "it", "aj", "note", "g", "z", "jl", "op", "js"]}}
{"project": "FFmpeg", "commit_id": "0424e052f83adc422d8a746e3cdc5ab6bc28679e", "target": 1, "func": "static void decode_postinit(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture *out = s->current_picture_ptr;\n\n    Picture *cur = s->current_picture_ptr;\n\n    int i, pics, out_of_order, out_idx;\n\n\n\n    s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_H264;\n\n    s->current_picture_ptr->pict_type= s->pict_type;\n\n\n\n    if (h->next_output_pic) return;\n\n\n\n    if (cur->field_poc[0]==INT_MAX || cur->field_poc[1]==INT_MAX) {\n\n        //FIXME this allows the next thread to start once we encounter the first field of a PAFF packet\n\n        //This works if the next packet contains the second field. It does not work if both fields are\n\n        //in the same packet.\n\n        //ff_thread_finish_setup(s->avctx);\n\n        return;\n\n    }\n\n\n\n    cur->interlaced_frame = 0;\n\n    cur->repeat_pict = 0;\n\n\n\n    /* Signal interlacing information externally. */\n\n    /* Prioritize picture timing SEI information over used decoding process if it exists. */\n\n\n\n    if(h->sps.pic_struct_present_flag){\n\n        switch (h->sei_pic_struct)\n\n        {\n\n        case SEI_PIC_STRUCT_FRAME:\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_FIELD:\n\n        case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n            cur->interlaced_frame = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n            if (FIELD_OR_MBAFF_PICTURE)\n\n                cur->interlaced_frame = 1;\n\n            else\n\n                // try to flag soft telecine progressive\n\n                cur->interlaced_frame = h->prev_interlaced_frame;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n            // Signal the possibility of telecined film externally (pic_struct 5,6)\n\n            // From these hints, let the applications decide if they apply deinterlacing.\n\n            cur->repeat_pict = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n            // Force progressive here, as doubling interlaced frame is a bad idea.\n\n            cur->repeat_pict = 2;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n            cur->repeat_pict = 4;\n\n            break;\n\n        }\n\n\n\n        if ((h->sei_ct_type & 3) && h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n\n            cur->interlaced_frame = (h->sei_ct_type & (1<<1)) != 0;\n\n    }else{\n\n        /* Derive interlacing flag from used decoding process. */\n\n        cur->interlaced_frame = FIELD_OR_MBAFF_PICTURE;\n\n    }\n\n    h->prev_interlaced_frame = cur->interlaced_frame;\n\n\n\n    if (cur->field_poc[0] != cur->field_poc[1]){\n\n        /* Derive top_field_first from field pocs. */\n\n        cur->top_field_first = cur->field_poc[0] < cur->field_poc[1];\n\n    }else{\n\n        if(cur->interlaced_frame || h->sps.pic_struct_present_flag){\n\n            /* Use picture timing SEI information. Even if it is a information of a past frame, better than nothing. */\n\n            if(h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM\n\n              || h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n\n                cur->top_field_first = 1;\n\n            else\n\n                cur->top_field_first = 0;\n\n        }else{\n\n            /* Most likely progressive */\n\n            cur->top_field_first = 0;\n\n        }\n\n    }\n\n\n\n    //FIXME do something with unavailable reference frames\n\n\n\n    /* Sort B-frames into display order */\n\n\n\n    if(h->sps.bitstream_restriction_flag\n\n       && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n        s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n        s->low_delay = 0;\n\n    }\n\n\n\n    if(   s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT\n\n       && !h->sps.bitstream_restriction_flag){\n\n        s->avctx->has_b_frames= MAX_DELAYED_PIC_COUNT;\n\n        s->low_delay= 0;\n\n    }\n\n\n\n    pics = 0;\n\n    while(h->delayed_pic[pics]) pics++;\n\n\n\n    assert(pics <= MAX_DELAYED_PIC_COUNT);\n\n\n\n    h->delayed_pic[pics++] = cur;\n\n    if(cur->reference == 0)\n\n        cur->reference = DELAYED_PIC_REF;\n\n\n\n    out = h->delayed_pic[0];\n\n    out_idx = 0;\n\n    for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame && !h->delayed_pic[i]->mmco_reset; i++)\n\n        if(h->delayed_pic[i]->poc < out->poc){\n\n            out = h->delayed_pic[i];\n\n            out_idx = i;\n\n        }\n\n    if(s->avctx->has_b_frames == 0 && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset))\n\n        h->next_outputed_poc= INT_MIN;\n\n    out_of_order = out->poc < h->next_outputed_poc;\n\n\n\n    if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)\n\n        { }\n\n    else if((out_of_order && pics-1 == s->avctx->has_b_frames && s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT)\n\n       || (s->low_delay &&\n\n        ((h->next_outputed_poc != INT_MIN && out->poc > h->next_outputed_poc + 2)\n\n         || cur->pict_type == AV_PICTURE_TYPE_B)))\n\n    {\n\n        s->low_delay = 0;\n\n        s->avctx->has_b_frames++;\n\n    }\n\n\n\n    if(out_of_order || pics > s->avctx->has_b_frames){\n\n        out->reference &= ~DELAYED_PIC_REF;\n\n        out->owner2 = s; // for frame threading, the owner must be the second field's thread\n\n                         // or else the first thread can release the picture and reuse it unsafely\n\n        for(i=out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i+1];\n\n    }\n\n    if(!out_of_order && pics > s->avctx->has_b_frames){\n\n        h->next_output_pic = out;\n\n        if(out_idx==0 && h->delayed_pic[0] && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset)) {\n\n            h->next_outputed_poc = INT_MIN;\n\n        } else\n\n            h->next_outputed_poc = out->poc;\n\n    }else{\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"no picture\\n\");\n\n    }\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n}\n", "idx": 22037, "substitutes": {"h": ["ha", "hand", "hd", "w", "kh", "ht", "p", "hl", "th", "gh", "host", "her", "http", "ih", "f", "zh", "q", "hist", "rh", "he", "b", "beh", "ah", "hh", "dh", "bh", "oh", "n", "v", "header", "c", "hs", "H", "e", "l", "hr", "hw", "ch", "ph", "adh", "sh", "history", "uh", "hash", "hm", "hi", "k", "m", "t", "han", "eh", "g", "hp"], "s": ["p", "ls", "f", "q", "rh", "si", "a", "sb", "storage", "cs", "u", "sch", "ops", "share", "gs", "conf", "spec", "sv", "support", "ds", "ses", "is", "b", "sc", "ts", "n", "hs", "ps", "e", "y", "services", "comments", "os", "S", "w", "ions", "sav", "sci", "stats", "c", "l", "r", "service", "ch", "qs", "sh", "es", "m", "sys", "t", "server", "ages", "sl", "g", "settings", "sq", "rs", "sync", "http", "fs", "ss", "ances", "o", "session", "d", "in", "hm", "su", "self", "sf", "ns", "this", "sg", "ures", "js"], "out": ["att", "image", "doc", "w", "cache", "p", "img", "co", "n", "err", "Out", "o", "conn", "ch", "output", "opt", "copy", "conv", "outs", "in", "obj", "arr", "m", "conf", "t", "inc", "rec", "op"], "cur": ["ur", "cont", "cache", "cu", "lc", "uber", "co", "proc", "q", "cer", "con", "tr", "sch", "bc", "dr", "conf", "spec", "master", "desc", "try", "catch", "src", "th", "loc", "public", "pg", "ocr", "config", "cr", "cher", "fr", "sc", "rest", "fac", "sel", "rc", "child", "enter", "rec", "pr", "enc", "uc", "der", "ub", "c", "r", "ch", "ph", "usr", "car", "conv", "keep", "client", "pub", "sl", "cf", "sq", "Cur", "http", "coll", "sr", "oc", "ah", "per", "sth", "tur", "cb", "ver", "conn", "result", "prev", "ctr", "sur", "impl", "attr", "ser", "ctrl", "last", "cha"], "i": ["ti", "ii", "ui", "image", "x", "I", "p", "phi", "di", "name", "j", "type", "ai", "ni", "io", "si", "v", "pi", "n", "c", "e", "xi", "chi", "d", "li", "id", "field", "ci"], "pics": ["pcs", " pic", "spcs", " picks", "spic", "Pics", "picks", "Pcs", " pcs", "Pic", "spicks", "Picks", "pic", "spics"], "out_of_order": ["out_or_orders", "out_or_info", "out_or_order", "out_of_desc", "out_or_desc", "out_of_info", "out_of_orders"], "out_idx": ["out_sidxs", "out_idxs", "out_Idi", "out_sidxc", "out_Idxc", "out_startx", "out_startxs", "out_starti", "out_Idx", "out_startxc", "out_sidi", "out_idxc", "out_Idxs", "out_sidx", "out_idi"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047, "substitutes": {"dst_errp": ["dst_err", "dst_rr", "dst_rpc", "dst_erp", "dst_erb", "dst_errorpc", "dst_errorps", "dst_raiser", "dst_errorP", "dst_errps", "dst_errr", "dst_raisel", "dst_erpre", "dst_rP", "dst_errorr", "dst_raisep", "dst_rrP", "dst_errl", "dst_irr", "dst_irp", "dst_erP", "dst_rp", "dst_errorl", "dst_erps", "dst_erpc", "dst_rrps", "dst_rrp", "dst_rrr", "dst_errorp", "dst_errorb", "dst_errb", "dst_raiseb", "dst_rpre", "dst_errpre", "dst_rrpre", "dst_errpc", "dst_errP", "dst_irps", "dst_erl"], "local_err": ["localallrr", "loc_var", "localallvar", "local_r", "local_var", "local___arr", "local_req", "remote_error", "local_er", "Local_gr", "global_err", "local_rr", "loc_rr", "local___req", " local_arr", "local___err", "local_type", "local_error", "Local_err", "remote_err", "global_r", "global_error", "localallerror", "global_er", "Local_r", "loc_err", "remote_type", " local_error", " local_rr", " local_req", "localallerr", "local_arr", "remote_er", "Local_er", "loc_error", "local___error", "local_gr", " local_er"]}}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "substitutes": {"ret": ["req", "expr", "iter", "fit", "cache", "template", "test", "buffer", "seq", "path", "reg", "aux", "result", "active", "final", "ctr", "output", "tr", "model", "wrapper", "ctx", "alt", "Ret", "prep", "prefix"], "TCGv": ["TCGatef", "TCGuv", "TCGenervc", "TCMGvv", "TCGWvs", "TCGsvm", "OCGvv", "TCGcv", "TCGenevan", "PCGcv", "TCGatep", "TCGenerv", "PGGMV", "TCGV", "TCGev", "TCGroupvc", "TCgcv", "PGGV", "TCGeneralvc", "TCGvs", "TCGp", "TCGuver", "TCGMV", "TCgev", "TCGroupf", "PCGp", "TCGroupev", "TCgvan", "TCgvc", "TCGlv", "TCGMvm", "PCgf", "OCGuvv", "OCGvr", "TCgver", "TCGlf", "TCGroupv", "PCgv", "TCGatecv", "TCGWf", "TCGenevv", "TCGep", "TCGuvv", "TCGver", "TCGsV", "PCgvv", "TCGvr", "TCGWev", "TCgv", "TCCGV", "TCCGvr", "PCGvv", "TCGvm", "TCMGv", "PGGvr", "TCGlvan", "OCGuver", "TCCGv", "TCCGvm", "TCGarf", "TCGarvs", "PCGv", "TCGMv", "TCgf", "PCGvan", "PGGMv", "TCGenervs", "PCGev", "TCgvr", "PCgev", "TCGenef", "TCGeneralvs", "TCGMvr", "PCgcv", "PCGvs", "TCGlvv", "OCGuv", "OCGuvr", "TCGeneralv", "TCGatev", "TCGeneralf", "PGGv", "TCGarev", "TCGvan", "TCGecv", "TCGef", "TCGuvr", "TCGf", "PCgvc", "TCGsvr", "PCGf", "TCgvv", "TCGenev", "TCMGvr", "PCGvc", "PGGMvr", "PGGvm", "PCgvs", "TCGsv", "OCGver", "TCGvv", "TCGvc", "PCgvan", "TCMGver", "TCGWv", "TCgvs", "PCgp", "TCgp", "PGGMvm", "TCGWvc", "OCGv", "TCGenerf", "TCGarv"], "uint32_t": ["uint32_n", "uint8_T", "uint32_int", "uint16_T", "uint16_p", "uint8_f", "uint32_f", "uint32_p", "uint8_t", "uint32_T", "uint16_n", "uint16_t", "uint8_int"]}}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 22065, "substitutes": {"STATUS_PARAM": ["STATUS_AVAS", "STATUS_PAS", "STATUS_VAR", "STATUS_AVAME", "STATUS_VAS", "STATUS_VAM", "STATUS_VAME", "STATUS_PARAME", "STATUS_PARAR", "STATUS_AVAR", "STATUS_PAR", "STATUS_PAM", "STATUS_AVAM", "STATUS_PAME", "STATUS_PARAS"], "aSign": ["asSign", "AExp", "aScript", "arScript", " aShift", "aMod", "alphaSign", "aaMod", "ASign", "vaSign", "vaDig", "aaScript", "alphaExp", "aDig", "arSign", " aMod", " aScale", "asScale", "aaComp", "APass", " aIgn", "aaShift", "aeScale", "vaIgn", "anPass", " aDig", "anExp", "arExp", "saExp", " aPass", "alphaMod", "asExp", "saScale", "aaDig", "aeSign", "aaIgn", "arComp", "aScale", " aComp", "anDig", "aeExp", "saSign", " aScript", "aIgn", "aShift", "aaExp", "aPass", "vaShift", "aaSign", "anSign", "ADig", "aComp"], "aExp": ["laScale", "pEx", "aEXP", " aExpl", "vaExt", "AExp", "vaEXP", "saExt", "aCl", "anEXP", "aExpl", "vaEx", "ARaw", "gaEx", " aRaw", " aEXP", "anaEx", "anEx", "saExpl", "anotherEXP", "pExp", "alphaExp", "AComp", " aScale", "amaExp", "alphaEXP", " aCl", "anaExp", "alphaExt", "amaNorm", "vaExp", "anExp", "anotherEx", "anRaw", "saExp", "laExp", "anComp", "gaEXP", "pCl", "aEsc", "gaEsc", "anotherScale", "pSign", "alphaComp", "aScale", "aComp", " aComp", "amaEx", "aExt", "aDecl", "saEx", "anCl", " aEsc", "gaExp", "anotherExp", "vaEsc", "aRaw", "anaDecl", "laEXP", "anaNorm", " aDecl", "amaDecl", " aNorm", "vaExpl", "ACl", "laEx", "anSign", "anExt", "aNorm", " aExt", "aEx", " aEx"], "shiftCount": ["hiftType", "hiftCast", "hiftSum", "ShiftCount", "hiftcount", " shiftType", "sliceCount", "shiftType", "shiftSum", "pushType", "sliceCast", "hiftCount", " shiftcount", "pushCast", " shiftSum", "ShiftSum", "slicecount", "shiftCast", "Shiftcount", "pushCount", "pushcount", " shiftCast", "shiftcount"], "aSig": ["aDsigma", "aVsIG", " aSuign", "aPresIG", "aPresigs", "aUsig", "aJsIG", "aSligs", "aSlim", "aAsiger", "aVsature", "aVsign", "aPsigs", "aPsIG", " aAsigs", "aPresig", "aAsigs", "aSiger", " aSlig", " aSlim", "aJsign", "aIssIG", " aAsign", "aSim", "aDsign", " aSigma", "aPsig", "aCassign", "aDsIG", " aAsature", "aDsigs", "aPresiger", "aSuign", "aSigs", "aCassig", "aSuigma", "aSigma", "aDsig", "aSature", "aAsign", "aEsigs", "aAsIG", " aAsiger", " aSIG", "aAsigma", "aCassiger", "aVsig", "aSlIG", "aSIG", "aPsim", "aJsigma", "aIssiger", "aEsign", " aSuiz", "aEsIG", " aSuig", " aSature", " aSim", " aAsigma", " aAsig", " aSiger", "aJsig", "aIssigma", "aEsig", "aIssig", "aCassigs", " aAsIG", " aSigs", "aPresigma", "aEsigma", "aSuig", " aSligs", "aAsature", " aSuigma", "aDsiz", " aSiz", "aUsign", "aUsigma", "aPresign", " aSlIG", "aDsiger", "aEsiz", "aSlig", "aJsigs", "aAsig", "aSuiz", "aUsigs", "aSiz"], "savedASig": ["savedASigma", "savingAsign", "savedASign", "savedPSiger", "savedNASigma", "savedSIG", "savedASIG", "saveAsiger", "savedSiger", "saveAsIG", "savedASiger", "saveASIG", "saveAsigma", "savedSig", "savingAsigma", "savingASigma", "savingAsIG", "savedNASig", "savedPSIG", "saveASigma", "savedPSign", "saveAsign", "savedAsigma", "saveAsig", "savedAsign", "savedSign", "savedAsIG", "saveASig", "savingASign", "savingASIG", "savingAsig", "savedAsiger", "savedNASign", "saveASiger", "savedNASIG", "saveASign", "savedPSig", "savedAsig", "savingASig", "savedSigma"], "z": ["Z", "zip", "cz", "x", "w", "p", "h", "sa", "code", "ce", "j", "za", "ez", "f", "zh", "q", " w", "b", "v", "nz", "k", "a", "zen", "n", "c", "iz", "e", "spin", "y", "l", "r", "zone", "ze", "u", "tz", "zer", "zz", "d", "qa", "yz", "i", "zi", " Z", "shift", "gz", "sign", "t", "oz", "m", "az", "g", "zo"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 22082, "substitutes": {"bs_queue": ["vs_file", "ns_que", "blocks_file", "b_file", "blocks_entry", "b_que", "bs_file", "bc_entry", "ns_parent", "b_queue", "bs_parent", "blocks_que", "bc_que", "bc_client", "bs_channel", "vs_que", "vs_server", "ns_channel", "bs_server", "vs_queue", "bc_queue", "blocks_queue", "b_entry", "bs_client", "bs_que", "vs_entry", "ns_queue", "blocks_server"], "bs": ["lb", "ins", "iss", "bb", "lc", "css", "bid", "bis", "ds", "ses", "blog", "bas", "fs", "bl", "b", "ss", "state", "bin", "BS", "buf", "sub", "ps", "base", "sb", "bps", "cb", "bos", "bits", "cs", "bp", "blocks", "bes", "lbs", "pb", "bytes", "ob", "bc", "bot", "bal", "obj", "bing", "gs", "gb", "os", "plugins", "fb", "vs", "lib", "ubs", "ns", "ls", "eb", "obs", "ba", "js"], "flags": ["fixes", "settings", "states", "options", "forces", "linux", " Flags", "status", "s", "stats", "types", "ants", "fs", "mask", "fee", "state", "files", "seq", "utils", "feat", "styles", "lag", "bits", "fun", "rules", "fl", "cs", "ils", "Flags", "fd", "locks", "args", "ports", "fps", "lbs", "parts", "vals", "size", "ops", "features", "ips", "bugs", "caps", "iffs", "flag", "data", "FLAG", "fx", "fg", "plugins", "fields", "sf", "vs", "codes", "util", "ints", "ags", "properties", "bytes"], "bs_entry": ["bsPqueue", "bsPcheck", "ns_enter", "bs_file", "bc_entry", "bsPenter", "bsPentry", "vs_Entry", "ss_queue", "bs_check", "bs_service", "ss_entry", "bs_Entry", "ss_enter", "bs_module", "bs_enter", "bs_reader", "bc_Entry", "vs_queue", "bc_queue", "ss_service", "vs_enter", "bc_file", "ns_module", "vs_check", "bs_rance", "vs_rance", "vs_entry", "ns_reader", "ns_entry"]}}
{"project": "FFmpeg", "commit_id": "808c10e728db2d92ccbb0f8b3bcd4a2f4305a2cf", "target": 0, "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        AVBPrint part[3], int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    av_bprint_init(part+0, 0, 1);\n\n    av_bprint_init(part+1, 0, 1);\n\n    av_bprint_init(part+2, 0, 65536);\n\n\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                av_bprintf(part+0, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(parent);\n\n            }\n\n        }\n\n        av_bprintf(part+1, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    av_vbprintf(part+2, fmt, vl);\n\n\n\n    if(*part[0].str || *part[1].str || *part[2].str) {\n\n        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;\n\n        *print_prefix = lastc == '\\n' || lastc == '\\r';\n\n    }\n\n}\n", "idx": 22086, "substitutes": {"ptr": ["br", "class", "p", "offset", "buffer", "proc", "Ptr", " pointer", "nt", "ref", "tr", "pos", "porter", "mount", "eth", "uint", "dr", "pad", "addr", "ext", "adr", "trace", "desc", "src", "jp", "address", "fr", "pc", "touch", "fd", "tip", "private", "point", "inter", "peer", "transfer", "slice", "comp", "inst", "eger", "h", "reference", "length", "thread", "pt", "r", "tmp", "fp", "later", "kind", "fi", "slave", "primary", "ctx", "tty", "push", "typ", "ace", "alloc", "code", "pair", "pointer", "nil", "dll", "ctr", "str", "port", "cp", "attr", "pty", "remote"], "level": ["line", "stage", "cl", "lf", "depth", "loc", "ln", "mode", "length", "temp", "len", "scale", "base", "style", "col", "letter", "lang", "kind", "point", "layer", "scope", "count", "lvl", "vel", "unit", "Level", "levels"], "fmt": ["flt", "vformat", " filt", "Fmt", "Flt", "filt", "hformat", "hnt", "Filt", "fformat", "vlt", " fformat", "hilt", "Fformat", "Fnt", " fret", "fret", "Fret", "vmt", "vret", "fnt", " flt", " fnt", "hmt"], "vl": ["iv", "ure", "lc", "bb", "lf", "ol", "el", "wl", " lvl", "buffer", "var", "tl", "ln", "lan", "nb", "vv", "mt", "v", "len", "vol", " LP", "lp", "fl", "nl", "l", " l", "erv", "ll", "pl", "split", "lv", "lvl", "kl", "vc", " ls", "ls", "ld", "icle", "ml"], "part": ["time", "line", "class", "p", "step", "half", "offset", "info", "art", "order", "detail", "sector", "base", "old", "key", "pre", "function", "PART", "pos", "diff", "data", "product", "count", "pad", "component", "add", "phase", "no", "comment", "try", "item", "partial", "stage", "section", "bit", "name", "year", "only", "entry", "from", "page", "format", "parts", "point", "cond", "Part", "id", "work", "group", "division", "element", "word", "change", "state", "argument", "error", "pt", "patch", "or", "ch", "connection", "instance", "member", "unit", "front", "block", "pair", "and", "object", "start", "position", "day", "result", "but", "span", "layer", "split", "obj", "one", "pty", "self", "list"], "print_prefix": ["print_format", "printlogname", "write_token", "print__gap", " print_fix", "printlogformat", "print__fix", "printableprefix", "printloggap", "logableformat", "log_format", "log_prefix", "print_gap", "write_offset", "log_gap", "printlogprefix", "log_fix", "write_name", "print__prefix", "print_token", "printablegap", "printlogoffset", "print_offset", "write_prefix", "logablefix", "printableformat", "logableprefix", "print_fix", "logablegap", "printlogfix", "print_name", "printablefix", "print__format", "printlogtoken", " print_format"], "type": ["time", "line", "match", "class", "p", "cross", "info", "like", "order", "base", "user", "ref", "key", "pre", "function", "py", "at", "count", "all", "comment", "var", "pe", "call", "cat", "val", "name", "status", "year", "types", "index", "y", "format", "point", "rule", "size", "target", "model", "Type", "id", "group", "resource", "pr", "option", "length", "ype", "rel", "error", "style", "or", "value", "unit", "sys", "t", "op", "typ", "ty", "x", "block", "link", "code", "TYPE", "object", "other", "where", "ver", "span", "post", "port", "layer", "in", "attr", "ping", "number", "list", "tag"], "avc": ["afcs", "afac", "avecs", "afl", "avf", "Avcs", "ajf", "Avcu", "aul", "Avf", "ajb", "avlc", " avlc", "avac", "aff", "aveac", "avC", "avb", "avl", "aulc", "afcu", "avcu", "afct", "AvC", " avcu", " avC", " avl", "ajC", "afc", " avf", "auc", " avcs", "avect", "Avc", "auct", "avec", "avelc", " avac", "ajc", "avcs", "Avb", "aflc", "avel", "avct", " avb"], "parent": ["class", "cache", "p", "offset", "mother", "tax", "family", "anc", "father", "ref", "key", "source", "null", "component", "term", "Parent", "master", "owner", "pe", "test", "current", "pid", "name", "loc", "public", "cot", "pc", "none", "fat", "common", "point", "anch", "size", "api", "target", "child", "id", "author", "comp", "channel", "children", "pr", "ac", "reference", "option", "rel", "temp", "c", "pt", "root", "or", "connection", "instance", "ctx", "unit", "file", "g", "op", "pool", "pa", "pointer", "and", "coll", "gap", "other", "per", "paren", "path", "o", "conn", "col", "result", "port", "layer", "parents", "self", "remote"]}}
{"project": "FFmpeg", "commit_id": "1f4ff53aea7c5090f31cd1323d95f7c407c9b2bb", "target": 0, "func": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)\n\n{\n\n    if (cid != ctx->cid) {\n\n        int index;\n\n\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);\n\n            return AVERROR(ENOSYS);\n\n        }\n\n        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);\n\n\n\n        ff_free_vlc(&ctx->ac_vlc);\n\n        ff_free_vlc(&ctx->dc_vlc);\n\n        ff_free_vlc(&ctx->run_vlc);\n\n\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n\n                 ctx->cid_table->ac_bits, 1, 1,\n\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,\n\n                 ctx->cid_table->dc_bits, 1, 1,\n\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n\n                 ctx->cid_table->run_bits, 1, 1,\n\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n\n\n        ctx->cid = cid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22089, "substitutes": {"ctx": ["cv", "cu", "lc", "css", "co", "anc", "kw", "utils", "ca", "cas", "cs", "bc", "pkg", "component", "act", "lib", "wp", "support", "cl", "gp", "setup", "xc", "jp", "cc", "loc", "ce", "cli", "config", "pc", "Context", "cmd", "sc", "fw", "cm", "qa", "np", "rc", "voc", "mc", "cfg", "cci", "na", "sci", "git", "c", "hw", "fp", "cal", "connection", "conv", "fi", "tc", "scope", "cca", "cpp", "ci", "sys", "client", "cam", "cf", "cms", "general", "gc", "sync", "linux", "cus", "qq", "coll", "fc", "ck", "cb", "tx", "conn", "kb", "chan", "wcs", "cp", "obj", "vc", "txt", "cmp", "ctrl", "nc", "context", "cn", "exec"], "cid": ["lcip", "cfname", "Cip", "uID", "gname", " cID", "cide", "cuids", "cname", "ciden", "fid", "ride", "rid", "ucurl", "noid", "cuID", "gip", "Cname", "nID", "acId", "pname", "csID", "acid", "curl", "foid", "acaid", "dcide", "pid", "fids", "rID", "lcurl", "raid", "pids", "acname", "nid", "dcids", "acids", "caid", "lcid", "cfurl", " cname", "acide", "cuiden", " cId", "lcname", "cfoid", "Cid", "ucId", "ucID", "lcId", "cId", "csid", " cide", "cids", "lcoid", "cip", "acip", "dcname", "gid", " cids", " ciden", "ucid", "gids", " curl", "csiden", "fID", "acID", "uurl", "uid", " coid", "nids", "cfid", "coid", " cip", "pip", "cID", "dcid", " caid", "uId", "cuid", "csids", "Cids"], "index": ["comment", "element", "update", "part", "image", "match", "x", "ion", "section", "access", "sync", "block", "location", "num", "date", "offset", "loc", "j", "address", "length", "insert", "type", "info", "len", "view", "position", "path", "action", "search", "ind", "found", "find", "active", "key", "edit", "connection", "end", "value", "size", "connect", "weight", "instance", "pos", "member", "append", "pull", "input", "count", "i", "id", "column", "Index", "level", "slice", "include", "context", "add", "node", "inc", "prefix"]}}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n", "idx": 22093, "substitutes": {"avctx": [" avcn", "akcms", "attcmp", "avcn", "afcmp", " avcms", "mpcontext", "autctx", "mpctx", "autcmp", "attctx", "AVcms", "autcms", "mpcmp", "evcmp", "attcms", "akcn", "afcn", "avjp", "mpca", "afca", "avcontext", "evca", "AVctx", "akctx", "akcontext", " avcf", "evctx", "autcontext", "AVcontext", "Avjp", "Avctx", "avcmp", " avjp", "Avcf", " avcontext", "afcf", "avcms", "afjp", "afctx", "avcf", "afcms", "evcontext", "avca", "AVcmp", "attcontext", "Avcontext", "afcontext"], "x4": ["ax2004", "X4", "x14", "x54", "exfour", "work4", "ax40", "i72", "i4", "cross54", "i004", "wa104", " x384", "ax6", "viewoutput", "x40", "X44", " x54", "xi400", "f6", "q2004", " x484", "ifour", "X40", " x104", "y2", "q004", "x2", "f2", "X14", "axfour", "X2", "p104", "y84", "xi384", " xoutput", " x04", "view14", " x14", "q72", "u004", "Xfour", "u04", "u4", " x400", "x84", "cross400", "u72", "x44", "xfour", "qfour", "ex004", "x2004", "f04", "cross4", " x004", "X84", "x400", "pfour", "crossfour", "xoutput", "u6", "x004", " xfour", " x6", "f4", " x24", "rx40", "x484", "yfour", "xi4", "work84", "wa4", "wa004", "ax04", "y4", "x104", "wa54", "cross24", "view4", "cross6", "cross104", " x44", "xi14", "rx44", "rxfour", "xi484", "ufour", "ax4", "f14", "xioutput", " x2", "cross384", "xi24", "y2004", "ax104", "view484", "p4", "cross004", "x384", "ex4", "rx4", "q4", "ex6", "x04", "x24", "x72", "p40", "x6", "ffour", " x40", "workfour", "work2"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n", "idx": 22094, "substitutes": {"env": ["iv", "console", "ev", "iss", "eni", "en", "enc", "queue", "ea", "priv", "code", "que", "ef", "config", "eng", "equ", "net", "enh", "ep", "vm", "v", "ah", "exc", "ench", "next", "err", "e", "enable", "osc", "style", "conn", "args", "erv", "end", "fi", "profile", "viron", "np", "rc", "environment", "eu", "txt", "er", "nc", "context", "enter", "exec", "ec", "ext"], "sigset": ["sigmaset", " sigcase", "sigmasc", "sigermatch", "psigset", "psigSET", " siget", "swigmatch", "siget", "sigmaget", "sigsend", " sigSET", "sigercheck", "sigend", "ssigmaend", "dsigsbase", "sIGcase", " sigget", "ssigmacheck", "sigsSET", "ssigend", "sigcase", "sigsget", "ssigmatch", "sighset", "psigmacheck", " sigsSET", "siggbase", "dsiget", "dsigsset", "sigmatch", "sigssc", "swigbase", "sigmamatch", "sigmacheck", "sigerend", "sigmaSET", "dsigset", " sigmatch", "sigget", "sigmaend", "psigmaset", "sigSET", "sIGend", "sIGSET", " sigend", "sigsset", "sigsbase", " sigscase", "ssigcheck", "sigmacase", "sighmatch", " sigsget", "swigset", "ssigmamatch", "ssigmaset", "psigsc", " sigsset", "psigmaSET", "sigscase", "sigbase", " sigsmatch", "sigmaet", "dsigbase", "psigmasc", "sIGget", "sighbase", "swigend", "segcheck", "siggset", "segSET", "sIGet", " sigsend", "sigscheck", "sigerset", "ssigset", "psigcheck", "sIGset", " sigsbase", "sigcheck", "segsc", "segset", " sigbase", "sigsmatch", "swigcheck", "sigsc"], "sigmask": ["sirmask", " sigmark", " sigmash", "siematch", "sigmuth", "smmak", "sighik", " sirmak", "sigmaik", "sirmuth", "sigguth", " sirmuth", "siggask", "sigmake", "sirmak", "siemask", " sigmaak", " sirmask", "sigmaallow", "sigmauth", "siemallow", "sigmatch", "sirmark", "sigash", "siemak", "sirmatch", " sirmatch", "sighak", " sirmik", "sigmaake", " sigmauth", "sigmaask", "sigmik", " sigmaake", " sigmuth", " sigmatch", "sirmik", "symash", "sigake", "sigmaatch", "semicallow", " sirmark", " sigmaask", "siggatch", " sirmake", "sigmark", "semicask", "siggak", "sigmak", "sirmash", "symask", " sigmak", " sigmallow", " sirmash", " sigmake", "sirmake", "sigmallow", "smmask", " sirmallow", "sigmaak", "sirmallow", "sigark", "smmuth", "sighask", "sigmash", "sigask", "semicake", "semicatch", "symake", "sighake", "smmake", "siemake", " sigmik", "symark", "siggake"], "r": ["br", "ler", "ur", "ner", "mr", "rs", "p", "rar", "rt", "f", "s", "cr", "sr", "order", "rh", "b", "v", "vr", "c", "ar", "err", "R", "rr", "nr", "e", "l", "kr", "hr", "or", "result", "u", "run", "rd", "rn", "d", "rc", "re", "rf", "k", "rw", "dr", "m", "reader", "er", "lr", "rl", "z", "rb", "rg"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n", "idx": 22132, "substitutes": {"opaque": [" opusher", "opusher", "opec", "ospaque", "opque", "ospacity", "opacity", " opque", "operaques", "ospque", "iopec", "ospec", "ompaques", "ompusher", "operusher", " opacity", "iopque", "ompaque", " opaques", "operacity", "operaque", " opec", "ompacity", "opaques", "iopaque", "iopacity"], "s": ["php", "settings", "S", "close", "secure", "w", "p", "sym", "ls", "sync", "sa", "ses", "ds", "f", "sec", "fs", "is", "ss", "si", "b", "a", "c", "opens", "sie", "o", "sb", "e", "u", "services", "es", "d", "ops", "ssl", "gs", "i", "self", "os", "sys", "sf", "socket", "server", "open", "sl", "ns", "sg", "g", "js"]}}
{"project": "FFmpeg", "commit_id": "de1824e970d448a84bedce4936c301c322baa714", "target": 0, "func": "static int mpeg_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    Mpeg1Context *s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n\n    av_dlog(avctx, \"fill_buffer\\n\");\n\n\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {\n\n        /* special case for last picture */\n\n        if (s2->low_delay == 0 && s2->next_picture_ptr) {\n\n            *picture = s2->next_picture_ptr->f;\n\n            s2->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return buf_size;\n\n    }\n\n\n\n    if (s2->flags & CODEC_FLAG_TRUNCATED) {\n\n        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n\n\n\n        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)\n\n            return buf_size;\n\n    }\n\n\n\n    s2->codec_tag = avpriv_toupper4(avctx->codec_tag);\n\n    if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32(\"VCR2\")\n\n                                           || s2->codec_tag == AV_RL32(\"BW10\")\n\n                                          ))\n\n        vcr2_init_sequence(avctx);\n\n\n\n    s->slice_count = 0;\n\n\n\n    if (avctx->extradata && !avctx->frame_number) {\n\n        int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);\n\n        if(*data_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"picture in extradata\\n\");\n\n            *data_size = 0;\n\n        }\n\n        if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n\n            return ret;\n\n    }\n\n\n\n    return decode_chunks(avctx, picture, data_size, buf, buf_size);\n\n}\n", "idx": 22137, "substitutes": {"avctx": ["alcam", "avecam", "aveca", "ajcam", "airctx", "aucontext", "aircf", "versync", "afcoll", "avecas", "ajcu", "avectx", "aucas", "avekb", "AVcontext", "afloc", "avsync", "ajcal", "avcas", "avesync", "afcci", "avecu", "avecmp", "avctrl", "AVcam", "afca", "avcontext", "aveloc", "ajct", "afct", "aircas", "alcv", "vercontext", "afkb", "avcv", "ajcontext", "aircontext", "avecmd", "afcam", " avconn", "ajcci", "afcas", "avca", "ajcmd", "afcontext", "avecoll", "ajctx", "avcal", "afcv", "airctrl", "avloc", "afctrl", "avkb", "ajkb", "avecontext", "avcu", " avcoll", "avcoll", "afconn", "aircam", "avcmp", "avect", "avcam", "afcf", "avcmd", "AVcmp", "avct", "alcmp", "aucf", "avecci", "avecal", "auctx", "afcal", "afcmp", "avecf", "ajcmp", "avecv", "afcmd", "verctx", "afcu", "avconn", "AVctx", "ajloc", "avcci", "vercoll", "alctx", " avctrl", " avcas", " avcontext", "ajcf", "afctx", "avcf", "afsync", "aveconn", "ajca"], "data": ["du", "image", "cache", "src", "p", "DATA", "queue", "block", "code", "img", "buff", "buffer", "frame", "val", "pack", "length", "au", "config", "sample", "start", "body", "media", "a", "audio", "next", "view", "board", "library", "base", "database", "dat", "photo", "message", "tmp", "batch", "result", "window", "fp", "value", "size", "api", "video", "pos", "input", "memory", "reader", "i", "iterator", "Data", "slice", "package", "bytes"], "data_size": ["batch_stream", "slice_number", "ata6sized", "data6size", "batch_size", "data_sized", "data_cache", "data2size", "ata6needed", "batch_cache", " data_len", "slice_size", "data2sized", "data2mode", "data_unit", "buf_size", " data_scale", "data_needed", "ata_sized", "data_number", "data_offset", "data_mode", "ata6mode", "slice_ize", " data_count", "data_scale", "data_stream", "data2needed", "batch_offset", "ata_needed", "buf_scale", "data6needed", "data_len", "data6mode", "data_count", "slice_unit", "ata_mode", "data_ize", "buf_mode", "data6sized", "ata6size", "ata_size"], "avpkt": ["avvpkt", "abfkt", "avlpck", " avfpsth", "avvpacket", "avedcht", "avdud", "avpaud", "avfpks", "avPkt", "avepkt", "abfck", "avPks", "avPnt", " avfpnt", "avpcht", "avbks", "avbkt", " avpsth", " avfpkt", "abpkt", "avfud", "avvpatt", "avfpnt", "avfpsth", "avdacket", "avedkt", "avedud", " avpnt", "avdcht", "abfacket", "avfcht", "avpaacket", "avpacht", "abfatt", "avepud", "avvpck", "avbsth", "avlpatt", "avlpacket", " avfpks", "avbnt", "abpck", "avlpkt", "avfck", "avdkt", "avpatt", "avpck", "avpks", "avpakt", "avfatt", "avfpkt", "avpnt", "avepcht", "avepacket", "avedacket", "avPsth", "avpsth", "abpatt", "avpud", " avpks", "avpacket", "avfkt", "avfacket", "abpacket"], "buf": ["home", "cf", "br", "box", "wb", "cv", "uf", "alloc", "src", "wav", "queue", "block", "code", "img", "buff", "buffer", "frame", "bd", "proc", "length", "config", "uc", "b", "raw", "seq", "next", "feat", "cb", "cas", "vec", "fd", "fp", "batch", "result", "pb", "bag", "fi", "conv", "bc", "cp", "ctx", "pad", "fb", "rb"], "s": ["params", "sets", "S", "sq", "rs", "p", "h", "ls", "aws", "sym", "sa", "sac", "http", "ses", "ds", "f", "stats", "fs", "ss", "si", "b", "ts", "v", "n", "c", "utils", "spec", "ps", "hs", "nas", "e", "cs", "r", "args", "service", "session", "u", "qs", "services", "ssl", "share", "gs", "su", "m", "sys", "t", "sf", "g", "ns", "sg", "sl", "js"], "picture": ["image", "doc", "p", "sea", "img", "pic", "buffer", "ana", "frame", "info", "config", "stat", "media", "audio", "avi", "Picture", "uri", "library", "storage", "photo", "jpg", "fp", "filename", "meta", "fi", "profile", "summary", "li", " pictures", "video", "bank", "obj", "ctx", "movie", "slice", "pict", "feature", "csv", "cam", "file", "package"], "s2": ["is2", "ns82", "csecond", "d62", "sg2", "s82", "ns4", "Stwo", "ws0", "f12", "awssecond", "ss2", "c02", "ns62", "c4", "nstwo", "s5", "p0", "sys1", "sys5", " s6", "c1", "ps256", "s256", "ssecond", "is62", "f2", "sbs", "sgbs", "ptwo", "f82", "session62", "ss0", "d2", "ds2", "c62", "hs62", "ftwo", "snow", "ctwo", " snow", "sbc", "s4", "sys0", "ps2", " stwo", "cbc", "h1", "ks62", "s0", "S82", "s12", "sstwo", "hs12", "ns256", " s4", "p62", "hsbs", "s02", "ws82", "ks2", " s62", "sessionnow", "nssecond", "istwo", "p2", "sys2", "ls82", "nsnow", "s1", "ls256", "s62", "ws2", " sbc", "ns12", "lstwo", "S2", "p1", "ss6", "nsbs", "htwo", "ks02", "dtwo", "ls2", "sg4", "wstwo", " s5", "ws256", "sysbc", " s1", "ns2", "ds02", "dstwo", "hs2", "stwo", "sII", "c2", "s6", "ds1", "h02", "sys62", "pstwo", "sgnow", "sessiontwo", "sys4", "ks1", "awstwo", "session2", "dnow", "ps82", "c256", "S12", " sII", "p02", "isnow", "h2", "sgII", "aws2", "sg12", " s0", "ws6", "sg62", "c5", "nsII", "aws256"]}}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n", "idx": 22140, "substitutes": {"opaque": ["opac", "paque", "operatile", "pac", "ompa", "pa", "transac", "paco", "iopaco", "ompac", "ompaco", "opacity", "opatile", "oplacity", "opaco", " opatile", " opac", "oppaco", "opa", "oplaques", "operac", "oppa", "oplaco", " opaco", "iopaques", " opacity", "ompaque", " opaques", "transatile", "oppaque", "oplaque", "operacity", "operaque", "transaque", "opaques", "transacity", "iopaque", "iopacity", "oppac"], "chr": ["chrar", "qrar", "chru", "chro", "cherc", "CHrar", "qru", "phru", "phri", "cherr", "chsr", "Chr", "CHsr", "mutr", "qro", " chri", "qr", "phr", "ochr", "ochrr", "chri", " chrar", "cher", "chrr", " chrs", "qri", "mutm", "mutrr", " chm", " chsr", "CHri", "ochrar", "chm", "CHr", "ochrc", " chro", "attr", " chrr", "qsr", "attrc", "Chrr", "phro", " chru", "attrr", "attrar", "chrs", "Chrs", "chrc", "cherar", "mutrs", "Chm"], "s": ["S", "sq", "ks", "secure", "rs", "south", "p", "sym", "aws", "sync", "se", "http", "ses", "ds", "f", "sec", "sr", "is", "si", "b", "ss", "sc", "state", "n", "c", "spec", "hs", "ps", "sb", "o", "sie", "e", "cs", "space", "r", "service", "session", "services", "es", "ops", "ssl", "gs", "self", "os", "sys", "conf", "m", "sf", "socket", "sl", "ls", "sg", "g", "sv", "ns", "js"], "size": ["zip", "time", "capacity", "shape", "x", "empty", "en", "enc", "code", "el", "val", "loc", "type", "address", "length", "f", "name", "offset", "sec", "start", "body", "Size", "content", "fee", "n", "c", "SIZE", "scale", "send", "sum", "e", "min", "l", "limit", "clean", "ize", "end", "small", "li", "weight", "pos", "rc", "count", "grade", "i", "unit", "form", "speed", "large", "z", "ec", "sn"], "len": ["full", "ler", "line", "iter", "cl", "lin", "lc", "en", "lit", "Len", "enc", "num", "lf", "el", "val", "ln", "le", "loc", "lim", "length", "f", "lan", "dl", "ni", "body", "n", "seq", "fl", "min", "l", "conn", " length", "limit", "span", "ll", "li", "pos", "count", "fin", "ell", "fail", "kn", "dy", "lon", "sl", "ls", "z", "ld", "ann"], "buf": ["Buffer", "cap", "br", "empty", "cv", "wb", "uf", "alloc", "src", "bb", "queue", "block", "buff", "buffer", "loc", "bd", "config", "uc", "cmd", "b", "bh", "exc", "raw", "seq", "bin", "cb", "cas", "vec", "fl", "fd", "fp", "byte", "blocks", "result", "ref", "batch", "str", "bag", "ff", "bc", "pos", "rc", "data", "ctx", "null", "fb", "array", "map", "context", "rb", "pool", "bytes"]}}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n", "idx": 22151, "substitutes": {"opts": ["opps", "cpts", "optx", "opouts", " oppt", " optts", "operments", " opTS", "operta", "cptes", "pputs", "opTS", "optte", "opments", "opets", "opt", "opted", "verte", "opertes", "pptx", "appts", "depts", "hopts", "optpt", "hopte", "verts", "OPts", "optuts", "hoptics", "cpops", "cputs", "deptes", "sette", "popouts", "optops", "optta", "opttes", "optes", "ffets", "argte", "argouts", "ffuts", "setts", "setops", "depments", "ffts", "OPt", " opouts", "operts", "fftx", "poppt", " opttx", "opte", " opps", "settes", "optps", "hopted", "oppt", "optted", "appte", "experte", "popTS", "optics", " opt", "experted", " optuts", "argts", "experts", "apputs", "ppts", "optTS", "setuts", "opops", "veruts", "setted", "optts", "verouts", "optments", "popts", "appted", "OPTS", "arguts", "ppets", "optouts", " optets", "opta", "oputs", "optt", "opttics", "depta", "expertics", "OPps"], "val": ["VAL", "def", "p", "lc", "lit", "pal", "elt", "f", "valid", "base", "key", "ref", "py", "pre", "vals", "gen", "bc", "pos", "data", "k", "la", "lib", "ld", "all", "var", "part", "doc", "al", "call", "pid", "name", "loc", "j", "fail", "msg", "b", "len", "fl", "ind", "fat", "sel", "cond", "rule", "pl", "ll", "alt", "arg", "let", "serv", "il", "eval", "text", "pr", "label", "enc", "vert", "local", "el", "func", "pass", "aval", "v", "rel", "err", "pt", "l", "cal", "value", "li", "url", "vel", "unit", "live", "sl", "g", "it", "ul", "x", "nil", "ana", "bl", "bin", "vol", "slot", "ver", "play", "ee", "str", "split", "vc", "Val", "cel", "util", "rl", "exec", "ol"]}}
{"project": "qemu", "commit_id": "5829b097204189c56dd1fb62c7f827360394bb39", "target": 0, "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd, colour;\n\n    int args, len;\n\n    int x, y, dx, dy, width, height;\n\n    struct vmsvga_cursor_definition_s cursor;\n\n    uint32_t cmd_start;\n\n\n\n    len = vmsvga_fifo_length(s);\n\n    while (len > 0) {\n\n        /* May need to go back to the start of the command if incomplete */\n\n        cmd_start = s->cmd->stop;\n\n\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n\n        case SVGA_CMD_UPDATE:\n\n        case SVGA_CMD_UPDATE_VERBOSE:\n\n            len -= 5;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n\n            break;\n\n\n\n        case SVGA_CMD_RECT_FILL:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            colour = vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_FILL_ACCEL\n\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_RECT_COPY:\n\n            len -= 7;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            dx = vmsvga_fifo_read(s);\n\n            dy = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_RECT_ACCEL\n\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_DEFINE_CURSOR:\n\n            len -= 8;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            cursor.id = vmsvga_fifo_read(s);\n\n            cursor.hot_x = vmsvga_fifo_read(s);\n\n            cursor.hot_y = vmsvga_fifo_read(s);\n\n            cursor.width = x = vmsvga_fifo_read(s);\n\n            cursor.height = y = vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            cursor.bpp = vmsvga_fifo_read(s);\n\n\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n\n            if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n\n                    goto badcmd;\n\n            }\n\n\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n#ifdef HW_MOUSE_ACCEL\n\n            vmsvga_cursor_define(s, &cursor);\n\n            break;\n\n#else\n\n            args = 0;\n\n            goto badcmd;\n\n#endif\n\n\n\n        /*\n\n         * Other commands that we at least know the number of arguments\n\n         * for so we can avoid FIFO desync if driver uses them illegally.\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n", "idx": 22155, "substitutes": {"s": ["south", "secondary", "p", "us", "f", "si", "a", "sb", "storage", "u", "details", "gs", "i", "conf", "multi", "your", "spec", "phys", "src", "current", "ses", "ds", "an", "status", "results", "is", "b", "strings", "n", "e", "blocks", "services", "parts", "os", "set", "states", "S", "lines", "sym", "site", "ions", "its", "v", "state", "c", "r", "service", "es", "m", "sys", "t", "client", "server", "g", "new", "settings", "sets", "sq", "series", "sync", "http", "request", "native", "o", "result", "session", "d", "features", "ssl", "self", "sf", "ns", "sg", "js"], "cmd": ["cfg", "req", "cf", "def", "cl", "MD", "call", "cd", "code", "cc", "force", "name", "shell", "msg", "mode", "head", "md", "config", "dict", "cli", "init", "comm", "seq", "header", "bind", "c", "cb", "path", "send", "pipe", "conn", "module", "cookie", "Cmd", "kind", "history", "command", "gen", "target", "cp", "input", "ctx", "id", "grad", "ctrl", "client", "nc", "method", "dom"], "colour": ["thin", "image", "text", "template", "our", "h", "event", "blue", "color", "force", "grey", "type", "msg", "f", "background", "config", "dict", "bg", "md", " colours", "b", "win", "v", "dh", "view", "theme", "c", "quad", "feat", "action", "style", "draw", "cycle", "col", "ch", "vt", "window", "l", "output", "str", "ll", "i", "dr", "gb", "vc", "rect", "fn", "t", "fg", "g", "qt", "rg"], "args": ["params", "debug", "lines", " flags", "flags", "doc", "axis", "partial", "call", "num", "val", "frame", " arg", "dim", "md", "config", "rows", "body", "next", "Args", "argument", "fun", "err", "style", "min", "l", "col", "blocks", "parts", "size", "pos", "data", "count", "arr", "self", "arg", "fields", "all", "bytes"], "len": ["part", "delay", "il", "line", "light", "lin", "lc", "en", "lit", "Len", "pid", "label", "lf", "num", "el", "val", "ln", "lim", "elt", "dim", "length", "name", "lan", "dl", "nn", "rev", "ni", "lt", "bl", "body", "win", "n", "seq", "bin", "fun", "err", "vec", "fl", "duration", "l", "non", "nt", "limit", "span", "lang", "del", "size", "ll", "li", "layer", "split", "pos", "syn", "count", "lvl", "alt", "fin", "ell", "fn", "fail", "list", "yn", "lib", "lon", "sl", "ls", "ld", "ann"], "x": ["image", "w", "xy", "ix", "pe", "p", "h", " X", "X", "ex", "val", "name", "ax", "f", "xs", "rx", "b", "win", "v", "xx", "pixel", "wx", "index", "n", "c", "e", "l", "tx", "xi", "u", "d", "pos", "input", "xt", "i", "m", "fx", "t", "work", " i", "px", "z"], "y": ["ey", "ym", "ty", "ny", "cy", "w", "xy", "yl", "h", "p", "sky", "wy", "sy", "hy", "yt", "ye", "oy", "type", "f", "year", "start", "b", "iy", "yer", "ry", "n", "ys", "ady", "ya", "py", "yi", "d", "vy", "yy", "i", "yd", "yn", "zy", "Y", "yo", "lon", "z", "ay"], "dx": ["w", "xy", "ix", "ex", "depth", "eddy", "distance", "ds", "dim", "length", "ax", "md", "xs", "start", "rx", "dh", "xx", "index", "wx", "tick", "ady", "ind", "min", "tx", "xi", "py", "del", "dd", "d", "foo", "data", "phy", "pad", "fx", "px", "z"], "dy": ["delay", "thin", "dj", "xy", "gy", "depth", "eddy", "distance", "di", "den", "ds", "dim", "length", "md", "dl", "yer", "dh", "dq", "dir", "ady", "tail", "py", "del", "dd", "d", "foo", "phy", "yy", "dn", "zy", "lon", "z"], "height": ["ty", "shape", "thin", "image", "rank", "hd", "w", "layout", "png", "h", "ht", "th", "gy", "inches", "gh", "img", " heights", "depth", "distance", "above", "dim", "length", "margin", "volume", "driver", "rh", "Height", "html", "images", "padding", "lat", "arrow", "build", "duration", "huge", "window", "crop", "hang", "size", "bottom", "weight", "d", "quality", "hold", "resolution", "pull", "z", "angle", "density"], "cursor": ["curation", "bcuration", "ccurses", "lcuration", "lcoder", "lcurses", "ccuration", "coder", "lcursor", "bcursor", "ccursor", "ccoder", "bcoder", "curses", "bcurses"], "cmd_start": ["md_add", "cmdnend", "md_starting", "cmdnstarting", "cmd_end", "cmd_st", "md_st", "cmdnadd", "cmd_starting", "md_start", "md_end", "cmd_id", "cmd_add", "cmdnstart", "md_id"]}}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 22167, "substitutes": {"st": ["nd", "inst", "sts", "kt", "stage", "src", "test", "stack", "dt", "ft", "td", "stat", "ST", "start", "mt", "St", "ss", "sc", "ct", "sth", "rest", "sw", "sb", "ast", "pt", "style", "sta", "nt", "std", "str", "d", "est", "ist", "data", "ost", "sp", "sd", "t", "sf", "sl", "this", "sec", "ld", "ste"], "buf": ["Buffer", "desc", "cap", "br", "cf", "wb", "cv", "cache", "uf", "alloc", "src", "queue", "mem", "block", " buffer", "buff", "buffer", "xff", "db", "bd", "proc", "config", "f", "func", "uc", "cur", "grab", "bf", "cmd", "b", "feed", "exc", "temp", "seq", "cb", "path", "vec", "cas", "ab", "fa", "fd", "tmp", "fp", "result", "window", "aux", "pb", "brace", "output", "bag", "fi", "ff", "bc", "append", "data", "ctx", "pad", "fb", "context", "rb", "bytes"], "end": ["END", "desc", "element", "close", "event", "en", "enc", "block", "End", "offset", "max", "ender", "start", "len", "ended", "index", "rest", "c", "send", "path", "begin", "e", "enable", "result", "format", "run", "output", "post", "ending", "port", "after", "pos", "url", "append", "est", "api", "id", "ad", "open", "last", "edge", "ent", "enter", " End", "stop", "set", "ext"], "sysfspath": ["sysfispad", "sysfSPath", "sysfsspATH", "sysfsspaths", "sysfbspATH", "sysfsspath", "sysfcSPth", "syscspth", "syscspath", "syscspATH", "syscaspad", "sysfsSPATH", "sysfSPp", "sysfcspeth", "sysfpash", "sysfsport", "syscaspth", "sysfspad", "sysfpeth", "sysfbspaths", "sysfasport", "syscaspATH", "sysfspaths", "sysfispATH", "sysfscath", "sysfcspth", "sysfbsport", "sysfcSPeth", "sysfcspash", "sysfaspp", "sysfSPth", "sysfSPash", "sysfspth", "sysfaspATH", "sysfcspath", "sysfspATH", "sysfaspaths", "sysfscash", "sysfSPeth", "sysfcSPath", "sysfbspath", "syscaspath", "sysfsSPp", "sysfSPATH", "sysfbspth", "syscaspaths", "syscsport", "sysfscth", "sysfspeth", "sysfSPaths", "sysfcSPash", "sysfpth", "syscasport", "sysfispath", "sysfsspp", "sysfspash", "syscspaths", "sysfpp", "sysfpaths", "syscspad", "sysfispaths", "sysfaspth", "sysfaspad", "sysfpATH", "sysfsSPath", "sysfsceth", "sysfaspath", "sysfbspad", "sysfpath", "sysfspp", "sysfsSPaths", "sysfport"], "ret": ["req", "match", "res", "lit", "rt", "info", "det", "f", "valid", "art", "feat", "base", "fun", "nt", "ref", "opt", "addr", "no", "ext", "part", "iter", "rets", "num", "cat", "bit", "db", "val", "fail", "status", "bf", "gd", "len", "gt", "back", "fd", "fat", "format", "std", "flag", "re", "arr", "id", "alt", "arg", "fin", "pet", "att", "mem", "rev", "expected", "mt", "html", "temp", "r", "run", "orig", "success", "resp", "fit", "code", "ft", "RET", "reg", "result", "out", "wrap", "str", "post", "sur", "reply", "rf", "obj", "xt", "Ret"], "max_segments": ["max_begs", "max_SEments", "max_pegements", "max_psegment", "max_presections", "max_begment", "max_begements", "max_pregments", "max_SEgment", "max_SEgments", "max_SEgs", "max_pregs", "max_segs", "max_SEgements", "max_pegments", "max_pesections", "max_psegments", "max_psegs", "max_sesections", "max_pegs", "max_segment", "max_segements", "max_pregment", "max_sements", "max_begments", "max_pegment", "max_psesections", "max_pements"]}}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201, "substitutes": {"s": ["settings", "states", "sets", "S", "south", "sq", "rs", "p", "sym", "aws", "sync", "site", "sa", "http", "ses", "status", "f", "ds", "xs", "stats", "is", "fs", "ss", "ts", "si", "sis", "b", "state", "n", "c", "spec", "sie", "ps", "o", "sb", "submit", "storage", "e", "cs", "args", "service", "session", "services", "es", "ops", "side", "ssl", "gs", "i", "self", "os", "sys", "m", "t", "conf", "sf", "su", "ns", "g", "sg", "js"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250, "substitutes": {}}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n", "idx": 22265, "substitutes": {"bs": ["lb", "ins", "abi", "cms", "rs", "iss", "cache", "bb", "sync", "css", "us", "bid", "db", "bis", "ds", "ses", "banks", "s", "bas", "as", "fs", "bl", "b", "ss", "bh", "bt", "BS", "utils", "ps", "base", "sb", "bps", "bits", "bos", "cs", "ab", "blocks", "bytes", "pb", "uses", "outs", "bc", "bot", "bing", "gs", "gb", "os", "plugins", "fb", "vs", "server", "ns", "ls", "rb", "bi", "js"], "options": ["Options", "settings", "params", "cache", "acl", "option", "info", "config", "offs", "stats", "fs", "ts", "files", "opens", "base", "bits", "args", "aux", "fp", "private", "opt", "details", "op", "includes", "ops", "outs", "ips", "pos", "obj", "os", "objects", "plugins", "array", "exec", "properties"], "flags": ["settings", "lines", "ats", "reads", "bit", " Flags", "status", "info", "s", "types", "stats", "ants", "fs", "mask", "utf", "len", "files", "opens", "lag", "bits", "fun", "rules", "fl", "nl", "ils", "Flags", "locks", "args", "prot", "parts", "vals", "ops", "features", "ips", "flag", "FLAG", "fields", "ints", "properties", "bytes"], "errp": ["errr", " errcp", " errps", "errpre", "erP", "erpre", "errP", "Erpre", "errcp", " errP", " errpre", "err", "Erp", "ErP", "errps", "Erps", "Err", "rorps", " errr", "rorcp", "Ercp", "erp", "rorp", "rorP"], "client": ["circ", "cl", "secure", "cache", "p", "call", "core", "use", "co", "http", "ac", "cat", "ce", "cli", "proxy", "public", "app", "config", "q", "pc", "request", "Client", "cmd", "io", "con", "c", "parent", "base", "handler", "conn", "session", "manager", "private", "connection", "cm", "plugin", "api", "cp", "ssl", "wrapper", "url", "container", "ctx", "self", "bird", "server", "open", "socket", "util", "ctrl", "cn", "resource", "cell", "remote"], "ret": ["req", "att", "def", "res", "resp", "rets", "reset", "fit", "al", "lit", "ait", "mem", "code", "num", "cat", "rt", "val", "bit", "fail", " Ret", "status", "det", "ft", "valid", "f", "rev", "sr", "art", "length", "mt", "bf", "pass", "RET", "ry", "len", "back", "buffer", "fun", "reg", "base", "conn", "nt", "result", "ref", "run", "final", "out", "opt", "str", "tr", "hard", "url", "reply", "flag", "re", "data", "job", "rc", "obj", "id", "alt", "arg", "fin", "success", "Ret", "pet", "let", "ext"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22270, "substitutes": {"opaque": ["opac", "iopacle", "opec", "OPaque", " opc", "OPc", "opacity", "opacle", "oacity", "octaque", "oacle", "octac", "OPec", " opac", "opc", " opacity", "iopaques", "iopaque", " opaques", "oaques", "OPac", " opec", "octc", "oaque", "opaques", "octec", " opacle", "iopacity"], "addr": ["dc", "offset", "rt", "art", "hop", "seq", "adder", "base", "amd", "pos", "data", "eth", "dr", "pad", "oa", "grad", "add", "no", "ext", "adr", "part", "kt", "src", "ea", "ord", "loc", "ada", "address", "config", "md", "none", "cmd", "asm", "len", "align", "amp", "osi", "args", "arr", "id", "ad", "alt", "arg", "ip", " address", "enc", "bridge", "host", "ac", "mode", "nr", "dd", "url", "ptr", "afi", "node", "ace", "x", "code", "route", "pointer", "start", "mac", "cb", "conn", "layer", "cmp", "od", "az"], "retval": ["resultvalid", "argvalid", "rtvalid", "retvals", "altv", "RETvals", "altval", "Retvals", "altvals", "defvalid", "altVAL", "retvalid", "RETvalid", " retVAL", "RetVAL", "Retvalid", "rtVAL", "Retval", "defVAL", "defval", " retvals", "altfail", "retVAL", "retvalue", "defeval", "argvalue", "RETvalue", "defsel", "RETeval", "defvals", " retv", "reteval", "argVAL", " retvalid", "rtfail", "resultval", " retvalue", "resultsel", "rtv", "argvals", "retv", "RETval", "retfail", "rtval", "argeval", "rtsel", " reteval", "retsel", " retfail", "altvalid", "argval", "resultVAL", "RETVAL"], "d": ["dm", "dc", "nd", "x", "pd", " dd", "p", "cd", "dt", "di", "db", "bd", "ds", "f", "md", "dl", "D", "gd", "b", " da", "dh", "c", "da", "o", "dat", "e", "l", "fd", "u", "dad", "data", "id", "sd", "dr", "ad", "m", "t", "i", "grad", "ded", "od", "vd", "z", "ld"]}}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276, "substitutes": {"env": ["console", "iss", "ev", "esi", "eve", "eni", "en", "enc", "ea", "code", "her", "el", "db", "ef", "chal", "eng", "config", "inv", "enh", "v", "eur", "exc", "ench", "err", "estate", "e", "engine", "conn", "him", "esm", "erv", "profile", "viron", "Environment", "impl", "emb", "obj", "environment", "eu", "er", "vs", "enter", "context", "loader", "qt", "exec", "energy", "ec", "ext"], "tlb": ["ptlb", " trb", "ttl", "ptlam", "llb", "trb", "Tbl", "Tlr", "tl", "ttrb", "llc", " tlam", "ttlb", " tlc", "tlr", "tbm", "llam", "ttlam", " tl", "atlr", "ttbl", "atbm", "tlc", "ll", "Tlb", " tbm", "Tbm", "atlb", "ptbl", "atbl", "tbl", " tlr", "ttlc", "ptrb", "tlam", " tbl"], "tlbncfg": ["slbanfg", "tlbmconn", "tlbmfg", "tlbmconf", "tlfncfg", "tlfnconfig", "lbncfg", "tlgincf", "slbnconn", "tlboncfg", "tlbnConfig", "tlBNconn", "tlbnconfig", "tlBNconfig", "tlginconfig", "tlbenconfig", "tlbinfg", "tlbinConfig", "lbmconfig", "tlbinconfig", "slbnfg", "tlbmcfg", "tlBNcfg", "lbnconn", "tlginConfig", "lbmfg", "tlgincfg", "tlbonfg", "tlbmcf", "tlbncf", "lbmcfg", "lbnconfig", "lbnfg", "slbanconn", "tlfncf", "tlbanconf", "tlbincf", "tlfnfg", "tlbanconn", "tlbincfg", "slbncfg", "tlbonconf", "tlbnconf", "lbmcf", "tlBNcf", "tlbenconn", "tlbanfg", "lbnConfig", "tlbmconfig", "tlbnfg", "lbncf", "tlbencf", "tlbancfg", "slbnconf", "tlbnconn", "tlbmConfig", "lbmconn", "lbmConfig", "tlbencfg", "tlbonconn", "slbancfg", "slbanconf"], "tlbm_size": ["tlBM_size", "tlbm_ize", "tlbon_size", "tlbm_sum", "tlbh_rate", "tlbh_ize", "tlbm_source", "tlbon__size", "tlbmxscale", "tlbm__scale", "tlbh_size", "tlbm_scale", "tlbon_speed", "tlbn_mode", "tlbm_type", "tlbm_name", "tlbmxspeed", "tlBM_source", "tlbn_scale", "tlbon_ize", "tlbm__size", "tlbmxmode", "tlbm2name", "tlbm2rate", "tlbh_type", "tlbon__speed", "tlbm__ize", "tlbm_mode", "tlbon__ize", "tlbm_rate", "tlbh_name", "tlbh_speed", "tlbon__scale", "tlBM_sum", "tlbm2size", "tlbon_scale", "tlbh2name", "tlbm__mode", "tlbh2type", "tlbm__speed", "tlbmxsize", "tlbh2size", "tlbh2rate", "tlbn_size", "tlbm_speed", "tlbm2type", "tlbn_speed"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n", "idx": 22279, "substitutes": {"xfer": ["axender", " xener", "yporter", "wfer", " xputer", "pxferred", "viewter", "xfar", "yFER", "xacher", "xener", " xter", "wcer", "pxfen", "yxfar", "byfen", "plusfer", " xformer", "ylporter", "lexferred", "wFER", "xeder", " xender", "rxference", "txference", "xference", "xferred", " xfar", "xporter", "plusformer", "helfen", "fxender", "lexfer", "yxcer", " xger", "axformer", "xxfen", "fxter", "axference", "lexporter", " xcer", "yxFER", "xff", "xxporter", "yxfer", "helfer", "txfer", "yference", "xter", "pxFER", "xffen", "axporter", "ylputer", "xFER", "txfen", "byfer", "xxfer", "xcer", "txger", "xformer", "viewference", "rxporter", "axener", "axeder", "byference", "xender", "Xf", "xxference", "yafer", "xf", "axfer", " xacher", "plusener", "xger", "yfer", "helporter", "xxputer", "pxfer", " xeder", "helference", "Xfer", "xputer", " xference", "fxacher", "ylfer", "xfen", "rxfer", "axter", "lexference", "yaferred", "pxference", " xporter", "fxference", "viewfer", " xf", "axputer", "yleder", "byger", "xffer", "pxf", "yaference", "xxf", "xfference", "wfar", "Xporter", " xFER", " xfen", "pxporter", "plusference", "viewacher", "fxfer", "Xputer", "rxfen", "fxputer", "yaporter"], "port": ["test", "host", "pointer", "proxy", "ort", "proc", "config", "ported", "pass", " Port", "mac", "hop", "parent", "path", " transport", "nat", "ports", "gate", "end", "post", "tr", "target", "porter", "PORT", " sport", "Port", "ip"], "ep": ["channel", "req", "ek", "gp", " epoch", "ev", "ec", "p", " ip", "el", "ef", "ream", "mp", "pp", "seq", "Ep", "e", "pipe", "ew", "xp", " Ep", "fp", " EP", "point", "op", "EP", "eps", " p", " esp", " e", "cp", "dep", "sp", "esp", "ap", "phase", "eb", "dp", "yp", "ext", "ip"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n", "idx": 22280, "substitutes": {"acb": [" acf", "ascp", "Acp", "Acl", "akp", "acl", "acsbe", "akf", " acl", "ascbr", "acp", "akb", "acf", "Acb", "acbr", "acsb", "acsp", " acp", " acbe", "Acbe", "ascf", "acbe", "akbr", " acbr", "acsl", "ascb"], "elem": ["eeject", "element", "eject", "eade", "elete", "Elete", "eelev", "kelement", "Elem", "peject", " elam", " eade", "aeleg", "belem", "kelem", "eelee", "oelem", "elev", "elee", "ebm", "aelement", "oelete", "elam", "pebm", "eelam", "beleg", "belements", "eelements", " element", "eleg", "keject", "eeade", "aelements", "Elements", " elev", "eelem", " elee", "eelete", "Elee", "pelam", "oelee", "elements", "eebm", "oelements", "eelement", "pelement", "eeleg", "pelem", "peade", " elements", "pelete", "belement", "kelements", " elete", "pelements", "Elev", " ebm", "aelem"], "pool": ["loop", "full", "timeout", "cl", "box", "pa", "cache", "round", "p", "row", "queue", "host", "block", "platform", "que", "call", "plus", "rol", "wl", "clock", "fail", "proxy", "pg", "pm", "poll", "object", "coll", "pc", "widget", "wa", "lock", "lane", "iam", "thread", "parent", "table", "hole", "conn", "flow", "place", "col", "batch", "page", "module", "gro", "ref", "guard", "connection", "pl", "lam", "port", "worker", "wrapper", "container", "Pool", "job", "four", "role", "sem", "rain", "ping", "work", "allow", "client", "list", "server", "lib", "group", "file", "prefix", "serv"]}}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 22300, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "5952b8da0b7f65dfa23991e71737e0abdaeb339c", "target": 1, "func": "static int seek_test(const char *input_filename, const char *start, const char *end)\n\n{\n\n    AVCodec *codec = NULL;\n\n    AVCodecContext *ctx= NULL;\n\n    AVCodecParameters *origin_par = NULL;\n\n    AVFrame *fr = NULL;\n\n    AVFormatContext *fmt_ctx = NULL;\n\n    int video_stream;\n\n    int result;\n\n    int i, j;\n\n    long int start_ts, end_ts;\n\n\n\n    size_of_array = 0;\n\n    number_of_elements = 0;\n\n    crc_array = pts_array = NULL;\n\n\n\n    result = avformat_open_input(&fmt_ctx, input_filename, NULL, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't open file\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avformat_find_stream_info(fmt_ctx, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't get stream info\\n\");\n\n        return result;\n\n    }\n\n\n\n    start_ts = read_seek_range(start);\n\n    end_ts = read_seek_range(end);\n\n    if ((start_ts < 0) || (end_ts < 0))\n\n        return -1;\n\n\n\n    //TODO: add ability to work with audio format\n\n    video_stream = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n\n    if (video_stream < 0) {\n\n      av_log(NULL, AV_LOG_ERROR, \"Can't find video stream in input file\\n\");\n\n      return -1;\n\n    }\n\n\n\n    origin_par = fmt_ctx->streams[video_stream]->codecpar;\n\n\n\n    codec = avcodec_find_decoder(origin_par->codec_id);\n\n    if (!codec) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't find decoder\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx = avcodec_alloc_context3(codec);\n\n    if (!ctx) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate decoder context\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = avcodec_parameters_to_context(ctx, origin_par);\n\n    if (result) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't copy decoder context\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avcodec_open2(ctx, codec, NULL);\n\n    if (result < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Can't open decoder\\n\");\n\n        return result;\n\n    }\n\n\n\n    fr = av_frame_alloc();\n\n    if (!fr) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate frame\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);\n\n    if (result != 0)\n\n        return -1;\n\n\n\n    for (i = start_ts; i < end_ts; i += 100) {\n\n        for (j = i + 100; j < end_ts; j += 100)\n\n        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 0);\n\n        if (result != 0)\n\n            return -1;\n\n    }\n\n\n\n    av_freep(&crc_array);\n\n    av_freep(&pts_array);\n\n    av_frame_free(&fr);\n\n    avcodec_close(ctx);\n\n    avformat_close_input(&fmt_ctx);\n\n    avcodec_free_context(&ctx);\n\n    return 0;\n\n}\n", "idx": 22316, "substitutes": {"input_filename": ["inputingfile", "inputlocklocation", "input64filename", " input_file", "image_filename", "image_document", "inputingfilename", "input_location", "input64location", "inputlockdocument", "input64document", "inputingdocument", "input_file", "image_file", "input64file", "inputlockfile", "inputlockfilename", " input_document", "input_document", " input_location"], "start": ["first", "time", "create", "x", "origin", "starting", "scan", "use", "offset", "name", "load", "address", "length", "info", "cur", "art", "init", "send", "range", "from", "play", "pre", "source", "size", "in", "read", "pos", "before", "mid", "id", "Start", "open", "add", "stop", "set", "get"], "end": ["END", "nd", "time", "p", "en", "vert", "End", "offset", "address", "length", "max", "len", "ended", "view", "index", "send", "range", "r", "limit", "size", "ending", "after", "in", "est", "append", "id", "last", "edge", "stop", "set"], "codec": [" coduc", "preduc", "odesc", " codesc", "predec", "Codef", "metec", " codformat", "odEC", "codeef", "meteca", "codiac", "cod\n", "indesc", "codesc", "codEC", "predesc", "codeec", "pedef", "prederc", " codocol", "metesc", "CodEC", "odformat", " coderc", "coduc", "pedec", " codiac", "metEC", "od\n", "odec", "indec", "codeformat", "codformat", "inderc", "codeca", "Codec", "predocol", "odeca", "Codeca", "indiac", "codeesc", "pedEC", "coderc", "codef", "indocol", "induc", "pedesc", " cod\n", "prediac", "codeEC", "Codesc", "code\n", "codocol"], "ctx": ["mc", "cf", "crit", "cv", "xc", "src", "jp", "lc", "cu", "sync", "cc", "loc", "cli", "config", "coll", "cr", "pc", "rx", "uc", "anc", "cmd", "fc", "mac", "kw", "c", "fw", "parent", "cb", "ca", "cas", "cs", "tx", "conn", "chan", "fp", "hw", "ch", "auc", "cm", "conv", "wcs", " context", "np", "cp", "bc", "qa", "obj", "scope", "concept", "vc", "cca", "cpp", "pkg", "txt", "fn", "client", "ctrl", "grad", "cmp", "lib", "context", "exec", "cam", "cn", "voc"], "origin_par": ["Origin_par", "origin__par", "origin_param", "originpydep", "origin_dep", "origin_p", " origin_dep", "origin__comp", "origin_rec", "originityadr", "origin_comp", "origin__param", "originityarc", "Origin_pos", "Origin_p", "originpycomp", "origin_arc", "originpypar", " origin_rec", "origin_adr", "Origin_adr", "originitydep", "origin__rec", "origin_pc", " origin_arc", "originitypar", " origin_comp", "origin_pos", "originpyarc", "Origin_comp", " origin_param", "originitypos", "Origin_pc", "originitycomp"], "fr": ["req", "iframe", "res", "cv", "jp", "img", "rt", "frame", "coll", "fs", "vr", "err", "vec", "play", " frame", "fps", "frac", "ff", "tr", "fi", "progress", "arr", "fx", "fin", "mult", "feature", "fram", "FR", "fm"], "fmt_ctx": ["fmt_cp", "fmt_cn", "fmtjctx", "frt_cf", "fMT_tx", "fmt2context", "fmt_ci", "fmt2ctx", "fmt2loc", "fmt_cf", "frt_ctx", "fMT_loc", "fmtjconfig", "filt_config", "fmtjcontext", "fmtjci", "frt_comp", "frt_tx", "filt_cp", "fmt_tx", "fMT_context", "filt_ctx", "fmt_context", "fMT_ctx", "fmt2tx", "frt_cn", "fmt_comp", "frt_context", "filt_context", "filt_ci", "fmt_loc", "fmt_config"], "video_stream": ["picture_channel", "videoflowstream", "videokurl", "videoadform", "video_url", "videoingurl", "origin_src", "videoadstream", "picturekrec", "videoalsrc", "video_channel", "video_src", "originalstick", "origin_group", "videoalstick", "origin_stick", "videokchannel", "video_string", "media_thread", "videoalstream", "video_stick", "videokrec", "videoingchannel", " video_tag", "picturekurl", "videoingstream", "videoflowgroup", "originalstream", " video_coll", "videoflowstick", "videoingrec", "picturekstream", " video_form", "video_coll", "videoalgroup", "originalsrc", "videoadcoll", "video_form", "video_thread", "originalgroup", "picture_stream", "media_string", "media_stream", "picture_rec", "media_form", "picturekchannel", "origin_stream", "video_rec", "videoadtag", "video_tag", "videoflowsrc", "videokstream", "video_group", "picture_url"], "result": ["first", "br", "match", "true", "res", "answer", "use", "date", "info", "valid", "cur", "order", "mask", "range", "sum", "rate", "function", "source", "diff", "data", "product", "count", "score", "total", "term", "successful", "comment", "try", "compl", "catch", "runner", "mr", "event", "test", "row", "current", "status", "results", "ret", "back", "page", "final", "cup", "weight", "rc", "child", "grade", "work", "method", "package", "resource", "reason", "length", "counter", "dict", "pass", "Result", "df", "err", "error", "duration", "root", "value", "after", "instance", "member", "done", "success", "record", "new", "full", "mer", "response", "coll", "sr", "gap", "request", "report", "next", "math", "search", "ver", "acc", "message", "found", "session", "cmp", "number", "feature", "mark"], "i": ["ii", "x", "I", "p", "f", "b", "v", "a", "n", "index", "c", "o", "e", "y", "l", "u", "d", "in", "li", "k", "id", "ci", "z", "it"], "j": ["ii", "ok", "jp", "p", "step", "section", "jump", "f", "b", "v", "n", "adj", "o", "range", "e", "r", "pos", "obj", "J", "k", "m", "t", "it", "aj", "z", "op", "js"], "start_ts": [" start_tes", "start_TS", "startNTS", "start_points", "start_tz", "start_times", "end_points", "end_TS", " start_times", "startNpoints", "start_acks", "startIPtz", "startThetz", " start_dt", "startTheacks", "write_types", "startIPacks", "writeThetypes", "write_ts", "startThets", "startNts", "start_dt", "write_acks", "writeThets", "start_tes", "start_types", "startThetypes", "startNtimes", "write_tz", "writeThetz", "end_times", "writeTheacks", "startIPts", "startIPtypes"], "end_ts": ["start_tz", "end_Ts", "start_times", "end_ms", "start_Ts", "end36times", "end\u00b7ms", "end_offs", "start_tt", "end\u00b7times", "end_tz", "end36ts", "start_ms", "start_ets", "start_offs", "end36tt", "end_tt", "end_ets", "end\u00b7ets", "end36Ts", "end\u00b7ts", "end_times"]}}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330, "substitutes": {"bus": ["loop", "Bus", "BUS", "cache", "bridge", "host", "sync", "us", "cat", "http", "db", "drive", "proxy", "config", "driver", "controller", "lock", "feed", "io", "bug", "device", "ux", "board", "base", "serial", "user", "engine", "service", "boot", "hub", "connection", "plugin", "fi", "port", "bc", "product", "mount", "plug", "usb", "socket", "lib"], "cmd": ["dc", "nd", "cfg", "req", "def", "cl", "class", "MD", "host", "cd", "call", "code", "cc", "num", "name", "type", "msg", "mode", "md", "config", "proc", "head", "func", "cli", "ack", "magic", "device", "content", "comm", "mac", "callback", "seq", "cod", "header", "buf", "c", "bind", "cb", "path", "fun", "send", "handler", "conn", "module", "cookie", "Cmd", "ctr", "kind", "cm", "plugin", "domain", "command", "count", "ctx", "id", "mid", "pkg", "grad", "cmp", "client", "ctrl", "addr", "method", "node", "prefix"], "address": ["channel", "ace", "inet", "shape", "image", "interface", "attribute", "each", "event", "eni", "host", "location", "route", "date", "offset", "pointer", "length", "config", "object", "order", "ress", "device", "content", "uri", "index", "header", "position", "path", "alias", "error", "handler", "message", "email", "service", "connection", "output", "end", "point", "size", "source", "command", "target", "attr", "slave", "grade", "array", "number", "component", "server", "addr", "network", "Address", "enter", "package", "resource", "ip"], "len": ["delay", "line", "partial", "lin", "lc", "en", "Len", "mem", "block", "lf", "num", "lim", "el", "val", "ln", "loc", "offset", "length", "nn", "lan", "dl", "dim", "f", "lock", "body", "n", "seq", "fun", "base", "fl", "ind", "min", "l", "conn", "nt", "limit", "end", "del", "size", "ll", "gen", "li", "pl", "pos", "split", "url", "count", "lvl", "alt", "fin", "fn", "list", "un", "dy", "addr", "lon", "sl", "ld", "all", "non"], "data": ["channel", "delay", "def", "cache", "DATA", "queue", "block", "di", "buffer", "name", "load", "msg", "length", "response", "config", "start", "body", "content", "a", "uri", "buf", "dat", "alpha", "message", "result", "byte", "format", "connection", "str", "size", "command", "d", "after", "reply", "input", "memory", "id", "pad", "ad", "reader", "Data", "addr", "new", "bytes"], "i2c_bus": ["i2c_loop", "i2c2usb", "i2c__loop", "i2chJboot", "i2cJbus", "i2f_bus", "i2c__usb", "i2vc_space", "i2cJbit", "i2c_boot", "i2cADux", "i2cPubplugin", "i2ct_proc", "i2c2bridge", "i2ce_controller", "i2c_usb", "i2cAMbus", "i2cADblock", "i2vcAMbus", "i2c_ux", "i2vcAMspace", "i2cADbus", "i2cJboot", "i2cu__bus", "i2cADproc", "i2c6boot", "i2cu__usb", "i2c6bus", "i2vc_controller", "i2cu_bus", "i2c__bus", "i2f_Bus", "i2cPubbit", "i2xc_bus", "i2vcAMcontroller", "i2c__bridge", "i2ch_boot", "i2vc_boot", "i2cPubboot", "i2c_space", "i2ct_bus", "i2c_plugin", "i2c_bridge", "i2c_controller", "i2c_use", "i2ctADblock", "i2ct_block", "i2cu_boot", "i2cAMboot", "i2c_block", "i2ctADbus", "i2c_root", "i2f_bridge", "i2c_driver", "i2cJplugin", "i2cu__loop", "i2vc_bus", "i2cin_bis", "i2c_bis", "i2cu_usb", "i2xc_serial", "i2c_bit", "i2c_proc", "i2xc_root", "i2cPubbus", "i2f_usb", "i2c_serial", "i2cin_block", "i2ce_bus", "i2cin_bus", "i2c_fail", "i2ch_bus", "i2cin_die", "i2chJplugin", "i2cAMcontroller", "i2vcAMboot", "i2cu_loop", "i2c2Bus", "i2c6controller", "i2chJbus", "i2c6space", "i2ce_use", "i2c__boot", "i2ctADux", "i2ct_ux", "i2c__Bus", "i2chJbit", "i2cu__boot", "i2ch_plugin", "i2ctADproc", "i2c2bus", "i2c_Bus", "i2cAMspace", "i2c_die", "i2ch_bit", "i2xc_fail", "i2ce_driver"], "i": ["ti", "ii", "abi", "ui", "qi", "I", "ix", "p", "eni", "block", "phi", "di", "buffer", "val", "ri", "j", "info", "f", "ai", "type", "s", "ini", "oi", "ni", "is", "io", "b", "si", "v", "a", "n", "index", "uri", "c", "pi", "e", "ind", "l", "xi", "fi", "d", "li", "iu", "id", "m", "mi", "ci", "multi", "array", "addr", "udi", "gi", "ip"]}}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 22361, "substitutes": {"c": ["C", "dc", "cf", "cy", "w", "cit", "cache", "cv", "p", "h", "lc", "cu", "xc", "enc", "cc", "co", "ac", "ce", "f", "config", "s", "cur", "uc", "b", "oc", "v", "ct", "fc", "n", "con", "ca", "e", "cs", "l", "u", "cm", "d", "ctx", "vc", "m", "ci", "client", "ctrl", "context", "cn", "g", "ec", "icc"], "lumFilter": ["lumfilter", "lufFile", "lumFil", "lumFile", "Lumbfilter", "lacFile", "lumbFil", "lacfilter", "lumbFile", "lumbfilter", "LumFil", "lufFilter", "lufFil", "luffilter", "lacFil", "LumbFil", "LumbFilter", "lacFilter", "LumbFile", "lumbFilter", "Lumfilter", "LumFilter", "LumFile"], "lumSrc": ["lumaAsnc", "lumSysrc", "lumSRC", "lumAsvc", "lumVSRC", "lumAsRC", "lumSysnc", "lumaAsrc", "lumaSrc", "lumSysRC", "lumSnc", "lumSvc", "lumAsrc", "lumAsnc", "lumVSrc", "lumaAsRC", "lumVSvc", "lumaSRC", "lumVSnc", "lumSysvc", "lumaSnc", "lumaAsvc", "lumaSvc"], "lumFilterSize": ["lumControlC", "lumfilterExport", "lmpFilterC", "lumfilterSize", "lumFileC", "lumControlExport", "lumFileExport", "lumFilterExport", "lmpFilterExport", "lumFilterC", "lmpfilterExport", "lumControlSize", "lmpfilterSize", "lmpfilterC", "lumfilterC", "lmpFilterSize", "lumFileSize"], "chrFilter": ["chrfConfig", "shrFl", "chmSource", "chmFl", "chrConfig", "chrFl", "chbFl", "chbSource", "shrfFl", "shrfConfig", "shrfSource", "shrConfig", "shrSource", "chmFilter", "chrfFilter", "chrSource", "chmConfig", "shrFilter", "chrfSource", "shrfFilter", "chrfFl", "chbFilter", "chbConfig"], "chrUSrc": ["chrSSsrc", "chrUSSec", "chrfSSrs", "chrVSec", "chrUSSsrc", "chrUSSrc", "chrUSsrc", "chrVSrs", "chrVSsrc", "chrfSSrc", "chrfSSsrc", "chrfSSec", "chrfUSsrc", "chrSSrs", "chrfUSrs", "chrfUSec", "chrUSrs", "chrSSrc", "chrfUSrc", "chrUSSrs", "chrSSec", "chrUSec"], "chrVSrc": ["chrSdc", "chrbVsrc", "chrVSdc", "chrRSRC", "chrSsrc", "chrbVSsrc", "chrbVsdc", "chrbVsRC", "chrVsRC", "chrVSsrc", "chrRSsrc", "chrVsdc", "chrVssrc", "chrSRC", "chrRSrc", "chrRSdc", "chrVsrc", "chrbVssrc", "chrbVSRC", "chrSrc", "chrbVSdc", "chrbVSrc", "chrVSRC"], "chrFilterSize": ["chrSortsize", "chrbFiltersize", "chrSortSize", "chrSortLength", "chrFiltersize", "chrbSortsize", "chrFilterSIZE", "chrbFilterSize", "chrfiltersize", "chrfilterSIZE", "chrfilterLength", "chrbSortSize", "chrSortSIZE", "chrbFilterLength", "chrbSortLength", "chrbFilterSIZE", "chrfilterSize", "chrFilterLength", "chrbSortSIZE"], "alpSrc": ["alcAsRC", "alcAsdr", "alcSsrc", "alcSRC", "alpAsRC", "alcAssrc", "alcSdr", "alpSSdr", "alcSrc", "alpSSrc", "alpAssrc", "alcAsrc", "alpSdr", "alpSRC", "alpSsrc", "alpSSsrc", "alpSSRC", "alpAsdr", "alpAsrc"], "dest": ["dc", "desc", "home", "shape", "match", "beta", "cont", "wb", "src", "img", "route", "die", "name", "loc", "mode", "config", "md", "ie", "cur", "uc", "sc", "dir", "transform", "send", "path", "dev", "cb", "dat", "tmp", "dist", "source", "d", "target", "diff", "coord", "data", "comb", "Dest", "dep", "destroy", "shift", "txt", "done", "de"], "uDest": ["uOrig", "vRest", "uDir", "vDir", "UDest", "aOrig", "fOrig", "uComb", " uDir", "URest", "UDir", "cComb", "vSc", " uRest", "fDest", "cDest", "aComb", "USc", "uSc", "vdest", "aRest", "adest", "udest", "uRest", "fComb", "aDir", "cOrig", " udest", " uSc"], "vDest": ["wDist", " vDist", "wDest", " vDes", "vDes", "fDesc", "vDesc", " vDesc", " vOrig", "wDes", "fExt", "wExt", "vExt", "fDest", "bDes", "fDist", "bOrig", "wDesc", "vOrig", "vDist", " vExt", "wOrig", "bDesc", "bDest"], "aDest": ["aDep", "aPriv", "aCor", "vaCor", "baForce", " aDesc", "baOrig", " aPriv", "aOrig", "sCor", "sDest", " aCor", "aDesc", "bSource", "aSource", "vaPriv", "bDep", "vaDest", "ADep", "ASource", " aOrig", "aForce", " aForce", "sPriv", "AOrig", "vaDesc", "baPriv", " aDep", "aDist", "APriv", "baDest", " aSource", "ADist", " aDist", "ADest", "sDesc", "AForce", "bDest", "bDist"], "dstW": ["DstMW", "drcWS", "dstWS", "dstageW", "DstM", "drcL", "dmtW", "dscWS", " drcD", " drcL", " dstL", " drcH", "dSTH", "dstMW", "drcD", "dstw", "Dstw", "dstageM", "dSTD", "Drcw", "DscW", " dstH", "dstL", "dSTMW", "drcw", " drcW", " dstD", "dscH", "DstWS", "drcMW", "DrcH", "dmtH", "drcW", "dSTL", "DrcMW", "DrcW", "DscH", "dscW", "dstH", "dSTW", "dstD", "drcH", "DscWS", "dmtw", "dscM", "dstM", "DstW", "dscD", "dstageWS", "DscM", "DstH", "dmtMW", "drcM", "dstageH", "dscL", "dSTw"], "chrDstW": ["chrLSTM", "chrDftH", "chrDntW", "chrDSTL", "chrDrcH", "chrIdftW", "chrLstM", "chrDstrW", "chrDrcM", "chrNstW", "chrDSTWS", "chrDstL", "chrIdftVW", "chrDntU", "chrIdstW", "chrLstW", "chrDstM", "chrDscH", "chrDstVW", "chrDSTU", "chrDrcG", "chrDntWS", "chrLSTW", "chrDftW", "chrIdstG", "chrNSTW", "chrDSTG", "chrDSTH", "chrDscL", "chrDntF", "chrDrcL", "chrIdftH", "chrDftVW", "chrDSTM", "chrDSTW", "chrLSTH", "chrDftG", "chrLstL", "chrDstrWS", "chrLSTL", "chrNSTWS", "chrDstH", "chrDstF", "chrDSTF", "chrDstG", "chrDscW", "chrNstU", "chrDrcW", "chrIdstVW", "chrDrcVW", "chrNstWS", "chrDstrU", "chrDstrF", "chrDstU", "chrNSTF", "chrIdftG", "chrDstWS", "chrDscM", "chrNSTU", "chrDSTVW", "chrNstF", "chrIdstH", "chrLstH"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 22364, "substitutes": {"errp": ["efpe", "efp", "errpe", "derlp", "derp", "erpe", "efps", "erps", "errps", "erlp", "erp", "eflp", "derpe", "derps", "errlp"], "info": ["ii", "def", "f", "app", "ignore", "q", "tf", "si", "ami", "base", "sum", "Info", "user", "py", "key", "opt", "fo", "source", "diff", "data", "i", "conf", "note", "comment", "inner", "ext", "php", "part", "event", "options", "current", "area", "num", "name", "now", "config", "is", "index", "fw", "help", "manager", "end", "check", "qa", "api", "id", "os", "slice", "gi", "ui", "update", "home", "thin", "ok", "INFO", "by", "init", "bug", "state", "information", "error", "style", "iso", "meta", "fi", "li", "hi", "afi", "orig", "success", "z", "op", "new", "it", "zip", "full", "menu", "image", "inf", "linux", "link", "http", "di", "type", "extra", "start", "fs", "available", "result", "post", "off", "json", "obj", "job", "admin", "follow", "txt"], "s": ["res", "secondary", "p", "se", "f", "si", "a", "sb", "storage", "cs", "source", "details", "ops", "data", "gs", "i", "spec", "sa", "ses", "status", "ds", "xs", "is", "b", "ts", "ps", "e", "y", "args", "services", "parts", "sup", "comments", "os", "set", "rates", "params", "states", "S", "sym", "site", "ions", "stats", "its", "v", "state", "c", "service", "es", "m", "sys", "t", "sl", "g", "new", "settings", "sets", "sq", "rs", "sync", "sg", "as", "ss", "o", "session", "ssl", "su", "sf", "ns", "ls", "sec"]}}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365, "substitutes": {"bs": ["lb", "ins", "abi", "ks", "iss", "asts", "ec", "bb", "als", "css", "us", "bid", "bis", "ras", "ses", "ds", "bas", "fs", "ss", "b", "ros", "bh", "BS", "base", "bits", "cb", "bos", "cs", "obs", "ab", "blocks", "bes", "lbs", "pb", "bytes", "outs", "bc", "os", "vs", "las", "ubs", "ns", "ls", "rb", "ums", "ba", "js"], "bitnum": ["bytenum", " bitnumber", "intnumber", "intno", "BITNum", "Bitnum", " bitno", "byteNum", "BITnum", "bitum", " bitnom", "bitno", "BitNum", "Bitnumber", "bytenumber", "intnum", "BITnumber", " bitNum", "blocknum", "blocknumber", "bitnom", "bitnumber", "bitsno", "blockum", "Bitum", "bitsnumber", "blockNum", "bitsnum", "BITnom", "bitNum", "bytenom", " bitum"], "bitmap": ["daymap", "BitMap", "bmask", " bitmask", "bitcache", "daylock", "nullview", "bmap", "blockblock", " bitmaps", "bitMap", "daycast", " bitMap", "nullmap", " bitarray", "bitfill", "blockMap", "bitarray", "bitcast", "tagflow", "binmask", "bitmask", "Bitblock", "binview", "bitblock", " bitcap", "bmaps", "binfill", " bitblock", "blockmap", "bytemaps", "byteMap", "bitdata", "bootmask", "binarray", "bootmap", "nullmask", "bootlock", "bitsmap", "bitcap", "binflow", "bitsmask", "binmaps", " bitfill", "bytemap", "Bitmask", "bincap", "bitflow", "bfill", "blockmask", "bitlock", "bitscap", "bootcast", "bitscache", "bincache", "tagview", "bindata", "binmap", "daymask", "Bitmap", "Bitdata", "bitmaps", "tagmap", "blockmaps", "Bitmaps", "bytearray", "blocklock", "bitsmaps", "nullflow", "blockcache", "blockcast", "bitsdata", "tagmask", "binMap", "bitview"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int voc_probe(AVProbeData *p)\n\n{\n\n    int version, check;\n\n\n\n    if (p->buf_size < 26)\n\n        return 0;\n\n    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n\n        return 0;\n\n    version = p->buf[22] | (p->buf[23] << 8);\n\n    check = p->buf[24] | (p->buf[25] << 8);\n\n    if (~version + 0x1234 != check)\n\n        return 10;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 22379, "substitutes": {"p": ["br", "gp", "pa", "jp", "img", "http", "j", "f", "app", "s", "pc", "b", "v", "up", "per", "pp", "pi", "n", "a", "c", "lp", "o", "bp", "e", "patch", "l", "P", "fp", "u", "pb", "pre", "vp", "post", "tp", "d", "np", "cp", "progress", "api", "data", "at", "k", "i", "sp", "m", "cop", "t", "ap", "exec", "wp", "op", "it", "ip"], "version": ["update", "release", "ion", "vision", "test", "vert", "code", "Version", "VERSION", "num", "depth", "val", "name", "date", "type", "info", "length", "f", "block", "option", "versions", "bug", "v", "n", "index", "scale", "c", "position", "build", "error", "ver", "patch", "result", "byte", "fix", "value", "ison", "data", "id", "ant", "number", "server", "feature", "ception", "core"], "check": ["wait", "update", "ok", "match", "test", "call", "sync", "block", "code", "force", "load", "val", "info", "valid", "max", "start", "lock", "feed", "bug", "view", "index", "c", "ck", "ver", "patch", "play", "query", "clean", "fix", "key", "CHECK", "end", "read", "pull", "print", "id", "work", "add", "Check", "look", "checked", "set", "comment"]}}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381, "substitutes": {"f": ["cf", "uf", "p", "h", "fe", "inf", "lf", "j", "s", "fr", "fs", "tf", "xf", "bf", "feed", "b", "v", "fc", "df", "F", "fw", "elf", "c", "fen", "e", "fed", "l", "fa", "r", "fd", "fp", "fac", "fo", "fi", "ff", "d", "rf", "i", "m", "form", "fx", "t", "fn", "sf", "fb", "conf", "self", "file", "g", "fm"], "opaque": ["opacity", "Opacity", "Opque", "opsaque", "Opaque", "iophole", "opshole", "iopque", "Ophole", "iopacity", "opque", "iopaque", "ophole", "opsque", "opsacity"], "version_id": ["server_oid", "version1version", "versionCline", "versionEname", "versioneeid", "versionCvid", "version_name", "version_ids", "versioneid", "versionCdesc", " version_ID", "language_ids", "versionPid", "version_key", " versioneid", "versionerid", "versionFid", "servererid", "versionPID", "versionernum", "versionedid", "versioneedesc", " versionename", "version_aid", "versionedvid", "versionEkey", "server_id", "servereroid", "version1oid", "language_aid", "stage_line", "versionEbit", "stageedid", "stageeddesc", "version_vid", "version_desc", "language_id", "versionCid", "server_num", "version_value", " version_key", "version_bit", "stage_id", "version_num", " version_index", "stage_vid", "versionebit", " version_ids", "versionPindex", "stageedline", "server_version", "versionervalue", "version_ID", "versioneraid", "versionename", "versioneroid", "version_index", "versionPids", "versionerversion", "language_value", " versionebit", "versionFvalue", "servererversion", "version_oid", "versionFids", "versionekey", "version1num", "versionedline", "versioneevid", " version_name", "version_version", "versioneddesc", "stageedvid", "versionEid", "versionFaid", "stage_desc", "versioneeline", "versionerids", " version_bit", "version1id", "serverernum", "version_line", " versionekey"], "addr": ["p", "arch", "offset", "buffer", "rt", "ack", "mask", "hop", "seq", "base", "amd", "ref", "opt", "pos", "data", "dr", "pad", "oa", "act", "ext", "adr", "part", "src", "ord", "loc", "address", "config", "md", "cmd", "b", "asm", "align", "amp", "index", "back", "xp", "fd", "args", "filename", "size", "rc", "arr", "alt", "ad", "prefix", "ip", "inst", " address", "bb", "acl", "ac", "rss", "mode", "state", "height", "r", "url", "ptr", "afi", "fx", "Address", "node", "ace", "image", "x", "code", "frame", "start", "mac", "padding", "buf", "alias", "ast", "nl", "port", "layer", "attr", "coord", "rf", "cmp", "od"], "flags": ["ins", "offset", " Flags", "s", "planes", "mask", "links", "seq", "utils", "bits", "ports", "vals", "details", "ops", "requires", "bugs", "tests", "ids", "FLAG", "count", "eth", "plugins", "fields", "vs", "bytes", "options", "heads", "lf", "reads", "xff", "rights", "config", "types", "versions", "strings", "lag", "fl", "ils", "args", "fd", "blocks", "format", "services", "ips", "flag", " bits", "ints", "properties", "alls", "utf", "forces", "acl", "stats", "ants", "files", "mods", "styles", "rules", "Flags", "groups", "ffff", "afi", "fx", "fg", "settings", "rs", "linux", "allows", "fs", "nl", "locks", "fps", "features", "frames"], "id": ["part", "kid", "image", "line", "def", "p", "bid", "h", "pid", "link", "code", "num", "bit", "name", "val", "offset", "type", "info", "like", "Id", "stat", "address", "uid", "head", "start", "aid", "frame", "body", "lock", "a", "seq", "uri", "base", "path", "ID", "r", "root", "ref", "key", "ident", "end", "oid", "str", "size", "gen", "d", "in", "split", "ids", "url", "data", "count", "hash", "i", "pad", "ad", "sid", "map", "tag", "no", "ip"], "length": ["part", "full", "capacity", "shape", "line", "partial", "match", "row", "section", "label", "en", "Length", "link", "code", "offset", "val", "load", "loc", "type", "address", "info", "name", "rows", "lock", "up", "seq", "n", "index", "padding", "position", "buffer", "base", "path", "sum", "build", "sequence", "style", "l", "message", "limit", "key", "end", "value", "size", "pl", "split", "url", "data", "count", "number", "slice", "ength", "ip"], "block": ["channel", "part", "full", "image", "line", "def", "cl", "box", "empty", "partial", "row", "label", "num", "bit", "buffer", "name", "frame", "type", "pack", "address", "complete", "object", "inv", "coll", "none", "lock", "bl", "b", "bin", "parent", "base", "range", "error", "r", "flow", "byte", "blocks", "chain", "limit", "ref", "offset", "function", "prev", "point", "end", "plugin", "check", "off", "bc", "pos", "data", "child", "obj", "unit", "blocking", "Block", "number", "slice", "open", "group", "node", "comment", "ip"], "len": ["part", "ler", "il", "line", "lin", "lc", "en", "label", "Len", "lit", "lf", "num", "el", "val", "ln", "offset", "loc", "le", "lan", "dl", "den", "lock", "bl", "rel", "seq", "n", "bin", "fl", "ind", "l", "limit", "pre", "str", "size", "li", "pos", "url", "data", "count", "fn", "slice", "dy", "sl", "z", "all"], "host": ["channel", "machine", "home", "cf", "image", "h", "th", "location", "arch", "name", "frame", "loc", "ce", "address", "proxy", "head", "config", "driver", "object", "bug", "mac", "xx", "Host", "hop", "c", "parent", "path", "build", "serv", "patch", "conn", "localhost", "chan", "service", "hw", "hub", "boot", "ref", "source", "ich", "cast", "connect", "port", "target", "hard", "url", "cp", "mount", "dr", "work", "server", "component", "act", "node", "comp", "pool", "ip"], "ch": ["channel", "chip", "tch", "gr", "ech", "cl", "Ch", "h", "p", "th", "code", "arch", "el", "zh", "q", "CH", "cher", "che", "chrom", "bug", "ct", "bh", "c", "chn", "dev", "cs", "conn", "chan", "col", "batch", "sk", "sh", "ach", "ich", "anch", "sch", "cp", "count", "eth", "ctx", "conf", "work", "cmp", "cha", "cht", "cor"]}}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 22387, "substitutes": {"common": ["chief", "global", "full", "create", "general", "cache", "stack", "central", "lc", "current", "sync", "core", "local", "http", "name", "standard", "low", "cli", "public", "config", "none", "document", "family", "security", "media", "comm", "con", "utils", "control", "base", "com", "storage", "mod", "fun", "performance", "conn", "flow", "normal", "Common", "module", "meta", "final", "pb", "connection", "recent", "node", "function", "cm", "communication", "command", "summary", "tc", "data", "ctx", "sem", "null", "conf", "client", "custom", "component", "lib", "util", "loader", "generic", "context", "java", "resource", "remote"], "errp": [" errpr", "rrpc", " errlp", "errr", "Errorpc", "errpr", "errorlp", "Errorlp", "errfp", "errlp", "erP", "rrp", "erpc", "errP", "rrpr", "errorP", "Errorp", "errorpc", "erfp", " errP", " errfp", "errpc", "rrr", "rarp", "errorfp", "errorp", "rarpr", " errpc", " errr", "rarpc", "erp", "rarr"], "state": ["cache", "p", "STATE", "use", "date", "info", "f", " states", "base", "storage", "rate", "key", "data", "i", "un", "lib", "comment", "part", "runner", "current", "area", "name", "loc", "j", "status", "public", "config", "is", "back", "power", "parent", "manager", "private", "rule", "State", "grade", "work", "slice", "resource", "set", "update", "states", "parse", "local", "pse", "region", "stat", "media", "store", "style", "l", "cal", "ass", "instance", "scope", "m", "g", "new", "settings", "st", "statement", "sync", "block", "code", "type", "start", "body", "reg", "conn", "result", "session", "port", "self", "list", "tag"], "bs": ["lb", "ins", "br", "iss", "rs", "bb", "sync", "css", "us", "bid", "db", "ras", "bis", "ds", "ses", "banks", "bas", "fs", "bl", "b", "ss", "ros", "bh", "BS", "ps", "base", "sb", "cb", "bus", "bos", "bits", "cs", "ab", "nas", "bi", "blocks", "bes", "bytes", "pb", "bu", "outs", "bc", "bal", "bot", "obj", "bing", "gs", "ctx", "hs", "gb", "os", "fb", "vs", "lib", "ubs", "ns", "ls", "obs", "ba", "js"], "backup": ["undback", "unddown", "backdown", "udout", "undups", "backout", "backUP", "Backup", "pullupid", "frontout", "workdown", "workup", "backupid", "pullout", "workUP", "frontups", "buckdown", "undup", "Backdown", "udap", "buckap", "frontback", "pulldown", "workupid", "pullup", "workout", "backap", "buckup", "frontdown", "frontUP", "frontup", "uddown", "backups", " backout", " backap", " backdown", "Backups", "udup", "buckout", " backUP", "frontupid", "Backback", "backback"], "local_err": ["global_ctr", "remote_err", "remote_error", "global_rs", "remote_er", "global_error", "local67ctr", "local67er", "localiperror", "localiperr", "global_er", "local67err", "local_er", "local_ctr", "local_rs", "global_err", " local_error", "localiprs", " local_er", "local_error", "local_msg", "localipmsg", "global_msg"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n", "idx": 22389, "substitutes": {"ctx": ["dc", "cf", "crit", "cv", "xc", "jp", "src", "lc", "cc", "loc", "ce", "config", "sci", "cr", "pc", "Context", "anc", "cmd", "sc", "ct", "fc", "c", "ck", "ca", "cas", "cs", "tx", "conn", "kb", "chan", "fp", "cm", "bc", "qa", "cp", "tc", "rc", "scope", "cca", "cpp", "ci", "pkg", "ctrl", "cmp", "context", "exec", "cn"]}}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n", "idx": 22392, "substitutes": {}}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399, "substitutes": {"env": ["req", "cfg", "ev", "cv", "priv", "en", "enc", "ea", "queue", "que", "proc", "ef", "chal", "config", "dict", "enh", "vm", "exc", "fw", "err", "cb", "manager", "fi", "viron", "bc", "Environment", "np", "impl", "emb", "rc", "scope", "environment", "eu", "conf", "txt", "fg", "loader", "context", "qt", "ec"], "ctx": ["comment", "cfg", "cf", "sq", "console", "general", "gc", "cv", "xc", "event", "lc", "cu", "sync", "css", "cc", "acl", "que", "local", "loc", "cli", "config", "zh", "gpu", "git", "cmd", "sc", "exc", "kw", "fw", "c", "utils", "ck", "cb", "cas", "ca", "hs", "tx", "conn", "kb", "hw", "fp", "pb", "std", "cm", "conv", "wcs", "qa", "cp", "rc", "obj", "scope", "vc", "ci", "conf", "pkg", "fn", "ctrl", "cmp", "util", "act", "context", "exec", "cn", "qt"], "eaddr": ["adr", "eyder", "eadbr", "hwrd", "ecr", "engder", "oaddr", "aestr", "eddDR", "eyrr", "eddbr", "ewdr", "ecaddr", "eebr", "aeaddr", "engrd", "eadder", "awDR", "ewbr", "eadrd", "awder", "adaddr", "ewder", "eadrr", "engDR", "execdr", "acerr", "eeDR", "eydr", "eadstr", "eadaddr", "eadhr", "execstr", "oadDR", "engdr", "awbr", "awdr", "ewDR", "eystr", "hwder", "awrd", "aer", "oadder", "acedr", "ecdr", "aedr", "ecstr", "execrr", "eddhr", "hwdr", "eadDR", "eedr", "aceder", "edddr", "acestr", "execder", "adstr", "hwDR", "eehr", "addr", "oadhr", "oadbr", "eadr"], "rw": ["req", " len", "match", " flags", "w", "res", "class", "src", "buffer", "mode", "rows", "wr", "reg", "table", "rr", "xp", "ref", "dest", " pri", "tr", "weight", "rc", "ptr", "eth", "rep", "rec", "pool"], "type": ["ty", "shape", "class", "version", "lit", "block", "name", "val", "info", "TYPE", "ype", "types", "len", "pt", "ver", "style", "format", "ref", "key", "py", "pb", "value", "port", "target", "Type", "ptr", "ping", "ip"], "hash": ["ha", "auth", "chip", "image", "match", "Hash", "version", "kh", "cache", "empty", "h", "block", "img", "num", "depth", " Hash", "val", "ash", "rev", "msg", "rh", "hz", "v", "html", "mac", "height", "index", "header", "sha", "where", "sum", "search", "root", "ph", "key", "ref", "sh", "value", "str", "tr", "memory", "count", "id", "number", "array", "skip", "pool"], "vsid": ["vsaid", "opsid", "vassecret", "dside", "osid", "versid", " vsip", "hersaid", " vskey", "VSd", "Vside", "vside", "versite", "vsids", "ssid", "opensId", "kinsid", "Vsid", "umsid", "csite", "VS\n", "csname", "vasId", "vssid", "vsuid", "lsId", " vsID", "opensid", "VSaid", "cside", "VSids", "cosId", "stside", "VSip", "vsparent", "VSide", "osids", "vessecret", "obsid", "cskid", "csID", "vesId", "hersbit", "stsid", "psoid", "dsids", "VSsid", "ss0", "hersID", "vasname", " vskid", "ssaid", "vsfile", "opsID", "VSbit", "umsID", "veside", "psi", "VSID", "vs0", "versname", "VsID", "vsbit", "vesID", " vsId", "dsid", "vasid", "opsparent", "verskid", "psname", "vsite", "VSId", " vs0", "vskey", "dskey", "psid", "opensID", " vsfile", "kinsId", "stskid", " vs\n", "kinsID", "vsip", "vssecret", " vsuid", "bsID", "cosaid", "obsID", "csid", "ssID", "kinsparent", "pside", "osID", "vs\n", "VSsecret", "ss\n", "bsfile", " vside", "stsite", "stsparent", "stsoid", "umsids", " vsi", "versoid", "VSkid", " vsids", "versi", "lside", "vsId", "VSparent", " vsaid", "dsID", "vesname", "vskid", "vsi", "lsID", "VSoid", "pssid", "psID", "umsname", " vsd", "versids", "oskey", "vsoid", "psuid", "cosd", "dsparent", "vsname", "opensfile", "vsID", "stsId", "vessid", " vsoid", "obside", "versID", "ssbit", "vsd", "stsID", "bsId", "opsId", "obsId", "VSid", "cosid", "versuid", "bsid", "VS0", "VSname", "lsid", " vsname", "hersid", "versip", "csoid", "Vsparent", "vesid"], "pr": ["po", "br", "gr", "mr", "rs", "pe", "pa", "p", "ra", "pin", "sa", "Ra", "val", "j", "spr", "fr", "cr", "sr", "rx", "pc", "PR", "repl", "rel", "up", "wr", "per", "seq", "pro", "ps", "err", "build", "fl", "pt", "rr", "ver", "r", "kr", "ch", "pre", "pl", "tr", "pos", "pull", "arr", "ptr", "sp", "dr", "lo", "lr", "Pr", "put"], "target_page_bits": ["target_page32bits", "target_page_bytes", "target_site_bit", "target_page64bit", "target_page64pieces", "target_page_pieces", "target_page64bytes", "target_Page_bit", "target_page2bytes", "target_pagepbytes", "target_Page_bits", "target_page2bits", "target_page_bit", "target_pagepbit", "target_page32bytes", "target_Page_pieces", "target_site_pieces", "target_page2bit", "target_page64bits", "target_pagepbits", "target_page32bit", "target_page32pieces", "target_page2pieces", "target_pagepints", "target_Page_bytes", "target_page_ints", "target_site_bits", "target_site_bytes", "target_site_ints"], "ret": ["req", "match", "def", "res", "resp", "rets", "lit", "mem", "pin", "val", "rev", "proc", "pat", "RET", "rel", "seq", "fun", "reg", "nt", "result", "re", "arr", "alt", "Ret", "rep", "pub", "sec"], "ret2": [" ret4", " ret1", "Ret4", "ret1", "ret4", "Ret2", "seq4", "seq2", "Ret1", "seq1"], "slb": [" slB", "slbs", "islb", "llb", "silB", "plbb", "sslib", "plB", " slbu", "Slbs", "silb", "mlib", " slab", "SLbar", "sslbu", "mlb", "blB", "plb", "llp", "selbb", "slp", "islbu", "mlk", "llbb", "Slbi", "selab", "Slb", "slr", "Slf", " slp", "slf", "clbi", "slab", "slbb", "SLb", "ellp", "llf", "dlsb", "islib", "ellb", "SLsb", "silf", " slk", "slib", "dlb", "clb", "dlbb", "slsb", "sslb", " slib", "slbi", " slbar", "sslB", "islB", " slbb", "blab", "selib", "plob", " slsb", "selb", "ellab", "blb", "mlp", "mlbb", "slbar", "mlB", "SLf", "islsb", "selk", "ellsb", "dlB", "selp", "slob", "dlob", "llB", " slf", " slr", "silab", "SLbb", "SLB", "slk", "slB", "mlr", "selob", "clB", "selB", "blf", "Slbb", " slbs", "SLp", "SlB", "SLab", "dlbar", "selbs", "selr", "self", "slbu", " slbi"], "pageaddr": [" pagebreak", "pageAddress", "pageatt", "changeaddress", "serveraddress", " pageattr", "recordaddr", " pagehop", " pageptr", " pageoffset", "imagehop", "_addr", "pageptr", "pageoffset", "gehop", " pageaddress", "pagead", "diskptr", "pageflags", "screenaddr", "changead", "serveradd", "pageadd", "pageattr", "agead", "changeaddr", " pageadd", "diskatt", "screenptr", "screenatt", "geaddr", "_address", "imageaddress", "agebreak", "recordaddress", "recordattr", " pagead", "pagebreak", " pageflags", " pageAddress", "ageaddress", "pageaddress", "imageAddress", "serverattr", "serveraddr", "pagehop", " pageatt", "diskaddr", "ageoffset", "_flags", "ageflags", "diskaddress", "screenaddress", "_break", "ageaddr", "imageaddr", "geaddress", "changeoffset", "recordadd", "geAddress"], "segment_bits": ["segmentsflags", "segment64files", "sevision_pieces", "segment36pieces", "segmentationbits", "segment64bits", "sevision_cats", "segment64pins", "segmentnumabs", "segment_bytes", "sevisionationabs", "segmentsbytes", "segment36cats", "segmentnumbits", "segment_parts", "sevision64bits", "segment54files", "segment_flags", "segment36bits", "sevision64files", "sevision_files", "sevision_abs", "segment_locks", "segmentnumcats", "segmentnumpieces", "sevision_pins", "sevisionationcats", "segment_files", "sevision_bits", "sevisionationpieces", "sevision64pins", "sevisionationbits", "segmentationabs", "segement_bytes", "segment36abs", "segmentsbits", "segement_locks", "segment_cats", "segment_pieces", "segment_abs", "segment54bits", "segement_pieces", "segment54pins", "segmentsparts", "segement_bits", "segmentationpieces", "segment_pins", "segmentationcats"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n", "idx": 22413, "substitutes": {"sockfd": ["fsockdir", "sickdir", "sOCKfd", "svcfd", "svcfb", "fsockstream", "sinkdir", " sockfb", "sinkdf", "sockstream", "fsockfd", "sinkstream", " socksecd", "sdkdir", "sdkfd", "socksfd", " sockFD", "svcFD", " socksFD", "fsockdf", "sockecd", "sockdir", " socksfd", " socksfb", "sockfb", "sdkstream", "sockFD", "socksfb", "fsinkdir", "sOCKfb", "socksecd", "sickdf", " sockecd", "sdkdf", "sickfd", "socksFD", "sOCKecd", "fsinkdf", "sOCKFD", "sockdf", "sinkfd", "sickstream", "fsinkfd", "fsinkstream", "svcecd"], "status": ["wait", "settings", "update", "ok", "stage", "gc", "resp", "version", "class", "p", "Status", "current", "sync", "code", "date", "complete", "type", "mode", "stat", "info", "proc", "response", "stats", "security", "si", "comm", "content", "temp", "state", "seq", "header", "error", "message", "result", "format", "output", "source", "details", "STAT", "str", "command", "summary", "progress", "login", "ssl", "unit", "sp", "received", "sys", "sex", "score", "success", "speed", "skip", "level", "method", " Status", "spec", "dom"], "iov": ["dm", "iv", "oren", "wav", "voice", "iro", "mem", "wikipedia", "iol", " io", "oy", "nox", "obo", "minecraft", "club", "micro", "irc", "io", "media", "ibr", "avi", "iii", "oyer", "gru", "drm", "iris", "hw", "userc", "iop", "imedia", "ilib", "liv", "misc", "uni", "music", "soc", "member", "lore", "rolet", "memory", "anova", "uno", "mpeg", "intern", "mus", "vg", "ilo", "gio", "lov", "voc", "anon", "imi", "mu"], "msg": ["dm", "bm", "req", "man", "irm", "co", "info", "game", "seq", "module", "gen", "bc", "gs", "dr", "pkg", "vg", "addr", "generic", "global", "debug", "doc", "rag", "call", "db", "name", "go", "mo", "cli", "config", "md", "Msg", "cmd", "mail", "manager", "input", "mom", "cfg", "console", "gm", "gui", "mem", "mode", "stat", "mn", "media", "comm", "gram", "err", "error", "mag", "copy", "fi", "member", "m", "og", "live", "client", "file", "pub", "g", "node", "mess", "menu", "iq", "block", "frame", "sim", "buf", "send", "conn", "message", "session", "mid", "sg", "ms", "mg", "mu"], "cmsg": ["cfnode", " cmail", "ccmd", "cmn", " cmg", " cdesc", "ccomm", "hmessage", "confmessage", "crmsg", "Cmg", "crmn", "cvcomm", " cmem", "Cmd", "confmodule", "cvdoc", "lcmessage", "confcomm", "cnode", "cvmsg", "cgame", "ncmessage", " cmessage", " cmodule", "dcmail", "nccomm", "conmsg", "confmsg", "rcmessage", "cmd", "rcgame", "Cog", "decdesc", "fcmd", "fmessage", "lcmd", "cicmd", "concomm", "cfmd", "cmem", "lccmd", "confcmd", "cdesc", "ncmd", "cconn", " ccomm", "fmail", "rcmsg", "fmem", "conmodule", "cmessage", "ncmg", "cvmessage", "cfmsg", "fmsg", "crmodule", "ncmsg", "Cmessage", "cimessage", "cmg", " cgame", "decnode", "hmsg", "cmail", " cmd", "rcdesc", " cnode", "confog", "cdoc", "Ccmd", "dcmessage", "cfconn", "dcmsg", "cfcmd", "crmessage", "decmsg", "dcmem", "fog", "decmessage", "ncdoc", " ccmd", "lcmsg", "deccmd", "conmessage", "hcomm", "concmd", "decconn", "cimd", "cmodule", "decgame", "Cmsg", "hdoc", "conmn", "cog", "cimsg", " cmn", "cfmessage", " cconn"], "retval": ["returnVAL", "rtvalid", "retvals", "altv", "altval", "Retvals", "defvalue", "altvals", "altVAL", "retvalid", " retVAL", "refrol", "altVal", "RetVAL", "pretVal", "Retval", "returnVal", "defval", " retvals", "alteval", "returnval", "retVAL", "retvalue", "defeval", "refval", "pretval", " retVal", "retrol", "returnvals", "refvalid", "RetVal", "refVAL", " retv", "altrol", "defvals", "altreq", "reteval", " retreq", "retVal", " retvalid", "altvalue", "pretreq", " retvalue", "pretvals", "rtv", "rtval", " retrol", "rtvalue", " reteval", "altvalid", "retv", "retreq"], "data": ["req", "def", "buffer", "info", "valid", "io", "content", "a", "function", "uni", "failed", "i", "dr", "received", "addr", "no", "bytes", "doc", "empty", "val", "loc", "fail", "ds", "results", "config", "len", "parent", "action", "format", "size", "memory", "input", "id", "Data", "rec", "ip", "update", "text", "DATA", "mem", "stat", "media", "comm", "init", "err", "error", "dat", "download", "byte", "connection", "dd", "done", "record", "file", "resp", "voice", "block", "dt", "di", "frame", "load", "response", "raw", "next", "buf", "send", "da", "message", "result", "str", "d", "reader", "mu"], "fd": ["dm", "dc", "def", "hd", "pd", "fe", "cd", "dt", "db", "bd", "ds", "f", "md", "dl", "FD", "bf", "io", "fc", "fee", "df", "buf", "fun", "cb", "da", "fff", "fl", "dat", "handler", "fed", "fa", "fp", "format", "output", "dd", "cond", "fi", "ff", "d", "sd", "ad", "fin", "fx", "fn", "fb", "dy", "wd", "fm"], "msg_control": ["msg_coll", "msgvcontrol", "message_control", "msgvcontroller", " msg_controller", "msg_controller", "message_coll", "msg_controlled", " msg_Control", "msg_config", "message_Control", " msg_length", " msg_ctrl", "msg_Control", "msgvctrl", "msgvconfig", "message_ctrl", "msg_ctrl", "msg_length", "message_controlled", " msg_config"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n", "idx": 22417, "substitutes": {"env": ["ey", "inst", "ace", "stage", "ev", "iss", "cache", "gui", "eni", "en", "enc", "ea", "site", "db", "ce", "cli", "mode", "ef", "status", "config", "eng", "proc", "si", "vm", "ah", "v", "exc", "state", "c", "err", "dev", "path", "fen", "e", "enable", "exe", "engine", "conn", "osc", "args", "gear", "esm", "style", "nw", "output", "end", "profile", "viron", "np", "Environment", "rc", "scope", "environment", "ctx", "eu", "oa", "conf", "fg", "vs", "open", "server", "edge", "context", "exec", "network", "qt", "loader", "energy", "ec", "skin", "ext"], "mce": ["Mke", "MCE", "pcing", "Mcer", "pce", "cce", "cge", "vce", "emcer", "vcer", "mCE", "emCE", "vCE", "mge", "Mce", "cke", "cCE", " mke", " mcing", " mCE", "mcing", "emce", "pCE", " mge", "vcel", "emcel", "mcer", "Mge", "mke", "pge", "mcel", "Mcel", "ccing"], "flag": ["wait", "image", "af", "stage", "flags", "sync", "code", "sy", "draft", "use", "offset", "Flag", "name", "bit", "type", "mode", "info", "status", "f", "func", "start", "bug", "fee", "len", "state", "ag", "thread", "age", "fun", "lag", "ind", "args", "fd", "fi", "data", "FLAG", "count", "id", "pad", "arg", "sid", "file", "feature", "ext"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22418, "substitutes": {"ctx": ["dc", "cfg", "cf", "cl", "cv", "xc", "cache", "lc", "cd", "cc", "loc", "config", "Context", "sc", "c", "buf", "ca", "cas", "cb", "handler", "tx", "conn", "connection", "cm", " context", "bc", "instance", "cp", "obj", "scope", "cdn", "ci", "conf", "pkg", "fn", "ctrl", "client", "context", "cn", "exec"], "fd": ["dc", "nd", " fid", "pd", "fe", "pid", "cd", "lf", "bd", "loc", "ds", "dim", "f", "td", "dl", "FD", "fs", "bf", "xf", "fc", "fee", "dir", "df", "fw", "cb", "fen", "fl", "pipe", "handler", "fed", "fa", "flow", "fp", "filename", "dB", "dd", "size", "fi", "d", "ffff", "lvl", "sd", "fx", "fin", "fn", "sf", "fb", " FD", "dn", "wd", "ld", "fm"], "node": ["tree", "event", "call", "host", "link", "core", "route", "local", "name", "nn", "load", "f", "object", "valid", "no", "none", "document", "content", "native", "annot", "n", "index", "ode", "parent", "new", "path", "error", "e", "leaf", "handler", "root", "query", "result", "nw", "ref", "function", "source", "anch", "post", "op", "value", "instance", "child", "missing", "one", "cdn", "id", "self", "null", "destroy", "live", "fn", "component", "edge", "loader", "this", "de", "Node", "remote"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421, "substitutes": {"env": ["inst", "iv", "ev", "hl", "priv", "en", "enc", "ea", "her", "proc", "ef", "dict", "config", "dir", "kw", "cb", "e", "conn", "usr", "bc", "rc", "environment", "eu", "conf", "fg", "enter", "ec"], "dc": ["dm", "mc", "xc", "lc", "cd", "cc", "ac", "di", "DC", "pc", "disc", "jc", "oc", "sc", "fc", "ct", "c", "da", "fd", "director", "cm", "d", "bc", "rc", "tc", "cdn", "nc", "ec"]}}
{"project": "FFmpeg", "commit_id": "043800a96888f1a04732f12316ba477d8f098d3f", "target": 0, "func": "static int end_frame(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext    *ctx = inlink->dst;\n\n    FPSContext           *s = ctx->priv;\n\n    AVFilterLink   *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef  *buf = inlink->cur_buf;\n\n    int64_t delta;\n\n    int i, ret;\n\n\n\n    inlink->cur_buf = NULL;\n\n    s->frames_in++;\n\n    /* discard frames until we get the first timestamp */\n\n    if (s->pts == AV_NOPTS_VALUE) {\n\n        if (buf->pts != AV_NOPTS_VALUE) {\n\n            write_to_fifo(s->fifo, buf);\n\n            s->first_pts = s->pts = buf->pts;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\n                   \"timestamp.\\n\");\n\n            avfilter_unref_buffer(buf);\n\n            s->drop++;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* now wait for the next timestamp */\n\n    if (buf->pts == AV_NOPTS_VALUE) {\n\n        return write_to_fifo(s->fifo, buf);\n\n    }\n\n\n\n    /* number of output frames */\n\n    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\n\n                         outlink->time_base);\n\n\n\n    if (delta < 1) {\n\n        /* drop the frame and everything buffered except the first */\n\n        AVFilterBufferRef *tmp;\n\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n\n        s->drop += drop;\n\n\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n\n        flush_fifo(s->fifo);\n\n        ret = write_to_fifo(s->fifo, tmp);\n\n\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    /* can output >= 1 frames */\n\n    for (i = 0; i < delta; i++) {\n\n        AVFilterBufferRef *buf_out;\n\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n\n\n        /* duplicate the frame if needed */\n\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n\n            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n\n            s->dup++;\n\n        }\n\n\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n\n                                    outlink->time_base) + s->frames_out;\n\n\n\n        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n\n            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n\n            (ret = ff_end_frame(outlink)) < 0) {\n\n            avfilter_unref_bufferp(&buf);\n\n            return ret;\n\n        }\n\n\n\n        s->frames_out++;\n\n    }\n\n    flush_fifo(s->fifo);\n\n\n\n    ret = write_to_fifo(s->fifo, buf);\n\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n\n\n    return ret;\n\n}\n", "idx": 22425, "substitutes": {"inlink": ["inload", "ninline", "Inload", "ninlink", "inslock", "outload", "inclink", " inink", "ninflow", "insline", "incline", " inLink", "Inlock", " inload", "insload", "inflow", "inLink", "inslink", "inink", "inlock", "outlock", "insLink", "outline", "outflow", "inclock", "outLink", "outink", "incink", " inflow", "ninlock", "InLink", "insink", "Inlink", " inlock"], "ctx": ["mc", "bm", "cf", "cms", "crit", "sq", "gc", "xc", "cv", "cu", "lc", "sync", "cc", "acl", "loc", "cli", "config", "driver", "sci", "uc", "Context", "anc", "cmd", "sc", "media", "fc", "mac", "kw", "wx", "c", "fw", "ck", "cb", "cas", "ca", "utils", "cs", "tx", "conn", "kb", "hw", "cal", "cm", "conv", "wcs", "bc", "qa", "cp", "rc", "tc", "cca", "vc", "ci", "pkg", "ctrl", "client", "cmp", "util", "nc", "context", "cam", "exec", "cn", "ann"], "s": ["ins", "p", "us", "f", "si", "a", "sb", "storage", "cs", "u", "ops", "bc", "tests", "soc", "data", "gs", "conf", "bs", "vs", "spec", "sv", "src", "aws", "sa", "ses", "ds", "config", "xs", "is", "sc", "b", "ts", "n", "ps", "hs", "e", "args", "services", "parts", "ans", "sup", "slice", "serv", "S", "ks", "lines", "sym", "stats", "its", "sis", "v", "c", "space", "r", "service", "qs", "es", "scope", "m", "sys", "server", "sl", "g", "settings", "full", "sets", "sq", "rs", "uf", "sync", "http", "as", "sr", "fs", "ss", "session", "uns", "d", "ssl", "su", "sf", "ns", "ls", "sg", "ms", "js"], "outlink": ["inman", "outplug", "unconnection", " outline", "uplink", "offplug", "outman", "unlink", "upplug", " outconnection", "inLink", "unline", "offline", "offman", "offlink", "outconnection", "outline", "inconnection", "unLink", "outLink", " outLink", "inplug", "upline", "upman"], "buf": ["bm", "lb", "cap", "br", "home", "cf", "box", "wb", "cv", "uf", "src", "alloc", "bridge", "queue", "img", "bd", "buff", "buffer", "proc", "f", "config", "uc", "func", "cur", "bf", "cmd", "b", "bh", "seq", "bt", "fw", "cb", "sb", "vec", "cas", "ab", "fd", "fp", "aux", "window", "ref", "pb", "bu", "fi", "bag", "raf", "bc", "conv", "cp", "port", "ff", "su", "pkg", "fb", "cmp", "context", "rb", "pool"], "delta": ["nance", "adetime", "Dota", " danta", "dota", "adance", "Dqa", "sdetime", "cdancel", "dqa", "Delta", "delt", "nota", " dDelta", "detime", "lota", " dancel", "lelta", "Delt", "sdanta", "lDelta", "netime", "sdency", "adelta", "sdelta", "sdelt", " delt", " dency", "nency", "nelt", " dota", "nqa", "sdancel", "danta", "DDelta", "adota", "sdota", "dancel", "cdelt", "cdelta", "cdota", "dance", "nelta", "nanta", "sdqa", "dency", "sdance", "dDelta"], "i": ["ti", "ii", "ui", "jit", "ji", "ani", "qi", "x", "I", "ix", "p", "phi", "di", "ri", "j", "type", "f", "ai", "info", "ie", "ini", "ni", "start", "is", "b", "io", "si", "v", "a", "pi", "n", "index", "ki", "c", "uri", "base", "ind", "e", "y", "l", "xi", "u", "chi", "li", "d", "mini", "iu", "count", "hi", "k", "id", "zi", "ci", "multi", "t", "gi", "z", "mu", "bi", "it", "ip"], "ret": ["match", "iter", "res", "resp", "rets", "en", "mem", "rt", "val", "rev", "ft", "det", "info", "pass", "RET", "len", "gt", "back", "rot", "flat", "red", "reg", "fun", "fl", "r", "nt", "result", "ref", "final", "rem", "fi", "mini", "reply", "rf", "rc", "re", "url", "data", "obj", "mi", "alt", "fin", "Ret", "lr", "rep", "stop", "rb", "get"], "frames_in": ["framesNout", "frames__in", "frame_out", "frame_used", "framesNused", "frame_in", "frames__out", "frames__end", "framesNend", "frames_end", "frame_end", "frames_used", "frames__used", "framesNin"], "drop": ["loop", "zip", "dro", "delay", "create", "shape", "dropping", "update", "close", "x", "core", "carry", "fail", "low", "type", "dl", "ignore", "max", "pass", "roll", "hide", "move", "change", "hop", "scale", "flat", "throw", "id", "error", "drops", "Drop", "patch", "clear", "min", "col", "batch", "fix", "crop", "grow", "pop", "size", "layer", "pull", "sleep", "diff", "fly", "pos", "count", "fall", "down", "shift", "dr", "save", "pad", "push", "keep", "field", "grad", "sort", "slice", "level", "clip", "dp", "phase", "add", "delete", "stop", "op", "pool"], "tmp": ["zip", "part", "stuff", "etc", "wb", "cache", "src", "test", "bb", "uf", "tab", "img", "buff", "buffer", "proc", "config", "nb", "media", "mp", "mm", "temp", "flat", "cb", "storage", "appy", "cro", "vt", "fp", "result", "meta", "pb", "ref", "copy", "bag", "conv", "foo", "cp", "attr", "tc", "data", "obj", "ptr", "np", "api", "kk", "pad", "txt", "pkg", "fb", "gz", "cmp", "slice", "map", "front", "wp", "rb"], "buf_out": ["buffer_out", "bufadagain", "buf_io", "bufnlist", "bufKarr", "bufKio", "buf_again", "buffer_list", "bufnout", "buff_out", "fp_o", "buf_clean", "buf_off", "bufadin", "buff_in", "bufKout", "buf_Out", "fpKarr", "fpKio", "buffer_Out", "fpKo", "buff_clean", "bufnOut", "bufnoff", "buf_in", "buff_again", "fp_out", "buf_arr", "bufadclean", "bufadout", "fp_arr", "buf_o", "fp_io", "bufKo", "buffer_off", "fpKout", "buf_list"]}}
{"project": "FFmpeg", "commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "target": 1, "func": "static int roq_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    RoqDemuxContext *roq = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    unsigned int chunk_size;\n\n    unsigned int chunk_type;\n\n    unsigned int codebook_size;\n\n    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];\n\n    int packet_read = 0;\n\n    int64_t codebook_offset;\n\n\n\n    while (!packet_read) {\n\n\n\n        if (avio_feof(s->pb))\n\n            return AVERROR(EIO);\n\n\n\n        /* get the next chunk preamble */\n\n        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n\n            RoQ_CHUNK_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n\n\n        chunk_type = AV_RL16(&preamble[0]);\n\n        chunk_size = AV_RL32(&preamble[2]);\n\n        if(chunk_size > INT_MAX)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        chunk_size = ffio_limit(pb, chunk_size);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case RoQ_INFO:\n\n            if (roq->video_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);\n\n                roq->video_stream_index = st->index;\n\n                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;\n\n                st->codecpar->codec_tag    = 0;  /* no fourcc */\n\n\n\n                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)\n\n                    return AVERROR(EIO);\n\n                st->codecpar->width  = roq->width  = AV_RL16(preamble);\n\n                st->codecpar->height = roq->height = AV_RL16(preamble + 2);\n\n                break;\n\n            }\n\n            /* don't care about this chunk anymore */\n\n            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);\n\n            break;\n\n\n\n        case RoQ_QUAD_CODEBOOK:\n\n            if (roq->video_stream_index < 0)\n\n                return AVERROR_INVALIDDATA;\n\n            /* packet needs to contain both this codebook and next VQ chunk */\n\n            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;\n\n            codebook_size = chunk_size;\n\n            avio_skip(pb, codebook_size);\n\n            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n\n                RoQ_CHUNK_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n\n                codebook_size;\n\n\n\n            if (chunk_size > INT_MAX)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            /* rewind */\n\n            avio_seek(pb, codebook_offset, SEEK_SET);\n\n\n\n            /* load up the packet */\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n\n            if (ret != chunk_size)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = roq->video_stream_index;\n\n            pkt->pts = roq->video_pts++;\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case RoQ_SOUND_MONO:\n\n        case RoQ_SOUND_STEREO:\n\n            if (roq->audio_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);\n\n                roq->audio_stream_index = st->index;\n\n                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;\n\n                st->codecpar->codec_tag = 0;  /* no tag */\n\n                if (chunk_type == RoQ_SOUND_STEREO) {\n\n                    st->codecpar->channels       = 2;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n                } else {\n\n                    st->codecpar->channels       = 1;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22426, "substitutes": {"s": ["support", "sets", "ks", "south", "sq", "S", "rs", "p", "sym", "ls", "aws", "sync", "single", "sa", "ses", "sim", "f", "ds", "xs", "sci", "stats", "sr", "si", "b", "ss", "sc", "c", "spec", "sie", "ps", "sb", "sed", "e", "cs", "r", "service", "session", "services", "qs", "d", "ops", "ssl", "gs", "self", "os", "su", "conf", "t", "sys", "sf", "client", "sl", "ns", "sg", "g", "sv", "js"], "pkt": [" psth", "psth", " packet", "ppacket", "packet", "Pct", "ppkt", "pct", "Packet", "Pkt", " pct", "ppsth", "Psth", "ppct"], "roq": ["troqa", "troql", "groq", "roQ", "groquest", "proq", "ROqa", "proquest", "groqa", "roquest", "groqt", "grok", "croqa", "ROq", "boqa", "groqs", "croqt", "koq", "koqu", " roQ", "troqs", "troquest", "broqs", "bok", "rok", "groflow", "groqu", "troqu", "riqa", "croqs", "riflow", "broq", " roqu", "riq", "broz", "proz", "roql", "broquest", "resourceq", "ROz", "croq", "proqs", "boq", "ROqs", "rouq", "groQ", "roqt", " roquest", "troq", "ROqt", "troQ", "rik", "roflow", "koquest", "koQ", "roqu", "troz", "resourcez", "rouquest", "resourceqa", "rouqu", "rouQ", "roqs", "roqa", "resourceql", "boflow", "ROql", "roz"], "pb": ["typ", "lb", "bm", "pd", "pa", "wb", "uf", "p", "cv", "bb", "platform", "ib", "db", "xb", "phrase", "pg", "pm", "pc", "b", "mp", "bh", "fc", "pp", "lab", "ub", "lp", "sb", "bps", "bp", "cb", "ab", "prot", "tmp", "fp", "hub", "pit", "vp", "plugin", "pl", "tp", "summary", "bc", "np", "PB", "rob", "cp", "ctx", "ppa", "cpp", "gb", "pkg", "fb", "bs", "dp", "eb", "wp", "rb"], "chunk_size": ["chunkacstrength", "chummy_size", "chunkacsn", "chunks_sn", "chunk_sum", "chunklexsize", "chunkacsize", "chick_id", "chummy_speed", "chunk_sn", "chunk_id", "chunklexsum", "chunk_weight", "chunk_strength", "chunklexlength", "chunk_speed", "chunk_sized", "chick_number", "chummy_value", "chunklexSIZE", "chunk_cache", "chickernumber", "chunkersized", "chickersize", "chick_size", "chunc_size", "chunkerid", "chickerid", "chunks_strength", "chunk_length", "chunc_sum", "chunc_length", "chunkactype", "chunk_number", "chunkersize", "chunkernumber", "chunk_value", "chunks_type", "chunks_size", "chick_sized", "chickersized", "chunk_SIZE", "chunk_form", "chunc_SIZE", "chummy_form"], "chunk_type": ["chunk_number", "chunkersize", "chunker_name", "chunk8index", "chunk_family", "chunk_name", "chunker_type", "chunknid", "chunkerid", "chunknnumber", "chunkerindex", "chunker_id", "chunk8id", "chunk8size", "chunk_index", "chunk8type", "chunknname", "chunkntype", "chunk6type", "chunk6size", "chunk_style", "chunkertype", "chunk_id", "chunker_number", "chunk6style", "chunk6family"], "codebook_size": ["codebookssize", "codebookslen", "codebook_capacity", "codebox_capacity", "codebookscapacity", "codebookslength", "codebook_length", "codebox_length", "codebox_size", "codebox_len", "codebook_len"], "preamble": ["prambled", "ppreamback", "Preaml", "preamBLE", "Preambles", "pREAMbled", "prombled", "pepbled", "promle", "ppreamBLE", "Preambled", "piddle", "piddbled", "Preamback", "ppREAMle", "pyml", "pREAMle", "prawle", "Pramle", " pepbled", "pREAMBLE", "pawnble", "preamback", "PREAMbler", "pepback", "pREAMback", "PREAMback", "piddble", "preambe", "pambe", "Preambe", "pepBLE", " preambled", "pepl", " preamle", "prawBLE", "pREAMbler", "pymble", "Preambler", "preambler", "pucbe", "pamle", "pawnle", "pepbler", " peple", "prawbles", "PreamBLE", "preambled", "promble", " pepl", "Prambled", "pawnbled", "prawble", "pucbles", "preaml", "Prambe", "PREAMble", "Pramble", "pREAMble", "pamble", "pymbler", "ppREAMBLE", "Preamle", "praml", "pymback", "preambles", "pepble", "pramBLE", "pawnBLE", "Prambles", " preaml", "prawback", "pramble", "peple", "ppREAMback", "pambled", "ppREAMble", " pepble", "PramBLE", "ppreamle", "Preamble", "pucle", "piddBLE", "pREAMl", "prawbe", "proml", "prambe", "prambles", "PREAMl", "pucble", "pramle", "pREAMbe", "ppreamble", "preamle"], "codebook_offset": ["codebook__offset", "codebook__no", "codeboard_position", "codeboard_offset", "codeboard_len", "codeboard__len", "codebook__position", "codeboard_no", "codeboard__offset", "codebook_no", "codeboard__position", "codebook__len", "codeboard__no", "codebook_len", "codebook_position"], "st": ["nd", "inst", "sts", "kt", "stage", "tt", "src", "stack", "lc", "fe", "sa", "se", "ft", "ST", "sr", "start", "art", "mt", "fr", "St", "sc", "ts", "ss", "ut", "ct", "bl", "sth", "rest", "stream", "sw", "sb", "ast", "pt", "sty", "tmp", "put", "sta", "nt", "sk", "std", "sh", "str", "sv", "et", "d", "est", "ist", "obj", "ost", "ust", "sp", "sd", "spect", "t", "sl", "ld", "ste", "set", "sn"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,\n\n\t\t\t\t  int16_t *filter, int16_t *filterPos, int filterSize)\n\n{\n\n#ifdef HAVE_MMX\n\n\tassert(filterSize % 4 == 0 && filterSize>0);\n\n\tif(filterSize==4) // allways true for upscaling, sometimes for down too\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 4), %%mm1\\n\\t\"\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 4), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse if(filterSize==8)\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*4;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 16(%1, %%\"REG_BP\", 8), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 24(%1, %%\"REG_BP\", 8), %%mm5\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm4, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\t\t\t\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse\n\n\t{\n\n\t\tuint8_t *offset = src+filterSize;\n\n\t\tlong counter= -2*dstW;\n\n//\t\tfilter-= counter*filterSize/2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"mov %2, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%%\"REG_c\", %0), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%%\"REG_c\", %0), %%ebx\t\\n\\t\"\n\n\t\t\t\"mov %5, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%1), %%mm1\t\t\\n\\t\"\n\n\t\t\t\"movq (%1, %6), %%mm3\t\t\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_a\"), %%mm0\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_b\"), %%mm2\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm0, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"add $8, %1\t\t\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\" jb 2b\t\t\t\t\\n\\t\"\n\n\t\t\t\"add %6, %1\t\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"mov %3, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm4, (%%\"REG_a\", %0)\t\\n\\t\"\n\n\t\t\t\"add $4, %0\t\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t: \"+r\" (counter), \"+r\" (filter)\n\n\t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset),\n\n\t\t\t  \"m\" (src), \"r\" ((long)filterSize*2)\n\n\t\t\t: \"%\"REG_b, \"%\"REG_a, \"%\"REG_c\n\n\t\t);\n\n\t}\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\n\thScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<dstW; i++)\n\n\t{\n\n\t\tint j;\n\n\t\tint srcPos= filterPos[i];\n\n\t\tint val=0;\n\n//\t\tprintf(\"filterPos: %d\\n\", filterPos[i]);\n\n\t\tfor(j=0; j<filterSize; j++)\n\n\t\t{\n\n//\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]);\n\n\t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n\t\t}\n\n//\t\tfilter += hFilterSize;\n\n\t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...\n\n//\t\tdst[i] = val>>7;\n\n\t}\n\n#endif\n\n#endif\n\n}\n", "idx": 22429, "substitutes": {"dst": ["Dst", "Ddest", "idost", "idst", " dbl", " dsrc", "Dsc", "dstal", "ddest", "nddest", "dsrc", " dost", "dbl", "Dsts", "datsc", "ndsts", " dsc", "Dbl", "dsc", "Dstal", "datbl", "datsrc", "idstal", "dost", "dsts", "ndstal", " ddest", "datst", "ndst", "idsts", " dsts", " dstal", "Dsrc", "Dost"], "dstW": ["dsrcH", "dblW", "DSTH", "dsrcL", "drcL", "dconstW", "dconstw", "lconstW", "DSTw", "lstw", "dstV", "DSTWidth", "dscWidth", "lconstw", "dstWidth", "dSTH", "dscV", "DSTW", "dstw", "Dstw", "dSTV", "dsrcw", " dblWidth", "dsrcN", "lstW", "dsrcWidth", "dstL", "dblWidth", "dblw", "drcw", "dblV", "drcW", "lconstN", " dstWidth", "DstWidth", " dblV", "lconstL", "dconstL", "lstL", "dscW", "lstN", "dSTW", "dscw", "dstH", " dblw", " dblW", "DstW", " dstw", "dconstN", "drcN", "dstN", "DstH", " dstV", "dblH", "dSTWidth", "dsrcW", "dSTw"], "src": ["RC", "secure", "rin", "scan", "reflect", "sync", "loc", "config", "sr", "sc", "scl", "stream", "sb", "rib", "dest", "usr", "source", "conv", "sur", "url", "rc", "attr", "fn", "sort", "include", "sl", "rb"], "srcW": ["destRW", " srcRW", "sourceL", "srcV", "sourceV", " srcV", "sourceW", "destL", "sourceRW", " srcL", "srcL", "destW", "srcRW", "destV"], "xInc": ["ixInc", " xinc", "ixAdd", "ixDir", "rxInc", " xDir", "rxDir", "xAdd", "xDir", "rxAdd", " xAdd", "ixinc", "xinc", "rxinc"], "filter": ["channel", "support", "shape", "cover", "match", "version", "event", "block", "force", "name", "type", "f", "wave", "counter", "config", "Filter", "ir", "mask", "per", "resource", "header", "control", "parent", "path", "search", "fl", "fil", "page", "tail", "query", "batch", "limit", "output", "source", "plugin", "profile", "layer", "target", "url", "model", "rf", "sort", "skip", "feature", "frequency", "stop"], "filterPos": ["featurePos", "filpos", "filterLen", " filterPo", "sourcePos", "featurePo", "sourceDir", "featureSize", "filterOffset", "filterDir", "sortPos", "sourcepos", "filSize", "filPo", "sourceMin", "filterMin", " filterpos", "filterPo", "FilterSize", "sortSize", "sortOffset", "FilterPos", "filPos", "filMin", " filterMin", " filterOffset", "featurepos", "filDir", " filterLen", "FilterLen", "FilterOffset", "filterpos", " filterDir", "sortLen"], "filterSize": ["flatCode", "controlSize", "headerSIZE", "filterLen", "headerSmall", "sortC", "maskSIZE", "masksize", "FilterSIZE", "filterSIZE", "filsize", "FilterCode", "maskSize", "maskAddress", "flatSize", "flatSIZE", "filtersize", "controlCode", "sortsize", "filterCode", "controlsize", "filSize", "headerSize", "FilterC", "filSmall", "FilterSize", " filterCode", "sortSize", "filSIZE", "filterSmall", " filterSmall", "sortCode", "headerC", " filtersize", "filterC", "filAddress", " filterSIZE", "sortSIZE", "filterAddress", " filterLen", " filterAddress", "FilterLen", "Filtersize", "controlSIZE", "filC", " filterC", "sortLen"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "substitutes": {"f": ["cf", "af", "w", "p", "inf", "lf", "fr", "fs", "tf", "bf", "v", "fc", "F", "fw", "elf", "c", "df", "o", "fen", "framework", "e", "l", "fd", "fp", "ref", "tif", "fo", "ff", "rf", "i", "self", "m", "fx", "t", "fb", "sf", "file", "g", "this", "new"], "ret": ["att", "resp", "rets", "res", "pret", "al", "lit", "en", "mem", "cat", "rt", "val", " Ret", "det", "pat", "mt", "RET", "ry", "back", "fun", "reg", "red", "nt", "result", "ref", "reply", "re", "arr", "xt", "id", "alt", "arg", "Ret", "rep", "ext"]}}
{"project": "FFmpeg", "commit_id": "d3b4b74c32cf302d36a4c4d2cce08027f0a22560", "target": 0, "func": "static int encode_picture_lossless(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    MJpegContext * const m = s->mjpeg_ctx;\n\n    AVFrame *pict = data;\n\n    const int width= s->width;\n\n    const int height= s->height;\n\n    AVFrame * const p= (AVFrame*)&s->current_picture;\n\n    const int predictor= avctx->prediction_method+1;\n\n\n\n    init_put_bits(&s->pb, buf, buf_size);\n\n\n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    p->key_frame= 1;\n\n\n\n    ff_mjpeg_encode_picture_header(s);\n\n\n\n    s->header_bits= put_bits_count(&s->pb);\n\n\n\n    if(avctx->pix_fmt == PIX_FMT_RGB32){\n\n        int x, y, i;\n\n        const int linesize= p->linesize[0];\n\n        uint16_t (*buffer)[4]= (void *) s->rd_scratchpad;\n\n        int left[3], top[3], topleft[3];\n\n\n\n        for(i=0; i<3; i++){\n\n            buffer[0][i]= 1 << (9 - 1);\n\n        }\n\n\n\n        for(y = 0; y < height; y++) {\n\n            const int modified_predictor= y ? predictor : 1;\n\n            uint8_t *ptr = p->data[0] + (linesize * y);\n\n\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < width*3*4){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            for(i=0; i<3; i++){\n\n                top[i]= left[i]= topleft[i]= buffer[0][i];\n\n            }\n\n            for(x = 0; x < width; x++) {\n\n                buffer[x][1] = ptr[4*x+0] - ptr[4*x+1] + 0x100;\n\n                buffer[x][2] = ptr[4*x+2] - ptr[4*x+1] + 0x100;\n\n                buffer[x][0] = (ptr[4*x+0] + 2*ptr[4*x+1] + ptr[4*x+2])>>2;\n\n\n\n                for(i=0;i<3;i++) {\n\n                    int pred, diff;\n\n\n\n                    PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                    topleft[i]= top[i];\n\n                    top[i]= buffer[x+1][i];\n\n\n\n                    left[i]= buffer[x][i];\n\n\n\n                    diff= ((left[i] - pred + 0x100)&0x1FF) - 0x100;\n\n\n\n                    if(i==0)\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                    else\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                }\n\n            }\n\n        }\n\n    }else{\n\n        int mb_x, mb_y, i;\n\n        const int mb_width  = (width  + s->mjpeg_hsample[0] - 1) / s->mjpeg_hsample[0];\n\n        const int mb_height = (height + s->mjpeg_vsample[0] - 1) / s->mjpeg_vsample[0];\n\n\n\n        for(mb_y = 0; mb_y < mb_height; mb_y++) {\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < mb_width * 4 * 3 * s->mjpeg_hsample[0] * s->mjpeg_vsample[0]){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n            for(mb_x = 0; mb_x < mb_width; mb_x++) {\n\n                if(mb_x==0 || mb_y==0){\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n                                if(y==0 && mb_y==0){\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= 128;\n\n                                    }else{\n\n                                        pred= ptr[-1];\n\n                                    }\n\n                                }else{\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= ptr[-linesize];\n\n                                    }else{\n\n                                        PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n                                    }\n\n                                }\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n//printf(\"%d %d %d %d %8X\\n\", mb_x, mb_y, x, y, ptr);\n\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(s);\n\n    s->picture_number++;\n\n\n\n    flush_put_bits(&s->pb);\n\n    return pbBufPtr(&s->pb) - s->pb.buf;\n\n//    return (put_bits_count(&f->pb)+7)/8;\n\n}\n", "idx": 22436, "substitutes": {"avctx": ["avecam", "avqa", "afcmp", "avercam", "afqa", "afcv", "avecmp", "avconfig", "navcontext", "AVc", "afpkg", "AVcf", "AVconfig", "avecf", "avcontext", " avpkg", "avecontext", "Avpkg", "avpkg", "aveqa", "avconn", "avectx", "AVctx", "afconn", "averctx", "afc", "AVcontext", "avc", "abcmp", " avcv", "avercmp", "Avctx", "avcmp", "avcam", "avcv", "afconfig", "abconfig", "abctx", " avcontext", "avec", "afcf", "afcam", "navqa", "afctx", "avcf", "navconn", "aveconn", "avercontext", "Avcv", "AVcmp", "abcontext", "navctx", "Avcontext", "afcontext"], "buf": ["Buffer", "cap", "br", "cf", "text", "wb", "cv", "uf", "src", "alloc", "queue", "mem", "block", "img", "num", "buff", "proc", "uc", "cmd", "b", "raw", "seq", "header", "cb", "vec", "fd", "aux", "fp", "batch", "window", "pb", "dest", "ctr", "off", "conv", "ff", "port", "bc", "rc", "ctx", "fb", "map", "file", "rb", "prefix"], "buf_size": ["buflexsize", "buf1size", "padlexcount", "pad_count", "buf1num", "buf_form", "buf5form", "pad_depth", "pad_size", "pad_form", "buflexnum", "buf1source", "buflexcount", "buf5size", "padlexsize", "buflexform", "buf5count", "buf_num", "buf5depth", "buflexsource", "padlexdepth", " buf_num", "padlexform", "buflexdepth", "buf_depth", "buf_source", " buf_source", "buf_count"], "data": ["first", "ui", "image", "text", "empty", "cache", "capt", "DATA", "queue", "block", "code", "img", "buff", "offset", "proc", "f", "config", "devices", "body", "media", "device", "a", "next", "bin", "picture", "padding", "parent", "board", "dat", "alpha", "tmp", "batch", "result", "window", "format", "d", "pos", "video", "memory", "input", "reader", "pad", "Data", "slice", "open", "map"], "s": ["ins", "se", "f", "si", "a", "sb", "storage", "sm", "cs", "u", "ops", "gs", "conf", "spec", "sv", "support", "aws", "sa", "ses", "ds", "xs", "is", "sc", "ts", "b", "n", "ps", "hs", "sites", "e", "services", "parts", "sup", "os", "params", "sts", "S", "ks", "sym", "bis", "stat", "stats", "c", "space", "r", "service", "qs", "small", "es", "ctx", "sp", "sys", "t", "client", "sl", "g", "settings", "sets", "sq", "rs", "sync", "sg", "http", "fs", "ss", "session", "tp", "d", "ssl", "su", "self", "sf", "ns", "ls", "sec", "ms", "js"], "m": ["mc", "bm", "man", "w", "nm", "gm", "mem", "M", "f", "mn", "mA", "mm", "media", "mp", "mac", "n", "c", "r", "l", "manager", "cm", "d", "mi", "g", "ms", "ml"], "pict": ["png", "image", "doc", "fig", "capt", "jp", "img", "pic", "buff", "proc", "info", "stat", "config", "sci", "ct", "seq", "Picture", "picture", "peg", "feat", "photo", "conn", "password", "tmp", "jpg", "fp", "fat", "pb", "fi", " picture", "phot", "Pict", "cp", "np", "obj", "ctx", "pty", "txt", "csv", "cam"], "p": ["po", "part", "gp", "pe", "pd", "pa", "jp", "pr", "pic", "pointer", "j", "pg", "f", "pc", "b", "pp", "pi", "n", "a", "c", "parent", "ps", "lp", "o", "bp", "e", "l", "P", "r", "fp", "pn", "py", "pb", "u", "pre", "vp", "tp", "d", "np", "cp", "sp", "cop", "t", "g", "op"], "x": ["image", "w", "xy", "ix", "pe", "xc", "yx", "host", "code", "X", "num", "ex", "el", "ax", "j", "f", "q", "xxx", "rx", "b", "win", "ct", "xx", "n", "index", "height", "c", "wx", "any", "e", "dx", "l", "r", "tx", "xp", "xi", "u", "d", "on", "pos", "in", "k", "id", "fx", "t", "sex", "px", "g", "z", "ip"], "y": ["ey", "ym", "ty", "ny", "cy", "w", "xy", "yl", "sky", "sy", "yt", "ye", "oy", "j", "type", "f", "b", "ry", "yr", "xx", "height", "n", "c", "o", "python", "e", "l", "ya", "ch", "py", "u", "yi", "d", "vy", "count", "hi", "yy", "id", "t", "yn", "dy", "Y", "yo", "g", "z", "ay"], "i": ["ti", "ii", "ui", "my", "qi", "w", "I", "ix", "eni", "phi", "di", "j", "info", "f", "ai", "ip", "ini", "ie", "ni", "q", "b", "si", "io", "init", "pi", "n", "index", "c", "o", "e", "l", "xi", "u", "yi", "chi", "fi", "d", "li", "iu", "in", "one", "hi", "k", "id", "mi", "zi", "ci", "t", "multi", "gi", "g", "z", "bi", "it", "mu"], "buffer": ["cache", "proc", "uffer", "border", "table", "window", "source", "bc", "pos", "pad", "all", "writer", "iter", "stack", "img", "_", "config", "b", "header", "surface", "page", "memory", "input", "transfer", "slice", "resource", "Buffer", "pause", "cap", "text", "buff", "c", "r", "profile", "vector", "cube", "server", "program", "g", "pool", "image", "scroll", "uf", "queue", "que", "document", "paste", "padding", "position", "message", "result", "ctr", "command", "port", "layer", "d", "context"], "top": ["first", "stack", "high", "platform", "offset", "pointer", "above", "upper", "max", "start", "up", "per", "Top", "parent", "position", "pt", "min", "root", "tail", "tip", "but", "dot", "pop", "bottom", "bot", "target", "tops", "TOP", "sp", "best", "skip", "last", "master", "stop", "op"], "topleft": ["stoplefts", "tokeaft", "stoplequest", "tolloft", "stopleaft", "trossovel", "triefts", "striecl", "stoplecl", "tounquest", "trossoquest", "toplequest", "topleaft", "t\u00faquest", "tounft", "tollofts", "stoplevel", "tounvel", "t\u00favel", "stounft", "trossofts", "tolloaft", "trieft", "toplecl", "t\u00faft", "trieaft", "striefts", "tollocl", "stounquest", "toplevel", "tokefts", "toplefts", "stounfts", "tounfts", "stopleft", "tokeft", "trossoft", "strieaft", "stounvel", "tokecl", "triecl", "t\u00fafts", "strieft"], "ptr": ["inst", "iv", "br", "alloc", "pr", "butt", "code", "que", "pair", "pointer", "loc", "buff", "offset", "elt", "length", "ud", "td", "rt", "val", "cur", "temp", "padding", "rot", "Ptr", "pt", "prot", "ref", "pre", "tr", "inter", "pl", "pos", "attr", "arr", "xt", "pty", "dr", "pad", "rect", "grad", "slice", "addr", "pointers", "ext", "tips"], "linesize": ["framesize", "linescale", "netsizes", " linespace", "framescore", "framesizer", "linscale", "linsizes", "linesiz", "possize", "linesization", "linesIZE", "elinespace", "elinesization", "linsIZE", "netscale", "elinesize", "elinesIZE", " linesIZE", "linssize", "framesiz", " linesization", "linesizes", "linesizer", " linesizer", "linspace", "poscale", "planesize", "planesiz", "netssize", "posize", " linesiz", "netsize", " linescore", "linsize", "posizes", "planescore", "linespace", "planesizer", "linescore", "linsization", "linessize"]}}
{"project": "FFmpeg", "commit_id": "934fe00680a1139cbc0950641655af5923dd7763", "target": 0, "func": "static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (o->format) {\n\n        if (!(file_iformat = av_find_input_format(o->format))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Unknown input format: '%s'\\n\", o->format);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n    if (o->nb_audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (o->nb_audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_channels[o->nb_audio_channels - 1].u.i);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (o->nb_frame_rates) {\n\n        av_dict_set(&format_opts, \"framerate\", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_sizes) {\n\n        av_dict_set(&format_opts, \"video_size\", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_pix_fmts)\n\n        av_dict_set(&format_opts, \"pixel_format\", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);\n\n\n\n    ic->video_codec_id   = video_codec_name ?\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;\n\n    ic->audio_codec_id   = audio_codec_name ?\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;\n\n    ic->subtitle_codec_id= subtitle_codec_name ?\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n    ic->interrupt_callback = int_cb;\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* open the input file with generic avformat function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    /* apply forced codec ids */\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        choose_decoder(o, ic, ic->streams[i]);\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        exit_program(1);\n\n    }\n\n\n\n    timestamp = o->start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n", "idx": 22459, "substitutes": {"o": ["po", "image", "oe", "p", "bo", "original", "co", "http", "go", "mo", "f", "online", "ocr", "to", "object", "oi", "ro", "ov", "io", "so", "O", "oo", "oc", "n", "c", "from", "e", "l", "ou", "module", "iso", "u", "oid", "fo", "off", "ob", "obj", "one", "k", "oa", "os", "m", "vo", "ow", "t", "ant", "lo", "ao", "custom", "ot", "od", "ko", "wo", "no", "node", "ilo", "op", "ol"], "opt": ["timeout", "w", "text", "alloc", "options", "enc", "cat", "loc", "option", "proc", "info", "config", "cmd", "oc", "io", "path", "root", "Option", "attr", "url", "obj", "Opt", "ctx", "fn", "open", "rec", "op"], "filename": ["timeout", "title", "il", "png", "src", "wav", "which", "println", "directory", "location", "nil", "name", "wl", "phrase", "ln", "msg", "f", "length", "document", "bf", "Filename", "dll", "sheet", "files", "uri", "path", "microsoft", "fil", "l", "jpg", "download", "fd", "fp", "source", "ename", "nuclear", "json", "login", "url", "kl", "username", "fax", "txt", "fn", "sf", "kn", "lua", "fb", "file", "subject", "binary", "prefix", "tty", "utf"], "ic": ["mc", "nic", "cy", "mic", "gc", "cit", "xc", "cu", "lc", "cci", "pic", "ac", "isc", "au", "ici", "ai", "aci", "pc", "anc", "oc", "fc", "ct", "acs", "c", "ics", "xi", "IC", "lic", "aic", "ico", "fi", "iac", "bc", "ican", "ig", "tc", "ik", "vc", "ctx", "ci", "ant", "voc", "ec", "icc", "icer"], "file_iformat": ["file_iplat", "file_isolit", "file_iplt", "file_iolac", "file__iolant", "file_iolant", "file_iformata", "file_iplac", "file_iolata", "file__iolt", "file_iddac", "file_iformt", "file_iformac", "file__iformant", "file_iolt", "file_iolat", "file_iliart", "file_iddat", "file_iformant", "file__iformt", "file_iliata", "file_isolat", "file_iolart", "file_isolart", "file_iformit", "file__iformac", "file_iplant", "file__iformat", "file_iformart", "file__iolac", "file_iddt", "file_isolata", "file_iolit", "file_iliit", "file_iddant", "file__iolat", "file_iliat"], "err": [" resp", "req", " len", "res", "resp", "h", "status", "stat", " fe", " error", "len", " seq", "seq", "cb", "fun", "error", "rr", "fd", "nt", "result", " pri", "out", " typ", "rc", " aux", " rc", "id", "var"], "i": ["ti", "ii", "ui", "x", "I", "ix", "p", "h", "info", "f", "ai", "s", "ini", "ni", "is", "si", "io", "b", "v", "pi", "n", "index", "c", "ind", "e", "l", "r", "u", "li", "d", "iu", "count", "k", "id", "mi", "ci", "m", "t", "zi", "z", "it", "ip"], "ret": ["res", "en", "mem", "cat", "rt", "val", "buffer", "status", "wa", "RET", "ry", "len", "seq", "back", "cb", "aux", "nt", "result", "fi", "bc", "rc", "flag", "alt", "Ret", "no"], "timestamp": ["microoffset", "imestamp", "frametime", "microest", "imest", "microestamp", "microetime", "imetime", "timest", "imoffset", "timoffset", "timetime", "framest", "framoffset", "framestamp"], "buf": ["br", "box", "cv", "buffer", "proc", "f", "cur", "seq", "feat", "begin", "window", "ref", "pb", "ucc", "ff", "bc", "data", "null", "bn", "la", "fb", "bytes", "desc", "doc", "src", "img", "Buff", "loc", "msg", "config", "bf", "b", "header", "vec", "fd", "batch", "auc", "rc", "cap", "text", "wb", "font", "bo", "mem", "buff", "bg", "func", "uc", "wx", "aux", "tmp", "fp", "byte", "output", "usr", "bag", "conv", "url", "ctx", "rb", "pool", "uf", "alloc", "queue", "block", "bd", "bh", "bin", "cb", "fam", "str", "port", "context", "bed"], "opts": [" opttes", " opttr", "opertes", " optr", "operts", " optfs", "optes", " opfs", "optr", " optts", " optes", "opertr", "opfs", "operfs"], "orig_nb_streams": [" orig_nb_inputs", " orig_nb_streamries", " orig_nb_streamd", " orig_nb_roundd", " orig_nb_roundries", " orig_nb_threads", " orig_nb_streaming", " orig_nb_threadries", " orig_nb_rounds", " orig_nb_inputries", " orig_nb_rounding", " orig_nb_inputd", " orig_nb_threading", " orig_nb_threadd", " orig_nb_inputing"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 22462, "substitutes": {"val": ["expr", "VAL", "x", "eval", "al", "p", "el", "rt", "f", "valid", "func", "b", "v", "vol", "scale", "base", "pt", "ind", "min", "l", "tx", "cal", "py", "ref", "vals", "value", "cond", "data", "arr", "ctx", "unit", "gb", "fx", "Val", "grad", "sl", "all", "var"], "u": ["ui", "ul", "du", "ur", "ue", "w", "uf", "p", "cu", "us", "num", "f", "s", "uv", "q", "ru", "io", "ut", "b", "v", "up", "a", "c", "o", "U", "user", "l", "tu", "ou", "bu", "lu", "yu", "d", "iu", "pu", "eu", "i", "su", "chu", "t", "util", "nu", "uu", "mu"]}}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n", "idx": 22465, "substitutes": {"linker": ["layler", "laye", "fixer", "installier", "layener", "fixker", " linkener", "lockator", "lockener", "locke", "linkener", "layator", "layger", "puller", "locker", "layner", "pullier", " linkler", "linkker", "linkator", "lockner", "pullker", "lockler", " linkner", "lockger", " linkger", " linkator", " linke", "fixener", "pullener", "layer", "linkger", "installer", "linkner", "fixier", "installener", "linkier", "linke", "installker", "linkler"], "file_name": ["entry_connection", "entryNamename", "filexuri", "fileMname", "fileNameconnection", "fileMName", "fileNamestring", "entryNamelen", "entryNameName", "file_connection", "file_Name", "entry_name", "file_num", "entryNameconnection", "fileNamelen", "fileNameName", " file_string", "file_address", "entry_len", " file_uri", "filexnum", "entry_Name", " file_num", "fileMlen", "fileMconnection", " file_address", "file_uri", "filexname", "fileNamename", "file_string", "fileNameaddress", "file_len"], "start": ["first", "time", "part", "image", "line", "origin", "step", "starting", "block", "use", "se", "offset", "name", "load", "type", "info", "length", "address", "init", "len", "resource", "index", "scale", "position", "base", "range", "from", "error", "begin", "space", "sum", "enable", "limit", "run", "end", "source", "read", "pos", "data", "scope", "count", "grade", "id", "shift", "unit", "self", "Start", "speed", "slice", "last", "skip", "stop", "set", "new", "get"], "size": ["time", "timeout", "capacity", "shape", "empty", "izes", "sync", "use", "se", "offset", "name", "loc", "mode", "length", "extra", "address", "si", "Size", " sizes", "second", "len", "n", "scale", "SIZE", "position", "send", "sum", "storage", "from", "style", "set", "limit", "ize", "end", "six", "small", "source", "member", "data", "count", "sized", "unit", "i", "speed", "number", "last", "slice", "g", "all"], "checksum": ["cksums", "checksam", "readsumm", " checkssum", "cksup", "cksnum", "checksums", "checkam", "checkum", "readsume", "cksumm", "alsumer", "cksume", "alssum", "checksup", " checksumer", "alsum", " checksup", " checksumm", "checksnum", " checksume", " checksnum", "checkssum", "ckssum", "cksam", " checksums", "readsum", "checksume", "cksumer", "readsnum", "checkup", " checksam", "alsums", "checksumer", "checksumm", "cksum"], "entry": ["write", "line", "match", "class", "cache", "lc", "escape", "se", "offset", "info", "valid", "si", "view", "table", "ger", "module", "source", "diff", "archive", "data", "Entry", "component", "add", "comment", "inner", "writer", "try", "part", "ue", "event", "row", "ge", "her", "name", "index", "e", "install", "end", "array", "enter", "ries", "package", "cell", "element", "parse", "way", "insert", "ie", "expected", "feed", "ry", "error", "export", "entity", "or", "service", "byte", "connection", "value", "member", "server", "record", "new", "image", "zero", "code", "type", "import", "extra", "object", "next", "parser", "engine", "result", "command", "reader", "cue", "ent", "loader", "sec", "inc"], "file": ["time", "line", "cache", "use", "buffer", "offset", "le", "info", "f", "content", "base", "table", "module", "source", "data", "count", "phase", "binary", "comment", "part", "item", "ge", "db", "name", "dir", "len", "index", "parent", "from", "page", "filename", "format", "end", "rule", "model", "child", "resource", "set", "il", "File", "el", "folder", "length", "feed", "change", "files", "handler", "l", "service", "fp", "limit", "letter", "connection", "value", "url", "unit", "pool", "single", "full", "ul", "image", "queue", "block", "type", "lane", "up", "per", "path", "play", "message", "ile", "port", "read", "this"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->internal->thread_ctx;\n\n    FrameThreadContext *fctx;\n\n    AVFrame *dst, *tmp;\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                          avctx->thread_safe_callbacks                   ||\n\n                          (\n\n#if FF_API_GET_BUFFER\n\n                           !avctx->get_buffer &&\n\n#endif\n\n                           avctx->get_buffer2 == avcodec_default_get_buffer2);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    if (!f->f->buf[0])\n\n        return;\n\n\n\n    if (avctx->debug & FF_DEBUG_BUFFERS)\n\n        av_log(avctx, AV_LOG_DEBUG, \"thread_release_buffer called on pic %p\\n\", f);\n\n\n\n    av_buffer_unref(&f->progress);\n\n    f->owner    = NULL;\n\n\n\n    if (can_direct_free) {\n\n        av_frame_unref(f->f);\n\n        return;\n\n    }\n\n\n\n    fctx = p->parent;\n\n    pthread_mutex_lock(&fctx->buffer_mutex);\n\n\n\n    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))\n\n        goto fail;\n\n    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,\n\n                          (p->num_released_buffers + 1) *\n\n                          sizeof(*p->released_buffers));\n\n    if (!tmp)\n\n        goto fail;\n\n    p->released_buffers = tmp;\n\n\n\n    dst = &p->released_buffers[p->num_released_buffers];\n\n    av_frame_move_ref(dst, f->f);\n\n\n\n    p->num_released_buffers++;\n\n\n\nfail:\n\n    pthread_mutex_unlock(&fctx->buffer_mutex);\n\n}\n", "idx": 22503, "substitutes": {"avctx": ["ajctx", "afcal", "aveca", "avectl", "afcmp", "avcal", "devctx", "avecmp", "avconfig", "AVcf", "evconv", "axctx", "AVconfig", "afconv", "avlc", "ayctl", "afctl", "devcontext", "aycu", "afca", "avcontext", "AVcu", "avecontext", "afcu", "ajcu", "avcu", "avectx", "avconn", "avconv", "ajconn", "AVctx", "devcmp", "aveconfig", "afhw", "evctx", "avctl", "aycontext", "afconn", "AVcontext", "ayctx", "axctl", "avcmp", "abhw", "avhw", "avehw", "evcu", "axca", "afconfig", "AVconn", "abctx", "ajcal", "AVcal", "ajcontext", "afcf", "avelc", "AVlc", "axcontext", "avecu", "afctx", "ajconv", "evcontext", "avca", "aflc", "devcf", "avcf", "AVcmp", "abcontext", "abcmp", "afcontext"], "f": ["full", "cf", "af", "interface", "x", "w", "cache", "uf", "h", "fe", "inf", "frame", "j", "info", "s", "q", "fr", "fs", "tf", "bf", "b", "feed", "v", "fc", "F", "c", "df", "fw", "elf", "parent", "fen", "framework", "e", "fl", "l", "fa", "flow", "fd", "r", "fp", "ref", "u", "fac", "function", "fo", "ff", "fi", "d", "rf", "k", "i", "m", "form", "fx", "t", "fn", "sf", "fb", "conf", "ext", "file", "g", "exec", "of", "new", "fm"], "p": ["po", "part", "br", "w", "pe", "pa", "cache", "jp", "pr", "h", "parse", "http", "j", "app", "pg", "s", "pm", "q", "pc", "b", "v", "up", "per", "pi", "n", "pp", "c", "parent", "ps", "lp", "o", "bp", "e", "patch", "l", "P", "r", "fp", "u", "pb", "pre", "point", "vp", "post", "tp", "d", "np", "api", "cp", "after", "ctx", "i", "self", "m", "sp", "cop", "t", "pkg", "k", "ap", "g", "this", "wp", "op"], "fctx": ["cfcmp", "cfcontext", "pcmp", "psci", "fxctx", "Fcontext", "Fctx", "frcmp", "cfctrl", "Fca", "fctrl", "fcf", "Fcf", "afca", "cfsci", "flowsci", "flowcmp", "ifcf", " ftx", "pctrl", "fxtx", "flowcontext", "fcontext", "fsci", "Fcb", "ftx", "pctx", "frcontext", "Ftx", " fcb", "ifctx", "frctrl", "frctx", "afcf", "cfctx", "fca", "fcmp", "afctx", "fxcontext", "flowctx", "fxcb", "fcb", " fcontext", "ifca", "ifcontext", "pcontext", "afcontext"], "dst": ["Dst", "hdset", "ddput", "dedst", " dsrc", "dfe", "dedsts", "lost", "hdst", "adst", "rdsts", "dsrc", " dost", "dstore", "Dsts", "ddset", "adput", "adset", "hdstore", "lst", "dedST", "Dfe", " dST", "rdsrc", "dST", "hdput", "rdst", "dost", "dsts", "dput", "dedost", "adstore", "ddstore", "dset", " dfe", " dsts", "rdfe", "lST", "Dsrc", "ddst", "lsts"], "tmp": ["zip", "part", "stuff", "beta", "tt", "cache", "jp", "src", "test", "bb", "img", "buff", "loc", "j", "proc", "Temp", "now", "vv", "nb", "tf", "bf", "b", "mp", "v", "bug", "temp", "bt", "buf", "cb", "sb", "err", "acc", "fd", "fp", "vt", "result", "nt", "pre", "pb", "boot", "output", "dest", "copy", "sup", "tp", "attr", "cp", "pos", "tc", "mmm", "diff", "ptr", "obj", "kk", "data", "sp", "emp", "cpp", "pad", "su", "t", "pkg", "fb", "txt", "fake", "cmp", "slice", "wp", "rb"], "num_released_buffers": ["num_released_bufers", "num_released_buffeners", "num_released_countensions", "num_releasedingbuckers", "num_releaseditybuffests", "num_released_ufores", "num_released_scribants", "num_released_compers", "num_released_buckerc", "num_released_buffer", "num_released_counterc", "num_releaseditycodeners", "num_released_bufERS", "num_releasedingbuffants", "num_released_coder", "num_released_buterers", "num_releaseditycodests", "num_released_callers", "num_released_bufferers", "num_releaseditybuffer", "num_released_fundERS", "num_released_fundores", "num_released_buffensions", "num_released_bufters", "num_released_fundters", "num_released_Bufferc", "num_released_ufERS", "num_released_bufores", "num_released_Buffeners", "num_releaseditycoders", "num_released_scriberc", "num_released_compERS", "num_released_scribers", "num_released_Buffer", "num_releasedingbuckants", "num_released_calleners", "num_released_Buffers", "num_released_coders", "num_released_caller", "num_released_buckants", "num_released_countants", "num_releaseditycoder", "num_released_buters", "num_released_buffERS", "num_released_buckers", "num_releasedingbuckerc", "num_released_counters", "num_released_BuffERS", "num_releasedingbuffensions", "num_released_Bufferers", "num_releasedingbufferc", "num_released_bufferc", "num_releasedingbuffers", "num_released_callests", "num_released_funders", "num_released_buffters", "num_released_comperers", "num_releaseditybuffers", "num_releasedingbuckensions", "num_releaseditybuffeners", "num_released_ufters", "num_released_comperc", "num_released_butERS", "num_released_codeners", "num_released_ufers", "num_released_buckensions", "num_released_buffests", "num_released_codests", "num_released_buffants", "num_released_Buffests", "num_released_scribensions", "num_released_buffores", "num_released_buterc"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n", "idx": 22531, "substitutes": {"queue": ["channel", "loop", "menu", "collection", "line", "ue", "cache", "event", "p", "sync", "que", "route", "buffer", "complete", "status", "config", "q", "priority", "seq", "thread", "future", "entry", "sequence", "pipe", "user", "message", "page", "batch", "module", "manager", "plugin", "command", "port", "qa", "progress", "model", "worker", "flag", "job", "client", "server", "list", "Queue", "file", "group", "lib", "prefix", "pool"], "free_func": ["freefuncdc", "freefunccb", "free2func", "free_function", " free_cb", "free_pc", " free_dc", "free2pc", "free2function", "free__cb", "free__dc", "free2lambda", "free__function", "free_lambda", " free_pc", "freefuncfunc", "free__func", " free_lambda", "free_cb", "freefuncfunction", "free_dc", " free_function"]}}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534, "substitutes": {}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n", "idx": 22545, "substitutes": {"val": ["expr", "il", "VAL", "def", "eval", "al", "el", "loc", "valid", "func", "v", "len", "index", "vol", "base", "reg", "slot", "ind", "pt", "min", "cal", "ref", "sel", "vals", "value", "data", "count", "unit", "alt", "Val", "sl", "sec", "ay", "all", "ol"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 22552, "substitutes": {"dc": ["mc", "desc", "dm", "cf", "du", "doc", "gc", "gui", "lc", "ea", "enc", "cd", "cc", "dt", "ac", "db", "di", "DC", "ds", "loc", "config", "pc", "uc", "disc", "cmd", "sc", "oc", "jc", "ct", "fc", "mac", "df", "c", "ga", " DC", "da", "dat", "draw", "conn", "fd", "source", "cm", "d", "bc", "ic", "rc", "tc", "design", "input", "cdn", "cca", "vc", "dr", "nc", "dp", "context", "enter", "exec", "inc", "ec"], "t0": ["t8", " t50", " t8", "T25", "T1", "tt4", " tfe", " t4", "T0", " t1", "t25", "tt0", "p4", "p1", " T1", "ta4", "tfe", "T4", "t1", "tt8", "f1", "p50", "ta1", " t25", "t4", "ta8", "p0", "t50", "tt25", " t2", "ta0", " Tfe", "T50", "tt1", "f0", "f2", " T0", "t2", "tt2", "Tfe", "T2"]}}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "AVInputFormat *av_find_input_format(const char *short_name)\n\n{\n\n    AVInputFormat *fmt = NULL;\n\n    while ((fmt = av_iformat_next(fmt)))\n\n        if (match_format(short_name, fmt->name))\n\n            return fmt;\n\n    return NULL;\n\n}\n", "idx": 22559, "substitutes": {"short_name": ["Short_NAME", "Short_name", "shortnamename", "shortnamenames", "shortPName", "shortFpath", "short_NAME", "short_names", "Short_size", "Short_Name", "shortPname", "short2NAME", "shortFname", "short_size", "shortFnames", "shortPnames", "short2name", "Short_names", "shortFName", "short_Name", "shortnameNAME", "short2size", "short_path", "short2names", "shortnamesize", "Short_path", "shortPpath"], "fmt": ["fmd", "formmd", " fbf", "formmt", "frlt", "flt", "tflt", "fatt", "Fpr", "compatter", " fmd", "fpl", "Fmd", "tfnt", "Fmt", "complt", "fatter", "frmd", "Flt", "Fpl", "fMT", "frnt", " fatter", "ufpr", "bmt", "bpl", "formnt", "fpr", "bpr", " fatt", "tfMT", "frmt", "Fatter", "ufmt", "Fnt", "Fatt", "tfmd", " fMT", "blt", "tfmt", "compbf", "fbf", "FMT", "fnt", "Fbf", "ufpl", " flt", "compmt", "formlt", " fnt", "uflt", "tfatt"]}}
{"project": "FFmpeg", "commit_id": "b791a0831b0a027e7ba4eb6961cc0180472ac603", "target": 1, "func": "static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,\n\n                                      int mm_flags)\n\n{\n\n#if HAVE_SSE2_INLINE\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {\n\n        c->idct_put              = ff_idct_xvid_sse2_put;\n\n        c->idct_add              = ff_idct_xvid_sse2_add;\n\n        c->idct                  = ff_idct_xvid_sse2;\n\n        c->idct_permutation_type = FF_SSE2_IDCT_PERM;\n\n    }\n\n#endif /* HAVE_SSE2_INLINE */\n\n\n\n#if HAVE_SSE2_EXTERNAL\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;\n\n    if (mm_flags & AV_CPU_FLAG_ATOM) {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;\n\n    } else {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_sse2;\n\n    }\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_sse2;\n\n    } else if (!(mm_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        c->apply_window_int16 = ff_apply_window_int16_round_sse2;\n\n    }\n\n    c->bswap_buf = ff_bswap32_buf_sse2;\n\n#endif /* HAVE_SSE2_EXTERNAL */\n\n}\n", "idx": 22597, "substitutes": {"c": ["C", "dc", "mc", "cf", "cy", "x", "w", "cv", "xc", "cache", "p", "lc", "cu", "enc", "h", "cd", "call", "cc", "co", "ac", "ce", "f", "config", "s", "coll", "pc", "cur", "cr", "uc", "oc", "sc", "b", "v", "ct", "fc", "a", "n", "con", "ca", "o", "e", "cs", "l", "r", "ch", "u", "cm", "d", "bc", "cp", "tc", "ctx", "vc", "k", "self", "conf", "ci", "t", "m", "cmp", "ctrl", "nc", "g", "this", "ec"], "avctx": ["aveca", "afcmp", "awcmp", "avecmp", "avloc", "evcmp", "AVca", " avloc", "awcontext", "afca", "avcontext", "afcmd", "avecontext", " avcmp", "avconn", "AVloc", "avectx", "AVctx", "awcmd", "AVcmd", "afconn", "evconn", "evctx", "AVcontext", "afloc", "avcmp", "AVconn", " avcontext", "avcmd", "afctx", "evcontext", "avca", "AVcmp", "awctx", "afcontext"], "mm_flags": ["ml_includes", "cmd_rules", "mmacplanes", "cmdamflags", "ml_flags", "mmamrules", "mm_alls", "mm_tones", "cmd_lists", "cmdamrules", "mm_groups", " mm_groups", "ml_planes", "mmpflags", "mm_rules", "mm_includes", "mmacflags", "ml_fields", "cmdamlists", "cmd_alls", "mmamflags", "cmdamalls", "mmacfields", "mmamlists", " mm_tones", "cmd_flags", "mmpgroups", "mmamalls", "mm_planes", "mm_lists", "mmptones", "mmacincludes", "mm_fields"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int au_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 24)\n\n        return 0;\n\n    if (p->buf[0] == '.' && p->buf[1] == 's' &&\n\n        p->buf[2] == 'n' && p->buf[3] == 'd')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 22601, "substitutes": {"p": ["pe", "pa", "jp", "current", "http", "j", "f", "pc", "b", "up", "per", "pp", "n", "a", "c", "ps", "lp", "o", "parser", "bp", "e", "r", "P", "l", "fp", "u", "pb", "pre", "prev", "vp", "post", "tp", "d", "progress", "cp", "api", "at", "data", "np", "k", "sp", "i", "m", "t", "ap", "exec", "g", "wp", "op", "comp", "it", "ip"]}}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615, "substitutes": {"opts": ["optTS", " optcs", "opats", " opats", "OPts", "OPcs", "otts", " optts", " opta", " opTS", "operTS", "operta", "optts", "optats", "opTS", "optments", " optats", " optt", "OPta", "opments", "optta", "opttes", " opcs", "opertt", " opt", "optes", " optments", "opt", "otments", "opcs", "ottes", "otta", " opments", "opta", "optcs", "optt", "opttt", "OPt", " optes", "operts"], "machine": ["mc", "element", "image", "interface", "template", "mobile", "company", "host", "name", "folder", "mage", "mode", "info", "app", "object", "computer", "controller", "vm", "media", "device", "money", "b", "Machine", "mac", "bug", "parent", "database", "base", "user", "handler", "engine", "message", "module", "service", "session", "manager", "boot", "window", "connection", "builder", "source", "oper", "rule", "plugin", "instance", "model", "slave", "creator", "editor", "m", "office", "server", "record", "file", "loader", "division", "node", "project"], "filename": ["full", "title", "il", "directory", "original", "location", "nil", "name", "word", "phrase", "wl", "SourceFile", "f", "folder", "length", "document", "bf", "b", "Filename", "dll", "sheet", "files", "buf", "database", "path", "metadata", "sequence", "fil", "download", "jpg", "message", "password", "fd", "fp", "l", "ema", "url", "kl", "mpeg", "ppa", "username", "fax", "txt", "fn", "sf", "kn", "file", "rl", "package", "binary", "prefix", "utf"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,\n\n                        int *duration)\n\n{\n\n    int64_t out_pts = AV_NOPTS_VALUE;\n\n    int removed_samples = 0;\n\n\n\n#ifdef DEBUG\n\n    ff_af_queue_log_state(afq);\n\n#endif\n\n\n\n    /* get output pts from the next frame or generated pts */\n\n    if (afq->frame_queue) {\n\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n\n    } else {\n\n        if (afq->next_pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->next_pts - afq->remaining_delay;\n\n    }\n\n    if (pts) {\n\n        if (out_pts != AV_NOPTS_VALUE)\n\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n\n        else\n\n            *pts = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n\n       for the output packet and leave all frames in the queue */\n\n    if (afq->remaining_delay >= nb_samples) {\n\n        removed_samples      += nb_samples;\n\n        afq->remaining_delay -= nb_samples;\n\n    }\n\n    /* remove frames from the queue until we have enough to cover the\n\n       requested number of samples or until the queue is empty */\n\n    while (removed_samples < nb_samples && afq->frame_queue) {\n\n        removed_samples += afq->frame_queue->duration;\n\n        delete_next_frame(afq);\n\n    }\n\n    afq->remaining_samples -= removed_samples;\n\n\n\n    /* if there are no frames left and we have room for more samples, use\n\n       any remaining delay samples */\n\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n\n        int add_samples = FFMIN(afq->remaining_samples,\n\n                                nb_samples - removed_samples);\n\n        removed_samples        += add_samples;\n\n        afq->remaining_samples -= add_samples;\n\n    }\n\n    if (removed_samples > nb_samples)\n\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n\n    if (duration)\n\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n\n}\n", "idx": 22637, "substitutes": {"afq": ["afiq", "ufq", "abqa", "phqu", "ajg", "affw", "afiqs", "awsq", "affq", "faqs", "aphsq", "awg", "rafque", "affqs", "alfcl", "awqa", "awqs", "efk", "avk", "afp", "cfqa", "affg", "afQ", " afck", "awqi", "rafw", "afg", "alfquest", "ufkg", "avw", "ufck", "avqs", "affsq", "efqa", "alfk", "abq", "aphq", "auqt", " afQ", "affck", "ajsq", "offqa", "auxq", "abz", "affcl", "afqu", "ajqs", "alfqa", "abqu", "alfqu", "afsq", "offq", "afqt", "rafq", "phq", "awck", "affcle", "afct", "aphquest", "avq", "ajqt", "aww", "afqs", "awqu", " afqa", "avz", "auct", "affz", "affct", "afck", "rafqs", "afk", "affqu", " afsq", "awk", "avqu", "ajqi", "cfg", " afk", "avqa", "avcl", "afqa", "afcl", "auk", " afquest", " afkg", " afg", "avck", "phz", " afqs", "afcle", "rafqa", "afiqt", "auq", "awq", "awquest", "auqs", "afiqu", "phqa", "alfck", "faw", "efcle", "cfq", "faque", "auxcle", "aucl", "ajquest", "auquest", "avQ", "affQ", "affp", "ajq", "efq", "avct", " afz", "cfk", "awqt", "afkg", "faq", "afz", "awcl", "affque", "awQ", "afquest", "affquest", "auxqa", "aup", "alfq", "affk", "ajk", "offque", "affkg", "offqs", "ajQ", "afw", "affqt", "alfQ", "affqi", "ajp", "aphk", "afque", "awz", "afqi", "alfg", "affqa", "faqa", "avqt", " afque", "auxk", "ufque"], "nb_samples": ["nb_tolutions", "nb_vickets", "nb7timesocks", "nb_sysamples", "nb_scamples", "nb_outsamples", "nb_samps", "nb_ssances", "nb_scummies", "nb_vipes", "nb_tippers", "nb_subs", "nb_insamps", "nb_sysipes", "nb25outsances", "nb_tipes", "nb_nourses", "nb_svamps", "nb25outsamples", "nb_nocks", "nb_ssources", "nb_compamples", "nb_namps", "nb_sances", "nb_vamples", "nb_nims", "nb_vourses", "nb_psances", "nb25spects", "nb_tsourses", "nb_insippers", "nb_solutions", "nb_tsamples", "nb_nalls", "nb_inspects", "nb_syspects", "nb_sysances", "nb_sessions", "nb_insimens", "nb_salls", "nb_tamples", "nb_compipes", "nb_tamps", "nb_seipes", "nb_compims", "nb25sipes", "nb_sickets", "nb_sims", "nb_timesims", "nb_seamples", "nb7socks", "nb_simens", "nb7timesims", "nb_timesamples", "nb_seubs", "nb_nances", "nb_insummies", "nb7samples", "nb_outsances", "nb_ssamples", "nb_sources", "nb7timesipes", "nb_ssipes", "nb_ssolutions", "nb_specalls", "nb25sances", "nb_namples", "nb25samples", "nb_eventsources", "nb_socks", "nb_svpects", "nb7sims", "nb_insamples", "nb_svimens", "nb7sipes", "nb7timesamples", "nb_eventsamples", "nb_timesipes", "nb_outsipes", "nb_spects", "nb_psources", "nb_psamples", "nb_specessions", "nb_sippers", "nb_eventsalls", "nb_sipes", "nb_tsickets", "nb_npects", "nb_specources", "nb25outspects", "nb_nickets", "nb_outspects", "nb_compocks", "nb_scippers", "nb_scamps", "nb_timesocks", "nb_tsipes", "nb_eventsessions", "nb_nessions", "nb_psamps", "nb_ssamps", "nb_nimens", "nb_sourses", "nb25outsipes", "nb_svamples", "nb_nipes", "nb_summies", "nb_specamples", "nb_tummies", "nb_ssubs", "nb_seolutions", "nb_tubs", "nb_nources"], "pts": ["iptn", "cols", "colsid", "ptsid", "aptds", "ctd", "lls", "iptns", "aptsum", "iptsid", "ctns", "prsid", "prs", "apts", "ctn", "cold", "prds", "ptsum", "txd", "lln", "roundd", "ptds", "xtss", "prd", "ptd", "aptd", "ptsk", "cts", "lld", "emptsk", "emptd", "rounds", "ipts", "prsum", "iptsets", "roundns", "xtd", "ptsets", "txss", "roundn", "txs", "ptn", "xts", "ptss", "ctsk", "prsk", "empts", "colsets", "iptss", "iptsum", "ptns", "iptds", "iptd", "prsets"], "duration": ["time", "pause", "delay", "timeout", "stage", "doc", "version", "seconds", "series", "runtime", "date", "depth", "distance", "type", "address", "length", "volume", "description", "document", "gap", "videos", "timer", "fee", "audio", "age", "lag", "range", "amount", "sequence", "rate", "later", "window", "span", "d", "sleep", "video", "memory", "direction", "Duration", "grade", "unit", "pad", "period", "term", "phase", "repeat", "frequency", "angle", "until"]}}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652, "substitutes": {"bs": ["lb", "rs", "src", "bb", "sync", "ib", "bid", "db", "bis", "ds", "ses", "bas", "stats", "fs", "b", "ss", "bh", "BS", "ps", "sb", "bps", "bos", "cs", "bi", "blocks", "fps", "pb", "bc", "bing", "gs", "os", "fb", "vs", "las", "ns", "ls", "rb", "ba", "js"], "base": ["Base", "cache", "p", "bb", "area", "core", "site", "local", "sync", "buffer", "name", "db", "bid", "type", "address", "proxy", "status", "f", "bas", "start", "family", "body", "b", "state", "back", "c", "parent", "sb", "build", "e", "root", "chain", "ase", "builder", "source", "based", "bc", "url", "ctx", "id", "work", "server", "client", "file", "sl", "binary", "prefix", "pool"], "base_id": ["baseacname", "baseamoffset", "file_ids", "file_size", "file_name", "file_id", "base_offset", "baseipid", "file_path", "file_offset", "baseipoffset", "file_num", "base_num", "base_path", "baseacsource", "baseacids", "baseipnum", "file_source", "baseamid", "base_ids", "baseamids", "base_size", "baseamnum", "base_source", "baseipids", "base_name", "baseacid"], "speed": ["Speed", "ace", "ism", "gc", "src", "fast", " speeds", "sync", "css", "type", "status", "mode", "length", "cost", "driver", "start", "ss", "sc", "si", "state", "stream", "scale", "sb", "sm", "engine", "rate", "peed", "service", "sk", "source", "size", "weight", "url", "ssl", "sp", "sf", "score", "slice", "sl", "spec", "sn"], "cb": ["cf", "cv", "bb", "cd", "cc", "core", "buff", "db", "f", "func", "pc", "bf", "cmd", "b", "CB", "cow", "fc", "callback", "cod", "c", "sb", "fun", "cs", "cgi", "pb", "function", "ob", "bc", "unc", "cp", "tc", "Callback", "ctx", "ci", "conf", "fb", "rb", "ec", "cor"], "opaque": ["opac", "paque", "compacity", "pac", "ipaque", "paco", "opacity", "opcode", "ipcode", "copacity", "ipacity", "opaco", "copaque", " opac", "operac", "pcode", "copaques", " opacity", " opaco", "operaco", " opaques", "ipac", "operacity", "operaque", " opcode", "pacity", "compaque", "opaques", "compaques"], "errp": ["erpa", "isepc", "errr", " errps", "ierpa", "erP", "errP", "oeps", "ierr", " errP", "oepa", "iseps", "errpc", "err", "isepa", "ierp", "errps", "errpa", "ierP", " errpc", "oep", " errr", "isep", "oepc", " errpa", "erp"], "s": ["ins", "S", "sq", "ks", "rs", "p", "sym", "css", "sync", "sa", "se", "http", "us", "ses", "ds", "f", "coll", "is", "b", "ss", "so", "si", "ts", "sc", "v", "state", "n", "c", "spec", "ps", "hs", "o", "sb", "e", "cs", "l", "r", "sk", "services", "sh", "sup", "es", "ops", "ssl", "gs", "su", "os", "sys", "m", "ns", "ls", "sg", "sl", "g", "sn", "js"], "co": ["mc", "po", " Co", "aco", "cf", "xc", "cache", "oe", "cu", "CO", "cross", "lc", "bo", "company", "cc", "que", "code", "loc", "ce", "mo", "go", "cus", "ro", "coll", "pc", "cur", "Co", "oc", "so", "oo", "con", "c", "ck", "ca", "o", "cs", "can", "cm", "oper", "ico", "bc", "rc", "cca", "ci", "ko", "coe"]}}
{"project": "FFmpeg", "commit_id": "2711cb28f46463760f0326d806fe5ef9551ade2c", "target": 1, "func": "static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){\n\n    RateControlContext *rcc= &s->rc_context;\n\n    AVCodecContext *a= s->avctx;\n\n    const int pict_type= rce->new_pict_type;\n\n    const double last_p_q    = rcc->last_qscale_for[P_TYPE];\n\n    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];\n\n\n\n    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))\n\n        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;\n\n    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)\n\n        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;\n\n\n\n\n    /* last qscale / qdiff stuff */\n\n    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){\n\n        double last_q= rcc->last_qscale_for[pict_type];\n\n        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;\n\n\n\n        if     (q > last_q + maxdiff) q= last_q + maxdiff;\n\n        else if(q < last_q - maxdiff) q= last_q - maxdiff;\n\n    }\n\n\n\n    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring\n\n\n\n    if(pict_type!=B_TYPE)\n\n        rcc->last_non_b_pict_type= pict_type;\n\n\n\n    return q;\n\n}", "idx": 22655, "substitutes": {"s": ["sets", "sq", "S", "south", "w", "p", "sa", "sg", "ses", "ds", "f", "b", "ts", "si", "sis", "ss", "sc", "n", "c", "spec", "sb", "o", "sed", "e", "cs", "r", "service", "session", "u", "qs", "services", "es", "d", "ssl", "i", "self", "m", "sys", "su", "os", "t", "sf", "sl", "ns", "sec", "g", "sv", "js"], "rce": ["rtces", "prces", "arfe", " rfe", "srce", "rcing", "rtcing", "prge", "arge", "srces", " rces", "rtge", " rcing", "arces", "prce", "rces", "srcing", "rtce", " rge", "rfe", "rge", "arce", "prfe", "srge"], "q": ["comment", "quant", "req", "qi", "sq", "ue", "x", "question", "p", "h", "iq", "sync", "quit", "qv", "force", "load", "ce", "val", "qu", "f", "length", "qq", "max", "quick", "um", "bug", "v", "dq", "change", "view", "c", "quad", "ck", "o", "error", "e", "y", "l", "qual", "query", "Q", "ch", "u", "qs", "sh", "value", "eq", "quest", "check", "d", "qa", "quality", "count", "aq", "k", "id", "i", "m", "t", "charge", "g", "z", "qt"], "rcc": [" rcca", "dcc", "Rpc", "frcc", "srco", "rrck", "lcc", "Ruc", "ecc", "srrc", "ruc", "rsuc", "dck", "arrc", "rcca", "arcc", " rpc", "bruc", "rscc", "ercd", "arpc", "rrc", "fruc", "rsck", "rrce", "srcca", "ecca", "rbc", "erce", "Rcc", " racc", "prrc", "sruc", "eacc", "Rcd", "prcca", "srbc", "errc", " rbc", "dcca", "srcc", "rbpc", "euc", "prcc", "erpc", "rco", "prpc", "arck", "ircca", "rcd", "duc", "erck", "rbcc", "rbce", "eruc", "pracc", "brcc", "prco", "ercc", "Rck", "ircc", "rsacc", "luc", "aruc", "racc", "rck", "dacc", "srpc", "rrcd", "frcca", "bracc", " ruc", "lck", "rrcc", "arco", "Rce", "irbc", "brcca", "lcca", "rpc", "fracc", "prck", "iruc", "rbuc", "pruc", "arcca"], "a": ["ha", "aa", "w", "pa", "p", "ea", "access", "area", "sa", "ac", "f", "ana", "an", "ma", "ai", "app", "na", "as", "ata", "ack", "wa", "mA", "b", "ba", "ae", "index", "c", "ga", "ar", "ia", "ca", "parser", "aka", "da", "alpha", "ab", "e", "y", "args", "ya", "sta", "va", "u", "fac", "A", "api", "i", "oa", "ua", "ad", "ao", "la", "another", "ora", "am", "aj", "cha", "this", "au", "ama", "aaa"]}}
{"project": "FFmpeg", "commit_id": "67400f6b6219892ab7a555fb61ef979c857692d7", "target": 0, "func": "static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n\n    int64_t pos = avio_tell(pb);\n\n\n\n    if (!track) { /* no media --> data handler */\n\n        hdlr      = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr     = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr     = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            hdlr_type = \"soun\";\n\n            descr     = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = \"sbtl\";\n\n            else                                      hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {\n\n            hdlr_type = \"hint\";\n\n            descr     = \"HintHandler\";\n\n        }\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"hdlr\");\n\n    avio_wb32(pb, 0); /* Version & flags */\n\n    avio_write(pb, hdlr, 4); /* handler */\n\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track || track->mode == MODE_MOV)\n\n        avio_w8(pb, strlen(descr)); /* pascal string */\n\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n\n    if (track && track->mode != MODE_MOV)\n\n        avio_w8(pb, 0); /* c string */\n\n    return update_size(pb, pos);\n\n}\n", "idx": 22662, "substitutes": {"pb": ["lb", "bm", "aph", "pd", "pa", "wb", "uf", "p", "jp", "prop", "platform", "db", "xb", "proc", "pg", "pm", "td", "pc", "bf", "b", "mp", "bh", "fc", "pp", "lab", "amp", "pro", "lp", "sb", "bps", "bp", "bos", "pt", "bj", "cb", "prot", "tmp", "fp", "hub", "py", "vp", "bsp", "pl", "tp", "bc", "PB", "api", "tc", "cp", "ctx", "ppa", "cpp", "gb", "pkg", "fb", "bs", "dp", "pub", "eb", "hp", "wp", "rb"], "track": ["match", "tt", "step", "tracking", "Track", "road", "cost", "cur", "ack", "roll", "hop", "transform", "metadata", "gro", "tr", "progress", "tracks", "dr", "form", "add", "note", "wp", "comment", "task", "trace", "stage", "event", "test", "row", "call", "trial", "check", "sound", "ACK", "ogg", "project", "gg", "round", "bb", "tab", "tm", "jump", "mode", "rr", "song", "token", "run", "tc", "seek", "t", "sort", "record", "skip", "sync", "route", "type", "coll", "gap", "report", "audio", "ck", "tick", "play", "session", "post", "tp", "port", "layer", "strip", "follow", "trans", "tag", "rack"], "hdlr": ["pdlr", "hdsr", "adhrel", "hdrf", "adhrl", "hidrn", "hidlc", "pdrn", "wdlr", "hidler", "hdlc", "hdrepl", "hdll", "hdrel", "vdrf", "mdlc", "hdrn", "wdler", "vdlr", "wdrl", "vdrepl", "hidrf", "vdrn", "hdler", "mdlr", "vdler", "pdrf", "adhlr", "hdrl", "vdrel", "hidll", "vdsr", "hidlr", "hidrel", "adhll", "mdrl", "hidrl", "wdsr", "mdll", "hidsr", "hidrepl", "adhlc", "vdrl", "adhrepl", "pdrl"], "descr": ["negrt", "structrin", "escerr", "defrs", "Descar", " descrt", "destrin", "decll", "destrr", "testr", "accerr", "desterr", "accrs", "descar", "escr", "declr", "descrr", "discr", "accr", "descriptionr", "descriptionry", "neglr", "escrt", "declres", "Descl", "ascr", "pririn", "descriptionrin", " desclr", "ascl", "declrin", "accrr", "descrt", "descrs", "testrs", "descriptionl", "testR", "descerr", "descry", " descerr", "deprs", " descl", "prir", " descrs", "prierr", "testar", "defl", "escR", "descres", "discar", "declrs", "escrin", "negrs", "defR", "descrin", "descR", "discrs", "descriptionR", "declR", " descR", "structrs", "prirr", "ascrin", "desclr", "defr", "structr", "destr", "declry", "descriptionrs", "escrr", "structerr", "deperr", "discR", "deprr", " descrr", " descrin", "ascry", "descriptionres", "descl", "depr", "esclr", "Descr", "DescR", "Descrs", "escrs", "negr", "escres"], "hdlr_type": ["hdrl_Type", "hdriter_TYPE", "hdrl_time", "hdlr_types", "hdrl_TYPE", "hdlrJtime", "hdlr__id", "hdLR_types", "hdler_id", "hdrl_ty", "hdlrJtype", "hdlrJname", "hdlr_time", "hdLR_block", "hdlr_style", "hdlr_ref", "hdlr_var", "hdrl_types", "hdlr_block", "hdlr_Type", "hdril_ty", "hdlr_ty", "hdlr_val", "hdriter_info", "hdrl_var", "hdlr_id", "hdlr_rel", "hdrl_style", "hdlr__Type", "hdlr__block", "hdril_ref", "hdlr__types", "hdriter_type", "hdrl_type", "hdriter_val", "hdlr_key", "hdLR_type", "hdler_types", "hdlr__name", "hdrl_rel", "hdlr_TYPE", "hdrl_name", "hdler_type", "hdlr_info", "hdLR_Type", "hdrl_key", "hdlrJkey", "hdlr_name", "hdril_types", "hdler_name", "hdlr__type", "hdril_type"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683, "substitutes": {}}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "substitutes": {"file": ["time", "write", "line", "class", "empty", "cache", "File", "call", "code", "use", "http", "buffer", "name", "folder", "db", "type", "le", "f", "cli", "config", "feed", "hide", "bug", "files", "resource", "uri", "future", "base", "path", "entry", "e", "handler", "l", "message", "place", "ile", "fp", "filename", "key", "letter", "function", "connection", "source", "ban", "output", "command", "port", "model", "data", "id", "work", "txt", "socket", "binary", "comment", "single"]}}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_probe(AVProbeData *p)\n\n{\n\n    const unsigned char *ptr = p->buf;\n\n    int i, v, num = 0;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3;  /* skip UTF-8 BOM */\n\n\n\n    while (*ptr == '\\r' || *ptr == '\\n')\n\n        ptr++;\n\n    for (i=0; i<2; i++) {\n\n        if ((num == i || num + 1 == i)\n\n            && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)\n\n            return AVPROBE_SCORE_MAX;\n\n        num = atoi(ptr);\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22702, "substitutes": {"p": ["gp", "pa", "jp", "prop", "h", "pair", "pointer", "proc", "f", "s", "pc", "b", "pp", "pi", "n", "a", "c", "pro", "ps", "lp", "o", "bp", "e", "r", "P", "l", "fp", "pre", "pb", "vp", "tp", "d", "np", "cp", "data", "sp", "m", "t", "ap", "g", "op"], "ptr": ["req", "br", "buffer", "offset", "proc", "f", "cur", "vr", "Ptr", "ref", "tr", "pos", "data", "mount", "uint", "dr", "pad", "eth", "addr", "ext", "adr", "trace", "pe", "src", "test", "num", "loc", "address", "fr", "uri", "index", "fd", "tip", "pl", "np", "peer", "plug", "shift", "transfer", "slice", "inst", "eger", "fe", "pend", "buff", "length", "pert", "temp", "cod", "pt", "prot", "fp", "fi", "tc", "ctx", "tty", "ci", "push", "tch", "alloc", "code", "pair", "pointer", "td", "start", "sth", "padding", "buf", "ctr", "str", "tp", "port", "attr"], "i": ["ti", "ii", "ui", "qi", "x", "I", "phi", "num", "di", "ri", "j", "f", "ai", "oi", "ni", "b", "si", "io", "ki", "pi", "n", "index", "uri", "c", "e", "y", "r", "l", "vi", "xi", "u", "fi", "d", "li", "iu", "api", "hi", "k", "m", "ci", "zi", "mi", "t", "multi", "gi", "z", "bi", "it", "ip"], "v": ["ii", "x", "w", "h", "num", "val", "j", "f", "s", "b", "si", "temp", "pi", "n", "c", "o", "e", "r", "l", "vi", "vt", "xi", "u", "vp", "value", "V", "d", "pos", "k", "vc", "m", "ci", "unit", "t", "vs", "sv"]}}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 22705, "substitutes": {"s": ["params", "states", "S", "south", "sq", "w", "rs", "p", "h", "less", "sym", "sync", "http", "ses", "ds", "f", "is", "fs", "ss", "ts", "b", "v", "state", "n", "c", "spec", "ps", "o", "sb", "e", "cs", "r", "service", "session", "u", "services", "sup", "es", "d", "side", "ssl", "gs", "i", "su", "m", "sys", "self", "t", "os", "conf", "bs", "server", "ns", "g", "sg", "js"], "dev": ["dc", "dm", "req", "debug", "def", "ev", "Dev", "test", "priv", "block", "di", "rev", "ds", "info", "app", "prom", "driver", "DEV", "cur", "develop", "device", "bug", "der", "gu", "v", "prov", "pro", "err", "mod", "error", "adv", "ver", "serial", "user", "engine", "conn", "ch", "hw", "kind", "dd", "dot", "d", "data", "sd", "conf", "development", "ad", "fin", "grad", "wd", "pub", "de", "rad", "serv"], "bus": ["loop", "Bus", "BUS", "cache", "bridge", "sync", "block", "us", "config", "is", "pass", "fs", "feed", "b", "bug", "sc", "device", "state", "board", "boot", "prev", "fi", "gen", "bc", "pos", "child", "data", "self", "os", "conf", "bs", "lib", "bi"], "qdev": ["wdevice", "cdevice", "wdebug", "cgu", "pdebug", "cdie", "dqdevice", "eqdev", "dqdiv", "cdev", "sqdev", "pdevice", "iqdiv", "eqdie", "wdev", " qdebug", "iqbus", "pdiv", " qdevice", "dprom", "qqdev", "iqdev", "qbus", "ddev", "qdebug", "qdie", "eqgu", "iqdevice", "dqdev", "qqgu", "qqdie", "sqprom", "eqdevice", "dqbus", "qprom", "sqdevice", "qdiv", "ddevice", "qgu", "qqdevice", "pbus", "pprom", "qdevice"], "next": ["first", "ner", "version", "step", "current", "link", "sync", "code", "bis", "proc", " Next", "config", "start", "then", "device", "second", "state", "seq", "future", "sub", "parent", "Next", "path", "sequence", "error", "flow", "result", "prev", "dot", "gen", "pos", "reply", "child", "data", "iterator", "follow", "done", "success", "server", "last", "sec", "new"], "pdev": ["cev", "lpdevice", "cdevice", "pppriv", " pdevice", "ppdev", "pDev", "lprad", "qdem", "pdem", "lpdem", "cdev", "pdevice", "qrad", " pev", "qDev", "prad", "ppev", " prad", "cpriv", "lpev", "qev", "pev", " ppriv", "lpdev", "ppdevice", " pDev", "lpDev", " pdem", "ppriv", "qdevice"], "pc": ["mc", "pd", "p", "lc", "cc", "cci", "pic", "ac", "pointer", "FC", "proc", "pm", "sc", "fc", "ct", "con", "amp", "c", "PC", "cs", "conn", "py", "pb", "arc", "pl", "bc", "cp", "soc", "tc", "rc", "vc", "sys", "client", "nc", "px", "cam", "ec"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 22709, "substitutes": {"job": ["Job", "image", "section", "queue", "block", "sea", "db", "j", "status", "address", "config", "object", "lock", "feed", "b", "base", "slot", "flow", "service", "manager", "run", "connection", "plugin", "worker", "child", "slave", "jobs", "work", "server", "lib", "project", "obs", "pool"], "speed": ["Speed", "powered", "settings", "time", "shape", "rank", "image", "capacity", "scroll", "step", "high", "mph", "plane", "strength", "status", "length", "cost", "pass", "si", "skill", "power", "scale", "slow", "sw", "error", "performance", "rate", "peed", "service", "limit", "sk", "source", "size", "gain", "port", "weight", "grade", "sp", "score", "slice", "level", "race", "spec", "stop"], "errp": ["iterc", " errlp", "rrc", "errc", "derc", "errlp", "rrp", "erP", "errP", "iterpe", "rrP", " errpe", "erc", " errP", "iterP", "rrlp", "iterp", "derp", " errc", "derlp", "errpe", "erpe", "erp", "derP"], "s": ["S", "sq", "rs", "p", "ls", "sync", "se", "ses", "ds", "f", "is", "fs", "si", "ss", "b", "v", "c", "sw", "ps", "o", "e", "cs", "l", "service", "session", "sh", "services", "es", "ops", "ssl", "gs", "m", "os", "sl", "ns", "spec", "g", "js"]}}
{"project": "FFmpeg", "commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "target": 1, "func": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n", "idx": 22718, "substitutes": {"avctx": ["afcmp", "AVcb", "avecmp", "AVwcs", "afwcs", "avcontext", "avecontext", "avconn", "avectx", "AVctx", "afconn", "avercb", "averctx", "AVcontext", "avcmp", "AVconn", "averwcs", "afctx", "avwcs", "afcb", "avercontext", "aveconn", "AVcmp", "avcb", "afcontext"], "ctx": ["dc", "cf", "crit", "cms", "sq", "gc", "cv", "xc", "alloc", "cu", "lc", "cc", "loc", "cli", "config", "cus", "sci", "coll", "Context", "anc", "cmd", "sc", "fc", "fw", "c", "utils", "buf", "ca", "cas", "cb", "cs", "tx", "conn", "aux", "fp", "hw", "auc", "cm", "conv", "wcs", "bc", "qa", "cp", "soc", "tc", "data", "obj", "cca", "vc", "ci", "pkg", "la", "ctrl", "cmp", "nc", "context", "cn", "cam", "coe", "voc", "comp"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 22741, "substitutes": {"path": ["time", "image", "text", "PATH", "p", "enc", "pointer", "name", "loc", "pass", "win", "dir", "ath", "temp", "uri", "c", "parent", "alias", "user", "conn", "root", "col", "filename", "key", "str", "port", "url", "Path", "ctx", "id", "txt", "file", "method", "node", "binary", "prefix", "ith"], "un": ["ul", "update", "mun", "une", "il", "release", "UN", "x", "package", "en", "block", "use", "num", "Un", "unknown", "_", "tun", "name", "loc", "an", "f", "func", "uc", "family", "unity", "ut", "other", "up", "con", "n", "bind", "sun", "fun", "build", "user", "old", "conn", "non", "ou", "common", "u", "run", "boot", "out", "connection", "rule", "uni", "off", "gen", "in", "unc", "url", "child", "uno", "unit", "null", "socket", "util", "unt", "file", "no", "node", "new", "put", "una"], "sock": ["opensaddr", "syvc", "oip", "issaddr", "issink", "oocket", "oocks", " svc", "hsocks", "bsocket", "oock", "servock", "slock", "sink", " Ssocket", "slocked", "pocked", "insock", "syocked", "pock", "Sib", "syocket", "Sock", "newocket", " socks", "hsock", "wink", "sick", "bock", "sesaddr", " sib", "wsock", "hsvc", "hseth", "insocket", "ssocket", "sesvc", "wick", "issick", "sesink", "wsvc", "insocks", "socks", "pocks", "sesock", "opensink", "wock", "Socks", "hsaddr", " Socks", "Ssocket", "slocket", "Socket", "seth", "hsocked", "hsink", " sip", "syock", "sip", "socket", "socked", "wsaddr", "slvc", "saddr", "sib", "bocket", "insib", "issock", "opensock", " socked", "pocket", "peth", "servsocket", "servocket", "waddr", "newsocket", "pip", "wsink", "svc", " Sock", " Socket", " seth", "newock", " socket", "opensick"]}}
{"project": "qemu", "commit_id": "d9e0dfa2462e32cc5c6c49401ad7bff36453f75c", "target": 0, "func": "void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    Error *local_err = NULL;\n\n\n\n    memset(&bs->bl, 0, sizeof(bs->bl));\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* Default alignment based on whether driver has byte interface */\n\n    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;\n\n\n\n    /* Take some limits from the children as a default */\n\n    if (bs->file) {\n\n        bdrv_refresh_limits(bs->file->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n", "idx": 22752, "substitutes": {"bs": ["ins", "cache", "css", "us", "ros", "utils", "base", "sb", "bits", "cs", "ab", "lbs", "pb", "bc", "bing", "gs", "org", "bn", "bel", "plugins", "fb", "vs", "mes", "biz", "lib", "ubs", "bytes", "lb", "iss", "bid", "db", "ras", "bit", "ds", "ses", "bas", "is", "bf", "b", "ts", "ps", "ils", "blocks", "bu", "lu", "BC", "web", "outs", "os", "abc", "facebook", "las", "obs", "tails", "ks", "bb", "bis", "banks", "git", "its", "ys", "bps", "boxes", "qs", "sys", "bi", "abi", "sels", "rs", "als", "block", "sync", "http", "blog", "as", "fs", "bl", "ss", "bh", "bt", "BS", "bin", "cb", "bos", "bes", "bot", "obj", "ns", "ls", "eb", "ms", "ba", "js"], "errp": ["odersp", "erpa", "oderpt", "errr", "ryp", "erps", "rysp", "ersp", " errps", "rorr", "oderp", "rypt", "errfp", "magicp", "erP", "errP", "erpt", "errorps", "errorP", "ryr", "erfp", " errP", "magicps", " errfp", "oderr", "err", "errpt", "rorpa", "errorfp", "errps", "errorp", "errpa", "errsp", "magicpa", "rorps", "erp", "rorp", "magicr"], "drv": ["rtV", "srv", "hrb", "drV", "DRc", " drp", "srV", "srf", "Drb", "drf", "rtvs", " drc", " drb", "hrp", "drp", "DRf", "drb", "hrv", "Drp", "hrc", "rtv", " drf", "drc", "Drf", "Drv", "hrf", "drvs", "DRp", "Drvs", "DRv", "DrV", "srvs", "rtf"], "local_err": ["localayvar", "localaylr", "global_str", "localayerror", "local__Er", "foreign_finder", "remote_msg", "local__err", "locallyer", "localxerr", " local_Er", "localxerror", "local_var", "foreign_err", "localacer", "remote_error", "localayerr", "local_er", "local_ctr", "locallyerr", "localxvar", "global_err", "local__er", "local_late", "global_mr", "local_error", "local_Er", "local_mr", "localacEr", "foreign_ctr", "remote_err", " local_op", "global_error", "global_er", "local_lr", " local_error", "locallyop", "localacerr", "locallyerror", "local_msg", "local_op", "local__str", "remote_er", "remote_var", "localxlr", "remote_lr", " local_er", "local_str", "foreign_late", "local_finder"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n                Error *local_err = NULL;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size,\n\n                                    &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22759, "substitutes": {"bs": ["bm", "ins", "abi", "ks", "rs", "iss", "src", "bb", "aws", "sync", "css", "core", "us", "http", "db", "bit", "bis", "ds", "ses", "account", "bas", "fs", "is", "bl", "b", "ss", "ts", "ros", "bh", "its", "bin", "BS", "buf", "ps", "base", "sb", "bits", "cb", "bos", "cs", "ab", "blocks", "bes", "lbs", "pb", "qs", "hub", "bytes", "outs", "bc", "bot", "url", "gs", "os", "gb", "fn", "fb", "vs", "ubs", "ns", "ls", "ms", "obs", "bi", "js"], "res": ["req", "gr", "def", "mr", "resp", "rs", "css", "Res", "rss", "val", "ras", "rev", "results", "response", "rx", "rows", "fs", "ress", "pers", "rh", "RES", "err", "reg", "ps", "cs", "r", "args", "result", "vals", "rem", "details", "rez", "changes", "reply", "rc", "re", "resolution", "nos", "des", "os", "sys", "conf", "rep", "rus", "cons", "spec", "pres", "js"], "fix": ["comment", "fixes", "update", "delay", "prefix", "def", "x", "ix", "cache", "reset", "test", "call", "code", "force", "type", "status", "pack", "address", "config", "valid", "apply", "ack", "init", "bug", "next", "future", "error", "patch", "clear", "commit", "pre", "prev", " prefix", "final", "edit", " Fix", "post", "check", "Fix", "diff", "re", "missing", "hack", "conf", "replace", "FIX", "make", "correct", "add", "method", "op", "get"], "rebuild": ["refuild", "precover", "reuild", "recover", "refupdate", "reluild", "rbuild", "relbuild", "ruild", "rupdate", "reshcover", "refbuild", "preuild", "prebuild", "relupdate", "rerun", "rcover", "rrun", "preupdate", "reupdate", "reshbuild", "reshuild", "relrun", "reshupdate", "refrun"], "refcount_table": ["refcountstree", "refsize_table", "refcount_tree", "refsizestree", "refcountingTABLE", "refcount2table", "refcount_buffer", "refsize_type", "refcount_type", "refount_buffer", "refcount2tree", "refsizestable", "refsizestype", "refcount_TABLE", "refcountingarray", "refcount2file", "refount_tab", "refcountstype", "refsize_TABLE", "refcountingtab", "refcount2type", "refcountsfile", "refount_array", "refcountingbuffer", "refcountingfile", "refsizeingfile", "refcount_tab", "refsize_file", "refsizeingTABLE", "refsize_tree", "refount_table", "refsizesfile", "refcount_file", "refcountingtable", "refcountstable", "refcount_array", "refsizeingarray", "refsize_array", "refsizeingtable"], "nb_clusters": ["nb_blashes", "nb_spluster", "nb_sluster", "nb_zaxies", "nb_CLusters", "nb_lusters", "nb_clresses", "nb_lodes", "nb_bluster", "nb_sclashes", "nb_locations", "nb_CLients", "nb_lashes", "nb_zusters", "nb_luster", "nb_CLresses", "nb_clodes", "nb_lients", "nb_chients", "nb_scluster", "nb_CLaxies", "nb_alluster", "nb_CLodes", "nb_allocations", "nb_zuster", "nb_slocations", "nb_blodes", "nb_chusters", "nb_allresses", "nb_CLocations", "nb_sclusters", "nb_clients", "nb_chuster", "nb_chashes", "nb_CLashes", "nb_clashes", "nb_sclocations", "nb_splusters", "nb_slusters", "nb_CLuster", "nb_blients", "nb_splappers", "nb_cluster", "nb_clappers", "nb_clocations", "nb_splaxies", "nb_slresses", "nb_claxies", "nb_blusters", "nb_CLappers", "nb_allusters", "nb_zappers"], "s": ["ins", "secondary", "p", "us", "se", "f", "si", "sb", "cs", "details", "gs", "spec", "sv", "iss", "src", "aws", "sa", "ses", "ds", "status", "xs", "is", "b", "sc", "ts", "ps", "hs", "e", "services", "parts", "sup", "os", "rates", "states", "S", "sym", "site", "bis", "stat", "stats", "comm", "its", "state", "c", "r", "service", "qs", "es", "scope", "sp", "m", "sys", "server", "sl", "g", "settings", "sets", "sq", "rs", "sync", "http", "ss", "sie", "o", "session", "d", "ssl", "su", "ns", "ls", "js"], "i": ["ti", "ii", "ui", "abi", "qi", "iter", "x", "ix", "I", "p", "eni", "phi", "ib", "di", "j", "info", "f", "ai", "ini", "ie", "ni", "oi", "start", "is", "ski", "si", "b", "io", "v", "pi", "n", "index", "uri", "c", "base", "o", "e", "y", "l", "xi", "u", "fi", "li", "in", "iu", "mini", "d", "count", "id", "zi", "ci", "mi", "m", "multi", "t", "slice", "ori", "gi", "mu", "bi", "it", "ip"], "size": ["time", "capacity", "shape", "ix", "cache", "si", "Size", "content", "SIZE", "sum", "storage", "key", "mini", "data", "count", "form", "ext", "desc", "part", "cl", "empty", "en", "area", "name", "loc", "address", "len", "e", "page", "fat", "ize", "weight", "sized", "shift", "slice", "set", "el", "length", "ice", "temp", "c", "err", "error", "small", "big", "sp", "unit", "g", "new", "zip", "full", "code", "complete", "max", "security", "body", "scale", "iz", "sec"], "ret": ["req", "match", "def", "lit", "rt", "info", "det", "valid", "cur", "rot", "feat", "fun", "nt", "ref", "opt", "bad", "count", "ext", "get", "part", "iter", "rets", "en", "cat", "num", "bit", "val", "fail", "status", "len", "gt", "back", "flat", "rc", "flag", "re", "id", "alt", "arg", "pet", "let", "att", "rev", "mt", "err", "error", "usr", "after", "big", "success", "rep", "resp", "fit", "code", "ft", "sr", "ut", "RET", "reg", "conn", "result", "wrap", "str", "reply", "obj", "job", "Ret", "rl", "sec"], "offset": ["ui", "abi", "timeout", "ace", "inet", "image", "part", "origin", "secondary", "reset", "p", "location", "pointer", "reference", "loc", "address", "length", "Offset", "start", "gap", "fee", "align", "index", "padding", "position", "base", "o", "range", "slot", "error", "alias", "alpha", "adjust", "entry", "style", "tile", "fp", "iso", "ref", "point", "end", "off", "post", "stop", "initial", "split", "pos", "api", "missing", "url", "shift", "id", "slice", "addr", "absolute", "set", "prefix", "ip"], "cluster": ["plip", "clancer", "blancer", "plust", "clanch", "bloser", "bluster", "clard", "clust", "spluster", "blip", "plard", "blanch", "plancer", "ploser", " clust", "pluster", "slust", "splust", " clip", "sloser", " clancer", "sluster", "closer", "blause", "blard", "blust", "slanch", "planch", "plause", " clause", " clard", "slancer", "clip", "splanch", "clause", "splancer"], "corruptions": ["corintisions", "corintitions", "corruption", "corriptitions", "Corruptitions", "corintion", "Corruptisions", "corription", "Corruptions", "corintions", "corruptitions", "corriptions", "corriptisions", "Corruption", "corruptisions"], "new_nb_clusters": ["new_nb_plicas", "new_nb_clos", "new_nb_clients", "new_nb_plores", "new_nb_blones", "new_nb_cicas", "new_nb_chusters", "new_nb_clones", "new_nb_plusters", "new_nb_custer", "new_nb_labusters", "new_nb_Clores", "new_nb_CLicas", "new_nb_CLuster", "new_nb_scones", "new_nb_chos", "new_nb_Clones", "new_nb_labos", "new_nb_blicas", "new_nb_Clicas", "new_nb_blusters", "new_nb_CLores", "new_nb_blients", "new_nb_cores", "new_nb_Clients", "new_nb_cluster", "new_nb_chuster", "new_nb_CLusters", "new_nb_Clusters", "new_nb_clores", "new_nb_Cluster", "new_nb_custers", "new_nb_clords", "new_nb_labords", "new_nb_labuster", "new_nb_scuster", "new_nb_chords", "new_nb_pluster", "new_nb_lusters", "new_nb_luster", "new_nb_lores", "new_nb_scients", "new_nb_scusters", "new_nb_clicas", "new_nb_Clords", "new_nb_licas", "new_nb_Clos", "new_nb_bluster", "new_nb_blores"], "local_err": ["local_arr", "remote_err", "raw_err", "remote_error", "localamerror", "localamerr", "remote_er", "external_err", "localingarr", "raw_exc", "external_errors", "raw_data", "remote_result", "local_data", "external_er", "local7err", "local_er", "external7size", "external7errors", "localingerr", "localingdata", "local7size", "localingsize", "local7er", "localingerrors", "external7err", "localamresult", "external7er", "external_size", "raw_arr", "local_exc", "localinger", "local_result", "local_error", "local7errors", "local_errors", "local_size", "localingexc", "localamer"], "check_errors": ["check__err", "work_params", "checkallerrors", "work__comments", "checkallerr", "checkallcomments", "check_comments", "checkerparams", "work_errors", "check__errors", "checkererr", "check__comments", "work_comments", "work__err", "check__params", "work__errors", "check_err", "work__params", "checkercomments", "checkallparams", "checkererrors", "work_err", "check_params"], "corruptions_fixed": ["corruptIONS_fix", "corruptions_fix", "corruptIONS_failed", "corruptIONS_diff", "corruptIONS_fixed", "corruptions_failed", "corruptions_diff"]}}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801, "substitutes": {"opts": ["opps", "hopta", "OPns", "OPters", " oppt", " optts", "Opts", "optrs", "operments", "OPrs", "copts", "otTs", "optters", "OPta", "opments", "otters", " opted", "opt", "opted", "optTs", "optcs", "otsts", "operrs", "OPments", "optpt", "hopts", "omts", "OPts", "optuts", "OPsts", "copats", "optta", "omted", "OPuts", "otcs", "OPpt", "experns", "ott", "opsts", "OPt", "opert", "operts", "opats", " opats", " opps", "optps", " oprs", "hopted", "oppt", "Opted", "optted", "optats", "otuts", "optns", " optt", "oprs", " optns", "experted", " opt", "otments", "opcs", "experts", "opns", "opters", "optsts", "OPats", "opTs", "opercs", " opsts", "OPTs", "opersts", "otts", "copters", "copcs", "omt", "optts", "Opters", "Opta", "optments", "OPted", "omments", "expert", "coprs", "copt", " opments", " optters", "opta", "oputs", "optt", "Oputs", "hoputs", "OPps"], "block_default_type": ["block_block_t", "block_block_type", "block_block_class", "block_default_types", "block_default_class", "block_default_t", "block_block_types"], "buf": ["Buffer", "desc", "br", "runner", "box", "text", "cv", "uf", "src", "alloc", "label", "queue", "block", "img", "buff", "buffer", "proc", "config", "func", "uc", "cmd", "b", "callback", "seq", "cb", "path", "cas", "bus", "vec", "fd", "aux", "fp", "tmp", "filename", "ref", "output", "conv", "bag", "ff", "bc", "rc", "data", "input", "ctx", "pkg", "fb", "binary", "rb", "pool"], "file": ["zip", "time", "ul", "il", "image", "class", "cache", "File", "http", "name", "f", "book", "dir", "files", "uri", "mail", "where", "path", "base", "place", "ile", "fp", "filename", "letter", "connection", "show", "source", "port", "model", "url", "data", "input", "unit", "la", "socket", "resource", "pool"], "serial": ["zip", "phone", "version", "series", "template", "mobile", "local", "http", "rol", "unknown", "mode", "proc", "volume", "xxx", "pass", "io", "device", "roll", "spec", "dev", "Serial", "alias", "select", "iso", "sel", "model", "mount", "usb", "random", "ser", "socket", "tel", "custom", "tag", "package", "resource"], "mediastr": ["mediestril", "datestrs", "mediestr", "mediastril", "mediendril", "datastril", "mediastrs", "mediendrs", "datestrl", "mediostrs", "mediestrl", "datastrs", "mediostril", "mediostr", "mediendr", "mediendrl", "datestril", "mediastrl", "datastrl", "datastr", "datestr", "mediestrs", "mediostrl"], "type": ["typ", "time", "part", "ty", "create", "shape", "x", "class", "pe", "p", "options", "test", "call", "block", "code", "unknown", "name", "info", "length", "like", "config", "TYPE", "object", "types", "ype", "other", "lock", "state", "parent", "position", "day", "style", "y", "message", "col", "py", "pre", "key", "span", "value", "size", "weight", "model", "split", "diff", "data", "Type", "count", "month", "id", "i", "unit", "ping", "t", "number", "sort", "total", "level", "tag", "no", "all", "comment", "var"], "media": ["Media", "image", "medium", "template", "http", "import", "mode", "volume", "document", "io", "device", "audio", "material", "uri", "medi", "control", "library", "spec", "metadata", "storage", "message", "module", "manager", "meta", "format", "source", "port", "model", "memory", "data", "reader", "m", "record", "package", "resource"], "bus_id": ["unit_sid", "unitpsid", " bus_name", "bus_version", "bus_bid", "bus_sid", "buspsid", "unitpversion", " bus_ids", "bus_ids", "unit_version", "buspversion", "bus_name", "buspid", "unitpid", " bus_type", "buspbid", "unitpbid", "unit_bid", "bus_type"], "unit_id": [" unit_ids", "unitactype", " unit_name", "unitacid", "unitacversion", " unit_type", "unit_type", "unit_version", "device_name", "unit_ids", "device_id", "device_version", "device_type", "unitacname", "unit_name"], "cyls": ["rycs", "cycs", " cylf", " crols", "ryls", "zyls", "zylf", " crls", "cylf", "corles", "zyps", " crles", "zycs", " cycs", "ryps", "cyrs", "cyps", "cyles", "corols", " cyols", " cyrs", "cyols", " cyps", "rylf", " crrs", "corls", "corrs", " cyles"], "heads": ["sections", "headers", "tails", "flags", "cases", "reads", "loads", "head", "sticks", "shots", "pages", "offs", "rows", "links", "members", "files", "mods", "opens", "checks", "views", "locks", "hook", "blocks", "HEAD", "modules", "times", "outs", "tests", "tops", "docs", "jobs", "frames", "maps", "workers", "plugins", "shows", "obs"], "secs": [" secseconds", "ribo", "ribn", "seqs", " seco", "suppp", "suppseconds", "seqo", " secn", "seqseconds", "supps", "ribs", "seco", "seqls", "secls", " secp", "seqp", " secls", "secseconds", "secp", "secn", "ribls", "seqn", "suppn"], "translation": ["settings", "abi", "title", "image", "flags", "version", "rating", "template", "options", "lit", "Translation", "acl", "local", "http", "offset", "name", "loc", "mo", "info", "proxy", "language", "description", "bl", "protection", "flash", "rot", "utils", "base", "alias", "message", "lang", "port", "misc", "pos", "conf", "la", "trans", "resource", "comment"], "drv": ["srw", "Drf", "drw", "srv", "Drv", "srf", "Drw", " drf", " drc", "src", "drf", " drw", "Drc", "drc"], "max_devs": ["max_defs", "max_devi", "max_devicep", "max_defid", "max_devid", "max_devicei", "max_deviceid", "max_evi", "max_evs", "max_defi", "max_evid", "max_evp", "max_defp", "max_devp", "max_devices"], "index": ["shape", "image", "match", "x", "version", "axis", "cache", "block", "num", "depth", "name", "loc", "info", "length", "proxy", "config", "head", "dir", "height", "position", "parent", "ind", "limit", "key", "connection", "weight", "target", "diff", "pos", "input", "unit", "id", "number", "Index", "level", "slice", "inc", "prefix"], "on_read_error": ["on_read_errors", "on_write_errors", "on_read_ror", "on_read_progress", "on_write_ror", "on_write_progress"], "on_write_error": ["on_write_err", "on_writeouterr", "on_write_change", "on_writing_error", "on_write_result", "on_writing_result", "on_writing_err", "on_writeouterror", "on_writeoutchange", "on_writeoutresult", "on_writing_change"], "devaddr": ["evaddress", "devaddress", "pubaddress", "devicesid", "devAddress", "pubsid", "pubaddr", "deviceAddress", "devsid", "deviceaddress", "evAddress", "evsid", "pubAddress", "deviceaddr", "evaddr"], "dinfo": [" dInfo", " dapi", "dlconf", "dlapi", "dlInfo", "dcconf", "dInfo", " dconf", "dcInfo", "dcapi", "dconf", "dcinfo", "dapi", "dlinfo"], "io_limits": ["IO_limit", "io_maps", "IO_limits", "IO_maps", "IO_limited", "io_limit", "io_limited"], "copy_on_read": ["copy_On_write", "copy_on__read", "copy_on_READ", "copy_on__READ", "copy_onCwrite", "copy_onCload", "copy_off_READ", "copy_off_write", "copy_on_access", "copy_onCread", "copy_on_load", "copy_on__reader", "copy_On_access", "copy_onCaccess", "copy_on__write", "copy_On_read", "copy_On_load", "copy_on_write", "copy_on_reader", "copy_off_reader", "copy_off_read"], "ret": [" resp", "def", "res", "resp", "rets", "class", "rs", "lit", "mem", "num", "rt", "val", "rev", "RET", "rot", "nt", "result", "ref", "lang", "model", " reply", "rc", "re", "reply", "Ret"], "error": ["attribute", "row", "call", "block", "status", "rage", "option", "info", "ack", "bug", "parser", "err", "Error", "query", "result", "danger", "ERROR", "op", "command", "layer", "progress", "success", "server", "slice", "ror", "resource", "comment"]}}
{"project": "qemu", "commit_id": "0b2c1beea4358e40d1049b8ee019408ce96b37ce", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815, "substitutes": {"qdict": ["qdatabase", "qttable", "qdb", "qdef", " qdef", "qtdict", "qudatabase", " qdb", "quobject", "qconfig", "reqdict", "qtobject", "dqdatabase", "reqdb", "qtdatabase", "dqdict", "dqtable", "sqconfig", "reqdef", "qtable", " qconfig", "sqdict", "reqconfig", "qudict", "qobject", "dqobject", "sqdef", "qutable", "sqdb"], "params": ["settings", "resources", "shape", "part", "ks", "ins", "sq", "req", "rs", "p", "options", "sym", "name", "ras", "par", "names", "phrase", "ses", "config", "properties", "words", "types", "start", "members", "kw", "seq", "ps", "search", "cs", "keys", "args", "ams", "query", "py", "qs", "parts", "vals", "es", "ops", "json", "ips", "attr", "ssl", "gs", "ctx", "k", "param", "sys", "m", "objects", "plugins", "array", "conf", "slice", "sid", "ls", "spec", "ms", "prefix"], "implied_key": ["implicit_name", "implicit_type", "impliedsname", "impliedOnext", "implicit_keys", "impliedenvalue", "implied__value", "impliedOkey", "implicatedPkey", "implicated_type", "impliedPvalue", "implied_name", "imploded_code", "implicit_key", "imploded_key", "implied_ver", "implied_value", "impliedOname", "implied_code", "implied_type", "impliedskey", "impliedPkeys", "impliedPkey", "implicated_key", "implied_message", "implicated_Key", "implied__code", "implixed_value", "impliedJver", "implied__name", "impliedOver", "implicit__type", "impliedPKey", "impliedPrule", "impliedsfield", "implied__key", "imploded_name", "implicatedPvalue", "implicit__name", "implied_Key", "implicit_rule", "implied__Key", "implicated_next", "implicit_field", "implied_keys", "impliedJname", "implixed_key", "implicatedPtype", "implicit_ver", "implicatedPKey", "implixed_message", "implicated_name", "implicit__field", "implicated_value", "implicated_ver", "implied__type", "impliedenkey", "impliedJkey", "impliedenmessage", "impliedJnext", "implied_field", "implied_rule", "implied__field", "implied_next", "implicit__key", "impliedPtype", "impliedPver", "impliedstype", "imploded_Key"], "errp": ["armp", "errr", "rrc", "krp", "erps", "errc", "errpr", "armr", "ierpa", "errpy", "errfp", "rrp", "erP", "yrp", "ercp", "yrpy", "errP", "erc", "errcp", "erfp", " errP", "krpr", " errfp", "errg", "dersp", "err", "rrcp", "krg", "interpa", "interP", "Erp", "rrr", "erpy", "rrpy", "derp", "interp", "iersp", "ierp", "ErP", "errps", "asterps", "yrc", "errpa", "rrps", "ierP", "errsp", "derpa", "armg", "astercp", "asterr", "Err", "intersp", " errr", "yrr", "krr", "Erfp", "erp", "derP", "erg", "asterp", "armpr", "erpr"], "key": ["req", "time", "match", "close", "cache", "p", "se", "date", "f", "q", "order", "secret", "kw", "seq", "seed", "base", "sum", "any", "min", "pri", "KEY", "sk", "source", "data", "hash", "k", "i", "no", "part", "pe", "row", "call", "core", "sy", "name", "ce", "j", "go", "fee", "n", "index", "parent", "e", "keys", "y", "args", "query", "size", "rule", "id", "sign", "param", "ip", "w", "length", "ie", "by", "ak", "ry", "v", "change", "temp", "state", "c", "error", "root", "select", "service", "kind", "value", "op", "ace", "full", "ty", "x", "sync", "block", "code", "link", "pair", "par", "type", "phrase", "max", "start", "mac", "Key", "search", "ver", "str", "self", "field", "list", "sec"], "key_end": ["value_offset", "key0offset", "key0start", "value_ended", "textCended", "key_n", "keyjen", "keyjsize", "key_size", "keyPended", "key_ended", "text_ended", "keyPoffset", "key__end", "value0ended", "keyClength", "key__start", "value0start", "keyjstart", "key0ended", "keyPstart", "key_END", "value_end", "keyCended", "key_add", "key__en", " key_offset", "value0end", "key0end", "key_offset", "keyjend", " key_en", " key_size", "text_end", "textClength", "keyCend", " key_END", "key__size", " key_n", " key_start", "keyPend", "key_length", "text_length", "textCend", "value_start", "value0offset", "key_en", "key_start", " key_add"], "s": ["ins", "res", "secondary", "p", "f", "words", "si", "sb", "cs", "sk", "u", "source", "ops", "pos", "side", "gs", "i", "k", "spec", "bytes", "sy", "ds", "ses", "j", "xs", "is", "b", "ts", "n", "ps", "hs", "e", "keys", "y", "args", "services", "parts", "size", "sup", "os", "slice", "set", "states", "S", "ks", "w", "sym", "h", "sec", "v", "c", "r", "l", "service", "es", "scope", "sp", "m", "sys", "t", "server", "sl", "g", "new", "single", "settings", "sets", "sq", "rs", "sync", "sr", "start", "fs", "ss", "sie", "send", "o", "search", "session", "str", "uns", "d", "ssl", "su", "sing", "sid", "ns", "ls", "sg", "js"], "len": ["line", "lc", "lit", "lim", "elt", "le", "low", "f", "valid", "seq", "base", "fun", "min", "nt", "lang", "ref", "pre", "pos", "data", "lif", "count", "sil", "la", "lib", "spec", "ld", "all", "part", "ler", "en", "Len", "lf", "num", "name", "fail", "loc", "j", "repl", "n", "vec", "fl", "ind", "args", "non", "fat", "lu", "end", "size", "ll", "alt", "fin", "dy", "lin", "label", "vert", "el", "rev", "ln", "length", "ie", "net", "rel", "v", "err", "l", "limit", "li", "url", "sp", "lon", "sl", "full", "lt", "body", "bl", "lock", "conn", "span", "str", "syn", "split", "L", "field", "fn", "ren", "ls", "js"], "key_in_cur": ["key_in_rc", "key_int_cur", "key_in_ver", "key_n_cur", "key_int_rc", "key_out_cur", "key_in_per", "key_in_var", "key_out_car", "key_out_valid", "key_n_cache", "key_in_valid", "key_out_sur", "key_in_ur", "key_n_ur", "key_in_ser", "key_out_per", "key_in_cache", "key_in_sur", "key_n_ser", "key_in_car", "key_out_ver", "key_int_var", "key_out_ser"], "cur": ["desc", "req", "cf", "ur", "sq", "oe", "src", "pr", "row", "enc", "current", "sync", "Cur", "cat", "co", "loc", "rev", "dict", "ocr", "coll", "cr", "sr", "uc", "sc", "tra", "rel", "der", "per", "con", "rest", "c", "buf", "sth", "new", "cb", "serv", "ver", "r", "conn", "pri", "col", "ch", "result", "prev", "cal", "ctr", "sel", "car", "sur", "tr", "attr", "rc", "child", "keep", "dr", "ser", "client", "sl", "spec", "rec", "var"], "ret": [" resp", "req", "att", "iter", "res", "rets", " sr", "lit", "en", "Len", "num", "el", " fun", "rev", "j", "f", "rt", "sr", " lib", "lt", "pass", "repl", "RET", "rel", "seq", "n", " repl", "fun", "err", "reg", "min", "r", "nt", "result", "pre", "ref", "opt", "str", " lang", " rel", "ll", " alt", " reply", "reply", " fin", "re", "arr", "obj", "alt", "fin", "arg", "ren", "success", "Ret", "rl", "sec", "ext"], "next": ["first", "z", "br", "ner", "sq", "doc", "sen", "eni", "en", "current", "enc", "p", "code", "bis", "rev", "more", "proc", "j", "now", "config", "head", "valid", "start", "then", "sche", "state", "c", "future", "err", "dev", "Next", "again", "ver", "min", "conn", "args", "tmp", "result", "session", "prev", "end", "value", "dot", "gen", "ne", "li", "data", "obj", "child", "big", "primary", "conf", "client", "last", "open", "skip", "sec", "new"], "val": ["def", "VAL", "eval", "cache", "prop", "el", "name", "rev", "valid", "v", "rel", "seq", "base", "pre", "sel", "vals", "value", "str", "li", "arr", "arg", "Val", "lib", "sl", "ls", "var"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)\n\n{\n\n    int16_t input[MDCT_SAMPLES];\n\n    int32_t output[AC3_MAX_COEFS];\n\n    float input1[MDCT_SAMPLES];\n\n    float output1[AC3_MAX_COEFS];\n\n    float s, a, err, e, emax;\n\n    int i, k, n;\n\n\n\n    for (i = 0; i < MDCT_SAMPLES; i++) {\n\n        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;\n\n        input1[i] = input[i];\n\n    }\n\n\n\n    mdct512(mdct, output, input);\n\n\n\n    /* do it by hand */\n\n    for (k = 0; k < AC3_MAX_COEFS; k++) {\n\n        s = 0;\n\n        for (n = 0; n < MDCT_SAMPLES; n++) {\n\n            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));\n\n            s += input1[n] * cos(a);\n\n        }\n\n        output1[k] = -2 * s / MDCT_SAMPLES;\n\n    }\n\n\n\n    err  = 0;\n\n    emax = 0;\n\n    for (i = 0; i < AC3_MAX_COEFS; i++) {\n\n        av_log(NULL, AV_LOG_DEBUG, \"%3d: %7d %7.0f\\n\", i, output[i], output1[i]);\n\n        e = output[i] - output1[i];\n\n        if (e > emax)\n\n            emax = e;\n\n        err += e * e;\n\n    }\n\n    av_log(NULL, AV_LOG_DEBUG, \"err2=%f emax=%f\\n\", err / AC3_MAX_COEFS, emax);\n\n}\n", "idx": 22826, "substitutes": {"mdct": ["cmdct", "magect", "MDct", "mdc", "mdCT", "magcf", " mdcf", "mdcf", "MDCT", "amdCT", "mdconfig", " mdconfig", "magct", "cmdCT", "amdct", "amdcf", " mdect", "amdc", "cmdc", "cmdect", "magconfig", "MDcf", "cmdconfig", "MDc", "mdect", "cmdcf"], "lfg": ["lvgs", "dlG", "afG", "dlg", "dlcfg", "afgc", "afcfg", "dfG", "lvcfg", "olfge", "dfgc", "afgs", "olfgc", "afg", "olfG", "dlgs", "dfge", "olfg", "lfge", "lfcfg", "lvG", "lfgs", "afge", "lfG", "dfg", "lfgc", "lvg"], "input": ["first", "support", "condition", "update", "Output", "image", "interface", "PUT", "text", "version", "inf", "current", "answer", "buffer", "import", "address", "option", "config", "response", "document", "request", "feed", "init", "accept", "temp", "state", "view", "audio", "stream", "index", "argument", "parent", "control", "table", "submit", "error", "Input", "select", "batch", "out", "source", "value", "in", "initial", "model", "target", "instance", "child", "data", "form", "array", "list", "include", "method", "context", "op", "inner"], "output": ["generation", "write", "Output", "update", "image", "console", "PUT", "version", "text", "current", "queue", "forward", "production", "reference", "complete", "option", "address", "response", "config", "wave", "object", "fore", "document", "other", "second", "index", "information", "control", "position", "o", "hidden", "flow", "result", "out", "outer", "source", "value", "summary", "target", "model", "memory", "expression", "environment", "four", "display", "unit", "number", "network", "context", "prefix", "put", "operation"], "input1": ["contextone", " inputone", "Inputone", "context1", "input2", "inputone", "Input1", "request1", "context2", "request2", " input2", "requestone", "output2", "Input2", "outputone"], "output1": ["responseone", "image1", " output100", "outputOne", "imageone", "input2", "OutputOne", "inputOne", "response1", "Output2", " output2", "output100", "Output1", "resource2", "image100", "resource1", " outputone", "output2", "resource100", " outputOne", "responseOne", "image2", "imageOne", "resourceOne", "outputone"], "s": ["z", "S", "sq", "south", "ks", "rs", "w", "p", "h", "sync", "sa", "se", "ds", "j", "f", "as", "is", "si", "ss", "b", "v", "c", "ps", "o", "sb", "cs", "y", "r", "l", "space", "u", "ans", "es", "d", "ssl", "gs", "su", "os", "m", "t", "sf", "ns", "ls", "sl", "g", "sv"], "a": ["aa", "af", "x", "p", "area", "sa", "ac", "aw", "ta", "an", "au", "ai", "ma", "na", "as", "ata", "wa", "b", "ae", "ar", "c", "ga", "ca", "o", "alpha", "ab", "y", "r", "fa", "va", "sta", "u", "A", "d", "oa", "m", "am", "g", "ba"], "err": ["ace", "req", "late", "iter", "w", "oe", "esi", "p", "h", "ea", "fe", "ge", "die", "j", "f", "ie", "max", "cr", "fr", "ir", "E", "b", "v", "fee", "ae", "ar", "c", "scale", "o", "error", "rr", "Error", "y", "r", "l", "result", "u", "errors", "ee", "str", "end", "d", "ne", "diff", "Er", "dr", "m", "ell", "gz", "er", "lr", "dy", "g", "z", "ec"], "e": ["de", "ace", "element", "ue", "x", "ev", "eval", "oe", "esi", "pe", "p", "en", "ea", "fe", "event", "ge", "ed", "el", "se", "te", "ce", "f", "ef", "ie", "none", "ep", "E", "equal", "ae", "ei", "c", "o", "error", "y", "r", "l", "entity", "ze", "u", "ee", "be", "end", "es", "d", "ne", "ffe", "diff", "ele", "eu", "m", "ell", "er", "edge", "g", "eb", "z", "energy", "ec", "me"], "emax": [" emall", "emaj", "omaxy", " emaj", "EMAX", "amall", "imack", "ematch", "emase", "atemin", "termatch", "EMin", "omack", "imase", "emall", " emazon", "emack", "atemaj", "omax", "tmAX", "imask", "termone", "imax", "emaax", "emask", "emaone", "imall", " emack", " emase", "tmake", "emaazon", "amax", "amask", "EMaj", "atematch", " emone", "atemax", "EMake", "emone", "imAX", "termax", "emin", "emazon", "emake", "EMax", "EMack", " emin", "emaxy", "omase", "tmack", "tmax", "imake", " emake", "imaxy", " emaxy", "EMatch", "emaatch", " ematch", "termazon", "amake", " emask", "emAX"], "i": ["ti", "ii", "ui", "my", "iv", "qi", "ani", "part", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "info", "f", "ai", "cli", "ini", "oi", "ni", "ie", "is", "b", "si", "io", "v", "init", "pi", "index", "uri", "c", "o", "y", "l", "xi", "u", "yi", "inner", "fi", "d", "li", "iu", "mini", "id", "m", "ci", "mi", "multi", "t", "gi", "g", "ori", "z", "mu", "bi", "it", "ip"], "k": ["ok", "ek", "kid", "ks", "x", "w", "p", "h", "ask", "kin", "j", "f", "q", "ack", "b", "ak", "v", "ki", "kw", "c", "uk", "ke", "ck", "o", "y", "r", "l", "N", "u", "sk", "key", "d", "kick", "dk", "m", "ik", "id", "self", "kn", "mk", "ko", "g", "z", "K"], "n": ["x", "p", "en", "nn", "name", "j", "an", "f", "net", "na", "ni", "nb", "b", "v", "c", "o", "y", "l", "r", "ng", "nt", "N", "pn", "u", "d", "ne", "m", "fn", "un", "nc", "nu", "cn", "g", "ns", "z", "sn"]}}
{"project": "FFmpeg", "commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "target": 1, "func": "static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n", "idx": 22833, "substitutes": {"old_w": ["new_wd", "new_width", "new_W", "old01w", "old25wd", "old01h", "old_width", "old25w", "old_wd", "old_wid", "old_W", "old25h", "new_wid", "old01wid", "old25W", "old01width"], "old_h": ["old_max", "new_c", "old44max", "old44q", "new_q", "old67q", "old55c", "old_z", "old67w", "old55w", "old55z", "old55h", "old_c", "new_max", "new_z", "old44w", "old67max", "old_q", "old44h", "old67h"], "sar": ["Saur", "Sar", "psara", "ssar", "yara", "Sara", "psarat", "dsart", "spar", "psarin", "lsarin", "setsaur", "nsarr", "yar", "asara", "sAR", "sarin", "sarr", "sesar", " sarat", "yAR", "esart", "ssAR", "sart", "ssars", "asarat", "sara", "asar", "ssara", "nsar", "esarat", "asarl", "psarl", "psarp", "sesara", "SAR", " sart", "slar", "setsarp", "sarat", "nsAR", "lsarl", " sarl", "Sarp", "lsar", "Sarr", "sarp", "dslar", "sarl", "setsara", "lspar", "psaur", "setsar", "sesarat", "saur", "nsara", "dsarat", " slar", "eslar", " spar", "dsar", "nsars", "esar", "sesarl", "psar", "yarr", "pspar", "sars", " sarin"], "new_w": ["new_wa", "new25wd", "new25h", "new_iw", "new_wd", "old_iw", " new_wa", "new25w", " new_wal", "old_wd", "new_wal", "new25iw"], "new_h": ["new_c", "old_sh", "old_end", "new44end", "new_H", "new44h", "new2end", "new_end", "new2H", "old_c", "new2w", "new44H", "new2h", "old_H", "new_sh", "new44w"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834, "substitutes": {"bus": ["Bus", "BUS", "cache", "bridge", "sync", "us", "use", "bis", "proc", "config", "book", "controller", "pass", "bug", "buf", "board", "serial", "engine", "boot", "plugin", "port", "pos", "mount", "used", "plug", "usb", "os"], "devfn": [" devpath", "evn", " devfp", " devn", "evfn", "privpath", "Devn", "Devfp", "evfp", "devn", "Devfn", "devpath", "devfp", "privfp", "evpath", "privfn", "Devpath"], "offset": ["inet", "timeout", "attribute", "reset", "location", "pointer", "type", "address", "length", "Offset", "start", "len", "annot", "index", "padding", "position", "parent", "base", "o", "slot", "style", "fp", "format", "limit", "enabled", "size", "off", "et", "pos", "url", "data", "optional", "number", "addr", "phase", "prefix"]}}
{"project": "FFmpeg", "commit_id": "ee90119e9ee0e2c54f1017bbe1460bfcd50555d0", "target": 1, "func": "static int decode_block(BinkAudioContext *s, float **out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = out[ch];\n\n\n\n        if (s->version_b) {\n\n            if (get_bits_left(gb) < 64)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n        } else {\n\n            if (get_bits_left(gb) < 58)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        if (get_bits_left(gb) < s->num_bands * 8)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            int value = get_bits(gb, 8);\n\n            quant[i]  = quant_table[FFMIN(value, 95)];\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else {\n\n                int v;\n\n                GET_BITS_SAFE(v, 1);\n\n                if (v) {\n\n                    GET_BITS_SAFE(v, 4);\n\n                    j = i + rle_length_tab[v] * 8;\n\n                } else {\n\n                    j = i + 8;\n\n                }\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            GET_BITS_SAFE(width, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    GET_BITS_SAFE(coeff, width);\n\n                    if (coeff) {\n\n                        int v;\n\n                        GET_BITS_SAFE(v, 1);\n\n                        if (v)\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        int j;\n\n        int count = s->overlap_len * s->channels;\n\n        if (!s->first) {\n\n            j = ch;\n\n            for (i = 0; i < s->overlap_len; i++, j += s->channels)\n\n                out[ch][i] = (s->previous[ch][i] * (count - j) +\n\n                                      out[ch][i] *          j) / count;\n\n        }\n\n        memcpy(s->previous[ch], &out[ch][s->frame_len - s->overlap_len],\n\n               s->overlap_len * sizeof(*s->previous[ch]));\n\n    }\n\n\n\n    s->first = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 22844, "substitutes": {"s": ["ves", "p", "less", "us", "se", "f", "words", "si", "a", "sb", "storage", "cs", "u", "ops", "side", "gs", "multi", "conf", "plugins", "your", "spec", "sv", "support", "aws", "ses", "ds", "xs", "is", "b", "ts", "sc", "n", "ps", "hs", "e", "y", "services", "parts", "sup", "outs", "os", "states", "S", "ks", "w", "sym", "site", "bis", "stats", "sis", "c", "l", "service", "qs", "es", "sp", "m", "sys", "t", "server", "sl", "g", "settings", "full", "sets", "sq", "rs", "sync", "sim", "fs", "ss", "ges", "o", "session", "features", "ssl", "su", "self", "sf", "ns", "ls", "sg", "js"], "out": ["channel", "part", "params", "prefix", "att", "image", "w", "cache", "p", "sync", "block", "code", "buffer", "process", "cmd", "io", "b", "up", "bin", "amp", "c", "buf", "err", "Out", "o", "OUT", "again", "conn", "batch", "result", "output", "source", "outs", "in", "at", "data", "input", "obj", "m", "array", "g", "op"], "use_dct": ["use_duct", "use_pft", "use_fuct", "use_bdCT", "use_Dft", "use_dCT", "use_bdst", "use_pCT", "use_Duct", "use_fct", "use_DCT", "use_fCT", "use_fft", "use_Dct", "use_bdcc", "use_dft", "use_dcc", "use_Dcc", "use_bdct", "use_dst", "use_Dst", "use_pct", "use_puct"], "ch": ["channel", "chip", "qi", "cy", "x", "Ch", "h", "p", "th", "ht", "code", "arch", "core", "f", "zh", "CH", " chunk", "che", "chrom", "b", "bh", "c", "chn", "cb", "och", "e", "cs", "y", "l", "conn", "chan", "col", "batch", "ph", "sk", "chi", "sh", "ach", "ich", "cm", "sch", "cp", "rc", "cho", "child", "count", "vc", "ci", "chu", "conf", "g", "z", "cht", "cor"], "i": ["ti", "ii", "ui", "my", "ji", "qi", "x", "w", "I", "ix", "p", "eni", "phi", "di", "info", "f", "ai", "ie", "ini", "ni", "start", "b", "si", "io", "init", "ki", "pi", "n", "uri", "index", "c", "o", "ind", "e", "y", "l", "xi", "u", "key", "yi", "fi", "li", "in", "d", "iu", "mini", "api", "hi", "id", "m", "ci", "mi", "ik", "multi", "gi", "g", "z", "bi", "it", "ip"], "j": ["ji", "ii", "ui", "jit", "jen", "qi", "br", "dj", "x", "w", "ix", "jp", "p", "h", "jet", "f", "length", "ja", "ie", "fr", "start", "b", "jc", "si", "uj", "n", "index", "vol", "adj", "o", "jj", "e", "y", "l", "r", "ij", "xi", "u", "key", "size", "d", "li", "J", "m", "dy", "aj", "g", "z", "jl", "js"], "k": ["ok", "qi", "ks", "x", "w", "p", "h", "f", "b", "ki", "n", "c", "ke", "ck", "o", "e", "y", "r", "sk", "u", "key", "d", "kk", "ik", "m", "g", "z", "K"], "q": ["req", " quality", "qi", "sq", "cl", "w", "ill", "p", "h", " query", "val", "qv", "f", "qu", "qq", "max", " w", "dq", "c", "quad", "ind", "y", "r", "query", "Q", "u", "qs", "frac", "d", "quality", "qa", "ig", "pad", "m", "g", "z", "qt"], "quant": ["req", "quart", "compl", "text", "cat", "buff", "proc", "qu", "pack", "config", "qq", "cost", "quick", "cur", "gap", "sc", "mask", "pp", "raw", "quad", "scale", "spec", "percent", "sum", "user", "draw", "patch", "press", "qual", "query", "window", "final", "requ", "complex", "private", "post", "frac", "quality", "qa", "pad", "mult", "total", "component", "util", "qt", "rec", "comment", "comp"], "coeff": ["loef", "coefficient", "Coeff", " coef", "loff", " coff", " coefficient", "loeff", "coef", "Coefficient", "Coff", "coff", "loefficient", "Coef"], "gb": ["mc", "bm", "cfg", "ui", "gg", "lb", "gp", "general", "xy", "wb", "gm", "bb", "gy", "bridge", "gh", "gam", "ge", "db", "buff", "go", "gnu", "uv", "bg", "gpu", "pc", "nb", "gal", "bf", "gd", "io", "b", "gin", "gram", "gt", "gl", "GB", "ga", "cb", "sb", "storage", "range", "bp", "gru", "mb", "cgi", "kb", "yg", "hub", "py", "boot", "cm", "gold", "bc", "url", "rc", "phy", "gs", "abb", "ctx", "usb", "gz", "fb", "vg", "gio", "lib", "gi", "g", "eb", "sl", "binary", "px", "rb", "rg"], "coeffs": ["coeffn", " coefos", "coffs", "coefficos", "coefficp", "coefficients", "COeffes", "coeffi", "coEFFn", "coeffns", " coeffes", "COeffos", "coeffes", "coefs", "coffes", "COEFFs", "coefp", "coEFFp", "COeffi", " coefes", "coffi", "coefficientes", "coffos", "coeffices", "coEFes", "coEFFs", " coefp", "coEFs", " coeffi", "coaffes", " coefns", "coefn", " coeffp", "coffns", "coefficienti", "coffp", " coefs", "coEFp", "coaffp", "coefficientp", "coEFFes", "coeffos", "COEFFes", "COEFFos", "coefes", " coefi", " coeffos", "coffn", "coefns", "coaffns", "coeffics", "COEFFi", "coefficientos", "coEFFos", "coEFFi", "coeffp", "coefi", "coaffs", " coeffns", " coefn", "coefos", "COeffs", " coeffn"], "v": ["ii", "iv", "x", "ve", "w", "version", "ev", "p", "h", "vert", "tv", "qv", "val", "f", "uv", "vv", "ov", "b", "n", "vol", "c", "volt", "o", "e", "ver", "l", "r", "vi", "vt", "va", "av", "u", "vp", "value", "V", "d", "vid", "lv", "m", "t", "vs", "g", "z", "sv"]}}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875, "substitutes": {"cpu": ["nic", "loop", " CPU", "CP", "home", "gp", "CPU", "gc", "cache", "pai", "p", "lc", "current", "linux", "css", "core", "clock", "processor", "cli", "proc", "proxy", "consumer", "cus", "gpu", "computer", "pc", "roc", "fc", "mac", "c", "parent", "performance", "conn", "hw", "auc", "boot", "instance", "cp", "foo", "pu", "ctx", "null", "cpp", "pkg", "cmp", "component", "nc", "cn", "loader", "px", "node", "pool"], "scc": ["Scc", "cscca", "dscc", "dsuc", "sCC", "Scca", " sCC", "scci", "sfc", "csCC", "asuc", "dscca", "Scci", "cscc", "cscci", "sysCC", " scca", " sBC", "syscc", "asfc", " sfc", "ascc", " scci", "ascca", "sBC", "SBC", "syscca", " suc", "SCC", "dsfc", "sysBC", "scca", "suc"]}}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n", "idx": 22876, "substitutes": {"s": ["states", "S", "sq", "iss", "p", "http", "ds", "ses", "f", "as", "stats", "fs", "is", "ss", "ts", "b", "v", "a", "state", "c", "ys", "ps", "sb", "o", "e", "cs", "env", "r", "u", "services", "qs", "ans", "ops", "ssl", "sys", "bs", "ns", "ls", "sl", "sv", "js"], "vs": ["ins", "ves", "css", "vr", "cs", "sk", "vals", "ops", "eps", "pos", "lv", "gs", "bs", "sv", "var", "flags", "verts", "events", "ds", "xs", "versions", "ts", "ps", "env", "ils", "args", "services", "outs", "ips", "os", "obs", "alls", "Vs", "VS", "sts", "ks", "lines", "rev", "pages", "stats", "vv", "ov", "vm", "v", "state", "files", "ys", "rules", "va", "qs", "vis", "oss", "es", "ents", "posts", "cf", "rs", "vers", "vas", "fs", "ss", "ver", "vt", "prev", "vp", "vc", "ns", "ls", "ms", "ums", "js"], "err": ["req", "ace", "nor", "ok", "good", "ner", "gr", "iter", "mr", "rs", "resp", "runner", "pr", "fe", "code", "status", "aster", "msg", "an", "cr", "cur", "order", "rh", "ir", " error", "bug", "ah", "der", "fee", "len", "asm", "ar", "cb", "dev", "error", "rr", "Error", "ind", "ver", "r", "result", "ctr", "errors", "str", "attr", "rc", "ig", "Er", "count", "arr", "dr", "orig", "fg", "er", "lr", "dy", " Err", "inner", "var"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906, "substitutes": {"info": ["ii", "full", "update", "thin", "ui", "image", "hand", "def", "part", "INFO", "setup", "inf", "options", "link", "die", "di", "http", "type", "f", "extra", "config", "now", "app", "start", "is", "tf", "feed", "init", "bug", "si", "io", "state", "information", "index", "ami", "utils", "help", "base", "build", "error", "Info", "aux", "result", "manager", "py", "end", "fo", "off", "check", "li", "json", "api", "diff", "data", "hi", "afi", "i", "id", "conf", "txt", "gi", "this", "op", "inner", "it"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931, "substitutes": {"ram_size": ["gram_size", "gram_count", "ram_count", "ram2size", "ram__size", "ram2count", "ram__count", "ram2len", "gram_address", "ram_len", "gram_len", "ram2address", "ram_address", "ram__address", "ram__len"], "do_init": ["do_load", "do_setup", "do_set"], "cpu_model": ["cpuammodel", "cpulexModel", " cpu_format", "cpu__format", "cpu__models", "CPU_controller", "cpu_controller", "cpuammethod", "CPU_Model", " cpu_Model", "cpu_method", "cpu__model", " cpu_models", " cpu__models", "cpulexmethod", " cpu__model", " cpu__format", "cpuamModel", " cpu__Model", "CPU_method", "cpuamcontroller", "cpu_Model", "cpu__Model", "cpu_format", "cpulexmodel", "cpu_models", "CPU_model", "cpulexcontroller"], "sysclk": [" sysclok", "ysCLck", "ysclks", " sysCLks", "sysclks", "ysclck", "sysCLks", "sysClok", "sysblks", "ysCLk", " sysCLok", "ysCLok", "sysblck", "ysclk", "sysCLck", " sysCLk", "sysblk", "sysCLok", "sysClks", "sysblok", "sysCLk", " sysclks", "sysplck", "sysplok", "sysclck", "sysplk", "sysplks", "ysclok", "ysCLks", "sysclok", "sysClk"], "cpu": ["lb", " CPU", "chip", "cfg", "console", "gp", "CPU", "cache", "pai", "lc", "eni", "GPU", "uci", "linux", "uca", "core", "css", "platform", "PU", "clock", "processor", "process", "cli", "proc", "config", "gpu", "net", "computer", "pc", "none", "vm", "c", "pid", "python", "performance", "conn", "appa", "hw", "result", "fps", "auc", "boot", "fp", "node", "np", "cp", "instance", "pu", "uno", "ctx", "cpp", "cmp", "nu", "nc", "loader", "px", "bench", "cn", "hp", "pool"], "env": ["inet", "req", "cv", "cache", "proc", "eng", "equ", "anne", "dev", "exe", "oa", "conf", "vs", "ec", "ext", "ev", "stack", "priv", "en", "ea", "core", "db", "shell", "cli", "config", "dir", "pect", "e", "args", "manager", "end", "viron", "qa", "Environment", "np", "worker", "environment", "eu", "cfg", "console", "gui", "enc", "el", "net", "vm", "init", "v", "agent", "state", "err", "export", "style", "profile", "scope", "ctx", "server", "energy", "agents", "qt", "cf", "eni", "code", "que", "extra", "exc", "estate", "engine", "conn", "password", "session", "erv", "txt", "nc", "context", "exec", "loader", "inc", "skin"], "irqs": ["ierq", "errqs", "IRq", "ircks", " ircks", "irsq", "errques", " irq", "iercks", "errquest", "IRqus", "IRques", "mirqs", "pirqs", "irql", "mirql", "pircks", "irq", "mirq", "irsqs", "pirques", "ierql", "IRqs", "ierches", "IRacks", " irks", "iracks", "irques", " irqus", "IRquest", "ierqs", "irsches", " irques", "ierqus", "pirquest", "errq", "IRcks", "mirches", "irqus", " iracks", "irquest", "pirq", "irches", "IRks", "miracks", "pirks", "irsql", "irks", "mirks"]}}
{"project": "FFmpeg", "commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "target": 1, "func": "static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n", "idx": 22944, "substitutes": {"qtables": ["tions", "ktable", "questable", "ktries", "quantable", "qries", "iotable", "ktools", "qtabilities", "quantables", "questries", "iotions", "table", "qable", "iotables", "qtable", "qtions", "tables", "qtries", "quantions", "iotabilities", "tabilities", "questables", "qools", "qables", "questools", "quantabilities", "ktables", "qtools"], "q": ["quant", "req", "factor", "qi", "sq", "x", "cl", "w", "ix", "question", "p", "iq", "depth", "val", "force", "qu", "f", "length", "qq", "max", "bug", "v", "dq", "ct", "c", "quad", "scale", "base", "range", "r", "l", "query", "Q", "ch", "col", "limit", "u", "qs", "requ", "value", "quest", "qa", "quality", "count", "k", "id", "conf", "g", "frequency", "z", "qt"], "i": ["ti", "ui", "ii", "part", "qi", "line", "x", "I", "ix", "p", "phi", "di", "val", "ri", "j", "info", "f", "ai", "ie", "ini", "ni", "lock", "b", "si", "io", "v", "len", "pi", "n", "index", "uri", "c", "base", "o", "e", "ind", "xi", "u", "fi", "li", "iu", "count", "k", "id", "zi", "ci", "mi", "t", "gi", "bi", "it", "ip"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n", "idx": 22949, "substitutes": {"afq": ["afiq", "afqu", "artqs", "afz", "afiz", "affq", "afcl", "afqa", "alfque", "alfqa", "afique", " afquest", "artq", "affque", "apq", "afquest", "avque", "awqs", "rafcl", "afiquest", "alfq", " afqs", "apqu", "rafq", "rafqa", "afQ", "avale", " afcl", " afck", "artqa", "awq", "afiqu", "avq", "apque", "alfQ", "apck", "awe", "afque", "afick", "afqs", "awqu", "avz", " afqa", "artcl", " afQ", "affqa", "avalq", "avquest", "affQ", "rafqs", "afck", " afque", "avalqs", " afqu", "avalqu", " afz", "afe", " afe"]}}
{"project": "FFmpeg", "commit_id": "81cc7d0bd1eab0aa782ff8dd49e087025a42cdee", "target": 1, "func": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n", "idx": 22955, "substitutes": {"_dst": ["_fST", "_Dest", " _fbl", "_rdST", "_lST", "_rdest", "_Dst", "_sdbl", "_sdsts", "_rdst", "_lbl", " _dbl", " _lST", "_rdbl", " _fest", "_dsts", "_lsts", " _dsts", " _fST", " _dST", "_dest", "_Dsts", " _lsts", "_Dbl", "_lst", "_fst", " _lbl", " _lst", " _fst", "_sdST", "_fbl", "_DST", "_fest", " _dest", "_dbl", "_sdst", "_dST"], "i": ["ti", "ii", "ui", "ji", "abi", "qi", "x", "I", "p", "h", "eni", "phi", "di", "ri", "j", "info", "f", "ai", "ini", "oi", "ni", "b", "si", "io", "v", "init", "a", "pi", "uri", "index", "c", "o", "e", "l", "r", "xi", "u", "key", "fi", "d", "li", "in", "iu", "attr", "data", "count", "hi", "k", "id", "m", "field", "t", "zi", "ci", "multi", "gi", "z", "bi", "it", "mu"], "dst": ["Dst", "DST", "dconst", " dbl", "Dconst", "fST", " dest", "ndST", "sdST", "fconst", "dbl", "Dsts", "ndsts", "nsta", "nest", " dsta", "sdest", "Dbl", " dconst", "fst", "nST", " dST", "dST", "dest", "sdsta", "dsts", "ndbl", "nst", "ndst", "fsts", " dsts", "dsta", "sdst"]}}
{"project": "FFmpeg", "commit_id": "1f80742f49a9a4e846c9f099387881abc87150b2", "target": 1, "func": "static void fill_coding_method_array(sb_int8_array tone_level_idx,\n\n                                     sb_int8_array tone_level_idx_temp,\n\n                                     sb_int8_array coding_method,\n\n                                     int nb_channels,\n\n                                     int c, int superblocktype_2_3,\n\n                                     int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n}\n", "idx": 22956, "substitutes": {"tone_level_idx": ["tone_level_idxe", "tone_level_namev", "tone_level_idxf", "tone_level_namex", "tone_level_infoxs", "tone_level_endz", "tone_level_idez", "tone_level_idex", "tone_level_idey", "tone_level_sidv", "tone_level_idsx", "tone_level_sidn", "tone_level_infoc", "tone_level_addx", "tone_level_idn", "tone_level_idy", "tone_level_idev", "tone_level_ridxs", "tone_level_ideld", "tone_level_idld", "tone_level_addld", "tone_level_idsc", "tone_level_ridxf", "tone_level_addz", "tone_level_addy", "tone_level_namexs", "tone_level_idsxs", "tone_level_ridv", "tone_level_idsv", "tone_level_dz", "tone_level_idc", "tone_level_dxe", "tone_level_idv", "tone_level_endxe", "tone_level_idxs", "tone_level_ridx", "tone_level_namexf", "tone_level_endn", "tone_level_idec", "tone_level_idsz", "tone_level_infoz", "tone_level_dv", "tone_level_sidz", "tone_level_dx", "tone_level_endv", "tone_level_idz", "tone_level_infox", "tone_level_endx", "tone_level_sidx"], "tone_level_idx_temp": ["tone_level_idz_tem", "tone_level_idx__index", "tone_level_idx_alt", "tone_level_idb_Temp", "tone_level_idx_output", "tone_level_idst_temp", "tone_level_idz_alt", "tone_level_idx_flat", "tone_level_idx2table", "tone_level_idx_level", "tone_level_idst_cache", "tone_level_idst_table", "tone_level_idb_level", "tone_level_idx__temp", "tone_level_idx2cache", "tone_level_idz_temp", "tone_level_idb_temp", "tone_level_idx_Temp", "tone_level_idx2temp", "tone_level_idz_output", "tone_level_idx2flat", "tone_level_idx_index", "tone_level_idx__alt", "tone_level_idx_cache", "tone_level_idx_tem", "tone_level_idst_flat", "tone_level_idx_table", "tone_level_idz_index"], "coding_method": ["coder_type", "coding2method", "coder_method", "coder_round", "coding2type", "coding_type", "coder_function", "coding_function", "coding2function", "coding2round", "coding_round"], "nb_channels": ["nb_thchannel", "nb_chips", "nb_chairs", "nb_chords", "nb_cannels", "nb_thannels", "nb_chans", "nb_whips", "nb_vannels", "nb_Chones", "nb_whannels", "nb_vchannel", "nb_pords", "nb_thairs", "nb_pairs", "nb_vords", "nb_chones", "nb_Chans", "nb_Chips", "nb_Channels", "nb_whans", "nb_chchannel", "nb_cips", "nb_pannels", "nb_vairs", "nb_thords", "nb_cans", "nb_pchannel", "nb_cones", "nb_whones"], "c": ["C", "mc", "dc", "cl", "w", "xc", "cache", "p", "lc", "enc", "cc", "ac", "f", "b", "sc", "ct", "n", "con", "e", "conv", "cp", "rc", "count", "m", "ci", "cpp", "cmp", "nc"], "superblocktype_2_3": ["superblocktype_2C23", "superblocktype_2O7", "superblocktype_1_23", "superblocktype_1_3", "superblocktype_2O3", "superblocktype_2_23", "superblocktype_1_7", "superblocktype_2x03", "superblocktype_2O23", "superblocktype_2O03", "superblocktype_2x3", "superblocktype_1_03", "superblocktype_2C7", "superblocktype_2_03", "superblocktype_2C03", "superblocktype_2x23", "superblocktype_2C3", "superblocktype_2x7", "superblocktype_2_7"], "cm_table_select": ["cm_cache2count", "cm_table2select", "cm_table2desc", "cm_cache2block", "cm_table2count", "cm_cache2desc", "cm_tablewdesc", "cm_cache_count", "cm_table2block", "cm_tablewblock", "cm_table_count", "cm_table_desc", "cm_tablewselect", "cm_table_block", "cm_cache2select", "cm_tablewcount", "cm_cache_desc", "cm_cache_block", "cm_cache_select"], "ch": ["cy", "p", "lc", "arch", "se", "co", "f", "app", "q", "rh", "ky", "sk", "sch", "count", "k", "conf", "form", " cs", "cor", "chip", "chart", "cl", "th", "gh", "loc", "ce", "zh", "fr", "cher", "he", "b", "y", "chi", "ich", "cm", "cham", "chu", "hand", "Ch", "h", "qu", "CH", "v", "hw", "ph", "sh", "ach", "cho", " rc", "ctx", "ci", "uch", "ht", "code", "che", "bh", "ct", "chn", "cb", "och", "conn", "chan", "col", "cp", "vc", "cmp", "cel", "cha", "cn", "cle", "cht"], "sb": ["bm", "sit", "secondary", "lc", "ib", "chal", "s", "si", "sm", "bp", "kr", "sk", "pb", "ff", "bc", "i", "abb", "gb", "fb", "bs", "sv", "lb", "ji", "src", "jp", "sa", "sy", "num", "db", "nn", "loc", "zh", "bf", "b", "sc", "jc", "n", "jj", "obb", "sel", "sup", "sd", "lr", "dy", "shop", "wb", "bb", "length", "dl", "bg", "sci", "zon", "nb", "btn", "cod", "bps", "l", "SB", "yi", "sh", "ctx", "sp", "sl", "g", "rb", "sn", "sq", "sync", "bl", "ss", "bh", "sth", "sub", "sie", "cb", "bj", "span", "bash", "split", "stab", "job", "usb", "su", "sf", "ctrl", "cel", "cn", "eb", "sg"], "j": ["ji", "ui", "jen", "br", "part", "dj", "x", "jp", "p", "h", "pr", "jo", "el", "nn", "je", "jet", "f", "ja", "ie", "q", "fr", "b", "jc", "si", "v", "uj", "kj", "temp", "ju", "n", "adj", "bj", "o", "jj", "ind", "y", "l", "r", "ij", "u", "d", "li", "obj", "J", "job", "k", "i", "sp", "m", "sn", "it", "aj", "dy", "g", "note", "z", "jan", "em", "jl", "js"], "tmp": ["zip", "xxxxxxxx", "att", "stuff", "beta", "tt", "cache", "jp", "p", "bb", "test", "src", "img", "buff", "elt", "loc", "proc", "Temp", "app", "config", "xxx", "bf", "mm", "mp", "v", "temp", "amp", "buf", "adj", "cb", "jj", "alpha", "pre", "output", "opt", "sup", "ff", "tp", "np", "cp", "attr", "tc", "rc", "input", "treatment", "diff", "kk", "obj", "sp", "emp", "pad", "yy", "fake", "txt", "xxxx", "fb", "cmp", "rb", "prefix", "perm"], "acc": ["att", "circ", "ani", "cache", "test", "ACC", "cc", "num", "ac", "app", "config", "uc", "ack", "pass", "aug", "exc", "amp", "adj", "eff", "ind", "alpha", "rate", "fac", "gain", "attr", "input", "count", "emp", "ad", "abc", "conf", "cmp", "add", "Acc", "inc", "rec"], "esp_40": ["asm_num", "asm_result", "esp_result", "esp_time", "asm_time", "esp_num", "asm_40"], "comp": ["time", "circ", "omp", "cache", "code", "co", "proc", "config", "change", "seq", "amp", "quad", "mod", "com", "cond", "frac", "cp", "pos", "comb", "unit", "conf", "grad", "cmp", "lib", "rec", "op"], "add1": ["added2", "ad4", "push3", "add6", " add6", "accessOne", "add1001", "dd2", "att1", " add1001", "Add2", "pushOne", " add0", "update99", "Add1", "updateOne", "access1", "add0", "AddOne", " addOne", "addOne", "Add6", "update55", "ad1", "att2", "access55", "add99", "Add3", "dd1", "added1001", " add99", " add55", "access99", "att1001", "ad6", "Add4", "ad3", "added0", "add55", "added1", "push1", "push2", "update1", "dd4", "att0"], "add2": ["adTwo", "added2", "ad4", "ad02", "added8", "add182", " addTwo", "push182", "add12", "add8", "Add2", "address182", "Add1", " add8", "change4", "index8", "address2", "addtwo", "append2", "push96", " add5", "ad2", "incTwo", "change1", "index4", "append182", " add12", "inc12", "add5", "add02", "address02", "changetwo", "added02", "ad5", "index2", "Add4", "added5", "address96", "inc4", "indexTwo", "added12", "append02", "inc2", "Addtwo", "push2", "push02", "added4", " addtwo", "add96", "change2", " add02", "addTwo", "append96", "addedTwo"], "add3": ["push3", "add15", "append3", "attthird", "address48", "addthird", "push15", "add123", "address123", "append43", "add48", " addThree", "append48", "added53", "att3", "append18", "addThree", "show83", "show3", "added30", " add30", "build18", "Add1", "show48", "add23", "ADD3", "push4", "address83", "build103", "app83", "show123", "app48", " add15", "att53", "add43", "add30", "app123", "pushThree", "append103", "plus43", "plusthird", "append53", "add103", "ADD30", "inc48", "inc103", "Add3", "add83", "ADD23", "plus3", "add53", "incThree", "Add53", " add53", "app3", "ADD4", "added3", "build48", "inc18", "inc3", "inc15", "att43", "build3", "address3", " add23", "appendthird", "added23", "inc4", "add18", "added1", "added4", "plus53"], "add4": [" add256", "addFour", "mod6", "ad4", "add04", "add6", "add104", " add6", "mod5", "load2", "added44", "show2", "Add2", " addfour", "pushfour", "inc04", " add44", "add48", "show4", "load48", "sum4", "sum2", "Add6", "show48", " add04", "ad2", " addFour", "addedFour", "load4", "Add3", "mod2", "addfour", "incfour", "add5", "ADDFour", " add104", "push04", "push4", "load104", "Add4", "sumfour", "sum256", "Add5", "ad3", "inc4", "inc256", "mod4", "inc2", "add44", "push2", "added4", "ADD4", "ADD44", " add48", "add256", " add5", "show104"], "multres": ["countreed", "centrix", "centres", "countre", "rendrix", "addres", "countrix", "rendres", "countres", "addrix", "rendre", "addreed", "centreed", "rendreed", "centre", "addre"]}}
{"project": "FFmpeg", "commit_id": "9ec39937f9c7f28a2279a19f71f290d8161eb52f", "target": 1, "func": "static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,\n\n                        int width, int height, int stride, Transform *t)\n\n{\n\n    int x, y;\n\n    IntMotionVector mv = {0, 0};\n\n    int counts[128][128];\n\n    int count_max_value = 0;\n\n    int contrast;\n\n\n\n    int pos;\n\n    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));\n\n    int center_x = 0, center_y = 0;\n\n    double p_x, p_y;\n\n\n\n    // Reset counts to zero\n\n    for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n        for (y = 0; y < deshake->ry * 2 + 1; y++) {\n\n            counts[x][y] = 0;\n\n        }\n\n    }\n\n\n\n    pos = 0;\n\n    // Find motion for every block and store the motion vector in the counts\n\n    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {\n\n        // We use a width of 16 here to match the libavcodec sad functions\n\n        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {\n\n            // If the contrast is too low, just skip this block as it probably\n\n            // won't be very useful to us.\n\n            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);\n\n            if (contrast > deshake->contrast) {\n\n                //av_log(NULL, AV_LOG_ERROR, \"%d\\n\", contrast);\n\n                find_block_motion(deshake, src1, src2, x, y, stride, &mv);\n\n                if (mv.x != -1 && mv.y != -1) {\n\n                    counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1;\n\n                    if (x > deshake->rx && y > deshake->ry)\n\n                        angles[pos++] = block_angle(x, y, 0, 0, &mv);\n\n\n\n                    center_x += mv.x;\n\n                    center_y += mv.y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pos = FFMAX(1, pos);\n\n\n\n    center_x /= pos;\n\n    center_y /= pos;\n\n\n\n    t->angle = clean_mean(angles, pos);\n\n    if (t->angle < 0.001)\n\n        t->angle = 0;\n\n\n\n    // Find the most common motion vector in the frame and use it as the gmv\n\n    for (y = deshake->ry * 2; y >= 0; y--) {\n\n        for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n            //av_log(NULL, AV_LOG_ERROR, \"%5d \", counts[x][y]);\n\n            if (counts[x][y] > count_max_value) {\n\n                t->vector.x = x - deshake->rx;\n\n                t->vector.y = y - deshake->ry;\n\n                count_max_value = counts[x][y];\n\n            }\n\n        }\n\n        //av_log(NULL, AV_LOG_ERROR, \"\\n\");\n\n    }\n\n\n\n    p_x = (center_x - width / 2);\n\n    p_y = (center_y - height / 2);\n\n    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;\n\n    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;\n\n\n\n    // Clamp max shift & rotation?\n\n    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);\n\n    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);\n\n    t->angle = av_clipf(t->angle, -0.1, 0.1);\n\n\n\n    //av_log(NULL, AV_LOG_ERROR, \"%d x %d\\n\", avg->x, avg->y);\n\n    av_free(angles);\n\n}\n", "idx": 22959, "substitutes": {"deshake": ["ldeshale", "dhedake", "denseake", "deshke", "fhesake", "dshase", "deshak", "desase", "dleshade", "dashaker", "dshale", " dleshake", "leshale", "ineshaker", "dhattanaker", "dleshaker", "dashake", "dueshuke", "teshak", "dhesake", "dhedak", "gethare", " deshak", "duzzleake", "desease", "doodleose", "pardeshave", " denseare", " dhemise", "dueshke", "ghedatch", "deshure", "dalshake", "ondeshaker", "pardeshane", "dhedure", "geshase", "inhedaker", "dhesace", "gethape", "dheduke", "duscheke", "duscheake", "dhattanave", "teshke", "dadhaker", "lduzzleake", " deshare", "ondeseare", " denseake", "deske", "deseaker", "neshake", "dethase", "dethape", "ondeshare", "dhedaker", "ldellak", "dahade", "tishake", "dhedatch", "densease", "dehak", "dhesare", "gethake", "pardhattanave", "tishade", "deshave", "dleshare", "leshare", "duzzleale", "lduzzleave", "ghedake", "dahake", "pardhattanane", " denseack", "deshaker", "feshake", "deshatch", "leshake", " dhemake", "geshake", "dhemane", "dadhave", "neshaker", "duzzleaker", "denseack", "inhedake", "dhedane", "dalshaker", "dhemak", "geshare", "deshane", "teshase", "deseade", "dscheake", "ldeshak", "deshinate", "feshare", "lduzzleaker", "dhemaker", "dellak", "tishaker", "dadhale", "fhesare", "dhesape", "ondeseake", "tesease", "teshaker", "dishaker", "dethake", "teshade", "teseake", "desisade", "dadhak", "dhesure", "delshake", "ondeseaker", "geshak", "leseape", "dscheose", "doodleuke", " dleshare", "dephak", "ondeshake", "denseare", "deseure", "duzzleave", "dhedke", " deshise", "deshuke", "deshose", "dhemave", "dephaker", "ldeshaker", "dhesame", "deseame", "dalshale", "ldeshake", "pardeshaker", "dueshake", "leseake", "dhedinate", "dishake", "dleshake", "dashak", " dhemaker", "inhedure", "geshatch", "delshase", "dephare", "deseape", "ineshak", "dahale", "teshake", "desisaker", "deshare", "dethke", "ldelloise", "deshale", "deshise", "teseak", "pardeshake", "dishade", "denseale", " deshase", "dehaker", "desisake", "ldellake", " deshaker", "ldeshinate", "dshatch", "doeake", "dadhase", "dhesoise", "pardhattanaker", "dhattanake", "dshake", "dhedase", "nalshake", "dhedale", " dleshase", "desale", "dishace", "dleshase", "dhedose", "deseise", "dscheuke", "dellake", "neshak", "dehake", "neshape", "ghedale", "deseke", "feshace", "dishare", "deseake", "dethak", "leseale", "dhattanane", "dhedave", "deshase", "leseare", "deseak", "dehape", "dadhare", "dhesak", " dleshak", "deseare", "doodleake", "nalshaker", "dashise", " deshack", "fhesace", "dalshape", "dishak", "tishak", "dhesase", "deshape", "dalshade", "nalshak", "leshape", "inhedak", "dhemake", "dishame", "deshace", "ldellinate", "lduzzleale", "fhesame", "geshale", "dadhake", "ineshake", "desake", "deseace", "denseak", "delloise", "doease", "dellinate", "delshack", "dethare", "deshack", "deshade", "denseaker", "delshare", "ondeshak", "dahak", "teseke", "doeak", "ldeshave", "duscheose", " densease", "duscheuke", "deshoise", "dephake", "dalshak", "denseatch", "ineshure", "ldeshoise", "desare", "dhesinate", "nalshape", "denseape", "dscheke", "doodleke", "desak", "gethak", "desape", "dhesaker", "ghedase", "denseave", "dhesack", "dhemise", "geshape", " dhemak", "deshame", "doeare", "feshame", "deseale", "dhesale", "desisak", "dleshak", "dueshose", "ondeseak", "dhedoise", "pardhattanake"], "src1": ["rc1", " src0", " src3", "rcone", "src0", "source1", "source0", "source2", "rc3", "sourceone", "srcOne", "source3", "rcOne", " srcOne", " srcone", "rc2", "sourceOne", "rc0", "src3", "srcone"], "src2": ["src02", "srctwo", " srcTwo", "source02", "rc1", " src0", "img2", "rc5", "rb0", "inst5", "inst2", "sourceTwo", "src0", "source1", "instsecond", "rctwo", "proc2", " src02", "proc1", "source2", "rbtwo", " srctwo", "inst1", "rcsecond", "imgTwo", "rb1", "src5", "rb2", "srcsecond", "proc5", "img1", "rc2", "procsecond", "rc0", "srcTwo", "img02"], "height": ["ty", "shape", "thin", "w", "layout", "scroll", "h", "row", "deep", "inches", "depth", "dim", "length", "rows", "rh", "Height", "dir", "padding", "lat", "angle", "alpha", "style", "square", "three", "flow", "window", "radius", "crop", "hang", "size", "d", "bottom", "resolution", "direction", "id", "top", "dy", "level", "density", "stroke"], "stride": ["shrate", "trate", "striad", "trided", "tride", "stide", "strade", " stridi", " strade", "strided", "decande", "shrided", "stridi", "strate", "decide", "tridi", " strate", "decade", "striade", " strided", "striide", "strande", " strande", "shride", "decided", "striided", "shridi", "stided", "stad", " strad", "strad", "stande", "stade"], "t": ["T", "ti", "st", "att", "tt", "w", "p", "h", "tm", "tw", "dt", "rt", "type", "ta", "f", "ret", "tor", "tf", "ut", "ts", "b", "v", "tower", "temp", "n", "bt", "c", "table", "o", "tools", "e", "pt", "l", "r", "tr", "tp", "d", "at", "port", "tc", "i", "m", "ant", "ot", "unt", "g", "qt", "it"], "x": ["time", "xy", "ix", "p", "yx", "cross", "X", "ex", "ax", "f", "s", "rx", "xe", "ady", "min", "dx", "u", "key", "xa", "data", "i", "sex", "px", "pe", "xc", "name", "j", "an", "xxx", "xs", "b", "n", "index", "e", "xp", "xi", "size", "weight", "ic", "id", "work", "dy", "wy", "w", "h", "host", "el", "wa", "xf", "v", "pixel", "wx", "lat", "c", "l", "ph", "hi", "m", "fx", "z", "image", "code", "ye", "type", "ct", "xx", "ux", "path", "tx", "ya", "d", "on", "one", "xt", "wd"], "y": ["ey", "ym", "ty", "ny", "cy", "ish", "w", "yl", "asy", "xy", "p", "h", "sky", "gy", "wy", "area", "sy", "hy", "yt", "oy", "ye", "type", "j", "f", "year", "start", "iy", "b", "yer", "ry", "yr", "v", "xx", "n", "c", "ys", "ady", "o", "ery", "ky", "e", "ya", "ch", "key", "py", "yi", "d", "vy", "iny", "yan", "k", "i", "yy", "id", "yn", "dy", "zy", "Y", "yo", "lon", "z", "ay"], "counts": ["seqings", "Countps", "seqs", "weightings", " countings", "weightds", "Counts", "weightps", " countments", " countps", "seqments", "lengthances", "condings", "countances", "countp", "condments", "lengthds", "condp", "weights", "weightances", "lengths", "lengthps", "Countances", "seqp", "Countings", "countds", "countps", " countances", " countp", "countments", "Countds", "countings", "conds"], "contrast": ["Conturation", "Contraction", "Contness", "distness", "contraction", "containt", "continness", "ucaint", "conterence", "distrast", "Contrib", "Containt", "continrast", "consrast", " contrib", "contractor", " conterence", "continraction", "continuration", " contraction", "consistor", "ucrast", " contness", "Contrast", "disterence", "ucness", " contractor", "conturation", "extrast", "Contractor", "contrib", "Conterence", "ucistor", " conturation", "Contistor", "consaint", "consness", "extractor", "extness", "extrib", "contness", "contistor"], "pos": ["po", "neg", "part", "z", " position", "axis", "cache", "p", "prop", "pose", "pid", "block", "num", "ac", "offset", "val", "loc", "POS", "type", "config", "pc", "none", "start", "pass", "rel", "len", "pi", "n", "index", "seq", "pro", "position", "spec", "ps", "o", "slot", " positions", "pt", "min", "style", "col", "size", "ass", "cond", "port", "diff", "nos", "Pos", "unit", "i", "os", "sp", "conf", "id", "px", "no", "Position", "all", "pres"], "angles": ["anges", "ii", "params", "abi", "shape", "states", "image", "lines", "balls", "hours", "units", "mol", "forces", "inches", "bands", "length", "sticks", "ions", "xs", "types", "ings", "faces", "breaks", "ots", "chains", "images", "points", "padding", "quad", "styles", "ps", "cb", "bits", "xes", "ads", "boxes", "blocks", "actions", "rots", "es", "eps", "archs", "letters", "les", "gs", "holes", "angled", "angular", "objects", "array", "slice", " angle", "ays", "cuts", "angle", "rings", "limits"], "p_x": [" p_w", "p_xy", " p_xy", "p_w"], "p_y": ["p_cy", "p_i", " p_cy", " p_i"]}}
{"project": "FFmpeg", "commit_id": "984f50deb2d48f6844d65e10991b996a6d29e87c", "target": 1, "func": "static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)\n\n{\n\n    DiracContext *s     = avctx->priv_data;\n\n    AVFrame *picture    = data;\n\n    uint8_t *buf        = pkt->data;\n\n    int buf_size        = pkt->size;\n\n    int i, data_unit_size, buf_idx = 0;\n\n    int ret;\n\n\n\n    /* release unused frames */\n\n    for (i = 0; i < MAX_FRAMES; i++)\n\n        if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {\n\n            av_frame_unref(s->all_frames[i].avframe);\n\n            memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));\n\n        }\n\n\n\n    s->current_picture = NULL;\n\n    *got_frame = 0;\n\n\n\n    /* end of stream, so flush delayed pics */\n\n    if (buf_size == 0)\n\n        return get_delayed_pic(s, (AVFrame *)data, got_frame);\n\n\n\n    for (;;) {\n\n        /*[DIRAC_STD] Here starts the code from parse_info() defined in 9.6\n\n          [DIRAC_STD] PARSE_INFO_PREFIX = \"BBCD\" as defined in ISO/IEC 646\n\n          BBCD start code search */\n\n        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {\n\n            if (buf[buf_idx  ] == 'B' && buf[buf_idx+1] == 'B' &&\n\n                buf[buf_idx+2] == 'C' && buf[buf_idx+3] == 'D')\n\n                break;\n\n        }\n\n        /* BBCD found or end of data */\n\n        if (buf_idx + DATA_UNIT_HEADER_SIZE >= buf_size)\n\n            break;\n\n\n\n        data_unit_size = AV_RB32(buf+buf_idx+5);\n\n        if (buf_idx + data_unit_size > buf_size || !data_unit_size) {\n\n            if(buf_idx + data_unit_size > buf_size)\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Data unit with size %d is larger than input buffer, discarding\\n\",\n\n                   data_unit_size);\n\n            buf_idx += 4;\n\n            continue;\n\n        }\n\n        /* [DIRAC_STD] dirac_decode_data_unit makes reference to the while defined in 9.3 inside the function parse_sequence() */\n\n        if (dirac_decode_data_unit(avctx, buf+buf_idx, data_unit_size))\n\n        {\n\n            av_log(s->avctx, AV_LOG_ERROR,\"Error in dirac_decode_data_unit\\n\");\n\n            return -1;\n\n        }\n\n        buf_idx += data_unit_size;\n\n    }\n\n\n\n    if (!s->current_picture)\n\n        return buf_size;\n\n\n\n    if (s->current_picture->avframe->display_picture_number > s->frame_number) {\n\n        DiracFrame *delayed_frame = remove_frame(s->delay_frames, s->frame_number);\n\n\n\n        s->current_picture->avframe->reference |= DELAYED_PIC_REF;\n\n\n\n        if (add_frame(s->delay_frames, MAX_DELAY, s->current_picture)) {\n\n            int min_num = s->delay_frames[0]->avframe->display_picture_number;\n\n            /* Too many delayed frames, so we display the frame with the lowest pts */\n\n            av_log(avctx, AV_LOG_ERROR, \"Delay frame overflow\\n\");\n\n\n\n            for (i = 1; s->delay_frames[i]; i++)\n\n                if (s->delay_frames[i]->avframe->display_picture_number < min_num)\n\n                    min_num = s->delay_frames[i]->avframe->display_picture_number;\n\n\n\n            delayed_frame = remove_frame(s->delay_frames, min_num);\n\n            add_frame(s->delay_frames, MAX_DELAY, s->current_picture);\n\n        }\n\n\n\n        if (delayed_frame) {\n\n            delayed_frame->avframe->reference ^= DELAYED_PIC_REF;\n\n            if((ret=av_frame_ref(data, delayed_frame->avframe)) < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    } else if (s->current_picture->avframe->display_picture_number == s->frame_number) {\n\n        /* The right frame at the right time :-) */\n\n        if((ret=av_frame_ref(data, s->current_picture->avframe)) < 0)\n\n            return ret;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    if (*got_frame)\n\n        s->frame_number = picture->display_picture_number + 1;\n\n\n\n    return buf_idx;\n\n}\n", "idx": 22966, "substitutes": {"avctx": ["avalctrl", "avalcontext", "afcmp", "avconfig", "avctrl", "avalconn", "avalctx", "afxc", "airctx", "afca", "avcontext", " avconfig", "avecontext", "avecas", "avconn", "avectx", "aveconfig", "AVctx", "airhw", "afhw", "akca", "AVhw", " avxc", "akctx", "akcontext", "aircas", "AVcontext", "avectrl", "AVctrl", "avcmp", "avhw", "avxc", "akcas", "afconfig", "aircmp", "AVconn", "abctx", " avcontext", "abca", "avcas", "aircontext", "abcas", "airconfig", "afcas", "afctx", "avexc", "avca", "aveconn", "AVcmp", "abcontext", "afcontext"], "data": ["ui", "image", "def", "empty", "cache", "p", "DATA", "queue", "block", "code", "img", "buffer", "val", "frame", "buff", "name", "info", "f", "config", "object", "xxx", "ata", "valid", "start", "body", "feed", "media", "device", "content", "a", "audio", "next", "index", "align", "parent", "board", "database", "da", "o", "metadata", "base", "dat", "alpha", "draw", "style", "message", "batch", "result", "window", "meta", "value", "size", "d", "li", "api", "video", "input", "memory", "obj", "ctx", "reader", "m", "Data", "client", "slice", "package", "binary", "new"], "got_frame": ["got_position", "got_cycle", "got__pixel", "gotenframe", "gotkcycle", "got__frame", "gotenversion", " got_cycle", "gotayiframe", " got__cycle", " got__pixel", "gotkpixel", " got__frame", "gotkframe", "gotenpixel", " got_version", "got___frame", "got__version", "got_iframe", "got_version", "got___position", "got___image", " got_position", "gotencycle", "gotaylarge", " got_component", " got__version", " got_iframe", " got_large", "got__cycle", "got_component", "gotkversion", " got_image", "got___component", "got_pixel", "gotayframe", "got_large", " got_pixel", "got_image"], "pkt": ["bct", "Pqt", " packet", "spkt", "punt", "packet", "Pct", " pnt", "bnt", "Pkt", "fiece", "Punt", "fkt", "pqt", "Pett", "facket", "spunt", "Packet", " pett", " pct", "piece", " piece", "spacket", "backet", "fnt", "spqt", "bkt", " punt", " pqt", "pct", "biece", "bett", "pnt", "pett"], "s": ["p", "us", "se", "f", "si", "a", "sb", "cs", "sk", "ops", "gs", "conf", "bs", "this", "spec", "sv", "aws", "events", "sa", "ses", "ds", "xs", "is", "sc", "ts", "n", "ps", "hs", "sites", "e", "services", "parts", "sup", "comments", "os", "states", "S", "ks", "sym", "bis", "stats", "its", "c", "l", "r", "service", "groups", "qs", "es", "ctx", "m", "sys", "g", "full", "sets", "sq", "rs", "sync", "http", "as", "fs", "ss", "session", "d", "ssl", "su", "self", "sf", "ns", "ls", "sg", "js"], "picture": ["image", "doc", "img", "pic", "buffer", "frame", "info", "config", "stat", "media", "v", "avi", "Picture", "cb", "vec", "photo", "filename", "meta", "profile", "fi", "summary", "video", "obj", "ctx", "m", "slice", "pict", "cam"], "buf": ["ha", "home", "cf", "br", "cap", "text", "box", "cv", "capt", "uf", "alloc", "src", "p", "queue", "mem", "bo", "font", "img", "block", "buff", "buffer", "loc", "wave", "config", "uv", "cur", "uc", "grab", "func", "um", "ru", "b", "feed", "v", "seq", "fw", "feat", "board", "cb", "vec", "bus", "ab", "fd", "wb", "fp", "av", "window", "ref", "pb", "bu", "fam", "bag", "profile", "port", "bc", "np", "conv", "ff", "rc", "raf", "ctx", "pkg", "fb", "rb", "ba"], "i": ["ti", "ii", "ui", "iv", "abi", "qi", "x", "I", "ix", "p", "h", "eni", "lc", "phi", "di", "ri", "j", "cli", "f", "ai", "info", "ini", "oi", "ni", "ie", "b", "io", "si", "v", "a", "pi", "n", "index", "ki", "c", "uri", "o", "e", "y", "l", "xi", "u", "yi", "size", "fi", "li", "d", "iu", "api", "hi", "k", "id", "zi", "ci", "mi", "t", "m", "multi", "gi", "z", "mu", "bi", "it", "ip"], "data_unit_size": ["data_transfer_name", "data_unit_start", "data_unit___id", "data_unit_scale", "data_unit_number", "data_unitfullscale", "data_unit__len", "data_unit___adjust", "data_unit_adjust", "data_unit_len", "data_unit2length", "data_units_len", "data_unit_count", "data_unit___size", "data_Unit_scale", "data_unit__scale", "data_Unit_name", "data_unit2size", "data_unit_style", "data_transfer_size", "data_unit2address", "data_unitfullsize", "data_unit__count", "data_unit__size", "data_Unit_size", "data_unit_length", "data_unit_address", "data_transfer_start", "data_unit_id", "data_units_count", "data_unit_name", "data_unitfullstyle", "data_units_size", "data_units_scale"], "ret": [" mi", " fid", " def", " init", " ip", " disp", " counter", " arr", "f", " di", " bi", " il", " pi", "r", " pri", " ptr", " li", " fin", " rc", " fu", " res", " r", " rows", "Ret", " result"], "buf_idx": ["buf_Idze", "buf_errorxf", "buf_maink", "buf_pidis", "buf_edy", "bufPfxs", "buf_mainy", "buf_erz", "buf_addx", "buf_idep", "buf_idld", "buflexidis", "buf_sidesw", "buflexidq", "bufPfx", "buflexmainx", "buf_pathy", "buf0idxf", "buf_indl", "buf_fy", "buf_erc", "buf_idest", "buf_edxs", "buf_pathxs", "buflexidsw", "buf_IDxf", "buf_idex", "buflexmainco", "buf_errory", "buf_Ide", "buflexidp", "buf_ideco", "buf_pathx", "buf_pidsw", "buf_edxx", "buf_idxs", "buf0IDl", "buf_pidq", "buf_idces", "buf_addest", "buf_mainces", "buf0idex", "buf_index", "buf_countx", "buf_argis", "buf_keyx", "buf_errorl", "buf0idl", "buf_namez", "bufOidld", "buf_idsxs", "buf_indx", "bufPidze", "buf_mainx", "buf_idco", "buf_idb", "buf_idsx", "buf_argx", "buf_ile", "buf_ideest", "buf_erxx", "buf_ardxs", "bufOidx", "buf_mainp", "buf_idxx", "buf_Idz", "buf_ardze", "buf_IDll", "buf_keyco", "bufOcountxx", "buf_IDb", "buf0IDxf", "buflexsideis", "buf_ilxs", "buf_idxf", "buf_sidex", "bufPfy", "buf_Idct", "buf_ilz", "buf_indxs", "buf_idq", "buf_IDx", "buf_idze", "buflexsideq", "buf_ere", "buf_pidx", "buf_idc", "buf_addp", "buf_errork", "buf_IDg", "bufPidx", "buf_countld", "buflexmainest", "buf_IDex", "buf_idk", "buflexsidex", "buf0IDex", "bufPfze", "bufOcountld", "buf_Idc", "buf_fx", "buf_idp", "buf_fze", "buf_idll", "buf_Idxs", "buf_mainest", "buf_idl", "buf_argsw", "buf_edze", "buf_fxs", "buf_pathze", "buf_indb", "bufOcounty", "buflexidx", "buf_erx", "buf_namex", "buf_ide", "buf_erxb", "buflexidco", "buf_idz", "buf_indxf", "buf_nameg", "buf_county", "buf_idsz", "buf_ilx", "buf_ilxx", "buf_mainco", "buf_idsw", "buflexmainp", "buf0IDx", "buf_idct", "buf_argq", "buf_idis", "buf_idg", "buf_ardx", "buf_namell", "buf_idxb", "buf_errorces", "buf_addco", "buf_ilco", "buf_errorx", "buf_idy", "buf_edld", "bufPidy", "buf_keyz", "buf_Idx", "buf_idsct", "buf0idx", "buf_sideq", "buf_errorex", "bufOidy", "buf_Idxb", "buf_sideis", "buf_Idxx", "bufOcountx", "buf_indct", "bufOidxx", "buflexsidesw", "buf_IDl", "buf_keyxs", "buf_edz", "buf_countxx", "buflexidest", "bufPidxs", "buf_edx", "buf_ardz", "buf_indz", "buf_IDz"]}}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969, "substitutes": {"env": ["settings", "inst", "console", "iss", "setup", "ev", "cache", "esi", "eni", "en", "enc", "ea", "ses", "ds", "f", "chal", "config", "dict", "inv", "enh", "init", "win", "dh", "v", "exc", "state", "c", "sb", "estate", "e", "dat", "engine", "conn", "esm", "session", "viron", "Environment", "np", "ssl", "impl", "scope", "environment", "ctx", "eu", "conf", "txt", "sf", "server", "vs", "nc", "context", "sl", "exec", "ec"], "s": ["settings", "states", "sets", "S", "sq", "setup", "src", "p", "sync", "site", "us", "local", "http", "bis", "ses", "ds", "f", "proc", "stat", "ions", "xs", "stats", "fs", "ss", "si", "sc", "b", "v", "native", "state", "n", "c", "spec", "sb", "storage", "sites", "o", "e", "r", "service", "session", "services", "qs", "es", "d", "ops", "ssl", "scope", "ctx", "m", "sys", "t", "sf", "socket", "server", "sl", "g", "sg", "ns", "sv", "js"], "insn": ["idsnc", "incN", "intsn", "INSv", " insz", "vinn", "intsne", "insd", "incd", "linsN", "linsb", "upsN", "inspace", "INSsn", "upsnt", "intsc", "ssm", "opsnin", " insconn", "insv", "INSl", "nsn", "INSnc", "INSm", "intsN", "linesn", "linsn", "ssn", "idsd", "insnin", "linesd", "intsnc", "inscn", "incnt", "nsnc", "vinN", "insb", "INSen", "incpace", "insne", "opssn", "upsn", "insnt", "incb", "nspace", "ssne", "INSnin", "vinb", "ainsen", " insc", "INSconn", "inasv", "INScn", "idsl", "insc", "intsconn", "INSz", "INSN", "linesnt", "insl", "intsm", "opsn", "incn", "insnc", "insen", "inassn", "intsl", "INSc", "inasn", "intsz", "INSpace", " insl", "nsne", "linesN", "INSne", "insm", "ainsne", " insen", "incc", "inccn", "idsn", "incne", "inasnin", "idsN", "insN", "ssd", "upsne", "INSn", "inssn", "opsv", "ainsz", "ssnt", "INSnt", "ainsn", "linsc", "idscn", "vinc", "idsz", "insconn", " insnc", " insne", "incnc", "INSd", "insz", "ssN"], "opsize": ["offsize", "pssize", "pinssize", "upsize", "offsizer", "psizer", "copize", "OPSizer", "bitsizer", "outsiz", "OPSiz", "ipsize", " opsization", "copization", "bitsiz", "offsiz", "oosizer", "vertsize", "vsize", "opersization", "opsIZE", "oopsization", "upsIZE", "OPSized", " opspace", "outsize", "nosize", "bitspace", "bitsization", "offsization", "outssize", "upsizer", "topsized", "OPSsize", "bitsizing", "topsize", "topsizer", "opsiz", "opspace", "coppace", " opsizer", "psize", "piecesize", "opensIZE", "ipsized", "opensizer", "nosizer", "piecesizer", "ipsizer", "opersiz", "opersized", "oopsIZE", "vertsizer", "opensization", "posization", "opsizer", "OPSIZE", "vsized", "psization", "vsization", "openssize", "ipsization", "outsized", "opersize", "vertsiz", "OPSize", "OPSization", " opsIZE", "opssize", "copizer", "piecesization", "oosiz", "opsization", "posize", "vssize", "oosizing", "oopsize", "opensized", "oopsizer", "vertsization", "opensize", "topsization", "opensiz", "piecesiz", "posized", "opsizing", "pinsize", "posizer", "outsization", "opensizing", "nosization", "opsized", "upssize", "pinsizer", "bitsize", "oosize", "pinsization", "nosized"], "val": ["expr", "VAL", "def", "eval", "x", "al", "alloc", "p", "prop", "doc", "call", "local", "el", "loc", "var", "ret", "stat", "valid", "func", "bl", "ival", "aval", "win", "v", "len", "seq", "vol", "buf", "feat", "fun", "slot", "store", "ind", "play", "vi", "ref", "cal", "sel", "vals", "value", "rule", "pl", "bc", "pos", "data", "ig", "arr", "ctx", "unit", "arg", "Val", "grad", "slice", "util", "lib", "exec", "sl", "all", "serv"], "addrp": ["drpre", " addrP", "hostP", "attrp", "addrps", "addrv", "alignpa", "hoppc", " addrpre", "alignpr", "addressp", " addrc", "alignpc", "lenpe", "ordv", "addressc", "hostpc", "addresspe", "armp", " addrpr", "addrpe", "hostps", "addrpin", "ordP", "argpre", "drpc", " addrps", "argpr", "addrpre", "drP", "drps", " addrv", "argP", "addressv", "attrpin", "alignps", "hostpe", "hopp", "hopv", "ptrp", "addrpa", "hostp", "addresspc", "argps", "drpr", "ptrP", "addressP", "argp", "hostv", "drp", "addrc", "armpin", "attrpi", "alignP", "ptrpr", "ptrpa", "armpi", "addresspi", "ordp", " addrpc", "addressps", "addrpr", "addrpi", "addresspin", "alignp", "ordps", "lenpc", "armP", " addrpa", "addrpc", "addrP", "attrP", "lenp", "hopc", "argpc"], "what": [" how", "about", "like", "app", "ack", "hop", "theme", "feat", "wh", "fun", "module", "thing", "function", "WHAT", "diff", "form", "component", "act", "spec", "all", "task", "nic", "item", "doc", "al", "event", "test", "current", "name", "none", "that", "who", "action", "args", "rule", "pl", "arg", "work", "make", "resource", "channel", "What", " What", "w", "ask", "wrong", "meaning", "by", "chrom", "anything", "yes", "style", "value", "truth", "missing", "whatever", "unit", "why", "something", "it", "menu", "good", "which", "type", "when", "other", "hat", "exc", "here", "where", "nothing", "again", "fact", "you", "col", "how", "existing", "there", "self", "also", "util", "pres", "non"], "reg": ["req", "br", "res", "cache", "proc", "app", "eng", "ro", "seq", "feat", "fun", "ref", "lang", "function", "leg", "gen", "data", "org", "form", "var", "debug", "urg", "cl", "num", "db", "loc", "ret", "pg", "config", "aug", "rest", "mod", "ng", "rem", "rule", "rc", "re", "sign", "arg", "abc", "erg", "rec", "rg", "gr", "round", "enc", "mem", "region", "Reg", "stat", "bg", "func", "sec", "mn", "wa", "pred", "win", "lex", "err", "store", "r", "root", "run", "value", "ig", "comb", "record", "g", "op", "sam", "code", "rol", "eg", "REG", "bl", "greg", "adj", "play", "conn", "acc", "tag", "exec", "sg", "ann"], "result": ["br", "match", "true", "runner", "res", "resp", "cache", "round", "test", "row", "event", "current", "answer", "date", "region", "complete", "ret", "results", "dict", "proc", "valid", "response", "cur", "config", "order", "mask", "up", "report", "compl", "rest", "Result", "transform", "feat", "parent", "err", "acc", "page", "root", "found", "session", "run", "final", "function", "output", "value", "rule", "diff", "rc", "data", "re", "arr", "child", "su", "replace", "work", "cmp", "array", "record", "success", "method", "group", "master", "resource", "rb", "comment", "new"], "offset": ["empty", "alloc", "num", "loc", "Offset", "extra", "start", "order", "len", "seq", "index", "align", "base", "err", "error", "ref", "off", "ops", "unc", "pos", "data", "count", "shift", "map", "op"], "tmp": ["tt", "cont", "cache", "prop", "p", "elt", "proc", "app", "cur", "tra", "storage", "bp", "pre", "pb", "py", "dest", "source", "ff", " obj", "diff", "data", "pad", "pkg", "fb", "term", "part", "xxxxxxxx", "stuff", "empty", "jp", "test", "current", "original", "img", "now", "config", "mp", "amp", "flat", "private", "sup", "np", "api", "param", "array", "slice", "inst", "params", "property", "bb", "buff", "nb", "bug", "v", "temp", "wx", "dat", "handler", "output", "wrapper", "ptr", "sp", "cpp", "done", "success", "rb", "new", "zip", "resp", "extra", "next", "buf", "cb", "appy", "vt", "session", "tp", "cp", "attr", "obj", "kk", "su", "txt", "cmp"]}}
{"project": "FFmpeg", "commit_id": "1330a0f31f373f3b9f1ea53d48b94edc47759b76", "target": 1, "func": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->bit_rate > 0) {\n\n        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n\n\n    if (avctx->rc_max_rate > 0)\n\n        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;\n\n\n\n    if (ctx->rc < 0) {\n\n        if (ctx->flags & NVENC_ONE_PASS)\n\n            ctx->twopass = 0;\n\n        if (ctx->flags & NVENC_TWO_PASSES)\n\n            ctx->twopass = 1;\n\n\n\n        if (ctx->twopass < 0)\n\n            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;\n\n\n\n        if (ctx->cbr) {\n\n            if (ctx->twopass) {\n\n                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;\n\n            } else {\n\n                ctx->rc = NV_ENC_PARAMS_RC_CBR;\n\n            }\n\n        } else if (avctx->global_quality > 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;\n\n        } else if (ctx->twopass) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;\n\n        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;\n\n        }\n\n    }\n\n\n\n    if (ctx->flags & NVENC_LOSSLESS) {\n\n        set_lossless(avctx);\n\n    } else if (ctx->rc > 0) {\n\n        nvenc_override_rate_control(avctx);\n\n    } else {\n\n        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;\n\n        set_vbr(avctx);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n}\n", "idx": 22970, "substitutes": {"avctx": ["navkw", "AVdc", "AVconfig", "navctrl", "navcmp", "varctl", "avectx", " avcu", "AVvoc", "akcontext", " avcf", "avctl", "AVcontext", "afkw", "afconfig", "navctx", "navconfig", "AVcb", "vargc", "avctrl", "AVpkg", "varcp", "avcontext", "aveloc", "calpkg", " avcmp", "varctx", "varcontext", "AVcmd", "calcmp", "varcmp", "avvoc", "afdc", "avgc", "navctl", "calctx", "navcb", "afcontext", "AVkw", "AVgc", "avconfig", "avloc", "AVcf", "AVctl", " avloc", "navgc", "AVcu", "avecontext", "calcontext", "avcu", "AVloc", "avdc", "AVcp", "akctx", "navcmd", "akconfig", "AVctrl", "avcmp", "afvoc", "AVcca", "afcf", "avkw", "avcmd", "AVcmp", "avcb", "avcp", "afcmp", "avecb", "navcontext", "afpkg", "afcmd", "avpkg", "afcu", "AVctx", "navcp", " avctrl", "akloc", "vardc", " avcontext", "navvoc", "akcmd", "navcca", "afctx", "avcf", "navloc", "avcca", "varcca"], "ctx": ["bm", "cv", "cache", "cu", "lc", "co", "anc", "kw", "ca", "cas", "cs", "bc", "conf", "la", "pkg", "component", "act", "support", "cl", "xc", "cc", "loc", "cli", "msg", "config", "pc", "cmd", "sc", "fw", "auc", "cm", "qa", "rc", "voc", "cfg", "console", "acl", "na", "sci", "btn", "wx", "c", "hw", "instance", "tc", "scope", "cca", "concept", "sys", "ci", "client", "cam", "cf", "cms", "sq", "sync", "cus", "coll", "ct", "fc", "ck", "cb", "tx", "conn", "kb", "wcs", "cp", "vc", "txt", "fn", "ctrl", "cmp", "nc", "context", "cn", "exec"]}}
{"project": "FFmpeg", "commit_id": "8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f", "target": 1, "func": "static av_cold int vp3_decode_end(AVCodecContext *avctx)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if (avctx->is_copy && !s->current_frame.data[0])\n\n        return 0;\n\n\n\n    av_free(s->superblock_coding);\n\n    av_free(s->all_fragments);\n\n    av_free(s->coded_fragment_list[0]);\n\n    av_free(s->dct_tokens_base);\n\n    av_free(s->superblock_fragments);\n\n    av_free(s->macroblock_coding);\n\n    av_free(s->motion_val[0]);\n\n    av_free(s->motion_val[1]);\n\n    av_free(s->edge_emu_buffer);\n\n\n\n    if (avctx->is_copy) return 0;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        free_vlc(&s->dc_vlc[i]);\n\n        free_vlc(&s->ac_vlc_1[i]);\n\n        free_vlc(&s->ac_vlc_2[i]);\n\n        free_vlc(&s->ac_vlc_3[i]);\n\n        free_vlc(&s->ac_vlc_4[i]);\n\n    }\n\n\n\n    free_vlc(&s->superblock_run_length_vlc);\n\n    free_vlc(&s->fragment_run_length_vlc);\n\n    free_vlc(&s->mode_code_vlc);\n\n    free_vlc(&s->motion_vector_vlc);\n\n\n\n    /* release all frames */\n\n    if (s->golden_frame.data[0])\n\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n\n        ff_thread_release_buffer(avctx, &s->last_frame);\n\n    /* no need to release the current_frame since it will always be pointing\n\n     * to the same frame as either the golden or last frame */\n\n\n\n    return 0;\n\n}\n", "idx": 22976, "substitutes": {"avctx": ["ajctx", "accountctx", "avalcontext", "opercontext", "accountpc", "accountcontext", "afcrit", "avbc", "afnas", "avpc", " avca", "operpc", "avconfig", "avalbc", "navcontext", "avalctx", "AVconfig", "avecf", "avkb", "ajconfig", "avcup", "AVca", "akcf", "afpc", "navkb", "akcu", "navbc", "afca", "navcu", "avcontext", " avconfig", "avecontext", "afcu", "avcu", "avectx", "AVctx", "akctx", "akcontext", "accountcrit", "evctx", "AVcontext", "avnas", "abnas", "avcrit", "opercrit", "afkb", "evcu", "operctx", "afbc", "abctx", "abca", " avcontext", "ajcontext", "ajnas", "afcf", "avalkb", "afctx", "avecu", "avcf", "evcup", "avca", "evcontext", "ajca", "navcup", "abcontext", "navctx", "afcup", "afcontext"], "s": ["ins", "p", "us", "se", "f", "si", "a", "sb", "cs", "u", "ops", "side", "gs", "conf", "bs", "your", "spec", "sv", "aws", "ses", "ds", "xs", "is", "sc", "ts", "b", "n", "ps", "hs", "e", "args", "services", "sup", "changes", "comments", "os", "states", "S", "ks", "sym", "h", "bis", "stat", "ions", "its", "v", "c", "r", "l", "service", "qs", "es", "ctx", "m", "sys", "t", "g", "has", "sets", "sq", "rs", "sync", "als", "http", "as", "fs", "ss", "o", "session", "uns", "d", "ssl", "su", "sf", "ns", "ls", "sg", "ms", "js"], "i": ["ti", "ii", "ui", "ji", "abi", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "info", "idi", "ai", "cli", "ie", "ini", "ni", "oi", "si", "io", "b", "pi", "n", "index", "uri", "c", "o", "e", "y", "l", "vi", "xi", "u", "yi", "fi", "li", "d", "iu", "mini", "api", "hi", "id", "zi", "ci", "mi", "m", "multi", "dr", "gi", "z", "mu", "bi", "it", "ip"]}}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980, "substitutes": {"vs": ["ins", "ves", "cv", "css", "s", "vr", "utils", "cs", "vi", "ports", "sk", "vals", "ops", "lv", "gs", "plugins", "bs", "vg", "wp", "sv", "iv", "iss", "verts", "flags", "ues", "ds", "ses", "pg", "config", "xs", "versions", "ps", "env", "ils", "services", "changes", "os", "obs", "alls", "Vs", "VS", "sts", "ks", "lines", "pages", "stats", "ov", "vm", "v", "state", "nas", "va", "qs", "es", "rs", "vers", "http", "nav", "vas", "fs", "ss", "grades", "ver", "views", "vt", "prev", "vp", "plugin", "vid", "vc", "ns", "ls", "ms", "ums", "js"]}}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n", "idx": 22994, "substitutes": {"opts": ["opps", "opls", "copations", "hopts", "obters", "catts", "ppters", "opercs", " opps", "OPts", "cats", "optps", "operations", "copcs", "operTS", " opTS", "copTS", "obds", "prots", " opls", "ppds", "optts", " opds", "copts", "opTS", "optters", "props", " optt", "opations", "hoptt", "prols", "optds", "obps", " opcs", " opations", "hopps", " ops", "ops", "OPs", "opcs", "obts", "catds", "OPt", "ppps", "optt", "OPds", "opds", "ppts", "prott", "hopls", "catt", "opters", "operts"], "opt": ["always", "expr", "def", "prop", "step", "p", "lit", "info", "proc", "hop", "eff", "nt", "key", "dest", "oper", "tr", "pos", "Opt", "org", "open", "term", "ext", "loop", "neg", "iv", "iter", "doc", "options", "cat", "num", "name", "loc", "go", "val", "ret", "ord", "config", "sc", "parent", "tip", "dot", "ott", "alt", "optim", "text", "vert", "option", "ort", "init", "temp", "err", "error", "tmp", "or", "usr", "esc", "oss", "cho", "comb", "skip", "op", "zero", "inf", "aut", "type", "lt", "oc", "sub", "o", "prev", "ctr", "post", "off", "attr", "obj", "txt", "fn", "exec", "tag", "sec"], "desc": ["dc", "req", "def", "cont", "prop", "lc", "info", "cur", "anc", "seq", "dev", "ref", "dest", "bc", "diff", "org", "term", "ec", "ext", "neg", "stage", "doc", "src", "test", "contract", "ord", "loc", "name", "config", "decl", "sc", "dir", "entry", "env", "end", "eq", "sup", "rc", "child", "dep", "rec", "text", "oe", "enc", "option", "description", "Desc", "uc", "feed", "der", "cod", "err", "meta", "esc", "comb", "sort", "asc", "op", "resp", "code", "type", "td", "next", "sub", "path", "conn", "bot", "des", "obj", "exec", "sec", "inc"], "value": ["element", "values", "iv", "home", "property", "text", "version", "current", "num", "reference", "name", "Value", "val", "type", "option", "variable", "VALUE", "address", "offset", "valid", "description", "object", "none", "language", "start", "max", "v", "content", "help", "parent", "entry", "error", "style", "r", "min", "message", "flow", "hello", "result", "format", "key", "letter", "function", "size", "json", "data", "count", "unit", "null", "field", "id", "alt", "number", "server", "feature", "group", "resource", "set", "comment"]}}
{"project": "qemu", "commit_id": "e3da9921ebc554fad3224a9fdda9a7425ffd9ef7", "target": 0, "func": "static uint32_t nvic_readl(nvic_state *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t val;\n\n    int irq;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return (s->num_irq / 32) - 1;\n\n    case 0x10: /* SysTick Control and Status.  */\n\n        val = s->systick.control;\n\n        s->systick.control &= ~SYSTICK_COUNTFLAG;\n\n        return val;\n\n    case 0x14: /* SysTick Reload Value.  */\n\n        return s->systick.reload;\n\n    case 0x18: /* SysTick Current Value.  */\n\n        {\n\n            int64_t t;\n\n            if ((s->systick.control & SYSTICK_ENABLE) == 0)\n\n                return 0;\n\n            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n            if (t >= s->systick.tick)\n\n                return 0;\n\n            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;\n\n            /* The interrupt in triggered when the timer reaches zero.\n\n               However the counter is not reloaded until the next clock\n\n               tick.  This is a hack to return zero during the first tick.  */\n\n            if (val > s->systick.reload)\n\n                val = 0;\n\n            return val;\n\n        }\n\n    case 0x1c: /* SysTick Calibration Value.  */\n\n        return 10000;\n\n    case 0xd00: /* CPUID Base.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.cp15.c0_cpuid;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = s->gic.running_irq[0];\n\n        if (val == 1023) {\n\n            val = 0;\n\n        } else if (val >= 32) {\n\n            val -= 16;\n\n        }\n\n        /* RETTOBASE */\n\n        if (s->gic.running_irq[0] == 1023\n\n                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* VECTPENDING */\n\n        if (s->gic.current_pending[0] != 1023)\n\n            val |= (s->gic.current_pending[0] << 12);\n\n        /* ISRPENDING */\n\n        for (irq = 32; irq < s->num_irq; irq++) {\n\n            if (s->gic.irq_state[irq].pending) {\n\n                val |= (1 << 22);\n\n                break;\n\n            }\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)\n\n            val |= (1 << 26);\n\n        /* PENDSVSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)\n\n            val |= (1 << 28);\n\n        /* NMIPENDSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)\n\n            val |= (1 << 31);\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa05000;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* TODO: Implement Configuration Control bits.  */\n\n        return 0;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        /* TODO: Implement Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Configurable Fault Status unimplemented\\n\");\n\n        return 0;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n    case 0xd30: /* Debug Fault Status.  */\n\n    case 0xd34: /* Mem Manage Address.  */\n\n    case 0xd38: /* Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23016, "substitutes": {"s": ["ins", "south", "secondary", "p", "less", "us", "se", "f", "si", "sb", "storage", "cs", "u", "ops", "tests", "gs", "i", "conf", "vs", "your", "spec", "options", "current", "ims", "aws", "ses", "ds", "xs", "is", "b", "ts", "n", "ps", "hs", "sites", "e", "ing", "services", "os", "params", "states", "S", "ks", "sym", "site", "stats", "ings", "its", "v", "c", "submit", "l", "r", "service", "qs", "es", "sys", "socket", "server", "g", "settings", "sets", "sq", "rs", "seconds", "sync", "http", "sim", "request", "fs", "ss", "native", "sie", "session", "uns", "d", "ssl", "su", "sf", "ns", "ls", "ms", "js"], "offset": ["timeout", "delay", "origin", "axis", "reset", "orient", "sync", "location", "pointer", "bit", "clock", "type", "address", "length", "Offset", "start", "len", "seq", "index", "padding", "rot", "align", "position", "base", "o", "slot", "range", "fp", "limit", "boot", "size", "pos", "data", "ptr", "shift", "pad", "slice", "addr", "phase", "frequency", "prefix", "operation"], "cpu": ["nic", " pci", "chip", " CPU", "gp", "CPU", "pa", "cache", "p", "lc", "pid", "mem", "linux", "core", "platform", "css", "clock", "processor", "process", "proc", "config", "gpu", "net", "pc", "vidia", "vm", "c", "conn", "xi", "fps", "boot", "fi", "port", "np", "cp", "pu", "phy", "ctx", "sys", "cmp", "component", "nc", "cn", "node"], "val": ["delay", "VAL", "p", "pal", "lit", "rt", "Value", "elt", "f", "valid", "rot", "base", "dev", "min", "fa", "ref", "pre", "py", "key", "vals", "bal", "pos", "data", "count", "sil", "la", "fb", "ot", "timeout", "item", "doc", "al", "call", "pid", "num", "ol", "fail", "ret", "year", "pc", "b", "trial", "len", "index", "fl", "ind", "sel", "cond", "pl", "arg", "alt", "serv", "update", "il", "eval", "fe", "el", "aval", "v", "rel", "err", "pt", "l", "r", "cal", "value", "li", "unit", "isal", "fx", "live", "sl", "op", "it", "x", "pa", "nil", "rol", "lt", "sol", "bl", "vol", "pol", "slot", "play", "col", "result", "ee", "d", "split", "Val", "cel", "rl", "ann"], "irq": ["ierq", "prq", "irqu", "ierqual", "IRq", "arqual", "ierqu", "irce", "ierqa", "irch", "IRqu", "prf", "arch", "irQ", "iraq", "irtch", "irach", " irqa", "riq", "arqa", "irtque", " irx", " irce", " irque", "arf", "IRqa", "irque", "iraqa", "ierry", "irf", "rique", "iraqual", " irQ", " irry", "irtx", "arq", "irace", "irqual", "iraQ", "irqa", " irqu", "iraf", "iraqu", "prqu", "irx", "irtq", " irch", "irry", "irary", "IRQ", "rich", "ierque", "ierce", "prch", "iraque", "rix", "arqu"], "t": ["T", "ti", "ty", "tt", "x", "p", "test", "dt", "rt", "ta", "type", "f", "j", "b", "ts", "ut", "v", "ct", "n", "rot", "c", "tick", "o", "e", "pt", "y", "l", "r", "tu", "nt", "token", "u", "tz", "tp", "d", "at", "tc", "i", "m", "tim", "ant", "ot", "g", "z"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int gxf_write_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    GXFContext *gxf = s->priv_data;\n\n    GXFStreamContext *vsc = NULL;\n\n    uint8_t tracks[255] = {0};\n\n    int i, media_info = 0;\n\n\n\n    if (!pb->seekable) {\n\n        av_log(s, AV_LOG_ERROR, \"gxf muxer does not support streamed output, patch welcome\");\n\n        return -1;\n\n    }\n\n\n\n    gxf->flags |= 0x00080000; /* material is simple clip */\n\n    for (i = 0; i < s->nb_streams; ++i) {\n\n        AVStream *st = s->streams[i];\n\n        GXFStreamContext *sc = av_mallocz(sizeof(*sc));\n\n        if (!sc)\n\n            return AVERROR(ENOMEM);\n\n        st->priv_data = sc;\n\n\n\n        sc->media_type = ff_codec_get_tag(gxf_media_types, st->codecpar->codec_id);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (st->codecpar->codec_id != AV_CODEC_ID_PCM_S16LE) {\n\n                av_log(s, AV_LOG_ERROR, \"only 16 BIT PCM LE allowed for now\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->sample_rate != 48000) {\n\n                av_log(s, AV_LOG_ERROR, \"only 48000hz sampling rate is allowed\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->channels != 1) {\n\n                av_log(s, AV_LOG_ERROR, \"only mono tracks are allowed\\n\");\n\n                return -1;\n\n            }\n\n            sc->track_type = 2;\n\n            sc->sample_rate = st->codecpar->sample_rate;\n\n            avpriv_set_pts_info(st, 64, 1, sc->sample_rate);\n\n            sc->sample_size = 16;\n\n            sc->frame_rate_index = -2;\n\n            sc->lines_index = -2;\n\n            sc->fields = -2;\n\n            gxf->audio_tracks++;\n\n            gxf->flags |= 0x04000000; /* audio is 16 bit pcm */\n\n            media_info = 'A';\n\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (i != 0) {\n\n                av_log(s, AV_LOG_ERROR, \"video stream must be the first track\\n\");\n\n                return -1;\n\n            }\n\n            /* FIXME check from time_base ? */\n\n            if (st->codecpar->height == 480 || st->codecpar->height == 512) { /* NTSC or NTSC+VBI */\n\n                sc->frame_rate_index = 5;\n\n                sc->sample_rate = 60;\n\n                gxf->flags |= 0x00000080;\n\n                gxf->time_base = (AVRational){ 1001, 60000 };\n\n            } else if (st->codecpar->height == 576 || st->codecpar->height == 608) { /* PAL or PAL+VBI */\n\n                sc->frame_rate_index = 6;\n\n                sc->media_type++;\n\n                sc->sample_rate = 50;\n\n                gxf->flags |= 0x00000040;\n\n                gxf->time_base = (AVRational){ 1, 50 };\n\n            } else {\n\n                av_log(s, AV_LOG_ERROR, \"unsupported video resolution, \"\n\n                       \"gxf muxer only accepts PAL or NTSC resolutions currently\\n\");\n\n                return -1;\n\n            }\n\n            avpriv_set_pts_info(st, 64, gxf->time_base.num, gxf->time_base.den);\n\n            if (gxf_find_lines_index(st) < 0)\n\n                sc->lines_index = -1;\n\n            sc->sample_size = st->codecpar->bit_rate;\n\n            sc->fields = 2; /* interlaced */\n\n\n\n            vsc = sc;\n\n\n\n            switch (st->codecpar->codec_id) {\n\n            case AV_CODEC_ID_MJPEG:\n\n                sc->track_type = 1;\n\n                gxf->flags |= 0x00004000;\n\n                media_info = 'J';\n\n                break;\n\n            case AV_CODEC_ID_MPEG1VIDEO:\n\n                sc->track_type = 9;\n\n                gxf->mpeg_tracks++;\n\n                media_info = 'L';\n\n                break;\n\n            case AV_CODEC_ID_MPEG2VIDEO:\n\n                sc->first_gop_closed = -1;\n\n                sc->track_type = 4;\n\n                gxf->mpeg_tracks++;\n\n                gxf->flags |= 0x00008000;\n\n                media_info = 'M';\n\n                break;\n\n            case AV_CODEC_ID_DVVIDEO:\n\n                if (st->codecpar->format == AV_PIX_FMT_YUV422P) {\n\n                    sc->media_type += 2;\n\n                    sc->track_type = 6;\n\n                    gxf->flags |= 0x00002000;\n\n                    media_info = 'E';\n\n                } else {\n\n                    sc->track_type = 5;\n\n                    gxf->flags |= 0x00001000;\n\n                    media_info = 'D';\n\n                }\n\n                break;\n\n            default:\n\n                av_log(s, AV_LOG_ERROR, \"video codec not supported\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        /* FIXME first 10 audio tracks are 0 to 9 next 22 are A to V */\n\n        sc->media_info = media_info<<8 | ('0'+tracks[media_info]++);\n\n        sc->order = s->nb_streams - st->index;\n\n    }\n\n\n\n    if (ff_audio_interleave_init(s, GXF_samples_per_frame, (AVRational){ 1, 48000 }) < 0)\n\n        return -1;\n\n\n\n    gxf_init_timecode_track(&gxf->timecode_track, vsc);\n\n    gxf->flags |= 0x200000; // time code track is non-drop frame\n\n\n\n    gxf_write_map_packet(s, 0);\n\n    gxf_write_flt_packet(s);\n\n    gxf_write_umf_packet(s);\n\n\n\n    gxf->packet_count = 3;\n\n\n\n    avio_flush(pb);\n\n    return 0;\n\n}\n", "idx": 23049, "substitutes": {"s": ["ins", "south", "p", "us", "se", "f", "si", "sb", "storage", "cs", "details", "ops", "gs", "conf", "spec", "sv", "aws", "sa", "ses", "ds", "xs", "types", "is", "ts", "b", "n", "ps", "e", "services", "comments", "os", "sts", "ks", "S", "w", "sym", "site", "stat", "sci", "stats", "v", "c", "ys", "l", "service", "qs", "es", "m", "sys", "t", "client", "server", "g", "sl", "single", "settings", "sets", "sq", "rs", "sync", "http", "request", "fs", "ss", "parser", "session", "d", "ssl", "su", "sf", "sing", "ns", "ls", "sg", "js"], "pb": ["typ", "lb", "pac", "pd", "pa", "wb", "uf", "p", "prop", "jp", "platform", "db", "loc", "phrase", "pg", "pm", "pc", "b", "mp", "bh", "fc", "lab", "pro", "lp", "sb", "parser", "bp", "cb", "ab", "prot", "fp", "hub", "vp", "pl", "tp", "summary", "bc", "PB", "rob", "tc", "cp", "impl", "ctx", "ppa", "cpp", "fb", "bs", "dp", "eb", "rb"], "gxf": ["gxe", "gaxe", "ergxc", "Gfc", " gxc", "guxc", "igxe", "rgxc", "rgxf", "Gxe", " gfc", " gxe", "rgfc", "Gxf", "Gfx", "igfx", "gafx", "gufc", "gfc", "gaxf", "ergfx", "igxc", "ergxf", " gfx", "ergfc", "Gxc", "rgfx", "guxf", "gfx", "gxc", "igxf", "gufx", "gaxc"], "vsc": ["VSC", "fSC", "vSC", "Vcc", " vSC", " vcc", "fcc", "Vsc", "fsc", "vcc"], "tracks": ["desc", "gp", "flags", "ls", "ributes", "cc", "length", "rows", "order", "track", "raw", "seq", "files", "stream", "cs", "icks", "ctr", "ips", "cp", "frames", "fields", "codes", "cmp", "clips", "ints", "acks", "bytes"], "i": [" ii", "ii", "ui", "ti", "abi", "qi", "x", "I", "ix", "p", "eni", "area", "phi", "code", "di", "ri", "j", "type", "idi", "ai", "info", "f", "ini", "oi", "ie", "cli", "start", "si", "b", "io", "v", "pi", "n", "index", "uri", "c", "o", "e", "y", "l", "r", "xi", "u", "yi", "fi", "d", "li", "iu", "in", "hi", "k", "id", "zi", "ci", "mi", "t", "multi", "m", "it", "anti", "gi", "z", " j", "ip"], "st": ["nd", "typ", "support", "inst", "sts", "kt", "stage", "src", "lc", "fe", "sync", "sa", "se", "ft", "td", "cr", "pc", "uc", "ST", "fr", "sr", "St", "ss", "si", "start", "ct", "bl", "mt", "sth", "stream", "c", "sw", "rest", "sb", "ast", "r", "sta", "nt", "std", "dest", "rd", "sv", "str", "post", "d", "est", "ist", "ost", "sp", "sd", "dr", "sf", "sl", "spec", "ld", "ste", "set", "sn"], "sc": ["dc", "match", "cont", "cv", "lc", "anc", "si", "sche", "ca", "sb", "sum", "cs", "Sc", "bc", "soc", "la", "spec", "comment", "ec", "desc", "stage", "cl", "src", "test", "scan", "row", "cc", "sa", "loc", "config", "cr", "pc", "mp", "scl", "sup", "pl", "model", "rc", "SC", "project", "mc", "inst", "capt", "enc", "sci", "uc", "ub", "c", "osc", "ch", "sh", "esc", "scope", "ctx", "client", "server", "cam", "asc", "cf", "sq", "sync", "sac", "isc", "cus", "sr", "usc", "ct", "fc", "sw", "sub", "acc", "syn", "nc", "context", "sec"], "audio_tracks": ["audio_count", "media_track", "audio_track", "audio_info", "media_count", "media_tracks", "media_info"], "media_type": ["audio_count", "mediaalcount", "mediaalinfo", "mediainginfo", "mediaalsource", "mediaaltype", "audio_info", "audio_type", "audio_source", "mediaingtype", "media_count", "mediaingsource", "mediaingcount", "media_info", "media_source"]}}
{"project": "qemu", "commit_id": "2f464b5a32b414adb545acc6d94b5c35c7d258ba", "target": 0, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 23050, "substitutes": {"qxl": ["qxtlc", "quylr", "qxpdl", "qxdl", "sqxlc", "qnexlc", "sqxe", "qxxls", "qze", "qttlp", "qu_", " qwwll", "quxcla", "qvel", "sqpxel", "vxmlle", "qswL", "gulexlc", "qctrl", "qwwll", "qxil", "qlexlc", "qxtn", "qlexl", "qlexlo", "qrexl", "qttli", "qxxlp", "kexlc", "sqxli", "qctl", "qllL", " qxxu", "qyli", "qwwL", "qfxlc", "quxel", "qexn", "kxxdl", "qasylo", "sqxel", "qxcl", "sqxll", "qxmll", " qxmlb", "sqpxl", "qexel", "qpxla", "qexv", "qnexl", " qxlc", "qxxu", "qfxel", " qxxl", "qttlc", "sqxls", "qxle", "guxle", " qwwle", "quxesli", "pexli", "qswf", "qpxil", "qxlo", "qullL", "qxesly", "quxe", "qzil", "qaxel", "qexla", "vxle", "qexrl", "sqxl", "qwwl", "qyv", "sqzn", "sqrel", "sqxxl", "quxpli", "queswL", "gulexle", "qulldl", "aqngli", "qpxL", "qwwle", "qylp", "qxylr", " qxll", "qxb", "quxeslp", "qapxl", "qttb", "qreli", "sq_", " qxle", "kexesla", "kxxl", "qexly", "qwxe", "qrxb", "gulexli", "qaxlp", "qrxel", "qxxshell", "kexesn", "qxcel", "qxll", "qxlp", "iqxll", "qapxll", "qnexrl", "qxL", "iqxl", " qfxlc", "qqxu", "qexlc", "qswly", " qxmll", "qqxe", "qqxl", "qxla", "qullil", "quxL", "qxmllc", "qxli", "quxlc", "qrexli", "qfxdl", "kexesl", "qxv", "qxfel", "qqfxe", "qqfxl", "qxmlel", "aqngil", "qrxo", "gulexl", " q_", "qfxll", "qwwdl", " qxmlel", "quxpu", "qxmlli", "qxo", "qlll", "qren", "qexl", "quxla", "qwxli", " qxu", "qxxl", "quenexlc", "qxpu", "guxli", "qxxdl", "qxshell", "qxlc", "qxeslp", "q_", "qlexli", "qtxl", "qxesL", "qpxel", "qXL", "sq\n", " qfxlp", "kxl", "aqxlo", "qexli", " qxxli", "qwxl", "iqexll", "vxmllc", "kexl", "qxpli", "quxesl", "qexil", "vxlc", "pexesli", "guxlc", " qxo", "qxyv", "qxfl", "qaxla", "pexesl", "qpxll", "qxtla", "qxesdl", "qzdl", "qurxli", "qwxdl", "qwxll", "qxesli", "qexL", "qllil", "kxxel", "qqfxu", "qzli", "vxmldl", "qfxlp", "qvdl", "qwxu", "sqreli", "qurxel", " qxli", "qaxlc", "qnglo", "qzl", "aqxil", "qxf", "qexe", " qxxla", "pexl", "sqxla", "quxlr", "qxn", "qaxl", "qxu", "sqxxls", "qrel", "quylc", "qaxll", "quxcel", "qxly", "quxshell", "sqxxli", "quxl", " qxxlp", "quenexl", "qasyl", "qwwli", "qrxlc", "quxu", "sqzll", "vxmll", "qtxdl", "qqfxlc", " qstr", "quxil", "qexu", "qxesl", "sqpxlc", "quxesL", "queswly", "qxpl", "qxeslc", "qxxla", "queswl", "qxcla", "qrexel", "q\n", "quexlc", "kexn", "iqexlc", "qexll", " qxmlo", "qexb", "qlldl", "sqren", "sqreil", "pexesel", "qulll", "qngl", "aqxl", "iqexb", "qpxli", "kxdl", " qxlp", "qxesf", "qapxlc", "qxe", "qtxlp", "qngil", "qXla", " qxla", "qyla", "qxxll", "kxlp", "pexel", "qxlr", "sqpxli", " qxxel", "pexdl", " qxL", "quyv", "qwwu", "qtxel", "qxel", "qpxlc", "qreil", "quxpdl", "quxcl", "qpxlp", "qswl", "qxrl", "qXli", "qlexil", "kxxlp", "qvli", "qxyl", "qXl", "qxesn", "quexL", "qqxlc", "qurxl", "qfxb", "quenexrl", "qzll", "qylr", "sqxL", "aqnglo", "qasyli", "qu\n", "qxesla", "sqze", "qfxe", "qxxli", "sqxil", "qaxshell", "qapxlp", "qzn", "qctel", "vxdl", "qxls", "qngli", " qfxli", "qrxl", "sqxxll", "qyl", "qfxli", "iqxb", "qctlc", "qxmlo", "quxdl", "qxmlle", "qzL", "qstr", "queswf", "qxmldl", "qvl", "quexl", "qustr", " qxxlc", "qctu", "qylc", "qxxel", "qaxli", "qrexlc", "qfxu", "sqzl", "qexlr", " qxb", "qxcshell", "pexesdl", " q\n", "qexo", "qwxls", "qfxle", "qurxlc", " qfxl", "qasyil", "kexeslc", " qwwL", "qxesel", "qexle", "kxel", "sqxn", "qaxdl", "quxli", "qpxl", "quxv", "quxpl", "quexly", "qfxl", "qlexle", "qxylc", "qxflc", "qrxli", "qpxdl", "qexlp", "aqxli", "qxxe", "quxlp", "qttll", "sqpxla", "quyl", " qwwl", "guxl", "kexla", "qttl", "qfxL", "sqpxL", "qwxn", "qfxla", "vxl", "qxtl", "quxcshell", "qexf", "aqngl", "qxmlb", "qxxlc", "quexf", "quexrl", "qexls", "iqxlc", "iqexl", "qexdl", " qxel", "sqstr", "qxfli"], "vga": ["veta", "veja", "Vgas", "vema", "lja", "avqa", "svja", "svga", "vgas", "vta", "gja", "lca", "qca", "vma", " vta", "vegas", "fga", "fgas", "nvda", "lgas", "gqa", "nvga", " vqa", "vca", "avma", "lda", "svgas", "svma", "veqa", " vca", "qqa", "vda", "avga", " vda", "Vma", "vja", "vqa", " vgas", "avgas", "nvqa", "lma", "qta", "qgas", "qga", "Vga", "qda", "fqa", " vma", "lga", "Vda", "Vca", "ggas", " vja", "vega", "fma", "gga", "qma"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "gui", "eni", "p", "lc", "phi", "di", "ri", "j", "f", "ai", "length", "ie", "ini", "ni", "oi", "start", "si", "io", "b", "pi", "n", "index", "ami", "uri", "c", "o", "e", "ind", "y", "l", "adi", "xi", "u", "chi", "yi", "uni", "fi", "d", "li", "iu", "mini", "diff", "attr", "hi", "k", "zi", "multi", "ci", "t", "m", "mi", "slice", "gi", "z", "mu", "bi", "ip"]}}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052, "substitutes": {"system_info": [" system_fo", " system_information", " system_inf", "system_fo", "system_status", "systemdbinfo", "system_inf", " system_Info", "system_Info", " system_id", "systemdbstatus", "systemdbInfo", " system_status", "systemdbinformation", "system_id", "system_information"], "freep": ["faak", "feeak", "freec", "Freq", "fleep", "freeep", "speip", "freap", "frepp", "speeps", "speep", "freeps", "freEP", " freap", "feeEP", "Freap", "speEP", "faec", "freeek", "freip", "fleek", " freEP", "Freek", "FreEP", "fremp", " freek", "feq", " frepp", "feep", "faek", "feek", "fayp", "flemp", "Freyp", "passeps", "Frepp", " freeps", "passEP", "freemp", "freyp", " freq", "Freak", "freak", "Freeps", "feip", "faip", "freek", "faEP", "fapp", "freq", "freeap", "feec", "fleap", " freyp", "feap", "passip", "faep", "feeep", " freec", "feeeps", "Freep", " fremp", "passep", " freip", "faeps"], "i": ["ti", "ui", "ii", "jit", "ji", "qi", "abi", "part", "I", "ix", "gui", "eni", "lc", "p", "phi", "di", "ri", "j", "ai", "ini", "oi", "ni", "ie", "start", "si", "hei", "io", "b", "pi", "uri", "index", "c", "uli", "o", "e", "y", "l", "xi", "yi", "chi", "fi", "li", "iu", "api", "count", "id", "zi", "ci", "multi", "mi", "t", "slice", "udi", "gi", "z", "mu", "inner", "it", "ip"], "cnt": ["Count", "Cnd", "ncnt", "ncnd", "Crt", "Cid", "crnc", " crt", " cid", "crno", "ncnn", "ncnc", "crrt", "Cnc", "Cnt", "lcount", "cid", "lcnt", "cnc", "Cnn", "crnt", " cno", " cnd", " count", "count", "cnn", "lcno", " cnn", "crt", " cnc", "lcid", "cnd", "cno", "Cno"], "startaddr": ["partaddr", "shareaddress", "likeaddr", "starthop", "endattr", "sourceaddr", "sourceptr", "sourceaddress", "sumptr", "patchhop", "patchaddress", "sourcehop", " startptr", "patchptr", "sumaddr", "startptr", "endadr", " startadr", "loadptr", "startadr", "partptr", "stopattr", " startaddress", "stopptr", "startaddress", "startattr", "shareaddr", "endaddress", "stopaddress", "partattr", "loadaddress", "shareptr", "partaddress", "patchaddr", "loadaddr", "sumhop", " starthop", "likeadr", "stopaddr", "endptr", "likeaddress", "endhop", "sumaddress"], "endaddr": ["ENDhop", "allorder", "starthop", "endattr", " startorder", "endedaddr", "startaug", "stopoffset", "Endhop", "endnode", "ENDaddr", " endnode", " endattr", "Endaddr", "endoffset", "alladdr", "stopdr", "ENDaddress", "endwork", "endorder", " endconn", "pendaug", "enddr", "endaug", " endorder", "pendalign", "startconn", "endedaug", " startptr", "endednode", " endaug", " startaddress", "endedaddress", "startaddress", "startattr", " endaddress", "endedwork", "startalign", "endaddress", "startdr", "endedattr", " enddr", "Endattr", "stopaddress", "ENDattr", "endedhop", "endalign", "startoffset", " endwork", "allptr", "endconn", "pendaddr", " endptr", " endoffset", "stopaddr", "endedconn", " endhop", "pendaddress", "endptr", "endhop", " endalign", "startnode", "alladdress", "startwork", "Endaddress"], "f": ["x", "w", "p", "h", "fe", "buff", "fr", "func", "fs", "b", "feed", "v", "fu", "a", "F", "fw", "c", "df", "files", "fun", "fen", "fl", "e", "handler", "l", "fa", "r", "fd", "fp", "u", "function", "fo", "fi", "ff", "d", "rf", "m", "form", "t", "fn", "fb", "file"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 23066, "substitutes": {"host_port": ["address_port", "host_name", " host_address", "host_host", "address_address", "address_name", " host_host", "address_host", "host_address"], "errp": ["acesp", " errf", " errsp", "Erpc", "Erf", "erP", "erpc", "errP", "errf", "acep", "ernp", " errP", "Erip", " errip", "errpc", "Erp", "acef", "ErP", "aceip", " errnp", "errsp", "Ernp", " errpc", "errip", "errnp", "erp", "Ersp"], "iaddr": ["shop", "tiadr", " iwork", "ihop", "sass", " ikt", "iager", "tiptr", "skt", "ikt", "ipager", "ipadr", "siwork", "ipaddress", "ipaddr", " iaddress", "iptr", "iphop", "siager", "siaddr", "Iaddr", "sikt", "Iass", "ipptr", "iass", "sadr", "iadr", "sager", "tiaddr", "siaddress", "tiaddress", "swork", "Iaddress", "spkg", " iass", "iaddress", "Ipkg", " ipkg", "saddress", "iwork", "ipkg", "sptr", "sihop"], "saddr": ["ssaddr", " sdb", " saddress", "psvr", " salign", "padd", " slayer", "oshost", "pvr", " shost", " sadd", " sarr", "sarr", "osadr", "ssarr", "sdb", "Saddr", "phost", "sadd", "ssrt", "osdb", "sihost", "Salign", "slayer", "wsaddress", "siaddr", "svr", "Saddress", "ihost", "pptr", "wslayer", "osaddr", "srt", "paddress", "sadr", "wsrt", "Sarr", "shost", " srt", "psaddress", "salign", "psptr", "iaddress", " sptr", "psaddr", "sidb", "ssaddress", "paddr", " sadr", " svr", "saddress", "siadr", "iadd", "ssalign", "wsaddr", "sslayer", "sptr"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n", "idx": 23074, "substitutes": {"bs": ["lb", "ks", "rs", "iss", "bb", "sa", "us", "bid", "ses", "ds", "fs", "bl", "b", "ss", "ts", "state", "Bs", "BS", "ps", "cb", "sb", "bp", "bos", "cs", "blocks", "pb", "qs", "bc", "gs", "gb", "os", "fb", "vs", "ns", "ls", "ms", "ba"], "s": ["ins", "states", "S", "sq", "south", "rs", "p", "sym", "ls", "sa", "ses", "ds", "f", "is", "b", "ss", "ts", "si", "state", "n", "c", "opens", "spec", "ps", "hs", "sb", "o", "cs", "session", "u", "qs", "es", "ops", "d", "ssl", "gs", "os", "m", "sl", "ns", "sg", "ms", "sv", "js"]}}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "substitutes": {"d": ["dm", "dc", "st", "p", "cd", "dt", "bd", "ds", "f", "dict", "md", "driver", "s", "D", "gd", "b", "dh", "a", "state", "c", "da", "o", "e", "dx", "r", "l", "fd", "u", "data", "i", "sd", "m", "ad", "dr", "t", "dn", "dp", "z", "ld"], "drc": ["dnrt", " dsrc", "droc", "adrt", "pdrt", "pdroc", " dRC", "prec", "datru", "pirc", "trt", "frec", "dRC", "flc", "pdsc", "adlc", "drsrc", "tsc", "Drc", "sdrc", " drec", "ldRC", "ldsc", "trc", "psrc", "prc", "lRC", "pdrec", "drac", "dlc", "dssrc", "drrec", "adru", "bsrc", "dirc", "tdrc", "dsrec", "datRC", "bsc", "ldirc", "drirc", "frc", "dnRC", "psc", "sdrt", "drsc", "lrc", "adrec", "Drec", " drt", "dsrc", " drac", "brc", "ldrc", "datlc", "ldrac", " droc", "drec", "lirc", " dsc", "bRC", "datrc", "ldsrc", "pdrac", "dsrt", "dsc", "troc", "dru", "adsrc", "tdrec", "adrc", "dnrc", "dssc", "tdrt", "datrec", "lrec", "tdsrc", "birc", "drRC", "drrc", "fRC", "sdroc", "Dru", "drt", "brec", "ldrec", "dsRC", "dnroc", "DRC", "lsrc", "adRC", "sdRC", "pdrc"], "drck": ["hrck", "drok", "strcc", "drack", "DRcks", "drac", " drco", "derck", "drrc", "DRrc", " drac", "drcks", " drok", "derco", "drock", "DRack", "hrack", " drcks", "hrok", "DRcc", "DRock", "drcc", "strck", "strack", "strcks", "hrco", "derok", " drock", "hrac", " drcc", "DRck", " drrc", "derac", "hrock", "drco", "hrrc", " drack"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23088, "substitutes": {"current_env": ["activewobj", " current_enc", "currentJenv", "currentwserver", "activewserver", "reported_env", "currentlexsession", "current__exc", " current_exc", "reported_eni", "cur_environment", "currentlexobj", "current_environment", "active_env", "current__enc", "current__env", "currentwobj", "current_state", "activewsession", "currentwsession", "currentlexenv", "current_exc", "cur_env", "current_eni", "currentJserver", "current_enc", "cur_eni", "current_server", "active_server", "current_session", "currentJsession", "current_ext", " current_state", "active_obj", "reported_conn", "reported_ext", "current__state", "currentJobj", "active_session", "currentlexserver", "current_conn", "activewenv", "current_obj", "currentwenv"], "addr": ["ace", "src", "en", "enc", "host", "arch", "route", "acl", "offset", "pointer", "loc", "rt", "name", "address", "mode", "el", "config", "cmd", "dir", "hop", "align", "seq", "amp", "ar", "mac", "base", "entry", "alias", "nr", "conn", "ref", "arp", "layer", "pos", "url", "rc", "attr", "target", "ptr", "oa", "pad", "ad", "dr", "pkg", "node", "ld", "prefix", "ext", "ip"], "len": ["line", "resp", "lin", "en", "enc", "Len", "mem", "lf", "el", "lim", "ln", "rev", "val", "offset", "length", "loc", "lan", "net", "seq", "bin", "base", "l", "limit", "ref", "lang", "end", "size", "ll", "gen", "li", "pos", "url", "count", "lvl", "fin", "la", "list", "un", "lon", "ann"], "type": ["typ", "time", "x", "class", "p", "block", "code", "link", "offset", "name", "val", "info", "length", "year", "TYPE", "ype", "types", "rel", "state", "o", "path", "action", "error", "style", "y", "format", "py", "kind", "ref", "key", "pre", "source", "plugin", "port", "model", "Type", "role", "id", "unit", "ping", "t", "op", "ext", "var"], "bp": ["lb", "br", "gp", "jp", "p", "bb", "bridge", "db", "buffer", "BP", "pg", "bg", "pc", "nb", "bf", "vm", "b", "bh", "pp", "amp", "adj", "lp", "bps", "sb", "cb", "mb", "conn", "xp", "kb", "fp", "py", "pb", "arp", "vp", "bsp", "tp", "bc", "np", "cp", "ctx", "sp", "gb", "cpp", "pkg", "fb", "ap", "eb", "sg", "hp", "wp", "rb", "ip"], "env": ["po", "global", "inst", "br", "console", "eye", "ev", "eval", "cache", "ec", "jp", "eni", "en", "enc", "queue", "site", "ea", "p", "core", "gui", "qv", "db", "loc", "proc", "config", "eng", "net", "equ", "ep", "lock", "vm", "v", "exc", "n", "next", "c", "dev", "fen", "e", "enable", "exe", "engine", "conn", "args", "manager", "viron", "np", "ig", "scope", "obj", "environment", "dep", "ctx", "eu", "oa", "org", "work", "esp", "vs", "edge", "context", "exec", "nc", "loader", "qt", "ext"], "err": ["req", "br", "ner", "aster", "f", "finder", "order", "rh", "rx", "hide", "wr", "ar", "dev", "kr", "rn", "far", "dr", "act", "var", "nor", "ler", "iter", "mr", "ev", "doc", "runner", "rag", "val", "go", "msg", "fy", "fer", "cr", "fr", " error", "ind", "e", "y", "hr", "rc", "arr", "Er", "lr", "erg", "ok", "gr", "orr", "eor", "pr", "fe", "rar", "init", "bug", "yr", "der", "error", "rr", "Error", "nr", "r", "root", "later", "or", "ig", "orig", "fg", " Err", "resp", "code", "nil", "risk", "rage", "sr", "better", "ir", "ah", "here", "cb", "ver", "result", "ee", "fam", "str", "attr", "reader", "er"], "use_count": ["use2count", "used_type", "used_cache", "use_sum", "use_type", "useblocksum", "use2cache", "useblockcache", "use_size", "useblockcount", "useblocktype", "used_size", "use2sum", "used_count", "used_sum", "use_cache", "use2size"]}}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n", "idx": 23104, "substitutes": {"env": ["stage", "console", "ev", "cv", "event", "gui", "en", "enc", "ea", "forge", "code", "que", "her", "core", "db", "el", "config", "eng", "dict", "equ", "net", "ep", "ah", "v", "exc", "state", "ench", "err", "cb", "e", "export", "style", "engine", "conn", "enable", "args", "manager", "erv", "end", "ass", "viron", "qa", "Environment", "obj", "scope", "environment", "eu", "conf", "txt", "er", "server", "vs", "context", "enter", "exec", "loader", "ec"], "t0": [" t00", "p00", "p2", "T1", " t12", "T0", "t00", "p1", "T12", "p0", "p12", "T00", "t12", "t2", "T2", " t2"], "t1": ["p2", "T1", "T121", "ty2", " t4", "T0", "ty0", " t121", "p4", "p1", "T4", "ty1", "t4", "p0", "ty121", "t121", "t2", "T2", " t2"], "relation": ["nor", "origin", "orr", "attribute", "ation", "version", "cross", "section", "bridge", "balance", "use", "unknown", "reference", "sharing", "type", "option", "length", "translation", "family", "rel", "angle", " comparison", "position", "parent", " ratio", "different", "action", "error", "rr", "hip", "relative", "result", "format", " relationship", "span", "function", "connection", "related", "bearing", "attr", " association", "role", "unit", " correlation", "relations", "rection", "cmp", "number", "record", "feature", "component", "term", "notation", "resource", "effect", "operation"]}}
{"project": "qemu", "commit_id": "f0536bb848ad6eb2709a7dc675f261bd160c751b", "target": 0, "func": "static int img_info(int argc, char **argv)\n\n{\n\n    int c;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n", "idx": 23105, "substitutes": {"argc": ["argumentv", "armce", "argb", "argumentb", "argsb", "argumentl", "Argv", "armv", "argcount", "argumentc", "Argl", " argl", "Argce", "inccount", "incv", "argsc", " argce", "argsC", "incl", "argl", "argsl", " argC", "argC", "argce", " argb", "arml", "argumentcount", "armc", " argcount", "Argc", "argumentC", "incc"], "argv": ["argvs", "Argv", "argsv", " argf", " argp", " argl", "usev", "usevs", "arv", "argsc", "argp", " argvs", "argsl", "argl", "argf", "arp", "drv", "argsp", "Argf", "arc", "drc", "usec", "drvs", "Argc", "usep", "arvs", "argsvs", "drl", "Argp", "argsf"], "c": ["C", "dc", "mc", "channel", "cy", "cl", "xc", "p", "lc", "cu", "enc", "h", "cc", "code", "ac", "ce", "f", "cr", "pc", "uc", "cur", "b", "sc", "v", "fc", "ct", "n", "cod", "con", "ca", "e", "cs", "l", "r", "u", "end", "cm", "d", "bc", "cp", "count", "category", "k", "i", "m", "ci", "ad", "nc", "cn", "sec", "rec", "ec"], "filename": ["title", "setup", "nm", "version", "STDOUT", "println", "directory", "figure", "which", "platform", "location", "nil", "wl", "name", "f", "config", "document", "Filename", "dll", "files", "database", "path", "metadata", "fil", "download", "jpg", "password", "fd", "fp", "format", "source", "size", "summary", "url", "data", "input", "kl", "username", "software", "txt", "fn", "lua", "kn", "sf", "file", "binary", "jl", "prefix"], "fmt": ["flt", "hMT", "tflt", "hrt", "Ftm", "cfformat", "bactory", "Fmt", "Flt", "fMT", "frt", "cfMT", "hformat", "tfformat", "cftm", "fformat", "bmt", " fformat", " factory", "tfMT", " ftm", "Fformat", "ftm", "Factory", " fMT", "factory", "bMT", "tfmt", "FMT", " flt", " frt", "cfmt", "hmt", "Frt", "bformat"], "output": ["generation", "write", "offset", "protected", "key", "function", "source", "progress", "data", "cut", "binary", "put", "global", "version", "name", "public", "config", "flat", "page", "format", "final", "dot", "summary", "target", "four", "input", "resource", "prefix", "update", "Output", "console", "text", "reason", "production", "option", "error", "export", "style", "letter", "enabled", "external", "after", "unit", "success", "sort", "file", "image", "pretty", "complete", "type", "response", "document", "other", "next", "control", "again", "o", "hidden", "result", " Output", "out", "outer", "append", "display", "fn"], "bs": ["lb", "ins", "abi", "rs", "iss", "src", "bb", "sync", "ib", "us", "http", "bid", "db", "bis", "buff", "ds", "banks", "s", "bg", "bas", "fs", "bf", "bl", "ss", "b", "ba", "bh", "BS", "ps", "base", "sb", "bits", "bp", "bos", "bps", "cs", "blocks", "bes", "bu", "pb", "bytes", "details", "ms", "ob", "bc", "bot", "outs", "obj", "bing", "gs", "os", "gb", "bn", "org", "browser", "fb", "vs", "las", "plugins", "lib", "ubs", "ns", "ls", "aos", "eb", "obs", "bi", "js"], "info": ["zip", "ii", "update", "ui", "part", "full", "image", "home", "ok", "abi", "INFO", "setup", "inf", "options", "jo", "guide", "http", "buff", "frame", "bis", "j", "f", "now", "config", "app", "fs", "tf", "is", "io", "si", "init", "bug", "state", "pi", "information", "index", "ami", "fw", "base", "build", "error", "Info", "fa", "result", "iso", "py", "show", "source", "fo", "details", "check", "summary", "fi", "li", "json", "off", "api", "diff", "data", "job", "afi", "i", "conf", "fb", "file", "gi", "z", "properties", "bi", "js"], "long_options": ["long__values", "long__options", "long__option", " long_option", "long__types", "long_types", "long_option", "short_types", "long_values", "short_options", " long_args", "long_args", "long_ops", "short_option", " long_ops", "short_values"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23108, "substitutes": {"resolver": ["msolution", "registor", " resolution", "reector", "resector", "assector", " resver", "solution", "erector", "assolves", "msector", "resolving", "sver", "regolves", "erolution", "reolving", "regolver", "sector", "erolving", " resolves", "msolver", "resolves", "assolver", "resver", "reolver", "msver", "erolver", "resolution", "solving", " resector", "solver", "assistor", " resistor", "resistor", "regector", "reolution"], "addr": ["adr", "ace", "inet", "kt", "x", "ix", "alloc", "p", "host", "pointer", "ord", "name", "rt", "address", "mode", "driver", "ack", "cmd", "device", "mac", "prov", "hop", "amp", "ar", "adder", "alias", "ast", "rr", "conn", "amd", "str", "port", "layer", "at", "attr", "url", "obj", "ptr", "hash", "pton", "dr", "oa", "ad", "pkg", "work", "socket", "server", "add", "act", "enter", "Address", "exec", "node", "ld", "prefix", "ext", "ip"], "naddrs": ["nattls", "nattras", "noders", "Naddresses", "nattresses", "ndders", "Nadders", "Naddrd", "nddras", "naddresses", "nastrs", "nastls", "Naddras", "nddrd", "naddls", "nastresses", "nadresses", "naddrd", "nddrs", "Naddls", "nadls", "nodls", "nodresses", "nadders", "Nddrd", "Naddrs", "Ndders", "nattrd", "Nddresses", "nddls", "nddresses", "Nddras", "nadrs", "Nddls", "nattrs", "Nddrs", "nadrd", "nastras", "naddras", "natters", "nodrs"], "addrs": ["adr", "addrd", "ddresses", "adras", "adres", "ddr", "ddrd", "ddrs", " addresses", "addras", "ddras", "adrd", "adresses", "ddres", " addres", " addrd", "addres", " addras", "adrs", "addresses"], "errp": [" errlp", "errr", "ryp", "erps", "Erlp", "ryfp", "rypre", "errorlp", "errpre", "ierpa", "rylp", "ierpc", "aerpa", "iterps", "errfp", "errlp", "errorpre", "Erpre", "acerr", "acerpo", "errpc", "aerpc", "err", "Erp", "iterpo", "iterp", "aerlp", "iterr", "errorfp", "ierp", "errps", "errorp", "aerp", "errpa", "errpo", " errpc", "acerp", "erpo", "acerps", "Erfp", " errpa", "erp", "ierlp"]}}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n    Error *err = NULL;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 23116, "substitutes": {"bs": ["lb", "abi", "iss", "src", "bb", "sync", "css", "us", "db", "bid", "bis", "ds", "ses", "banks", "bas", "fs", "bl", "b", "ss", "ros", "bh", "BS", "ps", "cb", "sb", "base", "bps", "bos", "bits", "cs", "fps", "bes", "lbs", "pb", "bu", "outs", "bc", "bing", "gs", "gb", "os", "fb", "vs", "ubs", "ns", "ls", "obs", "bi", "js"], "sector_num": ["sector_dom", "sector_offset", "section_offset", "sector7name", "section_begin", "sector_id", "sector2no", "section_number", "sector_name", "sector_uri", " sector_name", "sector7num", "section_id", "sector2number", "sector___num", "sector_begin", "section_no", "sector_no", "sector___um", "sector2id", "sector7uri", "sector2num", "section_dom", " sector_um", "sector7um", "sector___name", "sector_um", "sector_number", "sector___uri", "section_num", " sector_uri"], "nb_sectors": ["nb_pegments", "nb_pectors", "nb_casectors", "nb_vegments", "nb_seorers", "nb_nectors", "nb_cectors", "nb_verets", "nb_seivers", "nb_neivers", "nb_secures", "nb_vevers", "nb_shgments", "nb_negments", "nb_semgments", "nb_inserets", "nb_casevers", "nb_inseorers", "nb_segments", "nb_caseorers", "nb_ceivers", "nb_electors", "nb_semures", "nb_seators", "nb_serets", "nb_peivers", "nb_eleators", "nb_vectors", "nb_shctors", "nb_secgments", "nb_caserets", "nb_eleures", "nb_perets", "nb_seures", "nb_secctors", "nb_insectors", "nb_insevers", "nb_nevers", "nb_cegments", "nb_semctors", "nb_shrets", "nb_semators", "nb_severs", "nb_shvers", "nb_peorers", "nb_pevers", "nb_secators", "nb_elegments", "nb_cevers"], "qiov": [" qoren", "questimoto", "questilo", "quuno", "sqiov", "questiov", "questilib", "quoren", "wliv", "woren", "questuno", " qilib", " qveh", "qoyer", "Qoyer", " qilo", "quveh", "questveh", "woyer", "wiov", " qimoto", "questliv", "quliv", "questoren", "qarrison", "Qiov", "quno", "quiov", "sqimoto", " qoyer", " qarrison", "qimoto", "qliv", "qilib", " quno", "quarrison", "Qarrison", "Qilo", "sqilo", "qveh", "questoyer", "qilo", "quilo", "sqilib", "quoyer", "qoren"], "s": ["settings", "ins", "states", "sets", "S", "sq", "rs", "p", "sym", "aws", "sync", "site", "sa", "sg", "rss", "http", "ses", "ds", "f", "sim", "stat", "xs", "stats", "is", "fs", "b", "ss", "si", "ts", "state", "c", "ps", "sie", "sb", "sites", "submit", "serv", "cs", "space", "service", "session", "services", "parts", "sup", "uns", "es", "side", "ssl", "gs", "su", "os", "sys", "conf", "t", "self", "sl", "ls", "spec", "g", "ns", "js"], "index_in_cluster": ["index_in_clusters", "index_in_chusters", "index_in_chensus", "index_in_lusters", "index_in_sclusters", "index_in_locensus", "index_in_lication", "index_in_closer", "index_in_scluster", "index_in_clensus", "index_in_Clica", "index_in_Clusters", "index_in_locusters", "index_in_queorsi", "index_in_luster", "index_in_locoser", "index_in_chuster", "index_in_Clensus", "index_in_clication", "index_in_chorsi", "index_in_clorsi", "index_in_clica", "index_in_choser", "index_in_Clorsi", "index_in_queusters", "index_in_Clication", "index_in_locuster", "index_in_queuster", "index_in_sclica", "index_in_Closer", "index_in_lica", "index_in_Cluster", "index_in_queoser", "index_in_sclication"], "n": ["ny", "nor", "x", "nm", "p", "en", "num", "nn", "j", "f", "na", "net", "ni", "nb", "mn", "b", "v", "len", "c", "adj", "o", "nr", "nl", "y", "r", "l", "nat", "conn", "nt", "N", "pn", "u", "span", "size", "rn", "ne", "d", "np", "k", "i", "m", "t", "dn", "fn", "number", "un", "nu", "nc", "cn", "ns", "no", "z", "network", "sn", "non"], "cluster_offset": ["cluster64slot", "clard_offset", "clause__len", "cluster__len", "clayer64data", "cluster__offset", "clayer_offset", "cluster_alias", "cluster_slot", "clayer64slot", "cluster64data", "clayer64offset", "cluster_location", "clayer_num", "clause__position", "cluster_len", "clard_position", "clard_Offset", "clution_num", "clorum_auto", "clution_offset", "clause_position", "clard_location", "clorum_offset", "clause_start", "clause__offset", "cluster2offset", "cluster2len", "cluster_Offset", "clorum_alias", "cluster64offset", "clayer_data", "cluster2num", "cluster_auto", "clution_size", "clayer_slot", "clayer64num", "clause__start", "cluster64num", "clorum_num", "cluster_start", "clause_len", "cluster_num", "clution_len", "cluster__start", "cluster2size", "cluster_size", "cluster_position", "cluster_data", "cluster__position", "clause_offset"], "hd_iov": ["hd_liv", "pd_ilo", "uds_ilo", "hd_iris", "hd_veh", "hd_io", "hd_oyer", "gh_liv", "hid_io", "hd_rolet", "uds_oyer", "hd_ilo", "gh_ilo", "pd_veh", "uds_lov", "pd_liv", "hd_oren", "uds_iov", "pd_iov", "hd_lov", "hid_iris", "hid_iov", "hid_rolet", "gh_oren", "gh_iov"], "hd_qiov": ["hd_gicho", "hd_koyer", "hd_qarrison", "hd_Qiov", "hd_Qicho", "hd_koren", "hd_qqarrison", "hd_goyer", "hd_govo", "hd_qqoyer", "hd_quiov", "hd_qoyer", "hd_qqoren", "hd_sqoyer", "hd_sqiov", "hd_qicho", "hd_qoren", "hd_qovo", "hd_quarrison", "hd_goren", "hd_giov", "hd_qiris", "hd_qqiov", "hd_karrison", "hd_quiris", "hd_Qoyer", "hd_quoren", "hd_kiov", "hd_quoyer", "hd_sqoren", "hd_sqiris", "hd_Qovo", "hd_giris"], "buf": ["Buffer", "home", "cf", "br", "runner", "box", "wb", "cv", "text", "uf", "alloc", "src", "bo", "queue", "block", "mem", "img", "buff", "buffer", "bd", "xff", "Buff", "loc", "config", "uc", "func", "cmd", "b", "feed", "bh", "raw", "seq", "fw", "feat", "cb", "cas", "vec", "fl", "ab", "fd", "aux", "fp", "result", "tmp", "auc", "pb", "dest", "brace", "bag", "ff", "port", "raf", "bc", "conv", "rc", "obj", "data", "ctx", "orig", "fb", "rb", "pool"], "orig_buf": ["orig2vec", "orig_buff", "orig2buff", "orig2header", " orig_vec", " orig_buff", "prev_cb", "origPvec", "orig_vec", "orig_uf", "prev_buff", "origPbuf", "orig2buf", "prev_uf", "prev_buf", "orig_cb", "origPheader", "orig_buffer", "prev_buffer", "orig_header", "origPbuff", " orig_header"], "err": ["req", "br", "gr", "res", "resp", "rs", "go", "msg", "proc", "cr", "rx", "rh", "exc", "error", "rr", "Error", "e", "r", "ctr", "usr", "str", "rc", "arr", "Er", "sys", "er", "sg"]}}
{"project": "FFmpeg", "commit_id": "9a0f60a0f89a7a71839dfa9def5a26f2037aed62", "target": 0, "func": "static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n\n{\n\n    int hours, minutes, seconds;\n\n\n\n    if (!show_bits(gb, 23)) {\n\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hours   = get_bits(gb, 5);\n\n    minutes = get_bits(gb, 6);\n\n    skip_bits1(gb);\n\n    seconds = get_bits(gb, 6);\n\n\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n\n\n    skip_bits1(gb);\n\n    skip_bits1(gb);\n\n\n\n    return 0;\n\n}\n", "idx": 23123, "substitutes": {"s": ["rates", "sets", "sq", "S", "ks", "rs", "p", "ls", "aws", "sync", "sa", "sg", "http", "ses", "ds", "f", "fs", "b", "sc", "si", "ges", "ss", "ts", "c", "spec", "hs", "sb", "o", "e", "cs", "service", "services", "qs", "ops", "ssl", "ctx", "gs", "self", "os", "sys", "conf", "bs", "server", "sl", "g", "ns", "sv", "js"], "gb": ["bm", "ui", "lb", "gg", "du", "hd", "gp", "gc", "wb", "general", "gm", "bb", "gy", "bo", "sync", "gam", "ge", "db", "buff", "go", "gnu", "bg", "pc", "gal", "bf", "gd", "b", "gin", "gu", "gram", "kw", "game", "cod", "GB", "ga", "gt", "cb", "sb", "storage", "cgi", "gae", "kb", "hub", "google", "boot", "agg", "bc", "ogg", "phy", "usb", "gs", "abb", "ci", "og", "multi", "Gb", "gio", "lib", "gi", "g", "eb", "sg", "binary", "ko", "rb", "rg"], "hours": ["time", "hops", "headers", "dates", "lines", "units", "h", "utes", "forces", "events", "inches", "ows", "itudes", "days", "cycles", "length", "eks", "amples", "words", "flows", "pages", "runs", "hh", "images", "steps", "bits", "months", "Hours", "hour", "groups", "blocks", "parts", "times", "details", "features", "hm", "jobs", "frames", "workers", "shows", "ays", "years", "ages", "ints", "ms", "obs", "quarters"], "minutes": ["Minutes", "Minute", "continute", "minsseconds", "minseconds", "minuted", "Minutions", "minues", "donuted", "nicutes", "menutions", "mnutions", "Minuted", "menuted", "mnutes", "menutes", "minute", "donute", "mnuted", "minions", "monutions", "menions", "nicutions", "Minues", "nicseconds", "monutes", "continuted", "minutions", "Minions", "continues", "nicments", "donutes", "minsments", "continutes", "monments", "minsutions", "minments", "monseconds", "mnions", "donues", "minsutes"], "seconds": ["sections", "timeout", "sets", "dates", "units", "mins", "utes", "events", "reports", "abytes", "ses", "days", "tones", "flows", "words", "security", "second", "strings", "files", "utils", "steps", "months", "duration", "pieces", "fps", "blocks", "groups", "services", "details", "six", "size", "outs", "eps", "letters", "frames", "ones", "years", "games", "sec", "quarters", "bytes"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_restart(FTPContext *s, int64_t pos)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    const int rest_codes[] = {350, 0};\n\n\n\n    snprintf(command, sizeof(command), \"REST %\"PRId64\"\\r\\n\", pos);\n\n    if (!ftp_send_command(s, command, rest_codes, NULL))\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n}\n", "idx": 23136, "substitutes": {"s": ["php", "support", "settings", "sets", "S", "sq", "rs", "setup", "secondary", "src", "p", "sym", "sudo", "sync", "ses", "ds", "f", "fs", "ssh", "ss", "ts", "c", "sb", "o", "e", "r", "service", "session", "es", "ssl", "scope", "gs", "i", "self", "m", "os", "t", "sf", "socket", "client", "server", "ns"], "pos": ["po", "line", " position", "cache", "p", "pose", "pid", "block", "location", "offset", "pointer", "loc", "POS", "type", "address", "proc", "info", "val", "length", "Position", "pc", "start", "len", "seq", "index", "position", "patch", "args", "ref", "point", "end", "size", "port", "ptr", "Pos", "i", "os", "addr", "spec", "op"], "command": ["php", "script", "prefix", "text", "directory", "call", "Command", "code", "buffer", "word", "mode", "length", "msg", "response", "address", "document", "pattern", "cmd", "comm", "content", "power", "argument", "send", "python", "sequence", "error", "patch", "message", "character", "password", "query", "result", "execute", "function", "connection", "communication", "child", "data", "input", "array", "program", "method", "exec", "package", "comment", "operation"], "rest_codes": ["rest_errors", " rest_cod", " rest_errors", "restpcodes", "rest_keys", " rest_comm", "rest_cod", " rest_keys", "restperrors", "rest_comm", "restpcode", "rest_code", "restpcomm", " rest_code"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n\n{\n\n    BlockDriverState *bs = child->bs;\n\n\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_offset;\n\n    unsigned int cluster_bytes;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* FIXME We cannot require callers to have write permissions when all they\n\n     * are doing is a read request. If we did things right, write permissions\n\n     * would be obtained anyway, but internally by the copy-on-read code. As\n\n     * long as it is implemented here rather than in a separate filter driver,\n\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n\n     * it could request permissions. Therefore we have to bypass the permission\n\n     * system for the moment. */\n\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 23140, "substitutes": {"child": ["Child", "cy", "children", "cl", "cache", "current", "block", "code", "core", "bit", "uncle", "f", "cus", "cur", "pc", "fs", "bl", "feed", "GV", "bin", "c", "buf", "sub", "parent", "conn", "root", "fd", "ch", "baby", "ssl", "job", "crypt", "gb", "client", "lib", "inner", "pool"], "offset": ["inet", "timeout", "image", "origin", "alloc", "reset", "location", "acl", "pointer", "loc", "initialized", "address", "length", "Offset", "info", "config", "online", "net", "offs", "start", "len", "align", "index", "seq", "padding", "utils", "position", "parent", "base", "seed", "slot", "entry", "alias", "o", "error", "root", "fp", "limit", "output", "oid", "size", "off", "et", "initial", "layer", "pos", "url", "slave", "count", "afi", "optional", "shift", "number", "slice", "phase", "loader", "set", "prefix"], "bytes": ["zip", "values", "lines", "seconds", "tes", "units", "ls", "classes", "css", "length", "net", "pages", "rows", "fs", "Bytes", "videos", "b", "fee", "len", "seq", "files", "steps", "bits", "bps", "byte", "blocks", "pieces", "boot", "errors", "size", "es", "outs", "ops", "ips", "bc", "data", "les", "null", "os", "gz", "codes", "items", "binary"], "qiov": [" qoren", " qregor", "questirin", "questiov", "qregor", "dqirin", "qoyer", "dqclub", "questregor", "qirin", "questoren", "dqiov", "questclub", "zoren", " qoyer", "questrolet", "ziov", " qclub", "qrolet", " qrolet", " qirin", "zoyer", "dqrolet", "questoyer", "zregor", "qclub", "qoren"], "bs": ["lb", "settings", "ins", "rs", "iss", "bb", "ls", "sync", "css", "ib", "ubis", "us", "http", "bid", "bis", "ds", "ses", "banks", "s", "bas", "fs", "bf", "bl", "b", "ss", "bh", "bin", "BS", "ps", "base", "sb", "cb", "bits", "bos", "bps", "cs", "serv", "root", "bi", "blocks", "bes", "boot", "pb", "lbs", "fps", "BC", "hub", "outs", "bc", "bal", "obj", "bing", "gs", "gb", "bn", "js", "bel", "plugins", "fb", "vs", "os", "las", "lib", "ubs", "ns", "eb", "ba"], "bounce_buffer": ["bounce24writer", "bounce_buff", "bounce_pad", "bancel64iter", "benge_resource", "botation_layer", "bounce_writer", "bancel_buffer", "bounce_Buffer", "bounceablequeue", "bounce_byte", "bounceablelength", "bouncepresource", "bounce_buf", "bounce_resource", "bounce2buffer", "bounce64buffer", "bounce_length", "bouncepreBuffer", "bouncelexbyte", "bouncepwriter", "benge_buffer", "batteryablebyte", "bounce2queue", "bouncelexbuf", "bouncelexlayer", "battery_Buffer", "bounceablepad", "batteryablequeue", "bounceingiter", "bancel_iter", "benge_queue", "bouncelexiter", "bouncepqueue", "bounceingbuffer", "bounceableBuffer", "bounce_iter", "batteryablelength", "bancel64buf", "bounceablebyte", "bancel64buffer", "bounce24queue", "battery_pad", "benge_writer", "bounceprebuffer", "botation67table", "bounce_layer", "bounce64buf", "bounce67table", "battery_length", "bouncelextable", "bouncelexbuffer", "battery_byte", "botation67buffer", "bounce_table", "bait_length", "benge24buffer", "bait_buff", "bancel64byte", "botation_table", "botation67layer", "battery_queue", "bounce64byte", "bounce24resource", "benge24resource", "battery_buffer", "bounce2byte", "bounce67layer", "bait_Buffer", "batteryablepad", "bounceprelength", "bancel_buf", "bait_buffer", "botation_buffer", "bouncepbuffer", "bancel_byte", "bounce24buffer", "bounce67buffer", "benge24writer", "bounce64iter", "bounceprepad", "batteryablebuffer", "batteryableBuffer", "bounceingbyte", "bounceablebuffer", "bounceingbuf", "benge24queue", "bounce_queue"], "drv": ["irj", "irv", "srv", "hrj", " drj", "hrb", "DRV", "drV", "irb", "rrv", "irV", "rrf", "srf", " drh", "Drb", "drf", " drV", " drb", "hrV", "drh", "DRf", " drvs", "hrv", "drb", "drj", " drf", "rrh", "DRb", "srh", "Drf", "Drv", "drvs", "DRv", "rrvs", "DrV", "srvs"], "iov": [" gymn", "oren", "rov", "wav", "voice", "iro", "\u00ef", "iev", "igroup", " club", "iol", "ville", "nox", "ibl", "obo", "minecraft", "icho", " cohort", "club", "ionic", "ir", "chrom", "io", "nih", "ibr", " bio", "buf", "oyer", "gru", "sbm", "drm", "isco", "iris", "ij", "userc", "iop", "Club", "imedia", "ilib", "liv", "soc", "nov", "rolet", "\u00ee", "uno", "dyl", "IO", "vre", "vg", "ressor", "ilo", "gio", "lov", " ensemble", " liv", "lib", "voc"], "bounce_qiov": ["bounce_qqoyer", "bounce_pilo", "bounce_qrolet", "bounce_dqliv", "bounce_qliv", "bounce_gilo", "bounce_quiov", "bounce_qurolet", "bounce_qqiop", "bounce_dqoyer", "bounce_giop", "bounce_quiop", "bounce_pliv", "bounce_prolet", "bounce_qqilo", "bounce_dqiov", "bounce_grolet", "bounce_qqrolet", "bounce_piop", "bounce_gliv", "bounce_poyer", "bounce_qoyer", "bounce_qqiov", "bounce_dqiop", "bounce_piov", "bounce_quoyer", "bounce_qilo", "bounce_qiop", "bounce_giov", "bounce_goyer"], "cluster_offset": ["clresh_offset", "cluster___align", "clresh_layer", "cluster_loss", "clresh___layer", "cluster__len", "cluster64index", "cluster__Offset", "clistry_area", "cluster__offset", "clusterIPfrequency", "clresh___align", "cluster___offset", "cluster__size", "clusters_seconds", "clistry_offset", "cluster7layer", "cluster7len", "cluster7frequency", "cluster_layer", "cluster__off", "cluster_align", "clistry_part", "cluster_end", "cluster7offset", "clistry_len", "cluster_len", "clusterIPlength", "cluster__seconds", "clistry67len", "clusters_off", "cluster64padding", "cluster_address", "cluster_off", "clusters_offset", "clusterIPseconds", "clresh_loss", "cluster_part", "clusters_padding", "clusters_length", "clusterIPoffset", "cluster_seconds", "clusters_Offset", "cluster_frequency", "cluster_Offset", "cluster64len", "cluster67len", "clistry67area", "clusters_size", "clusters_index", "cluster__length", "cluster67area", "clusters_len", "clusterIPlayer", "cluster_padding", "cluster64offset", "clusterIPoff", "clresh___loss", "clusterIPlen", "cluster_length", "cluster67offset", "cluster___layer", "cluster_area", "cluster___loss", "clusters_frequency", "clistry67part", "cluster67part", "cluster_size", "clistry67offset", "clresh_align", "cluster_index", "clresh___offset", "clusters_layer"], "cluster_bytes": ["cluster8values", "cluster7ops", "cluster67flows", "cluster64bits", "clensus_items", "cluster67loads", "clensus6ops", "cluster64lines", "clensus_ops", "closer_bits", "cluster6bytes", "cluster_sequence", "cluster_loads", "cluster_items", "clause_byte", "clensus6items", "cluster67sequence", "clancer_loads", "clensus_bytes", "clensus6length", "clancer_bytes", "cluster_len", "clancer_blocks", "clluster67bytes", "cluster_byte", "clluster67len", "cluster6sequence", "cluster8len", "clensus6bytes", "clause_pieces", "cluster_ops", "clluster_values", "cluster8items", "cluster67seconds", "cluster0items", "clancer_seconds", "cluster6items", "cluster_lines", "clusters_flows", "cluster6files", "clensus_length", "cluster67items", "cluster67files", "cluster_seconds", "closer_lines", "cluster_values", "cluster67len", "cluster64bytes", "cluster_files", "cluster67values", "cluster_flows", "cluster7length", "cluster67length", "clause_bytes", "clluster_items", "cluster0bytes", "cluster64seconds", "cluster6length", "cluster_bits", "clusters_blocks", "cluster_length", "cluster67blocks", "cluster_blocks", "cluster8bytes", "clluster67values", "clusters_files", "cluster7bytes", "closer_seconds", "cluster_pieces", "cluster0ops", "cluster7items", "cluster_size", "clusters_bytes", "clluster_bytes", "closer_bytes", "cluster0length", "cluster6ops", "clluster67items", "cluster67bytes", "clluster_len", "clause_size"], "skip_bytes": ["skip_seconds", "skip___lines", " skip_lines", "skip___bits", "skip67units", "skip67tes", "skip___bps", "skip67bytes", "skip_bits", "skip_bps", " skip_bits", " skip_seconds", " skip_units", "skip_tes", "skip___bytes", "skip___units", "skip2bits", "skip___tes", "skip2bps", " skip_bps", "skip_lines", "skip2lines", " skip_tes", "skip2bytes", "skip_units"], "ret": ["part", "att", "match", "def", "res", "resp", "rets", "fit", "lit", "code", "cat", "num", "bit", "rt", "val", "rev", " Ret", "det", "ft", "status", "lt", "art", "mt", "pass", "RET", "gt", "len", "back", "feat", "fun", "reg", "base", "result", "nt", "ref", "final", "std", "out", "usr", "opt", "value", "fi", "sur", " RET", "reply", "flag", "re", "obj", "count", "job", "id", "alt", "arg", "fin", "success", "cmp", "Ret", "addr", "group", "no", "let"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n", "idx": 23145, "substitutes": {"s": ["S", "aps", "sq", "p", "sym", "sa", "se", "ses", "ds", "f", "as", "is", "ss", "si", "b", "sis", "a", "n", "c", "spec", "ps", "sb", "o", "space", "ans", "services", "sh", "es", "ssl", "sp", "os", "sys", "t", "sf", "sl", "ns", "sg", "sv"], "type": ["typ", "part", "time", "ty", "shape", "class", "pe", "al", "p", "test", "prop", "block", "val", "name", "info", "f", "address", "app", "ip", "TYPE", "ype", "types", "pc", "art", "amp", "ar", "parent", "o", "error", "pt", "style", "format", "key", "ref", "pre", "py", "tp", "port", "pos", "data", "Type", "id", "null", "sp", "t", "list", "method", "op", "var"], "ret": ["part", "br", "att", "af", "match", "res", "rets", "al", "lit", "en", "code", "num", "cat", "rt", "val", "bit", "db", "let", "ft", "det", "status", "lt", "art", "pat", "mt", "bf", "RET", "len", "gt", "back", "red", "reg", "fun", "sb", "err", "nt", "result", "py", "ref", "out", "reply", "rc", "flag", "data", "re", "arr", "xt", "obj", "id", "alt", "Ret", "pet", "no", "all", "ext", "ann"], "arg": ["ace", "doc", "al", "p", "enc", "call", "arm", "ac", "ang", "val", "ax", "par", "au", "app", "Arg", "config", "pc", "art", "ak", "ar", "ag", "argument", "err", "play", "args", "mag", "or", "ref", "lang", "arp", "ass", "arc", "ann", "ig", "flag", "arr", "sp", "ad", "alt", "addr", "aj", "exec", "g", "inc", "op", "var"], "ap": ["cap", "att", "aps", "af", "pa", "hap", "jp", "p", "al", "ac", "AP", "an", "app", "as", "gap", "ep", "xml", "wa", "ak", "mp", "a", "amp", "apy", "ag", "ar", "ape", " AP", "ps", "bp", "ast", "ab", "av", "arp", "tp", "np", "api", "apt", "sp", " app", "list", "array", "map", "rep", " sp", "op", "ip"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155, "substitutes": {"opaque": ["oplonymous", "iopcus", "opec", " ophole", "ioponymous", "optaque", "oophole", " opivalent", "oopaque", "ophole", "optec", "optivalent", "hopaque", "oopivalent", "oopec", "opivalent", "oplaque", "hopcus", "hoponymous", "opcus", "oponymous", " opec", "oplcus", "opthole", "iopaque"], "offset": ["bound", "part", "timeout", "delay", "origin", "attribute", "alloc", "zero", "reset", "location", "pointer", "loc", "buffer", "type", "address", "length", "option", "config", "Offset", "online", "sample", "start", "exclusive", "fee", "seq", "padding", "align", "seed", "parent", "position", "base", "o", "slot", "entry", "action", "error", "alpha", "alias", "style", "range", "ref", "off", "command", "port", "initial", "pos", "data", "ptr", "i", "number", "server", "slice", "addr", "phase", "energy", "set", "prefix", "operation"], "size": [" bytes", "type", "address", "length", " error", "Size", " sizes", "len", "align", "SIZE", " length", "ize", "data", "bytes"], "s": ["states", "sets", "S", "sq", "ks", "rs", "secondary", "p", "sym", "ls", "aws", "sync", "site", "sa", "us", "ses", "ds", "f", "sim", "stats", "fs", "is", "si", "b", "ts", "ss", "its", "native", "n", "c", "spec", "sie", "hs", "o", "storage", "sb", "ps", "e", "cs", "sum", "service", "session", "u", "services", "d", "ops", "ssl", "shared", "gs", "su", "self", "sys", "conf", "t", "os", "sf", "server", "slice", "sl", "ns", "sg", "g", "sv", "js"], "index": ["element", "match", "x", "ion", "version", "row", "access", "block", "num", "pointer", "loc", "name", "type", "address", "length", "val", "start", "si", "len", "align", "position", "base", "action", "ind", "conn", "find", "key", "fix", "connection", "end", "connect", "weight", "pos", "input", "i", "id", "field", "number", "column", "Index", "level", "slice", "inc", "prefix"], "shift": ["timeout", "shape", "ix", "hift", "label", "carry", "balance", "use", "depth", "force", "load", "pack", "address", "length", "max", "start", "mask", "align", "power", "scale", "seed", "reverse", "throw", "transform", "Shift", "send", "range", "ind", "patch", "flow", "limit", "ctr", "dist", "sh", "show", "sup", "off", "pop", "weight", "pull", "diff", "pos", "sleep", "strip", "ptr", "pad", "field", "push", "sort", "slice", "mix", "set"], "count": ["Count", "part", "match", "text", "cache", "current", "call", "code", "cc", "num", "depth", "name", "cat", "carry", "type", "info", "length", "counter", "max", "coll", "start", "mask", "content", "len", "seq", "c", "base", "sum", "ind", "col", "batch", "found", "limit", "ref", "handle", "weight", "flag", "child", "id", "i", "allow", "array", "total", "list", "number", "all"], "value": ["example", "Value", "info", "valid", "volume", "device", "content", "seq", "dev", "range", "python", "vi", "function", "data", "null", "multi", "comment", "get", "version", "current", "num", "depth", "val", "name", "parent", "amount", "action", "format", "end", "summary", "weight", "model", "child", "memory", "gi", "home", "values", "element", "label", "length", "description", "media", "v", "error", "style", "service", "output", "instance", "member", "slave", "unit", "server", "image", "balance", "type", "VALUE", "response", "object", "document", "start", "native", "scale", "reg", "message", "result", "expression", "number", "feature", "this"], "lt_i": [" ref_slice", " seq_slice", " seq_i", " ref_int", " seq_ii", " ref_ii", " ref_i", " seq_int"]}}
{"project": "FFmpeg", "commit_id": "bb146bb57bea6647f9c080aa4f9323a3a789ad22", "target": 0, "func": "theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)\n\n{\n\n    struct ogg *ogg = ctx->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    struct theora_params *thp = os->private;\n\n    uint64_t iframe = gp >> thp->gpshift;\n\n    uint64_t pframe = gp & thp->gpmask;\n\n\n\n    if (thp->version < 0x030201)\n\n        iframe++;\n\n\n\n    if(!pframe)\n\n        os->pflags |= AV_PKT_FLAG_KEY;\n\n\n\n    if (dts)\n\n        *dts = iframe + pframe;\n\n\n\n    return iframe + pframe;\n\n}\n", "idx": 23159, "substitutes": {"ogg": ["gg", "gow", "gp", "ogo", "bb", "aud", "ogi", "go", "rog", "pg", "app", "ocr", "embed", "gd", "oc", "media", "owl", "ogs", "audio", "gram", "math", "stream", "ga", "pp", "ogl", "osc", "ppy", "hw", "window", "obb", "tz", "agg", "oper", "oss", "ob", "soc", "attr", "ott", "oga", "orm", "mpeg", "og", "ow", "pkg", "gz", "oci", "od", "omm", "obs", "argo"], "os": ["ok", "p", "linux", "css", "ds", "proc", "s", "object", "pc", "io", "oc", "so", "ss", "mac", "osi", "ps", "o", "bos", "obs", "cs", "osc", "conn", "boot", "oper", "oid", "oss", "et", "ops", "ob", "ips", "pos", "OS", "obj", "ott", "ost", "oa", "sys", "ow", "pkg", "dos", "ot", "od", "ns", "op", "ol"], "thp": ["ithlp", " thper", "plpc", "thper", "thpc", "ghpc", "plp", "Thp", "gha", "thanp", "Thpc", "ghper", "sthp", "uthpa", "thpa", "thlp", "uthp", "thos", "sthos", "THps", "Thpe", "Thf", " tha", "Thper", "sthnp", "THf", "thnp", "Tha", " thpc", "sthps", "thpe", "pllp", "thaos", "THp", " thos", "ithp", "uthlp", "ghp", "ithpc", " thnp", " thpe", "THpe", "uthpc", "Thps", "thap", " thf", "thps", " thps", "plpa", "ithpa", "thf", "tha", "thaps"], "iframe": ["zip", "ui", "image", "interface", "scroll", "gm", "isi", "gui", "gallery", "rame", "uca", "img", "pic", "frame", "proxy", "margin", "embed", "media", "gif", "border", "fee", "avi", "python", "pipe", "hw", "window", "fps", "py", "tif", "cm", "size", "plugin", "fi", "li", "mini", "video", "wrapper", "ctx", "movie", "zi", "gb", "multi", "ci", "fb", "episode", "slice", "include", "clip", "cam", "binary", "ip"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void av_build_index_raw(AVFormatContext *s)\n\n{\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    st = s->streams[0];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, s->data_offset, SEEK_SET);\n\n\n\n    for(;;) {\n\n        ret = av_read_frame(s, pkt);\n\n        if (ret < 0)\n\n            break;\n\n        if (pkt->stream_index == 0 && st->parser &&\n\n            (pkt->flags & PKT_FLAG_KEY)) {\n\n            add_index_entry(st, st->parser->frame_offset, pkt->dts, \n\n                            AVINDEX_KEYFRAME);\n\n        }\n\n        av_free_packet(pkt);\n\n    }\n\n}\n", "idx": 23161, "substitutes": {"s": ["settings", "sts", "sets", "sq", "S", "south", "rs", "p", "ls", "less", "sync", "site", "sa", "se", "us", "bis", "ses", "an", "f", "aus", "request", "fs", "is", "b", "ss", "v", "a", "n", "c", "spec", "ps", "sb", "storage", "e", "cs", "r", "args", "service", "session", "u", "qs", "parts", "services", "es", "d", "ops", "in", "ssl", "data", "gs", "ctx", "su", "os", "m", "sys", "t", "i", "sf", "self", "server", "socket", "context", "g", "ns", "sg", "sl", "sv", "set", "js"], "pkt1": ["Pkt1", "pKT0", "pk1", " pkt0", "pkt3", "pqt0", "pk0", "pct3", "Packet0", "pKT2", "pkg3", "pct0", "pKT1", "pkt0", " pct0", "Pkt0", "pkg0", " pkt3", "Pkt2", "packet2", "pkg1", "pqt3", " pct1", "Packet2", "Packet1", "packet1", "pk2", "pkt2", "pct1", "pqt1", " pct3", "packet0"], "pkt": ["Pkg", " packet", " pet", "paacket", " pkg", "perkg", "packet", "Pct", "pnt", "pernt", "Pkt", "pakg", "cpkt", "cpct", "cpacket", "apnt", "cpnt", "apct", "apacket", "Packet", " pct", "perkt", "pant", "cpkg", "pakt", "cpet", "Pnt", "Pet", "pkg", "peracket", "pct", "pet", "apkt", " pnt"], "ret": ["att", "ur", "match", "iter", "res", "rets", "al", "en", "lit", "cat", "num", "rt", "val", " Ret", "ft", "det", "valid", "pat", "art", "sr", "mt", "bf", "pass", "ut", "RET", "len", "back", "fun", "reg", "ver", "nt", "result", "ref", "str", " RET", "reply", "rc", "flag", "re", "arr", "alt", "arg", "fin", "success", "Ret", "addr", "pet"], "st": ["kt", "sts", "inst", "ace", "stage", "src", "step", "sa", "se", "ft", "ST", "art", "start", "St", "sc", "ts", "ss", "ct", "sth", "rest", "stream", "sw", "sb", "pt", "ast", "r", "sta", "nt", "std", "sh", "str", "et", "est", "ist", "ost", "sp", "sd", "t", "sl", "ld", "ste", "sn"]}}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163, "substitutes": {"fw_cfg": ["fdthegui", "fwxfg", "nw_bg", "fwersettings", "fdthegeneral", "fwxcfg", "cf_gate", "fw_gd", "fw25general", "cf_config", "wk_cf", "fwthegeneral", "rw_cf", "fwfdc", "wk_cfg", "work_cb", "fwappcfg", "fw_gen", "cf_cf", "fwthecf", "fw_gate", "workfconn", "fdthecf", "cf_gen", "fx_forge", "fwappbg", "workfdc", "fwappfg", "rw_dc", "fwfcb", "fw25cfg", "wk_fg", "fx_cfg", "fwxcgi", "rw_cfg", "rw_conn", "fw_settings", "fw_cf", "fd_general", "fwergeneral", "fd_cfg", "fx_settings", "nw_gd", "cf_cfg", "nw_cfg", "fw_config", "fw_cgi", "fx_general", "fwxgd", "fw_conn", "fwtheforge", "wk_conn", "workfcb", "fw_dc", "fwthesettings", "work_cfg", "fw_bg", "workfcfg", "work_dc", "rw_fg", "fdthecfg", "rw_cb", "fw__fg", "fw_general", "fw25gui", "cf_conn", "fwthecfg", "fwercfg", "fw__bg", "fw25cf", "fwthegui", "work_conn", "fw_cb", "fd_cf", "cf_fg", "fwerforge", "fw_fg", "nw_fg", "fd_gui", "fw__gd", "fwfcfg", "fw_forge", "nw_cgi", "fw__cfg", "fwappgd", "fw_gui", "fwfconn"], "smbios_tables": ["smbios_tubs", "smbios_entamps", "smbios_contees", "smbios_ontabs", "smbios_Tributes", "smbios_tries", "smbios_tenrees", "smbios_stributes", "smbios_ontable", "smbios_tamps", "smbios_ttubs", "smbios_entables", "smbios_entries", "smbios_ttamps", "smbios_stables", "smbios_stries", "smbios_nables", "smbios_lrees", "smbios_untees", "smbios_temrees", "smbios_ftras", "smbios_untable", "smbios_ptrees", "smbios_temasks", "smbios_contables", "smbios_tees", "smbios_tasks", "smbios_nributes", "smbios_tributes", "smbios_tenables", "smbios_untabs", "smbios_ftipes", "smbios_temables", "smbios_bables", "smbios_ontables", "smbios_Tipes", "smbios_tipes", "smbios_tabs", "smbios_tenipes", "smbios_ptigs", "smbios_temipes", "smbios_brees", "smbios_stigs", "smbios_lasks", "smbios_testubs", "smbios_nries", "smbios_Tries", "smbios_Tigs", "smbios_contabs", "smbios_temests", "smbios_temigs", "smbios_tenras", "smbios_Tables", "smbios_tigs", "smbios_testables", "smbios_bests", "smbios_tenests", "smbios_contable", "smbios_lables", "smbios_ptasks", "smbios_ligs", "smbios_entubs", "smbios_ttries", "smbios_ttables", "smbios_testamps", "smbios_tras", "smbios_ptables", "smbios_trees", "smbios_ontees", "smbios_untables", "smbios_Tras", "smbios_ftables", "smbios_nigs", "smbios_testries", "smbios_tenributes", "smbios_tests", "smbios_ftributes", "smbios_bipes", "smbios_table"], "smbios_anchor": ["smbios_minor", "smbios_extor", "smbios_minore", "smbios_anchore", "smbios_actor", "smbios_ancore", "smbios_adaptor", "smbios_annorer", "smbios_archuser", "smbios_chor", "smbios_cher", "smbios_gateors", "smbios_anchors", "smbios_archer", "smbios_gateor", "smbios_actation", "smbios_extation", "smbios_adapter", "smbios_ancor", "smbios_annore", "smbios_annor", "smbios_anchOR", "smbios_chuser", "smbios_annors", "smbios_anchuser", "smbios_actore", "smbios_anchorer", "smbios_chorer", "smbios_extore", "smbios_minors", "smbios_gateOR", "smbios_archor", "smbios_extors", "smbios_ancher", "smbios_ancorer", "smbios_chOR", "smbios_ancors", "smbios_minOR", "smbios_chation", "smbios_archors", "smbios_chors", "smbios_gateore", "smbios_adaptors", "smbios_adaptuser", "smbios_anchation", "smbios_chore", "smbios_actors"], "smbios_tables_len": ["smbios_tablessel", "smbios_tipes_len", "smbios_tributes_rev", "smbios_tables__length", "smbios_tributes_Len", "smbios_tables__len", "smbios_tipes_Len", "smbios_tributes_length", "smbios_tables_part", "smbios_tipes_lon", "smbios_tributes_part", "smbios_tables_rev", "smbios_tables_el", "smbios_tables___len", "smbios_tributes_len", "smbios_tablesspart", "smbios_tables_lon", "smbios_tables_length", "smbios_tipes_en", "smbios_tables__Len", "smbios_tables_Len", "smbios_tables___length", "smbios_tables___Len", "smbios_tipes_seq", "smbios_tipes_length", "smbios_tables_en", "smbios_tablesslen", "smbios_tables__seq", "smbios_tables_seq", "smbios_tributes_el", "smbios_tables___lon", "smbios_tablesslength"], "smbios_anchor_len": ["smbios_anchr_len", "smbios_anchr_Len", "smbios_anchor_val", "smbios_anchr_lon", "smbios_anchore_length", "smbios_anchore_len", "smbios_anchor_length", "smbios_anchore_name", "smbios_anchore_l", "smbios_anchore_val", "smbios_anchr_length", "smbios_anchor_l", "smbios_anchore_Len", "smbios_anchor_lon", "smbios_anchor_Len", "smbios_anchor_name"], "numa_fw_cfg": ["numa_fw_cgi", "numa_FW_cgi", "numa_FW_conf", "numa_fw_config", "numa_FW_cfg", "numa_fw_conf", "numa_FW_config"], "i": ["ii", "ui", "x", "I", "p", "f", "ni", "is", "io", "v", "a", "n", "index", "c", "o", "y", "r", "l", "u", "d", "iu", "id", "ci", "t", "it", "ip"], "j": ["ji", "ii", "jp", "p", "f", "q", "b", "v", "len", "n", "o", "l", "r", "ij", "uni", "ne", "pos", "J", "job", "k", "m", "aj", "g", "z"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23174, "substitutes": {"env": ["iv", "console", "ev", "iss", "oe", "esi", "ec", "event", "eni", "en", "enc", "ea", "code", "que", "db", "etr", "ef", "config", "eng", "chal", "net", "equ", "enh", "ep", "vm", "init", "v", "exc", "here", "ench", " environment", "e", "enable", "osc", "engine", "conn", "erv", "et", "viron", "Environment", "np", "scope", "environment", "ctx", "eu", "org", "conf", "fg", "txt", "esp", "er", "server", "eas", "context", "exec", "loader", "enter", "energy", "qt", "ext"], "vaddr": ["vconfig", "ovattr", "vcaddr", "wdc", "vaddress", "vord", "vhost", "ovaddress", "ervattr", "bdr", " vconfig", " vaddress", "bptr", "ervaddress", "baddress", "whost", "word", " vord", "hconfig", " vattr", "wattr", " vhost", "haddress", "vdr", " vdr", "venter", "ovaddr", "wptr", "wdr", "rdc", "wenter", "pptr", "hattr", "baddr", "waddr", "paddress", "ervaddr", "ervconfig", "rhost", " venter", "vcattr", "haddr", "vattr", "oventer", "vcaddress", "rptr", "waddress", "vptr", "paddr", " vptr", "vcord", " vdc", "vdc", "raddress"], "rw": ["ww", "w", "wb", "rs", "row", "tw", "rss", "ro", "ru", "sr", "rx", "rh", "wa", "wal", "RW", "wr", "wn", "raw", "wx", "kw", "sw", "fw", "wh", "wheel", "rr", "nr", "ew", "r", "hw", "nw", "rd", "usr", "wrap", "rn", "wcs", "rc", "rf", "ow", "walker", "rew", "work", "rec", "wd", "wo", "rus", "rl", "wu", "wp", "rb", "rg", "rack"], "asc": ["desc", "rank", "stage", "cl", "alloc", "src", "lc", "ra", "acl", "arch", "ac", "isc", "rss", "all", "rev", "rar", "proc", "as", "pc", "uc", "ru", "irc", "anc", "sc", "oc", "ss", "up", "fc", "asm", "raw", "scale", "reverse", "alpha", "acc", "auc", "ase", "prev", "rac", "ctr", "ASC", "esc", "bc", "attr", "rc", "abc", "SC", "inc", "rec"], "raddr": [" rsta", "mhost", "ruaddr", "vpad", "hraddr", "rradder", "vmac", "vloc", "craddress", "rrsta", "baddr", "vadder", "hraddress", " rpad", "Raddr", "rdr", "nraddr", "rroute", "rpad", "srpad", "rsta", "caddr", "vaddress", "ruadder", "bptr", "srhop", "vroute", "mptr", "rraddress", "clayer", "srsta", "vdr", " rroute", " rhop", "srdr", "crpad", "nraddress", "rloc", "craddr", "Rptr", "vhop", "vlayer", "baddress", "crlayer", "radder", "srptr", "hrlayer", " raddress", "rusta", "bsta", "raddress", "rptr", "sraddress", "rlayer", "nrroute", "rraddr", " rptr", "vhost", "maddr", "rhop", " rlayer", " rloc", "caddress", "srloc", "vsta", "maddress", " rmac", "rhost", "sraddr", "chop", "ruaddress", " rdr", "Rhost", "vptr", "rmac", "srlayer", "rrpad", "hrhop", "rrmac", "Raddress"], "flags": ["lists", " Flags", "f", "words", "planes", "links", "opens", "utils", "feat", "bits", "errors", "vals", "details", "ops", "caps", "requires", "atts", "tops", "FLAG", "tracks", "plugins", "fields", "vs", "items", "dds", "acks", "bytes", "dates", "rets", "options", "lf", "reads", "rights", "types", "rows", "versions", "runs", "faces", "strings", "works", "fw", "checks", "lag", "fl", "ils", "args", "fd", "ips", "comments", "flag", "cons", "properties", "alls", "states", "lines", "forces", "ats", "inks", "lights", "flows", "stats", "pages", "ants", "offs", "files", "mods", "styles", "rules", "Flags", "orts", "groups", "posts", "fx", "settings", "rs", "allows", "fs", "members", "sw", "nl", "locks", "includes", "wcs", "features", "ags", "quarters"], "sk": ["ace", "ek", "ok", "kid", "ks", "SK", "ask", "sky", "call", "se", "nn", "cost", "q", "cr", "ep", "ski", "sc", "ss", "mask", "ak", "pp", "ki", "hop", "sw", "c", "ke", "uk", "ck", "ork", "cs", "kr", "ch", "key", "sh", "can", "ink", "ka", "sch", "cp", "kk", "k", "dk", "sp", "ik", "work", "push", "sf", "kn", "vs", "sl", "spec", "Sk", "K", "sn"]}}
{"project": "FFmpeg", "commit_id": "dbc1163b203b175d246b7454c32ac176f84006d1", "target": 0, "func": "static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,\n\n                                   int blocks_per_slice,\n\n                                   int plane_size_factor,\n\n                                   const uint8_t *scan)\n\n{\n\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n\n    int max_coeffs, bits_left;\n\n\n\n    /* set initial prediction values */\n\n    run   = 4;\n\n    level = 2;\n\n\n\n    max_coeffs = blocks_per_slice << 6;\n\n    block_mask = blocks_per_slice - 1;\n\n\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n\n        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];\n\n        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return 0;\n\n\n\n        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);\n\n        if (run < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        level = decode_vlc_codeword(gb, ff_prores_ac_codebook[lev_cb_index]) + 1;\n\n        if (level < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        pos += run + 1;\n\n        if (pos >= max_coeffs)\n\n            break;\n\n\n\n        sign = get_sbits(gb, 1);\n\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n\n            (level ^ sign) - sign;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23184, "substitutes": {"gb": ["bm", "cfg", "gg", "tg", "gp", "gc", "gm", "src", "bb", "gy", "bo", "ge", "gam", "buff", "db", "ds", "gnu", "bg", "nb", "gal", "bf", "gd", "che", "b", "gin", "gu", "ges", "game", "gram", "cod", "GB", "ga", "cb", "sb", "storage", "gru", "cgi", "kb", "hub", "py", "bc", "rc", "ig", "phy", "usb", "gs", "ctx", "ci", "abb", "gz", "bn", "ged", "vg", "gio", "lib", "gi", "eb", "g", "sg", "binary", "rb", "rg"], "out": ["params", "image", "line", "cache", "sync", "pin", "img", "buffer", "process", "ret", "pass", "cmd", "io", "b", "gin", "up", "parent", "err", "Out", "again", "OUT", "o", "serv", "batch", "result", "byte", "boot", "output", "source", "copy", "can", "op", "outs", "in", "attr", "strip", "array", "lib", "group", "inc", "prefix", "new", "ann"], "blocks_per_slice": ["blocks_per\u05bcscale", "blocks_per_zone", "blocks_per_scale", "blocks_per_side", "blocks_per_shape", "blocks_per_region", "blocks_per_pixel", "blocks_per\u05bcslice", "blocks_pre_slice", "blocks_per_edge", "blocks_per\u05bccase", "blocks_per_layer", "blocks_per_case", "blocks_per\u05bcside", "blocks_pre_pixel", "blocks_pre_scale", "blocks_pre_shape"], "plane_size_factor": ["plane_size_sector", "plane_unit_factor", "plane_size__fact", "plane_size__factor", "plane_size64factor", "plane_size32factor", "plane_size32flag", "plane_unit__fact", "plane_size_fact", "plane_unit__sector", "plane_size__sector", "plane_size64digit", "plane_unit__factor", "plane_size_limit", "plane_unit_fact", "plane_unit_digit", "plane_size_digit", "plane_unit__digit", "plane_size_flag", "plane_unit_sector", "plane_size64sector", "plane_size__digit", "plane_size64fact", "plane_size32limit"], "scan": ["parse", "row", "call", "nan", "sync", "pin", "block", "cat", "nn", "stat", "ignore", "sc", "mask", "win", "pan", "gram", "align", "bin", "con", "ga", "scale", "sub", "store", "range", "sum", "search", "chan", "query", "gate", "can", "gen", "read", "split", "sys", "Scan", "slice", "skip", "feature", "look", "cell", "ann"], "pos": ["po", "neg", "part", "z", " position", "x", "cache", "p", "pr", "pose", "pid", "block", "depth", "offset", "val", "loc", "POS", "j", "config", "start", "order", "rupt", "pass", "win", "len", "n", "index", "seq", "lat", "pro", "position", "ps", "base", "o", " positions", "pt", "ind", "min", "pre", "ass", "off", "cond", "post", "pl", "port", "size", "diff", "coord", "data", "d", "Pos", "unit", "i", "os", "su", "push", "id", "slice", "un", "no", "spec", "pres"], "block_mask": ["blockacmask", "block\u00b7key", "block\u00b7patch", "run_pack", "word_mask", "word_clean", "block_count", "blockingmask", "block__sum", "block64label", "run64label", "run_label", "block_pack", "block_patch", "block64mask", "block2mask", "run64pack", "block2patch", "run_depth", "bit_mask", "block_clean", "block_depth", "blockaclabel", "run64depth", "block2key", "bit_key", "word__sum", "blockacpack", "block64depth", "run_mask", "blockacdepth", "word__clean", "block_sum", "word_count", "word__count", "block64pack", "blockinglabel", "blockingdepth", "block_label", "block\u00b7mask", "block__mask", "blockingpack", "block__clean", "word_sum", "bit_patch", "word__mask", "block__count", "run64mask", "block_key"], "run": ["ran", "loop", "zip", "update", "man", "rank", "line", "runner", "version", "round", "step", "row", "call", "block", "use", "num", "date", "depth", "name", "nn", "go", "type", "year", "config", "ru", "order", "runs", "pass", "running", "lock", "win", "dir", "trial", "n", "index", "thread", "position", "fun", "reg", "range", "ind", "day", "min", "r", "play", "plot", "clean", "node", "model", "job", "unit", "su", "id", "work", "sort", "un", "record", "group", "add", "tag", "Run", "exec"], "level": ["line", "lc", "low", "le", "order", "roll", "min", "key", "pull", "count", "lvl", "la", "loop", "stage", "cl", "pe", "row", "call", "lev", "depth", "val", "loc", "fail", "year", "dir", "len", "index", "parent", "clean", "pl", "model", "child", "levels", "round", "lin", "local", "mode", "length", "pass", "win", "rel", "build", "style", "l", "limit", "letter", "scope", "vel", "unit", "keep", "file", "Level", "zip", "full", "ul", "block", "code", "rol", "type", "coll", "sol", "lock", "vol", "scale", "position", "where", "play", "col", "show", "layer", "lo", "tag", "inc"], "sign": ["z", "shape", "close", "version", "ix", "round", "ask", "step", "call", "SIGN", "se", "plus", "name", "loc", "type", "pack", "max", "pass", "secret", "ss", "sc", "mask", "win", "pen", "ign", "index", "scale", "sub", "mod", "sum", "ind", "min", "clean", "sk", "dig", "value", "size", "vis", "connect", "gen", "Sign", "weight", "diff", "pull", "side", "gn", "shift", "id", "sort", "skip", "act", "tag", "spec", "inc", "save", "ann"], "run_cb_index": ["run_cb_slice", "run_bc_index", "run_cbsindex", "run_seq_type", "run_cbPlevel", "run_seq_index", "run_cod_id", "run_cod_index", "run_cbsaddress", "run_cbPoffset", "run_cb_offset", "run_cb_type", "run_cb_Index", "run_cbPid", "run_cbPindex", "run_cbstype", "run_cb_level", "run_bc_count", "run_cod_level", "run_cb_id", "run_cb_address", "run_seq_address", "run_bc_Index", "run_cbsslice", "run_seq_slice", "run_cb_count", "run_cod_offset"], "lev_cb_index": ["lev_cod_Index", "lev_cb_Index", "lev_cbsid", "lev_cb_slice", "lev_cbbpart", "lev_nb_block", "lev_cbockblock", "lev_cbendlist", "lev_nb_index", "lev_cbrsize", "lev_cod_list", "lev_cod_index", "lev_db_slice", "lev_cbrblock", "lev_cbrindex", "lev_db_part", "lev_cb_part", "lev_cbocknode", "lev_cbockindex", "lev_nb_node", "lev_cbendIndex", "lev_cb_list", "lev_cbbindex", "lev_db_index", "lev_cbbid", "lev_db_id", "lev_cbspart", "lev_cb_size", "lev_cb_id", "lev_cbsindex", "lev_cb_node", "lev_cb_image", "lev_cbocksize", "lev_nb_size", "lev_cbbslice", "lev_cbsslice", "lev_cbendindex", "lev_cb_block", "lev_cbendimage", "lev_cod_image", "lev_cbrnode"], "max_coeffs": ["max_coeffes", "max_coefes", "max_coEFFes", "max_coffp", "max_coefficientss", "max_COeffs", "max_coeffi", "max_coeffd", "max_COeffd", "max_COffp", "max_COeffp", "max_coefits", "max_coefd", "max_COffs", "max_coefp", "max_coEFFs", "max_coffits", "max_coEFFits", "max_coefficienti", "max_COffits", "max_COeffi", "max_COffd", "max_coefficientsits", "max_coefs", "max_coffd", "max_coefficientsi", "max_coffs", "max_coEFFi", "max_coEFFd", "max_coefficientits", "max_coffi", "max_coffes", "max_coeffp", "max_COeffits", "max_coefficients", "max_coefi", "max_COffi", "max_coefficientsp", "max_coeffits", "max_coefficientd"], "bits_left": ["its_right", "bitsNplus", "ports_leave", "bitsSright", "bytes_none", "bits___pull", "bitsNbottom", "bits_lost", "boxes_la", "bitsNleft", "bits8left", "bits_log", "cuts_path", "cutsPpath", "bitsSavailable", "topsSright", "bits0none", "bitslenlost", "bits_none", "topsSlimit", "bits8right", "cuts_plus", " bits_ignore", "bitslenlog", " bits_log", "bytes_left", "topsSleft", "cuts_left", "bits64left", "bitsPpath", "bits_plus", "bits_path", "boxes___pull", "boxes_pull", "blocks_left", "tops_left", "boxes___la", "bitslenleft", "tops_available", "bits_available", "bits_2", "its_joined", "bits8free", "bits_off", "its_free", "cutsPbottom", "bits8joined", "bits___la", "bits_limit", "bitsSleft", "bits___free", "boxes_left", "bitsNpath", "bits64leave", "tops_right", "cutsPleft", "tops_limit", " bits_leave", "cutsPplus", "bits_l", "bits_loaded", "topsSavailable", "bitsSlimit", "blocks_2", "bits_joined", "boxes_down", "bits_ignore", "bits_bottom", "ports_loaded", "bits_pull", "bits_leave", "bits___left", "bits0left", "bits_down", "bitsPleft", "boxes___down", "its_left", "bits_right", " bits_lost", "ports_left", "bytes_right", "bits___down", "bitsPbottom", "bits_default", "bits___joined", "cuts_bottom", "bitsPplus", "bitslendefault", "bits64ignore", "bits64right", "bits0right", "bits_la", " bits_right", " bits_default", "blocks_l", "boxes___left", "bits_free", "blocks_right", "ports_off", "bits___right"]}}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}", "idx": 23186, "substitutes": {"ctx": ["mc", "cf", "gc", "xc", "alloc", "jp", "lc", "src", "linux", "buff", "loc", "config", "coll", "Context", "anc", "sc", "lex", "ux", "c", "fw", "utils", "buf", "ca", "cas", "cs", "tx", "conn", "aux", "hw", "fp", "cm", "conv", "bc", "cp", "tc", "rc", "cca", "ci", "pkg", "grad", "cmp", "context", "exec"], "fs_path": ["fs1path", " fs_text", "fs1text", "fs1prop", "fs_part", " fs_parent", "fs67path", "fs67text", " fs_prop", "fs_parent", "fs67prop", " fs_Path", "fs_text", "fs_prop", " fs_part", " fs1prop", "fs1part", "fs_Path", "fs67part", " fs1part", " fs1text", " fs1path"], "fs": ["cf", "states", "ks", "flags", "cache", "aws", "linux", "lf", "ds", "f", "irs", "flows", "feed", "ss", "fc", "files", "df", "fw", "acs", "utils", "ps", "cs", "ils", "fd", "args", "fp", "Fs", "qs", "vals", "FS", "raf", "ops", "self", "os", "sys", "fb", "sf", "bs", "vs", "ns", "ls", "obs"], "dirfd": ["dirFD", " dird", "fdd", "directoryfd", "foldersd", " dirf", "dirpd", "drfd", " dirdir", "dnpd", "dirfn", "drawdf", "DIRFD", "drawfd", "DIRdf", "directoryf", " directoryFD", "dirflow", "directoryFD", " dirflow", "drf", " directoryflow", " directoryfd", "DIRfn", "drpd", "dnf", "drawfn", "drdir", " directoryf", "directoryflow", "drawFD", "DIRfd", "folderfd", "dirsd", "dirdir", " dirfn", "dirf", "dndir", " dirdf", "fdfd", "fdf", " dirsd", " dirpd", "dird", "fdsd", "folderf", "dnfd", "folderd", " dirFD", "dirdf"], "stream": ["channel", "zip", "through", "stage", "ev", "src", "host", "forward", "draft", "plus", "type", "public", "length", "f", "object", "driver", "coll", "feed", "content", "filter", "dir", "raw", "view", "sw", "transform", "unk", "wh", "path", "entry", "pipe", "handler", "draw", "fd", "clean", "cloud", "source", "dd", "port", "upload", "progress", "model", "hold", "wrapper", "data", "input", "seek", "reader", "Stream", "form", "live", "iterator", "follow", "speed", "client", "open", "level", "file", "context", "sl", "resource", "pool"]}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, ac3_id;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd = (ctx->oformat == &mpeg1vcd_mux);\n\n    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_mux);\n\n    \n\n    if (s->is_vcd)\n\n        s->packet_size = 2324; /* VCD packet size */\n\n    else\n\n        s->packet_size = 2048;\n\n        \n\n    /* startcode(4) + length(2) + flags(1) */\n\n    s->packet_data_max_size = s->packet_size - 7;\n\n    if (s->is_mpeg2)\n\n        s->packet_data_max_size -= 2;\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n    mpa_id = AUDIO_ID;\n\n    ac3_id = 0x80;\n\n    mpv_id = VIDEO_ID;\n\n    s->scr_stream_index = -1;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        switch(st->codec.codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if (st->codec.codec_id == CODEC_ID_AC3)\n\n                stream->id = ac3_id++;\n\n            else\n\n                stream->id = mpa_id++;\n\n            stream->max_buffer_size = 4 * 1024; \n\n            s->audio_bound++;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            /* by default, video is used for the SCR computation */\n\n            if (s->scr_stream_index == -1)\n\n                s->scr_stream_index = i;\n\n            stream->id = mpv_id++;\n\n            stream->max_buffer_size = 46 * 1024; \n\n            s->video_bound++;\n\n            break;\n\n        default:\n\n            av_abort();\n\n        }\n\n    }\n\n    /* if no SCR, use first stream (audio) */\n\n    if (s->scr_stream_index == -1)\n\n        s->scr_stream_index = 0;\n\n\n\n    /* we increase slightly the bitrate to take into account the\n\n       headers. XXX: compute it exactly */\n\n    bitrate = 2000;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        bitrate += st->codec.bit_rate;\n\n    }\n\n    s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n    \n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n       s->pack_header_freq = 1;\n\n    \n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* every 40 packets, this is my invention */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n    \n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        stream->buffer_ptr = 0;\n\n        stream->packet_number = 0;\n\n        stream->start_pts = AV_NOPTS_VALUE;\n\n        stream->start_dts = AV_NOPTS_VALUE;\n\n    }\n\n    s->last_scr = 0;\n\n    return 0;\n\n fail:\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        av_free(ctx->streams[i]->priv_data);\n\n    }\n\n    return -ENOMEM;\n\n}\n", "idx": 23193, "substitutes": {"ctx": ["cf", "kt", "cms", "sq", "ks", "cl", "gc", "www", "cv", "xc", "jp", "cu", "lc", "sync", "cc", "co", "loc", "cli", "config", "cus", "sci", "coll", "pc", "xs", "Context", "anc", "sc", "media", "ct", "kw", "wx", "c", "ck", "ca", "cas", "cb", "cs", "tx", "conn", "kb", "fp", "hw", "qs", "cm", "conv", "wcs", "bc", "cp", "tc", "rc", "cca", "gs", "vc", "cpp", "ci", "conf", "pkg", "cmp", "ctrl", "client", "nc", "context", "cam", "cn", "wp", "qt"], "s": ["ins", "south", "p", "us", "se", "f", "si", "sb", "storage", "cs", "sk", "u", "ops", "gs", "conf", "bs", "vs", "spec", "sv", "aws", "sa", "ses", "ds", "xs", "is", "b", "ts", "n", "ps", "hs", "e", "ing", "services", "ans", "sup", "os", "set", "rates", "sts", "S", "ks", "h", "sym", "ings", "its", "v", "c", "ys", "l", "r", "service", "qs", "es", "m", "sys", "t", "client", "server", "sl", "g", "settings", "sets", "sq", "rs", "sync", "als", "fs", "ss", "o", "session", "d", "ssl", "su", "self", "sf", "ns", "ls", "sg", "ms", "js"], "bitrate": ["bitrates", "BITration", " bitRate", "wordrates", "audRate", "BITrate", " bitration", "Bitrate", "audrate", "BITrates", " bitrates", "audrates", "wordration", "wordrate", "bitration", "bitRate", "Bitrates", "BitRate"], "i": ["ti", "ii", "ui", "abi", "ji", "qi", "image", "jit", "x", "I", "ix", "p", "eni", "lc", "h", "phi", "di", "ri", "type", "j", "f", "ai", "info", "ret", "ini", "ie", "ni", "start", "im", "si", "io", "v", "pi", "uri", "index", "n", "c", "e", "ind", "y", "l", "ij", "adi", "xi", "u", "key", "yi", "chi", "inner", "fi", "li", "mini", "iu", "in", "hi", "id", "m", "ci", "mi", "multi", "t", "slice", "gi", "z", "bi", "it", "ip"], "mpa_id": ["mpa67id", "mpp__size", "mpv_path", "mpa__id", "mpada67id", "mpada_id", "mpa_uid", "mpa67ids", "mpa67uid", "mpp__ids", "mpv_uid", "mpa__pid", "mpp_name", "mpp__name", "mpada_uid", "mpa__size", "mpa67pid", "mpada67pid", "mpa__ids", "mpa_pid", "mpp_id", "mpv_oid", "mpada67ids", "mpp_ids", "mpa__name", "mpp_size", "mpada_ids", "mpa_ids", "mpada_pid", "mpa_oid", "mpa_name", "mpa_path", "mpa__uid", "mpa_size", "mpada67uid", "mpp__id"], "mpv_id": ["mpvrockmid", "mpvrockpid", "mpv_pid", "mpvapptype", "mpv_mid", "mpvockid", "mpvocktype", "mpvockpid", "mpv2id", "mpv_name", "mpvr_pid", "mpov_type", "mpvappindex", "mpf_id", "mpov_i", "mpf_ip", "mpvr_type", "mpv2kid", "mpov_id", "mpf_kid", "mpv_i", "mpv2ip", "mpvappi", "mpvappid", "mpv_type", "mpvockmid", "mpv2name", "mpvrockid", "mpv_kid", "mpvr_id", "mpov_index", "mpf_name", "mpvr_mid", "mpv_ip", "mpvrocktype", "mpv_index"], "ac3_id": ["ac3sname", "acd_id", "ac3_ids", "ac3_pid", "ac3_path", "acd_num", "ac63_id", "ac3ssid", "acd_sid", "ac3_num", "ac63_sid", "ac3sid", "ac3snum", "ac63_ids", "acd_pid", "ac63_path", "ac3_name", "ac3_sid", "acd_name", "acd_type", "ac3_type"], "st": ["nd", "inst", "sts", "steam", "stage", "cl", "src", "p", "step", "fe", "stack", "sa", "ft", "td", "ST", "fr", "start", "St", "ss", "sc", "ts", "v", "ct", "bl", "a", "sth", "rest", "sw", "stop", "sb", "pt", "ast", "sta", "sk", "std", "dest", "str", "sv", "d", "est", "ist", "ost", "sp", "sd", "t", "sf", "trans", "sl", "ste", "sn"], "stream": ["f", "valid", "ack", "ream", "filter", "view", "user", "source", "tr", "upload", "progress", "data", "form", "put", "steam", "iv", "stage", "src", "event", "stack", "row", "public", "sc", "back", "fd", "model", "child", "input", "Stream", "slice", "resource", "rec", "channel", "console", "w", "round", "enc", "draft", "length", "uc", "feed", "temp", "thread", "draw", "output", "instance", "wrapper", "live", "client", "server", "record", "file", "g", "sl", "pool", "image", "sync", "load", "response", "object", "coll", "document", "bl", "body", "track", "flash", "sw", "path", "engine", "result", "post", "port", "video", "ssl", "reader", "trans"], "audio_bound": ["audio_position", "audio64position", "audiolexBound", "video_cond", "audio__limit", "audio_limit", "audio64bound", "image_bound", "video_Bound", "audio_bind", "image_position", "audio64Bound", "image_limit", "audiolexbind", "audiolexbound", "video_bind", "audiolexcond", "audio__Bound", "audio__position", "audio_cond", "image_Bound", "audio__bound", "audio_Bound", "audio64limit"], "video_bound": ["video_count", "media_limit", "videoloffset", "video_order", "video_weight", "videolorder", "video_offset", "videolbound", "media_weight", "video_limit", "media_bound", "audio_order", "media_count", "audio_offset"]}}
{"project": "FFmpeg", "commit_id": "d7da4d47a6841444f12bf56dfe4230d3e4af8646", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n    int ret;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n    mxf->edit_units_per_packet = 1;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!url_feof(s->pb)) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n\n\n            if (!mxf->current_partition) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            if (!mxf->current_partition->essence_offset) {\n\n                /* for OP1a we compute essence_offset\n\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n\n                 */\n\n                int64_t op1a_essence_offset =\n\n                    round_to_kag(mxf->current_partition->this_partition +\n\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n\n\n                if (mxf->op == OPAtom) {\n\n                    /* point essence_offset to the actual data\n\n                    * OPAtom has all the essence in one big KLV\n\n                    */\n\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n\n                    mxf->current_partition->essence_length = klv.length;\n\n                } else {\n\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n\n                }\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else if (mxf->parsing_backward)\n\n                continue;\n\n            /* we're still parsing forward. proceed to parsing this partition pack */\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n\n\n                    /* only seek forward, else this can loop for a long time */\n\n                    if (avio_tell(s->pb) > next) {\n\n                        av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n\n                               klv.offset);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    /* we need to do this before computing the index tables\n\n     * to be able to fill in zero IndexDurations with st->duration */\n\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n\n        return ret;\n\n\n\n    if (mxf->nb_index_tables > 1) {\n\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    mxf_handle_small_eubc(s);\n\n\n\n    return 0;\n\n}\n", "idx": 23206, "substitutes": {"s": ["south", "secondary", "p", "us", "se", "f", "si", "sb", "storage", "com", "cs", "source", "ops", "gs", "i", "conf", "spec", "sv", "aws", "ses", "ds", "xs", "is", "b", "sc", "ts", "n", "e", "services", "os", "serv", "S", "sym", "site", "sci", "stats", "v", "c", "r", "l", "service", "qs", "es", "m", "sys", "t", "client", "server", "sl", "g", "new", "single", "settings", "sets", "sq", "rs", "sync", "sg", "http", "fs", "ss", "native", "o", "session", "d", "ssl", "su", "sf", "ns", "ls", "sec", "js"], "mxf": [" mxa", "gxe", "dxf", " mcf", "mfc", "mxe", "cmcf", "dxe", "mcf", "Mxc", "Mxf", "cmxd", "nfc", "cmxf", "ncf", "pxf", "gxd", "dxd", "fmxe", "nxc", "pxc", "dxc", "cmxe", "Mxe", "fmcf", "cmxc", "nxf", "fmxf", "Mxd", "Mfc", " mxe", "dcf", "mxd", "mxa", " mxc", "nxe", "gxf", "Mcf", "nxd", "mxc", "fmxd", " mxd", "nxa", "cmfc", "gxc", "pxd", "pcf", "fmxc", "Mxa", " mfc"], "klv": ["kevi", "sklp", "okwl", "Klf", "kvl", "knvi", "uklv", "keLV", "ksll", "kwl", "mrl", "Kln", "skla", "kswl", "sklf", "kelp", "knlp", "kql", "skvc", "knla", " kll", "kevc", "okLV", "kelv", "ukvl", "iklv", "oklv", " kvl", "Kvm", "ikvl", "okvm", "kela", "okvc", "skln", "okln", " kql", " klc", "kLV", "oklf", "klf", "kvi", "ckll", "krl", "knlv", "skvi", "klc", "mlp", "Kvl", "kla", "ckwl", " kLV", "cklv", "cklc", "uklc", "Klc", "kvm", "skvm", "ikwl", "kvc", "mLV", "kslc", "Kwl", "okvl", "sklv", "klp", " kwl", "mlv", "Klv", "cklf", "sklc", "oklp", "Kql", "okrl", "skrl", "kll", "ikLV", "uklf", "skLV", "kln", "skql", "kslv", " klf"], "ret": [" resp", " success", "def", " flags", "num", "val", " Ret", " val", "RET", "ry", "col", "nt", " RET", "rc", "Ret", "rep"], "metadata": ["params", "package", "ATA", "options", "info", "ma", "definition", "description", "ata", "annot", "header", "stream", "parser", "entry", "o", "message", "tmp", "filename", "meta", "details", "summary", "json", "data", "m", "iterator", "adata", "node", "met"]}}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23213, "substitutes": {"retval": ["retvals", "retpart", "returnvalue", "RETvals", "rtref", "resel", "revalue", "Retval", "returnVal", " retvals", "returnval", "retvalue", "Retref", "RETVal", " retVal", "RETvalue", "returnvals", "retref", "gtpart", "gtref", "RetVal", "retVal", "gtVal", "reval", " retvalue", "reVal", " retsel", "rtVal", "gtval", "RETval", "rtval", "rtsel", "rtvalue", "Retpart", "retsel", "rtpart"], "msg": ["desc", "mess", "cfg", "debug", "req", "def", "doc", "text", "gm", "reason", "enc", "val", "code", "go", "db", "name", "frame", "loc", "word", "status", "info", "md", "config", "bg", "ma", "Msg", "cmd", "body", "comm", "html", "bug", "gram", "game", "err", "send", "mod", "notice", "error", "base", "mb", "l", "ger", "message", "args", "module", "manager", "u", "str", "details", "plugin", "cm", "gen", "op", "data", "obj", "missing", "gs", "dr", "m", "arg", "og", "pkg", "gb", "sys", "generic", "g", "sg", "ms", "comment", "ext"], "flags": ["settings", "prefix", "lines", " errors", "options", "forces", "tags", " Flags", "status", " bugs", "magic", "stats", "types", "rows", "fs", "mask", "links", "files", "mods", "utils", "styles", "lag", "bits", "checks", "rules", "cs", "ils", "Flags", "args", "locks", "ports", "fps", "modules", "errors", "vals", "details", "features", "ops", "ips", "bugs", "comments", "flag", "FLAG", "tracks", "frames", "plugins", " bits", "fields", "codes", "ages", "ints", "ags", "properties", "alls", "bytes"], "nchars": ["nfars", "lchARS", "nquannels", " nchalls", "nChards", "nhars", "lcharars", "nshases", "ncharicks", "nquards", "ncquases", "nvapes", "nvalls", "nfannels", "ncchards", "ncchannels", " nChards", "ncquards", " nvapes", "ncolannels", "nchalls", "nChars", "nbARS", "nhicks", "Nquats", "lchicks", "nchants", " nvars", "ncharases", "nscards", "nChats", " nChats", "nchards", "nichards", " nquannels", " nvalls", "nscalls", "nhARS", "nichars", " nquans", "narchars", "Nquars", " nchats", "nichases", "ncharars", "lcharARS", "nfares", "nvards", "nbases", "ncquannels", "nchats", "nspards", "Nquards", "Nchases", "ncchases", "nichats", "nquars", "nchases", "Nquases", "nshards", "nspats", "nChants", "nchapes", " nchants", "ncolars", " nchannels", "Nchats", "narchapes", " nchans", "nfans", "nquans", "nquares", "ncolards", "lchases", " nChars", "narchalls", "nvars", "nchannels", " nquars", " nchapes", " nvards", " nchares", "nscapes", "Nchards", "lcharases", "nchicks", "nquases", "ncolans", "nbicks", "lchars", "Nchars", "nscars", "nchARS", "nspants", "ncchars", "nshannels", "nquats", " nchards", "ncharARS", "nquants", "nspars", "nhases", "nchans", "lcharicks", "ncquars", "nshars", " nquares", " nChants", "ncolares", "nchares", "nbars", "narchards", "nChases", "ncolases"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n", "idx": 23237, "substitutes": {"r": ["adr", "br", "ur", "gr", "mr", "rs", "w", "p", "pr", "rt", "f", "fr", "sr", "ru", "rx", "rh", "ir", "cr", "b", "cur", "rel", "ar", "c", "err", "R", "range", "o", "rr", "nr", "e", "l", "kr", "hr", "or", "result", "u", "rd", "d", "attr", "rf", "re", "rc", "arr", "k", "rw", "dr", "reader", "m", "t", "er", "lr", "record", "rl", "rb", "rg", "rec"], "r_next": ["r_rev", " r_rev", " r_last", " r_seq", "r_end", "r___next", "r___sequence", "r__last", " r_sequence", "r_seq", "r_last", "R_last", "R_next", "R_end", "r__seq", "r__next", "r___rev", "r_sequence"], "h": ["ha", "hd", "x", "w", "kh", "p", "th", "ht", "hl", "gh", "host", "code", "ih", "f", "head", "zh", "q", "rh", "ho", "he", "b", "v", "bh", "ah", "dh", "oh", "n", "sth", "header", "c", "hh", "hs", "err", "o", "H", "e", "l", "hr", "ch", "ph", "u", "sh", "d", "uh", "hash", "hm", "hi", "k", "i", "id", "m", "t", "work", "g", "eh"]}}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n", "idx": 23244, "substitutes": {"iscsilun": ["iscsluno", "iscsiluna", "iscraluna", "uscsluno", "uscsilumen", "iscselun", "iscinfuna", "iscsilunion", "itschrieluna", "itschrieluni", "iscielunion", "itschsilunion", "iscalune", "iscrubune", "iscslunin", "iscselunin", "iscralun", "iscslunion", "ircsiluno", "ircslun", "isclitun", "uscsiluna", "iscsiluno", "iscslmun", "iscinfun", "iscsilumen", "ircsiluna", "iscrieluna", "ircsluno", "iscsinumen", "iscrieluni", "iscsinun", "uscslut", "iscaluna", "isclituno", "iscrubut", "iscisluno", "uscslun", "iscsilmun", "iscinfune", "iscrielun", "iscsluni", "uscslumen", "itschrielunion", "iscislun", "iscrubun", "uscsilune", "iscieluni", "iscieluna", "uscsilmun", "ircsilunin", "iscslumen", "iscralmun", "uscsluna", "iscielun", "itschrielun", "iscsilunin", "iscislunin", "isclituna", "iscslut", "uscsiluno", "iscisluna", "iscseluna", "uscsilun", "iscralune", "iscsilut", "iscsiluni", "uscsilut", "iscslune", "iscseluno", "ircsilun", "isclitumen", "itschsiluni", "itschsiluna", "iscinfut", "ircsluna", "iscalun", "uscslmun", "iscsilune", "uscslune", "iscrubuna", "iscslun", "iscsinuna", "iscsluna", "iscrielunion", "itschsilun", "iscalmun", "ircslunin", "iscsinuno"], "sector_num": ["sector_offset", "section_offset", "sector00sum", "sectoridset", "sectoridoffset", "sector00offset", "section_initial", "sector00num", " sector_length", "section_set", "section_number", "sector_name", " sector_name", "sector_length", "sector_set", "sectoridsum", "sector_sum", "sector00set", " sector_number", "sectoridnum", "sector_number", "section_sum", "sector_initial", "section_num"], "nb_sectors": ["nb_pegments", "nb_pectors", "nb_secctor", "nb_serctions", "nb_sugments", "nb_secsections", "nb_sevec", "nb_pevec", "nb_suctors", "nb_sesections", "nb_segments", "nb_gegments", "nb_sector", "nb_serctors", "nb_psector", "nb_secgments", "nb_gesections", "nb_servec", "nb_secctors", "nb_sections", "nb_suvec", "nb_pections", "nb_psectors", "nb_psesections", "nb_sergments", "nb_suctions", "nb_gectors", "nb_psegments", "nb_gector"], "cluster_num": ["clancer_sum", "cluster_number", "cluster_n", "clancer_Num", "clusters_Num", "clusters_name", "cluster_sum", "cluster_Num", "cluster_name", "cluster_count", "clancer_num", "clusters_num", "clancer_count", "cluster_size"], "nb_clusters": ["nb_splions", "nbNalluster", "nb_clonents", "nb_compuster", "nb_plards", "nb_slonents", "nb_allusters", "nb_splayers", "nbNcluster", "nb_plers", "nb_players", "nb_CLards", "nb_slayers", "nb_plblocks", "nb_CLusters", "nbNallers", "nb_splusters", "nb_alluster", "nb_compers", "nb_CLions", "nb_clers", "nbNclblocks", "nb_allers", "nb_slusters", "nb_CLuster", "nbNallusters", "nb_compusters", "nb_cluster", "nb_bluster", "nb_plonents", "nb_clards", "nb_plusters", "nb_slions", "nb_compblocks", "nb_blions", "nb_plions", "nb_splonents", "nb_blusters", "nbNallblocks", "nb_pluster", "nbNclers", "nb_blards", "nb_clayers", "nb_clions", "nb_allblocks", "nbNclusters", "nb_clblocks"]}}
{"project": "qemu", "commit_id": "e511b4d783c47a32420da802104cfb0eb974b22f", "target": 0, "func": "int cpu_exec(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n#endif\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    uintptr_t next_tb;\n\n    SyncClocks sc;\n\n\n\n    /* This must be volatile so it is not trashed by longjmp() */\n\n    volatile bool have_tb_lock = false;\n\n\n\n    if (cpu->halted) {\n\n        if (!cpu_has_work(cpu)) {\n\n            return EXCP_HALTED;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    current_cpu = cpu;\n\n\n\n    /* As long as current_cpu is null, up to the assignment just above,\n\n     * requests by other threads to exit the execution loop are expected to\n\n     * be issued using the exit_request global. We must make sure that our\n\n     * evaluation of the global value is performed past the current_cpu\n\n     * value transition point, which requires a memory barrier as well as\n\n     * an instruction scheduling constraint on modern architectures.  */\n\n    smp_mb();\n\n\n\n    if (unlikely(exit_request)) {\n\n        cpu->exit_request = 1;\n\n    }\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n    cpu->exception_index = -1;\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n\n            /* if an exception is pending, we execute it here */\n\n            if (cpu->exception_index >= 0) {\n\n                if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = cpu->exception_index;\n\n                    if (ret == EXCP_DEBUG) {\n\n                        cpu_handle_debug_exception(env);\n\n                    }\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    cc->do_interrupt(cpu);\n\n#endif\n\n                    ret = cpu->exception_index;\n\n                    break;\n\n#else\n\n                    cc->do_interrupt(cpu);\n\n                    cpu->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = cpu->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        cpu->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        cpu->halted = 1;\n\n                        cpu->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                        cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n                        do_cpu_init(x86_cpu);\n\n                        cpu->exception_index = EXCP_HALTED;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#else\n\n                    if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n                        cpu_reset(cpu);\n\n                    }\n\n#endif\n\n                    /* The target hook has 3 exit conditions:\n\n                       False when the interrupt isn't processed,\n\n                       True when it is, and we should restart on a new TB,\n\n                       and via longjmp via cpu_loop_exit.  */\n\n                    if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                        next_tb = 0;\n\n                    }\n\n                    /* Don't use the cached interrupt_request value,\n\n                       do_interrupt may have updated the EXITTB flag. */\n\n                    if (cpu->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(cpu->exit_request)) {\n\n                    cpu->exit_request = 0;\n\n                    cpu->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit(cpu);\n\n                }\n\n                spin_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = true;\n\n                tb = tb_find_fast(env);\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tcg_ctx.tb_ctx.tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tcg_ctx.tb_ctx.tb_invalidated_flag = 0;\n\n                }\n\n                if (qemu_loglevel_mask(CPU_LOG_EXEC)) {\n\n                    qemu_log(\"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));\n\n                }\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~TB_EXIT_MASK),\n\n                                next_tb & TB_EXIT_MASK, tb);\n\n                }\n\n                have_tb_lock = false;\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                cpu->current_tb = tb;\n\n                barrier();\n\n                if (likely(!cpu->exit_request)) {\n\n                    trace_exec_tb(tb, tb->pc);\n\n                    tc_ptr = tb->tc_ptr;\n\n                    /* execute the generated code */\n\n                    next_tb = cpu_tb_exec(cpu, tc_ptr);\n\n                    switch (next_tb & TB_EXIT_MASK) {\n\n                    case TB_EXIT_REQUESTED:\n\n                        /* Something asked us to stop executing\n\n                         * chained TBs; just continue round the main\n\n                         * loop. Whatever requested the exit will also\n\n                         * have set something else (eg exit_request or\n\n                         * interrupt_request) which we will handle\n\n                         * next time around the loop.\n\n                         */\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        next_tb = 0;\n\n                        break;\n\n                    case TB_EXIT_ICOUNT_EXPIRED:\n\n                    {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n", "idx": 23245, "substitutes": {"env": ["cfg", "ev", "cv", "cache", "eni", "en", "enc", "ea", "core", "db", "cli", "proc", "config", "eng", "net", "cmd", "vm", "exc", "c", "e", "exe", "osc", "conn", "engine", "et", "fi", "ne", "profile", "np", "Environment", "cp", "rc", "bc", "environment", "eu", "org", "conf", "esp", "vs", "server", "nc", "context", "loader", "bench", "ec"], "cpu": ["cache", "lc", "cu", "css", "processor", "proc", "gpu", "intel", "utils", "gru", "python", "exe", "module", "bc", "pu", "pkg", "component", "lib", "px", "uu", "bench", "ec", " cp", "nic", "chip", " CPU", "lb", "CPU", "jp", "uci", "platform", "pid", "current", "core", "num", "clock", "cli", "config", "roc", "pc", "computer", "framework", "kernel", "auc", "np", "eu", "chu", "cfg", "console", "ubuntu", "host", "consumer", "uc", "vm", "c", "hw", "fp", "instance", "ctx", "unit", "cpp", "server", "node", "hp", "gc", "hu", "GPU", "linux", "frame", "process", "prem", "fc", "mac", "conn", "fps", "boot", "cp", "uno", "cmp", "nc", "cn", "loader", "coe"], "cc": ["mc", "dc", "cf", "cl", "gc", "xc", "cache", "lc", "css", "cci", "co", "core", "proc", "pc", "uc", "cow", "ct", "fc", "con", " gcc", "c", "ck", "ca", "PC", "cs", "conn", "acc", "hw", "ucc", "cm", "bc", "cp", "tc", "rc", "cca", "CC", "ctx", "vc", "ci", "ctrl", "cmp", "ctl", "nc", "cn", "ec", "icc"], "x86_cpu": ["x86_CPU", "x64_cpu", "x86_gpu", "x64_CPU", "x64_gpu", "x64_core", "x86_core"], "ret": ["att", "match", "res", "resp", "rets", "lit", "mem", "code", "num", "cat", "rt", "val", "bit", "rev", " Ret", "ft", "det", "valid", "lt", "mt", "ut", "RET", "ct", "len", "seq", "back", "feat", "fun", "reg", "red", "vt", "result", "nt", "ref", "opt", "fi", "bc", " RET", "data", "re", "job", "id", "alt", "arg", "fin", "success", "Ret", "pub", "pet", "let"], "interrupt_request": ["interart_query", "interruption_demand", "interruptMrequest", "interrupt_report", "interruption_response", "interart_response", "intercept_right", "interrupt_query", "interrupt67Request", "interruptfulquestion", "intercept_require", "interruptedrequest", "interrupt_path", "interrupt_received", "intercept_received", "intercept_length", "interruptlyright", "interrupt_require", "interruption_right", "interruptedresponse", "interruptfulresponse", "intercept_seek", "interruption_Request", "interrupt_call", "interruptMseek", "interrupt_demand", "intercept_request", "interrupt_seek", "interruptlyseek", "intercept_question", "interart_request", "interruptedright", "interrupt67request", "interruptableresponse", "interruptfullength", "interrupt67right", "intercept_response", "interruptablecall", "interruptlyrequire", "interart_path", "interruptMrequire", "interrupt_response", "interrupt_question", "interruptedreceived", "interruption_call", "interrupt_Request", "interruptlyrequest", "interruption_request", "interruptfulrequest", "interruption_report", "interrupt67response", "interrupt_right", "interrupt_length", "interruptMright", "interruptablereport", "interruptablerequest"], "tb": ["tpb", "ttpb", "ttrb", " tpb", "tbs", "ttb", "untpb", " tbs", "untrb", " trb", "ttbs", "untbs", "trb", "untb"], "tc_ptr": ["tcxref", "tc_pointer", "tcxpointer", "TC_ptr", "TC_pointer", "TC_inst", "tc_inst", "tcxinst", "TC_ref", "tcxptr", "tc_ref"], "next_tb": ["next_nab", "next_xtbi", "next_tf", "next_tbi", "next_untb", "next_Tlb", "next_rtbi", "next_Tbi", "next_rtf", "next_tlb", "next_xtb", "next_Tb", "next_xtlb", "next_nlb", "next_nb", "next_tab", "next_rtb", "next_Tp", "next_Tab", "next_rtp", "next_Tf", "next_tp", "next_xtab", "next_nbi", "next_untp", "next_untf", "next_untbi"], "sc": ["mc", "sq", "cl", "src", "lc", "sync", "sa", " ssh", "isc", "sci", "cr", "uc", "pc", "ss", "si", "ct", "scl", "sw", "c", "ca", "sb", "Sc", " scr", "cs", "osc", "acc", "ch", "sh", "esc", "bc", "soc", "rc", "tc", "scope", "sp", " Sc", "SC", "sl", "spec", "asc", "ec", "icc"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "substitutes": {"str": ["st", "inst", "br", "expr", "gr", "iter", "rs", "empty", "text", "ix", "lc", "pr", "enc", "code", "ocr", "fr", "sr", "cr", "sec", "cur", "start", "sc", "wr", "temp", "seq", "len", "spec", "err", "cs", "r", "hr", "STR", "ctr", "wrap", "Str", "tr", "obj", "arr", "ptr", "dr", "last", "exec", "stri", "inner"], "endptr": ["startpointers", " endpointer", "startctr", " endPtr", "endedpointers", "endedpointer", "startpointer", " endctr", "endedctr", "startptr", "adpointer", "endpointers", "endctr", " endpointers", "adpointers", "adptr", "endPtr", "adPtr", "endpointer", "endedptr", "endedPtr", "startPtr"], "res": [" Res", "req", "gr", "resp", "rs", "css", "Res", "_", "ras", "rev", "rss", "ret", "results", "val", "s", "cr", "rows", "rh", "ress", "RES", "err", "reg", "ps", "R", "vec", "cs", "r", "reed", "ics", "args", "result", "bytes", "pre", "out", "vals", "rez", "des", "re", "data", "resolution", "arr", "obj", "Rs", "rec", "ms", "rap", "pres", "js"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 23250, "substitutes": {"ysrc": ["sysroc", "yssrc", "xsync", "src", "xsrt", "inssrc", "ysRC", "sysync", "iesrt", "sysRC", "ysroc", "sysrt", "sysrc", "insrc", "iessrc", "ysrt", "sRC", "iesync", "ssrc", "iesrc", "insroc", "insRC", "xssrc", "xsrc", "sroc", "syssrc", "ysync"], "usrc": ["aussrc", "usri", " usri", " usource", " usdc", "uource", "urc", "usource", "uri", "ausdc", "ausri", "ausrc", "ausource", " ussrc", "ussrc", "udc", "usdc"], "vsrc": ["svsl", "fsrc", "vsst", "floc", "svloc", "urc", "usource", "svsource", "vrc", "wsource", "ussource", "vloc", "vsource", "fsource", "vssource", "svsrc", "vst", "vssrc", "fsl", "wsl", "vsl", "ust", "ussrc", "wloc", "wsrc", "usst"], "dst": ["Ddest", "sst", "DST", "Dst", " dste", "idst", "bdste", "dste", "sdST", "ddest", "dsrc", "idbe", "sdsrc", "sST", "dbe", "sdest", "ssrc", "dST", "bdsts", "dsts", "idste", "bdst", "bdbe", "sddest", "idsts", " dsts", "Dsrc", "sdst", " dbe"], "height": ["ty", "shape", "thin", "rank", "image", "hd", "h", "high", "deep", "img", " heights", "depth", "distance", "above", "dim", "length", "max", "gap", "Height", "images", "padding", "alpha", "y", "style", "square", "window", "crop", "dist", "wrap", "size", "bottom", "pull", "resolution", "direction", "input", "pad", "density", "stroke"], "lumStride": ["lumSTrite", "lumbStrite", "lumScrip", "lumstro", "lumbStrip", "lumbStrride", "lumbstro", "lumstri", "lumScro", "lumStri", "lumbStride", "lumStrip", "lumstride", "lumbStro", "lumStrite", "lumSTrip", "lumSTride", "lumbStri", "lumSTro", "lumStrrip", "lumbStrri", "lumScride", "lumbstride", "lumStrride", "lumScrite", "lumbStrro", "lumbstrite", "lumbStrrip", "lumstrite", "lumStrro", "lumbstrip", "lumSTri", "lumStro", "lumstrip", "lumStrri"], "chromStride": ["chromUrite", "romStrite", "chromStrrip", "chromUro", "chromSTric", "chromStrric", "chromStric", "romstride", "romstrite", "romStro", "homStrride", "chromStrite", "chromstride", "chromUride", "homStric", "chromStrride", "chromsterve", "homStrri", "homStrrip", "chromSTride", "chromEstride", "romstro", "chromSTrip", "romSterve", "chromstrite", "chromSTerve", "chromSTrite", "chromSTro", "homStride", "chromStri", "romStride", "homStrric", "chromstro", "romsterve", "chromSTri", "chromEstric", "chromEstrip", "homStrip", "chromSterve", "homStri", "chromStro", "chromEstri", "chromUerve", "chromStrri", "chromStrip"], "dstStride": ["dstStro", "dstStue", "dstStend", "dstSTue", "dspTue", "dspStue", "dstClrip", "dstClue", "dstTride", "dspStrip", "dscStride", "dstRestide", "dstStrrip", "dstTue", "dscStrrip", "dspStend", "dstSTride", "dstClend", "dstStrro", "dstTend", "dstRestrip", "dstSTrip", "dstClride", "dscStro", "dscStide", "dstStide", "dstStrride", "dstRestride", "dspStride", "dspTend", "dstRestro", "dscStrride", "dscStrip", "dspTrip", "dspTride", "dstTrip", "dstSTend", "dscStrro", "dstStrip"]}}
{"project": "FFmpeg", "commit_id": "b7d9b4a1f1fcd01084ccbec6f7ef32c853681833", "target": 1, "func": "int ff_h263_decode_mb(MpegEncContext *s,\n                      int16_t block[6][64])\n{\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    const int xy= s->mb_x + s->mb_y * s->mb_stride;\n    int cbpb = 0, pb_mv_count = 0;\n    av_assert2(!s->h263_pred);\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        do{\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for(i=0;i<6;i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->mb_skipped = !(s->obmc | s->loop_filter);\n                goto end;\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 20);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra) goto intra;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n            cbpy ^= 0xF;\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n            /* 16x16 motion prediction */\n            s->mv_type = MV_TYPE_16X16;\n            ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n            if (s->umvplus)\n               mx = h263p_decode_umotion(s, pred_x);\n            else\n               mx = ff_h263_decode_motion(s, pred_x, 1);\n            if (mx >= 0xffff)\n            if (s->umvplus)\n               my = h263p_decode_umotion(s, pred_y);\n            else\n               my = ff_h263_decode_motion(s, pred_y, 1);\n            if (my >= 0xffff)\n            s->mv[0][0][0] = mx;\n            s->mv[0][0][1] = my;\n            if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n               skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type = MV_TYPE_8X8;\n            for(i=0;i<4;i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                  skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                mot_val[0] = mx;\n                mot_val[1] = my;\n    } else if(s->pict_type==AV_PICTURE_TYPE_B) {\n        int mb_type;\n        const int stride= s->b8_stride;\n        int16_t *mot_val0 = s->current_picture.motion_val[0][2 * (s->mb_x + s->mb_y * stride)];\n        int16_t *mot_val1 = s->current_picture.motion_val[1][2 * (s->mb_x + s->mb_y * stride)];\n//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;\n        //FIXME ugly\n        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=\n        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=\n        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=\n        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;\n        do{\n            mb_type= get_vlc2(&s->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);\n            if (mb_type < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b mb_type damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            mb_type= h263_mb_type_b_map[ mb_type ];\n        }while(!mb_type);\n        s->mb_intra = IS_INTRA(mb_type);\n        if(HAS_CBP(mb_type)){\n            s->bdsp.clear_blocks(s->block[0]);\n            cbpc = get_vlc2(&s->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);\n            if(s->mb_intra){\n                dquant = IS_QUANT(mb_type);\n                goto intra;\n            cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n            if (cbpy < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n                cbpy ^= 0xF;\n            cbp = (cbpc & 3) | (cbpy << 2);\n        }else\n            cbp=0;\n        av_assert2(!s->mb_intra);\n        if(IS_QUANT(mb_type)){\n            h263_decode_dquant(s);\n        if(IS_DIRECT(mb_type)){\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type |= set_direct_mv(s);\n        }else{\n            s->mv_dir = 0;\n            s->mv_type= MV_TYPE_16X16;\n//FIXME UMV\n            if(USES_LIST(mb_type, 0)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                s->mv_dir = MV_DIR_FORWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n            if(USES_LIST(mb_type, 1)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 1, &pred_x, &pred_y);\n                s->mv_dir |= MV_DIR_BACKWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[1][0][0] = mx;\n                s->mv[1][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do{\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 8);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\nintra:\n        s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n        if (s->h263_aic) {\n            s->ac_pred = get_bits1(&s->gb);\n            if(s->ac_pred){\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n                s->h263_aic_dir = get_bits1(&s->gb);\n        }else\n            s->ac_pred = 0;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(cbpy<0){\n            av_log(s->avctx, AV_LOG_ERROR, \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        pb_mv_count += !!s->pb_frame;\n    while(pb_mv_count--){\n        ff_h263_decode_motion(s, 0, 1);\n        ff_h263_decode_motion(s, 0, 1);\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (h263_decode_block(s, block[i], i, cbp&32) < 0)\n            return -1;\n        cbp+=cbp;\n    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)\n        return -1;\n    if(s->obmc && !s->mb_intra){\n        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)\n            preview_obmc(s);\nend:\n        /* per-MB end of slice check */\n    {\n        int v= show_bits(&s->gb, 16);\n        if (get_bits_left(&s->gb) < 16) {\n            v >>= 16 - get_bits_left(&s->gb);\n        if(v==0)\n            return SLICE_END;\n    return SLICE_OK;", "idx": 23256, "substitutes": {"s": ["ins", "secondary", "p", "us", "f", "si", "a", "sb", "cs", "ops", "side", "gs", "conf", "your", "spec", "sv", "support", "ims", "ses", "ds", "xs", "is", "b", "ts", "n", "ps", "sites", "e", "services", "parts", "changes", "comments", "os", "cons", "set", "rates", "states", "S", "ks", "w", "sym", "site", "bis", "stats", "its", "v", "c", "l", "r", "service", "qs", "times", "es", "m", "sys", "t", "g", "new", "settings", "sets", "sq", "rs", "sync", "as", "fs", "ss", "o", "session", "uns", "ssl", "des", "su", "self", "sf", "ns", "ls", "sg", "ms", "sports", "js"], "block": ["channel", "part", "image", "line", "def", "cl", "x", "box", "row", "mem", "code", "buffer", "bit", "frame", "type", "object", "bl", "lock", "device", "seq", "bin", "view", "buf", "header", "base", "byte", "blocks", "ref", " blocks", "str", " Block", "plugin", "ban", "bc", "layer", "obj", "data", "arr", "job", "unit", "Block", "array", "record", "map", "node", "BL", "ip"], "cbpc": ["kbc", "cfp", "cbpn", "cfproc", "cdpc", "bbpr", "cbpr", "CBbc", "rbp", "cbPC", "bbpn", "bbfc", "rbpc", "CBfc", "ctrfc", "cdbc", "ctrp", "cbpb", "pbpb", "kbpc", "cbbc", "cbproc", "bbc", "dbc", "dbpn", "CBproc", "bcp", "bbpi", "bbpc", "CBpc", "rbbc", "cbnc", "cdfc", "abbpc", "ctrpc", "cbc", "pbfc", "bbpb", "abbp", "CBPC", "CBp", "ctrpr", "cbfc", "rbPC", "abbfc", "dbpi", "bcfc", "CBpb", "rbnc", "pbproc", "kbpi", "CBnc", "bbp", "bcproc", "cdnc", "pbpc", "cffc", "CBpr", "cbpi", "kbpn", "bbproc", "bcpc", "cfpc", "dbpc", "rbfc", "abbPC"], "cbpy": ["CBpm", "CBpy", "cbpx", "CBpx", "cfpy", "pbpy", "pbpc", "pbpm", "cbpm", "pbpx", "cfpc", "cfpx", "CBpc", "cfpm"], "i": ["ti", "ii", "ui", "ji", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "info", "type", "cli", "ai", "f", "ini", "ie", "ni", "oi", "is", "si", "io", "init", "b", "v", "pi", "uri", "index", "n", "c", "e", "y", "l", "r", "xi", "bi", "u", "chi", "fi", "li", "in", "iu", "d", "hi", "k", "id", "mi", "ci", "zi", "multi", "gi", "z", "inner", "ip"], "cbp": ["cfp", "cfpe", "cvpm", "cvpe", "gcp", "cvbp", "gcbp", "cvp", "cbpm", "gcpe", "cfbp", "cfpm", "gcpm", "cbpe", "cbbp"], "pred_x": ["prop_x", "pred_name", "prop_y", "prop_name", "pred_p", "prop_p"], "pred_y": ["cb_y", "pred_z", "cb_vy", "cb_z", "cb_x", "pred_vy"], "mx": ["mc", "dm", "ym", "bm", "mr", "xy", "wm", "mem", "loc", "mode", "pm", "md", "mn", "rx", "vm", "mm", "mp", "mb", "xp", "mag", "cm", "np", "foo", "mi", "m", "mes", "ms", "ml"], "my": ["mc", "cy", "mic", "sym", "test", "My", "mis", "mode", "mos", "rx", "mn", "mm", "hh", "wx", "meta", "ms", "mmm", "yy", "mi", "sys", "another", "custom", "mix", "mys", "Mi", "mon", "me"], "dquant": ["lquant", "fqual", "fquant", "mcount", "mqual", " dcount", "dbbuff", " dqual", "lproc", "lcomp", "mquant", "lqual", "fproc", "dbquant", "dbuff", "dcomp", "mbuff", "dproc", "dqual", "fcomp", " dcomp", " dbuff", " dproc", "dcount", "dbqual", "dbcount"], "mot_val": ["mot_type", "mot2depth", "motFval", "mot2type", "mot_depth", "mot2value", "reg2depth", "reg2val", "mot2val", "mot__depth", "reg2value", "motFdepth", "reg2type", "motFtype", "mot__type", "reg_val", "reg_value", "motFvalue", "mot__val", "mot_value", "mot__value", "reg_depth", "reg_type"], "mb_type": ["mp_style", "mp_list", "mb__style", "mb__type", "mb_style", "mb_types", "mp_types", "mb_list", "mp_type", "mb__types", "mb__list"], "pb_mv_count": ["pb_mtv_size", "pb_mtv_id", "pb_mv__info", "pb_mv_size", "pb_mv_id", "pb_mtv_count", "pb_mtv0info", "pb_mtv0count", "pb_mv__size", "pb_mtv0size", "pb_mv0size", "pb_mv__id", "pb_mv0id", "pb_mv_info", "pb_mav_id", "pb_mv0info", "pb_mav_count", "pb_mv0count", "pb_mtv0id", "pb_mv_base", "pb_mtv_info", "pb_mav_base", "pb_mv__count"]}}
{"project": "FFmpeg", "commit_id": "92fabca427ff2d8fffa4bd4f09839d8d3822ef31", "target": 0, "func": "static void DEF(put, pixels16_x2)(uint8_t *block, const uint8_t *pixels, ptrdiff_t line_size, int h)\n\n{\n\n    MOVQ_BFE(mm6);\n\n    __asm__ volatile(\n\n        \"lea        (%3, %3), %%\"REG_a\" \\n\\t\"\n\n        \".p2align 3                     \\n\\t\"\n\n        \"1:                             \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"subl   $4, %0                  \\n\\t\"\n\n        \"jnz    1b                      \\n\\t\"\n\n        :\"+g\"(h), \"+S\"(pixels), \"+D\"(block)\n\n        :\"r\"((x86_reg)line_size)\n\n        :REG_a, \"memory\");\n\n}\n", "idx": 23259, "substitutes": {"block": ["channel", "full", "image", "line", "w", "wall", "cache", "row", "enc", "buffer", "bit", "name", "frame", "type", "clock", "length", "pack", "none", "lock", "bl", "pixel", "index", "header", "patch", "hole", "page", "col", "batch", "byte", "blocks", "limit", "pre", "end", "pos", "unit", "blocking", "Block", "column", "level", "inc", "cell", "pool"], "pixels": ["peps", "tixels", "picks", "towers", "powers", "cixels", " picks", "ticks", "npixels", "npeps", "cixel", "piles", "tixel", "cowers", "pixel", "ceps", "ciles", "tiles", " powers", "teps", "npixel", " piles", "cicks"], "line_size": ["line32size", "line32rate", "line32scale", "block_Size", "block_scale", "lineallrate", " line_num", "line_scale", "linewnum", "line_rate", "lineallSize", "line32Size", "linewsize", "line_level", "linewlevel", "line_Size", "lineallscale", "lineallsize", "block_rate", "block_size", "line_num", " line_level"], "h": ["headers", "x", "w", "p", "ht", "row", "heads", "ih", "f", "head", "rh", "b", "v", "bh", "oh", "n", "header", "c", "padding", "hs", "o", "H", "e", "hidden", "y", "r", "l", "hole", "ch", "hw", "sh", "ach", "history", "d", "layer", "hash", "hm", "i", "m", "z", "hp"]}}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274, "substitutes": {"idstr": ["endstr", "midst", "idcode", "pidbr", "IDbytes", "aidbr", "idst", "IDobj", "idbreak", " idarr", "aidst", "Idstr", "midStr", "IDcr", "idlist", "endbreak", "midbr", "iddStr", " idbreak", " idlist", "nameStr", "pidcode", "Idlist", "IdStr", "aidstr", "Idcode", "keyobj", "keystr", "aidstring", " idSTR", " idcr", "idSTR", "idarr", "idstring", "namestr", "idobj", "pidst", "midstr", "pidStr", "IDSTR", "midarr", "iddbreak", "pidstr", " idcode", "idbytes", " idbytes", "midbytes", "pidlist", "IDarr", "midstring", "IDstr", " idobj", "namestring", "keystring", "pidcr", "endobj", "endStr", "IDstring", "idcr", "iddstr", "iddobj", "pidSTR", "IDStr", " idStr", "idbr", "pidstring", "keyStr", "nameobj", "idStr"], "instance_id": ["instance___ids", " instance_ids", " instance_name", "instance64base", "instance64id", "instance_base", "instance64ids", "instance_Id", "instance_i", "instance_ids", "ance_count", " instance_base", " instance_offset", "instance_type", "ance_version", "instance___name", "ance_end", "instance_oid", "instance_count", "ance_sid", "instance___id", "instance_name", "ance_id", "instance64i", "instance_version", "ance_ids", "instance_end", "instance64name", "instance_sid", "ance_name", " instance_sid", " instance_i", "instance___version", "instance_offset", " instance_oid", "ance_Id", " instance_type"], "version_id": ["version_index", "versionfulstart", "instance_code", "versioneename", "versionPoolname", "versionalname", "versioneecode", "version_source", "version_code", "versionPoolsource", "versionalident", "instance_name", "versionalstart", "instance_source", " version_index", "instance_start", "version_ident", "versionfulid", "versioneeid", "instance_ident", " version_ids", "versionfulident", "versionfulname", "version_start", "version_ids", "version_name", "versioneesource", "versionalid", " version_ident", "versionPoolid", "versionPoolcode"], "save_state": ["instanceedstatus", "saveedstate", "ave_rule", "save__resource", "saveingconfig", "save_rule", "load_config", "saveedpolicy", "save_policy", "ave_state", "savefstates", "savefpolicy", "save__id", "savefstate", "save_id", "instanceedpolicy", "instanceedstates", "saveedstatus", "save_status", "instance_policy", "saveingstate", "load_policy", "ave_resource", "instanceedstate", "ave_id", "save_resource", "saveingpolicy", "instance_status", "instance_state", "saveingrule", "instance_states", "save_states", "save__rule", "load_rule", "save_config", "save__state", "savefstatus", "saveedstates"], "load_state": [" load_job", "save_type", "loading_state", "loadingingstring", "loadingstates", "loadamrule", "loadingstring", "load_job", "loading_string", "loadalsession", " load_states", "loaderjob", "loaderstates", "loadingstate", "load_states", "load_string", "loadingrule", "loadaltype", "loadingtype", "loadamjob", "loadingsession", "load_session", "loadamstates", "load_type", "loading_rule", "loading_states", "loadalstate", "loadamstate", "loaderstate", " load_rule", "loadingingrule", "loadingingstates", "load_rule", "loadingingstate", "save_session", "loaderrule"], "opaque": ["opity", "opsaque", "opericate", "operasso", "opicate", "uppacement", "oppity", "opsaques", "operacement", "opacity", " opacement", "opsicit", "oppacity", "copacity", "uppacity", "obaque", "opicit", "uppaque", "Opicit", "opacement", " opicate", "copaque", "obity", "uppicate", "opsacity", "copaques", " opacity", "opasso", "oppaque", "Opacity", "operacity", "operaque", "Opaque", "Opaques", "obacity", "obasso", "opaques", "operity", "copicit", "oppasso"], "se": ["ace", "ese", "SE", "ue", "pe", "ve", "parse", "sync", "sea", "sa", "site", "ge", "te", "le", "ses", "ce", "ide", "s", "ie", "sc", "si", "so", "see", "lex", "ae", "sle", "ade", "Se", "ke", "seed", "send", "sed", "ine", "e", "asse", "ite", "isse", "ch", "ph", "ze", "ase", "sk", "sel", "esse", "be", "sh", "del", "es", "ne", "ste", "sp", "sem", "su", "sd", "cle", "ser", "sing", "spe", "sl", "sec", "de", "ede", "serv"], "pse": ["phone", "SE", "clus", "kes", "pe", "ve", "parse", "esi", "pa", "p", "pr", "jp", "oe", "pose", "fe", "sea", "sa", "ship", "ge", "pid", "te", "process", "je", "proc", "pm", "cess", "na", "xe", "pass", "si", "lex", "ae", "perse", "pen", "ade", " pe", "seq", "ke", "ps", "pes", "ine", "ple", "press", "ite", "isse", "ph", "pre", "pei", "poke", "ee", "psy", "tp", "ne", "ffe", "pos", "inse", "syn", "pty", "sem", "su", "vale", "pas", "la", "ene", "spe", "coe", "phe", "ste", "ede", "pex", "me", "sei"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "substitutes": {"klass": ["kscl", "Kass", "skass", "kass", "ksclass", " kass", " kcl", "kclass", "kslass", "Klass", "klasses", "Kclass", "Klasses", "sklass", "sklasses", " kclass", " klasses", "kcl", "Kcl", "kslasses", "skclass"], "data": ["ui", "def", "cache", "DATA", "di", "load", "info", "config", "ata", "parent", "da", "dat", "session", "dd", "after", "api", "rc", "input", "i", "Data", "this", "loader", "exec"], "dc": ["mc", "cf", "tk", "gc", "doc", "lc", "cd", "css", "cc", "dt", "di", "db", "ac", "DC", "cat", "ds", "loc", "config", "md", "cr", "pc", "controller", "disc", "jc", "fc", "df", "c", "ga", " DC", "da", "dat", "conn", "fd", "dd", "cm", "d", "bc", "tc", "design", "rc", "cdn", "cca", "dk", "vc", "dr", "ctrl", "nc", "enter", "spec", "ec"]}}
{"project": "FFmpeg", "commit_id": "042ef4b720f5d3321d9b7eeeb2067c671d5aeefd", "target": 1, "func": "static int decode_mb_cavlc(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;\n\n    int partition_count;\n\n    unsigned int mb_type, cbp;\n\n    int dct8x8_allowed= h->pps.transform_8x8_mode;\n\n\n\n    s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?\n\n\n\n    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);\n\n    cbp = 0; /* avoid warning. FIXME: find a solution without slowing\n\n                down the code */\n\n    if(h->slice_type != I_TYPE && h->slice_type != SI_TYPE){\n\n        if(s->mb_skip_run==-1)\n\n            s->mb_skip_run= get_ue_golomb(&s->gb);\n\n\n\n        if (s->mb_skip_run--) {\n\n            if(FRAME_MBAFF && (s->mb_y&1) == 0){\n\n                if(s->mb_skip_run==0)\n\n                    h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n                else\n\n                    predict_field_decoding_flag(h);\n\n            }\n\n            decode_mb_skip(h);\n\n            return 0;\n\n        }\n\n    }\n\n    if(FRAME_MBAFF){\n\n        if( (s->mb_y&1) == 0 )\n\n            h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n    }else\n\n        h->mb_field_decoding_flag= (s->picture_structure!=PICT_FRAME);\n\n\n\n    h->prev_mb_skipped= 0;\n\n\n\n    mb_type= get_ue_golomb(&s->gb);\n\n    if(h->slice_type == B_TYPE){\n\n        if(mb_type < 23){\n\n            partition_count= b_mb_type_info[mb_type].partition_count;\n\n            mb_type=         b_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 23;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else if(h->slice_type == P_TYPE /*|| h->slice_type == SP_TYPE */){\n\n        if(mb_type < 5){\n\n            partition_count= p_mb_type_info[mb_type].partition_count;\n\n            mb_type=         p_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 5;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else{\n\n       assert(h->slice_type == I_TYPE);\n\ndecode_intra_mb:\n\n        if(mb_type > 25){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"mb_type %d in %c slice too large at %d %d\\n\", mb_type, av_get_pict_type_char(h->slice_type), s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n        partition_count=0;\n\n        cbp= i_mb_type_info[mb_type].cbp;\n\n        h->intra16x16_pred_mode= i_mb_type_info[mb_type].pred_mode;\n\n        mb_type= i_mb_type_info[mb_type].type;\n\n    }\n\n\n\n    if(MB_FIELD)\n\n        mb_type |= MB_TYPE_INTERLACED;\n\n\n\n    h->slice_table[ mb_xy ]= h->slice_num;\n\n\n\n    if(IS_INTRA_PCM(mb_type)){\n\n        unsigned int x, y;\n\n\n\n        // We assume these blocks are very rare so we do not optimize it.\n\n        align_get_bits(&s->gb);\n\n\n\n        // The pixels are stored in the same order as levels in h->mb array.\n\n        for(y=0; y<16; y++){\n\n            const int index= 4*(y&3) + 32*((y>>2)&1) + 128*(y>>3);\n\n            for(x=0; x<16; x++){\n\n                tprintf(s->avctx, \"LUMA ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*((x>>2)&1) + 64*(x>>3)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA U ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 64 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA V ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n\n\n        // In deblocking, the quantizer is 0\n\n        s->current_picture.qscale_table[mb_xy]= 0;\n\n        h->chroma_qp = get_chroma_qp(h->pps.chroma_qp_index_offset, 0);\n\n        // All coeffs are present\n\n        memset(h->non_zero_count[mb_xy], 16, 16);\n\n\n\n        s->current_picture.mb_type[mb_xy]= mb_type;\n\n        return 0;\n\n    }\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] <<= 1;\n\n        h->ref_count[1] <<= 1;\n\n    }\n\n\n\n    fill_caches(h, mb_type, 0);\n\n\n\n    //mb_pred\n\n    if(IS_INTRA(mb_type)){\n\n            int pred_mode;\n\n//            init_top_left_availability(h);\n\n            if(IS_INTRA4x4(mb_type)){\n\n                int i;\n\n                int di = 1;\n\n                if(dct8x8_allowed && get_bits1(&s->gb)){\n\n                    mb_type |= MB_TYPE_8x8DCT;\n\n                    di = 4;\n\n                }\n\n\n\n//                fill_intra4x4_pred_table(h);\n\n                for(i=0; i<16; i+=di){\n\n                    int mode= pred_intra_mode(h, i);\n\n\n\n                    if(!get_bits1(&s->gb)){\n\n                        const int rem_mode= get_bits(&s->gb, 3);\n\n                        mode = rem_mode + (rem_mode >= mode);\n\n                    }\n\n\n\n                    if(di==4)\n\n                        fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );\n\n                    else\n\n                        h->intra4x4_pred_mode_cache[ scan8[i] ] = mode;\n\n                }\n\n                write_back_intra_pred_mode(h);\n\n                if( check_intra4x4_pred_mode(h) < 0)\n\n                    return -1;\n\n            }else{\n\n                h->intra16x16_pred_mode= check_intra_pred_mode(h, h->intra16x16_pred_mode);\n\n                if(h->intra16x16_pred_mode < 0)\n\n                    return -1;\n\n            }\n\n\n\n            pred_mode= check_intra_pred_mode(h, get_ue_golomb(&s->gb));\n\n            if(pred_mode < 0)\n\n                return -1;\n\n            h->chroma_pred_mode= pred_mode;\n\n    }else if(partition_count==4){\n\n        int i, j, sub_partition_count[4], list, ref[2][4];\n\n\n\n        if(h->slice_type == B_TYPE){\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=13){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"B sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      b_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n            if(   IS_DIRECT(h->sub_mb_type[0]) || IS_DIRECT(h->sub_mb_type[1])\n\n               || IS_DIRECT(h->sub_mb_type[2]) || IS_DIRECT(h->sub_mb_type[3])) {\n\n                pred_direct_motion(h, &mb_type);\n\n                h->ref_cache[0][scan8[4]] =\n\n                h->ref_cache[1][scan8[4]] =\n\n                h->ref_cache[0][scan8[12]] =\n\n                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;\n\n            }\n\n        }else{\n\n            assert(h->slice_type == P_TYPE || h->slice_type == SP_TYPE); //FIXME SP correct ?\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=4){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"P sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      p_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n        }\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            int ref_count= IS_REF0(mb_type) ? 1 : h->ref_count[list];\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) continue;\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    unsigned int tmp = get_te0_golomb(&s->gb, ref_count); //FIXME init to 0 before and skip?\n\n                    if(tmp>=ref_count){\n\n                        av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", tmp);\n\n                        return -1;\n\n                    }\n\n                    ref[list][i]= tmp;\n\n                }else{\n\n                 //FIXME\n\n                    ref[list][i] = -1;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(dct8x8_allowed)\n\n            dct8x8_allowed = get_dct8x8_allowed(h);\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) {\n\n                    h->ref_cache[list][ scan8[4*i] ] = h->ref_cache[list][ scan8[4*i]+1 ];\n\n                    continue;\n\n                }\n\n                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ]=\n\n                h->ref_cache[list][ scan8[4*i]+8 ]=h->ref_cache[list][ scan8[4*i]+9 ]= ref[list][i];\n\n\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    const int sub_mb_type= h->sub_mb_type[i];\n\n                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;\n\n                    for(j=0; j<sub_partition_count[i]; j++){\n\n                        int mx, my;\n\n                        const int index= 4*i + block_width*j;\n\n                        int16_t (* mv_cache)[2]= &h->mv_cache[list][ scan8[index] ];\n\n                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        if(IS_SUB_8X8(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]=\n\n                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;\n\n                            mv_cache[ 1 ][1]=\n\n                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;\n\n                        }else if(IS_SUB_8X4(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]= mx;\n\n                            mv_cache[ 1 ][1]= my;\n\n                        }else if(IS_SUB_4X8(sub_mb_type)){\n\n                            mv_cache[ 8 ][0]= mx;\n\n                            mv_cache[ 8 ][1]= my;\n\n                        }\n\n                        mv_cache[ 0 ][0]= mx;\n\n                        mv_cache[ 0 ][1]= my;\n\n                    }\n\n                }else{\n\n                    uint32_t *p= (uint32_t *)&h->mv_cache[list][ scan8[4*i] ][0];\n\n                    p[0] = p[1]=\n\n                    p[8] = p[9]= 0;\n\n                }\n\n            }\n\n        }\n\n    }else if(IS_DIRECT(mb_type)){\n\n        pred_direct_motion(h, &mb_type);\n\n        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;\n\n    }else{\n\n        int list, mx, my, i;\n\n         //FIXME we should set ref_idx_l? to 0 if we use that later ...\n\n        if(IS_16X16(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, 0, list)){\n\n                        val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                        if(val >= h->ref_count[list]){\n\n                            av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                            return -1;\n\n                        }\n\n                    }else\n\n                        val= LIST_NOT_USED&0xFF;\n\n                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, val, 1);\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                unsigned int val;\n\n                if(IS_DIR(mb_type, 0, list)){\n\n                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my);\n\n                    mx += get_se_golomb(&s->gb);\n\n                    my += get_se_golomb(&s->gb);\n\n                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                    val= pack16to32(mx,my);\n\n                }else\n\n                    val=0;\n\n                fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, val, 4);\n\n            }\n\n        }\n\n        else if(IS_16X8(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 4);\n\n                }\n\n            }\n\n        }else{\n\n            assert(IS_8X16(mb_type));\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 4);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if(IS_INTER(mb_type))\n\n        write_back_motion(h, mb_type);\n\n\n\n    if(!IS_INTRA16x16(mb_type)){\n\n        cbp= get_ue_golomb(&s->gb);\n\n        if(cbp > 47){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"cbp too large (%u) at %d %d\\n\", cbp, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        if(IS_INTRA4x4(mb_type))\n\n            cbp= golomb_to_intra4x4_cbp[cbp];\n\n        else\n\n            cbp= golomb_to_inter_cbp[cbp];\n\n    }\n\n    h->cbp = cbp;\n\n\n\n    if(dct8x8_allowed && (cbp&15) && !IS_INTRA(mb_type)){\n\n        if(get_bits1(&s->gb))\n\n            mb_type |= MB_TYPE_8x8DCT;\n\n    }\n\n    s->current_picture.mb_type[mb_xy]= mb_type;\n\n\n\n    if(cbp || IS_INTRA16x16(mb_type)){\n\n        int i8x8, i4x4, chroma_idx;\n\n        int chroma_qp, dquant;\n\n        GetBitContext *gb= IS_INTRA(mb_type) ? h->intra_gb_ptr : h->inter_gb_ptr;\n\n        const uint8_t *scan, *scan8x8, *dc_scan;\n\n\n\n//        fill_non_zero_count_cache(h);\n\n\n\n        if(IS_INTERLACED(mb_type)){\n\n            scan8x8= s->qscale ? h->field_scan8x8_cavlc : h->field_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->field_scan : h->field_scan_q0;\n\n            dc_scan= luma_dc_field_scan;\n\n        }else{\n\n            scan8x8= s->qscale ? h->zigzag_scan8x8_cavlc : h->zigzag_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;\n\n            dc_scan= luma_dc_zigzag_scan;\n\n        }\n\n\n\n        dquant= get_se_golomb(&s->gb);\n\n\n\n        if( dquant > 25 || dquant < -26 ){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"dquant out of range (%d) at %d %d\\n\", dquant, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        s->qscale += dquant;\n\n        if(((unsigned)s->qscale) > 51){\n\n            if(s->qscale<0) s->qscale+= 52;\n\n            else            s->qscale-= 52;\n\n        }\n\n\n\n        h->chroma_qp= chroma_qp= get_chroma_qp(h->pps.chroma_qp_index_offset, s->qscale);\n\n        if(IS_INTRA16x16(mb_type)){\n\n            if( decode_residual(h, h->intra_gb_ptr, h->mb, LUMA_DC_BLOCK_INDEX, dc_scan, h->dequant4_coeff[0][s->qscale], 16) < 0){\n\n                return -1; //FIXME continue if partitioned and other return -1 too\n\n            }\n\n\n\n            assert((cbp&15) == 0 || (cbp&15) == 15);\n\n\n\n            if(cbp&15){\n\n                for(i8x8=0; i8x8<4; i8x8++){\n\n                    for(i4x4=0; i4x4<4; i4x4++){\n\n                        const int index= i4x4 + 4*i8x8;\n\n                        if( decode_residual(h, h->intra_gb_ptr, h->mb + 16*index, index, scan + 1, h->dequant4_coeff[0][s->qscale], 15) < 0 ){\n\n                            return -1;\n\n                        }\n\n                    }\n\n                }\n\n            }else{\n\n                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);\n\n            }\n\n        }else{\n\n            for(i8x8=0; i8x8<4; i8x8++){\n\n                if(cbp & (1<<i8x8)){\n\n                    if(IS_8x8DCT(mb_type)){\n\n                        DCTELEM *buf = &h->mb[64*i8x8];\n\n                        uint8_t *nnz;\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            if( decode_residual(h, gb, buf, i4x4+4*i8x8, scan8x8+16*i4x4,\n\n                                                h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 16) <0 )\n\n                                return -1;\n\n                        }\n\n                        nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                        nnz[0] += nnz[1] + nnz[8] + nnz[9];\n\n                    }else{\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            const int index= i4x4 + 4*i8x8;\n\n\n\n                            if( decode_residual(h, gb, h->mb + 16*index, index, scan, h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale], 16) <0 ){\n\n                                return -1;\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    uint8_t * const nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                    nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(cbp&0x30){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++)\n\n                if( decode_residual(h, gb, h->mb + 256 + 16*4*chroma_idx, CHROMA_DC_BLOCK_INDEX, chroma_dc_scan, NULL, 4) < 0){\n\n                    return -1;\n\n                }\n\n        }\n\n\n\n        if(cbp&0x20){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++){\n\n                const uint32_t *qmul = h->dequant4_coeff[chroma_idx+1+(IS_INTRA( mb_type ) ? 0:3)][chroma_qp];\n\n                for(i4x4=0; i4x4<4; i4x4++){\n\n                    const int index= 16 + 4*chroma_idx + i4x4;\n\n                    if( decode_residual(h, gb, h->mb + 16*index, index, scan + 1, qmul, 15) < 0){\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n            nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n        }\n\n    }else{\n\n        uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);\n\n        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n        nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n    }\n\n    s->current_picture.qscale_table[mb_xy]= s->qscale;\n\n    write_back_non_zero_count(h);\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] >>= 1;\n\n        h->ref_count[1] >>= 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23299, "substitutes": {"h": ["ha", "home", "hand", "hd", "w", "kh", "hu", "ht", "hl", "host", "gh", "th", "her", "http", "ih", "f", "zh", "q", "hist", "rh", "he", "ssh", "b", "ah", "hh", "v", "bh", "oh", "n", "header", "c", "help", "hs", "o", "H", "e", "l", "hr", "hw", "him", "ph", "hhh", "u", "ch", "sh", "history", "d", "uh", "hash", "hm", "hi", "k", "self", "m", "t", "this", "g", "eh", "z", "hp", "han", "it"], "s": ["ins", "ls", "us", "f", "si", "sb", "storage", "cs", "u", "ops", "gs", "conf", "vs", "spec", "sv", "options", "ds", "ses", "xs", "is", "b", "ts", "sc", "n", "hs", "ps", "sites", "e", "ess", "args", "services", "parts", "os", "params", "S", "ks", "w", "sym", "site", "ions", "sec", "stats", "its", "v", "c", "l", "r", "service", "ch", "qs", "sh", "es", "scope", "m", "sys", "t", "ages", "sl", "g", "has", "settings", "sets", "sq", "rs", "http", "as", "fs", "ssh", "ss", "ances", "o", "session", "d", "ssl", "su", "self", "sf", "ns", "this", "sg", "ms", "ures", "js"], "partition_count": ["partitions_size", "partitioningnumber", "partitioningweight", "partitions_map", "partitioninglength", "partition_map", "partition_size", "partitionablecount", "partition_type", "partitioningsize", "partitions_number", "partitioningcount", "partition_length", "partitionablesize", "partitions_length", "partitionableweight", "partition_number", "partitioningtype", "partitions_count", "partitionablenumber", "partition_weight", "partitions_weight", "partitions_type"], "mb_type": ["mbjclass", "mb_ty", "url_TYPE", "mbPtype", "mbJname", "mb_site", "mb_class", "mb_parent", "url_ty", "mbFtyp", "mb_rule", "mbjtype", "mb_types", "cm_length", "mbPfamily", "mb_list", "mbFfamily", "mb_shape", " MB_class", "mb_length", "mbPinfo", "bg_shape", "mbFty", "emb_types", "urlFtype", "urlFid", "mb_TYPE", "mn_typ", "url_type", "mbFinfo", "mb_info", "mn_type", "emb_name", "url_id", "mbJtypes", "mm_class", "mb_scale", "bg_scale", "mb_id", "mbJtype", "mb9rule", "bg_type", "mb9site", "mbjname", "mbJlist", "mm_site", "emb_list", "mbFid", "mb_y", "mb_spec", " MB_order", "mn_info", "urlFty", "mb_typ", "mbFTYPE", "cm_y", "cm_spec", "mbPparent", "cm_type", "mb9class", "mn_family", "emb_type", "mbPtyp", "mb_order", "mbjorder", "mm_rule", "mbPshape", "mb_family", " MB_type", "bg_parent", "urlFTYPE", " MB_name", "mbPscale", "mbFtype", "mm_type", "mb_name", "mb9type"], "cbp": ["CBv", "cbpy", "cbpc", "obP", "bbpy", "rbp", "rbpy", "rbpc", "zbp", "bbpc", "CBpc", "abbpc", "zbr", "cbr", "CBP", "abbP", "abbp", "cbP", "obp", "obpc", "CBp", "zbpy", "abbv", "rbr", "bbp", "bbr", "cbv", "zbpc", "obv"], "mb_skip_run": ["mb_run_run", "mb_run_unit", "mb_skip__runs", "mb_run__mode", "mb_skip_unit", "mb_skip__r", "mb_skip_ran", "mb_skip_r", "mb_run_runs", "mb_run_ran", "mb_skip__run", "mb_skip_skip", "mb_skipqrun", "mb_run__min", "mb_skip_min", "mb_skip_in", "mb_skip_runs", "mb_skipJmin", "mb_run_mode", "mb_run__runs", "mb_run_min", "mb_run_skip", "mb_skipqskip", "mb_skip__min", "mb_run_r", "mb_skipJruns", "mb_skipJmode", "mb_skipqr", "mb_skip__skip", "mb_skipqruns", "mb_run__run", "mb_skip_mode", "mb_skipJrun", "mb_skip__mode"], "gb": ["ym", "bm", "gg", "gom", "gp", "gc", "wb", "gm", "src", "bb", "gy", "gam", "db", "buffer", "gue", "uv", "bg", "gpu", "pc", "nb", "gal", "git", "gd", "bf", "mm", "gin", "gram", "gl", "bin", "GB", "ga", "sb", "storage", "mb", "jpg", "kb", "hub", "py", "bc", "usb", "gz", "vg", "lib", "rb"]}}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307, "substitutes": {"d": ["dm", "dc", "du", "p", "cd", "dt", "db", "bd", "ds", "f", "md", "config", "dl", "dict", "s", "D", "gd", "b", "cmd", "dh", "n", "df", "c", "da", "o", "e", "dat", "l", "fd", "u", "dd", "dom", "plugin", "dad", "data", "sd", "m", "ad", "t", "dn", "dos", "dp", "g", "z", "ld"], "address": ["shape", "capacity", "interface", "p", "answer", "date", "offset", "order", "device", "hop", "any", "email", "hello", "data", "office", "adr", "event", "en", "name", "clock", "ord", "config", "uri", "index", "align", "entry", "e", "point", "size", "target", "allow", "work", "array", "enter", "resource", "prefix", "ip", "channel", "element", "host", "reference", "mode", "length", "ress", "duration", "service", "connection", "output", "value", "ptr", "m", "server", "Address", "ace", "image", "x", "each", "attribute", "which", "eni", "block", "code", "route", "pair", "pointer", "position", "alias", "alpha", "message", "port", "layer", "attr", "direction", "number", "network"], "val": ["values", "def", "VAL", "eval", "x", "al", "cache", "test", "alloc", "p", "pr", "call", "mem", "block", "code", "ol", "el", "loc", "type", "ret", "f", "config", "stat", "valid", "bl", "aval", "v", "rel", "seq", "bin", "vol", "buf", "index", "base", "ind", "tx", "byte", "ref", "pre", "cal", "sel", "vals", "value", "rule", "fi", "bal", "pos", "data", "arr", "unit", "alt", "arg", "Val", "sl", "exec", "all", "var"], "len": ["line", "lin", "lc", "en", "Len", "mem", "code", "num", "lf", "el", "ln", "loc", "ol", "length", "lim", "lan", "dl", "valid", "bl", "lock", "v", "n", "seq", "l", "limit", "size", "ll", "pl", "li", "layer", "pos", "split", "data", "L", "alt", "fn", "fin", "lib", "lon", "sl", "z", "ld", "ann"], "can_write": ["canOveredit", "can2config", " can_read", "allow_write", "can_control", "canaycontrol", "canaywrite", "can_writing", "canaywritten", "can_writer", "canFwrite", "can_written", " can_written", "can_edit", "can_load", "allow_control", "canOverwritten", "ban_edit", "can_read", " can_writer", "ban_written", " can_writing", " can_load", "canOverwrite", "canFwriter", "can_config", "can2write", "can2writer", "allow_written", "ban_write", " can_config", "canFconfig"], "i": ["ti", "ii", "ui", "qi", "ani", "x", "I", "esi", "ix", "p", "eni", "phi", "di", "ri", "j", "info", "dim", "ai", "ini", "ie", "ni", "start", "si", "pi", "uri", "index", "ami", "n", "c", "l", "adi", "xi", "u", "chi", "uni", "fi", "li", "mini", "iu", "pos", "attr", "hi", "id", "zi", "ci", "mi", "m", "multi", "slice", "ori", "gi", "bi", "it", "ip"], "end": ["nd", "iv", "eval", "fe", "enc", "code", "num", "loc", "valid", "start", "is", "ended", "index", "dev", "ind", "rib", "byte", "value", "port", "pos", "data", "id", "Val", "sec", "all"], "addr": ["adr", "dc", "ace", "p", "eni", "ea", "enc", "host", "arm", "code", "acl", "route", "offset", "name", "loc", "ord", "mode", "config", "ack", "order", "device", "mac", "hop", "align", "amp", "index", "asm", "adder", "ady", "e", "amd", "ref", "advert", "port", "layer", "pos", "attr", "coord", "data", "direction", "ptr", "arr", "eth", "dr", "oa", "ad", "alt", "slice", "add", "enter", "Address", "node", "prefix", "ip"], "r": ["adr", "br", "ner", "mr", "rs", "w", "p", "pr", "rar", "rt", "region", "f", "s", "ro", "fr", "sr", "ru", "cr", "rh", "b", "v", "rel", "vr", "ar", "c", "err", "R", "range", "o", "rr", "nr", "e", "l", "kr", "hr", "or", "result", "u", "rd", "rn", "rc", "re", "rf", "dr", "m", "t", "er", "g", "rl", "rb", "rg"], "reg": ["debug", "br", "res", "rin", "row", "num", "ac", "rol", "region", "loc", "Reg", "par", "pg", "ret", "config", "eng", "stat", "ro", "eg", "REG", "rx", "bl", "pred", "rel", "lex", "rest", "feat", "adj", "mod", "err", " Reg", "fun", "ind", "conn", "acc", "ref", "rem", "rule", "leg", "port", "rc", "ig", "re", "sign", "org", "g", "tag", "sec", "rec", "rg", "ann"]}}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309, "substitutes": {"avctx": ["avemedia", "afsci", "Avsci", "afmedia", "avcontext", "afctx", "avsci", "avecontext", "avesci", "avmedia", "Avctx", "avectx", "Avmedia", "Avcontext", "afcontext"], "s": ["ins", "p", "us", "f", "si", "a", "sb", "cs", "u", "ops", "gs", "conf", "plugins", "this", "ubs", "your", "spec", "sv", "aws", "ims", "ses", "ds", "ches", "xs", "rows", "is", "b", "ts", "strings", "ps", "hs", "e", "args", "ies", "services", "ans", "parts", "comments", "os", "params", "ks", "S", "lines", "sym", "h", "ats", "ions", "ings", "its", "c", "ys", "r", "l", "service", "qs", "es", "m", "sys", "t", "g", "sl", "new", "settings", "sets", "sq", "rs", "sync", "als", "http", "as", "fs", "ss", "o", "session", "uns", "d", "ssl", "self", "su", "sf", "ns", "ls", "sg", "ms", "js"], "length": [" lengths", "delay", "shape", "match", "line", "p", "se", "buffer", "oh", "seq", "count", "k", "form", "total", "part", "section", "th", "j", "len", "end", "size", "pl", "child", "id", "slice", "level", "text", "el", "build", "duration", "style", "l", "tail", "ph", "limit", "sh", "value", "supp", "url", "sl", "angle", "zip", "full", "block", "Length", "code", "load", "type", "other", "lock", "sth", "position", "path", "sequence", "off", "L", "number", "list", "ength"], "v": ["ii", "iv", "x", "ev", "ve", "cv", "w", "p", "h", "nv", "tv", "code", "qv", "val", "j", "f", "uv", "q", "vv", "b", "gu", "a", "n", "volt", "c", "vol", "o", "e", "ver", "y", "l", "r", "vi", "va", "av", "limit", "u", "end", "value", "vp", "V", "conv", "vals", "d", "lv", "k", "m", "t", "vs", "g", "vd", "z", " V", "sv"], "i": ["ti", "ii", "iv", "ui", "ji", "qi", "abi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "info", "f", "ai", "cli", "ini", "oi", "ni", "ie", "is", "si", "b", "io", "pi", "uri", "index", "n", "c", "o", "ind", "e", "y", "l", "vi", "xi", "u", "yi", "fi", "li", "iu", "api", "hi", "k", "id", "mi", "ci", "zi", "multi", "slice", "gi", "ori", "z", "mu", "bi", "it", "ip"]}}
{"project": "FFmpeg", "commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n", "idx": 23323, "substitutes": {"s": ["ins", "p", "less", "us", "f", "si", "a", "sb", "cs", "u", "ops", "side", "gs", "i", "spec", "php", "support", "aws", "ims", "ses", "ds", "xs", "is", "b", "ts", "n", "ps", "e", "ing", "y", "args", "private", "services", "ans", "sup", "comments", "os", "w", "sym", "site", "stats", "ings", "its", "v", "c", "l", "service", "qs", "es", "scope", "m", "sys", "t", "g", "settings", "full", "sets", "sq", "sync", "als", "http", "as", "fs", "ss", "o", "session", "uns", "d", "ssl", "self", "su", "ns", "ls", "sg", "js"], "crc": ["crs", "circ", "csdc", " cbc", "rcrc", "Croc", "rcrs", " crs", "csroc", "csrc", "croc", "cdc", "csbc", "Crs", "cRC", "rcirc", "acirc", "cbc", "acRC", "rcRC", " cdc", " circ", "Crc", "CRC", "Cbc", " croc", " cRC", "Cdc", "acrc", "Circ", "acrs"], "S": ["C", "T", "Sa", "SN", "SE", "SP", "I", "WS", "SR", "B", "Source", "X", "PS", "M", "SA", "SU", "ST", "Socket", "D", "ss", "O", "TS", "INT", "F", "BS", "CS", "R", "U", "H", "G", "P", "SB", "Q", "N", "SI", "V", "A", "IS", "SS", "NS", "OS", "US", "L", "RS", "Si", "SH", "SC", "DS", "W", "K", "AS"], "bit": ["comment", "part", "image", "x", "text", "version", "step", "block", "pin", "cat", "all", "offset", "word", "ac", "type", "and", "f", "option", "val", "pass", "lock", "b", "second", "bug", "mask", "ct", "hop", "bin", "BIT", "feat", "hit", "bits", "slot", "Bit", "character", "byte", "token", "fix", "key", "str", "value", "bc", "digit", "flag", "input", "count", "big", "id", "null", "sign", "unit", "arg", "i", "component", "feature", "no", "tag", "binary", "g", "set", "op", "it", "ip"]}}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339, "substitutes": {"env": ["eye", "cache", "proc", "app", "chal", "equ", "sb", "G", "py", "et", "oa", "vs", "act", "ec", "ext", "global", "stage", "doc", "ev", "stack", "event", "priv", "en", "ea", "db", "_", "shell", "ef", "config", "e", "viron", "Environment", "np", "environment", "dep", "cdn", "eu", "esp", "console", "esi", "enc", "site", "dict", "enh", "vm", "init", "dat", "style", "usr", "ctx", "fg", "assets", "qt", "eni", "que", "dt", "ah", "exc", "here", "conn", "erv", "LE", "kn", "nc", "context", "exec", "loader", "skin"], "arg1": ["locinf", "oc2", "arginf", "input81", "exec2", "error81", "arg81", "exec01", "mem1", "ack2", "ang1", "agginf", "exec4", "ackname", "gu81", "arc2", "option2", "ang2", "arg3", "argann", "execOne", " arg81", "agg1", "encOne", "resultinf", "aginf", "agg81", "arm1", "mem3", "mem2", "tagname", "gu2", "argpart", "aggOne", "argumentOne", "argumentone", "angOne", "error1", "loc1", "loc81", "resultOne", "ac4", "askinf", "ag1", "acOne", "input1", "docpart", "arg4", "ocpart", "ag81", "askf", "argpre", "inputul", "ackinf", "oc1", "encname", "taginf", "rec1", " arg01", "rec81", "ang4", "argf", "arcpre", "recOne", "oc81", "enc2", "compOne", "locf", "memOne", "argOne", "doc2", "option4", "ask1", "ac2", "option1", "optionpre", "ac1", "errorinf", "result1", "result81", "arcann", "compul", "inputOne", " argpart", " arg4", "argumentpart", "argument2", "exec81", "arm81", "argument3", "ask81", "argname", "arm2", " argone", "encinf", " argpre", "execinf", "doc1", "errorf", "enc4", "execpart", "tag1", "ack1", "ic1", "arm01", " arg3", "option81", "optionann", "argone", "ac81", "comp1", "inputinf", "gu01", " argOne", "encpart", "ackOne", "argument1", "ocOne", " argName", "ocName", "ocul", " argann", "arg01", "enc1", "argul", "tagOne", "docone", "arc1", "comppart", "exec1", "argName", "inputpart", "agOne", "gu1", "recinf", "ack81", "ackName"], "arg2": ["args2", "tag2", "gen4", "valless", "idsecond", "mem1", "ag82", "ang1", "argument82", " arg6", "locto", " arg62", "ang2", "valto", "mem4", "val6", "argless", " argtwo", "ar22", "mem2", "loctwo", "ArgSecond", "arg82", "rg02", "argsecond", "tagTwo", "Argtwo", "ag62", " arg02", "argTwo", "tagless", "ag1", " arg82", "arg4", "id2", "arg5", "locless", " argTwo", "valtwo", "idtwo", "ag4", " arg5", "ang4", " argSecond", "val22", "Arg62", "enc2", "Arg2", "argtwo", "gen82", "argSecond", "args5", "ar1", "args02", "tag4", "arg6", "rg2", "rg4", "argsTwo", "ar6", "val2", "gentwo", "loc2", "ag2", "gen62", " arg4", "memSecond", "tagtwo", "argument2", "artwo", "enctwo", "args1", "id4", "arg62", "ang6", "id1", "enc4", "tag1", "argument4", "arg22", "tagto", "rg1", "Arg82", "ar4", "arg02", "ar2", "agtwo", "gen2", "arsecond", "tag82", "Arg1", "tag5", "argument1", "agsecond", "val4", "Arg4", "enc1", "argto", "gen1", "argument22", "argument6", "args4"], "mem_idx": ["mem_idp", "mem_catz", "mem_ginxp", "mem_argz", "mem_Idx", "mem_argces", "mem_IdX", "mem_midx", "mem_lengthx", "mem_ridv", "mem_numx", "mem_pathv", "mem_indcent", "mem_latex", "mem_idex", "mem_gincent", "mem_idxp", "mem_lin1", "mem_argx", "mem_linx", "mem_pathx", "mem_idxi", "mem_indxp", "mem_idsz", "mem_idz", "mem_Ide", "mem_catpe", "mem_midp", "mem_idv", "mem_latz", "mem_lat1", "mem_idsp", "mem_sidv", "mem_catxi", "mem_idspe", "mem_ridx", "mem_lengthz", "mem_Idv", "mem_sidx", "mem_sidX", "mem_idg", "mem_indz", "mem_ide", "mem_idcent", "mem_midz", "mem_argld", "mem_idsxc", "mem_sidg", "mem_linz", "mem_idpe", "mem_idld", "mem_idces", "mem_pathe", "mem_ride", "mem_midxc", "mem_Idz", "mem_id1", "mem_ridex", "mem_ginx", "mem_numz", "mem_indx", "mem_pathex", "mem_idxc", "mem_idX", "mem_numv", "mem_catx", "mem_idcode", "mem_Idg", "mem_lengthces", "mem_linex", "mem_Idex", "mem_numcode", "mem_ginz", "mem_idsxi", "mem_lengthld", "mem_idsx", "mem_Idcode", "mem_latx"], "tmp": ["req", "br", "tt", "cache", "p", "buffer", "elt", "proc", "app", "cur", "tf", "sb", "storage", "bp", "py", "pb", "dest", "pre", "opt", "ff", "diff", "data", "pad", "pkg", "fb", "wp", "ext", "var", "part", "stuff", "beta", "jp", "src", "img", "db", "now", "Temp", "config", "mp", "amp", "parent", "sup", "np", "api", "input", "alt", "mom", "mk", "wb", "bb", "tab", "buff", "bg", "vv", "nb", "vm", "v", "html", "temp", "fp", "meta", "output", "copy", "sp", "rb", "zip", "resp", "nm", "extra", "pot", "next", "bt", "buf", "cb", "appy", "vt", "result", "boot", "tp", "cp", "attr", "obj", "kk", "txt", "cmp"]}}
{"project": "FFmpeg", "commit_id": "289520fd97395ffd5bf933ac80487e858bc4039d", "target": 0, "func": "static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n        int v = get_bits(&s->gb, 8);\n\n        if (v == 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\");\n\n            return -1;\n\n        }\n\n        if (intra && i == 0 && v != 8) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v);\n\n            v = 8; // needed by pink.mpg / issue1046\n\n        }\n\n        matrix0[j] = v;\n\n        if (matrix1)\n\n            matrix1[j] = v;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23344, "substitutes": {"s": ["settings", "sets", "sq", "S", "ks", "w", "rs", "src", "p", "aws", "sync", "us", "bis", "ses", "ds", "f", "ions", "xs", "fs", "is", "si", "ts", "b", "v", "ss", "a", "c", "spec", "ps", "o", "sb", "e", "cs", "space", "r", "service", "session", "u", "services", "qs", "es", "ops", "ssl", "data", "ctx", "gs", "self", "m", "cpp", "su", "t", "sf", "client", "this", "ns", "ls", "g", "ms", "sv", "your", "sports", "js"], "matrix0": ["matrow00", "mathric0", "matri0", "matri1", "atrix2", "matric00", "mathric1", "mathrix2", "matric0", "atrow5", "matrow0", "matresh2", "matric1", "matric2", "matrix5", "matract0", "atrow00", "atrix0", "matrices1", "mathrix0", "matresh00", "matresh0", "matrices00", "matrices0", "atrix5", "matract5", "matri2", "atrow2", "mathric00", "matri00", "atrow0", "mathric2", "matrow5", "matresh5", "matrix2", "mathrix00", "mathrix1", "matrix00", "matrow2", "atrix00", "matract2", "matrices2", "matract00"], "matrix1": ["matrixI", "matrices9", "atricesx", "attric1", "attrix2", "materialric10", "attrix0", "matrorI", "matrice2", "matx10", "atrixOne", "materialrix1", "matMatrixx", "atrices0", "attric0", "materialric2", "matrixOne", "matMatrixOne", "matric0", "matricesx", "matxI", "materialricI", "matric10", "matric1", "matric2", "matMatrix0", "matrix10", "matricI", "attric9", "matricesOne", "atrix0", "matrices1", "materialric1", "matror2", "atrix1", "matMatrix1", "matx1", "matrices0", "materialrixI", "atrices1", "matrix9", "matror1", "atricesOne", "attric2", "attrix9", "matx2", "matrice0", "matrix2", "matric9", "matror10", "materialrix10", "matrices2", "attrix1", "atrixx", "materialrix2", "matrixx", "matrice1", "matrice9"], "intra": [" intbase", "intras", " intlo", "outras", "uttra", "extra", "distra", "intbase", "intri", "intlo", "extras", "inttra", "constra", "outtra", "utlo", "distras", "extri", "exttra", " inttra", "distri", "utbase", "consttra", "outra", "outri", "constbase", "constlo", "disttra", "utra"], "i": ["ti", "ii", "ui", "ji", "iv", "qi", "x", "I", "ix", "p", "eni", "di", "j", "info", "f", "ai", "ie", "ini", "ni", "oi", "start", "si", "b", "io", "v", "pi", "n", "ami", "uri", "c", "index", "o", "e", "ind", "y", "l", "vi", "xi", "u", "key", "yi", "fi", "li", "d", "iu", "hi", "k", "id", "m", "ci", "mi", "multi", "it", "gi", "z", "bi", " j", "ip"]}}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n", "idx": 23354, "substitutes": {"sig": ["Sig", "sigs", "Sigs", "figh", "fig", "figs", "Sigh", " sigs", " sigh", "sigh"], "status": ["wait", "expr", "class", "p", "Status", "atus", "current", "code", "ex", "complete", "process", "type", "msg", "stat", "s", "stats", "xml", "si", "temp", "index", "sw", "error", "args", "result", "fps", "active", "str", "STAT", "size", "uses", "progress", "worker", "ssl", "data", "id", "success", "server", "level", "sl", "serv"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)\n\n{\n\n    int current_offset = s->pixel_ptr - dst->data[0];\n\n    int motion_offset = current_offset + delta_y * dst->linesize[0]\n\n                       + delta_x * (1 + s->is_16bpp);\n\n    if (motion_offset < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motion_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (motion_offset > s->upper_motion_limit_offset) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\",\n\n            motion_offset, s->upper_motion_limit_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (src->data[0] == NULL) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,\n\n                                            dst->linesize[0], 8);\n\n    return 0;\n\n}\n", "idx": 23361, "substitutes": {"s": ["ins", "states", "sets", "S", "sq", "ks", "rs", "south", "p", "sym", "aws", "ims", "site", "sync", "us", "se", "http", "sg", "ses", "ds", "f", "xs", "is", "fs", "si", "ts", "ss", "sc", "n", "c", "spec", "ps", "sb", "e", "cs", "r", "l", "args", "service", "session", "u", "qs", "services", "source", "es", "d", "ops", "ssl", "comments", "ctx", "i", "gs", "m", "sys", "os", "t", "self", "su", "client", "sf", "conf", "ns", "ls", "g", "sl", "sv", "new", "js"], "src": ["support", "st", "inst", "iv", "ins", "sq", "rs", "secure", "sync", "img", "loc", "ds", "ses", "config", "fr", "sr", "uc", "sc", "b", "ss", "sth", "flash", "cb", "sb", "cs", "r", "dest", "sel", "source", "sup", "conv", "sur", "d", "impl", "url", "rc", "ssl", "ctx", "gs", "gb", "bs", "sl", "ls", "spec", "rb", "sn"], "dst": ["Dst", "DST", "inst", "drest", "dconst", "dsp", "dedst", " drest", "Dsc", "rdST", "dedsts", "dedsth", "adst", " dstd", "rdsts", "adsts", "adsp", "dsth", "Dsts", "instd", "inconst", "dstd", "pdsts", "sdrest", "sdsth", "sdsts", " dsc", " dconst", "pdstd", "Dsp", "dsc", " dST", "dST", "pdst", "rdst", " dsth", "dsts", "adST", "insts", "rdsp", "rdsc", "pdconst", " dsts", "dedrest", "sdst"], "delta_x": ["delt_x", "delt_y", "delta_w", "delta_l", "delt_l", "delt_w", "delt_xy", "delta2xy", "delta2x", "delta_xy", "delta2l", "delta2w"], "delta_y": ["delt_x", "delta67f", "delta_f", "delta64x", "delt_y", "delt_z", "delta_Y", "delta67ye", "delta64y", "delta_z", "delta64ye", "delta64f", "delt_Y", "delta67y", "delta67x", "delta_ye"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n", "idx": 23371, "substitutes": {"dev": ["dm", "req", "home", "debug", "def", "ev", "w", "Dev", "test", "priv", "di", "info", "md", "prom", "devices", "device", "temp", "pro", "mod", "reg", "ver", "serial", "conn", "hw", "ch", "dd", "tr", "d", "data", "conf", "dem", "pub", "cam", "dom", "de", "rad"], "s": ["settings", "params", "states", "sets", "S", "sq", "ks", "rs", "p", "sym", "sync", "site", "se", "ses", "ds", "f", "xs", "stats", "is", "fs", "ss", "ts", "b", "its", "v", "state", "c", "spec", "ps", "new", "sb", "o", "e", "cs", "r", "l", "args", "service", "session", "u", "services", "qs", "es", "d", "ops", "tests", "ssl", "uns", "gs", "i", "su", "m", "conf", "os", "t", "sys", "plugins", "vs", "this", "sl", "ls", "sg", "g", "ns", "your", "ms", "js"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374, "substitutes": {}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386, "substitutes": {"child": ["desc", "Child", "kid", "children", "cl", "cache", "p", "row", "current", "queue", "block", "ib", "http", "bit", "head", "f", "app", "q", "cur", "pc", "request", "fr", "feed", "fee", "seq", "c", "sub", "parent", "build", "ab", "r", "conn", "root", "ch", "session", "rib", "bc", "slave", "count", "job", "id", "ell", "client", "server", "lib", "g", "cell", "leaf", "inner", "pool", "serv"], "req": ["desc", "crit", "gr", "def", "compl", "res", "resp", "require", "queue", "call", "required", "rss", "http", "load", "low", "proc", "f", "config", "qq", "q", "cur", "fr", "request", "rx", "grab", "repl", "cmd", "rel", "dq", " request", "per", "seq", "pro", "sub", "err", "reg", "rr", "ver", "download", "r", "conn", "query", "ch", "ref", "requ", "quest", "worker", "pull", "rf", "job", "id", "sem", "reader", "org", "cmp", "client", "exec", "spec", "resource", "rec", "qt", "comp", "ext"], "offset": ["part", "inet", "timeout", "delay", "operation", "ace", "origin", "reset", "lower", "location", "route", "reference", "pointer", "address", "length", "Offset", "online", "offs", "aff", "start", "order", "gap", "index", "padding", "header", "uri", "position", "seed", "slot", "range", "error", "alpha", "alias", "aligned", "entry", "tile", "iso", "end", "size", "off", "initial", "layer", "pos", "url", "archive", "shift", "transfer", "slice", "skip", "addr", "phase", "absolute", "prefix"], "bytes": ["zip", "settings", "values", "hops", "lines", "units", " errors", "seconds", "abytes", "reads", "loads", "elt", "length", "s", "net", "pages", "flows", "amples", "rows", "Bytes", "io", "ets", "fee", "len", "files", "seq", "padding", "steps", "bits", "bps", "aligned", "cells", "locks", "byte", "blocks", "pieces", "boot", "groups", "parts", "errors", "vals", "size", "es", "eps", "ops", "ips", "outs", "data", "count", "les", "ones", " offsets", " bits", "ns", "items", "binary"], "align": ["delay", "il", " aligned", "cache", "al", "label", "pal", "ignment", "sync", "balance", "pair", "el", "address", "margin", "length", "join", "aff", "lace", "gap", "border", "rel", "aug", "intel", "len", "pixel", "seq", "ign", "padding", "scale", "bin", "lag", " alignment", "aligned", "alias", "adjust", "range", "tail", "batch", "byte", "format", "shake", "lap", "coord", "role", "shift", "replace", "work", "ell", "array", "sort", "addr", "lead", "repeat", "binary", "ext"], "qiov": ["qibl", " qoren", "quuno", "chiour", "qtiev", "qu\u00ef", "chiov", "qtiov", " q\u00ef", "quoren", "qiev", "quiev", " qilib", " qibl", "qqivari", " qilo", "chiev", "chivari", "Qoren", "Qilib", "quiour", "Qliv", "Qibl", "qqiov", " qivari", "quliv", "quibl", "quivari", "qtiour", "qq\u00ef", "Qiov", "quno", "quiov", "qtivari", "qivari", "q\u00ef", "qiour", "qliv", "qilib", "qquno", " quno", "Qilo", "qilo", "quilo", " qliv", "qoren", "quilib"], "flags": ["settings", "tails", "limits", "options", "lists", "linux", "reads", "offs", "stats", "planes", "ants", "fs", "types", "lins", "flows", "faces", "mask", "links", "fee", "strings", "files", "utils", "styles", "lag", "bits", "rules", "fl", "ils", "Flags", "locks", "args", "fp", "orts", "fps", "format", "lbs", "errors", "vals", "ops", "features", "tops", "FL", "flag", "FLAG", "fields", "alls"], "bs": ["lb", "settings", "abi", "rs", "bb", "ls", "css", "block", "ib", "core", "sync", "http", "db", "bid", "bis", "rss", "ds", "ses", "s", "bas", "fs", "bf", "bl", "b", "ss", "ros", "bh", "BS", "utils", "ps", "base", "cb", "sb", "bits", "bos", "bps", "cs", "ab", "bi", "blocks", "bes", "bu", "pb", "outs", "bc", "bal", "bot", "ob", "bing", "gs", "plug", "gb", "os", "bn", "abc", "bel", "fb", "vs", "js", "las", "ubs", "ns", "eb", "obs", "ba"], "drv": ["irv", "rrV", "srv", "drver", "grw", "DRV", "DRver", "drV", "irb", "rrv", "srw", "rrver", "grf", "irvin", "srf", "rrf", "Drb", "drf", " drV", "Drvin", "irf", "DRw", "drw", " drver", "DRf", "drb", " drf", "DRb", "Drf", "DRvin", "srb", "Drv", "grb", "drvin", "DRv", "grv"], "waited": ["wait", "awaait", "waitted", "awited", "awaits", "awaiter", "laited", "WAait", "Waitted", "laitted", "paitted", "WAiting", "waiter", "awiting", "wited", "waiting", "laits", "awitted", "paiting", "paused", "WAited", "WAitted", "waait", "Waiter", "waits", "waused", "witing", "awaitted", "awaited", "laiter", "Waiting", "awused", "awaiting", "Waused", "witted", "Waits", "paited", "Waited"], "ret": ["att", "match", "def", "res", "resp", "rets", "lit", "num", "rt", "bit", "val", "rev", "det", "ft", "art", "mt", "ut", "RET", "len", "back", "feat", "fun", "reg", "sat", "nt", "result", "ref", "out", "fi", " RET", "reply", "rc", "re", "flag", "obj", "id", "alt", "fin", "success", "Ret", "let"], "max_transfer": ["maxalltransfer", "limitallflush", "maxfimport", "max_trans", "limitalladdress", "max_import", " max_trans", " max_import", "maxlogtransfer", "maxallsize", "maxfsize", "limit_flush", "maxftransfer", "limit_address", "maxlogtrans", "maxlogaddress", " max_address", "limitallsize", "maxlogsize", "max_flush", "maxfaddress", "maxalladdress", " max_size", "max_size", "limit_transfer", "max_address", "maxftrans", "limitalltransfer", "maxallflush", "limit_size"]}}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "substitutes": {"bs": ["lb", "iss", "lc", "css", "sa", "http", "db", "bid", "bis", "ses", "ds", "bas", "fs", "bl", "b", "ss", "ba", "BS", "ps", "base", "sb", "bps", "bos", "bits", "cs", "cas", "fps", "bes", "bytes", "pb", "qs", "ob", "bc", "bing", "gs", "gb", "os", "fb", "vs", "las", "ubs", "ns", "ls", "eb", "rb", "obs", "bi", "js"], "sector_num": ["sectoringdom", "sector_dom", "sectoringnom", "block_num", "sectoridend", "block_number", "block_name", " sector_length", "sector_name", " sector_name", "sector_length", "sectoringnum", "sector_begin", "sectoringend", "section_dom", "block_begin", " sector_number", "sectoridnum", "sectoriddom", "sector_number", "section_end", "sector_end", "sector_nom", "sectoridnom", "section_num", "section_nom"], "buf": ["Buffer", "lb", "text", "wb", "cv", "uf", "src", "bb", "prop", "queue", "mem", "block", "num", "buff", "buffer", "loc", "lim", "val", "offset", "length", "bd", "config", "proc", "uc", "bf", "cmd", "b", "feed", "len", "seq", "padding", "feat", "cas", "vec", "path", "ab", "fd", "batch", "byte", "blocks", "fp", "ref", "pb", "limit", "end", "bag", "port", "bc", "ff", "rc", "data", "pad", "gb", "fb", "array", "rb", "pool", "bytes"], "nb_sectors": ["nb_pegments", "nb_pectors", "nb_bectors", "nb_vegments", "nb_seivers", "nb_serctions", "nb_vecs", "nb_tegments", "nb_veces", "nb_teivers", "nb_seccs", "nb_secs", "nb_vections", "nb_segments", "nb_teces", "nb_seapters", "nb_gections", "nb_serctors", "nb_vectors", "nb_beces", "nb_serapters", "nb_veivers", "nb_secgments", "nb_sercs", "nb_gecs", "nb_begments", "nb_veapters", "nb_pecs", "nb_secctors", "nb_sections", "nb_seces", "nb_beivers", "nb_pections", "nb_gectors", "nb_secctions", "nb_tectors", "nb_geapters"], "cb": ["lb", "cfg", "cf", "gc", "wb", "cv", "src", "bb", "lc", "cd", "code", "buff", "db", "buffer", "config", "func", "cmd", "b", "CB", "callback", "cod", "c", "sb", "cgi", "fp", "pb", "obb", "function", "ob", "bc", "unc", "cp", "rob", "tc", "ctx", "usb", "cpp", "conf", "abc", "gb", "fn", "fb", "ctrl", "cmp", "eb", "rb"], "opaque": ["opac", "iopace", "paque", "pace", "opec", "ipque", "ipaque", "OPaque", "opque", " opc", "pque", "OPc", "copque", "opacity", "oppacity", "oppque", "copacity", "ipace", "ipacity", "copaque", "OPec", " opac", "Opac", "opc", "copaques", "iopaques", " opacity", "iopque", "copc", "oppaque", "opace", "OPacity", "Opacity", "oppaques", "Opaque", "OPac", " opec", "pacity", "copec", "opaques", "iopaque", "iopacity"], "acb": ["ecB", "ocbs", "ainb", "ancp", "anck", "eca", "ackb", "acbf", "awa", "agbe", "ack", "ecv", "akbb", "awb", "accv", "ecsb", "accp", " acsb", "ecbb", "akb", "ocp", "acv", "accbe", "akpl", "ACbb", "ACsb", "ancb", "ackfb", " acbf", "acB", "ainob", "accsb", " acB", "ecbf", "ACb", "acbb", "ancpl", "awab", " acob", "acf", "accbb", "ainpl", "ancbb", " acbs", "ecab", "ACp", "accb", "acbe", "awv", "ocbb", "ocb", "ancbe", "accn", "ecn", "ancv", "acca", " acn", "sacbb", "ackbf", " aca", "ACB", "acab", "acbs", "ecbe", "acsb", " acp", "sacb", "ancsb", "agb", "ecp", "ackbb", "ecfb", "ecf", " acf", " acbb", "accab", "ocbe", "ock", "anca", "aca", "acfb", "acpl", "ancob", "acn", " acfb", "sacbs", "ocob", "ecb", "sacob", "agp", "ainbb", "acob", " acv", "akob", "acp", "agk", "accf"], "s": ["settings", "states", "S", "iss", "rs", "secondary", "p", "sa", "http", "bis", "ses", "status", "stats", "is", "fs", "b", "ss", "si", "state", "c", "spec", "ps", "e", "cs", "service", "session", "services", "ssl", "gs", "su", "os", "sys", "sl", "ls", "sg", "ns", "js"], "bh": ["ha", "lb", "bm", "abi", "aph", "af", "hab", "wb", "kh", "h", "bb", "bang", "ht", "hl", "gh", "acl", "hy", "http", "bd", "xb", "db", "ih", "zh", "bg", "rh", "bf", "bl", "b", "ah", "hh", "dh", "bt", "sth", "sb", "bp", "amb", "fp", "bi", "ph", "hub", "pb", "obb", "adh", "sh", "uh", "hm", "kk", "abb", "bel", "fb", "lr", "hp", "ba"]}}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 23405, "substitutes": {"child": ["global", "Child", "kid", "children", "cache", "sync", "block", "code", "bit", "uncle", "f", "brother", "cost", "cur", "pc", "feed", "cow", "fee", "c", "parent", "sub", "entry", "build", "hole", "root", "ch", "kernel", "window", "end", "port", "baby", "slave", "count", "id", "self", "client", "lib", "daughter", "cell", "leaf", "inner"], "sector_num": ["sector8name", "sector8number", " sector_count", "sector_name", " sector_name", "sector_count", "sector8count", " sector_number", "sector8num", "sector_number"], "nb_sectors": ["nb_pegments", "nb_pectors", "nb_vegments", "nb_sekers", "nb_searers", "nb_cectors", "nb_secarers", "nb_pesections", "nb_vevers", "nb_secsections", "nb_spections", "nb_vecs", "nb_cearers", "nb_sharesections", "nb_seccs", "nb_sesections", "nb_secs", "nb_cecs", "nb_segments", "nb_spegments", "nb_cesections", "nb_vectors", "nb_spectors", "nb_spesections", "nb_secgments", "nb_seckers", "nb_secvers", "nb_sharegments", "nb_sharekers", "nb_secctors", "nb_cegments", "nb_sections", "nb_severs", "nb_pections", "nb_sharectors", "nb_spekers", "nb_secctions", "nb_spearers", "nb_cevers"], "qiov": ["chimedia", "qimedia", "chiov", "piop", "coyer", "Qnox", "kimedia", "chfour", "qoyer", " qnox", "qnox", "qiop", "choyer", "koyer", "Qliv", "kfour", " qiop", "cfour", "Qiov", "Qiop", "qliv", "qfour", "pnox", "cimedia", " qliv", "ciov", "kiov", "pliv", "piov"], "flags": ["settings", "friends", "options", "forces", "lf", " Flags", "f", "stats", "ants", "fs", "lins", "faces", "mask", "fc", "fee", "files", "utils", "styles", "feat", "fun", "bits", "weights", "ils", "Flags", "args", "fd", "orts", "aux", "fps", "vals", "ops", "features", "atts", "flag", "FLAG", "fx", "plugins", "fields", "sf", "lib", "properties"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n", "idx": 23411, "substitutes": {"signal": ["ignals", "ignAL", " signAL", "signaler", "SignAL", "signAL", "Signaler", "ignaler", "Signals", " signaler", "ignal", "Signal", "signals", " signals"]}}
{"project": "FFmpeg", "commit_id": "b3f9f7a33337e9b64e6044b0010e2722fa0b2f9c", "target": 0, "func": "static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)\n\n{\n\n    MpegTSFilter *tss;\n\n    PESContext *pes;\n\n\n\n    /* if no pid found, then add a pid context */\n\n    pes = av_mallocz(sizeof(PESContext));\n\n    if (!pes)\n\n        return 0;\n\n    pes->ts = ts;\n\n    pes->stream = ts->stream;\n\n    pes->pid = pid;\n\n    pes->pcr_pid = pcr_pid;\n\n    pes->stream_type = stream_type;\n\n    pes->state = MPEGTS_SKIP;\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);\n\n    if (!tss) {\n\n        av_free(pes);\n\n        return 0;\n\n    }\n\n    return pes;\n\n}\n", "idx": 23425, "substitutes": {"ts": ["aps", "ks", "tt", "flags", "rs", "tes", "test", "options", "ats", "als", "events", "cases", "pps", "tags", "ds", "s", "as", "xs", "stats", "types", "pc", "fs", "xml", "pers", "ss", "TS", "points", "acs", "stream", "ps", "hs", "cs", "tx", "ics", "ports", "amps", "qs", "parts", "tz", "times", "tr", "tp", "ops", "tests", "tc", "tracks", "t", "las", "bs", "arts", "trans", "context", "ns", "ls", "cons", "ms", "uts", "alls", "tips"], "pid": ["po", "part", "params", "pe", "pd", "pa", "pai", "p", "pr", "prop", "phi", "pin", "pointer", "pse", "type", "proc", "proxy", "pm", "status", "uid", "pc", "pot", "did", "pins", "priority", "per", "pi", "parent", "ps", "path", "pipe", "pt", "page", "pri", "fd", "fp", "pod", "pb", "plugin", "port", "vid", "pos", "pu", "ptr", "pty", "id", "mid", "ping", "mi", "period", "sid", "phase", "pet", "px", "ip"], "pcr_pid": ["pcr__did", "pcr_port", "pcr__pin", "pcre_vid", "pcr_vid", "pci_id", "pcr_pa", "pci_uid", "pcre_did", "pcr_pin", "pcr__id", "pcre_pid", "pcr_did", "pcre_id", "pcr_id", "pcre_pin", "pci_pa", "pci_pid", "pcr_uid", "pcr__pid", "pcre_port"], "stream_type": ["stream_name", "streamtypename", "streamtypedata", "stream_base", "streamstype", " stream_data", "stream_types", " stream_base", "stream___types", "channel_level", "streamslevel", "stream_ref", "streamtypebase", "channel_name", "streamacbase", "channel_type", "stream___level", "stream___name", "channel_types", " stream_level", "streamtypetype", " stream_name", "stream_data", "streamactype", "streamstypes", "streamacdata", "stream_level", " stream_ref", "streamacname", "streamsname", "stream___type"], "tss": ["tps", "fiss", "Tiss", " tiss", "atbs", "toss", " toss", "fss", "dse", "atss", "dss", " tbs", "tmss", " trss", "dsc", "tsc", " tse", "tmSS", "tmrss", "Tss", "atsc", "Trss", "Toss", "tSS", "trss", "foss", "tbs", "frss", "tiss", "Tps", "atse", "tse", " tSS", " tps", "TSS", " tsc", "tmps", "dbs"], "pes": ["kes", "ves", "hes", "ros", "ists", "cas", "cs", "ports", "pb", "eps", "ops", "tests", "pull", "Ps", "docs", "plugins", "vs", "px", "items", "ypes", "pe", "options", "aults", "cases", "PS", "ras", "ches", "ales", "xs", "pc", "types", "ps", "pl", "ips", "ides", "cons", "ces", "alls", "params", "ks", "lines", "ases", "oe", "rss", "pse", "pages", "aves", "lex", "apps", "files", "rules", "pex", "qs", "times", "es", "ups", "posts", "pas", "apes", "settings", "aps", "phones", "rs", " pulls", "pa", "projects", "tes", "pps", "fts", "ples", "cus", "fs", "pins", "ges", "per", "ances", " copies", "amps", "features", "packs", "ppa", "ls", "ums"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void mpeg_motion_internal(MpegEncContext *s,\n\n                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                 int field_based, int bottom_field, int field_select,\n\n                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int dxy, uvdxy, mx, my, src_x, src_y,\n\n        uvsrc_x, uvsrc_y, v_edge_pos;\n\n    emuedge_linesize_type uvlinesize, linesize;\n\n\n\n#if 0\n\nif(s->quarter_sample)\n\n{\n\n    motion_x>>=1;\n\n    motion_y>>=1;\n\n}\n\n#endif\n\n\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    src_x = s->mb_x* 16               + (motion_x >> 1);\n\n    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);\n\n\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n\n        if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){\n\n            mx = (motion_x>>1)|(motion_x&1);\n\n            my = motion_y >>1;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        }else{\n\n            uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n\n            uvsrc_x = src_x>>1;\n\n            uvsrc_y = src_y>>1;\n\n        }\n\n    }else if(!is_mpeg12 && s->out_format == FMT_H261){//even chroma mv's are full pel in H261\n\n        mx = motion_x / 4;\n\n        my = motion_y / 4;\n\n        uvdxy = 0;\n\n        uvsrc_x = s->mb_x*8 + mx;\n\n        uvsrc_y =    mb_y*8 + my;\n\n    } else {\n\n        if(s->chroma_y_shift){\n\n            mx = motion_x / 2;\n\n            my = motion_y / 2;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        } else {\n\n            if(s->chroma_x_shift){\n\n            //Chroma422\n\n                mx = motion_x / 2;\n\n                uvdxy = ((motion_y & 1) << 1) | (mx & 1);\n\n                uvsrc_x = s->mb_x* 8           + (mx >> 1);\n\n                uvsrc_y = src_y;\n\n            } else {\n\n            //Chroma444\n\n                uvdxy = dxy;\n\n                uvsrc_x = src_x;\n\n                uvsrc_y = src_y;\n\n            }\n\n        }\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0)\n\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&1) - h , 0)){\n\n            if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n               s->codec_id == AV_CODEC_ID_MPEG1VIDEO){\n\n                av_log(s->avctx,AV_LOG_DEBUG,\n\n                        \"MPEG motion vector out of boundary (%d %d)\\n\", src_x, src_y);\n\n                return;\n\n            }\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n\n                                17, 17+field_based,\n\n                                src_x, src_y<<field_based,\n\n                                s->h_edge_pos, s->v_edge_pos);\n\n            ptr_y = s->edge_emu_buffer;\n\n            if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n                uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize;\n\n                s->vdsp.emulated_edge_mc(uvbuf ,\n\n                                    ptr_cb, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n\n                                    ptr_cr, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                ptr_cb= uvbuf;\n\n                ptr_cr= uvbuf+16;\n\n            }\n\n    }\n\n\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n\n        dest_y += s->linesize;\n\n        dest_cb+= s->uvlinesize;\n\n        dest_cr+= s->uvlinesize;\n\n    }\n\n\n\n    if(field_select){\n\n        ptr_y += s->linesize;\n\n        ptr_cb+= s->uvlinesize;\n\n        ptr_cr+= s->uvlinesize;\n\n    }\n\n\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n\n    }\n\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n\n         s->out_format == FMT_H261){\n\n        ff_h261_loop_filter(s);\n\n    }\n\n}\n", "idx": 23429, "substitutes": {"s": ["support", "ins", "settings", "states", "sets", "S", "sq", "ks", "w", "rs", "secondary", "p", "sym", "sync", "us", "se", "bis", "ses", "sim", "f", "ds", "stats", "is", "fs", "si", "ts", "ss", "v", "strings", "n", "c", "spec", "ps", "hs", "sb", "o", "e", "cs", "space", "ess", "service", "session", "services", "qs", "sv", "es", "d", "uns", "ops", "ssl", "comments", "gs", "su", "m", "sys", "conf", "t", "os", "sf", "self", "this", "g", "ls", "sg", "ms", "ns", "sl", "sports", "js"], "dest_y": ["dest__vy", "dest_py", "dest__yo", "Dest_py", "Dest_yo", "dest__py", "dest_yo", "Dest_vy", "Dest_y", "dest_vy", "dest__y"], "dest_cb": ["Dest_cr", "dest_bb", "Dest_rb", "dest_rb", "Dest_bb", "Dest_cb"], "dest_cr": ["src_rc", "src_rx", "dest_rb", "dest_rx", "src_rb", "src_cr", "dest_rc"], "field_based": ["file_based", "FIELD_based", "fieldlebased", "field_count", "fieldalbased", "fieldacbase", "field_Based", "field67given", "FIELD_derived", " field_joined", "field_related", "field_enabled", "fieldingrelated", "fieldlemade", "FIELD_Based", "fieldacbased", " field_found", "field2based", "field64based", "field_made", " field_count", "FIELD_built", "fieldallmade", "fieldlexBased", "fieldingbased", "fieldalgiven", "field_found", "fieldallength", "field_fixed", "fieldalcount", "fieldlexderived", "file64bad", " field_related", "field_given", "fieldacmode", "field64related", "fieldalfixed", "field2related", " field_led", "field_base", "fieldingcount", "field67base", "field_built", "fieldlexbased", " field_base", "file64based", "fieldinglength", "field_length", " field_enabled", "fieldallbased", " field_length", "fieldacfound", "field_led", "file_bad", "file64related", "field2base", "fieldalled", "field67related", "field_mode", "fieldingled", "fieldallbase", "fieldlexbuilt", "fieldlejoined", "field64bad", "fieldalljoined", " field_given", "field67fixed", "file_related", "field_bad", "field_derived", "field2enabled", " field_mode", "field_joined", "field67enabled", " field_fixed", "fieldlebase", "field67based", " field_made", "fieldingbad"], "bottom_field": ["fieldestfields", "fieldestdepth", "fieldesthidden", "field_depth", "bottom_depth", "fieldestfield", "fieldvalfield", "fieldvalfields", "fieldvaldepth", "bottom_hidden", "field_field", "bottom_fields", "field_fields", "fieldvalhidden", "field_hidden"], "field_select": ["field67selected", "field_text", "field_selected", "field67loc", "field_loc", "field67select", " field_text", " field_selected", "field67text", " field_loc"], "ref_picture": ["ref_image", "current_image", "refspicture", "refsimage", "refsauto", "ref_img", "ref_auto", "current_auto", "refsimg", "current_img", "current_picture"], "pix_op": ["picker_op", "pix2oper", "picker_opt", "pix_ops", "picker_ops", "pix2opt", "pix_opt", "pix2ops", "picker_oper", "pix_oper", "pix2op"], "motion_x": ["motion_xs", "move_x", "motion__x", "motionqey", "motion2z", "motion33x", "motion36z", "motion36y", "motion36x", "motion_xx", "motion33y", "motion_xy", "motion_ya", "motion_time", "move_ey", "motion_ey", " motion_wx", " motion_xml", "motionECya", "motion_z", "move_time", "motion__xml", "motion2y", "move_y", "motionECxml", "motion67x", " motion_z", "motion67ey", "motion33ya", " motion_ya", "move_ya", " motion_py", "motion2x", "motionECx", "motion__y", "motion33xy", "motion__ya", " motion_xy", "motionqy", "motion36wx", "move_xy", "motionqtime", " motion_xx", "motion_wx", "motionECy", "motionqx", " motion_xs", "motion_py", "motion2wx", "motion67y", "motion67time", "motion_xml"], "motion_y": ["motion__x", "video_z", "music_y", "scene_vy", "motion_oy", "motionNx", "sceneJery", "music_vy", "video_y", "music_yy", "motion___y", " motion_zy", "motion_ya", "sceneJy", "motion_vy", "motionJzy", "motionTimey", " motion_vy", "motion_yan", "motion_z", "motion___ery", "motionNzy", "motionNon", "motionJx", "motionTimez", " motion_on", "motionJoy", "motion_yy", "motion_zy", "motionNz", " motion_z", "sceneJvy", "motionTimex", "motion___vy", "motionNoy", "motion_ye", " motion_ya", "video_x", "music_ye", "motion__y", "scene_ery", "motion_ery", "motion__ya", "motionTimeyan", "scene_z", "scene_y", "motionJz", "sceneJz", "motion_on", "motionJery", "motion___z", "motionJvy", "video_yan", "motionJy", " motion_oy", "motionNy", "motion__vy"], "h": ["w", "p", "f", "q", "b", "v", "bh", "oh", "c", "hs", "o", "H", "e", "y", "l", "ch", "ph", "u", "sh", "hm", "hi", "k", "i", "m", "t", "g", "z"], "is_mpeg12": ["is_mpeg11", "is_mpeg13", "isMmpeg11", "is_peg13", "is_peg11", "isMmpeg12", "is_peg22", "is_mp12", "is_cpp13", "isMvideo13", "is_cpp11", "is_video13", "is_video12", "is_mp13", "is_mp11", "is_mp22", "is_peg6", "is_mpeg22", "isMvideo11", "isMmpeg13", "isMvideo6", "isMvideo12", "is_mp6", "is_peg12", "isMmpeg6", "is_cpp22", "is_mpeg6", "is_cpp12", "is_video6", "is_video11"], "mb_y": ["mb_z", "ghost_vy", "ghost_ry", "mp_x", "mb05x", "mb_vy", "mp_y", "mb05vy", "mb33ry", "mp_z", "mb05z", "mb_yy", "ghost_y", "mb_sy", "mb33yy", "mb_ry", "mb33y", "mp_sy", "mb05y", "mb_x", "mb33vy", "mp_vy", "ghost_yy"], "ptr_y": ["ptramevy", "ptr_ya", "ptramewy", "ptrameya", "ptr_wy", "ptramey", "ptr_vy", "dest_ya", "dest_wy", "dest_vy"], "ptr_cb": ["ptr__cb", "ptr_b", "ptr_rb", "dest_b", "ptr__fb", "ptr__rb", "ptr_fb", "dest_rb", "dest_fb", "ptr__b"], "ptr_cr": ["ptr__cb", "ptr__cr", "dest_lr", "ptr_lr", "ptr__lr", "ptr_rb", "ptr__rb", "dest_rb"], "dxy": ["dval", "bdxy", " dxp", "dcoord", "Dxy", "dxp", "bdpx", "dpx", "odxy", "pdbit", "Dpx", "odcoord", "dlxy", "pdxy", "Dcoord", "oddy", "dhxp", "dgb", " dbit", "pdval", "dlval", " ddy", " dgb", " dcoord", "dhcoord", "ddy", "dlbit", "bdpy", "bdcoord", "dlgb", " dpy", " dpx", "dbit", " dval", "dhdy", "dpy", "odxp", "dhxy", "Dpy", "pdgb"], "uvdxy": ["uvlcoord", "uzdXY", "uzdsXY", "uvfxp", "uvndphy", "tvndoxy", "uvlzx", "ufdxy", "uvndxy", "uvndquad", "ufdxp", "tvndphy", "uzdxy", "uvdlphy", "tvndquad", "ufdlcoord", "uvdlxy", "uvdloxy", "uvdXY", "uvfcoord", "uvdlzx", "uvdsXY", "ufdlxy", "uvdcxy", "uvndoxy", "tvndxy", "uvdsphy", "uvdhxxx", "uvdxxx", "uvfzx", "uvdsxy", "uvdxp", "uvdquad", "uvdsxxx", "uvdcphy", "uzdxxx", "uzdphy", "uvdcoord", "ufdcoord", "tvdquad", "ufdzx", "uvfxy", "uvdhxy", "uvdhXY", "tvdphy", "uvlxy", "uvdlxp", "uvlxp", "uvdcoxy", "tvdxy", "ufdlzx", "uvdoxy", "uzdsxxx", "uvdhphy", "uvdlquad", "ufdlxp", "uvdzx", "uzdsphy", "tvdoxy", "uzdsxy", "uvdlcoord", "uvdcquad", "uvdphy"], "mx": ["mc", "dm", "ym", "mic", "MX", "x", "mr", "xy", "wm", "yx", "wy", "mem", "mis", "loc", "zx", "pm", "md", "mos", "mn", "xml", "rx", "vm", "mm", "mp", "nz", "mor", "hop", "wx", "mod", "tx", "mag", "module", "py", "cm", "km", "np", "memory", "axy", "m", "mi", "mus", "mes", "px", "Mi", "ms", "me", "ml"], "my": ["mc", "ym", "ey", "time", "mic", "med", "mr", "x", "cy", "ix", "test", "gy", "mph", "mem", "My", "mis", " mine", "maybe", "ma", "zx", "pm", "md", "mos", "mn", "body", "by", "mm", "mor", "wx", "ami", "where", "any", "y", "mag", "ng", "module", "meta", "py", "some", "mini", "mmm", "mid", "self", "mi", "m", "make", "am", "mys", "your", "Mi", "ms", "MY", "me"], "src_x": ["src_h", "source_y", "src", "srcJxs", "source_h", "img", "_", "srcaly", "srcJX", " src_X", "srcJy", "src_xs", "source_xs", "source_x", "src_X", "srcalh", " src_xs", "pos", "url", "mpeg", "srcalx", "srcJx", "srcalxs", "g", "bytes"], "src_y": ["source_y", "src_py", "source_dy", "src_dy", " src_yt", "src_i", "src_yt", "source_py", "source_x", " src_i"], "uvsrc_x": ["uvrc_h", "uvsrc_xy", "uvsrcJx", "uvrc_x", "uvsrc_id", "uvsrc_yl", "uvsrcJy", "uvrc_px", "uvsrc_h", "uvsrc_w", "uvsrc_ix", "uvrc_xy", "uvsrc_px", "uvsrcJyl", "uvsrcJix"], "uvsrc_y": ["uvrc_asy", "uvsrcJvy", "uvsrcJx", "uvrc_x", "uvsrc_dy", "uvsource_x", "uvrc_z", "uvsource_dy", "uvsrcJy", "uvsrc_vy", "uvsrc_asy", "uvsrc_z", "uvrc_y", "uvsrcJdy", "uvsource_y", "uvsource_vy"], "v_edge_pos": ["v_ge__position", "v_edge2os", "v_line_size", "v_ge__loc", "v_edge_size", "v_edge_type", "v_edge\u00b7position", "v_edge\u00b7neg", "v_edge2neg", "v_ge_val", "v_edge__pos", "v_edge__type", "v_pe_position", "v_ge_loc", "v_ge_position", "v_line_type", "v_line_position", "v_edge__position", "v_edge2pos", "v_line_pos", "v_edge\u00b7os", "v_edge\u00b7pos", "v_edge__val", "v_edge_val", "v_pe_pos", "v_edge_neg", "v_ge_pos", "v_edge__loc", "v_pe_neg", "v_ge__val", "v_edge_position", "v_ge__pos", "v_edge_loc", "v_edge2position", "v_pe_os", "v_edge__size", "v_edge_os"], "uvlinesize": ["uvipsense", "uvpinsizing", "uvlinksization", "uvpinsization", "uvipsization", "uvlinksizer", "uvlinksize", "uvmailsization", "uvnsize", "uvlinesense", "evnsizer", "uvnsizer", "evnsization", "uvlinksense", "evlinesization", "uvpinsize", "uvlinesiz", "uvlinesizer", "uvlinesizing", "evnsense", "evlinesense", "uvmailsizing", "uvmailsiz", "uvmailsize", "uvnsense", "evlinesizer", "evnsize", "uvipsize", "uvnsization", "evlinesize", "uvpinsiz", "uvipsizer", "uvlinesization"], "linesize": ["vertsizer", "vertsization", "passize", "linkssize", "pinsiz", " Linesiz", "passsize", "codesiz", "passizer", " linesizing", " linessize", "linesiz", " Linesization", "codesizing", "linesization", "pinsize", "pinsizing", "linesIZE", "linksization", "vertssize", "linsIZE", " linesIZE", " Linesize", "linssize", "passization", " linesization", "linesizer", "linksIZE", " linesizer", "codesizer", "pinsization", "codesize", " linesiz", " Linesizer", "linsize", "linksize", "vertsize", "codesization", "linesizing", "linsization", "linessize"]}}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n", "idx": 23455, "substitutes": {"cpu": ["chip", "android", "console", "gp", "CPU", "gc", "cache", "pai", "lc", "eni", "GPU", "platform", "linux", "uci", "core", "css", "sync", "cat", "clock", "processor", "process", "cli", "proc", "config", "ocr", "gpu", "computer", "roc", "pc", "vm", "prem", "mac", "fork", "np", "cp", "progress", "pu", "uno", "cpp", "cmp", "component", "nc", "cn", "node"], "config_change": [" config_update", "configprereplace", " config_changed", "configureremove", "configpreupdate", "config_remove", "config_update", "configurechange", " config_replace", "config_changed", " config_code", " config_remove", "configureupdate", "configpreplace", "configpChange", "config_replace", "config_Change", "configprechange", "configpupdate", "configpchange", "configpreChange", " config_Change", " config_add", "config_code", "configureadd", "config_add"], "token": ["channel", "settings", "timeout", "console", "reset", "template", "platform", "code", "buffer", "processor", "type", "Token", "tool", "lock", "secret", "device", "callback", "temp", "tick", "path", "KEN", "serial", "user", "password", "module", "service", "byte", "chain", "key", "session", "icon", "function", "or", "wt", "port", "target", "data", "scope", "oken", "tty", "random", "socket", "number", "context", "tag", "binary", "resource", "prefix"]}}
{"project": "FFmpeg", "commit_id": "dde0af2df1caffb9e33855c08fc691dbbbbc72b3", "target": 0, "func": "static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)\n\n{\n\n    int i;\n\n    static const uint8_t LUT[256] = {\n\n        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n    };\n\n\n\n    /* Read all the lengths in first */\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* At most we need to read 9 bits total to get indices up to 8 */\n\n        int val = show_bits(gb, 8);\n\n\n\n        // read reverse unary\n\n        if (val) {\n\n            val = LUT[val];\n\n            skip_bits(gb, val + 1);\n\n            ctx->len[i] = val;\n\n        } else {\n\n            skip_bits(gb, 8);\n\n            if (!get_bits1(gb))\n\n                return -1;\n\n            ctx->len[i] = 8;\n\n        }\n\n    }\n\n\n\n    /* For any values that have length 0 */\n\n    memset(ctx->val, 0, ctx->size);\n\n\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* Check we have enough bits left */\n\n        if (get_bits_left(gb) < ctx->len[i])\n\n            return -1;\n\n\n\n        /* get_bits can't take a length of 0 */\n\n        if (ctx->len[i])\n\n            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23465, "substitutes": {"ctx": ["gc", "cv", "xc", "jp", "lc", "cc", "loc", "sci", "ux", " cx", "ca", "cas", "cb", "tx", "conn", "kb", "conv", "cp", "rc", "obj", "tc", "ci", "pkg", "txt", "grad", "ctrl", "cmp", "context", "voc"], "gb": ["mc", "bm", "gp", "gc", "alloc", "lc", "cc", "loc", "bg", "gpu", "git", "gd", "sc", "gin", "gt", "gl", "pt", "kb", "hw", "fi", "bc", "rc", "tc", "cca", "gs", "txt", "grad", "lib", "rb"], "i": ["ii", "ion", "I", "p", "h", "j", "f", "is", "b", "io", "v", "a", "n", "c", "e", "l", " I", "r", "or", "fi", "d", "data", "k", "id", "ci", "it"], "LUT": ["XMT", "XST", "ZST", "ZUT", "LMT", "XUT", "LST", "LTE", "DLST", "ZMT", "XTE", "DLTE", "DLUT", "DLMT", "ZTE"]}}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n\n                const AVIOInterruptCB *int_cb)\n\n{\n\n    URLProtocol *up = NULL;\n\n    char proto_str[128], proto_nested[128], *ptr;\n\n    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n\n\n\n    if (filename[proto_len] != ':' || is_dos_path(filename))\n\n        strcpy(proto_str, \"file\");\n\n    else\n\n        av_strlcpy(proto_str, filename,\n\n                   FFMIN(proto_len + 1, sizeof(proto_str)));\n\n\n\n    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n\n    if ((ptr = strchr(proto_nested, '+')))\n\n        *ptr = '\\0';\n\n\n\n    while (up = ffurl_protocol_next(up)) {\n\n        if (!strcmp(proto_str, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n\n            !strcmp(proto_nested, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n    }\n\n    *puc = NULL;\n\n    return AVERROR_PROTOCOL_NOT_FOUND;\n\n}\n", "idx": 23470, "substitutes": {"puc": ["prc", "Prc", "Puc", "pbc", "jpuc", " pou", "pac", "Pauc", "cuc", "preunc", "Pbc", " prc", "pauc", " punc", "preucc", " pucc", "pc", "pUC", "paucc", "apuc", "ccu", "preauc", "apbc", "jpucc", "jpou", "pucc", "mpbc", "punc", "mprc", "cbc", "pou", "PUC", "mpuc", " pbc", "mpUC", "preuc", "apauc", "pcu", "Pucc", " pc", "jpc", "Pcu", "Punc", " pUC", "cauc", " pauc", "paou", "apcu"], "filename": ["eger", "title", "il", "text", "setup", "src", "which", "directory", "location", "nil", "buffer", "name", "wl", "phrase", "word", "unknown", "length", "f", "document", "Filename", "dll", "vr", "files", "uri", "seq", "lp", "path", "metadata", "sequence", "nl", "fil", "download", "l", "password", "message", "fd", "fp", "source", "size", "ename", "json", "unc", "url", "whatever", "lvl", "kl", "provided", "username", "tty", "txt", "fn", "sf", "kn", "slice", "file", "subject", "loader", "rl", "binary", "prefix", "utf"], "flags": ["fixes", "settings", "dates", "lines", "options", "ls", "lf", "reads", "tags", "fts", "length", "f", "s", "flows", "stats", "offs", "planes", "types", "fs", "faces", "strings", "fee", "links", "len", "utf", "files", "utils", "buf", "ps", "lag", "bits", "rules", "fl", "nl", "ils", "Flags", "args", "fd", "fp", "ports", "fps", "groups", "parts", "vals", "features", "ops", "atts", "ids", "flag", "FLAG", "frames", "fields", "codes", "ints", "properties", "bytes"], "int_cb": ["int2cb", "int2cod", "int2callback", "intingcb", "int_callback", "intflowcb", "intflowrb", "intallfun", "int_fun", " int2callback", "intflownob", "int_bc", "intallcallback", " int_bc", "int2fun", " int_fun", " int_cod", "int_nob", " int_callback", "intingfun", "int1rb", " int2cod", " int_cf", " int_nob", "int1cf", " int_gb", "int_cf", "intflowgb", " int2cb", "intallcb", "int_cod", "int_gb", " int_rb", "intingcallback", "int1bc", "int_rb", "intingcod", "int1cb", "intallcod", " int2fun"], "up": ["po", "home", "cap", "update", "menu", "omp", "image", "line", "setup", "uf", "p", "pr", "rup", "ra", "call", "plus", "ac", "name", "upper", "f", "now", "Up", "um", "uc", "ack", "own", "back", "UP", "amp", "view", "upt", "parent", "lp", "ps", "new", "pt", "upe", "user", "flow", "ump", "ch", "uph", "u", "pre", "out", "point", "vp", "pl", "cup", "upload", "instance", "api", "imp", "upp", "ups", "one", "ahead", "ame", "down", "pkg", "cmp", "file", "ap", "loader", "inc", "op", "comp", "ip"], "proto_str": ["proto_name", "proto__enc", "proto_obj", "propos_string", "proto_doc", "propo_obj", "proto__name", "proto__seq", "propos_part", "proto\u00b7enc", "proto_pos", "proto__pos", "proto_res", "proto\u00b7obj", "propo_str", "proto__Str", "propos_req", "propo_res", "proto_seq", "profrom_arr", "proto_req", "proto_arr", "propo_doc", "profrom_seq", "profrom_str", "propo_Str", "proto__arr", "probo_Str", "proto_st", "proto_enc", "probo_st", "proto\u00b7arr", "proto_part", "propo_st", "proto\u00b7pos", "proto\u00b7str", "probo_str", "profrom_name", "propos_str", "proto\u00b7doc", "proto_string", "proto\u00b7Str", "probo_string", "proto__str", "propo_arr", "proto_Str"], "proto_nested": ["proto_ngamed", "proto_inest", "proto_nest", "proto_adjested", "proto_gnored", "proto_gnesting", "proto_ngested", "proto_inotted", "proto__named", "proto_Notted", "proto\u00b7nest", "proto\u00b7inesting", "proto_adjesting", "proto2gnested", "proto_samed", "proto2gnured", "proto__nested", "proto_nesting", "proto__nest", "proto\u00b7inotted", "proto__sested", "proto_notest", "proto2gnored", "proto_nsamed", "proto_Nerved", "proto_adjured", "proto_nured", "proto_nsest", "proto2nested", "proto_notamed", "proto_ngerved", "proto_inesting", "proto_ngest", "proto_adjored", "proto_sesting", "proto\u00b7nested", "proto_nsested", "proto\u00b7nesting", "proto_nored", "proto_Nest", "proto2gnesting", "proto_Nested", "proto\u00b7inest", "proto_Nesting", "proto_nsesting", "proto2nored", "proto_ngesting", "proto_notesting", "proto_named", "proto_notested", "proto_sest", "proto2nesting", "proto_Named", "proto\u00b7inested", "proto__sesting", "proto_inested", "proto_gnured", "proto__samed", "proto_sested", "proto__nesting", "proto_notted", "proto\u00b7notted", "proto_gnested", "proto_nerved", "proto__sest", "proto2nured"], "ptr": ["adr", "trace", "inst", "br", "src", "stack", "pr", "sym", "code", "lf", "pair", "offset", "pointer", "loc", "name", "buffer", "buff", "length", "fr", "rel", "vr", "len", "seq", "buf", "Ptr", "pt", "xp", "fd", "fp", "ref", "pre", "ctr", "str", "tr", "port", "pos", "attr", "obj", "eth", "sp", "dr", "pad", "push", "cmp", "addr", "pointers", "ext"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n", "idx": 23491, "substitutes": {"bs": ["lb", "ins", "ks", "iss", "rs", "bb", "sa", "us", "bid", "bis", "ses", "ds", "banks", "bas", "xs", "fs", "bl", "ss", "b", "ts", "state", "BS", "ps", "bps", "sb", "bp", "bos", "cs", "ab", "boxes", "bi", "blocks", "bes", "lbs", "pb", "qs", "ob", "bc", "obj", "gs", "os", "gb", "abc", "fb", "vs", "ubs", "ns", "ls", "obs", "ba", "js"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495, "substitutes": {"opaque": ["paque", "ocaque", "obque", "patile", "ipque", " ophole", "ipaque", "OPaque", "opque", "opacity", "ocatile", "opatile", "ipacity", "obaque", " opatile", "ophole", " opaques", "ipaques", "OPaques", "OPacity", "obacity", "paques", "OPque", "phole", "ochole", "opaques", "ocaques", "obaques"], "addr": ["adr", "ace", "part", " address", "src", "p", "aud", "host", "code", "pointer", "ord", "ada", "rol", "address", "mode", "frame", "config", "offset", "pc", "cmd", "mac", "asm", "seq", "align", "len", "buf", "cb", "slot", "prot", "ref", "tz", "point", "port", "pos", "rc", "data", "ptr", "afi", "dr", "pad", "ad", "ocol", "sid"], "val": ["part", "VAL", "x", "eval", "def", "al", "p", "prop", "lit", "enc", "pid", "block", "el", "buffer", "loc", "fail", "ret", "stat", "valid", "xxx", "bl", "b", "v", "len", "state", "index", "vol", "buf", "rot", "base", "reg", "slot", "pt", "ind", "tx", "vt", "ref", "pre", "sel", "vals", "value", "pos", "data", "Val", "sl", "exec", "ival", "serv"], "size": [" bytes", "eval", "mem", "type", "address", "length", "Size", "fee", "len", "padding", "SIZE", " length", "args", "str", "value", "data", "unit", "bytes"], "s": ["settings", "states", "sets", "S", "south", "ks", "x", "rs", "w", "secondary", "p", "sym", "ls", "sync", "us", "se", "ows", "ds", "ses", "f", "an", "ions", "as", "is", "b", "ts", "ss", "v", "si", "a", "its", "n", "c", "opens", "ps", "o", "sb", "grades", "e", "cs", "r", "l", "service", "session", "u", "qs", "services", "private", "es", "d", "uns", "ops", "ssl", "ips", "scope", "gs", "i", "m", "sys", "os", "t", "server", "g", "ns", "sg", "sl", "js"]}}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n", "idx": 23504, "substitutes": {"cs": ["cf", "ks", "rs", "ec", "lc", "css", "cc", "ras", "ce", "ds", "cus", "s", "cr", "pc", "fs", "sc", "ss", "acs", "c", "ys", "CS", "ck", "cas", "cks", "ps", "ics", "sk", "cp", "rc", "ctx", "k", "sys", "cons", "cn", "ls", "spec", "ns", "acks"], "run": ["ran", "update", "man", "create", "ur", "image", "runner", "row", "scan", "call", "sync", "block", "use", "rol", "name", "load", "process", "kin", "head", "config", "ro", "cr", "none", "ram", "running", "runs", "pass", "ru", "win", "view", "con", "fun", "reg", "build", "r", "play", "flow", "module", "session", "clean", "boot", "output", "read", "model", "pos", "rc", "re", "product", "job", "unit", "rain", "work", "un", "record", "add", "cn", "Run", "exec", "node", "resource", "get"], "cpu": ["mc", "lb", "chip", " CPU", "cf", "runner", "CPU", "setup", "gp", "cache", "gc", "css", "lc", "eni", "GPU", "platform", "linux", "uca", "core", "que", "sync", "PU", "clock", "processor", "kin", "cli", "proc", "load", "config", "lan", "gpu", "consumer", "roc", "pc", "computer", "net", "CU", "vm", "prem", "cow", "c", "ck", "gru", "python", "performance", "conn", "hw", "auc", "boot", "cal", "lu", "cm", "bc", "np", "cp", "login", "pu", "progress", "product", "phy", "uno", "cmp", "component", "program", "nc", "nu", "cn", "loader", "bench", "node", "piece"], "switched_level": ["switching_levels", "switchedingvel", "swipped_level", "switched_layer", "switched_info", "switchedenmessage", "switchedlexsize", "switching_vel", "switchedingsize", "switching_lock", "switching_level", "switched_size", "switchingmessage", "switch_size", "switch_level", "switching_wall", "switchedlexlevel", "switchedeninfo", "switchedlexmessage", "switch_info", "switchedinginfo", "swipped_lvl", "switched_levels", "switchedensize", "swipped_line", "switching_layer", "switchedablewall", "swipped_vel", "switchedablelevel", "switchinginfo", "switchedenlevel", "switched_line", "switchedinglevel", "switched_wall", "switchedlexinfo", "switchedinglevels", "switched_lock", "switch_message", "switched_lvl", "swipped_layer", "switched_value", "switched_message", "switching_value", "switched_vel", "switchedingmessage", "switchinglevel", "switchedablelayer", "switchingsize"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_trailer(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int res = 0;\n\n    int i, j, n, nb_frames;\n\n    int64_t file_size;\n\n\n\n    if (pb->seekable) {\n\n        if (avi->riff_id == 1) {\n\n            ff_end_tag(pb, avi->movi_list);\n\n            res = avi_write_idx1(s);\n\n            ff_end_tag(pb, avi->riff_start);\n\n        } else {\n\n            avi_write_ix(s);\n\n            ff_end_tag(pb, avi->movi_list);\n\n            ff_end_tag(pb, avi->riff_start);\n\n\n\n            file_size = avio_tell(pb);\n\n            avio_seek(pb, avi->odml_list - 8, SEEK_SET);\n\n            ffio_wfourcc(pb, \"LIST\"); /* Making this AVI OpenDML one */\n\n            avio_skip(pb, 16);\n\n\n\n            for (n = nb_frames = 0; n < s->nb_streams; n++) {\n\n                AVCodecParameters *par = s->streams[n]->codecpar;\n\n                AVIStream *avist       = s->streams[n]->priv_data;\n\n\n\n                if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                    if (nb_frames < avist->packet_count)\n\n                        nb_frames = avist->packet_count;\n\n                } else {\n\n                    if (par->codec_id == AV_CODEC_ID_MP2 ||\n\n                        par->codec_id == AV_CODEC_ID_MP3)\n\n                        nb_frames += avist->packet_count;\n\n                }\n\n            }\n\n            avio_wl32(pb, nb_frames);\n\n            avio_seek(pb, file_size, SEEK_SET);\n\n\n\n            avi_write_counters(s, avi->riff_id);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVIStream *avist = s->streams[i]->priv_data;\n\n        for (j = 0; j < avist->indexes.ents_allocated / AVI_INDEX_CLUSTER_SIZE; j++)\n\n            av_free(avist->indexes.cluster[j]);\n\n        av_freep(&avist->indexes.cluster);\n\n        avist->indexes.ents_allocated = avist->indexes.entry = 0;\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 23508, "substitutes": {"s": ["ins", "p", "us", "f", "si", "a", "sb", "cs", "photos", "ops", "bc", "tests", "gs", "plugins", "bs", "vs", "spec", "wp", "sv", "aws", "sa", "ses", "ds", "xs", "aus", "types", "is", "b", "sc", "ts", "ps", "hs", "sites", "e", "services", "sup", "api", "comments", "os", "slice", "params", "ks", "S", "sym", "h", "bis", "ions", "sci", "its", "v", "sis", "c", "l", "service", "qs", "small", "es", "m", "sys", "t", "sl", "g", "rb", "single", "settings", "sets", "sq", "series", "sync", "sim", "request", "fs", "ss", "sie", "parser", "cb", "session", "ssl", "su", "sf", "ns", "ls", "sg", "js"], "avi": ["ii", "iv", "abi", "ui", "ani", "image", "aa", "pai", "voice", "eni", "abo", "wikipedia", "sa", "pic", "di", "bis", "ai", "opus", "ini", "oi", "nav", "aci", "si", "media", "mp", "ati", "asu", "audio", "pi", "ami", "picture", "ave", "audi", "photo", "omi", "vi", "adi", "xi", "av", "vp", "fi", "liv", "mini", "music", "api", "video", "vim", "data", "archive", "afi", "mi", "multi", "sn", "aj", "cam", "anti", "imi", "bi", "fm", "umi"], "pb": ["typ", "lb", "bm", "aph", "wb", "pa", "pai", "jp", "p", "bb", "pd", "lc", "platform", "ib", "db", "xb", "phrase", "ses", "proc", "pg", "pm", "um", "pc", "nb", "uc", "bf", "b", "alist", "mp", "bh", "fc", "lab", "ub", "lp", "sb", "cb", "bp", "parser", "bps", "ab", "bos", "kb", "prot", "tmp", "fp", "hub", "pit", "py", "vp", "plugin", "pl", "summary", "tp", "bc", "PB", "rob", "api", "cp", "posts", "ctx", "ppa", "abb", "gb", "cpp", "pkg", "plugins", "fb", "bs", "dp", "eb", "wp", "rb", "fm"], "i": ["ti", "ii", "ui", "qi", "ani", "x", "I", "ix", "p", "eni", "di", "ri", "f", "ai", "ie", "ini", "ni", "oi", "start", "im", "b", "si", "init", "v", "ki", "pi", "uri", "o", "ind", "e", "y", "r", "xi", "u", "yi", "fi", "d", "li", "iu", "in", "ik", "id", "mi", "ci", "m", "ori", "gi", "z", "ip"], "j": ["ji", "ii", "ui", "jit", "br", "dj", "x", "jp", "p", "h", "jo", "el", "jet", "f", "ja", "q", "ni", "fr", "b", "jc", "v", "kj", "uj", "index", "c", "adj", "bj", "o", "fl", "jj", "ind", "e", "y", "l", "r", "ij", "key", "oj", "d", "li", "pos", "syn", "obj", "J", "job", "k", "m", "js", "un", "it", "aj", "note", "g", "z", "jl", "ip"], "n": ["ny", "nor", "ner", "x", "w", "p", "en", "current", "num", "el", "nn", "name", "an", "f", "net", "na", "ni", "nb", "coll", "mn", "not", "b", "init", "v", "a", "c", "adj", "o", "e", "y", "l", "r", "conn", "min", "ng", "nt", "N", "pn", "u", "span", "nw", "node", "d", "ne", "syn", "k", "m", "t", "fn", "un", "yn", "nc", "nu", "ns", "g", "z", "sn"], "nb_frames": ["nbxfeatures", "nb67frames", "nbwframe", "num_features", "nb_bits", "nn_frames", "nb67fps", "nb00flows", "nb_frame", "nn67lines", "nb33views", "nb48frames", "nbJviews", "nb00bits", "nb_faces", "split_bits", "nb48features", "num_flows", "nbxcycles", "num_planes", "num_faces", "nn_lines", "nbXframes", "split_flows", "nbIPflows", "nn_features", "nb_videos", "nbxframes", "nbIPframes", "nb67images", "nb_features", "nn_views", "nb_steps", "nb_cycles", "nn67frames", "nbwframes", "nb48flows", "nb_flows", "nb33frames", "nbxframe", "num_frame", "split_features", "num_steps", "nbJlines", "nbXflows", "nbwvideos", "nb67lines", "nb67features", "split00bits", "nbIPfeatures", "nb00planes", "nb_views", "nbxflows", "nb_fram", "nb33features", "nb_fps", "nbxsteps", "split00features", "num_videos", "nb48faces", "nbxvideos", "nbIPbits", "nb67planes", "nn67features", "split00flows", "nbxfram", "nb_planes", "nb33lines", "num_fps", "nb_lines", "nbwfram", "nb00images", "nb00frames", "nbXsteps", "nbJfeatures", "split00frames", "nb00fps", "nn67views", "nb67views", "num_images", "nb00features", "nb_images", "nbxfaces", "num_fram", "nbJframes", "split_frames", "num_frames", "nbXcycles", "num_cycles"], "file_size": ["cache_time", "zip_scale", "file6size", "file6source", "cache64source", "file2size", "file_name", "cache_size", "zip_length", "cache64size", "file_offset", "file_count", "filexoffset", "file64source", "file_time", "file64size", "filexsize", "file_source", "cache64count", "file_scale", "file6time", "file64time", "file6count", "zip_size", "file64count", "zip_timeout", "cache64time", "file_timeout", " file_name", "cache_source", "file_length", "filexname", "file2name", "file2offset", "cache_count", " file_offset"], "par": ["po", "pie", "params", "part", "cap", "aa", "mar", "war", "pe", "pa", "parse", "capt", "p", "pr", "pal", "proc", "star", "app", "like", "har", "as", "pc", "pass", "mp", "per", "pp", "ar", "pro", "pol", "ps", "ca", "medi", "Par", "serv", "pard", "ph", "pre", "py", "oper", "car", "arin", "dep", "sp", "cop", "param", "pas", "la", "particip", "prep", "comp", "var"], "avist": [" avast", "avort", "varistent", "ajistent", "AViz", " avism", "avaliz", "eviste", "avistent", "avalist", "ajists", "ajirst", "appIST", "avalism", "alisted", " avists", " avinst", "avant", "abiste", "avalert", "alant", "overt", "avisted", "aviste", "evIST", "AVort", "evdist", "ajinst", "avalaint", "ajism", "avism", "AViste", " avistent", "ajist", "avaliste", "evinst", "abIST", "appiste", " avaint", "ovism", " avisted", "avast", " avirst", "ajast", "aveiste", "varist", "avinst", "varaint", "ajaint", "avirst", "avaint", "avists", "aveort", "ovist", "appist", "avert", "avdist", "abdist", "AVist", "abist", "ajant", "ajisted", "aveiz", "alist", "avalort", "evists", "ovaint", " avant", "evist", "aviz", "aveist", "appdist", "evism", "varirst", " avert", "avIST", "alast"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516, "substitutes": {"opaque": ["appque", "opque", "operonymous", "opacity", " opque", "oppacity", "oppque", "transque", "opaco", "oppaco", "transonymous", " opaco", " opacity", "operaco", "operque", "oppaque", "operacity", "operaque", "transaque", "oponymous", "appaque", "appacity", "apponymous", "transacity"], "addr": ["dc", "adr", "ace", "part", "image", "x", "src", "p", "host", "code", "arch", "route", "pointer", "offset", "ord", "loc", "type", "address", "mode", "config", "func", "start", "cmd", "asm", "state", "seq", "align", "padding", "len", "index", "base", "cb", "error", "nr", "alias", "conn", "args", "byte", "handle", "point", "inter", "port", "layer", "pos", "target", "data", "ptr", "afi", "ctx", "eth", "oa", "pad", "ad", "work", "dr", "cmp", "Address", "node", "prefix", "ip"], "size": ["capacity", "x", " address", "empty", "en", "sync", "code", "offset", "name", "loc", "type", "address", "length", "s", "Size", "fee", "len", "align", "c", "SIZE", "scale", "from", "e", "or", "ize", "small", "rc", "data", "sized", "large", "g", "sec", "bytes"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n", "idx": 23540, "substitutes": {"opaque": ["opac", " opasi", "opifice", "OPaque", "ipaque", "opusac", "opacity", "opusonymous", " opace", "OPonymous", "ipace", "ipacity", "Opace", "opasi", " opac", " opacity", "ipasi", "opusifice", "opace", " oponymous", "Opacity", "Opaque", "oponymous", "OPac", "OPifice", "opusaque", " opifice", "Opasi"], "addr": ["ace", "x", "class", "src", "host", "pointer", "offset", "address", "md", "config", "mt", "device", "vr", "mac", "seq", "cb", "nr", "fd", "filename", "ref", "inter", "xd", "at", "pos", "attr", "url", "data", "ptr", "eth", "id", "oa", "dr", "ad", "pad", "arg", "od", "Address", "node", "prefix"], "val": ["VAL", "x", "eval", "al", "el", "Value", "fail", "offset", "var", "valid", "aval", "b", "v", "rel", "len", "vol", "buf", "base", "slot", "tx", "byte", "ref", "sel", "ee", "vals", "value", "pos", "data", "arr", "oval", "alt", "Val", " value", "sl", "all", "ol"], "d": ["dc", "pd", "p", "cd", "dt", "db", "ds", "f", "md", "D", "gd", "b", "dh", "c", "o", "da", "e", "dat", "ads", "l", "r", "fd", "rd", "dd", "i", "sd", "m", "ad", "t", "grad", "dos", "od", "g", "z", "ld"], "s": ["S", "sq", "w", "rs", "p", "h", "ds", "ses", "f", "fs", "b", "si", "ss", "v", "ts", "a", "n", "c", "ps", "o", "e", "l", "r", "u", "ssl", "gs", "i", "m", "os", "ad", "t", "sl", "g", "sg", "ns"]}}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555, "substitutes": {"dev": ["dm", "dc", "req", "def", "ev", "Dev", "test", "priv", "di", "ds", "info", "proc", "md", "devices", "device", "pro", "mod", "bus", "ver", "conn", "hw", "dist", "str", "tr", "d", "diff", "data", "eth", "self", "tty", "conf", "development", "grad", "pub", "cam", "de", "rad"], "errp": ["rrpc", "erip", " errf", "errfp", "rorip", "rrp", "erpc", "errP", "errf", "rrf", "rrP", "errorP", "errorpc", " errP", "erfp", " errfp", "rorfp", " errip", "errpc", "errorp", "rorpc", " errpc", "errip", "errorf", "erp", "rorp"], "fs": ["cf", "ks", "af", "flags", "ats", "linux", "ows", "ds", "fts", "f", "fr", "stats", "flows", "bf", "feed", "ss", "fc", "files", "df", "fw", "ps", "cs", "fd", "fp", "Fs", "fps", "qs", "FS", "outs", "ips", "fits", "os", "fx", "sys", "fb", "bs", "vs", "ns", "ls", "ms", "alls", "js"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n", "idx": 23560, "substitutes": {"s": ["sts", "sq", "w", "rs", "src", "p", "ls", "sa", "se", "sac", "ses", "ds", "f", "an", "sci", "as", "fs", "is", "ss", "sc", "si", "sis", "lex", "a", "c", "sb", "sed", "e", "cs", "ast", "service", "source", "es", "gs", "self", "i", "sys", "sf", "sl", "ns", "sg", "sv"], "frame": ["ace", "cf", "part", "image", "interface", "iframe", "rame", "buffer", "pse", "word", "za", "f", "document", "view", "seq", "next", "range", "framework", "e", "Frame", "flow", "fp", "window", "point", "source", "fi", "video", "data", "self", "fx", "frames", "face", "fb", "slice", "component", "feature", "scene", "fram"], "flags": ["settings", "options", "Flag", " Flags", "mode", "f", "fr", "func", "stats", " flag", "fs", "ants", "faces", "mask", "feat", "lag", "bits", "cs", "Flags", "args", "format", "kind", "ops", "features", "ips", "ffff", "flag", "FLAG"], "ist": ["adr", "st", "kt", "ism", "iss", "dit", "isc", "isd", "ide", "aci", "ists", "alist", "asp", "osi", "ista", "feat", "pect", "ast", "pt", "ind", "iste", "ess", "asi", "edit", "dist", "ais", "et", "est", "ic", "ict", "ost", "xt", "IST", "sd", "ant", "wp"], "ctx": ["ace", "cf", "sq", "cv", "p", "cu", "lc", "cc", "acl", "ac", "loc", "ds", "config", "sci", "pc", "Context", "cmd", "fc", "ct", "kw", "acs", "fw", "c", "ca", "cas", "cs", "tx", "conn", "hw", "fp", "cal", "wcs", "cp", "cca", "vc", "ci", "pkg", "cmp", "nc", "context", "cn", "comp"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "void ff_h264_idct8_add_c(uint8_t *dst, DCTELEM *block, int stride){\n\n    int i;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    block[0] += 32;\n\n\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[0+i*8] + block[4+i*8];\n\n        const int a2 =  block[0+i*8] - block[4+i*8];\n\n        const int a4 = (block[2+i*8]>>1) - block[6+i*8];\n\n        const int a6 = (block[6+i*8]>>1) + block[2+i*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[3+i*8] + block[5+i*8] - block[7+i*8] - (block[7+i*8]>>1);\n\n        const int a3 =  block[1+i*8] + block[7+i*8] - block[3+i*8] - (block[3+i*8]>>1);\n\n        const int a5 = -block[1+i*8] + block[7+i*8] + block[5+i*8] + (block[5+i*8]>>1);\n\n        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        block[0+i*8] = b0 + b7;\n\n        block[7+i*8] = b0 - b7;\n\n        block[1+i*8] = b2 + b5;\n\n        block[6+i*8] = b2 - b5;\n\n        block[2+i*8] = b4 + b3;\n\n        block[5+i*8] = b4 - b3;\n\n        block[3+i*8] = b6 + b1;\n\n        block[4+i*8] = b6 - b1;\n\n    }\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[i+0*8] + block[i+4*8];\n\n        const int a2 =  block[i+0*8] - block[i+4*8];\n\n        const int a4 = (block[i+2*8]>>1) - block[i+6*8];\n\n        const int a6 = (block[i+6*8]>>1) + block[i+2*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[i+3*8] + block[i+5*8] - block[i+7*8] - (block[i+7*8]>>1);\n\n        const int a3 =  block[i+1*8] + block[i+7*8] - block[i+3*8] - (block[i+3*8]>>1);\n\n        const int a5 = -block[i+1*8] + block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1);\n\n        const int a7 =  block[i+3*8] + block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b7) >> 6) ];\n\n        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b2 + b5) >> 6) ];\n\n        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b4 + b3) >> 6) ];\n\n        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b6 + b1) >> 6) ];\n\n        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b6 - b1) >> 6) ];\n\n        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b4 - b3) >> 6) ];\n\n        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b2 - b5) >> 6) ];\n\n        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b7) >> 6) ];\n\n    }\n\n}\n", "idx": 23576, "substitutes": {"dst": ["Dst", "DST", "Dbl", "fst", "dsc", "fbl", "dbl", " dST", "dST", " dbl", "fsc", "fST", "Dsc", " dsc"], "block": ["line", "def", "match", "box", "cache", "p", "use", "buffer", "rock", "app", "join", "device", "filter", "view", "board", "user", "module", "pre", "bc", "pull", "product", "down", "random", "open", "all", "comment", "condition", "cl", "event", "row", "contract", "core", "bit", "name", "loc", "none", "b", "header", "flow", "page", "batch", "blocks", "chain", "clean", "point", "check", "container", "Block", "work", "map", "group", "large", "ip", "channel", "wall", "panel", "word", "bug", "build", "error", "patch", "style", "space", "byte", "limit", "copy", "unit", "keep", "record", "node", "pool", "full", "image", "layout", "sync", "link", "frame", "type", "pack", "head", "object", "request", "bl", "lock", "buf", "tick", "tx", "square", "session", "ban", "plugin", "post", "off", "month", "rect", "list", "bar", "tag", "BL"], "stride": [" strider", " shride", " shrides", "slider", "strider", " strite", "slides", "strite", " shrider", "slide", " strides", " shrite", "slite", "strides"], "i": ["ti", "ui", "ii", "ji", "qi", "x", "I", "ix", "esi", "p", "eni", "phi", "di", "j", "cli", "f", "ai", "info", "s", "ini", "ie", "ni", "oi", "is", "ir", "si", "io", "b", "v", "ki", "pi", "n", "index", "uri", "c", "ei", "ami", "o", "e", "y", "l", "vi", "adi", "xi", "asi", "u", "chi", "fi", "li", "mini", "iu", "in", "at", "hi", "k", "id", "zi", "ci", "mi", "multi", "slice", "gi", "ori", "mu", "bi", "it", "ip"], "cm": ["mc", "ym", "bm", "cf", "circ", "image", "mx", "gc", "nm", "lc", "cd", "cc", "pm", "cr", "mn", "im", "mm", "ca", "cb", "rem", "bc", "km", "cp", "ci", "CM", "fm"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587, "substitutes": {"val": ["VAL", "x", "eval", "doc", "al", "test", "prop", "lit", "call", "pid", "num", "local", "el", "name", "loc", "type", "ret", "valid", "sol", "v", "len", "index", "vol", "base", "reg", "slot", "entry", "ind", "old", "byte", "ref", "key", "sel", "ee", "vals", "value", "size", "pos", "data", "count", "Val", "arg", "live", "addr", "it", "var"]}}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tlb_set_page(CPUArchState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    section = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n           \" prot=%x idx=%d pd=0x%08lx\\n\",\n\n           vaddr, paddr, prot, mmu_idx, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 23622, "substitutes": {"env": ["inet", "cf", "ner", "console", "ev", "iss", "cv", "het", "oe", "gui", "eni", "en", "enc", "ea", "forge", "que", "core", "her", "dt", "db", "el", "ef", "config", "eng", "equ", "net", "cot", "ect", "init", "ah", "eur", "exc", "anne", "chn", "dev", " environment", "fen", "dat", "e", "osc", "engine", "conn", "export", "erv", "ee", "et", "viron", "ne", "Environment", "np", "environment", "ctx", "eu", "org", "txt", "server", "edge", "context", "enter", "ette", "qt", "exec", "ec", "ext"], "vaddr": ["fhost", "vaddress", "vhost", "ivhost", " vindex", "ivaddr", " vaddress", "nvaddr", "ldb", "uaddress", "prf", "lvhost", "lvaddr", "vrf", "phop", "hhost", "fdata", "uhost", " vhost", "phost", "frf", "haddress", " vadr", "pwork", " vdb", "vdb", "pdb", "lvaddress", "nvadr", "pnode", "laddress", "nvaddress", "laddr", "pdata", "fwork", "paddress", "vindex", "uhop", " vwork", " vdata", "vwork", "hindex", " vrf", "fnode", "vnode", "faddr", " vhop", "haddr", "lvhop", "faddress", "padr", "vdata", "vhop", "vadr", "ivaddress", "nvhop", "pindex", "uaddr", "ivnode"], "paddr": ["postdata", "padd", "vaddress", " pord", "Pkg", " pdata", "appaddr", "vpaddr", "pady", " pdb", " pconn", " padd", " pkg", "vargs", "pargs", "Pord", "Padd", "vpady", "vadd", " pptr", "pconn", "vdb", "pdb", "appaddress", "pptr", "pkg", "appptr", "vkg", "Pady", "pdata", "paddress", " pady", " paddress", "vpaddress", "vconn", "postaddress", "Paddr", "vpord", "vpargs", "postaddr", "padr", "vptr", "vpconn", "Paddress", "vdata", "postadr", "vadr", "appdb", " pargs", "pord", " padr"], "prot": ["typ", "inet", "thin", "att", "rin", "cont", "het", "reset", "Prot", "prop", "lit", "sect", "platform", "pointer", "tun", "cli", "dim", "ret", "plain", "stat", "config", "det", "pattern", "gap", "chrom", "io", "len", "byter", "seq", "lat", "rot", "pro", "sector", "python", "fen", "prototype", "pt", "dat", "fl", "nat", "conn", "col", "fp", "format", "ref", "plugin", "chron", "np", "bot", "model", "rf", "ptr", "phy", "eth", "transfer", "lo", "sil", "period", "txt", "mult", "rect", "server", "rep", "prefix", "ext", "utf"], "mmu_idx": ["mmu__idx", "mmu_ider", "mmu_idg", "mmu_idxs", "mmu_startx", "mmu_starty", "mmu_idc", "mmu_ideg", "mmu_idy", "mmu_idey", "mmu_idec", "mmu_idp", "mmu_idex", "mmu__idr", "mmu_idsv", "mmu_pidz", "mmu_indg", "mmu_idest", "mmu_idsz", "mmu_pidy", "mmu_pidxs", "mmu_pidv", "mmu_idev", "mmu_indy", "mmu_idsx", "mmu_idst", "mmu__idy", "mmu_startc", "mmu__startx", "mmu__idc", "mmu_idv", "mmu_pidp", "mmu_indx", "mmu_idep", "mmu_startr", "mmu_idez", "mmu_idsp", "mmu__startr", "mmu__startc", "mmu_indst", "mmu_idz", "mmu_idexs", "mmu_pidx", "mmu_idr", "mmu__starty"], "size": ["desc", "ui", "cap", "timeout", "capacity", "shape", "south", "class", "empty", "en", "core", "code", "offset", "name", "loc", "type", "mode", "length", "eng", "max", "sec", "security", "Size", "second", "fee", "len", "uri", "scale", "SIZE", "position", "send", "storage", "sum", "export", "style", "password", "page", "connection", "ize", "six", "esc", "small", "data", "count", "sized", "unit", "shift", "large", "z"], "section": ["script", "secondary", "lc", "Section", "sector", "storage", "function", "establishment", "bc", "form", "component", "ment", "comment", " sections", "ext", "part", "version", "test", "row", "area", "sa", "core", "loc", "j", "config", "definition", "ect", "sc", "entry", "action", "fat", "sel", "rc", "environment", "division", "package", "cell", "element", "sections", "site", "sea", "region", "option", "ie", "character", "service", "connection", "small", "esc", "server", "sl", "settings", "sq", "ion", "vision", "sect", "block", "route", "setting", "security", "ct", "sub", "search", "session", "plugin", "port", "job", "sec", "pex"], "index": ["loop", "condition", "ace", "element", "shape", "update", "match", "iter", "x", "ion", "test", "sect", "access", "sync", "code", "route", "num", "offset", "val", "loc", "pointer", "type", "length", "date", "config", "ini", "lock", "si", "fee", "len", "position", "action", "error", "ind", "find", "key", "connection", "point", "end", "value", "connect", "ticket", "ne", "pos", "diff", "i", "number", "sort", "Index", "slice", " indexes", "open", "addr", "edge", "inc"], "address": ["element", "ace", "shape", "capacity", "image", "attribute", "event", "test", "en", "host", "area", "location", "code", "route", "pair", "reference", "offset", "name", "region", "ACE", "length", "type", "mode", "pointer", "object", "order", "ress", "state", "uri", "align", "header", "padding", "position", "table", "alias", "alpha", "e", "message", "password", "format", "output", "point", "value", "end", "port", "memory", "ptr", "answer", "number", "array", "component", "addr", "enter", "Address", "network", "node", "resource", "ip"], "code_address": ["code64mode", "code_position", "code2position", "codes2position", "code2number", "code2address", "codes_number", "codes2address", "code2offset", "code2index", "code64address", "codes_address", "code_index", " code_number", "codes_position", "code2addr", " code_offset", "code_mode", "code_number", "codes2number", "code_offset", "code64addr", "codes2index", "codes_index", " code_mode", " code_addr", "code_addr"], "addend": [" addbegin", "addending", " addended", "Addstart", "addstart", "addedend", "genend", "addedended", "genended", "addender", "addEnd", "incended", "endended", "callending", "addbegin", "newEnd", "addpend", "AddEnd", " addstart", "addedEnd", "newender", "adended", "Addended", "Addender", "genending", "Addend", "nextending", "endend", "Addpend", "nextend", "endstart", "newbegin", "newended", " addending", "adend", "callend", "newend", " addEnd", "addedbegin", "nextpend", "addended", "adending", "incEnd", "incend", " addpend", "callpend", "endpend", "incender"], "te": ["ti", "de", "ue", "tg", "pe", "text", "oe", "ve", "tes", "template", "test", "fe", "tm", "tre", "se", "ge", "dt", "ye", "ce", "ta", "le", "info", "je", "td", "complete", "Te", "fr", "lt", "he", "ut", "ts", "so", "see", "fee", "ae", "ss", "ade", "scale", "ke", "e", "dat", "ite", "tile", "TE", "ze", "private", "ee", "be", "tr", "ffe", "ne", "ptr", "ele", "eu", "t", "txt", "ten", "ette", "ste", "let", "me"], "iotlb": ["iottlin", "ietlb", "iotl", "inetlp", "ietb", "itlp", "iottlb", "otb", "inetlb", "ctlb", "ottlp", "iottb", "iottl", "iollp", "ntlb", "ntlib", "ottl", "ietlin", "otlb", "iottlib", "inetbl", "itlab", "ntb", "ietl", "itlb", "iotlib", "iotb", "otla", "ietlp", "iottla", "iotlr", "iotlin", "otl", "ctlp", "ctlr", "ntlin", "ottlb", "iotlab", "iollr", "iotlp", "ietbl", "iotbl", "iotla", "ctlab", "ietla", "inetl", "iollb", "iollab", "itlr", "ottbl", "ietlib"]}}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 23626, "substitutes": {"opaque": ["opac", "opaya", "ospslot", "ospaque", "opec", " ophole", "OPaque", "Opaya", "OPec", " opac", "ophole", "ospec", "ospac", "Opec", "opslot", "Opaque", "OPac", "OPhole", " opec", "Ophole", "OPaya", " opaya", "OPslot", " opslot"], "addr": ["adr", "ace", "part", "flags", "x", "al", "src", "alloc", "ea", "host", "code", "offset", "ord", "rt", "address", "proc", "mode", "md", "config", "rx", "cmd", "device", "mac", "hop", "len", "asm", "align", "ag", "vr", "seq", "osi", "mod", "cb", "slot", "anne", "ast", "r", "mag", "amd", "sta", "advert", "ref", "el", "port", "layer", "pos", "coord", "rc", "data", "ptr", "afi", "eth", "id", "dr", "pad", "ad", "alt", "oa", "pkg", "grad", "cmp", "fx", "sid", "od", "node", "ip"], "val": ["delay", "line", "VAL", "prop", "p", "pal", "lit", "lc", "buffer", "elt", "f", "valid", "gal", "a", "rot", "base", "ref", "key", "vals", "bal", "pos", "data", "lv", "count", "gb", "sil", "la", "ld", "all", "part", "al", "loc", "fail", "ret", "au", "config", "b", "fee", "len", "index", "fl", "e", "ind", "sel", "cond", "pl", "alt", "ival", "serv", "update", "eval", "ve", "text", "label", "vert", "el", "dim", "stat", "aval", "v", "rel", "change", "err", "pt", "r", "l", "va", "cal", "value", "fi", "gold", "li", "unit", "live", "sl", "quote", "vl", "x", "als", "nil", "bl", "vol", "pol", "reg", "slot", "ver", "tx", "vt", "ee", "Val", "cel", "util", "ol"], "s": ["south", "p", "se", "f", "si", "a", "sb", "cs", "u", "sk", "ops", "side", "gs", "i", "conf", "your", "spec", "sa", "ses", "an", "ds", "status", "is", "b", "ts", "n", "ps", "e", "y", "services", "private", "os", "serv", "rates", "states", "S", "lines", "w", "sym", "stat", "stats", "its", "v", "state", "c", "r", "l", "service", "es", "m", "sys", "t", "socket", "server", "client", "sl", "g", "z", "new", "settings", "sets", "sq", "x", "rs", "sync", "http", "request", "fs", "ss", "sie", "o", "session", "d", "port", "ssl", "self", "sf", "ns", "ls", "sg"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n", "idx": 23627, "substitutes": {"src": ["support", "inst", "iv", "req", "secure", "stack", "reflect", "sync", "img", "loc", "config", "cur", "sr", "start", "irc", "sc", "filter", "stream", "transform", "sub", "cb", "sb", "dest", "sel", "source", "conv", "url", "rc", "input", "gb", "sil", "rect", "gz", "grad", "slice", "sl", "spec", "rb"], "stride": ["brend", "brance", "Strided", "fride", "strided", "frided", "strider", "dride", "Stride", "Strend", "drize", "frize", " strize", " strided", " strider", "drided", "strance", "strize", "strend", "Strance", " strend", "bride", "drider", " strance", "frider", "brided"], "filter_p1": ["filter_int6", "filter_qars", "filter_q0", "filter_q6", "filter_int1", "filter_intars", "filter_r8", "filter_p6", "filter_v6", "filter_int0", "filter_vars", "filter_pars", "filter_v1", "filter_r1", "filter_p0", "filter_p11", "filter_q11", "filter_v0", "filter_p8", "filter_r11", "filter_q8", "filter_r0"], "filter_q1": ["filter_k0", "filter_f1", "filter_q2", "filter_q0", "filter_f16", "filter_qs1", "filter_kb", "filter_k1", "filter_cb", "filter_qs0", "filter_qs2", "filter_p0", "filter_qb", "filter_q16", "filter_p16", "filter_c1", "filter_f0", "filter_pb", "filter_p2", "filter_qs16", "filter_f2", "filter_c0"], "alpha": ["lambda", "aa", "LA", "zero", "area", "sa", "acl", "ac", "ma", "star", "si", "init", "average", "a", "filter", "audio", "amp", "\u03b1", "scale", "da", "mad", "error", "acc", "appa", "Alpha", "A", "qa", "diff", "i", "la", "phase", "asc", "inc", "pha", "positive"], "beta": ["gradient", "neg", "lambda", "ii", "params", "\u03b2", "pa", "zero", "binary", "phi", "offset", "ta", "margin", "b", "si", "filter", "a", "c", "da", "error", "acc", "appa", "Alpha", "negative", "qa", "eta", "phase", "Beta", "ba", "mu"], "lim_p0q0": ["lim_p0dq00", "lim_p1p1", "lim_p0p8", "lim_p1q00", "lim_p0p00", "lim_p0p5", "lim_p1q1", "lim_p0p25", "lim_p1p0", "lim_p0q5", "lim_p1q25", "lim_p0dq1", "lim_p1q8", "lim_p0p1", "lim_p0q25", "lim_p0f8", "lim_p0dq25", "lim_p0p0", "lim_p0q00", "lim_p0q1", "lim_p0f5", "lim_p1q5", "lim_p0w1", "lim_p1p8", "lim_p1q0", "lim_p0w0", "lim_p0f0", "lim_p1p25", "lim_p1p00", "lim_p0dq0", "lim_p0w5", "lim_p1p5", "lim_p0q8", "lim_p0w8", "lim_p0f1"], "lim_q1": ["lim_qs0", "lim_q101", "lim_qq1", "lim_qs5", "lim_dq5", "lim_qi101", "lim_q01", "lim_p101", "lim_qq0", "lim_p0", "lim_qq01", "lim_q5", "lim_p01", "lim_qi0", "lim_qi01", "lim_qi1", "lim_qs1", "lim_dq0", "lim_dq1", "lim_qq101", "lim_q0", "lim_p5"], "lim_p1": ["lim_l1", "lim_l81", "lim_pi01", "lim_q01", "lim_p4", "lim_q81", "lim_p0", "lim_lone", "lim_pione", "lim_p81", "lim_p01", "lim_l01", "lim_qone", "lim_pi1", "lim_q4", "lim_pone", "lim_l4", "lim_q0", "lim_pi0", "lim_l0"]}}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static int decode_subframe(WmallDecodeCtx *s)\n\n{\n\n    int offset        = s->samples_per_frame;\n\n    int subframe_len  = s->samples_per_frame;\n\n    int total_samples = s->samples_per_frame * s->num_channels;\n\n    int i, j, rawpcm_tile, padding_zeroes, res;\n\n\n\n    s->subframe_offset = get_bits_count(&s->gb);\n\n\n\n    /* reset channel context and find the next block offset and size\n\n        == the next block of the channel with the smallest number of\n\n        decoded samples */\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        if (offset > s->channel[i].decoded_samples) {\n\n            offset = s->channel[i].decoded_samples;\n\n            subframe_len =\n\n                s->channel[i].subframe_len[s->channel[i].cur_subframe];\n\n        }\n\n    }\n\n\n\n    /* get a list of all channels that contain the estimated block */\n\n    s->channels_for_cur_subframe = 0;\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        const int cur_subframe = s->channel[i].cur_subframe;\n\n        /* subtract already processed samples */\n\n        total_samples -= s->channel[i].decoded_samples;\n\n\n\n        /* and count if there are multiple subframes that match our profile */\n\n        if (offset == s->channel[i].decoded_samples &&\n\n            subframe_len == s->channel[i].subframe_len[cur_subframe]) {\n\n            total_samples -= s->channel[i].subframe_len[cur_subframe];\n\n            s->channel[i].decoded_samples +=\n\n                s->channel[i].subframe_len[cur_subframe];\n\n            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;\n\n            ++s->channels_for_cur_subframe;\n\n        }\n\n    }\n\n\n\n    /* check if the frame will be complete after processing the\n\n        estimated block */\n\n    if (!total_samples)\n\n        s->parsed_all_subframes = 1;\n\n\n\n\n\n    s->seekable_tile = get_bits1(&s->gb);\n\n    if (s->seekable_tile) {\n\n        clear_codec_buffers(s);\n\n\n\n        s->do_arith_coding    = get_bits1(&s->gb);\n\n        if (s->do_arith_coding) {\n\n            avpriv_request_sample(s->avctx, \"Arithmetic coding\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        s->do_ac_filter       = get_bits1(&s->gb);\n\n        s->do_inter_ch_decorr = get_bits1(&s->gb);\n\n        s->do_mclms           = get_bits1(&s->gb);\n\n\n\n        if (s->do_ac_filter)\n\n            decode_ac_filter(s);\n\n\n\n        if (s->do_mclms)\n\n            decode_mclms(s);\n\n\n\n        if ((res = decode_cdlms(s)) < 0)\n\n            return res;\n\n        s->movave_scaling = get_bits(&s->gb, 3);\n\n        s->quant_stepsize = get_bits(&s->gb, 8) + 1;\n\n\n\n        reset_codec(s);\n\n    } else if (!s->cdlms[0][0].order) {\n\n        av_log(s->avctx, AV_LOG_DEBUG,\n\n               \"Waiting for seekable tile\\n\");\n\n        s->frame.nb_samples = 0;\n\n        return -1;\n\n    }\n\n\n\n    rawpcm_tile = get_bits1(&s->gb);\n\n\n\n    for (i = 0; i < s->num_channels; i++)\n\n        s->is_channel_coded[i] = 1;\n\n\n\n    if (!rawpcm_tile) {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            s->is_channel_coded[i] = get_bits1(&s->gb);\n\n\n\n        if (s->bV3RTM) {\n\n            // LPC\n\n            s->do_lpc = get_bits1(&s->gb);\n\n            if (s->do_lpc) {\n\n                decode_lpc(s);\n\n                avpriv_request_sample(s->avctx, \"Expect wrong output since \"\n\n                                      \"inverse LPC filter\");\n\n            }\n\n        } else\n\n            s->do_lpc = 0;\n\n    }\n\n\n\n\n\n    if (get_bits1(&s->gb))\n\n        padding_zeroes = get_bits(&s->gb, 5);\n\n    else\n\n        padding_zeroes = 0;\n\n\n\n    if (rawpcm_tile) {\n\n        int bits = s->bits_per_sample - padding_zeroes;\n\n        if (bits <= 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Invalid number of padding bits in raw PCM tile\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        av_dlog(s->avctx, \"RAWPCM %d bits per sample. \"\n\n                \"total %d bits, remain=%d\\n\", bits,\n\n                bits * s->num_channels * subframe_len, get_bits_count(&s->gb));\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_coeffs[i][j] = get_sbits(&s->gb, bits);\n\n    } else {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            if (s->is_channel_coded[i]) {\n\n                decode_channel_residues(s, i, subframe_len);\n\n                if (s->seekable_tile)\n\n                    use_high_update_speed(s, i);\n\n                else\n\n                    use_normal_update_speed(s, i);\n\n                revert_cdlms(s, i, 0, subframe_len);\n\n            } else {\n\n                memset(s->channel_residues[i], 0, sizeof(**s->channel_residues) * subframe_len);\n\n            }\n\n    }\n\n    if (s->do_mclms)\n\n        revert_mclms(s, subframe_len);\n\n    if (s->do_inter_ch_decorr)\n\n        revert_inter_ch_decorr(s, subframe_len);\n\n    if (s->do_ac_filter)\n\n        revert_acfilter(s, subframe_len);\n\n\n\n    /* Dequantize */\n\n    if (s->quant_stepsize != 1)\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_residues[i][j] *= s->quant_stepsize;\n\n\n\n    /* Write to proper output buffer depending on bit-depth */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        int subframe_len = s->channel[c].subframe_len[s->channel[c].cur_subframe];\n\n\n\n        for (j = 0; j < subframe_len; j++) {\n\n            if (s->bits_per_sample == 16) {\n\n                *s->samples_16[c]++ = (int16_t) s->channel_residues[c][j] << padding_zeroes;\n\n            } else {\n\n                *s->samples_32[c]++ = s->channel_residues[c][j] << padding_zeroes;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handled one subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ++s->channel[c].cur_subframe;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23636, "substitutes": {"s": ["south", "p", "less", "us", "se", "f", "si", "a", "sb", "cs", "u", "gs", "conf", "plugins", "bs", "vs", "this", "spec", "aws", "ds", "ses", "ches", "xs", "is", "b", "ts", "n", "ps", "hs", "sites", "e", "y", "services", "parts", "os", "set", "params", "states", "S", "ks", "sym", "site", "stats", "its", "l", "r", "service", "qs", "es", "m", "sys", "t", "g", "full", "sets", "sq", "rs", "sync", "http", "as", "fs", "ss", "native", "o", "session", "uns", "d", "features", "ssl", "self", "su", "sf", "ns", "ls", "sg", "ms", "js"], "i": ["ii", "qi", "line", "ix", "p", "lc", "phi", "offset", "info", "f", "si", "io", "pi", "range", "module", "u", "source", "mini", "k", "mi", "multi", "ori", "ti", "ji", "iv", "I", "ri", "name", "cli", "ni", "b", "n", "index", "uri", "e", "ind", "y", "xi", "api", "id", "slice", "gi", "ip", "ui", "h", "ie", "oi", "init", "v", "l", "r", "yi", "fi", "li", "zi", "ci", "m", "t", "bi", "it", "x", "eni", "di", "type", "ai", "ini", "start", "o", "result", "d", "iu", "field", "anti", "mu"], "j": ["ji", "dj", "jp", "p", "eni", "jump", "je", "ai", "ni", "jc", "v", "n", "adj", "o", "e", "l", "r", "ij", "pos", "obj", "J", "job", "k", "m", "aj", "g", "z", "js"], "rawpcm_tile": ["rawpca_slice", "rawpca_offset", "rawpcm_offset", "rawpcm_slice", "rawpca_tile", "rawpcm_style", "rawpca_style"], "padding_zeroes": ["padding_zerones", "padding_zoos", "padding_zones", "padding_eroes", "padding_erones", "padding_ereros", "padding_zoes", "padding_zeros", "padding_eros", "padding_zereros", "padding_zoones", "padding_zos", "padding_zooes", "padding_zoeros"], "res": ["req", "resp", "rs", "reset", "row", "rss", "Res", "val", "rev", "q", "max", "seq", "ps", "err", "range", "r", "col", "blocks", "final", "vals", "rem", "eps", "pos", "resolution", "nc", "pres"], "channels_for_cur_subframe": ["channels_for_cur_perframes", "channels_for_cur_perframe", "channels_for_cur_partcomponent", "channels_for_cur_longsample", "channels_for_cur_subframes", "channels_for_cur_broadframes", "channels_for_cur_broadcomponent", "channels_for_cur_percomponent", "channels_for_cur_longframes", "channels_for_cur_microsample", "channels_for_cur_microframe", "channels_for_cur_longscale", "channels_for_cur_subsample", "channels_for_cur_longframe", "channels_for_cur_longcomponent", "channels_for_cur_subscale", "channels_for_cur_partframe", "channels_for_cur_partframes", "channels_for_cur_microscale", "channels_for_cur_subcomponent", "channels_for_cur_broadframe"], "channel": ["image", "player", "version", "queue", "call", "block", "que", "core", "config", "course", "button", "sample", "sc", "change", "pixel", "game", "stream", "scale", "error", "cycle", "character", "chan", "module", "flow", "byte", "chain", "service", "Channel", "connection", "can", "center", "source", "layer", "target", "video", "container", "unit", "client", "column", "component", "server", "file", "group", "large", "context", "scene", "package", "phase", "network", "project", "remote"], "cur_subframe": ["cur_longslice", "cur_partframes", "cur_secondframe", "cur_longsample", "cur_subface", "cur_substate", "cur_transface", "cur_partframe", "cur_difflace", "cur_subfram", "cur_singleframes", "cur_supframes", "cur_subzone", "cur_partscene", "cur_serverdraw", "cur_secondrame", "cur_suprange", "cur_broadfram", "cur_partsample", "cur_subFrame", "cur_supzone", "cur_transframe", "cur_ubscene", "cur_serverframe", "cur_broadslice", "cur_submotion", "cur_perframe", "cur_perfram", "cur_ubFrame", "cur_partFrame", "cur_persample", "cur_diffdraw", "cur_subscene", "cur_subrame", "cur_seconddraw", "cur_subframes", "cur_singlestate", "cur_transmotion", "cur_singlemotion", "cur_pubscene", "cur_transslice", "cur_supmotion", "cur_serverrame", "cur_transstate", "cur_perframes", "cur_ubframe", "cur_broadframe", "cur_difframe", "cur_subslice", "cur_supface", "cur_broadframes", "cur_singlerange", "cur_pubframe", "cur_diffframe", "cur_secondlace", "cur_ubfram", "cur_subdraw", "cur_longframe", "cur_serverlace", "cur_singleframe", "cur_pubfram", "cur_partfram", "cur_sublace", "cur_subrange", "cur_subsample", "cur_transsample", "cur_broadsample", "cur_singleface", "cur_supstate", "cur_supframe", "cur_singlezone", "cur_pubFrame"]}}
{"project": "FFmpeg", "commit_id": "1bab6f852c7ca433285d19f65c701885fa69cc57", "target": 1, "func": "static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,\n\n                                 const int16_t *ubuf[2], const int16_t *bguf[2],\n\n                                 const int16_t *abuf0, uint8_t *dest,\n\n                                 int dstW, int uvalpha, int y)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];\n\n    const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1\n\n\n\n    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1b(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n", "idx": 23643, "substitutes": {"c": ["C", "dc", "mc", "cy", "x", "w", "cit", "cache", "p", "h", "lc", "enc", "cc", "ac", "f", "s", "b", "oc", "v", "a", "n", "cb", "ca", "e", "cs", "l", "r", "u", "cm", "d", "bc", "ctx", "i", "k", "m", "ci", "cam", "g"], "buf0": ["buf4", "uf4", "cv1", " buf5", "uf6", "cf0", "port2", "buffer4", "buf2", "buff1", "buff6", "port5", "buf5", "buf00", " buf2", "cv2", "uf1", "uf0", "cf2", "cv00", "buff4", "uf00", "buff0", "cf1", "buf6", "port1", "buff2", "buffer0", "cv0", "uf2", "buffer1", " buf6", "cf00", "uf5", "port0"], "ubuf": ["ucuffer", " ubbo", "rubbuf", "ubbuff", "buffer", "abuffer", "abbuff", "ubuffy", "ubuffer", "ufbo", "ubbuf", "ucbuf", " ubbuf", "abuffy", "abbuf", "buf", "uflf", "bbuff", "abbo", " ublf", "bbuf", "ucuf", "ufbuf", "rubuffy", "rubuffer", "ucuffy", "abuf", "ablf", "ufuf", "rubuf", "ubbo", "rubbuff", "ublf"], "bguf": ["gbuf", "gbuc", "bguc", "sbbuf", "gbull", "gbbuf", "bgbuf", "sbull", "lbbuf", "lbull", "lbuf", "bgull", "lbuc", "sbuc", "sbuf"], "abuf0": ["abef1", "abf0", "abf2", "abuf2", "ubbuf0", "abef2", "abbuf2", "abuf1", "ubuf2", "ubbuf2", "abef0", "abbuf1", "abf1", "ubbuf1", "abbuf0"], "dest": ["dc", "desc", "shape", "du", "beta", "origin", "wb", "cont", "src", "prop", "test", "w", "butt", "mem", "img", "di", "dim", "config", "temp", "bin", "seed", "feat", "err", "path", "acc", "tmp", "dist", "output", "source", "opt", "ff", "gen", "target", "coord", "comb", "Dest", "dep", "shift", "txt", "trans"], "dstW": ["hestW", "dstB", "dspW", "hstW", "hstD", "dSTD", "dspB", "hstY", "hestY", "dstY", "destD", "hestD", "hestB", "dspY", "dSTY", "dSTB", "dSTW", "destY", "dstD", "destB", "hstB", "dspD", "destW"], "uvalpha": ["uvalsta", "uvalsphas", "Uvalslambda", "Uvalsta", "uevalpha", "uvalsphase", "uvalslambda", " uValpa", " uvalpa", "uselph", "uvalsph", " uValpha", "uselpha", "uValpha", "uevallambda", "Uvalphas", "uValpa", "uvalta", "Uvallambda", "uValph", "uvalph", "uvalphase", " uValph", "uvalspha", " uvalph", "uevalta", "Uvalsphas", "Uvalpha", "uevalphas", "uvalphas", " uvalphase", "Uvalta", "uvalpa", "uvallambda", " uValphase", "Uvalspha", "uvalspa", "uselphase", "uselpa", "uValphase"], "y": ["ey", "ym", "ty", "ny", "cy", "x", "w", "wy", "sy", "oy", "iy", "ry", "ys", "e", " Y", "ya", "yi", "d", "vy", "yy", "i", "yd", "yn", "dy", "Y", "z", "ay"], "ubuf0": ["abuf00", "ubuf3", "ubf0", "ubbuff00", "obuf2", "ubbuf3", "obuf00", "obf0", "ubull0", "obf2", "ubbuf0", "ubull00", "obuf1", "ubf2", "abuf1", "obf00", "obuf0", "ubbuff1", "ubbuff3", "obf1", "abbuf3", "ubuf2", "ubbuf2", "ubbuff2", "abbuf1", "abbuf00", "ubf1", "ubbuf00", "ubull1", "ubull3", "abuf3", "ubbuff0", "ubf00", "ubbuf1", "ubuf00", "abbuf0"], "ubuf1": ["ubff1", "ubufn", "ubf0", "ublf2", "ubff0", "abf0", "ubff2", "ublfn", "abf2", "abuf2", "ubbuf0", "ubf2", "abbuf2", "abuf1", "ubbuff1", "ubbufn", "ublf0", "ubuf2", "ubbuf2", "ublf1", "ubbuff2", "abbuf1", "ubbuffn", "abufn", "ubf1", "abbufn", "ubbuff0", "abf1", "ubbuf1", "abbuf0"], "buf1": ["cv1", "buffn", "ufn", "buf2", "buff1", "uf1", "uf0", "bufn", "buff0", "bufb", "buffern", "buffb", "buffer0", "ufb", "cv0", "uf2", "cvb", "buff2", "buffer1", "cv2"]}}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 23656, "substitutes": {"mon": ["channel", "my", "man", "mun", "mat", "mic", "phys", "Mon", "arm", "don", "tun", "mo", "mer", "mos", "mn", "mm", "gin", "mor", "wan", "con", "emon", "meter", "min", "mag", "module", "mut", "MON", "dom", "chron", "on", "mini", "mand", "master", "atom", "mid", "m", "un", "mot", "mons", "monitor", "mu", "amon", "ann"], "qdict": ["qualdict", "reqblock", "ktable", "qualtable", "qdb", "qualdb", "qmap", "qdi", " qdb", "reqdict", "eqdetails", "kdi", "kdict", "kmap", "qdetails", " qfile", "qumap", "qrect", "qudb", "eqrect", "reqrect", "qtable", "iqdb", "sqblock", "eqdict", "qualfile", "sqdict", "qudi", "qfile", "reqdetails", "sqrect", "qudict", "iqmap", "iqdi", " qtable", "eqblock", "iqdict", "qblock", "kfile", "sqdetails", "kdb"], "size": ["capacity", "shape", "empty", "en", "enc", "sync", "code", "offset", "name", "loc", "address", "length", "s", "sec", "start", "si", "Size", "fee", "len", "scale", "SIZE", "sum", "iz", "e", "cs", "style", "ize", "cm", "small", "esc", "external", "weight", "count", "sized", "shift", "form", "ci", "speed", "large", "z", "sn", "bytes"], "chardev": ["chardov", "chardec", "chiderv", "rownov", "cdiev", "vardov", "chardeva", "cdev", "chniev", "rowneva", "chidev", "cdnec", "chardiev", "chnov", "chnerv", "chidiev", "cdnev", "rownec", "rownev", "charderv", "vardev", "chnev", "cderv", "vardeva", "chidov", "cdneva", "cdov", "cdnov", "vardec"], "data": ["image", "partial", "text", "empty", "cache", "zero", "DATA", "code", "buffer", "extra", "response", "valid", "none", "start", "body", "media", "content", "len", "raw", "uri", "next", "padding", "a", "scale", "database", "da", "base", "dat", "alpha", "style", "space", "message", "batch", "window", "format", "output", "value", "str", "json", "pos", "memory", "missing", "input", "reader", "shift", "done", "Data", "number", "slice", "rec", "inner", "bytes"], "errp": ["erf", " errlp", "rrpc", "frlp", "rrc", "src", "errc", "errpre", " errf", "errlp", "rrp", "erpc", "erpre", "errP", "srpe", "errf", "rrf", " errpe", "erc", " errP", " errpre", "frp", "errpc", "Erc", "Erp", "Erpe", "ErP", "erlp", "srP", " errc", "frpc", "srp", " errpc", "errpe", "erp", "frpre"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int do_bit_allocation(AC3DecodeContext *ctx, int flags)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i, snroffst = 0;\n\n\n\n    if (!flags) /* bit allocation is not required */\n\n        return 0;\n\n\n\n    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */\n\n        snroffst += ab->csnroffst;\n\n        if (ab->flags & AC3_AB_CPLINU)\n\n            snroffst += ab->cplfsnroffst;\n\n        for (i = 0; i < ctx->bsi.nfchans; i++)\n\n            snroffst += ab->fsnroffst[i];\n\n        if (ctx->bsi.flags & AC3_BSI_LFEON)\n\n            snroffst += ab->lfefsnroffst;\n\n        if (!snroffst) {\n\n            memset(ab->cplbap, 0, sizeof (ab->cplbap));\n\n            for (i = 0; i < ctx->bsi.nfchans; i++)\n\n                memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n\n            memset(ab->lfebap, 0, sizeof (ab->lfebap));\n\n\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    /* perform bit allocation */\n\n    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))\n\n        if (_do_bit_allocation(ctx, 5))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (flags & (1 << i))\n\n            if (_do_bit_allocation(ctx, i))\n\n                return -1;\n\n    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))\n\n        if (_do_bit_allocation(ctx, 6))\n\n            return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 23668, "substitutes": {"ctx": ["req", "cy", "def", "cv", "cache", "lc", "anc", "kw", "ca", "cas", "com", "cs", "bc", "conf", "pkg", "grad", "xc", "src", "stack", "cc", "loc", "cli", "config", "ocr", "pc", "Context", "cmd", "sc", "fw", "cm", "qa", "rc", "abc", "prefix", "cz", "parse", "sci", "func", "uc", "wx", "c", "ga", " cx", "hw", "ch", "cal", "conv", "tc", "cca", "cpp", "ci", "cam", "cf", "cms", "gc", "sync", "cus", "fc", "ct", "exc", "ck", "cb", "tx", "conn", "kb", "wcs", "cp", "obj", "vc", "txt", "cmp", "ctrl", "nc", "context", "cn", "exec"], "flags": ["ins", "ails", "lists", " Flags", "planes", "lins", "mask", "links", "utils", "feat", "fun", "bits", "ports", "vals", "details", "ops", "requires", "atts", "bugs", "ids", "FLAG", "relations", "plugins", "fields", "fb", "vs", "acks", "bytes", "dates", "rets", "options", "heads", "reads", "does", "ipes", "status", "types", "versions", "faces", "strings", "fee", "lag", "weights", "fl", "ils", "args", "fd", "parts", "ips", "comments", "flag", "id", "ints", "alls", "values", "states", "tails", "lines", "ats", "tones", "func", "stats", "pages", "ants", "files", "mods", "styles", "rules", "Flags", "orts", "ffff", "afi", "fx", "ages", "settings", "full", "fts", "allows", "fs", "pins", "members", "locks", "fps", "includes", "features", "frames", "ags", "missions"], "ab": ["lb", "bm", "cap", "abi", "aps", "af", "hab", "pa", "al", "bb", "tab", "ib", "acl", "arch", "ac", "db", "http", "fab", "app", "ai", "um", "nb", "wa", "anc", "bf", "b", "bl", "ah", "bh", "mac", "ae", "lab", "Ab", "ub", "ca", "sb", "base", "com", "amb", "ast", "mb", "av", "hub", "pb", "obb", "web", "bag", "abl", "ob", "bc", "api", "attr", "emb", "AB", "abb", "abc", "fb", "bs", "am", "ap", "eb", "pub", "rb", "ba", "sam"], "i": ["ii", "qi", "ix", "p", "phi", "ib", "info", "f", "s", "io", "si", "a", "pi", "vi", "u", "key", "k", "mi", "multi", "ti", "ji", "I", "bit", "ri", "name", "j", "ni", "is", "b", "ki", "n", "uri", "index", "e", "y", "xi", "id", "gi", "ip", "ui", "w", "ie", "oi", "v", "c", "l", "r", "yi", "fi", "li", "hi", "zi", "ci", "m", "t", "g", "z", "bi", "it", "abi", "image", "x", "eni", "di", "type", "ai", "ini", "o", "d", "in", "iu", "anti", "mu"]}}
{"project": "qemu", "commit_id": "761731b1805f6ef64eb615e5b82a0801db3cde78", "target": 0, "func": "void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 23680, "substitutes": {"device": ["machine", "element", "image", "android", "attribute", "mobile", "directory", "host", "location", "disk", "name", "address", "driver", "gpu", "devices", "controller", "mac", "database", "dev", "serial", "Device", "engine", "module", "service", "key", "connection", "node", "value", "plugin", "port", "model", "data", "direction", "product", "mount", "unit", "compatible", "server", "component", "feature", "network", "tag", "package", "resource", "project", "remote"], "target": ["origin", "version", "template", "host", "site", "platform", "route", "type", "address", "driver", "base", "path", "range", "token", "dest", "output", "plugin", "port", "data", "unit", "Target", "file", "node", "resource", "remote"], "has_format": [" has_spec", " has_source", "has_version", "has_spec", "has_source", " has_version"], "format": ["write", "att", "stage", "version", "layout", "attribute", "event", "template", "host", "cat", "route", "name", "date", "type", "option", "address", "config", "driver", "language", "pattern", "filter", "resource", "theme", "scale", "transform", "feat", "action", "Format", "style", "patch", "module", "letter", "function", "plugin", "command", "port", "at", "api", "data", "unit", "field", "form", "ant", "sort", "feature", "file", "method", "term", "tag", "package", "standard", "prefix", "it"], "sync": ["settings", "write", "delay", "match", "stage", "class", "setup", "cache", "use", "sy", "offset", "force", "bit", "drive", "status", "config", "driver", "lock", "io", "lag", "ync", "style", "ride", "copy", "plugin", "syn", "rc", "slave", "compatible", "transfer", "sort", "custom", "spec", "Sync"], "has_mode": ["has_lane", " has_type", "has__direction", "has__mode", "has__source", " has_direction", " has_source", "has_module", "has__type", " has_module", "has_type", "has_source", "has_direction", " has_lane"], "mode": ["ui", "stage", "class", "layout", "block", "site", "code", "route", "name", "force", "type", "option", "config", "only", "object", "driver", "language", "none", "state", "view", "theme", "scale", "mod", "error", "style", "message", "module", "kind", "enabled", "off", "command", "plugin", "model", "data", "direction", "slave", "role", "grade", "id", "unit", "transfer", "multi", "m", "Mode", "number", "MODE", "disable", "group", "phase", "no", "node"], "has_speed": ["has_size", "have_size", "have_time", "have_speed", "has_weight", "have_width", "has_time", "has_sync", "have_weight", "has_driver", "have_driver", "have_sync", "has_width"], "speed": ["Speed", "time", "capacity", "seconds", "zero", "access", "name", "strength", "drive", "address", "length", "proxy", "cost", "driver", "lock", "ress", "second", "priority", "state", "index", "stream", "scale", "sw", "power", "error", "spin", "performance", "style", "engine", "rate", "peed", "service", "fps", "gain", "connect", "port", "weight", "count", "grade", "score", "sort", "frequency", "spec", "mark"], "has_on_source_error": ["has_on_parent_data", "has_on_scene_info", "has_on_sourcealror", "has_on_parent_ror", "has_on_scene_error", "has_on_scene_type", "has_on_scene_err", "has_on_sourcealerr", "has_on_source_info", "has_on_sourcealdata", "has_on_source_err", "has_on_source_ror", "has_on_sourcealerror", "has_on_parent_err", "has_on_source_data", "has_on_source_type", "has_on_parent_error"], "on_source_error": ["on_target_err", "on_source_err", "on_source_function", "on_source_ror", "on_source_bug", "on_target_bug", "on_source67ror", "on_SOURCE_ror", "on_source67function", "on_SOURCE_err", "on_SOURCE_function", "on_SOURCE_error", "on_target_ror", "on_source67err", "on_source67error"], "has_on_target_error": ["has_on_target_type", "has_on_targetappsource", "has_on_targetapperror", "has_on_targetapperr", "has_on_target_ror", "has_on_source_source", "has_on_targetappror", "has_on_source_err", "has_on_target_err", "has_on_source_ror", "has_on_target_source", "has_on_source_type"], "on_target_error": ["on_target_err", "on_source_err", "on_source_operation", "on_targetbookerror", "on_source_ror", "on_targeterserver", "on_targetbookoperation", "on_target_server", "on_target_complete", "on_targetbookror", "on_targetererror", "on_target_operation", "on_target_ror", "on_targetbookerr", "on_targetercomplete", "on_source_server", "on_targetererr", "on_source_complete"], "errp": ["lerf", " errpr", "finderr", "lerpr", "errr", "erps", "lerP", "errpr", " errps", " errf", " erf", "Erpc", "errfp", "erP", "erpc", "finderP", "errP", "errf", "errorr", "errorP", "errorpc", "erfp", " errP", " errfp", " erpr", "errpc", "err", "Erp", "ErP", "errorfp", " erp", "errps", "errorp", "finderp", " erP", "Err", " errpc", " errr", "erp", "lerp", "finderps"], "bs": ["bm", "settings", "ins", "abi", "ks", "rs", "iss", "src", "bb", "css", "us", "http", "db", "bid", "bis", "ds", "banks", "s", "bas", "fs", "bl", "b", "ss", "ts", "bh", "state", "BS", "ps", "base", "sb", "bits", "bus", "bos", "bps", "cs", "conn", "blocks", "bes", "bu", "pb", "hub", "bytes", "outs", "bc", "ops", "obj", "bing", "gs", "null", "os", "gb", "fb", "vs", "las", "lib", "ns", "ls", "obs", "bi", "js"], "target_bs": ["target_vs", "source_ds", "target_src", "source_bs", "target_ds", "source_vs", "source_src"], "source": ["image", "interface", "secure", "origin", "text", "cache", "src", "site", "core", "Source", "proxy", "status", "config", "driver", "object", "comp", "family", "security", "git", "SOURCE", "view", "index", "ources", "parent", "storage", "select", "service", "session", "dest", "dist", "ident", "inner", "port", "ssl", "slave", "scope", "input", "id", "client", "server", "slice", "component", "spec", "master", "resource", "ource", "remote"], "drv": [" drva", "DRvs", "srv", "hrb", "rdp", "prf", "hrvp", " drp", "prva", "yrvs", "hrvs", "yrp", "srf", "drf", "prv", "hrva", " drb", "prvp", "rdvs", "hrp", "yrf", "drp", "drva", "DRf", " drvs", "hrv", "drb", " drvp", " drf", "rdf", "srp", "srb", "hrf", "drvs", "rdv", "DRp", "yrv", "DRv", "drvp", "srvs"], "local_err": ["local_er", "local_progress", " local_error", " local_er", "localxerr", "local_error", "localxer", "localxerror", "localxprogress", " local_progress"], "flags": ["settings", "delay", "states", "lines", "seconds", "options", " speeds", "heads", "reads", "offset", "ds", "status", "cycles", "s", "stats", "types", "fs", "mask", "links", "len", "files", "ps", "bits", "rules", "fl", "cs", "Flags", "args", "locks", "ports", "fps", "parts", "errors", "features", "ops", "ips", "flag", "data", "frames", "alls"], "size": ["cap", "capacity", "empty", "zero", "code", "name", "loc", "go", "address", "pack", "security", "Size", "stream", "scale", "SIZE", "store", "error", "engine", "args", "ize", "weight", "pos", "grade", "ci", "addr", "sec"], "ret": ["wait", " fs", " success", "delay", "res", "rs", "rets", " timeout", " disp", " quiet", "RET", "nt", "result", " fps", "quiet", "rc", " failures", " wait", "success", " rows", "Ret", " bits", "sec", " mem"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688, "substitutes": {"opaque": ["opac", "iopacle", "ocaque", "opsaque", "OPaque", "ioponymous", "copac", "opsaques", "OPca", "opsca", "opca", "opacle", "obaque", "copaque", "ocacle", "opsac", "copca", "obacle", "obaques", "copaques", "iopaques", "obonymous", "oconymous", "OPaques", "oponymous", "OPac", "opaques", "ocaques", "iopaque"], "addr": ["adr", "ace", "x", " address", "src", "p", "ea", "host", "route", "pointer", "frame", "name", "type", "address", "mode", "offset", "config", "rt", "loc", "v", "ino", "len", "hop", "align", "index", "base", "slot", "error", "ast", "r", "fd", "amd", "sta", "handle", "ref", "point", "value", "port", "pos", "data", "ptr", "arr", "afi", "dr", "pad", "ad", "oa", "work", "arg", "cmp", "sid", "add", "node"], "val": ["VAL", "prop", "p", "lit", "pal", "elt", "valid", "base", "old", "ref", "key", "pre", "py", "vals", "pos", "data", "role", "sv", "all", "var", "item", "al", "test", "pid", "num", "loc", "fail", "ret", "len", "index", "ind", "sel", "pl", "arr", "arg", "alt", "slice", "ival", "serv", "update", "eval", "text", "ve", "enc", "mem", "el", "aval", "v", "err", "error", "pt", "cal", "value", "unit", "live", "sl", "it", "vl", "x", "code", "nil", "rol", "start", "sol", "bl", "vol", "buf", "pol", "reg", "slot", "tx", "play", "ee", "str", "Val", "ol"], "size": [" bytes", "VAL", "eval", "mem", "type", " arg", "length", " error", "Size", "v", "len", "scale", "SIZE", " length", "vals", " type", "data", " data", " mem", "bytes"], "s": ["ins", "south", "secondary", "p", "us", "se", "f", "si", "a", "sb", "cs", "u", "gs", "i", "conf", "plugins", "your", "aws", "ses", "ds", "an", "status", "address", "is", "b", "ts", "n", "ps", "e", "y", "services", "private", "os", "serv", "states", "S", "sym", "local", "bis", "stat", "stats", "v", "state", "c", "r", "l", "service", "es", "instance", "slave", "scope", "m", "sys", "t", "socket", "server", "sl", "g", "settings", "sets", "sq", "x", "rs", "sync", "as", "fs", "ss", "sie", "o", "session", "uns", "d", "port", "ssl", "self", "ns", "sg", "js"], "saddr": ["fsptr", " saddress", "fsalt", "player", " sdr", "fsattr", "sbaddress", "wspos", "dhost", "syslayer", "daddr", "sarg", " spos", "fsaddr", "sysarg", "salt", "spos", "slive", " sattr", "sysattr", "daddress", "southaddress", "sesaddr", "slayer", "sysptr", "wsaddress", "sysalt", "sbarg", " salt", "southaddr", "sespos", "sesaddress", "sysaddr", "paddress", "southhost", "sysaddress", "parg", "shost", "sattr", " sptr", "dlive", "wsdr", "sdr", "paddr", "sblayer", "saddress", "sbaddr", "wsaddr", "southlive", "sptr", "sesdr"]}}
{"project": "FFmpeg", "commit_id": "94bb1ce882a12b6d7a1fa32715a68121b39ee838", "target": 0, "func": "static int revert_channel_correlation(ALSDecContext *ctx, ALSBlockData *bd,\n\n                                       ALSChannelData **cd, int *reverted,\n\n                                       unsigned int offset, int c)\n\n{\n\n    ALSChannelData *ch = cd[c];\n\n    unsigned int   dep = 0;\n\n    unsigned int channels = ctx->avctx->channels;\n\n\n\n    if (reverted[c])\n\n        return 0;\n\n\n\n    reverted[c] = 1;\n\n\n\n    while (dep < channels && !ch[dep].stop_flag) {\n\n        revert_channel_correlation(ctx, bd, cd, reverted, offset,\n\n                                   ch[dep].master_channel);\n\n\n\n        dep++;\n\n    }\n\n\n\n    if (dep == channels) {\n\n        av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel correlation!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bd->const_block = ctx->const_block + c;\n\n    bd->shift_lsbs  = ctx->shift_lsbs + c;\n\n    bd->opt_order   = ctx->opt_order + c;\n\n    bd->store_prev_samples = ctx->store_prev_samples + c;\n\n    bd->use_ltp     = ctx->use_ltp + c;\n\n    bd->ltp_lag     = ctx->ltp_lag + c;\n\n    bd->ltp_gain    = ctx->ltp_gain[c];\n\n    bd->lpc_cof     = ctx->lpc_cof[c];\n\n    bd->quant_cof   = ctx->quant_cof[c];\n\n    bd->raw_samples = ctx->raw_samples[c] + offset;\n\n\n\n    dep = 0;\n\n    while (!ch[dep].stop_flag) {\n\n        unsigned int smp;\n\n        unsigned int begin = 1;\n\n        unsigned int end   = bd->block_length - 1;\n\n        int64_t y;\n\n        int32_t *master = ctx->raw_samples[ch[dep].master_channel] + offset;\n\n\n\n        if (ch[dep].time_diff_flag) {\n\n            int t = ch[dep].time_diff_index;\n\n\n\n            if (ch[dep].time_diff_sign) {\n\n                t      = -t;\n\n                begin -= t;\n\n            } else {\n\n                end   -= t;\n\n            }\n\n\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1    ]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp        ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1    ]) +\n\n                     MUL64(ch[dep].weighting[3], master[smp - 1 + t]) +\n\n                     MUL64(ch[dep].weighting[4], master[smp     + t]) +\n\n                     MUL64(ch[dep].weighting[5], master[smp + 1 + t]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        } else {\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp    ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        }\n\n\n\n        dep++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23692, "substitutes": {"ctx": ["dc", "ha", "support", "cfg", "cf", "cms", "kt", "prefix", "gc", "cv", "xc", "lc", "cu", "sync", "cc", "cci", "core", "loc", "ce", "cli", "config", "cus", "qq", "sci", "ku", "Context", "anc", "cmd", "sc", "git", "kw", "fw", "utils", "ck", "cb", "cas", "ca", "ia", "cs", "tx", "conn", "kb", "cycle", "hw", "service", "cal", "cm", "wcs", "bc", "qa", "cp", "rc", "tc", "cdn", "cca", "vc", "concept", "ci", "pkg", "ctrl", "cmp", "client", "component", "nc", "context", "cam", "cn", "qt"], "bd": ["dm", "dc", "nd", "bm", "lb", "cf", "hd", "pd", "bb", "dt", "lf", "db", "di", "ds", "md", "dl", "td", "nb", "bf", "bl", "gd", "cmd", "b", "dh", "bh", "kel", "gt", "bt", "df", "sth", "ade", "board", "ke", "cb", "da", "sb", "kb", "fd", "dd", "xd", "ff", "d", "bc", "bot", "kk", "dk", "gb", "bn", "ad", "BD", "bs", "wd", "od", "vd", "ld", "edd"], "cd": ["dc", "nd", "cf", "hd", "pd", "xc", "cv", "cc", "db", "CD", "md", "td", "cr", "cand", "cmd", "ct", "cod", "ck", "cb", "da", "ca", "cs", "fd", "dd", "cm", "xd", "d", "bc", "cp", "rc", "cdn", "ci", "ad", "ecd", "cle", "ld"], "reverted": ["retjected", "convert", "pererved", "changevert", "referred", "reerved", "renverts", "inverted", "preverted", "recverted", "changeverted", "changearted", "renferred", "retverts", "refvert", "changeverting", "renvert", "perjected", "perferred", "renerved", "relverted", "prearted", "invert", "invered", "refverting", "converted", "refverted", "recvert", "retvert", "reverts", "recjected", "inverting", "renjected", "convered", "prevered", "refarted", "reljected", "revert", "rejected", "perverted", "relerved", "converting", "prevert", "reverting", "renverted", "preverting", "rearted", "revered", "retverted", "recverts", "relferred"], "offset": ["bound", "part", "delay", "timeout", "origin", "attribute", "scroll", "reset", "p", "location", "depth", "clock", "loc", "type", "address", "length", "Offset", "online", "f", "start", "disabled", "order", "fee", "len", "seq", "index", "padding", "position", "cb", "o", "base", "adjust", "error", "alpha", "lag", "entry", "col", "fp", "format", "ref", "enabled", "end", "size", "off", "et", "initial", "port", "pos", "url", "data", "count", "i", "shift", "pad", "ci", " offsets", "edge", "phase", "frequency", "set"], "c": ["C", "dc", "channel", "mc", "cf", "cy", "cl", "x", "cont", "xc", "cit", "cache", "p", "lc", "cu", "h", "cc", "code", "core", "ac", "cat", "ce", "f", "config", "s", "q", "cr", "pc", "uc", "cur", "coll", "b", "sc", "v", "ct", "toc", "fc", "n", "con", "ca", "com", "e", "cs", "l", "r", "col", "chain", "u", "center", "cm", "size", "d", "bc", "rc", "tc", "count", "k", "i", "vc", "ci", "m", "t", "nc", "cent", "cn", "g", "ec"], "ch": ["channel", "part", "cf", "chart", "cy", "tch", "cl", "ech", "Ch", "p", "h", "th", "gh", "code", "arch", "ce", "app", "zh", "q", "CH", "cher", "cr", "coll", "cand", "che", "cmd", "he", "inch", "change", "chn", "ca", "cb", "cs", "ver", "patch", "conn", "chan", "col", "ph", "sk", "chi", "sh", "ach", "ich", "cm", "sch", "bc", "cp", "rc", "cho", "vc", "unch", "conf", "ci", "cmp", "cha", "cle", "uch", "cht", "cor"], "dep": ["dc", "req", "deep", "f", "app", "cur", "ep", "pp", "view", "ca", "dev", "com", "depend", "ref", "bc", "pull", "dr", "grad", "ld", "ext", "nd", "desc", "inc", "neg", "cl", "ev", "src", "depth", "db", "loc", "config", "decl", "cmd", "sc", "egg", "dq", "dir", "gl", "mod", "ind", "pl", "imp", "rc", "category", "id", "ipp", "dp", "Dep", "rec", "comp", "channel", "bb", "dim", "mode", "uc", "change", "df", "ph", "dist", "supp", "tc", "ptr", "cpp", "push", "op", "du", "hl", "code", "deb", "oc", "day", "col", "ctr", "d", "cp", "attr", "upp", "cmp", "nc", "context", "de"], "smp": [" supp", " sme", "psmp", "smb", "Smb", " smc", "psamp", "Sme", "Sape", "dsmb", "psmc", "Supp", "dmp", " samp", "Smp", "isp", " scap", "dsamp", "ssmp", "psmb", " sMP", "sape", "dmb", "sme", "sMP", "isupp", "dupp", "dsmc", "SMP", " sape", "smc", "jsmp", "jsme", "samp", "supp", "scap", " smb", "ssmb", "jscap", "ssMP", "jsupp", "sp", "ismb", "ssape", "ismp", "dp", "Scap", " sp", "dsmp"], "y": ["ey", "ym", " x", "ny", "cy", "x", "yl", "p", "sky", "gy", "sy", "ye", "oy", "type", "j", "year", "fy", "ype", "iy", "yr", "n", "ys", "ya", "py", "ies", "yi", "vy", "i", "yy", "m", "t", "yn", "dy", "zy", "Y", "yo", "z", "ay", "ip"], "master": ["mx", "test", "num", "type", "wave", "bl", "ss", "mm", "parent", "table", "Master", "r", "tail", "pre", "dist", "worker", "target", "masters", "mid", "m", "top", "total", "server", "node", "mon", "all", "prefix", "me"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n", "idx": 23696, "substitutes": {"hpet": ["adhpret", "hepel", "phPet", "phped", "hrpet", "affpret", "hett", "phpret", "helpit", "affpet", "hvet", "bhPet", "hmpret", "hppel", "hpPet", "affpel", " hpit", "hped", "hrped", "hwpit", " hpret", "Hpet", "hmett", "Hvet", "hpit", "hpret", "phpet", "hmpel", "bhpret", "phpit", "Hpit", "adhpit", "helpel", "hwpel", "hppet", "heett", "hppit", "bhpit", "helpet", "hPet", "adhpet", "adhpel", " hvet", " hped", " hPet", "hpel", "bhpet", "affett", "hrpit", "Hpel", "bhped", "hepet", "helped", "hwvet", "bhpel", "hrPet", "hmpet", " hpel", "hwpret", "phpel", "hepret", "hwpet"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;\n\n    }\n\n}\n", "idx": 23704, "substitutes": {"samples": ["samps", "smodels", "ssamps", "Samples", "swmodels", "gumpy", "emodels", "Samps", "siments", "anspling", "pumpy", "eamples", "samp", "examps", "sources", " sients", "spints", "spamps", "sints", " sints", "sample", "assample", " sources", "exients", " saves", " spling", "ssamp", " ssample", "saves", "gamps", " sumpy", "pamples", "ssamples", "exources", "ssints", "psample", "pample", "ansamps", "swamples", "gamples", "spling", "piments", "gample", "sums", "pamp", "asamp", "eiments", "pamps", "spaves", " siments", "pums", "ssums", "asamps", "asums", "spamples", "eample", " samp", "ppling", "sients", "asamples", "pources", "ansamples", "swample", " sample", " sums", "pients", "ansiments", "sumpy", " smodels", "Sums", "ssample", "ssaves", " samps", "Samp", "swiments", "examples"], "i": ["ti", "ii", "ui", "abi", "qi", "x", "I", "ix", "p", "h", "phi", "di", "val", "ri", "j", "type", "f", "length", "ai", "info", "ini", "oi", "cli", "ni", "ie", "ip", "b", "si", "init", "v", "io", "a", "pi", "uri", "index", "ami", "c", "ki", "e", "l", "r", "xi", "u", "key", "inner", "source", "fi", "li", "in", "d", "iu", "api", "mini", "count", "hi", "id", "m", "ci", "t", "zi", "multi", "slice", "gi", "z", "bi", "it", "mu"]}}
{"project": "FFmpeg", "commit_id": "cd1047f3911fa0d34c86f470537f343d23c8b956", "target": 0, "func": "static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    const AVPixFmtDescriptor *desc;\n\n    mfxSession session = NULL;\n\n    int iopattern = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n    int frame_width  = avctx->coded_width;\n\n    int frame_height = avctx->coded_height;\n\n    int ret;\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!desc)\n\n        return AVERROR_BUG;\n\n\n\n    if (!q->async_fifo) {\n\n        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));\n\n        if (!q->async_fifo)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {\n\n        AVQSVContext *user_ctx = avctx->hwaccel_context;\n\n        session           = user_ctx->session;\n\n        iopattern         = user_ctx->iopattern;\n\n        q->ext_buffers    = user_ctx->ext_buffers;\n\n        q->nb_ext_buffers = user_ctx->nb_ext_buffers;\n\n    }\n\n\n\n    if (avctx->hw_frames_ctx) {\n\n        AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;\n\n\n\n        if (!iopattern) {\n\n            if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)\n\n                iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;\n\n            else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)\n\n                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;\n\n        }\n\n\n\n        frame_width  = frames_hwctx->surfaces[0].Info.Width;\n\n        frame_height = frames_hwctx->surfaces[0].Info.Height;\n\n    }\n\n\n\n    if (!iopattern)\n\n        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;\n\n    q->iopattern = iopattern;\n\n\n\n    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;\n\n    param.mfx.FrameInfo.FourCC         = q->fourcc;\n\n    param.mfx.FrameInfo.Width          = frame_width;\n\n    param.mfx.FrameInfo.Height         = frame_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0)\n\n        return ff_qsv_print_error(avctx, ret,\n\n                                  \"Error initializing the MFX video decoder\");\n\n\n\n    q->frame_info = param.mfx.FrameInfo;\n\n\n\n    return 0;\n\n}\n", "idx": 23714, "substitutes": {"avctx": ["ajctx", "avsq", "avclient", "afcmp", "avbc", "Avcu", "devctx", "avconfig", "vercu", "navcontext", "avloc", "averctl", "AVconfig", "afsq", " avsq", " avloc", "devcontext", "afctl", "avecv", "AVcu", "averconn", "avcontext", "Avconfig", "avecontext", "verctx", "navcmp", "aveloc", " avcmp", "verconn", "devcmp", "avconn", "avcu", "avectx", "aveconfig", "afcu", "AVloc", "AVctx", "AVsq", "ajclient", "AVclient", "afconn", "avctl", "averctx", "AVcontext", "avebc", "AVbc", "aveclient", "devconfig", "vercontext", "Avctx", "avcmp", "avcv", "afconfig", "AVconn", "ajcv", "navctl", " avcontext", "ajcontext", "vercmp", "avecu", "afctx", " avbc", "AVcv", "navconn", "avercontext", "AVcmp", "navctx", "Avcontext", "afcontext"], "q": ["req", "cf", "quant", "qi", "sq", "ue", "question", "w", "p", "h", "iq", "queue", "que", "qu", "f", "config", "qq", "request", "ack", "cmd", "v", "dq", "view", "c", "user", "conn", "query", "Q", "ch", "window", "session", "cal", "requ", "qs", "u", "batch", "eq", "quest", "post", "d", "qa", "input", "ctx", "k", "self", "m", "ad", "conf", "t", "client", "context", "g", "z", "qt", "get"], "desc": ["dc", "req", "def", "doc", "text", "ec", "lc", "enc", "code", "name", "loc", "info", "config", "Desc", "description", "cur", "uc", "func", "disc", "anc", "sc", "der", "dir", "fc", "sub", "fun", "cb", "env", "session", "meta", "dist", "esc", "d", "bc", "des", "rc", "dep", "la", "nc", "sec", "asc", "de", "rec", "comment", "ext"], "ret": [" resp", "match", "def", "res", "resp", "aud", " quiet", "cat", "valid", "RET", "fun", "reg", "error", "result", "progress", "re", "flag", "arr", "alt", "success", "Ret", "rep", "sec", "rec"], "user_ctx": ["user_context", "user_anc", "useringloc", "user_chan", "use_kb", "user_loc", "user_cmp", "useringcu", "user_wcs", "useringctx", " user_conn", " user_chan", "use_ctx", "useringcontext", " user_cu", "use_cu", " user_anc", "use_loc", "user_cu", "user_xc", "user_conn", "use_xc", " user_cmp", " user_loc", "user_kb", "use_cmp", "use_wcs", "use_context"], "frames_ctx": ["frames___vc", "frames___ctx", "frames_context", "flows_vc", "flows_context", "flows_pkg", "flows_ci", "flows_loc", "frames___context", "frames_vc", "frames_loc", "frames_pkg", "frames_ci", "flows_ctx", "frames___pkg"], "frames_hwctx": ["frames_memctx", "frames_hopcmd", "frames_vcsec", "frames_fwchan", "frames_fwctx", "frames_hhrx", "frames_cowchan", "frames_cowctx", "frames_hmconfig", "frames_hhcmd", "frames_cowcp", "frames_nvctx", "frames_iwcontext", "frames_hwcontext", "frames_fwcp", "frames_vcconfig", "frames_hopcontext", "frames_navcb", "frames_hwcmd", "frames_memsec", "frames_memcf", "frames_nvcontext", "frames_vccf", "frames_hwcf", "frames_hwchan", "frames_hwsec", "frames_nvchan", "frames_navconfig", "frames_cowcontext", "frames_nvcp", "frames_iwctx", "frames_hoprx", "frames_hwcp", "frames_hmcontext", "frames_iwcf", "frames_vcctx", "frames_hhctx", "frames_hhcontext", "frames_iwsec", "frames_fwcmd", "frames_hopctx", "frames_hwconfig", "frames_hwcb", "frames_hwrx", "frames_fwrx", "frames_navcontext", "frames_memconfig", "frames_navctx", "frames_hmcb", "frames_iwconfig", "frames_fwcontext", "frames_hmctx", "frames_iwcb"]}}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n", "idx": 23744, "substitutes": {"proxy": ["zip", "image", "gp", "pe", "pa", "cache", "Proxy", "bridge", "queue", "linux", "core", "route", "http", "pse", "address", "proc", "driver", "io", "native", "uri", "pro", "library", "base", "ruby", "service", "manager", "connection", "plugin", "port", "api", "wrapper", "slave", "phy", "plug", "cop", "client", "server", "slice", "component", "clip", "lib", "resource", "remote", "pool"], "region": ["script", "image", "ion", "version", "ale", "cache", "section", "area", "location", "route", "local", "folder", "address", "account", "config", "ort", "ortex", "dim", "gap", "REG", "native", "report", "reg", "range", "Region", "module", "service", "zone", "manager", "format", "span", "connection", "plugin", "port", "memory", "scope", "environment", "role", "unit", "transfer", "country", "array", "server", "record", "slice", "feature", "component", "group", "node", "resource", "project", "remote"], "cap": ["ha", "ace", "cf", "capacity", "cfg", "aps", "cl", "pac", "capt", "cache", "p", "access", "core", "acl", "ac", "cat", "fab", "app", "config", "tool", "lan", "gap", "mp", "mac", "scale", "feat", "ape", "ca", "cas", "ab", "acc", "Cap", "span", "fac", "can", "cast", "size", "car", "caps", "bc", "data", "cop", "cube", "cmp", "card", "CAP", "map", "ap", "clip", "feature", "spec", "rap", "ext", "ip"]}}
{"project": "qemu", "commit_id": "d044be3714db9c3750c430a2bb1be74beee6fd27", "target": 0, "func": "static void mixer_reset (AC97LinkState *s)\n\n{\n\n    uint8_t active[LAST_INDEX];\n\n\n\n    dolog (\"mixer_reset\\n\");\n\n    memset (s->mixer_data, 0, sizeof (s->mixer_data));\n\n    memset (active, 0, sizeof (active));\n\n    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n\n    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n\n    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n\n\n\n    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n\n    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n\n    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n\n    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n", "idx": 23747, "substitutes": {"s": ["south", "secondary", "p", "us", "f", "sb", "storage", "u", "tests", "gs", "i", "plugins", "this", "your", "spec", "sv", "current", "ses", "ds", "status", "an", "config", "xs", "is", "b", "ts", "hs", "sites", "e", "services", "parts", "os", "states", "S", "w", "sym", "h", "site", "stat", "stats", "its", "v", "temp", "c", "l", "r", "service", "groups", "qs", "es", "m", "sys", "t", "sl", "g", "new", "settings", "full", "sets", "sq", "rs", "sync", "http", "fs", "ss", "native", "o", "session", "tp", "d", "ssl", "self", "sf", "sing", "ns", "ls", "sg", "js"], "active": ["confirmed", "full", "empty", "Active", "cache", "mobile", "current", "events", " inactive", "activate", "complete", "cli", "status", "valid", "activation", "running", "connected", "pass", "visible", "selected", "seq", "index", "acs", "volt", "available", "play", "waves", "args", "activity", "enabled", "output", "actions", "fresh", "ents", "ops", "stable", "progress", "IVE", "memory", "data", "arr", "playing", "activated", "null", "live", "open", "activ", "act", "g", "all"]}}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751, "substitutes": {"bs": ["lb", "iss", "rs", "bb", "css", "bid", "bis", "ds", "ses", "s", "bas", "as", "fs", "bl", "b", "ss", "its", "bh", "state", "bt", "BS", "sub", "ps", "base", "sb", "bits", "bps", "bos", "cs", "mb", "blocks", "fps", "bes", "pb", "lbs", "boot", "ops", "bc", "ctx", "gs", "os", "fb", "vs", "ubs", "ns", "ls", "ms", "rb", "obs", "bi", "bytes"], "offset": ["part", "delay", "attribute", "alloc", "reset", "block", "location", "num", "reference", "loc", "pointer", "clock", "address", "length", "Offset", "type", "option", "ip", "mode", "start", "order", "len", "seq", "index", "padding", "position", "base", "entry", "slot", "range", "from", "error", "limit", "ref", "connection", "size", "off", "initial", "pos", "url", "data", "shift", "number", "sort", "slice", "addr", "phase", "set", "prefix", "offer", "bytes"], "count": ["Count", "first", "part", "timeout", "cache", "queue", "call", "code", "cc", "depth", "name", "force", "process", "type", "length", "f", "counter", "max", "start", "content", "len", "seq", "index", "c", "parent", "base", "amount", "sum", "error", "found", "col", "limit", "ref", "key", "cond", "size", "weight", "child", "mount", "id", "number", "list", "total", "large", "group"], "co": ["mc", "po", "aco", "cf", "oe", "cache", "cu", "CO", "flo", "call", "bo", "ra", "cc", "code", "ac", "ri", "mo", "loc", "ro", "coll", "pc", "Co", "oc", "oo", "con", "c", "ck", "ca", "o", "col", "py", "can", "fo", "oper", "ico", "ob", "rc", "cca", "CC", "ci", "cmp", "ko", "coe"], "aio_context": ["aiopenvironment", "aio__sc", "aio_environment", "aios_ctx", "aio_ctx", "aio_package", "aiopcontext", "aiopctx", "aio__context", "aios_sc", "aios_connection", "aio_connection", "aio__ctx", "aio__connection", "aios_context", "aio_sc", "aioppackage"]}}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n", "idx": 23758, "substitutes": {"env": ["inet", "iv", "ner", "eye", "console", "ev", "esi", "event", "eni", "en", "enc", "priv", "ea", "que", "her", "db", "el", "ef", "config", "eng", "equ", "uv", "enh", "ep", "vm", "init", "ah", "v", "exc", "anne", "buf", "c", "chn", "err", "dev", "fen", "estate", "e", "enable", "engine", "conn", "erv", "end", "et", "viron", "np", "Environment", "rc", "obj", "environment", "ctx", "eu", "org", "kn", "nc", "context", "ception", "eb", "energy", "ec"], "addr": ["arch", "offset", "rt", "proc", "ack", "order", "rx", "device", "vr", "intel", "hop", "seq", "ar", "adder", "ady", "amd", "ref", "pos", "data", "oa", "pad", "dr", "pkg", "grad", "ld", "ext", "adr", "part", "src", "db", "ord", "clock", "address", "md", "config", "xxx", "cmd", "aug", "align", "index", "amp", "inter", "arr", "id", "ad", "work", "prefix", "host", "rr", "sta", "usr", "dist", "dd", "ne", "url", "ptr", "ctx", "socket", "server", "edge", "node", "ace", "cpu", "pointer", "frame", "alias", "str", "layer", "attr", "coord", "cmp", "az"], "val": ["part", "il", "VAL", "x", "eval", "al", "pid", "ra", "call", "el", "buffer", "rt", "db", "loc", "au", "elt", "na", "valid", "ret", "stat", "as", "wa", "b", "aval", "v", "rel", "up", "len", "index", "rot", "vol", "base", "err", "entry", "pt", "old", "tx", "r", "vi", "va", "ref", "pre", "sel", "ee", "vals", "value", "pos", "data", "arr", "isal", "fail", "Val", "la", "sl", "ival", "var"]}}
{"project": "FFmpeg", "commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "target": 1, "func": "int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 23762, "substitutes": {"w": ["ww", "x", "p", "aw", "wl", "f", "s", "q", "max", "wa", "b", "v", "a", "n", "wx", "fw", "c", "sw", "wh", "we", "e", "l", "r", "hw", "u", "sh", "d", "wt", "weight", "rw", "m", "work", "ow", "wd", "W", "z"], "h": ["ha", "hd", "x", " H", "kh", "p", "hl", "ht", "th", "gh", "host", "ih", "f", "q", "max", "rh", "b", "v", "bh", "ah", "hh", "oh", "n", "c", "hs", "H", "l", "hr", "ch", "ph", "u", "sh", "d", "uh", "hm", "hi", "m", "han", "z"], "sar": ["ssar", "resolutionari", "esarl", "war", "sir", "siar", "ingsiar", "saru", "sare", "sart", "ssari", "ssars", "sslaru", "para", "osarp", " sari", "wara", "fare", " saru", "psAR", "larl", "yari", "ware", "ssear", "asarp", "far", "osara", "yare", "sars", "lAR", "resolutioniar", "resolutionar", "saring", "ssare", "parl", "sara", "phar", "psart", "ssara", "nsar", "sslar", "tear", "dsara", "tar", "lshar", " sars", "ingsari", " sart", "lar", " sarl", "tarl", "sarl", "lsara", "dsar", "ssarp", "dsari", "osar", "psara", "wari", "laru", "sslart", " shar", "sAR", "parp", "lsaring", "psarp", " sara", "lsar", "sarp", "sumar", "pare", "nsart", "nsari", " saring", "nsara", "sslarl", "tars", "esar", " sAR", "psare", "lari", "yara", "nsare", "asara", "yar", "osari", "resolutionaru", "par", "shar", "lir", "sari", " sir", "asar", "esara", " sear", "asarl", "sumaru", "ingsar", "psir", "dsare", "paring", "psari", "ingsaru", "sumiar", "pari", "sumari", "esarp", "sear", "fart", "ssarl", "fara", "psar", "lart"], "scaled_dim": ["scaled_dm", "scalled_shape", "scaled___num", "scalled_num", "scaled_grad", "scaled_lim", "scalled_mem", "scalled_dim", "scalled_di", "scaled__lim", "scaled__shape", "scalled_grad", "scaled__orig", "scalled_orig", "scaled__num", "scaled__dm", "scaled_mem", "scaled___di", "scaled_di", "scaled_num", "scaled_shape", "scaled___mem", "scaled___dim", "scalled_dm", "scaled__dim", "scalled_lim", "scaled_orig"]}}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n", "idx": 23769, "substitutes": {"s": ["rates", "settings", "sets", "S", "sq", "ks", "rs", "res", "p", "sym", "ls", "sync", "site", "http", "bis", "ses", "ds", "f", "ions", "sr", "is", "fs", "b", "si", "ts", "ss", "strings", "a", "c", "ps", "hs", "sb", "com", "sites", "e", "cs", "r", "l", "args", "service", "session", "u", "services", "qs", "times", "es", "ops", "d", "side", "ssl", "comments", "re", "ctx", "gs", "gb", "m", "conf", "t", "sys", "sf", "os", "ubs", "ns", "g", "sv", "js"], "count": ["Count", "loop", "close", "scroll", "cache", "current", "call", "code", "core", "cc", "depth", "offset", "force", "low", "type", "length", "name", "counter", "f", "process", "max", "coll", "start", "b", "len", "seq", "n", "c", "err", "base", "sum", "e", "ind", "l", "found", "col", "limit", "key", "find", "size", "cond", "cast", "weight", "child", "id", "conf", "number", "list", "num", "all", "pool"], "i": ["ti", "ui", "ii", "abi", "ji", "qi", "x", "I", "ix", "p", "eni", "lc", "phi", "di", "j", "info", "f", "ai", "cli", "ie", "ini", "oi", "ni", "si", "io", "b", "v", "gu", "init", "a", "pi", "n", "index", "uri", "ei", "c", "o", "ind", "e", "y", "l", "adi", "xi", "u", "fi", "li", "d", "iu", "api", "diff", "data", "id", "zi", "ci", "mi", "m", "multi", "slice", "gi", "bi", "it", "ip"]}}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n", "idx": 23771, "substitutes": {"mr": ["mc", "adr", "bm", "MR", "try", "br", "mx", "gr", "rs", "ra", "rt", "rm", "md", "fr", "sr", "Mr", "mn", "rh", "RR", "yr", "vr", "err", "rr", "nr", "r", "kr", "hr", "usr", "arr", "rw", "dr", "m", "er", "las", "lr", "mk", "shr", "rg"]}}
{"project": "qemu", "commit_id": "be18b2b53ebbf2eb3f00e7890d0b9ff8b58d22bf", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n        env->error_code = 0x10000000;\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x40000000;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (rwx == 1) {\n\n                env->spr[SPR_DSISR] = 0x42000000;\n\n            } else {\n\n                env->spr[SPR_DSISR] = 0x40000000;\n\n            }\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x08000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 23779, "substitutes": {"cpu": ["nic", "chip", "kt", "gp", "CPU", "gc", "cache", "lc", "GPU", "uci", "linux", "platform", "core", "cc", "clock", "processor", "process", "cli", "proc", "ocr", "gpu", "net", "roc", "pc", "vm", "cow", "intel", "c", "performance", "conn", "fp", "hw", "kernel", "auc", "boot", "np", "cp", "pu", "rc", "ctx", "cpp", "sys", "cmp", "component", "nc", "cn", "loader", "bench", "node", "hp", "ec", "comp"], "eaddr": ["efdr", "efder", "endtr", "ewayhr", "eeddat", "eadbr", "eyder", "eedhr", "eyDR", "eadld", "oaddr", "endder", "ledld", "ecder", "eeder", "avder", "eaddat", "eedDr", "efbr", "aydr", "eadder", "ewaydr", "eeddr", "epdr", "ellbr", "ecDR", "ellDR", "ellder", "enddr", "eedld", "ayder", "eeDR", "ledDR", "eftr", "ellhr", "epDR", "endDR", "eedDR", "ecbr", "eydr", "eadstr", "ewaydat", "eadhr", "efstr", "aybr", "avDR", "epbr", "epder", "oadstr", "eeDr", "aystr", "eedder", "ledder", "oadder", "ecdr", "efDR", "elldr", "eadDR", "eedr", "eadtr", "avdr", "elldat", "ewayder", "eyld", "avtr", "efDr", "leddr", "eadDr", "oadbr"], "rwx": ["rhxes", "RWf", "rwf", "wwx", "wxx", "rwX", "wrx", "RWx", "wxX", "rrX", "rackX", "RWax", "rhx", "wwX", "rwxp", "rwz", "rwax", "wxxes", "wnx", "nwx", "nwX", "RWX", "wny", "rhxp", "rnz", "rwy", "rhv", "wwv", "rrx", "RW1", "wwy", "rackx", "nwf", "rry", "rnx", "rhz", "wrX", "rhf", "RWy", "rhX", "rhy", "rw1", "rnX", "wxz", "wry", "rny", "wxxp", "racky", "RWxp", "rhax", "rh1", "rackax", "nwxes", "nwy", "rwxes", "RWz", "wnX", "RWv", "wrxp", "rwv", "wxy", "wn1", "rrxp"], "mmu_idx": ["mmu_sidxc", "mmu_aidxc", "mmu_namec", "mmu_idc", "mmu_idy", "mmu_midy", "mmu_aidv", "mmu_midz", "mmu_idsz", "mmu_idxc", "mmu_aidc", "mmu_sidv", "mmu_midw", "mmu_sidx", "mmu_namex", "mmu_idsx", "mmu_midx", "mmu_idv", "mmu_idw", "mmu_idsw", "mmu_aidx", "mmu_namexc", "mmu_namev", "mmu_idz", "mmu_sidc", "mmu_idsy"], "cs": ["cf", "Cs", "cms", "ks", "rs", "ix", "cache", "ec", "lc", "css", "sync", "core", "cc", "cases", "ac", "ras", "ce", "ds", "cus", "pc", "fs", "sc", "ts", "ss", "acs", "c", "utils", "ps", "CS", "ck", "ca", "cas", "conn", "args", "ics", "sk", "qs", "wcs", "bc", "cp", "rc", "ctx", "gs", "self", "vc", "sys", "ci", "bs", "vs", "cons", "ns", "ls", "spec", "cn", "acks", "js"], "env": ["En", "cfg", "ace", "console", "ev", "cv", "cache", "ec", "gui", "eni", "en", "enc", "ea", "forge", "eve", "core", "site", "db", "el", "cli", "ef", "config", "s", "equ", "net", "ss", "v", "agent", "exc", "here", "state", "c", "utils", "err", "dev", " environment", "estate", "enable", "style", "export", "conn", "e", "args", "engine", "session", "kernel", "cal", "ass", "et", "es", "ne", "viron", "np", "Environment", "bc", "rc", "scope", "environment", "eu", "conf", "esp", "server", "vs", "nc", "context", "assets", "spec", "energy", "qt", "skin", "js"], "slb": ["islB", "hlb", "slfb", "Slb", "SLB", " slbb", "slbs", "islfb", "slk", "islb", "helc", " slc", "clk", "helba", "SLc", " slfb", "slB", "hlab", "Slab", "slab", "snbs", " slba", "slbb", "SLb", "selb", "snb", "helb", "islib", "clc", "SLbd", "selc", " slab", "SLp", "SlB", "SLfb", "snp", "snc", "selp", " sla", "islab", "SLab", "isla", "Slbd", "selbs", " slk", "sla", "slib", "islbb", "clb", "slba", "islbd", "slp", "SLib", "hlbb", "slbd", " slib", "clba", "SLbs", "helk", "slc", "SLa"], "pte_offset": ["ptee_offset", "pte_length", "ptE_position", "ptE_length", "ptee_shift", "pte_len", "pte_ref", "pte_position", "pte_slice", "ptE_slice", "ptE_offset", "ptee_Offset", "pte_Offset", "ptee_length", "ptE_ref", "pte_shift", "ptE_len", "ptE_Offset"], "pte": ["ptes", "ppe", "iptE", "ntE", "PTae", " ptl", "ptl", " pted", "ppae", "PTes", "ppl", "ntes", "ipte", "nted", "PTed", "pted", "PTl", "iptes", "PTe", "ptE", "ipted", "nte", "ptae", "PTE", "pped", " ptae"], "pp_prot": ["pp_phys", "cp_phys", "pp_ptr", "pp_rot", "cp_ptr", "cp_rot", "cp_prot"], "amr_prot": ["amr2channel", "aml_seq", "amr_channel", "aml_channel", "amr2pointer", "amr_seq", "amr2prot", "amr2seq", "aml_pointer", "amr_pointer", "aml_prot"], "prot": ["channel", "att", "reset", "Prot", "prop", "ret", "stat", "config", "io", "seq", "rot", "header", "fl", "pri", " protocol", "pb", "ref", "port", "phy", "transfer", "sil", "period", "txt", "ocol", "server", "prefix", "ext"], "new_pte1": ["new_ptu4", "new_pte4", "new_ptes2", "new_ptu1", "new_ptes1", "new_pte2", "new_ptE1", "new_ptE4", "new_cte1", "new_ctE4", "new_cte2", "new_cte4", "new_ptes4", "new_ptu2", "new_ctE1", "new_ctE2", "new_ptE2"], "need_prot": ["nn_stat", "nn_conn", "nn_prot", "nn_channel", "pp_stat", "pp_conn", "pp_channel"], "raddr": ["Rpad", "Radr", " rada", "ppad", "pada", "rada", "rraddress", "rrada", "Raddress", "pptr", "sradr", " raddress", "paddress", " rpad", "Raddr", "radr", "sraddr", "rrptr", "rptr", "padr", "sraddress", "Rptr", "paddr", " rptr", "rraddr", "rpad", "srpad", "raddress"]}}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    uint8_t const *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin = AV_RL16(buf+ 4);\n\n    ymin = AV_RL16(buf+ 6);\n\n    xmax = AV_RL16(buf+ 8);\n\n    ymax = AV_RL16(buf+10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf+66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes<<8) + bits_per_pixel) {\n\n        case 0x0308:\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            break;\n\n        case 0x0108:\n\n        case 0x0104:\n\n        case 0x0102:\n\n        case 0x0101:\n\n        case 0x0401:\n\n        case 0x0301:\n\n        case 0x0201:\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                ptr[3*x  ] = scanline[x                    ];\n\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        for (y=0; y<h; y++, ptr+=stride) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto end;\n\n        }\n\n\n\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n", "idx": 23786, "substitutes": {"avctx": ["avcp", "avalcontext", "verkb", "avercam", "AVsync", "afcv", "avecp", "avloc", "avalctx", "afnp", "avalcca", "AVcam", "avkb", " avloc", "versync", "avecv", "averconn", "avcontext", "aveloc", "avecontext", "verctx", "verconn", "avconn", "avectx", "AVctx", "avekb", "AVcas", "AVcp", "avecc", "afconn", "averctx", "AVcontext", " avcv", "vercontext", "afloc", " avcc", "AVkb", "avcam", "avcv", "vercam", "AVconn", "avsync", "AVcca", " avcontext", "avcas", "avenp", " avconn", "avcc", "avesync", "afctx", "avalcas", "avercas", "avcca", "aveconn", "avercontext", "afcp", "AVnp", "avnp", "avercca", "afcc", "afcontext"], "data": ["channel", "image", "doc", "text", "cache", "DATA", "queue", "block", "buff", "buffer", "val", "frame", "proc", "results", "config", "sample", "start", "body", "feed", "media", "content", "audio", "next", "parent", "database", "base", "entry", "dat", "module", "batch", "result", "window", "meta", "connection", "value", "size", "d", "read", "api", "video", "pos", "input", "memory", "reader", "pad", "Data", "client", "open", "record", "package"], "data_size": [" data_name", " data_capacity", "data_len", " data_len", "data_name", "data_capacity"], "avpkt": ["abfkt", "avesacket", "avcft", "aveppkt", "aveppnt", "avessth", "avpct", "avPkt", "avepkt", "avskt", "avfft", "avPnt", "avepck", "abpct", "abfct", "avfsth", "avcct", "avcpct", "aveppacket", "abpkt", "avcpacket", "avfct", "avcpnt", "abpft", "avsck", "abfacket", "avfacket", "avckt", "avepsth", "avcpft", "avcacket", "avcpkt", "aveskt", "avPacket", "avfkt", "avPck", "avepnt", "avcpsth", "avppsth", "avfck", "avppacket", "avpft", "avpck", "abfft", "avpnt", "avepacket", "aveppsth", "avppnt", "avPsth", "avpsth", "avsacket", "avesck", "avpacket", "avssth", "avppkt", "abpacket"], "buf": ["home", "cf", "cap", "br", "box", "wb", "cv", "text", "uf", "alloc", "src", "prop", "queue", "bo", "block", "wav", "img", "tab", "uber", "buff", "buffer", "Buff", "bd", "loc", "proc", "config", "uv", "func", "uc", "grab", "cur", "cmd", "feed", "b", "chrom", "seq", "c", "feat", "aka", "cb", "cas", "vec", "begin", "ab", "fd", "tmp", "batch", "aux", "window", "brace", "usr", "dest", "fam", "bag", "conv", "port", "bc", "coord", "ctx", "plug", "uint", "pad", "gb", "pkg", "fb", "pub", "context", "rb", "pool", "utf"], "s": ["S", "sq", "rs", "sky", "sa", "ds", "j", "f", "as", "q", "sec", "fs", "pass", "ss", "si", "b", "v", "a", "c", "ps", "o", "sb", "e", "cs", "space", "l", "r", "size", "sup", "d", "ssl", "share", "m", "os", "conf", "sf", "ages", "g", "sl", "sg", "sv"], "picture": ["image", "conference", "gallery", "gui", "guide", "img", "pic", "buffer", "frame", "info", "plan", "config", "definition", "family", "media", "uri", "Picture", "avi", "detail", "library", "base", "photo", "space", "style", "fine", "meta", "details", "profile", "summary", "mini", "video", "obj", "ctx", "movie", "brush", "pict", "feature", "cam", "package", "camera", "piece"], "p": ["pd", " P", "proc", "f", "pc", "b", "mp", "v", "a", "pi", "c", "ps", "o", "e", "l", "P", "r", "fp", "py", "pb", "vp", "d", "np", "port", "m", "g", "it"], "compressed": ["suppressed", "ompression", " compacted", "ompressed", " uncompacted", "expressed", "suppacted", "composed", "expacted", "suppressor", "compacted", "omposed", " decompacted", " decompression", "suppression", "compressor", "expressor", " uncompressed", " decomposed", " decompressed", "ompacted", " compression", "expression", " uncompression", " uncompressor", "compression", " composed"], "xmin": ["xinit", "xmins", "exmins", "Xstart", "wmax", "ymins", "ystart", "ixmin", "xstart", " xMin", " xmini", "Xmini", "Xmax", "xpos", "exMin", "wpos", "wmins", " xinit", "yMin", " xstart", "Xmin", "xmini", "exmax", "ypos", "exmin", "ymini", "ixpos", "ixmax", "wMin", "xMin", "yinit", "ixinit", " xpos", "wmin"], "ymin": ["eymax", "eypos", " ymean", "Yname", "y0", "xonly", "Ymax", "yonly", "ystart", "eymean", "symin", "symax", "xpos", "sy0", "sypos", "eyonly", " yname", "yname", "eymin", "Y0", "Ymini", " ystart", "symini", " ymini", "xname", "ypos", "ymini", "systart", "Ystart", " y0", " yonly", "Ymin", "ymean", "xmean", "syonly"], "xmax": ["xMAX", "Xdiv", "Xend", " xlast", "yMAX", "xxax", " xMAX", "exend", "axend", "xlast", "yend", "xdiv", "Xmax", "axmin", "xax", "axmax", "Xlast", "xxend", "exMAX", "dxmax", "Xmin", "exmax", "xend", "axdiv", "xxmax", "xxmad", " xdiv", "exmin", "dxend", "dxmad", "xxmin", "xxlast", "xmad", " xax", "dxax", " xend", " xmad"], "ymax": ["yahass", "mmap", "yrass", "yahaze", "yahak", "ymase", "ymand", "ymmass", "iamail", "iamake", "imack", "imak", "ymmaz", "ymack", "iemax", "ymmaze", "ymmand", "yrax", "ymade", "iamax", "imase", "iamase", "ymaz", "ymaze", "imax", "atemade", "iemap", "ammax", "ammade", "tmase", "yahax", "iamak", "atemake", "ymmap", "iemaz", "iemand", "yrak", "yraze", "ymmax", "mmand", "atemail", "mmax", "ymmak", "iamack", "atemax", "tmak", "ymap", "ymass", "ammail", "iamade", "ammake", "tmack", "tmax", "ymak", "ymake", "ymail", "mmaz"], "w": ["wb", "ex", "aw", "f", "wave", "max", "q", "wa", "b", "win", "v", "week", "wx", "n", "sw", "fw", "c", "wh", " W", "we", "ew", "r", "l", "how", "hw", "u", "d", "wt", "weight", "iw", "rw", "m", "ow", "work", "g", "W", "z"], "h": ["en", "ht", "gh", "j", "f", "q", "rh", "b", "v", "dh", "hh", "n", "height", "padding", "c", "o", "H", "e", "l", "r", "col", "ch", "ph", "u", "sh", "d", "hm", "hi", "k", "m", "t", "g", "z"], "bits_per_pixel": ["bits_Per_line", "bits_Per_cell", "bits_per_cell", "bits_per_chip", "bits_per_byte", "bits_PER_pixel", "bits_Per_pixel", "bits_per_channel", "bits_PER_chip", "bits_per_page", "bits_PER_channel", "bits_per_line"], "bytes_per_line": ["bytes_per_pixel", "bytes_PER_pixel", "bytes_per_scene", "bytes_per_row", "bytes_per_cell", "bytes_per_slice", "bytes_PER_slice", "bytes_PER_byte", "bytes_per_byte", "bytes_per_page", "bytes_PER_line"], "nplanes": [" nframes", "numpages", " nliners", "lframes", "numrows", "Nframes", "numbands", "nliners", " nlines", "mframes", "llines", "numframes", "Nliners", "nbpages", "nlines", "Npages", "nbplanes", " nbands", "snplanes", "nframes", "lbands", "nbrows", "snlines", "snbands", "nblines", "nbands", "nrows", "mrows", "lplanes", "Nbands", "numlines", "Npins", "numpins", "mplanes", "npins", " npins", "numliners", "npages", "snframes", "Nrows", " nrows", "Nlines", "Nplanes", "mlines", "numplanes"], "stride": ["snides", "brider", "strided", "strider", "bride", "brides", "decides", "snide", "decider", "decide", "decided", "snided", "brided", "snider", "strides"], "y": ["ey", "type", "f", "start", "b", "height", "n", "padding", "c", "o", "min", "l", "size", "d", "vy", "yy", "m", "t", "dy", "Y", "lon", "z"], "x": ["xy", "ix", "step", "X", "ex", "f", "max", "xs", "xml", "win", "xx", "n", "index", "height", "c", "min", "l", "dx", "size", "d", "px", "z"], "bytes_per_scanline": ["bytes_per_readblock", "bytes_per_Scancell", "bytes_per_pixelment", "bytes_per_Scanline", "bytes_per_scanment", "bytes_per_scancell", "bytes_per_scanblock", "bytes_per_bincell", "bytes_per_pixelline", "bytes_per_readcell", "bytes_per_scanframe", "bytes_per_missse", "bytes_per_missline", "bytes_per_binline", "bytes_per_binment", "bytes_per_Scanse", "bytes_per_pixelse", "bytes_per_missframe", "bytes_per_scanse", "bytes_per_misscell", "bytes_per_pixelblock", "bytes_per_Scanment", "bytes_per_pixelcell", "bytes_per_pixelframe", "bytes_per_readline", "bytes_per_Scanblock", "bytes_per_Scanframe", "bytes_per_binblock"], "ptr": ["trace", "br", "src", "alloc", "prop", "queue", "code", "pair", "buff", "pointer", "buffer", "proc", "config", "seq", "cb", "vec", "tmp", "fd", "fp", "ctr", "fi", "port", "attr", "dr", "pad", "slice", "addr"], "bufstart": ["bufferstop", "bufferStart", "queueStart", "queuestart", "bufstop", "ufStart", "bufStart", "queuestop", "ufstart", "bufferstart", "ufstop"], "scanline": ["scanlines", "readline", "parseline", " scanl", "readl", " scanlines", "scanl", "parsel", "readlines", "parselines"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "substitutes": {"list": ["full", "ul", "listed", "x", "cl", "tree", "List", "p", "lists", "call", "code", "acl", "name", "load", "complete", "like", "LIST", "config", "object", "coll", "ack", "xml", "seq", "parent", "base", "entry", "l", "batch", "result", "chain", "out", "li", "self", "pkg", "array", "add", "this", "set", "comment"], "qdict": ["qtdocument", "qstr", "qsdict", "qmap", "qdir", "eqdocument", "qdf", "qtdict", "qstyle", " qdf", "qudf", "qustr", "qudir", "sqmap", " qdir", "qsmap", " qstr", "qudt", "sqdt", "qumap", "qsdt", " qmap", "eqstyle", "qtstyle", "eqdf", "eqdict", "sqdf", "qsdf", "sqdict", "qudict", " qstyle", "qtdf", "sqstr", "sqdir", " qdocument", "qdocument", "qdt"], "opts": ["opps", "appals", " opss", "hopts", "obins", "optss", "opins", " opps", "OPts", "OPtt", " optps", "optps", "hopents", "OPbs", " opbs", " optts", " oprs", "optrs", "optbs", "OPals", "OPrs", "optents", "OPgs", "hopcs", "optts", "opgs", " optrs", " optt", " opals", "oprs", "apptt", "obps", "opals", "optins", " opcs", " optins", " opents", " ops", "ops", "optgs", "OPs", "opss", "opcs", "obts", "opents", "obrs", "optcs", "optt", "opbs", "appts", " opgs", "hopss", "OPps", "appps"]}}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816, "substitutes": {"ch": ["channel", "chip", "chart", "cy", "gr", "cl", "ech", "Ch", "p", "th", "enc", "gh", "code", "arch", "http", "ce", "qu", "app", "zh", "q", "CH", "cher", "cur", "cand", "che", "cmd", "sc", "chrom", "bh", "change", "game", "c", "chn", "ck", "cb", "err", "conn", "chan", "hw", "ph", "or", "chi", "sh", "ach", "ich", "history", "command", "sch", "chron", "ic", "cp", "kick", "cho", "ctx", "conf", "form", "ci", "work", "client", "cha", "g", "exec", "cht", "cor"], "current": ["channel", "image", "compl", "cont", "Current", "cache", "reported", "queue", "code", "local", "complete", "now", "counter", "config", "valid", "running", "content", "selected", "temp", "accept", "next", "report", "stream", "c", "future", "parent", "control", "volt", "path", "com", "serial", "conn", "result", "active", "prev", "present", "recent", "history", "command", " cur", "target", "count", "ctx", "self", "form", "currently", "client", "open", "server", "component", "comment", "comp"], "br": ["bro", "bm", "gr", "mr", "cl", "p", "queue", "bridge", "bre", "code", "bid", "db", "broad", "el", "j", "msg", "fore", "bg", "cr", "fr", "bl", "cmd", "b", "comm", "rel", "bh", "bug", "vr", "header", "buf", "err", "base", "ver", "r", "hr", "handle", "ref", "ctr", "be", "str", "cm", "tr", "bc", "bal", "rc", "arr", "BR", "Br", "dr", "fb", "rb", "serv"], "sel_mask": ["sel_scale", "sel___value", "selgvalue", "sel_mode", "selalvalue", "sel_match", "sel_weight", "selalweight", "sel2mode", "sel_count", "sel2value", "sl_mode", "sel_shadow", "selgmask", "sel_scan", "sl_value", "sel___mask", "sl_sum", "sl_scale", "sl_mask", "selgmatch", "sl_weight", "sel_sum", "sel___shadow", "selgcount", "sl_count", "sel2scale", "selalscan", "sl_match", "sel2mask", "sl_scan", "sel___sum", "selalmask", "sl_shadow"], "sel_value": ["hidevalvalue", "sel_scale", "sel___value", "selvalinfo", "selsmask", "selvaladdress", "sel_work", "selvallabel", "selsscale", "hidevalid", "sel_address", "selsvalue", "hide_info", "sel_id", "selfvalue", "sl_work", "hide_address", "selfid", "sel_label", "sl_value", "selfaddress", "selsval", "sel___address", "selvalmask", "sl_scale", "hide_id", "sl_mask", "sel___info", "selvalwork", "sel___id", "sel_val", "sl_label", "hidevalinfo", "hidevaladdress", "sl_val", "selvalvalue", "sel_info", "hide_value", "selfinfo", "selvalid"], "status": ["wait", "nic", "st", "flags", "gc", "resp", "reason", "Status", "sync", "css", "code", "rss", "val", "complete", "shell", "msg", "stat", "s", "cli", "stats", "security", "comm", "state", "seq", "err", "reg", "error", "style", "result", "fps", "service", "uses", "STAT", "connect", "summary", "progress", "ssl", "rc", "id", "sp", "unit", "score", "speed", "success", "cmp", "exec", "spec", "comment", "serv"], "cond": ["contin", "condition", "part", "crit", "close", " condition", "cl", "resp", "cont", "box", "Cond", "reason", "lc", "xc", "block", "cc", "code", "co", "bit", "loc", "fail", "stat", "cr", "func", "rupt", "bf", "cmd", " conditional", "ct", "fc", "len", "c", "thread", "parent", "cb", "reg", "cas", "err", "fl", " conf", "ind", "day", " cont", "col", "pre", "lic", "connect", "bc", "pos", "count", "unit", "ci", "cmp", "success", "act", "exec", "no", "sec", "comp"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n\n                               Jpeg2000Component *comp,\n\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j;\n\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n\n        int *src = t1->data[j];\n\n        if (band->i_stepsize == 16384) {\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = src[i] / 2;\n\n        } else {\n\n            // This should be VERY uncommon\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;\n\n        }\n\n    }\n\n}\n", "idx": 23854, "substitutes": {"x": ["time", "w", "xy", "ix", "p", "h", "en", "code", "X", "ex", "ax", "f", "q", "xxx", "im", "b", "v", "xx", "n", "index", "c", "e", "l", "r", "dx", "xi", "u", "d", "on", "pos", "m", "ci", "t", "px", "z"], "y": ["ey", "ym", "ty", "ny", "cy", "w", "xy", "p", "h", "yt", "oy", "type", "b", "v", "a", "n", "c", "o", "col", "ch", "py", "u", "yi", "d", "vy", "hi", "k", "yy", "m", "ci", "t", "dy", "Y", "z", "ay"], "cblk": ["cblks", "cBLks", "lcblwork", "cbrkt", "cmlks", " cbalkt", "cflkie", "cblef", "dplq", "cllkid", "cplks", "cblf", "cllf", "Cblk", "cllk", "cllb", "cblkie", " cblkie", "cbrk", "cflwork", "Cllk", "cbalkie", "cBlck", "cplwork", "cblkt", "cmlk", "cmlik", "cflk", "cBlkt", "cBlke", "lcblik", "cblb", "Cblkid", "lcBlik", "cflke", "cbalkt", "cblq", " cblke", "Cllb", "cBlks", "cbrck", "lcBlk", "cwlf", "lcBlks", "cbalke", "lcblkt", "cflkt", "lcblk", "Cllkid", "cplq", "cbrq", " cbalkie", "cblekid", "cbreks", "cplck", "Cblb", "cblek", "cwlk", "dplck", " cbalke", "cbrework", "lcblke", "lcplkt", "cblwork", "cBLke", "dplk", "cblke", "dblq", " cblkt", "dblkt", "lcplks", "cmlke", "cblkid", "cBLik", "dplkt", "cwlkid", "Cblf", "dblck", "cwlb", "lcplk", "cblck", "Cllf", "cplke", "dblk", " cbalk", "lcplwork", "cplk", "cBLk", "cbalk", "cbrek", "cflks", "lcBlke", "cbrekt", "cbleb", "cblik", "cBlik", "cBlk", "cBlq", "lcblks", "cplkt", "cplkie"], "comp": ["req", "chart", "crit", "omp", "Comp", "xc", "prep", "prop", "p", "cache", "host", "cc", "code", "core", "par", "proc", "app", "config", "coll", "Component", "uc", "comm", "mac", "con", "c", "pro", "mod", "com", "ch", "ref", "source", "cond", "conv", "cp", "cell", "coord", "comb", "ctx", "cop", "unit", "conf", "cmp", "ctrl", "component", "cel", "spec", "project", "op"], "t1": ["pron", "p2", "pone", "itron", "T1", "tron", " t4", "it2", "p01", "it1", "p1", "p4", "T4", " tone", "it01", "t01", " tron", "t4", "tone", " t01", "Tone", "t2", "T2", " t2"], "band": ["channel", "part", "line", "prop", "bb", "bridge", "host", "co", "disk", "db", "force", "plane", "bd", "mode", "ground", "app", "config", "plan", "gap", "cmd", "b", "io", "pp", "lab", "amp", "bin", "cb", "Band", "range", "bus", "service", "project", "boot", "function", "connection", "plugin", "car", "d", "hard", "product", "gb", "bass", "component", "group", "phase", "tag", "g", "vd", "cell", "piece", "rad"], "i": ["ti", "ii", "ui", "ji", "abi", "qi", "w", "I", "ix", "p", "h", "eni", "phi", "di", "info", "f", "ai", "cli", "ini", "oi", "ie", "b", "si", "io", "v", "init", "a", "pi", "n", "uri", "temp", "o", "e", "ind", "l", "r", "xi", "result", "u", "end", "inner", "fi", "d", "li", "iu", "api", "k", "id", "m", "ci", "mi", "zi", "multi", "gi", "z", "mu", "bi", "it", "ip"], "j": ["ji", "ii", "jen", "jit", "qi", "dj", "w", "ix", "jp", "p", "h", "jo", "el", "f", "ja", "ie", "b", "jc", "v", "uj", "kj", "n", "index", "adj", "o", "e", "jj", "l", "ij", "ch", "xi", "u", "d", "li", "J", "job", "k", "m", "t", "dy", "aj", "z", "jl", "js"], "datap": [" datab", "Dataps", "metamp", "dataps", " Datap", "Datape", "netaps", "arrap", "datab", "netapper", "metab", " datip", "netape", " Datip", "arramp", "dataaps", "datip", "datapper", "dataap", "dataapper", "netap", " datape", " datapper", "datape", "Datap", "dataape", " Dataps", "arrab", "datamp", "metaps", " datamp", " Datape", "metap", "Datip", " dataps", "arraps"], "src": ["support", "inst", "iv", "st", "rs", "text", "sync", "img", "http", "rss", "loc", "proc", "config", "s", "uv", "sec", "uc", "sc", "b", "fc", "uri", "stream", "rest", "sub", "cb", "sb", "range", "r", "result", "dest", "std", "source", "sup", "sur", "conv", "bc", "split", "url", "rc", "data", "rob", "attr", "gb", "rect", "bs", "slice", "sid", "sl", "g", "spec", "rb"]}}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855, "substitutes": {"s": ["z", "sets", "S", "sq", "south", "rs", "w", "p", "h", "ls", "sym", "site", "sync", "sa", "ses", "f", "stats", "ss", "si", "ts", "b", "v", "so", "state", "n", "c", "spec", "sie", "ps", "sb", "o", "storage", "e", "r", "l", "service", "session", "u", "services", "d", "ssl", "i", "sd", "m", "os", "sys", "su", "t", "sf", "socket", "server", "client", "sl", "ns", "sg", "g", "sv", "js"], "sockaddr": ["sckref", "sackoff", "dsockaddress", "ionsockaddress", " sipaddress", "socksaddress", "sighord", "siglen", "sighoa", "siplen", "sigaddr", "sockstr", " sockadd", "sockadd", "sockoa", "sipoa", "ionsockaddr", "dsocklen", "dsipaddress", "scklen", "dsiplen", " sockaddress", " sipaddr", "ionsockstr", "sipaddr", "sipstr", "ionsipoa", "sockaddress", "sockord", "sipref", "dsockaddr", "sinkoff", " sipadd", "sinkstr", "sockref", "dsockref", "sipoff", "ionsockoa", "ionsipaddr", "sinkaddress", " sipoff", "sighaddress", "socksaddr", "sipadd", "sigref", "sackadd", "sckaddr", "sackaddr", "sipaddress", "dsipref", "sipord", "ionsipaddress", "sockoff", "socksord", "dsockord", "ionsipstr", "sinkadd", "sinkaddr", "sighaddr", "dsipord", "sckaddress", "socklen", "sackaddress", "dsipaddr", "sigaddress", "sinkoa", " sockoff", "sighstr"], "len": ["part", "ler", "line", "lin", "lc", "en", "Len", "lf", "num", "el", "val", "ln", "rev", "elt", "length", "f", "lan", "dl", "ie", "loc", "lock", "seq", "n", "base", "fun", "fl", "l", " length", "nt", "limit", "lic", "size", "ll", "li", "d", "pos", "data", "count", "id", "alt", "fin", "ell", "fn", "db", "dy", "lib", "lon", "sl", "ld"], "fd": ["dc", "hd", "cd", "f", "FD", "fun", "fa", "ff", "fb", " FD", "vd", "ld", "nd", " fid", "pid", "lf", "db", " f", "ds", " ff", "md", "config", "driver", " d", "bf", "fee", "dir", "fw", "fl", "pipe", "e", "fed", "flow", "fat", "format", "director", "xd", " fin", "sd", "fax", "fin", "dn", "dy", "pd", "fe", "flo", "draft", "ln", "dl", "feed", "v", "temp", "df", "c", "handler", " df", "l", "fp", "dd", "fi", "fx", "socket", "ctl", "cf", "dt", "bd", "pointer", "FH", "td", "fs", "fc", "buf", "cb", "fen", "d", "fn", "sf", "wd", "exec", "fm"]}}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferHEVC  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferHEVC   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH265Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH265MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        // general_profile_space == 0.\n\n        vseq->general_profile_idc = 1; // Main profile (ctx->codec_profile?)\n\n        vseq->general_tier_flag = 0;\n\n\n\n        vseq->general_level_idc = avctx->level * 3;\n\n\n\n        vseq->intra_period = 0;\n\n        vseq->intra_idr_period = 0;\n\n        vseq->ip_period = 0;\n\n\n\n        vseq->pic_width_in_luma_samples  = ctx->aligned_width;\n\n        vseq->pic_height_in_luma_samples = ctx->aligned_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1; // 4:2:0.\n\n        vseq->seq_fields.bits.separate_colour_plane_flag = 0;\n\n        vseq->seq_fields.bits.bit_depth_luma_minus8 = 0; // 8-bit luma.\n\n        vseq->seq_fields.bits.bit_depth_chroma_minus8 = 0; // 8-bit chroma.\n\n        // Other misc flags all zero.\n\n\n\n        // These have to come from the capabilities of the encoder.  We have\n\n        // no way to query it, so just hardcode ones which worked for me...\n\n        // CTB size from 8x8 to 32x32.\n\n        vseq->log2_min_luma_coding_block_size_minus3 = 0;\n\n        vseq->log2_diff_max_min_luma_coding_block_size = 2;\n\n        // Transform size from 4x4 to 32x32.\n\n        vseq->log2_min_transform_block_size_minus2 = 0;\n\n        vseq->log2_diff_max_min_transform_block_size = 3;\n\n        // Full transform hierarchy allowed (2-5).\n\n        vseq->max_transform_hierarchy_depth_inter = 3;\n\n        vseq->max_transform_hierarchy_depth_intra = 3;\n\n\n\n        vseq->vui_parameters_present_flag = 0;\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->vui_num_units_in_tick = avctx->framerate.num;\n\n            vseq->vui_time_scale        = avctx->framerate.den;\n\n        } else {\n\n            vseq->vui_num_units_in_tick = avctx->time_base.num;\n\n            vseq->vui_time_scale        = avctx->time_base.den;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->decoded_curr_pic.picture_id = VA_INVALID_ID;\n\n        vpic->decoded_curr_pic.flags      = VA_PICTURE_HEVC_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->reference_frames); i++) {\n\n            vpic->reference_frames[i].picture_id = VA_INVALID_ID;\n\n            vpic->reference_frames[i].flags      = VA_PICTURE_HEVC_INVALID;\n\n        }\n\n\n\n        vpic->collocated_ref_pic_index = 0xff;\n\n\n\n        vpic->last_picture = 0;\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n\n\n        vpic->diff_cu_qp_delta_depth = 0;\n\n        vpic->pps_cb_qp_offset = 0;\n\n        vpic->pps_cr_qp_offset = 0;\n\n\n\n        // tiles_enabled_flag == 0, so ignore num_tile_(rows|columns)_minus1.\n\n\n\n        vpic->log2_parallel_merge_level_minus2 = 0;\n\n\n\n        // No limit on size.\n\n        vpic->ctu_max_bitsize_allowed = 0;\n\n\n\n        vpic->num_ref_idx_l0_default_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_default_active_minus1 = 0;\n\n\n\n        vpic->slice_pic_parameter_set_id = 0;\n\n\n\n        vpic->pic_fields.bits.screen_content_flag = 0;\n\n        vpic->pic_fields.bits.enable_gpu_weighted_prediction = 0;\n\n\n\n        // Per-CU QP changes are required for non-constant-QP modes.\n\n        vpic->pic_fields.bits.cu_qp_delta_enabled_flag =\n\n            ctx->va_rc_mode != VA_RC_CQP;\n\n    }\n\n\n\n    {\n\n        mseq->video_parameter_set_id = 5;\n\n        mseq->seq_parameter_set_id = 5;\n\n\n\n        mseq->vps_max_layers_minus1 = 0;\n\n        mseq->vps_max_sub_layers_minus1 = 0;\n\n        mseq->vps_temporal_id_nesting_flag = 1;\n\n        mseq->sps_max_sub_layers_minus1 = 0;\n\n        mseq->sps_temporal_id_nesting_flag = 1;\n\n\n\n        for (i = 0; i < 32; i++) {\n\n            mseq->general_profile_compatibility_flag[i] =\n\n                (i == vseq->general_profile_idc);\n\n        }\n\n\n\n        mseq->general_progressive_source_flag    = 1;\n\n        mseq->general_interlaced_source_flag     = 0;\n\n        mseq->general_non_packed_constraint_flag = 0;\n\n        mseq->general_frame_only_constraint_flag = 1;\n\n        mseq->general_inbld_flag = 0;\n\n\n\n        mseq->log2_max_pic_order_cnt_lsb_minus4 = 8;\n\n        mseq->vps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->vps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->vps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->vps_max_latency_increase_plus1[0]   = 0;\n\n        mseq->sps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->sps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->sps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->sps_max_latency_increase_plus1[0]   = 0;\n\n\n\n        mseq->vps_timing_info_present_flag = 1;\n\n        mseq->vps_num_units_in_tick = avctx->time_base.num;\n\n        mseq->vps_time_scale        = avctx->time_base.den;\n\n        mseq->vps_poc_proportional_to_timing_flag = 1;\n\n        mseq->vps_num_ticks_poc_diff_minus1 = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            mseq->conformance_window_flag = 1;\n\n            mseq->conf_win_left_offset   = 0;\n\n            mseq->conf_win_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            mseq->conf_win_top_offset    = 0;\n\n            mseq->conf_win_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            mseq->conformance_window_flag = 0;\n\n        }\n\n\n\n        mseq->num_short_term_ref_pic_sets = 0;\n\n        // STRPSs should ideally be here rather than repeated in each slice.\n\n\n\n        mseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            mseq->aspect_ratio_info_present_flag = 1;\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                mseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                mseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                mseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                mseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (1) {\n\n            // Should this be conditional on some of these being set?\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format = 5; // Unspecified.\n\n            mseq->video_full_range_flag = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            mseq->colour_primaries = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coeffs = avctx->colorspace;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23870, "substitutes": {"avctx": ["avcp", "navcf", "svca", "svcmp", "afcmp", " avcp", "Avconn", "vcmp", "Avcu", "avecmp", "avconfig", "avloc", "AVctl", "navcontext", "AVconfig", "AVca", "afctl", "AVcu", "afca", "avcontext", "aveloc", "avecontext", "varctx", "avconn", "avcu", "vctx", "avectx", "AVloc", "varctl", "AVctx", "varcontext", "vloc", " avcf", "afconn", "evconn", "evctx", "AVcontext", "avctl", "varcmp", "Avctx", "avcmp", "evconfig", "afconfig", "navcp", "svctx", "AVconn", " avcontext", "svcontext", "afcf", "avecu", "vcontext", "afctx", "evcontext", "avca", "aveconn", "AVcmp", "afcp", "avcf", "navctx", "Avcontext", "afcontext"], "ctx": ["mc", "cf", "sq", "cv", "xc", "lc", "cu", "sync", "cc", "cases", "loc", "cli", "proc", "config", "cus", "sci", "pc", "uc", "rx", "Context", "anc", "cmd", "sc", "git", "media", "c", "fw", "utils", "cb", "ca", "cas", "cs", "tx", "conn", "kb", "fp", "hw", "auc", "qs", "cm", "conv", "wcs", "bc", "qa", "cp", "tc", "rc", "concept", "cca", "vc", "ci", "pkg", "ctrl", "cmp", "client", "nc", "context", "cam", "cn", "voc", "ann"], "vseq": ["revseq", "svseq", "vframe", "varseq", "fqueue", "uzip", "gseq", "Vstruct", "vreq", "vsem", "Vsem", "Vctx", "Vreq", " viq", "vcomp", "fsequence", "nsequence", "ssequ", "vinseq", "vesequence", "estruct", "sviq", " vsequence", "uvec", "vgen", "viq", "gstruct", " vclus", "voltctx", "ovsequence", "evsequence", "lqa", "wsequence", "useq", "yna", " vbatch", "Vclus", "vinsequence", "ysequence", " vcode", "Vsequ", "ureq", "lstruct", "veseq", "evsequ", "yseq", "ysem", "nvseq", "jiq", "vcode", "vevec", "lcode", "vstruct", "Vgen", "ovgen", "vna", "revsequence", "sclus", "variseq", "evreq", "variq", "Vframe", "ovseq", "eseq", "lna", "usequence", "lsequ", "fstruct", "varisequence", " vqueue", "lvec", "fna", " vqa", "lcomp", " vstruct", "Vseq", "Vconfig", "gsequence", "nvframe", " vcf", "ssequence", "varireq", "nseq", "Vvec", "liq", "vcf", "svsequ", " vzip", "evvec", "fseq", "giq", " vsequ", "vinclus", "lclus", "verreq", "wseq", " vvec", "usequ", "nvsequence", " vcomp", " vconfig", "vincf", "revcode", "esequence", "lreq", "Vna", "revqa", "nbatch", "gsequ", " vna", "wcomp", "vqueue", "vctx", "vinqueue", "voltvec", "ovvec", " vsem", "evseq", "Vsequence", " vctx", "sseq", "jseq", "svstruct", "wctx", "verseq", "svclus", "svsequence", "vsequence", "vzip", "vclus", "svconfig", "vconfig", "jbatch", "niq", "lseq", "varivec", "nvgen", "vequeue", "vvec", "fcf", "voltsequence", "voltseq", "varsequence", "fsequ", "jsequence", " vgen", "ena", "versequence", "wsequ", " vframe", " vreq", "svqueue", "vinzip", "vqa", "vbatch", "varvec", "svvec", "versequ", "lsequence", "lzip", "vsequ"], "vpic": [" vproc", " vstruct", "svproc", "tvpic", "tvproc", "tvctx", "vproc", " vctx", "svpic", "vctx", "svctx", "vstruct", "svstruct", "tvstruct"], "priv": ["mc", "auth", "cfg", "req", "cy", "cache", "access", "cci", "proc", "info", "ocr", "config", "roc", "uc", "anc", "ki", "ca", "cb", "prof", "tx", "conn", "acc", "pri", "aux", "pb", "private", "fi", "soc", "cp", "rc", "data", "obj", "vc", "conf", "pkg", "Priv", "cmp", "lib", "pub", "cam", "sec", "voc"], "mseq": ["dvec", "dsequence", "msequ", "gmvec", "msequence", "cmsequence", "gmsequ", "dsequ", "gmseq", "gmsequence", "cmseq", "cmvec", "cmsequ", "mvec", "dseq"], "i": ["ti", "ii", "x", "I", "p", "phi", "di", "j", "f", "is", "v", "a", "pi", "n", "c", "o", "e", "xi", "d", "iu", "count", "id", "zi", "ci", "multi", "bi", "it", "ip"]}}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "static void rdft_calc_c(RDFTContext *s, FFTSample *data)\n\n{\n\n    int i, i1, i2;\n\n    FFTComplex ev, od;\n\n    const int n = 1 << s->nbits;\n\n    const float k1 = 0.5;\n\n    const float k2 = 0.5 - s->inverse;\n\n    const FFTSample *tcos = s->tcos;\n\n    const FFTSample *tsin = s->tsin;\n\n\n\n    if (!s->inverse) {\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n    /* i=0 is a special case because of packing, the DC term is real, so we\n\n       are going to throw the N/2 term (also real) in with it. */\n\n    ev.re = data[0];\n\n    data[0] = ev.re+data[1];\n\n    data[1] = ev.re-data[1];\n\n    for (i = 1; i < (n>>2); i++) {\n\n        i1 = 2*i;\n\n        i2 = n-i1;\n\n        /* Separate even and odd FFTs */\n\n        ev.re =  k1*(data[i1  ]+data[i2  ]);\n\n        od.im = -k2*(data[i1  ]-data[i2  ]);\n\n        ev.im =  k1*(data[i1+1]-data[i2+1]);\n\n        od.re =  k2*(data[i1+1]+data[i2+1]);\n\n        /* Apply twiddle factors to the odd FFT and add to the even FFT */\n\n        data[i1  ] =  ev.re + od.re*tcos[i] - od.im*tsin[i];\n\n        data[i1+1] =  ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n        data[i2  ] =  ev.re - od.re*tcos[i] + od.im*tsin[i];\n\n        data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n    }\n\n    data[2*i+1]=s->sign_convention*data[2*i+1];\n\n    if (s->inverse) {\n\n        data[0] *= k1;\n\n        data[1] *= k1;\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n}\n", "idx": 23872, "substitutes": {"s": ["south", "p", "less", "se", "f", "si", "a", "sb", "cs", "u", "gs", "conf", "same", "this", "your", "spec", "sv", "support", "current", "aws", "ses", "ds", "sample", "is", "b", "ts", "n", "ps", "e", "args", "services", "sup", "os", "params", "states", "S", "w", "h", "sym", "site", "bis", "sci", "stats", "v", "c", "space", "r", "l", "service", "qs", "m", "sys", "t", "server", "g", "sets", "sq", "rs", "sync", "fs", "ss", "o", "session", "d", "in", "ssl", "self", "su", "sf", "ns", "ls", "sg", "js"], "data": ["first", "script", "delay", "aa", "cache", "p", "date", "info", "f", "valid", "ata", "mask", "content", "a", "view", "board", "module", "window", "key", "function", "ops", "pos", "product", "pad", "multi", "la", "grad", "open", "add", "items", "support", "dates", "models", "empty", "version", "options", "current", "img", "results", "config", "only", "sample", "devices", "align", "index", "e", "keys", "args", "batch", "parts", "end", "size", "model", "memory", "input", "arr", "sd", "ad", "Data", "array", "slice", "map", "rec", "ui", "params", "values", "lines", "w", "h", "DATA", "na", "pages", "wa", "pass", "media", "v", "change", "temp", "apps", "c", "steps", "error", "dat", "style", "r", "space", "draw", "output", "actions", "value", "missing", "m", "done", "record", "g", "new", "zip", "image", "x", "zero", "series", "code", "di", "load", "complete", "extra", "response", "days", "as", "start", "body", "next", "o", "da", "views", "message", "result", "session", "post", "off", "d", "split", "video", "one", "list", "this"], "i": ["ii", "qi", "ani", "ix", "p", "phi", "info", "f", "si", "io", "pi", "vi", "u", "key", "uni", "mini", "k", "ik", "mi", "multi", "ori", "ji", "ti", "I", "isi", "ri", "j", "cli", "ni", "is", "b", "n", "index", "uri", "e", "ind", "y", "xi", "chi", "api", "ic", "id", "slice", "gi", "ip", "ui", "ie", "oi", "v", "c", "uli", "l", "adi", "yi", "fi", "li", "m", "ci", "zi", "bi", "it", "abi", "x", "eni", "code", "di", "ai", "ini", "ia", "o", "d", "in", "iu"], "i1": ["i71", "li1", "si81", "pi31", "sione", "iione", "int8", "ione", "iL", "iu91", " i3", "ii31", " i01", "iniL", "li6", "iu64", "ii100", "int3", "iu61", "qi71", "iu1", "e91", "ini81", "iu71", "ii3", "i100", "pi01", "int1", "ii8", "i61", " ione", "pi1", "intOne", "i8", "ii71", "li2", "ii1", "iu01", "ini71", "e1", "li61", "qi01", "li13", "ini1", " iOne", "p2", "io1", "i13", " i61", "si61", "si71", "p01", "pi100", "pione", "iu13", "p1", "pi64", "ioone", "io01", "i3", "e71", "si100", "iOne", "si8", "e01", " i6", "si01", "ii81", "iu31", "i81", "li01", "i64", "ii01", "i6", "siOne", "li64", "pi13", "qi1", "io100", "i91", "iiOne", "i01", "iiL", " i81", " i8", "i31", "qi91", "ii61", "p6", "iu100", "siL", "pi61", "si1"], "i2": ["iuTwo", " i52", "u02", "i256", "iiTwo", "xi5", "uiSecond", "IB", "i4", "xi42", "i10", "k4", "ii5", "xi2", "iu2", "li62", "iniTwo", "si82", "isecond", "i20", "i5", "oiII", "ini6", "I62", "ii2", "k2", "I2", "ii8", "ui2", " iII", "kB", " i20", "i8", "ITwo", "li2", "ii1", "ini10", "i52", "oi62", "I4", "i42", "siII", "i82", "ii62", "li02", "si62", "k62", "iB", "iSecond", " isecond", "iiSecond", "si5", "si2", "iTwo", "i62", "ii82", "ui82", "ini52", "ini256", "siTwo", " i4", "ii10", "ii52", "ini62", "oi2", "liTwo", " i62", " i6", "u2", "si42", "iu10", " iB", "i6", " i02", "i02", "siSecond", "ii42", "ii6", "I8", "ii256", "ini2", "iII", "u20", "ui1", "oisecond", "li8", "xiTwo", "li20", "iu256", "sisecond", "si1"], "ev": ["ek", "aa", "cv", "cd", "tv", " dev", "ove", "equ", "ep", "im", "ae", "vr", "eff", "dev", "sk", "tr", "lv", "dem", "em", "sv", "ec", "iv", "event", "img", "lev", "ef", "wave", "ood", "uv", "ect", "gd", "vec", "eva", "e", "ind", "evidence", "av", "complex", "nov", "model", "re", "ott", "sd", "rec", "element", "inst", "gg", "gr", "ve", "eval", "oe", "enc", "vert", "el", "oy", "rev", "ov", "ak", "exper", "v", "c", "err", "ew", "r", "ch", "dd", "om", "ell", "record", "image", "ih", "ever", "eg", "vol", "ver", "ee", "er", "eb", "Ev"], "od": ["nd", "ok", "ani", "ur", "oder", "oe", "lad", "co", "OD", "ed", "ord", "oy", "el", "ud", "md", "td", "ood", "valid", "ov", "order", "gd", "pred", "rod", "oh", "cod", "oda", "ode", "ag", "mod", "o", "dev", "odd", "ind", "old", "ods", "or", "dd", "oid", "post", "off", "end", "bad", "ob", "odic", "d", "ox", "in", "opt", "ott", "ost", "id", "oa", "sd", "odi", "ad", "pad", "ody", "ell", "yd", "er", "ant", "add", "lov", "vd", "ld", "de", "op"], "tcos": ["tscs", "dcs", "tcs", "xcos", "Tmas", " tcin", "tsras", " tns", "tmas", " tpos", "Tpos", "tsros", " tmas", "tspose", "tns", "tspos", "tcus", "tpose", "Tcos", "ttcos", "hpos", "tscos", "ttns", "tscin", " tbs", "Tsin", "tras", "tnas", "dras", "xpos", "dris", " tras", " toks", "tris", "dcos", "tsoks", "hcos", "hpose", "xcus", "Tros", "Tcus", "tpos", "Tbs", "retnas", "Tcin", "ttcus", "retmas", "xbs", " tcs", "ttpos", "retcos", "tros", "retoks", "retcin", "tbs", "tcin", " tnas", "Tpose", "hros", "tsris", "ttbs", " tris", "retpos", "Tns", "toks", "ttsin", "tsnas"], "tsin": ["ssini", "timesinc", "vertsinc", "tipscin", "tipsinc", "psinn", "tsbin", "timescin", "atsIN", "psini", "tesout", "outsini", "tsins", "vertsbin", "TSbin", "ssin", "tesbin", "tsinn", "tesinc", "TSinn", "tesin", "tscin", "timesin", "tescin", "timesbin", "tipsout", "atesbin", "tesoin", "mentsin", "msinn", "TSin", "timesins", "TSoin", "outsinc", "msins", "tipsin", "atsoin", "tsoin", "timesini", "tsinc", "outsin", "tsout", "atesinn", "vertsoin", "tsIN", "atesin", "atesini", "vertsin", "tesins", "ssinn", "mentsIN", "psin", "TSins", "mentsins", "msini", "mentsoin", "TSIN", "tesini", "msin", "TSini", "ssins", "timesoin", "atsins", "psbin", "outsins", "tsini", "timesout", "atsin"]}}
{"project": "FFmpeg", "commit_id": "aca490777f9da2a71b537874ed4e16105bb3df02", "target": 0, "func": "static av_cold int g726_init(AVCodecContext * avctx)\n\n{\n\n    AVG726Context* c = (AVG726Context*)avctx->priv_data;\n\n    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;\n\n\n\n    if (\n\n        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&\n\n         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n    if(index>3){\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of bits %d\\n\", index+2);\n\n        return -1;\n\n    }\n\n    g726_reset(&c->c, index);\n\n    c->code_size = c->c.tbls->bits;\n\n    c->bit_buffer = 0;\n\n    c->bits_left = 0;\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23877, "substitutes": {"avctx": ["devctx", "avalctx", "AVconfig", "avcup", "airctx", "avlc", " avlc", "aircf", "ajcup", "devcmp", "avectx", " avcu", "aversci", "avctl", "AVcontext", "afloc", "avercmp", "alcontext", "afconfig", "aircmp", "ajcv", "avecu", "avesci", "avecup", "alctl", "avalcontext", "avectl", "avecmp", "avalcmd", " avvoc", "afctl", "avcontext", "afcca", "aveloc", "verconn", "ajconn", "avevoc", "vercontext", "avvoc", "avcv", "ajcontext", "avercf", "avecmd", "avelc", " avconn", "aflc", "ajcmd", "devcf", "afcup", "afcontext", "ajctx", "afcv", "avconfig", "avloc", "AVctl", "AVcf", "avsci", "afsci", " avloc", "devcontext", "avecontext", " avctl", "avcu", "aveconfig", "alcmd", "avalloc", "afconn", "averctx", " avcca", "avcmp", "afvoc", "afcf", "avcmd", "AVcv", "AVcmp", "avalconfig", "vercf", "afcmp", "Avctl", "Avconn", "alloc", "avalctl", "averctl", "avecf", "ajcmp", "averconn", "afcmd", "verctx", "avalcmp", "afcu", "avconn", "AVctx", "alctx", "Avctx", "AVconn", " avcontext", "avecca", "afctx", "avcf", "avcca", "aveconn", "avercontext", "airctl", "Avcontext"], "c": ["C", "mc", "dc", "cf", "z", "cy", "w", "cache", "p", "cu", "lc", "h", "cc", "co", "ac", "ce", "f", "config", "s", "roc", "uc", "coll", "cur", "pc", "cr", "b", "oc", "sc", "v", "orc", "a", "n", "con", "ca", "o", "e", "cs", "l", "conn", "r", "ch", "u", "cm", "d", "unc", "bc", "cp", "tc", "data", "ctx", "k", "i", "m", "ci", "conf", "t", "self", "ctrl", "cmp", "context", "g", "this", "exec", "ec"]}}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "substitutes": {"addr": ["adr", "ace", "inet", "image", "x", "src", "host", "pointer", "ord", "address", "asm", "align", "amp", "padding", "buf", "ar", "nr", "alpha", "r", "amd", "ref", "np", "rc", "ptr", "dr", "pad", "ad", "oa", "array", "slice", "nc", "g", "Address", "hp", "rb", "prefix", "ip"], "size": ["shape", "capacity", "cache", "answer", "order", "si", "Size", "see", "SIZE", "sum", "range", "storage", "function", "source", "needed", "side", "pos", "data", "count", "i", "score", "term", "bytes", "confirmed", "global", "timeout", "empty", "en", "area", "num", "name", "loc", "address", "fee", "len", "n", "from", "e", "page", "white", "ize", "end", "sized", "grade", "shift", "false", "large", "set", "ui", "length", "second", "change", "c", "error", "or", "negative", "value", "small", "es", "esc", "unit", "done", "g", "new", "sync", "code", "complete", "extra", "response", "max", "start", "when", "scale", "position", "send", "since", "message", "result", "number", "speed", "last", "sec"], "offset": ["part", "ace", "timeout", "origin", "empty", "attribute", "location", "answer", "pointer", "loc", "type", "address", "length", "Offset", "option", "extra", "online", "now", "start", "order", "disabled", "exclusive", "second", "len", "align", "index", "padding", "next", "position", "o", "range", "adjust", "error", "alpha", "aligned", "alias", "page", "result", "ref", "limit", "end", "off", "initial", "after", "pos", "attr", "ptr", "count", "id", "shift", "optional", "oa", "i", "iterator", "array", "number", "slice", "no", "set", "prefix", "operation"], "p": ["po", "x", "w", "jp", "h", "pair", "pointer", "proc", "f", "s", "q", "pc", "b", "v", "pp", "pi", "n", "a", "c", "lp", "o", "bp", "e", "r", "P", "l", "fp", "py", "u", "pre", "point", "vp", "tp", "d", "np", "cp", "api", "i", "sp", "m", "t", "dp", "ap", "g", "wp", "op", "ip"], "tmp": ["tt", "cache", "buffer", "proc", "f", "tf", "pp", "sb", "storage", "bp", "py", "pre", "opp", "source", "opt", "data", "pad", "fb", "clip", "binary", "wp", "po", "part", "stuff", "jp", "test", "loc", "address", "now", "config", "sample", "b", "mp", "page", "sup", "np", "api", "paper", "input", "shift", "array", "slice", "bb", "buff", "v", "temp", "wx", "c", "fp", "meta", "output", "copy", "tc", "wrapper", "ptr", "sp", "m", "t", "gz", "front", "rb", "zip", "st", "code", "pointer", "extra", "start", "buf", "cb", "appy", "cro", "vt", "result", "prev", "crop", "tp", "cp", "attr", "treatment", "obj", "kk", "emp", "txt", "cmp"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895, "substitutes": {"v": ["iv", "w", "ve", "ev", "p", "h", "tv", "vert", "val", "j", "f", "uv", "vv", "vm", "gu", "view", "volt", "c", "vic", "o", "e", "ver", "l", "vi", "vt", "u", "vp", "V", "conv", "api", "video", "vim", "lv", "k", "vc", "i", "m", "t", "vs", "util", "vd", "g", "z", "sv", "var"], "errp": ["armlp", "armp", "erpa", "erps", "errc", "eorpa", "errlp", "erP", "erpc", "errpi", "errP", "derpi", "erc", "eorp", " errP", " errpi", "drlp", "eorc", "errpc", "armP", "derp", "drp", "errps", "errpa", "erlp", " errc", "eorP", "drps", "drP", " errpc", "derpc", "erpi", " errpa", "erp", "derP", "armps"]}}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899, "substitutes": {"client": ["support", "ace", "man", "req", "close", "cl", "contact", "cache", "contract", "call", "current", "core", "cat", "http", "co", "name", "ce", "cli", "public", "cart", "friend", "config", "request", "irc", "Client", "cmd", "cod", "con", "c", "parent", "from", "patch", "conn", "manager", "clean", "private", "connection", "cm", "plugin", "command", "connect", "port", "api", "cell", "progress", "child", "input", "product", "container", "ci", "server", "custom", "util", "open", "method", "cn", "node", "master", "resource", "project", "remote"], "fatal": ["elfiller", "flaster", "flale", "afault", "filler", "ofatal", "elfatal", "rfiller", "fault", "afatal", "elfale", "fal", "elfaster", "infaster", "flatal", "ofaster", "infatal", "afal", "rfale", "faster", "ofal", "infal", "infault", "afaster", "fale", "rfatal", "ofault", "rfaster", "fliller"], "errp": [" errpr", "eorfp", "errr", "erps", " errcp", "eorcp", " errps", " erpe", " errf", " erf", "errpr", "errfp", "rrp", "ercp", "errf", "errorr", "rrpr", " errpe", "errcp", "eorp", "erfp", "arrp", " errfp", " err", "derfp", "derpe", "eorps", "rrfp", "derp", " erp", "errps", "errorp", "arrcp", "arrfp", "arrpr", "errpe", "rrpe", "errorpe", "erpe", " errr", "errorf", "derpr", "erp", "erpr"], "ret": ["desc", "req", "att", "match", "def", "res", "resp", "rets", "fit", "empty", "en", "lit", "mem", "cat", "all", "rt", "val", "_", "rev", " Ret", "ft", "det", "f", "art", "mt", "pass", "ut", "RET", "len", "fun", "reg", "cb", "base", "conn", "nt", "result", "ref", "py", "value", "fi", "bot", " RET", "reply", "rc", "re", "obj", "flag", "alt", "t", "arg", "fin", "sil", "Ret", "rep", "let"]}}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912, "substitutes": {"node_path": ["host_name", "host_package", "nodevalhost", "host_root", "nodevalname", "node_package", "host_pointer", "node_name", "host_host", "node_root", "node_host", " node_prop", "node_prop", "node_pointer", "nodevalpackage", "node_folder", "host_path", "nodevalpath", " node_name", " node_folder"], "prop": ["part", "home", "property", "p", "lit", "priv", "host", "pid", "test", "pointer", "name", "type", "proc", "option", "config", "pred", "pro", "parent", "range", "prot", "col", "tmp", "key", "Prop", "ref", "pb", "opt", "value", "op", "cp", "attr", "target", "data", "id", "param", "field", "term", "method", "project", "properties", "comp"], "val": ["expr", "VAL", "x", "eval", "def", "al", "p", "lit", "el", "buffer", "valid", "func", "b", "v", "buf", "base", "vec", "slot", "pt", "l", "ref", "sel", "vals", "value", "opt", "str", "read", "split", "data", "arg", "Val", "sl"], "len": ["part", "line", "resp", "lin", "en", "lit", "Len", "mem", "lc", "ellen", "lf", "num", "el", "name", "ln", "le", "rev", "length", "elt", "lan", "valid", "loc", "lt", "seq", "n", "c", "err", "base", "fun", "fl", "min", "l", " length", "fd", "nt", "fat", "limit", "pre", "ref", "end", "str", "size", "ll", "gen", "li", "pos", "data", "lif", "count", "fin", "la", "fn", "ell", "lon", "sl", "ls"], "path": ["home", "close", "cache", "p", "h", "enc", "host", "location", "cat", "route", "pointer", "loc", "name", "folder", "length", "config", "rh", "anc", "cmd", "dir", "temp", "n", "index", "ath", "c", "next", "parent", "base", "error", "handler", "l", "conn", "root", "fp", "fd", "limit", "ref", "key", "dest", "end", "point", "near", "np", "api", "url", "cp", "Path", "data", "child", "obj", "ctx", "id", "fn", "success", "open", "file", "method", "node", "prefix", "inner"], "f": ["cf", "af", "w", "fit", "p", "h", "fe", "inf", "fast", "j", "s", "fr", "fs", "bf", "feed", "b", "v", "fc", "F", "c", "df", "fun", "o", "fen", "e", "handler", "r", "fa", "l", "fd", "fp", "ref", "fac", "function", "fo", "fi", "ff", "raf", "d", "api", "rf", "m", "fx", "form", "t", "fn", "fb", "sf", "file", "g", "fm"], "ret": ["line", "match", "resp", "rets", "res", "fit", "al", "lit", "mem", "code", "cat", "rt", "name", "rev", "j", "det", "el", "elt", "ut", "RET", "gt", "feat", "base", "fun", "err", "reg", "nt", "result", "fat", "ref", "run", "out", "str", "fi", "bad", "re", "obj", "job", "id", "alt", "fin", "arg", "success", "fire", "Ret", "no", "ext"], "pathlen": ["athel", " pathen", "threadLen", "pathel", "Pathlength", "pathlength", "collen", " pathl", " pathel", "PathLen", "pathl", "Pathlon", " pathlength", "tempLen", "threadlen", "Pathel", "threaden", " pathLen", " pathlon", "pathen", "athLen", "pathLen", "Pathlen", "templen", "colLen", "templength", "athlen", "Pathl", "pathlon", "templ", "Pathen", "threadlon", "athlength", "collength"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 23916, "substitutes": {"s": ["states", "sets", "sq", "S", "ks", "w", "p", "h", "sync", "site", "us", "se", "ses", "ds", "f", "ches", "info", "ions", "stat", "stats", "request", "is", "fs", "b", "ss", "n", "c", "spec", "hs", "sb", "o", "e", "cs", "r", "service", "session", "u", "services", "qs", "private", "details", "es", "d", "ssl", "input", "scope", "gs", "i", "self", "m", "sys", "os", "t", "conf", "sf", "client", "this", "g", "ns", "sg", "sv", "js"], "data": ["desc", "def", "res", "cache", "src", "p", "DATA", "ds", "address", "info", "proc", "config", "decl", "sample", "xxx", "dll", "device", "base", "da", "database", "reg", "dat", "args", "result", "session", "str", "d", "memory", "input", "arr", "ctx", "reader", "mi", "ad", "m", "la", "grad", "Data", "array", "record", "slice", "map", "xxxx", "resource", "rec", "sam"], "addr": ["adr", "ha", "ace", "params", "nm", "src", "p", "eni", "ea", "area", "arm", "code", "pointer", "offset", "loc", "ord", "address", "m", "ack", "rx", "dll", "mac", "asm", "align", "osi", "amp", "ar", "index", "reg", "da", "sb", "alias", "nr", "e", "r", "amd", "sta", "ref", "dd", "rn", "np", "pos", "attr", "rc", "obj", "arr", "ptr", "coord", "ctx", "dr", "pad", "ad", "oa", "orig", "la", "work", "array", "arg", "add", "Address"], "oi": [" pci", " ii", "ui", " mi", "ti", "ii", " os", "abi", "inet", "ok", "sym", "eni", "uci", "ib", " ip", "di", "offset", " ie", "loc", "address", "ai", "ie", "roc", "ni", "ini", " di", "ski", "si", "mm", "im", "oji", "pi", "ei", "osi", "oda", "ahi", "rio", "uri", "amp", " bi", "o", " pi", "tmp", " iii", "oni", "iri", "agi", "asi", "yi", "oid", "cm", "fi", "aram", " si", "iu", " ki", "i", "oa", "mi", "ci", "odi", "oci", "ois", "ilo", "ori", " vi", "igi", "ip"], "is_64": [" is_32", "isx64", "is232", "is_128", "Is_64", "isx128", "is264", "is224", "is_32", " is_128", "is2128", "is_44", "isx32", "is_24", "Is_44", "Is_24", " is_24", "isx24", "Is_32"], "addrz": ["adrZ", "attrZ", "alignz", "addressz", "addrZ", "addrzen", "adriz", "drx", "addressZ", " addry", "adrzen", "addressiz", "drz", "attrzo", "aligniz", "attrz", "addrx", "alignzen", "drZ", "addrj", "urly", "addriz", "urlz", "addrzo", "urlzo", "drj", "adrz", " addrzo", "alignZ", " addrj", " addrZ", "addry", "alignx", "urlZ", "attry", " addrx", "addresszen", "alignj"], "param": ["adr", "channel", "part", "params", "item", "nm", "p", "sym", "mem", "arm", "num", "loc", "par", "var", "address", "proc", "pm", "rm", "config", "prom", "nick", "ram", "type", "ack", "request", "im", "vm", "mm", "asm", "temp", "resource", "amp", "index", "c", "err", "reg", "da", "sm", "error", "nom", "pri", "amd", "tmp", "ref", "rac", "source", "cm", "rn", "aram", "qa", "model", "member", "pos", "attr", "ctx", "grade", "m", "arg", "ad", "am", "inc", "rb", "sam", "Param"], "func": ["lambda", "cf", "partial", "doc", "src", "alloc", "stack", "call", "cc", "code", "val", "name", "go", "loc", "proc", "f", "xxx", "pc", "rx", "Function", "pass", "cmd", "dll", "aug", "asm", "callback", "mac", "align", "kw", "c", "fun", "cb", "cs", "r", "xp", "args", "amd", "function", "str", "unc", "attr", "rc", "wrapper", "obj", "job", "ctx", "CC", "self", "abc", "orig", "fn", "work", "sys", "slice", "method", "exec", "sec", "comp", "var"], "label_ptr": ["labelxpt", "labelingstruct", "label__ptr", "label__tr", "label_struct", "code_pt", "code_pointer", "labelxpointer", "labelxstruct", "labelingptr", "labelingpt", "label_tr", "align_proc", "label_proc", "align_ptr", "code_struct", "label_pointer", "labelingpointer", "labelxptr", "label__proc", "align_tr", "code_ptr", "label_pt", "label__pointer", "align_pointer"]}}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n", "idx": 23918, "substitutes": {}}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23922, "substitutes": {"s": ["ins", "p", "us", "f", "si", "a", "sb", "cs", "u", "details", "ops", "tests", "side", "gs", "i", "conf", "your", "spec", "sv", "aws", "uds", "ses", "ds", "an", "xs", "devices", "is", "b", "ts", "n", "ps", "e", "args", "services", "os", "set", "params", "S", "ks", "w", "sym", "site", "ions", "stats", "its", "v", "c", "r", "l", "service", "qs", "es", "m", "sys", "t", "server", "g", "new", "settings", "sets", "sq", "rs", "sync", "http", "as", "request", "fs", "ss", "o", "session", "uns", "d", "ssl", "self", "su", "sf", "ns", "ls", "sg", "js"], "dev": ["dc", "dm", "req", "def", "p", "cd", "info", "f", "app", "device", "user", "nt", "sk", "del", "diff", "data", "pad", "conf", "grad", "dem", "spec", "rad", "desc", "iv", "debug", "ev", "priv", "db", "name", "ds", "md", "driver", "cmd", "dh", "prov", "pro", "mod", "serial", "private", "dep", "sd", "ad", "dn", "dom", "home", "w", "ve", "h", "host", "die", "mode", "prom", "gu", "der", "v", "dat", "hw", "ch", "sh", "dist", "dd", "server", "pub", "cam", "g", "node", "Dev", "di", "den", "adv", "ver", "conn", "d", "wd", "od", "de"], "udev": ["ufef", "udef", "uiddev", "ubev", "ddv", "ddef", "udek", "ufiver", "ubov", "uidec", "udem", "vdev", "ddec", "ubek", "odef", "ddexp", "ufev", "odev", "uidem", "udec", "uidef", "udect", "udov", "udexp", "vdek", "udiv", "ddect", "odv", "oddev", "ufdev", "ubect", "odov", "hdiver", "ubexp", "ddev", "vdem", "ddov", "ufect", "hdef", "udiver", "hddev", "uidiver", "ubiv", "ubec", "ubef", "odexp", "ddiv", "uidev", "vdef", "ubem", "ubdev", "uidek", "ubiver", "dddev", "udv", "ufiv", "ddiver", "hdev", "uddev", "ubv"], "rc": ["dc", "RC", "req", " RC", "rs", "xc", "src", "hl", "lc", "irm", "sync", "cc", "co", "ac", "rt", "loc", "roc", "fail", "proc", "pg", "config", "cur", "uc", "pc", "rx", "ack", "rh", "irc", "sc", "oc", "cr", "anc", "fc", "ct", "rb", "ry", " src", "sth", "back", "ck", "cb", "err", "error", "rr", "conn", "sr", "result", "auc", "rd", "rn", "bc", "vc", "ci", "cmp", "nc", "ko", "rl", "inc", "rec", "rg", "ann"]}}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924, "substitutes": {"new_size": ["new_SIZE", "new_year", "newPyear", "newlexcapacity", "NEW_cache", " new_year", " new_weight", "new_name", "newPweight", "finallexset", "newlexset", "newPsize", " new_time", "new_time", "new_loc", "final_capacity", "final_set", "new6content", "newlset", "final_size", "old_content", "final_bytes", "newlsize", " new_capacity", "newaccache", "new_capacity", "newlexbytes", "old_cache", "new_weight", " new_SIZE", "new67cache", "NEWacsize", "new_number", "new6size", "newlbytes", "NEW_length", "NEW_size", "finallexbytes", "new67size", "finallexcapacity", "finallexsize", "newlexsize", "newlcapacity", "NEWacnumber", "NEWaccache", "newacsize", "NEWaclength", "new_bytes", " new_name", "new6cache", "new_content", "new67capacity", "newacnumber", "old_size", "newaclength", " new_storage", "new_length", "NEW_number", " new_loc", "new_set", "new_storage", "new67name"], "errp": ["armp", "rrpc", "erpa", "rrpre", "errr", "erps", " errcp", "errc", "armr", "errpre", "nerp", "irps", "errfp", "irp", "rrp", "erpc", "yrp", "ercp", "yrpc", "errcp", "erc", "erfp", " errpre", "errorpc", " errfp", "errpc", "errorc", "err", "armpa", "irpc", "errorfp", "yrpre", "errps", "nerpc", "errorp", "errpa", "irr", " errc", "armcp", "nerr", " errpc", "nerps", " errr", "rrpa", " errpa", "erp", "yrpa"], "new_cache": ["newAcconn", "new67cache", "newAcsize", "new_clear", " new_buffer", "new_config", "new67conn", " new_score", "new__size", "new__cache", " new_clear", " new_conn", "new_table", "newAccache", "newAcscore", "new67size", "new_buffer", " new_table", "new_conn", "new_score", " new_config", "new67score", "new__table"], "ret": ["part", "req", "match", "def", "res", "fit", "rets", "lit", "mem", "code", "num", "cat", "bit", "val", "rt", " Ret", "ft", "det", "info", "pat", "mt", "ut", "RET", "len", "gt", "feat", "fun", "reg", "sat", "nt", "result", "format", "pre", "final", "ref", "out", "wrap", "hard", "reply", "re", "flag", "data", "obj", "ig", "alt", "arg", "fin", "success", "Ret", "let", "ext"]}}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933, "substitutes": {"sig": ["dsigma", "gsigs", "pess", "fig", "dsigs", "figs", "pigh", "asigs", "ssigs", " sigma", "sigma", "ssigned", " sess", " sigs", "asess", "sess", "figma", "sigs", "asigma", "dsigned", "pigma", "gsigh", "ssigma", "pigs", "sigh", " sIG", "gsig", "asig", "dsig", "gsigma", "pIG", "fIG", "ssig", "sIG", " sigh", "pig"], "ka": ["ha", "kt", "ker", "LA", "KA", "ea", "ra", "kee", "sa", "jam", "ta", "ma", "ai", "ja", "na", "ku", "wa", "sc", "ba", "ae", "ki", "a", "oda", "ga", "aka", "ia", "ke", "ca", "da", "ket", "kb", "ya", "va", "sta", "kernel", "ema", "auc", "fi", "qa", "bc", "cca", "ctx", "k", "oa", "ua", "ci", "la", "qua", "ko", "java", "ama"], "info": ["ti", "ii", "ui", "abi", "image", "def", "interface", "INFO", "setup", "inf", "area", "code", "name", "loc", "f", "config", "stat", "ini", "ie", "family", "start", "si", "init", "index", "information", "error", "Info", "ind", "alias", "meta", "source", "fo", "fi", "summary", "inter", "raf", "isu", "api", "attr", "data", "hi", "ctx", "id", "mi", "ci", "conf", " fi", "util", "context", "spec"], "set": ["settings", "ace", "update", "create", "ise", "ner", "match", "sync", "setup", "parse", "reset", "en", "site", "vert", "code", "use", "ex", "kit", "offset", "se", "load", "status", "config", "stat", "net", "start", "setting", "ut", "init", "sc", "see", "Set", "sche", "state", "c", "err", "send", "base", "ind", "export", "e", "SET", "sel", "end", "post", "check", "et", "gen", "ne", "ctx", "sign", "push", "server", "open", "add", "act", "context", "spec", "new", "get"], "env": ["cfg", "stage", "ev", "cache", "stack", "eni", "en", "enc", "ea", "vert", "que", "db", "ef", "config", "dict", "net", "ini", "ep", "init", "v", "exc", "dir", "state", "dev", "e", "osc", "conn", "end", "eq", "et", "ne", "viron", "np", "obj", "scope", "environment", "ctx", "eu", "conf", "server", "nc", "context", "exec", "qt", "ec", "me", "ext"], "frame_addr": ["fram_addr", "fram_offset", "frame__offset", " frame_ord", "frame_offset", "frame_address", "frame_ord", "frame_nr", " frame_nr", "frame__addr", "fram_address", " frame_layer", "frame_layer", " frame_address", "fram_ord", "frame__nr", " frame_offset", "frame__address"], "r26": ["r6", "p26", " r27", "r27", "R26", " r16", " r6", "p27", "p6", "R6", "R16", "p16", "r16", "R27"], "frame": ["line", "interface", "def", "figure", "processor", "f", "sche", "game", "seq", "feat", "base", "range", "cycle", "module", "window", "ze", "function", "fo", "role", "face", "fb", "component", "condition", "part", "stage", "setup", "version", "jp", "event", "section", "call", "ce", "config", "sample", "fr", "framework", "e", "flow", "point", "model", "target", "environment", "fake", "slice", "ko", "cfg", "update", "element", "parse", "fe", "die", "plane", "force", "word", "za", "state", "thread", "build", "style", "Frame", "draw", "fi", "profile", "scope", "invoke", "file", "fram", "node", "flower", "raise", "cf", "image", "iframe", "block", "code", "object", "body", "lock", "motion", "position", "tick", "sequence", "play", "message", "session", "boot", "show", "layer", "shot", "frames", "txt", "fire", "feature", "context", "coe", "plate"], "i": ["ti", "ui", "ii", "ji", "part", "qi", "x", "I", "ix", "p", "eni", "phi", "code", "di", "ri", "j", "cli", "ai", "ie", "ini", "ni", "oi", "is", "si", "io", "b", "v", "a", "pi", "uri", "index", "n", "c", "uli", "err", "o", "e", "ind", "y", "l", "adi", "xi", "u", "yi", "fi", "d", "li", "iu", "mini", "api", "hi", "id", "zi", "m", "multi", "ci", "t", "slice", "gi", "z", "mu", "bi", "ip"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938, "substitutes": {"dev": ["dm", "req", "home", "debug", "def", "ev", "w", "Dev", "test", "priv", "di", "mode", "app", "prom", "ro", "devices", "device", "temp", "pro", "mod", "reg", "prof", "ver", "serial", "conn", "hw", "dd", "tr", "data", "conf", "grad", "dem", "cam", "dom", "de", "rad", "serv"], "s": ["ins", "p", "us", "se", "f", "si", "a", "sb", "cs", "u", "tests", "gs", "i", "conf", "same", "plugins", "bs", "vs", "your", "spec", "sv", "ses", "ds", "xs", "is", "b", "ts", "n", "hs", "ps", "e", "y", "args", "services", "ans", "comments", "os", "params", "states", "S", "ks", "w", "sym", "ats", "site", "its", "c", "l", "service", "qs", "es", "m", "sys", "t", "sl", "g", "has", "new", "settings", "sets", "sq", "x", "rs", "sync", "as", "fs", "ss", "o", "session", "uns", "d", "ssl", "su", "ns", "ls", "sg", "ms", "js"]}}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}", "idx": 23942, "substitutes": {"t": ["T", "time", "tt", "p", "h", "test", "tm", "dt", "type", "ta", "f", "b", "ts", "timer", "v", "n", "c", "o", "table", "e", "pt", "y", "r", "l", "tmp", "u", "tp", "d", "tc", "i", "m", "tty", "g", "this", "it"], "ev": ["ace", "iv", "ek", "inst", "ve", "eval", "event", "enc", "ait", "tv", " dev", "ex", "el", "rt", "ce", "rev", "ef", "app", "ere", "actor", "ect", "eg", "ep", "ov", "im", " inst", "eed", "bug", "v", "lex", "vr", "temp", "err", "dev", " event", "e", "ew", "ract", "env", "ind", "ch", "hw", "erv", "ee", "echo", "tr", "lv", "vc", "ell", "ant", "em", "exec", "Ev", "eb", "vent", "ec", "serv"], "host_timer": ["hard_monitor", "hostingtimer", "hostingtime", "hard_tim", "host_time", "hostingtim", " host_tim", "host_walker", "hard_timer", "hard_walker", "hostworktime", " host_time", "hostworktim", "hostingwalker", "hostworktimer", "host_tim", "host_monitor", "hostworkmonitor", "hard_time"], "act": ["acts", "ace", "att", "catch", "ain", " ACT", " acts", "ec", "ask", "cv", "ait", "call", "activate", "ac", "ex", "val", "actor", "ect", "art", "ack", "rx", "pass", "mit", "init", "agent", "ct", "lex", "amp", "acs", "parent", "feat", "fact", "cas", "err", "action", "eff", "nat", "active", "fac", "actions", "ass", "op", "ff", "fi", "obj", "ctx", "sign", "ACT", "form", "ant", "activ", "Act", " Act", "set", "effect"]}}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23947, "substitutes": {"cc": ["mc", "cf", "cy", "sq", "cl", "xc", "cv", "cu", "lc", "CCC", "cd", "cci", "co", "ac", "loc", "ce", "cus", "coll", "uc", "che", "cmd", "sc", "content", "ct", "hh", "fc", "seq", "c", "ck", "ca", "cs", "acc", "ucc", "ff", "cp", "rc", "tc", "lv", "cca", "CC", "kk", "cpp", "vc", "ctx", "cmp", "cn", "ec", "icc"], "pec": ["cfg", "cf", "clus", "cl", "pe", "cit", "cv", "hl", "lc", "uci", "cci", "pic", "qv", "loc", "cli", "pm", "config", "ocr", "pc", "che", "cmd", "mp", "erc", "fc", "priority", "scl", "seq", "pect", "pes", "cs", "ped", "xp", "fp", "cm", "plugin", "fi", "rc", "lv", "phy", "ctx", "cki", "closure", "cpp", "ci", "concept", "pkg", "username", "cmp", "cel", "csv", "context", "spec", "ec", "icc"], "fh": [" fch", "fhost", "lff", "fdH", "vhost", "fhm", "fH", "fdh", "lfh", "afph", "afhm", "fph", "lfhs", "rfch", "vbh", "fbh", " ff", "fdhm", "vhm", "fhs", "lfbh", " fbh", "rfhs", "afh", "vf", "lfch", "vph", "ff", "afH", "vh", "vH", "rfhost", "fch", "fdph", " fhs", "lfhost", "rfh", " fhost"], "fid": ["xmid", "caddr", "fID", "pid", "fide", "cfip", "rfid", "xid", "fip", "fids", "cfmid", "hstart", "cfID", "hide", "cfid", "cids", "cide", "cfids", "cip", "hids", "hid", "fstart", "rfstart", "cid", "pids", " fids", " fmid", "cstart", "fmid", "pip", " fID", "cfaddr", "rfids", "paddr", "xID", "xids", "rfide"], "faddr": ["caddr", "fhost", "vaddress", "vhost", "dhost", " fwd", "daddr", "hhost", "daddress", "did", "haddress", "caddress", "cfid", "hid", "cid", "fwd", "laddr", "cfhost", "vaddr", "lhost", "cwd", "cfaddress", "vid", "lwd", "haddr", "lid", "cfaddr", "chost", "faddress", " fhost"], "e": ["ace", "element", "pe", "oe", "eve", "p", "fe", "en", "ea", "se", "ed", "eeee", "complete", "je", "le", "f", "ef", "ie", "E", "v", "ae", "ei", "n", "c", "o", "error", "y", "r", "l", "entity", "ze", "u", "ee", "end", "be", "es", "d", "ffe", "ne", "est", "eu", "i", "m", "er", "edge", "g", "ec", "me"], "sei_cont": ["sei_sequ", "sei\u30f3ci", "fee_cod", "sei\u30f3nav", "fee_ci", "isi_const", "sei_cod", "sei_nav", "tsy_desc", "sei\u30f3cur", "tsy_cont", "isi_content", "sei\u30f3container", "isi_cms", "yi_core", "isi_cont", "sei_dest", "sei_core", "sei\u30f3component", "eni_cont", "sei_ont", "cies_Cont", "sei\u30f3cont", "ci_const", "sei_CONT", "sei_ci", "sei\u30f3control", "sei_container", "sei_cot", "sei__component", "sei_ct", "sei_const", "eni__ctr", "fee\u30f3control", "sei\u30f3content", "sei\u30f3sequ", "eni__cont", "ci_cont", "fee_control", "yi_cur", "eni_ctr", "eni_ont", "sei__cont", "eni_component", "yi_container", "ci_dest", "sei\u30f3ctr", "sei_component", "eni__component", "sei_content", "sei_desc", "sei_cms", "sei\u30f3ont", "sei_lc", "eni_sequ", "sei\u30f3cod", "yi_cont", "cies_cot", "sei_Cont", "fee\u30f3ci", "sei\u30f3core", "fee\u30f3cont", "sei_control", "eni__nav", "tsy_lc", "sei_cur", "sei_ctr", "ci_ct", "sei__ctr", "cies_sequ", "tsy_CONT", "sei__nav", "fee_cont", "cies_cont", "fee\u30f3cod", "eni_nav", "eni_content"], "s": ["settings", "states", "sets", "S", "rs", "secondary", "src", "p", "sym", "h", "site", "sync", "ds", "ses", "f", "stat", "is", "ss", "b", "v", "n", "c", "o", "sb", "r", "l", "service", "session", "u", "services", "d", "ssl", "i", "m", "sys", "t", "socket", "sl", "ls", "sg", "ns", "js"]}}
{"project": "qemu", "commit_id": "81907a582901671c15be36a63b5063f88f3487e2", "target": 1, "func": "void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,\n\n                CPSRWriteType write_type)\n\n{\n\n    uint32_t changed_daif;\n\n\n\n    if (mask & CPSR_NZCV) {\n\n        env->ZF = (~val) & CPSR_Z;\n\n        env->NF = val;\n\n        env->CF = (val >> 29) & 1;\n\n        env->VF = (val << 3) & 0x80000000;\n\n    }\n\n    if (mask & CPSR_Q)\n\n        env->QF = ((val & CPSR_Q) != 0);\n\n    if (mask & CPSR_T)\n\n        env->thumb = ((val & CPSR_T) != 0);\n\n    if (mask & CPSR_IT_0_1) {\n\n        env->condexec_bits &= ~3;\n\n        env->condexec_bits |= (val >> 25) & 3;\n\n    }\n\n    if (mask & CPSR_IT_2_7) {\n\n        env->condexec_bits &= 3;\n\n        env->condexec_bits |= (val >> 8) & 0xfc;\n\n    }\n\n    if (mask & CPSR_GE) {\n\n        env->GE = (val >> 16) & 0xf;\n\n    }\n\n\n\n    /* In a V7 implementation that includes the security extensions but does\n\n     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control\n\n     * whether non-secure software is allowed to change the CPSR_F and CPSR_A\n\n     * bits respectively.\n\n     *\n\n     * In a V8 implementation, it is permitted for privileged software to\n\n     * change the CPSR A/F bits regardless of the SCR.AW/FW bits.\n\n     */\n\n    if (write_type != CPSRWriteRaw && !arm_feature(env, ARM_FEATURE_V8) &&\n\n        arm_feature(env, ARM_FEATURE_EL3) &&\n\n        !arm_feature(env, ARM_FEATURE_EL2) &&\n\n        !arm_is_secure(env)) {\n\n\n\n        changed_daif = (env->daif ^ val) & mask;\n\n\n\n        if (changed_daif & CPSR_A) {\n\n            /* Check to see if we are allowed to change the masking of async\n\n             * abort exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_AW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_A flag from \"\n\n                              \"non-secure world with SCR.AW bit clear\\n\");\n\n                mask &= ~CPSR_A;\n\n            }\n\n        }\n\n\n\n        if (changed_daif & CPSR_F) {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n", "idx": 23956, "substitutes": {"env": ["inet", "cv", "cache", "app", "chal", "eng", "equ", "dev", "enable", "emb", "oa", "org", "conf", "vs", "ec", "ext", "global", "iv", "stage", "doc", "ev", "iss", "empty", "event", "en", "ea", "forge", "core", "img", "her", "db", "shell", "config", "uv", "ench", "header", "entry", "e", "args", "kernel", "manager", "cookie", "end", "viron", "np", "Environment", "environment", "eu", "gr", "console", "h", "enc", "site", "local", "el", "dict", "net", "enh", "vm", "init", "v", "c", "err", "dat", "export", "style", "token", "ass", "ne", "scope", "ctx", "vel", "server", "edge", "energy", "qt", "hl", "que", "code", "ah", "exc", "fen", "engine", "conn", "password", "session", "erv", "operator", "obj", "txt", "nc", "context", "loader", "skin"], "val": ["VAL", "cache", "p", "lit", "pal", "elt", "valid", "rot", "base", "min", "vi", "ref", "py", "key", "sk", "pre", "vals", "pos", "data", "count", "lib", "addr", "all", "item", "doc", "al", "bit", "loc", "db", "ret", "config", "b", "len", "index", "ind", "sel", "rule", "pl", "arg", "alt", "serv", "il", "eval", "mem", "vert", "local", "el", "stat", "aval", "win", "v", "lex", "pt", "byte", "cal", "value", "fi", "li", "vel", "unit", "ctx", "sl", "x", "pret", "code", "bl", "ut", "bin", "vol", "reg", "slot", "ee", "oval", "Val", "util", "exec", "ol"], "mask": ["delay", "shape", "cover", "match", "flags", "cache", "ask", "scan", "label", "iq", "pin", "black", "carry", "depth", "bit", "offset", "broad", "pack", "config", "magic", "pattern", "ack", "gap", "miss", "effect", "lock", "secret", "hide", "bug", "pass", "filter", "pixel", "header", "scale", "parent", "ck", "shadow", "sum", "alias", "patch", "Mask", "batch", "kernel", "clean", "fix", "key", "sk", "ban", "qa", "weight", "flag", "strip", "hash", "hack", "count", "sign", "shift", "pad", "conf", "allow", "skip", "map", "feature", "tag", "mark", "comment"], "write_type": ["callinglevel", "write___name", "callingbase", "write___base", " write_style", "writeingname", "writeinglevel", "call_level", "writerobject", " write_types", "callingname", "writertypes", "write_types", "writeingbase", "write_name", "writertype", "write_level", "call_name", "write_style", "callingtype", " write_object", "write___type", "write_base", "write___level", "write_object", "writerstyle", "call_type", "call_base", "writeingtype"], "changed_daif": ["changed_daig", "changed_eaif", "changed_deenilib", "changed_daIF", "changed_deenip", "changed_waife", "changed_waip", "changed_naif", "changed_daiv", "changed_eaIF", "changed_waIF", "changed_maIF", "changed_daife", "changed_daip", "changed_waiv", "changed_maif", "changed_taifer", "changed_eaip", "changed_naiff", "changed_deenIF", "changed_taiff", "changed_mailib", "changed_deenif", "changed_eailib", "changed_maiff", "changed_taig", "changed_shaip", "changed_daiff", "changed_naifer", "changed_waig", "changed_taIF", "changed_maip", "changed_daifer", "changed_shaif", "changed_naiv", "changed_dailib", "changed_waif", "changed_shaiv", "changed_naig", "changed_taif", "changed_taip", "changed_naIF", "changed_naife", "changed_shaife", "changed_naip", "changed_maifer"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 23965, "substitutes": {"vdev": ["wdevice", " vconn", "cdevice", "vserv", "ldev", "gdef", "lerror", "nvdev", "voff", "gdc", "hdiv", " vgu", "vmem", "vdiv", "pdev", "lver", "hoff", "vdef", "grad", " vmem", "mgu", "ldata", "nvdc", "vrad", "mflow", "svdevice", "verror", "gver", "mdev", "cdev", "pdevice", "wver", "vconf", "lserv", "lrad", "pconf", " vdata", "svdiv", "wdiv", "Vdev", "gproject", "hdev", "vdc", "gconn", "vver", "vgu", "gdev", "herror", "svproject", " vconf", "gconf", "mdevice", "pver", "Vflow", "nvdiv", "mdef", "ldef", "pconn", "gserv", "mconn", " vdiv", "Vconn", "nvproject", "vdata", "coff", "gdiv", "Vgu", "hdevice", " vdevice", "pde", "lde", "vproject", " verror", " vdef", "ldevice", "vflow", "gde", "lmem", "wdev", "pdiv", "ldc", "vde", "pdata", " vflow", "svdev", "nvserv", " vver", "hdef", "nvdevice", "vdevice", "svde", "moff", "svrad", "pmem", "svserv", "cdef", "gdevice", "vconn"], "nr": ["nic", "adr", "ii", "nor", "br", "ner", "gr", "iter", "mr", "rin", "nm", "src", "rue", "eni", "our", "NR", "iq", "num", "nn", "name", "nob", "counter", "ni", "nb", "sr", "rx", "none", "fr", "yr", "wr", "uj", "n", "seq", "next", "ar", "err", "range", "nl", "rr", "r", "nir", "ng", "nt", "nin", " NR", "chain", "nw", "radius", "manager", "usr", "or", "outer", "inter", "rn", "tr", "np", "nar", "attr", "rf", "nov", "rw", "number", "lr", "nc", "nu", "no", "rg", "rb", "inner", "sn", "rec"], "quirk": ["querirk", "confird", "QUirrel", "quirt", "confirk", "qirt", "sqark", "squlict", "shird", "aquark", "QUlict", "iquird", "equirk", " quirrel", "iquirus", "querik", "acquirk", "sqork", "acquirt", "promirk", " quird", " quavour", "acquoise", "shirt", "qirk", "quavour", "sqash", "qulict", "affik", "iquirt", "equir", "iquirk", "aquirrel", "QUark", "quirus", " quner", "promack", "queir", "confirus", "quirrel", "acquavour", "iquir", "promik", "aquirk", "coirk", "iquark", " quark", "equark", "sqirk", " quork", "acquik", "shirk", "querirt", "acquark", "QUirk", "qark", " qulict", "shack", "coirt", "qack", "squark", "equash", "acquner", "coik", "requirk", "affirk", "requird", " quoise", "confirt", "promark", "requark", "aquoise", "equlict", "quash", "quack", "queark", "aquavour", "affirt", "affird", "equirt", "requirt", " quirus", "querark", "queirk", "quelict", "qird", "requik", "squirt", "aquner", "aquirt", "quird", "QUirt", "squirk", "quik", "iqulict", " quirt", "qik", "quner", " quash", "quark", "equork", "equik", "quir", "quork", "acquird", "quoise", "coird", "promird", "promirt"], "mirror": ["marra", "varrage", "perace", "matner", "irra", "marrect", "mirmbol", " mirrorror", " mirron", "varrog", "irior", "mirbug", "murrage", "earra", "merrect", "marmbol", "horrect", "matrect", "murmbol", "perrr", "irrup", "earrect", "varrored", "prrect", "pirrored", "mirrc", "irrr", "varrr", "earner", "irner", " mirrorceptor", "marrage", "mirra", "verior", " mirrc", "mirrup", " mirrormbol", "varra", "verror", " mirrorrect", "marrup", "irrored", "silverror", "prmbol", "perrored", "varner", "merrr", " mirceptor", " mirrorception", "mirrog", "pirror", "varbug", "hyperrect", "matrr", "varmbol", "merror", " mirrage", "merior", "pirrage", "varrup", "ironception", "perri", "pirra", "marror", "irbug", "verrog", "mirray", "jerrored", "ironmbol", " mirner", "hyperror", "mirior", "horror", " mirrr", "mirrect", "horner", " mirra", " mirrect", "merray", "murror", "mirder", "mirri", "verceptor", "hypermbol", " mirmbol", "perra", "permbol", "earmbol", "perrc", "matmbol", "marray", "marbug", "prror", " mirrup", "varior", "ironrect", "matception", "murner", "irace", " mirrored", "perner", "silverceptor", "perron", "irceptor", "mirrage", "ironror", "marrr", " mirrorior", "varceptor", "mirner", "mirrored", "silverrr", "merner", " mirri", "varror", "silverner", "irri", "jerrc", " mirrorrog", "irrect", "horrr", " mirior", " mirace", "mirron", "irmbol", "hyperder", "mirrr", "irron", "mirception", "mirceptor", "marner", "irray", "irror", "earror", "marrored", "jermbol", "mirace", "matror", "earder", "jerror", "prder"]}}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009, "substitutes": {"ctx": ["mc", "cfg", "cf", "cl", "gc", "cv", "xc", "src", "cc", "loc", "cli", "proc", "config", "gpu", "func", "Context", "anc", "cmd", "sc", "c", "utils", " cx", "cb", "ca", "cas", "cs", "tx", "conn", "kb", "conv", "wcs", "bc", "cp", "rc", "tc", "obj", "vc", "cpp", "pkg", "cmp", "ctrl", "context", "cam", "exec", "comp"], "arg0": ["param4", " arg8", "param8", "param1", "Arg0", "arg4", "argument0", "param0", "Arg1", " arg4", "argument1", "argument2", "argument8", "Arg4", "arg8", "param2"], "arg1": [" arg3", "Arg01", "Arg3", "args0", "ark0", "ark01", "args3", "args2", "argument01", "argument0", "Arg1", "argument1", "argument2", "argument3", " arg01", "arg3", "arg01", "args1", "ark1", "Arg2", "args01", "ark2"], "arg2": ["args02", "param4", " arg02", "arg02", "args2", "ag1", "param1", "Arg5", "arg4", "arg5", "Arg1", "ag2", " arg4", "ag4", "Arg4", " arg5", "args1", "Arg2", "ag02", "param5", "param2", "args4"], "sub": ["desc", "neg", "sq", "south", "Sub", "loc", "dim", "sc", "second", "rel", "asm", "con", "ub", "control", "reg", "sum", "submit", "leaf", "super", "sel", "sup", "small", "bc", "split", "member", "rob", "child", "diff", "comb", "job", "mid", "sing", "lib", "pub", "trans", "sec", "rec"]}}
{"project": "FFmpeg", "commit_id": "cd19c677cb5dcaecc472c021bd38370817740a5e", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, \n\n                             void *data, int *data_size,\n\n                             uint8_t *buf, int buf_size)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    MpegEncContext *s = &h->s;\n\n    AVFrame *pict = data; \n\n    int buf_index;\n\n    \n\n    s->flags= avctx->flags;\n\n    s->flags2= avctx->flags2;\n\n\n\n   /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_TRUNCATED){\n\n        int next= find_frame_end(h, buf, buf_size);\n\n        \n\n        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )\n\n            return buf_size;\n\n//printf(\"next:%d buf_size:%d last_index:%d\\n\", next, buf_size, s->parse_context.last_index);\n\n    }\n\n\n\n    if(h->is_avc && !h->got_avcC) {\n\n        int i, cnt, nalsize;\n\n        unsigned char *p = avctx->extradata;\n\n        if(avctx->extradata_size < 7) {\n\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n\n            return -1;\n\n        }\n\n        if(*p != 1) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown avcC version %d\\n\", *p);\n\n            return -1;\n\n        }\n\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n\n           so put a fake nal_length_size = 2 while parsing them */\n\n        h->nal_length_size = 2;\n\n        // Decode sps from avcC\n\n        cnt = *(p+5) & 0x1f; // Number of sps\n\n        p += 6;\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding sps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Decode pps from avcC\n\n        cnt = *(p++); // Number of pps\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize)  != nalsize) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding pps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Now store right nal length size, that will be use to parse all other nals\n\n        h->nal_length_size = ((*(((char*)(avctx->extradata))+4))&0x03)+1;\n\n        // Do not reparse avcC\n\n        h->got_avcC = 1;\n\n    }\n\n\n\n    if(!h->is_avc && s->avctx->extradata_size && s->picture_number==0){\n\n        if(decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0) \n\n            return -1;\n\n    }\n\n\n\n    buf_index=decode_nal_units(h, buf, buf_size);\n\n    if(buf_index < 0) \n\n        return -1;\n\n\n\n    //FIXME do something with unavailable reference frames    \n\n \n\n//    if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_index, buf_size);\n\n    if(!s->current_picture_ptr){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"error, NO frame\\n\");\n\n        return -1;\n\n    }\n\n\n\n    {\n\n        Picture *out = s->current_picture_ptr;\n\n#if 0 //decode order\n\n        *data_size = sizeof(AVFrame);\n\n#else\n\n        /* Sort B-frames into display order */\n\n        Picture *cur = s->current_picture_ptr;\n\n        Picture *prev = h->delayed_output_pic;\n\n        int out_idx = 0;\n\n        int pics = 0;\n\n        int out_of_order;\n\n        int cross_idr = 0;\n\n        int dropped_frame = 0;\n\n        int i;\n\n\n\n        if(h->sps.bitstream_restriction_flag\n\n           && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n            s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n            s->low_delay = 0;\n\n        }\n\n\n\n        while(h->delayed_pic[pics]) pics++;\n\n        h->delayed_pic[pics++] = cur;\n\n        if(cur->reference == 0)\n\n            cur->reference = 1;\n\n\n\n        for(i=0; h->delayed_pic[i]; i++)\n\n            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)\n\n                cross_idr = 1;\n\n\n\n        out = h->delayed_pic[0];\n\n        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)\n\n            if(h->delayed_pic[i]->poc < out->poc){\n\n                out = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        out_of_order = !cross_idr && prev && out->poc < prev->poc;\n\n        if(prev && pics <= s->avctx->has_b_frames)\n\n            out = prev;\n\n        else if((out_of_order && pics-1 == s->avctx->has_b_frames)\n\n           || (s->low_delay && \n\n            ((!cross_idr && prev && out->poc > prev->poc + 2)\n\n             || cur->pict_type == B_TYPE)))\n\n        {\n\n            s->low_delay = 0;\n\n            s->avctx->has_b_frames++;\n\n            out = prev;\n\n        }\n\n        else if(out_of_order)\n\n            out = prev;\n\n\n\n        if(out_of_order || pics > s->avctx->has_b_frames){\n\n            dropped_frame = (out != h->delayed_pic[out_idx]);\n\n            for(i=out_idx; h->delayed_pic[i]; i++)\n\n                h->delayed_pic[i] = h->delayed_pic[i+1];\n\n        }\n\n\n\n        if(prev == out && !dropped_frame)\n\n            *data_size = 0;\n\n        else\n\n            *data_size = sizeof(AVFrame);\n\n        if(prev && prev != out && prev->reference == 1)\n\n            prev->reference = 0;\n\n        h->delayed_output_pic = out;\n\n#endif\n\n\n\n        *pict= *(AVFrame*)out;\n\n    }\n\n\n\n    assert(pict->data[0]);\n\n    ff_print_debug_info(s, pict);\n\n//printf(\"out %d\\n\", (int)pict->data[0]);\n\n#if 0 //?\n\n\n\n    /* Return the Picture timestamp as the frame number */\n\n    /* we substract 1 because it is added on utils.c    */\n\n    avctx->frame_number = s->picture_number - 1;\n\n#endif\n\n    return get_consumed_bytes(s, buf_index, buf_size);\n\n}\n", "idx": 24018, "substitutes": {"avctx": ["aveca", "ajlinux", " avcit", "avescope", "aircp", "aircci", "AVconfig", "aucam", "airctx", "aucontext", "avlc", "awcontext", "avectx", " avcf", "avctl", "AVcontext", "navcam", "afloc", "navlinux", "awctl", "afconfig", "auctl", "avsync", "avesync", "afcci", "avecu", "navctx", "awcit", "AVc", "afctl", "afca", "avcontext", "aveloc", "ajscope", "navctl", "ajcontext", "aircontext", "avelc", "afcam", "avca", "aflc", "afcit", "awctx", "afcontext", "ajctx", "AVsync", " avscope", "afscope", "avconfig", "navscope", "avloc", "afxc", "AVca", "avlinux", "AVcu", "avecontext", " avctl", "avcu", "AVloc", "aveconfig", " avxc", "avxc", "avcam", "afcf", "afcp", "AVlc", "aflinux", "avecci", "avcp", "auctx", "avecp", "navcontext", "avecf", "afcu", "AVctx", "avcci", "afc", "avc", "avcit", " avcontext", "avec", "afctx", "avcf", "afsync", "avexc", "avscope"], "data": ["image", "DATA", "block", "img", "buffer", "val", "frame", "buff", "f", "response", "sample", "fr", "start", "body", "b", "media", "a", "raw", "next", "base", "da", "o", "dat", "result", "window", "value", "size", "d", "video", "rc", "input", "memory", "reader", "m", "Data", "record"], "data_size": ["dataallSIZE", "dataallsized", "dataallsize", " data_sized", "data_channel", " data_channel", "dataallchannel", "data_sized", "data_SIZE", " data_SIZE"], "buf": ["cf", "br", "wb", "cv", "uf", "src", "queue", "block", "img", "buff", "buffer", "frame", "config", "func", "uc", "cmd", "b", "border", "v", "seq", "next", "header", "feat", "cb", "cas", "vec", "flow", "fd", "batch", "fp", "window", "result", "ref", "pb", "ff", "fi", "bag", "bc", "foo", "conv", "rc", "ctx", "fb", "array", "context", "rb"], "buf_size": ["buffer_len", "buf2unit", "buffer_index", "buf2length", "buf2size", "buf2name", "bufdscale", "uf2unit", "uf_size", " buf_len", "bufdlen", "buffer_count", "buf_len", "bufdunit", "data_unit", "buffer_name", "uf2size", "bufxcount", "bufssize", "bufslen", "buf64len", "bufpunit", "uf_length", "buf2index", "bufxsize", "buf_count", "bufnlen", "data_scale", "buf2send", "uf_send", "buf64size", "uf_unit", "buffer_scale", "uf2length", "buf_scale", "buf_name", "data_len", "buf2len", "bufxscale", "bufnindex", "bufpsend", "bufxindex", "bufslength", "buffer_size", "bufdsize", "bufnsize", "buf64length", "bufplength", "buf_unit", "buf_length", "bufnname", " buf_length", "buf_send", "uf2send", "bufpsize"], "h": ["ha", "home", "z", "ul", "hd", "w", "ht", "hl", "host", "gh", "http", "buff", "ih", "j", "f", "zh", "q", "rh", "he", "b", "v", "ah", "hh", "bh", "oh", "header", "c", "hs", "o", "H", "e", "r", "l", "hr", "hw", "ch", "ph", "hhh", "u", "sh", "history", "d", "uh", "hm", "hi", "ctx", "self", "m", "t", "this", "context", "g", "eh", "han", "hp", "ec"], "s": ["support", "settings", "S", "sq", "w", "secondary", "setup", "rs", "ls", "aws", "sym", "sync", "sa", "sg", "http", "ds", "ses", "f", "sec", "fs", "ssh", "b", "sc", "ss", "v", "si", "ts", "n", "c", "spec", "ps", "parser", "sb", "o", "storage", "hs", "e", "cs", "l", "service", "session", "sh", "qs", "sup", "d", "ops", "ssl", "share", "scope", "input", "shared", "ctx", "sp", "gs", "m", "su", "conf", "t", "sf", "client", "server", "slice", "sl", "g", "ns", "sv", "sports", "js"], "pict": ["af", "cv", "src", "img", "buffer", " f", "f", " b", "fr", "fs", " w", "raw", "F", "fw", "cb", "fl", " fa", "r", "fa", "fd", "ref", "fi", "rf", "rc", "fn", "fb", " r", "z", "rb", "fm"], "buf_index": ["cf_index", "cf_size", "buf_toc", "buf_offset", "cf_toc", "cf_offset"], "i": ["ti", "ii", "ui", "part", "ji", "qi", "x", "I", "ix", "eni", "phi", "code", "di", "ri", "j", "type", "f", "ai", "info", "ini", "ie", "ni", "oi", "io", "si", "b", "v", "pi", "n", "index", "uri", "c", "o", "ind", "e", "y", "l", "vi", "xi", "bi", "u", "yi", "chi", "fi", "li", "at", "d", "iu", "api", "count", "hi", "id", "mi", "ci", "zi", "multi", "slice", "ori", "gi", "g", "mu", "me", "it", "ip"], "cnt": ["ecNT", "ecct", " cne", "ecnt", "Cnd", "lcnc", "C0", " c0", "nant", "cne", "nnt", "CNT", "cNT", "ec0", "cant", "ucnc", "ecnc", "Cnc", "Cnt", "lcnt", "ucnt", "ucnn", "cnc", "Cct", "lcnn", "ecnd", " cnd", "ecant", " cant", "ucne", "cnn", " cNT", "nnc", "cct", " cnn", " cnc", "Cant", "nNT", " cct", "c0", "lcne", "cnd"], "nalsize": ["Nalescore", "Nalesization", "calssize", "notalsizer", "nalfsize", "nalsizer", "nallsite", "Nalscore", "NalesIZE", "nelssize", "nalscore", "nallsizer", "notalesized", "nasesite", "notaliz", "nallsize", "nallsiz", "nalfize", "nalesite", "nallyization", "nalesizer", "nassize", "nALScore", "nelsization", "nalsiz", "nalesize", " nasesizer", "nalssize", "nalsIZE", "Nalesizer", "nelsized", "nALSiz", "notalsize", "lalsiz", "nallyizer", "calsize", "lalsize", "nallssize", "lalesiz", "nasesize", "notalcore", "notalizer", "nitesiz", "nalsizes", "nitesize", "nassization", "lalesize", "nallsization", "nelsizes", "nalsized", "nallsIZE", "Nalsizer", "nallyize", "nallyiz", "lalessize", "lalsizer", "notalesizer", "nasesiz", "nALSizer", " nalsizer", "nalesiz", "nasesization", "nalesIZE", "nalfizer", "notalesiz", "nalsite", "callssize", "calsizes", " nasesite", "nassiz", "notalsiz", "nitesized", "notalize", "lalesizer", "nalesization", "nalesizes", "Nalesiz", "nasesizer", "nalessize", "notalesization", "callsize", "Nalesize", "nalfiz", "notalesize", "nelsize", "notalsIZE", " nasesize", "nitesization", "Nalsiz", " nalsite", "callsiz", " nalsiz", "nallsizes", "notalesIZE", "Nalsization", "notalsized", "callsizes", "nALSize", "lalssize", "NalsIZE", "nalescore", "nassIZE", "nalsization", "nalesized", " nasesiz", "Nalsize", "notalsization", "nallyIZE", "nelsiz", "calsiz"], "p": ["po", "part", "x", "pe", "pa", "jp", "pr", "pointer", "j", "f", "pm", "q", "pc", "pat", "b", "v", "up", "pp", "pi", "n", "per", "a", "c", "after", "ps", "lp", "o", "bp", "e", "pt", "y", "r", "P", "l", "press", "patch", "fp", "pn", "u", "pre", "pb", "py", "vp", "point", "post", "pl", "tp", "d", "at", "np", "api", "cp", "port", "sp", "m", "t", "ap", "dp", "g", "wp", "op", "ip"]}}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 24044, "substitutes": {"cpu": ["nic", "dc", "lb", " CPU", "chip", "cfg", "console", "gp", "CPU", "gc", "cache", "cu", "lc", "uci", "platform", "linux", "uca", "core", "css", "GPU", "clock", "processor", "process", "cli", "proc", "proxy", "ocr", "config", "gpu", "consumer", "roc", "pc", "uc", "computer", "vm", "fc", "mac", "c", "utils", "lp", "gru", "performance", "conn", "module", "hw", "fps", "auc", "boot", "ucc", "kernel", "np", "cp", "instance", "pu", "rc", "ctx", "unit", "cpp", "pkg", "cmp", "component", "program", "nc", "ilo", "px", "loader", "uu", "node", "cn", "comp"], "cc": ["mc", "dc", "cf", "cl", "gc", "cache", "lc", "LC", "cd", "css", "cci", "core", "ac", "pc", "uc", "anc", "sc", "fc", "con", " gcc", "ck", "ca", "PC", "cs", "acc", "ucc", "BC", "cm", "bc", "cp", " CC", "rc", "tc", "cca", "CC", "ctx", "vc", "ctrl", "cmp", "cn", "ec"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047, "substitutes": {"list": ["loop", "full", "listed", "collection", "stack", "List", "lists", "queue", "sync", "call", "code", "acl", "name", "complete", "low", "cli", "LIST", "config", "seq", "parent", "base", "sequence", "l", "batch", "result", "chain", "pre", "out", "li", "layer", "self", "top", "live", "la", "client", "this", "all"], "func": ["loop", "lambda", "ace", "expr", "cf", "interface", "stack", "cc", "val", "go", "complete", "proc", "f", "apply", "pc", "b", "up", "fc", "callback", "back", "next", "c", "adder", "cb", "fun", "handler", "r", "later", "prev", "function", "unc", "layer", "worker", "wrapper", "invoke", "fn", "nc", "exec", "op", " function"], "opaque": ["opsacle", "opsaque", "ipaque", "opsaques", "opacity", "ipacity", "opacle", "operaques", "opusacity", "oppha", "opsacity", "opsacs", "ipacle", "opacs", "operacle", " opacity", "opusacs", "ipaques", " oppha", "operacity", "operaque", " opacs", "opusaque", "opuspha", "opspha", "opaques"], "abort_on_failure": ["abort_on_failures", "abort_on_passion", "abort_on_structure", "abort_on_failedure", "abort_on_flowion", "abort_on_structash", "abort_on_structur", "abort_on_passured", "abort_on_fallash", "abort_on_failedured", "abort_on_flowure", "abort_on_flowURE", "abort_on_passures", "abort_on_fallur", "abort_on_failured", "abort_on_failedion", "abort_on_passURE", "abort_on_failURE", "abort_on_structures", "abort_on_failur", "abort_on_passur", "abort_on_failedURE", "abort_on_failion", "abort_on_failash", "abort_on_fallures", "abort_on_fallure", "abort_on_flowured", "abort_on_passure", "abort_on_passash"], "opts": ["opps", "operrs", " optcs", "opms", " opms", "hopts", "hopte", "opercs", "opte", "optms", "optps", " optts", " opters", "optrs", "opks", "optts", " opks", "hopters", "optte", "optters", "oprs", " opte", "apprs", " opcs", "opcs", "operps", "optks", " optters", "optcs", "appcs", "hopks", "opters", "appts", " optms", "operts", "appps"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n", "idx": 24050, "substitutes": {"opaque": ["ospatile", "opac", "ospaque", "OPaque", "ipaque", "ospacity", "ospaques", "OPatile", "opacity", "opatile", "ppatile", "ipacity", "ppaques", "ospac", "ppaque", "ipac", "ipaques", "OPaques", "OPacity", "OPac", "opaques"], "addr": ["adr", "ace", "x", "src", "eni", "eno", "access", "host", "area", "ea", "code", "pointer", "offset", "ord", "loc", "fx", "address", "proxy", "mode", "config", "au", "start", "ack", "rx", "mac", "align", "seq", "asm", "index", "amp", "ar", "adder", "base", "ady", "tta", "alias", "nr", "rr", "xp", "amd", "rd", "dist", "dd", "layer", "pos", "coord", "attr", "obj", "data", "ptr", "url", "afi", "eth", "id", "dr", "oa", "alt", "ad", "work", "pad", "grad", "la", "slice", "orig", "edge", "Address", "az", "node", "ld", "prefix", "ip"], "value": ["values", "write", "x", "version", "w", "block", "num", "offset", "name", "Value", "val", "complete", "address", "ret", "VALUE", "buffer", "length", "valid", "v", "content", "fee", "seq", "index", "buf", "padding", "store", "flow", "byte", "format", "key", "function", "end", "size", "data", "array", "number", "server", "set", "prefix"], "len": ["line", "lin", "lc", "en", "lit", "Len", "label", "num", "lf", "el", "val", "name", "ln", "rev", "offset", "length", "lan", "low", "valid", " val", "seq", "n", "fun", "base", "min", "l", " length", "fd", "format", "limit", "size", "ll", "li", "pos", "data", "count", "field", "alt", "la", "lim", "lib", "lon", "z", "bytes"], "mmio": ["temios", " mmino", " mmro", "magorg", "memios", "MMi", "pmIO", "cmro", "emio", "tmIO", "cmio", "mmro", "temino", " mmiol", "memio", "mmorg", "cmino", "pmno", "tmorg", " mmios", " mmi", "pmios", "magios", "emIO", "temro", "mmiol", " mmno", "mmIO", "MMios", "mmino", " mmIO", "emios", "mpi", "memno", "mpio", "mmno", "tmio", "temio", "mpios", "mpiol", "mmios", "mmi", "emorg", "magIO", "tmios", "cmios", "pmio", "magio", "MMio", "memIO", "MMiol"], "section": ["writer", "script", "part", "sections", " SECTION", "ECTION", "ion", "layout", "version", "vision", " structure", "sect", "lc", "area", "site", "core", "se", "pair", "region", "name", "Section", "loc", "option", "address", "proxy", "config", "definition", "description", "sec", "ie", " intersection", " setup", "protection", "sector", "sub", "parent", "shadow", "entry", " replacement", " Section", "service", "session", "connection", "function", "source", " subsection", " entry", "esc", "size", "establishment", " sector", "instance", "rc", "environment", " subscription", "closure", "array", "server", "slice", "component", " extension", "context", "division", " segment", "tag", "set", "comment", "behavior"]}}
{"project": "FFmpeg", "commit_id": "48e52e4edd12adbc36eee0eebe1b97ffe0255be3", "target": 0, "func": "static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 24072, "substitutes": {"avctx": ["awcv", "awconv", "Avconv", "AVconv", "aircomponent", "airctx", "awcontext", "avmac", "AVmac", "avcontext", "afcmd", "avconv", "AVctx", "airmac", "akctx", "akcontext", "Avmac", "AVcontext", "Avcmd", "Avctx", "akcas", "avcv", "Avcomponent", "aircontext", "akcmd", "avcomponent", "avcmd", "avcas", "AVcomponent", "afcas", "afctx", "AVcv", "Avcv", "Avcas", "awctx", "Avcontext", "afcontext"], "ctx": ["cv", "p", "lc", "cu", "anc", "kw", "ca", "cas", "python", "cs", "bc", "data", "pkg", "component", "wp", "support", "kt", "setup", "xc", "jp", "cc", "loc", "ce", "cli", "config", "pc", "Context", "cmd", "sc", "fw", "parent", "auc", "cm", "qa", "np", "prefix", "comp", "mc", "acl", "sci", "c", "aux", "fp", "hw", "connection", "conv", " context", "instance", "tc", "concept", "cca", "ci", "client", "cam", "cf", "sync", "cus", "coll", "ct", "mac", "fc", "ck", "cb", "tx", "conn", "kb", "wcs", "cp", "obj", "vc", "cmp", "ctrl", "nc", "context", "exec", "cn"], "dl_fn": ["dl_fd", "ll_function", "ll_fd", "dl_function", "dl1fd", "dlWconn", "dlpfn", "ll_func", "dlpfunc", "dl_module", "dl_ln", "DL_fn", "ll_fn", "DL_conn", "dlWmodule", "dl_conn", "dlWfn", "dl_func", "DL_ln", "dl1function", "DL_module", "dlWln", "dl1fn", "dlpfunction", "dl1func", "dlpfd"], "p_nvenc": ["p_nvenci", "p_nrencs", "p_navencs", "p_pvencs", "p_purencs", "p_nrenc", "p_nvinci", "p_pvenci", "p_navenec", "p_nurencs", "p_nvencc", "p_nvinf", "p_purenc", "p_cvenec", "p_pvenc", "p_cvencs", "p_nvinc", "p_navenf", "p_nvincs", "p_pvencc", "p_nurenc", "p_nrenf", "p_purenci", "p_purencc", "p_navenci", "p_nvenf", "p_cvenc", "p_cavenc", "p_nurencc", "p_navencc", "p_nvenec", "p_nrenec", "p_nurenci", "p_cavenec", "p_nvencs", "p_cvenf", "p_cavenf", "p_nvincc", "p_cavencs", "p_nvinec", "p_navenc"], "i": ["ji", "ii", "ui", "abi", "ti", "qi", "part", "iv", "full", "x", "I", "ix", "h", "lc", "p", "current", "phi", "block", "code", "di", "pointer", "ri", "load", "j", "info", "f", "ai", "ini", "oi", "ie", "start", "si", "io", "b", "v", "a", "pi", "uri", "index", "isin", "o", "ind", "e", "y", "l", "r", "adi", "xi", "u", "yi", "inner", "fi", "li", "d", "iu", "in", "count", "id", "m", "ci", "zi", "mi", "multi", "t", "slice", "gi", "g", "mu", "bi", "ip"], "nb_registered_frames": ["nb_registered_images", "nb_registered64frame", "nb_loaded_flows", "nb_loaded_Frames", "nb_registered_frame", "nb_registered_cycles", "nb_registered_objects", "nb_loaded_frames", "nb_loaded_cycles", "nb_registered64objects", "nb_registered_Frames", "nb_loaded_objects", "nb_loaded_devices", "nb_registeredjobjects", "nb_loaded_images", "nb_registered_flows", "nb_registered64frames", "nb_registeredjframe", "nb_registered64Frames", "nb_registered_devices", "nb_registeredjFrames", "nb_registeredjframes", "nb_loaded_frame"]}}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n", "idx": 24075, "substitutes": {"cpu": ["lb", "cfg", "chip", "coe", "gp", "CPU", "gc", "runner", "cache", "lc", "uci", "platform", "css", "uca", "core", "clock", "processor", "cli", "proc", "consumer", "gpu", "roc", "pc", "computer", "vm", "cow", "fc", "intel", "mac", "cb", "gru", "performance", "conn", "hw", "kernel", "auc", "boot", "cm", "tp", "cp", "pu", "phy", "uno", "ctx", "gb", "chu", "cmp", "nc", "ilo", "loader", "bench", "node"], "addr": ["adr", "ace", "x", "src", "p", "ea", "host", "arm", "code", "offset", "pointer", "ord", "address", "mode", "config", "ack", "device", "mac", "hop", "align", "index", "len", "amp", "ast", "nr", "e", "conn", "xp", "amd", "ref", "point", "layer", "target", "attr", "rc", "data", "ptr", "oa", "pad", "work", "slice", "add", "nc", "Address", "node", "ld"], "i": ["ti", "ui", "ii", "abi", "qi", "x", "I", "ix", "p", "eni", "phi", "di", "ri", "j", "f", "ai", "ini", "oi", "ni", "si", "io", "b", "v", "pi", "n", "index", "uri", "c", "o", "e", "l", "xi", "u", "yi", "fi", "li", "d", "iu", "k", "id", "m", "ci", "zi", "t", "multi", "gi", "z", "mu", "bi", "ip"]}}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n", "idx": 24084, "substitutes": {"bs": ["lb", "rs", "bb", "als", "bid", "bd", "bis", "ds", "banks", "bas", "fs", "bl", "b", "ts", "ss", "bin", "BS", "Bs", "ps", "sb", "bps", "bits", "bos", "bus", "cs", "bi", "blocks", "bes", "pb", "qs", "ops", "bc", "outs", "gs", "os", "fb", "vs", "ubs", "ns", "ls", "ba", "bytes"]}}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 24085, "substitutes": {"qov": ["qOV", " qoval", "sqova", "qtovi", "qtoval", "qovo", "woval", "sqoval", "sqov", "qtova", "koval", "wov", "ghOV", "sqovi", "ghoval", "qoval", "wOV", "kovo", "kOV", "kov", "qtov", "qova", "ghovo", " qovi", "ghov", "qovi", " qova", "wovo"], "value": ["element", "values", "image", "version", "w", "example", "package", "stack", "p", "queue", "block", "depth", "buffer", "name", "Value", "val", "type", "address", "length", "VALUE", "reference", "object", "none", "v", "content", "index", "parent", "entry", "message", "flow", "result", "key", "u", "function", "source", "size", "weight", "instance", "target", "data", "child", "expression", "id", "null", "array", "server", "number", "feature", "node", "comment"], "e": ["element", "x", "pe", "ev", "oe", "esi", "p", "en", "ea", "fe", "ge", "se", "el", "ed", "ce", "j", "f", "ie", "ep", "eg", "E", "v", "ae", "n", "ei", "c", "o", "entry", "l", "r", "entity", "u", "ee", "d", "ne", "ele", "eu", "i", "m", "er", "edge", "enter", "g", "eb", "node", "de", "ec"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n", "idx": 24087, "substitutes": {"x": ["php", "w", "xy", "ix", "xc", "X", "ex", "plus", "xb", "xs", "xxx", "rx", "xf", "v", "lex", "xx", "ux", "c", "xes", "y", "tx", "xp", "xi", "xa", "xt", "ctx", "px", "z"], "items": ["Items", "ins", "item", "values", "lines", "example", "izes", "classes", "events", "cycles", "xs", "pages", "xml", "rows", "members", "points", "bits", "keys", "pieces", "blocks", "groups", "times", "features", "eps", "ips", "ops", "ids", "objects", "orders", "ms", "properties", "bytes"], "size": ["z", "timeout", "capacity", "shape", "item", "empty", "izes", "ix", "code", "name", "loc", "j", "address", "length", "config", "s", "order", "si", "Size", "fee", "len", "n", "index", "scale", "SIZE", "c", "position", "o", "storage", "sum", "iz", "e", "page", "args", "ize", "grow", "value", "small", "weight", "member", "count", "sized", "unit", "i", "sign", "k", "speed", "large", "g", "sec"], "p": ["po", "pe", "jp", "j", "f", "q", "pc", "b", "v", "pp", "pi", "n", "per", "c", "ps", "lp", "o", "e", "y", "l", "P", "r", "fp", "pre", "py", "u", "point", "tp", "d", "np", "cp", "data", "i", "sp", "t", "ap", "g", "z", "ip"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090, "substitutes": {"vs": ["settings", "ii", "VS", "sts", "iv", "ks", "lines", "rs", "verts", "cv", "flags", "vert", "vers", "pps", "qv", "rev", "ds", "ses", "config", "s", "xs", "stats", "ov", "fs", "ss", "vm", "v", "vr", "state", "vol", "ys", "ps", "cs", "env", "ils", "vt", "vi", "va", "fps", "qs", "vp", "wp", "vis", "uns", "eps", "ops", "pos", "rc", "lv", "gs", "vc", "ctx", "alls", "bs", "vg", "ns", "ls", "spec", "ms", "sv", "obs", "Vs", "serv"], "x": ["image", "xy", "p", "row", "X", "ex", "f", "xs", "b", "v", "n", "index", "c", "o", "dx", "l", "col", "on", "d", "pos", "i", "m", "px", "z"], "y": ["xy", "p", "j", "f", "q", "b", "a", "n", "hot", "c", "o", "l", "r", "col", "ch", "d", "vy", "i", "yy", "m", "t", "Y", "z"], "w": ["p", "row", "f", "q", "max", "wa", "b", "win", "v", "n", "height", "wx", "fw", "c", "sw", "wh", "ew", "l", "r", "hw", "size", "d", "wt", "k", "i", "m", "ow", "level", "g", "W", "z"], "h": ["hd", "p", "ht", "th", "gh", "ih", "f", "q", "rh", "b", "v", "hh", "height", "n", "c", "o", "H", "l", "r", "hw", "ch", "ph", "u", "end", "d", "hi", "k", "i", "m", "t", "g", "z"], "palette": ["pallette", "reallette", "Palote", "Palipe", "realenge", "malignment", "palettes", "Pallette", "palote", " palote", "realipe", "plettes", "realettes", "plette", "palipe", "palenge", "plipe", "Palette", "palge", "realette", " palettes", "plignment", " palignment", " palenge", "malette", "realignment", "Palenge", "malote", "Palge", "Palettes", "mallette", "alge", "realge", "alettes", "alette", " pallette", " palge", "allette", "palignment", "Palignment"], "color_type": ["type_Type", "color__count", " color_var", " color_style", "color_types", "color32types", " color_ty", " color_unit", "colorvalunit", "channelftype", "typeentype", "typeenType", "color_value", "channel_type", "color_style", "colorenType", "colorftype", "channelftypes", "color_var", " color_value", "color_source", "channelfstr", "colorfstr", "colorentype", "color32ty", "channelfsource", "type_type", "channel_str", "colorvaltype", "colorvaltypes", "color_version", "colorPsource", "typeenrole", "colorPtype", "colorenrole", "colorvalvalue", "colorPtypes", " color_version", "channel_source", "color__types", "color32var", "colorPstr", "colorvalstyle", "color_count", " color_count", "colorvalversion", "type_role", "color_str", "color__type", " color_types", "color_Type", "color_role", "color__unit", "colorftypes", "color_ty", "color32type", "channel_types", "color_unit", "colorfsource", "colorvalcount"], "png_ptr": ["png67addr", "px_transfer", "pnglref", "img_desc", "img_pointer", "png_pt", "pngAMref", "png_Ptr", "png_fd", "px00push", "png00transfer", "img_tty", "png67desc", "wp_rot", "wp67ptr", "package67ptr", "img_proc", "np_pointers", "pngAMptr", "ng_ref", "img_Ptr", "np_ptr", "txt_Ptr", "png__pointer", "np_inst", "px_dr", "px00dr", "pnglpointers", "png_rt", "np_pointer", "png_desc", "png_addr", "wp67pointer", "png__ref", "txt_ptr", "img_ref", "package67addr", "png_proc", "png00tty", "wp_ptr", "wp67rot", "png67Ptr", "png67ptr", "png00dr", "png00push", "px_ptr", "png_dr", "png67rot", "png_tr", "png_pointers", "wp_pointer", "package_addr", "np_tr", "pngAMaddress", "png67pt", "png__ptr", "png67rt", "png00ptr", "png_inst", "png__desc", "png_rot", "wp_addr", "package_ptr", "ng_ptr", "px00ptr", "img_address", "ng_desc", "png00addr", "package_pt", "img_addr", "img_tr", "png_push", "pnglinst", "png_tty", "png00desc", "np_ref", "png_pointer", "package67pt", "png67pointer", "wp67addr", "txt_rt", "pnglptr", "px00transfer", "txt_pointer", "pngAMproc", "png67tty", "png_ref", "ng_pointer", "png_transfer", "px_push", "img_ptr", "np_fd", "png_address"], "info_ptr": ["info___pointer", "fo_ptr", " info_type", " info_pert", "infoPaddr", "infoPtype", "info___struct", "info_addr", "info_type", "fo_struct", "fo_addr", "info___ptr", "info_pert", "fo_pointer", "info_pointers", "info_dr", "info_struct", "fo_pointers", "infoPptr", "fo_buf", "infoPpointer", "info_pointer", " info_pointer", "info___buf", " info_dr", " info_addr", "info_buf"], "linebuf": ["Linearray", "Linebag", "Linebuf", "linearray", "inlinebuf", "slicebag", "linecache", "slicearray", "inlinecache", "slicebuf", "inlinearray", "inlinebag", "Linecache", "linebag", "slicecache"], "buf": ["Buffer", "cap", "box", "cv", "src", "uf", "alloc", "stack", "queue", "buff", "buffer", "val", "func", "cmd", "len", "seq", "cb", "tmp", "fd", "window", "conv", "ff", "rc", "ptr", "ctx", "pkg", "rb", "pool"], "dy": ["def", " row", " dd", " def", " dim", "sync", " dir", " dev", " disp", "di", "db", "ds", "dim", "ding", " d", "D", "dir", "dev", "dx", "dd", "d", " height", " delta", " dup", " rows", "ded"], "priv": ["auth", "neg", "req", "gr", "resp", "lit", "access", "ra", " privilege", "color", "buff", "proc", "info", "public", "ocr", "uc", "cert", " Priv", "pi", "cer", "pro", "wh", "err", "dev", "prof", "tx", "vt", "pri", "ch", "rib", "pb", "private", "fac", "trust", "riv", "white", "str", "fi", "li", "mini", "impl", "cp", "rc", "rw", "ci", "Priv", "pub", "sec", "rec"]}}
